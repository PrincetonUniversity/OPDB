/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/********************************************************************
 * Author: Sam Payne
 * 
 * Module encapsulates an asynchronus FIFO used for bridging signals
 * across clock domains, parameters allow for different sized modules
 * compatible with wide range of frequencies.
 *
 * * *******************************************************************/



module async_fifo 
#(
	parameter DSIZE = 64,
	parameter ASIZE = 5,
	parameter MEMSIZE = 16 // should be 2 ^ (ASIZE-1)
)
(
	rdata, 
	rempty,
	rclk,
	ren,
	wdata,
	wfull,
	wclk,
	wval,
	wreset,
	rreset
	);

//Inputs and Outputs
output  [DSIZE-1:0] 	rdata;
output			rempty;
output 			wfull;
input	[DSIZE-1:0]	wdata;
input			wval;
input			ren;
input			rclk;
input			wclk;
input 			wreset;
input			rreset;

//Internal Registers
reg	[ASIZE-1:0]	g_wptr;
reg	[ASIZE-1:0]	g_rptr;

reg	[ASIZE-1:0]	g_rsync1, g_rsync2;
reg	[ASIZE-1:0]	g_wsync1, g_wsync2;

//Memory
reg	[DSIZE-1:0] 	fifo[MEMSIZE-1:0];

wire [ASIZE-1:0] b_wptr;
wire [ASIZE-1:0] b_wptr_next;
wire [ASIZE-1:0] g_wptr_next;
wire [ASIZE-1:0] b_rptr;
wire [ASIZE-1:0] b_rptr_next;
wire [ASIZE-1:0] g_rptr_next;

/********************************************************************
COMBINATIONAL LOGIC
********************************************************************/

//convert gray to binary
assign b_wptr[ASIZE-1:0] = ({1'b0, b_wptr[ASIZE-1:1]} ^ g_wptr[ASIZE-1:0]);
assign b_rptr[ASIZE-1:0] = ({1'b0, b_rptr[ASIZE-1:1]} ^ g_rptr[ASIZE-1:0]);

//increment
assign b_wptr_next = b_wptr + 1;
assign b_rptr_next = b_rptr + 1;

//convert binary to gray
assign g_wptr_next[ASIZE-1:0] = {1'b0, b_wptr_next[ASIZE-1:1]} ^ b_wptr_next[ASIZE-1:0];
assign g_rptr_next[ASIZE-1:0] = {1'b0, b_rptr_next[ASIZE-1:1]} ^ b_rptr_next[ASIZE-1:0];

//full and empty signals
assign wfull =  (g_wptr[ASIZE-1]   != g_rsync2[ASIZE-1]  ) && 
		(g_wptr[ASIZE-2]   != g_rsync2[ASIZE-2]  ) &&
		(g_wptr[ASIZE-3:0] == g_rsync2[ASIZE-3:0]) ||
		(wreset || rreset);

assign rempty =  (g_wsync2[ASIZE-1:0] == g_rptr[ASIZE-1:0]) ||
	         (wreset || rreset);

//output values
assign rdata = fifo[b_rptr[ASIZE-2:0]];

/********************************************************************
SEQUENTIAL LOGIC
********************************************************************/

//transfer register values
always @(posedge rclk) begin
	if (rreset) begin
		g_rptr <= 0;
	end
	else if (ren && !rempty) begin
		g_rptr <= g_rptr_next;
	end

	g_wsync1 <= g_wptr;
	g_wsync2 <= g_wsync1;
end

always @(posedge wclk) begin
	if (wreset) begin
		g_wptr <= 0;
	end
	else if (wval && !wfull) begin
		fifo[b_wptr[ASIZE-2:0]] <= wdata;
		g_wptr <= g_wptr_next;
	end

	g_rsync1 <= g_rptr;
	g_rsync2 <= g_rsync1;

	
end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs, modified to be synthesizable

module bram_1r1w_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
  input wire MEMCLK,
  input wire RESET_N,
  input wire CEA,
  input wire [ADDR_WIDTH-1:0] AA,
  input wire [ADDR_WIDTH-1:0] AB,

  input wire RDWENA,
  input wire CEB,
  input wire RDWENB,
  input wire [DATA_WIDTH-1:0] BWA,
  input wire [DATA_WIDTH-1:0] DINA,
  output reg [DATA_WIDTH-1:0] DOUTA,
  input wire [DATA_WIDTH-1:0] BWB,
  input wire [DATA_WIDTH-1:0] DINB,
  output wire [DATA_WIDTH-1:0] DOUTB
  // input wire [`BIST_OP_WIDTH-1:0] BIST_COMMAND,
  // input wire [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DIN,
  // output reg [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DOUT,
  // input wire [`BIST_ID_WIDTH-1:0] SRAMID
);

wire                            write_enable_in;
wire                            read_enable_in;

// Temporary storage for write data
reg                             write_enable_in_reg;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg   [BITMASK_WIDTH-1:0 ]      WRITE_BIT_MASK_REG;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
// reg   [DATA_WIDTH-1:0    ]      DOUTB_r;

reg                             read_enable_in_reg;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_write_en;
reg                            bram_write_en_muxed;
wire                            bram_read_en;
wire                            bram_write_read_en;
reg  [DATA_WIDTH-1:0    ]      bram_data_write_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_in;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;
wire  [DATA_WIDTH-1:0    ]      last_wrote_data;
wire                            rw_conflict;
reg                             rw_conflict_r;
wire                            ww_conflict;
reg                             ww_conflict_r;

/* renaming signals */
assign read_enable_in    = CEA & (RDWENA == 1'b1);
assign write_enable_in   = CEB & (RDWENB == 1'b0);
wire [ADDR_WIDTH-1:0    ] READ_ADDRESS = AA;
wire [ADDR_WIDTH-1:0    ] WRITE_ADDRESS = AB;
wire [BITMASK_WIDTH-1:0    ] WRITE_BIT_MASK = BWB;

// Intermediate logic for write processing
always @(posedge MEMCLK) begin
  write_enable_in_reg <= write_enable_in;
  WRITE_ADDRESS_REG   <= WRITE_ADDRESS;
  WRITE_BIT_MASK_REG  <= WRITE_BIT_MASK;
  DIN_r <= DINB;
  read_enable_in_reg  <= read_enable_in;
  bram_data_in_r <= bram_data_in;
  rw_conflict_r  <= rw_conflict;
  ww_conflict_r  <= ww_conflict;
  // DOUTB_r  <= DOUTB;
end

// determining read-write and write-write conflict for data bypassing
assign rw_conflict      = write_enable_in_reg & read_enable_in & (WRITE_ADDRESS_REG == READ_ADDRESS);
assign ww_conflict      = write_enable_in_reg & write_enable_in & (WRITE_ADDRESS_REG == WRITE_ADDRESS);
assign DOUTB = {DATA_WIDTH{1'bx}}; // port B is always used for write

// calculate the correct read and write data after accoutning for conflicts
always @ * begin
  bram_data_in = (DIN_r & WRITE_BIT_MASK_REG);
  if (ww_conflict_r)
    bram_data_in = bram_data_in | (bram_data_in_r & ~WRITE_BIT_MASK_REG);
  else
    bram_data_in = bram_data_in | (bram_data_write_read_out_reg & ~WRITE_BIT_MASK_REG);
  

  // note: DOUT retains value if read enable is not asserted
  // which is why default value is not set for DOUT
  if (read_enable_in_reg) begin
    DOUTA = bram_data_read_out_reg; 
    if (rw_conflict_r) begin
      DOUTA = bram_data_in_r;
    end
  end
end

// synthesizable BRAM
assign bram_write_en      = write_enable_in_reg;
assign bram_read_en         = (read_enable_in) & ~rw_conflict;             // do not read in case of a conflict
assign bram_write_read_en         = (write_enable_in) & ~ww_conflict;             // do not read in case of a conflict

reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_write_read_out_reg;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
    ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_read_en) begin
    bram_data_read_out_reg <= ram[READ_ADDRESS];
  end
  if (bram_write_read_en) begin
    bram_data_write_read_out_reg <= ram[WRITE_ADDRESS];
  end
end
// END BRAM


/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = WRITE_ADDRESS_REG;
      bram_write_en_muxed = bram_write_en;
      bram_data_in_muxed = bram_data_in;
   end
end


endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs

module bram_1rw_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
    input                         MEMCLK,
    input wire RESET_N,
    input                         CE,
    input   [ADDR_WIDTH-1:0]      A,
    input                         RDWEN,
    input   [BITMASK_WIDTH-1:0]   BW,
    input   [DATA_WIDTH-1:0]      DIN,
    output  [DATA_WIDTH-1:0]      DOUT
);

wire                            write_en;
wire                            read_en;

// Temporary storage for write data
reg                             wen_r;
reg   [ADDR_WIDTH-1:0    ]      A_r;
reg   [BITMASK_WIDTH-1:0 ]      BW_r;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
reg   [DATA_WIDTH-1:0    ]      DOUT_r;

reg                             ren_r;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_wen;
wire                            bram_ren;
reg  [DATA_WIDTH-1:0    ]      bram_data_out;
wire  [DATA_WIDTH-1:0    ]      bram_data_in;
wire  [DATA_WIDTH-1:0    ]      up_to_date_data;
wire                            rw_conflict;
reg                             rw_conflict_r;



reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg                            bram_write_en_muxed;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;

assign write_en   = CE & (RDWEN == 1'b0);
assign read_en    = CE & (RDWEN == 1'b1);


// Intermediate logic for write processing
always @(posedge MEMCLK) begin
   wen_r <= write_en;
   A_r   <= A;
   BW_r  <= BW;
   DIN_r <= DIN;
end

always @(posedge MEMCLK) begin
  ren_r  <= read_en;
end

always @(posedge MEMCLK)
   bram_data_in_r <= bram_data_in;

always @(posedge MEMCLK)
   rw_conflict_r  <= rw_conflict;

always @(posedge MEMCLK)
  DOUT_r  <= DOUT;

assign bram_data_in = (up_to_date_data & ~BW_r) | (DIN_r & BW_r);

// processing of read in case if it just in the next cycle after read to the same address
assign rw_conflict      = wen_r & CE & (A_r == A);                         // read or write to the same address
assign up_to_date_data  = rw_conflict_r ? bram_data_in_r : bram_data_out;  // delay of mem is 1 cycle
assign bram_ren         = (read_en | write_en) & ~rw_conflict;             // do not read in case of a conflict
                                                                        // to make behaviour of a memory robust
assign bram_wen      = wen_r;

assign DOUT          = ren_r ? up_to_date_data : DOUT_r;

// BRAM
reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_out;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
      ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_ren) begin
    bram_data_out <= ram[A];
  end
end
// END BRAM

 // undefined by default

/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = A_r;
      bram_write_en_muxed = bram_wen;
      bram_data_in_muxed = bram_data_in;
   end
end













endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : synchronizer.v
//  Created On    : 2014-01-31 12:52:57
//  Last Modified : 2018-11-29 17:02:47
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   :
//==================================================================================================





module synchronizer (
    clk,
    presyncdata,
    syncdata
    );

// synopsys template
parameter SIZE = 1;

input wire clk;
input wire [SIZE-1:0] presyncdata;
output reg [SIZE-1:0] syncdata;













  reg [SIZE-1:0] presyncdata_tmp;



    // bw_u1_syncff_4x u_synchronizer_syncff [SIZE-1:0](.q(presyncdata_tmp),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

    // bw_u1_soff_2x u_synchronizer_ff[SIZE-1:0] (.q(syncdata),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata_tmp),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

always @ (posedge clk)
begin
    presyncdata_tmp <= presyncdata;
    syncdata        <= presyncdata_tmp;
end

endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : clk_gating_latch.v
//  Created On    : 2015-01-26 14:10:43
//  Last Modified : 2019-04-17 11:56:55
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   : Latch for glitchless clock gating
//==================================================================================================

module clk_gating_latch (
    input wire clk,
    input wire clk_en,
    output wire clk_out
);

// use clock buffer on FPGA
// note that not all FPGAs have enough of these available
// so we use the latch as a fallback on certain boards (e.g., vc707)




 // PITON_FPGA_SYNTH

  wire clk_en_sync;
  reg clk_en_sync_latch;

  assign clk_out = clk & clk_en_sync_latch;

  synchronizer sync(
      .clk            (clk),
      .presyncdata    (clk_en),
      .syncdata       (clk_en_sync)
  );

  // if possible, replace this with a native clock gate from the std cell lib
  // clk_en_sync_latch changes only on the negative duty of the cycle
  always @ (clk or clk_en_sync)
      if (~clk) clk_en_sync_latch = clk_en_sync;



endmodule // clk_gating_latch
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/****************************************************************************
 *
 *   FILE: credit_to_valrdy.v
 *
 *   Modified: Yaosheng Fu
 *   Date: May 2 2014

 ***************************************************************************/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

module credit_to_valrdy (
   clk,
   reset,
   //credit based interface	
   data_in,
   valid_in,
   yummy_in,
            
   //val/rdy interface
   data_out,
   valid_out,
   ready_out
);

   input	 clk;
   input	 reset;
   input [64-1:0]	 data_in;
   input	 valid_in;
   input     ready_out;
    
   output	 yummy_in;
   output	 valid_out;
   output [64-1:0] data_out;
   
   wire	 thanksIn;

   wire valid_out_temp;

   assign valid_out = valid_out_temp;

   network_input_blk_multi_out #(.LOG2_NUMBER_FIFO_ELEMENTS(2)) data(
      .clk(clk),
      .reset(reset),
      .data_in(data_in),
      .valid_in(valid_in),

      .thanks_in(valid_out & ready_out),

      .yummy_out(yummy_in),
      .data_val(data_out),
      .data_val1(/*not used*/),
      .data_avail(valid_out_temp));

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: m1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
// 64 bit nor gate with first 32 bits out

module zznor64_32 ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32



////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate

module zzor36 ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
	     | a[32] | a[33] | a[34] | a[35]); 
   
endmodule // zzor36



////////////////////////////////////////////////////////////////////////////////
// 32 bit or gate

module zzor32 ( z, a );
  input  [31:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

endmodule // zzor32



////////////////////////////////////////////////////////////////////////////////
// 24 bit nor gate

module zznor24 ( z, a );
  input  [23:0] a;
  output        z;

  assign z =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	      | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]); 

endmodule // zznor24



////////////////////////////////////////////////////////////////////////////////
// 16 bit nor gate

module zznor16 ( z, a );
  input  [15:0] a;
  output        z;

  assign z =  ~(a[0] | a[1] | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]); 

endmodule // zznor16



////////////////////////////////////////////////////////////////////////////////
// 8 bit or gate

module zzor8 ( z, a );
  input  [7:0] a;
  output       z;

  assign z =  (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7]); 
   
endmodule // zzor8




////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd13 ( rs1_data, rs2_data, cin, adder_out );

  input  [12:0] rs1_data;   // 1st input operand
  input  [12:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [12:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd13



////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd56 ( rs1_data, rs2_data, cin, adder_out );

  input  [55:0] rs1_data;   // 1st input operand
  input  [55:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [55:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd56



////////////////////////////////////////////////////////////////////////////////

module zzadd48 ( rs1_data, rs2_data, cin, adder_out );

  input  [47:0] rs1_data;   // 1st input operand
  input  [47:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [47:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd48



////////////////////////////////////////////////////////////////////////////////
//  This adder is primarily used in the multiplier.
//  The cin to out path is optimized.

module zzadd34c ( rs1_data, rs2_data, cin, adder_out );

  input  [33:0] rs1_data;
  input  [33:0] rs2_data;
  input         cin;

  output [33:0] adder_out;

  assign adder_out = rs1_data + rs2_data + cin;


endmodule // zzadd34c



////////////////////////////////////////////////////////////////////////////////

module zzadd32 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [31:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd32



////////////////////////////////////////////////////////////////////////////////

module zzadd18 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [17:0] rs1_data;   // 1st input operand
  input  [17:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [17:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd18



////////////////////////////////////////////////////////////////////////////////

module zzadd8 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [7:0] rs1_data;   // 1st input operand
  input  [7:0] rs2_data;   // 2nd input operand
  input        cin;        // carry in

  output [7:0] adder_out;  // result of add & decrement
  output       cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd8



////////////////////////////////////////////////////////////////////////////////
// Special 4-operand 32b adder used in spu_shamd5
//  Description:        This block implements the 4-operand 32-bit adder for SPU
//			It takes four 32-bit operands. It add them together and
//			output the 32-bit results to adder_out. The overflow of
//			32th bit and higher will be ignored.

module zzadd32op4 ( rs1_data, rs2_data, rs3_data, rs4_data, adder_out );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input  [31:0] rs3_data;   // 3rd input operand
  input  [31:0] rs4_data;   // 4th input operand

  output [31:0] adder_out;  // result of add

  assign adder_out = rs1_data + rs2_data + rs3_data + rs4_data;

endmodule // zzadd32op4


////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc alu.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out.  It outputs the overflow
//			and carry condition codes for both 64 bit and 32 bit operations.

module zzadd64 ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64



///////////////////////////////////////////////////////////////////////
/*
//      Description: This is the ffu VIS adder.  It can do either
//                              2 16 bit adds or 1 32 bit add.
*/

module zzadd32v (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
   a, b, cin, add32
   ) ;
   input [31:0] a;
   input [31:0] b;
   input        cin;
   input        add32;

   output [31:0] z;

   wire          cout15; // carry out from lower 16 bit add
   wire          cin16; // carry in to the upper 16 bit add
   wire          cout31; // carry out from the upper 16 bit add

   assign        cin16 = (add32)? cout15: cin;

   assign      {cout15, z[15:0]} = a[15:0]+b[15:0]+ cin;
   assign      {cout31, z[31:16]} = a[31:16]+b[31:16]+ cin16;

endmodule // zzadd32v




////////////////////////////////////////////////////////////////////////////////
// 64-bit incrementer

module zzinc64 ( in, out );

  input  [63:0] in;

  output [63:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc64


////////////////////////////////////////////////////////////////////////////////
// 48-bit incrementer

module zzinc48 ( in, out, overflow );

  input  [47:0] in;

  output [47:0] out;      // result of increment
  output        overflow; // overflow

  assign out      = in + 1'b1;
  assign overflow = ~in[47] & out[47];

endmodule // zzinc48


////////////////////////////////////////////////////////////////////////////////
// 32-bit incrementer

module zzinc32 ( in, out );

  input  [31:0] in;

  output [31:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc32


////////////////////////////////////////////////////////////////////////////////

module zzecc_exu_chkecc2 ( q,ce, ue, ne, d, p, vld );
   input [63:0] d;
   input [7:0]  p;
   input        vld;
   output [6:0] q;
   output       ce,
                ue,
                ne;

   wire       parity;

   assign     ce = vld & parity;

   assign ue = vld & ~parity & (q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);

   assign ne = ~vld | ~(parity | q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);


   assign q[0] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10]
               ^ d[11] ^ d[13] ^ d[15] ^ d[17] ^ d[19] ^ d[21] ^ d[23]
               ^ d[25] ^ d[26] ^ d[28] ^ d[30] ^ d[32] ^ d[34] ^ d[36]
               ^ d[38] ^ d[40] ^ d[42] ^ d[44] ^ d[46] ^ d[48] ^ d[50]
               ^ d[52] ^ d[54] ^ d[56] ^ d[57] ^ d[59] ^ d[61] ^ d[63]
               ^ p[0]  ;

   assign q[1] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[10]
               ^ d[12] ^ d[13] ^ d[16] ^ d[17] ^ d[20] ^ d[21] ^ d[24]
               ^ d[25] ^ d[27] ^ d[28] ^ d[31] ^ d[32] ^ d[35] ^ d[36]
               ^ d[39] ^ d[40] ^ d[43] ^ d[44] ^ d[47] ^ d[48] ^ d[51]
               ^ d[52] ^ d[55] ^ d[56] ^ d[58] ^ d[59] ^ d[62] ^ d[63]
               ^ p[1]  ;

   assign q[2] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[29] ^ d[30] ^ d[31] ^ d[32] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[45] ^ d[46] ^ d[47] ^ d[48] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
               ^ p[2]  ;

   assign q[3] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[3]  ;

   assign q[4] = d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[4]  ;

   assign q[5] = d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31] ^ d[32]
               ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
               ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[5]  ;

   assign q[6] = d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63] ^ p[6] ;

   assign parity = d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
                 ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
                 ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
                 ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
                 ^ d[32] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
                 ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46] ^ d[47]
                 ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53] ^ d[54] ^ d[55]
                 ^ d[56] ^ d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
                 ^ p[0]  ^ p[1]  ^ p[2]  ^ p[3]  ^ p[4]  ^ p[5]  ^ p[6]  ^ p[7];

endmodule // zzecc_exu_chkecc2



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_24b_gen ( din, dout, parity ) ;

// Input Ports
input  [23:0] din ;

// Output Ports
output [23:0] dout ;
output [5:0]  parity ;

wire   [23:0] dout ;
wire   [5:0]  parity ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire          p30 ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |  |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |  |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |  |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |  |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |  |  |* |  |* |* |  |  |* |* |  |* |  |  | * |   | * | * |   | * |   |   | * | * |   |   | * |   | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p30 = din[0]  ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5]  ^
             din[7]  ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^
             din[17] ^ din[18] ^ din[21] ^ din[23] ;

assign dout   = din ;
assign parity = {p30, p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_30b_cor ( din, parity, dout, corrected_bit ) ;

// Input Ports
input  [23:0] din ;
input  [4:0]  parity ;

// Output Ports
output [23:0] dout ;
output [4:0]  corrected_bit ;

wire   [23:0] dout ;
wire   [4:0]  corrected_bit ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire [23:0]   error_bit ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |* |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |* |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |* |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |* |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   | * | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |* |* |* |* |* |* |* |* |* |* |* |* |* |* | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = parity[0] ^
             din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = parity[1] ^
             din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = parity[2] ^
             din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = parity[3] ^
             din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = parity[4] ^
             din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign  error_bit[0]  = !p16 & !p8 & !p4 &  p2 &  p1 ; // 3
assign  error_bit[1]  = !p16 & !p8 &  p4 & !p2 &  p1 ; // 5
assign  error_bit[2]  = !p16 & !p8 &  p4 &  p2 & !p1 ; // 6
assign  error_bit[3]  = !p16 & !p8 &  p4 &  p2 &  p1 ; // 7
assign  error_bit[4]  = !p16 &  p8 & !p4 & !p2 &  p1 ; // 9
assign  error_bit[5]  = !p16 &  p8 & !p4 &  p2 & !p1 ; // 10
assign  error_bit[6]  = !p16 &  p8 & !p4 &  p2 &  p1 ; // 11
assign  error_bit[7]  = !p16 &  p8 &  p4 & !p2 & !p1 ; // 12
assign  error_bit[8]  = !p16 &  p8 &  p4 & !p2 &  p1 ; // 13
assign  error_bit[9]  = !p16 &  p8 &  p4 &  p2 & !p1 ; // 14
assign  error_bit[10] = !p16 &  p8 &  p4 &  p2 &  p1 ; // 15
assign  error_bit[11] =  p16 & !p8 & !p4 & !p2 &  p1 ; // 17
assign  error_bit[12] =  p16 & !p8 & !p4 &  p2 & !p1 ; // 18
assign  error_bit[13] =  p16 & !p8 & !p4 &  p2 &  p1 ; // 19
assign  error_bit[14] =  p16 & !p8 &  p4 & !p2 & !p1 ; // 20
assign  error_bit[15] =  p16 & !p8 &  p4 & !p2 &  p1 ; // 21
assign  error_bit[16] =  p16 & !p8 &  p4 &  p2 & !p1 ; // 22
assign  error_bit[17] =  p16 & !p8 &  p4 &  p2 &  p1 ; // 23
assign  error_bit[18] =  p16 &  p8 & !p4 & !p2 & !p1 ; // 24
assign  error_bit[19] =  p16 &  p8 & !p4 & !p2 &  p1 ; // 25
assign  error_bit[20] =  p16 &  p8 & !p4 &  p2 & !p1 ; // 26
assign  error_bit[21] =  p16 &  p8 & !p4 &  p2 &  p1 ; // 27
assign  error_bit[22] =  p16 &  p8 &  p4 & !p2 & !p1 ; // 28
assign  error_bit[23] =  p16 &  p8 &  p4 & !p2 &  p1 ; // 29

assign  dout          = din ^ error_bit ;
assign  corrected_bit = {p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_ecc39
//Function: Error Detection and Correction
//
//

module zzecc_sctag_ecc39 ( dout, cflag, pflag, parity, din);

   //Output: 32bit corrected data
   output[31:0] dout;
   output [5:0] cflag;
   output 	pflag;
   
   //Input: 32bit data din
   input [31:0] din;
   input [6:0]	parity;

   wire 	c0,c1,c2,c3,c4,c5;
   wire [31:0] 	err_bit_pos;

   //refer to the comments in parity_gen_32b.v for the position description
   
   assign c0= parity[0]^(din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   
   assign c1= parity[1]^(din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   
   assign c2= parity[2]^(din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   
   assign c3= parity[3]^(din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   
   assign c4= parity[4]^(din[11]^din[12])^(din[13]^din[14])^
                    (din[15]^din[16])^(din[17]^din[18])^(din[19]^din[20])^
                    (din[21]^din[22])^(din[23]^din[24])^din[25];

   assign c5= parity[5]^(din[26]^din[27])^(din[28]^din[29])^
		    (din[30]^din[31]);

   //generate total parity flag
   assign pflag= c0 ^
		(( (((parity[1]^parity[2])^(parity[3]^parity[4])) ^
		 ((parity[5]^parity[6])^(din[2]^din[5]))) ^		 
		 (((din[7]^din[9])^(din[12]^din[14])) ^
		 ((din[16]^din[18])^(din[20]^din[22]))) ) ^
		 ((din[24]^din[27])^(din[29]^din[31])) );
   
   assign cflag= {c5,c4,c3,c2,c1,c0};
   
   //6 to 32 decoder
   assign err_bit_pos[0] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[1] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[2] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[3] = (c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[4] = (c0)&(~c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[5] = (~c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[6] = (c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[7] = (~c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[8] = (c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[9] = (~c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[10] = (c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[11] = (c0)&(~c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[12] = (~c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[13] = (c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[14] = (~c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[15] = (c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[16] = (~c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[17] = (c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[18] = (~c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[19] = (c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[20] = (~c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[21] = (c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[22] = (~c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[23] = (c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[24] = (~c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[25] = (c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[26] = (c0)&(~c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[27] = (~c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[28] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[29] = (~c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[30] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[31] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(c5);

   //correct the error bit, it can only correct one error bit.
   
   assign dout = din ^ err_bit_pos;

endmodule // zzecc_sctag_ecc39


////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_pgen_32b
//Function: Generate 7 parity bits for 32bits input data
//

module zzecc_sctag_pgen_32b ( dout, parity, din);

   //Output: 32bit dout and 7bit parity bit
   output[31:0] dout;
   output [6:0] parity;

   //Input: 32bit data din
   input [31:0] din;

   //input data passing through this module
   assign dout = din ;

   //generate parity bits based on the hamming codes
   //the method to generate parity bit is shown as follows
   //1   2  3  4  5  6  7  8  9 10 11 12 13 14  15  16  17  18  19
   //P1 P2 d0 P4 d1 d2 d3 P8 d4 d5 d6 d7 d8 d9 d10 P16 d11 d12 d13 
   //
   // 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 
   //d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 P32 d26 d27 d28
   //
   // 36  37  38       
   //d29 d30 d31
   //For binary numbers B1-B2-B3-B4-B5-B6:
   //B1=1 for (1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,...)
   //B2=1 for (2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39...)
   //B3=1 for (4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,39....)
   //B4=1 for (8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,....)
   //B5=1 for (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,...)
   //B6=1 for (32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49...)
   //Parity bit P1,P2,P4,P8,P16,P32 can be generated from the above group of
   //bits B1=1,B2=1,B3=1,B4=1,B5=1,B6=1 respectively.

   //use parity[5:0] to stand for P1,P2,P4,P8,P16,P32
   assign parity[0] = (din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   //
   assign parity[1] = (din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   //
   assign parity[2] = (din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   //
   assign parity[3] = (din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[4] = (din[11]^din[12])^(din[13]^din[14])^(din[15]^din[16])
                     ^(din[17]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[5] = (din[26]^din[27])^(din[28]^din[29])^(din[30]^din[31]);

   //the last parity bit is the xor of all 38bits
   //assign parity[6] = (^din)^(^parity[5:0]);
   //it can be further simplified as:
   //din= d0  d1  d2  d3  d4  d5  d6  d7  d8  d9 d10 d11 d12 d13 d14 d15 
   //p0 =  x   x       x   x       x       x       x   x       x       x
   //p1 =  x       x   x       x   x           x   x       x   x
   //p2 =      x   x   x               x   x   x   x               x   x
   //p3 =                  x   x   x   x   x   x   x  
   //p4 =                                              x   x   x   x   x
   //p5 =
   //-------------------------------------------------------------------
   //Total 3   3   3   4   3   3   4   3   4   4   5   3   3   4   3   4 
   //
   //din=d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 
   //p0=       x       x       x       x       x   x       x       x    
   //p1=   x   x           x   x           x   x       x   x           x
   //p2=   x   x                   x   x   x   x               x   x   x
   //p3=           x   x   x   x   x   x   x   x
   //p4=   x   x   x   x   x   x   x   x   x   x
   //p5=                                           x   x   x   x   x   x
   //-------------------------------------------------------------------
   //total 4   5   3   4   4   5   4   5   5   6   3   3   4   3   4   4

   //so total=even number, the corresponding bit will not show up in the
   //final xor tree.
   assign parity[6] =  din[0] ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5] ^ din[7]
		    ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^ din[17]
		    ^ din[18] ^ din[21] ^ din[23] ^ din[24] ^ din[26]
		    ^ din[27] ^ din[29];
   
endmodule // zzecc_sctag_pgen_32b

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree

module zzpar34 ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
	      ^ d[32] ^ d[33]; 

endmodule // zzpar34



////////////////////////////////////////////////////////////////////////////////
// 32 bit parity tree

module zzpar32 ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]; 

endmodule // zzpar32



////////////////////////////////////////////////////////////////////////////////
// 28 bit parity tree

module zzpar28 ( z, d );
   input  [27:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27]; 

endmodule // zzpar28



////////////////////////////////////////////////////////////////////////////////
// 16 bit parity tree

module zzpar16 ( z, d );
   input  [15:0] d;
   output        z;

   assign z = d[0] ^ d[1] ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	    ^ d[8] ^ d[9] ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]; 
   
endmodule // zzpar16



////////////////////////////////////////////////////////////////////////////////
// 8 bit parity tree

module zzpar8 ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8



////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority

module zzpenc64 (/*AUTOARG*/
   // Outputs
   z, 
   // Inputs
  a 
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64

////////////////////////////////////////////////////////////////////////////////
//    4-bit 60x buffers

module zzbufh_60x4 (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [3:0] a;
   output [3:0] z;

   assign z = a;

endmodule //zzbufh_60x4

// LVT modules added below

module zzadd64_lv ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64_lv

module zzpar8_lv ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8_lv


module zzpar32_lv ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31];

endmodule // zzpar32_lv



module zznor64_32_lv ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32_lv

////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority
//    LVT version

module zzpenc64_lv (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64_lv

////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate
// LVT version

module zzor36_lv ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
             | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
             | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
             | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
             | a[32] | a[33] | a[34] | a[35]);

endmodule // zzor36_lv

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree
// LVT version

module zzpar34_lv ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
              ^ d[32] ^ d[33];

endmodule // zzpar34_lv


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: mul64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/*//////////////////////////////////////////////////////////////////////
//
//  Module Name: mul64
//  Description:        *This block implements the multiplier used in the modular multiplier
//                       unit (MUL) and be shared by sparc EXU and the streaming unit (SPU).
//                       It is also used as the 54x54 multiplier in the FPU.
//                      *It takes two 64-bit unsign data and accumulated operand and do the
//                       64x64 MAC operation at two cycle thruput and 5 cycle latency.
//                      *The mul_valid signal indicate the beginning of a new operation.
//                       It MUST be dis-asserted at the next cycle to have the proper 2-cycle
//                       latency operation in the csa array. If there are two back-to-back
//                       cycle operation, the first operation result will be incorrect.
//                      *Results are avaliable on the 5th cycle of the mul_valid as shows
//
//			*Following inputs should tie to "0" when used as a 64x64 multiplier
//			 - areg 
//			 - accreg 
//			 - x2
//
//                         Cycle-0  | Cycle-1 | Cycle-2 | Cycle-3 | Cycle-4 | Cycle-5
//                       1st        *         |         |         |         |
//                       rs1, rs2   ^         |         |         |         | 1st results
//                       valid=1    | valid=0 |         *         |         | avaliable
//                                1st         | 2nd OP  ^         |         |
//                                setup       | valid=1 |         |         |
//                                            |        2nd        |         |
//                                            |       setup       |         |
//
*/

//PITON_PROTO enables all FPGA related modifications



























































module mul64 (rs1_l, rs2, valid, areg, accreg, x2, out, rclk, si, so, se, mul_rst_l, mul_step);

input  [63:0]  	rs1_l;			// op1
input  [63:0]  	rs2;			// op2
input	       	valid;			// begin of the MUL operation
input  [96:0]  	areg;			// accumulated input for ACCUM
input  [135:129] accreg;		// direct input from ACCUM [135:129]
input	       	x2;			// for op1*op2*2
input	       	rclk, si, se, mul_rst_l, mul_step;
output  	so;
output [135:0] 	out;

wire	       	cyc1, cyc2, cyc3;	// cycle stage of MUL
wire [2:0]	b0, b1, b2,  b3,  b4,  b5,  b6,  b7;
wire [2:0]	b8, b9, b10, b11, b12, b13, b14, b15;
wire	    	b16;
wire [63:0]	op1_l, op1;
wire [81:0]	a0sum, a1sum, a0s, a1s; 
wire [81:4]	a0cout, a1cout, a0c, a1c;
wire		pcoutx2, psumx2;
wire 		x2_c1, x2_c2, x2_c3, x2_c2c3;

wire [98:0]	psum, pcout;
wire [98:30]	pcout_in, pc;
wire [98:31]	psum_in, ps;
wire [96:0]	ary2_cout, addin_cout;
wire [97:0]	ary2_sum,  addin_sum ;
wire		add_cin, addin_cin, add_co31, add_co96;
wire [103:0]	addout;
wire		clk_enb0, clk_enb1;
wire 		rst;
wire		clk;
wire		tm_l;

  assign clk = rclk;
  assign rst = ~mul_rst_l; 
  assign tm_l = ~se;

  clken_buf	ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));

  /////////////////////////////////////////////////////////////////////
  // 	States count
  /////////////////////////////////////////////////////////////////////
  dffr_s  cyc1_dff(.din(valid), .clk(clk_enb0), .q(cyc1), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc2_dff(.din(cyc1),  .clk(clk_enb0), .q(cyc2), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc3_dff(.din(cyc2),  .clk(clk_enb0), .q(cyc3), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c1_dff(.din(x2),    .clk(clk_enb0), .q(x2_c1), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c2_dff(.din(x2_c1), .clk(clk_enb0), .q(x2_c2), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c3_dff(.din(x2_c2), .clk(clk_enb0), .q(x2_c3), .rst(rst), .se(se), .si(), .so());

  assign x2_c2c3 =  x2_c2 | x2_c3 ;
	
  /////////////////////////////////////////////////////////////////////
  // 	Enable flops for op1
  /////////////////////////////////////////////////////////////////////
  clken_buf	ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(valid & mul_step)), .tmb_l(tm_l));
  dff_s #(64)  	ffrs1  (.din(rs1_l[63:0]), .clk(clk_enb1), .q(op1_l[63:0]),
			.se(se), .si(), .so());




  assign op1[63:0] = ~op1_l[63:0];

  mul_booth	 booth (.head (valid),
			.b_in (rs2),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (b8),
			.b9   (b9),
			.b10  (b10),
			.b11  (b11),
			.b12  (b12),
			.b13  (b13),
			.b14  (b14),
			.b15  (b15),
			.b16  (b16),
			.clk  (clk), .se(se), .si(), .so(), .mul_step(mul_step), .tm_l(tm_l));
			
  /////////////////////////////////////////////////////////////////////
  // 	Two Array1 inst ary1_a0 & ary1_a1 with the ouput flops 
  /////////////////////////////////////////////////////////////////////
  mul_array1	ary1_a0(.cout (a0cout[81:4]),
			.sum  (a0sum[81:0]),
			.a    (op1),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (3'b000),
			.head (cyc1),
			.bot  (1'b0)); //array a is never at the bottom of 33-pp rows
 
  dff_s #(78)  a0cot_dff (.din(a0cout[81:4]), .clk(clk_enb0), .q(a0c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a0sum_dff (.din(a0sum[81:0]), .clk(clk_enb0), .q(a0s[81:0]),
			.se(se), .si(), .so());

  mul_array1	ary1_a1(.cout (a1cout[81:4]),
			.sum  (a1sum[81:0]),
			.a    (op1),
			.b0   (b8),
			.b1   (b9),
			.b2   (b10),
			.b3   (b11),
			.b4   (b12),
			.b5   (b13),
			.b6   (b14),
			.b7   (b15),
			.b8   ({1'b0,b16,1'b0}),
			.head (1'b0),	//array b is never at the head of 33-pp rows
			.bot  (cyc2)); 

  dff_s #(78)  a1cot_dff (.din(a1cout[81:4]), .clk(clk_enb0), .q(a1c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a1sum_dff (.din(a1sum[81:0]), .clk(clk_enb0), .q(a1s[81:0]),
			.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Array2 with the reorder output mux-flops
  /////////////////////////////////////////////////////////////////////
  mul_array2 	 array2(.pcoutx2 (pcoutx2),
			.psumx2  (psumx2),
			.pcout 	 (pcout[98:0]),
			.psum    (psum[98:0]), 
			.a0c     (a0c[81:4]),
			.a0s     (a0s[81:0]),
			.a1c     (a1c[81:4]),
			.a1s     (a1s[81:0]),
			.pc	 (pc[98:30]),
			.ps	 (ps[98:31]),
			.areg    (areg[96:0]),
			.bot     (cyc3),
			.x2      (x2_c2c3));
 
  //// Outpput re-order muxes and flops	////
  dp_mux2es #(97)  ary2_cmux (.dout(ary2_cout[96:0]),
                              .in0(pcout[96:0]),
                              .in1({pcout[95:0],pcoutx2}),
                              .sel(x2_c2c3));
  dff_s #(97)  a2cot_dff (.din(ary2_cout[96:0]), .clk(clk_enb0), .q(addin_cout[96:0]), 
              		.se(se), .si(), .so());

  dp_mux2es #(98) ary2_smux (.dout(ary2_sum[97:0]),
                             .in0(psum[97:0]),
                             .in1({psum[96:0],psumx2}),
                             .sel(x2_c2c3));
  dff_s #(98)  a2sum_dff (.din(ary2_sum[97:0]), .clk(clk_enb0), .q(addin_sum[97:0]), 
			.se(se), .si(), .so());

  //// Pseudo sum & cout logic and flops ////
  assign psum_in[98:32]  = psum[98:32] & {67{cyc2}} ;
  assign psum_in[31]     = psum[31] & x2_c2 ;

  assign pcout_in[98:31] = pcout[98:31] & {68{cyc2}} ;
  assign pcout_in[30]    = pcout[30] & x2_c2 ;
  
  dff_s #(68)  psum_dff  (.din(psum_in[98:31]), .clk(clk_enb0), .q(ps[98:31]),
                	.se(se), .si(), .so());
  dff_s #(69)  pcout_dff (.din(pcout_in[98:30]), .clk(clk_enb0), .q(pc[98:30]),
            		.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Adder (104-bit) 
  /////////////////////////////////////////////////////////////////////

  assign 	add_cin = add_co31 & cyc3 ;

  assign {add_co31,addout[31:0]} =   {{1'b0},addin_sum[31:0]} 
		     		   + {{1'b0},addin_cout[30:0],addin_cin} ;


  assign {add_co96,addout[96:32]} =  addin_sum[97:32]	
				  + addin_cout[96:31]
				  + {{65'b0},add_co31} ;

  assign 	addout[103:97] =  accreg[135:129] + {{6'b0},add_co96} ;

  /////////////////////////////////////////////////////////////////////
  // 	Pipe adder outputs  
  /////////////////////////////////////////////////////////////////////

  dff_s  	      co31_dff (.din(add_cin), .clk(clk_enb0), .q(addin_cin),
       			.se(se), .si(), .so());

  dff_s #(104)   out_dff (.din(addout[103:0]), .clk(clk_enb0), .q(out[135:32]),
              		.se(se), .si(), .so());

  dff_s #(32)    pip_dff (.din(out[63:32]), .clk(clk_enb0), .q(out[31:0]),
               		.se(se), .si(), .so());

endmodule // mul64




////////////////////////////////////////////////////////////////////////
//	Sub-moudle for mul64
////////////////////////////////////////////////////////////////////////

module mul_array1 ( cout, sum, a, b0, b1, b2, b3, b4, b5, b6, b7, b8,
     bot, head );

input  bot, head;
output [81:4]  cout;
output [81:0]  sum;
input [2:0]  b6;
input [2:0]  b3;
input [2:0]  b8;
input [2:0]  b2;
input [2:0]  b1;
input [2:0]  b7;
input [63:0]  a;
input [2:0]  b0;
input [2:0]  b4;
input [2:0]  b5;

// Buses in the design

wire  [1:0]  b5n;
wire  [1:0]  b2n;
wire  [68:1]  c0;
wire  [69:0]  s1;
wire  [68:1]  c1;
wire  [69:0]  s2;
wire  [68:1]  c2;
wire  [70:4]  s_1;
wire  [69:2]  s0;
wire  [76:10]  s_2;
wire  [70:2]  c_1;
wire  [76:10]  c_2;
wire  [75:11]  co;

mul_negen p1n ( .b(b5[2:0]), .n1(b5n[1]), .n0(b5n[0]));
mul_negen p0n ( .b(b2[2:0]), .n1(b2n[1]), .n0(b2n[0]));
mul_csa42  sc3_71_ ( .c(s_2[71]), .cin(co[70]), .a(c_1[70]),
     .b(c_2[70]), .cout(co[71]), .sum(sum[71]), .d(s1[65]),
     .carry(cout[71]));
mul_csa42  sc3_75_ ( .c(s_2[75]), .cin(co[74]), .a(1'b0),
     .b(c_2[74]), .cout(co[75]), .sum(sum[75]), .d(s1[69]),
     .carry(cout[75]));
mul_csa42  sc3_74_ ( .c(s_2[74]), .cin(co[73]), .a(1'b0),
     .b(c_2[73]), .cout(co[74]), .sum(sum[74]), .d(s1[68]),
     .carry(cout[74]));
mul_csa42  sc3_73_ ( .c(s_2[73]), .cin(co[72]), .a(1'b0),
     .b(c_2[72]), .cout(co[73]), .sum(sum[73]), .d(s1[67]),
     .carry(cout[73]));
mul_csa42  sc3_72_ ( .c(s_2[72]), .cin(co[71]), .a(1'b0),
     .b(c_2[71]), .cout(co[72]), .sum(sum[72]), .d(s1[66]),
     .carry(cout[72]));
mul_csa42  sc3_76_ ( .c(s_2[76]), .cin(co[75]), .a(1'b0),
     .b(c_2[75]), .cout(), .sum(sum[76]), .d(1'b0),
     .carry(cout[76]));
mul_csa42  sc3_70_ ( .c(s_2[70]), .cin(co[69]), .a(c_1[69]),
     .b(c_2[69]), .cout(co[70]), .sum(sum[70]), .d(s_1[70]),
     .carry(cout[70]));
mul_csa42  sc3_69_ ( .c(s_2[69]), .cin(co[68]), .a(c_1[68]),
     .b(c_2[68]), .cout(co[69]), .sum(sum[69]), .d(s_1[69]),
     .carry(cout[69]));
mul_csa42  sc3_68_ ( .c(s_2[68]), .cin(co[67]), .a(c_1[67]),
     .b(c_2[67]), .cout(co[68]), .sum(sum[68]), .d(s_1[68]),
     .carry(cout[68]));
mul_csa42  sc3_67_ ( .c(s_2[67]), .cin(co[66]), .a(c_1[66]),
     .b(c_2[66]), .cout(co[67]), .sum(sum[67]), .d(s_1[67]),
     .carry(cout[67]));
mul_csa42  sc3_66_ ( .c(s_2[66]), .cin(co[65]), .a(c_1[65]),
     .b(c_2[65]), .cout(co[66]), .sum(sum[66]), .d(s_1[66]),
     .carry(cout[66]));
mul_csa42  sc3_65_ ( .c(s_2[65]), .cin(co[64]), .a(c_1[64]),
     .b(c_2[64]), .cout(co[65]), .sum(sum[65]), .d(s_1[65]),
     .carry(cout[65]));
mul_csa42  sc3_64_ ( .c(s_2[64]), .cin(co[63]), .a(c_1[63]),
     .b(c_2[63]), .cout(co[64]), .sum(sum[64]), .d(s_1[64]),
     .carry(cout[64]));
mul_csa42  sc3_63_ ( .c(s_2[63]), .cin(co[62]), .a(c_1[62]),
     .b(c_2[62]), .cout(co[63]), .sum(sum[63]), .d(s_1[63]),
     .carry(cout[63]));
mul_csa42  sc3_62_ ( .c(s_2[62]), .cin(co[61]), .a(c_1[61]),
     .b(c_2[61]), .cout(co[62]), .sum(sum[62]), .d(s_1[62]),
     .carry(cout[62]));
mul_csa42  sc3_61_ ( .c(s_2[61]), .cin(co[60]), .a(c_1[60]),
     .b(c_2[60]), .cout(co[61]), .sum(sum[61]), .d(s_1[61]),
     .carry(cout[61]));
mul_csa42  sc3_60_ ( .c(s_2[60]), .cin(co[59]), .a(c_1[59]),
     .b(c_2[59]), .cout(co[60]), .sum(sum[60]), .d(s_1[60]),
     .carry(cout[60]));
mul_csa42  sc3_59_ ( .c(s_2[59]), .cin(co[58]), .a(c_1[58]),
     .b(c_2[58]), .cout(co[59]), .sum(sum[59]), .d(s_1[59]),
     .carry(cout[59]));
mul_csa42  sc3_58_ ( .c(s_2[58]), .cin(co[57]), .a(c_1[57]),
     .b(c_2[57]), .cout(co[58]), .sum(sum[58]), .d(s_1[58]),
     .carry(cout[58]));
mul_csa42  sc3_57_ ( .c(s_2[57]), .cin(co[56]), .a(c_1[56]),
     .b(c_2[56]), .cout(co[57]), .sum(sum[57]), .d(s_1[57]),
     .carry(cout[57]));
mul_csa42  sc3_56_ ( .c(s_2[56]), .cin(co[55]), .a(c_1[55]),
     .b(c_2[55]), .cout(co[56]), .sum(sum[56]), .d(s_1[56]),
     .carry(cout[56]));
mul_csa42  sc3_55_ ( .c(s_2[55]), .cin(co[54]), .a(c_1[54]),
     .b(c_2[54]), .cout(co[55]), .sum(sum[55]), .d(s_1[55]),
     .carry(cout[55]));
mul_csa42  sc3_54_ ( .c(s_2[54]), .cin(co[53]), .a(c_1[53]),
     .b(c_2[53]), .cout(co[54]), .sum(sum[54]), .d(s_1[54]),
     .carry(cout[54]));
mul_csa42  sc3_53_ ( .c(s_2[53]), .cin(co[52]), .a(c_1[52]),
     .b(c_2[52]), .cout(co[53]), .sum(sum[53]), .d(s_1[53]),
     .carry(cout[53]));
mul_csa42  sc3_52_ ( .c(s_2[52]), .cin(co[51]), .a(c_1[51]),
     .b(c_2[51]), .cout(co[52]), .sum(sum[52]), .d(s_1[52]),
     .carry(cout[52]));
mul_csa42  sc3_51_ ( .c(s_2[51]), .cin(co[50]), .a(c_1[50]),
     .b(c_2[50]), .cout(co[51]), .sum(sum[51]), .d(s_1[51]),
     .carry(cout[51]));
mul_csa42  sc3_50_ ( .c(s_2[50]), .cin(co[49]), .a(c_1[49]),
     .b(c_2[49]), .cout(co[50]), .sum(sum[50]), .d(s_1[50]),
     .carry(cout[50]));
mul_csa42  sc3_49_ ( .c(s_2[49]), .cin(co[48]), .a(c_1[48]),
     .b(c_2[48]), .cout(co[49]), .sum(sum[49]), .d(s_1[49]),
     .carry(cout[49]));
mul_csa42  sc3_48_ ( .c(s_2[48]), .cin(co[47]), .a(c_1[47]),
     .b(c_2[47]), .cout(co[48]), .sum(sum[48]), .d(s_1[48]),
     .carry(cout[48]));
mul_csa42  sc3_47_ ( .c(s_2[47]), .cin(co[46]), .a(c_1[46]),
     .b(c_2[46]), .cout(co[47]), .sum(sum[47]), .d(s_1[47]),
     .carry(cout[47]));
mul_csa42  sc3_46_ ( .c(s_2[46]), .cin(co[45]), .a(c_1[45]),
     .b(c_2[45]), .cout(co[46]), .sum(sum[46]), .d(s_1[46]),
     .carry(cout[46]));
mul_csa42  sc3_45_ ( .c(s_2[45]), .cin(co[44]), .a(c_1[44]),
     .b(c_2[44]), .cout(co[45]), .sum(sum[45]), .d(s_1[45]),
     .carry(cout[45]));
mul_csa42  sc3_44_ ( .c(s_2[44]), .cin(co[43]), .a(c_1[43]),
     .b(c_2[43]), .cout(co[44]), .sum(sum[44]), .d(s_1[44]),
     .carry(cout[44]));
mul_csa42  sc3_43_ ( .c(s_2[43]), .cin(co[42]), .a(c_1[42]),
     .b(c_2[42]), .cout(co[43]), .sum(sum[43]), .d(s_1[43]),
     .carry(cout[43]));
mul_csa42  sc3_42_ ( .c(s_2[42]), .cin(co[41]), .a(c_1[41]),
     .b(c_2[41]), .cout(co[42]), .sum(sum[42]), .d(s_1[42]),
     .carry(cout[42]));
mul_csa42  sc3_41_ ( .c(s_2[41]), .cin(co[40]), .a(c_1[40]),
     .b(c_2[40]), .cout(co[41]), .sum(sum[41]), .d(s_1[41]),
     .carry(cout[41]));
mul_csa42  sc3_40_ ( .c(s_2[40]), .cin(co[39]), .a(c_1[39]),
     .b(c_2[39]), .cout(co[40]), .sum(sum[40]), .d(s_1[40]),
     .carry(cout[40]));
mul_csa42  sc3_39_ ( .c(s_2[39]), .cin(co[38]), .a(c_1[38]),
     .b(c_2[38]), .cout(co[39]), .sum(sum[39]), .d(s_1[39]),
     .carry(cout[39]));
mul_csa42  sc3_38_ ( .c(s_2[38]), .cin(co[37]), .a(c_1[37]),
     .b(c_2[37]), .cout(co[38]), .sum(sum[38]), .d(s_1[38]),
     .carry(cout[38]));
mul_csa42  sc3_37_ ( .c(s_2[37]), .cin(co[36]), .a(c_1[36]),
     .b(c_2[36]), .cout(co[37]), .sum(sum[37]), .d(s_1[37]),
     .carry(cout[37]));
mul_csa42  sc3_36_ ( .c(s_2[36]), .cin(co[35]), .a(c_1[35]),
     .b(c_2[35]), .cout(co[36]), .sum(sum[36]), .d(s_1[36]),
     .carry(cout[36]));
mul_csa42  sc3_35_ ( .c(s_2[35]), .cin(co[34]), .a(c_1[34]),
     .b(c_2[34]), .cout(co[35]), .sum(sum[35]), .d(s_1[35]),
     .carry(cout[35]));
mul_csa42  sc3_34_ ( .c(s_2[34]), .cin(co[33]), .a(c_1[33]),
     .b(c_2[33]), .cout(co[34]), .sum(sum[34]), .d(s_1[34]),
     .carry(cout[34]));
mul_csa42  sc3_33_ ( .c(s_2[33]), .cin(co[32]), .a(c_1[32]),
     .b(c_2[32]), .cout(co[33]), .sum(sum[33]), .d(s_1[33]),
     .carry(cout[33]));
mul_csa42  sc3_32_ ( .c(s_2[32]), .cin(co[31]), .a(c_1[31]),
     .b(c_2[31]), .cout(co[32]), .sum(sum[32]), .d(s_1[32]),
     .carry(cout[32]));
mul_csa42  sc3_31_ ( .c(s_2[31]), .cin(co[30]), .a(c_1[30]),
     .b(c_2[30]), .cout(co[31]), .sum(sum[31]), .d(s_1[31]),
     .carry(cout[31]));
mul_csa42  sc3_30_ ( .c(s_2[30]), .cin(co[29]), .a(c_1[29]),
     .b(c_2[29]), .cout(co[30]), .sum(sum[30]), .d(s_1[30]),
     .carry(cout[30]));
mul_csa42  sc3_29_ ( .c(s_2[29]), .cin(co[28]), .a(c_1[28]),
     .b(c_2[28]), .cout(co[29]), .sum(sum[29]), .d(s_1[29]),
     .carry(cout[29]));
mul_csa42  sc3_28_ ( .c(s_2[28]), .cin(co[27]), .a(c_1[27]),
     .b(c_2[27]), .cout(co[28]), .sum(sum[28]), .d(s_1[28]),
     .carry(cout[28]));
mul_csa42  sc3_27_ ( .c(s_2[27]), .cin(co[26]), .a(c_1[26]),
     .b(c_2[26]), .cout(co[27]), .sum(sum[27]), .d(s_1[27]),
     .carry(cout[27]));
mul_csa42  sc3_26_ ( .c(s_2[26]), .cin(co[25]), .a(c_1[25]),
     .b(c_2[25]), .cout(co[26]), .sum(sum[26]), .d(s_1[26]),
     .carry(cout[26]));
mul_csa42  sc3_25_ ( .c(s_2[25]), .cin(co[24]), .a(c_1[24]),
     .b(c_2[24]), .cout(co[25]), .sum(sum[25]), .d(s_1[25]),
     .carry(cout[25]));
mul_csa42  sc3_24_ ( .c(s_2[24]), .cin(co[23]), .a(c_1[23]),
     .b(c_2[23]), .cout(co[24]), .sum(sum[24]), .d(s_1[24]),
     .carry(cout[24]));
mul_csa42  sc3_23_ ( .c(s_2[23]), .cin(co[22]), .a(c_1[22]),
     .b(c_2[22]), .cout(co[23]), .sum(sum[23]), .d(s_1[23]),
     .carry(cout[23]));
mul_csa42  sc3_22_ ( .c(s_2[22]), .cin(co[21]), .a(c_1[21]),
     .b(c_2[21]), .cout(co[22]), .sum(sum[22]), .d(s_1[22]),
     .carry(cout[22]));
mul_csa42  sc3_21_ ( .c(s_2[21]), .cin(co[20]), .a(c_1[20]),
     .b(c_2[20]), .cout(co[21]), .sum(sum[21]), .d(s_1[21]),
     .carry(cout[21]));
mul_csa42  sc3_20_ ( .c(s_2[20]), .cin(co[19]), .a(c_1[19]),
     .b(c_2[19]), .cout(co[20]), .sum(sum[20]), .d(s_1[20]),
     .carry(cout[20]));
mul_csa42  sc3_19_ ( .c(s_2[19]), .cin(co[18]), .a(c_1[18]),
     .b(c_2[18]), .cout(co[19]), .sum(sum[19]), .d(s_1[19]),
     .carry(cout[19]));
mul_csa42  sc3_18_ ( .c(s_2[18]), .cin(co[17]), .a(c_1[17]),
     .b(c_2[17]), .cout(co[18]), .sum(sum[18]), .d(s_1[18]),
     .carry(cout[18]));
mul_csa42  sc3_17_ ( .c(s_2[17]), .cin(co[16]), .a(c_1[16]),
     .b(c_2[16]), .cout(co[17]), .sum(sum[17]), .d(s_1[17]),
     .carry(cout[17]));
mul_csa42  sc3_16_ ( .c(s_2[16]), .cin(co[15]), .a(c_1[15]),
     .b(c_2[15]), .cout(co[16]), .sum(sum[16]), .d(s_1[16]),
     .carry(cout[16]));
mul_csa42  sc3_15_ ( .c(s_2[15]), .cin(co[14]), .a(c_1[14]),
     .b(c_2[14]), .cout(co[15]), .sum(sum[15]), .d(s_1[15]),
     .carry(cout[15]));
mul_csa42  sc3_14_ ( .c(s_2[14]), .cin(co[13]), .a(c_1[13]),
     .b(c_2[13]), .cout(co[14]), .sum(sum[14]), .d(s_1[14]),
     .carry(cout[14]));
mul_csa42  sc3_13_ ( .c(s_2[13]), .cin(co[12]), .a(c_1[12]),
     .b(c_2[12]), .cout(co[13]), .sum(sum[13]), .d(s_1[13]),
     .carry(cout[13]));
mul_csa42  sc3_12_ ( .c(s_2[12]), .cin(co[11]), .a(c_1[11]),
     .b(c_2[11]), .cout(co[12]), .sum(sum[12]), .d(s_1[12]),
     .carry(cout[12]));
mul_csa42  sc3_11_ ( .c(s_2[11]), .cin(1'b0),
     .a(c_1[10]), .b(c_2[10]), .cout(co[11]), .sum(sum[11]),
     .d(s_1[11]), .carry(cout[11]));
mul_csa32  sc2_2_70_ ( .c(c1[63]), .b(c2[57]), .a(s2[58]),
     .cout(c_2[70]), .sum(s_2[70]));
mul_csa32  sc2_2_69_ ( .c(c1[62]), .b(c2[56]), .a(s2[57]),
     .cout(c_2[69]), .sum(s_2[69]));
mul_csa32  sc2_2_68_ ( .c(c1[61]), .b(c2[55]), .a(s2[56]),
     .cout(c_2[68]), .sum(s_2[68]));
mul_csa32  sc2_2_67_ ( .c(c1[60]), .b(c2[54]), .a(s2[55]),
     .cout(c_2[67]), .sum(s_2[67]));
mul_csa32  sc2_2_66_ ( .c(c1[59]), .b(c2[53]), .a(s2[54]),
     .cout(c_2[66]), .sum(s_2[66]));
mul_csa32  sc2_2_65_ ( .c(c1[58]), .b(c2[52]), .a(s2[53]),
     .cout(c_2[65]), .sum(s_2[65]));
mul_csa32  sc2_2_64_ ( .c(c1[57]), .b(c2[51]), .a(s2[52]),
     .cout(c_2[64]), .sum(s_2[64]));
mul_csa32  sc2_2_63_ ( .c(c1[56]), .b(c2[50]), .a(s2[51]),
     .cout(c_2[63]), .sum(s_2[63]));
mul_csa32  sc2_2_62_ ( .c(c1[55]), .b(c2[49]), .a(s2[50]),
     .cout(c_2[62]), .sum(s_2[62]));
mul_csa32  sc2_2_61_ ( .c(c1[54]), .b(c2[48]), .a(s2[49]),
     .cout(c_2[61]), .sum(s_2[61]));
mul_csa32  sc2_2_60_ ( .c(c1[53]), .b(c2[47]), .a(s2[48]),
     .cout(c_2[60]), .sum(s_2[60]));
mul_csa32  sc2_2_59_ ( .c(c1[52]), .b(c2[46]), .a(s2[47]),
     .cout(c_2[59]), .sum(s_2[59]));
mul_csa32  sc2_2_58_ ( .c(c1[51]), .b(c2[45]), .a(s2[46]),
     .cout(c_2[58]), .sum(s_2[58]));
mul_csa32  sc2_2_57_ ( .c(c1[50]), .b(c2[44]), .a(s2[45]),
     .cout(c_2[57]), .sum(s_2[57]));
mul_csa32  sc2_2_56_ ( .c(c1[49]), .b(c2[43]), .a(s2[44]),
     .cout(c_2[56]), .sum(s_2[56]));
mul_csa32  sc2_2_55_ ( .c(c1[48]), .b(c2[42]), .a(s2[43]),
     .cout(c_2[55]), .sum(s_2[55]));
mul_csa32  sc2_2_54_ ( .c(c1[47]), .b(c2[41]), .a(s2[42]),
     .cout(c_2[54]), .sum(s_2[54]));
mul_csa32  sc2_2_53_ ( .c(c1[46]), .b(c2[40]), .a(s2[41]),
     .cout(c_2[53]), .sum(s_2[53]));
mul_csa32  sc2_2_52_ ( .c(c1[45]), .b(c2[39]), .a(s2[40]),
     .cout(c_2[52]), .sum(s_2[52]));
mul_csa32  sc2_2_51_ ( .c(c1[44]), .b(c2[38]), .a(s2[39]),
     .cout(c_2[51]), .sum(s_2[51]));
mul_csa32  sc2_2_50_ ( .c(c1[43]), .b(c2[37]), .a(s2[38]),
     .cout(c_2[50]), .sum(s_2[50]));
mul_csa32  sc2_2_49_ ( .c(c1[42]), .b(c2[36]), .a(s2[37]),
     .cout(c_2[49]), .sum(s_2[49]));
mul_csa32  sc2_2_48_ ( .c(c1[41]), .b(c2[35]), .a(s2[36]),
     .cout(c_2[48]), .sum(s_2[48]));
mul_csa32  sc2_2_47_ ( .c(c1[40]), .b(c2[34]), .a(s2[35]),
     .cout(c_2[47]), .sum(s_2[47]));
mul_csa32  sc2_2_46_ ( .c(c1[39]), .b(c2[33]), .a(s2[34]),
     .cout(c_2[46]), .sum(s_2[46]));
mul_csa32  sc2_2_45_ ( .c(c1[38]), .b(c2[32]), .a(s2[33]),
     .cout(c_2[45]), .sum(s_2[45]));
mul_csa32  sc2_2_44_ ( .c(c1[37]), .b(c2[31]), .a(s2[32]),
     .cout(c_2[44]), .sum(s_2[44]));
mul_csa32  sc2_2_43_ ( .c(c1[36]), .b(c2[30]), .a(s2[31]),
     .cout(c_2[43]), .sum(s_2[43]));
mul_csa32  sc2_2_42_ ( .c(c1[35]), .b(c2[29]), .a(s2[30]),
     .cout(c_2[42]), .sum(s_2[42]));
mul_csa32  sc2_2_41_ ( .c(c1[34]), .b(c2[28]), .a(s2[29]),
     .cout(c_2[41]), .sum(s_2[41]));
mul_csa32  sc2_2_40_ ( .c(c1[33]), .b(c2[27]), .a(s2[28]),
     .cout(c_2[40]), .sum(s_2[40]));
mul_csa32  sc2_2_39_ ( .c(c1[32]), .b(c2[26]), .a(s2[27]),
     .cout(c_2[39]), .sum(s_2[39]));
mul_csa32  sc2_2_38_ ( .c(c1[31]), .b(c2[25]), .a(s2[26]),
     .cout(c_2[38]), .sum(s_2[38]));
mul_csa32  sc2_2_37_ ( .c(c1[30]), .b(c2[24]), .a(s2[25]),
     .cout(c_2[37]), .sum(s_2[37]));
mul_csa32  sc2_2_36_ ( .c(c1[29]), .b(c2[23]), .a(s2[24]),
     .cout(c_2[36]), .sum(s_2[36]));
mul_csa32  sc2_2_35_ ( .c(c1[28]), .b(c2[22]), .a(s2[23]),
     .cout(c_2[35]), .sum(s_2[35]));
mul_csa32  sc2_2_34_ ( .c(c1[27]), .b(c2[21]), .a(s2[22]),
     .cout(c_2[34]), .sum(s_2[34]));
mul_csa32  sc2_2_33_ ( .c(c1[26]), .b(c2[20]), .a(s2[21]),
     .cout(c_2[33]), .sum(s_2[33]));
mul_csa32  sc2_2_32_ ( .c(c1[25]), .b(c2[19]), .a(s2[20]),
     .cout(c_2[32]), .sum(s_2[32]));
mul_csa32  sc2_2_31_ ( .c(c1[24]), .b(c2[18]), .a(s2[19]),
     .cout(c_2[31]), .sum(s_2[31]));
mul_csa32  sc2_2_30_ ( .c(c1[23]), .b(c2[17]), .a(s2[18]),
     .cout(c_2[30]), .sum(s_2[30]));
mul_csa32  sc2_2_29_ ( .c(c1[22]), .b(c2[16]), .a(s2[17]),
     .cout(c_2[29]), .sum(s_2[29]));
mul_csa32  sc2_2_28_ ( .c(c1[21]), .b(c2[15]), .a(s2[16]),
     .cout(c_2[28]), .sum(s_2[28]));
mul_csa32  sc2_2_27_ ( .c(c1[20]), .b(c2[14]), .a(s2[15]),
     .cout(c_2[27]), .sum(s_2[27]));
mul_csa32  sc2_2_26_ ( .c(c1[19]), .b(c2[13]), .a(s2[14]),
     .cout(c_2[26]), .sum(s_2[26]));
mul_csa32  sc2_2_25_ ( .c(c1[18]), .b(c2[12]), .a(s2[13]),
     .cout(c_2[25]), .sum(s_2[25]));
mul_csa32  sc2_2_24_ ( .c(c1[17]), .b(c2[11]), .a(s2[12]),
     .cout(c_2[24]), .sum(s_2[24]));
mul_csa32  sc2_2_23_ ( .c(c1[16]), .b(c2[10]), .a(s2[11]),
     .cout(c_2[23]), .sum(s_2[23]));
mul_csa32  sc2_2_22_ ( .c(c1[15]), .b(c2[9]), .a(s2[10]),
     .cout(c_2[22]), .sum(s_2[22]));
mul_csa32  sc2_2_21_ ( .c(c1[14]), .b(c2[8]), .a(s2[9]),
     .cout(c_2[21]), .sum(s_2[21]));
mul_csa32  sc2_2_20_ ( .c(c1[13]), .b(c2[7]), .a(s2[8]),
     .cout(c_2[20]), .sum(s_2[20]));
mul_csa32  sc2_2_19_ ( .c(c1[12]), .b(c2[6]), .a(s2[7]),
     .cout(c_2[19]), .sum(s_2[19]));
mul_csa32  sc2_2_18_ ( .c(c1[11]), .b(c2[5]), .a(s2[6]),
     .cout(c_2[18]), .sum(s_2[18]));
mul_csa32  sc2_2_17_ ( .c(c1[10]), .b(c2[4]), .a(s2[5]),
     .cout(c_2[17]), .sum(s_2[17]));
mul_csa32  sc2_2_16_ ( .c(c1[9]), .b(c2[3]), .a(s2[4]),
     .cout(c_2[16]), .sum(s_2[16]));
mul_csa32  sc2_2_15_ ( .c(c1[8]), .b(c2[2]), .a(s2[3]),
     .cout(c_2[15]), .sum(s_2[15]));
mul_csa32  sc2_2_14_ ( .c(c1[7]), .b(c2[1]), .a(s2[2]),
     .cout(c_2[14]), .sum(s_2[14]));
mul_csa32  sc2_2_13_ ( .c(c1[6]), .b(s1[7]), .a(s2[1]),
     .cout(c_2[13]), .sum(s_2[13]));
mul_csa32  sc2_2_12_ ( .c(c1[5]), .b(s1[6]), .a(s2[0]),
     .cout(c_2[12]), .sum(s_2[12]));
mul_csa32  sc2_2_11_ ( .c(c1[4]), .b(s1[5]), .a(b5n[1]),
     .cout(c_2[11]), .sum(s_2[11]));
mul_csa32  sc2_2_10_ ( .c(c1[3]), .b(s1[4]), .a(b5n[0]),
     .cout(c_2[10]), .sum(s_2[10]));
mul_csa32  sc2_2_76_ ( .c(1'b1), .b(c2[63]), .a(s2[64]),
     .cout(c_2[76]), .sum(s_2[76]));
mul_csa32  sc2_2_77_ ( .c(c_2[76]), .b(c2[64]), .a(s2[65]),
     .cout(cout[77]), .sum(sum[77]));
mul_csa32  sc2_1_9_ ( .c(s1[3]), .b(c0[8]), .a(s0[9]), .cout(c_1[9]),
     .sum(s_1[9]));
mul_csa32  sc2_1_8_ ( .c(s1[2]), .b(c0[7]), .a(s0[8]), .cout(c_1[8]),
     .sum(s_1[8]));
mul_csa32  sc2_1_3_ ( .c(c_1[2]), .b(c0[2]), .a(s0[3]),
     .cout(c_1[3]), .sum(sum[3]));
mul_csa32  sc3_10_ ( .c(s_2[10]), .b(s_1[10]), .a(c_1[9]),
     .cout(cout[10]), .sum(sum[10]));
mul_csa32  sc3_9_ ( .c(c1[2]), .sum(sum[9]), .cout(cout[9]),
     .a(c_1[8]), .b(s_1[9]));
mul_csa32  sc3_8_ ( .c(c1[1]), .sum(sum[8]), .cout(cout[8]),
     .a(c_1[7]), .b(s_1[8]));
mul_csa32  sc2_2_71_ ( .c(c1[64]), .b(c2[58]), .a(s2[59]),
     .cout(c_2[71]), .sum(s_2[71]));
mul_csa32  sc2_2_75_ ( .c(c1[68]), .b(c2[62]), .a(s2[63]),
     .cout(c_2[75]), .sum(s_2[75]));
mul_csa32  sc2_2_74_ ( .c(c1[67]), .b(c2[61]), .a(s2[62]),
     .cout(c_2[74]), .sum(s_2[74]));
mul_csa32  sc2_2_73_ ( .c(c1[66]), .b(c2[60]), .a(s2[61]),
     .cout(c_2[73]), .sum(s_2[73]));
mul_csa32  sc2_2_72_ ( .c(c1[65]), .b(c2[59]), .a(s2[60]),
     .cout(c_2[72]), .sum(s_2[72]));
mul_csa32  sc2_1_69_ ( .c(s1[63]), .sum(s_1[69]), .cout(c_1[69]),
     .a(s0[69]), .b(c0[68]));
mul_csa32  sc2_1_68_ ( .c(s1[62]), .sum(s_1[68]), .cout(c_1[68]),
     .a(s0[68]), .b(c0[67]));
mul_csa32  sc2_1_67_ ( .c(s1[61]), .sum(s_1[67]), .cout(c_1[67]),
     .a(s0[67]), .b(c0[66]));
mul_csa32  sc2_1_66_ ( .c(s1[60]), .sum(s_1[66]), .cout(c_1[66]),
     .a(s0[66]), .b(c0[65]));
mul_csa32  sc2_1_65_ ( .c(s1[59]), .sum(s_1[65]), .cout(c_1[65]),
     .a(s0[65]), .b(c0[64]));
mul_csa32  sc2_1_64_ ( .c(s1[58]), .sum(s_1[64]), .cout(c_1[64]),
     .a(s0[64]), .b(c0[63]));
mul_csa32  sc2_1_63_ ( .c(s1[57]), .sum(s_1[63]), .cout(c_1[63]),
     .a(s0[63]), .b(c0[62]));
mul_csa32  sc2_1_62_ ( .c(s1[56]), .sum(s_1[62]), .cout(c_1[62]),
     .a(s0[62]), .b(c0[61]));
mul_csa32  sc2_1_61_ ( .c(s1[55]), .sum(s_1[61]), .cout(c_1[61]),
     .a(s0[61]), .b(c0[60]));
mul_csa32  sc2_1_60_ ( .c(s1[54]), .sum(s_1[60]), .cout(c_1[60]),
     .a(s0[60]), .b(c0[59]));
mul_csa32  sc2_1_59_ ( .c(s1[53]), .sum(s_1[59]), .cout(c_1[59]),
     .a(s0[59]), .b(c0[58]));
mul_csa32  sc2_1_58_ ( .c(s1[52]), .sum(s_1[58]), .cout(c_1[58]),
     .a(s0[58]), .b(c0[57]));
mul_csa32  sc2_1_57_ ( .c(s1[51]), .sum(s_1[57]), .cout(c_1[57]),
     .a(s0[57]), .b(c0[56]));
mul_csa32  sc2_1_56_ ( .c(s1[50]), .sum(s_1[56]), .cout(c_1[56]),
     .a(s0[56]), .b(c0[55]));
mul_csa32  sc2_1_55_ ( .c(s1[49]), .sum(s_1[55]), .cout(c_1[55]),
     .a(s0[55]), .b(c0[54]));
mul_csa32  sc2_1_54_ ( .c(s1[48]), .sum(s_1[54]), .cout(c_1[54]),
     .a(s0[54]), .b(c0[53]));
mul_csa32  sc2_1_53_ ( .c(s1[47]), .sum(s_1[53]), .cout(c_1[53]),
     .a(s0[53]), .b(c0[52]));
mul_csa32  sc2_1_52_ ( .c(s1[46]), .sum(s_1[52]), .cout(c_1[52]),
     .a(s0[52]), .b(c0[51]));
mul_csa32  sc2_1_51_ ( .c(s1[45]), .sum(s_1[51]), .cout(c_1[51]),
     .a(s0[51]), .b(c0[50]));
mul_csa32  sc2_1_50_ ( .c(s1[44]), .sum(s_1[50]), .cout(c_1[50]),
     .a(s0[50]), .b(c0[49]));
mul_csa32  sc2_1_49_ ( .c(s1[43]), .sum(s_1[49]), .cout(c_1[49]),
     .a(s0[49]), .b(c0[48]));
mul_csa32  sc2_1_48_ ( .c(s1[42]), .sum(s_1[48]), .cout(c_1[48]),
     .a(s0[48]), .b(c0[47]));
mul_csa32  sc2_1_47_ ( .c(s1[41]), .sum(s_1[47]), .cout(c_1[47]),
     .a(s0[47]), .b(c0[46]));
mul_csa32  sc2_1_46_ ( .c(s1[40]), .sum(s_1[46]), .cout(c_1[46]),
     .a(s0[46]), .b(c0[45]));
mul_csa32  sc2_1_45_ ( .c(s1[39]), .sum(s_1[45]), .cout(c_1[45]),
     .a(s0[45]), .b(c0[44]));
mul_csa32  sc2_1_44_ ( .c(s1[38]), .sum(s_1[44]), .cout(c_1[44]),
     .a(s0[44]), .b(c0[43]));
mul_csa32  sc2_1_43_ ( .c(s1[37]), .sum(s_1[43]), .cout(c_1[43]),
     .a(s0[43]), .b(c0[42]));
mul_csa32  sc2_1_42_ ( .c(s1[36]), .sum(s_1[42]), .cout(c_1[42]),
     .a(s0[42]), .b(c0[41]));
mul_csa32  sc2_1_41_ ( .c(s1[35]), .sum(s_1[41]), .cout(c_1[41]),
     .a(s0[41]), .b(c0[40]));
mul_csa32  sc2_1_40_ ( .c(s1[34]), .sum(s_1[40]), .cout(c_1[40]),
     .a(s0[40]), .b(c0[39]));
mul_csa32  sc2_1_39_ ( .c(s1[33]), .sum(s_1[39]), .cout(c_1[39]),
     .a(s0[39]), .b(c0[38]));
mul_csa32  sc2_1_38_ ( .c(s1[32]), .sum(s_1[38]), .cout(c_1[38]),
     .a(s0[38]), .b(c0[37]));
mul_csa32  sc2_1_37_ ( .c(s1[31]), .sum(s_1[37]), .cout(c_1[37]),
     .a(s0[37]), .b(c0[36]));
mul_csa32  sc2_1_36_ ( .c(s1[30]), .sum(s_1[36]), .cout(c_1[36]),
     .a(s0[36]), .b(c0[35]));
mul_csa32  sc2_1_35_ ( .c(s1[29]), .sum(s_1[35]), .cout(c_1[35]),
     .a(s0[35]), .b(c0[34]));
mul_csa32  sc2_1_34_ ( .c(s1[28]), .sum(s_1[34]), .cout(c_1[34]),
     .a(s0[34]), .b(c0[33]));
mul_csa32  sc2_1_33_ ( .c(s1[27]), .sum(s_1[33]), .cout(c_1[33]),
     .a(s0[33]), .b(c0[32]));
mul_csa32  sc2_1_32_ ( .c(s1[26]), .sum(s_1[32]), .cout(c_1[32]),
     .a(s0[32]), .b(c0[31]));
mul_csa32  sc2_1_31_ ( .c(s1[25]), .sum(s_1[31]), .cout(c_1[31]),
     .a(s0[31]), .b(c0[30]));
mul_csa32  sc2_1_30_ ( .c(s1[24]), .sum(s_1[30]), .cout(c_1[30]),
     .a(s0[30]), .b(c0[29]));
mul_csa32  sc2_1_29_ ( .c(s1[23]), .sum(s_1[29]), .cout(c_1[29]),
     .a(s0[29]), .b(c0[28]));
mul_csa32  sc2_1_28_ ( .c(s1[22]), .sum(s_1[28]), .cout(c_1[28]),
     .a(s0[28]), .b(c0[27]));
mul_csa32  sc2_1_27_ ( .c(s1[21]), .sum(s_1[27]), .cout(c_1[27]),
     .a(s0[27]), .b(c0[26]));
mul_csa32  sc2_1_26_ ( .c(s1[20]), .sum(s_1[26]), .cout(c_1[26]),
     .a(s0[26]), .b(c0[25]));
mul_csa32  sc2_1_25_ ( .c(s1[19]), .sum(s_1[25]), .cout(c_1[25]),
     .a(s0[25]), .b(c0[24]));
mul_csa32  sc2_1_24_ ( .c(s1[18]), .sum(s_1[24]), .cout(c_1[24]),
     .a(s0[24]), .b(c0[23]));
mul_csa32  sc2_1_23_ ( .c(s1[17]), .sum(s_1[23]), .cout(c_1[23]),
     .a(s0[23]), .b(c0[22]));
mul_csa32  sc2_1_22_ ( .c(s1[16]), .sum(s_1[22]), .cout(c_1[22]),
     .a(s0[22]), .b(c0[21]));
mul_csa32  sc2_1_21_ ( .c(s1[15]), .sum(s_1[21]), .cout(c_1[21]),
     .a(s0[21]), .b(c0[20]));
mul_csa32  sc2_1_20_ ( .c(s1[14]), .sum(s_1[20]), .cout(c_1[20]),
     .a(s0[20]), .b(c0[19]));
mul_csa32  sc2_1_19_ ( .c(s1[13]), .sum(s_1[19]), .cout(c_1[19]),
     .a(s0[19]), .b(c0[18]));
mul_csa32  sc2_1_18_ ( .c(s1[12]), .sum(s_1[18]), .cout(c_1[18]),
     .a(s0[18]), .b(c0[17]));
mul_csa32  sc2_1_17_ ( .c(s1[11]), .sum(s_1[17]), .cout(c_1[17]),
     .a(s0[17]), .b(c0[16]));
mul_csa32  sc2_1_16_ ( .c(s1[10]), .sum(s_1[16]), .cout(c_1[16]),
     .a(s0[16]), .b(c0[15]));
mul_csa32  sc2_1_15_ ( .c(s1[9]), .sum(s_1[15]), .cout(c_1[15]),
     .a(s0[15]), .b(c0[14]));
mul_csa32  sc2_1_14_ ( .c(s1[8]), .sum(s_1[14]), .cout(c_1[14]),
     .a(s0[14]), .b(c0[13]));
mul_csa32  sc2_1_7_ ( .c(s1[1]), .b(c0[6]), .a(s0[7]), .cout(c_1[7]),
     .sum(s_1[7]));
mul_csa32  sc2_1_6_ ( .c(s1[0]), .b(c0[5]), .a(s0[6]), .cout(c_1[6]),
     .sum(s_1[6]));
mul_csa32  sc2_1_5_ ( .c(b2n[1]), .b(c0[4]), .a(s0[5]),
     .cout(c_1[5]), .sum(s_1[5]));
mul_csa32  sc2_1_4_ ( .c(b2n[0]), .b(c0[3]), .a(s0[4]),
     .cout(c_1[4]), .sum(s_1[4]));
mul_ha sc2_1_10_ ( .sum(s_1[10]), .cout(c_1[10]), .a(s0[10]),
     .b(c0[9]));
mul_ha sc3_7_ ( .sum(sum[7]), .cout(cout[7]), .a(c_1[6]),
     .b(s_1[7]));
mul_ha sc3_6_ ( .sum(sum[6]), .cout(cout[6]), .a(c_1[5]),
     .b(s_1[6]));
mul_ha sc3_5_ ( .sum(sum[5]), .cout(cout[5]), .a(c_1[4]),
     .b(s_1[5]));
mul_ha sc3_4_ ( .sum(sum[4]), .cout(cout[4]), .a(c_1[3]),
     .b(s_1[4]));
mul_ha sc2_2_81_ ( .sum(sum[81]), .cout(cout[81]), .a(s2[69]),
     .b(c2[68]));
mul_ha sc2_2_80_ ( .sum(sum[80]), .cout(cout[80]), .a(s2[68]),
     .b(c2[67]));
mul_ha sc2_2_79_ ( .sum(sum[79]), .cout(cout[79]), .a(s2[67]),
     .b(c2[66]));
mul_ha sc2_2_78_ ( .sum(sum[78]), .cout(cout[78]), .a(s2[66]),
     .b(c2[65]));
mul_ha sc2_1_70_ ( .sum(s_1[70]), .cout(c_1[70]),
     .a(1'b1), .b(s1[64]));
mul_ha sc2_1_2_ ( .sum(sum[2]), .cout(c_1[2]), .a(s0[2]), .b(c0[1]));
mul_ha sc2_1_13_ ( .sum(s_1[13]), .cout(c_1[13]), .a(s0[13]),
     .b(c0[12]));
mul_ha sc2_1_12_ ( .sum(s_1[12]), .cout(c_1[12]), .a(s0[12]),
     .b(c0[11]));
mul_ha sc2_1_11_ ( .sum(s_1[11]), .cout(c_1[11]), .a(s0[11]),
     .b(c0[10]));
mul_ppgenrow3 I2 ( .head(1'b0), .bot(bot), .b2(b8[2:0]),
     .b1(b7[2:0]), .b0(b6[2:0]), .a(a[63:0]), .sum(s2[69:0]),
     .cout(c2[68:1]));
mul_ppgenrow3 I1 ( .head(1'b0), .bot(1'b1),
     .b2(b5[2:0]), .b1(b4[2:0]), .b0(b3[2:0]), .a(a[63:0]),
     .sum(s1[69:0]), .cout(c1[68:1]));
mul_ppgenrow3 I0 ( .head(head), .bot(1'b1), .b2(b2[2:0]),
     .b1(b1[2:0]), .b0(b0[2:0]), .a(a[63:0]), .sum({s0[69:2],
     sum[1:0]}), .cout(c0[68:1]));

endmodule // mul_array1

module mul_array2 ( pcout, pcoutx2, psum, psumx2, a0c, a0s, a1c, a1s,
     areg, bot, pc, ps, x2 );

output  pcoutx2, psumx2;
input  bot, x2;
output [98:0]  psum;
output [98:0]  pcout;
input [81:4]  a1c;
input [98:30]  pc;
input [98:31]  ps;
input [81:0]  a0s;
input [96:0]  areg;
input [81:0]  a1s;
input [81:4]  a0c;

// Buses in the design
wire  [81:15]  s3;
wire  [81:15]  c3;
wire  [96:0]  ain;
wire  [67:20]  co;
wire  [82:0]  s1;
wire  [96:0]  c2;
wire  [82:0]  c1;
wire  [96:0]  s2;
wire	      ainx2, s1x2, c1x2;

mul_mux2 sh_82_ ( .d1(areg[83]), .z(ain[82]), .d0(areg[82]), .s(x2));
mul_mux2 sh_68_ ( .d1(areg[69]), .z(ain[68]), .d0(areg[68]), .s(x2));
mul_mux2 sh_67_ ( .d1(areg[68]), .z(ain[67]), .d0(areg[67]), .s(x2));
mul_mux2 sh_66_ ( .d1(areg[67]), .z(ain[66]), .d0(areg[66]), .s(x2));
mul_mux2 sh_65_ ( .d1(areg[66]), .z(ain[65]), .d0(areg[65]), .s(x2));
mul_mux2 sh_64_ ( .d1(areg[65]), .z(ain[64]), .d0(areg[64]), .s(x2));
mul_mux2 sh_63_ ( .d1(areg[64]), .z(ain[63]), .d0(areg[63]), .s(x2));
mul_mux2 sh_62_ ( .d1(areg[63]), .z(ain[62]), .d0(areg[62]), .s(x2));
mul_mux2 sh_61_ ( .d1(areg[62]), .z(ain[61]), .d0(areg[61]), .s(x2));
mul_mux2 sh_60_ ( .d1(areg[61]), .z(ain[60]), .d0(areg[60]), .s(x2));
mul_mux2 sh_59_ ( .d1(areg[60]), .z(ain[59]), .d0(areg[59]), .s(x2));
mul_mux2 sh_58_ ( .d1(areg[59]), .z(ain[58]), .d0(areg[58]), .s(x2));
mul_mux2 sh_57_ ( .d1(areg[58]), .z(ain[57]), .d0(areg[57]), .s(x2));
mul_mux2 sh_56_ ( .d1(areg[57]), .z(ain[56]), .d0(areg[56]), .s(x2));
mul_mux2 sh_55_ ( .d1(areg[56]), .z(ain[55]), .d0(areg[55]), .s(x2));
mul_mux2 sh_54_ ( .d1(areg[55]), .z(ain[54]), .d0(areg[54]), .s(x2));
mul_mux2 sh_53_ ( .d1(areg[54]), .z(ain[53]), .d0(areg[53]), .s(x2));
mul_mux2 sh_52_ ( .d1(areg[53]), .z(ain[52]), .d0(areg[52]), .s(x2));
mul_mux2 sh_51_ ( .d1(areg[52]), .z(ain[51]), .d0(areg[51]), .s(x2));
mul_mux2 sh_50_ ( .d1(areg[51]), .z(ain[50]), .d0(areg[50]), .s(x2));
mul_mux2 sh_49_ ( .d1(areg[50]), .z(ain[49]), .d0(areg[49]), .s(x2));
mul_mux2 sh_48_ ( .d1(areg[49]), .z(ain[48]), .d0(areg[48]), .s(x2));
mul_mux2 sh_47_ ( .d1(areg[48]), .z(ain[47]), .d0(areg[47]), .s(x2));
mul_mux2 sh_46_ ( .d1(areg[47]), .z(ain[46]), .d0(areg[46]), .s(x2));
mul_mux2 sh_45_ ( .d1(areg[46]), .z(ain[45]), .d0(areg[45]), .s(x2));
mul_mux2 sh_44_ ( .d1(areg[45]), .z(ain[44]), .d0(areg[44]), .s(x2));
mul_mux2 sh_43_ ( .d1(areg[44]), .z(ain[43]), .d0(areg[43]), .s(x2));
mul_mux2 sh_42_ ( .d1(areg[43]), .z(ain[42]), .d0(areg[42]), .s(x2));
mul_mux2 sh_41_ ( .d1(areg[42]), .z(ain[41]), .d0(areg[41]), .s(x2));
mul_mux2 sh_40_ ( .d1(areg[41]), .z(ain[40]), .d0(areg[40]), .s(x2));
mul_mux2 sh_39_ ( .d1(areg[40]), .z(ain[39]), .d0(areg[39]), .s(x2));
mul_mux2 sh_38_ ( .d1(areg[39]), .z(ain[38]), .d0(areg[38]), .s(x2));
mul_mux2 sh_37_ ( .d1(areg[38]), .z(ain[37]), .d0(areg[37]), .s(x2));
mul_mux2 sh_36_ ( .d1(areg[37]), .z(ain[36]), .d0(areg[36]), .s(x2));
mul_mux2 sh_35_ ( .d1(areg[36]), .z(ain[35]), .d0(areg[35]), .s(x2));
mul_mux2 sh_34_ ( .d1(areg[35]), .z(ain[34]), .d0(areg[34]), .s(x2));
mul_mux2 sh_33_ ( .d1(areg[34]), .z(ain[33]), .d0(areg[33]), .s(x2));
mul_mux2 sh_32_ ( .d1(areg[33]), .z(ain[32]), .d0(areg[32]), .s(x2));
mul_mux2 sh_31_ ( .d1(areg[32]), .z(ain[31]), .d0(areg[31]), .s(x2));
mul_mux2 sh_30_ ( .d1(areg[31]), .z(ain[30]), .d0(areg[30]), .s(x2));
mul_mux2 sh_29_ ( .d1(areg[30]), .z(ain[29]), .d0(areg[29]), .s(x2));
mul_mux2 sh_28_ ( .d1(areg[29]), .z(ain[28]), .d0(areg[28]), .s(x2));
mul_mux2 sh_27_ ( .d1(areg[28]), .z(ain[27]), .d0(areg[27]), .s(x2));
mul_mux2 sh_26_ ( .d1(areg[27]), .z(ain[26]), .d0(areg[26]), .s(x2));
mul_mux2 sh_25_ ( .d1(areg[26]), .z(ain[25]), .d0(areg[25]), .s(x2));
mul_mux2 sh_24_ ( .d1(areg[25]), .z(ain[24]), .d0(areg[24]), .s(x2));
mul_mux2 sh_23_ ( .d1(areg[24]), .z(ain[23]), .d0(areg[23]), .s(x2));
mul_mux2 sh_22_ ( .d1(areg[23]), .z(ain[22]), .d0(areg[22]), .s(x2));
mul_mux2 sh_21_ ( .d1(areg[22]), .z(ain[21]), .d0(areg[21]), .s(x2));
mul_mux2 sh_20_ ( .d1(areg[21]), .z(ain[20]), .d0(areg[20]), .s(x2));
mul_mux2 sh_96_ ( .d1(1'b0), .z(ain[96]), .d0(areg[96]),
     .s(x2));
mul_mux2 sh_95_ ( .d1(areg[96]), .z(ain[95]), .d0(areg[95]), .s(x2));
mul_mux2 sh_94_ ( .d1(areg[95]), .z(ain[94]), .d0(areg[94]), .s(x2));
mul_mux2 sh_93_ ( .d1(areg[94]), .z(ain[93]), .d0(areg[93]), .s(x2));
mul_mux2 sh_92_ ( .d1(areg[93]), .z(ain[92]), .d0(areg[92]), .s(x2));
mul_mux2 sh_91_ ( .d1(areg[92]), .z(ain[91]), .d0(areg[91]), .s(x2));
mul_mux2 sh_90_ ( .d1(areg[91]), .z(ain[90]), .d0(areg[90]), .s(x2));
mul_mux2 sh_89_ ( .d1(areg[90]), .z(ain[89]), .d0(areg[89]), .s(x2));
mul_mux2 sh_88_ ( .d1(areg[89]), .z(ain[88]), .d0(areg[88]), .s(x2));
mul_mux2 sh_87_ ( .d1(areg[88]), .z(ain[87]), .d0(areg[87]), .s(x2));
mul_mux2 sh_86_ ( .d1(areg[87]), .z(ain[86]), .d0(areg[86]), .s(x2));
mul_mux2 sh_85_ ( .d1(areg[86]), .z(ain[85]), .d0(areg[85]), .s(x2));
mul_mux2 sh_84_ ( .d1(areg[85]), .z(ain[84]), .d0(areg[84]), .s(x2));
mul_mux2 sh_0_ ( .d1(areg[1]), .z(ain[0]), .d0(areg[0]), .s(x2));
mul_mux2 sh_81_ ( .d1(areg[82]), .z(ain[81]), .d0(areg[81]), .s(x2));
mul_mux2 sh_80_ ( .d1(areg[81]), .z(ain[80]), .d0(areg[80]), .s(x2));
mul_mux2 sh_79_ ( .d1(areg[80]), .z(ain[79]), .d0(areg[79]), .s(x2));
mul_mux2 sh_78_ ( .d1(areg[79]), .z(ain[78]), .d0(areg[78]), .s(x2));
mul_mux2 sh_77_ ( .d1(areg[78]), .z(ain[77]), .d0(areg[77]), .s(x2));
mul_mux2 sh_76_ ( .d1(areg[77]), .z(ain[76]), .d0(areg[76]), .s(x2));
mul_mux2 sh_75_ ( .d1(areg[76]), .z(ain[75]), .d0(areg[75]), .s(x2));
mul_mux2 sh_74_ ( .d1(areg[75]), .z(ain[74]), .d0(areg[74]), .s(x2));
mul_mux2 sh_73_ ( .d1(areg[74]), .z(ain[73]), .d0(areg[73]), .s(x2));
mul_mux2 sh_72_ ( .d1(areg[73]), .z(ain[72]), .d0(areg[72]), .s(x2));
mul_mux2 sh_71_ ( .d1(areg[72]), .z(ain[71]), .d0(areg[71]), .s(x2));
mul_mux2 sh_70_ ( .d1(areg[71]), .z(ain[70]), .d0(areg[70]), .s(x2));
mul_mux2 sh_69_ ( .d1(areg[70]), .z(ain[69]), .d0(areg[69]), .s(x2));
mul_mux2 sh_19_ ( .d1(areg[20]), .z(ain[19]), .d0(areg[19]), .s(x2));
mul_mux2 sh_18_ ( .d1(areg[19]), .z(ain[18]), .d0(areg[18]), .s(x2));
mul_mux2 sh_17_ ( .d1(areg[18]), .z(ain[17]), .d0(areg[17]), .s(x2));
mul_mux2 sh_16_ ( .d1(areg[17]), .z(ain[16]), .d0(areg[16]), .s(x2));
mul_mux2 sh_15_ ( .d1(areg[16]), .z(ain[15]), .d0(areg[15]), .s(x2));
mul_mux2 sh_4_ ( .d1(areg[5]), .z(ain[4]), .d0(areg[4]), .s(x2));
mul_mux2 sh_3_ ( .d1(areg[4]), .z(ain[3]), .d0(areg[3]), .s(x2));
mul_mux2 sh_2_ ( .d1(areg[3]), .z(ain[2]), .d0(areg[2]), .s(x2));
mul_mux2 sh_1_ ( .d1(areg[2]), .z(ain[1]), .d0(areg[1]), .s(x2));
mul_mux2 shx2 ( .d1(areg[0]), .z(ainx2), .d0(1'b0),
     .s(x2));
mul_mux2 sh_83_ ( .d1(areg[84]), .z(ain[83]), .d0(areg[83]), .s(x2));
mul_mux2 sh_14_ ( .d1(areg[15]), .z(ain[14]), .d0(areg[14]), .s(x2));
mul_mux2 sh_13_ ( .d1(areg[14]), .z(ain[13]), .d0(areg[13]), .s(x2));
mul_mux2 sh_12_ ( .d1(areg[13]), .z(ain[12]), .d0(areg[12]), .s(x2));
mul_mux2 sh_11_ ( .d1(areg[12]), .z(ain[11]), .d0(areg[11]), .s(x2));
mul_mux2 sh_10_ ( .d1(areg[11]), .z(ain[10]), .d0(areg[10]), .s(x2));
mul_mux2 sh_9_ ( .d1(areg[10]), .z(ain[9]), .d0(areg[9]), .s(x2));
mul_mux2 sh_8_ ( .d1(areg[9]), .z(ain[8]), .d0(areg[8]), .s(x2));
mul_mux2 sh_7_ ( .d1(areg[8]), .z(ain[7]), .d0(areg[7]), .s(x2));
mul_mux2 sh_6_ ( .d1(areg[7]), .z(ain[6]), .d0(areg[6]), .s(x2));
mul_mux2 sh_5_ ( .d1(areg[6]), .z(ain[5]), .d0(areg[5]), .s(x2));
mul_csa42  sc3_68_ ( .cin(co[67]), .d(1'b0),
     .carry(c3[68]), .c(c2[67]), .b(s2[68]), .a(1'b0),
     .cout(), .sum(s3[68]));
mul_csa42  sc3_67_ ( .cin(co[66]), .d(1'b0),
     .carry(c3[67]), .c(c2[66]), .b(s2[67]), .a(s1[67]), .cout(co[67]),
     .sum(s3[67]));
mul_csa42  sc3_66_ ( .cin(co[65]), .d(c1[65]), .carry(c3[66]),
     .c(c2[65]), .b(s2[66]), .a(s1[66]), .cout(co[66]), .sum(s3[66]));
mul_csa42  sc3_65_ ( .cin(co[64]), .d(c1[64]), .carry(c3[65]),
     .c(c2[64]), .b(s2[65]), .a(s1[65]), .cout(co[65]), .sum(s3[65]));
mul_csa42  sc3_64_ ( .cin(co[63]), .d(c1[63]), .carry(c3[64]),
     .c(c2[63]), .b(s2[64]), .a(s1[64]), .cout(co[64]), .sum(s3[64]));
mul_csa42  sc3_63_ ( .cin(co[62]), .d(c1[62]), .carry(c3[63]),
     .c(c2[62]), .b(s2[63]), .a(s1[63]), .cout(co[63]), .sum(s3[63]));
mul_csa42  sc3_62_ ( .cin(co[61]), .d(c1[61]), .carry(c3[62]),
     .c(c2[61]), .b(s2[62]), .a(s1[62]), .cout(co[62]), .sum(s3[62]));
mul_csa42  sc3_61_ ( .cin(co[60]), .d(c1[60]), .carry(c3[61]),
     .c(c2[60]), .b(s2[61]), .a(s1[61]), .cout(co[61]), .sum(s3[61]));
mul_csa42  sc3_60_ ( .cin(co[59]), .d(c1[59]), .carry(c3[60]),
     .c(c2[59]), .b(s2[60]), .a(s1[60]), .cout(co[60]), .sum(s3[60]));
mul_csa42  sc3_59_ ( .cin(co[58]), .d(c1[58]), .carry(c3[59]),
     .c(c2[58]), .b(s2[59]), .a(s1[59]), .cout(co[59]), .sum(s3[59]));
mul_csa42  sc3_58_ ( .cin(co[57]), .d(c1[57]), .carry(c3[58]),
     .c(c2[57]), .b(s2[58]), .a(s1[58]), .cout(co[58]), .sum(s3[58]));
mul_csa42  sc3_57_ ( .cin(co[56]), .d(c1[56]), .carry(c3[57]),
     .c(c2[56]), .b(s2[57]), .a(s1[57]), .cout(co[57]), .sum(s3[57]));
mul_csa42  sc3_56_ ( .cin(co[55]), .d(c1[55]), .carry(c3[56]),
     .c(c2[55]), .b(s2[56]), .a(s1[56]), .cout(co[56]), .sum(s3[56]));
mul_csa42  sc3_55_ ( .cin(co[54]), .d(c1[54]), .carry(c3[55]),
     .c(c2[54]), .b(s2[55]), .a(s1[55]), .cout(co[55]), .sum(s3[55]));
mul_csa42  sc3_54_ ( .cin(co[53]), .d(c1[53]), .carry(c3[54]),
     .c(c2[53]), .b(s2[54]), .a(s1[54]), .cout(co[54]), .sum(s3[54]));
mul_csa42  sc3_53_ ( .cin(co[52]), .d(c1[52]), .carry(c3[53]),
     .c(c2[52]), .b(s2[53]), .a(s1[53]), .cout(co[53]), .sum(s3[53]));
mul_csa42  sc3_52_ ( .cin(co[51]), .d(c1[51]), .carry(c3[52]),
     .c(c2[51]), .b(s2[52]), .a(s1[52]), .cout(co[52]), .sum(s3[52]));
mul_csa42  sc3_51_ ( .cin(co[50]), .d(c1[50]), .carry(c3[51]),
     .c(c2[50]), .b(s2[51]), .a(s1[51]), .cout(co[51]), .sum(s3[51]));
mul_csa42  sc3_50_ ( .cin(co[49]), .d(c1[49]), .carry(c3[50]),
     .c(c2[49]), .b(s2[50]), .a(s1[50]), .cout(co[50]), .sum(s3[50]));
mul_csa42  sc3_49_ ( .cin(co[48]), .d(c1[48]), .carry(c3[49]),
     .c(c2[48]), .b(s2[49]), .a(s1[49]), .cout(co[49]), .sum(s3[49]));
mul_csa42  sc3_48_ ( .cin(co[47]), .d(c1[47]), .carry(c3[48]),
     .c(c2[47]), .b(s2[48]), .a(s1[48]), .cout(co[48]), .sum(s3[48]));
mul_csa42  sc3_47_ ( .cin(co[46]), .d(c1[46]), .carry(c3[47]),
     .c(c2[46]), .b(s2[47]), .a(s1[47]), .cout(co[47]), .sum(s3[47]));
mul_csa42  sc3_46_ ( .cin(co[45]), .d(c1[45]), .carry(c3[46]),
     .c(c2[45]), .b(s2[46]), .a(s1[46]), .cout(co[46]), .sum(s3[46]));
mul_csa42  sc3_45_ ( .cin(co[44]), .d(c1[44]), .carry(c3[45]),
     .c(c2[44]), .b(s2[45]), .a(s1[45]), .cout(co[45]), .sum(s3[45]));
mul_csa42  sc3_44_ ( .cin(co[43]), .d(c1[43]), .carry(c3[44]),
     .c(c2[43]), .b(s2[44]), .a(s1[44]), .cout(co[44]), .sum(s3[44]));
mul_csa42  sc3_43_ ( .cin(co[42]), .d(c1[42]), .carry(c3[43]),
     .c(c2[42]), .b(s2[43]), .a(s1[43]), .cout(co[43]), .sum(s3[43]));
mul_csa42  sc3_42_ ( .cin(co[41]), .d(c1[41]), .carry(c3[42]),
     .c(c2[41]), .b(s2[42]), .a(s1[42]), .cout(co[42]), .sum(s3[42]));
mul_csa42  sc3_41_ ( .cin(co[40]), .d(c1[40]), .carry(c3[41]),
     .c(c2[40]), .b(s2[41]), .a(s1[41]), .cout(co[41]), .sum(s3[41]));
mul_csa42  sc3_40_ ( .cin(co[39]), .d(c1[39]), .carry(c3[40]),
     .c(c2[39]), .b(s2[40]), .a(s1[40]), .cout(co[40]), .sum(s3[40]));
mul_csa42  sc3_39_ ( .cin(co[38]), .d(c1[38]), .carry(c3[39]),
     .c(c2[38]), .b(s2[39]), .a(s1[39]), .cout(co[39]), .sum(s3[39]));
mul_csa42  sc3_38_ ( .cin(co[37]), .d(c1[37]), .carry(c3[38]),
     .c(c2[37]), .b(s2[38]), .a(s1[38]), .cout(co[38]), .sum(s3[38]));
mul_csa42  sc3_37_ ( .cin(co[36]), .d(c1[36]), .carry(c3[37]),
     .c(c2[36]), .b(s2[37]), .a(s1[37]), .cout(co[37]), .sum(s3[37]));
mul_csa42  sc3_36_ ( .cin(co[35]), .d(c1[35]), .carry(c3[36]),
     .c(c2[35]), .b(s2[36]), .a(s1[36]), .cout(co[36]), .sum(s3[36]));
mul_csa42  sc3_35_ ( .cin(co[34]), .d(c1[34]), .carry(c3[35]),
     .c(c2[34]), .b(s2[35]), .a(s1[35]), .cout(co[35]), .sum(s3[35]));
mul_csa42  sc3_34_ ( .cin(co[33]), .d(c1[33]), .carry(c3[34]),
     .c(c2[33]), .b(s2[34]), .a(s1[34]), .cout(co[34]), .sum(s3[34]));
mul_csa42  sc3_33_ ( .cin(co[32]), .d(c1[32]), .carry(c3[33]),
     .c(c2[32]), .b(s2[33]), .a(s1[33]), .cout(co[33]), .sum(s3[33]));
mul_csa42  sc3_32_ ( .cin(co[31]), .d(c1[31]), .carry(c3[32]),
     .c(c2[31]), .b(s2[32]), .a(s1[32]), .cout(co[32]), .sum(s3[32]));
mul_csa42  sc3_31_ ( .cin(co[30]), .d(c1[30]), .carry(c3[31]),
     .c(c2[30]), .b(s2[31]), .a(s1[31]), .cout(co[31]), .sum(s3[31]));
mul_csa42  sc3_30_ ( .cin(co[29]), .d(c1[29]), .carry(c3[30]),
     .c(c2[29]), .b(s2[30]), .a(s1[30]), .cout(co[30]), .sum(s3[30]));
mul_csa42  sc3_29_ ( .cin(co[28]), .d(c1[28]), .carry(c3[29]),
     .c(c2[28]), .b(s2[29]), .a(s1[29]), .cout(co[29]), .sum(s3[29]));
mul_csa42  sc3_28_ ( .cin(co[27]), .d(c1[27]), .carry(c3[28]),
     .c(c2[27]), .b(s2[28]), .a(s1[28]), .cout(co[28]), .sum(s3[28]));
mul_csa42  sc3_27_ ( .cin(co[26]), .d(c1[26]), .carry(c3[27]),
     .c(c2[26]), .b(s2[27]), .a(s1[27]), .cout(co[27]), .sum(s3[27]));
mul_csa42  sc3_26_ ( .cin(co[25]), .d(c1[25]), .carry(c3[26]),
     .c(c2[25]), .b(s2[26]), .a(s1[26]), .cout(co[26]), .sum(s3[26]));
mul_csa42  sc3_25_ ( .cin(co[24]), .d(c1[24]), .carry(c3[25]),
     .c(c2[24]), .b(s2[25]), .a(s1[25]), .cout(co[25]), .sum(s3[25]));
mul_csa42  sc3_24_ ( .cin(co[23]), .d(c1[23]), .carry(c3[24]),
     .c(c2[23]), .b(s2[24]), .a(s1[24]), .cout(co[24]), .sum(s3[24]));
mul_csa42  sc3_23_ ( .cin(co[22]), .d(c1[22]), .carry(c3[23]),
     .c(c2[22]), .b(s2[23]), .a(s1[23]), .cout(co[23]), .sum(s3[23]));
mul_csa42  sc3_22_ ( .cin(co[21]), .d(c1[21]), .carry(c3[22]),
     .c(c2[21]), .b(s2[22]), .a(s1[22]), .cout(co[22]), .sum(s3[22]));
mul_csa42  sc3_21_ ( .cin(co[20]), .d(c1[20]), .carry(c3[21]),
     .c(c2[20]), .b(s2[21]), .a(s1[21]), .cout(co[21]), .sum(s3[21]));
mul_csa42  sc3_20_ ( .cin(1'b0), .d(c1[19]),
     .carry(c3[20]), .c(c2[19]), .b(s2[20]), .a(s1[20]), .cout(co[20]),
     .sum(s3[20]));
mul_csa32  sc4_82_ ( .c(c3[81]), .b(s2[82]), .a(ain[82]),
     .cout(pcout[82]), .sum(psum[82]));
mul_csa32  sc4_68_ ( .c(c3[67]), .b(s3[68]), .a(ain[68]),
     .cout(pcout[68]), .sum(psum[68]));
mul_csa32  sc4_67_ ( .c(c3[66]), .b(s3[67]), .a(ain[67]),
     .cout(pcout[67]), .sum(psum[67]));
mul_csa32  sc4_66_ ( .c(c3[65]), .b(s3[66]), .a(ain[66]),
     .cout(pcout[66]), .sum(psum[66]));
mul_csa32  sc4_65_ ( .c(c3[64]), .b(s3[65]), .a(ain[65]),
     .cout(pcout[65]), .sum(psum[65]));
mul_csa32  sc4_64_ ( .c(c3[63]), .b(s3[64]), .a(ain[64]),
     .cout(pcout[64]), .sum(psum[64]));
mul_csa32  sc4_63_ ( .c(c3[62]), .b(s3[63]), .a(ain[63]),
     .cout(pcout[63]), .sum(psum[63]));
mul_csa32  sc4_62_ ( .c(c3[61]), .b(s3[62]), .a(ain[62]),
     .cout(pcout[62]), .sum(psum[62]));
mul_csa32  sc4_61_ ( .c(c3[60]), .b(s3[61]), .a(ain[61]),
     .cout(pcout[61]), .sum(psum[61]));
mul_csa32  sc4_60_ ( .c(c3[59]), .b(s3[60]), .a(ain[60]),
     .cout(pcout[60]), .sum(psum[60]));
mul_csa32  sc4_59_ ( .c(c3[58]), .b(s3[59]), .a(ain[59]),
     .cout(pcout[59]), .sum(psum[59]));
mul_csa32  sc4_58_ ( .c(c3[57]), .b(s3[58]), .a(ain[58]),
     .cout(pcout[58]), .sum(psum[58]));
mul_csa32  sc4_57_ ( .c(c3[56]), .b(s3[57]), .a(ain[57]),
     .cout(pcout[57]), .sum(psum[57]));
mul_csa32  sc4_56_ ( .c(c3[55]), .b(s3[56]), .a(ain[56]),
     .cout(pcout[56]), .sum(psum[56]));
mul_csa32  sc4_55_ ( .c(c3[54]), .b(s3[55]), .a(ain[55]),
     .cout(pcout[55]), .sum(psum[55]));
mul_csa32  sc4_54_ ( .c(c3[53]), .b(s3[54]), .a(ain[54]),
     .cout(pcout[54]), .sum(psum[54]));
mul_csa32  sc4_53_ ( .c(c3[52]), .b(s3[53]), .a(ain[53]),
     .cout(pcout[53]), .sum(psum[53]));
mul_csa32  sc4_52_ ( .c(c3[51]), .b(s3[52]), .a(ain[52]),
     .cout(pcout[52]), .sum(psum[52]));
mul_csa32  sc4_51_ ( .c(c3[50]), .b(s3[51]), .a(ain[51]),
     .cout(pcout[51]), .sum(psum[51]));
mul_csa32  sc4_50_ ( .c(c3[49]), .b(s3[50]), .a(ain[50]),
     .cout(pcout[50]), .sum(psum[50]));
mul_csa32  sc4_49_ ( .c(c3[48]), .b(s3[49]), .a(ain[49]),
     .cout(pcout[49]), .sum(psum[49]));
mul_csa32  sc4_48_ ( .c(c3[47]), .b(s3[48]), .a(ain[48]),
     .cout(pcout[48]), .sum(psum[48]));
mul_csa32  sc4_47_ ( .c(c3[46]), .b(s3[47]), .a(ain[47]),
     .cout(pcout[47]), .sum(psum[47]));
mul_csa32  sc4_46_ ( .c(c3[45]), .b(s3[46]), .a(ain[46]),
     .cout(pcout[46]), .sum(psum[46]));
mul_csa32  sc4_45_ ( .c(c3[44]), .b(s3[45]), .a(ain[45]),
     .cout(pcout[45]), .sum(psum[45]));
mul_csa32  sc4_44_ ( .c(c3[43]), .b(s3[44]), .a(ain[44]),
     .cout(pcout[44]), .sum(psum[44]));
mul_csa32  sc4_43_ ( .c(c3[42]), .b(s3[43]), .a(ain[43]),
     .cout(pcout[43]), .sum(psum[43]));
mul_csa32  sc4_42_ ( .c(c3[41]), .b(s3[42]), .a(ain[42]),
     .cout(pcout[42]), .sum(psum[42]));
mul_csa32  sc4_41_ ( .c(c3[40]), .b(s3[41]), .a(ain[41]),
     .cout(pcout[41]), .sum(psum[41]));
mul_csa32  sc4_40_ ( .c(c3[39]), .b(s3[40]), .a(ain[40]),
     .cout(pcout[40]), .sum(psum[40]));
mul_csa32  sc4_39_ ( .c(c3[38]), .b(s3[39]), .a(ain[39]),
     .cout(pcout[39]), .sum(psum[39]));
mul_csa32  sc4_38_ ( .c(c3[37]), .b(s3[38]), .a(ain[38]),
     .cout(pcout[38]), .sum(psum[38]));
mul_csa32  sc4_37_ ( .c(c3[36]), .b(s3[37]), .a(ain[37]),
     .cout(pcout[37]), .sum(psum[37]));
mul_csa32  sc4_36_ ( .c(c3[35]), .b(s3[36]), .a(ain[36]),
     .cout(pcout[36]), .sum(psum[36]));
mul_csa32  sc4_35_ ( .c(c3[34]), .b(s3[35]), .a(ain[35]),
     .cout(pcout[35]), .sum(psum[35]));
mul_csa32  sc4_34_ ( .c(c3[33]), .b(s3[34]), .a(ain[34]),
     .cout(pcout[34]), .sum(psum[34]));
mul_csa32  sc4_33_ ( .c(c3[32]), .b(s3[33]), .a(ain[33]),
     .cout(pcout[33]), .sum(psum[33]));
mul_csa32  sc4_32_ ( .c(c3[31]), .b(s3[32]), .a(ain[32]),
     .cout(pcout[32]), .sum(psum[32]));
mul_csa32  sc4_31_ ( .c(c3[30]), .b(s3[31]), .a(ain[31]),
     .cout(pcout[31]), .sum(psum[31]));
mul_csa32  sc4_30_ ( .c(c3[29]), .b(s3[30]), .a(ain[30]),
     .cout(pcout[30]), .sum(psum[30]));
mul_csa32  sc4_29_ ( .c(c3[28]), .b(s3[29]), .a(ain[29]),
     .cout(pcout[29]), .sum(psum[29]));
mul_csa32  sc4_28_ ( .c(c3[27]), .b(s3[28]), .a(ain[28]),
     .cout(pcout[28]), .sum(psum[28]));
mul_csa32  sc4_27_ ( .c(c3[26]), .b(s3[27]), .a(ain[27]),
     .cout(pcout[27]), .sum(psum[27]));
mul_csa32  sc4_26_ ( .c(c3[25]), .b(s3[26]), .a(ain[26]),
     .cout(pcout[26]), .sum(psum[26]));
mul_csa32  sc4_25_ ( .c(c3[24]), .b(s3[25]), .a(ain[25]),
     .cout(pcout[25]), .sum(psum[25]));
mul_csa32  sc4_24_ ( .c(c3[23]), .b(s3[24]), .a(ain[24]),
     .cout(pcout[24]), .sum(psum[24]));
mul_csa32  sc4_23_ ( .c(c3[22]), .b(s3[23]), .a(ain[23]),
     .cout(pcout[23]), .sum(psum[23]));
mul_csa32  sc4_22_ ( .c(c3[21]), .b(s3[22]), .a(ain[22]),
     .cout(pcout[22]), .sum(psum[22]));
mul_csa32  sc4_21_ ( .c(c3[20]), .b(s3[21]), .a(ain[21]),
     .cout(pcout[21]), .sum(psum[21]));
mul_csa32  sc4_20_ ( .c(c3[19]), .b(s3[20]), .a(ain[20]),
     .cout(pcout[20]), .sum(psum[20]));
mul_csa32  sc4_96_ ( .c(c2[95]), .b(s2[96]), .a(ain[96]),
     .cout(pcout[96]), .sum(psum[96]));
mul_csa32  sc4_95_ ( .c(c2[94]), .b(s2[95]), .a(ain[95]),
     .cout(pcout[95]), .sum(psum[95]));
mul_csa32  sc4_94_ ( .c(c2[93]), .b(s2[94]), .a(ain[94]),
     .cout(pcout[94]), .sum(psum[94]));
mul_csa32  sc4_93_ ( .c(c2[92]), .b(s2[93]), .a(ain[93]),
     .cout(pcout[93]), .sum(psum[93]));
mul_csa32  sc4_92_ ( .c(c2[91]), .b(s2[92]), .a(ain[92]),
     .cout(pcout[92]), .sum(psum[92]));
mul_csa32  sc4_91_ ( .c(c2[90]), .b(s2[91]), .a(ain[91]),
     .cout(pcout[91]), .sum(psum[91]));
mul_csa32  sc4_90_ ( .c(c2[89]), .b(s2[90]), .a(ain[90]),
     .cout(pcout[90]), .sum(psum[90]));
mul_csa32  sc4_89_ ( .c(c2[88]), .b(s2[89]), .a(ain[89]),
     .cout(pcout[89]), .sum(psum[89]));
mul_csa32  sc4_88_ ( .c(c2[87]), .b(s2[88]), .a(ain[88]),
     .cout(pcout[88]), .sum(psum[88]));
mul_csa32  sc4_87_ ( .c(c2[86]), .b(s2[87]), .a(ain[87]),
     .cout(pcout[87]), .sum(psum[87]));
mul_csa32  sc4_86_ ( .c(c2[85]), .b(s2[86]), .a(ain[86]),
     .cout(pcout[86]), .sum(psum[86]));
mul_csa32  sc4_85_ ( .c(c2[84]), .b(s2[85]), .a(ain[85]),
     .cout(pcout[85]), .sum(psum[85]));
mul_csa32  sc4_84_ ( .c(c2[83]), .b(s2[84]), .a(ain[84]),
     .cout(pcout[84]), .sum(psum[84]));
mul_csa32  sc4_81_ ( .c(c3[80]), .b(s3[81]), .a(ain[81]),
     .cout(pcout[81]), .sum(psum[81]));
mul_csa32  sc4_80_ ( .c(c3[79]), .b(s3[80]), .a(ain[80]),
     .cout(pcout[80]), .sum(psum[80]));
mul_csa32  sc4_79_ ( .c(c3[78]), .b(s3[79]), .a(ain[79]),
     .cout(pcout[79]), .sum(psum[79]));
mul_csa32  sc4_78_ ( .c(c3[77]), .b(s3[78]), .a(ain[78]),
     .cout(pcout[78]), .sum(psum[78]));
mul_csa32  sc4_77_ ( .c(c3[76]), .b(s3[77]), .a(ain[77]),
     .cout(pcout[77]), .sum(psum[77]));
mul_csa32  sc4_76_ ( .c(c3[75]), .b(s3[76]), .a(ain[76]),
     .cout(pcout[76]), .sum(psum[76]));
mul_csa32  sc4_75_ ( .c(c3[74]), .b(s3[75]), .a(ain[75]),
     .cout(pcout[75]), .sum(psum[75]));
mul_csa32  sc4_74_ ( .c(c3[73]), .b(s3[74]), .a(ain[74]),
     .cout(pcout[74]), .sum(psum[74]));
mul_csa32  sc4_73_ ( .c(c3[72]), .b(s3[73]), .a(ain[73]),
     .cout(pcout[73]), .sum(psum[73]));
mul_csa32  sc4_72_ ( .c(c3[71]), .b(s3[72]), .a(ain[72]),
     .cout(pcout[72]), .sum(psum[72]));
mul_csa32  sc4_71_ ( .c(c3[70]), .b(s3[71]), .a(ain[71]),
     .cout(pcout[71]), .sum(psum[71]));
mul_csa32  sc4_70_ ( .c(c3[69]), .b(s3[70]), .a(ain[70]),
     .cout(pcout[70]), .sum(psum[70]));
mul_csa32  sc4_69_ ( .c(c3[68]), .b(s3[69]), .a(ain[69]),
     .cout(pcout[69]), .sum(psum[69]));
mul_csa32  acc_4_ ( .c(c2[3]), .sum(psum[4]), .cout(pcout[4]),
     .a(ain[4]), .b(s2[4]));
mul_csa32  acc_3_ ( .c(c2[2]), .sum(psum[3]), .cout(pcout[3]),
     .a(ain[3]), .b(s2[3]));
mul_csa32  acc_2_ ( .c(c2[1]), .sum(psum[2]), .cout(pcout[2]),
     .a(ain[2]), .b(s2[2]));
mul_csa32  acc_1_ ( .c(c2[0]), .sum(psum[1]), .cout(pcout[1]),
     .a(ain[1]), .b(s2[1]));
mul_csa32  sc3_97_ ( .c(c2[96]), .sum(psum[97]), .cout(pcout[97]),
     .a(a1s[81]), .b(a1c[80]));
mul_csa32  sc1_19_ ( .c(a1s[3]), .b(pc[50]), .a(ps[51]),
     .cout(c1[19]), .sum(s1[19]));
mul_csa32  sc1_18_ ( .c(a1s[2]), .b(pc[49]), .a(ps[50]),
     .cout(c1[18]), .sum(s1[18]));
mul_csa32  sc1_17_ ( .c(a1s[1]), .b(pc[48]), .a(ps[49]),
     .cout(c1[17]), .sum(s1[17]));
mul_csa32  sc1_16_ ( .c(a1s[0]), .b(pc[47]), .a(ps[48]),
     .cout(c1[16]), .sum(s1[16]));
mul_csa32  sc1_15_ ( .c(1'b0), .b(pc[46]), .a(ps[47]),
     .cout(c1[15]), .sum(s1[15]));
mul_csa32  sc4_83_ ( .c(c2[82]), .b(s2[83]), .a(ain[83]),
     .cout(pcout[83]), .sum(psum[83]));
mul_csa32  sc2_83_ ( .c(c1[82]), .b(a1c[66]), .a(a1s[67]),
     .cout(c2[83]), .sum(s2[83]));
mul_csa32  sc2_19_ ( .c(a0c[18]), .b(a0s[19]), .a(s1[19]),
     .cout(c2[19]), .sum(s2[19]));
mul_csa32  sc2_18_ ( .c(a0c[17]), .b(a0s[18]), .a(s1[18]),
     .cout(c2[18]), .sum(s2[18]));
mul_csa32  sc2_17_ ( .c(a0c[16]), .b(a0s[17]), .a(s1[17]),
     .cout(c2[17]), .sum(s2[17]));
mul_csa32  sc2_16_ ( .c(a0c[15]), .b(a0s[16]), .a(s1[16]),
     .cout(c2[16]), .sum(s2[16]));
mul_csa32  sc2_15_ ( .c(a0c[14]), .b(a0s[15]), .a(s1[15]),
     .cout(c2[15]), .sum(s2[15]));
mul_csa32  sc1_81_ ( .c(a0s[81]), .b(a1c[64]), .a(a1s[65]),
     .cout(c1[81]), .sum(s1[81]));
mul_csa32  sc1_80_ ( .c(a0s[80]), .b(a1c[63]), .a(a1s[64]),
     .cout(c1[80]), .sum(s1[80]));
mul_csa32  sc1_79_ ( .c(a0s[79]), .b(a1c[62]), .a(a1s[63]),
     .cout(c1[79]), .sum(s1[79]));
mul_csa32  sc1_78_ ( .c(a0s[78]), .b(a1c[61]), .a(a1s[62]),
     .cout(c1[78]), .sum(s1[78]));
mul_csa32  sc1_77_ ( .c(a0s[77]), .b(a1c[60]), .a(a1s[61]),
     .cout(c1[77]), .sum(s1[77]));
mul_csa32  sc1_76_ ( .c(a0s[76]), .b(a1c[59]), .a(a1s[60]),
     .cout(c1[76]), .sum(s1[76]));
mul_csa32  sc1_75_ ( .c(a0s[75]), .b(a1c[58]), .a(a1s[59]),
     .cout(c1[75]), .sum(s1[75]));
mul_csa32  sc1_74_ ( .c(a0s[74]), .b(a1c[57]), .a(a1s[58]),
     .cout(c1[74]), .sum(s1[74]));
mul_csa32  sc1_73_ ( .c(a0s[73]), .b(a1c[56]), .a(a1s[57]),
     .cout(c1[73]), .sum(s1[73]));
mul_csa32  sc1_72_ ( .c(a0s[72]), .b(a1c[55]), .a(a1s[56]),
     .cout(c1[72]), .sum(s1[72]));
mul_csa32  sc1_71_ ( .c(a0s[71]), .b(a1c[54]), .a(a1s[55]),
     .cout(c1[71]), .sum(s1[71]));
mul_csa32  sc1_70_ ( .c(a0s[70]), .b(a1c[53]), .a(a1s[54]),
     .cout(c1[70]), .sum(s1[70]));
mul_csa32  sc1_69_ ( .c(a0s[69]), .b(a1c[52]), .a(a1s[53]),
     .cout(c1[69]), .sum(s1[69]));
mul_csa32  sc1_68_ ( .c(a0s[68]), .b(a1c[51]), .a(a1s[52]),
     .cout(c1[68]), .sum(s1[68]));
mul_csa32  sc3_19_ ( .c(c2[18]), .b(c1[18]), .a(s2[19]),
     .cout(c3[19]), .sum(s3[19]));
mul_csa32  sc3_18_ ( .c(c2[17]), .b(c1[17]), .a(s2[18]),
     .cout(c3[18]), .sum(s3[18]));
mul_csa32  sc3_17_ ( .c(c2[16]), .b(c1[16]), .a(s2[17]),
     .cout(c3[17]), .sum(s3[17]));
mul_csa32  sc3_16_ ( .c(c2[15]), .b(c1[15]), .a(s2[16]),
     .cout(c3[16]), .sum(s3[16]));
mul_csa32  sc3_15_ ( .c(c2[14]), .b(c1[14]), .a(s2[15]),
     .cout(c3[15]), .sum(s3[15]));
mul_csa32  sc1_82_ ( .c(a0c[81]), .b(a1c[65]), .a(a1s[66]),
     .cout(c1[82]), .sum(s1[82]));
mul_csa32  acc_14_ ( .c(c2[13]), .sum(psum[14]), .cout(pcout[14]),
     .a(ain[14]), .b(s2[14]));
mul_csa32  acc_13_ ( .c(c2[12]), .sum(psum[13]), .cout(pcout[13]),
     .a(ain[13]), .b(s2[13]));
mul_csa32  acc_12_ ( .c(c2[11]), .sum(psum[12]), .cout(pcout[12]),
     .a(ain[12]), .b(s2[12]));
mul_csa32  acc_11_ ( .c(c2[10]), .sum(psum[11]), .cout(pcout[11]),
     .a(ain[11]), .b(s2[11]));
mul_csa32  acc_10_ ( .c(c2[9]), .sum(psum[10]), .cout(pcout[10]),
     .a(ain[10]), .b(s2[10]));
mul_csa32  acc_9_ ( .c(c2[8]), .sum(psum[9]), .cout(pcout[9]),
     .a(ain[9]), .b(s2[9]));
mul_csa32  acc_8_ ( .c(c2[7]), .sum(psum[8]), .cout(pcout[8]),
     .a(ain[8]), .b(s2[8]));
mul_csa32  acc_7_ ( .c(c2[6]), .sum(psum[7]), .cout(pcout[7]),
     .a(ain[7]), .b(s2[7]));
mul_csa32  acc_6_ ( .c(c2[5]), .sum(psum[6]), .cout(pcout[6]),
     .a(ain[6]), .b(s2[6]));
mul_csa32  acc_5_ ( .c(c2[4]), .sum(psum[5]), .cout(pcout[5]),
     .a(ain[5]), .b(s2[5]));
mul_csa32  sc2_67_ ( .c(a0c[66]), .b(c1[66]), .a(a0s[67]),
     .cout(c2[67]), .sum(s2[67]));
mul_csa32  sc1_14_ ( .c(a0s[14]), .b(pc[45]), .a(ps[46]),
     .cout(c1[14]), .sum(s1[14]));
mul_csa32  sc1_13_ ( .c(a0s[13]), .b(pc[44]), .a(ps[45]),
     .cout(c1[13]), .sum(s1[13]));
mul_csa32  sc1_12_ ( .c(a0s[12]), .b(pc[43]), .a(ps[44]),
     .cout(c1[12]), .sum(s1[12]));
mul_csa32  sc1_11_ ( .c(a0s[11]), .b(pc[42]), .a(ps[43]),
     .cout(c1[11]), .sum(s1[11]));
mul_csa32  sc1_10_ ( .c(a0s[10]), .b(pc[41]), .a(ps[42]),
     .cout(c1[10]), .sum(s1[10]));
mul_csa32  sc1_9_ ( .c(a0s[9]), .b(pc[40]), .a(ps[41]), .cout(c1[9]),
     .sum(s1[9]));
mul_csa32  sc1_8_ ( .c(a0s[8]), .b(pc[39]), .a(ps[40]), .cout(c1[8]),
     .sum(s1[8]));
mul_csa32  sc1_7_ ( .c(a0s[7]), .b(pc[38]), .a(ps[39]), .cout(c1[7]),
     .sum(s1[7]));
mul_csa32  sc1_6_ ( .c(a0s[6]), .b(pc[37]), .a(ps[38]), .cout(c1[6]),
     .sum(s1[6]));
mul_csa32  sc1_5_ ( .c(a0s[5]), .b(pc[36]), .a(ps[37]), .cout(c1[5]),
     .sum(s1[5]));
mul_csa32  sc2_14_ ( .c(a0c[13]), .b(c1[13]), .a(s1[14]),
     .cout(c2[14]), .sum(s2[14]));
mul_csa32  sc2_13_ ( .c(a0c[12]), .b(c1[12]), .a(s1[13]),
     .cout(c2[13]), .sum(s2[13]));
mul_csa32  sc2_12_ ( .c(a0c[11]), .b(c1[11]), .a(s1[12]),
     .cout(c2[12]), .sum(s2[12]));
mul_csa32  sc2_11_ ( .c(a0c[10]), .b(c1[10]), .a(s1[11]),
     .cout(c2[11]), .sum(s2[11]));
mul_csa32  sc2_10_ ( .c(a0c[9]), .b(c1[9]), .a(s1[10]),
     .cout(c2[10]), .sum(s2[10]));
mul_csa32  sc2_9_ ( .c(a0c[8]), .b(c1[8]), .a(s1[9]), .cout(c2[9]),
     .sum(s2[9]));
mul_csa32  sc2_8_ ( .c(a0c[7]), .b(c1[7]), .a(s1[8]), .cout(c2[8]),
     .sum(s2[8]));
mul_csa32  sc2_7_ ( .c(a0c[6]), .b(c1[6]), .a(s1[7]), .cout(c2[7]),
     .sum(s2[7]));
mul_csa32  sc2_6_ ( .c(a0c[5]), .b(c1[5]), .a(s1[6]), .cout(c2[6]),
     .sum(s2[6]));
mul_csa32  sc2_5_ ( .c(a0c[4]), .b(c1[4]), .a(s1[5]), .cout(c2[5]),
     .sum(s2[5]));
mul_csa32  sc2_82_ ( .c(c2[81]), .b(c1[81]), .a(s1[82]),
     .cout(c2[82]), .sum(s2[82]));
mul_csa32  sc1_4_ ( .c(a0s[4]), .b(pc[35]), .a(ps[36]), .cout(c1[4]),
     .sum(s1[4]));
mul_csa32  sc1_3_ ( .c(a0s[3]), .b(pc[34]), .a(ps[35]), .cout(c1[3]),
     .sum(s1[3]));
mul_csa32  sc1_2_ ( .c(a0s[2]), .b(pc[33]), .a(ps[34]), .cout(c1[2]),
     .sum(s1[2]));
mul_csa32  sc1_1_ ( .c(a0s[1]), .b(pc[32]), .a(ps[33]), .cout(c1[1]),
     .sum(s1[1]));
mul_csa32  sc2_66_ ( .c(a0c[65]), .b(a0s[66]), .a(a1c[49]),
     .cout(c2[66]), .sum(s2[66]));
mul_csa32  sc2_65_ ( .c(a0c[64]), .b(a0s[65]), .a(a1c[48]),
     .cout(c2[65]), .sum(s2[65]));
mul_csa32  sc2_64_ ( .c(a0c[63]), .b(a0s[64]), .a(a1c[47]),
     .cout(c2[64]), .sum(s2[64]));
mul_csa32  sc2_63_ ( .c(a0c[62]), .b(a0s[63]), .a(a1c[46]),
     .cout(c2[63]), .sum(s2[63]));
mul_csa32  sc2_62_ ( .c(a0c[61]), .b(a0s[62]), .a(a1c[45]),
     .cout(c2[62]), .sum(s2[62]));
mul_csa32  sc2_61_ ( .c(a0c[60]), .b(a0s[61]), .a(a1c[44]),
     .cout(c2[61]), .sum(s2[61]));
mul_csa32  sc2_60_ ( .c(a0c[59]), .b(a0s[60]), .a(a1c[43]),
     .cout(c2[60]), .sum(s2[60]));
mul_csa32  sc2_59_ ( .c(a0c[58]), .b(a0s[59]), .a(a1c[42]),
     .cout(c2[59]), .sum(s2[59]));
mul_csa32  sc2_58_ ( .c(a0c[57]), .b(a0s[58]), .a(a1c[41]),
     .cout(c2[58]), .sum(s2[58]));
mul_csa32  sc2_57_ ( .c(a0c[56]), .b(a0s[57]), .a(a1c[40]),
     .cout(c2[57]), .sum(s2[57]));
mul_csa32  sc2_56_ ( .c(a0c[55]), .b(a0s[56]), .a(a1c[39]),
     .cout(c2[56]), .sum(s2[56]));
mul_csa32  sc2_55_ ( .c(a0c[54]), .b(a0s[55]), .a(a1c[38]),
     .cout(c2[55]), .sum(s2[55]));
mul_csa32  sc2_54_ ( .c(a0c[53]), .b(a0s[54]), .a(a1c[37]),
     .cout(c2[54]), .sum(s2[54]));
mul_csa32  sc2_53_ ( .c(a0c[52]), .b(a0s[53]), .a(a1c[36]),
     .cout(c2[53]), .sum(s2[53]));
mul_csa32  sc2_52_ ( .c(a0c[51]), .b(a0s[52]), .a(a1c[35]),
     .cout(c2[52]), .sum(s2[52]));
mul_csa32  sc2_51_ ( .c(a0c[50]), .b(a0s[51]), .a(a1c[34]),
     .cout(c2[51]), .sum(s2[51]));
mul_csa32  sc2_50_ ( .c(a0c[49]), .b(a0s[50]), .a(a1c[33]),
     .cout(c2[50]), .sum(s2[50]));
mul_csa32  sc2_49_ ( .c(a0c[48]), .b(a0s[49]), .a(a1c[32]),
     .cout(c2[49]), .sum(s2[49]));
mul_csa32  sc2_48_ ( .c(a0c[47]), .b(a0s[48]), .a(a1c[31]),
     .cout(c2[48]), .sum(s2[48]));
mul_csa32  sc2_47_ ( .c(a0c[46]), .b(a0s[47]), .a(a1c[30]),
     .cout(c2[47]), .sum(s2[47]));
mul_csa32  sc2_46_ ( .c(a0c[45]), .b(a0s[46]), .a(a1c[29]),
     .cout(c2[46]), .sum(s2[46]));
mul_csa32  sc2_45_ ( .c(a0c[44]), .b(a0s[45]), .a(a1c[28]),
     .cout(c2[45]), .sum(s2[45]));
mul_csa32  sc2_44_ ( .c(a0c[43]), .b(a0s[44]), .a(a1c[27]),
     .cout(c2[44]), .sum(s2[44]));
mul_csa32  sc2_43_ ( .c(a0c[42]), .b(a0s[43]), .a(a1c[26]),
     .cout(c2[43]), .sum(s2[43]));
mul_csa32  sc2_42_ ( .c(a0c[41]), .b(a0s[42]), .a(a1c[25]),
     .cout(c2[42]), .sum(s2[42]));
mul_csa32  sc2_41_ ( .c(a0c[40]), .b(a0s[41]), .a(a1c[24]),
     .cout(c2[41]), .sum(s2[41]));
mul_csa32  sc2_40_ ( .c(a0c[39]), .b(a0s[40]), .a(a1c[23]),
     .cout(c2[40]), .sum(s2[40]));
mul_csa32  sc2_39_ ( .c(a0c[38]), .b(a0s[39]), .a(a1c[22]),
     .cout(c2[39]), .sum(s2[39]));
mul_csa32  sc2_38_ ( .c(a0c[37]), .b(a0s[38]), .a(a1c[21]),
     .cout(c2[38]), .sum(s2[38]));
mul_csa32  sc2_37_ ( .c(a0c[36]), .b(a0s[37]), .a(a1c[20]),
     .cout(c2[37]), .sum(s2[37]));
mul_csa32  sc2_36_ ( .c(a0c[35]), .b(a0s[36]), .a(a1c[19]),
     .cout(c2[36]), .sum(s2[36]));
mul_csa32  sc2_35_ ( .c(a0c[34]), .b(a0s[35]), .a(a1c[18]),
     .cout(c2[35]), .sum(s2[35]));
mul_csa32  sc2_34_ ( .c(a0c[33]), .b(a0s[34]), .a(a1c[17]),
     .cout(c2[34]), .sum(s2[34]));
mul_csa32  sc2_33_ ( .c(a0c[32]), .b(a0s[33]), .a(a1c[16]),
     .cout(c2[33]), .sum(s2[33]));
mul_csa32  sc2_32_ ( .c(a0c[31]), .b(a0s[32]), .a(a1c[15]),
     .cout(c2[32]), .sum(s2[32]));
mul_csa32  sc2_31_ ( .c(a0c[30]), .b(a0s[31]), .a(a1c[14]),
     .cout(c2[31]), .sum(s2[31]));
mul_csa32  sc2_30_ ( .c(a0c[29]), .b(a0s[30]), .a(a1c[13]),
     .cout(c2[30]), .sum(s2[30]));
mul_csa32  sc2_29_ ( .c(a0c[28]), .b(a0s[29]), .a(a1c[12]),
     .cout(c2[29]), .sum(s2[29]));
mul_csa32  sc2_28_ ( .c(a0c[27]), .b(a0s[28]), .a(a1c[11]),
     .cout(c2[28]), .sum(s2[28]));
mul_csa32  sc2_27_ ( .c(a0c[26]), .b(a0s[27]), .a(a1c[10]),
     .cout(c2[27]), .sum(s2[27]));
mul_csa32  sc2_26_ ( .c(a0c[25]), .b(a0s[26]), .a(a1c[9]),
     .cout(c2[26]), .sum(s2[26]));
mul_csa32  sc2_25_ ( .c(a0c[24]), .b(a0s[25]), .a(a1c[8]),
     .cout(c2[25]), .sum(s2[25]));
mul_csa32  sc2_24_ ( .c(a0c[23]), .b(a0s[24]), .a(a1c[7]),
     .cout(c2[24]), .sum(s2[24]));
mul_csa32  sc2_23_ ( .c(a0c[22]), .b(a0s[23]), .a(a1c[6]),
     .cout(c2[23]), .sum(s2[23]));
mul_csa32  sc2_22_ ( .c(a0c[21]), .b(a0s[22]), .a(a1c[5]),
     .cout(c2[22]), .sum(s2[22]));
mul_csa32  sc2_21_ ( .c(a0c[20]), .b(a0s[21]), .a(a1c[4]),
     .cout(c2[21]), .sum(s2[21]));
mul_csa32  sc2_20_ ( .c(a0c[19]), .b(a0s[20]), .a(1'b0),
     .cout(c2[20]), .sum(s2[20]));
mul_csa32  sc1_66_ ( .c(a1s[50]), .b(pc[97]), .a(ps[98]),
     .cout(c1[66]), .sum(s1[66]));
mul_csa32  sc1_65_ ( .c(a1s[49]), .b(pc[96]), .a(ps[97]),
     .cout(c1[65]), .sum(s1[65]));
mul_csa32  sc1_64_ ( .c(a1s[48]), .b(pc[95]), .a(ps[96]),
     .cout(c1[64]), .sum(s1[64]));
mul_csa32  sc1_63_ ( .c(a1s[47]), .b(pc[94]), .a(ps[95]),
     .cout(c1[63]), .sum(s1[63]));
mul_csa32  sc1_62_ ( .c(a1s[46]), .b(pc[93]), .a(ps[94]),
     .cout(c1[62]), .sum(s1[62]));
mul_csa32  sc1_61_ ( .c(a1s[45]), .b(pc[92]), .a(ps[93]),
     .cout(c1[61]), .sum(s1[61]));
mul_csa32  sc1_60_ ( .c(a1s[44]), .b(pc[91]), .a(ps[92]),
     .cout(c1[60]), .sum(s1[60]));
mul_csa32  sc1_59_ ( .c(a1s[43]), .b(pc[90]), .a(ps[91]),
     .cout(c1[59]), .sum(s1[59]));
mul_csa32  sc1_58_ ( .c(a1s[42]), .b(pc[89]), .a(ps[90]),
     .cout(c1[58]), .sum(s1[58]));
mul_csa32  sc1_57_ ( .c(a1s[41]), .b(pc[88]), .a(ps[89]),
     .cout(c1[57]), .sum(s1[57]));
mul_csa32  sc1_56_ ( .c(a1s[40]), .b(pc[87]), .a(ps[88]),
     .cout(c1[56]), .sum(s1[56]));
mul_csa32  sc1_55_ ( .c(a1s[39]), .b(pc[86]), .a(ps[87]),
     .cout(c1[55]), .sum(s1[55]));
mul_csa32  sc1_54_ ( .c(a1s[38]), .b(pc[85]), .a(ps[86]),
     .cout(c1[54]), .sum(s1[54]));
mul_csa32  sc1_53_ ( .c(a1s[37]), .b(pc[84]), .a(ps[85]),
     .cout(c1[53]), .sum(s1[53]));
mul_csa32  sc1_52_ ( .c(a1s[36]), .b(pc[83]), .a(ps[84]),
     .cout(c1[52]), .sum(s1[52]));
mul_csa32  sc1_51_ ( .c(a1s[35]), .b(pc[82]), .a(ps[83]),
     .cout(c1[51]), .sum(s1[51]));
mul_csa32  sc1_50_ ( .c(a1s[34]), .b(pc[81]), .a(ps[82]),
     .cout(c1[50]), .sum(s1[50]));
mul_csa32  sc1_49_ ( .c(a1s[33]), .b(pc[80]), .a(ps[81]),
     .cout(c1[49]), .sum(s1[49]));
mul_csa32  sc1_48_ ( .c(a1s[32]), .b(pc[79]), .a(ps[80]),
     .cout(c1[48]), .sum(s1[48]));
mul_csa32  sc1_47_ ( .c(a1s[31]), .b(pc[78]), .a(ps[79]),
     .cout(c1[47]), .sum(s1[47]));
mul_csa32  sc1_46_ ( .c(a1s[30]), .b(pc[77]), .a(ps[78]),
     .cout(c1[46]), .sum(s1[46]));
mul_csa32  sc1_45_ ( .c(a1s[29]), .b(pc[76]), .a(ps[77]),
     .cout(c1[45]), .sum(s1[45]));
mul_csa32  sc1_44_ ( .c(a1s[28]), .b(pc[75]), .a(ps[76]),
     .cout(c1[44]), .sum(s1[44]));
mul_csa32  sc1_43_ ( .c(a1s[27]), .b(pc[74]), .a(ps[75]),
     .cout(c1[43]), .sum(s1[43]));
mul_csa32  sc1_42_ ( .c(a1s[26]), .b(pc[73]), .a(ps[74]),
     .cout(c1[42]), .sum(s1[42]));
mul_csa32  sc1_41_ ( .c(a1s[25]), .b(pc[72]), .a(ps[73]),
     .cout(c1[41]), .sum(s1[41]));
mul_csa32  sc1_40_ ( .c(a1s[24]), .b(pc[71]), .a(ps[72]),
     .cout(c1[40]), .sum(s1[40]));
mul_csa32  sc1_39_ ( .c(a1s[23]), .b(pc[70]), .a(ps[71]),
     .cout(c1[39]), .sum(s1[39]));
mul_csa32  sc1_38_ ( .c(a1s[22]), .b(pc[69]), .a(ps[70]),
     .cout(c1[38]), .sum(s1[38]));
mul_csa32  sc1_37_ ( .c(a1s[21]), .b(pc[68]), .a(ps[69]),
     .cout(c1[37]), .sum(s1[37]));
mul_csa32  sc1_36_ ( .c(a1s[20]), .b(pc[67]), .a(ps[68]),
     .cout(c1[36]), .sum(s1[36]));
mul_csa32  sc1_35_ ( .c(a1s[19]), .b(pc[66]), .a(ps[67]),
     .cout(c1[35]), .sum(s1[35]));
mul_csa32  sc1_34_ ( .c(a1s[18]), .b(pc[65]), .a(ps[66]),
     .cout(c1[34]), .sum(s1[34]));
mul_csa32  sc1_33_ ( .c(a1s[17]), .b(pc[64]), .a(ps[65]),
     .cout(c1[33]), .sum(s1[33]));
mul_csa32  sc1_32_ ( .c(a1s[16]), .b(pc[63]), .a(ps[64]),
     .cout(c1[32]), .sum(s1[32]));
mul_csa32  sc1_31_ ( .c(a1s[15]), .b(pc[62]), .a(ps[63]),
     .cout(c1[31]), .sum(s1[31]));
mul_csa32  sc1_30_ ( .c(a1s[14]), .b(pc[61]), .a(ps[62]),
     .cout(c1[30]), .sum(s1[30]));
mul_csa32  sc1_29_ ( .c(a1s[13]), .b(pc[60]), .a(ps[61]),
     .cout(c1[29]), .sum(s1[29]));
mul_csa32  sc1_28_ ( .c(a1s[12]), .b(pc[59]), .a(ps[60]),
     .cout(c1[28]), .sum(s1[28]));
mul_csa32  sc1_27_ ( .c(a1s[11]), .b(pc[58]), .a(ps[59]),
     .cout(c1[27]), .sum(s1[27]));
mul_csa32  sc1_26_ ( .c(a1s[10]), .b(pc[57]), .a(ps[58]),
     .cout(c1[26]), .sum(s1[26]));
mul_csa32  sc1_25_ ( .c(a1s[9]), .b(pc[56]), .a(ps[57]),
     .cout(c1[25]), .sum(s1[25]));
mul_csa32  sc1_24_ ( .c(a1s[8]), .b(pc[55]), .a(ps[56]),
     .cout(c1[24]), .sum(s1[24]));
mul_csa32  sc1_23_ ( .c(a1s[7]), .b(pc[54]), .a(ps[55]),
     .cout(c1[23]), .sum(s1[23]));
mul_csa32  sc1_22_ ( .c(a1s[6]), .b(pc[53]), .a(ps[54]),
     .cout(c1[22]), .sum(s1[22]));
mul_csa32  sc1_21_ ( .c(a1s[5]), .b(pc[52]), .a(ps[53]),
     .cout(c1[21]), .sum(s1[21]));
mul_csa32  sc1_20_ ( .c(a1s[4]), .b(pc[51]), .a(ps[52]),
     .cout(c1[20]), .sum(s1[20]));
mul_csa32  sc2_81_ ( .c(a0c[80]), .b(c1[80]), .a(s1[81]),
     .cout(c2[81]), .sum(s2[81]));
mul_csa32  sc2_80_ ( .c(a0c[79]), .b(c1[79]), .a(s1[80]),
     .cout(c2[80]), .sum(s2[80]));
mul_csa32  sc2_79_ ( .c(a0c[78]), .b(c1[78]), .a(s1[79]),
     .cout(c2[79]), .sum(s2[79]));
mul_csa32  sc2_78_ ( .c(a0c[77]), .b(c1[77]), .a(s1[78]),
     .cout(c2[78]), .sum(s2[78]));
mul_csa32  sc2_77_ ( .c(a0c[76]), .b(c1[76]), .a(s1[77]),
     .cout(c2[77]), .sum(s2[77]));
mul_csa32  sc2_76_ ( .c(a0c[75]), .b(c1[75]), .a(s1[76]),
     .cout(c2[76]), .sum(s2[76]));
mul_csa32  sc2_75_ ( .c(a0c[74]), .b(c1[74]), .a(s1[75]),
     .cout(c2[75]), .sum(s2[75]));
mul_csa32  sc2_74_ ( .c(a0c[73]), .b(c1[73]), .a(s1[74]),
     .cout(c2[74]), .sum(s2[74]));
mul_csa32  sc2_73_ ( .c(a0c[72]), .b(c1[72]), .a(s1[73]),
     .cout(c2[73]), .sum(s2[73]));
mul_csa32  sc2_72_ ( .c(a0c[71]), .b(c1[71]), .a(s1[72]),
     .cout(c2[72]), .sum(s2[72]));
mul_csa32  sc2_71_ ( .c(a0c[70]), .b(c1[70]), .a(s1[71]),
     .cout(c2[71]), .sum(s2[71]));
mul_csa32  sc2_70_ ( .c(a0c[69]), .b(c1[69]), .a(s1[70]),
     .cout(c2[70]), .sum(s2[70]));
mul_csa32  sc2_69_ ( .c(a0c[68]), .b(c1[68]), .a(s1[69]),
     .cout(c2[69]), .sum(s2[69]));
mul_csa32  sc2_68_ ( .c(a0c[67]), .b(c1[67]), .a(s1[68]),
     .cout(c2[68]), .sum(s2[68]));
mul_csa32  acc_19_ ( .c(c3[18]), .b(s3[19]), .a(ain[19]),
     .cout(pcout[19]), .sum(psum[19]));
mul_csa32  acc_18_ ( .c(c3[17]), .b(s3[18]), .a(ain[18]),
     .cout(pcout[18]), .sum(psum[18]));
mul_csa32  acc_17_ ( .c(c3[16]), .b(s3[17]), .a(ain[17]),
     .cout(pcout[17]), .sum(psum[17]));
mul_csa32  acc_16_ ( .c(c3[15]), .b(s3[16]), .a(ain[16]),
     .cout(pcout[16]), .sum(psum[16]));
mul_csa32  acc_15_ ( .c(1'b0), .b(s3[15]), .a(ain[15]),
     .cout(pcout[15]), .sum(psum[15]));
mul_csa32  sc1_0_ ( .c(a0s[0]), .sum(s1[0]), .cout(c1[0]),
     .a(ps[32]), .b(pc[31]));
mul_csa32  sc1_67_ ( .c(a1c[50]), .b(pc[98]), .a(a1s[51]),
     .cout(c1[67]), .sum(s1[67]));
mul_ha acc_0_ ( .sum(psum[0]), .cout(pcout[0]), .a(ain[0]),
     .b(s2[0]));
mul_ha sc3_98_ ( .sum(psum[98]), .cout(pcout[98]), .a(bot),
     .b(a1c[81]));
mul_ha sc2_96_ ( .b(a1c[79]), .a(a1s[80]), .cout(c2[96]),
     .sum(s2[96]));
mul_ha sc2_95_ ( .b(a1c[78]), .a(a1s[79]), .cout(c2[95]),
     .sum(s2[95]));
mul_ha sc2_94_ ( .b(a1c[77]), .a(a1s[78]), .cout(c2[94]),
     .sum(s2[94]));
mul_ha sc2_93_ ( .b(a1c[76]), .a(a1s[77]), .cout(c2[93]),
     .sum(s2[93]));
mul_ha sc2_92_ ( .b(a1c[75]), .a(a1s[76]), .cout(c2[92]),
     .sum(s2[92]));
mul_ha sc2_91_ ( .b(a1c[74]), .a(a1s[75]), .cout(c2[91]),
     .sum(s2[91]));
mul_ha sc2_90_ ( .b(a1c[73]), .a(a1s[74]), .cout(c2[90]),
     .sum(s2[90]));
mul_ha sc2_89_ ( .b(a1c[72]), .a(a1s[73]), .cout(c2[89]),
     .sum(s2[89]));
mul_ha sc2_88_ ( .b(a1c[71]), .a(a1s[72]), .cout(c2[88]),
     .sum(s2[88]));
mul_ha sc2_87_ ( .b(a1c[70]), .a(a1s[71]), .cout(c2[87]),
     .sum(s2[87]));
mul_ha sc2_86_ ( .b(a1c[69]), .a(a1s[70]), .cout(c2[86]),
     .sum(s2[86]));
mul_ha sc2_85_ ( .b(a1c[68]), .a(a1s[69]), .cout(c2[85]),
     .sum(s2[85]));
mul_ha sc2_84_ ( .b(a1c[67]), .a(a1s[68]), .cout(c2[84]),
     .sum(s2[84]));
mul_ha sc3_81_ ( .b(c2[80]), .a(s2[81]), .cout(c3[81]),
     .sum(s3[81]));
mul_ha sc3_80_ ( .b(c2[79]), .a(s2[80]), .cout(c3[80]),
     .sum(s3[80]));
mul_ha sc3_79_ ( .b(c2[78]), .a(s2[79]), .cout(c3[79]),
     .sum(s3[79]));
mul_ha sc3_78_ ( .b(c2[77]), .a(s2[78]), .cout(c3[78]),
     .sum(s3[78]));
mul_ha sc3_77_ ( .b(c2[76]), .a(s2[77]), .cout(c3[77]),
     .sum(s3[77]));
mul_ha sc3_76_ ( .b(c2[75]), .a(s2[76]), .cout(c3[76]),
     .sum(s3[76]));
mul_ha sc3_75_ ( .b(c2[74]), .a(s2[75]), .cout(c3[75]),
     .sum(s3[75]));
mul_ha sc3_74_ ( .b(c2[73]), .a(s2[74]), .cout(c3[74]),
     .sum(s3[74]));
mul_ha sc3_73_ ( .b(c2[72]), .a(s2[73]), .cout(c3[73]),
     .sum(s3[73]));
mul_ha sc3_72_ ( .b(c2[71]), .a(s2[72]), .cout(c3[72]),
     .sum(s3[72]));
mul_ha sc3_71_ ( .b(c2[70]), .a(s2[71]), .cout(c3[71]),
     .sum(s3[71]));
mul_ha sc3_70_ ( .b(c2[69]), .a(s2[70]), .cout(c3[70]),
     .sum(s3[70]));
mul_ha sc3_69_ ( .b(c2[68]), .a(s2[69]), .cout(c3[69]),
     .sum(s3[69]));
mul_ha accx2 ( .sum(psumx2), .cout(pcoutx2), .a(ainx2), .b(s1x2));
mul_ha sc2_4_ ( .sum(s2[4]), .cout(c2[4]), .a(s1[4]), .b(c1[3]));
mul_ha sc2_3_ ( .sum(s2[3]), .cout(c2[3]), .a(s1[3]), .b(c1[2]));
mul_ha sc2_2_ ( .sum(s2[2]), .cout(c2[2]), .a(s1[2]), .b(c1[1]));
mul_ha sc2_1_ ( .sum(s2[1]), .cout(c2[1]), .a(s1[1]), .b(c1[0]));
mul_ha sc2_0_ ( .sum(s2[0]), .cout(c2[0]), .a(s1[0]), .b(c1x2));
mul_ha sc1x2 ( .sum(s1x2), .cout(c1x2), .a(ps[31]), .b(pc[30]));

endmodule //mul_array2

module mul_csa32 (sum, cout, a, b, c);

output sum, cout;
input a, b, c;

wire x, y0, y1, y2;

assign x = a ^ b;
assign sum = c ^ x;

assign y0 = a & b ;
assign y1 = a & c ;
assign y2 = b & c ;

assign cout = y0 | y1 | y2 ;

endmodule //mul_csa32

module mul_csa42 (sum, carry, cout, a, b, c, d, cin);

output sum, carry, cout;
input a, b, c, d, cin;

wire x, y, z;

assign x = a ^ b;
assign y = c ^ d;
assign z = x ^ y;

assign sum = z ^ cin ;

assign carry = (b & ~z) | (cin & z);

assign cout = (d & ~y) | (a & y);

endmodule // mul_csa42

module mul_ha ( cout, sum, a, b );
output  cout, sum;
input  a, b;

assign sum = a ^ b;
assign cout = a & b ;

endmodule //mul_ha

module mul_negen ( n0, n1, b );
output  n0, n1;
input [2:0]  b;

assign n0 = b[2] & b[1] & ~b[0] ;
assign n1 = b[2] & b[1] & b[0] ;

endmodule //mul_negen

module mul_ppgen3lsb4 (cout, p0_l, p1_l, sum, a, b0, b1 );

output  p0_l, p1_l;
output [3:0]  sum;
output [3:1]  cout;
input [3:0]  a;
input [2:0]  b0;
input [2:0]  b1;

wire b0n, b0n_0, b0n_1, b1n_0, b1n_1;
wire p0_0, p0_1, p0_2, p0_3, p1_2, p1_3;
wire p0_l_0, p0_l_1, p0_l_2, p1_l_2;

assign b0n = b0n_1 | (b0n_0 & p0_0) ;
assign sum[0] = b0n_0 ^ p0_0 ;

mul_negen p0n ( .b(b0[2:0]), .n1(b0n_1), .n0(b0n_0));
mul_negen p1n ( .b(b1[2:0]), .n1(b1n_1), .n0(b1n_0));
mul_csa32  sc1_2_ ( .c(b1n_0), .sum(sum[2]), .cout(cout[2]),
     .a(p0_2), .b(p1_2));
mul_csa32  sc1_3_ ( .c(b1n_1), .sum(sum[3]), .cout(cout[3]),
     .a(p0_3), .b(p1_3));
mul_ha sc1_1_ ( .sum(sum[1]), .cout(cout[1]), .a(p0_1),
     .b(b0n));
mul_ppgen p0_3_ ( .pm1_l(p0_l_2), .p_l(p0_l), .b(b0[2:0]), .a(a[3]),
     .z(p0_3));
mul_ppgen p1_3_ ( .pm1_l(p1_l_2), .p_l(p1_l), .b(b1[2:0]), .a(a[1]),
     .z(p1_3));
mul_ppgen p0_2_ ( .pm1_l(p0_l_1), .p_l(p0_l_2), .b(b0[2:0]),
     .a(a[2]), .z(p0_2));
mul_ppgen p0_1_ ( .pm1_l(p0_l_0), .p_l(p0_l_1), .b(b0[2:0]),
     .a(a[1]), .z(p0_1));
mul_ppgen p0_0_ ( .pm1_l(1'b1), .p_l(p0_l_0),
     .b(b0[2:0]), .a(a[0]), .z(p0_0));
mul_ppgen p1_2_ ( .pm1_l(1'b1), .p_l(p1_l_2),
     .b(b1[2:0]), .a(a[0]), .z(p1_2));

endmodule // mul_ppgen3lsb4

module mul_ppgen3sign ( cout, sum, am1, am2, am3, am4, b0, b1, b2,
     bot, head, p0m1_l, p1m1_l, p2m1_l );
input  am1, am2, am3, am4;
input  bot, head, p0m1_l, p1m1_l, p2m1_l;
output [5:0]  sum;
output [4:0]  cout;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net37, net42, net075, net088, net0117; 
wire net47, net073, net38, net0118, net078, net8, net15, net43, net48, net35;
wire p2_l_67, p2_l_66, p2_l_65, p2_l_64; 
wire p1_l_65, p1_l_64; 

assign sum[5] = bot & net075 ;
assign net0117 = head & net088 ; 
assign net37 = ~net0117 ;
assign net42 = head ^ net088 ;

mul_ppgensign p0_64_ ( .b(b0[2:0]), .z(net47), .p_l(net088),
     .pm1_l(p0m1_l));
mul_ppgensign p2_68_ ( .pm1_l(p2_l_67), .b(b2[2:0]), .z(net073),
     .p_l(net075));
mul_ppgensign p1_66_ ( .pm1_l(p1_l_65), .b(b1[2:0]), .z(net38),
     .p_l(net0118));
mul_ha sc1_68_ ( .b(net073), .a(1'b1), .cout(cout[4]),
     .sum(sum[4]));
mul_ppgen p2_67_ ( .pm1_l(p2_l_66), .b(b2[2:0]), .a(am1), .z(net078),
     .p_l(p2_l_67));
mul_ppgen p2_66_ ( .pm1_l(p2_l_65), .b(b2[2:0]), .a(am2), .z(net8),
     .p_l(p2_l_66));
mul_ppgen p2_65_ ( .pm1_l(p2_l_64), .p_l(p2_l_65), .b(b2[2:0]),
     .a(am3), .z(net15));
mul_ppgen p1_65_ ( .pm1_l(p1_l_64), .p_l(p1_l_65), .b(b1[2:0]),
     .a(am1), .z(net43));
mul_ppgen p1_64_ ( .pm1_l(p1m1_l), .p_l(p1_l_64), .b(b1[2:0]),
     .a(am2), .z(net48));
mul_ppgen p2_64_ ( .pm1_l(p2m1_l), .p_l(p2_l_64), .b(b2[2:0]),
     .a(am4), .z(net35));
mul_csa32  sc1_67_ ( .c(net078), .b(net0117), .a(net0118),
     .cout(cout[3]), .sum(sum[3]));
mul_csa32  sc1_66_ ( .c(net8), .b(net37), .a(net38), .cout(cout[2]),
     .sum(sum[2]));
mul_csa32  sc1_65_ ( .c(net15), .b(net42), .a(net43), .cout(cout[1]),
     .sum(sum[1]));
mul_csa32  sc1_64_ ( .c(net35), .b(net47), .a(net48), .cout(cout[0]),
     .sum(sum[0]));

endmodule //mul_ppgen3sign

module mul_ppgen3 ( cout, p0_l, p1_l, p2_l, sum, am2, am4,
     a, b0, b1, b2, p0m1_l, p1m1_l, p2m1_l );
output  cout, p0_l, p1_l, p2_l, sum;
input  am2, am4;
input  a, p0m1_l, p1m1_l, p2m1_l;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net046, net32, net043;

mul_csa32  sc1 ( .a(net046), .b(net32), .cout(cout), .sum(sum),
     .c(net043));
mul_ppgen p2 ( .pm1_l(p2m1_l), .p_l(p2_l), .b(b2[2:0]), .a(am4),
     .z(net043));
mul_ppgen p1 ( .pm1_l(p1m1_l), .p_l(p1_l), .b(b1[2:0]), .a(am2),
     .z(net046));
mul_ppgen p0 ( .pm1_l(p0m1_l), .p_l(p0_l), .b(b0[2:0]), .a(a),
     .z(net32));

endmodule // mul_ppgen3

module mul_ppgenrow3 ( cout, sum, a, b0, b1, b2, bot, head );

output [68:1]  cout;
output [69:0]  sum;
input [63:0]  a;
input [2:0]  b2;
input [2:0]  b0;
input [2:0]  b1;
input  bot, head;

// Buses in the design
wire  [63:4]  p2_l;
wire  [63:3]  p1_l;
wire  [63:3]  p0_l;

mul_ppgen3sign I2 ( .am4(a[60]), .am3(a[61]), .am2(a[62]),
     .am1(a[63]), .p2m1_l(p2_l[63]), .p1m1_l(p1_l[63]),
     .p0m1_l(p0_l[63]), .b2(b2[2:0]), .head(head), .bot(bot),
     .sum(sum[69:64]), .cout(cout[68:64]), .b1(b1[2:0]), .b0(b0[2:0]));
mul_ppgen3 I1_63_ ( .p2_l(p2_l[63]), .b2(b2[2:0]),
     .am2(a[61]), .a(a[63]), .p2m1_l(p2_l[62]),
     .p1m1_l(p1_l[62]), .p0m1_l(p0_l[62]), .am4(a[59]), .sum(sum[63]),
     .cout(cout[63]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[63]),
     .p0_l(p0_l[63]));
mul_ppgen3 I1_62_ ( .p2_l(p2_l[62]), .b2(b2[2:0]), 
     .am2(a[60]), .a(a[62]), .p2m1_l(p2_l[61]),
     .p1m1_l(p1_l[61]), .p0m1_l(p0_l[61]), .am4(a[58]), .sum(sum[62]),
     .cout(cout[62]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[62]),
     .p0_l(p0_l[62]));
mul_ppgen3 I1_61_ ( .p2_l(p2_l[61]), .b2(b2[2:0]), 
     .am2(a[59]), .a(a[61]), .p2m1_l(p2_l[60]),
     .p1m1_l(p1_l[60]), .p0m1_l(p0_l[60]), .am4(a[57]), .sum(sum[61]),
     .cout(cout[61]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[61]),
     .p0_l(p0_l[61]));
mul_ppgen3 I1_60_ ( .p2_l(p2_l[60]), .b2(b2[2:0]), 
     .am2(a[58]), .a(a[60]), .p2m1_l(p2_l[59]),
     .p1m1_l(p1_l[59]), .p0m1_l(p0_l[59]), .am4(a[56]), .sum(sum[60]),
     .cout(cout[60]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[60]),
     .p0_l(p0_l[60]));
mul_ppgen3 I1_59_ ( .p2_l(p2_l[59]), .b2(b2[2:0]), 
     .am2(a[57]), .a(a[59]), .p2m1_l(p2_l[58]),
     .p1m1_l(p1_l[58]), .p0m1_l(p0_l[58]), .am4(a[55]), .sum(sum[59]),
     .cout(cout[59]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[59]),
     .p0_l(p0_l[59]));
mul_ppgen3 I1_58_ ( .p2_l(p2_l[58]), .b2(b2[2:0]), 
     .am2(a[56]), .a(a[58]), .p2m1_l(p2_l[57]),
     .p1m1_l(p1_l[57]), .p0m1_l(p0_l[57]), .am4(a[54]), .sum(sum[58]),
     .cout(cout[58]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[58]),
     .p0_l(p0_l[58]));
mul_ppgen3 I1_57_ ( .p2_l(p2_l[57]), .b2(b2[2:0]), 
     .am2(a[55]), .a(a[57]), .p2m1_l(p2_l[56]),
     .p1m1_l(p1_l[56]), .p0m1_l(p0_l[56]), .am4(a[53]), .sum(sum[57]),
     .cout(cout[57]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[57]),
     .p0_l(p0_l[57]));
mul_ppgen3 I1_56_ ( .p2_l(p2_l[56]), .b2(b2[2:0]), 
     .am2(a[54]), .a(a[56]), .p2m1_l(p2_l[55]),
     .p1m1_l(p1_l[55]), .p0m1_l(p0_l[55]), .am4(a[52]), .sum(sum[56]),
     .cout(cout[56]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[56]),
     .p0_l(p0_l[56]));
mul_ppgen3 I1_55_ ( .p2_l(p2_l[55]), .b2(b2[2:0]), 
     .am2(a[53]), .a(a[55]), .p2m1_l(p2_l[54]),
     .p1m1_l(p1_l[54]), .p0m1_l(p0_l[54]), .am4(a[51]), .sum(sum[55]),
     .cout(cout[55]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[55]),
     .p0_l(p0_l[55]));
mul_ppgen3 I1_54_ ( .p2_l(p2_l[54]), .b2(b2[2:0]), 
     .am2(a[52]), .a(a[54]), .p2m1_l(p2_l[53]),
     .p1m1_l(p1_l[53]), .p0m1_l(p0_l[53]), .am4(a[50]), .sum(sum[54]),
     .cout(cout[54]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[54]),
     .p0_l(p0_l[54]));
mul_ppgen3 I1_53_ ( .p2_l(p2_l[53]), .b2(b2[2:0]), 
     .am2(a[51]), .a(a[53]), .p2m1_l(p2_l[52]),
     .p1m1_l(p1_l[52]), .p0m1_l(p0_l[52]), .am4(a[49]), .sum(sum[53]),
     .cout(cout[53]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[53]),
     .p0_l(p0_l[53]));
mul_ppgen3 I1_52_ ( .p2_l(p2_l[52]), .b2(b2[2:0]), 
     .am2(a[50]), .a(a[52]), .p2m1_l(p2_l[51]),
     .p1m1_l(p1_l[51]), .p0m1_l(p0_l[51]), .am4(a[48]), .sum(sum[52]),
     .cout(cout[52]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[52]),
     .p0_l(p0_l[52]));
mul_ppgen3 I1_51_ ( .p2_l(p2_l[51]), .b2(b2[2:0]), 
     .am2(a[49]), .a(a[51]), .p2m1_l(p2_l[50]),
     .p1m1_l(p1_l[50]), .p0m1_l(p0_l[50]), .am4(a[47]), .sum(sum[51]),
     .cout(cout[51]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[51]),
     .p0_l(p0_l[51]));
mul_ppgen3 I1_50_ ( .p2_l(p2_l[50]), .b2(b2[2:0]), 
     .am2(a[48]), .a(a[50]), .p2m1_l(p2_l[49]),
     .p1m1_l(p1_l[49]), .p0m1_l(p0_l[49]), .am4(a[46]), .sum(sum[50]),
     .cout(cout[50]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[50]),
     .p0_l(p0_l[50]));
mul_ppgen3 I1_49_ ( .p2_l(p2_l[49]), .b2(b2[2:0]), 
     .am2(a[47]), .a(a[49]), .p2m1_l(p2_l[48]),
     .p1m1_l(p1_l[48]), .p0m1_l(p0_l[48]), .am4(a[45]), .sum(sum[49]),
     .cout(cout[49]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[49]),
     .p0_l(p0_l[49]));
mul_ppgen3 I1_48_ ( .p2_l(p2_l[48]), .b2(b2[2:0]), 
     .am2(a[46]), .a(a[48]), .p2m1_l(p2_l[47]),
     .p1m1_l(p1_l[47]), .p0m1_l(p0_l[47]), .am4(a[44]), .sum(sum[48]),
     .cout(cout[48]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[48]),
     .p0_l(p0_l[48]));
mul_ppgen3 I1_47_ ( .p2_l(p2_l[47]), .b2(b2[2:0]), 
     .am2(a[45]), .a(a[47]), .p2m1_l(p2_l[46]),
     .p1m1_l(p1_l[46]), .p0m1_l(p0_l[46]), .am4(a[43]), .sum(sum[47]),
     .cout(cout[47]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[47]),
     .p0_l(p0_l[47]));
mul_ppgen3 I1_46_ ( .p2_l(p2_l[46]), .b2(b2[2:0]), 
     .am2(a[44]), .a(a[46]), .p2m1_l(p2_l[45]),
     .p1m1_l(p1_l[45]), .p0m1_l(p0_l[45]), .am4(a[42]), .sum(sum[46]),
     .cout(cout[46]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[46]),
     .p0_l(p0_l[46]));
mul_ppgen3 I1_45_ ( .p2_l(p2_l[45]), .b2(b2[2:0]), 
     .am2(a[43]), .a(a[45]), .p2m1_l(p2_l[44]),
     .p1m1_l(p1_l[44]), .p0m1_l(p0_l[44]), .am4(a[41]), .sum(sum[45]),
     .cout(cout[45]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[45]),
     .p0_l(p0_l[45]));
mul_ppgen3 I1_44_ ( .p2_l(p2_l[44]), .b2(b2[2:0]), 
     .am2(a[42]), .a(a[44]), .p2m1_l(p2_l[43]),
     .p1m1_l(p1_l[43]), .p0m1_l(p0_l[43]), .am4(a[40]), .sum(sum[44]),
     .cout(cout[44]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[44]),
     .p0_l(p0_l[44]));
mul_ppgen3 I1_43_ ( .p2_l(p2_l[43]), .b2(b2[2:0]), 
     .am2(a[41]), .a(a[43]), .p2m1_l(p2_l[42]),
     .p1m1_l(p1_l[42]), .p0m1_l(p0_l[42]), .am4(a[39]), .sum(sum[43]),
     .cout(cout[43]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[43]),
     .p0_l(p0_l[43]));
mul_ppgen3 I1_42_ ( .p2_l(p2_l[42]), .b2(b2[2:0]), 
     .am2(a[40]), .a(a[42]), .p2m1_l(p2_l[41]),
     .p1m1_l(p1_l[41]), .p0m1_l(p0_l[41]), .am4(a[38]), .sum(sum[42]),
     .cout(cout[42]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[42]),
     .p0_l(p0_l[42]));
mul_ppgen3 I1_41_ ( .p2_l(p2_l[41]), .b2(b2[2:0]), 
     .am2(a[39]), .a(a[41]), .p2m1_l(p2_l[40]),
     .p1m1_l(p1_l[40]), .p0m1_l(p0_l[40]), .am4(a[37]), .sum(sum[41]),
     .cout(cout[41]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[41]),
     .p0_l(p0_l[41]));
mul_ppgen3 I1_40_ ( .p2_l(p2_l[40]), .b2(b2[2:0]), 
     .am2(a[38]), .a(a[40]), .p2m1_l(p2_l[39]),
     .p1m1_l(p1_l[39]), .p0m1_l(p0_l[39]), .am4(a[36]), .sum(sum[40]),
     .cout(cout[40]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[40]),
     .p0_l(p0_l[40]));
mul_ppgen3 I1_39_ ( .p2_l(p2_l[39]), .b2(b2[2:0]), 
     .am2(a[37]), .a(a[39]), .p2m1_l(p2_l[38]),
     .p1m1_l(p1_l[38]), .p0m1_l(p0_l[38]), .am4(a[35]), .sum(sum[39]),
     .cout(cout[39]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[39]),
     .p0_l(p0_l[39]));
mul_ppgen3 I1_38_ ( .p2_l(p2_l[38]), .b2(b2[2:0]), 
     .am2(a[36]), .a(a[38]), .p2m1_l(p2_l[37]),
     .p1m1_l(p1_l[37]), .p0m1_l(p0_l[37]), .am4(a[34]), .sum(sum[38]),
     .cout(cout[38]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[38]),
     .p0_l(p0_l[38]));
mul_ppgen3 I1_37_ ( .p2_l(p2_l[37]), .b2(b2[2:0]), 
     .am2(a[35]), .a(a[37]), .p2m1_l(p2_l[36]),
     .p1m1_l(p1_l[36]), .p0m1_l(p0_l[36]), .am4(a[33]), .sum(sum[37]),
     .cout(cout[37]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[37]),
     .p0_l(p0_l[37]));
mul_ppgen3 I1_36_ ( .p2_l(p2_l[36]), .b2(b2[2:0]), 
     .am2(a[34]), .a(a[36]), .p2m1_l(p2_l[35]),
     .p1m1_l(p1_l[35]), .p0m1_l(p0_l[35]), .am4(a[32]), .sum(sum[36]),
     .cout(cout[36]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[36]),
     .p0_l(p0_l[36]));
mul_ppgen3 I1_35_ ( .p2_l(p2_l[35]), .b2(b2[2:0]), 
     .am2(a[33]), .a(a[35]), .p2m1_l(p2_l[34]),
     .p1m1_l(p1_l[34]), .p0m1_l(p0_l[34]), .am4(a[31]), .sum(sum[35]),
     .cout(cout[35]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[35]),
     .p0_l(p0_l[35]));
mul_ppgen3 I1_34_ ( .p2_l(p2_l[34]), .b2(b2[2:0]), 
     .am2(a[32]), .a(a[34]), .p2m1_l(p2_l[33]),
     .p1m1_l(p1_l[33]), .p0m1_l(p0_l[33]), .am4(a[30]), .sum(sum[34]),
     .cout(cout[34]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[34]),
     .p0_l(p0_l[34]));
mul_ppgen3 I1_33_ ( .p2_l(p2_l[33]), .b2(b2[2:0]), 
     .am2(a[31]), .a(a[33]), .p2m1_l(p2_l[32]),
     .p1m1_l(p1_l[32]), .p0m1_l(p0_l[32]), .am4(a[29]), .sum(sum[33]),
     .cout(cout[33]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[33]),
     .p0_l(p0_l[33]));
mul_ppgen3 I1_32_ ( .p2_l(p2_l[32]), .b2(b2[2:0]), 
     .am2(a[30]), .a(a[32]), .p2m1_l(p2_l[31]),
     .p1m1_l(p1_l[31]), .p0m1_l(p0_l[31]), .am4(a[28]), .sum(sum[32]),
     .cout(cout[32]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[32]),
     .p0_l(p0_l[32]));
mul_ppgen3 I1_31_ ( .p2_l(p2_l[31]), .b2(b2[2:0]), 
     .am2(a[29]), .a(a[31]), .p2m1_l(p2_l[30]),
     .p1m1_l(p1_l[30]), .p0m1_l(p0_l[30]), .am4(a[27]), .sum(sum[31]),
     .cout(cout[31]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[31]),
     .p0_l(p0_l[31]));
mul_ppgen3 I1_30_ ( .p2_l(p2_l[30]), .b2(b2[2:0]), 
     .am2(a[28]), .a(a[30]), .p2m1_l(p2_l[29]),
     .p1m1_l(p1_l[29]), .p0m1_l(p0_l[29]), .am4(a[26]), .sum(sum[30]),
     .cout(cout[30]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[30]),
     .p0_l(p0_l[30]));
mul_ppgen3 I1_29_ ( .p2_l(p2_l[29]), .b2(b2[2:0]), 
     .am2(a[27]), .a(a[29]), .p2m1_l(p2_l[28]),
     .p1m1_l(p1_l[28]), .p0m1_l(p0_l[28]), .am4(a[25]), .sum(sum[29]),
     .cout(cout[29]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[29]),
     .p0_l(p0_l[29]));
mul_ppgen3 I1_28_ ( .p2_l(p2_l[28]), .b2(b2[2:0]), 
     .am2(a[26]), .a(a[28]), .p2m1_l(p2_l[27]),
     .p1m1_l(p1_l[27]), .p0m1_l(p0_l[27]), .am4(a[24]), .sum(sum[28]),
     .cout(cout[28]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[28]),
     .p0_l(p0_l[28]));
mul_ppgen3 I1_27_ ( .p2_l(p2_l[27]), .b2(b2[2:0]), 
     .am2(a[25]), .a(a[27]), .p2m1_l(p2_l[26]),
     .p1m1_l(p1_l[26]), .p0m1_l(p0_l[26]), .am4(a[23]), .sum(sum[27]),
     .cout(cout[27]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[27]),
     .p0_l(p0_l[27]));
mul_ppgen3 I1_26_ ( .p2_l(p2_l[26]), .b2(b2[2:0]), 
     .am2(a[24]), .a(a[26]), .p2m1_l(p2_l[25]),
     .p1m1_l(p1_l[25]), .p0m1_l(p0_l[25]), .am4(a[22]), .sum(sum[26]),
     .cout(cout[26]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[26]),
     .p0_l(p0_l[26]));
mul_ppgen3 I1_25_ ( .p2_l(p2_l[25]), .b2(b2[2:0]), 
     .am2(a[23]), .a(a[25]), .p2m1_l(p2_l[24]),
     .p1m1_l(p1_l[24]), .p0m1_l(p0_l[24]), .am4(a[21]), .sum(sum[25]),
     .cout(cout[25]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[25]),
     .p0_l(p0_l[25]));
mul_ppgen3 I1_24_ ( .p2_l(p2_l[24]), .b2(b2[2:0]), 
     .am2(a[22]), .a(a[24]), .p2m1_l(p2_l[23]),
     .p1m1_l(p1_l[23]), .p0m1_l(p0_l[23]), .am4(a[20]), .sum(sum[24]),
     .cout(cout[24]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[24]),
     .p0_l(p0_l[24]));
mul_ppgen3 I1_23_ ( .p2_l(p2_l[23]), .b2(b2[2:0]), 
     .am2(a[21]), .a(a[23]), .p2m1_l(p2_l[22]),
     .p1m1_l(p1_l[22]), .p0m1_l(p0_l[22]), .am4(a[19]), .sum(sum[23]),
     .cout(cout[23]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[23]),
     .p0_l(p0_l[23]));
mul_ppgen3 I1_22_ ( .p2_l(p2_l[22]), .b2(b2[2:0]), 
     .am2(a[20]), .a(a[22]), .p2m1_l(p2_l[21]),
     .p1m1_l(p1_l[21]), .p0m1_l(p0_l[21]), .am4(a[18]), .sum(sum[22]),
     .cout(cout[22]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[22]),
     .p0_l(p0_l[22]));
mul_ppgen3 I1_21_ ( .p2_l(p2_l[21]), .b2(b2[2:0]), 
     .am2(a[19]), .a(a[21]), .p2m1_l(p2_l[20]),
     .p1m1_l(p1_l[20]), .p0m1_l(p0_l[20]), .am4(a[17]), .sum(sum[21]),
     .cout(cout[21]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[21]),
     .p0_l(p0_l[21]));
mul_ppgen3 I1_20_ ( .p2_l(p2_l[20]), .b2(b2[2:0]), 
     .am2(a[18]), .a(a[20]), .p2m1_l(p2_l[19]),
     .p1m1_l(p1_l[19]), .p0m1_l(p0_l[19]), .am4(a[16]), .sum(sum[20]),
     .cout(cout[20]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[20]),
     .p0_l(p0_l[20]));
mul_ppgen3 I1_19_ ( .p2_l(p2_l[19]), .b2(b2[2:0]), 
     .am2(a[17]), .a(a[19]), .p2m1_l(p2_l[18]),
     .p1m1_l(p1_l[18]), .p0m1_l(p0_l[18]), .am4(a[15]), .sum(sum[19]),
     .cout(cout[19]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[19]),
     .p0_l(p0_l[19]));
mul_ppgen3 I1_18_ ( .p2_l(p2_l[18]), .b2(b2[2:0]), 
     .am2(a[16]), .a(a[18]), .p2m1_l(p2_l[17]),
     .p1m1_l(p1_l[17]), .p0m1_l(p0_l[17]), .am4(a[14]), .sum(sum[18]),
     .cout(cout[18]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[18]),
     .p0_l(p0_l[18]));
mul_ppgen3 I1_17_ ( .p2_l(p2_l[17]), .b2(b2[2:0]), 
     .am2(a[15]), .a(a[17]), .p2m1_l(p2_l[16]),
     .p1m1_l(p1_l[16]), .p0m1_l(p0_l[16]), .am4(a[13]), .sum(sum[17]),
     .cout(cout[17]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[17]),
     .p0_l(p0_l[17]));
mul_ppgen3 I1_16_ ( .p2_l(p2_l[16]), .b2(b2[2:0]), 
     .am2(a[14]), .a(a[16]), .p2m1_l(p2_l[15]),
     .p1m1_l(p1_l[15]), .p0m1_l(p0_l[15]), .am4(a[12]), .sum(sum[16]),
     .cout(cout[16]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[16]),
     .p0_l(p0_l[16]));
mul_ppgen3 I1_15_ ( .p2_l(p2_l[15]), .b2(b2[2:0]), 
     .am2(a[13]), .a(a[15]), .p2m1_l(p2_l[14]),
     .p1m1_l(p1_l[14]), .p0m1_l(p0_l[14]), .am4(a[11]), .sum(sum[15]),
     .cout(cout[15]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[15]),
     .p0_l(p0_l[15]));
mul_ppgen3 I1_14_ ( .p2_l(p2_l[14]), .b2(b2[2:0]), 
     .am2(a[12]), .a(a[14]), .p2m1_l(p2_l[13]),
     .p1m1_l(p1_l[13]), .p0m1_l(p0_l[13]), .am4(a[10]), .sum(sum[14]),
     .cout(cout[14]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[14]),
     .p0_l(p0_l[14]));
mul_ppgen3 I1_13_ ( .p2_l(p2_l[13]), .b2(b2[2:0]), 
     .am2(a[11]), .a(a[13]), .p2m1_l(p2_l[12]),
     .p1m1_l(p1_l[12]), .p0m1_l(p0_l[12]), .am4(a[9]), .sum(sum[13]),
     .cout(cout[13]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[13]),
     .p0_l(p0_l[13]));
mul_ppgen3 I1_12_ ( .p2_l(p2_l[12]), .b2(b2[2:0]), 
     .am2(a[10]), .a(a[12]), .p2m1_l(p2_l[11]),
     .p1m1_l(p1_l[11]), .p0m1_l(p0_l[11]), .am4(a[8]), .sum(sum[12]),
     .cout(cout[12]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[12]),
     .p0_l(p0_l[12]));
mul_ppgen3 I1_11_ ( .p2_l(p2_l[11]), .b2(b2[2:0]), 
     .am2(a[9]), .a(a[11]), .p2m1_l(p2_l[10]),
     .p1m1_l(p1_l[10]), .p0m1_l(p0_l[10]), .am4(a[7]), .sum(sum[11]),
     .cout(cout[11]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[11]),
     .p0_l(p0_l[11]));
mul_ppgen3 I1_10_ ( .p2_l(p2_l[10]), .b2(b2[2:0]), 
     .am2(a[8]), .a(a[10]), .p2m1_l(p2_l[9]),
     .p1m1_l(p1_l[9]), .p0m1_l(p0_l[9]), .am4(a[6]), .sum(sum[10]),
     .cout(cout[10]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[10]),
     .p0_l(p0_l[10]));
mul_ppgen3 I1_9_ ( .p2_l(p2_l[9]), .b2(b2[2:0]), 
     .am2(a[7]), .a(a[9]), .p2m1_l(p2_l[8]),
     .p1m1_l(p1_l[8]), .p0m1_l(p0_l[8]), .am4(a[5]), .sum(sum[9]),
     .cout(cout[9]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[9]),
     .p0_l(p0_l[9]));
mul_ppgen3 I1_8_ ( .p2_l(p2_l[8]), .b2(b2[2:0]), 
     .am2(a[6]), .a(a[8]), .p2m1_l(p2_l[7]),
     .p1m1_l(p1_l[7]), .p0m1_l(p0_l[7]), .am4(a[4]), .sum(sum[8]),
     .cout(cout[8]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[8]),
     .p0_l(p0_l[8]));
mul_ppgen3 I1_7_ ( .p2_l(p2_l[7]), .b2(b2[2:0]), 
     .am2(a[5]), .a(a[7]), .p2m1_l(p2_l[6]),
     .p1m1_l(p1_l[6]), .p0m1_l(p0_l[6]), .am4(a[3]), .sum(sum[7]),
     .cout(cout[7]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[7]),
     .p0_l(p0_l[7]));
mul_ppgen3 I1_6_ ( .p2_l(p2_l[6]), .b2(b2[2:0]), 
     .am2(a[4]), .a(a[6]), .p2m1_l(p2_l[5]),
     .p1m1_l(p1_l[5]), .p0m1_l(p0_l[5]), .am4(a[2]), .sum(sum[6]),
     .cout(cout[6]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[6]),
     .p0_l(p0_l[6]));
mul_ppgen3 I1_5_ ( .p2_l(p2_l[5]), .b2(b2[2:0]), 
     .am2(a[3]), .a(a[5]), .p2m1_l(p2_l[4]),
     .p1m1_l(p1_l[4]), .p0m1_l(p0_l[4]), .am4(a[1]), .sum(sum[5]),
     .cout(cout[5]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[5]),
     .p0_l(p0_l[5]));
mul_ppgen3 I1_4_ ( .p2_l(p2_l[4]), .b2(b2[2:0]), 
     .am2(a[2]), .a(a[4]), .p2m1_l(1'b1),
     .p1m1_l(p1_l[3]), .p0m1_l(p0_l[3]), .am4(a[0]), .sum(sum[4]),
     .cout(cout[4]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[4]),
     .p0_l(p0_l[4]));
mul_ppgen3lsb4 I0 ( .cout(cout[3:1]), .a(a[3:0]), .sum(sum[3:0]),
     .p1_l(p1_l[3]), .p0_l(p0_l[3]), .b1(b1[2:0]), .b0(b0[2:0]));

endmodule //mul_ppgenrow3

module mul_ppgensign ( p_l, z, b, pm1_l );
output  p_l, z;
input  pm1_l;
input [2:0]  b;

assign p_l = ~(b[1] & b[2]);
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgensign

module mul_ppgen ( p_l, z, a, b, pm1_l );
output  p_l, z;
input  a, pm1_l;
input [2:0]  b;

assign p_l = ~((a ^ b[2]) & b[1]) ;
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgen

module mul_mux2 ( z, d0, d1, s );
output  z;
input  d0, d1, s;

assign z = s ? d1 : d0 ;

endmodule // mul_mux2 

module mul_booth(
	head,
        b_in,
        b0, b1, b2, b3, b4, b5, b6, b7,
	b8, b9, b10, b11, b12, b13, b14, b15, b16,
	clk, se, si, so, mul_step, tm_l
	);
input		head;		// begin of the MUL operation
input   [63:0] 	b_in;
input		clk, se, si, mul_step, tm_l;
output  [2:0]  	b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
output 		b16;
output 		so;

wire  [63:31] 	b;
wire [2:0] 	b0_in0, b1_in0,  b2_in0,  b3_in0,  b4_in0,  b5_in0,  b6_in0,  b7_in0 ;
wire [2:0] 	b8_in0, b9_in0, b10_in0, b11_in0, b12_in0, b13_in0, b14_in0, b15_in0 ;
wire [2:0] 	b0_in1, b1_in1,  b2_in1,  b3_in1,  b4_in1,  b5_in1,  b6_in1,  b7_in1 ;
wire [2:0] 	b8_in1, b9_in1, b10_in1, b11_in1, b12_in1, b13_in1, b14_in1, b15_in1 ;
wire 	   	b16_in1;

wire [2:0] 	b0_outmx, b1_outmx, b2_outmx, b3_outmx, b4_outmx, b5_outmx, b6_outmx;
wire [2:0] 	b7_outmx, b8_outmx, b9_outmx, b10_outmx, b11_outmx, b12_outmx, b13_outmx;
wire [2:0] 	b14_outmx, b15_outmx;
wire 	   	b16_outmx;
wire		clk_enb0, clk_enb1;


  mul_bodec 		encode0_a(
				.x  (1'b0),
				.b  (b_in[15:0]),
				.b0 (b0_in0),
				.b1 (b1_in0),
				.b2 (b2_in0),
				.b3 (b3_in0),
				.b4 (b4_in0),
				.b5 (b5_in0),
				.b6 (b6_in0),
				.b7 (b7_in0)
				);
				//remove 16th row since it's never the last row
				//b8_in0 = 3'b010; 
  mul_bodec		encode0_b(
				.x  (b_in[15]),
				.b  (b_in[31:16]),
				.b0 (b8_in0),
				.b1 (b9_in0),
				.b2 (b10_in0),
				.b3 (b11_in0),
				.b4 (b12_in0),
				.b5 (b13_in0),
				.b6 (b14_in0),
				.b7 (b15_in0)
				);
				// remove 32th row since it's never the last row 
				// b16_in0 = 3'b010 ;

  // Pipe picked address [63:31] and hold flop

  clken_buf     ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));
  clken_buf     ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(head & mul_step)), .tmb_l(tm_l));

  dff_s 			hld_dff0(.din(b_in[31]), .clk(clk_enb1), .q(b[31]),
                        	.se(se), .si(), .so());
  dff_s #(32) 		hld_dff(.din(b_in[63:32]), .clk(clk_enb1), .q(b[63:32]),
				.se(se), .si(), .so());

  mul_bodec     	encode1_a(
                        	.x  (b[31]),
                        	.b  (b[47:32]),
                        	.b0 (b0_in1),
                        	.b1 (b1_in1),
                        	.b2 (b2_in1),
                        	.b3 (b3_in1),
                        	.b4 (b4_in1),
                        	.b5 (b5_in1),
                        	.b6 (b6_in1),
                        	.b7 (b7_in1)
                        	);
                        	//remove 16th row since it's never the last row
                        	//b8_in1 = 3'b010;
  mul_bodec     	encode1_b(
                        	.x  (b[47]),
                        	.b  (b[63:48]),
                        	.b0 (b8_in1),
                        	.b1 (b9_in1),
                        	.b2 (b10_in1),
                        	.b3 (b11_in1),
                        	.b4 (b12_in1),
                        	.b5 (b13_in1),
                        	.b6 (b14_in1),
                        	.b7 (b15_in1)
                        	);
				assign b16_in1 = b[63] ;

// Select booth encoded b outputs and flop based on the cycle0 and cycle1 

  dp_mux2es #(3)    out_mux0(.dout(b0_outmx[2:0]),
                        .in0(b0_in0[2:0]),
                        .in1(b0_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux1(.dout(b1_outmx[2:0]),
                        .in0(b1_in0[2:0]),
                        .in1(b1_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux2(.dout(b2_outmx[2:0]),
                        .in0(b2_in0[2:0]),
                        .in1(b2_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux3(.dout(b3_outmx[2:0]),
                        .in0(b3_in0[2:0]),
                        .in1(b3_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux4(.dout(b4_outmx[2:0]),
                        .in0(b4_in0[2:0]),
                        .in1(b4_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux5(.dout(b5_outmx[2:0]),
                        .in0(b5_in0[2:0]),
                        .in1(b5_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux6(.dout(b6_outmx[2:0]),
                        .in0(b6_in0[2:0]),
                        .in1(b6_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux7(.dout(b7_outmx[2:0]),
                        .in0(b7_in0[2:0]),
                        .in1(b7_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux8(.dout(b8_outmx[2:0]),
                        .in0(b8_in0[2:0]),
                        .in1(b8_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux9(.dout(b9_outmx[2:0]),
                        .in0(b9_in0[2:0]),
                        .in1(b9_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux10(.dout(b10_outmx[2:0]),
                        .in0(b10_in0[2:0]),
                        .in1(b10_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux11(.dout(b11_outmx[2:0]),
                        .in0(b11_in0[2:0]),
                        .in1(b11_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux12(.dout(b12_outmx[2:0]),
                        .in0(b12_in0[2:0]),
                        .in1(b12_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux13(.dout(b13_outmx[2:0]),
                        .in0(b13_in0[2:0]),
                        .in1(b13_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux14(.dout(b14_outmx[2:0]),
                        .in0(b14_in0[2:0]),
                        .in1(b14_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux15(.dout(b15_outmx[2:0]),
                        .in0(b15_in0[2:0]),
                        .in1(b15_in1[2:0]),
                        .sel(~head));
  dp_mux2es         out_mux16(.dout(b16_outmx),
                        .in0(1'b0),
                        .in1(b16_in1),
                        .sel(~head));

  dff_s #(3)    out_dff0 (.din(b0_outmx[2:0]), .clk(clk_enb0), .q(b0[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff1 (.din(b1_outmx[2:0]), .clk(clk_enb0), .q(b1[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff2 (.din(b2_outmx[2:0]), .clk(clk_enb0), .q(b2[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff3 (.din(b3_outmx[2:0]), .clk(clk_enb0), .q(b3[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff4 (.din(b4_outmx[2:0]), .clk(clk_enb0), .q(b4[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff5 (.din(b5_outmx[2:0]), .clk(clk_enb0), .q(b5[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff6 (.din(b6_outmx[2:0]), .clk(clk_enb0), .q(b6[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff7 (.din(b7_outmx[2:0]), .clk(clk_enb0), .q(b7[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff8 (.din(b8_outmx[2:0]), .clk(clk_enb0), .q(b8[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff9 (.din(b9_outmx[2:0]), .clk(clk_enb0), .q(b9[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff10 (.din(b10_outmx[2:0]), .clk(clk_enb0), .q(b10[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff11 (.din(b11_outmx[2:0]), .clk(clk_enb0), .q(b11[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff12 (.din(b12_outmx[2:0]), .clk(clk_enb0), .q(b12[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff13 (.din(b13_outmx[2:0]), .clk(clk_enb0), .q(b13[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff14 (.din(b14_outmx[2:0]), .clk(clk_enb0), .q(b14[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff15 (.din(b15_outmx[2:0]), .clk(clk_enb0), .q(b15[2:0]),
			.se(se), .si(), .so());
  dff_s 	      out_dff16 (.din(b16_outmx), .clk(clk_enb0), .q(b16),
			.se(se), .si(), .so());
endmodule //mul_booth

module mul_bodec (x, b,  
        b0, b1, b2, b3, b4, b5, b6, b7);

input	x;
input   [15:0] 	b;
output  [2:0] 	b0, b1, b2, b3, b4, b5, b6, b7; 

assign b0[2] = b[1];
assign b0[1] = ~((b[1] & b[0] & x) | (~b[1] & ~b[0] & ~x)) ;
assign b0[0] = (~b[1] & b[0] & x) | (b[1] & ~b[0] & ~x) ;

assign b1[2] = b[3]; 
assign b1[1] = ~((b[3] & b[2] & b[1]) | (~b[3] & ~b[2] & ~b[1])) ;
assign b1[0] = (~b[3] & b[2] & b[1]) | (b[3] & ~b[2] & ~b[1]) ;

assign b2[2] = b[5]; 
assign b2[1] = ~((b[5] & b[4] & b[3]) | (~b[5] & ~b[4] & ~b[3])) ;
assign b2[0] = (~b[5] & b[4] & b[3]) | (b[5] & ~b[4] & ~b[3]) ;

assign b3[2] = b[7] ;
assign b3[1] = ~((b[7] & b[6] & b[5]) | (~b[7] & ~b[6] & ~b[5])) ;
assign b3[0] = (~b[7] & b[6] & b[5]) | (b[7] & ~b[6] & ~b[5]) ;

assign b4[2] = b[9] ;
assign b4[1] = ~((b[9] & b[8] & b[7]) | (~b[9] & ~b[8] & ~b[7])) ;
assign b4[0] = (~b[9] & b[8] & b[7]) | (b[9] & ~b[8] & ~b[7]) ;

assign b5[2] = b[11] ;
assign b5[1] = ~((b[11] & b[10] & b[9]) | (~b[11] & ~b[10] & ~b[9])) ;
assign b5[0] = (~b[11] & b[10] & b[9]) | (b[11] & ~b[10] & ~b[9]) ;

assign b6[2] = b[13] ;
assign b6[1] = ~((b[13] & b[12] & b[11]) | (~b[13] & ~b[12] & ~b[11])) ;
assign b6[0] = (~b[13] & b[12] & b[11]) | (b[13] & ~b[12] & ~b[11]) ;

assign b7[2] = b[15] ;
assign b7[1] = ~((b[15] & b[14] & b[13]) | (~b[15] & ~b[14] & ~b[13])) ;
assign b7[0] = (~b[15] & b[14] & b[13]) | (b[15] & ~b[14] & ~b[13]) ;

endmodule // mul_bodec

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_clib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: swrvr_clib.v
//      Description: Design control behavioural library
*/                 





// POSITVE-EDGE TRIGGERED FLOP with SCAN
module dff_s (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;










endmodule // dff_s

// POSITVE-EDGE TRIGGERED FLOP with SCAN for Shadow-scan
module dff_sscan (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;










always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;

assign so={SIZE{1'b0}};


endmodule // dff_sscan

// POSITVE-EDGE TRIGGERED FLOP without SCAN
module dff_ns (din, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)

	q[SIZE-1:0]  <= din[SIZE-1:0] ;

endmodule // dff_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET
module dffr_s (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= ((rst) ? {SIZE{1'b0}}  : din[SIZE-1:0] );










endmodule // dffr_s

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET_L
module dffrl_s (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};










endmodule // dffrl_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, without SCAN
module dffr_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];
   
endmodule // dffr_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, without SCAN
module dffrl_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};

endmodule // dffrl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN and FUNCTIONAL ENABLE
module dffe_s (din, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// en	se	out
//------------------
// x	1	sin ; scan dominates
// 1  	0	din
// 0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) ;









endmodule // dffe_s

// POSITIVE-EDGE TRIGGERED FLOP with enable, without SCAN
module dffe_ns (din, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)
  q[SIZE-1:0] <= en ? din[SIZE-1:0] : q[SIZE-1:0];

endmodule // dffe_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET, FUNCTIONAL ENABLE, SCAN.
module dffre_s (din, rst, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 1	x	x	0   ; reset dominates
// 0	x	1	sin ; scan dominates
// 0	1  	0	din
// 0 	0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= (rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) ;











endmodule // dffre_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, FUNCTIONAL ENABLE, SCAN.
module dffrle_s (din, rst_l, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 0	x	x	0   ; reset dominates
// 1	x	1	sin ; scan dominates
// 1	1  	0	din
// 1 	0 	0	q
//


always @ (posedge clk)
	 q[SIZE-1:0]  <= (rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}}) ;










endmodule // dffrle_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, ENABLE, without SCAN.
module dffre_ns (din, rst, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 1	x	0   ; reset dominates
// 0	1  	din
// 0 	0 	q
//

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0]);

endmodule // dffre_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, ENABLE, without SCAN.
module dffrle_ns (din, rst_l, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 0	x	0   ; reset dominates
// 1	1  	din
// 1 	0 	q
//

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}} ;

endmodule // dffrle_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET
module dffr_async (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or posedge rst)
	q[SIZE-1:0]  <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];










endmodule // dffr_async

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET_L
module dffrl_async (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or negedge rst_l)
 
  if (!rst_l) q[SIZE-1:0] <= {SIZE{1'b0}}; else q[SIZE-1:0]  <= din[SIZE-1:0];
 












endmodule // dffrl_async

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET, without SCAN
//module dffr_async_ns (din, clk, rst, q);
//// synopsys template
//parameter SIZE = 1;
//input   [SIZE-1:0]      din ;   // data in
//input                   clk ;   // clk or scan clk
//input                   rst ;   // reset
//output  [SIZE-1:0]      q ;     // output
//reg     [SIZE-1:0]      q ;
// Reset dominates
//// synopsys async_set_reset "rst"
//always @ (posedge clk or posedge rst)
//        if(rst) q[SIZE-1:0]  <= {SIZE{1'b0}};
//        else if(clk) q[SIZE-1:0]  <= din[SIZE-1:0];
//endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET_L, without SCAN
module dffrl_async_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

// Reset dominates
// synopsys async_set_reset "rst_l"
 reg [SIZE-1:0] q;   
always @ (posedge clk or negedge rst_l) begin
 
    if (~rst_l) begin
        q[SIZE-1:0] <=  {SIZE{1'b0}};
    end else begin
        q[SIZE-1:0] <=  ({SIZE{rst_l}} & din[SIZE-1:0]);
    end
 



end

//   reg  [SIZE-1:0]   qm, qs, qm_l, qs_l, qm_f, qs_f;
//   wire              s_l;
//   assign            s_l = 1'b1;
//
//   always @ (rst_l or qm)   qm_l = ~(qm & {SIZE{rst_l}});
//   always @ (s_l or qs)   qs_l = ~(qs & {SIZE{s_l}});
//   always @ (s_l or qm_l) qm_f = ~(qm_l & {SIZE{s_l}});
//   always @ (rst_l or qs_l) qs_f = ~(qs_l & {SIZE{rst_l}});
//
//   always @ (clk or din or qm_f)
//      qm <= clk ? qm_f : din;
//
//   always @ (clk or qm_l or qs_f)
//      qs <= clk ? qm_l : qs_f;
//
//   assign q  = ~qs;

endmodule // dffrl_async_ns

// 2:1 MUX WITH DECODED SELECTS
module mux2ds (dout, in0, in1, sel0, sel1) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel0;
input			sel1;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;

// priority encoding takes care of mutex'ing selects.




wire [1:0] sel = {sel1, sel0}; // 0in one_hot
   
always @ (sel0 or sel1 or in0 or in1)

	case ({sel1,sel0}) // synopsys infer_mux
		2'b01 :	dout = in0 ;
		2'b10 : dout = in1 ;
		2'b11 : dout = {SIZE{1'bx}} ;
		2'b00 : dout = {SIZE{1'bx}} ;
			// 2'b00 : // E.g. 4state vs. 2state modelling.
			// begin
			//	`ifdef FOUR_STATE
			//		dout = {SIZE{1'bx}};
			//	`else
			//		begin
			//		dout = {SIZE{1'b0}};
			//		$error();
			//		end
			//	`endif
			// end
		default : dout = {SIZE{1'bx}};
	endcase

endmodule // mux2ds

// 3:1 MUX WITH DECODED SELECTS
module mux3ds (dout, in0, in1, in2, sel0, sel1, sel2) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0;
input			sel1;
input			sel2;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or in0 or in1 or in2)

	case ({sel2,sel1,sel0}) 
		3'b001 : dout = in0 ;
		3'b010 : dout = in1 ;
		3'b100 : dout = in2 ;
		3'b000 : dout = {SIZE{1'bx}} ;
		3'b011 : dout = {SIZE{1'bx}} ;
		3'b101 : dout = {SIZE{1'bx}} ;
		3'b110 : dout = {SIZE{1'bx}} ;
		3'b111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux3ds

// 4:1 MUX WITH DECODED SELECTS
module mux4ds (dout, in0, in1, in2, in3, sel0, sel1, sel2, sel3) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0;
input			sel1;
input			sel2;
input			sel3;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [3:0] sel = {sel3,sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or sel3 or in0 or in1 or in2 or in3)

	case ({sel3,sel2,sel1,sel0}) 
		4'b0001 : dout = in0 ;
		4'b0010 : dout = in1 ;
		4'b0100 : dout = in2 ;
		4'b1000 : dout = in3 ;
		4'b0000 : dout = {SIZE{1'bx}} ;
		4'b0011 : dout = {SIZE{1'bx}} ;
		4'b0101 : dout = {SIZE{1'bx}} ;
		4'b0110 : dout = {SIZE{1'bx}} ;
		4'b0111 : dout = {SIZE{1'bx}} ;
		4'b1001 : dout = {SIZE{1'bx}} ;
		4'b1010 : dout = {SIZE{1'bx}} ;
		4'b1011 : dout = {SIZE{1'bx}} ;
		4'b1100 : dout = {SIZE{1'bx}} ;
		4'b1101 : dout = {SIZE{1'bx}} ;
		4'b1110 : dout = {SIZE{1'bx}} ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux4ds

// SINK FOR UNLOADED INPUT PORTS
module sink (in);
// synopsys template

parameter SIZE = 1;

input [SIZE-1:0] in;

// Alexey
// `ifdef PITON_PROTO
   // As of version 8.2 XST does not remove this module without the
   // following additional dead code

   wire    a;

   assign		a = | in;

// `endif

endmodule //sink

// SOURCE FOR UNDRIVEN OUTPUT PORTS
module source (out) ;
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0] out;
// 
// Once 4state/2state model established
// then enable check.
// `ifdef FOUR_STATE
// leda check for x_or_z_in rhs_of assign turned off
// assign  out = {SIZE{1'bx}};
//`else
assign  out = {SIZE{1'b0}};
//`endif

endmodule //source

// 2:1 MUX WITH PRIORITY ENCODED SELECTS
//module mux2es (dout, in0, in1, sel0, sel1) ;
//
//parameter SIZE = 1;
//
//output 	[SIZE-1:0] 	dout;
//input	[SIZE-1:0]	in0;
//input	[SIZE-1:0]	in1;
//input			sel0;
//input			sel1;
//
//// reg declaration does not imply state being maintained
//// across cycles. Used to construct case statement and
//// always updated by inputs every cycle.
//reg	[SIZE-1:0]	dout ;
//
//// must take into account lack of mutex selects.
//// there is no reason for handling of x and z conditions.
//// This will be dictated by design.
//always @ (sel0 or sel1 or in0 or in1)
//
//	case ({sel1,sel0})
//		2'b1x : dout = in1 ; // 10(in1),11(z) 
//		2'b0x :	dout = in0 ; // 01(in0),00(x)
//	endcase
//
//endmodule // mux2es

// CLK Header for gating off the clock of
// a FF.
// clk - output of the clk header
// rclk - input clk
// enb_l - Active low clock enable
// tmb_l  - Active low clock enable ( in scan mode, this input is !se )

module clken_buf (clk, rclk, enb_l, tmb_l);
output clk;
input  rclk, enb_l, tmb_l;
reg    clken;

  always @ (rclk or enb_l or tmb_l)
    if (!rclk)  //latch opens on rclk low phase
      clken = !enb_l | !tmb_l;
  assign clk = clken & rclk;

endmodule



// The following flops are maintained and used in ENET , MAC IP  ONLY
// -- Mimi X61467

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys sync_set_reset "set_l"
always @ (posedge clk)
  q[SIZE-1:0] <= set_l ? din[SIZE-1:0] : {SIZE{1'b1}};

endmodule // dffsl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_async_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys async_set_reset "set_l"
always @ (posedge clk or negedge set_l) begin

    if (~set_l) begin
        q[SIZE-1:0] <= {SIZE{1'b1}};
    end else begin
        q[SIZE-1:0] <= ({SIZE{~set_l}} | din[SIZE-1:0]);
    end



end
endmodule // dffsl_async_ns

// POSITIVE-EDGE TRIGGERED FLOP WITH SET_H , without SCAN.

module dffr_ns_r1 (din, clk, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_ns_r1

// POSITIVE-EDGE TRIGGERED ASYNC RESET_H FLOP , without SCAN.

module dffr_async_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset dominates
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];

endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_r1 (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset to 1
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_r1


// NEGATIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_cl_r1 (din, clkl, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clkl ;  // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (negedge clkl or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_cl_r1

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_dlib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// DP library

// 2:1 MUX WITH ENCODED SELECT
module dp_mux2es (dout, in0, in1, sel) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel;

reg	[SIZE-1:0]	dout ;

always @ (sel or in0 or in1)

 begin
	   case (sel)
	     1'b1: dout = in1 ; 
	     1'b0: dout = in0;
	     default: 
         begin
            if (in0 == in1) begin
               dout = in0;
            end
            else
              dout = {SIZE{1'bx}};
         end
	   endcase // case(sel)
 end

endmodule // dp_mux2es

// ----------------------------------------------------------------------


// 4:1 MUX WITH DECODED SELECTS
module dp_mux4ds (dout, in0, in1, in2, in3, 
		     sel0_l, sel1_l, sel2_l, sel3_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [3:0] sel = {sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3)

	case ({sel3_l,sel2_l,sel1_l,sel0_l})
		4'b1110 : dout = in0 ;
		4'b1101 : dout = in1 ;
		4'b1011 : dout = in2 ;
		4'b0111 : dout = in3 ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux4ds

// ----------------------------------------------------------------------


// 5:1 MUX WITH DECODED SELECTS
module dp_mux5ds (dout, in0, in1, in2, in3,  in4,
		     sel0_l, sel1_l, sel2_l, sel3_l, sel4_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [4:0] sel = {sel4_l,sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or sel4_l or
		in0 or in1 or in2 or in3 or in4)

	case ({sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		5'b11110 : dout = in0 ;
		5'b11101 : dout = in1 ;
		5'b11011 : dout = in2 ;
		5'b10111 : dout = in3 ;
		5'b01111 : dout = in4 ;
		5'b11111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux5ds

// --------------------------------------------------------------------

// 8:1 MUX WITH DECODED SELECTS
module dp_mux8ds (dout, in0, in1, in2, in3, 
			in4, in5, in6, in7,
		     sel0_l, sel1_l, sel2_l, sel3_l,
		     sel4_l, sel5_l, sel6_l, sel7_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input	[SIZE-1:0]	in5;
input	[SIZE-1:0]	in6;
input	[SIZE-1:0]	in7;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;
input			sel5_l;
input			sel6_l;
input			sel7_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;






wire [7:0] sel = {sel7_l,sel6_l,sel5_l,sel4_l,
                  sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3 or
	  sel4_l or sel5_l or sel6_l or sel7_l or in4 or in5 or in6 or in7)

	case ({sel7_l,sel6_l,sel5_l,sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		8'b11111110 : dout = in0 ;
		8'b11111101 : dout = in1 ;
		8'b11111011 : dout = in2 ;
		8'b11110111 : dout = in3 ;
		8'b11101111 : dout = in4 ;
		8'b11011111 : dout = in5 ;
		8'b10111111 : dout = in6 ;
		8'b01111111 : dout = in7 ;
		8'b11111111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux8ds


// ----------------------------------------------------------------------


// 3:1 MUX WITH DECODED SELECTS
module dp_mux3ds (dout, in0, in1, in2, 
		     sel0_l, sel1_l, sel2_l);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0_l;
input			sel1_l;
input			sel2_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or in0 or in1 or in2)

	case ({sel2_l,sel1_l,sel0_l})
		3'b110 : dout = in0 ;
		3'b101 : dout = in1 ;
		3'b011 : dout = in2 ;
	        default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux3ds

// ----------------------------------------------------------------------


// 2:1 MUX WITH DECODED SELECTS
module dp_mux2ds (dout, in0, in1,
             sel0_l, sel1_l);
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0]  dout;
input   [SIZE-1:0]  in0;
input   [SIZE-1:0]  in1;
input           sel0_l;
input           sel1_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg [SIZE-1:0]  dout ;





wire [1:0] sel = {sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or in0 or in1)

    case ({sel1_l,sel0_l})
        3'b10 : dout = in0 ;
        3'b01 : dout = in1 ;
            default : dout = {SIZE{1'bx}} ;
    endcase

endmodule // dp_mux3ds

// ---------------------------------------------------------------------


module dp_buffer(dout, in);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in;

assign dout = in;

endmodule // dp_buffer









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: test_stub_scan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// ____________________________________________________________________________
//
//  test_stub_bist - Test Stub with Scan Support
// ____________________________________________________________________________
//
// Description: DBB interface for test signal generation
// ____________________________________________________________________________

module test_stub_scan (/*AUTOARG*/
// Outputs
mux_drive_disable, mem_write_disable, sehold, se, testmode_l, 
mem_bypass, so_0, so_1, so_2, 
// Inputs
ctu_tst_pre_grst_l, arst_l, global_shift_enable, 
ctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, 
ctu_tst_short_chain, long_chain_so_0, short_chain_so_0, 
long_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2
);

   input        ctu_tst_pre_grst_l;
   input        arst_l;                // no longer used
   input        global_shift_enable;
   input        ctu_tst_scan_disable;  // redefined as pin_based_scan
   input        ctu_tst_scanmode;
   input 	ctu_tst_macrotest;
   input 	ctu_tst_short_chain;
   input 	long_chain_so_0;
   input 	short_chain_so_0;
   input 	long_chain_so_1;
   input 	short_chain_so_1;
   input 	long_chain_so_2;
   input 	short_chain_so_2;
   
   output 	mux_drive_disable;
   output 	mem_write_disable;
   output 	sehold;
   output 	se;
   output 	testmode_l;
   output 	mem_bypass;
   output 	so_0;
   output 	so_1;
   output 	so_2;

   wire         pin_based_scan;
   wire         short_chain_en;
   wire         short_chain_select;

   // INTERNAL CLUSTER CONNECTIONS
   //
   // Scan Chain Hookup
   // =================
   //
   // Scan chains have two configurations: long and short.
   // The short chain is typically the first tenth of the
   // long chain. The short chain should contain memory
   // collar flops for deep arrays. The CTU determines
   // which configuration is selected. Up to three chains
   // are supported.
   //
   // The scanout connections from the long and short
   // chains connect to the following inputs:
   //
   // long_chain_so_0, short_chain_so_0 (mandatory)
   // long_chain_so_1, short_chain_so_1 (optional)
   // long_chain_so_2, short_chain_so_2 (optional)
   //
   // The test stub outputs should connect directly to the
   // scanout port(s) of the cluster:
   //
   // so_0 (mandatory), so_1 (optional), so_2 (optional)
   //
   //
   // Static Output Signals
   // =====================
   //
   // testmode_l
   //
   // Local testmode control for overriding gated
   // clocks, asynchronous resets, etc. Asserted
   // for all shift-based test modes.
   //
   // mem_bypass
   //
   // Memory bypass control for arrays without output
   // flops. Allows testing of shadow logic. Asserted
   // for scan test; de-asserted for macrotest.
   //
   //
   // Dynamic Output Signals
   // ======================
   //
   // sehold
   //
   // The sehold signal needs to be set for macrotest
   // to allow holding flops in the array collars
   // to retain their shifted data during capture.
   // Inverted version of scan enable during macrotest.
   //
   // mux_drive_disable (for mux/long chain protection)
   //
   // Activate one-hot mux protection circuitry during
   // scan shift and reset. Formerly known as rst_tri_en.
   // Also used by long chain memories with embedded
   // control.
   //
   // mem_write_disable (for short chain protection)
   //
   // Protects contents of short chain memories during
   // shift and POR.
   //
   // se

   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;
   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;
   assign  sehold             = ctu_tst_macrotest & ~se;
   assign  se                 = global_shift_enable;
   assign  testmode_l         = ~ctu_tst_scanmode;
   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;
   assign  pin_based_scan     = ctu_tst_scan_disable;
   assign  short_chain_en     = ~(pin_based_scan & se);
   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;
   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;
   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;
   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;
   
endmodule // test_stub_scan
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: u1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
//
// basic gates {
//
////////////////////////////////////////////////////////////////////////


//bw_u1_inv_0p6x
//
//

module bw_u1_inv_0p6x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1x
//
//

module bw_u1_inv_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1p4x
//
//

module bw_u1_inv_1p4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_2x
//
//

module bw_u1_inv_2x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_3x
//
//

module bw_u1_inv_3x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_4x
//
//

module bw_u1_inv_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule



//bw_u1_inv_5x
//
//

module bw_u1_inv_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_8x
//
//

module bw_u1_inv_8x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_10x
//
//

module bw_u1_inv_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_15x
//
//

module bw_u1_inv_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_20x
//
//

module bw_u1_inv_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_30x
//
//

module bw_u1_inv_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_40x
//
//

module bw_u1_inv_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_15x
//
//

module bw_u1_invh_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_25x
//
//

module bw_u1_invh_25x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_30x
//
//

module bw_u1_invh_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_50x
//
//

module bw_u1_invh_50x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_60x
//
//

module bw_u1_invh_60x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule




//bw_u1_nand2_0p4x
//
//
module bw_u1_nand2_0p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_0p6x
//
//
module bw_u1_nand2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1x
//
//
module bw_u1_nand2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1p4x
//
//
module bw_u1_nand2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_2x
//
//
module bw_u1_nand2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_3x
//
//
module bw_u1_nand2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_4x
//
//
module bw_u1_nand2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_5x
//
//
module bw_u1_nand2_5x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_7x
//
//
module bw_u1_nand2_7x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_10x
//
//
module bw_u1_nand2_10x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_15x
//
//
module bw_u1_nand2_15x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand3_0p4x
//
//
module bw_u1_nand3_0p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule




//bw_u1_nand3_0p6x
//
//
module bw_u1_nand3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule



//bw_u1_nand3_1x

//
//
module bw_u1_nand3_1x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_1p4x

//
//
module bw_u1_nand3_1p4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_2x

//
//
module bw_u1_nand3_2x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_3x

//
//
module bw_u1_nand3_3x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_4x

//
//
module bw_u1_nand3_4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_5x

//
//
module bw_u1_nand3_5x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_7x

//
//
module bw_u1_nand3_7x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_10x

//
//
module bw_u1_nand3_10x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand4_0p6x

//
//
module bw_u1_nand4_0p6x (
    z,
    a,  
    b,  
    c,  
    d );
    
    output z;
    input  a;
    input  b;
    input  c;
    input  d;
    
    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1x
//
//
module bw_u1_nand4_1x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1p4x
//
//
module bw_u1_nand4_1p4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_2x
//
//
module bw_u1_nand4_2x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_3x
//
//
module bw_u1_nand4_3x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_4x
//
//
module bw_u1_nand4_4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_6x
//
//

module bw_u1_nand4_6x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nand4_8x
//
//

module bw_u1_nand4_8x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nor2_0p6x
//
//

module bw_u1_nor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1x
//
//

module bw_u1_nor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1p4x
//
//

module bw_u1_nor2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_2x
//
//

module bw_u1_nor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_3x
//
//

module bw_u1_nor2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_4x
//
//

module bw_u1_nor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_6x
//
//

module bw_u1_nor2_6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_8x
//
//

module bw_u1_nor2_8x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_12x
//
//

module bw_u1_nor2_12x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule




//bw_u1_nor3_0p6x
//
//

module bw_u1_nor3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1x
//
//

module bw_u1_nor3_1x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1p4x
//
//

module bw_u1_nor3_1p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_2x
//
//

module bw_u1_nor3_2x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_3x
//
//

module bw_u1_nor3_3x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_4x
//
//

module bw_u1_nor3_4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_6x
//
//

module bw_u1_nor3_6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_8x
//
//

module bw_u1_nor3_8x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_aoi21_0p4x
//
// 
module bw_u1_aoi21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_1x
//
// 
module bw_u1_aoi21_1x (

    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a  ));

endmodule
//bw_u1_aoi21_2x
//
// 
module bw_u1_aoi21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_4x
//
// 
module bw_u1_aoi21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_8x
//
// 
module bw_u1_aoi21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_12x
//
// 
module bw_u1_aoi21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi22_0p4x
//
// 
module bw_u1_aoi22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_1x
//
// 
module bw_u1_aoi22_1x (
    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;


    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_2x
//
// 
module bw_u1_aoi22_2x (


    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;
 
    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_4x
//
// 
module bw_u1_aoi22_4x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_8x
//
// 
module bw_u1_aoi22_8x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi211_0p3x
//
// 
module bw_u1_aoi211_0p3x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_1x
//
// 
module bw_u1_aoi211_1x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_2x
//
// 
module bw_u1_aoi211_2x (



    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_4x
//
// 
module bw_u1_aoi211_4x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_8x
//
// 
module bw_u1_aoi211_8x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_oai21_0p4x
//
//
module bw_u1_oai21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_1x
//
//
module bw_u1_oai21_1x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_2x
//
//
module bw_u1_oai21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_4x
//
//
module bw_u1_oai21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_8x
//
//
module bw_u1_oai21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_12x
//
//
module bw_u1_oai21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai22_0p4x
// 
module bw_u1_oai22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_1x
// 
module bw_u1_oai22_1x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_2x
// 
module bw_u1_oai22_2x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_4x
// 
module bw_u1_oai22_4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_8x
// 
module bw_u1_oai22_8x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai211_0p3x
//
//
module bw_u1_oai211_0p3x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_1x
//
//
module bw_u1_oai211_1x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_2x
//
//
module bw_u1_oai211_2x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_4x
//
//
module bw_u1_oai211_4x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_8x
//
//
module bw_u1_oai211_8x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_aoi31_1x
//
// 
module bw_u1_aoi31_1x (


    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_2x
//
// 
module bw_u1_aoi31_2x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_4x
//
// 
module bw_u1_aoi31_4x (
    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_8x
//
// 
module bw_u1_aoi31_8x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi32_1x
//
// 
module bw_u1_aoi32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_2x
//
// 
module bw_u1_aoi32_2x (
    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_4x
//
// 
module bw_u1_aoi32_4x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_8x
//
// 
module bw_u1_aoi32_8x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 
    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi33_1x
//
//
module bw_u1_aoi33_1x (




    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_2x
//
//
module bw_u1_aoi33_2x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_4x
//
//
module bw_u1_aoi33_4x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_8x
//
//
module bw_u1_aoi33_8x (
       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi221_1x
//
// 
module bw_u1_aoi221_1x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_2x
//
// 
module bw_u1_aoi221_2x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_4x
//
// 
module bw_u1_aoi221_4x (



    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_8x
//
// 
module bw_u1_aoi221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi222_1x
//
//
module bw_u1_aoi222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_aoi222_2x
//
//
module bw_u1_aoi222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi222_4x
//
//
module bw_u1_aoi222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi311_1x
//
//
module bw_u1_aoi311_1x (

    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_2x
//
//
module bw_u1_aoi311_2x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_4x
//
//
module bw_u1_aoi311_4x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;


    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_8x
//
//
module bw_u1_aoi311_8x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_oai31_1x
//
//
module bw_u1_oai31_1x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_2x
//
//
module bw_u1_oai31_2x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_4x
//
//
module bw_u1_oai31_4x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_8x
//
//
module bw_u1_oai31_8x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai32_1x
//
//
module bw_u1_oai32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_2x
//
//
module bw_u1_oai32_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_4x
//
//
module bw_u1_oai32_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_8x
//
//
module bw_u1_oai32_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai33_1x
//
//
module bw_u1_oai33_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_2x
//
//
module bw_u1_oai33_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_4x
//
//
module bw_u1_oai33_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_8x
//
//
module bw_u1_oai33_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai221_1x
//
//
module bw_u1_oai221_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_2x
//
//
module bw_u1_oai221_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_4x
//
//
module bw_u1_oai221_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_8x
//
//
module bw_u1_oai221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai222_1x
//
//
module bw_u1_oai222_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_2x
//
//
module bw_u1_oai222_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_4x
//
//
module bw_u1_oai222_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai311_1x
//
//
module bw_u1_oai311_1x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_2x
//
//
module bw_u1_oai311_2x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_4x
//
//
module bw_u1_oai311_4x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 | c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_8x
//
//
module bw_u1_oai311_8x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_muxi21_0p6x



module bw_u1_muxi21_0p6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_1x



module bw_u1_muxi21_1x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule







//bw_u1_muxi21_2x



module bw_u1_muxi21_2x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_4x



module bw_u1_muxi21_4x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule




//bw_u1_muxi21_6x


module bw_u1_muxi21_6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule

//bw_u1_muxi31d_4x
//

module bw_u1_muxi31d_4x (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
        zmuxi31d_prim i0 ( z, d0, d1, d2, s0, s1, s2 );
endmodule

//bw_u1_muxi41d_4x
//

module bw_u1_muxi41d_4x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule

//bw_u1_muxi41d_6x
//

module bw_u1_muxi41d_6x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule
 

//bw_u1_xor2_0p6x
//
// 
module bw_u1_xor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_1x
//
// 
module bw_u1_xor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_2x
//
// 
module bw_u1_xor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_4x
//
// 
module bw_u1_xor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xnor2_0p6x
//
// 
module bw_u1_xnor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_1x
//
// 
module bw_u1_xnor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_2x
//
// 
module bw_u1_xnor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_4x
//
// 
module bw_u1_xnor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule

//bw_u1_buf_1x
//

module bw_u1_buf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_buf_5x
//

module bw_u1_buf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_10x
//

module bw_u1_buf_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_15x
//

module bw_u1_buf_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_20x
//

module bw_u1_buf_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_30x
//

module bw_u1_buf_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_40x
//

module bw_u1_buf_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_ao2222_1x
//
//
module bw_u1_ao2222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_ao2222_2x
//
//
module bw_u1_ao2222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_ao2222_4x
//
//
module bw_u1_ao2222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

////////////////////////////////////////////////////////////////////////
//
// flipflops {
//
////////////////////////////////////////////////////////////////////////

//      scanable D-flipflop with scanout

module bw_u1_soff_1x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_2x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_8x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

//      fast scanable D-flipflop with scanout with inverted Q output

module bw_u1_soffi_4x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule
  
module bw_u1_soffi_8x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule

//      scanable D-flipflop with scanout with 2-to-1 input mux

module bw_u1_soffm2_4x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

module bw_u1_soffm2_8x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

//      scanable D-flipflop with scanout with sync reset-bar

module bw_u1_soffr_2x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule
  
module bw_u1_soffr_4x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

module bw_u1_soffr_8x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

//bw_u1_soffasr_2x

module bw_u1_soffasr_2x (q, so, ck, d, r_l, s_l, se, sd);
output q, so;
input  ck, d, r_l, s_l, se, sd;
        zsoffasr_prim i0 (q, so, ck, d, r_l, s_l, se, sd);
endmodule


//bw_u1_ckbuf_1p5x


module bw_u1_ckbuf_1p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_3x


module bw_u1_ckbuf_3x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_4p5x


module bw_u1_ckbuf_4p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_6x


module bw_u1_ckbuf_6x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_7x
//

module bw_u1_ckbuf_7x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_8x
//
module bw_u1_ckbuf_8x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_11x
//

module bw_u1_ckbuf_11x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_14x
//

module bw_u1_ckbuf_14x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_17x
//

module bw_u1_ckbuf_17x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_19x
//

module bw_u1_ckbuf_19x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_22x
//

module bw_u1_ckbuf_22x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_25x
//

module bw_u1_ckbuf_25x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_28x
//

module bw_u1_ckbuf_28x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_30x
//

module bw_u1_ckbuf_30x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_33x
//

module bw_u1_ckbuf_33x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_40x
//

module bw_u1_ckbuf_40x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


// gated clock buffers


module bw_u1_ckenbuf_6x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

module bw_u1_ckenbuf_14x (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule   

////////////////////////////////////////////////////////////////////////
//
// half cells
//
////////////////////////////////////////////////////////////////////////



module bw_u1_zhinv_0p6x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_1x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_1p4x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_2x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_3x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_4x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhnand2_0p4x (z, a, b);
output z;
input  a, b;
        nand (z, a, b);
endmodule


module bw_u1_zhnand2_0p6x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1p4x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_2x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_3x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_1x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_2x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule


module bw_u1_zhnand4_0p6x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_1x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_2x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule


        
module bw_u1_zhnor2_0p6x (z, a, b);
output z;
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_1x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_2x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule



module bw_u1_zhnor3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nor (z, a, b, c);
endmodule


module bw_u1_zhaoi21_0p4x (z,b1,b2,a);

    output z;   
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));
    
endmodule



module bw_u1_zhaoi21_1x (z, a, b1, b2);

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule



module bw_u1_zhoai21_1x (z,b1,b2,a );
    
    output z;
    input  b1;
    input  b2;  
    input  a;
  
    assign z = ~(( b1 | b2 ) & ( a ));
      
endmodule




module bw_u1_zhoai211_0p3x (z, a, b, c1, c2);
    output z; 
    input  c1;  
    input  c2;
    input  b;
    input  a;
      
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





module bw_u1_zhoai211_1x (z, a, b, c1, c2);
output z;
input  a, b, c1, c2;
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





/////////////// Scan data lock up latch ///////////////

module bw_u1_scanlg_2x (so, sd, ck, se);
output so;
input sd, ck, se;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd or se )
       if (~ck) so_l <= ~(sd & se) ;

endmodule

module bw_u1_scanl_2x (so, sd, ck);
output so;
input sd, ck;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd )
       if (~ck) so_l <= ~sd ;

endmodule



////////////////// Synchronizer ////////////////

module bw_u1_syncff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;

reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r;

endmodule




////////////////////////////////////////////////////////////////////////
//
// non library cells
// 
////////////////////////////////////////////////////////////////////////

// These cells are used only in custom DP macros
// Do not use in any block design without prior permission


module bw_u1_zzeccxor2_5x (z, a, b); 
 output z; 
 input a, b;
    assign z = ( a ^ b );

endmodule



module bw_u1_zzmulcsa42_5x (sum, carry, cout, a, b, c, d, cin);
output sum, carry, cout;
input  a, b, c, d, cin;
wire and_cin_b, or_cin_b, xor_a_c_d, and_or_cin_b_xor_a_c_d;
wire and_a_c, and_a_d, and_c_d;
        assign sum   = cin ^ a ^ b ^ c ^ d;
        assign carry = cin & b | (cin | b) & (a ^ c ^ d);
        assign cout  = a & c | a & d | c & d;
endmodule



module bw_u1_zzmulcsa32_5x (sum, cout, a, b, c);
output sum, cout;
input  a, b, c;
wire and_a_b, and_a_c, and_b_c;
        assign sum  = a ^ b ^ c ;
        assign cout = a & b | a & c | b & c ;
endmodule



module bw_u1_zzmulppmuxi21_2x ( z, d0, d1, s );
output  z;
input  d0, d1, s;
    assign z = s ? ~d1 : ~d0;
endmodule



module bw_u1_zzmulnand2_2x ( z, a, b );
output z;
input  a;
input  b;
    assign z = ~( a & b );
endmodule



// Primitives




module zmuxi31d_prim (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
// for Blacktie



wire [2:0] sel = {s0,s1,s2}; // 0in one_hot
reg z;
    always @ (s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s2,d2,s1,d1,s0,d0})
            6'b0?0?10: z = 1'b1;  
            6'b0?0?11: z = 1'b0;  
            6'b0?100?: z = 1'b1;  
            6'b0?110?: z = 1'b0;  
            6'b0?1010: z = 1'b1;  
            6'b0?1111: z = 1'b0;  
            6'b100?0?: z = 1'b1;  
            6'b110?0?: z = 1'b0;  
            6'b100?10: z = 1'b1;  
            6'b110?11: z = 1'b0;  
            6'b10100?: z = 1'b1;  
            6'b11110?: z = 1'b0;  
            6'b101010: z = 1'b1;  
            6'b111111: z = 1'b0;  
            default: z = 1'bx;
        endcase
endmodule







module zmuxi41d_prim (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
// for Blacktie



wire [3:0] sel = {s0,s1,s2,s3}; // 0in one_hot
reg z;
    always @ (s3 or d3 or s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s3,d3,s2,d2,s1,d1,s0,d0})
            8'b0?0?0?10: z = 1'b1;
            8'b0?0?0?11: z = 1'b0;
            8'b0?0?100?: z = 1'b1;
            8'b0?0?110?: z = 1'b0;
            8'b0?0?1010: z = 1'b1;
            8'b0?0?1111: z = 1'b0;
            8'b0?100?0?: z = 1'b1;
            8'b0?110?0?: z = 1'b0;
            8'b0?100?10: z = 1'b1;
            8'b0?110?11: z = 1'b0;
            8'b0?10100?: z = 1'b1;
            8'b0?11110?: z = 1'b0;
            8'b0?101010: z = 1'b1;
            8'b0?111111: z = 1'b0;
            8'b100?0?0?: z = 1'b1;
            8'b110?0?0?: z = 1'b0;
            8'b100?0?10: z = 1'b1;
            8'b110?0?11: z = 1'b0;
            8'b100?100?: z = 1'b1;
            8'b110?110?: z = 1'b0;
            8'b100?1010: z = 1'b1;
            8'b110?1111: z = 1'b0;
            8'b10100?0?: z = 1'b1;
            8'b11110?0?: z = 1'b0;
            8'b10100?10: z = 1'b1;
            8'b11110?11: z = 1'b0;
            8'b1010100?: z = 1'b1;
            8'b1111110?: z = 1'b0;
            8'b10101010: z = 1'b1;
            8'b11111111: z = 1'b0;
            default: z = 1'bx;
        endcase   
endmodule



module zsoff_prim (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r ;
endmodule


module zsoffr_prim (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (d & r_l) ;
  assign q  = q_r;
  assign so = q_r;
endmodule


module zsoffi_prim (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q_l = ~q_r;
  assign so  = q_r;
endmodule



module zsoffm2_prim (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (s ? d1 : d0) ;
  assign q  = q_r;
  assign so = q_r;
endmodule

module zsoffasr_prim (q, so, ck, d, r_l, s_l, se, sd);
  output q, so;
  input ck, d, r_l, s_l, se, sd;

  // asynchronous reset and asynchronous set
  // (priority: r_l > s_l > se > d)
  reg q;
  wire so;

  always @ (posedge ck or negedge r_l or negedge s_l) begin
		if(~r_l) q <= 1'b0;
		else if (~s_l) q <= r_l;
		else if (se) q <= r_l & s_l & sd;
		else q <= r_l & s_l & (~se) & d;
  end

  assign so = q | ~se;

endmodule



module zckenbuf_prim (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
reg    clken;

  always @ (rclk or en_l or tm_l)
    if (!rclk)  //latch opens on rclk low phase
      clken <= ~en_l | ~tm_l;
  assign clk = clken & rclk;

endmodule

module bw_mckbuf_40x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_33x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_30x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_28x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_25x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_22x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_19x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_17x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_14x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_11x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_8x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_7x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_6x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_4p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_3x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_1p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

//bw_u1_minbuf_1x
//

module bw_u1_minbuf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_4x
//

module bw_u1_minbuf_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_5x
//

module bw_u1_minbuf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

module bw_u1_ckenbuf_4p5x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

// dummy fill modules to get rid of DFT "CAP" property errors (bug 5487)

module bw_u1_fill_1x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_2x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_3x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_4x(\vdd! );
input \vdd! ;
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_in.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:	ucb_bus_in (ucb bus inbound interface block)
//  Description:	This interface block is instaniated by the
//                      UCB modules and IO Bridge to receive packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
			// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Interface signal list declarations
////////////////////////////////////////////////////////////////////////
module ucb_bus_in (/*AUTOARG*/
   // Outputs
   stall, indata_buf_vld, indata_buf,
   // Inputs
   rst_l, clk, vld, data, stall_a1
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;


////////////////////////////////////////////////////////////////////////
// Signal declarations
////////////////////////////////////////////////////////////////////////
   // Global interface
   input                     rst_l;
   input 		     clk;


   // UCB bus interface
   input 		     vld;
   input [UCB_BUS_WIDTH-1:0] data;
   output 		     stall;


   // Local interface
   output 		     indata_buf_vld;
   output [REG_WIDTH+63:0]   indata_buf;
   input 		     stall_a1; // would this prevent indata_buf to change?


   // Internal signals
   wire 		     vld_d1;
   wire 		     stall_d1;
   wire [UCB_BUS_WIDTH-1:0]  data_d1;
   wire 		     skid_buf0_en;
   wire 		     vld_buf0;
   wire [UCB_BUS_WIDTH-1:0]  data_buf0;
   wire 		     skid_buf1_en;
   wire 		     vld_buf1;
   wire [UCB_BUS_WIDTH-1:0]  data_buf1;
   wire 		     skid_buf0_sel;
   wire 		     skid_buf1_sel;
   wire 		     vld_mux;
   wire [UCB_BUS_WIDTH-1:0]  data_mux;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec_next;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec;
   wire [REG_WIDTH+63:0]     indata_buf_next;
   wire 		     indata_vec0_d1;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    * This is to make signals going between IOB and UCB flop-to-flop
    * to improve timing.
    ************************************************************/
   dffrle_ns #(1) vld_d1_ff (.din(vld),
			     .rst_l(rst_l),
			     .en(~stall_d1),
			     .clk(clk),
			     .q(vld_d1));

   dffe_ns #(UCB_BUS_WIDTH) data_d1_ff (.din(data),
					.en(~stall_d1),
					.clk(clk),
					.q(data_d1));

   dffrl_ns #(1) stall_ff (.din(stall_a1),
			   .clk(clk),
			   .rst_l(rst_l),
			   .q(stall));

   dffrl_ns #(1) stall_d1_ff (.din(stall),
			      .clk(clk),
			      .rst_l(rst_l),
			      .q(stall_d1));


   /************************************************************
    * Skid buffer
    * We need a two deep skid buffer to handle stalling.
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   // Buffer 0
   assign 	 skid_buf0_en = stall_a1 & ~stall;

   dffrle_ns #(1) vld_buf0_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf0_en),
			       .clk(clk),
			       .q(vld_buf0));

   dffe_ns #(UCB_BUS_WIDTH) data_buf0_ff (.din(data_d1),
					  .en(skid_buf0_en),
					  .clk(clk),
					  .q(data_buf0));

   // Buffer 1
   dffrl_ns #(1) skid_buf1_en_ff (.din(skid_buf0_en),
				  .clk(clk),
				  .rst_l(rst_l),
				  .q(skid_buf1_en));

   dffrle_ns #(1) vld_buf1_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf1_en),
			       .clk(clk),
			       .q(vld_buf1));

   dffe_ns #(UCB_BUS_WIDTH) data_buf1_ff (.din(data_d1),
					  .en(skid_buf1_en),
					  .clk(clk),
					  .q(data_buf1));


   /************************************************************
    * Mux between skid buffer and interface flop
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   assign 	 skid_buf0_sel = ~stall_a1 & stall;

   dffrl_ns #(1) skid_buf1_sel_ff (.din(skid_buf0_sel),
				   .clk(clk),
				   .rst_l(rst_l),
				   .q(skid_buf1_sel));

   assign 	 vld_mux = skid_buf0_sel ? vld_buf0 :
		           skid_buf1_sel ? vld_buf1 :
		                           vld_d1;

   assign 	 data_mux = skid_buf0_sel ? data_buf0 :
		            skid_buf1_sel ? data_buf1 :
		                            data_d1;


   /************************************************************
    * Assemble inbound data
    ************************************************************/
   // valid vector
   assign 	 indata_vec_next = {vld_mux,
				    indata_vec[(REG_WIDTH+64)/UCB_BUS_WIDTH-1:1]};
   dffrle_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) indata_vec_ff (.din(indata_vec_next),
							    .en(~stall_a1),
							    .rst_l(rst_l),
							    .clk(clk),
							    .q(indata_vec));

   // data buffer
   assign 	 indata_buf_next = {data_mux,
				    indata_buf[REG_WIDTH+63:UCB_BUS_WIDTH]};
   dffe_ns #(REG_WIDTH+64) indata_buf_ff (.din(indata_buf_next),
					  .en(~stall_a1),
					  .clk(clk),
					  .q(indata_buf));

   // detect a new packet
   dffrle_ns #(1) indata_vec0_d1_ff (.din(indata_vec[0]),
				     .rst_l(rst_l),
				     .en(~stall_a1),
				     .clk(clk),
				     .q(indata_vec0_d1));

   assign        indata_buf_vld = indata_vec[0] & ~indata_vec0_d1;


endmodule // ucb_bus_in
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_out.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:        ucb_bus_out (ucb bus outbound interface block)
//	Description:	This interface block is instantiated by the
//                      UCB modules and IO Bridge to transmit packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which
                        // contains the time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module ucb_bus_out (/*AUTOARG*/
   // Outputs
   vld, data, outdata_buf_busy,
   // Inputs
   clk, rst_l, stall, outdata_buf_in, outdata_vec_in, outdata_buf_wr
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;            // maximum data bits that needs to
                                        // be sent.  Set to 64 or 128

   // Globals
   input                                clk;
   input 				rst_l;


   // UCB bus interface
   output 				vld;
   output [UCB_BUS_WIDTH-1:0] 		data;
   input 				stall;


   // Local interface
   output 				outdata_buf_busy;  // busy outputting, can't accept data into buffer
   input [REG_WIDTH+63:0] 		outdata_buf_in;
   input [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] outdata_vec_in; // indicating how much data to send
   input 				outdata_buf_wr;


   // Local signals
   wire 				stall_d1;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec_next;
   wire [REG_WIDTH+63:0] 		outdata_buf;
   reg [REG_WIDTH+63:0] 		outdata_buf_next;
   wire 				load_outdata;
   wire 				shift_outdata;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    ************************************************************/
   assign 	 vld = outdata_vec[0];
   // assign 	 data = vld ? outdata_buf[UCB_BUS_WIDTH-1:0] : `UCB_BUS_WIDTH'b0;
   assign    data = outdata_buf[UCB_BUS_WIDTH-1:0];

   dffrl_ns #(1) stall_d1_ff (.din(stall),
                              .clk(clk),
                              .rst_l(rst_l),
                              .q(stall_d1));


   /************************************************************
    * Outbound Data
    ************************************************************/
   // accept new data only if there is none being processed
   assign 	 load_outdata = outdata_buf_wr & ~outdata_buf_busy;

   assign 	 outdata_buf_busy = outdata_vec[0] | stall_d1;

   // only shifts when then input vector is a straight valids
   assign 	 shift_outdata = outdata_vec[0] & ~stall_d1;

   assign 	 outdata_vec_next =
		 load_outdata  ? outdata_vec_in:
		 shift_outdata ? outdata_vec >> 1:
	                         outdata_vec;
   dffrl_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) outdata_vec_ff (.din(outdata_vec_next),
							    .clk(clk),
							    .rst_l(rst_l),
							    .q(outdata_vec));

   // assign 	 outdata_buf_next =
		 // load_outdata  ? outdata_buf_in:
		 // shift_outdata ? (outdata_buf >> UCB_BUS_WIDTH):
	  //                        outdata_buf;
   always @ *
   begin
      if (load_outdata)
         outdata_buf_next = outdata_buf_in;
      else if (shift_outdata)
      begin
         outdata_buf_next = outdata_buf >> UCB_BUS_WIDTH;
         if (outdata_vec[1] == 1'b0)
            outdata_buf_next[UCB_BUS_WIDTH-1:0] = 0;
      end
      else
         outdata_buf_next = outdata_buf; // no shifting
   end

   dff_ns #(REG_WIDTH+64) outdata_buf_ff (.din(outdata_buf_next),
					  .clk(clk),
					  .q(outdata_buf));


endmodule // ucb_bus_out






// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//File: valrdy_to_credit.v (modified from space_avail_top.v)
//
//Modified: Yaosheng Fu
//May 2, 2014
//
//Function: This module keeps track of how many spots are free in the NIB that
//	we are sending to
//
//State: count_f, yummy_out_f, valid_in_f
//
//Instantiates: 
//

module valrdy_to_credit (
            clk,
            reset,
                
            //val/rdy interface
            data_in,
            valid_in,
            ready_in,

			//credit based interface	
            data_out,
            valid_out,
		    yummy_out);

parameter BUFFER_SIZE = 4;
parameter BUFFER_BITS = 3;
   
input clk;
input reset;

 
input [64-1:0]	 data_in;
 input valid_in;			// sending data to the output
 input yummy_out;			// output consumed data

output [64-1:0]  data_out;
 output valid_out;
 output ready_in;		// is there space available?


//This is the state
 reg yummy_out_f;
 reg valid_temp_f;
 reg [BUFFER_BITS-1:0] count_f;

reg is_one_f;
 reg is_two_or_more_f;

//wires
 wire [BUFFER_BITS-1:0] count_plus_1;
 wire [BUFFER_BITS-1:0] count_minus_1;
 wire up;
 wire down;

 wire valid_temp;

//wire regs
  reg [BUFFER_BITS-1:0] count_temp;


//assigns
assign data_out = data_in;
assign valid_temp = valid_in & ready_in;
assign valid_out = valid_temp;

assign count_plus_1 = count_f + 1'b1;
assign count_minus_1 = count_f - 1'b1;
assign ready_in = is_two_or_more_f;
assign up = yummy_out_f & ~valid_temp_f;
assign down = ~yummy_out_f & valid_temp_f;

always @ (count_f or count_plus_1 or count_minus_1 or up or down)
begin
	case (count_f)
	0:
		begin
			if(up)
			begin
				count_temp <= count_plus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	BUFFER_SIZE:
		begin
			if(down)
			begin
				count_temp <= count_minus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	default:
		begin
			case ({up, down})
				2'b10:	count_temp <= count_plus_1;
				2'b01:	count_temp <= count_minus_1;
				default:	count_temp <= count_f;
			endcase
		end
	endcase
end

//wire top_bits_zero_temp = ~| count_temp[BUFFER_BITS-1:1];
 wire top_bits_zero_temp = count_temp < 3 ? 1 : 0;

always @ (posedge clk)
begin
	if(reset)
	begin
	   count_f <= BUFFER_SIZE;
	   yummy_out_f <= 1'b0;
	   valid_temp_f <= 1'b0;
	   is_one_f <= (BUFFER_SIZE == 1);
	   is_two_or_more_f <= (BUFFER_SIZE >= 2);
	end
	else
	begin
	   count_f <= count_temp;
	   yummy_out_f <= yummy_out;
	   valid_temp_f <= valid_temp;
	   is_one_f         <= top_bits_zero_temp & count_temp[0];
   	   is_two_or_more_f <= ~top_bits_zero_temp;
	end
end

endmodule
      
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




// Uncomment to define USE_GENERIC_SRAM_IMPLEMENTATION to use the old unsynthesizable BRAM
// `define USE_GENERIC_SRAM_IMPLEMENTATION




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

// Tile config

// devices.xml





// NoC interface





















// NodeID decomposition








//========================
//Packet format
//=========================

//Header decomposition































// these shifted fields are added for convienience
// HEADER 2








// HEADER 3








//NoC header information










// Width of MSG_ADDR field - you're probably looking for PHY_ADDR_WIDTH


//Coherence information





//Requests from L15 to L2
// Should always make #0 an error








//condition satisfied

//condition not satisfied

//Both SWAP and LDSTUB are the same for L2









//RISC-V AMO requests









//RISC-V AMO L2-internal phase 1









//RISC-V AMO L2-internal phase 2












//Forward requests from L2 to L15







//Memory requests from L2 to DRAM






//Forward acks from L15 to L2







//Memory acks from memory to L2









//Acks from L2 to L15


//TODO



//Only exist within L2





//`define MSG_TYPE_LOAD_REQ           8'd31 if this is enabled, don't use 31





// These should be defined in l2.vh, not the global defines











//Physical address










//Transition data size












//`define HOME_ID_MASK_X          10:10
//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only


// Tri: dynamically adjust these parameters based on how many tiles are available
//  Assumption: 8x8 topology























































//`define DMBR_TAG_WIDTH 4

//Clumpy Shared Memory






////////////////////////////////////////////
// SOME CONFIGURATION REGISTERS DEFINES
////////////////////////////////////////////
// example: read/write to csm_en would be 0xba_0000_0100

// `define ASI_ADDRESS_MASK    `L15_ADDR_TYPE
// `define CONFIG_ASI_ADDRESS  `L15_ADDR_TYPE_WIDTH'hba










// DMBR Config register 1 fields















// DMBR Config register 2 fields



//Home allocation method






//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only

































//`define TTE_CSM_WIDTH           64
//`define TTE_CSM                 63:0
//`define TTE_CSM_VALID           63
//`define TTE_CSM_SZL             62:61
//`define TTE_CSM_NFO             60
//`define TTE_CSM_IE              59
//`define TTE_CSM_SOFT2           58:49
//`define TTE_CSM_SZH             48
//`define TTE_CSM_DIAG            47:40
//`define TTE_CSM_RES1            39
//`define TTE_CSM_SDID            38:29
//`define TTE_CSM_HDID            28:19
//`define TTE_CSM_LSID            18:13
//`define TTE_CSM_SOFT            12:8
//`define TTE_CSM_RES2            7
//`define TTE_CSM_LOCK            6
//`define TTE_CSM_CP              5
//`define TTE_CSM_CV              4
//`define TTE_CSM_E               3
//`define TTE_CSM_P               2
//`define TTE_CSM_W               1
//`define TTE_CSM_RES3            0







//`define HOME_ID_X_POS_WIDTH         3
//`define HOME_ID_X_POS               2:0
//`define HOME_ID_Y_POS_WIDTH         3
//`define HOME_ID_Y_POS               5:3

// Packet format for home id





/////////////////////////////////////
// BIST
/////////////////////////////////////

// the data width from tap to individual sram wrappers



//deprecated































/////////////////////////////////////
// IDs for JTAG-Core interface
/////////////////////////////////////

// 48b for writing the PC reset vector

// 94b for reading the sscan data











// Execution Drafting Synchronization Method Values





// Execution Drafting timeout counter bit width


// Configuration registers












// Execution Drafting configuration register bit positions








// Execution Drafting configuration register default values
// ED disabled, STSM sync method, LFSR seed = 16'b0, LFSR load = 1'b0,
// Counter Timeout = 16'd32



//Clumpy sharer memory configuration registers
























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]






// `define L15_CACHELINE_WIDTH 128

















// devices.xml
// this is used in the ariane SV packages to derive the parameterization

















































// 7

// 7




// 16B cache lines

// 10




// 40 - 4 (16B line) - 7 (index width) = 29

// 11

// 39


// this need to be defined when L1.5 has more sets than L1D
// for correct operations
// `define L15_WMT_EXTENDED_ALIAS


















// `define L15_WMT_ENTRY_0_MASK 1*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_1_MASK 2*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_2_MASK 3*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_3_MASK 4*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_0_VALID_MASK 1*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_1_VALID_MASK 2*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_2_VALID_MASK 3*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_3_VALID_MASK 4*`L15_WMT_ENTRY_WIDTH-1


  
  


  
  


  
  


  
  







// LRU array storage
// keeps 6 bits per cache set: 4 "used" bits, 1 each cache line, and 2 bits for wayid round robin (4w)





// source





// MSHR






// controls how many mshr there are
// `define L15_MSHR_COUNT 10
// should be more than the count above when 2^n











// pipeline OPs




// `define L15_MSHR_ALLOCATE_TYPE_WIDTH 2
// `define L15_MSHR_ALLOCATE_TYPE_LD 2'd1
// `define L15_MSHR_ALLOCATE_TYPE_ST 2'd2
// `define L15_MSHR_ALLOCATE_TYPE_IFILL 2'd3









































































































// `define PCX_REQ_SIZE_WIDTH 4


























// define the width of the flattened, native L15 interface, used for ARIANE_RV64 option



























// [L15_DTAG_OP_WIDTH-1:0]































//`define L15_S3_MESI_WRITE_TAGCHECK_WAY_M_IF_LRSC_SET 3'd7






























































// `define L15_NOC1_DUMMY_GEN_NOC1_CREDIT 5'd11










































// L2 shared states


// `define L15_NOC2_ACK_STATE_WIDTH 2
// `define L15_NOC2_ACK_STATE_S 2'd1
// `define L15_NOC2_ACK_STATE_E 2'd2
// `define L15_NOC2_ACK_STATE_M 2'd3

// `define L15_NOC1_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC1_REQTYPE_WRITEBACK_GUARD `MSG_TYPE_WBGUARD_REQ
// `define L15_NOC1_REQTYPE_LD_REQUEST `MSG_TYPE_LOAD_REQ
// `define L15_NOC1_REQTYPE_LD_PREFETCH_REQUEST `MSG_TYPE_PREFETCH_REQ
// `define L15_NOC1_REQTYPE_LD_NC_REQUEST `MSG_TYPE_NC_LOAD_REQ
// `define L15_NOC1_REQTYPE_IFILL_REQUEST `MSG_TYPE_LOAD_REQ
// // `define L15_NOC1_REQTYPE_WRITETHROUGH_REQUEST 6'd4
// `define L15_NOC1_REQTYPE_ST_REQUEST `MSG_TYPE_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_REQUEST `MSG_TYPE_BLK_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_INIT_REQUEST `MSG_TYPE_BLKINIT_STORE_REQ
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE_ST_UPGRADE_REQUEST 6
// // `define L15_NOC1_REQTYPE_ST_FILL_REQUEST 6'd6
// `define L15_NOC1_REQTYPE_CAS_REQUEST `MSG_TYPE_CAS_REQ
// `define L15_NOC1_REQTYPE_SWAP_REQUEST `MSG_TYPE_SWAP_REQ

// `define L15_NOC3_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC3_REQTYPE_WRITEBACK `MSG_TYPE_WB_REQ
// `define L15_NOC3_REQTYPE_NO_DATA_FWD_ACK `MSG_TYPE_NODATA_ACK
// `define L15_NOC3_REQTYPE_DATA_FWD_ACK `MSG_TYPE_DATA_ACK

// `define L2_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L2_REQTYPE_INVALIDATE 6'd1
// `define L2_REQTYPE_DOWNGRADE 6'd2
// `define L2_REQTYPE_ACKDT_LD_NC 6'd3
// `define L2_REQTYPE_ACKDT_IFILL 6'd4
// `define L2_REQTYPE_ACKDT_LD 6'd5
// `define L2_REQTYPE_ACKDT_ST_IM 6'd6
// `define L2_REQTYPE_ACKDT_ST_SM 6'd7
// `define L2_REQTYPE_ACK_WRITETHROUGH 6'd8
// `define L2_REQTYPE_ACK_ATOMIC 6'd9






































// NOC1 ENCODER











// NOC3 ENCODER










// NOC2 BUFFER





// DMBR
// put this here for now, should be moved to a more appropriate location


// NOC1 CREDIT MANAGEMENT
// becareful, the noc1buffer module assumes these are power of two
// also, please change the corresponding pyv value in noc1buffer.v.pyv























// `define L15_NOC1BUFFER_BLKSTORE_LO  `L15_NOC1BUFFER_PREFETCH_HI + 1
// `define L15_NOC1BUFFER_BLKSTORE_HI  `L15_NOC1BUFFER_BLKSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_BLKINITSTORE_LO  `L15_NOC1BUFFER_BLKSTORE_HI + 1
// `define L15_NOC1BUFFER_BLKINITSTORE_HI  `L15_NOC1BUFFER_BLKINITSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_DATA_INDEX_LO  `L15_NOC1BUFFER_BLKINITSTORE_HI + 1
































// `define L15_CPUID_ADDRESS 40'h9800000900






////////////////
// CSM
////////////////



// Tri: save space on l15 sram






















//HMC array
































//Special addresses for HMC


//`define L15_ADDR_TYPE_TAG_ACCESS     8'hb4 // later
//`define L15_ADDR_TYPE_STATE_ACCESS   8'hb6 // later
//`define L15_ADDR_TYPE_DIR_ACCESS     8'hb1 // later
//`define L15_ADDR_TYPE_CTRL_REG       8'hb9
//`define L15_ADDR_TYPE_DIS_FLUSH      8'hbc, 8'hbd, 8'hbe, 8'hbf
// `define L15_ADDR_TYPE_HMT_BASE_REG      8'hb7


















// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml



module flat_id_to_xy(
    input  [(6-1):0] flat_id,
    output reg [(8-1):0] x_coord,
    output reg [(8-1):0] y_coord
);

    always @*
    begin
        case (flat_id)
        
//(`NOC_Y_WIDTH+`NOC_X_WIDTH)'d0: 
6'd0: 
begin
    x_coord = 8'd0;
    y_coord = 8'd0;
end

        default:
        begin
            x_coord = 8'dX;
            y_coord = 8'dX;
        end
        endcase
    end
endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]























































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml



module xy_to_flat_id(
    input  [(8-1):0] x_coord,
    input  [(8-1):0] y_coord,
    output reg [(6-1):0] flat_id
);
    
    
    always @*
    begin
        case (x_coord)
        
8'd0:
begin
     case (y_coord)

    // (x,y) = (0, 0)
    8'd0:
    begin
        flat_id = 6'd0;
    end
     default:
     begin
         flat_id = 6'dX;
     end
     endcase
end

        default:
        begin
            flat_id = 6'dX;
        end
        endcase
    end
endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l2_data
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [13-1:0] A,
input wire RDWEN,
input wire [144-1:0] BW,
input wire [144-1:0] DIN,
output wire [144-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [144-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (8192),
   .ADDR_WIDTH    (13),
   .BITMASK_WIDTH (144),
   .DATA_WIDTH    (144)
)   sram_l2_data (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l2_dir
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [11-1:0] A,
input wire RDWEN,
input wire [64-1:0] BW,
input wire [64-1:0] DIN,
output wire [64-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [64-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (2048),
   .ADDR_WIDTH    (11),
   .BITMASK_WIDTH (64),
   .DATA_WIDTH    (64)
)   sram_l2_dir (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l2_state
(
input wire MEMCLK,
input wire RESET_N,
input wire CEA,
input wire [9-1:0] AA,
input wire RDWENA,
input wire CEB,
input wire [9-1:0] AB,
input wire RDWENB,
input wire [15*4+2+4-1:0] BWA,
input wire [15*4+2+4-1:0] DINA,
output wire [15*4+2+4-1:0] DOUTA,
input wire [15*4+2+4-1:0] BWB,
input wire [15*4+2+4-1:0] DINB,
output wire [15*4+2+4-1:0] DOUTB,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);
  

wire [15*4+2+4-1:0] DOUTA_bram;
wire [15*4+2+4-1:0] DOUTB_bram;
assign DOUTA = DOUTA_bram;
assign DOUTB = DOUTB_bram;

bram_1r1w_wrapper #(
   .NAME          (""             ),
   .DEPTH         (512),
   .ADDR_WIDTH    (9),
   .BITMASK_WIDTH (15*4+2+4),
   .DATA_WIDTH    (15*4+2+4)
)   sram_l2_state (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CEA        (CEA     ),
   .AA        (AA     ),
   .AB        (AB     ),
   .RDWENA        (RDWENA     ),
   .CEB        (CEB     ),
   .RDWENB        (RDWENB     ),
   .BWA        (BWA     ),
   .DINA        (DINA     ),
   .DOUTA        (DOUTA_bram     ),
   .BWB        (BWB     ),
   .DINB        (DINB     ),
   .DOUTB        (DOUTB_bram     )
);
      







































 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l2_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [9-1:0] A,
input wire RDWEN,
input wire [100-1:0] BW,
input wire [100-1:0] DIN,
output wire [100-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [100-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (512),
   .ADDR_WIDTH    (9),
   .BITMASK_WIDTH (100),
   .DATA_WIDTH    (100)
)   sram_l2_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.v
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main verilog file for the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2(

    input wire clk,
    input wire rst_n,

    input wire [14-1:0] chipid,
    input wire [8-1:0] coreid_x,
    input wire [8-1:0] coreid_y,

    input wire noc1_valid_in,
    input wire [64-1:0] noc1_data_in,
    output wire noc1_ready_in,


    input wire noc3_valid_in,
    input wire [64-1:0] noc3_data_in,
    output wire noc3_ready_in,

    output wire noc2_valid_out,
    output wire [64-1:0] noc2_data_out,
    input wire noc2_ready_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data
);

// sram
wire [4-1:0] data_rtap_data;
wire [4-1:0] dir_rtap_data;
wire [4-1:0] tag_rtap_data;
wire [4-1:0] state_rtap_data;
assign srams_rtap_data = data_rtap_data
                            | dir_rtap_data
                            | tag_rtap_data
                            | state_rtap_data;

localparam y = 1'b1;
localparam n = 1'b0;


wire mshr_cam_en_p1;
wire mshr_wr_state_en_p1;
wire mshr_wr_data_en_p1;
wire mshr_pending_ready_p1;
wire [2-1:0] mshr_state_in_p1;
wire [120+2-1:0] mshr_data_in_p1;
wire [120+2-1:0] mshr_data_mask_in_p1;
wire [3-1:0] mshr_inv_counter_rd_index_in_p1;
wire [3-1:0] mshr_wr_index_in_p1;
wire [9-1:0] mshr_addr_in_p1;

wire mshr_rd_en_p2;
wire mshr_wr_state_en_p2;
wire mshr_wr_data_en_p2;
wire mshr_inc_counter_en_p2;
wire [2-1:0] mshr_state_in_p2;
wire [120+2-1:0] mshr_data_in_p2;
wire [120+2-1:0] mshr_data_mask_in_p2;
wire [3-1:0] mshr_rd_index_in_p2;
wire [3-1:0] mshr_wr_index_in_p2;

wire mshr_hit;
wire [3-1:0] mshr_hit_index;




wire [2-1:0] rd_mshr_state_out;
wire [120+2-1:0] rd_mshr_data_out;
// wire [`L2_MSHR_STATE_BITS-1:0] cam_mshr_state_out;
wire [120+2-1:0] cam_mshr_data_out;
wire [120+2-1:0] pending_mshr_data_out;


wire [6-1:0] mshr_inv_counter_out;
wire [3:0] mshr_empty_slots;
wire mshr_pending;
wire [3-1:0] mshr_pending_index;
wire [3-1:0] mshr_empty_index;

wire state_rd_en_p1;
wire state_wr_en_p1;
wire [9-1:0] state_rd_addr_p1;
wire [9-1:0] state_wr_addr_p1;
wire [15*4+2+4-1:0] state_data_in_p1;
wire [15*4+2+4-1:0] state_data_mask_in_p1;

wire state_rd_en_p2;
wire state_wr_en_p2;
wire [9-1:0] state_rd_addr_p2;
wire [9-1:0] state_wr_addr_p2;
wire [15*4+2+4-1:0] state_data_in_p2;
wire [15*4+2+4-1:0] state_data_mask_in_p2;

wire [15*4+2+4-1:0] state_data_out;

wire tag_clk_en_p1;
wire tag_rdw_en_p1;
wire [9-1:0] tag_addr_p1;
wire [100-1:0] tag_data_in_p1;
wire [100-1:0] tag_data_mask_in_p1;

wire tag_clk_en_p2;
wire tag_rdw_en_p2;
wire [9-1:0] tag_addr_p2;
wire [100-1:0] tag_data_in_p2;
wire [100-1:0] tag_data_mask_in_p2;

wire [100-1:0] tag_data_out;

wire dir_clk_en_p1;
wire dir_rdw_en_p1;
wire [9+2-1:0] dir_addr_p1;
wire [64-1:0] dir_data_in_p1;
wire [64-1:0] dir_data_mask_in_p1;

wire dir_clk_en_p2;
wire dir_rdw_en_p2;
wire [9+2-1:0] dir_addr_p2;
wire [64-1:0] dir_data_in_p2;
wire [64-1:0] dir_data_mask_in_p2;

wire [64-1:0] dir_data_out;

wire data_clk_en_p1;
wire data_rdw_en_p1;
wire [9+2+2-1:0] data_addr_p1;
wire [144-1:0] data_data_in_p1;
wire [144-1:0] data_data_mask_in_p1;

wire data_clk_en_p2;
wire data_rdw_en_p2;
wire [9+2+2-1:0] data_addr_p2;
wire [144-1:0] data_data_in_p2;
wire [144-1:0] data_data_mask_in_p2;
wire [144-1:0] data_data_out;


wire smc_rd_en;
wire smc_rd_diag_en;
wire smc_wr_diag_en;
wire smc_flush_en;
wire [2-1:0] smc_addr_op;
wire [16-1:0] smc_rd_addr_in;

wire smc_wr_en_p1;
wire [16-1:0] smc_wr_addr_in_p1;
wire [128-1:0] smc_data_in_p1;

wire smc_wr_en_p2;
wire [16-1:0] smc_wr_addr_in_p2;
wire [128-1:0] smc_data_in_p2;

wire [2-1:0] broadcast_counter_op_p1;
wire broadcast_counter_op_val_p1;

wire [2-1:0] broadcast_counter_op_p2;
wire broadcast_counter_op_val_p2;

wire smc_hit;
wire [30-1:0] smc_data_out;
wire [4-1:0] smc_valid_out;
wire [14-1:0] smc_tag_out;

wire broadcast_counter_zero1;
wire broadcast_counter_max1;
wire broadcast_counter_avail1;
wire [14-1:0] broadcast_chipid_out1;
wire [8-1:0] broadcast_x_out1;
wire [8-1:0] broadcast_y_out1;

wire broadcast_counter_zero2;
wire broadcast_counter_max2;
wire broadcast_counter_avail2;
wire [14-1:0] broadcast_chipid_out2;
wire [8-1:0] broadcast_x_out2;
wire [8-1:0] broadcast_y_out2;


wire reg_rd_en;
wire reg_wr_en;
wire [8-1:0] reg_rd_addr_type;
wire [8-1:0] reg_wr_addr_type;
wire [64-1:0] reg_data_out;
wire [64-1:0] reg_data_in;
wire l2_access_valid;
wire l2_miss_valid;
wire data_ecc_corr_error;
wire data_ecc_uncorr_error;
wire [9+2+2-1:0] data_ecc_addr;
wire [40-1:0] error_addr;
wire [34-1:0] my_nodeid;
wire [14+8+8-1:0] core_max;

wire csm_en;

wire [22-1:0] smt_base_addr;


wire pipe2_valid_S1;
wire pipe2_valid_S2;
wire pipe2_valid_S3;



wire [8-1:0] pipe2_msg_type_S1;
wire [8-1:0] pipe2_msg_type_S2;
wire [8-1:0] pipe2_msg_type_S3;

wire [40-1:0] pipe2_addr_S1;
wire [40-1:0] pipe2_addr_S2;
wire [40-1:0] pipe2_addr_S3;

wire active_S1;
wire active_S2;
wire active_S3;





l2_config_regs config_regs(

    .clk                    (clk),
    .rst_n                  (rst_n),
    .chipid                 (chipid),
    .coreid_x               (coreid_x),
    .coreid_y               (coreid_y),
    .l2_access_valid        (l2_access_valid),
    .l2_miss_valid          (l2_miss_valid),
    .data_ecc_corr_error    (data_ecc_corr_error),
    .data_ecc_uncorr_error  (data_ecc_uncorr_error),
    .data_ecc_addr          (data_ecc_addr),
    .error_addr             (error_addr),
    .reg_rd_en              (reg_rd_en),
    .reg_wr_en              (reg_wr_en),
    .reg_rd_addr_type       (reg_rd_addr_type),
    .reg_wr_addr_type       (reg_wr_addr_type),
    .reg_data_in            (reg_data_in),

    .reg_data_out           (reg_data_out),
    .my_nodeid              (my_nodeid),
    .core_max               (core_max),
    
    .csm_en                 (csm_en),
    


    .smt_base_addr          (smt_base_addr)

);




l2_mshr_wrap mshr_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),



    .pipe_wr_sel            (active_S3),




    .cam_en1                (mshr_cam_en_p1),
    .wr_state_en1           (mshr_wr_state_en_p1),
    .wr_data_en1            (mshr_wr_data_en_p1),
    .pending_ready1         (mshr_pending_ready_p1),
    .state_in1              (mshr_state_in_p1),
    .data_in1               (mshr_data_in_p1),
    .data_mask_in1          (mshr_data_mask_in_p1),



    .inv_counter_rd_index_in1(mshr_inv_counter_rd_index_in_p1),
    .wr_index_in1           (mshr_wr_index_in_p1),
    .addr_in1               (mshr_addr_in_p1),





    .wr_state_en2           (mshr_wr_state_en_p2),
    .wr_data_en2            (mshr_wr_data_en_p2),



    .inc_counter_en2        (mshr_inc_counter_en_p2),
    .state_in2              (mshr_state_in_p2),
    .data_in2               (mshr_data_in_p2),
    .data_mask_in2          (mshr_data_mask_in_p2),
    .rd_index_in2           (mshr_rd_index_in_p2),
    .wr_index_in2           (mshr_wr_index_in_p2),




    .hit                    (mshr_hit),
    .hit_index              (mshr_hit_index),




    .rd_state_out           (rd_mshr_state_out),
    .rd_data_out            (rd_mshr_data_out),
    // .cam_state_out       (cam_mshr_state_out),
    .cam_data_out           (cam_mshr_data_out),
    .pending_data_out       (pending_mshr_data_out),

    .inv_counter_out        (mshr_inv_counter_out), 
    .empty_slots            (mshr_empty_slots),
    .pending                (mshr_pending),
    .pending_index          (mshr_pending_index),
    .empty_index            (mshr_empty_index)
);

l2_state_wrap state_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pdout_en               (1'b0),
    .deepsleep              (1'b0),
    .pipe_rd_sel            (active_S1),
    .pipe_wr_sel            (active_S3),

    .rd_en1                 (state_rd_en_p1),
    .wr_en1                 (state_wr_en_p1),
    .rd_addr1               (state_rd_addr_p1),
    .wr_addr1               (state_wr_addr_p1),
    .data_in1               (state_data_in_p1),
    .data_mask_in1          (state_data_mask_in_p1),

    .rd_en2                 (state_rd_en_p2),
    .wr_en2                 (state_wr_en_p2),
    .rd_addr2               (state_rd_addr_p2),
    .wr_addr2               (state_wr_addr_p2),
    .data_in2               (state_data_in_p2),
    .data_mask_in2          (state_data_mask_in_p2),

    .data_out               (state_data_out),
    .pdata_out              (),

    // sram interfaces
    .srams_rtap_data (state_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);

l2_tag_wrap tag_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pdout_en               (1'b0),
    .deepsleep              (1'b0),
    .pipe_sel               (active_S1),

    .clk_en1                (tag_clk_en_p1),
    .rdw_en1                (tag_rdw_en_p1),
    .addr1                  (tag_addr_p1),
    .data_in1               (tag_data_in_p1),
    .data_mask_in1          (tag_data_mask_in_p1),

    .clk_en2                (tag_clk_en_p2),
    .rdw_en2                (tag_rdw_en_p2),
    .addr2                  (tag_addr_p2),
    .data_in2               (tag_data_in_p2),
    .data_mask_in2          (tag_data_mask_in_p2),


    .data_out               (tag_data_out),
    .pdata_out              (),

    // sram interfaces
    .srams_rtap_data (tag_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);

l2_dir_wrap dir_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pdout_en               (1'b0),
    .deepsleep              (1'b0),
    .pipe_sel               (active_S2),

    .clk_en1                (dir_clk_en_p1),
    .rdw_en1                (dir_rdw_en_p1),
    .addr1                  (dir_addr_p1),
    .data_in1               (dir_data_in_p1),
    .data_mask_in1          (dir_data_mask_in_p1),

    .clk_en2                (dir_clk_en_p2),
    .rdw_en2                (dir_rdw_en_p2),
    .addr2                  (dir_addr_p2),
    .data_in2               (dir_data_in_p2),
    .data_mask_in2          (dir_data_mask_in_p2),


    .data_out               (dir_data_out),
    .pdata_out              (),

    // sram interfaces
    .srams_rtap_data (dir_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);

l2_data_wrap data_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pdout_en               (1'b0),
    .deepsleep              (1'b0),
    .pipe_sel               (active_S2),

    .clk_en1                (data_clk_en_p1),
    .rdw_en1                (data_rdw_en_p1),
    .addr1                  (data_addr_p1),
    .data_in1               (data_data_in_p1),
    .data_mask_in1          (data_data_mask_in_p1),

    .clk_en2                (data_clk_en_p2),
    .rdw_en2                (data_rdw_en_p2),
    .addr2                  (data_addr_p2),
    .data_in2               (data_data_in_p2),
    .data_mask_in2          (data_data_mask_in_p2),


    .data_out               (data_data_out),
    .pdata_out              (),

    // sram interfaces
    .srams_rtap_data (data_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);


l2_smc_wrap smc_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pipe_sel               (active_S2),
    .rd_en                  (smc_rd_en),
    .rd_diag_en             (smc_rd_diag_en),
    .flush_en               (smc_flush_en),
    .addr_op                (smc_addr_op),
    .rd_addr_in             (smc_rd_addr_in),

    .wr_en1                 (smc_wr_en_p1),
    .wr_addr_in1            (smc_wr_addr_in_p1),
    .data_in1               (smc_data_in_p1),
    .wr_diag_en1            (smc_wr_diag_en),

    .wr_en2                 (smc_wr_en_p2),
    .wr_addr_in2            (smc_wr_addr_in_p2),
    .data_in2               (smc_data_in_p2),
    .wr_diag_en2            (1'b0),

    .hit                    (smc_hit),
    .data_out               (smc_data_out),
    .valid_out              (smc_valid_out),
    .tag_out                (smc_tag_out)
);

l2_broadcast_counter_wrap l2_broadcast_counter_wrap(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .chipid_max             (core_max[29:16]),
    .x_max                  (core_max[7:0]),
    .y_max                  (core_max[15:8]),
    .pipe_sel               (active_S2),

    .counter_op1            (broadcast_counter_op_p1),
    .counter_op_val1        (broadcast_counter_op_val_p1),

    .counter_op2            (broadcast_counter_op_p2),
    .counter_op_val2        (broadcast_counter_op_val_p2),

    .zero1                  (broadcast_counter_zero1),
    .max1                   (broadcast_counter_max1),
    .avail1                 (broadcast_counter_avail1),
    .chipid_out1            (broadcast_chipid_out1),
    .x_out1                 (broadcast_x_out1),
    .y_out1                 (broadcast_y_out1),

    .zero2                  (broadcast_counter_zero2),
    .max2                   (broadcast_counter_max2),
    .avail2                 (broadcast_counter_avail2),
    .chipid_out2            (broadcast_chipid_out2),
    .x_out2                 (broadcast_x_out2),
    .y_out2                 (broadcast_y_out2)
);



l2_pipe1 pipe1(
    .clk                    (clk),
    .rst_n                  (rst_n),
    .my_nodeid              (my_nodeid),
    
    .csm_en                 (csm_en),
    
    .smt_base_addr          (smt_base_addr),

    .noc_valid_in           (noc1_valid_in),
    .noc_data_in            (noc1_data_in),
    .noc_ready_in           (noc1_ready_in),

    .noc_valid_out          (noc2_valid_out),
    .noc_data_out           (noc2_data_out),
    .noc_ready_out          (noc2_ready_out),


    .pipe2_valid_S1         (pipe2_valid_S1),
    .pipe2_valid_S2         (pipe2_valid_S2),
    .pipe2_valid_S3         (pipe2_valid_S3),
    .pipe2_msg_type_S1      (pipe2_msg_type_S1),
    .pipe2_msg_type_S2      (pipe2_msg_type_S2),
    .pipe2_msg_type_S3      (pipe2_msg_type_S3),
    .pipe2_addr_S1          (pipe2_addr_S1),
    .pipe2_addr_S2          (pipe2_addr_S2),
    .pipe2_addr_S3          (pipe2_addr_S3),
    .global_stall_S1        (active_S1),
    .global_stall_S2        (active_S2),
    .global_stall_S4        (active_S3),

    .mshr_hit               (mshr_hit),



    .cam_mshr_data_out      (cam_mshr_data_out),
    .pending_mshr_data_out  (pending_mshr_data_out),

    .mshr_inv_counter_out   (mshr_inv_counter_out),
    .mshr_empty_slots       (mshr_empty_slots),
    .mshr_pending           (mshr_pending),
    .mshr_pending_index     (mshr_pending_index),
    .mshr_empty_index       (mshr_empty_index),

    
    .broadcast_counter_zero (broadcast_counter_zero1),
    .broadcast_counter_max  (broadcast_counter_max1),
    .broadcast_counter_avail(broadcast_counter_avail1),
    .broadcast_chipid_out   (broadcast_chipid_out1),
    .broadcast_x_out        (broadcast_x_out1),
    .broadcast_y_out        (broadcast_y_out1),
    

    .state_data_out         (state_data_out),
    .tag_data_out           (tag_data_out),
    .dir_data_out           (dir_data_out),
    .data_data_out          (data_data_out),

    .l2_access_valid        (l2_access_valid),
    .l2_miss_valid          (l2_miss_valid),
    .data_ecc_corr_error    (data_ecc_corr_error),
    .data_ecc_uncorr_error  (data_ecc_uncorr_error),
    .data_ecc_addr          (data_ecc_addr),
    .error_addr             (error_addr),

    .reg_rd_en              (reg_rd_en),
    .reg_wr_en              (reg_wr_en),
    .reg_rd_addr_type       (reg_rd_addr_type),
    .reg_wr_addr_type       (reg_wr_addr_type),

    .reg_data_out           (reg_data_out),
    .reg_data_in            (reg_data_in),

    .mshr_cam_en            (mshr_cam_en_p1),
    .mshr_wr_state_en       (mshr_wr_state_en_p1),
    .mshr_wr_data_en        (mshr_wr_data_en_p1),
    .mshr_pending_ready     (mshr_pending_ready_p1),
    .mshr_state_in          (mshr_state_in_p1),
    .mshr_data_in           (mshr_data_in_p1),
    .mshr_data_mask_in      (mshr_data_mask_in_p1),
    .mshr_inv_counter_rd_index_in(mshr_inv_counter_rd_index_in_p1),
    .mshr_wr_index_in       (mshr_wr_index_in_p1),
    .mshr_addr_in           (mshr_addr_in_p1),

    .state_rd_en            (state_rd_en_p1),
    .state_wr_en            (state_wr_en_p1),
    .state_rd_addr          (state_rd_addr_p1),
    .state_wr_addr          (state_wr_addr_p1),
    .state_data_in          (state_data_in_p1),
    .state_data_mask_in     (state_data_mask_in_p1),

    .tag_clk_en             (tag_clk_en_p1),
    .tag_rdw_en             (tag_rdw_en_p1),
    .tag_addr               (tag_addr_p1),
    .tag_data_in            (tag_data_in_p1),
    .tag_data_mask_in       (tag_data_mask_in_p1),

    .dir_clk_en             (dir_clk_en_p1),
    .dir_rdw_en             (dir_rdw_en_p1),
    .dir_addr               (dir_addr_p1),
    .dir_data_in            (dir_data_in_p1),
    .dir_data_mask_in       (dir_data_mask_in_p1),

    
    .broadcast_counter_op   (broadcast_counter_op_p1),
    .broadcast_counter_op_val(broadcast_counter_op_val_p1),

    .smc_rd_en              (smc_rd_en),
    .smc_rd_addr_in         (smc_rd_addr_in),
    .smc_rd_diag_en         (smc_rd_diag_en),
    .smc_flush_en           (smc_flush_en),
    .smc_addr_op            (smc_addr_op),
    .smc_wr_diag_en         (smc_wr_diag_en),
    .smc_wr_en              (smc_wr_en_p1),
    .smc_wr_addr_in         (smc_wr_addr_in_p1),
    .smc_data_in            (smc_data_in_p1),
    .smc_hit                (smc_hit),
    .smc_data_out           (smc_data_out),
    .smc_valid_out          (smc_valid_out),
    .smc_tag_out            (smc_tag_out),
    

    .data_clk_en            (data_clk_en_p1),
    .data_rdw_en            (data_rdw_en_p1),
    .data_addr              (data_addr_p1),
    .data_data_in           (data_data_in_p1),
    .data_data_mask_in      (data_data_mask_in_p1)

);



l2_pipe2 pipe2(
    .clk                    (clk),
    .rst_n                  (rst_n),
    
    .csm_en                 (csm_en),
    
    .noc_valid_in           (noc3_valid_in),
    .noc_data_in            (noc3_data_in),
    .noc_ready_in           (noc3_ready_in),





    .mshr_state_out         (rd_mshr_state_out),
    .mshr_data_out          (rd_mshr_data_out),


    
    .broadcast_counter_zero (broadcast_counter_zero2),
    .broadcast_counter_max  (broadcast_counter_max2),
    .broadcast_chipid_out   (broadcast_chipid_out2),
    .broadcast_x_out        (broadcast_x_out2),
    .broadcast_y_out        (broadcast_y_out2),
    

    .state_data_out         (state_data_out),
    .tag_data_out           (tag_data_out),
    .dir_data_out           (dir_data_out),

    .mshr_rd_en             (mshr_rd_en_p2),
    .mshr_wr_state_en       (mshr_wr_state_en_p2),
    .mshr_wr_data_en        (mshr_wr_data_en_p2),
    .mshr_inc_counter_en    (mshr_inc_counter_en_p2),
    .mshr_state_in          (mshr_state_in_p2),
    .mshr_data_in           (mshr_data_in_p2),
    .mshr_data_mask_in      (mshr_data_mask_in_p2),
    .mshr_rd_index_in       (mshr_rd_index_in_p2),
    .mshr_wr_index_in       (mshr_wr_index_in_p2),

    .state_rd_en            (state_rd_en_p2),
    .state_wr_en            (state_wr_en_p2),
    .state_rd_addr          (state_rd_addr_p2),
    .state_wr_addr          (state_wr_addr_p2),
    .state_data_in          (state_data_in_p2),
    .state_data_mask_in     (state_data_mask_in_p2),

    .tag_clk_en             (tag_clk_en_p2),
    .tag_rdw_en             (tag_rdw_en_p2),
    .tag_addr               (tag_addr_p2),
    .tag_data_in            (tag_data_in_p2),
    .tag_data_mask_in       (tag_data_mask_in_p2),

    .dir_clk_en             (dir_clk_en_p2),
    .dir_rdw_en             (dir_rdw_en_p2),
    .dir_addr               (dir_addr_p2),
    .dir_data_in            (dir_data_in_p2),
    .dir_data_mask_in       (dir_data_mask_in_p2),

    .data_clk_en            (data_clk_en_p2),
    .data_rdw_en            (data_rdw_en_p2),
    .data_addr              (data_addr_p2),
    .data_data_in           (data_data_in_p2),
    .data_data_mask_in      (data_data_mask_in_p2),


    
    .broadcast_counter_op   (broadcast_counter_op_p2),
    .broadcast_counter_op_val(broadcast_counter_op_val_p2),

    .smc_wr_en              (smc_wr_en_p2),
    .smc_wr_addr_in         (smc_wr_addr_in_p2),
    .smc_data_in            (smc_data_in_p2),
    

    .valid_S1               (pipe2_valid_S1),
    .valid_S2               (pipe2_valid_S2),
    .valid_S3               (pipe2_valid_S3),
    .msg_type_S1            (pipe2_msg_type_S1),
    .msg_type_S2            (pipe2_msg_type_S2),
    .msg_type_S3            (pipe2_msg_type_S3),
    .addr_S1                (pipe2_addr_S1),
    .addr_S2                (pipe2_addr_S2),
    .addr_S3                (pipe2_addr_S3),
    .active_S1              (active_S1),
    .active_S2              (active_S2),
    .active_S3              (active_S3)
);

endmodule
/*
Copyright (c) 2018 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1
























































module l2_amo_alu #(
  parameter SWAP_ENDIANESS = 1
) (
  input      [4-1:0] amo_alu_op,
  input      [40-1:0]      address,
  input      [3-1:0] data_size,
  input      [128-1:0]  memory_operand,
  input      [128-1:0]  cpu_operand,
  output reg [128-1:0]  amo_result
);

wire [63:0] amo_operand_a_mux, amo_operand_b_mux;
wire [63:0] amo_operand_a_swp, amo_operand_b_swp;
reg  [63:0] amo_operand_a, amo_operand_b;
reg  [63:0] amo_64b_tmp, amo_64b_result;
reg  [64:0] adder_operand_a, adder_operand_b;
wire [64:0] adder_sum;

// note: the L2_DATA_DATA_WIDTH_LOG2 is calculated for a bit width
// so we have to subtract 6 from it in order to get the a dword index
wire [7-7:0] dword_offset;


// select dword to operate on
assign dword_offset      = address[7-4:3];
assign amo_operand_a_mux = memory_operand[dword_offset*64 +: 64];
assign amo_operand_b_mux = cpu_operand[dword_offset*64 +: 64];

// endianess swap (if needed)
generate
  if (SWAP_ENDIANESS) begin : g_swap_in
    assign amo_operand_a_swp = {amo_operand_a_mux[ 0 +:8],
                                amo_operand_a_mux[ 8 +:8],
                                amo_operand_a_mux[16 +:8],
                                amo_operand_a_mux[24 +:8],
                                amo_operand_a_mux[32 +:8],
                                amo_operand_a_mux[40 +:8],
                                amo_operand_a_mux[48 +:8],
                                amo_operand_a_mux[56 +:8]};

    assign amo_operand_b_swp = {amo_operand_b_mux[ 0 +:8],
                                amo_operand_b_mux[ 8 +:8],
                                amo_operand_b_mux[16 +:8],
                                amo_operand_b_mux[24 +:8],
                                amo_operand_b_mux[32 +:8],
                                amo_operand_b_mux[40 +:8],
                                amo_operand_b_mux[48 +:8],
                                amo_operand_b_mux[56 +:8]};
  end else begin : g_swap_in
    assign amo_operand_a_swp = amo_operand_a_mux;
    assign amo_operand_b_swp = amo_operand_b_mux;
  end
endgenerate

// operand word/byte select
always @* begin
  amo_operand_a = 64'h0;
  amo_operand_b = 64'h0;

  case (data_size)
    3'b001: begin
      amo_operand_a[56 +: 8]     = amo_operand_a_swp[address[2:0]*8 +: 8];
      amo_operand_b[56 +: 8]     = amo_operand_b_swp[address[2:0]*8 +: 8];
    end
    3'b010: begin
        amo_operand_a[48 +: 16]  = amo_operand_a_swp[address[2:1]*16 +: 16];
        amo_operand_b[48 +: 16]  = amo_operand_b_swp[address[2:1]*16 +: 16];
     end
    3'b011: begin
        amo_operand_a[32 +: 32]  = amo_operand_a_swp[address[2:2]*32 +: 32];
        amo_operand_b[32 +: 32]  = amo_operand_b_swp[address[2:2]*32 +: 32];
    end
    3'b100: begin
        amo_operand_a  = amo_operand_a_swp;
        amo_operand_b  = amo_operand_b_swp;
    end
    default: ;
  endcase // data_size
end


// main ALU
assign adder_sum     = adder_operand_a + adder_operand_b;

always @*
begin
    adder_operand_a = $signed(amo_operand_a);
    adder_operand_b = $signed(amo_operand_b);

    amo_64b_tmp     = amo_operand_a;

    case (amo_alu_op)
        4'd0: ;
        4'd1: amo_64b_tmp = adder_sum[63:0];
        4'd2: amo_64b_tmp = amo_operand_a & amo_operand_b;
        4'd3:  amo_64b_tmp = amo_operand_a | amo_operand_b;
        4'd4: amo_64b_tmp = amo_operand_a ^ amo_operand_b;
        4'd5: begin
            adder_operand_b = -$signed(amo_operand_b);
            amo_64b_tmp = adder_sum[64] ? amo_operand_b : amo_operand_a;
        end
        4'd6: begin
            adder_operand_a = $unsigned(amo_operand_a);
            adder_operand_b = -$unsigned(amo_operand_b);
            amo_64b_tmp = adder_sum[64] ? amo_operand_b : amo_operand_a;
        end
        4'd7: begin
            adder_operand_b = -$signed(amo_operand_b);
            amo_64b_tmp = adder_sum[64] ? amo_operand_a : amo_operand_b;
        end
        4'd8: begin
            adder_operand_a = $unsigned(amo_operand_a);
            adder_operand_b = -$unsigned(amo_operand_b);
            amo_64b_tmp = adder_sum[64] ? amo_operand_a : amo_operand_b;
        end
        default: ;
    endcase
end


// operand select and endianess swap
always @* begin
  // first read-modify-write 64bit word
  amo_64b_result = amo_operand_a_swp;
  case (data_size)
    3'b001: begin
      amo_64b_result[address[2:0]*8 +: 8]     = amo_64b_tmp[56 +: 8];
    end
    3'b010: begin
        amo_64b_result[address[2:1]*16 +: 16]  = amo_64b_tmp[48 +: 16];
     end
    3'b011: begin
        amo_64b_result[address[2:2]*32 +: 32]  = amo_64b_tmp[32 +: 32];
    end
    3'b100: begin
        amo_64b_result  = amo_64b_tmp;
    end
    default: ;
  endcase // data_size

  // merge back into memory line
  amo_result     = memory_operand;
  if (SWAP_ENDIANESS) begin
    amo_result[dword_offset*64 +: 64] = {amo_64b_result[ 0 +:8],
                                         amo_64b_result[ 8 +:8],
                                         amo_64b_result[16 +:8],
                                         amo_64b_result[24 +:8],
                                         amo_64b_result[32 +:8],
                                         amo_64b_result[40 +:8],
                                         amo_64b_result[48 +:8],
                                         amo_64b_result[56 +:8]};
  end else begin
    amo_result[dword_offset*64 +: 64] = amo_64b_result;
  end
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_broadcast_counter.v
//  Created On    : 2014-08-14
//  Revision      
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The broadcast counter in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_broadcast_counter(

    input wire clk,
    input wire rst_n,
    input wire [14-1:0] chipid_max,
    input wire [8-1:0] x_max,
    input wire [8-1:0] y_max,

    input wire [2-1:0] counter_op,
    input wire counter_op_val,
    
    output reg zero,
    output reg max,
    output reg [14-1:0] chipid_out,
    output reg [8-1:0] x_out,
    output reg [8-1:0] y_out

);


reg [14-1:0] chipid_f;
reg [14-1:0] chipid_next;
reg [8-1:0] x_f;
reg [8-1:0] x_next;
reg [8-1:0] y_f;
reg [8-1:0] y_next;



always @ *
begin
    if (!rst_n)
    begin
        chipid_next = 0;
        x_next = 0;
        y_next = 0;
    end
    else if (counter_op_val)
    begin
        if (counter_op == 2'd1)
        begin
            chipid_next = chipid_max;
            x_next = x_max;
            y_next = y_max;
        end
        else if (counter_op == 2'd0)
        begin
            chipid_next = 0;
            x_next = 0;
            y_next = 0;
        end
        else if (counter_op == 2'd2)
        begin
            if (x_f == x_max)
            begin
                if (y_f == y_max)
                begin
                    if(chipid_f == chipid_max)
                    begin
                        chipid_next = 0;
                        x_next = 0;
                        y_next = 0;
                    end
                    else        
                    begin
                        chipid_next = chipid_f + 1;
                        x_next = 0;
                        y_next = 0;
                    end
                end
                else
                begin
                    chipid_next = chipid_f;
                    x_next = 0;
                    y_next = y_f + 1;
                end
            end
            else
            begin
                chipid_next = chipid_f;
                x_next = x_f + 1;
                y_next = y_f;
            end
        end
        else
        begin
            chipid_next = chipid_f;
            x_next = x_f;
            y_next = y_f;
        end
    end
    else
    begin
        chipid_next = chipid_f;
        x_next = x_f;
        y_next = y_f;
    end
end


always @ (posedge clk)
begin
    chipid_f <= chipid_next;
    x_f <= x_next;
    y_f <= y_next;
end


always @ *
begin
    zero = (x_f == 0) && (y_f == 0) && (chipid_f == 0);
    max = (x_f == x_max) && (y_f == y_max) && (chipid_f == chipid_max);
end



always @ *
begin
    chipid_out = chipid_f;
    x_out = x_f;
    y_out = y_f;
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_broadcast_counter_wrap.v
//  Created On    : 2014-08-14
//  Revision      
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for the broadcast counter in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_broadcast_counter_wrap(

    input wire clk,
    input wire rst_n,
    input wire [14-1:0] chipid_max,
    input wire [8-1:0] x_max,
    input wire [8-1:0] y_max,
    input wire pipe_sel,

    input wire [2-1:0] counter_op1,
    input wire counter_op_val1,
   

    input wire [2-1:0] counter_op2,
    input wire counter_op_val2,
 
    output wire zero1,
    output wire max1,
    output reg  avail1,
    output wire [14-1:0] chipid_out1,
    output wire [8-1:0] x_out1,
    output wire [8-1:0] y_out1,

    output wire zero2,
    output wire max2,
    output reg  avail2,
    output wire [14-1:0] chipid_out2,
    output wire [8-1:0] x_out2,
    output wire [8-1:0] y_out2
);


reg state_f;
reg state_next;

always @ *
begin
    if (!rst_n)
    begin
        state_next = 1'b0;
    end
    else
    begin
        if (counter_op_val1 && (counter_op1 == 2'd2))
        begin
            state_next = 1'b1;
        end
        else if (counter_op_val2 && (counter_op2 == 2'd0))
        begin
            state_next = 1'b0;
        end
        else
        begin
            state_next = state_f;
        end
    end
end


always @ (posedge clk)
begin
    state_f <= state_next;
end


always @ *
begin
    avail1 = (state_f == 1'b0);
    avail2 = (state_f == 1'b0);
end


l2_broadcast_counter l2_broadcast_counter1(
    .clk                (clk),
    .rst_n              (rst_n), 
    .chipid_max         (chipid_max),
    .x_max              (x_max),
    .y_max              (y_max),
    .counter_op         (counter_op1),
    .counter_op_val     (counter_op_val1),
    .zero               (zero1),
    .max                (max1),
    .chipid_out         (chipid_out1),
    .x_out              (x_out1),
    .y_out              (y_out1)

);

l2_broadcast_counter l2_broadcast_counter2(
    .clk                (clk),
    .rst_n              (rst_n), 
    .chipid_max         (chipid_max),
    .x_max              (x_max),
    .y_max              (y_max),
    .counter_op         (counter_op2),
    .counter_op_val     (counter_op_val2),
    .zero               (zero2),
    .max                (max2),
    .chipid_out         (chipid_out2),
    .x_out              (x_out2),
    .y_out              (y_out2)

);


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_config_regs.v
//  Created On    : 2015-01-02
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Config registers for the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_config_regs(

    input wire clk,
    input wire rst_n,

    input wire [14-1:0] chipid,
    input wire [8-1:0] coreid_x,
    input wire [8-1:0] coreid_y,
    input wire l2_access_valid,
    input wire l2_miss_valid,
    input wire data_ecc_corr_error,
    input wire data_ecc_uncorr_error,
    input wire [9+2+2-1:0] data_ecc_addr,
    input wire [40-1:0] error_addr,
    input wire reg_rd_en,
    input wire reg_wr_en,
    input wire [8-1:0] reg_rd_addr_type,
    input wire [8-1:0] reg_wr_addr_type,
    input wire [64-1:0] reg_data_in,

    output reg [64-1:0] reg_data_out,
    output reg [34-1:0] my_nodeid,
    output reg [14+8+8-1:0] core_max,
    output reg csm_en,
    output reg [22-1:0] smt_base_addr

);


reg [64-1:0] ctrl_reg_f;
reg [64-1:0] coreid_reg_f;
reg [64-1:0] l2_access_counter_reg_f;
reg [64-1:0] l2_miss_counter_reg_f;
reg [64-1:0] error_status_reg_f;

reg ctrl_reg_wr_en;
reg coreid_reg_wr_en;
reg l2_access_counter_reg_wr_en;
reg l2_miss_counter_reg_wr_en;
reg error_status_reg_wr_en;
reg error_status_en;
reg l2_access_counter_inc_en;
reg l2_miss_counter_inc_en;

always @ *
begin
    ctrl_reg_wr_en = reg_wr_en && (reg_wr_addr_type == 8'ha9); 
    coreid_reg_wr_en = reg_wr_en && (reg_wr_addr_type == 8'ha7); 
    l2_access_counter_reg_wr_en = reg_wr_en && (reg_wr_addr_type == 8'haa); 
    l2_miss_counter_reg_wr_en = reg_wr_en && (reg_wr_addr_type == 8'hab); 
    error_status_reg_wr_en = reg_wr_en && (reg_wr_addr_type == 8'ha8); 
    
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        ctrl_reg_f <= 0;
    end
    else if (ctrl_reg_wr_en)
    begin
        ctrl_reg_f <= reg_data_in; 
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        coreid_reg_f <= {{(64-34){1'b0}},chipid, coreid_x, coreid_y, 4'd0};
    end
    else if (coreid_reg_wr_en)
    begin
        coreid_reg_f <= reg_data_in; 
    end
end

reg l2_access_counter_inc_en_f;
always @ (posedge clk)
begin
    if (!rst_n)
    begin
        l2_access_counter_reg_f <= 0;
    end
    else if (l2_access_counter_reg_wr_en)
    begin
        l2_access_counter_reg_f <= reg_data_in; 
    end
    // else if (l2_access_counter_inc_en && l2_access_valid)
    // begin
    //     l2_access_counter_reg_f <= l2_access_counter_reg_f + 1;
    // end 
    // trin: pipeline addition for timing
    l2_access_counter_inc_en_f <= l2_access_counter_inc_en && l2_access_valid;
    if (l2_access_counter_inc_en_f) begin
        l2_access_counter_reg_f <= l2_access_counter_reg_f + 1;
    end
end


reg l2_miss_counter_inc_en_f;
always @ (posedge clk)
begin
    if (!rst_n)
    begin
        l2_miss_counter_reg_f <= 0;
    end
    else if (l2_miss_counter_reg_wr_en)
    begin
        l2_miss_counter_reg_f <= reg_data_in; 
    end
    // else if (l2_miss_counter_inc_en && l2_miss_valid)
    // begin
    //     l2_miss_counter_reg_f <= l2_miss_counter_reg_f + 1;
    // end 
    // trin: pipeline addition for timing
    l2_miss_counter_inc_en_f <= l2_miss_counter_inc_en && l2_miss_valid;
    if (l2_miss_counter_inc_en_f) begin
        l2_miss_counter_reg_f <= l2_miss_counter_reg_f + 1;
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        error_status_reg_f <= 0;
    end
    else if (error_status_reg_wr_en)
    begin
        error_status_reg_f <= reg_data_in; 
    end
    else if (error_status_en && data_ecc_corr_error)
    begin
        if (|error_status_reg_f[1:0])
        begin
            error_status_reg_f <= {error_status_reg_f[63:55], error_addr, data_ecc_addr, 1'b1, 1'b0, 1'b1};
        end
        else
        begin
            error_status_reg_f <= {error_status_reg_f[63:55], error_addr, data_ecc_addr, 1'b0, 1'b0, 1'b1};
        end
    end
    else if (error_status_en && data_ecc_uncorr_error)
    begin
        if (|error_status_reg_f[1:0])
        begin
            error_status_reg_f <= {error_status_reg_f[63:55], error_addr, data_ecc_addr, 1'b1, 1'b1, 1'b0};
        end
        else
        begin
            error_status_reg_f <= {error_status_reg_f[63:55], error_addr, data_ecc_addr, 1'b0, 1'b1, 1'b0};
        end
    end

end


always @ * 
begin
    if (reg_rd_en)
    begin
        if (reg_rd_addr_type == 8'ha9)
        begin
            reg_data_out = ctrl_reg_f;
        end
        else if (reg_rd_addr_type == 8'ha7)
        begin
            reg_data_out = coreid_reg_f;
        end
        else if (reg_rd_addr_type == 8'haa)
        begin
            reg_data_out = l2_access_counter_reg_f;
        end
        else if (reg_rd_addr_type == 8'hab)
        begin
            reg_data_out = l2_miss_counter_reg_f;
        end
        else if (reg_rd_addr_type == 8'ha8)
        begin
            reg_data_out = error_status_reg_f;
        end
        else
        begin
            reg_data_out = 0;
        end
    end
    else
    begin
        reg_data_out = 0;
    end
end

always @ * 
begin
    csm_en = ctrl_reg_f[0];
    error_status_en = ctrl_reg_f[1];
    l2_access_counter_inc_en = ctrl_reg_f[2];
    l2_miss_counter_inc_en = ctrl_reg_f[3];
    smt_base_addr = ctrl_reg_f[22+32-1 : 32];
end

always @ * 
begin
    my_nodeid = coreid_reg_f[34-1 : 0]; 
    core_max = coreid_reg_f[14+8+8+34-1 : 34];
end




endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_data.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The data array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_data(

    input wire clk,
    input wire rst_n,
    input wire clk_en,
    input wire rdw_en,
    input wire pdout_en,
    input wire deepsleep,

    input wire [9+2+2-1:0] addr,
    input wire [144-1:0] data_in,
    input wire [144-1:0] data_mask_in,

    output wire [144-1:0] data_out,
    output wire [144-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data
);

/*
localparam reset = 2'd0;
localparam init  = 2'd1;
localparam done  = 2'd2;

reg [1:0] init_state_f;
reg [1:0] init_state_next;
reg [`L2_DATA_INDEX_WIDTH-1:0] init_counter_f;
reg [`L2_DATA_INDEX_WIDTH-1:0] init_counter_next;

reg [`L2_DATA_INDEX_WIDTH-1:0] addr_real;
reg rdw_en_real;
reg clk_en_real;
reg [`L2_DATA_ARRAY_WIDTH-1:0] data_in_real;
reg [`L2_DATA_ARRAY_WIDTH-1:0] data_mask_in_real;

always @ *
begin
    if (!rst_n)
    begin
        init_state_next = reset;
    end
    else
    begin
        if (init_state_f == reset)
        begin
            init_state_next = init;
        end
        else if ((init_state_f == init) && (init_counter_f == {`L2_DATA_INDEX_WIDTH{1'b1}}))
        begin
            init_state_next = done;
        end
        else
        begin
            init_state_next = init_state_f;
        end
    end
end

always @ (posedge clk)
begin
    init_state_f <= init_state_next;
end

always @ *
begin
    if ((init_state_f == reset) || (init_state_f == done))
    begin
        init_counter_next = {`L2_DATA_INDEX_WIDTH{1'b0}};
    end
    else
    begin
        init_counter_next = init_counter_f + 1;
    end
end


always @ (posedge clk)
begin
    init_counter_f <= init_counter_next;
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    if (init_state_f == init)
    begin
        clk_en_real = 1'b1;
        rdw_en_real = 1'b0;
        addr_real = init_counter_f;
        data_in_real = {`L2_DATA_ARRAY_WIDTH{1'b0}};
        data_mask_in_real = {`L2_DATA_ARRAY_WIDTH{1'b1}};
    end
    else
    begin
        clk_en_real = clk_en;
        rdw_en_real = rdw_en;
        addr_real = addr;
        data_in_real = data_in;
        data_mask_in_real = data_mask_in;
    end
end

*/

// sram_1rw_4096x144 l2_data_array(
sram_l2_data l2_data_array(
    .MEMCLK     (clk),
    .RESET_N(rst_n),
    .CE         (clk_en),

    .A          (addr),
    .DIN        (data_in),
    .RDWEN      (rdw_en),
    .BW         (data_mask_in),
    .DOUT       (data_out),
    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(8'd13)
);


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_data_wrap.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for data array in the L2 cache
//
//
//==================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_data_wrap(

    input wire clk,
    input wire rst_n,
    input wire clk_en1,
    input wire clk_en2,
    input wire rdw_en1,
    input wire rdw_en2,
    input wire pdout_en,
    input wire deepsleep,
    input wire pipe_sel,

    input wire [9+2+2-1:0] addr1,
    input wire [144-1:0] data_in1,
    input wire [144-1:0] data_mask_in1,

    input wire [9+2+2-1:0] addr2,
    input wire [144-1:0] data_in2,
    input wire [144-1:0] data_mask_in2,

    output wire [144-1:0] data_out,
    output wire [144-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);

reg clk_en;
reg rdw_en;
reg [9+2+2-1:0] addr;
reg [144-1:0] data_in;
reg [144-1:0] data_mask_in;

always @ *
begin
    if (pipe_sel)
    begin
        clk_en = clk_en2;
        rdw_en = rdw_en2;
        addr = addr2;
        data_in = data_in2;
        data_mask_in = data_mask_in2;
    end
    else
    begin
        clk_en = clk_en1;
        rdw_en = rdw_en1;
        addr = addr1;
        data_in = data_in1;
        data_mask_in = data_mask_in1;
    end
end

l2_data l2_data(

    .clk            (clk),
    .rst_n          (rst_n),
    .clk_en         (clk_en),
    .rdw_en         (rdw_en),
    .pdout_en       (pdout_en),
    .deepsleep      (deepsleep),
    .addr           (addr),
    .data_in        (data_in),
    .data_mask_in   (data_mask_in),
    .data_out       (data_out),
    .pdata_out      (pdata_out),

    // sram interfaces
    .srams_rtap_data (srams_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);



endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_decoder.v
//  Created On    : 2014-02-25
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The message decoder in the L2 cache
//
//
//====================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_decoder(

    input wire [192-1:0] msg_header,

    output reg [8-1:0] msg_type,
    output reg [8-1:0] msg_length,
    output reg [8-1:0] msg_mshrid,
    output reg [3-1:0] msg_data_size,
    output reg [1-1:0] msg_cache_type,
    output reg [4-1:0] msg_subline_vector,
    output reg [2-1:0] msg_mesi,
    output reg [1-1:0] msg_l2_miss,
    output reg [2-1:0] msg_subline_id,
    output reg [1-1:0] msg_last_subline,
    output reg [40-1:0] msg_addr,
    output reg [14-1:0] msg_src_chipid,
    output reg [8-1:0] msg_src_x,
    output reg [8-1:0] msg_src_y,
    output reg [4-1:0] msg_src_fbits,
    output reg [10-1:0] msg_sdid,
    output reg [6-1:0] msg_lsid
);

always @ *
begin
    msg_type = msg_header[21:14];
    msg_length = msg_header[29:22];
    msg_mshrid = msg_header[13:6];
    msg_data_size = msg_header[74:72];
    msg_cache_type = msg_header[75];
    msg_subline_vector = msg_header[79:76];
    msg_mesi = msg_header[5:4];
    msg_l2_miss = msg_header[3];
    msg_subline_id = msg_header[2:1];
    msg_last_subline = msg_header[0];
    msg_addr = msg_header[119:80];
    msg_src_chipid = msg_header[191:178];
    msg_src_x = msg_header[177:170];
    msg_src_y = msg_header[169:162];
    msg_src_fbits = msg_header[161:158];
    msg_sdid = msg_header[157:148];
    msg_lsid = msg_header[147:142];
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_dir.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The directory array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_dir(

    input wire clk,
    input wire rst_n,
    input wire clk_en,
    input wire rdw_en,
    input wire pdout_en,
    input wire deepsleep,

    input wire [9+2-1:0] addr,
    input wire [64-1:0] data_in,
    input wire [64-1:0] data_mask_in,

    output wire [64-1:0] data_out,
    output wire [64-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);
/*
localparam reset = 2'd0;
localparam init  = 2'd1;
localparam done  = 2'd2;

reg [1:0] init_state_f;
reg [1:0] init_state_next;
reg [`L2_DIR_INDEX_WIDTH-1:0] init_counter_f;
reg [`L2_DIR_INDEX_WIDTH-1:0] init_counter_next;

reg [`L2_DIR_INDEX_WIDTH-1:0] addr_real;
reg rdw_en_real;
reg clk_en_real;
reg [`L2_DIR_ARRAY_WIDTH-1:0] data_in_real;
reg [`L2_DIR_ARRAY_WIDTH-1:0] data_mask_in_real;

always @ *
begin
    if (!rst_n)
    begin
        init_state_next = reset;
    end
    else
    begin
        if (init_state_f == reset)
        begin
            init_state_next = init;
        end
        else if ((init_state_f == init) && (init_counter_f == {`L2_DIR_INDEX_WIDTH{1'b1}}))
        begin
            init_state_next = done;
        end
        else
        begin
            init_state_next = init_state_f;
        end
    end
end

always @ (posedge clk)
begin
    init_state_f <= init_state_next;
end

always @ *
begin
    if ((init_state_f == reset) || (init_state_f == done))
    begin
        init_counter_next = {`L2_DIR_INDEX_WIDTH{1'b0}};
    end
    else
    begin
        init_counter_next = init_counter_f + 1;
    end
end


always @ (posedge clk)
begin
    init_counter_f <= init_counter_next;
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    if (init_state_f == init)
    begin
        clk_en_real = 1'b1;
        rdw_en_real = 1'b0;
        addr_real = init_counter_f;
        data_in_real = {`L2_DIR_ARRAY_WIDTH{1'b0}};
        data_mask_in_real = {`L2_DIR_ARRAY_WIDTH{1'b1}};
    end
    else
    begin
        clk_en_real = clk_en;
        rdw_en_real = rdw_en;
        addr_real = addr;
        data_in_real = data_in;
        data_mask_in_real = data_mask_in;
    end
end
*/


// sram_1rw_1024x64 l2_dir_array(
sram_l2_dir l2_dir_array(
    .MEMCLK     (clk),
    .RESET_N(rst_n),
    .CE         (clk_en),

    .A          (addr),
    .DIN        (data_in),
    .RDWEN      (rdw_en),
    .BW         (data_mask_in),

    .DOUT       (data_out),
    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(8'd14)
);

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_dir_wrap.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for directory array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































module l2_dir_wrap(

    input wire clk,
    input wire rst_n,
    input wire clk_en1,
    input wire clk_en2,
    input wire rdw_en1,
    input wire rdw_en2,
    input wire pdout_en,
    input wire deepsleep,
    input wire pipe_sel,

    input wire [9+2-1:0] addr1,
    input wire [64-1:0] data_in1,
    input wire [64-1:0] data_mask_in1,

    input wire [9+2-1:0] addr2,
    input wire [64-1:0] data_in2,
    input wire [64-1:0] data_mask_in2,

    output wire [64-1:0] data_out,
    output wire [64-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);

reg clk_en;
reg rdw_en;
reg [9+2-1:0] addr;
reg [64-1:0] data_in;
reg [64-1:0] data_mask_in;

always @ *
begin
    if (pipe_sel)
    begin
        clk_en = clk_en2;
        rdw_en = rdw_en2;
        addr = addr2;
        data_in = data_in2;
        data_mask_in = data_mask_in2;
    end
    else
    begin
        clk_en = clk_en1;
        rdw_en = rdw_en1;
        addr = addr1;
        data_in = data_in1;
        data_mask_in = data_mask_in1;
    end
end

l2_dir l2_dir(

    .clk            (clk),
    .rst_n          (rst_n),
    .clk_en         (clk_en),
    .rdw_en         (rdw_en),
    .pdout_en       (pdout_en),
    .deepsleep      (deepsleep),
    .addr           (addr),
    .data_in        (data_in),
    .data_mask_in   (data_mask_in),
    .data_out       (data_out),
    .pdata_out      (pdata_out),

    // sram interfaces
    .srams_rtap_data (srams_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);



endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_encoder.v
//  Created On    : 2014-03-03
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The message encoder in the L2 cache
//
//
//====================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_encoder(

    input wire [14-1:0] msg_dst_chipid,
    input wire [8-1:0] msg_dst_x,
    input wire [8-1:0] msg_dst_y,
    input wire [4-1:0] msg_dst_fbits,
    input wire [8-1:0] msg_length,
    input wire [8-1:0] msg_type,
    input wire [8-1:0] msg_mshrid,
    input wire [3-1:0] msg_data_size,
    input wire [1-1:0] msg_cache_type,
    input wire [4-1:0] msg_subline_vector,
    input wire [2-1:0] msg_mesi,
    input wire [1-1:0] msg_l2_miss,
    input wire [1-1:0] msg_last_subline,
    input wire [2-1:0] msg_subline_id,
    input wire [40-1:0] msg_addr,
    input wire [14-1:0] msg_src_chipid,
    input wire [8-1:0] msg_src_x,
    input wire [8-1:0] msg_src_y,
    input wire [4-1:0] msg_src_fbits,
    input wire [10-1:0] msg_sdid,
    input wire [6-1:0] msg_lsid,


    output reg [192-1:0] msg_header
);

always @ *
begin
    msg_header = {msg_src_chipid,
                  msg_src_x,
                  msg_src_y,
                  msg_src_fbits,
                  msg_sdid,
                  msg_lsid,
                  14'd0,

                  8'd0,
                  msg_addr,
                  msg_subline_vector,
                  msg_cache_type,
                  msg_data_size,
                  8'd0,

                  msg_dst_chipid,
                  msg_dst_x,
                  msg_dst_y,
                  msg_dst_fbits,
                  msg_length,
                  msg_type,
                  msg_mshrid,
                  msg_mesi,
                  msg_l2_miss,
                  msg_subline_id,
                  msg_last_subline};
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_mshr_decoder.v
//  Created On    : 2014-03-03
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The mshr decoder in the L2 cache
//
//
//====================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_mshr_decoder(

    input wire [120+2-1:0] data_in,

    output reg [40-1:0] addr_out,
    output reg [2-1:0] way_out,
    output reg [8-1:0] mshrid_out,
    output reg [1-1:0] cache_type_out,
    output reg [3-1:0] data_size_out,
    output reg [8-1:0] msg_type_out,
    output reg [1-1:0] msg_l2_miss_out,
    output reg [14-1:0] src_chipid_out,
    output reg [8-1:0] src_x_out,
    output reg [8-1:0] src_y_out,
    output reg [4-1:0] src_fbits_out,
    output reg [10-1:0] sdid_out,
    output reg [6-1:0] lsid_out,
    output reg [6-1:0] miss_lsid_out,
    output reg smc_miss_out,
    output reg recycled,
    output reg inv_fwd_pending

);


always @ *
begin
    addr_out = data_in[39:0];
    way_out = data_in[39+2:40];
    mshrid_out = data_in[47+2:40+2];
    cache_type_out = data_in[48+2];
    data_size_out = data_in[51+2:49+2];
    msg_type_out = data_in[59+2:52+2];
    msg_l2_miss_out = data_in[60+2];
    src_chipid_out = data_in[74+2:61+2];
    src_x_out = data_in[82+2:75+2];
    src_y_out = data_in[90+2:83+2];
    src_fbits_out = data_in[94+2:91+2];
    sdid_out = data_in[104+2:95+2];
    lsid_out = data_in[110+2:105+2];
    miss_lsid_out = data_in[116+2:111+2];
    smc_miss_out = data_in[117+2];
    recycled = data_in[118+2];
    inv_fwd_pending = data_in[119+2];
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe1.v
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Pipeline 1 for the L2 cache
//
//
//====================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe1(

    input wire clk,
    input wire rst_n,
    input wire [34-1:0] my_nodeid,
    
    input wire csm_en,
    
    input wire [22-1:0] smt_base_addr,
  
   //inputs from NOC1
   
    input wire noc_valid_in,
    input wire [64-1:0] noc_data_in,
    output wire noc_ready_in,
    

    //outputs to NOC2
   
    output wire noc_valid_out,
    output wire [64-1:0] noc_data_out,
    input wire  noc_ready_out,

    input wire pipe2_valid_S1,
    input wire pipe2_valid_S2,
    input wire pipe2_valid_S3,
    input wire [8-1:0] pipe2_msg_type_S1,
    input wire [8-1:0] pipe2_msg_type_S2,
    input wire [8-1:0] pipe2_msg_type_S3,
    input wire [40-1:0] pipe2_addr_S1,
    input wire [40-1:0] pipe2_addr_S2,
    input wire [40-1:0] pipe2_addr_S3,
    input wire global_stall_S1,
    input wire global_stall_S2,
    input wire global_stall_S4,

    input wire mshr_hit,



    input wire [120+2-1:0] cam_mshr_data_out,
    input wire [120+2-1:0] pending_mshr_data_out,
 // L2_CAM_MSHR
    input wire [6-1:0] mshr_inv_counter_out,
    input wire [3:0] mshr_empty_slots,
    input wire mshr_pending,
    input wire [3-1:0] mshr_pending_index,
    input wire [3-1:0] mshr_empty_index,

    
    input wire broadcast_counter_zero,
    input wire broadcast_counter_max,
    input wire broadcast_counter_avail,
    input wire [14-1:0] broadcast_chipid_out,
    input wire [8-1:0] broadcast_x_out,
    input wire [8-1:0] broadcast_y_out,
    

    input wire [15*4+2+4-1:0] state_data_out,
    
    input wire [100-1:0] tag_data_out,

    input wire [64-1:0] dir_data_out,

    input wire [144-1:0] data_data_out,

    
    input wire smc_hit,
    input wire [30-1:0] smc_data_out,
    input wire [4-1:0] smc_valid_out,
    input wire [14-1:0] smc_tag_out,
    

    input wire [64-1:0] reg_data_out,

    output wire mshr_cam_en,
    output wire mshr_wr_state_en,
    output wire mshr_wr_data_en,
    output wire mshr_pending_ready,
    output wire [2-1:0] mshr_state_in,
    output wire [120+2-1:0] mshr_data_in,
    output wire [120+2-1:0] mshr_data_mask_in,
    output wire [3-1:0] mshr_inv_counter_rd_index_in,
    output wire [3-1:0] mshr_wr_index_in,
    output wire [9-1:0] mshr_addr_in,

    output wire state_rd_en,
    output wire state_wr_en,
    output wire [9-1:0] state_rd_addr,
    output wire [9-1:0] state_wr_addr,
    output wire [15*4+2+4-1:0] state_data_in,
    output wire [15*4+2+4-1:0] state_data_mask_in,


    output wire tag_clk_en,
    output wire tag_rdw_en,
    output wire [9-1:0] tag_addr,
    output wire [100-1:0] tag_data_in,
    output wire [100-1:0] tag_data_mask_in,

    output wire dir_clk_en,
    output wire dir_rdw_en,
    output wire [9+2-1:0] dir_addr,
    output wire [64-1:0] dir_data_in,
    output wire [64-1:0] dir_data_mask_in,

    output wire data_clk_en,
    output wire data_rdw_en,
    output wire [9+2+2-1:0] data_addr,
    output wire [144-1:0] data_data_in,
    output wire [144-1:0] data_data_mask_in,

    
    output wire [2-1:0] broadcast_counter_op,
    output wire broadcast_counter_op_val,
    

    
    output wire smc_rd_en,
    output wire [16-1:0] smc_rd_addr_in,
    output wire smc_rd_diag_en,
    output wire smc_flush_en,
    output wire [2-1:0] smc_addr_op,
    output wire smc_wr_en,
    output wire smc_wr_diag_en,
    output wire [16-1:0] smc_wr_addr_in,
    output wire [128-1:0] smc_data_in,
    

    output wire l2_access_valid,
    output wire l2_miss_valid,
    output wire data_ecc_corr_error,
    output wire data_ecc_uncorr_error,
    output wire [9+2+2-1:0] data_ecc_addr,
    output wire [40-1:0] error_addr,

    output wire reg_rd_en,
    output wire reg_wr_en,
    output wire [8-1:0] reg_rd_addr_type,
    output wire [8-1:0] reg_wr_addr_type,
    output wire [64-1:0] reg_data_in

);


wire [8-1:0] msg_type;
wire [8-1:0] msg_length;
wire [8-1:0] msg_mshrid;
wire [3-1:0] msg_data_size;
wire [1-1:0] msg_cache_type;
wire [40-1:0] msg_addr;
wire [14-1:0] msg_src_chipid;
wire [8-1:0] msg_src_x;
wire [8-1:0] msg_src_y;
wire [4-1:0] msg_src_fbits;
wire [10-1:0] msg_sdid;
wire [6-1:0] msg_lsid;

















wire [8-1:0] cam_mshr_msg_type;
wire [8-1:0] cam_mshr_mshrid;
wire [3-1:0] cam_mshr_data_size;
wire [1-1:0] cam_mshr_cache_type;
wire [40-1:0] cam_mshr_addr;
wire [2-1:0] cam_mshr_way;
wire [1-1:0] cam_mshr_l2_miss;
wire [14-1:0] cam_mshr_src_chipid;
wire [8-1:0] cam_mshr_src_x;
wire [8-1:0] cam_mshr_src_y;
wire [4-1:0] cam_mshr_src_fbits;
wire [10-1:0] cam_mshr_sdid;
wire [6-1:0] cam_mshr_lsid;
wire [6-1:0] cam_mshr_miss_lsid;
 // L2_CAM_MSHR




wire cam_mshr_smc_miss;
 // L2_CAM_MSHR




wire cam_mshr_recycled;

wire [8-1:0] pending_mshr_msg_type;
wire [8-1:0] pending_mshr_mshrid;
wire [3-1:0] pending_mshr_data_size;
wire [1-1:0] pending_mshr_cache_type;
wire [40-1:0] pending_mshr_addr;
wire [2-1:0] pending_mshr_way;
wire [1-1:0] pending_mshr_l2_miss;
wire [14-1:0] pending_mshr_src_chipid;
wire [8-1:0] pending_mshr_src_x;
wire [8-1:0] pending_mshr_src_y;
wire [4-1:0] pending_mshr_src_fbits;
wire [10-1:0] pending_mshr_sdid;
wire [6-1:0] pending_mshr_lsid;
wire [6-1:0] pending_mshr_miss_lsid;

wire pending_mshr_smc_miss;

wire pending_mshr_recycled;
 // L2_CAM_MSHR

wire msg_header_valid;
wire [192-1:0] msg_header;
wire msg_header_ready;

wire msg_data_valid;
wire [64-1:0] msg_data;
wire msg_data_ready;


wire valid_S1; 
wire stall_S1;  
wire msg_from_mshr_S1;
wire [40-1:0] addr_S1;
wire dis_flush_S1;


wire [4-1:0] amo_alu_op_S2;

wire valid_S2; 
wire stall_S2;  
wire stall_before_S2; 
wire stall_real_S2; 
wire msg_from_mshr_S2;
wire [8-1:0] msg_type_S2;
wire [3-1:0] data_size_S2;
wire [1-1:0] cache_type_S2;
wire state_owner_en_S2;
wire [2-1:0] state_owner_op_S2;
wire state_subline_en_S2;
wire [2-1:0] state_subline_op_S2;
wire state_di_en_S2;
wire state_vd_en_S2;
wire [2-1:0] state_vd_S2;
wire state_mesi_en_S2;
wire [2-1:0] state_mesi_S2;
wire state_lru_en_S2;
wire [1-1:0] state_lru_op_S2;
wire state_rb_en_S2;
wire l2_ifill_32B_S2;
wire [2-1:0] l2_load_data_subline_S2;
wire [40-1:0] addr_S2;
wire l2_tag_hit_S2;
wire l2_evict_S2;
wire l2_wb_S2;
wire [2-1:0] l2_way_state_mesi_S2;
wire [2-1:0] l2_way_state_vd_S2;
wire [1-1:0] l2_way_state_cache_type_S2;
wire [4-1:0] l2_way_state_subline_S2;
wire [2-1:0] dir_op_S2;
wire req_from_owner_S2;
wire addr_l2_aligned_S2;
wire special_addr_type_S2;
wire [6-1:0] lsid_S2;
wire state_load_sdid_S2;


wire valid_S3; 
wire stall_S3;  
wire stall_before_S3; 
wire [40-1:0] addr_S3;

wire valid_S4;    
wire stall_S4;
wire stall_before_S4; 
wire [6-1:0] dir_sharer_S4;
wire [6-1:0] dir_sharer_counter_S4;
wire cas_cmp_en_S4;
wire [3-1:0] cas_cmp_data_size_S4;
wire [40-1:0] addr_S4;
wire l2_evict_S4;
wire l2_tag_hit_S4;
wire [2-1:0] l2_way_state_mesi_S4;
wire [6-1:0] l2_way_state_owner_S4;
wire [2-1:0] l2_way_state_vd_S4;
wire [4-1:0] l2_way_state_subline_S4;
wire [1-1:0] l2_way_state_cache_type_S4;
wire [8-1:0] mshrid_S4;
wire req_from_owner_S4;
wire cas_cmp_S4;
wire atomic_read_data_en_S4;
wire [8-1:0] msg_type_S4;
wire [3-1:0] data_size_S4;
wire [1-1:0] cache_type_S4;
wire [1-1:0] l2_miss_S4;
wire [6-1:0] mshr_miss_lsid_S4;
wire [6-1:0] lsid_S4;
wire special_addr_type_S4;
wire state_wr_sel_S4;
wire [64-1:0] dir_data_S4;
wire [64-1:0] dir_data_sel_S4;

wire smc_miss_S4;
wire stall_smc_buf_S4;
    
wire msg_from_mshr_S4;
wire req_recycle_S4;
wire inv_fwd_pending_S4;

wire msg_send_valid;
wire msg_send_ready;
wire [3-1:0] msg_send_mode;
wire [8-1:0] msg_send_type;
wire [8-1:0] msg_send_type_pre;
wire [8-1:0] msg_send_length;
wire [3-1:0] msg_send_data_size;
wire [1-1:0] msg_send_cache_type;
wire [1-1:0] msg_send_l2_miss;
wire [2-1:0] msg_send_mesi;
wire [8-1:0] msg_send_mshrid;
wire [4-1:0] msg_send_subline_vector;
wire [40-1:0] msg_send_addr;
wire [14-1:0] msg_send_dst_chipid;
wire [8-1:0] msg_send_dst_x;
wire [8-1:0] msg_send_dst_y;
wire [4-1:0] msg_send_dst_fbits;
wire [64*2-1:0] msg_send_data;
wire [64*3-1:0] msg_send_header;


assign error_addr = addr_S4;

l2_pipe1_buf_in buf_in(
    .clk                    (clk),
    .rst_n                  (rst_n),

    .valid_in               (noc_valid_in),
    .data_in                (noc_data_in),
    .ready_in               (noc_ready_in),

    .msg_header_valid_out   (msg_header_valid),
    .msg_header_out         (msg_header),
    .msg_header_ready_out   (msg_header_ready),

    .msg_data_valid_out     (msg_data_valid),
    .msg_data_out           (msg_data),
    .msg_data_ready_out     (msg_data_ready)
);


l2_decoder decoder(
    .msg_header         (msg_header),
    .msg_type           (msg_type),
    .msg_length         (msg_length),
    .msg_mshrid         (msg_mshrid),
    .msg_data_size      (msg_data_size),
    .msg_cache_type     (msg_cache_type),
    .msg_subline_vector (),
    .msg_mesi           (),
    .msg_l2_miss        (),
    .msg_subline_id     (),
    .msg_last_subline   (),
    .msg_addr           (msg_addr),
    .msg_src_chipid     (msg_src_chipid),
    .msg_src_x          (msg_src_x),
    .msg_src_y          (msg_src_y),
    .msg_src_fbits      (msg_src_fbits),
    .msg_sdid           (msg_sdid),
    .msg_lsid           (msg_lsid)
);




























// reg [`L2_MSHR_ARRAY_WIDTH-1:0] mshr_data_out;
// always @ * begin
//     if (mshr_cam_en)
//         mshr_data_out = cam_mshr_data_out;
//     else
//         mshr_data_out = pending_mshr_data_out;
// end

l2_mshr_decoder cam_mshr_decoder(

    // .cam_data_in            (cam_mshr_data_out),
    // .pending_data_in            (pending_mshr_data_out),
    .data_in            (cam_mshr_data_out),
    .addr_out           (cam_mshr_addr),
    .way_out            (cam_mshr_way),
    .mshrid_out         (cam_mshr_mshrid),
    .cache_type_out     (cam_mshr_cache_type), 
    .data_size_out      (cam_mshr_data_size),
    .msg_type_out       (cam_mshr_msg_type),
    .msg_l2_miss_out    (cam_mshr_l2_miss),
    .src_chipid_out     (cam_mshr_src_chipid),
    .src_x_out          (cam_mshr_src_x),
    .src_y_out          (cam_mshr_src_y),
    .src_fbits_out      (cam_mshr_src_fbits),
    .sdid_out           (cam_mshr_sdid),
    .lsid_out           (cam_mshr_lsid),
    .miss_lsid_out      (cam_mshr_miss_lsid),
    
    .smc_miss_out       (cam_mshr_smc_miss),
    


    .recycled           (cam_mshr_recycled),
    .inv_fwd_pending    ()
);

l2_mshr_decoder pending_mshr_decoder(

    // .cam_data_in            (cam_mshr_data_out),
    // .pending_data_in            (pending_mshr_data_out),
    .data_in            (pending_mshr_data_out),
    .addr_out           (pending_mshr_addr),
    .way_out            (pending_mshr_way),
    .mshrid_out         (pending_mshr_mshrid),
    .cache_type_out     (pending_mshr_cache_type), 
    .data_size_out      (pending_mshr_data_size),
    .msg_type_out       (pending_mshr_msg_type),
    .msg_l2_miss_out    (pending_mshr_l2_miss),
    .src_chipid_out     (pending_mshr_src_chipid),
    .src_x_out          (pending_mshr_src_x),
    .src_y_out          (pending_mshr_src_y),
    .src_fbits_out      (pending_mshr_src_fbits),
    .sdid_out           (pending_mshr_sdid),
    .lsid_out           (pending_mshr_lsid),
    .miss_lsid_out      (pending_mshr_miss_lsid),
    
    .smc_miss_out       (pending_mshr_smc_miss),
    


    .recycled           (pending_mshr_recycled),
    .inv_fwd_pending    ()
);
 // L2_CAM_MSHR

l2_pipe1_ctrl ctrl(

    .clk                        (clk),
    .rst_n                      (rst_n),
    
    .csm_en                     (csm_en),
    

    .pipe2_valid_S1             (pipe2_valid_S1),
    .pipe2_valid_S2             (pipe2_valid_S2),
    .pipe2_valid_S3             (pipe2_valid_S3),
    .pipe2_msg_type_S1          (pipe2_msg_type_S1),
    .pipe2_msg_type_S2          (pipe2_msg_type_S2),
    .pipe2_msg_type_S3          (pipe2_msg_type_S3),
    .pipe2_addr_S1              (pipe2_addr_S1),
    .pipe2_addr_S2              (pipe2_addr_S2),
    .pipe2_addr_S3              (pipe2_addr_S3),

    .global_stall_S1            (global_stall_S1),
    .msg_header_valid_S1        (msg_header_valid),
    .msg_type_S1                (msg_type),
    .msg_data_size_S1           (msg_data_size),
    .msg_cache_type_S1          (msg_cache_type),
    .mshr_hit_S1                (mshr_hit),






    .cam_mshr_msg_type_S1       (cam_mshr_msg_type),
    .cam_mshr_l2_miss_S1        (cam_mshr_l2_miss),
    .cam_mshr_data_size_S1      (cam_mshr_data_size),
    .cam_mshr_cache_type_S1     (cam_mshr_cache_type), 
 // L2_CAM_MSHR
    .mshr_pending_S1            (mshr_pending),
    .mshr_pending_index_S1      (mshr_pending_index),
    .mshr_empty_slots_S1        (mshr_empty_slots),
    



    .cam_mshr_smc_miss_S1       (cam_mshr_smc_miss),
 // L2_CAM_MSHR
    

    .pending_mshr_msg_type_S1           (pending_mshr_msg_type),
    .pending_mshr_l2_miss_S1            (pending_mshr_l2_miss),
    .pending_mshr_data_size_S1          (pending_mshr_data_size),
    .pending_mshr_cache_type_S1         (pending_mshr_cache_type), 
    
    .pending_mshr_smc_miss_S1           (pending_mshr_smc_miss),
    
 // L2_CAM_MSHR
    .msg_data_valid_S1          (msg_data_valid),
    .addr_S1                    (addr_S1),
   
    .global_stall_S2            (global_stall_S2),
    .l2_tag_hit_S2              (l2_tag_hit_S2),
    .l2_evict_S2                (l2_evict_S2),
    .l2_wb_S2                   (l2_wb_S2),
    .l2_way_state_mesi_S2       (l2_way_state_mesi_S2),
    .l2_way_state_vd_S2         (l2_way_state_vd_S2),
    .l2_way_state_cache_type_S2 (l2_way_state_cache_type_S2),
    .l2_way_state_subline_S2    (l2_way_state_subline_S2),
    .req_from_owner_S2          (req_from_owner_S2),
    .addr_l2_aligned_S2         (addr_l2_aligned_S2),
    .lsid_S2                    (lsid_S2),
    .msg_data_valid_S2          (msg_data_valid),
    .addr_S2                    (addr_S2),

    .dir_data_S3                (dir_data_out),
    .addr_S3                    (addr_S3),

    .global_stall_S4            (global_stall_S4),
    .l2_evict_S4                (l2_evict_S4),
    .l2_tag_hit_S4              (l2_tag_hit_S4),
    .l2_way_state_mesi_S4       (l2_way_state_mesi_S4),
    .l2_way_state_owner_S4      (l2_way_state_owner_S4),
    .l2_way_state_vd_S4         (l2_way_state_vd_S4),
    .l2_way_state_subline_S4    (l2_way_state_subline_S4),
    .l2_way_state_cache_type_S4 (l2_way_state_cache_type_S4),
    .mshrid_S4                  (mshrid_S4),
    .req_from_owner_S4          (req_from_owner_S4),
    .mshr_miss_lsid_S4          (mshr_miss_lsid_S4),
    .lsid_S4                    (lsid_S4),
    .addr_S4                    (addr_S4),
    .cas_cmp_S4                 (cas_cmp_S4),
    .msg_send_ready_S4          (msg_send_ready),
    .mshr_empty_index_S4        (mshr_empty_index),
    
    
    .smc_hit_S4                 (smc_hit),
    .broadcast_counter_zero_S4  (broadcast_counter_zero),
    .broadcast_counter_max_S4   (broadcast_counter_max),
    .broadcast_counter_avail_S4 (broadcast_counter_avail),
    .broadcast_chipid_out_S4    (broadcast_chipid_out),
    .broadcast_x_out_S4         (broadcast_x_out),
    .broadcast_y_out_S4         (broadcast_y_out),
    

    .valid_S1                   (valid_S1),  
    .stall_S1                   (stall_S1),    
    .msg_from_mshr_S1           (msg_from_mshr_S1), 
    .dis_flush_S1               (dis_flush_S1),
    .mshr_cam_en_S1             (mshr_cam_en),
    .mshr_pending_ready_S1      (mshr_pending_ready),
    .msg_header_ready_S1        (msg_header_ready),
    .tag_clk_en_S1              (tag_clk_en),
    .tag_rdw_en_S1              (tag_rdw_en),
    .state_rd_en_S1             (state_rd_en),
    .reg_wr_en_S1               (reg_wr_en),
    .reg_wr_addr_type_S1        (reg_wr_addr_type),


    .valid_S2                   (valid_S2),    
    .stall_S2                   (stall_S2), 
    .stall_before_S2            (stall_before_S2), 
    .stall_real_S2              (stall_real_S2),
    .msg_type_S2                (msg_type_S2),
    .msg_from_mshr_S2           (msg_from_mshr_S2),
    .special_addr_type_S2       (special_addr_type_S2),
    .dir_clk_en_S2              (dir_clk_en),
    .dir_rdw_en_S2              (dir_rdw_en),
    .dir_op_S2                  (dir_op_S2),
    .data_clk_en_S2             (data_clk_en),
    .data_rdw_en_S2             (data_rdw_en),
    .amo_alu_op_S2              (amo_alu_op_S2),
    .data_size_S2               (data_size_S2),
    .cache_type_S2              (cache_type_S2),
    .state_owner_en_S2          (state_owner_en_S2),
    .state_owner_op_S2          (state_owner_op_S2),
    .state_subline_en_S2        (state_subline_en_S2),
    .state_subline_op_S2        (state_subline_op_S2),   
    .state_di_en_S2             (state_di_en_S2),
    .state_vd_en_S2             (state_vd_en_S2),
    .state_vd_S2                (state_vd_S2),
    .state_mesi_en_S2           (state_mesi_en_S2),
    .state_mesi_S2              (state_mesi_S2),
    .state_lru_en_S2            (state_lru_en_S2),
    .state_lru_op_S2            (state_lru_op_S2),
    .state_rb_en_S2             (state_rb_en_S2),
    .state_load_sdid_S2         (state_load_sdid_S2),
    .l2_ifill_32B_S2            (l2_ifill_32B_S2),
    .l2_load_data_subline_S2    (l2_load_data_subline_S2),
    .msg_data_ready_S2          (msg_data_ready),
    
    .smc_wr_en_S2               (smc_wr_en),
    .smc_wr_diag_en_S2          (smc_wr_diag_en),
    .smc_flush_en_S2            (smc_flush_en),
    .smc_addr_op_S2             (smc_addr_op),
        

    .valid_S3                   (valid_S3),    
    .stall_S3                   (stall_S3), 
    .stall_before_S3            (stall_before_S3), 

    .valid_S4                   (valid_S4),    
    .stall_S4                   (stall_S4), 
    .stall_before_S4            (stall_before_S4),
     
    .stall_smc_buf_S4           (stall_smc_buf_S4),
    
    .msg_from_mshr_S4           (msg_from_mshr_S4),
    .req_recycle_S4             (req_recycle_S4),
    .inv_fwd_pending_S4         (inv_fwd_pending_S4),
    .dir_sharer_S4              (dir_sharer_S4),
    .dir_sharer_counter_S4      (dir_sharer_counter_S4),
    .cas_cmp_en_S4              (cas_cmp_en_S4),
    .atomic_read_data_en_S4     (atomic_read_data_en_S4),
    .cas_cmp_data_size_S4       (cas_cmp_data_size_S4),
    .msg_send_valid_S4          (msg_send_valid),
    .msg_send_mode_S4           (msg_send_mode),
    .msg_send_type_S4           (msg_send_type),
    .msg_send_type_pre_S4       (msg_send_type_pre),
    .msg_send_length_S4         (msg_send_length),
    .msg_send_data_size_S4      (msg_send_data_size),
    .msg_send_cache_type_S4     (msg_send_cache_type),
    .msg_send_mesi_S4           (msg_send_mesi),
    .msg_send_l2_miss_S4        (msg_send_l2_miss),
    .msg_send_mshrid_S4         (msg_send_mshrid),
    .msg_send_subline_vector_S4 (msg_send_subline_vector),
    .special_addr_type_S4       (special_addr_type_S4),
    .dir_data_sel_S4            (dir_data_sel_S4),
    .dir_data_S4                (dir_data_S4),
    .msg_type_S4                (msg_type_S4),
    .data_size_S4               (data_size_S4),
    .cache_type_S4              (cache_type_S4),
    .l2_miss_S4                 (l2_miss_S4),
    
    .smc_miss_S4                (smc_miss_S4),
    
    .mshr_wr_data_en_S4         (mshr_wr_data_en),
    .mshr_wr_state_en_S4        (mshr_wr_state_en),
    .mshr_state_in_S4           (mshr_state_in),
    .mshr_wr_index_in_S4        (mshr_wr_index_in),    
    .mshr_inv_counter_rd_index_in_S4(mshr_inv_counter_rd_index_in),    
    .state_wr_sel_S4            (state_wr_sel_S4),
    .state_wr_en_S4             (state_wr_en),
    
    .broadcast_counter_op_S4    (broadcast_counter_op),
    .broadcast_counter_op_val_S4(broadcast_counter_op_val),
    
    
    
    .smc_rd_diag_en_buf_S4      (smc_rd_diag_en),
    .smc_rd_en_buf_S4           (smc_rd_en),
    

    .l2_access_valid_S4         (l2_access_valid),
    .l2_miss_valid_S4           (l2_miss_valid),
    .reg_rd_en_S4               (reg_rd_en),
    .reg_rd_addr_type_S4        (reg_rd_addr_type)


);


l2_pipe1_dpath dpath(
    .clk                        (clk),
    .rst_n                      (rst_n),
    
    .csm_en                     (csm_en),
    
    .smt_base_addr              (smt_base_addr),
    













    .cam_mshr_addr_S1           (cam_mshr_addr),
    .cam_mshr_mshrid_S1         (cam_mshr_mshrid),
    .cam_mshr_way_S1            (cam_mshr_way),
    .cam_mshr_src_chipid_S1     (cam_mshr_src_chipid),
    .cam_mshr_src_x_S1          (cam_mshr_src_x),
    .cam_mshr_src_y_S1          (cam_mshr_src_y),
    .cam_mshr_src_fbits_S1      (cam_mshr_src_fbits),
    .cam_mshr_sdid_S1           (cam_mshr_sdid),
    .cam_mshr_lsid_S1           (cam_mshr_lsid),
    .cam_mshr_miss_lsid_S1      (cam_mshr_miss_lsid),
    .cam_mshr_recycled_S1       (cam_mshr_recycled),
    
    .mshr_pending_S1            (mshr_pending),
    .pending_mshr_addr_S1       (pending_mshr_addr),
    .pending_mshr_mshrid_S1     (pending_mshr_mshrid),
    .pending_mshr_way_S1        (pending_mshr_way),
    .pending_mshr_src_chipid_S1 (pending_mshr_src_chipid),
    .pending_mshr_src_x_S1      (pending_mshr_src_x),
    .pending_mshr_src_y_S1      (pending_mshr_src_y),
    .pending_mshr_src_fbits_S1  (pending_mshr_src_fbits),
    .pending_mshr_sdid_S1       (pending_mshr_sdid),
    .pending_mshr_lsid_S1       (pending_mshr_lsid),
    .pending_mshr_miss_lsid_S1  (pending_mshr_miss_lsid),
    .pending_mshr_recycled_S1   (pending_mshr_recycled),
 // L2_CAM_MSHR

    .dis_flush_S1               (dis_flush_S1),
    .msg_addr_S1                (msg_addr),
    .msg_mshrid_S1              (msg_mshrid),
    .msg_src_chipid_S1          (msg_src_chipid),
    .msg_src_x_S1               (msg_src_x),
    .msg_src_y_S1               (msg_src_y),
    .msg_src_fbits_S1           (msg_src_fbits),
    .msg_sdid_S1                (msg_sdid),
    .msg_lsid_S1                (msg_lsid),
    .msg_data_S1                (msg_data),
    .valid_S1                   (valid_S1),
    .stall_S1                   (stall_S1),
    .msg_from_mshr_S1           (msg_from_mshr_S1), 


    .state_data_S2              (state_data_out),
    .tag_data_S2                (tag_data_out),
    .msg_data_S2                (msg_data),
    .msg_type_S2                (msg_type_S2),
    .msg_from_mshr_S2           (msg_from_mshr_S2),
    .special_addr_type_S2       (special_addr_type_S2),
    .data_size_S2               (data_size_S2),
    .cache_type_S2              (cache_type_S2),
    .state_owner_en_S2          (state_owner_en_S2),
    .state_owner_op_S2          (state_owner_op_S2), 
    .state_subline_en_S2        (state_subline_en_S2),
    .state_subline_op_S2        (state_subline_op_S2),
    .state_di_en_S2             (state_di_en_S2),
    .state_vd_en_S2             (state_vd_en_S2),
    .state_vd_S2                (state_vd_S2),
    .state_mesi_en_S2           (state_mesi_en_S2),
    .state_mesi_S2              (state_mesi_S2),
    .state_lru_en_S2            (state_lru_en_S2),
    .state_lru_op_S2            (state_lru_op_S2),
    .state_rb_en_S2             (state_rb_en_S2),
    .state_load_sdid_S2         (state_load_sdid_S2),
    .dir_op_S2                  (dir_op_S2),
    .l2_ifill_32B_S2            (l2_ifill_32B_S2),
    .l2_load_data_subline_S2    (l2_load_data_subline_S2),
    .valid_S2                   (valid_S2),
    .stall_S2                   (stall_S2),
    .stall_before_S2            (stall_before_S2), 
    .data_clk_en_S2             (data_clk_en),
    .stall_real_S2              (stall_real_S2),
    .amo_alu_op_S2              (amo_alu_op_S2),

    .valid_S3                   (valid_S3),
    .stall_S3                   (stall_S3),
    .stall_before_S3            (stall_before_S3), 
    .data_data_S3               (data_data_out),

    .valid_S4                   (valid_S4),
    .stall_S4                   (stall_S4),
    .stall_before_S4            (stall_before_S4),
     
    .stall_smc_buf_S4           (stall_smc_buf_S4),
    
    .msg_from_mshr_S4           (msg_from_mshr_S4),
    .req_recycle_S4             (req_recycle_S4),
    .inv_fwd_pending_S4         (inv_fwd_pending_S4),
    .cas_cmp_en_S4              (cas_cmp_en_S4),    
    .atomic_read_data_en_S4     (atomic_read_data_en_S4),
    .cas_cmp_data_size_S4       (cas_cmp_data_size_S4),
    .dir_sharer_S4              (dir_sharer_S4),
    .dir_sharer_counter_S4      (dir_sharer_counter_S4),
    .mshr_inv_counter_out_S4    (mshr_inv_counter_out),
    .special_addr_type_S4       (special_addr_type_S4),
    .dir_data_sel_S4            (dir_data_sel_S4),
    .dir_data_S4                (dir_data_S4),
    .msg_send_type_S4           (msg_send_type),
    .msg_send_length_S4         (msg_send_length),
    .my_nodeid_chipid_S4        (my_nodeid[33:20]),
    .my_nodeid_x_S4             (my_nodeid[19:12]),
    .my_nodeid_y_S4             (my_nodeid[11:4]),
    .state_wr_sel_S4            (state_wr_sel_S4),
    .msg_type_S4                (msg_type_S4),
    .msg_send_type_pre_S4       (msg_send_type_pre),
    .data_size_S4               (data_size_S4),
    .cache_type_S4              (cache_type_S4),
    .l2_miss_S4                 (l2_miss_S4),

    
    .smc_miss_S4                (smc_miss_S4),
    .smc_data_out_S4            (smc_data_out),
    .smc_valid_out_S4           (smc_valid_out),
    .smc_tag_out_S4             (smc_tag_out),
    
    .reg_data_out_S4            (reg_data_out),
    
    .broadcast_chipid_out_S4    (broadcast_chipid_out),
    .broadcast_x_out_S4         (broadcast_x_out),
    .broadcast_y_out_S4         (broadcast_y_out),
    
 
    .addr_S1                    (addr_S1),
    .mshr_addr_in_S1            (mshr_addr_in),
    .tag_addr_S1                (tag_addr),
    .tag_data_in_S1             (tag_data_in),  
    .tag_data_mask_in_S1        (tag_data_mask_in),
    .state_rd_addr_S1           (state_rd_addr),
    .reg_data_in_S1             (reg_data_in),

    .addr_S2                    (addr_S2),
    .l2_tag_hit_S2              (l2_tag_hit_S2),
    .l2_evict_S2                (l2_evict_S2),
    .l2_wb_S2                   (l2_wb_S2),
    .l2_way_state_mesi_S2       (l2_way_state_mesi_S2),
    .l2_way_state_vd_S2         (l2_way_state_vd_S2),    
    .l2_way_state_cache_type_S2 (l2_way_state_cache_type_S2),
    .l2_way_state_subline_S2    (l2_way_state_subline_S2),
    .req_from_owner_S2          (req_from_owner_S2),
    .addr_l2_aligned_S2         (addr_l2_aligned_S2),
    .lsid_S2                    (lsid_S2),
    .dir_addr_S2                (dir_addr),
    .dir_data_in_S2             (dir_data_in),
    .dir_data_mask_in_S2        (dir_data_mask_in),
    .data_addr_S2               (data_addr),
    .data_data_in_S2            (data_data_in),
    .data_data_mask_in_S2       (data_data_mask_in),

    
    .smc_wr_addr_in_S2          (smc_wr_addr_in),
    .smc_data_in_S2             (smc_data_in),
    

    .addr_S3                    (addr_S3),

    .addr_S4                    (addr_S4),
    .data_addr_S4               (data_ecc_addr),
    .l2_evict_S4                (l2_evict_S4),
    .l2_tag_hit_S4              (l2_tag_hit_S4),
    .l2_way_state_mesi_S4       (l2_way_state_mesi_S4),
    .l2_way_state_owner_S4      (l2_way_state_owner_S4),
    .l2_way_state_vd_S4         (l2_way_state_vd_S4),
    .l2_way_state_subline_S4    (l2_way_state_subline_S4),
    .l2_way_state_cache_type_S4 (l2_way_state_cache_type_S4),
    .mshrid_S4                  (mshrid_S4),
    .req_from_owner_S4          (req_from_owner_S4),
    .mshr_miss_lsid_S4          (mshr_miss_lsid_S4),
    .lsid_S4                    (lsid_S4),
    .corr_error_S4              (data_ecc_corr_error),
    .uncorr_error_S4            (data_ecc_uncorr_error),
    .cas_cmp_S4                 (cas_cmp_S4),
    .msg_send_addr_S4           (msg_send_addr),
    .msg_send_dst_chipid_S4     (msg_send_dst_chipid),
    .msg_send_dst_x_S4          (msg_send_dst_x),
    .msg_send_dst_y_S4          (msg_send_dst_y),
    .msg_send_dst_fbits_S4      (msg_send_dst_fbits),
    .msg_send_data_S4           (msg_send_data),
    .mshr_data_in_S4            (mshr_data_in),
    .mshr_data_mask_in_S4       (mshr_data_mask_in),

    
    .smc_rd_addr_in_buf_S4      (smc_rd_addr_in),
    

    .state_wr_addr_S4           (state_wr_addr),
    .state_data_in_S4           (state_data_in),
    .state_data_mask_in_S4      (state_data_mask_in)

);

l2_encoder encoder(
    .msg_dst_chipid             (msg_send_dst_chipid),
    .msg_dst_x                  (msg_send_dst_x),
    .msg_dst_y                  (msg_send_dst_y),
    .msg_dst_fbits              (msg_send_dst_fbits),
    .msg_length                 (msg_send_length),
    .msg_type                   (msg_send_type),
    .msg_mshrid                 (msg_send_mshrid),
    .msg_data_size              (msg_send_data_size),
    .msg_cache_type             (msg_send_cache_type),
    .msg_subline_vector         (msg_send_subline_vector),
    .msg_mesi                   (msg_send_mesi),
    .msg_l2_miss                (msg_send_l2_miss),
    .msg_subline_id             ({2{1'b0}}),
    .msg_last_subline           ({1{1'b0}}),
    .msg_addr                   (msg_send_addr),
    .msg_src_chipid             (my_nodeid[33:20]),
    .msg_src_x                  (my_nodeid[19:12]),
    .msg_src_y                  (my_nodeid[11:4]),
    .msg_src_fbits              (my_nodeid[3:0]),
    .msg_sdid                   ({10{1'b0}}),
    .msg_lsid                   ({6{1'b0}}),
    .msg_header                 (msg_send_header)
);



l2_pipe1_buf_out buf_out(
    .clk                (clk),
    .rst_n              (rst_n),
    .mode_in            (msg_send_mode),
    .valid_in           (msg_send_valid),
    .data_in            ({msg_send_data, msg_send_header}),
    .ready_in           (msg_send_ready),
    .valid_out          (noc_valid_out),
    .data_out           (noc_data_out),
    .ready_out          (noc_ready_out)
);



endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe2.v
//  Created On    : 2014-04-03
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Pipeline 2 for the L2 cache
//
//
//====================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe2(

    input wire clk,
    input wire rst_n,
    
    input wire csm_en,
    
    //inputs from NOC3
   
    input wire noc_valid_in,
    input wire [64-1:0] noc_data_in,
    output wire noc_ready_in,

    input wire [2-1:0] mshr_state_out,
    input wire [120+2-1:0] mshr_data_out,

    
    input wire broadcast_counter_zero,
    input wire broadcast_counter_max,
    input wire [14-1:0] broadcast_chipid_out,
    input wire [8-1:0] broadcast_x_out,
    input wire [8-1:0] broadcast_y_out,
    

    input wire [15*4+2+4-1:0] state_data_out,
    
    input wire [100-1:0] tag_data_out,

    input wire [64-1:0] dir_data_out,


    output wire mshr_rd_en,
    output wire mshr_wr_state_en,
    output wire mshr_wr_data_en,
    output wire [2-1:0] mshr_state_in,
    output wire [120+2-1:0] mshr_data_in,
    output wire [120+2-1:0] mshr_data_mask_in,
    output wire [3-1:0] mshr_rd_index_in,
    output wire [3-1:0] mshr_wr_index_in,
    output wire mshr_inc_counter_en,

    output wire state_rd_en,
    output wire state_wr_en,
    output wire [9-1:0] state_rd_addr,
    output wire [9-1:0] state_wr_addr,
    output wire [15*4+2+4-1:0] state_data_in,
    output wire [15*4+2+4-1:0] state_data_mask_in,


    output wire tag_clk_en,
    output wire tag_rdw_en,
    output wire [9-1:0] tag_addr,
    output wire [100-1:0] tag_data_in,
    output wire [100-1:0] tag_data_mask_in,

    output wire dir_clk_en,
    output wire dir_rdw_en,
    output wire [9+2-1:0] dir_addr,
    output wire [64-1:0] dir_data_in,
    output wire [64-1:0] dir_data_mask_in,

    output wire data_clk_en,
    output wire data_rdw_en,
    output wire [9+2+2-1:0] data_addr,
    output wire [144-1:0] data_data_in,
    output wire [144-1:0] data_data_mask_in,

    
    output wire [2-1:0] broadcast_counter_op,
    output wire broadcast_counter_op_val,

    output wire smc_wr_en,
    output wire [16-1:0] smc_wr_addr_in,
    output wire [128-1:0] smc_data_in,
    

    output wire valid_S1,
    output wire valid_S2,
    output wire valid_S3,

    output wire [8-1:0] msg_type_S1,
    output wire [8-1:0] msg_type_S2,
    output wire [8-1:0] msg_type_S3,

    output wire [40-1:0] addr_S1,
    output wire [40-1:0] addr_S2,
    output wire [40-1:0] addr_S3,

    output wire active_S1,
    output wire active_S2,
    output wire active_S3
);


wire [8-1:0] msg_type;
wire [8-1:0] msg_length;
wire [8-1:0] msg_mshrid;
wire [3-1:0] msg_data_size;
wire [1-1:0] msg_cache_type;
wire [2-1:0] msg_subline_id;
wire [1-1:0] msg_last_subline;
wire [2-1:0] msg_mesi;
wire [40-1:0] msg_addr;
wire [14-1:0] msg_src_chipid;
wire [8-1:0] msg_src_x;
wire [8-1:0] msg_src_y;
wire [4-1:0] msg_src_fbits;
wire [10-1:0] msg_sdid;
wire [6-1:0] msg_lsid;


wire [8-1:0] mshr_msg_type;
wire [8-1:0] mshr_mshrid;
wire [3-1:0] mshr_data_size;
wire [1-1:0] mshr_cache_type;
wire [40-1:0] mshr_addr;
wire [2-1:0] mshr_way;
wire [1-1:0] mshr_l2_miss;
wire [14-1:0] mshr_src_chipid;
wire [8-1:0] mshr_src_x;
wire [8-1:0] mshr_src_y;
wire [4-1:0] mshr_src_fbits;
wire [10-1:0] mshr_sdid;
wire [6-1:0] mshr_lsid;
wire [6-1:0] mshr_miss_lsid;

wire mshr_smc_miss;

wire mshr_recycled;
wire mshr_inv_fwd_pending;

wire msg_header_valid;
wire [192-1:0] msg_header;
wire msg_header_ready;

wire msg_data_valid;
wire [128-1:0] msg_data;
wire msg_data_ready;

//wire valid_S1;
wire stall_S1;
wire msg_from_mshr_S1;
//wire [`PHY_ADDR_WIDTH-1:0] addr_S1;
wire is_same_address_S1;


//wire valid_S2;
wire stall_S2;
wire stall_before_S2;
wire msg_from_mshr_S2;
wire [3-1:0] data_size_S2;
wire [1-1:0] cache_type_S2;
wire state_owner_en_S2;
wire [2-1:0] state_owner_op_S2;
wire state_subline_en_S2;
wire [2-1:0] state_subline_op_S2;
wire state_di_en_S2;
wire state_vd_en_S2;
wire [2-1:0] state_vd_S2;
wire state_mesi_en_S2;
wire [2-1:0] state_mesi_S2;
wire state_lru_en_S2;
wire [1-1:0] state_lru_op_S2;
wire state_rb_en_S2;
wire dir_clr_en_S2;
wire l2_load_64B_S2;
wire l2_load_32B_S2;
wire [2-1:0] l2_load_data_subline_S2;
//wire [`PHY_ADDR_WIDTH-1:0] addr_S2;
wire l2_tag_hit_S2;
wire [2-1:0] l2_way_sel_S2;
wire l2_evict_S2;
wire l2_wb_S2;
wire [6-1:0] l2_way_state_owner_S2;
wire [2-1:0] l2_way_state_mesi_S2;
wire [2-1:0] l2_way_state_vd_S2;
wire [4-1:0] l2_way_state_subline_S2;
wire [1-1:0] l2_way_state_cache_type_S2;
wire addr_l2_aligned_S2;
wire subline_valid_S2;
wire [6-1:0] lsid_S2;

//wire valid_S3;
wire stall_S3;
//wire [`PHY_ADDR_WIDTH-1:0] addr_S3;

assign msg_type_S1 = msg_type;


l2_pipe2_buf_in buf_in(
    .clk                    (clk),
    .rst_n                  (rst_n),

    .valid_in               (noc_valid_in),
    .data_in                (noc_data_in),
    .ready_in               (noc_ready_in),

    .msg_header_valid_out   (msg_header_valid),
    .msg_header_out         (msg_header),
    .msg_header_ready_out   (msg_header_ready),

    .msg_data_valid_out     (msg_data_valid),
    .msg_data_out           (msg_data),
    .msg_data_ready_out     (msg_data_ready)
);


l2_decoder decoder(
    .msg_header         (msg_header),
    .msg_type           (msg_type),
    .msg_length         (msg_length),
    .msg_mshrid         (msg_mshrid),
    .msg_data_size      (msg_data_size),
    .msg_cache_type     (msg_cache_type),
    .msg_subline_vector (),
    .msg_mesi           (msg_mesi),
    .msg_l2_miss        (),
    .msg_subline_id     (msg_subline_id),
    .msg_last_subline   (msg_last_subline),
    .msg_addr           (msg_addr),
    .msg_src_chipid     (msg_src_chipid),
    .msg_src_x          (msg_src_x),
    .msg_src_y          (msg_src_y),
    .msg_src_fbits      (msg_src_fbits),
    .msg_sdid           (msg_sdid),
    .msg_lsid           (msg_lsid)
);

l2_mshr_decoder mshr_decoder(

    .data_in            (mshr_data_out),
    .addr_out           (mshr_addr),
    .way_out            (mshr_way),
    .mshrid_out         (mshr_mshrid),
    .cache_type_out     (mshr_cache_type), 
    .data_size_out      (mshr_data_size),
    .msg_type_out       (mshr_msg_type),
    .msg_l2_miss_out    (mshr_l2_miss),
    .src_chipid_out     (mshr_src_chipid),
    .src_x_out          (mshr_src_x),
    .src_y_out          (mshr_src_y),
    .src_fbits_out      (mshr_src_fbits),
    .sdid_out           (mshr_sdid),
    .lsid_out           (mshr_lsid),
    .miss_lsid_out      (mshr_miss_lsid),
    
    .smc_miss_out       (mshr_smc_miss),
    

    
    .recycled           (mshr_recycled),
    .inv_fwd_pending    (mshr_inv_fwd_pending)

);


l2_pipe2_ctrl ctrl(

    .clk                        (clk),
    .rst_n                      (rst_n),
    
    .csm_en                     (csm_en),
    

    .msg_header_valid_S1        (msg_header_valid),
    .msg_type_S1                (msg_type),
    .msg_length_S1              (msg_length),
    .msg_data_size_S1           (msg_data_size),
    .msg_cache_type_S1          (msg_cache_type),
    .msg_last_subline_S1        (msg_last_subline),
    .msg_mesi_S1                (msg_mesi),
    .mshr_msg_type_S1           (mshr_msg_type),
    .mshr_l2_miss_S1            (mshr_l2_miss),
    .mshr_data_size_S1          (mshr_data_size),
    .mshr_cache_type_S1         (mshr_cache_type),
     
    .mshr_smc_miss_S1           (mshr_smc_miss),
    
    .mshr_state_out_S1          (mshr_state_out),
    .mshr_inv_fwd_pending_S1    (mshr_inv_fwd_pending),
    .addr_S1                    (addr_S1),
    .is_same_address_S1         (is_same_address_S1),
   
    .l2_tag_hit_S2              (l2_tag_hit_S2),
    .l2_way_sel_S2              (l2_way_sel_S2),
    .l2_wb_S2                   (l2_wb_S2),
    .l2_way_state_owner_S2      (l2_way_state_owner_S2),
    .l2_way_state_mesi_S2       (l2_way_state_mesi_S2),
    .l2_way_state_vd_S2         (l2_way_state_vd_S2),
    .l2_way_state_subline_S2    (l2_way_state_subline_S2),
    .l2_way_state_cache_type_S2 (l2_way_state_cache_type_S2),
    .addr_l2_aligned_S2         (addr_l2_aligned_S2),
    .subline_valid_S2           (subline_valid_S2),
    .msg_data_valid_S2          (msg_data_valid),
    
    .broadcast_counter_zero_S2  (broadcast_counter_zero),
    .broadcast_counter_max_S2   (broadcast_counter_max),
    .broadcast_chipid_out_S2    (broadcast_chipid_out),
    .broadcast_x_out_S2         (broadcast_x_out),
    .broadcast_y_out_S2         (broadcast_y_out),
    
    .lsid_S2                    (lsid_S2),
    .addr_S2                    (addr_S2),


    .addr_S3                    (addr_S3),

    .valid_S1                   (valid_S1),  
    .stall_S1                   (stall_S1), 
    .active_S1                  (active_S1),   
    .msg_from_mshr_S1           (msg_from_mshr_S1), 
    .mshr_rd_en_S1              (mshr_rd_en),
    .msg_header_ready_S1        (msg_header_ready),
    .tag_clk_en_S1              (tag_clk_en),
    .tag_rdw_en_S1              (tag_rdw_en),
    .state_rd_en_S1             (state_rd_en),

    .valid_S2                   (valid_S2),    
    .stall_S2                   (stall_S2), 
    .stall_before_S2            (stall_before_S2), 
    .active_S2                  (active_S2), 
    .msg_from_mshr_S2           (msg_from_mshr_S2),
    .msg_type_S2                (msg_type_S2),
    .data_size_S2               (data_size_S2),
    .cache_type_S2              (cache_type_S2),
    .dir_clk_en_S2              (dir_clk_en),
    .dir_rdw_en_S2              (dir_rdw_en),
    .dir_clr_en_S2              (dir_clr_en_S2),
    .data_clk_en_S2             (data_clk_en),
    .data_rdw_en_S2             (data_rdw_en),
    .state_owner_en_S2          (state_owner_en_S2),
    .state_owner_op_S2          (state_owner_op_S2),
    .state_subline_en_S2        (state_subline_en_S2),
    .state_subline_op_S2        (state_subline_op_S2),   
    .state_di_en_S2             (state_di_en_S2),
    .state_vd_en_S2             (state_vd_en_S2),
    .state_vd_S2                (state_vd_S2),
    .state_mesi_en_S2           (state_mesi_en_S2),
    .state_mesi_S2              (state_mesi_S2),
    .state_lru_en_S2            (state_lru_en_S2),
    .state_lru_op_S2            (state_lru_op_S2),
    .state_rb_en_S2             (state_rb_en_S2),
    .l2_load_64B_S2             (l2_load_64B_S2),
    .l2_load_32B_S2             (l2_load_32B_S2),
    .l2_load_data_subline_S2    (l2_load_data_subline_S2),
    .msg_data_ready_S2          (msg_data_ready),
    
    .smc_wr_en_S2               (smc_wr_en),
    .broadcast_counter_op_S2    (broadcast_counter_op),
    .broadcast_counter_op_val_S2(broadcast_counter_op_val),
    

    .valid_S3                   (valid_S3),    
    .stall_S3                   (stall_S3), 
    .active_S3                  (active_S3),   
    .msg_type_S3                (msg_type_S3),
    .mshr_wr_state_en_S3        (mshr_wr_state_en),
    .mshr_wr_data_en_S3         (mshr_wr_data_en),
    .mshr_state_in_S3           (mshr_state_in),
    .mshr_inc_counter_en_S3     (mshr_inc_counter_en),
    .state_wr_en_S3             (state_wr_en)
);


l2_pipe2_dpath dpath(
    .clk                        (clk),
    .rst_n                      (rst_n),
    .mshr_addr_S1               (mshr_addr),
    .mshr_mshrid_S1             (mshr_mshrid),
    .mshr_way_S1                (mshr_way),
    .mshr_src_chipid_S1         (mshr_src_chipid),
    .mshr_src_x_S1              (mshr_src_x),
    .mshr_src_y_S1              (mshr_src_y),
    .mshr_src_fbits_S1          (mshr_src_fbits),
    .mshr_sdid_S1               (mshr_sdid),
    .mshr_lsid_S1               (mshr_lsid),
    .mshr_miss_lsid_S1          (mshr_miss_lsid),
    .msg_addr_S1                (msg_addr),
    .msg_type_S1                (msg_type),
    .msg_subline_id_S1          (msg_subline_id),
    .msg_mshrid_S1              (msg_mshrid),
    .msg_src_chipid_S1          (msg_src_chipid),
    .msg_src_x_S1               (msg_src_x),
    .msg_src_y_S1               (msg_src_y),
    .msg_src_fbits_S1           (msg_src_fbits),
    .msg_sdid_S1                (msg_sdid),
    .msg_lsid_S1                (msg_lsid),
    .valid_S1                   (valid_S1),
    .stall_S1                   (stall_S1),
    .msg_from_mshr_S1           (msg_from_mshr_S1), 

    .state_data_S2              (state_data_out),
    .tag_data_S2                (tag_data_out),
    .msg_data_S2                (msg_data),
    .msg_from_mshr_S2           (msg_from_mshr_S2),
    .msg_type_S2                (msg_type_S2),
    .data_size_S2               (data_size_S2),
    .cache_type_S2              (cache_type_S2),
    .state_owner_en_S2          (state_owner_en_S2),
    .state_owner_op_S2          (state_owner_op_S2), 
    .state_subline_en_S2        (state_subline_en_S2),
    .state_subline_op_S2        (state_subline_op_S2),
    .state_di_en_S2             (state_di_en_S2),
    .state_vd_en_S2             (state_vd_en_S2),
    .state_vd_S2                (state_vd_S2),
    .state_mesi_en_S2           (state_mesi_en_S2),
    .state_mesi_S2              (state_mesi_S2),
    .state_lru_en_S2            (state_lru_en_S2),
    .state_lru_op_S2            (state_lru_op_S2),
    .state_rb_en_S2             (state_rb_en_S2),
    .dir_clr_en_S2              (dir_clr_en_S2),
    .l2_load_64B_S2             (l2_load_64B_S2),
    .l2_load_32B_S2             (l2_load_32B_S2),
    .l2_load_data_subline_S2    (l2_load_data_subline_S2),
    .valid_S2                   (valid_S2),
    .stall_S2                   (stall_S2),
    .stall_before_S2            (stall_before_S2), 


    .valid_S3                   (valid_S3),
    .stall_S3                   (stall_S3),

    .addr_S1                    (addr_S1),
    .mshr_rd_index_S1           (mshr_rd_index_in),
    .tag_addr_S1                (tag_addr),
    .state_rd_addr_S1           (state_rd_addr),
    .tag_data_in_S1             (tag_data_in),  
    .tag_data_mask_in_S1        (tag_data_mask_in),
    .is_same_address_S1         (is_same_address_S1),

    .addr_S2                    (addr_S2),
    .l2_tag_hit_S2              (l2_tag_hit_S2),
    .l2_way_sel_S2              (l2_way_sel_S2),
    .l2_wb_S2                   (l2_wb_S2),
    .l2_way_state_owner_S2      (l2_way_state_owner_S2),
    .l2_way_state_mesi_S2       (l2_way_state_mesi_S2),
    .l2_way_state_vd_S2         (l2_way_state_vd_S2),    
    .l2_way_state_subline_S2    (l2_way_state_subline_S2),
    .l2_way_state_cache_type_S2 (l2_way_state_cache_type_S2),
    .addr_l2_aligned_S2         (addr_l2_aligned_S2),
    .subline_valid_S2           (subline_valid_S2),
    .lsid_S2                    (lsid_S2),
    .dir_addr_S2                (dir_addr),
    .dir_data_in_S2             (dir_data_in),
    .dir_data_mask_in_S2        (dir_data_mask_in),
    .data_addr_S2               (data_addr),
    .data_data_in_S2            (data_data_in),
    .data_data_mask_in_S2       (data_data_mask_in),
    
    .smc_wr_addr_in_S2          (smc_wr_addr_in),
    .smc_data_in_S2             (smc_data_in),
    

    .addr_S3                    (addr_S3),
    .mshr_wr_index_S3           (mshr_wr_index_in),
    .mshr_data_in_S3            (mshr_data_in),
    .mshr_data_mask_in_S3       (mshr_data_mask_in),
    .state_wr_addr_S3           (state_wr_addr),
    .state_data_in_S3           (state_data_in),
    .state_data_mask_in_S3      (state_data_mask_in)
);


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_smc_wrap.v
//  Created On    : 2014-06-19
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for smc in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_smc_wrap(

    input wire clk,
    input wire rst_n,
    input wire pipe_sel,
    input wire rd_en,
    input wire rd_diag_en,
    input wire flush_en,
    input wire [2-1:0] addr_op,
    input wire [16-1:0] rd_addr_in,

    input wire wr_en1,
    input wire [16-1:0] wr_addr_in1,
    input wire [128-1:0] data_in1,
    input wire wr_diag_en1,

    input wire wr_en2,
    input wire [16-1:0] wr_addr_in2,
    input wire [128-1:0] data_in2,
    input wire wr_diag_en2,

    output wire hit,
    output wire [30-1:0] data_out,
    output wire [4-1:0] valid_out,
    output wire [14-1:0] tag_out
);


reg wr_en;
reg [16-1:0] wr_addr_in;
reg [128-1:0] data_in;
reg wr_diag_en;

always @ *
begin
    if (pipe_sel)
    begin
        wr_en = wr_en2;
        wr_addr_in = wr_addr_in2;
        data_in = data_in2;
        wr_diag_en = wr_diag_en2;
    end
    else
    begin
        wr_en = wr_en1;
        wr_addr_in = wr_addr_in1;
        data_in = data_in1;
        wr_diag_en = wr_diag_en1;
    end
end

l2_smc l2_smc(
    .clk            (clk),
    .rst_n          (rst_n),
    .rd_en          (rd_en),
    .wr_en          (wr_en),
    .rd_diag_en     (rd_diag_en),
    .wr_diag_en     (wr_diag_en),
    .flush_en       (flush_en),
    .addr_op        (addr_op),
    .rd_addr_in     (rd_addr_in),
    .wr_addr_in     (wr_addr_in),
    .data_in        (data_in),
    .hit            (hit),
    .data_out       (data_out),
    .valid_out      (valid_out),
    .tag_out        (tag_out)
);


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_state_wrap.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for state array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_state_wrap(


    input wire clk,
    input wire rst_n,
    input wire pipe_rd_sel,
    input wire pipe_wr_sel,
    input wire pdout_en,
    input wire deepsleep,

    input wire rd_en1,
    input wire wr_en1,
    input wire [9-1:0] rd_addr1,
    input wire [9-1:0] wr_addr1,
    input wire [15*4+2+4-1:0] data_in1,
    input wire [15*4+2+4-1:0] data_mask_in1,

    input wire rd_en2,
    input wire wr_en2,
    input wire [9-1:0] rd_addr2,
    input wire [9-1:0] wr_addr2,
    input wire [15*4+2+4-1:0] data_in2,
    input wire [15*4+2+4-1:0] data_mask_in2,

    output wire [15*4+2+4-1:0] data_out,
    output wire [15*4+2+4-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);

reg rd_en;
reg wr_en;
reg [9-1:0] rd_addr;
reg [9-1:0] wr_addr;
reg [15*4+2+4-1:0] data_in;
reg [15*4+2+4-1:0] data_mask_in;

always @ *
begin
    if (pipe_rd_sel)
    begin
        rd_en = rd_en2;
        rd_addr = rd_addr2;
    end
    else
    begin
        rd_en = rd_en1;
        rd_addr = rd_addr1;
    end
end

always @ *
begin
    if (pipe_wr_sel)
    begin
        wr_en = wr_en2;
        wr_addr = wr_addr2;
        data_in = data_in2;
        data_mask_in = data_mask_in2;
     end
    else
    begin
        wr_en = wr_en1;
        wr_addr = wr_addr1;
        data_in = data_in1;
        data_mask_in = data_mask_in1;
    end
end


l2_state l2_state(

    .clk            (clk),
    .rst_n          (rst_n),
    .rd_en          (rd_en),
    .wr_en          (wr_en),
    .pdout_en       (pdout_en),
    .deepsleep      (deepsleep),
    .rd_addr        (rd_addr),
    .wr_addr        (wr_addr),
    .data_in        (data_in),
    .data_mask_in   (data_mask_in),
    .data_out       (data_out),
    .pdata_out      (pdata_out),

    // sram interfaces
    .srams_rtap_data (srams_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_tag.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The tag array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_tag(

    input wire clk,
    input wire rst_n,
    input wire clk_en,

    //0 for write, 1 for read
    input wire rdw_en,
    input wire pdout_en,
    input wire deepsleep,

    input wire [9-1:0] addr,
    input wire [100-1:0] data_in,
    input wire [100-1:0] data_mask_in,

    output wire [100-1:0] data_out,
    output wire [100-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);

/*
localparam reset = 2'd0;
localparam init  = 2'd1;
localparam done  = 2'd2;

reg [1:0] init_state_f;
reg [1:0] init_state_next;
reg [`L2_TAG_INDEX_WIDTH-1:0] init_counter_f;
reg [`L2_TAG_INDEX_WIDTH-1:0] init_counter_next;

reg [`L2_TAG_INDEX_WIDTH-1:0] addr_real;
reg rdw_en_real;
reg clk_en_real;
reg [`L2_TAG_ARRAY_WIDTH-1:0] data_in_real;
reg [`L2_TAG_ARRAY_WIDTH-1:0] data_mask_in_real;

always @ *
begin
    if (!rst_n)
    begin
        init_state_next = reset;
    end
    else
    begin
        if (init_state_f == reset)
        begin
            init_state_next = init;
        end
        else if ((init_state_f == init) && (init_counter_f == {`L2_TAG_INDEX_WIDTH{1'b1}}))
        begin
            init_state_next = done;
        end
        else
        begin
            init_state_next = init_state_f;
        end
    end
end

always @ (posedge clk)
begin
    init_state_f <= init_state_next;
end

always @ *
begin
    if ((init_state_f == reset) || (init_state_f == done))
    begin
        init_counter_next = {`L2_TAG_INDEX_WIDTH{1'b0}};
    end
    else
    begin
        init_counter_next = init_counter_f + 1;
    end
end


always @ (posedge clk)
begin
    init_counter_f <= init_counter_next;
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    init_done = (init_state_f == done);
end


always @ *
begin
    if (init_state_f == init)
    begin
        clk_en_real = 1'b1;
        rdw_en_real = 1'b0;
        addr_real = init_counter_f;
        data_in_real = {`L2_TAG_ARRAY_WIDTH{1'b0}};
        data_mask_in_real = {`L2_TAG_ARRAY_WIDTH{1'b1}};
    end
    else
    begin
        clk_en_real = clk_en;
        rdw_en_real = rdw_en;
        addr_real = addr;
        data_in_real = data_in;
        data_mask_in_real = data_mask_in;
    end
end
*/


// sram_1rw_256x104 l2_tag_array(
sram_l2_tag l2_tag_array(
    .MEMCLK     (clk),
    .RESET_N(rst_n),
    .CE         (clk_en),

    .A          (addr),
    .DIN        (data_in),
    .RDWEN      (rdw_en),
    .BW         (data_mask_in),
    .DOUT       (data_out),
    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(8'd16)
);

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_tag_wrap.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for tag array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_tag_wrap(

    input wire clk,
    input wire rst_n,
    input wire clk_en1,
    input wire clk_en2,
    input wire rdw_en1,
    input wire rdw_en2,
    input wire pdout_en,
    input wire deepsleep,
    input wire pipe_sel,

    input wire [9-1:0] addr1,
    input wire [100-1:0] data_in1,
    input wire [100-1:0] data_mask_in1,


    input wire [9-1:0] addr2,
    input wire [100-1:0] data_in2,
    input wire [100-1:0] data_mask_in2,

    output wire [100-1:0] data_out,
    output wire [100-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);

reg clk_en;
reg rdw_en;
reg [9-1:0] addr;
reg [100-1:0] data_in;
reg [100-1:0] data_mask_in;

always @ *
begin
    if (pipe_sel)
    begin
        clk_en = clk_en2;
        rdw_en = rdw_en2;
        addr = addr2;
        data_in = data_in2;
        data_mask_in = data_mask_in2;
    end
    else
    begin
        clk_en = clk_en1;
        rdw_en = rdw_en1;
        addr = addr1;
        data_in = data_in1;
        data_mask_in = data_mask_in1;
    end
end

l2_tag l2_tag(

    .clk            (clk),
    .rst_n          (rst_n),
    .clk_en         (clk_en),
    .rdw_en         (rdw_en),
    .pdout_en       (pdout_en),
    .deepsleep      (deepsleep),
    .addr           (addr),
    .data_in        (data_in),
    .data_mask_in   (data_mask_in),
    .data_out       (data_out),
    .pdata_out      (pdata_out),

    // sram interfaces
    .srams_rtap_data (srams_rtap_data),
    .rtap_srams_bist_command (rtap_srams_bist_command),
    .rtap_srams_bist_data (rtap_srams_bist_data)
);



endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_data_ecc.v
//  Created On    : 2014-06-02
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : L2 cache array error detection and correction
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================









































































































































































































































































































































































































































































































































































































module l2_data_ecc ( 
   input  [64-1:0]      din,
   input  [8-1:0]	 parity,

   output [64-1:0]      dout,
   output                                    corr_error,
   output                                    uncorr_error
);

   
wire [64-1:0] 	err_bit_pos;
wire [8-2:0]    cflag;
wire 	                                pflag;
assign cflag[0] = parity[0]  ^ din[0] ^ din[1] ^ din[3] ^ din[4] ^ din[6] ^ din[8] ^ din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^ din[21] ^ din[23] ^ din[25] ^ din[26] ^ din[28] ^ din[30] ^ din[32] ^ din[34] ^ din[36] ^ din[38] ^ din[40] ^ din[42] ^ din[44] ^ din[46] ^ din[48] ^ din[50] ^ din[52] ^ din[54] ^ din[56] ^ din[57] ^ din[59] ^ din[61] ^ din[63] ;

assign cflag[1] = parity[1]  ^ din[0] ^ din[2] ^ din[3] ^ din[5] ^ din[6] ^ din[9] ^ din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^ din[21] ^ din[24] ^ din[25] ^ din[27] ^ din[28] ^ din[31] ^ din[32] ^ din[35] ^ din[36] ^ din[39] ^ din[40] ^ din[43] ^ din[44] ^ din[47] ^ din[48] ^ din[51] ^ din[52] ^ din[55] ^ din[56] ^ din[58] ^ din[59] ^ din[62] ^ din[63] ;

assign cflag[2] = parity[2]  ^ din[1] ^ din[2] ^ din[3] ^ din[7] ^ din[8] ^ din[9] ^ din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[29] ^ din[30] ^ din[31] ^ din[32] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ^ din[60] ^ din[61] ^ din[62] ^ din[63] ;

assign cflag[3] = parity[3]  ^ din[4] ^ din[5] ^ din[6] ^ din[7] ^ din[8] ^ din[9] ^ din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[33] ^ din[34] ^ din[35] ^ din[36] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign cflag[4] = parity[4]  ^ din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[41] ^ din[42] ^ din[43] ^ din[44] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign cflag[5] = parity[5]  ^ din[26] ^ din[27] ^ din[28] ^ din[29] ^ din[30] ^ din[31] ^ din[32] ^ din[33] ^ din[34] ^ din[35] ^ din[36] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[41] ^ din[42] ^ din[43] ^ din[44] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign cflag[6] = parity[6]  ^ din[57] ^ din[58] ^ din[59] ^ din[60] ^ din[61] ^ din[62] ^ din[63] ;

assign pflag = cflag[0]
 ^ parity[1]  ^ parity[2]  ^ parity[3]  ^ parity[4]  ^ parity[5]  ^ parity[6] 
^ din[2] ^ din[5] ^ din[7] ^ din[9] ^ din[12] ^ din[14] ^ din[16] ^ din[18] ^ din[20] ^ din[22] ^ din[24] ^ din[27] ^ din[29] ^ din[31] ^ din[33] ^ din[35] ^ din[37] ^ din[39] ^ din[41] ^ din[43] ^ din[45] ^ din[47] ^ din[49] ^ din[51] ^ din[53] ^ din[55] ^ din[58] ^ din[60] ^ din[62] ;

assign err_bit_pos[0] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[1] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[2] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[3] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[4] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[5] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[6] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[7] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[8] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[9] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[10] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[11] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[12] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[13] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[14] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[15] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[16] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[17] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[18] =  (~cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[19] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[20] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[21] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[22] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[23] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[24] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[25] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (~cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[26] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[27] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[28] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[29] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[30] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[31] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[32] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[33] =  (~cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[34] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[35] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[36] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[37] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[38] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[39] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[40] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (~cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[41] =  (~cflag[0]) & (~cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[42] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[43] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[44] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[45] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[46] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[47] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[48] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[49] =  (~cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[50] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[51] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[52] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[53] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[54] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[55] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[56] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (cflag[3]) & (cflag[4]) & (cflag[5]) & (~cflag[6]) ;

assign err_bit_pos[57] =  (cflag[0]) & (~cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[58] =  (~cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[59] =  (cflag[0]) & (cflag[1]) & (~cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[60] =  (~cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[61] =  (cflag[0]) & (~cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[62] =  (~cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;

assign err_bit_pos[63] =  (cflag[0]) & (cflag[1]) & (cflag[2]) & (~cflag[3]) & (~cflag[4]) & (~cflag[5]) & (cflag[6]) ;





//correct the error bit, it can only correct one error bit.

assign dout = din ^ err_bit_pos;

assign corr_error = pflag;

assign uncorr_error = |(cflag[8-2:0]) & ~pflag;


endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_data_pgen.v
//  Created On    : 2014-06-02
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : L2 cache array parity bits generation
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================









































































































































































































































































































































































































































































































































































































module l2_data_pgen ( 
   input    [64-1:0]   din,

   output   [8-1:0] parity
);


//generate parity bits based on the hamming codes
assign parity[0] =  din[0] ^ din[1] ^ din[3] ^ din[4] ^ din[6] ^ din[8] ^ din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^ din[21] ^ din[23] ^ din[25] ^ din[26] ^ din[28] ^ din[30] ^ din[32] ^ din[34] ^ din[36] ^ din[38] ^ din[40] ^ din[42] ^ din[44] ^ din[46] ^ din[48] ^ din[50] ^ din[52] ^ din[54] ^ din[56] ^ din[57] ^ din[59] ^ din[61] ^ din[63] ;

assign parity[1] =  din[0] ^ din[2] ^ din[3] ^ din[5] ^ din[6] ^ din[9] ^ din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^ din[21] ^ din[24] ^ din[25] ^ din[27] ^ din[28] ^ din[31] ^ din[32] ^ din[35] ^ din[36] ^ din[39] ^ din[40] ^ din[43] ^ din[44] ^ din[47] ^ din[48] ^ din[51] ^ din[52] ^ din[55] ^ din[56] ^ din[58] ^ din[59] ^ din[62] ^ din[63] ;

assign parity[2] =  din[1] ^ din[2] ^ din[3] ^ din[7] ^ din[8] ^ din[9] ^ din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[29] ^ din[30] ^ din[31] ^ din[32] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ^ din[60] ^ din[61] ^ din[62] ^ din[63] ;

assign parity[3] =  din[4] ^ din[5] ^ din[6] ^ din[7] ^ din[8] ^ din[9] ^ din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[33] ^ din[34] ^ din[35] ^ din[36] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign parity[4] =  din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^ din[23] ^ din[24] ^ din[25] ^ din[41] ^ din[42] ^ din[43] ^ din[44] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign parity[5] =  din[26] ^ din[27] ^ din[28] ^ din[29] ^ din[30] ^ din[31] ^ din[32] ^ din[33] ^ din[34] ^ din[35] ^ din[36] ^ din[37] ^ din[38] ^ din[39] ^ din[40] ^ din[41] ^ din[42] ^ din[43] ^ din[44] ^ din[45] ^ din[46] ^ din[47] ^ din[48] ^ din[49] ^ din[50] ^ din[51] ^ din[52] ^ din[53] ^ din[54] ^ din[55] ^ din[56] ;

assign parity[6] =  din[57] ^ din[58] ^ din[59] ^ din[60] ^ din[61] ^ din[62] ^ din[63] ;

assign parity[7] =  din[0] ^ din[1] ^ din[2] ^ din[4] ^ din[5] ^ din[7] ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^ din[17] ^ din[18] ^ din[21] ^ din[23] ^ din[24] ^ din[26] ^ din[27] ^ din[29] ^ din[32] ^ din[33] ^ din[36] ^ din[38] ^ din[39] ^ din[41] ^ din[44] ^ din[46] ^ din[47] ^ din[50] ^ din[51] ^ din[53] ^ din[56] ^ din[57] ^ din[58] ^ din[60] ^ din[63] ;




endmodule 


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_mshr.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The MSHRs in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_mshr(

    input wire clk,
    input wire rst_n,

    //Read enable
    input wire rd_en,

    //cam enable
    input wire cam_en,

    //Write state enable
    input wire wr_state_en,


    //Write data enable
    input wire wr_data_en,

    //Reading out a pending entry
    input wire pending_ready,

    //increment counter which is used as a temporary place to count invalidated sharers
    input wire inc_counter_en,


    //Write state
    input wire [2-1:0] state_in,

    //Write data
    input wire [120+2-1:0] data_in,
    input wire [120+2-1:0] data_mask_in,

    //Read index
    input wire [3-1:0] rd_index_in,

    //Inv counter index
    input wire [3-1:0] inv_counter_rd_index_in,

    //Write/increment counter index
    input wire [3-1:0] wr_index_in,

    //CAM address
    input wire [9-1:0] addr_in,



    output reg hit,
    output reg [3-1:0] hit_index,
    
    //Read or pending output
    output reg [2-1:0] state_out,
    output reg [120+2-1:0] data_out,
    output reg [6-1:0] inv_counter_out,

    //Status output
    output reg [3:0] empty_slots,
    output reg pending,
    output reg [3-1:0] pending_index,
    output reg [3-1:0] empty_index
);



reg [2-1:0] state_mem_f [8-1:0];
reg [120+2-1:0] data_mem_f [8-1:0];
reg [6-1:0] counter_mem_f [8-1:0];
reg [3-1:0] wbg_counter_f;
reg [3-1:0] wbg_counter_next;

always @ *
begin
    empty_slots = 0;
    if (state_mem_f[0] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[1] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[2] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[3] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[4] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[5] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[6] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[7] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end

end

always @ *
begin
    if (state_mem_f[0] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd0;
    end
    else if (state_mem_f[1] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd1;
    end
    else if (state_mem_f[2] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd2;
    end
    else if (state_mem_f[3] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd3;
    end
    else if (state_mem_f[4] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd4;
    end
    else if (state_mem_f[5] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd5;
    end
    else if (state_mem_f[6] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd6;
    end
    else if (state_mem_f[7] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd7;
    end
    else
    begin
        pending = 1'b0;
        pending_index = 3'd0;
    end

end

always @ *
begin
    if (state_mem_f[0] == 2'd0)
    begin
        empty_index = 3'd0;
    end
    else if (state_mem_f[1] == 2'd0)
    begin
        empty_index = 3'd1;
    end
    else if (state_mem_f[2] == 2'd0)
    begin
        empty_index = 3'd2;
    end
    else if (state_mem_f[3] == 2'd0)
    begin
        empty_index = 3'd3;
    end
    else if (state_mem_f[4] == 2'd0)
    begin
        empty_index = 3'd4;
    end
    else if (state_mem_f[5] == 2'd0)
    begin
        empty_index = 3'd5;
    end
    else if (state_mem_f[6] == 2'd0)
    begin
        empty_index = 3'd6;
    end
    else if (state_mem_f[7] == 2'd0)
    begin
        empty_index = 3'd7;
    end
    else
    begin
        empty_index = 3'd0;
    end

end

always @ *
begin
    if (rd_en)
    begin
        state_out = state_mem_f[rd_index_in];
        data_out = data_mem_f[rd_index_in];
    end
    else if (cam_en && hit)
    begin
        state_out = state_mem_f[hit_index];
        data_out = data_mem_f[hit_index];
    end
    else if (pending)
    begin
        state_out = state_mem_f[pending_index];
        data_out = data_mem_f[pending_index];
    end
    else
    begin
        state_out = 2'd0;
        data_out = 0;
    end
end

always @ *
begin
    inv_counter_out = counter_mem_f[inv_counter_rd_index_in];
end

always @ *
begin
    if(cam_en)
    begin
        if ((data_mem_f[0][6+9-1:6] == addr_in) && (state_mem_f[0] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd0;
        end
        else if ((data_mem_f[1][6+9-1:6] == addr_in) && (state_mem_f[1] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd1;
        end
        else if ((data_mem_f[2][6+9-1:6] == addr_in) && (state_mem_f[2] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd2;
        end
        else if ((data_mem_f[3][6+9-1:6] == addr_in) && (state_mem_f[3] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd3;
        end
        else if ((data_mem_f[4][6+9-1:6] == addr_in) && (state_mem_f[4] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd4;
        end
        else if ((data_mem_f[5][6+9-1:6] == addr_in) && (state_mem_f[5] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd5;
        end
        else if ((data_mem_f[6][6+9-1:6] == addr_in) && (state_mem_f[6] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd6;
        end
        else if ((data_mem_f[7][6+9-1:6] == addr_in) && (state_mem_f[7] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd7;
        end
        else
        begin
            hit = 1'b0;
            hit_index = 3'd0;
        end
    end
    else
    begin
        hit = 1'b0;
        hit_index = 3'd0;
    end

end




always @ (posedge clk)
begin
    if (!rst_n)
    begin
        state_mem_f[0] <= 2'd0;
        state_mem_f[1] <= 2'd0;
        state_mem_f[2] <= 2'd0;
        state_mem_f[3] <= 2'd0;
        state_mem_f[4] <= 2'd0;
        state_mem_f[5] <= 2'd0;
        state_mem_f[6] <= 2'd0;
        state_mem_f[7] <= 2'd0;

    end
    else if (wr_state_en)
    begin
        state_mem_f[wr_index_in] <= state_in;
        if (pending && pending_ready && (pending_index != wr_index_in))
        begin
            //SMC miss entries are locked in the mshr
            if (data_mem_f[pending_index][117+2])
            begin
                state_mem_f[pending_index] <= 2'd1;
            end
            else
            begin
                state_mem_f[pending_index] <= 2'd0;
            end
        end
    end
    else if (pending && pending_ready)
    begin
        if (data_mem_f[pending_index][117+2])
        begin
            state_mem_f[pending_index] <= 2'd1;
        end
        else
        begin
            state_mem_f[pending_index] <= 2'd0;
        end
    end
    else if (cam_en && hit && (data_mem_f[hit_index][59+2:52+2] == 8'd13))
    begin
        state_mem_f[hit_index] <= 2'd2;
    end
    //Clear entries with WB guard requests if they occupy more entries than the threshold
    else if (wbg_counter_f > 4)
    begin
        if ((state_mem_f[0] == 2'd1) && (data_mem_f[0][59+2:52+2] == 8'd13))
        begin
            state_mem_f[0] <= 2'd2;
        end
        if ((state_mem_f[1] == 2'd1) && (data_mem_f[1][59+2:52+2] == 8'd13))
        begin
            state_mem_f[1] <= 2'd2;
        end
        if ((state_mem_f[2] == 2'd1) && (data_mem_f[2][59+2:52+2] == 8'd13))
        begin
            state_mem_f[2] <= 2'd2;
        end
        if ((state_mem_f[3] == 2'd1) && (data_mem_f[3][59+2:52+2] == 8'd13))
        begin
            state_mem_f[3] <= 2'd2;
        end
        if ((state_mem_f[4] == 2'd1) && (data_mem_f[4][59+2:52+2] == 8'd13))
        begin
            state_mem_f[4] <= 2'd2;
        end
        if ((state_mem_f[5] == 2'd1) && (data_mem_f[5][59+2:52+2] == 8'd13))
        begin
            state_mem_f[5] <= 2'd2;
        end
        if ((state_mem_f[6] == 2'd1) && (data_mem_f[6][59+2:52+2] == 8'd13))
        begin
            state_mem_f[6] <= 2'd2;
        end
        if ((state_mem_f[7] == 2'd1) && (data_mem_f[7][59+2:52+2] == 8'd13))
        begin
            state_mem_f[7] <= 2'd2;
        end

    end
end



always @ *
begin
    if(wr_state_en && wr_data_en && (state_in == 2'd1) 
    && (data_in[59+2:52+2] == 8'd13) && (data_mask_in[59+2:52+2] == {8{1'b1}}))
    begin
        wbg_counter_next = wbg_counter_f + 1;
    end
    else if ((~wr_state_en) && (~(pending && pending_ready)) 
          && (cam_en && hit && (data_mem_f[hit_index][59+2:52+2] == 8'd13)))
    begin
        wbg_counter_next = wbg_counter_f - 1;
    end
    else
    begin
        wbg_counter_next = wbg_counter_f;
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        wbg_counter_f <= 0;
    end
    else   
    begin
        wbg_counter_f <= wbg_counter_next;
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        counter_mem_f[0] <= {6{1'b0}};
        counter_mem_f[1] <= {6{1'b0}};
        counter_mem_f[2] <= {6{1'b0}};
        counter_mem_f[3] <= {6{1'b0}};
        counter_mem_f[4] <= {6{1'b0}};
        counter_mem_f[5] <= {6{1'b0}};
        counter_mem_f[6] <= {6{1'b0}};
        counter_mem_f[7] <= {6{1'b0}};

    end
    else if (pending && pending_ready)
    begin
        counter_mem_f[pending_index] <= {6{1'b0}};
        if (inc_counter_en && (pending_index != wr_index_in))
        begin
            counter_mem_f[wr_index_in] <= counter_mem_f[wr_index_in] + 1;
        end
    end
    else if (inc_counter_en)
    begin
        counter_mem_f[wr_index_in] <= counter_mem_f[wr_index_in] + 1;
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin
        data_mem_f[0] <= {120+2{1'b0}};
        data_mem_f[1] <= {120+2{1'b0}};
        data_mem_f[2] <= {120+2{1'b0}};
        data_mem_f[3] <= {120+2{1'b0}};
        data_mem_f[4] <= {120+2{1'b0}};
        data_mem_f[5] <= {120+2{1'b0}};
        data_mem_f[6] <= {120+2{1'b0}};
        data_mem_f[7] <= {120+2{1'b0}};

    end
    else if (wr_data_en)
    begin
        data_mem_f[wr_index_in] <= (data_mem_f[wr_index_in] & (~data_mask_in))
                                 | (data_in & data_mask_in);
    end
    else
    begin
        data_mem_f[wr_index_in] <= data_mem_f[wr_index_in];
    end
end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_mshr_wrap.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The wrap module for MSHRs in the L2 cache
//
//
//==================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_mshr_wrap(

    input wire clk,
    input wire rst_n,


 // L2_CAM_MSHR
    input wire pipe_wr_sel,



 // L2_CAM_MSHR
    input wire cam_en1,
    input wire wr_state_en1,
    input wire wr_data_en1,
    input wire pending_ready1,
    input wire [2-1:0] state_in1,
    input wire [120+2-1:0] data_in1,
    input wire [120+2-1:0] data_mask_in1,


 // L2_CAM_MSHR
    input wire [3-1:0] inv_counter_rd_index_in1,
    input wire [3-1:0] wr_index_in1,
    input wire [9-1:0] addr_in1,




 // L2_CAM_MSHR
    input wire wr_state_en2,
    input wire wr_data_en2,


 // L2_CAM_MSHR
    input wire inc_counter_en2,
    input wire [2-1:0] state_in2,
    input wire [120+2-1:0] data_in2,
    input wire [120+2-1:0] data_mask_in2,
    input wire [3-1:0] rd_index_in2,
    input wire [3-1:0] wr_index_in2,


 // L2_CAM_MSHR












    output reg hit,
    output reg [3-1:0] hit_index,
    output reg [2-1:0] rd_state_out,
    output reg [120+2-1:0] rd_data_out,
    // output wire [`L2_MSHR_STATE_BITS-1:0] cam_state_out,
    output reg [120+2-1:0] cam_data_out,
    output reg [120+2-1:0] pending_data_out,

    output reg [6-1:0] inv_counter_out,
    output reg [3:0] empty_slots,
    output reg pending,
    output reg [3-1:0] pending_index,
    output reg [3-1:0] empty_index
 // L2_CAM_MSHR
);




 // L2_CAM_MSHR
reg wr_state_en;
reg wr_data_en;


 // L2_CAM_MSHR
reg [2-1:0] state_in;
reg [120+2-1:0] data_in;
reg [120+2-1:0] data_mask_in;


 // L2_CAM_MSHR
reg [3-1:0] wr_index_in;


 // L2_CAM_MSHR






















 // L2_CAM_MSHR

always @ *
begin
    if (pipe_wr_sel)
    begin
        wr_state_en = wr_state_en2;
        wr_data_en = wr_data_en2;
        state_in = state_in2;
        data_in = data_in2;
        data_mask_in = data_mask_in2;
        wr_index_in = wr_index_in2;
    end
    else
    begin
        wr_state_en = wr_state_en1;
        wr_data_en = wr_data_en1;
        state_in = state_in1;
        data_in = data_in1;
        data_mask_in = data_mask_in1;
        wr_index_in = wr_index_in1;
    end
end


































reg [2-1:0] state_mem_f [8-1:0];
reg [120+2-1:0] data_mem_f [8-1:0];
reg [6-1:0] counter_mem_f [8-1:0];
reg [3-1:0] wbg_counter_f;
reg [3-1:0] wbg_counter_next;

always @ *
begin
    empty_slots = 0;
    if (state_mem_f[0] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[1] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[2] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[3] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[4] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[5] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[6] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end
    if (state_mem_f[7] == 2'd0)
    begin
        empty_slots = empty_slots + 1;
    end

end

always @ *
begin
    if (state_mem_f[0] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd0;
    end
    else if (state_mem_f[1] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd1;
    end
    else if (state_mem_f[2] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd2;
    end
    else if (state_mem_f[3] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd3;
    end
    else if (state_mem_f[4] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd4;
    end
    else if (state_mem_f[5] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd5;
    end
    else if (state_mem_f[6] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd6;
    end
    else if (state_mem_f[7] == 2'd2)
    begin
        pending = 1'b1;
        pending_index = 3'd7;
    end
    else
    begin
        pending = 1'b0;
        pending_index = 3'd0;
    end

end

always @ *
begin
    if (state_mem_f[0] == 2'd0)
    begin
        empty_index = 3'd0;
    end
    else if (state_mem_f[1] == 2'd0)
    begin
        empty_index = 3'd1;
    end
    else if (state_mem_f[2] == 2'd0)
    begin
        empty_index = 3'd2;
    end
    else if (state_mem_f[3] == 2'd0)
    begin
        empty_index = 3'd3;
    end
    else if (state_mem_f[4] == 2'd0)
    begin
        empty_index = 3'd4;
    end
    else if (state_mem_f[5] == 2'd0)
    begin
        empty_index = 3'd5;
    end
    else if (state_mem_f[6] == 2'd0)
    begin
        empty_index = 3'd6;
    end
    else if (state_mem_f[7] == 2'd0)
    begin
        empty_index = 3'd7;
    end
    else
    begin
        empty_index = 3'd0;
    end

end

always @ *
begin
    // if (rd_en2)
    // begin
    rd_state_out = state_mem_f[rd_index_in2];
    rd_data_out = data_mem_f[rd_index_in2];
    // end
    // else 
    // if (cam_en1 && hit)
    // begin
    // cam_state_out = state_mem_f[hit_index];
    cam_data_out = data_mem_f[hit_index];
    // end
    // else if (pending)
    // begin
    // pending_state_out = state_mem_f[pending_index];
    pending_data_out = data_mem_f[pending_index];
    // end
    // else
    // begin
    //     state_out = `L2_MSHR_STATE_INVAL;
    //     data_out = 0;
    // end
end

always @ *
begin
    inv_counter_out = counter_mem_f[inv_counter_rd_index_in1];
end

always @ *
begin
    if(cam_en1)
    begin
        if ((data_mem_f[0][6+9-1:6] == addr_in1) && (state_mem_f[0] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd0;
        end
        else if ((data_mem_f[1][6+9-1:6] == addr_in1) && (state_mem_f[1] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd1;
        end
        else if ((data_mem_f[2][6+9-1:6] == addr_in1) && (state_mem_f[2] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd2;
        end
        else if ((data_mem_f[3][6+9-1:6] == addr_in1) && (state_mem_f[3] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd3;
        end
        else if ((data_mem_f[4][6+9-1:6] == addr_in1) && (state_mem_f[4] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd4;
        end
        else if ((data_mem_f[5][6+9-1:6] == addr_in1) && (state_mem_f[5] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd5;
        end
        else if ((data_mem_f[6][6+9-1:6] == addr_in1) && (state_mem_f[6] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd6;
        end
        else if ((data_mem_f[7][6+9-1:6] == addr_in1) && (state_mem_f[7] != 2'd0))
        begin
            hit = 1'b1;
            hit_index = 3'd7;
        end
        else
        begin
            hit = 1'b0;
            hit_index = 3'd0;
        end
    end
    else
    begin
        hit = 1'b0;
        hit_index = 3'd0;
    end

end




always @ (posedge clk)
begin
    if (!rst_n)
    begin
        state_mem_f[0] <= 2'd0;
        state_mem_f[1] <= 2'd0;
        state_mem_f[2] <= 2'd0;
        state_mem_f[3] <= 2'd0;
        state_mem_f[4] <= 2'd0;
        state_mem_f[5] <= 2'd0;
        state_mem_f[6] <= 2'd0;
        state_mem_f[7] <= 2'd0;

    end
    else if (wr_state_en)
    begin
        state_mem_f[wr_index_in] <= state_in;
        if (pending && pending_ready1 && (pending_index != wr_index_in))
        begin
            //SMC miss entries are locked in the mshr
            if (data_mem_f[pending_index][117+2])
            begin
                state_mem_f[pending_index] <= 2'd1;
            end
            else
            begin
                state_mem_f[pending_index] <= 2'd0;
            end
        end
    end
    else if (pending && pending_ready1)
    begin
        if (data_mem_f[pending_index][117+2])
        begin
            state_mem_f[pending_index] <= 2'd1;
        end
        else
        begin
            state_mem_f[pending_index] <= 2'd0;
        end
    end
    else if (cam_en1 && hit && (data_mem_f[hit_index][59+2:52+2] == 8'd13))
    begin
        state_mem_f[hit_index] <= 2'd2;
    end
    //Clear entries with WB guard requests if they occupy more entries than the threshold
    else if (wbg_counter_f > 4)
    begin
        if ((state_mem_f[0] == 2'd1) && (data_mem_f[0][59+2:52+2] == 8'd13))
        begin
            state_mem_f[0] <= 2'd2;
        end
        if ((state_mem_f[1] == 2'd1) && (data_mem_f[1][59+2:52+2] == 8'd13))
        begin
            state_mem_f[1] <= 2'd2;
        end
        if ((state_mem_f[2] == 2'd1) && (data_mem_f[2][59+2:52+2] == 8'd13))
        begin
            state_mem_f[2] <= 2'd2;
        end
        if ((state_mem_f[3] == 2'd1) && (data_mem_f[3][59+2:52+2] == 8'd13))
        begin
            state_mem_f[3] <= 2'd2;
        end
        if ((state_mem_f[4] == 2'd1) && (data_mem_f[4][59+2:52+2] == 8'd13))
        begin
            state_mem_f[4] <= 2'd2;
        end
        if ((state_mem_f[5] == 2'd1) && (data_mem_f[5][59+2:52+2] == 8'd13))
        begin
            state_mem_f[5] <= 2'd2;
        end
        if ((state_mem_f[6] == 2'd1) && (data_mem_f[6][59+2:52+2] == 8'd13))
        begin
            state_mem_f[6] <= 2'd2;
        end
        if ((state_mem_f[7] == 2'd1) && (data_mem_f[7][59+2:52+2] == 8'd13))
        begin
            state_mem_f[7] <= 2'd2;
        end

    end
end



always @ *
begin
    if(wr_state_en && wr_data_en && (state_in == 2'd1) 
    && (data_in[59+2:52+2] == 8'd13) && (data_mask_in[59+2:52+2] == {8{1'b1}}))
    begin
        wbg_counter_next = wbg_counter_f + 1;
    end
    else if ((~wr_state_en) && (~(pending && pending_ready1)) 
          && (cam_en1 && hit && (data_mem_f[hit_index][59+2:52+2] == 8'd13)))
    begin
        wbg_counter_next = wbg_counter_f - 1;
    end
    else
    begin
        wbg_counter_next = wbg_counter_f;
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        wbg_counter_f <= 0;
    end
    else   
    begin
        wbg_counter_f <= wbg_counter_next;
    end
end

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        counter_mem_f[0] <= {6{1'b0}};
        counter_mem_f[1] <= {6{1'b0}};
        counter_mem_f[2] <= {6{1'b0}};
        counter_mem_f[3] <= {6{1'b0}};
        counter_mem_f[4] <= {6{1'b0}};
        counter_mem_f[5] <= {6{1'b0}};
        counter_mem_f[6] <= {6{1'b0}};
        counter_mem_f[7] <= {6{1'b0}};

    end
    else if (pending && pending_ready1)
    begin
        counter_mem_f[pending_index] <= {6{1'b0}};
        if (inc_counter_en2 && (pending_index != wr_index_in))
        begin
            counter_mem_f[wr_index_in] <= counter_mem_f[wr_index_in] + 1;
        end
    end
    else if (inc_counter_en2)
    begin
        counter_mem_f[wr_index_in] <= counter_mem_f[wr_index_in] + 1;
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin
        data_mem_f[0] <= {120+2{1'b0}};
        data_mem_f[1] <= {120+2{1'b0}};
        data_mem_f[2] <= {120+2{1'b0}};
        data_mem_f[3] <= {120+2{1'b0}};
        data_mem_f[4] <= {120+2{1'b0}};
        data_mem_f[5] <= {120+2{1'b0}};
        data_mem_f[6] <= {120+2{1'b0}};
        data_mem_f[7] <= {120+2{1'b0}};

    end
    else if (wr_data_en)
    begin
        data_mem_f[wr_index_in] <= (data_mem_f[wr_index_in] & (~data_mask_in))
                                 | (data_in & data_mask_in);
    end
    else
    begin
        data_mem_f[wr_index_in] <= data_mem_f[wr_index_in];
    end
end
 // L2_CAM_MSHR

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe1_buf_in.v
//  Created On    : 2014-04-06
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Input buffer for pipeline1
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe1_buf_in(

    input wire clk,
    input wire rst_n,

    input wire valid_in,
    input wire [64-1:0] data_in,
    output reg ready_in,

   
    output reg msg_header_valid_out,
    output reg [192-1:0] msg_header_out,
    input wire msg_header_ready_out,


    output reg msg_data_valid_out,
    output reg [64-1:0] msg_data_out,
    input wire msg_data_ready_out
);


localparam msg_data_state0 = 2'd0;
localparam msg_data_state1 = 2'd1;
localparam msg_data_state2 = 2'd2;

localparam msg_state_header0 = 3'd0;
localparam msg_state_header1 = 3'd1;
localparam msg_state_header2 = 3'd2;
localparam msg_state_data0 = 3'd3;
localparam msg_state_data1 = 3'd4;

reg [2:0] msg_state_f;
reg [2:0] msg_state_next;
reg real_ready_in;

reg [1:0] msg_data_state_f;
reg [1:0] msg_data_state_next;

//stall for interrupt packets with only 1 header flit
reg [2:0] msg_int_state_f;
reg [2:0] msg_int_state_next;
reg int_stall;

always @ *
begin
    if (!rst_n)
    begin
        msg_data_state_next = msg_data_state0;
    end
    else if((msg_state_f == msg_state_header0) && valid_in)
    begin
        if (data_in[21:14] == 8'd32)
        begin
            msg_data_state_next = msg_data_state1;
        end
        else
        begin
            msg_data_state_next = data_in[29:22] - 2;
        end
    end
    else
    begin
        msg_data_state_next = msg_data_state_f;
    end
end

always @ (posedge clk)
begin
    msg_data_state_f <= msg_data_state_next;
end

always @ *
begin
    if (!rst_n)
    begin
        msg_state_next = msg_state_header0;
    end
    else if (valid_in && real_ready_in)
    begin
        if ((msg_state_f == msg_state_header2) && (msg_data_state_f == msg_data_state0))
        begin
            msg_state_next = msg_state_header0;
        end
        else if ((msg_state_f == msg_state_data0) && (msg_data_state_f == msg_data_state1))
        begin
            msg_state_next = msg_state_header0;
        end
        else
        begin
            if (msg_state_f == msg_state_data1)
            begin
                msg_state_next = msg_state_header0;
            end
            else
            begin
                msg_state_next = msg_state_f + 3'd1;
            end
        end
    end
    else
    begin
        msg_state_next = msg_state_f;
    end 
end


always @ (posedge clk)
begin
    msg_state_f <= msg_state_next;
end

always @ *
begin
    if (!rst_n)
    begin
        msg_int_state_next = msg_state_header0;
    end
    else if (valid_in && real_ready_in && (data_in[21:14] == 8'd32) 
         && (msg_state_f == msg_state_header0))
    begin
        msg_int_state_next = msg_state_header1;
    end
    else if (valid_in && real_ready_in && (msg_int_state_f == msg_state_header1))
    begin
        msg_int_state_next = msg_state_header2;
    end
    else if (valid_in && real_ready_in && (msg_int_state_f == msg_state_header2))
    begin
        msg_int_state_next = msg_state_header0;
    end
    else
    begin
        msg_int_state_next = msg_int_state_f;
    end 
end

always @ (posedge clk)
begin
    msg_int_state_f <= msg_int_state_next;
end


always @ *
begin
    if ((valid_in && (data_in[21:14] == 8'd32) && (msg_state_f == msg_state_header0))
    || (msg_int_state_f == msg_state_header1))
    begin
        int_stall = 1'b1;
    end
    else
    begin
        int_stall = 1'b0;
    end
end




localparam msg_mux_header = 1'b0;
localparam msg_mux_data = 1'b1;

reg msg_mux_sel;

always @ *
begin
    if ((msg_state_f == msg_state_header0)
    ||  (msg_state_f == msg_state_header1)
    ||  (msg_state_f == msg_state_header2))
    begin
        msg_mux_sel = msg_mux_header;
    end
    else
        msg_mux_sel = msg_mux_data;
end


reg msg_header_valid_in;
reg [64-1:0] msg_header_in;
reg msg_header_ready_in;


reg msg_data_valid_in;
reg [64-1:0] msg_data_in;
reg msg_data_ready_in;


always @ *
begin
    if (msg_mux_sel == msg_mux_header)
    begin
        msg_header_valid_in = valid_in;
        msg_header_in = data_in;
    end
    else
    begin
        msg_header_valid_in = 0;
        msg_header_in = 0;
    end
end

always @ *
begin
    if (msg_mux_sel == msg_mux_data)
    begin
        msg_data_valid_in = valid_in;
        msg_data_in = data_in;
    end
    else
    begin
        msg_data_valid_in = 0;
        msg_data_in = 0;
    end
end

always @ *
begin
    if (msg_mux_sel == msg_mux_data)
    begin
        real_ready_in = msg_data_ready_in; 
    end
    else
    begin
        real_ready_in = msg_header_ready_in;
    end
end

always @ *
begin
    ready_in = real_ready_in && (!int_stall);
end


reg [64-1:0] header_buf_mem_f [8-1:0];
reg header_buf_empty;
reg header_buf_full;
reg [3:0] header_buf_counter_f;
reg [3:0] header_buf_counter_next;
reg [3-1:0] header_rd_ptr_f;
reg [3-1:0] header_rd_ptr_next;
reg [3-1:0] header_rd_ptr_plus1;
reg [3-1:0] header_rd_ptr_plus2;
reg [3-1:0] header_wr_ptr_f;
reg [3-1:0] header_wr_ptr_next;


always @ *
begin
    header_buf_empty = (header_buf_counter_f == 0);
    header_buf_full = (header_buf_counter_f ==  8);
end

always @ *
begin
    if ((msg_header_valid_in && msg_header_ready_in) && (msg_header_valid_out && msg_header_ready_out))
    begin
        header_buf_counter_next = header_buf_counter_f + 1 - 3;
    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin 
        header_buf_counter_next = header_buf_counter_f + 1;
    end
    else if (msg_header_valid_out && msg_header_ready_out)
    begin 
        header_buf_counter_next = header_buf_counter_f - 3;
    end
    else
    begin
        header_buf_counter_next = header_buf_counter_f;
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin
        header_buf_counter_f <= 0;
    end
    else
    begin
        header_buf_counter_f <= header_buf_counter_next;
    end
end

always @ *
begin
    if (!rst_n)
    begin   
        header_rd_ptr_next = 0;
    end
    else if (msg_header_valid_out && msg_header_ready_out)
    begin
        header_rd_ptr_next = header_rd_ptr_f + 3;
    end
    else
    begin
        header_rd_ptr_next = header_rd_ptr_f;
    end
end

always @ (posedge clk)
begin
    header_rd_ptr_f <= header_rd_ptr_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        header_wr_ptr_next = 0;
    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin
        header_wr_ptr_next = header_wr_ptr_f + 1;
    end
    else
    begin
        header_wr_ptr_next = header_wr_ptr_f;
    end
end


always @ (posedge clk)
begin
    header_wr_ptr_f <= header_wr_ptr_next;
end


always @ *
begin
    header_rd_ptr_plus1 = header_rd_ptr_f + 1;
    header_rd_ptr_plus2 = header_rd_ptr_f + 2;
end


always @ *
begin
   msg_header_ready_in = !header_buf_full;
end


always @ *
begin
    msg_header_valid_out = (header_buf_counter_f >= 3);
    msg_header_out = {header_buf_mem_f[header_rd_ptr_plus2], 
                      header_buf_mem_f[header_rd_ptr_plus1], 
                      header_buf_mem_f[header_rd_ptr_f]};
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin   
        header_buf_mem_f[0] <= 0;
        header_buf_mem_f[1] <= 0;
        header_buf_mem_f[2] <= 0;
        header_buf_mem_f[3] <= 0;
        header_buf_mem_f[4] <= 0;
        header_buf_mem_f[5] <= 0;
        header_buf_mem_f[6] <= 0;
        header_buf_mem_f[7] <= 0;

    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin
        header_buf_mem_f[header_wr_ptr_f] <= msg_header_in;
    end
    else
    begin 
        header_buf_mem_f[header_wr_ptr_f] <= header_buf_mem_f[header_wr_ptr_f];
    end
end




reg [64-1:0] data_buf_mem_f [4-1:0];
reg data_buf_empty;
reg data_buf_full;
reg [2:0] data_buf_counter_f;
reg [2:0] data_buf_counter_next;
reg [2-1:0] data_rd_ptr_f;
reg [2-1:0] data_rd_ptr_next;
reg [2-1:0] data_wr_ptr_f;
reg [2-1:0] data_wr_ptr_next;

always @ *
begin
    data_buf_empty = (data_buf_counter_f == 0);
    data_buf_full = (data_buf_counter_f ==  4);
end

always @ *
begin
    if (!rst_n)
    begin
        data_buf_counter_next = 0;
    end
    else if ((msg_data_valid_in && msg_data_ready_in) && (msg_data_valid_out && msg_data_ready_out))
    begin
        data_buf_counter_next = data_buf_counter_f + 1 - 1;
    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin 
        data_buf_counter_next = data_buf_counter_f + 1;
    end
    else if (msg_data_valid_out && msg_data_ready_out)
    begin 
        data_buf_counter_next = data_buf_counter_f - 1;
    end
    else
    begin
        data_buf_counter_next = data_buf_counter_f;
    end
end

always @ (posedge clk)
begin
    data_buf_counter_f <= data_buf_counter_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        data_rd_ptr_next = 0;
    end
    else if (msg_data_valid_out && msg_data_ready_out)
    begin
        data_rd_ptr_next = data_rd_ptr_f + 1;
    end
    else
    begin
        data_rd_ptr_next = data_rd_ptr_f;
    end
end


always @ (posedge clk)
begin
    data_rd_ptr_f <= data_rd_ptr_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        data_wr_ptr_next = 0;
    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin
        data_wr_ptr_next = data_wr_ptr_f + 1;
    end
    else
    begin
        data_wr_ptr_next = data_wr_ptr_f;
    end
end

always @ (posedge clk)
begin
    data_wr_ptr_f <= data_wr_ptr_next;
end



always @ *
begin
   msg_data_ready_in = !data_buf_full;
end


always @ *
begin
    msg_data_valid_out = !data_buf_empty;
    msg_data_out = data_buf_mem_f[data_rd_ptr_f]; 
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin   
        data_buf_mem_f[0] <= 0;
        data_buf_mem_f[1] <= 0;
        data_buf_mem_f[2] <= 0;
        data_buf_mem_f[3] <= 0;

    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin
        data_buf_mem_f[data_wr_ptr_f] <= msg_data_in;
    end
    else
    begin 
        data_buf_mem_f[data_wr_ptr_f] <= data_buf_mem_f[data_wr_ptr_f];
    end
end



endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe1_buf_out.v
//  Created On    : 2014-04-06
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Output buffer for pipeline1
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe1_buf_out(

    input wire clk,
    input wire rst_n,

    input wire [3-1:0] mode_in,
    input wire valid_in,
    input wire [320 -1:0] data_in,
    output reg ready_in,

   
    output reg valid_out,
    output reg [64-1:0] data_out,
    input wire ready_out

);



reg [64-1:0] buf_mem_f [16-1:0];
reg buf_empty;
reg buf_full;
reg [4:0] buf_counter_f;
reg [4:0] buf_counter_next;
reg [4-1:0] rd_ptr_f;
reg [4-1:0] rd_ptr_next;
reg [4-1:0] wr_ptr_f;
reg [4-1:0] wr_ptr_next;
reg [4-1:0] wr_ptr_plus1;
reg [4-1:0] wr_ptr_plus2;
reg [4-1:0] wr_ptr_plus3;
reg [4-1:0] wr_ptr_plus4;
reg [4:0] buf_rd_flits;

always @ *
begin
    if (mode_in == 3'd1)
    begin
        buf_rd_flits = 1;
    end
    else if (mode_in == 3'd2)
    begin
        buf_rd_flits = 2;
    end
    else if (mode_in == 3'd3)
    begin
        buf_rd_flits = 3;
    end
    else if (mode_in == 3'd4)
    begin
        buf_rd_flits = 3;
    end
    else if (mode_in == 3'd5)
    begin
        buf_rd_flits = 4;
    end
    else if (mode_in == 3'd6)
    begin
        buf_rd_flits = 5;
    end
    else if (mode_in == 3'd7)
    begin
        buf_rd_flits = 2;
    end
    else
    begin
        buf_rd_flits = 0;
    end
end



always @ *
begin
   buf_empty = (buf_counter_f == 0);
   buf_full = (buf_counter_f ==  16);
end

always @ *
begin
    if (!rst_n)
    begin
        buf_counter_next = 0;
    end
    else if ((valid_in && ready_in) && (valid_out && ready_out))
    begin
        buf_counter_next = buf_counter_f + buf_rd_flits - 1;
    end
    else if (valid_in && ready_in)
    begin 
        buf_counter_next = buf_counter_f + buf_rd_flits;
    end
    else if (valid_out && ready_out)
    begin 
        buf_counter_next = buf_counter_f - 1;
    end
    else
    begin
        buf_counter_next = buf_counter_f;
    end
end



always @ (posedge clk)
begin
    buf_counter_f <= buf_counter_next;
end


always @ *
begin
    if (!rst_n)
    begin   
        rd_ptr_next = 0;
    end
    else if (valid_out && ready_out)
    begin
        rd_ptr_next = rd_ptr_f + 1;
    end
    else
    begin
        rd_ptr_next = rd_ptr_f;
    end
end



always @ (posedge clk)
begin
    rd_ptr_f <= rd_ptr_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        wr_ptr_next = 0;
    end
    else if (valid_in && ready_in)
    begin
        wr_ptr_next = wr_ptr_f + buf_rd_flits;
    end
    else
    begin
        wr_ptr_next = wr_ptr_f;
    end
end

always @ (posedge clk)
begin
    wr_ptr_f <= wr_ptr_next;
end


always @ *
begin
    wr_ptr_plus1 = wr_ptr_f + 1;
    wr_ptr_plus2 = wr_ptr_f + 2;
    wr_ptr_plus3 = wr_ptr_f + 3;
    wr_ptr_plus4 = wr_ptr_f + 4;
end


always @ *
begin
    ready_in = (buf_counter_f <= 16 - buf_rd_flits);
end


always @ *
begin
    valid_out = !buf_empty;
    data_out = buf_mem_f[rd_ptr_f]; 
end



always @ (posedge clk)
begin
    if (!rst_n)
    begin  
        buf_mem_f[0] <= 0;
        buf_mem_f[1] <= 0;
        buf_mem_f[2] <= 0;
        buf_mem_f[3] <= 0;
        buf_mem_f[4] <= 0;
        buf_mem_f[5] <= 0;
        buf_mem_f[6] <= 0;
        buf_mem_f[7] <= 0;
        buf_mem_f[8] <= 0;
        buf_mem_f[9] <= 0;
        buf_mem_f[10] <= 0;
        buf_mem_f[11] <= 0;
        buf_mem_f[12] <= 0;
        buf_mem_f[13] <= 0;
        buf_mem_f[14] <= 0;
        buf_mem_f[15] <= 0;

    end
    else if (valid_in && ready_in)
    begin
        if (mode_in == 3'd1)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
        end
        else if (mode_in == 3'd2)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*4-1:64*3];
        end
        else if (mode_in == 3'd7)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64*4-1:64*3];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*5-1:64*4];
        end
        else if (mode_in == 3'd4)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*2-1:64];
            buf_mem_f[wr_ptr_plus2] <= data_in[64*3-1:64*2];
        end
        else if (mode_in == 3'd3)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*4-1:64*3];
            buf_mem_f[wr_ptr_plus2] <= data_in[64*5-1:64*4];
        end
        else if (mode_in == 3'd5)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*2-1:64];
            buf_mem_f[wr_ptr_plus2] <= data_in[64*3-1:64*2];
            buf_mem_f[wr_ptr_plus3] <= data_in[64*4-1:64*3];
        end
        else if (mode_in == 3'd6)
        begin
            buf_mem_f[wr_ptr_f] <= data_in[64-1:0];
            buf_mem_f[wr_ptr_plus1] <= data_in[64*2-1:64];
            buf_mem_f[wr_ptr_plus2] <= data_in[64*3-1:64*2];
            buf_mem_f[wr_ptr_plus3] <= data_in[64*4-1:64*3];
            buf_mem_f[wr_ptr_plus4] <= data_in[64*5-1:64*4];
        end
    end

end




endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe1_ctrl.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The control unit for pipeline1 in the L2 cache
//
//
//====================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe1_ctrl(

    input wire clk,
    input wire rst_n,
    
    input wire csm_en,
    
    //Inputs to Stage 1

    input wire pipe2_valid_S1,
    input wire pipe2_valid_S2,
    input wire pipe2_valid_S3,
    input wire [8-1:0] pipe2_msg_type_S1,
    input wire [8-1:0] pipe2_msg_type_S2,
    input wire [8-1:0] pipe2_msg_type_S3,
    input wire [40-1:0] pipe2_addr_S1,
    input wire [40-1:0] pipe2_addr_S2,
    input wire [40-1:0] pipe2_addr_S3,

    //global stall from pipeline2
    input wire global_stall_S1,

    //input msg from the input buffer
    input wire msg_header_valid_S1,
    input wire [8-1:0] msg_type_S1,
    input wire [3-1:0] msg_data_size_S1,
    input wire [1-1:0] msg_cache_type_S1,

    //input from the mshr
    input wire mshr_hit_S1,





 // L2_CAM_MSHR
    input wire mshr_pending_S1,
    input wire [3-1:0] mshr_pending_index_S1,
    input wire [3:0] mshr_empty_slots_S1,
    


 // L2_CAM_MSHR
    


    //input from the mshr
    input wire [8-1:0] cam_mshr_msg_type_S1,
    input wire [1-1:0] cam_mshr_l2_miss_S1,
    input wire [3-1:0] cam_mshr_data_size_S1,
    input wire [1-1:0] cam_mshr_cache_type_S1,
    
    input wire cam_mshr_smc_miss_S1,
    

    //input from the mshr
    input wire [8-1:0] pending_mshr_msg_type_S1,
    input wire [1-1:0] pending_mshr_l2_miss_S1,
    input wire [3-1:0] pending_mshr_data_size_S1,
    input wire [1-1:0] pending_mshr_cache_type_S1,
    
    input wire pending_mshr_smc_miss_S1,
    
 // L2_CAM_MSHR

    //data valid signal from the input buffer
    input wire msg_data_valid_S1,

    input wire [40-1:0] addr_S1,


    //Inputs to Stage 2

    //global stall from pipeline2
    input wire global_stall_S2,

    //tag and state info from dpath
    input wire l2_tag_hit_S2,
    input wire l2_evict_S2,
    input wire l2_wb_S2,
    input wire [2-1:0] l2_way_state_mesi_S2,
    input wire [2-1:0] l2_way_state_vd_S2,
    input wire [1-1:0] l2_way_state_cache_type_S2,
    input wire [4-1:0] l2_way_state_subline_S2,
    input wire req_from_owner_S2,
    input wire addr_l2_aligned_S2,
    input wire [6-1:0] lsid_S2,

    //data valid signal from the input buffer
    input wire msg_data_valid_S2,


    input wire [40-1:0] addr_S2,

    //Inputs to Stage 3

    //global stall from pipeline2
    //input wire global_stall_S3,
    //sharer list from the directory array
    input wire [64-1:0] dir_data_S3,
    input wire [40-1:0] addr_S3,


    //Inputs to Stage 4
    //global stall from pipeline2
    input wire global_stall_S4,

    //input signals from the mshr
    input wire [3-1:0] mshr_empty_index_S4,

    //pipelined tag and state info from dpath
    input wire l2_tag_hit_S4,
    input wire l2_evict_S4,
    input wire [2-1:0] l2_way_state_mesi_S4,
    input wire [6-1:0] l2_way_state_owner_S4,
    input wire [2-1:0] l2_way_state_vd_S4,
    input wire [4-1:0] l2_way_state_subline_S4,
    input wire [1-1:0] l2_way_state_cache_type_S4,
    input wire [8-1:0] mshrid_S4,
    input wire req_from_owner_S4,
    input wire [6-1:0] mshr_miss_lsid_S4,
    input wire [6-1:0] lsid_S4,

    
    input wire broadcast_counter_zero_S4,
    input wire broadcast_counter_max_S4,
    input wire broadcast_counter_avail_S4,
    input wire [14-1:0] broadcast_chipid_out_S4,
    input wire [8-1:0] broadcast_x_out_S4,
    input wire [8-1:0] broadcast_y_out_S4,
    

    input wire [40-1:0] addr_S4,
    //comparing result of CAS requests
    input wire cas_cmp_S4,

    //ready signal from the output buffer
    input wire msg_send_ready_S4,

    //inputs from the smc
    
    input wire smc_hit_S4,
    

    //Outputs from Stage 1

    output reg valid_S1,
    output reg stall_S1,
    output reg msg_from_mshr_S1,
    output reg dis_flush_S1,

    output reg mshr_cam_en_S1,
    output reg mshr_pending_ready_S1,

    output reg msg_header_ready_S1,

    output reg tag_clk_en_S1,
    output reg tag_rdw_en_S1,

    output reg state_rd_en_S1,

    output reg reg_wr_en_S1,
    output reg [8-1:0] reg_wr_addr_type_S1,


    //Outputs from Stage 2

    output reg valid_S2,
    output reg stall_S2,
    output reg stall_before_S2,
    output reg stall_real_S2,
    output reg [8-1:0] msg_type_S2,

    output reg msg_from_mshr_S2,
    output reg special_addr_type_S2,
    output wire state_load_sdid_S2,

    output reg dir_clk_en_S2,
    output reg dir_rdw_en_S2,
    output reg [2-1:0] dir_op_S2,


    output reg data_clk_en_S2,
    output reg data_rdw_en_S2,
    output reg [4-1:0] amo_alu_op_S2,

    output reg [3-1:0] data_size_S2,
    output reg [1-1:0] cache_type_S2,
    output reg state_owner_en_S2,
    output reg [2-1:0] state_owner_op_S2,
    output reg state_subline_en_S2,
    output reg [2-1:0] state_subline_op_S2,
    output reg state_di_en_S2,
    output reg state_vd_en_S2,
    output reg [2-1:0] state_vd_S2,
    output reg state_mesi_en_S2,
    output reg [2-1:0] state_mesi_S2,
    output reg state_lru_en_S2,
    output reg [1-1:0] state_lru_op_S2,
    output reg state_rb_en_S2,

    output reg [2-1:0] l2_load_data_subline_S2,
    output reg l2_ifill_32B_S2,

    output reg msg_data_ready_S2,

    
    output reg smc_wr_en_S2,
    output reg smc_wr_diag_en_S2,
    output reg smc_flush_en_S2,
    output reg [2-1:0] smc_addr_op_S2,
    
    //Outputs from Stage 3

    output reg valid_S3,
    output reg stall_S3,
    output reg stall_before_S3,

    //Outputs from Stage 4

    output reg valid_S4,
    output reg stall_S4,
    output reg stall_before_S4,


    output reg [8-1:0] msg_type_S4,
    output reg [3-1:0] data_size_S4,
    output reg [1-1:0] cache_type_S4,
    output reg [1-1:0] l2_miss_S4,
    
    output reg smc_miss_S4,
    output reg stall_smc_buf_S4,
    
    output reg  msg_from_mshr_S4,
    output reg req_recycle_S4,
    output reg inv_fwd_pending_S4,

    output wire [6-1:0] dir_sharer_S4,
    output reg [6-1:0] dir_sharer_counter_S4,
    output reg [64-1:0] dir_data_sel_S4,
    output reg cas_cmp_en_S4,
    output reg atomic_read_data_en_S4,
    output reg [3-1:0] cas_cmp_data_size_S4,
    output reg [64-1:0] dir_data_S4,

    output reg msg_send_valid_S4,
    output reg [3-1:0] msg_send_mode_S4,
    output reg [8-1:0] msg_send_type_S4,
    output reg [8-1:0] msg_send_type_pre_S4,

    output reg [8-1:0] msg_send_length_S4,
    output reg [3-1:0] msg_send_data_size_S4,
    output reg [1-1:0] msg_send_cache_type_S4,
    output reg [2-1:0] msg_send_mesi_S4,
    output reg [1-1:0] msg_send_l2_miss_S4,
    output reg [8-1:0] msg_send_mshrid_S4,
    output reg [4-1:0] msg_send_subline_vector_S4,
    output reg special_addr_type_S4,

    output reg mshr_wr_data_en_S4,
    output reg mshr_wr_state_en_S4,
    output reg [2-1:0] mshr_state_in_S4,
    output reg [3-1:0] mshr_inv_counter_rd_index_in_S4,
    output reg [3-1:0] mshr_wr_index_in_S4,

    output reg state_wr_sel_S4,
    output reg state_wr_en_S4,

    
    output reg [2-1:0] broadcast_counter_op_S4,
    output reg broadcast_counter_op_val_S4,
    

    
    output reg smc_rd_diag_en_buf_S4,
    output reg smc_rd_en_buf_S4,
    

    output reg l2_access_valid_S4,
    output reg l2_miss_valid_S4,
    output reg reg_rd_en_S4,
    output reg [8-1:0] reg_rd_addr_type_S4

);




localparam y = 1'b1;
localparam n = 1'b0;


localparam rd = 1'b1;
localparam wr = 1'b0;


// pre-declare
reg [8-1:0] msg_type_S2_f;
reg msg_from_mshr_S2_f;
reg [8-1:0] msg_type_S4_f;

//============================
// Stage 1
//============================

reg stall_pre_S1;
reg stall_hazard_S1;
reg [8-1:0] msg_type_mux_S1;
reg [8-1:0] msg_type_trans_S1;
reg [3-1:0] data_size_S1;
reg [1-1:0] cache_type_S1;

reg msg_header_ready_real_S1;
reg msg_cas_cmp_S1_f;
reg msg_cas_cmp_S1_next;
reg msg_input_en_S1_f;
reg msg_input_en_S1_next;
reg [8-1:0] addr_type_S1;
reg [2-1:0] addr_op_S1;
reg special_addr_type_S1;
reg msg_data_rd_S1;

always @ *
begin
    valid_S1 = mshr_pending_S1 || (msg_header_valid_S1 && msg_input_en_S1_f);
end



always @ *
begin
    stall_pre_S1 = stall_S2 || global_stall_S1;
end


always @ *
begin
    mshr_pending_ready_S1 = mshr_pending_S1 && (!stall_S1);
end

always @ *
begin
    msg_from_mshr_S1 = mshr_pending_S1;
end

//msgs from mshr have higher priority than those from the input buffer
always @ *
begin
    if (msg_from_mshr_S1)
    begin



        msg_type_mux_S1 = pending_mshr_msg_type_S1;
 // L2_CAM_MSHR
    end
    else
    begin
        msg_type_mux_S1 = msg_type_S1;
    end
end


always @ *
begin
     //Modified for timing
    //mshr_cam_en_S1 = (!mshr_pending_S1) && msg_header_valid_S1 && (!stall_pre_S1);
    // mshr_cam_en_S1 = (!mshr_pending_S1) && msg_header_valid_S1;
    mshr_cam_en_S1 = (!mshr_pending_S1) && msg_header_valid_S1 && (!global_stall_S1);
    // trinn
end


localparam atomic_state0 = 1'b0;
localparam atomic_state1 = 1'b1;
reg atomic_state_S1_f;
reg atomic_state_S1_next;
reg [4-1:0] amo_alu_op_S1;
reg [4-1:0] amo_alu_op_S2_f;


always @ *
begin
    amo_alu_op_S1 = 4'd0;
    if (!rst_n)
    begin
        atomic_state_S1_next = atomic_state0;
    end
    else if (valid_S1 && (!msg_from_mshr_S1) &&
       (msg_type_trans_S1 == 8'd6
        || msg_type_trans_S1 == 8'd10
        || msg_type_trans_S1 == 8'd44
        || msg_type_trans_S1 == 8'd45
        || msg_type_trans_S1 == 8'd46
        || msg_type_trans_S1 == 8'd47
        || msg_type_trans_S1 == 8'd48
        || msg_type_trans_S1 == 8'd49
        || msg_type_trans_S1 == 8'd50
        || msg_type_trans_S1 == 8'd51))
    begin
        atomic_state_S1_next = atomic_state1;
    end
    else if (valid_S1 && (!msg_from_mshr_S1) &&
            (msg_type_trans_S1 == 8'd7
            || msg_type_trans_S1 == 8'd8
            || msg_type_trans_S1 == 8'd11
            || msg_type_trans_S1 == 8'd52
            || msg_type_trans_S1 == 8'd53
            || msg_type_trans_S1 == 8'd54
            || msg_type_trans_S1 == 8'd55
            || msg_type_trans_S1 == 8'd56
            || msg_type_trans_S1 == 8'd57
            || msg_type_trans_S1 == 8'd58
            || msg_type_trans_S1 == 8'd59))
    begin
        atomic_state_S1_next = atomic_state0;
        case (msg_type_trans_S1)
            8'd52: begin
                amo_alu_op_S1 = 4'd1;
            end
            8'd53: begin
                amo_alu_op_S1 = 4'd2;
            end
            8'd54: begin
                amo_alu_op_S1 = 4'd3;
            end
            8'd55: begin
                amo_alu_op_S1 = 4'd4;
            end
            8'd56: begin
                amo_alu_op_S1 = 4'd5;
            end
            8'd57: begin
                amo_alu_op_S1 = 4'd6;
            end
            8'd58: begin
                amo_alu_op_S1 = 4'd7;
            end
            8'd59: begin
                amo_alu_op_S1 = 4'd8;
            end
        endcase
    end
    else
    begin
        atomic_state_S1_next = atomic_state_S1_f;
    end
end


always @ (posedge clk)
begin
    if (!stall_S1)
    begin
        atomic_state_S1_f <= atomic_state_S1_next;
    end
end

//translate atomic instructions into two subtypes based on two phases
always @ *
begin
    case (msg_type_mux_S1)
    8'd14:
    begin
        case (addr_type_S1)
        8'hac, 8'had, 8'hae, 8'haf:
        begin
            msg_type_trans_S1 = 8'd35;
        end
        8'ha3:
        begin
            msg_type_trans_S1 = 8'd34;
        end
        default:
        begin
            msg_type_trans_S1 = msg_type_mux_S1;
        end
        endcase
    end
    8'd5:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd6;
        end
        else
        begin
            if (msg_cas_cmp_S1_f)
            begin
                msg_type_trans_S1 = 8'd7;
            end
            else
            begin
                msg_type_trans_S1 = 8'd8;
            end
        end
    end
    8'd9:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd10;
        end
        else
        begin
            msg_type_trans_S1 = 8'd11;
        end
    end
    8'd36:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd44;
        end
        else
        begin
            msg_type_trans_S1 = 8'd52;
        end
    end
    8'd37:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd45;
        end
        else
        begin
            msg_type_trans_S1 = 8'd53;
        end
    end
    8'd38:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd46;
        end
        else
        begin
            msg_type_trans_S1 = 8'd54;
        end
    end
    8'd39:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd47;
        end
        else
        begin
            msg_type_trans_S1 = 8'd55;
        end
    end
    8'd40:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd48;
        end
        else
        begin
            msg_type_trans_S1 = 8'd56;
        end
    end
    8'd41:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd49;
        end
        else
        begin
            msg_type_trans_S1 = 8'd57;
        end
    end
    8'd42:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd50;
        end
        else
        begin
            msg_type_trans_S1 = 8'd58;
        end
    end
    8'd43:
    begin
        if (atomic_state_S1_f == atomic_state0)
        begin
            msg_type_trans_S1 = 8'd51;
        end
        else
        begin
            msg_type_trans_S1 = 8'd59;
        end
    end
    default:
    begin
        msg_type_trans_S1 = msg_type_mux_S1;
    end
    endcase
end


always @ *
begin
    dis_flush_S1 = (msg_type_trans_S1 == 8'd35) && ~msg_from_mshr_S1;
end

always @ *
begin
    addr_type_S1 = addr_S1[39:32];
    addr_op_S1 = addr_S1[31:30];
end


always @ *
begin
    if ((msg_type_trans_S1 == 8'd14 || msg_type_trans_S1 == 8'd15)
    &&  (addr_type_S1 == 8'ha0
    ||   addr_type_S1 == 8'ha4
    ||   addr_type_S1 == 8'ha6
    ||   addr_type_S1 == 8'ha1
    ||   addr_type_S1 == 8'ha2
    ||   addr_type_S1 == 8'ha5
    ||   addr_type_S1 == 8'haa
    ||   addr_type_S1 == 8'hab
    ||   addr_type_S1 == 8'ha7
    ||   addr_type_S1 == 8'ha8
    ||   addr_type_S1 == 8'ha9))
    begin
        special_addr_type_S1 = 1'b1;
    end
    else
    begin
        special_addr_type_S1 = 1'b0;
    end
end

always @ *
begin
    if (msg_from_mshr_S1)
    begin



        data_size_S1 = pending_mshr_data_size_S1;
 // L2_CAM_MSHR
    end
    else
    begin
        data_size_S1 = msg_data_size_S1;
    end
end

always @ *
begin
    if (msg_from_mshr_S1)
    begin



        cache_type_S1 = pending_mshr_cache_type_S1;
 // L2_CAM_MSHR
    end
    else
    begin
        cache_type_S1 = msg_cache_type_S1;
    end
end


reg [3-1:0] cs_S1;

always @ *
begin
    cs_S1 = {3{1'bx}};
    if (valid_S1)
    begin
        if (special_addr_type_S1)
        begin
            case (addr_type_S1)
                8'ha4:
                begin
                    if (msg_type_trans_S1 == 8'd14)
                    begin
                        //  tag_clk_en      tag_rdw_en    state_rd_en
                        cs_S1 = {y,             rd,       n};
                    end
                    else
                    begin
                        cs_S1 = {y,             wr,        n};
                    end
                end
                8'ha6:
                begin
                    if (msg_type_trans_S1 == 8'd14)
                    begin
                        //  tag_clk_en      tag_rdw_en   state_rd_en
                        cs_S1 = {y,             rd,      y};
                    end
                    else
                    begin
                        cs_S1 = {n,             rd,       n};
                    end
                end
                default:
                begin
                    cs_S1 = {n,             rd,           n};
                end
            endcase
        end
        else
        begin
            case (msg_type_trans_S1)
                8'd31, 8'd14, 8'd15, 8'd1,
                8'd2,
                8'd60,
                8'd13, 8'd7, 8'd11,
                8'd6, 8'd10, 8'd35,8'd34,
                8'd44, 8'd52,
                8'd45, 8'd53,
                8'd46, 8'd54,
                8'd47, 8'd55,
                8'd48, 8'd56,
                8'd49, 8'd57,
                8'd50, 8'd58,
                8'd51, 8'd59:
                begin
                //  tag_clk_en      tag_rdw_en      state_rd_en
                    cs_S1 = {y,             rd,     y};
                end
                8'd30, 8'd8, 8'd32:
                begin
                    cs_S1 = {n,             rd,          n};
                end
                default:
                begin
                    cs_S1 = {3{1'bx}};
                end
            endcase
        end
    end
    else
    begin
        cs_S1 = {3{1'b0}};
    end
end


//disable inputs from the input buffers for requests with stored data because the stored data cannot be buffered
//if those instructions cause misses
always @ *
begin
    if (!rst_n)
    begin
        msg_input_en_S1_next = y;
    end
    else if ((valid_S1 && !stall_S1)
           &&((msg_type_trans_S1 == 8'd7)
           || (msg_type_trans_S1 == 8'd11)
           || (msg_type_trans_S1 == 8'd52)
           || (msg_type_trans_S1 == 8'd53)
           || (msg_type_trans_S1 == 8'd54)
           || (msg_type_trans_S1 == 8'd55)
           || (msg_type_trans_S1 == 8'd56)
           || (msg_type_trans_S1 == 8'd57)
           || (msg_type_trans_S1 == 8'd58)
           || (msg_type_trans_S1 == 8'd59)
           || (msg_type_trans_S1 == 8'd15))
           && !msg_from_mshr_S1)
    begin
        msg_input_en_S1_next = n;
    end
    else if ((valid_S2 && !stall_S2)
           &&((((msg_type_S2_f == 8'd7)
           || (msg_type_S2_f == 8'd11)
           || (msg_type_S2_f == 8'd52)
           || (msg_type_S2_f == 8'd53)
           || (msg_type_S2_f == 8'd54)
           || (msg_type_S2_f == 8'd55)
           || (msg_type_S2_f == 8'd56)
           || (msg_type_S2_f == 8'd57)
           || (msg_type_S2_f == 8'd58)
           || (msg_type_S2_f == 8'd59))
                && l2_tag_hit_S2 && (l2_way_state_mesi_S2 == 2'b00))
            ||((msg_type_S2_f == 8'd15)
                && ((!l2_tag_hit_S2 && !msg_from_mshr_S2_f) || (l2_tag_hit_S2 && (l2_way_state_mesi_S2 == 2'b00) && (l2_way_state_vd_S2 == 2'b10))))))
    begin
        msg_input_en_S1_next = y;
    end
    else
    begin
        msg_input_en_S1_next = msg_input_en_S1_f;
    end
end


always @ (posedge clk)
begin
    msg_input_en_S1_f <= msg_input_en_S1_next;
end



always @ *
begin
    msg_data_rd_S1 = valid_S1 && (msg_type_trans_S1 == 8'd15)
                  && (addr_type_S1 == 8'ha7
                  ||  addr_type_S1 == 8'ha9
                  ||  addr_type_S1 == 8'ha8
                  ||  addr_type_S1 == 8'haa
                  ||  addr_type_S1 == 8'hab
                  ||  addr_type_S1 == 8'ha4);
end


always @ *
begin
    reg_wr_en_S1 = valid_S1 && ~stall_S1 && (msg_type_trans_S1 == 8'd15)
               && ((addr_type_S1 == 8'ha9)
                || (addr_type_S1 == 8'ha7)
                || (addr_type_S1 == 8'ha8)
                || (addr_type_S1 == 8'haa)
                || (addr_type_S1 == 8'hab));
end

always @ *
begin
    reg_wr_addr_type_S1 = addr_type_S1;
end


//write the comparing result from stage 3
always @ *
begin
    if (!rst_n)
    begin
        msg_cas_cmp_S1_next = n;
    end
    else if (msg_type_S4_f == 8'd6 && cas_cmp_en_S4)
    begin
        if (cas_cmp_S4)
        begin
            msg_cas_cmp_S1_next = y;
        end
        else
        begin
            msg_cas_cmp_S1_next = n;
        end
    end
    else
    begin
        msg_cas_cmp_S1_next = msg_cas_cmp_S1_f;
    end
end


always @ (posedge clk)
begin
    msg_cas_cmp_S1_f <= msg_cas_cmp_S1_next;
end


always @ *
begin
    stall_hazard_S1 = (valid_S2 && (addr_S1[6+9-1:6] == addr_S2[6+9-1:6]))
                   || (valid_S3 && (addr_S1[6+9-1:6] == addr_S3[6+9-1:6]))
                   || (valid_S4 && (addr_S1[6+9-1:6] == addr_S4[6+9-1:6]))
                   || (pipe2_valid_S1 && (addr_S1[39:6] == pipe2_addr_S1[39:6]))
                   || (pipe2_valid_S2 && (addr_S1[39:6] == pipe2_addr_S2[39:6]))
                   || (pipe2_valid_S3 && (addr_S1[39:6] == pipe2_addr_S3[39:6]));
end

reg stall_mshr_S1;

always @ *
begin
    // trinn
    // stall_mshr_S1 = ( (mshr_cam_en_S1 && !global_stall_S1) && mshr_hit_S1)
    stall_mshr_S1 = (mshr_cam_en_S1 && mshr_hit_S1)
                 || (~msg_from_mshr_S1
                 //can be optimized
                 &&((mshr_empty_slots_S1 <= 3 && (valid_S2 || valid_S3 || valid_S4))
                 ||  mshr_empty_slots_S1 == 0));
end

reg stall_msg_S1;

always @ *
begin
    stall_msg_S1 = msg_data_rd_S1 && ~msg_data_valid_S1;
end

always @ *
begin
    stall_S1 = valid_S1 && (stall_pre_S1 || stall_hazard_S1 || stall_mshr_S1 || stall_msg_S1);
end


always @ *
begin
    msg_header_ready_real_S1 = (!stall_S1) && (!msg_from_mshr_S1) && msg_input_en_S1_f;
end

always @ *
begin
    msg_header_ready_S1 = msg_header_ready_real_S1
        && ((msg_type_trans_S1 != 8'd6)
         && (msg_type_trans_S1 != 8'd10)
         && (msg_type_trans_S1 != 8'd44)
         && (msg_type_trans_S1 != 8'd45)
         && (msg_type_trans_S1 != 8'd46)
         && (msg_type_trans_S1 != 8'd47)
         && (msg_type_trans_S1 != 8'd48)
         && (msg_type_trans_S1 != 8'd49)
         && (msg_type_trans_S1 != 8'd50)
         && (msg_type_trans_S1 != 8'd51)
         );
end


always @ *
begin
    //for timing
    tag_clk_en_S1 = valid_S1 && cs_S1[2];
    //tag_clk_en_S1 = valid_S1 && !stall_S1 && cs_S1[`CS_TAG_CLK_EN_S1];
end

always @ *
begin
    //for timing
    tag_rdw_en_S1 = valid_S1 && cs_S1[1];
    //tag_rdw_en_S1 = valid_S1 && !stall_S1 && cs_S1[`CS_TAG_RDW_EN_S1];
end

always @ *
begin
    //for timing
    state_rd_en_S1 = valid_S1 && cs_S1[0];
    //state_rd_en_S1 = valid_S1 && !stall_S1 && cs_S1[`CS_STATE_RD_EN_S1];
end

reg l2_miss_S1;

always @ *
begin
    if (msg_from_mshr_S1)
    begin



        l2_miss_S1 = pending_mshr_l2_miss_S1;
 // L2_CAM_MSHR
    end
    else
    begin
        l2_miss_S1 = 0;
    end
end


reg valid_S1_next;

always @ *
begin
    valid_S1_next = valid_S1 && !stall_S1;
end



//============================
// Stage 1 -> Stage 2
//============================

reg valid_S2_f;
reg [3-1:0] data_size_S2_f;
reg [1-1:0] cache_type_S2_f;
reg [1-1:0] l2_miss_S2_f;

reg mshr_smc_miss_S2_f;

reg [3-1:0] mshr_pending_index_S2_f;
reg special_addr_type_S2_f;
reg msg_data_rd_S2_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        valid_S2_f <= 1'b0;
        msg_type_S2_f <= 0;
        data_size_S2_f <= 0;
        cache_type_S2_f <= 0;
        l2_miss_S2_f <= 0;
        
        mshr_smc_miss_S2_f <= 0;
        
        msg_from_mshr_S2_f <= 1'b0;
        mshr_pending_index_S2_f <= 0;
        special_addr_type_S2_f <= 0;
        msg_data_rd_S2_f <= 0;
        amo_alu_op_S2_f <= 4'b0;
    end
    else if (!stall_S2)
    begin
        valid_S2_f <= valid_S1_next;
        msg_type_S2_f <= msg_type_trans_S1;
        data_size_S2_f <= data_size_S1;
        cache_type_S2_f <= cache_type_S1;
        l2_miss_S2_f <= l2_miss_S1;
        



        mshr_smc_miss_S2_f <= (mshr_pending_S1 == 1'b1) ? pending_mshr_smc_miss_S1 : (mshr_hit_S1 && cam_mshr_smc_miss_S1);
 // L2_CAM_MSHR
        
        msg_from_mshr_S2_f <= msg_from_mshr_S1;
        mshr_pending_index_S2_f <= mshr_pending_index_S1;
        special_addr_type_S2_f <= special_addr_type_S1;
        msg_data_rd_S2_f <= msg_data_rd_S1;
        amo_alu_op_S2_f <= amo_alu_op_S1;
    end
end



//============================
// Stage 2
//============================

reg stall_pre_S2;
// reg stall_real_S2;
reg stall_before_S2_f;
reg stall_before_S2_next;
reg state_wr_en_S2;
reg [1-1:0] l2_miss_S2;
//re-execute this request
reg req_recycle_S2;
reg req_recycle_cur_S2;
reg req_recycle_buf_S2_f;
reg req_recycle_buf_S2_next;

reg mshr_wr_data_en_S2;
reg mshr_wr_state_en_S2;
reg [2-1:0] mshr_state_in_S2;

reg [8-1:0] addr_type_S2;
reg [2-1:0] addr_op_S2;


always @ *
begin
    valid_S2 = valid_S2_f;
    data_size_S2 = data_size_S2_f;
    cache_type_S2 = cache_type_S2_f;
    msg_from_mshr_S2 = msg_from_mshr_S2_f;
    stall_before_S2 = stall_before_S2_f;
    msg_type_S2 = msg_type_S2_f;
    special_addr_type_S2 = special_addr_type_S2_f;
    amo_alu_op_S2 = amo_alu_op_S2_f;
end

always @ *
begin
    addr_type_S2 = addr_S2[39:32];
    addr_op_S2 = addr_S2[31:30];
end



always @ *
begin
    if (!rst_n)
    begin
        stall_before_S2_next = 0;
    end
    else
    begin
        stall_before_S2_next = stall_S2;
    end
end


always @ (posedge clk)
begin
    stall_before_S2_f <= stall_before_S2_next;
end


always @ *
begin
    stall_pre_S2 = stall_S3 || global_stall_S2;
end


reg [27-1:0] cs_S2;

always @ *
begin
    // default assignment to prevent latch inferral
    cs_S2 = {27{1'bx}};
    if (valid_S2)
    begin
        if (special_addr_type_S2_f)
        begin
            case (addr_type_S2)
                8'ha0:
                begin
                    if (msg_type_S2_f == 8'd14)
                    begin
                        //       amo_alu    dir        dir      dir     data    data           mshr     state      state       state       msg
                        //       op         clk_en     rdw_en   op      clk_en  rdw_en         wr_en    owner_en   owner_op    subline_en  data_ready
                        cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,     n,          n,
                        //       state       state   state   state          state    state           state   state
                        //       subline_op  di_en   vd_en   vd             mesi_en  mesi            lru_en  lru
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                    else
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,     n,          y,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                end
                8'ha1:
                begin
                    if (msg_type_S2_f == 8'd14)
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          n,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                    else
                    begin
                        cs_S2 = {4'd0, y,         wr,      2'd0, n,      rd,            n,       n,         2'd0,     n,          y,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                end
                8'ha6:
                begin
                    if (msg_type_S2_f == 8'd15)
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       y,         2'd0,     y,          y,
                                 2'd0,    y,      y,      2'b00,  y,       2'b00, y,      1'b0};
                    end
                    else
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          n,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                end
                8'ha2:
                begin
                    if (msg_type_S2_f == 8'd15)
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          y,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                    else
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          n,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                end
                default:
                begin
                    cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          n,
                             2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                end
            endcase
        end
        else if (req_recycle_S2)
        begin
            cs_S2 = {27{1'b0}};
        end
        else
        begin
            if ((msg_type_S2_f == 8'd8) || (msg_type_S2_f == 8'd32))
            begin
                cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          y,
                         2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
            end

            else if (l2_evict_S2)
            begin
                case (l2_way_state_mesi_S2)
                2'b01:
                begin
                    cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                             2'd0,   n,       n,      2'b01,  n,      2'b00, n,      1'b0};
                end
                
                2'b11:
                begin
                    cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                             2'd0,   n,       n,      2'b01,  n,      2'b00, n,      1'b0};
                end
                
                2'b10:
                begin
                    
                    if (csm_en)
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                 2'd0,   n,       n,      2'b01,  n,      2'b00, n,      1'b0};
                    end
                    else
                    
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                 2'd0,   n,       n,      2'b01,  n,      2'b00, n,      1'b0};
                    end
                end
                2'b00:
                begin
                    case (l2_way_state_vd_S2)
                    2'b10:
                    begin
                        if (msg_type_S2_f == 8'd34)
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                        else
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                    end
                    2'b11:
                    begin
                        if (msg_type_S2_f == 8'd34)
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                        else
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            y,       n,         2'd0,    n,          n,
                                     2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end
                default:
                begin
                    cs_S2 = {27{1'bx}};
                end
                endcase
            end

            else if (!l2_tag_hit_S2)
            begin
                if (msg_type_S2_f == 8'd15)
                begin
                    if (msg_from_mshr_S2_f)
                    begin
                        //       dir        dir      dir     data    data           mshr     state      state       state       msg
                        //       clk_en     rdw_en   op      clk_en  rdw_en         wr_en    owner_en   owner_op    subline_en  data_ready
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,     n,          n,
                        //       state       state   state   state          state    state           state   state
                        //       subline_op  di_en   vd_en   vd             mesi_en  mesi            lru_en  lru
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                    else
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,     n,          y,
                                 2'd0,    n,      n,      2'b01,  n,       2'b00, n,      1'b0};
                    end
                end
                else if (msg_type_S2_f == 8'd13
                 || msg_type_S2_f == 8'd34
                 || msg_type_S2_f == 8'd35)
                begin
                    cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,    n,          n,
                             2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                end
                else
                begin
                    cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                             2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                end
            end

            else begin
            case (msg_type_S2_f)

                8'd13:
                begin
                    
                    if (csm_en && (l2_way_state_mesi_S2 == 2'b10) && l2_way_state_subline_S2[addr_S2[5:4]])
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            n,       n,         2'd0,    n,          n,
                                2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    else
                    
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,    n,          n,
                                2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                end
                8'd35:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    n,          n,
                                2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase

                end
                8'd14:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        case (l2_way_state_vd_S2)
                        2'b10:
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                        2'b11:
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            y,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b10,  n,      2'b00, y,      1'b0};
                        end
                        default:
                        begin
                            cs_S2 = {27{1'bx}};
                        end
                        endcase
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end

                8'd15:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        case (l2_way_state_vd_S2)
                        2'b10:
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            y,       n,         2'd0,    n,          y,
                                    2'd0,   n,       y,      2'b00,  n,      2'b00, y,      1'b0};
                        end
                        2'b11:
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            y,       n,         2'd0,    n,          n,
                                    2'd0,   n,       y,      2'b10,  n,      2'b00, y,      1'b0};
                        end
                        default:
                        begin
                            cs_S2 = {27{1'bx}};
                        end
                        endcase
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end

                8'd31:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        if (cache_type_S2_f == 1'b0)
                        begin
                            
                            if (csm_en)
                            begin
                                cs_S2 = {4'd0, y,         wr,      2'd1, y,      rd,            n,       y,         2'd1,     y,      n,
                                         2'd2,   y,       n,      2'b00,  y,      2'b10,   y,     1'b1};
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       y,         2'd1,     y,      n,
                                         2'd2,   y,       n,      2'b00,  y,      2'b10,   y,     1'b1};
                            end
                        end
                        else
                        begin
                            
                            if (csm_en)
                            begin
                                if (lsid_S2 == 6'd63)
                                begin
                                    cs_S2 = {4'd0, y,         wr,      2'd0, y,      rd,            n,       y,         2'd0,     y,      n,
                                            2'd1,   y,       n,      2'b00,  y,      2'b11,   y,     1'b1};
                                end
                                else
                                begin
                                    cs_S2 = {4'd0, y,         wr,      2'd0, y,      rd,            n,       y,         2'd1,     y,      n,
                                            2'd1,   y,       n,      2'b00,  y,      2'b01,   y,     1'b1};

                                end
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, y,         wr,      2'd0, y,      rd,            n,       y,         2'd0,     y,      n,
                                         2'd2,   y,       n,      2'b00,  y,      2'b01,   y,     1'b1};
                            end
                        end
                    end
                    2'b01:
                    begin
                        if (cache_type_S2_f == l2_way_state_cache_type_S2)
                        begin
                            
                            if (csm_en)
                            begin
                                cs_S2 = {4'd0, y,         wr,      2'd0, y,      rd,            n,       n,         2'd0,    n,      n,
                                        2'd0,   n,       n,      2'b00,  n,      2'b00, y,     1'b1};
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, y,         wr,      2'd0, y,      rd,            n,       n,         2'd0,    y,      n,
                                        2'd2,   n,       n,      2'b00,  n,      2'b00, y,     1'b1};
                            end
                        end
                        else
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    
                    2'b11:
                    begin
                        if (cache_type_S2_f == l2_way_state_cache_type_S2)
                        begin
                            
                            if (csm_en)
                            begin
                                cs_S2 = {4'd0, n,         wr,      2'd0, y,      rd,            n,       n,         2'd0,    n,      n,
                                         2'd0,   n,       n,      2'b00,  n,      2'b00, y,     1'b1};
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, n,         wr,      2'd0, y,      rd,            n,       n,         2'd0,    y,      n,
                                         2'd2,   n,       n,      2'b00,  n,      2'b00, y,     1'b1};
                            end
                        end
                        else
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    
                    2'b10:
                    begin
                        if (req_from_owner_S2 && (cache_type_S2_f == l2_way_state_cache_type_S2))
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    y,      n,
                                     2'd2,   n,       n,      2'b00,  n,      2'b00, y,      1'b1};
                        end
                        else
                        begin
                            
                            if (csm_en)
                            begin
                                cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                         2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                         2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                            end
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end
                // Just like a STORE
                8'd60:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        if (cache_type_S2_f == 1'b0)
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       y,         2'd1,     y,      n,
                                     2'd2,   y,       n,      2'b00,  y,      2'b10,   y,     1'b1};
                        end
                        else begin
                            cs_S2 = {27{1'bx}};
                        end
                    end
                    2'b01:   // change MESI state to I in pipe2
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    2'b10:
                    begin
                        if (req_from_owner_S2 && (cache_type_S2_f == l2_way_state_cache_type_S2))
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    y,      n,
                                     2'd2,   n,       n,      2'b00,  n,      2'b00, y,      1'b1};
                        end
                        else
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end
                8'd1:
                begin
                    cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            n,       n,         2'd0,    n,      n,
                             2'd0,   n,       n,      2'b00,  n,      2'b00, y,      1'b1};
                end

                8'd2:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         wr,      2'd1, y,      rd,            n,       y,         2'd1,     y,      n,
                                     2'd2,   y,       n,      2'b00,  y,      2'b10, y,     1'b1};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       y,         2'd1,     y,      n,
                                     2'd2,   y,       n,      2'b00,  y,      2'b10, y,     1'b1};
                        end
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,          n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        if (req_from_owner_S2 && (cache_type_S2_f == l2_way_state_cache_type_S2))
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,    y,      n,
                                     2'd2,   n,       n,      2'b00,  n,      2'b00, y,      1'b1};
                        end
                        else
                        begin
                            
                            if (csm_en)
                            begin
                                cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                         2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                            end
                            else
                            
                            begin
                                cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                         2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                            end
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end
                8'd6:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,     n,      y,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00,   y,     1'b1};
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end
                8'd10,
                8'd44,
                8'd45,
                8'd46,
                8'd47,
                8'd48,
                8'd49,
                8'd50,
                8'd51:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, y,      rd,            n,       n,         2'd0,     n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00,   y,     1'b1};
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end

                8'd7,
                8'd11,
                8'd52,
                8'd53,
                8'd54,
                8'd55,
                8'd56,
                8'd57,
                8'd58,
                8'd59:
                begin
                    case (l2_way_state_mesi_S2)
                    2'b00:
                    begin
                        case (msg_type_S2_f)
                        8'd7,
                        8'd11:
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd52:
                        begin
                            cs_S2 = {4'd1, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd53:
                        begin
                            cs_S2 = {4'd2, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd54:
                        begin
                            cs_S2 = {4'd3, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd55:
                        begin
                            cs_S2 = {4'd4, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd56:
                        begin
                            cs_S2 = {4'd5, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd57:
                        begin
                            cs_S2 = {4'd6, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd58:
                        begin
                            cs_S2 = {4'd7, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        8'd59:
                        begin
                            cs_S2 = {4'd8, n,         rd,      2'd0, y,      wr,            n,       n,         2'd0,    n,      y,
                                 2'd0,   y,       y,      2'b11,  n,      2'b00, y,      1'b1};
                        end
                        endcase
                    end
                    2'b01:
                    begin
                        cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b11:
                    begin
                        cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                 2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                    end
                    
                    2'b10:
                    begin
                        
                        if (csm_en)
                        begin
                            cs_S2 = {4'd0, y,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                        else
                        
                        begin
                            cs_S2 = {4'd0, n,         rd,      2'd0, n,      rd,            y,       n,         2'd0,    n,      n,
                                     2'd0,   n,       n,      2'b00,  n,      2'b00, n,      1'b0};
                        end
                    end
                    default:
                    begin
                        cs_S2 = {27{1'bx}};
                    end
                    endcase
                end

                default:
                begin
                    cs_S2 = {27{1'bx}};
                end
            endcase
            end
        end
    end
    else
    begin
        cs_S2 = {27{1'b0}};
    end
end



reg [2-1:0] l2_load_data_subline_S2_f;
reg [2-1:0] l2_load_data_subline_S2_next;


always @ *
begin
    dir_clk_en_S2 = !stall_S2 && cs_S2[22];
end

always @ *
begin
    dir_rdw_en_S2 = !stall_S2 && cs_S2[21];
end


always @ *
begin
    dir_op_S2 = cs_S2[20:19];
end

always @ *
begin
    data_clk_en_S2 = !stall_real_S2 && cs_S2[18];
end

always @ *
begin
    data_rdw_en_S2 = !stall_real_S2 && cs_S2[17];
end

always @ *
begin
    mshr_wr_data_en_S2 = !stall_S2 && cs_S2[16];
    mshr_wr_state_en_S2 = !stall_S2 && cs_S2[16];
end



always @ *
begin
    if ( l2_tag_hit_S2 && (msg_type_S2_f == 8'd14 || msg_type_S2_f == 8'd15)
    && (l2_way_state_mesi_S2 == 2'b00) && (l2_way_state_vd_S2 == 2'b11))
    begin
        mshr_state_in_S2 = 2'd2;
    end
    else
    begin
        mshr_state_in_S2 = 2'd1;
    end
end


always @ *
begin
    if (!l2_tag_hit_S2)
    begin
        l2_miss_S2 = 1;
    end
    else
    begin
        l2_miss_S2 = l2_miss_S2_f;
    end
end




always @ *
begin
    if (special_addr_type_S2_f && (addr_type_S2 == 8'ha2) && (msg_type_S2_f == 8'd15))
    begin
        smc_wr_en_S2 = 1'b1;
        smc_wr_diag_en_S2 = 1'b1;
    end
    else
    begin
        smc_wr_en_S2 = 1'b0;
        smc_wr_diag_en_S2 = 1'b0;
    end
end

always @ *
begin
    if (special_addr_type_S2_f && (addr_type_S2 == 8'ha5))
    begin
        smc_flush_en_S2 = 1'b1;
    end
    else
    begin
        smc_flush_en_S2 = 1'b0;
    end
end


always @ *
begin
    smc_addr_op_S2 = addr_op_S2;
end


always @ *
begin
    state_owner_en_S2 =  cs_S2[15];
end


always @ *
begin
    state_owner_op_S2 = cs_S2[14:13];
end


always @ *
begin
    state_subline_en_S2 =  cs_S2[12];
end

always @ *
begin
    state_subline_op_S2 = cs_S2[10:9];
end



assign state_load_sdid_S2 = csm_en && state_owner_en_S2 && (state_owner_op_S2 ==2'd1)
                                && state_subline_en_S2 && (state_subline_op_S2 == 2'd1);




always @ *
begin
    state_di_en_S2 = cs_S2[8];
end

always @ *
begin
    state_vd_en_S2 = cs_S2[7];
end

always @ *
begin
    state_vd_S2 = cs_S2[6:5];
end

always @ *
begin
    state_mesi_en_S2 = cs_S2[4];
end

always @ *
begin
    if (!cs_S2[4])
    begin
        state_mesi_S2 = l2_way_state_mesi_S2;
    end
    else
    begin
        state_mesi_S2 = cs_S2[3:2];
    end
end

always @ *
begin
    state_lru_en_S2 =  cs_S2[1];
end

always @ *
begin
    state_lru_op_S2 = cs_S2[0];
end


//TODO
always @ *
begin
    state_rb_en_S2 =  l2_evict_S2  && (l2_way_state_mesi_S2 == 2'b00)
                 && (msg_type_S2_f != 8'd8);
end


always @ *
begin
    state_wr_en_S2 = valid_S2 && !stall_S2 && (
                          cs_S2[15]
                       || cs_S2[12]
                       || cs_S2[7]
                       || cs_S2[8]
                       || cs_S2[4]
                       || cs_S2[1]
                       || (state_rb_en_S2));
end


always @ *
begin
    req_recycle_cur_S2 = valid_S2
    &&  (~special_addr_type_S2_f)
    &&  ((pipe2_valid_S1 && (pipe2_msg_type_S1 == 8'd12)
        && (addr_S2[39:6] == pipe2_addr_S1[39:6]))
    ||   (pipe2_valid_S2 && (pipe2_msg_type_S1 == 8'd12)
        && (addr_S2[39:6] == pipe2_addr_S2[39:6]))
    ||   (pipe2_valid_S3 && (pipe2_msg_type_S3 == 8'd12)
        && (addr_S2[39:6] == pipe2_addr_S3[39:6])));
end


always @ *
begin
    if (!rst_n)
    begin
        req_recycle_buf_S2_next = 1'b0;
    end
    else
    begin
        if (!stall_S2)
        begin
            req_recycle_buf_S2_next = 1'b0;
        end
        else if (req_recycle_cur_S2)
        begin
            req_recycle_buf_S2_next = 1'b1;
        end
        else
        begin
            req_recycle_buf_S2_next = req_recycle_buf_S2_f;
        end
    end
end


always @ (posedge clk)
begin
    req_recycle_buf_S2_f <= req_recycle_buf_S2_next;
end


always @ *
begin
    req_recycle_S2 = req_recycle_cur_S2 | req_recycle_buf_S2_f;
end


always @ *
begin
    msg_data_ready_S2 = valid_S2 && !stall_S2 && (cs_S2[11] || msg_data_rd_S2_f);
end


always @ *
begin
    if (special_addr_type_S2)
    begin
        l2_ifill_32B_S2 = n;
    end
    else if (valid_S2 && l2_tag_hit_S2 && data_clk_en_S2 && (data_rdw_en_S2 == rd) && ~l2_wb_S2
    && (cache_type_S2_f == 1'b1))
    begin
        l2_ifill_32B_S2 = y;








    end
    else
    begin
        l2_ifill_32B_S2 = n;
    end
end



//writeback reads 64B and required 4 cycles to read out from the data array
//ifill loads 32B and required 2 cycles to read out from the data array
always @ *
begin
    if (!rst_n)
    begin
        l2_load_data_subline_S2_next = 2'd0;
    end
    else if (valid_S2 && !(stall_real_S2) && l2_ifill_32B_S2 && (l2_load_data_subline_S2_f == 2'd1))
    begin
        l2_load_data_subline_S2_next = 2'd0;
    end
    else if (valid_S2 && !(stall_real_S2) && (l2_wb_S2 || l2_ifill_32B_S2))
    begin
        l2_load_data_subline_S2_next = l2_load_data_subline_S2_f + 1;
    end
    else
    begin
        l2_load_data_subline_S2_next = l2_load_data_subline_S2_f;
    end
end


always @ (posedge clk)
begin
    l2_load_data_subline_S2_f <= l2_load_data_subline_S2_next;
end

reg stall_load_S2;

always @ *
begin
    if (l2_wb_S2)
    begin
        stall_load_S2 = (l2_load_data_subline_S2_f != 2'd3);
    end
    else if (l2_ifill_32B_S2)
    begin
        stall_load_S2 = (l2_load_data_subline_S2_f != 2'd1);
    end
    else
    begin
        stall_load_S2 = n;
    end
end


always @ *
begin
    l2_load_data_subline_S2 = l2_load_data_subline_S2_f;
end

reg stall_msg_S2;

always @ *
begin
    stall_msg_S2 = (cs_S2[11] || msg_data_rd_S2_f) && ~msg_data_valid_S2;
end


always @ *
begin
    stall_real_S2 = valid_S2 && (stall_pre_S2 || stall_msg_S2);
 end

always @ *
begin
    stall_S2 = valid_S2 && (stall_real_S2 || stall_load_S2);
end

reg valid_S2_next;

always @ *
begin
    valid_S2_next = valid_S2 && !stall_real_S2;
end



//============================
// Stage 2 -> Stage 3
//============================

reg valid_S3_f;
reg [8-1:0] msg_type_S3_f;
reg [3-1:0] data_size_S3_f;
reg [1-1:0] cache_type_S3_f;
reg msg_from_mshr_S3_f;
reg [2-1:0] l2_load_data_subline_S3_f;
reg [2-1:0] state_mesi_S3_f;
reg [1-1:0] l2_miss_S3_f;

reg mshr_smc_miss_S3_f;

reg state_wr_en_S3_f;
reg mshr_wr_data_en_S3_f;
reg mshr_wr_state_en_S3_f;
reg [2-1:0] mshr_state_in_S3_f;
reg [3-1:0] mshr_pending_index_S3_f;
reg special_addr_type_S3_f;
reg req_recycle_S3_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        valid_S3_f <= 1'b0;
        msg_type_S3_f <= 0;
        data_size_S3_f <= 0;
        cache_type_S3_f <= 0;
        msg_from_mshr_S3_f <= 0;
        l2_load_data_subline_S3_f <= 0;
        state_mesi_S3_f <= 0;
        l2_miss_S3_f <= 0;
        
        mshr_smc_miss_S3_f <= 0;
        
        state_wr_en_S3_f <= 0;
        mshr_wr_data_en_S3_f <= 0;
        mshr_wr_state_en_S3_f <= 0;
        mshr_state_in_S3_f <= 0;
        mshr_pending_index_S3_f <= 0;
        special_addr_type_S3_f <= 0;
        req_recycle_S3_f <= 0;
    end
    else if (!stall_S3)
    begin
        valid_S3_f <= valid_S2_next;
        msg_type_S3_f <= msg_type_S2_f;
        data_size_S3_f <= data_size_S2_f;
        cache_type_S3_f <= cache_type_S2_f;
        msg_from_mshr_S3_f <= msg_from_mshr_S2_f;
        l2_load_data_subline_S3_f <= l2_load_data_subline_S2_f;
        state_mesi_S3_f <= state_mesi_S2;
        l2_miss_S3_f <= l2_miss_S2;
        
        mshr_smc_miss_S3_f <= mshr_smc_miss_S2_f;
        
        state_wr_en_S3_f <= state_wr_en_S2;
        mshr_wr_data_en_S3_f <= mshr_wr_data_en_S2;
        mshr_wr_state_en_S3_f <= mshr_wr_state_en_S2;
        mshr_state_in_S3_f <= mshr_state_in_S2;
        mshr_pending_index_S3_f <= mshr_pending_index_S2_f;
        special_addr_type_S3_f <= special_addr_type_S2_f;
        req_recycle_S3_f <= req_recycle_S2;
    end
end


//============================
// Stage 3
//============================

reg stall_pre_S3;
reg stall_before_S3_f;
reg stall_before_S3_next;
reg req_recycle_S3;
reg req_recycle_cur_S3;
reg req_recycle_buf_S3_f;
reg req_recycle_buf_S3_next;

always @ *
begin
    stall_before_S3 = stall_before_S3_f;
    valid_S3 = valid_S3_f;
end



always @ *
begin
    req_recycle_cur_S3 = valid_S3 && (req_recycle_S3_f
     || (state_wr_en_S3_f
        && ((pipe2_valid_S1 && (pipe2_msg_type_S1 == 8'd12)
            && (addr_S3[39:6] == pipe2_addr_S1[39:6]))
        ||  (pipe2_valid_S2 && (pipe2_msg_type_S2 == 8'd12)
            && (addr_S3[39:6] == pipe2_addr_S2[39:6]))
        ||  (pipe2_valid_S3 && (pipe2_msg_type_S3 == 8'd12)
            && (addr_S3[39:6] == pipe2_addr_S3[39:6])))));
end

always @ *
begin
    if (!rst_n)
    begin
        req_recycle_buf_S3_next = 1'b0;
    end
    else
    begin
        if (!stall_S3)
        begin
            req_recycle_buf_S3_next = 1'b0;
        end
        else if (req_recycle_cur_S3)
        begin
            req_recycle_buf_S3_next = 1'b1;
        end
        else
        begin
            req_recycle_buf_S3_next = req_recycle_buf_S3_f;
        end
    end
end


always @ (posedge clk)
begin
    req_recycle_buf_S3_f <= req_recycle_buf_S3_next;
end


always @ *
begin
    req_recycle_S3 = req_recycle_cur_S3 | req_recycle_buf_S3_f;
end




always @ *
begin
    stall_pre_S3 = stall_S4;
    //stall_pre_S3 = stall_S4 || global_stall_S3;
end

always @ *
begin
    if (!rst_n)
    begin
        stall_before_S3_next = 0;
    end
    else
    begin
        stall_before_S3_next = stall_S3;
    end
end

//used to switch buffered output from arrays
always @ (posedge clk)
begin
    stall_before_S3_f <= stall_before_S3_next;
end



always @ *
begin
    stall_S3 = stall_pre_S3;
end



reg valid_S3_next;

always @ *
begin
    valid_S3_next = valid_S3 && !stall_S3;
end


//============================
// Stage 3 -> Stage 4
//============================

reg valid_S4_f;
reg [3-1:0] data_size_S4_f;
reg [1-1:0] cache_type_S4_f;
reg msg_from_mshr_S4_f;
reg [2-1:0] l2_load_data_subline_S4_f;
reg [2-1:0] state_mesi_S4_f;
reg [1-1:0] l2_miss_S4_f;

reg mshr_smc_miss_S4_f;

reg state_wr_en_S4_f;
reg mshr_wr_data_en_S4_f;
reg mshr_wr_state_en_S4_f;
reg [2-1:0] mshr_state_in_S4_f;
reg [3-1:0] mshr_pending_index_S4_f;
reg special_addr_type_S4_f;
reg [64-1:0] dir_data_S4_f;
reg req_recycle_S4_f;


always @ (posedge clk)
begin
    if (!rst_n)
    begin
        valid_S4_f <= 1'b0;
        msg_type_S4_f <= 0;
        data_size_S4_f <= 0;
        cache_type_S4_f <= 0;
        msg_from_mshr_S4_f <= 0;
        l2_load_data_subline_S4_f <= 0;
        state_mesi_S4_f <= 0;
        l2_miss_S4_f <= 0;
        
        mshr_smc_miss_S4_f <= 0;
        
        state_wr_en_S4_f <= 0;
        mshr_wr_data_en_S4_f <= 0;
        mshr_wr_state_en_S4_f <= 0;
        mshr_state_in_S4_f <= 0;
        mshr_pending_index_S4_f <= 0;
        special_addr_type_S4_f <= 0;
        dir_data_S4_f <= 0;
        req_recycle_S4_f <= 0;
    end
    else if (!stall_S4)
    begin
        valid_S4_f <= valid_S3_next;
        msg_type_S4_f <= msg_type_S3_f;
        data_size_S4_f <= data_size_S3_f;
        cache_type_S4_f <= cache_type_S3_f;
        msg_from_mshr_S4_f <= msg_from_mshr_S3_f;
        l2_load_data_subline_S4_f <= l2_load_data_subline_S3_f;
        state_mesi_S4_f <= state_mesi_S3_f;
        l2_miss_S4_f <= l2_miss_S3_f;
        
        mshr_smc_miss_S4_f <= mshr_smc_miss_S3_f;
        
        state_wr_en_S4_f <= state_wr_en_S3_f;
        mshr_wr_data_en_S4_f <= mshr_wr_data_en_S3_f;
        mshr_wr_state_en_S4_f <= mshr_wr_state_en_S3_f;
        mshr_state_in_S4_f <= mshr_state_in_S3_f;
        mshr_pending_index_S4_f <= mshr_pending_index_S3_f;
        special_addr_type_S4_f <= special_addr_type_S3_f;
        dir_data_S4_f <= dir_data_S3;
        req_recycle_S4_f <= req_recycle_S3;
    end
end


//============================
// Stage 4
//============================

reg stall_before_S4_f;
reg stall_before_S4_next;
reg dir_data_stall_S4;
reg state_wr_en_real_S4;
reg stall_inv_counter_S4;
reg msg_stall_S4;
reg load_store_mem_S4;

reg smc_stall_S4;
reg broadcast_stall_S4;

reg req_recycle_cur_S4;
reg req_recycle_buf_S4_f;
reg req_recycle_buf_S4_next;

reg [8-1:0] addr_type_S4;
reg [2-1:0] addr_op_S4;

reg msg0_send_valid_S4;
reg [8-1:0] msg0_send_type_S4;
reg msg1_send_valid_S4;
reg [8-1:0] msg1_send_type_S4;
//reg msg_send_valid_pre_S4;
//reg [`MSG_TYPE_WIDTH-1:0] msg_send_type_pre_S4;


reg smc_rd_diag_en_S4;
reg smc_rd_en_S4;


reg mshr_inv_flag_S4;

always @ *
begin
    valid_S4 = valid_S4_f;
    stall_before_S4 = stall_before_S4_f;
    msg_type_S4 = msg_type_S4_f;
    data_size_S4 = data_size_S4_f;
    cache_type_S4 = cache_type_S4_f;
    l2_miss_S4 = l2_miss_S4_f;
    special_addr_type_S4 = special_addr_type_S4_f;
    dir_data_S4 = dir_data_S4_f;
    msg_from_mshr_S4 = msg_from_mshr_S4_f;
end


always @ *
begin
    if (~special_addr_type_S4_f && req_recycle_S4)
    begin
        mshr_state_in_S4 = 2'd2;
    end
    else if(mshr_inv_flag_S4)
    begin
        mshr_state_in_S4 = 2'd0;
    end
    else
    begin
        mshr_state_in_S4 = mshr_state_in_S4_f;
    end
end

always @ *
begin
    req_recycle_cur_S4 = valid_S4 && (req_recycle_S4_f
     || (state_wr_en_S4_f
        && ((pipe2_valid_S1 && (pipe2_msg_type_S1 == 8'd12)
            && (addr_S4[39:6] == pipe2_addr_S1[39:6]))
        ||  (pipe2_valid_S2 && (pipe2_msg_type_S2 == 8'd12)
            && (addr_S4[39:6] == pipe2_addr_S2[39:6]))
        ||  (pipe2_valid_S3 && (pipe2_msg_type_S3 == 8'd12)
            && (addr_S4[39:6] == pipe2_addr_S3[39:6])))));
end

always @ *
begin
    if (!rst_n)
    begin
        req_recycle_buf_S4_next = 1'b0;
    end
    else
    begin
        if (!stall_S4)
        begin
            req_recycle_buf_S4_next = 1'b0;
        end
        else if (req_recycle_cur_S4)
        begin
            req_recycle_buf_S4_next = 1'b1;
        end
        else
        begin
            req_recycle_buf_S4_next = req_recycle_buf_S4_f;
        end
    end
end


always @ (posedge clk)
begin
    req_recycle_buf_S4_f <= req_recycle_buf_S4_next;
end


always @ *
begin
    req_recycle_S4 = req_recycle_cur_S4 | req_recycle_buf_S4_f;
end




reg smc_rd_diag_en_buf_S4_next;
reg smc_rd_en_buf_S4_next;
reg smc_rd_diag_en_buf_S4_f;
reg smc_rd_en_buf_S4_f;

always @ *
begin
    if (!rst_n)
    begin
        smc_rd_diag_en_buf_S4_next = 0;
        smc_rd_en_buf_S4_next = 0;
    end
    else if (!stall_smc_buf_S4)
    begin
        smc_rd_diag_en_buf_S4_next = smc_rd_diag_en_S4;
        smc_rd_en_buf_S4_next = smc_rd_en_S4;
    end
    else
    begin
        smc_rd_diag_en_buf_S4_next = smc_rd_diag_en_buf_S4_f;
        smc_rd_en_buf_S4_next = smc_rd_en_buf_S4_f;
    end
end

always @ (posedge clk)
begin
    smc_rd_diag_en_buf_S4_f <= smc_rd_diag_en_buf_S4_next;
    smc_rd_en_buf_S4_f <= smc_rd_en_buf_S4_next;
end


always @ *
begin
    smc_rd_diag_en_buf_S4 = smc_rd_diag_en_buf_S4_f;
    smc_rd_en_buf_S4 = smc_rd_en_buf_S4_f;
end
/*
reg smc_hit_buf_S4_next;
reg smc_hit_buf_S4_f;

always @ *
begin
    if (!rst_n)
    begin
        smc_hit_buf_S4_next = 0;
    end
    else if (!stall_smc_buf_S4)
    begin
        smc_hit_buf_S4_next = smc_hit_S4;
    end
    else
    begin
        smc_hit_buf_S4_next = smc_hit_buf_S4_f;
    end
end

always @ (posedge clk)
begin
    smc_hit_buf_S4_f <= smc_hit_buf_S4_next;
end
*/



always @ *
begin
    if(valid_S4)
        begin
        if (~special_addr_type_S4_f && req_recycle_S4)
        begin
            mshr_wr_data_en_S4 = ~stall_S4;
            mshr_wr_state_en_S4 = ~stall_S4;
            mshr_inv_flag_S4 = 1'b0;
        end
        else if (load_store_mem_S4)
        begin
            mshr_wr_data_en_S4 = msg_send_valid_S4 && (msg_send_type_S4 == msg0_send_type_S4) && msg_send_ready_S4;
            mshr_wr_state_en_S4 = msg_send_valid_S4 && (msg_send_type_S4 == msg0_send_type_S4) && msg_send_ready_S4;
            mshr_inv_flag_S4 = 1'b0;
        end
        else if (msg_send_type_S4 == 8'd18)
        begin
            mshr_wr_data_en_S4 = ((msg_send_valid_S4 && msg_send_ready_S4 && (dir_sharer_counter_S4 == 1)) || (~stall_S4))
                              && mshr_wr_data_en_S4_f;
            mshr_wr_state_en_S4 = ((msg_send_valid_S4 && msg_send_ready_S4 && (dir_sharer_counter_S4 == 1)) || (~stall_S4))
                               && mshr_wr_state_en_S4_f;
            mshr_inv_flag_S4 = 1'b0;
        end
        else if ((msg_type_S4 == 8'd13) && l2_tag_hit_S4
              && (l2_way_state_mesi_S4 == 2'b10) && l2_way_state_subline_S4[addr_S4[5:4]]
              && req_from_owner_S4)
        begin
            mshr_wr_data_en_S4 = ~stall_S4;
            mshr_wr_state_en_S4 = ~stall_S4;
            mshr_inv_flag_S4 = 1'b0;
        end
        
        else if (csm_en && mshr_smc_miss_S4_f && (~mshr_wr_state_en_S4_f))
        begin
            mshr_wr_data_en_S4 = 1'b0;
            mshr_wr_state_en_S4 = ~stall_S4;
            mshr_inv_flag_S4 = 1'b1;
        end
        
        else
        begin
            mshr_wr_data_en_S4 = ~stall_S4 && mshr_wr_data_en_S4_f;
            mshr_wr_state_en_S4 = ~stall_S4 && mshr_wr_state_en_S4_f;
            mshr_inv_flag_S4 = 1'b0;
        end
    end
    else
    begin
        mshr_wr_data_en_S4 = 1'b0;
        mshr_wr_state_en_S4 = 1'b0;
        mshr_inv_flag_S4 = 1'b0;
    end
end

always @ *
begin
    if (valid_S4 && (!req_recycle_S4) && (msg_send_type_S4 == 8'd18)
     && (msg_send_valid_S4 && msg_send_ready_S4 && (dir_sharer_counter_S4 == 1) && stall_S4)
     && mshr_wr_data_en_S4_f)
    begin
        inv_fwd_pending_S4 = 1'b1;
    end
    else
    begin
        inv_fwd_pending_S4 = 1'b0;
    end
end

always @ *
begin
    addr_type_S4 = addr_S4[39:32];
    addr_op_S4 = addr_S4[31:30];
end



always @ *
begin
    if (!rst_n)
    begin
        stall_before_S4_next = 0;
    end
    else
    begin
        stall_before_S4_next = stall_S4;
    end
end

//used to switch buffered output from arrays
always @ (posedge clk)
begin
    stall_before_S4_f <= stall_before_S4_next;
end


reg [19-1:0] cs_S4;

always @ *
begin
    if (valid_S4)
    begin
        if (special_addr_type_S4_f)
        begin
            if (msg_type_S4_f == 8'd15)
            begin
                //       msg        msg0        msg0                   msg1        msg1
                //       send_fwd   send_en     send_type              send_en     send_type
                cs_S4 = {n,         y,          8'd28,  n,          8'd30};
            end
            else
            begin
                cs_S4 = {n,         y,          8'd29,  n,          8'd30};
            end
        end
        else if(req_recycle_S4)
        begin
            cs_S4 = {19{1'b0}};
        end
        else
        begin
            if (msg_type_S4_f == 8'd32)
            begin
                cs_S4 = {n,         y,          8'd33,    n,          8'd30};
            end
            else if (msg_type_S4_f == 8'd8)
            begin
                cs_S4 = {n,         n,          8'd30,    n,          8'd30};
            end
            else if (msg_type_S4_f == 8'd13)
            begin
                cs_S4 = {n,         n,          8'd30,    n,          8'd30};
            end
            else if (l2_evict_S4)
            begin
                begin
                    case (l2_way_state_mesi_S4)
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,    n,          8'd30};
                    end
                    2'b00:
                    begin
                        case (l2_way_state_vd_S4)
                        2'b10:
                        begin
                            if (msg_type_S4_f == 8'd34)
                            begin
                                cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                            end
                            else if (msg_type_S4_f == 8'd14)
                            begin
                                //TODO
                                //cs_S4 = {y,          `MSG_TYPE_NC_LOAD_REQ,    n,          `MSG_TYPE_ERROR};
                                


                                    cs_S4 = {n,         y,          8'd19,    n,          8'd30};
                                
                            end
                            else
                            begin
                                cs_S4 = {n,         y,          8'd19,    n,          8'd30};
                            end
                        end
                        2'b11:
                        begin
                            if (msg_type_S4_f == 8'd34)
                            begin
                                cs_S4 = {n,         y,          8'd29,    y,          8'd20};
                            end
                            else if (msg_type_S4_f == 8'd14)
                            begin
                                //TODO
                                //cs_S4 = {y,          `MSG_TYPE_NC_LOAD_REQ,    y,          `MSG_TYPE_STORE_MEM};
                                


                                    cs_S4 = {n,         y,          8'd19,    y,          8'd20};
                                
                            end
                            else
                            begin
                                cs_S4 = {n,         y,          8'd19,    y,          8'd20};
                            end
                        end
                        default:
                        begin
                            cs_S4 = {19{1'bx}};
                        end
                        endcase
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
            end

            else if (!l2_tag_hit_S4)
            begin
                begin
                    if (msg_type_S4_f == 8'd35 || msg_type_S4_f == 8'd34)
                    begin
                        cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                    end
                    else if (msg_type_S4_f == 8'd15)
                    begin
                        if (msg_from_mshr_S4_f)
                        begin
                            //       msg         msg0        msg0                   msg1        msg1
                            //       send_fwd    send_en     send_type              send_en     send_type
                            cs_S4 = {n,          y,          8'd28,  n,          8'd30};
                        end
                        else
                        begin
                            cs_S4 = {n,          y,          8'd15,n,          8'd30};
                        end
                    end
                    else if (msg_type_S4_f == 8'd14)
                    begin
                        //TODO
                        //cs_S4 = {y,          `MSG_TYPE_NC_LOAD_REQ,    n,          `MSG_TYPE_ERROR};
                        


                            cs_S4 = {n,         y,          8'd19,    n,          8'd30};
                        
                    end
                    else
                    begin
                        cs_S4 = {n,         y,          8'd19,    n,          8'd30};
                    end
                end
            end

            else begin
            case (msg_type_S4_f)
                //TODO
                8'd35, 8'd34:
                begin
                   case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        case (l2_way_state_vd_S4)
                        2'b10:
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        2'b11:
                        begin
                            cs_S4 = {n,         y,          8'd29,    y,          8'd20};
                        end
                        default:
                        begin
                            cs_S4 = {19{1'bx}};
                        end
                        endcase
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,   n,          8'd30};
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
                8'd15:
                begin
                   case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        case (l2_way_state_vd_S4)
                        2'b10:
                        begin
                            cs_S4 = {n,         y,          8'd15,    n,          8'd30};
                        end
                        2'b11:
                        begin
                            cs_S4 = {n,         y,          8'd20,    n,          8'd30};
                        end
                        default:
                        begin
                            cs_S4 = {19{1'bx}};
                        end
                        endcase
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,   n,          8'd30};
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end

                8'd14:
                begin
                   case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        case (l2_way_state_vd_S4)
                        2'b10:
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        2'b11:
                        begin
                            cs_S4 = {n,         y,          8'd20,    n,          8'd30};
                        end
                        default:
                        begin
                            cs_S4 = {19{1'bx}};
                        end
                        endcase
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,   n,          8'd30};
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
                8'd31:
                begin
                    case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                    end
                    2'b01, 2'b11:
                    begin
                        if (cache_type_S4_f == l2_way_state_cache_type_S4)
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        else
                        begin
                            cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                        end
                    end
                    2'b10:
                    begin
                        if (req_from_owner_S4 && (cache_type_S4_f == l2_way_state_cache_type_S4))
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        else if (cache_type_S4_f != l2_way_state_cache_type_S4)
                        begin
                            cs_S4 = {y,         y,          8'd17,   n,          8'd30};
                        end
                        else
                        begin
                            cs_S4 = {y,         y,          8'd16,   n,          8'd30};
                        end
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
                8'd60:   // Jsut same as a store req
                begin
                    case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                    end
                    2'b01:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        if (req_from_owner_S4 && (cache_type_S4_f == l2_way_state_cache_type_S4))
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        else
                        begin
                            cs_S4 = {y,         y,          8'd17,    n,          8'd30};
                        end
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
                8'd1:
                begin
                    cs_S4 = {n,         y,          8'd28,    n,          8'd30};
                end

                8'd2:
                begin
                    case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        if (req_from_owner_S4 && (cache_type_S4_f == l2_way_state_cache_type_S4))
                        begin
                            cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                        end
                        else
                        begin
                            cs_S4 = {y,         y,          8'd17,    n,          8'd30};
                        end
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end
                8'd6, 8'd10,
                8'd44,
                8'd45,
                8'd46,
                8'd47,
                8'd48,
                8'd49,
                8'd50,
                8'd51:
                begin
                    case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        cs_S4 = {n,         y,          8'd29,    n,          8'd30};
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,    n,          8'd30};
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end

                8'd7, 8'd11,
                8'd52,
                8'd53,
                8'd54,
                8'd55,
                8'd56,
                8'd57,
                8'd58,
                8'd59:
                begin
                    case (l2_way_state_mesi_S4)
                    2'b00:
                    begin
                        cs_S4 = {n,         n,          8'd30,    n,          8'd30};
                    end
                    2'b01, 2'b11:
                    begin
                        cs_S4 = {y,         y,          8'd18,    n,          8'd30};
                    end
                    2'b10:
                    begin
                        cs_S4 = {y,         y,          8'd17,    n,          8'd30};
                    end
                    default:
                    begin
                        cs_S4 = {19{1'bx}};
                    end
                    endcase
                end

                default:
                begin
                    cs_S4 = {19{1'bx}};
                end
            endcase
            end
        end
    end
    else
    begin
        cs_S4 = {19{1'b0}};
    end
end




always @ *
begin
    msg0_send_valid_S4 = !(global_stall_S4 || stall_inv_counter_S4 || smc_stall_S4 || broadcast_stall_S4) && cs_S4[17];
    msg0_send_type_S4 = cs_S4[16:9];
    msg1_send_valid_S4 = !(global_stall_S4 || stall_inv_counter_S4|| smc_stall_S4 || broadcast_stall_S4) && cs_S4[8];
    msg1_send_type_S4 = cs_S4[7:0];
end











always @ *
begin
    load_store_mem_S4 = cs_S4[17] && cs_S4[8] &&
                       (msg0_send_type_S4 == 8'd19 || msg0_send_type_S4 == 8'd14)
                     &&(msg1_send_type_S4 == 8'd20);
end

localparam msg_state_0 = 1'b0;
localparam msg_state_1 = 1'b1;

reg msg_state_S4_f;
reg msg_state_S4_next;



always @ *
begin
    if (!rst_n)
    begin
        msg_state_S4_next = msg_state_0;
    end
    else if (msg0_send_valid_S4 && msg1_send_valid_S4 && valid_S4
    && !(dir_data_stall_S4 || smc_stall_S4 || (msg_send_valid_S4 && !msg_send_ready_S4) || global_stall_S4 || broadcast_stall_S4))
    begin
        if (msg_state_S4_f == msg_state_0)
        begin
            msg_state_S4_next = msg_state_1;
        end
        else
        begin
            if (l2_load_data_subline_S4_f == 2'd3)
            begin
                msg_state_S4_next = msg_state_0;
            end
            else
            begin
                msg_state_S4_next = msg_state_1;
            end
        end
    end
    else
    begin
        msg_state_S4_next = msg_state_S4_f;
    end
end



































always @ (posedge clk)
begin
    msg_state_S4_f <= msg_state_S4_next;
end

always @ *
begin
    if (msg_state_S4_f == msg_state_0)
    begin
        msg_send_valid_S4 = msg0_send_valid_S4;
        msg_send_type_pre_S4 = msg0_send_type_S4;
    end
    else
    begin
        msg_send_valid_S4 = msg1_send_valid_S4;
        msg_send_type_pre_S4 = msg1_send_type_S4;
    end
end


always @ *
begin
    if (smc_miss_S4)
    begin
        msg_send_type_S4 = 8'd14;
    end
    else
    begin
        msg_send_type_S4 = msg_send_type_pre_S4;
    end
end








//stall signal for one cycle delay of smc array read to meet timing
/*
always @ *
begin
    if (msg_state_S4_f == msg_state_0)
    begin
        msg_send_valid_pre_S4 = msg0_send_valid_S4;
        msg_send_type_S4 = msg0_send_type_S4;
    end
    else
    begin
        msg_send_valid_pre_S4 = msg1_send_valid_S4;
        msg_send_type_S4 = msg1_send_type_S4;
    end
end
*/


localparam smc_state_0 = 1'b0;
localparam smc_state_1 = 1'b1;

reg smc_state_S4_f;
reg smc_state_S4_next;

always @ *
begin
    if (!rst_n)
    begin
        smc_state_S4_next = smc_state_0;
    end
    else if (smc_rd_en_S4 && (~stall_smc_buf_S4))
    begin
        if (smc_state_S4_f == smc_state_0)
        begin
            smc_state_S4_next = smc_state_1;
        end
        else
        begin
            smc_state_S4_next = smc_state_0;
        end
    end
    else
    begin
        smc_state_S4_next = smc_state_S4_f;
    end
end

always @ (posedge clk)
begin
    smc_state_S4_f <= smc_state_S4_next;
end

always @ *
begin
    smc_stall_S4 = smc_rd_en_S4 && (smc_state_S4_f == smc_state_0);
end

/*
always @ *
begin
    msg_send_valid_S4 = msg_send_valid_pre_S4 && (~smc_stall_S4);
end
*/

reg [3-1:0] mshr_empty_index_buf_S4_f;
reg [3-1:0] mshr_empty_index_buf_S4_next;
reg [3-1:0] mshr_empty_index_sel_S4;

always @ *
begin
    if (stall_before_S4_f)
    begin
        mshr_empty_index_sel_S4 = mshr_empty_index_buf_S4_f;
    end
    else
    begin
        mshr_empty_index_sel_S4 = mshr_empty_index_S4;
    end
end

always @ *
begin
    if (!rst_n)
    begin
        mshr_empty_index_buf_S4_next = {3{1'b0}};
    end
    else if (stall_S4 && !stall_before_S4_f)
    begin
        mshr_empty_index_buf_S4_next = mshr_empty_index_S4;
    end
    else
    begin
        mshr_empty_index_buf_S4_next = mshr_empty_index_buf_S4_f;
    end
end


always @ (posedge clk)
begin
    mshr_empty_index_buf_S4_f <= mshr_empty_index_buf_S4_next;
end



always @ *
begin
    if (msg_send_valid_S4)
    begin
        case (msg_send_type_S4)
        8'd16, 8'd17, 8'd18:
        begin
            msg_send_mode_S4 = 3'd4;
            msg_send_length_S4 = 8'd2;
            msg_send_data_size_S4 = 3'b101;
            msg_send_cache_type_S4 = l2_way_state_cache_type_S4;
            msg_send_mshrid_S4 = mshr_wr_index_in_S4;
        end
        8'd28:
        begin
            msg_send_mode_S4 = 3'd1;
            msg_send_length_S4 = 8'd0;
            msg_send_data_size_S4 = 3'b000;
            msg_send_cache_type_S4 = cache_type_S4_f;
            msg_send_mshrid_S4 = mshrid_S4;
        end
        8'd29:
        begin
            // For DATA_ACK, data_size field is not used
            if (special_addr_type_S4_f)
            begin
                msg_send_mode_S4 = 3'd3;
                msg_send_length_S4 = 8'd2;
                // msg_send_data_size_S4 = data_size_S4_f;
                msg_send_cache_type_S4 = cache_type_S4_f;
                msg_send_mshrid_S4 = mshrid_S4;
            end






























            else if (cache_type_S4_f == 1'b0)
            begin
                msg_send_mode_S4 = 3'd3;
                msg_send_length_S4 = 8'd2;
                // msg_send_data_size_S4 = `MSG_DATA_SIZE_16B;
                msg_send_cache_type_S4 = cache_type_S4_f;
                msg_send_mshrid_S4 = mshrid_S4;
            end
            else
            begin
                // ifill ack
                msg_send_length_S4 = 8'd4;
                // msg_send_data_size_S4 = `MSG_DATA_SIZE_32B;
                msg_send_cache_type_S4 = cache_type_S4_f;
                msg_send_mshrid_S4 = mshrid_S4;
                if (l2_load_data_subline_S4_f == 2'd0)
                begin
                    msg_send_mode_S4 = 3'd3;
                end
                else
                begin
                    msg_send_mode_S4 = 3'd7;
                end
            end

        end
        8'd19:
        begin
            msg_send_mode_S4 = 3'd4;
            msg_send_length_S4 = 8'd2;



            msg_send_data_size_S4 = data_size_S4_f;

            msg_send_cache_type_S4 = 1'b0;
            msg_send_mshrid_S4 = mshr_wr_index_in_S4;
        end
        8'd14:
        begin
            msg_send_mode_S4 = 3'd4;
            msg_send_length_S4 = 8'd2;



            msg_send_data_size_S4 = data_size_S4_f;



            if (smc_miss_S4)
            begin
                msg_send_data_size_S4 = 3'b101;
            end

            msg_send_cache_type_S4 = cache_type_S4_f;
            msg_send_mshrid_S4 = mshr_wr_index_in_S4;
        end

        8'd15:
        begin
            msg_send_mode_S4 = 3'd5;
            msg_send_length_S4 = 8'd3;
            msg_send_data_size_S4 = data_size_S4_f;
            msg_send_cache_type_S4 = cache_type_S4_f;
            msg_send_mshrid_S4 = mshr_wr_index_in_S4;
        end
        8'd33:
        begin
            msg_send_mode_S4 = 3'd2;
            msg_send_length_S4 = 8'd1;
            msg_send_data_size_S4 = data_size_S4_f;
            msg_send_cache_type_S4 = cache_type_S4_f;
            msg_send_mshrid_S4 = mshrid_S4;
        end

        8'd20:
        begin
            msg_send_length_S4 = 8'd10;



            msg_send_data_size_S4 = data_size_S4_f;

            msg_send_cache_type_S4 = 1'b0;
            msg_send_mshrid_S4 = mshr_wr_index_in_S4;
            if (l2_load_data_subline_S4_f == 2'd0)
            begin
                msg_send_mode_S4 = 3'd6;
            end
            else
            begin
                msg_send_mode_S4 = 3'd7;
            end
        end
        default:
        begin
            msg_send_mode_S4 = 3'd0;
            msg_send_length_S4 = 8'd0;
            msg_send_data_size_S4 = 3'b000;
            msg_send_cache_type_S4 = 1'b0;
            msg_send_mshrid_S4 = mshrid_S4;
        end
        endcase
    end
    else
    begin
        msg_send_mode_S4 = 3'd0;
        msg_send_length_S4 = 8'd0;
        msg_send_data_size_S4 = 3'b000;
        msg_send_cache_type_S4 = 1'b0;
        msg_send_mshrid_S4 = mshrid_S4;
    end
end

always @ *
begin
    msg_send_l2_miss_S4 = l2_miss_S4_f;
end

always @ *
begin
    if ((msg_send_type_S4 == 8'd33)
    || special_addr_type_S4_f
    || ((msg_type_S4_f == 8'd15) && !l2_tag_hit_S4))
    begin
        msg_send_subline_vector_S4 = {4{1'b0}};
    end
    else if (msg_send_type_S4 == 8'd18)
    begin
        msg_send_subline_vector_S4 = {4{1'b1}};
    end
    else
    begin
        msg_send_subline_vector_S4 = l2_way_state_subline_S4;
    end
end


always @ *
begin
    if ((msg_type_S4_f == 8'd2 || msg_type_S4_f == 8'd60) && msg_send_type_S4 == 8'd29)
    begin
        msg_send_mesi_S4 = 2'b11;
    end
    else if ((msg_send_type_S4 == 8'd33)
    || special_addr_type_S4_f
    || ((msg_type_S4_f == 8'd15) && !l2_tag_hit_S4))
    begin
        msg_send_mesi_S4 = 2'b00;
    end
    else
    begin
        if (state_mesi_S4_f == 2'b11)
        begin
            msg_send_mesi_S4 = 2'b01;
        end
        else
        begin
            msg_send_mesi_S4 = state_mesi_S4_f;
        end
    end
end

always @ *
begin
    l2_access_valid_S4 = valid_S4 && !stall_S4 && msg_send_valid_S4
                     && (msg_send_type_S4 == 8'd29 || msg_send_type_S4 == 8'd28);
end


always @ *
begin
    l2_miss_valid_S4 = l2_access_valid_S4 && msg_send_l2_miss_S4;
end


always @ *
begin
    msg_stall_S4 = msg0_send_valid_S4 && msg1_send_valid_S4
               && (msg_state_S4_f == msg_state_0);
end


reg [64-1:0] dir_data_buf_S4_f;
reg [64-1:0] dir_data_buf_S4_next;
reg [64-1:0] dir_data_trans_S4;

always @ *
begin
    if (stall_before_S4_f)
    begin
        dir_data_sel_S4 = dir_data_buf_S4_f;
    end
    else
    begin
        
        if(mshr_smc_miss_S4_f)
        begin
            //continue invalidation in the middle of the sharer list
            dir_data_sel_S4 = (dir_data_S4 >> mshr_miss_lsid_S4) << mshr_miss_lsid_S4;
        end
        else
        
        begin
            dir_data_sel_S4 = dir_data_S4;
        end
    end
end


always @ *
begin
    if (!rst_n)
    begin
        dir_data_buf_S4_next = {64{1'b0}};
    end
    else if ((stall_S4 && !stall_before_S4_f) && (msg_send_type_pre_S4 == 8'd18) && (l2_way_state_mesi_S4 != 2'b11))
    begin
        if (msg_stall_S4 || smc_stall_S4 || (msg_send_valid_S4 && !msg_send_ready_S4)
         || global_stall_S4 || stall_inv_counter_S4 )
        begin
            if(mshr_smc_miss_S4_f)
            begin
                dir_data_buf_S4_next = (dir_data_S4 >> mshr_miss_lsid_S4) << mshr_miss_lsid_S4;
            end
            else
            begin
                dir_data_buf_S4_next = dir_data_S4;
            end
        end
        else
        begin
            dir_data_buf_S4_next = dir_data_trans_S4;
        end
    end
    else if (!((msg_send_valid_S4 && !msg_send_ready_S4) || global_stall_S4 || smc_stall_S4 || broadcast_stall_S4
             || stall_inv_counter_S4) && dir_data_stall_S4)
    begin
        dir_data_buf_S4_next = dir_data_trans_S4;
    end
    else
    begin
        dir_data_buf_S4_next = dir_data_buf_S4_f;
    end
end































always @ (posedge clk)
begin
    dir_data_buf_S4_f <= dir_data_buf_S4_next;
end

wire [64-1:0] dir_sharer_mask_S4;
wire nonzero_sharer_S4;


l2_priority_encoder_6 priority_encoder_6bits( 

    .data_in        (dir_data_sel_S4),
    .data_out       (dir_sharer_S4),
    .data_out_mask  (dir_sharer_mask_S4),
    .nonzero_out    (nonzero_sharer_S4)
);

/*
always @ *
begin
    dir_sharer_mask_S4 = {`L2_DIR_ARRAY_WIDTH{1'b1}};
    dir_sharer_mask_S4[dir_sharer_S4] = 1'b0;
end
*/
//decode sharers from the sharer list with priority decoder
/*
always @ *
begin
    dir_sharer_S4 = {`L2_OWNER_BITS{1'b0}};
    dir_sharer_mask_S4 = {`L2_DIR_ARRAY_WIDTH{1'b0}};
    if (dir_data_sel_S4[0])
    begin
        dir_sharer_S4 = 6'd0;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000000001;
    end
    else if (dir_data_sel_S4[1])
    begin
        dir_sharer_S4 = 6'd1;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000000010;
    end
    else if (dir_data_sel_S4[2])
    begin
        dir_sharer_S4 = 6'd2;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000000100;
    end
    else if (dir_data_sel_S4[3])
    begin
        dir_sharer_S4 = 6'd3;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000001000;
    end
    else if (dir_data_sel_S4[4])
    begin
        dir_sharer_S4 = 6'd4;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000010000;
    end
    else if (dir_data_sel_S4[5])
    begin
        dir_sharer_S4 = 6'd5;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000000100000;
    end
    else if (dir_data_sel_S4[6])
    begin
        dir_sharer_S4 = 6'd6;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000001000000;
    end
    else if (dir_data_sel_S4[7])
    begin
        dir_sharer_S4 = 6'd7;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000010000000;
    end
    else if (dir_data_sel_S4[8])
    begin
        dir_sharer_S4 = 6'd8;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000000100000000;
    end
    else if (dir_data_sel_S4[9])
    begin
        dir_sharer_S4 = 6'd9;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000001000000000;
    end
    else if (dir_data_sel_S4[10])
    begin
        dir_sharer_S4 = 6'd10;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000010000000000;
    end
    else if (dir_data_sel_S4[11])
    begin
        dir_sharer_S4 = 6'd11;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000000100000000000;
    end
    else if (dir_data_sel_S4[12])
    begin
        dir_sharer_S4 = 6'd12;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000001000000000000;
    end
    else if (dir_data_sel_S4[13])
    begin
        dir_sharer_S4 = 6'd13;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000010000000000000;
    end
    else if (dir_data_sel_S4[14])
    begin
        dir_sharer_S4 = 6'd14;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000000100000000000000;
    end
    else if (dir_data_sel_S4[15])
    begin
        dir_sharer_S4 = 6'd15;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000001000000000000000;
    end
    else if (dir_data_sel_S4[16])
    begin
        dir_sharer_S4 = 6'd16;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000010000000000000000;
    end
    else if (dir_data_sel_S4[17])
    begin
        dir_sharer_S4 = 6'd17;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000000100000000000000000;
    end
    else if (dir_data_sel_S4[18])
    begin
        dir_sharer_S4 = 6'd18;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000001000000000000000000;
    end
    else if (dir_data_sel_S4[19])
    begin
        dir_sharer_S4 = 6'd19;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000010000000000000000000;
    end
    else if (dir_data_sel_S4[20])
    begin
        dir_sharer_S4 = 6'd20;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000000100000000000000000000;
    end
    else if (dir_data_sel_S4[21])
    begin
        dir_sharer_S4 = 6'd21;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000001000000000000000000000;
    end
    else if (dir_data_sel_S4[22])
    begin
        dir_sharer_S4 = 6'd22;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000010000000000000000000000;
    end
    else if (dir_data_sel_S4[23])
    begin
        dir_sharer_S4 = 6'd23;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000000100000000000000000000000;
    end
    else if (dir_data_sel_S4[24])
    begin
        dir_sharer_S4 = 6'd24;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000001000000000000000000000000;
    end
    else if (dir_data_sel_S4[25])
    begin
        dir_sharer_S4 = 6'd25;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000010000000000000000000000000;
    end
    else if (dir_data_sel_S4[26])
    begin
        dir_sharer_S4 = 6'd26;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000000100000000000000000000000000;
    end
    else if (dir_data_sel_S4[27])
    begin
        dir_sharer_S4 = 6'd27;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000001000000000000000000000000000;
    end
    else if (dir_data_sel_S4[28])
    begin
        dir_sharer_S4 = 6'd28;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000010000000000000000000000000000;
    end
    else if (dir_data_sel_S4[29])
    begin
        dir_sharer_S4 = 6'd29;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000000100000000000000000000000000000;
    end
    else if (dir_data_sel_S4[30])
    begin
        dir_sharer_S4 = 6'd30;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000001000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[31])
    begin
        dir_sharer_S4 = 6'd31;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000010000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[32])
    begin
        dir_sharer_S4 = 6'd32;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000000100000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[33])
    begin
        dir_sharer_S4 = 6'd33;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000001000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[34])
    begin
        dir_sharer_S4 = 6'd34;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000010000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[35])
    begin
        dir_sharer_S4 = 6'd35;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000000100000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[36])
    begin
        dir_sharer_S4 = 6'd36;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000001000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[37])
    begin
        dir_sharer_S4 = 6'd37;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000010000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[38])
    begin
        dir_sharer_S4 = 6'd38;
        dir_sharer_mask_S4 = 64'b0000000000000000000000000100000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[39])
    begin
        dir_sharer_S4 = 6'd39;
        dir_sharer_mask_S4 = 64'b0000000000000000000000001000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[40])
    begin
        dir_sharer_S4 = 6'd40;
        dir_sharer_mask_S4 = 64'b0000000000000000000000010000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[41])
    begin
        dir_sharer_S4 = 6'd41;
        dir_sharer_mask_S4 = 64'b0000000000000000000000100000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[42])
    begin
        dir_sharer_S4 = 6'd42;
        dir_sharer_mask_S4 = 64'b0000000000000000000001000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[43])
    begin
        dir_sharer_S4 = 6'd43;
        dir_sharer_mask_S4 = 64'b0000000000000000000010000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[44])
    begin
        dir_sharer_S4 = 6'd44;
        dir_sharer_mask_S4 = 64'b0000000000000000000100000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[45])
    begin
        dir_sharer_S4 = 6'd45;
        dir_sharer_mask_S4 = 64'b0000000000000000001000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[46])
    begin
        dir_sharer_S4 = 6'd46;
        dir_sharer_mask_S4 = 64'b0000000000000000010000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[47])
    begin
        dir_sharer_S4 = 6'd47;
        dir_sharer_mask_S4 = 64'b0000000000000000100000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[48])
    begin
        dir_sharer_S4 = 6'd48;
        dir_sharer_mask_S4 = 64'b0000000000000001000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[49])
    begin
        dir_sharer_S4 = 6'd49;
        dir_sharer_mask_S4 = 64'b0000000000000010000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[50])
    begin
        dir_sharer_S4 = 6'd50;
        dir_sharer_mask_S4 = 64'b0000000000000100000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[51])
    begin
        dir_sharer_S4 = 6'd51;
        dir_sharer_mask_S4 = 64'b0000000000001000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[52])
    begin
        dir_sharer_S4 = 6'd52;
        dir_sharer_mask_S4 = 64'b0000000000010000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[53])
    begin
        dir_sharer_S4 = 6'd53;
        dir_sharer_mask_S4 = 64'b0000000000100000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[54])
    begin
        dir_sharer_S4 = 6'd54;
        dir_sharer_mask_S4 = 64'b0000000001000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[55])
    begin
        dir_sharer_S4 = 6'd55;
        dir_sharer_mask_S4 = 64'b0000000010000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[56])
    begin
        dir_sharer_S4 = 6'd56;
        dir_sharer_mask_S4 = 64'b0000000100000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[57])
    begin
        dir_sharer_S4 = 6'd57;
        dir_sharer_mask_S4 = 64'b0000001000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[58])
    begin
        dir_sharer_S4 = 6'd58;
        dir_sharer_mask_S4 = 64'b0000010000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[59])
    begin
        dir_sharer_S4 = 6'd59;
        dir_sharer_mask_S4 = 64'b0000100000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[60])
    begin
        dir_sharer_S4 = 6'd60;
        dir_sharer_mask_S4 = 64'b0001000000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[61])
    begin
        dir_sharer_S4 = 6'd61;
        dir_sharer_mask_S4 = 64'b0010000000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[62])
    begin
        dir_sharer_S4 = 6'd62;
        dir_sharer_mask_S4 = 64'b0100000000000000000000000000000000000000000000000000000000000000;
    end
    else if (dir_data_sel_S4[63])
    begin
        dir_sharer_S4 = 6'd63;
        dir_sharer_mask_S4 = 64'b1000000000000000000000000000000000000000000000000000000000000000;
    end

end
*/


reg [6-1:0] dir_sharer_counter_S4_f;
reg [6-1:0] dir_sharer_counter_S4_next;

always @ *
begin
    if (!rst_n)
    begin
        dir_sharer_counter_S4_next = 1;
    end
    else if (msg_send_valid_S4 && msg_send_ready_S4 && (msg_send_type_pre_S4 == 8'd18))
    begin
        if (dir_data_stall_S4)
        begin
            dir_sharer_counter_S4_next = dir_sharer_counter_S4_f + 1;
        end
        else
        begin
            dir_sharer_counter_S4_next = 1;
        end
    end
    else
    begin
        dir_sharer_counter_S4_next = dir_sharer_counter_S4_f;
    end
end


always @ (posedge clk)
begin
    dir_sharer_counter_S4_f <= dir_sharer_counter_S4_next;
end


always @ *
begin
    dir_sharer_counter_S4 = dir_sharer_counter_S4_f;
end

always @ *
begin
    dir_data_trans_S4 = dir_data_sel_S4 & (dir_sharer_mask_S4);
end


localparam broadcast_state_0 = 1'b0;
localparam broadcast_state_1 = 1'b1;

reg broadcast_state_S4_f;
reg broadcast_state_S4_next;

always @ *
begin
    if (!rst_n)
    begin
        broadcast_state_S4_next = broadcast_state_0;
    end
    else if (valid_S4 && (~stall_S4))
    begin
        broadcast_state_S4_next = broadcast_state_0;
    end
    else if (valid_S4 && (l2_way_state_mesi_S4 == 2'b11) && (msg_send_type_S4 == 8'd18)
         && (~(msg_stall_S4 || smc_stall_S4 || (msg_send_valid_S4 && !msg_send_ready_S4)
         || global_stall_S4 || stall_inv_counter_S4 || broadcast_stall_S4)))
    begin
        if (broadcast_state_S4_f == broadcast_state_0)
        begin
            broadcast_state_S4_next = broadcast_state_1;
        end
        else
        begin
            broadcast_state_S4_next = broadcast_state_S4_f;
        end
    end
    else
    begin
        broadcast_state_S4_next = broadcast_state_S4_f;
    end
end

always @ (posedge clk)
begin
    broadcast_state_S4_f <= broadcast_state_S4_next;
end


always @ *
begin
    broadcast_stall_S4 = (l2_way_state_mesi_S4 == 2'b11) && (msg_send_type_S4 == 8'd18)
                      && (broadcast_state_S4_f == broadcast_state_0) && (~broadcast_counter_avail_S4)
                      && (~(msg_from_mshr_S4_f && mshr_smc_miss_S4_f));
end



always @ *
begin
    broadcast_counter_op_val_S4 = valid_S4 && (~stall_smc_buf_S4) && (~smc_stall_S4) && (l2_way_state_mesi_S4 == 2'b11)
    && (msg_send_type_S4 == 8'd18) && (~((broadcast_state_S4_f == broadcast_state_1) && broadcast_counter_zero_S4));
end


always @ *
begin
    if (broadcast_counter_op_val_S4)
    begin
        broadcast_counter_op_S4 = 2'd2;
    end
    else
    begin
        broadcast_counter_op_S4 = 2'd0;
    end
end




always @ *
begin
    if (l2_way_state_mesi_S4 == 2'b11)
    begin
        dir_data_stall_S4 = (msg_send_type_S4 == 8'd18) && (~broadcast_counter_max_S4);
    end
    else
    begin
        dir_data_stall_S4 = (msg_send_type_S4 == 8'd18) && (| dir_data_trans_S4[64-1:0]);
    end
end









always @ *
begin
    state_wr_en_real_S4 = valid_S4 && !dir_data_stall_S4 &&  msg_send_valid_S4 && (msg_send_type_pre_S4 == 8'd18);
end

//write to the state array if either the enable signal of S3 or the one from S2 is true
always @ *
begin
    if (load_store_mem_S4)
    begin
        state_wr_en_S4 = msg_send_valid_S4 && (msg_send_type_S4 == msg0_send_type_S4) && msg_send_ready_S4 && ~(req_recycle_S4 && ~special_addr_type_S4_f);
    end
    else
    begin
        state_wr_en_S4 = !stall_S4 && (state_wr_en_real_S4 || state_wr_en_S4_f) && ~(req_recycle_S4 && ~special_addr_type_S4_f);
    end
end



always @ *
begin
    smc_rd_en_S4 = valid_S4 &&
                ((special_addr_type_S4_f
                && (addr_S4[39:32] == 8'ha2)
                && (msg_type_S4 == 8'd14))
                || (csm_en
//To break timing loop
//&& msg_send_valid_S4
//&& cs_S4[`CS_MSG_SEND_FWD_S4]);
                && (((msg_send_type_pre_S4 == 8'd18) && (l2_way_state_mesi_S4 != 2'b11)))));
           //     || ((msg_send_type_pre_S4 == `MSG_TYPE_LOAD_FWD || msg_send_type_pre_S4 == `MSG_TYPE_STORE_FWD)
           //        && (l2_way_state_owner_S4 != `L2_PUBLIC_SHARER))));
end

always @ *
begin
    smc_rd_diag_en_S4 =
                (special_addr_type_S4_f
                && (addr_S4[39:32] == 8'ha2)
                && (msg_type_S4 == 8'd14));
end

always @ *
begin
    smc_miss_S4 = smc_rd_en_S4  && ~smc_rd_diag_en_S4 && (~smc_hit_S4);
end


always @ *
begin
    if (msg_type_S4_f == 8'd6 && (msg_send_valid_S4 && msg_send_type_S4 == 8'd29)
    && valid_S4 && !stall_S4)
    begin
        cas_cmp_en_S4 = y;
    end
    else
    begin
        cas_cmp_en_S4 = n;
    end
end

always @ *
begin
    if ((msg_type_S4_f == 8'd6
        || msg_type_S4_f == 8'd10
        || msg_type_S4_f == 8'd44
        || msg_type_S4_f == 8'd45
        || msg_type_S4_f == 8'd46
        || msg_type_S4_f == 8'd47
        || msg_type_S4_f == 8'd48
        || msg_type_S4_f == 8'd49
        || msg_type_S4_f == 8'd50
        || msg_type_S4_f == 8'd51)
    && (msg_send_valid_S4 && msg_send_type_S4 == 8'd29)
    && valid_S4 && !stall_S4)
    begin
        atomic_read_data_en_S4 = y;
    end
    else
    begin
        atomic_read_data_en_S4 = n;
    end
end


always @ *
begin
    cas_cmp_data_size_S4 = data_size_S4_f;
end

always @ *
begin
    reg_rd_en_S4 = valid_S4  && (msg_type_S4 == 8'd14)
               && ((addr_type_S4 == 8'ha9)
                || (addr_type_S4 == 8'ha7)
                || (addr_type_S4 == 8'ha8)
                || (addr_type_S4 == 8'haa)
                || (addr_type_S4 == 8'hab));
end

always @ *
begin
    reg_rd_addr_type_S4 = addr_type_S4;
end

always @ *
begin
    if (state_wr_en_real_S4)
    begin
        state_wr_sel_S4 = 1'b1;
    end
    else
    begin
        state_wr_sel_S4 = 1'b0;
    end
end

always @ *
begin
    
    if (mshr_smc_miss_S4_f)
    begin
        mshr_wr_index_in_S4 = mshr_pending_index_S4_f;
    end
    else
    
    begin
        mshr_wr_index_in_S4 = mshr_empty_index_sel_S4;
    end
end

always @ *
begin
    mshr_inv_counter_rd_index_in_S4 = mshr_wr_index_in_S4;
end

//wait for inv_fwdack to write to mshr in pipeline2
always @ *
begin
    stall_inv_counter_S4 = valid_S4 && ((global_stall_S1 && (pipe2_msg_type_S1 == 8'd23))
                                     || (global_stall_S2 && (pipe2_msg_type_S2 == 8'd23)))
                       && (msg_send_type_pre_S4 == 8'd18);
                   //    && ~(dir_data_stall_S4|| msg_stall_S4 || global_stall_S4);
end



always @ *
begin
    stall_smc_buf_S4 = valid_S4 && (global_stall_S4
           || (msg_send_valid_S4 && !msg_send_ready_S4)
           || broadcast_stall_S4
           || stall_inv_counter_S4);
end


always @ *
begin
    stall_S4 = valid_S4 && (global_stall_S4 || msg_stall_S4 || dir_data_stall_S4
           || (msg_send_valid_S4 && !msg_send_ready_S4)
           || stall_inv_counter_S4
           || broadcast_stall_S4
           || smc_stall_S4);
end











endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe1_dpath.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The datapath for pipeline1 in the L2 cache
//
//
//==================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































// devices.xml


module l2_pipe1_dpath(

    input wire clk,
    input wire rst_n,
    
    input wire csm_en,
    
    input wire [22-1:0] smt_base_addr,

    //Inputs to Stage 1   















    //inputs from the mshr
    input wire [40-1:0] cam_mshr_addr_S1,
    input wire [8-1:0] cam_mshr_mshrid_S1,
    input wire [2-1:0] cam_mshr_way_S1,
    input wire [14-1:0] cam_mshr_src_chipid_S1,
    input wire [8-1:0] cam_mshr_src_x_S1,
    input wire [8-1:0] cam_mshr_src_y_S1,
    input wire [4-1:0] cam_mshr_src_fbits_S1,
    input wire [10-1:0] cam_mshr_sdid_S1,
    input wire [6-1:0] cam_mshr_lsid_S1,
    input wire [6-1:0] cam_mshr_miss_lsid_S1,
    input wire cam_mshr_recycled_S1,
    //inputs from the mshr
    input wire mshr_pending_S1,
    input wire [40-1:0] pending_mshr_addr_S1,
    input wire [8-1:0] pending_mshr_mshrid_S1,
    input wire [2-1:0] pending_mshr_way_S1,
    input wire [14-1:0] pending_mshr_src_chipid_S1,
    input wire [8-1:0] pending_mshr_src_x_S1,
    input wire [8-1:0] pending_mshr_src_y_S1,
    input wire [4-1:0] pending_mshr_src_fbits_S1,
    input wire [10-1:0] pending_mshr_sdid_S1,
    input wire [6-1:0] pending_mshr_lsid_S1,
    input wire [6-1:0] pending_mshr_miss_lsid_S1,
    input wire pending_mshr_recycled_S1,
 // L2_CAM_MSHR
    input wire dis_flush_S1,

    //msg info from the input buffer
    input wire [40-1:0] msg_addr_S1,
    input wire [8-1:0] msg_mshrid_S1,
    input wire [14-1:0] msg_src_chipid_S1,
    input wire [8-1:0] msg_src_x_S1,
    input wire [8-1:0] msg_src_y_S1,
    input wire [4-1:0] msg_src_fbits_S1,
    input wire [10-1:0] msg_sdid_S1,
    input wire [6-1:0] msg_lsid_S1,
    
    input wire [64-1:0] msg_data_S1,

    //control signals from ctrl
    input wire valid_S1,
    input wire stall_S1,
    input wire msg_from_mshr_S1, 
    
 
    //Inputs to Stage 2   
    //input from the input buffer
    input wire [64-1:0] msg_data_S2,
   //input from the state array
    input wire [15*4+2+4-1:0] state_data_S2,
    
    //input from the tag array 
    input wire [100-1:0] tag_data_S2,


    //control signals from ctrl
    input wire msg_from_mshr_S2,
    input wire special_addr_type_S2,
    input wire [8-1:0] msg_type_S2,
    input wire [3-1:0] data_size_S2,
    input wire [1-1:0] cache_type_S2,
    input wire [2-1:0] dir_op_S2,
    input wire state_owner_en_S2,
    input wire [2-1:0] state_owner_op_S2,
    input wire state_subline_en_S2,
    input wire [2-1:0] state_subline_op_S2,
    input wire state_di_en_S2,
    input wire state_vd_en_S2,
    input wire [2-1:0] state_vd_S2,
    input wire state_mesi_en_S2,
    input wire [2-1:0] state_mesi_S2,
    input wire state_lru_en_S2,
    input wire [1-1:0] state_lru_op_S2,
    input wire state_rb_en_S2,
    input wire l2_ifill_32B_S2,
    input wire [2-1:0] l2_load_data_subline_S2,
    input wire valid_S2,
    input wire stall_S2,
    input wire stall_before_S2,
    input wire state_load_sdid_S2, 
    input wire data_clk_en_S2,
    input wire stall_real_S2,
    input wire [4-1:0] amo_alu_op_S2,

    //Inputs to Stage 3

    //input from the data array
    input wire [144-1:0] data_data_S3,
    input wire valid_S3,
    input wire stall_S3,
    input wire stall_before_S3, 


    //Inputs to Stage 4
    //control signals from ctrl
    input wire valid_S4,
    input wire stall_S4,
    input wire stall_before_S4, 
    input wire cas_cmp_en_S4,
    input wire atomic_read_data_en_S4,
    input wire [3-1:0] cas_cmp_data_size_S4,
    input wire [6-1:0] dir_sharer_S4,
    input wire [6-1:0] dir_sharer_counter_S4,
    input wire [6-1:0] mshr_inv_counter_out_S4,
    input wire [8-1:0] msg_send_type_S4,
    input wire [8-1:0] msg_send_length_S4,
    input wire [8-1:0] msg_send_type_pre_S4,
    input wire state_wr_sel_S4,
    input wire [8-1:0] msg_type_S4,
    input wire [3-1:0] data_size_S4,
    input wire [1-1:0] cache_type_S4,
    input wire [1-1:0] l2_miss_S4,
    
    input wire smc_miss_S4,
    
    input wire special_addr_type_S4,
    input wire [64-1:0] dir_data_sel_S4,
    input wire [64-1:0] dir_data_S4,
    
    input wire stall_smc_buf_S4,
    
    input wire msg_from_mshr_S4,
    input wire req_recycle_S4,
    input wire inv_fwd_pending_S4,

    
    //input from the broadcast counter
    input wire [14-1:0] broadcast_chipid_out_S4,
    input wire [8-1:0] broadcast_x_out_S4,
    input wire [8-1:0] broadcast_y_out_S4,
    
    //input from the smc
    
    input wire [30-1:0] smc_data_out_S4,
    input wire [4-1:0] smc_valid_out_S4,
    input wire [14-1:0] smc_tag_out_S4,
    
    //node id from id register
    input wire [14-1:0] my_nodeid_chipid_S4,
    input wire [8-1:0] my_nodeid_x_S4,
    input wire [8-1:0] my_nodeid_y_S4,
    input wire [64-1:0] reg_data_out_S4,
    

    //Outputs from Stage 1
    
    output reg [40-1:0] addr_S1,
    output reg [9-1:0] mshr_addr_in_S1,
    output reg [9-1:0] tag_addr_S1,
    output reg [9-1:0] state_rd_addr_S1,
    output reg [64-1:0] reg_data_in_S1,

    output reg [100-1:0] tag_data_in_S1,
    output reg [100-1:0] tag_data_mask_in_S1,
    //Outputs from Stage 2
   
 
    output reg [40-1:0] addr_S2,
    output reg l2_tag_hit_S2,
    output reg l2_evict_S2,
    output reg l2_wb_S2,
    output reg [2-1:0] l2_way_state_mesi_S2,
    output reg [2-1:0] l2_way_state_vd_S2,
    output reg [1-1:0] l2_way_state_cache_type_S2,
    output reg [4-1:0] l2_way_state_subline_S2,
    output reg req_from_owner_S2,
    output reg addr_l2_aligned_S2,
    output reg [6-1:0] lsid_S2,

    output reg [9+2-1:0] dir_addr_S2,
    output reg [64-1:0] dir_data_in_S2,
    output reg [64-1:0] dir_data_mask_in_S2,

    output reg [9+2+2-1:0] data_addr_S2,
    output reg [144-1:0] data_data_in_S2,
    output reg [144-1:0] data_data_mask_in_S2,

    
    output reg [16-1:0] smc_wr_addr_in_S2,
    output reg [128-1:0] smc_data_in_S2,
    

    //Outputs from Stage 3
    output reg [40-1:0] addr_S3,

    //Outputs from Stage 4
    output reg [40-1:0] addr_S4,
    output reg [9+2+2-1:0] data_addr_S4,

    output reg l2_tag_hit_S4,
    output reg l2_evict_S4,
    output reg [2-1:0] l2_way_state_mesi_S4,
    output reg [6-1:0] l2_way_state_owner_S4,
    output reg [2-1:0] l2_way_state_vd_S4,
    output reg [4-1:0] l2_way_state_subline_S4,
    output reg [1-1:0] l2_way_state_cache_type_S4,
    output reg [8-1:0] mshrid_S4,
    output reg req_from_owner_S4,
    output reg cas_cmp_S4,
    output reg [6-1:0] mshr_miss_lsid_S4,
    output reg [6-1:0] lsid_S4,
    output reg corr_error_S4,
    output reg uncorr_error_S4,

    output reg [40-1:0] msg_send_addr_S4,
    output reg [14-1:0] msg_send_dst_chipid_S4,
    output reg [8-1:0] msg_send_dst_x_S4,
    output reg [8-1:0] msg_send_dst_y_S4,
    output reg [4-1:0] msg_send_dst_fbits_S4,
    output reg [128-1:0] msg_send_data_S4,

    output reg [120+2-1:0] mshr_data_in_S4,
    output wire [120+2-1:0] mshr_data_mask_in_S4,


    
    output reg [16-1:0] smc_rd_addr_in_buf_S4,
    

    output reg [9-1:0] state_wr_addr_S4,
    output reg [15*4+2+4-1:0] state_data_in_S4,
    output reg [15*4+2+4-1:0] state_data_mask_in_S4

);


localparam y = 1'b1;
localparam n = 1'b0;


//used by stage 1
wire [128-1:0] data_data_ecc_S4;
//============================
// Stage 1
//============================

reg [8-1:0] mshrid_S1;
reg [14-1:0] src_chipid_S1;
reg [8-1:0] src_x_S1;
reg [8-1:0] src_y_S1;
reg [4-1:0] src_fbits_S1;
reg [10-1:0] sdid_S1;
reg [6-1:0] lsid_S1;
reg [40-1:0] addr_trans_S1;
reg recycled_S1;

always @ *
begin
    if (msg_from_mshr_S1)
    begin











        addr_S1 = pending_mshr_addr_S1;
        mshrid_S1 = pending_mshr_mshrid_S1;
        src_chipid_S1 = pending_mshr_src_chipid_S1;
        src_x_S1 = pending_mshr_src_x_S1;
        src_y_S1 = pending_mshr_src_y_S1;
        src_fbits_S1 = pending_mshr_src_fbits_S1;
        sdid_S1 = pending_mshr_sdid_S1;
        lsid_S1 = pending_mshr_lsid_S1;
        recycled_S1 = pending_mshr_recycled_S1;
 // L2_CAM_MSHR
    end
    else
    begin
        addr_S1 = msg_addr_S1;
        mshrid_S1 = msg_mshrid_S1;
        src_chipid_S1 = msg_src_chipid_S1;
        src_x_S1 = msg_src_x_S1;   
        src_y_S1 = msg_src_y_S1;   
        src_fbits_S1 = msg_src_fbits_S1;
        sdid_S1 = msg_sdid_S1;
        lsid_S1 = msg_lsid_S1;
        recycled_S1 = 1'b0;
    end
end

always @ *
begin
    if (dis_flush_S1)
    begin
        //address reorder for displacement flush
        addr_trans_S1 = {addr_S1[5:0],addr_S1[33:6],6'd0};
    end
    else
    begin
        addr_trans_S1 = addr_S1;
    end
end


always @ *
begin
    if (~msg_from_mshr_S1)
    begin
        mshr_addr_in_S1 = addr_trans_S1[6+9-1:6];
    end
    else 
    begin
        mshr_addr_in_S1 = {9{1'b0}};
    end
end

always @ *
begin
    tag_addr_S1 = addr_trans_S1[6+9-1:6];
end

always @ *
begin
    state_rd_addr_S1 = addr_trans_S1[6+9-1:6];
end


//the cache line read by the 1st phase of atomic instructions
reg [128-1:0] atomic_read_data_S1_f;
reg [128-1:0] atomic_read_data_S1_next;

always @ *
begin
    if (!rst_n)
    begin
        atomic_read_data_S1_next = 0;
    end
    else if (atomic_read_data_en_S4)
    begin
        atomic_read_data_S1_next = data_data_ecc_S4;
    end
    else
    begin
        atomic_read_data_S1_next = atomic_read_data_S1_f;
    end
end


always @ (posedge clk)
begin
    atomic_read_data_S1_f <= atomic_read_data_S1_next;
end

always @ *
begin
    reg_data_in_S1 = msg_data_S1;
end


always @ *
begin
    tag_data_in_S1 = {4{msg_data_S1[25-1:0]}};
end

always @ *
begin
    tag_data_mask_in_S1 = {{(4-1)*25{1'b0}},{25{1'b1}}} 
                       << (addr_trans_S1[6+9+2-1:6+9] * 25);
end


//============================
// Stage 1 -> Stage 2
//============================


reg [40-1:0] addr_S2_f;
reg [8-1:0] mshrid_S2_f;
reg [14-1:0] src_chipid_S2_f;
reg [8-1:0] src_x_S2_f;
reg [8-1:0] src_y_S2_f;
reg [4-1:0] src_fbits_S2_f;
reg [10-1:0] sdid_S2_f;
reg [6-1:0] lsid_S2_f;
reg [2-1:0] mshr_way_S2_f;
reg [6-1:0] mshr_miss_lsid_S2_f;
reg [128-1:0] atomic_read_data_S2_f;
reg recycled_S2_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        addr_S2_f <= 0; 
        mshrid_S2_f <= 0;
        src_chipid_S2_f <= 0;
        src_x_S2_f <= 0;
        src_y_S2_f <= 0;
        src_fbits_S2_f <= 0;
        sdid_S2_f <= 0;
        lsid_S2_f <= 0;
        mshr_way_S2_f <= 0;
        mshr_miss_lsid_S2_f <= 0;
        atomic_read_data_S2_f <= 0;
        recycled_S2_f <= 0;
    end
    else if (!stall_S2)
    begin
        addr_S2_f <= addr_trans_S1;
        mshrid_S2_f <= mshrid_S1;
        src_chipid_S2_f <= src_chipid_S1;
        src_x_S2_f <= src_x_S1;
        src_y_S2_f <= src_y_S1;
        src_fbits_S2_f <= src_fbits_S1;
        sdid_S2_f <= sdid_S1;
        lsid_S2_f <= lsid_S1;




        // trin: ambiguous??
        mshr_way_S2_f <= (mshr_pending_S1 == 1'b1) ? pending_mshr_way_S1 : cam_mshr_way_S1;
        mshr_miss_lsid_S2_f <= (mshr_pending_S1 == 1'b1) ? pending_mshr_miss_lsid_S1 : cam_mshr_miss_lsid_S1;
 // L2_CAM_MSHR
        atomic_read_data_S2_f <= atomic_read_data_S1_f;
        recycled_S2_f <= recycled_S1;
    end
end


//============================
// Stage 2
//============================


reg [64-1:0] return_data_S2;
reg [2-1:0] l2_way_sel_S2;
reg [15*4+2+4-1:0] state_data_in_S2;
reg [15*4+2+4-1:0] state_data_mask_in_S2;


always @ *
begin
    addr_S2 = addr_S2_f;
    lsid_S2 = lsid_S2_f;
end

reg [100-1:0] tag_data_buf_S2_f;
reg [100-1:0] tag_data_buf_S2_next;
reg [100-1:0] tag_data_trans_S2;

always @ *
begin
    if (!rst_n)
    begin
        tag_data_buf_S2_next = 0;
    end
    else if (stall_S2 && !stall_before_S2)
    begin
        tag_data_buf_S2_next = tag_data_S2;
    end
    else
    begin
        tag_data_buf_S2_next = tag_data_buf_S2_f;
    end
end


always @ (posedge clk)
begin
    tag_data_buf_S2_f <= tag_data_buf_S2_next;
end


//choose between the direct output and buffered output of the tag array based on stall situation
always @ *
begin
    if (stall_before_S2)
    begin
        tag_data_trans_S2 = tag_data_buf_S2_f;
    end
    else
    begin
        tag_data_trans_S2 = tag_data_S2;
    end
end

wire [6-1:0] flat_id_S2;

xy_to_flat_id flat_id_gen(
    .flat_id    (flat_id_S2),
    .x_coord    (src_x_S2_f),
    .y_coord    (src_y_S2_f)
);


reg [15*4+2+4-1:0] state_data_buf_S2_f;
reg [15*4+2+4-1:0] state_data_buf_S2_next;
reg [15*4+2+4-1:0] state_data_trans_S2;

always @ *
begin
    if (!rst_n)
    begin
        state_data_buf_S2_next = 0;
    end
    else if (stall_S2 && !stall_before_S2)
    begin
        state_data_buf_S2_next = state_data_S2;
    end
    else
    begin
        state_data_buf_S2_next = state_data_buf_S2_f;
    end
end


always @ (posedge clk)
begin
    state_data_buf_S2_f <= state_data_buf_S2_next;
end


//choose between the direct output and buffered output of the state array based on stall situation
always @ *
begin
    if (stall_before_S2)
    begin
        state_data_trans_S2 = state_data_buf_S2_f;
    end
    else
    begin
        state_data_trans_S2 = state_data_S2;
    end
end


wire [2-1:0] l2_hit_way_sel_S2;
reg [2-1:0] l2_evict_way_sel_S2;
reg [2-1:0] l2_rb_bits_S2;
reg [4-1:0] l2_lru_bits_S2;


always @ *
begin
    l2_rb_bits_S2 = state_data_trans_S2[15*4+2+4-1:15*4+4];
    l2_lru_bits_S2 = state_data_trans_S2[15*4+4-1:15*4];
end


reg [25 - 1:0] tag_data_way_S2 [3:0];


reg [3:0] tag_hit_way_S2;


reg [15 - 1:0] state_way_S2 [3:0];







always @ *
begin
    tag_data_way_S2[0] = tag_data_trans_S2[25 * 1 - 1: 25 * 0];
    tag_data_way_S2[1] = tag_data_trans_S2[25 * 2 - 1: 25 * 1];
    tag_data_way_S2[2] = tag_data_trans_S2[25 * 3 - 1: 25 * 2];
    tag_data_way_S2[3] = tag_data_trans_S2[25 * 4 - 1: 25 * 3];

end

always @ *
begin
    state_way_S2[0] = state_data_trans_S2[15 * 1 - 1: 
15 * 0];
    state_way_S2[1] = state_data_trans_S2[15 * 2 - 1: 
15 * 1];
    state_way_S2[2] = state_data_trans_S2[15 * 3 - 1: 
15 * 2];
    state_way_S2[3] = state_data_trans_S2[15 * 4 - 1: 
15 * 3];

end

always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[0]) && 
(state_way_S2[0][12:11] == 2'b10 || state_way_S2[0][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[0] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[0] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[1]) && 
(state_way_S2[1][12:11] == 2'b10 || state_way_S2[1][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[1] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[1] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[2]) && 
(state_way_S2[2][12:11] == 2'b10 || state_way_S2[2][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[2] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[2] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[3]) && 
(state_way_S2[3][12:11] == 2'b10 || state_way_S2[3][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[3] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[3] = 1'b0;
    end
end



wire l2_tag_cmp_hit_S2;


l2_priority_encoder_2 priority_encoder_tag_cmp_2bits( 

    .data_in        (tag_hit_way_S2),
    .data_out       (l2_hit_way_sel_S2),
    .data_out_mask  (),
    .nonzero_out    (l2_tag_cmp_hit_S2)
);



always @ *
begin
    if (special_addr_type_S2 || msg_type_S2 == 8'd34)
    begin
        l2_tag_hit_S2 = 1'b0;
    end
    else
    begin
        l2_tag_hit_S2 = l2_tag_cmp_hit_S2;
    end
end
/*
            l2_tag_hit_S2 = tag_hit_way_S2[0] || tag_hit_way_S2[1] || tag_hit_way_S2[2] || tag_hit_way_S2[3];

    end
end



always @ *
begin
    l2_hit_way_sel_S2 = {`L2_WAYS_WIDTH{1'b0}};
    if (tag_hit_way_S2[0])
    begin
        l2_hit_way_sel_S2 = `L2_WAY_0;
    end
    if (tag_hit_way_S2[1])
    begin
        l2_hit_way_sel_S2 = `L2_WAY_1;
    end
    if (tag_hit_way_S2[2])
    begin
        l2_hit_way_sel_S2 = `L2_WAY_2;
    end
    if (tag_hit_way_S2[3])
    begin
        l2_hit_way_sel_S2 = `L2_WAY_3;
    end

end
*/
 
//pseudo LRU algorithm 
always @ *
begin

     if (!state_way_S2[0][12:11]) 
        begin
            l2_evict_way_sel_S2 = 2'd0;
        end
     else if (!state_way_S2[1][12:11]) 
        begin
            l2_evict_way_sel_S2 = 2'd1;
        end
     else if (!state_way_S2[2][12:11]) 
        begin
            l2_evict_way_sel_S2 = 2'd2;
        end
     else if (!state_way_S2[3][12:11]) 
        begin
            l2_evict_way_sel_S2 = 2'd3;
        end

    else
    begin
    case (l2_rb_bits_S2)
    2'd0:
    begin
        if (!l2_lru_bits_S2[0])
        begin
            l2_evict_way_sel_S2 = 2'd0;
        end
        else if (!l2_lru_bits_S2[1])
        begin
            l2_evict_way_sel_S2 = 2'd1;
        end
        else if (!l2_lru_bits_S2[2])
        begin
            l2_evict_way_sel_S2 = 2'd2;
        end
        else
        begin
            l2_evict_way_sel_S2 = 2'd3;
        end
    end
    2'd1:
    begin
        if (!l2_lru_bits_S2[1])
        begin
            l2_evict_way_sel_S2 = 2'd1;
        end
        else if (!l2_lru_bits_S2[2])
        begin
            l2_evict_way_sel_S2 = 2'd2;
        end
        else if (!l2_lru_bits_S2[3])
        begin
            l2_evict_way_sel_S2 = 2'd3;
        end
        else
        begin
            l2_evict_way_sel_S2 = 2'd0;
        end
    end
    2'd2:
    begin
        if (!l2_lru_bits_S2[2])
        begin
            l2_evict_way_sel_S2 = 2'd2;
        end
        else if (!l2_lru_bits_S2[3])
        begin
            l2_evict_way_sel_S2 = 2'd3;
        end
        else if (!l2_lru_bits_S2[0])
        begin
            l2_evict_way_sel_S2 = 2'd0;
        end
        else
        begin
            l2_evict_way_sel_S2 = 2'd1;
        end
    end
    2'd3:
    begin
        if (!l2_lru_bits_S2[3])
        begin
            l2_evict_way_sel_S2 = 2'd3;
        end
        else if (!l2_lru_bits_S2[0])
        begin
            l2_evict_way_sel_S2 = 2'd0;
        end
        else if (!l2_lru_bits_S2[1])
        begin
            l2_evict_way_sel_S2 = 2'd1;
        end
        else
        begin
            l2_evict_way_sel_S2 = 2'd2;
        end
    end

    default:
    begin
        l2_evict_way_sel_S2 = 2'd0;
    end
    endcase
    end
end


always @ *
begin
/*
    if (msg_from_mshr_S2)
    begin
        l2_way_sel_S2 = mshr_way_S2_f;
    end
    else 
*/
    if (special_addr_type_S2 || msg_type_S2 == 8'd34)
    begin
        l2_way_sel_S2 = addr_S2[6+9+2-1:6+9];
    end
    else if (l2_tag_hit_S2)
    begin
        l2_way_sel_S2 = l2_hit_way_sel_S2;
    end
    else   
    begin
        l2_way_sel_S2 = l2_evict_way_sel_S2;
    end
end

always @ *
begin
    if (special_addr_type_S2 
     || msg_type_S2 == 8'd13
     || msg_type_S2 == 8'd15)
    begin
        l2_evict_S2 = 1'b0;
    end
    else if (!l2_tag_hit_S2 && (state_way_S2[l2_way_sel_S2][12:11] == 2'b10 || 
        state_way_S2[l2_way_sel_S2][12:11] == 2'b11))
    begin
        l2_evict_S2 = 1'b1;
    end
    else
    begin
        l2_evict_S2 = 1'b0;
    end
end

always @ *
begin
    if (special_addr_type_S2
     || msg_type_S2 == 8'd13)
    begin
        l2_wb_S2 = 1'b0;
    end
    else if (((!l2_tag_hit_S2 && (msg_type_S2 != 8'd15))
           || (msg_type_S2 == 8'd14 || msg_type_S2 == 8'd35)
           || (l2_tag_hit_S2 && msg_type_S2 == 8'd15))
    && (state_way_S2[l2_way_sel_S2][14:13] == 2'b00)
    && (state_way_S2[l2_way_sel_S2][12:11] == 2'b11))
    begin
        l2_wb_S2 = 1'b1;
    end
    else
    begin
        l2_wb_S2 = 1'b0;
    end
end


reg [6-1:0] l2_way_state_owner_S2;

always @ *
begin
    l2_way_state_mesi_S2 = state_way_S2[l2_way_sel_S2][14:13];
    l2_way_state_vd_S2 = state_way_S2[l2_way_sel_S2][12:11];
    l2_way_state_subline_S2 = state_way_S2[l2_way_sel_S2][9:6];
    l2_way_state_cache_type_S2 = state_way_S2[l2_way_sel_S2][10];
    l2_way_state_owner_S2 = state_way_S2[l2_way_sel_S2][5:0];
end



always @ *
begin
    
    if (csm_en)
    begin
        req_from_owner_S2 = (l2_way_state_owner_S2 == lsid_S2_f) && (lsid_S2_f != 6'd63);
    end
    else
    
    begin
        req_from_owner_S2 = (l2_way_state_owner_S2 == flat_id_S2);
    end
end


always @ *
begin
    dir_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2}; 
end

always @ *
begin
    if (l2_wb_S2)
    begin
        data_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2, l2_load_data_subline_S2};
    end
    else if (l2_ifill_32B_S2)
    begin
        data_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2, 
                        addr_S2_f[5], l2_load_data_subline_S2[0]};
    end
    else
    begin
        data_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2, addr_S2_f[5:4]};
    end
end

reg [40-1:0] evict_addr_S2;

always @ *
begin
    evict_addr_S2 = {tag_data_way_S2[l2_way_sel_S2], addr_S2_f[6+9-1:6], {6{1'b0}}}; 
end



always @ *
begin
    addr_l2_aligned_S2 = (addr_S2_f[6-1:0] == {6{1'b0}}); 
end



always @ *
begin
    if (special_addr_type_S2)
    begin  
        if (addr_S2[39:32] == 8'ha4)
        begin
            return_data_S2 = {{(64 - 25){1'b0}}, tag_data_way_S2[l2_way_sel_S2]};
        end
        else if (addr_S2[39:32] == 8'ha6)
        begin
        // State access is only available when L2_WAYS is less than 8
            if (addr_S2[31:30] == {2{1'b0}})
            begin
                return_data_S2 = {{(64 - 15*4){1'b0}}, state_data_trans_S2[15*4-1:0]};
            end
            else
            begin
                return_data_S2 = {{(64 - 2 - 4){1'b0}}, l2_rb_bits_S2, l2_lru_bits_S2};
            end
        end
        else
        begin
            return_data_S2 = {64{1'b0}};
        end 
    end
    else
    begin
        return_data_S2 = {64{1'b0}};
    end
end




always @ *
begin
    if (special_addr_type_S2)
    begin  
        dir_data_in_S2 = msg_data_S2;  
    end
    else
    begin
        //track owner beyond the domain scope
        
        if (csm_en && (dir_op_S2 == 2'd1))
        begin
            dir_data_in_S2 = {sdid_S2_f, src_chipid_S2_f, src_y_S2_f,src_x_S2_f};  
        end
        else        
        
        begin
            dir_data_in_S2 = {64{1'b1}}; 
        end 
    end
end

always @ *
begin
    if (special_addr_type_S2)
    begin  
        dir_data_mask_in_S2 = {64{1'b1}};
    end
    else
    begin
        
        if (csm_en)
        begin
            if (dir_op_S2 == 2'd1)
            begin
                dir_data_mask_in_S2 = {64{1'b1}};
            end
            else
            begin
                dir_data_mask_in_S2 = {{(64-1){1'b0}},1'b1} << lsid_S2_f;
            end
        end
        else    
        
        begin
            dir_data_mask_in_S2 = {{(64-1){1'b0}},1'b1} << flat_id_S2;
        end
    end 
end



reg [128-1:0] msg_data_mask_in_S2;
reg [128-1:0] data_data_merge_S2;
wire [8-1:0] data_data_parity1_S2;
wire [8-1:0] data_data_parity2_S2;
wire [128-1:0] amo_result_S2;

always @ *
begin
    if (data_size_S2 == 3'b001)
    begin
        msg_data_mask_in_S2 = {{8{1'b1}}, {(128-8){1'b0}}};
        msg_data_mask_in_S2 = msg_data_mask_in_S2 >> (8*addr_S2_f[3:0]);
    end
    else if (data_size_S2 == 3'b010)
    begin
        msg_data_mask_in_S2 = {{16{1'b1}}, {(128-16){1'b0}}};
        msg_data_mask_in_S2 = msg_data_mask_in_S2 >> (16*addr_S2_f[3:1]);
    end
    else if (data_size_S2 == 3'b011)
    begin
        msg_data_mask_in_S2 = {{32{1'b1}}, {(128-32){1'b0}}};
        msg_data_mask_in_S2 = msg_data_mask_in_S2 >> (32*addr_S2_f[3:2]);
    end
    else
    begin   
        msg_data_mask_in_S2 = {128{1'b1}}; 
    end
    msg_data_mask_in_S2 = {msg_data_mask_in_S2[63:0], msg_data_mask_in_S2[127:64]};
end

l2_amo_alu l2_amo_alu (
    .amo_alu_op     (amo_alu_op_S2),
    .address        (addr_S2_f),
    .data_size      (data_size_S2),
    .memory_operand (atomic_read_data_S2_f),
    .cpu_operand    ({msg_data_S2, msg_data_S2}),
    .amo_result     (amo_result_S2)
);

always @ *
begin
    data_data_merge_S2 = ({msg_data_S2, msg_data_S2} & msg_data_mask_in_S2)
                       | (atomic_read_data_S2_f & ~msg_data_mask_in_S2); 

    if (amo_alu_op_S2 != 4'd0)
    begin
        data_data_merge_S2 = amo_result_S2;
    end
end

l2_data_pgen data_pgen1( 
    .din            (data_data_merge_S2[64-1:0]),
    .parity         (data_data_parity1_S2)
);

l2_data_pgen data_pgen2( 
    .din            (data_data_merge_S2[128-1:64]),
    .parity         (data_data_parity2_S2)
);


always @ *
begin
    if (special_addr_type_S2)
    begin
        data_data_in_S2 = {msg_data_S2[8-1:0], msg_data_S2,
                           msg_data_S2[8-1:0], msg_data_S2};
    end
    else
    begin
        data_data_in_S2 = {data_data_parity2_S2, data_data_merge_S2[127:64], data_data_parity1_S2, data_data_merge_S2[63:0]}; 
    end
end

always @ *
begin
    if (special_addr_type_S2)
    begin
        if (addr_S2_f[31:30] == {2{1'b0}})
        begin
            data_data_mask_in_S2 = {{(144-72){1'b0}},
                                    {8{1'b0}}, {64{1'b1}}};
        end
        else
        begin
            data_data_mask_in_S2 = {{(144-72){1'b0}},
                                    {8{1'b1}}, {64{1'b0}}};
        end
        data_data_mask_in_S2 = data_data_mask_in_S2 << (72*addr_S2_f[3]);
    end
    else if (data_size_S2 == 3'b001 || data_size_S2 == 3'b010
    ||  data_size_S2 == 3'b011 || data_size_S2 == 3'b100
    )
    begin
        data_data_mask_in_S2 = {{(144-72){1'b0}},{72{1'b1}}};
        data_data_mask_in_S2 = data_data_mask_in_S2 << (72*addr_S2_f[3]);
    end
    else
    begin   
        data_data_mask_in_S2 = {144{1'b1}}; 
    end
end




reg [6-1:0] state_owner_S2;
reg [4-1:0] state_subline_S2;
reg [2-1:0] state_rb_S2;
reg [4-1:0] state_lru_S2;

always @ *
begin
    state_owner_S2 = l2_way_state_owner_S2; 
    if (state_owner_op_S2 == 2'd1)
    begin
        
        if (csm_en)
        begin
            if (state_load_sdid_S2)
            begin
                state_owner_S2 = sdid_S2_f[5:0];
            end
            else
            begin
                state_owner_S2 = lsid_S2_f; 
            end
        end
        else
        
        begin
            state_owner_S2 = flat_id_S2; // {src_y_S2_f[`L2_OWNER_XY], src_x_S2_f[`L2_OWNER_XY]}; 
        end
    end
    else if (state_owner_op_S2 == 2'd2)
    begin
        state_owner_S2 = l2_way_state_owner_S2 + 1; 
    end
    else if (state_owner_op_S2 == 2'd3)
    begin
        state_owner_S2 = l2_way_state_owner_S2 - 1; 
    end
    else if (state_owner_op_S2 == 2'd0)
    begin
        state_owner_S2 = 0; 
    end
end

reg [4-1:0] addr_subline_S2;

always @ *
begin
    if (cache_type_S2 == 1'b0)
    begin
        //addr_subline_S2= {1'b1, {(`L2_SUBLINE_BITS-1){1'b0}}} >> addr_S2_f[`L2_DATA_SUBLINE];
        addr_subline_S2= {{(4-1){1'b0}},1'b1} << addr_S2_f[5:4];
    end
    else
    begin
        addr_subline_S2= {{(4-2){1'b0}},2'b11} << (2*addr_S2_f[5]);
        //addr_subline_S2= {2'b11, {(`L2_SUBLINE_BITS-2){1'b0}}} >> (2*addr_S2_f[`L2_INS_SUBLINE]);
    end
end


always @ *
begin
    if (state_load_sdid_S2)
    begin
        state_subline_S2 = sdid_S2_f[9:6];
    end
    else if (state_subline_op_S2 == 2'd2)
    begin
        state_subline_S2 = l2_way_state_subline_S2 | addr_subline_S2;
    end
    else if (state_subline_op_S2 == 2'd3)
    begin
        state_subline_S2 = l2_way_state_subline_S2 & (~addr_subline_S2);
    end
    else if (state_subline_op_S2 == 2'd0)
    begin
        state_subline_S2 = {4{1'b0}};
    end
    else
    begin
        state_subline_S2 = {4{1'bx}};
    end
end

always @ *
begin
    state_rb_S2 = l2_rb_bits_S2 + 1; 
end


always @ *
begin
    if (state_lru_en_S2)
    begin
        if (state_lru_op_S2 == 1'b0)
        begin
            state_lru_S2 = l2_lru_bits_S2 & (~({{(4-1){1'b0}},1'b1} << l2_way_sel_S2));
        end
        else
        begin
            state_lru_S2 = l2_lru_bits_S2 | ({{(4-1){1'b0}},1'b1} << l2_way_sel_S2);
            //clear all lru bits if they are all set
            if (state_lru_S2 == {4{1'b1}})
            begin
                state_lru_S2 = {4{1'b0}};
            end
        end
    end
    else
    begin
        state_lru_S2 = l2_lru_bits_S2; 
    end
end


always @ *
begin
    if (special_addr_type_S2)
    begin   
        state_data_in_S2 = {msg_data_S2[2+4-1:0], msg_data_S2[15*4-1:0]};
    end
    else
    begin
        state_data_in_S2 = {state_rb_S2, state_lru_S2, 
        {4{state_mesi_S2, state_vd_S2, cache_type_S2, state_subline_S2, state_owner_S2}}};
    end
end

reg [15*4-1:0] state_way_data_mask_in_S2;



always @ *
begin
    state_way_data_mask_in_S2 = {{(4-1)*15{1'b0}},
                                {{2{state_mesi_en_S2}}, 
                                 {2{state_vd_en_S2}}, 
                                 {1{state_di_en_S2}}, 
                                 {4{state_subline_en_S2}}, 
                                 {6{state_owner_en_S2}}}} 
    << (l2_way_sel_S2 * 15); 
end


always @ *
begin
    if (special_addr_type_S2)
    begin
        if (addr_S2_f[31:30] == {2{1'b0}})
        begin
            state_data_mask_in_S2 = {{(2+4){1'b0}}, {15*4{1'b1}}};
        end
        else
        begin
            state_data_mask_in_S2 = {{(2+4){1'b1}}, {15*4{1'b0}}};
        end
    end
    else
    begin
        state_data_mask_in_S2 = {{2{state_rb_en_S2}}, 
                                {4{state_lru_en_S2}},
                                state_way_data_mask_in_S2}; 
    end
end


reg [64-1:0] msg_data_S2_next;

always @ *
begin
    if (special_addr_type_S2)
    begin
        msg_data_S2_next = return_data_S2;
    end
    else
    begin
        msg_data_S2_next = msg_data_S2;
    end
end


always @ *
begin
    smc_wr_addr_in_S2 = addr_S2[16+3:4];
end

always @ *
begin
    smc_data_in_S2 = {msg_data_S2, msg_data_S2};
end


//============================
// Stage 2 > Stage 3
//============================

reg [40-1:0] addr_S3_f;
reg [8-1:0] mshrid_S3_f;
reg [14-1:0] src_chipid_S3_f;
reg [8-1:0] src_x_S3_f;
reg [8-1:0] src_y_S3_f;
reg [4-1:0] src_fbits_S3_f;
reg [10-1:0] sdid_S3_f;
reg [6-1:0] lsid_S3_f;
reg [6-1:0] mshr_miss_lsid_S3_f;
reg [40-1:0] evict_addr_S3_f;
reg l2_tag_hit_S3_f;
reg l2_evict_S3_f;
reg [2-1:0] l2_way_sel_S3_f;
reg [6-1:0] l2_way_state_owner_S3_f;
reg [2-1:0] l2_way_state_mesi_S3_f;
reg [2-1:0] l2_way_state_vd_S3_f;
reg [4-1:0] l2_way_state_subline_S3_f;
reg [1-1:0] l2_way_state_cache_type_S3_f;
reg [64-1:0] msg_data_S3_f;
reg req_from_owner_S3_f;
reg [15*4+2+4-1:0] state_data_in_S3_f;
reg [15*4+2+4-1:0] state_data_mask_in_S3_f;
reg [9+2+2-1:0] data_addr_S3_f;
reg recycled_S3_f;
reg data_clk_en_S3_f; // trin: added for stalled skid buffer

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        addr_S3_f <= 0;
        mshrid_S3_f <= 0;
        src_chipid_S3_f <= 0;
        src_x_S3_f <= 0;
        src_y_S3_f <= 0;
        src_fbits_S3_f <= 0;
        sdid_S3_f <= 0;
        lsid_S3_f <= 0;
        mshr_miss_lsid_S3_f <= 0;
        evict_addr_S3_f <= 0;
        l2_tag_hit_S3_f <= 0;
        l2_evict_S3_f <= 0;
        l2_way_sel_S3_f <= 0;
        l2_way_state_owner_S3_f <= 0;
        l2_way_state_mesi_S3_f <= 0;
        l2_way_state_vd_S3_f <= 0;
        l2_way_state_subline_S3_f <= 0;
        l2_way_state_cache_type_S3_f <= 0;
        msg_data_S3_f <= 0;
        req_from_owner_S3_f <= 0; 
        state_data_in_S3_f <= 0;
        state_data_mask_in_S3_f <= 0;
        data_addr_S3_f <= 0;
        recycled_S3_f <= 0;
        data_clk_en_S3_f <= 0;
    end
    else if (!stall_S3)
    begin
        addr_S3_f <= addr_S2;
        mshrid_S3_f <= mshrid_S2_f;
        src_chipid_S3_f <= src_chipid_S2_f;
        src_x_S3_f <= src_x_S2_f;
        src_y_S3_f <= src_y_S2_f;
        src_fbits_S3_f <= src_fbits_S2_f;
        sdid_S3_f <= sdid_S2_f;
        lsid_S3_f <= lsid_S2_f;
        mshr_miss_lsid_S3_f <= mshr_miss_lsid_S2_f;
        evict_addr_S3_f <= evict_addr_S2;
        l2_tag_hit_S3_f <= l2_tag_hit_S2;
        l2_evict_S3_f <= l2_evict_S2;
        l2_way_sel_S3_f <= l2_way_sel_S2;
        l2_way_state_owner_S3_f <= l2_way_state_owner_S2;
        l2_way_state_mesi_S3_f <= l2_way_state_mesi_S2;
        l2_way_state_vd_S3_f <= l2_way_state_vd_S2;
        l2_way_state_subline_S3_f <= l2_way_state_subline_S2;
        l2_way_state_cache_type_S3_f <= l2_way_state_cache_type_S2;
        msg_data_S3_f <= msg_data_S2_next;
        req_from_owner_S3_f <= req_from_owner_S2; 
        state_data_in_S3_f <= state_data_in_S2;
        state_data_mask_in_S3_f <= state_data_mask_in_S2;
        data_addr_S3_f <= data_addr_S2;
        recycled_S3_f <= recycled_S2_f;
    end
    data_clk_en_S3_f <= (data_clk_en_S2 && valid_S2 && !stall_real_S2); // note: should not be qualified by stall_S3
end


//============================
// Stage 3
//============================

always @ *
begin
    addr_S3 = addr_S3_f;
end
//============================
// Stage 3 > Stage 4
//============================

reg [40-1:0] addr_S4_f;
reg [8-1:0] mshrid_S4_f;
reg [14-1:0] src_chipid_S4_f;
reg [8-1:0] src_x_S4_f;
reg [8-1:0] src_y_S4_f;
reg [4-1:0] src_fbits_S4_f;
reg [10-1:0] sdid_S4_f;
reg [6-1:0] lsid_S4_f;
reg [6-1:0] mshr_miss_lsid_S4_f;
reg [40-1:0] evict_addr_S4_f;
reg l2_tag_hit_S4_f;
reg l2_evict_S4_f;
reg [2-1:0] l2_way_sel_S4_f;
reg [6-1:0] l2_way_state_owner_S4_f;
reg [2-1:0] l2_way_state_mesi_S4_f;
reg [2-1:0] l2_way_state_vd_S4_f;
reg [4-1:0] l2_way_state_subline_S4_f;
reg [1-1:0] l2_way_state_cache_type_S4_f;
reg [64-1:0] msg_data_S4_f;
reg req_from_owner_S4_f;
reg [15*4+2+4-1:0] state_data_in_S4_f;
reg [15*4+2+4-1:0] state_data_mask_in_S4_f;
reg [144-1:0] data_data_S4_f;
reg [9+2+2-1:0] data_addr_S4_f;
reg recycled_S4_f;

reg data_stalled_skid_buffer_en_S3_f;
reg [144-1:0] data_stalled_skid_buffer_S3_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        addr_S4_f <= 0;
        mshrid_S4_f <= 0;
        src_chipid_S4_f <= 0;
        src_x_S4_f <= 0;
        src_y_S4_f <= 0;
        src_fbits_S4_f <= 0;
        sdid_S4_f <= 0;
        lsid_S4_f <= 0;
        mshr_miss_lsid_S4_f <= 0;
        evict_addr_S4_f <= 0;
        l2_tag_hit_S4_f <= 0;
        l2_evict_S4_f <= 0;
        l2_way_sel_S4_f <= 0;
        l2_way_state_owner_S4_f <= 0;
        l2_way_state_mesi_S4_f <= 0;
        l2_way_state_vd_S4_f <= 0;
        l2_way_state_subline_S4_f <= 0;
        l2_way_state_cache_type_S4_f <= 0;
        msg_data_S4_f <= 0;
        req_from_owner_S4_f <= 0; 
        state_data_in_S4_f <= 0;
        state_data_mask_in_S4_f <= 0;
        data_data_S4_f <= 0;
        data_addr_S4_f <= 0;
        recycled_S4_f <= 0;
    end
    else if (!stall_S4)
    begin
        addr_S4_f <= addr_S3_f;
        mshrid_S4_f <= mshrid_S3_f;
        src_chipid_S4_f <= src_chipid_S3_f;
        src_x_S4_f <= src_x_S3_f;
        src_y_S4_f <= src_y_S3_f;
        src_fbits_S4_f <= src_fbits_S3_f;
        sdid_S4_f <= sdid_S3_f;
        lsid_S4_f <= lsid_S3_f;
        mshr_miss_lsid_S4_f <= mshr_miss_lsid_S3_f;
        evict_addr_S4_f <= evict_addr_S3_f;
        l2_tag_hit_S4_f <= l2_tag_hit_S3_f;
        l2_evict_S4_f <= l2_evict_S3_f;
        l2_way_sel_S4_f <= l2_way_sel_S3_f;
        l2_way_state_owner_S4_f <= l2_way_state_owner_S3_f;
        l2_way_state_mesi_S4_f <= l2_way_state_mesi_S3_f;
        l2_way_state_vd_S4_f <= l2_way_state_vd_S3_f;
        l2_way_state_subline_S4_f <= l2_way_state_subline_S3_f;
        l2_way_state_cache_type_S4_f <= l2_way_state_cache_type_S3_f;
        msg_data_S4_f <= msg_data_S3_f;
        req_from_owner_S4_f <= req_from_owner_S3_f; 
        state_data_in_S4_f <= state_data_in_S3_f;
        state_data_mask_in_S4_f <= state_data_mask_in_S3_f;
        data_data_S4_f <= data_data_S3;
        data_addr_S4_f <= data_addr_S3_f;
        recycled_S4_f <= recycled_S3_f;
        if (data_stalled_skid_buffer_en_S3_f) begin
            data_data_S4_f <= data_stalled_skid_buffer_S3_f;
        end
    end
end

// trin: skid buffer for data read (bug 7/11/18)
wire data_stalled_skid_buffer_en_S3 = data_clk_en_S3_f && valid_S3 && stall_S3;
wire data_stalled_skid_buffer_consume_S3 = valid_S3 && !stall_S3;

always @ (posedge clk) begin
    if (data_stalled_skid_buffer_en_S3) begin
        data_stalled_skid_buffer_S3_f <= data_data_S3;
        data_stalled_skid_buffer_en_S3_f <= 1'b1;
    end
    if (data_stalled_skid_buffer_consume_S3) begin
        data_stalled_skid_buffer_en_S3_f <= 1'b0;
    end
end














 // L2_CAM_MSHR



//============================
// Stage 4
//============================

reg [15*4+2+4-1:0] state_data_in_real_S4;
reg [15*4+2+4-1:0] state_data_mask_in_real_S4;

reg [16-1:0] smc_rd_addr_in_S4;

reg [144-1:0] data_data_S4;
reg [10-1:0] sdid_S4;

always @ *
begin
    addr_S4 = addr_S4_f;
    mshrid_S4 = mshrid_S4_f;
    l2_evict_S4 = l2_evict_S4_f;
    l2_tag_hit_S4 = l2_tag_hit_S4_f;
    l2_way_state_mesi_S4 = l2_way_state_mesi_S4_f;
    l2_way_state_owner_S4 = l2_way_state_owner_S4_f;
    l2_way_state_vd_S4 = l2_way_state_vd_S4_f;
    l2_way_state_subline_S4 = l2_way_state_subline_S4_f; 
    l2_way_state_cache_type_S4 = l2_way_state_cache_type_S4_f;
    mshr_miss_lsid_S4 = mshr_miss_lsid_S4_f;
    lsid_S4 = lsid_S4_f;
    data_data_S4 = data_data_S4_f;
    data_addr_S4 = data_addr_S4_f;
end


always @ *
begin
    
    if (csm_en && (!msg_from_mshr_S4 || recycled_S4_f) && l2_evict_S4)
    begin
        if (l2_way_state_mesi_S4 == 2'b10)
        begin
            sdid_S4 = dir_data_S4[14+8+8+10-1:14+8+8]; 
        end
        else if (l2_way_state_mesi_S4 == 2'b01 || l2_way_state_mesi_S4 == 2'b11)
        begin
            sdid_S4 = {l2_way_state_subline_S4, l2_way_state_owner_S4};
        end
        else
        begin
            sdid_S4 = sdid_S4_f;
        end
    end
    else
    
    begin
        sdid_S4 = sdid_S4_f;
    end
end

always @ *
begin
    
    if (csm_en && (msg_type_S4 == 8'd13) && l2_tag_hit_S4
     && (l2_way_state_mesi_S4 == 2'b10) && l2_way_state_subline_S4[addr_S4[5:4]])
    begin
        req_from_owner_S4 = (src_chipid_S4_f == dir_data_S4[29:16])
                         && (src_x_S4_f == dir_data_S4[7:0])
                         && (src_y_S4_f == dir_data_S4[15:8]);
    end
    else
    
    begin
        req_from_owner_S4 = req_from_owner_S4_f;
    end
end



reg [16-1:0] smc_rd_addr_in_buf_S4_next;
reg [16-1:0] smc_rd_addr_in_buf_S4_f;

always @ *
begin
    if (!rst_n)
    begin
        smc_rd_addr_in_buf_S4_next = 0;
    end
    else if (!stall_smc_buf_S4)
    begin
        smc_rd_addr_in_buf_S4_next = smc_rd_addr_in_S4;
    end
    else 
    begin
        smc_rd_addr_in_buf_S4_next = smc_rd_addr_in_buf_S4_f;
    end
end

always @ (posedge clk)
begin
    smc_rd_addr_in_buf_S4_f <= smc_rd_addr_in_buf_S4_next;
end

always @ *
begin
    smc_rd_addr_in_buf_S4 = smc_rd_addr_in_buf_S4_f;
end
/*
reg [`L2_SMC_DATA_OUT_WIDTH-1:0] smc_data_out_buf_S4_next;
reg [`L2_SMC_VALID_WIDTH-1:0] smc_valid_out_buf_S4_next;
reg [`L2_SMC_TAG_WIDTH-1:0] smc_tag_out_buf_S4_next;
reg [`L2_SMC_DATA_OUT_WIDTH-1:0] smc_data_out_buf_S4_f;
reg [`L2_SMC_VALID_WIDTH-1:0] smc_valid_out_buf_S4_f;
reg [`L2_SMC_TAG_WIDTH-1:0] smc_tag_out_buf_S4_f;


always @ *
begin
    if (!rst_n)
    begin
        smc_data_out_buf_S4_next = 0;
        smc_tag_out_buf_S4_next = 0;
        smc_valid_out_buf_S4_next = 0;
    end
    else if (!stall_smc_buf_S4)
    begin
        smc_data_out_buf_S4_next = smc_data_out_S4;
        smc_tag_out_buf_S4_next = smc_tag_out_S4;
        smc_valid_out_buf_S4_next = smc_valid_out_S4;
    end
    else 
    begin
        smc_data_out_buf_S4_next = smc_data_out_buf_S4_f;
        smc_tag_out_buf_S4_next = smc_tag_out_buf_S4_f;
        smc_valid_out_buf_S4_next = smc_valid_out_buf_S4_f;
    end
end

always @ (posedge clk)
begin
    smc_data_out_buf_S4_f <= smc_data_out_buf_S4_next;
    smc_tag_out_buf_S4_f <= smc_tag_out_buf_S4_next;
    smc_valid_out_buf_S4_f <= smc_valid_out_buf_S4_next;
end
*/


always @ *
begin
    state_wr_addr_S4 = addr_S4_f[6+9-1:6]; 
end

always @ *
begin
    //invalidations may be interrupted by smc misses so the number of sharers may    
    //not be the same as the total number. In addition, the counter needs to 
    //consider the case that inv_acks for early invs come back before later invs     
    //are sent out
    if(!msg_from_mshr_S4 || recycled_S4_f)
    begin
        
        if (smc_miss_S4)
        begin
            state_data_in_real_S4 = {{2{1'b0}}, {4{1'b0}}, 
            {4{{2{1'b0}}, {2{1'b0}}, {1{1'b0}}, {4{1'b0}}, 
            (dir_sharer_counter_S4 - mshr_inv_counter_out_S4 - 6'b1)}}};
        end
        else
        
        begin
            state_data_in_real_S4 = {{2{1'b0}}, {4{1'b0}}, 
            {4{{2{1'b0}}, {2{1'b0}}, {1{1'b0}}, {4{1'b0}}, 
            (dir_sharer_counter_S4 - mshr_inv_counter_out_S4)}}};
        end
    end
    else
    begin
        
        if (smc_miss_S4)
        begin
            state_data_in_real_S4 = {{2{1'b0}}, {4{1'b0}}, 
            {4{{2{1'b0}}, {2{1'b0}}, {1{1'b0}}, {4{1'b0}}, 
            (dir_sharer_counter_S4 + l2_way_state_owner_S4_f - mshr_inv_counter_out_S4 - 6'b1)}}};
        end
        else
        
        begin
            state_data_in_real_S4 = {{2{1'b0}}, {4{1'b0}}, 
            {4{{2{1'b0}}, {2{1'b0}}, {1{1'b0}}, {4{1'b0}}, 
            (dir_sharer_counter_S4 + l2_way_state_owner_S4_f - mshr_inv_counter_out_S4)}}};
        end
    end
end

reg [4*15-1:0] state_way_data_mask_in_S4;



always @ *
begin
    state_way_data_mask_in_S4 = {{(4-1)*15{1'b0}},
                                {{2{1'b0}}, 
                                 {2{1'b0}}, 
                                 {1{1'b0}}, 
                                 {4{1'b0}}, 
                                 {6{state_wr_sel_S4}}}} 
    << (l2_way_sel_S4_f * 15); 
end


always @ *
begin
    state_data_mask_in_real_S4 = {{2{1'b0}}, 
                                 {4{1'b0}},
                                 state_way_data_mask_in_S4}; 
end


always @ *
begin
    state_data_mask_in_S4 = state_data_mask_in_S4_f | state_data_mask_in_real_S4;
end

always @ *
begin
    state_data_in_S4 = (state_data_in_S4_f & state_data_mask_in_S4_f) | 
                       (state_data_in_real_S4 & state_data_mask_in_real_S4);
end

reg [144-1:0] data_data_buf_S4_f;
reg [144-1:0] data_data_buf_S4_next;
reg [144-1:0] data_data_trans_S4;
reg [128-1:0] data_data_shift_S4;
wire corr_error1_S4, corr_error2_S4;
wire uncorr_error1_S4, uncorr_error2_S4;

always @ *
begin
    if (!rst_n)
    begin
        data_data_buf_S4_next = 0;
    end
    else if (stall_S4 && !stall_before_S4)
    begin
        data_data_buf_S4_next = data_data_S4;
    end
    else
    begin
        data_data_buf_S4_next = data_data_buf_S4_f;
    end
end



always @ (posedge clk)
begin
    data_data_buf_S4_f <= data_data_buf_S4_next;
end


always @ *
begin
    if (stall_before_S4)
    begin
        data_data_trans_S4 = data_data_buf_S4_f;
    end
    else
    begin
        data_data_trans_S4 = data_data_S4;
    end
end

l2_data_ecc data_ecc1 ( 
    .din                (data_data_trans_S4[63:0]),
    .parity             (data_data_trans_S4[71:64]),        
    .dout               (data_data_ecc_S4[63:0]),
    .corr_error         (corr_error1_S4),
    .uncorr_error       (uncorr_error1_S4)
);

l2_data_ecc data_ecc2 ( 
    .din                (data_data_trans_S4[135:72]),
    .parity             (data_data_trans_S4[143:136]),        
    .dout               (data_data_ecc_S4[127:64]),
    .corr_error         (corr_error2_S4),
    .uncorr_error       (uncorr_error2_S4)
);


always @ *
begin
    corr_error_S4 = corr_error1_S4 | corr_error2_S4; 
    uncorr_error_S4 = uncorr_error1_S4 | uncorr_error2_S4; 
end


always @ *
begin
    case (cas_cmp_data_size_S4)
    3'b011:  
    begin
        data_data_shift_S4 = {data_data_ecc_S4[63:0],data_data_ecc_S4[127:64]} << 32*addr_S4_f[3:2];
    end
    3'b100:
    begin
        data_data_shift_S4 = {data_data_ecc_S4[63:0], data_data_ecc_S4[127:64]} << 64*addr_S4_f[3];
    end
    default:
    begin
        data_data_shift_S4 = {data_data_ecc_S4[63:0], data_data_ecc_S4[127:64]};
    end
    endcase
end



always @ *
begin
    if (cas_cmp_en_S4)
    begin
    case (cas_cmp_data_size_S4)
        3'b011:  
        begin
            if (data_data_shift_S4[127:96] == msg_data_S4_f[31:0])
            begin
                cas_cmp_S4 = y;
            end
            else
            begin
                cas_cmp_S4 = n;
            end
        end
        3'b100:
        begin
            if (data_data_shift_S4[127:64] == msg_data_S4_f[63:0])
            begin
                cas_cmp_S4 = y;
            end
            else
            begin
                cas_cmp_S4 = n;
            end
        end
        default:
        begin
            cas_cmp_S4 = n;
        end
    endcase
    end
    else
    begin
        cas_cmp_S4 = n;
    end
end

always @ *
begin
    if (l2_evict_S4 
    && (msg_send_type_S4 == 8'd20
    ||  msg_send_type_S4 == 8'd18
    ||  msg_send_type_S4 == 8'd17))
    begin
        msg_send_addr_S4 = evict_addr_S4_f;
    end
    else if (msg_send_type_S4 == 8'd17
         ||  msg_send_type_S4 == 8'd18
         ||  msg_send_type_S4 == 8'd16)
    begin
        msg_send_addr_S4 = {addr_S4_f[39:6+9], addr_S4_f[6+9-1:6], {6{1'b0}}}; 
    end
    else if (msg_send_type_S4 == 8'd14)
    begin
        
        if (csm_en)
        begin 
            if (smc_miss_S4)
            begin 
                msg_send_addr_S4 = {smt_base_addr, smc_rd_addr_in_S4[15:2], 4'd0};
            end
            else
            begin
                msg_send_addr_S4 = addr_S4_f;
            end
        end
        else
        
        begin
            msg_send_addr_S4 = addr_S4_f;
        end
    end
    else    
    begin
        msg_send_addr_S4 = addr_S4_f;
    end
end

wire [(8-1) : 0] owner_x_S4; 
wire [(8-1) : 0] owner_y_S4; 
wire [(8-1) : 0] sharer_x_S4; 
wire [(8-1) : 0] sharer_y_S4; 
flat_id_to_xy owner_xy_gen(
    .flat_id            (l2_way_state_owner_S4_f),
    .x_coord            (owner_x_S4),
    .y_coord            (owner_y_S4)
);
flat_id_to_xy sharer_xy_gen(
    .flat_id            (dir_sharer_S4),
    .x_coord            (sharer_x_S4),
    .y_coord            (sharer_y_S4)
);

always @ *
begin
    case (msg_send_type_S4)
    8'd16, 8'd17: 
    begin
        
        if (csm_en)
        begin
            msg_send_dst_chipid_S4 = dir_data_S4[29:16];
            msg_send_dst_x_S4 = dir_data_S4[7:0];
            msg_send_dst_y_S4 = dir_data_S4[15:8];
        end
        else    
        
        begin


      
            msg_send_dst_chipid_S4 = my_nodeid_chipid_S4;
      
            msg_send_dst_x_S4 = owner_x_S4; 
            msg_send_dst_y_S4 = owner_y_S4;
        end
        msg_send_dst_fbits_S4 = 4'd0;
    end
    8'd18:
    begin
        
        if (csm_en)
        begin
            if (l2_way_state_mesi_S4_f == 2'b11)
            begin
                msg_send_dst_chipid_S4 = broadcast_chipid_out_S4;
                msg_send_dst_x_S4 = broadcast_x_out_S4;
                msg_send_dst_y_S4 = broadcast_y_out_S4;
            end
            else
            begin
                msg_send_dst_chipid_S4 = smc_data_out_S4[29:16];
                msg_send_dst_x_S4 = smc_data_out_S4[7:0];
                msg_send_dst_y_S4 = smc_data_out_S4[15:8];
            end
        end
        else
        
        begin
            msg_send_dst_chipid_S4 = my_nodeid_chipid_S4;
            msg_send_dst_x_S4 = sharer_x_S4; 
            msg_send_dst_y_S4 = sharer_y_S4;
        end
        msg_send_dst_fbits_S4 = 4'd0;
    end
    8'd28, 8'd29:
    begin
        msg_send_dst_chipid_S4 = src_chipid_S4_f;
        msg_send_dst_x_S4 = src_x_S4_f; 
        msg_send_dst_y_S4 = src_y_S4_f;
        msg_send_dst_fbits_S4 = 4'd0;

    end
    8'd19, 8'd14, 8'd15, 8'd20:
    begin
        msg_send_dst_chipid_S4 = {1'b1, my_nodeid_chipid_S4[12:0]};
        msg_send_dst_x_S4 = 0; 
        msg_send_dst_y_S4 = 0;
        msg_send_dst_fbits_S4 = 4'd2;
    end
    8'd33:
    begin
        msg_send_dst_chipid_S4 = my_nodeid_chipid_S4;
        msg_send_dst_x_S4 = my_nodeid_x_S4; 
        msg_send_dst_y_S4 = my_nodeid_y_S4;
        msg_send_dst_fbits_S4 = 4'd0;
    end
    default:
    begin
        msg_send_dst_chipid_S4 = my_nodeid_chipid_S4;
        msg_send_dst_x_S4 = my_nodeid_x_S4; 
        msg_send_dst_y_S4 = my_nodeid_y_S4;
        msg_send_dst_fbits_S4 = 4'd0;
    end
    endcase
end

always @ *
begin
    if (special_addr_type_S4)
    begin  
        if (addr_S4[39:32] == 8'ha0)
        begin
            if (addr_S4[31:30] == {2{1'b0}})
            begin
                if (addr_S4[3] == 0)
                begin
                    msg_send_data_S4 = {2{data_data_trans_S4[63:0]}}; 
                end
                else
                begin
                    msg_send_data_S4 = {2{data_data_trans_S4[135:72]}}; 
                end
            end
            else
            begin
                if (addr_S4[3] == 0)
                begin
                    msg_send_data_S4 = {2{56'b0, data_data_trans_S4[71:64]}}; 
                end
                else
                begin
                    msg_send_data_S4 = {2{56'b0, data_data_trans_S4[143:136]}}; 
                end
            end
        end
        else if (addr_S4[39:32] == 8'ha1)
        begin
            msg_send_data_S4 = {2{dir_data_sel_S4}}; 
        end
        
        else if (addr_S4[39:32] == 8'ha2)
        begin
            case (addr_S4[31:30])
            2'd0:
            begin
                msg_send_data_S4 = {2{{(64-30){1'b0}}, smc_data_out_S4}}; 
            end
            2'd1:
            begin
                msg_send_data_S4 = {2{{(64-4){1'b0}}, smc_valid_out_S4}}; 
            end
            2'd2: 
            begin
                msg_send_data_S4 = {2{{(64-14){1'b0}}, smc_tag_out_S4}}; 
            end
            default:
            begin
                msg_send_data_S4 = {128{1'b0}}; 
            end
            endcase
        end
        
        else if (addr_S4[39:32] == 8'ha9 
              || addr_S4[39:32] == 8'ha7
              || addr_S4[39:32] == 8'ha8
              || addr_S4[39:32] == 8'haa
              || addr_S4[39:32] == 8'hab)
        begin
            msg_send_data_S4 = {2{reg_data_out_S4}}; 
        end
        else
        begin
            msg_send_data_S4 = {2{msg_data_S4_f}}; 
        end 
    end
    else if ((msg_type_S4 == 8'd34 || msg_type_S4 == 8'd35) 
         &&  (msg_send_type_S4 == 8'd29))
    begin
        msg_send_data_S4 = {128{1'b0}}; 
    end  
    else if (msg_send_type_S4 == 8'd15 || (msg_send_type_S4 == 8'd33))
    begin
        msg_send_data_S4 = {2{msg_data_S4_f}}; 
    end






    else    
    begin
        msg_send_data_S4 = data_data_ecc_S4;
    end
end



always @ *
begin
    if (special_addr_type_S4 && (addr_S4[39:32] == 8'ha2))
    begin
        smc_rd_addr_in_S4 = addr_S4[16+3:4];
    end
    else if (msg_send_type_pre_S4 == 8'd18)
    begin
        smc_rd_addr_in_S4 = {sdid_S4, dir_sharer_S4};
    end
    else
    begin
        smc_rd_addr_in_S4 = {sdid_S4, l2_way_state_owner_S4_f};
    end
end




always @ *
begin
    mshr_data_in_S4 = {inv_fwd_pending_S4,
                       (req_recycle_S4 && (!msg_from_mshr_S4 || recycled_S4_f)),
                       smc_miss_S4,
                       smc_rd_addr_in_S4[5:0],
                       lsid_S4_f, 
                       sdid_S4,
                       src_fbits_S4_f,
                       src_y_S4_f,
                       src_x_S4_f,
                       src_chipid_S4_f,
                       l2_miss_S4,
                       msg_type_S4,
                       data_size_S4,
                       cache_type_S4,
                       mshrid_S4_f,
                       l2_way_sel_S4_f,
                       addr_S4_f};
end























/*
always @ *
begin
    mshr_data_mask_in_S2 = {`L2_MSHR_ARRAY_WIDTH{1'b1}}; 
end
*/
assign mshr_data_mask_in_S4 = {120+2{1'b1}}; 



endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe2_buf_in.v
//  Created On    : 2014-04-06
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : Input buffer for pipeline2
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module l2_pipe2_buf_in(

    input wire clk,
    input wire rst_n,

    input wire valid_in,
    input wire [64-1:0] data_in,
    output reg ready_in,

    output reg msg_header_valid_out,
    output reg [192-1:0] msg_header_out,
    input wire msg_header_ready_out,

    output reg msg_data_valid_out,
    output reg [128-1:0] msg_data_out,
    input wire msg_data_ready_out
);





localparam msg_data_state_0F = 4'd0;
localparam msg_data_state_1F = 4'd1; // NC load ack
localparam msg_data_state_2F = 4'd2;
localparam msg_data_state_4F = 4'd3;
localparam msg_data_state_8F = 4'd4;

localparam msg_state_header0 = 4'd0;
localparam msg_state_header1 = 4'd1;
localparam msg_state_header2 = 4'd2;
localparam msg_state_data0 = 4'd3;
localparam msg_state_data1 = 4'd4;
localparam msg_state_data2 = 4'd5;
localparam msg_state_data3 = 4'd6;
localparam msg_state_data4 = 4'd7;
localparam msg_state_data5 = 4'd8;
localparam msg_state_data6 = 4'd9;
localparam msg_state_data7 = 4'd10;

reg [4-1:0] msg_state_f;
reg [4-1:0] msg_state_next;

reg [4-1:0] msg_data_state_f;
reg [4-1:0] msg_data_state_next;

always @ *
begin
    if (!rst_n)
    begin
        msg_data_state_next = msg_data_state_0F;
    end
    else if((msg_state_f == msg_state_header0) && valid_in)
    begin
        if (data_in[29:22] == 8'd8)
        begin
            msg_data_state_next = msg_data_state_8F;
        end
        else if (data_in[29:22] == 8'd0)
        begin
            msg_data_state_next = msg_data_state_0F;
        end











        else    
        begin
            msg_data_state_next = msg_data_state_2F;
        end
    end
    else
    begin
        msg_data_state_next = msg_data_state_f;
    end
end

always @ (posedge clk)
begin
    msg_data_state_f <= msg_data_state_next;
end

always @ *
begin
    if (!rst_n)
    begin
        msg_state_next = msg_state_header0;
    end
    else if (valid_in && ready_in)
    begin
        if ((msg_state_f == msg_state_header0) && (data_in[21:14] != 8'd12))
        begin
            if (data_in[29:22] == 8'd0)
            begin
                msg_state_next = msg_state_header0;
            end
            else
            begin
                msg_state_next = msg_state_data0;
            end
        end










        else if ((msg_state_f == msg_state_data1) && (msg_data_state_f == msg_data_state_2F))
        begin
            msg_state_next = msg_state_header0;
        end
        else
        begin
            if (msg_state_f == msg_state_data7)
            begin
                msg_state_next = msg_state_header0;
            end
            else
            begin
                msg_state_next = msg_state_f + 4'd1;
            end
        end
    end
    else
    begin
        msg_state_next = msg_state_f;
    end 
end


always @ (posedge clk)
begin
    msg_state_f <= msg_state_next;
end

localparam msg_mux_header = 1'b0;
localparam msg_mux_data = 1'b1;

reg msg_mux_sel;

always @ *
begin
    if ((msg_state_f == msg_state_header0)
    ||  (msg_state_f == msg_state_header1)
    ||  (msg_state_f == msg_state_header2))
    begin
        msg_mux_sel = msg_mux_header;
    end
    else
        msg_mux_sel = msg_mux_data;
end


reg msg_header_valid_in;
reg [64-1:0] msg_header_in;
reg msg_header_ready_in;


reg msg_data_valid_in;
reg [64-1:0] msg_data_in;
reg msg_data_ready_in;


always @ *
begin
    if (msg_mux_sel == msg_mux_header)
    begin
        msg_header_valid_in = valid_in;
        msg_header_in = data_in;
    end
    else
    begin
        msg_header_valid_in = 0;
        msg_header_in = 0;
    end
end

always @ *
begin
    if (msg_mux_sel == msg_mux_data)
    begin
        msg_data_valid_in = valid_in;
        msg_data_in = data_in;
    end
    else
    begin
        msg_data_valid_in = 0;
        msg_data_in = 0;
    end
end

always @ *
begin
    if (msg_mux_sel == msg_mux_data)
    begin
        ready_in = msg_data_ready_in; 
    end
    else
    begin
        ready_in = msg_header_ready_in;
    end
end



reg [64-1:0] header_buf_mem_f [4-1:0];
reg header_buf_empty;
reg header_buf_full;
reg [2:0] header_buf_counter_f;
reg [2:0] header_buf_counter_next;
reg [2-1:0] header_rd_ptr_f;
reg [2-1:0] header_rd_ptr_next;
reg [2-1:0] header_rd_ptr_plus1;
reg [2-1:0] header_rd_ptr_plus2;
reg [2-1:0] header_wr_ptr_f;
reg [2-1:0] header_wr_ptr_next;


always @ *
begin
    header_buf_empty = (header_buf_counter_f == 0);
    header_buf_full = (header_buf_counter_f ==  4);
end

reg [1:0] msg_header_flits;

always @ *
begin
    msg_header_flits = 1;
    if (header_buf_mem_f[header_rd_ptr_f][21:14] == 8'd12)
    begin
        msg_header_flits = 3;
    end
    else
    begin
        msg_header_flits = 1;
    end
end

always @ *
begin
   if (!rst_n)
    begin
        header_buf_counter_next = 0;
    end
    else if ((msg_header_valid_in && msg_header_ready_in) && (msg_header_valid_out && msg_header_ready_out))
    begin
        header_buf_counter_next = header_buf_counter_f + 1 - msg_header_flits;
    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin 
        header_buf_counter_next = header_buf_counter_f + 1;
    end
    else if (msg_header_valid_out && msg_header_ready_out)
    begin 
        header_buf_counter_next = header_buf_counter_f - msg_header_flits;
    end
    else
    begin
        header_buf_counter_next = header_buf_counter_f;
    end
end



always @ (posedge clk)
begin
    header_buf_counter_f <= header_buf_counter_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        header_rd_ptr_next = 0;
    end
    else if (msg_header_valid_out && msg_header_ready_out)
    begin
        header_rd_ptr_next = header_rd_ptr_f + msg_header_flits;
    end
    else
    begin
        header_rd_ptr_next = header_rd_ptr_f;
    end
end


always @ (posedge clk)
begin
    header_rd_ptr_f <= header_rd_ptr_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        header_wr_ptr_next = 0;
    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin
        header_wr_ptr_next = header_wr_ptr_f + 1;
    end
    else
    begin
        header_wr_ptr_next = header_wr_ptr_f;
    end
end

always @ (posedge clk)
begin
    header_wr_ptr_f <= header_wr_ptr_next;
end


always @ *
begin
    header_rd_ptr_plus1 = header_rd_ptr_f + 1;
    header_rd_ptr_plus2 = header_rd_ptr_f + 2;
end


always @ *
begin
   msg_header_ready_in = !header_buf_full;
end


always @ *
begin
    msg_header_valid_out = (!header_buf_empty) && (header_buf_counter_f >= msg_header_flits);
end

always @ *
begin
    if (msg_header_flits == 3)
    begin
        msg_header_out = {header_buf_mem_f[header_rd_ptr_plus2], 
                          header_buf_mem_f[header_rd_ptr_plus1], 
                          header_buf_mem_f[header_rd_ptr_f]};
    end
    else
    begin
        msg_header_out = {{(2*64){1'b0}},header_buf_mem_f[header_rd_ptr_f]}; 
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin   
        header_buf_mem_f[0] <= 0;
        header_buf_mem_f[1] <= 0;
        header_buf_mem_f[2] <= 0;
        header_buf_mem_f[3] <= 0;

    end
    else if (msg_header_valid_in && msg_header_ready_in)
    begin
        header_buf_mem_f[header_wr_ptr_f] <= msg_header_in;
    end
    else
    begin 
        header_buf_mem_f[header_wr_ptr_f] <= header_buf_mem_f[header_wr_ptr_f];
    end
end



reg [64-1:0] data_buf_mem_f [16-1:0];
reg data_buf_empty;
reg data_buf_full;
reg [4:0] data_buf_counter_f;
reg [4:0] data_buf_counter_next;
reg [4-1:0] data_rd_ptr_f;
reg [4-1:0] data_rd_ptr_next;
reg [4-1:0] data_rd_ptr_plus1;
reg [4-1:0] data_wr_ptr_f;
reg [4-1:0] data_wr_ptr_next;
reg [4-1:0] data_wr_ptr_plus1;

always @ *
begin
    data_buf_empty = (data_buf_counter_f == 0);
    data_buf_full = (data_buf_counter_f ==  16);
end








always @ *
begin
    if ((msg_data_valid_in && msg_data_ready_in) && (msg_data_valid_out && msg_data_ready_out))
    begin



        data_buf_counter_next = data_buf_counter_f + 1 - 2;

    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin 



        data_buf_counter_next = data_buf_counter_f + 1;

    end
    else if (msg_data_valid_out && msg_data_ready_out)
    begin 
        data_buf_counter_next = data_buf_counter_f - 2;
    end
    else
    begin
        data_buf_counter_next = data_buf_counter_f;
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
        data_buf_counter_f <= 0;
    else
        data_buf_counter_f <= data_buf_counter_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        data_rd_ptr_next = 0;
    end
    else if (msg_data_valid_out && msg_data_ready_out)
    begin
        data_rd_ptr_next = data_rd_ptr_f + 2;
    end
    else
    begin
        data_rd_ptr_next = data_rd_ptr_f;
    end
end


always @ (posedge clk)
begin
    data_rd_ptr_f <= data_rd_ptr_next;
end

always @ *
begin
    if (!rst_n)
    begin   
        data_wr_ptr_next = 0;
    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin



        data_wr_ptr_next = data_wr_ptr_f + 1;

    end
    else
    begin
        data_wr_ptr_next = data_wr_ptr_f;
    end
end

always @ (posedge clk)
begin
    data_wr_ptr_f <= data_wr_ptr_next;
end


always @ *
begin
    data_rd_ptr_plus1 = data_rd_ptr_f + 1;



end

always @ *
begin
   msg_data_ready_in = !data_buf_full;
end


always @ *
begin
    msg_data_valid_out = (data_buf_counter_f >= 2);
    msg_data_out = {data_buf_mem_f[data_rd_ptr_plus1], data_buf_mem_f[data_rd_ptr_f]}; 
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin   
        data_buf_mem_f[0] <= 0;
        data_buf_mem_f[1] <= 0;
        data_buf_mem_f[2] <= 0;
        data_buf_mem_f[3] <= 0;
        data_buf_mem_f[4] <= 0;
        data_buf_mem_f[5] <= 0;
        data_buf_mem_f[6] <= 0;
        data_buf_mem_f[7] <= 0;
        data_buf_mem_f[8] <= 0;
        data_buf_mem_f[9] <= 0;
        data_buf_mem_f[10] <= 0;
        data_buf_mem_f[11] <= 0;
        data_buf_mem_f[12] <= 0;
        data_buf_mem_f[13] <= 0;
        data_buf_mem_f[14] <= 0;
        data_buf_mem_f[15] <= 0;

    end
    else if (msg_data_valid_in && msg_data_ready_in)
    begin
        data_buf_mem_f[data_wr_ptr_f] <= msg_data_in;








    end
    else
    begin 
        data_buf_mem_f[data_wr_ptr_f] <=  data_buf_mem_f[data_wr_ptr_f];



    end
end



endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe2_ctrl.v
//  Created On    : 2014-04-03
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The control unit for pipeline2 in the L2 cache
//
//
//====================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_pipe2_ctrl(

    input wire clk,
    input wire rst_n,
    
    input wire csm_en,
    
    //Inputs to Stage 1   

 
    input wire msg_header_valid_S1,
    input wire [8-1:0] msg_type_S1,
    input wire [8-1:0] msg_length_S1,
    input wire [3-1:0] msg_data_size_S1,
    input wire [1-1:0] msg_cache_type_S1,
    input wire [1-1:0] msg_last_subline_S1,
    input wire [2-1:0] msg_mesi_S1,

    //input wire mshr_hit_S1,
    input wire [8-1:0] mshr_msg_type_S1,
    input wire [1-1:0] mshr_l2_miss_S1,
    input wire [3-1:0] mshr_data_size_S1,
    input wire [1-1:0] mshr_cache_type_S1, 
    
    input wire mshr_smc_miss_S1,
    
    input wire [2-1:0] mshr_state_out_S1,
    input wire mshr_inv_fwd_pending_S1,

    input wire [40-1:0] addr_S1,
    input wire is_same_address_S1,

    //Inputs to Stage 2
   
 
    input wire l2_tag_hit_S2,
    input wire [2-1:0] l2_way_sel_S2,
    input wire l2_wb_S2,
    input wire [6-1:0] l2_way_state_owner_S2,
    input wire [2-1:0] l2_way_state_mesi_S2,
    input wire [2-1:0] l2_way_state_vd_S2,
    input wire [4-1:0] l2_way_state_subline_S2,
    input wire [1-1:0] l2_way_state_cache_type_S2,
    input wire addr_l2_aligned_S2,
    input wire subline_valid_S2,
    input wire [6-1:0] lsid_S2,

    
    input wire broadcast_counter_zero_S2,
    input wire broadcast_counter_max_S2,
    input wire [14-1:0] broadcast_chipid_out_S2,
    input wire [8-1:0] broadcast_x_out_S2,
    input wire [8-1:0] broadcast_y_out_S2,
    

    input wire msg_data_valid_S2,
    
    input wire [40-1:0] addr_S2,


    //Inputs to Stage 3
    input wire [40-1:0] addr_S3,

    //Outputs from Stage 1

    output reg valid_S1,  
    output reg stall_S1,
    output reg active_S1, 
    output reg msg_from_mshr_S1, 
 
    output reg mshr_rd_en_S1,
    //output reg mshr_cam_en_S1,

    output reg msg_header_ready_S1,

    output reg tag_clk_en_S1,
    output reg tag_rdw_en_S1,

    output reg state_rd_en_S1,

    //Outputs from Stage 2

    output reg valid_S2,    
    output reg stall_S2,  
    output reg stall_before_S2,
    output reg active_S2, 

    output reg msg_from_mshr_S2,
    output reg [8-1:0] msg_type_S2,
    output reg [3-1:0] data_size_S2,
    output reg [1-1:0] cache_type_S2,

    output reg dir_clk_en_S2,
    output reg dir_rdw_en_S2,
    output reg dir_clr_en_S2,


    output reg data_clk_en_S2,
    output wire data_rdw_en_S2,

    
    output reg [2-1:0] broadcast_counter_op_S2,
    output reg broadcast_counter_op_val_S2,
    

    output reg state_owner_en_S2,
    output reg [2-1:0] state_owner_op_S2,
    output reg state_subline_en_S2,
    output reg [2-1:0] state_subline_op_S2,
    output reg state_di_en_S2,
    output reg state_vd_en_S2,
    output reg [2-1:0] state_vd_S2,
    output reg state_mesi_en_S2,
    output reg [2-1:0] state_mesi_S2,
    output reg state_lru_en_S2,
    output reg [1-1:0] state_lru_op_S2,
    output wire state_rb_en_S2,

    output reg l2_load_64B_S2, 
    output reg l2_load_32B_S2, 
    output reg [2-1:0] l2_load_data_subline_S2,

    output reg msg_data_ready_S2,

    
    output reg smc_wr_en_S2,
    
    //Outputs from Stage 3
    output reg valid_S3,    
    output wire stall_S3,  
    output reg active_S3, 

    output reg [8-1:0] msg_type_S3,
    output reg mshr_wr_state_en_S3,
    output wire mshr_wr_data_en_S3,
    output reg [2-1:0] mshr_state_in_S3,
    output reg mshr_inc_counter_en_S3,
    output reg state_wr_en_S3

);




localparam y = 1'b1;
localparam n = 1'b0;


localparam rd = 1'b1;
localparam wr = 1'b0;


//============================
// Stage 1
//============================

reg stall_pre_S1;
reg [3-1:0] data_size_S1;
reg [1-1:0] cache_type_S1;

reg smc_miss_S1;

reg inv_fwd_pending_S1;

reg stall_hazard_S1;

always @ *
begin
    stall_hazard_S1 = (valid_S2 && (addr_S1[6+9-1:6] == addr_S2[6+9-1:6])) ||
                      (valid_S3 && (addr_S1[6+9-1:6] == addr_S3[6+9-1:6]));
end


always @ *
begin
    valid_S1 = msg_header_valid_S1;
end


always @ *
begin
    stall_pre_S1 = stall_S2; 
end


always @ *
begin
    mshr_rd_en_S1 = valid_S1 && (msg_type_S1 != 8'd12) && (msg_type_S1 != 8'd25);
end

/*
always @ *
begin
    mshr_cam_en_S1 = valid_S1 && (msg_type_S1 == `MSG_TYPE_WB_REQ);
end
*/
always @ *
begin
    msg_from_mshr_S1 = mshr_rd_en_S1
                    && (mshr_state_out_S1 != 2'd0); 
end


always @ *
begin
    if (msg_from_mshr_S1)
    begin
        data_size_S1 = mshr_data_size_S1;
    end
    else
    begin
        data_size_S1 = msg_data_size_S1;
    end
end

always @ *
begin
    if (msg_from_mshr_S1)
    begin
        cache_type_S1 = mshr_cache_type_S1;
    end
    else
    begin
        cache_type_S1 = msg_cache_type_S1;
    end
end

always @ *
begin
    if (msg_from_mshr_S1)
    begin
        inv_fwd_pending_S1 = mshr_inv_fwd_pending_S1;
    end
    else
    begin
        inv_fwd_pending_S1 = 1'b0;
    end
end


reg [3-1:0] cs_S1;

always @ *
begin
    cs_S1 = {3{1'bx}};
    if (valid_S1)
    begin
        case (msg_type_S1)
        8'd23:
        begin
            //       tag_clk_en      tag_rdw_en   state_rd_en
            cs_S1 = {n,              rd,           y};
        end
        8'd21, 8'd22:
        begin
            cs_S1 = {n,              rd,         y};
        end
        8'd24, 8'd26:
        begin
            
            if (smc_miss_S1)
            begin
                cs_S1 = {n,              rd,           n};
            end
            else
            
            begin
                cs_S1 = {y,              wr,         n};
            end
        end
        8'd25, 8'd27:
        begin
            cs_S1 = {n,              rd,         n};
        end
        8'd12:
        begin
            cs_S1 = {y,              rd,          y};
        end
        default:
        begin
            cs_S1 = {3{1'bx}};
        end
        endcase
    end
    else
    begin
        cs_S1 = {3{1'b0}};
    end
end





always @ *
begin
    stall_S1 = valid_S1 && (stall_pre_S1 || stall_hazard_S1);
end

always @ *
begin
    msg_header_ready_S1 = !stall_S1; 
end


always @ *
begin
    tag_clk_en_S1 = valid_S1 && !stall_S1 && cs_S1[2];
end

always @ *
begin
    tag_rdw_en_S1 = valid_S1 && !stall_S1 && cs_S1[1];
end

always @ *
begin
    state_rd_en_S1 =  valid_S1 && !stall_S1 && cs_S1[0];
end


always @ *
begin
    if (msg_from_mshr_S1)
    begin
        smc_miss_S1 = mshr_smc_miss_S1;
    end
    else
    begin
        smc_miss_S1 = 0;
    end
end


reg valid_next_S1;

always @ *
begin
    valid_next_S1 = valid_S1 && !stall_S1;
end

always @ *
begin
    active_S1 = valid_S1;
//             || (valid_S1 && msg_type_S1 == `MSG_TYPE_WB_REQ)
//             || (valid_S2 && msg_type_S2_f == `MSG_TYPE_WB_REQ);
end


//============================
// Stage 1 -> Stage 2
//============================

reg valid_S2_f;
reg [8-1:0] msg_length_S2_f;
reg [1-1:0] msg_last_subline_S2_f;
reg [3-1:0] data_size_S2_f;
reg [1-1:0] cache_type_S2_f;
reg msg_from_mshr_S2_f;
reg [2-1:0] msg_mesi_S2_f;

reg smc_miss_S2_f;

reg [8-1:0] msg_type_S2_f;
reg inv_fwd_pending_S2_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        valid_S2_f <= 1'b0;
        msg_type_S2_f <= 0;
        msg_length_S2_f <= 0;
        msg_last_subline_S2_f <= 0;
        data_size_S2_f <= 0;  
        cache_type_S2_f <= 0; 
        msg_from_mshr_S2_f <= 1'b0;
        msg_mesi_S2_f <= 0;
        
        smc_miss_S2_f <= 0;
        
        inv_fwd_pending_S2_f <= 0;
    end
    else if (!stall_S2)
    begin
        valid_S2_f <= valid_next_S1;
        msg_type_S2_f <= msg_type_S1;
        msg_length_S2_f <= msg_length_S1;
        msg_last_subline_S2_f <= msg_last_subline_S1;
        data_size_S2_f <= data_size_S1;
        cache_type_S2_f <= cache_type_S1;
        msg_from_mshr_S2_f <= msg_from_mshr_S1;
        msg_mesi_S2_f <= msg_mesi_S1;
        
        smc_miss_S2_f <= smc_miss_S1;
        
        inv_fwd_pending_S2_f <= inv_fwd_pending_S1;
    end
end

//============================
// Stage 2
//============================

reg stall_real_S2;
reg stall_load_S2;
reg stall_before_S2_f;
reg stall_before_S2_next;
reg state_wr_en_S2;
reg mshr_wr_state_en_S2;
reg [2-1:0] mshr_state_in_S2;

always @ *
begin
    valid_S2 = valid_S2_f;
    msg_type_S2 = msg_type_S2_f;
    msg_from_mshr_S2 = msg_from_mshr_S2_f;
    data_size_S2 = data_size_S2_f;
    cache_type_S2 = cache_type_S2_f;
    stall_before_S2 = stall_before_S2_f;
end

always @ *
begin
    if (!rst_n)
    begin
        stall_before_S2_next = 0;
    end
    else
    begin
        stall_before_S2_next = stall_S2;
    end
end

always @ (posedge clk)
begin
    stall_before_S2_f <= stall_before_S2_next;
end


reg is_last_subline_S2;


always @ *
begin
    is_last_subline_S2 = msg_last_subline_S2_f;
end




reg [19-1:0] cs_S2;

always @ *
begin
    if (valid_S2)
    begin
    case (msg_type_S2_f)
        8'd21:
        begin
            case (l2_way_state_mesi_S2)
            2'b10:
            begin
                if (is_last_subline_S2)
                begin
                    
                    if (csm_en)
                    begin
                        if (lsid_S2 == 6'd63)
                        begin
                            if (subline_valid_S2)   
                            begin
                                if (msg_length_S2_f != 0)
                                begin
                                    //       data   dir        dir         dir      state      state        state        state       state 
                                    //       clk_en clk_en     rdw_en      clr_en   owner_en   owner_op     subline_en   subline_op  di_en  
                                    cs_S2 = {y,     y,         wr,         y,        y,         2'd0,     n,           2'd0,    n, 
                                    //       state   state          state    state           state   state
                                    //       vd_en   vd             mesi_en  mesi            lru_en  lru
                                             y,      2'b11,  y,      2'b11,      n,      1'b0};  
                                end     
                                else
                                begin       
                                    cs_S2 = {n,     y,         wr,         y,        y,         2'd0,     n,           2'd0,    n, 
                                             y,      2'b11,  y,      2'b11,      n,      1'b0};  

                                end
                            end
                            else
                            begin
                                cs_S2 = {n,     n,         wr,         n,       y,         2'd0,     n,           2'd0,    n, 
                                         y,      2'b11,  y,      2'b11,      n,      1'b0};    
                            end
                        end
                        else
                        begin
                            if (subline_valid_S2)   
                            begin
                                if (msg_length_S2_f != 0)
                                begin
                                    //       data   dir        dir         dir      state      state        state        state       state 
                                    //       clk_en clk_en     rdw_en      clr_en   owner_en   owner_op     subline_en   subline_op  di_en  
                                    cs_S2 = {y,     y,         wr,         n,        y,         2'd1,     y,           2'd1,    n, 
                                    //       state   state          state    state           state   state
                                    //       vd_en   vd             mesi_en  mesi            lru_en  lru
                                             y,      2'b11,  y,      2'b01,      n,      1'b0};  
                                end     
                                else
                                begin       
                                    cs_S2 = {n,     y,         wr,         n,        y,         2'd1,     y,           2'd1,    n, 
                                             y,      2'b11,  y,      2'b01,      n,      1'b0};  

                                end
                            end
                            else
                            begin
                                cs_S2 = {n,     y,         wr,         n,       y,         2'd1,     y,           2'd1,    n, 
                                         y,      2'b11,  y,      2'b01,      n,      1'b0};    
                            end
                        end
                    end
                    else
                    
                    begin
                        if (subline_valid_S2)   
                        begin
                            if (msg_length_S2_f != 0)
                            begin
                                //       data   dir        dir         dir      state      state        state        state       state 
                                //       clk_en clk_en     rdw_en      clr_en   owner_en   owner_op     subline_en   subline_op  di_en  
                                cs_S2 = {y,     y,         wr,         n,        y,         2'd0,     n,           2'd0,    n, 
                                //       state   state          state    state           state   state
                                //       vd_en   vd             mesi_en  mesi            lru_en  lru
                                         y,      2'b11,  y,      2'b01,      n,      1'b0};  
                            end     
                            else
                            begin       
                                cs_S2 = {n,     y,         wr,         n,        y,         2'd0,     n,           2'd0,    n, 
                                         y,      2'b11,  y,      2'b01,      n,      1'b0};  

                            end
                        end
                        else
                        begin
                            cs_S2 = {n,     y,         wr,         n,       y,         2'd0,     n,           2'd0,    n, 
                                     y,      2'b11,  y,      2'b01,      n,      1'b0};    
                        end

                    end
                end
                else
                begin
                    if (subline_valid_S2)   
                    begin
                        if (msg_length_S2_f != 0)
                        begin
                            cs_S2 = {y,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                     n,      2'b01,  n,      2'b00,  n,      1'b0};
                        end
                        else
                        begin
                            cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                     n,      2'b01,  n,      2'b00,  n,      1'b0};
                        end
                    end
                    else
                    begin
                        cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                 n,      2'b01,  n,      2'b00,  n,      1'b0};
                    end
                end  
            end
            2'b00:
            begin
                cs_S2 = {n,     n,         rd,         n,       n,         2'd0,      n,           2'd0,    n,       
                         n,      2'b01,  n,      2'b00,  n,      1'b0};
            end
            default:
            begin
                cs_S2 = {19{1'bx}};
            end
            endcase
        end
        8'd22:
        begin
            case (l2_way_state_mesi_S2)
            2'b10:
            begin
                if (is_last_subline_S2)
                begin
                    if (subline_valid_S2)   
                    begin
                        if (msg_length_S2_f != 0)
                        begin
                            cs_S2 = {y,     y,         wr,         y,       y,         2'd0,     y,           2'd0,    n, 
                                     y,      2'b11,  y,      2'b00,      n,      1'b0};  
                        end
                        else
                        begin
                            cs_S2 = {n,     y,         wr,         y,       y,         2'd0,     y,           2'd0,    n, 
                                     y,      2'b11,  y,      2'b00,      n,      1'b0};  
                        end
                        
                    end
                    else
                    begin
                        cs_S2 = {n,     y,         wr,         y,       y,         2'd0,     y,           2'd0,    n, 
                                 y,      2'b11,  y,      2'b00,      n,      1'b0};  
                    end  
                end
                else
                begin
                    if (subline_valid_S2)   
                    begin
                        if (msg_length_S2_f != 0)
                        begin
                            cs_S2 = {y,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                     n,      2'b01,  n,      2'b00,  n,      1'b0};
                        end
                        else
                        begin
                            cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                     n,      2'b01,  n,      2'b00,  n,      1'b0};
                        end
                    end
                    else
                    begin
                        cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                                 n,      2'b01,  n,      2'b00,  n,      1'b0};
                    end 
                end 
            end
            2'b00:
            begin
                cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                         n,      2'b01,  n,      2'b00,  n,      1'b0};
            end
            default:
            begin
                cs_S2 = {19{1'bx}};
            end
            endcase
        end
        8'd23:
        begin
            if (is_last_subline_S2)
            begin
                
                if (l2_way_state_mesi_S2 == 2'b11)
                begin   
                    if (broadcast_counter_max_S2)
                    begin
                        cs_S2 = {n,     n,         rd,         n,       y,         2'd0,     y,           2'd0,    n, 
                                 n,      2'b01,  y,      2'b00,      n,      1'b0};    
                    end
                    else
                    begin
                        cs_S2 = {n,     n,         rd,         n,       y,         2'd3,     n,           2'd0,    n, 
                                 n,      2'b01,  n,      2'b00, n,      1'b0};    
                    end
                end
                else 
                
                begin
                    
                    if ((l2_way_state_owner_S2 == 1) && (~smc_miss_S2_f) && (~inv_fwd_pending_S2_f))
                    


                    begin
                        cs_S2 = {n,     n,         rd,         n,       y,         2'd0,     y,           2'd0,    n, 
                                 n,      2'b01,  y,      2'b00,      n,      1'b0};    
                    end
                    else
                    begin
                        cs_S2 = {n,     n,         rd,         n,       y,         2'd3,     n,           2'd0,    n, 
                                 n,      2'b01,  n,      2'b00, n,      1'b0};    
                    end
                end
            end
            else
            begin
                cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                         n,      2'b01,  n,      2'b00,  n,      1'b0};
            end  
        end

        8'd24:
        begin
            cs_S2 = {y,     y,         wr,         y,       n,         2'd0,     y,           2'd0,    n,       
                     y,      2'b10,  n,      2'b00,  n,      1'b0};
        end
        8'd26:
        begin
            
            if (smc_miss_S2_f)
            begin
                cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                         n,      2'b10,  n,      2'b00,  n,      1'b0};
            end
            else
            
            begin
                cs_S2 = {y,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                         y,      2'b10,  n,      2'b00,  n,      1'b0};
            end
        end
        8'd25, 8'd27:
        begin
            cs_S2 = {n,     n,         rd,         n,       n,         2'd0,     n,           2'd0,    n,       
                     n,      2'b01,  n,      2'b00,  n,      1'b0};
        end
        8'd12:
        begin
            begin
            //should be the last line
            if (l2_way_state_subline_S2 == ({{(4-1){1'b0}}, 1'b1} << addr_S2[5:4]))
            begin
                cs_S2 = {y,     y,         wr,         y,       n,         2'd0,     y,        2'd3,    n,       
                         y,     2'b11,  y,      2'b00,     n,      1'b0};
            end
            else
            begin
                cs_S2 = {y,     n,         rd,         n,       n,         2'd0,     y,        2'd3,    n,       
                         n,      2'b01,  n,      2'b00,     n,      1'b0};
            end
            end
         end
        default:
        begin
            cs_S2 = {19{1'bx}};
        end
    endcase
    end
    else    
    begin
        cs_S2 = {19{1'b0}};
    end
end





always @ *
begin
    broadcast_counter_op_val_S2 = !stall_S2 && valid_S2 && is_last_subline_S2 
                               && (msg_type_S2_f == 8'd23) && (l2_way_state_mesi_S2 == 2'b11);
end

always @ *
begin
    if (broadcast_counter_max_S2)
    begin
        broadcast_counter_op_S2 = 2'd0;
    end
    else
    begin
        broadcast_counter_op_S2 = 2'd2;
    end
end


always @ *
begin
    dir_clk_en_S2 = !stall_S2 && cs_S2[17];
end

always @ *
begin
    dir_rdw_en_S2 = cs_S2[16];
end


always @ *
begin
    dir_clr_en_S2 = cs_S2[15];
end

always @ *
begin
    data_clk_en_S2 = !stall_real_S2 && cs_S2[18];
end
/*
always @ *
begin
    data_rdw_en_S2 = wr;
end
*/
assign data_rdw_en_S2 = wr;


always @ *
begin
    if (msg_type_S2_f == 8'd12 || msg_type_S2_f == 8'd25)
    begin
        mshr_wr_state_en_S2 = n;
        mshr_state_in_S2 = 2'd0;
    end
    else if (msg_type_S2_f == 8'd23 
          || msg_type_S2_f == 8'd21
          || msg_type_S2_f == 8'd22)
    begin
        if (is_last_subline_S2)
        begin
             
            if (msg_type_S2_f == 8'd23 
            && ((l2_way_state_owner_S2 != 1) || smc_miss_S2_f || inv_fwd_pending_S2_f))
            



            begin
                mshr_wr_state_en_S2 = n;
                mshr_state_in_S2 = 2'd0;
            end
            else
            begin
                mshr_wr_state_en_S2 = !stall_S2;
                mshr_state_in_S2 = 2'd2;
            end
        end
        else
        begin
            mshr_wr_state_en_S2 = n;
            mshr_state_in_S2 = 2'd0;
        end
    end
    else
    begin
        mshr_wr_state_en_S2 = !stall_S2;
        mshr_state_in_S2 = 2'd2;
    end
end


always @ *
begin
    state_owner_en_S2 = !stall_S2 && cs_S2[14];
end


always @ *
begin
    state_owner_op_S2 = cs_S2[13:12];
end

always @ *
begin
    state_subline_en_S2 = !stall_S2 && cs_S2[11];
end

always @ *
begin
    state_subline_op_S2 = cs_S2[10:9];
end

always @ *
begin
    state_di_en_S2 = cs_S2[8];
end

always @ *
begin
    state_vd_en_S2 = !stall_S2 && cs_S2[7];
end

always @ *
begin
    state_vd_S2 = cs_S2[6:5];
end

always @ *
begin
    state_mesi_en_S2 = !stall_S2 && cs_S2[4];
end

always @ *
begin
    state_mesi_S2 = cs_S2[3:2];
end

always @ *
begin
    state_lru_en_S2 = !stall_S2 && cs_S2[1];
end

always @ *
begin
    state_lru_op_S2 = cs_S2[0];
end

always @ *
begin
    state_wr_en_S2 = !stall_S2 && (state_owner_en_S2 || state_subline_en_S2 || state_vd_en_S2
                  ||  state_di_en_S2 || state_mesi_en_S2 || state_lru_en_S2 || state_rb_en_S2);
end



always @ *
begin
    msg_data_ready_S2 = !stall_real_S2 && (data_clk_en_S2 || smc_wr_en_S2);
end






/*
always @ *
begin
    state_rb_en_S2 = n; 
end
*/

always @ *
begin
    smc_wr_en_S2 = valid_S2 && smc_miss_S2_f && (msg_type_S2_f == 8'd26);
end



assign state_rb_en_S2 = n;

always @ *
begin
    if (msg_type_S2_f == 8'd24)
    begin
        l2_load_64B_S2 = y;
        l2_load_32B_S2 = n;
    end







    else    
    begin
        l2_load_64B_S2 = n;
        l2_load_32B_S2 = n;
    end
end

reg [2-1:0] l2_load_data_subline_S2_f;
reg [2-1:0] l2_load_data_subline_S2_next;

always @ *
begin
    if (!rst_n)
    begin
        l2_load_data_subline_S2_next = 2'd0;
    end










    else if (valid_S2 && !stall_real_S2 && l2_load_64B_S2)
    begin
        l2_load_data_subline_S2_next = l2_load_data_subline_S2_f + 1;
    end

    else
    begin
        l2_load_data_subline_S2_next = l2_load_data_subline_S2_f;
    end
end

always @ (posedge clk)
begin
    l2_load_data_subline_S2_f <= l2_load_data_subline_S2_next;
end


always @ *
begin
    if (l2_load_64B_S2)
    begin
        stall_load_S2 = (l2_load_data_subline_S2_f != 2'd3);
    end






    else
    begin
        stall_load_S2 = n;
    end
end


always @ *
begin
    l2_load_data_subline_S2 = l2_load_data_subline_S2_f;
end


always @ *
begin
    stall_real_S2 = valid_S2 && ((cs_S2[18] || smc_wr_en_S2) && !msg_data_valid_S2);
end






always @ *
begin
    stall_S2 = valid_S2 && (stall_real_S2 || stall_load_S2);
end




always @ *
begin
    active_S2 = valid_S2;
end

reg valid_next_S2;

always @ *
begin
    valid_next_S2 = valid_S2 && !stall_S2;
end


//============================
// Stage 2 -> Stage 3
//============================

reg valid_S3_f;
reg state_wr_en_S3_f;
reg mshr_wr_state_en_S3_f;
reg [2-1:0] mshr_state_in_S3_f;

reg smc_miss_S3_f;

reg msg_from_mshr_S3_f;
reg [8-1:0] msg_type_S3_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        valid_S3_f <= 1'b0;
        state_wr_en_S3_f <= 1'b0;
        mshr_wr_state_en_S3_f <= 0;
        mshr_state_in_S3_f <= 0;
        
        smc_miss_S3_f <= 0;
        
        msg_from_mshr_S3_f <= 0;
        msg_type_S3_f <= 0;
    end
    else if (!stall_S3)
    begin
        valid_S3_f <= valid_next_S2;
        state_wr_en_S3_f <= state_wr_en_S2;
        mshr_wr_state_en_S3_f <= mshr_wr_state_en_S2;
        mshr_state_in_S3_f <= mshr_state_in_S2;
        
        smc_miss_S3_f <= smc_miss_S2_f;
        
        msg_from_mshr_S3_f <= msg_from_mshr_S2_f;
        msg_type_S3_f <= msg_type_S2_f;
    end
end

//============================
// Stage 3
//============================



always @ *
begin
    valid_S3 = valid_S3_f;
    state_wr_en_S3 = !stall_S3 && valid_S3 && state_wr_en_S3_f;
    mshr_wr_state_en_S3 = !stall_S3 && valid_S3 && mshr_wr_state_en_S3_f;
    mshr_state_in_S3 = mshr_state_in_S3_f;
    msg_type_S3 = msg_type_S3_f;
end

assign mshr_wr_data_en_S3 = 1'b0;


always @ *
begin
    mshr_inc_counter_en_S3 = valid_S3 && (msg_type_S3_f == 8'd23);
end

always @ *
begin
    active_S3 = valid_S3;
end

assign stall_S3 = 1'b0;

/*
//============================
// Debug
//============================

`ifndef SYNTHESIS


wire [15*8-1:0] msg_type_string_S1;
wire [15*8-1:0] msg_type_string_S2;

l2_msg_type_parse msg_type_parse_S1(
    .msg_type (msg_type_S1),
    .msg_type_string (msg_type_string_S1)
);

always @ (posedge clk)
begin
    if (valid_S1 && !stall_S1)
    begin
        $display("-------------------------------------");
        $display($time);
        $display("P2S1 msg type: %s, data_size: %b, cache_type: %b, last_subline: %b", msg_type_string_S1, data_size_S1, cache_type_S1, msg_last_subline_S1);
        $display("P2S1 valid: stall: %b, stall_pre: %b, stall_hazard: %b",
                  stall_S1, stall_pre_S1, stall_hazard_S1);
        $display("Control signals: %b", cs_S1);
        $display("Msg from mshr: %b", msg_from_mshr_S1);
    end
end


l2_msg_type_parse msg_type_parse_S2(
    .msg_type (msg_type_S2_f),
    .msg_type_string (msg_type_string_S2)
);

always @ (posedge clk)
begin
    if (valid_S2 && !stall_S2)
    begin
        $display("-------------------------------------");
        $display($time);
        $display("P2S2 msg type: %s, data_size: %b, cache_type: %b, last_subline: %b", msg_type_string_S2, data_size_S2_f, cache_type_S2_f,msg_last_subline_S2_f);
        $display("P2S2 valid: stall: %b, stall_real: %b, stall_load: %b",
                  stall_S2, stall_real_S2,stall_load_S2);
        $display("Control signals: %b", cs_S2);
        $display("Msg from mshr: %b", msg_from_mshr_S2);
    end
end




`endif
*/
endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_pipe2_dpath.v
//  Created On    : 2014-04-03
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The datapath for pipeline2 in the L2 cache
//
//
//==================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml


module l2_pipe2_dpath(

    input wire clk,
    input wire rst_n,

    //Inputs to Stage 1   

    input wire [40-1:0] mshr_addr_S1,
    input wire [8-1:0] mshr_mshrid_S1,
    input wire [2-1:0] mshr_way_S1,
    input wire [14-1:0] mshr_src_chipid_S1,
    input wire [8-1:0] mshr_src_x_S1,
    input wire [8-1:0] mshr_src_y_S1,
    input wire [4-1:0] mshr_src_fbits_S1,
    input wire [10-1:0] mshr_sdid_S1,
    input wire [6-1:0] mshr_lsid_S1,
    input wire [6-1:0] mshr_miss_lsid_S1,


    input wire [40-1:0] msg_addr_S1,
    input wire [8-1:0] msg_type_S1,
    input wire [2-1:0] msg_subline_id_S1,
    input wire [8-1:0] msg_mshrid_S1,
    input wire [14-1:0] msg_src_chipid_S1,
    input wire [8-1:0] msg_src_x_S1,
    input wire [8-1:0] msg_src_y_S1,
    input wire [4-1:0] msg_src_fbits_S1,
    input wire [10-1:0] msg_sdid_S1,
    input wire [6-1:0] msg_lsid_S1,

    input wire valid_S1,
    input wire stall_S1,
    input wire msg_from_mshr_S1, 
    
    //Inputs to Stage 2   

    input wire [15*4+2+4-1:0] state_data_S2,
    input wire [100-1:0] tag_data_S2,

    input wire [128-1:0] msg_data_S2,

    input wire msg_from_mshr_S2,
    input wire [8-1:0] msg_type_S2,
   
    input wire [3-1:0] data_size_S2,
    input wire [1-1:0] cache_type_S2,
    input wire state_owner_en_S2,
    input wire [2-1:0] state_owner_op_S2,
    input wire state_subline_en_S2,
    input wire [2-1:0] state_subline_op_S2,
    input wire state_di_en_S2,
    input wire state_vd_en_S2,
    input wire [2-1:0] state_vd_S2,
    input wire state_mesi_en_S2,
    input wire [2-1:0] state_mesi_S2,
    input wire state_lru_en_S2,
    input wire [1-1:0] state_lru_op_S2,
    input wire state_rb_en_S2,
    input wire dir_clr_en_S2,
   
    input wire l2_load_64B_S2, 
    input wire l2_load_32B_S2, 
    input wire [2-1:0] l2_load_data_subline_S2,
 
    input wire valid_S2,
    input wire stall_S2,
    input wire stall_before_S2,

    //Inputs to Stage 3 
    input wire valid_S3,
    input wire stall_S3,
    
    //Outputs from Stage 1
    
    output reg [40-1:0] addr_S1,
    output reg [3-1:0] mshr_rd_index_S1,
    output reg [9-1:0] tag_addr_S1,
    output reg [9-1:0] state_rd_addr_S1,
    
    output reg [100-1:0] tag_data_in_S1,
    output reg [100-1:0] tag_data_mask_in_S1,
    output reg is_same_address_S1,

    //Outputs from Stage 2
   
 
    output reg [40-1:0] addr_S2,
    output reg l2_tag_hit_S2,
    output reg [2-1:0] l2_way_sel_S2,
    output reg l2_wb_S2,
    output reg [6-1:0] l2_way_state_owner_S2,
    output reg [2-1:0] l2_way_state_mesi_S2,
    output reg [2-1:0] l2_way_state_vd_S2,
    output reg [4-1:0] l2_way_state_subline_S2,
    output reg [1-1:0] l2_way_state_cache_type_S2,
    output reg addr_l2_aligned_S2,
    output reg subline_valid_S2, 
    output reg [6-1:0] lsid_S2,

    output reg [9+2-1:0] dir_addr_S2,
    output reg [64-1:0] dir_data_in_S2,
    output wire [64-1:0] dir_data_mask_in_S2,

    output reg [9+2+2-1:0] data_addr_S2,
    output reg [144-1:0] data_data_in_S2,
    output wire [144-1:0] data_data_mask_in_S2,

    
    output reg [16-1:0] smc_wr_addr_in_S2,
    output reg [128-1:0] smc_data_in_S2,
    

    //Outputs from Stage 3
    output reg [40-1:0] addr_S3,
    output reg [3-1:0] mshr_wr_index_S3,
    output wire [120+2-1:0] mshr_data_in_S3,
    output wire [120+2-1:0] mshr_data_mask_in_S3,
    output reg [9-1:0] state_wr_addr_S3,
    output reg [15*4+2+4-1:0] state_data_in_S3,
    output reg [15*4+2+4-1:0] state_data_mask_in_S3

);


//============================
// Stage 1
//============================

reg [8-1:0] mshrid_S1;
reg [14-1:0] src_chipid_S1;
reg [8-1:0] src_x_S1;
reg [8-1:0] src_y_S1;
reg [4-1:0] src_fbits_S1;
reg [10-1:0] sdid_S1;
reg [6-1:0] lsid_S1;

always @ *
begin
    if (msg_from_mshr_S1)
    begin




        addr_S1 = {mshr_addr_S1[39:6+9], mshr_addr_S1[6+9-1:6],
                         msg_subline_id_S1, mshr_addr_S1[3:0]};
 // L2_SEND_NC_REQ
        src_chipid_S1 = mshr_src_chipid_S1;
        src_x_S1 = mshr_src_x_S1;   
        src_y_S1 = mshr_src_y_S1;   
        src_fbits_S1 = mshr_src_fbits_S1;
        sdid_S1 = mshr_sdid_S1;
        lsid_S1 = mshr_lsid_S1;
    end
    else
    begin
        addr_S1 = msg_addr_S1;
        src_chipid_S1 = msg_src_chipid_S1;
        src_x_S1 = msg_src_x_S1;   
        src_y_S1 = msg_src_y_S1;   
        src_fbits_S1 = msg_src_fbits_S1;
        sdid_S1 = msg_sdid_S1;
        lsid_S1 = msg_lsid_S1;
    end
end

always @ *
begin
    is_same_address_S1 = (mshr_addr_S1 == msg_addr_S1);
end

always @ *
begin
    mshrid_S1 = msg_mshrid_S1;
end


always @ *
begin
    mshr_rd_index_S1 = msg_mshrid_S1;
end


always @ *
begin
    tag_addr_S1 = addr_S1[6+9-1:6];
end

always @ *
begin
    state_rd_addr_S1 = addr_S1[6+9-1:6];
end


always @ *
begin
    tag_data_in_S1 = {4{addr_S1[39:6+9]}};
end

always @ *
begin
    tag_data_mask_in_S1 = {{(4-1)*25{1'b0}},{25{1'b1}}} 
                       << (mshr_way_S1 * 25);
end


//============================
// Stage 1 -> Stage 2
//============================


reg [40-1:0] addr_S2_f;
reg [8-1:0] mshrid_S2_f;
reg [14-1:0] src_chipid_S2_f;
reg [8-1:0] src_x_S2_f;
reg [8-1:0] src_y_S2_f;
reg [4-1:0] src_fbits_S2_f;
reg [10-1:0] sdid_S2_f;
reg [6-1:0] lsid_S2_f;
reg [2-1:0] mshr_way_S2_f;
reg [2-1:0] msg_subline_id_S2_f;
reg [6-1:0] mshr_miss_lsid_S2_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        addr_S2_f <= 0; 
        mshrid_S2_f <= 0;
        src_chipid_S2_f <= 0;
        src_x_S2_f <= 0;
        src_y_S2_f <= 0;
        src_fbits_S2_f <= 0;
        sdid_S2_f <= 0;
        lsid_S2_f <= 0;
        mshr_way_S2_f <= 0;
        msg_subline_id_S2_f <= 0;
        mshr_miss_lsid_S2_f <= 0;
    end
    else if (!stall_S2)
    begin
        addr_S2_f <= addr_S1;
        mshrid_S2_f <= mshrid_S1;
        src_chipid_S2_f <= src_chipid_S1;
        src_x_S2_f <= src_x_S1;
        src_y_S2_f <= src_y_S1;
        src_fbits_S2_f <= src_fbits_S1;
        sdid_S2_f <= sdid_S1;
        lsid_S2_f <= lsid_S1;
        mshr_way_S2_f <= mshr_way_S1;
        msg_subline_id_S2_f <= msg_subline_id_S1;
        mshr_miss_lsid_S2_f <= mshr_miss_lsid_S1;
    end
end


//============================
// Stage 2
//============================


reg [15*4+2+4-1:0] state_data_in_S2;
reg [15*4+2+4-1:0] state_data_mask_in_S2;

always @ *
begin
    addr_S2 = addr_S2_f;
    lsid_S2 = lsid_S2_f;
end


reg [100-1:0] tag_data_buf_S2_f;
reg [100-1:0] tag_data_buf_S2_next;
reg [100-1:0] tag_data_trans_S2;

always @ *
begin
    if (!rst_n)
    begin
        tag_data_buf_S2_next = 0;
    end
    else if (stall_S2 && !stall_before_S2)
    begin
        tag_data_buf_S2_next = tag_data_S2;
    end
    else
    begin
        tag_data_buf_S2_next = tag_data_buf_S2_f;
    end
end

always @ (posedge clk)
begin
    tag_data_buf_S2_f <= tag_data_buf_S2_next;
end

always @ *
begin
    if (stall_before_S2)
    begin
        tag_data_trans_S2 = tag_data_buf_S2_f;
    end
    else
    begin
        tag_data_trans_S2 = tag_data_S2;
    end
end

reg [100-1:0] state_data_buf_S2_f;
reg [100-1:0] state_data_buf_S2_next;
reg [100-1:0] state_data_trans_S2;

always @ *
begin
    if (!rst_n)
    begin
        state_data_buf_S2_next = 0;
    end
    else if (stall_S2 && !stall_before_S2)
    begin
        state_data_buf_S2_next = state_data_S2;
    end
    else
    begin
        state_data_buf_S2_next = state_data_buf_S2_f;
    end
end

always @ (posedge clk)
begin
    state_data_buf_S2_f <= state_data_buf_S2_next;
end

always @ *
begin
    if (stall_before_S2)
    begin
        state_data_trans_S2 = state_data_buf_S2_f;
    end
    else
    begin
        state_data_trans_S2 = state_data_S2;
    end
end


reg [2-1:0] l2_hit_way_sel_S2;
reg [2-1:0] l2_rb_bits_S2;
reg [4-1:0] l2_lru_bits_S2;


always @ *
begin
    l2_rb_bits_S2 = state_data_trans_S2[15*4+2+4-1:15*4+4];
    l2_lru_bits_S2 = state_data_trans_S2[15*4+4-1:15*4];
end


reg [25 - 1:0] tag_data_way_S2 [3:0];


reg [3:0] tag_hit_way_S2;


reg [15 - 1:0] state_way_S2 [3:0];





always @ *
begin
    tag_data_way_S2[0] = tag_data_trans_S2[25 * 1 - 1: 25 * 0];
    tag_data_way_S2[1] = tag_data_trans_S2[25 * 2 - 1: 25 * 1];
    tag_data_way_S2[2] = tag_data_trans_S2[25 * 3 - 1: 25 * 2];
    tag_data_way_S2[3] = tag_data_trans_S2[25 * 4 - 1: 25 * 3];

end

always @ *
begin
    state_way_S2[0] = state_data_trans_S2[15 * 1 - 1: 
15 * 0];
    state_way_S2[1] = state_data_trans_S2[15 * 2 - 1: 
15 * 1];
    state_way_S2[2] = state_data_trans_S2[15 * 3 - 1: 
15 * 2];
    state_way_S2[3] = state_data_trans_S2[15 * 4 - 1: 
15 * 3];

end

always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[0]) && 
(state_way_S2[0][12:11] == 2'b10 || state_way_S2[0][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[0] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[0] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[1]) && 
(state_way_S2[1][12:11] == 2'b10 || state_way_S2[1][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[1] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[1] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[2]) && 
(state_way_S2[2][12:11] == 2'b10 || state_way_S2[2][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[2] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[2] = 1'b0;
    end
end
always @ *
begin
    if ((addr_S2_f[39:6+9] == tag_data_way_S2[3]) && 
(state_way_S2[3][12:11] == 2'b10 || state_way_S2[3][12:11] == 2'b11 ))
    begin
        tag_hit_way_S2[3] = 1'b1;
    end
    else
    begin
        tag_hit_way_S2[3] = 1'b0;
    end
end



always @ *
begin
    if (msg_from_mshr_S2)
    begin
        l2_tag_hit_S2 = tag_hit_way_S2[mshr_way_S2_f];
    end
    else
        l2_tag_hit_S2 = tag_hit_way_S2[0] || tag_hit_way_S2[1] || tag_hit_way_S2[2] || tag_hit_way_S2[3];

end

always @ *
begin
    l2_hit_way_sel_S2 = {2{1'bx}};
    if (tag_hit_way_S2[0])
    begin
        l2_hit_way_sel_S2 = 2'd0;
    end
    if (tag_hit_way_S2[1])
    begin
        l2_hit_way_sel_S2 = 2'd1;
    end
    if (tag_hit_way_S2[2])
    begin
        l2_hit_way_sel_S2 = 2'd2;
    end
    if (tag_hit_way_S2[3])
    begin
        l2_hit_way_sel_S2 = 2'd3;
    end

end


always @ *
begin
    if(valid_S2)
    begin
        if (msg_from_mshr_S2)
        begin
            l2_way_sel_S2 = mshr_way_S2_f;
        end
        else
        begin
            l2_way_sel_S2 = l2_hit_way_sel_S2;
        end
    end
    else
    begin
        l2_way_sel_S2 = 0;
    end
end


always @ *
begin
    if (!l2_tag_hit_S2 && (state_way_S2[l2_way_sel_S2][12:11] == 2'b11))
    begin
        l2_wb_S2 = 1'b1;
    end
    else
    begin
        l2_wb_S2 = 1'b0;
    end
end



always @ *
begin
    l2_way_state_mesi_S2 = state_way_S2[l2_way_sel_S2][14:13];
    l2_way_state_vd_S2 = state_way_S2[l2_way_sel_S2][12:11];
    l2_way_state_subline_S2 = state_way_S2[l2_way_sel_S2][9:6];
    l2_way_state_cache_type_S2 = state_way_S2[l2_way_sel_S2][10];
    l2_way_state_owner_S2 = state_way_S2[l2_way_sel_S2][5:0];
end





always @ *
begin
    dir_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2}; 
end

always @ *
begin
    if (l2_load_64B_S2)
    begin
        data_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2, l2_load_data_subline_S2};
    end







    else
    begin
        data_addr_S2 = {addr_S2_f[6+9-1:6],l2_way_sel_S2, addr_S2_f[5:4]};
    end
end



always @ *
begin
    addr_l2_aligned_S2 = (addr_S2_f[6-1:0] == {6{1'b0}}); 
end

/*
always @ *
begin
    dir_data_mask_in_S2 = {`L2_DIR_ARRAY_WIDTH{1'b1}}; 
end
*/
assign dir_data_mask_in_S2 = {64{1'b1}};

//TODO
always @ *
begin
    if (dir_clr_en_S2)
    begin
        dir_data_in_S2 = {(64){1'b0}}; 
    end
    else
    begin
        dir_data_in_S2 = {{(64-1){1'b0}},1'b1} << l2_way_state_owner_S2; 
    end
end


wire [8-1:0] msg_data_parity1_S2;
wire [8-1:0] msg_data_parity2_S2;

l2_data_pgen data_pgen1( 
    .din            (msg_data_S2[64-1:0]),
    .parity         (msg_data_parity1_S2)
);

l2_data_pgen data_pgen2( 
    .din            (msg_data_S2[128-1:64]),
    .parity         (msg_data_parity2_S2)
);


always @ *
begin
    data_data_in_S2 = {msg_data_parity2_S2, msg_data_S2[127:64], msg_data_parity1_S2, msg_data_S2[63:0]}; 
end

assign data_data_mask_in_S2 = {144{1'b1}}; 


reg [6-1:0] state_owner_S2;
reg [4-1:0] state_subline_S2;
reg [2-1:0] state_rb_S2;
reg [4-1:0] state_lru_S2;


always @ *
begin
    state_owner_S2 = l2_way_state_owner_S2; 
    if (state_owner_op_S2 == 2'd1)
    begin
        state_owner_S2 = sdid_S2_f[5:0]; 
    end
    else if (state_owner_op_S2 == 2'd2)
    begin
        state_owner_S2 = l2_way_state_owner_S2 + 1; 
    end
    else if (state_owner_op_S2 == 2'd3)
    begin
        state_owner_S2 = l2_way_state_owner_S2 - 1; 
    end
    else if (state_owner_op_S2 == 2'd0)
    begin
        state_owner_S2 = 0; 
    end
end

reg [4-1:0] addr_subline_S2;

always @ *
begin
    if (cache_type_S2 == 1'b0)
    begin
        //addr_subline_S2= {1'b1, {(`L2_SUBLINE_BITS-1){1'b0}}} >> addr_S2_f[`L2_DATA_SUBLINE];
        addr_subline_S2= {{(4-1){1'b0}},1'b1} << addr_S2_f[5:4];
    end
    else
    begin
        //addr_subline_S2= {2'b11, {(`L2_SUBLINE_BITS-2){1'b0}}} >> (2*addr_S2_f[`L2_INS_SUBLINE]);
        addr_subline_S2= {{(4-2){1'b0}},2'b11} << (2*addr_S2_f[5]);
    end
end


always @ *
begin
    if (state_subline_op_S2 == 2'd1)
    begin
        state_subline_S2 = sdid_S2_f[9:6];
    end
    else if (state_subline_op_S2 == 2'd2)
    begin
        state_subline_S2 = l2_way_state_subline_S2 | addr_subline_S2;
    end
    else if (state_subline_op_S2 == 2'd3)
    begin
        state_subline_S2 = l2_way_state_subline_S2 & (~addr_subline_S2);
    end
    else if (state_subline_op_S2 == 2'd0)
    begin
        state_subline_S2 = {4{1'b0}};
    end
    else
    begin
        state_subline_S2 = {4{1'bx}};
    end
end

always @ *
begin
    state_rb_S2 = l2_rb_bits_S2 + 1; 
end


always @ *
begin
    if (state_lru_en_S2)
    begin
        if (state_lru_op_S2 == 1'b0)
        begin
            state_lru_S2 = l2_lru_bits_S2 & (~({{(4-1){1'b0}},1'b1} << l2_way_sel_S2));
        end
        else
        begin
            state_lru_S2 = l2_lru_bits_S2 | ({{(4-1){1'b0}},1'b1} << l2_way_sel_S2);
            if (state_lru_S2 == {4{1'b1}})
            begin
                state_lru_S2 = {4{1'b0}};
            end
        end
    end
    else
    begin
        state_lru_S2 = l2_lru_bits_S2; 
    end
end


always @ *
begin
    subline_valid_S2 = l2_way_state_subline_S2[msg_subline_id_S2_f]; 
end



always @ *
begin
    state_data_in_S2 = {state_rb_S2, state_lru_S2, 
    {4{state_mesi_S2, state_vd_S2, cache_type_S2, state_subline_S2, state_owner_S2}}};
end

reg [4*15-1:0] state_way_data_mask_in_S2;


always @ *
begin
    state_way_data_mask_in_S2 = {{(4-1)*15{1'b0}},
                                {{2{state_mesi_en_S2}}, 
                                 {2{state_vd_en_S2}}, 
                                 {1{state_di_en_S2}}, 
                                 {4{state_subline_en_S2}}, 
                                 {6{state_owner_en_S2}}}} 
    << (l2_way_sel_S2 * 15); 
end

always @ *
begin
    state_data_mask_in_S2 = {{2{state_rb_en_S2}}, 
                             {4{state_lru_en_S2}},
                              state_way_data_mask_in_S2}; 
end


always @ *
begin
    smc_wr_addr_in_S2 = {sdid_S2_f, mshr_miss_lsid_S2_f}; 
end

always @ *
begin
    smc_data_in_S2 = msg_data_S2; 
end



//============================
// Stage 2 -> Stage 3
//============================


reg [40-1:0] addr_S3_f;
reg [15*4+2+4-1:0] state_data_in_S3_f;
reg [15*4+2+4-1:0] state_data_mask_in_S3_f;
reg [8-1:0] mshrid_S3_f;
reg [6-1:0] mshr_miss_lsid_S3_f;

always @ (posedge clk)
begin
    if (!rst_n)
    begin
        addr_S3_f <= 0; 
        state_data_in_S3_f <= 0;
        state_data_mask_in_S3_f <= 0;
        mshrid_S3_f <= 0;
        mshr_miss_lsid_S3_f <= 0;
    end
    else if (!stall_S3)
    begin
        addr_S3_f <= addr_S2_f;
        state_data_in_S3_f <= state_data_in_S2;
        state_data_mask_in_S3_f <= state_data_mask_in_S2;
        mshrid_S3_f <= mshrid_S2_f;
        mshr_miss_lsid_S3_f <= mshr_miss_lsid_S2_f;
    end
end


//============================
// Stage 3
//============================

always @ *
begin
    state_data_in_S3 = state_data_in_S3_f;
    state_data_mask_in_S3 = state_data_mask_in_S3_f;
    addr_S3 = addr_S3_f;
end


always @ *
begin
    state_wr_addr_S3 = addr_S3_f[6+9-1:6]; 
end

always @ *
begin
    mshr_wr_index_S3 = mshrid_S3_f; 
end

assign mshr_data_in_S3 = {120+2{1'b0}}; 
assign mshr_data_mask_in_S3 = {1'b1, {(120+2-1){1'b0}}}; 

/*
//============================
// Debug
//============================

`ifndef SYNTHESIS
    

always @ (posedge clk)
begin
    if (valid_S1 && !stall_S1)
    begin
        $display("-------------------------------------");
        $display($time);
        $display("P2S1 addr: 0x%h", addr_S1);
        $display("Mshr_rd_index: %b", mshr_rd_index_S1);
        $display("Tag_addr: 0x%h", tag_addr_S1,);
        $display("Tag_data_in: 0x%h", tag_data_in_S1,);
        $display("Tag_data_mask_in: 0x%h", tag_data_mask_in_S1,);
        $display("State_rd_addr: 0x%h",state_rd_addr_S1);
        $display("Msg from mshr: %b", msg_from_mshr_S1);
    end
end


always @ (posedge clk)
begin
    if (valid_S2 && !stall_S2)
    begin
        $display("-------------------------------------");
        $display($time);
        $display("P2S2 addr: 0x%h", addr_S2);
        $display("P2S2 valid: l2_way_sel: %b, l2_hit: %b, l2_wb: %b",
                  l2_way_sel_S2, l2_tag_hit_S2, l2_wb_S2);
        $display("state: mesi: %b, vd: %b, subline: %b, cache_type: %b, owner: %b",
                 l2_way_state_mesi_S2, l2_way_state_vd_S2, l2_way_state_subline_S2, l2_way_state_cache_type_S2, l2_way_state_owner_S2);
        $display("Msg from mshr: %b", msg_from_mshr_S2);
        $display("Mshr wr index: %b", mshr_wr_index_S2);
        $display("Dir addr: 0x%h", dir_addr_S2);
        $display("Dir data: 0x%h", dir_data_in_S2);
        $display("Dir data mask: 0x%h", dir_data_mask_in_S2);
        $display("Data addr: 0x%h", data_addr_S2);
        $display("Data data: 0x%h", data_data_in_S2);
        $display("Data data mask: 0x%h", data_data_mask_in_S2);
        $display("State wr addr: 0x%h", state_wr_addr_S2);
        $display("State data: 0x%h", state_data_in_S2);
        $display("State data mask: 0x%h", state_data_mask_in_S2);
    end
end





`endif
*/
endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_priority_encoder.v
//  Created On    : 2014-07-09
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The priority encoder for pipeline1 in the L2 cache
//
//
//==================================================================================================


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================









































































































































































































































































































































































































































































































































































































module l2_priority_encoder_1(
    input wire [1:0] data_in,
    output wire [0:0] data_out,
    output wire [1:0] data_out_mask,
    output wire nonzero_out
);

assign data_out = data_in[0] ? 1'b0 : 1'b1;
assign data_out_mask = data_in[0] ? 2'b10 : 2'b01;
assign nonzero_out = | (data_in[1:0]);
endmodule

module l2_priority_encoder_2(
    input wire [3:0] data_in,
    output wire [1:0] data_out,
    output wire [3:0] data_out_mask,
    output wire nonzero_out
);

wire [0:0] data_low;

wire [0:0] data_high;

wire [1:0] data_low_mask;

wire [1:0] data_high_mask;

wire nonzero_low;

wire nonzero_high;

l2_priority_encoder_1 encoder_high_1 (.data_in(data_in[3:2]), .data_out(data_high), .data_out_mask(data_high_mask), .nonzero_out(nonzero_high));

l2_priority_encoder_1 encoder_low_1(.data_in(data_in[1:0]), .data_out(data_low), .data_out_mask(data_low_mask), .nonzero_out(nonzero_low));

assign data_out = nonzero_low ? {1'b0, data_low} : {1'b1, data_high};

assign data_out_mask = nonzero_low ? {{2{1'b1}}, data_low_mask} : {data_high_mask,{2{1'b1}}};

assign nonzero_out = nonzero_low | nonzero_high;
endmodule

module l2_priority_encoder_3(
    input wire [7:0] data_in,
    output wire [2:0] data_out,
    output wire [7:0] data_out_mask,
    output wire nonzero_out
);

wire [1:0] data_low;

wire [1:0] data_high;

wire [3:0] data_low_mask;

wire [3:0] data_high_mask;

wire nonzero_low;

wire nonzero_high;

l2_priority_encoder_2 encoder_high_2 (.data_in(data_in[7:4]), .data_out(data_high), .data_out_mask(data_high_mask), .nonzero_out(nonzero_high));

l2_priority_encoder_2 encoder_low_2(.data_in(data_in[3:0]), .data_out(data_low), .data_out_mask(data_low_mask), .nonzero_out(nonzero_low));

assign data_out = nonzero_low ? {1'b0, data_low} : {1'b1, data_high};

assign data_out_mask = nonzero_low ? {{4{1'b1}}, data_low_mask} : {data_high_mask,{4{1'b1}}};

assign nonzero_out = nonzero_low | nonzero_high;
endmodule

module l2_priority_encoder_4(
    input wire [15:0] data_in,
    output wire [3:0] data_out,
    output wire [15:0] data_out_mask,
    output wire nonzero_out
);

wire [2:0] data_low;

wire [2:0] data_high;

wire [7:0] data_low_mask;

wire [7:0] data_high_mask;

wire nonzero_low;

wire nonzero_high;

l2_priority_encoder_3 encoder_high_3 (.data_in(data_in[15:8]), .data_out(data_high), .data_out_mask(data_high_mask), .nonzero_out(nonzero_high));

l2_priority_encoder_3 encoder_low_3(.data_in(data_in[7:0]), .data_out(data_low), .data_out_mask(data_low_mask), .nonzero_out(nonzero_low));

assign data_out = nonzero_low ? {1'b0, data_low} : {1'b1, data_high};

assign data_out_mask = nonzero_low ? {{8{1'b1}}, data_low_mask} : {data_high_mask,{8{1'b1}}};

assign nonzero_out = nonzero_low | nonzero_high;
endmodule

module l2_priority_encoder_5(
    input wire [31:0] data_in,
    output wire [4:0] data_out,
    output wire [31:0] data_out_mask,
    output wire nonzero_out
);

wire [3:0] data_low;

wire [3:0] data_high;

wire [15:0] data_low_mask;

wire [15:0] data_high_mask;

wire nonzero_low;

wire nonzero_high;

l2_priority_encoder_4 encoder_high_4 (.data_in(data_in[31:16]), .data_out(data_high), .data_out_mask(data_high_mask), .nonzero_out(nonzero_high));

l2_priority_encoder_4 encoder_low_4(.data_in(data_in[15:0]), .data_out(data_low), .data_out_mask(data_low_mask), .nonzero_out(nonzero_low));

assign data_out = nonzero_low ? {1'b0, data_low} : {1'b1, data_high};

assign data_out_mask = nonzero_low ? {{16{1'b1}}, data_low_mask} : {data_high_mask,{16{1'b1}}};

assign nonzero_out = nonzero_low | nonzero_high;
endmodule

module l2_priority_encoder_6(
    input wire [63:0] data_in,
    output wire [5:0] data_out,
    output wire [63:0] data_out_mask,
    output wire nonzero_out
);

wire [4:0] data_low;

wire [4:0] data_high;

wire [31:0] data_low_mask;

wire [31:0] data_high_mask;

wire nonzero_low;

wire nonzero_high;

l2_priority_encoder_5 encoder_high_5 (.data_in(data_in[63:32]), .data_out(data_high), .data_out_mask(data_high_mask), .nonzero_out(nonzero_high));

l2_priority_encoder_5 encoder_low_5(.data_in(data_in[31:0]), .data_out(data_low), .data_out_mask(data_low_mask), .nonzero_out(nonzero_low));

assign data_out = nonzero_low ? {1'b0, data_low} : {1'b1, data_high};

assign data_out_mask = nonzero_low ? {{32{1'b1}}, data_low_mask} : {data_high_mask,{32{1'b1}}};

assign nonzero_out = nonzero_low | nonzero_high;
endmodule




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_smc.v
//  Created On    : 2014-06-07
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The SMC in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_smc(

    input wire clk,
    input wire rst_n,

    //Read enable
    input wire rd_en,

    //Write enable
    input wire wr_en,

    //Diagnostic read enable
    input wire rd_diag_en,

    //Diagnostic write enable
    input wire wr_diag_en,

    //Flush enable
    input wire flush_en,

    input wire [2-1:0] addr_op,

    //address
    input wire [16-1:0] rd_addr_in,
    input wire [16-1:0] wr_addr_in,

    //Write data
    input wire [128-1:0] data_in,

    output reg hit,
    
    //Read output
    output reg [30-1:0] data_out,
    output reg [4-1:0] valid_out,
    output reg [14-1:0] tag_out
);



reg [16-1:0] entry_used_f;
reg [16-1:0] entry_used_next;
reg [16-1:0] entry_used_and_mask;
reg [16-1:0] entry_used_or_mask;
reg [16-1:0] entry_locked_f;
reg [16-1:0] entry_locked_next;
reg [16-1:0] entry_locked_and_mask;
reg [16-1:0] entry_locked_or_mask;
reg [138-1:0] data_mem_f [16-1:0];

reg [14-1:0] smc_tag [16-1:0];
reg [4-1:0] smc_valid [16-1:0];
reg [120-1:0] smc_data [16-1:0];
reg [10-1:0] smc_sdid [16-1:0];
reg [14-1:0] rd_tag_in;
reg [14-1:0] wr_tag_in;
reg [4-1:0] rd_index_in;
reg [4-1:0] wr_index_in;
reg [2-1:0] rd_offset_in;
reg [2-1:0] wr_offset_in;
reg [10-1:0] wr_sdid_in;
reg [4-1:0] smc_valid_in;
reg [120-1:0] smc_data_in;
reg [4-1:0] hit_index;
reg [4-1:0] replace_index;
reg wr_hit;
reg [4-1:0] wr_hit_index;
reg [4-1:0] wr_index;


always @ *
begin
    smc_tag[0] = data_mem_f[0][137:124];
    smc_tag[1] = data_mem_f[1][137:124];
    smc_tag[2] = data_mem_f[2][137:124];
    smc_tag[3] = data_mem_f[3][137:124];
    smc_tag[4] = data_mem_f[4][137:124];
    smc_tag[5] = data_mem_f[5][137:124];
    smc_tag[6] = data_mem_f[6][137:124];
    smc_tag[7] = data_mem_f[7][137:124];
    smc_tag[8] = data_mem_f[8][137:124];
    smc_tag[9] = data_mem_f[9][137:124];
    smc_tag[10] = data_mem_f[10][137:124];
    smc_tag[11] = data_mem_f[11][137:124];
    smc_tag[12] = data_mem_f[12][137:124];
    smc_tag[13] = data_mem_f[13][137:124];
    smc_tag[14] = data_mem_f[14][137:124];
    smc_tag[15] = data_mem_f[15][137:124];

end

always @ *
begin
    smc_valid[0] = data_mem_f[0][123:120];
    smc_valid[1] = data_mem_f[1][123:120];
    smc_valid[2] = data_mem_f[2][123:120];
    smc_valid[3] = data_mem_f[3][123:120];
    smc_valid[4] = data_mem_f[4][123:120];
    smc_valid[5] = data_mem_f[5][123:120];
    smc_valid[6] = data_mem_f[6][123:120];
    smc_valid[7] = data_mem_f[7][123:120];
    smc_valid[8] = data_mem_f[8][123:120];
    smc_valid[9] = data_mem_f[9][123:120];
    smc_valid[10] = data_mem_f[10][123:120];
    smc_valid[11] = data_mem_f[11][123:120];
    smc_valid[12] = data_mem_f[12][123:120];
    smc_valid[13] = data_mem_f[13][123:120];
    smc_valid[14] = data_mem_f[14][123:120];
    smc_valid[15] = data_mem_f[15][123:120];

end

always @ *
begin
    smc_data[0] = data_mem_f[0][119:0];
    smc_data[1] = data_mem_f[1][119:0];
    smc_data[2] = data_mem_f[2][119:0];
    smc_data[3] = data_mem_f[3][119:0];
    smc_data[4] = data_mem_f[4][119:0];
    smc_data[5] = data_mem_f[5][119:0];
    smc_data[6] = data_mem_f[6][119:0];
    smc_data[7] = data_mem_f[7][119:0];
    smc_data[8] = data_mem_f[8][119:0];
    smc_data[9] = data_mem_f[9][119:0];
    smc_data[10] = data_mem_f[10][119:0];
    smc_data[11] = data_mem_f[11][119:0];
    smc_data[12] = data_mem_f[12][119:0];
    smc_data[13] = data_mem_f[13][119:0];
    smc_data[14] = data_mem_f[14][119:0];
    smc_data[15] = data_mem_f[15][119:0];

end

always @ *
begin
    smc_sdid[0] = data_mem_f[0][137:128];
    smc_sdid[1] = data_mem_f[1][137:128];
    smc_sdid[2] = data_mem_f[2][137:128];
    smc_sdid[3] = data_mem_f[3][137:128];
    smc_sdid[4] = data_mem_f[4][137:128];
    smc_sdid[5] = data_mem_f[5][137:128];
    smc_sdid[6] = data_mem_f[6][137:128];
    smc_sdid[7] = data_mem_f[7][137:128];
    smc_sdid[8] = data_mem_f[8][137:128];
    smc_sdid[9] = data_mem_f[9][137:128];
    smc_sdid[10] = data_mem_f[10][137:128];
    smc_sdid[11] = data_mem_f[11][137:128];
    smc_sdid[12] = data_mem_f[12][137:128];
    smc_sdid[13] = data_mem_f[13][137:128];
    smc_sdid[14] = data_mem_f[14][137:128];
    smc_sdid[15] = data_mem_f[15][137:128];

end


always @ *
begin
    rd_tag_in = rd_addr_in[15:2];
    rd_offset_in = rd_addr_in[1:0];
    rd_index_in = rd_addr_in[5:2];
end

always @ *
begin
    wr_tag_in = wr_addr_in[15:2];
    wr_offset_in = wr_addr_in[1:0];
    wr_index_in = wr_addr_in[5:2];
    wr_sdid_in = wr_addr_in[15:6];
end


always @ *
begin
    smc_valid_in = { data_in[127], data_in[95], data_in[63], data_in[31] };
    smc_data_in = { data_in[125:96], data_in[93:64], data_in[61:32], data_in[29:0] };

end


wire [4-1:0] tag_hit_index;
wire tag_hit;


reg [15:0] smc_tag_cmp;

always @ *
begin

    smc_tag_cmp[0] = (smc_tag[0] == rd_tag_in) && smc_valid[0][rd_offset_in];

    smc_tag_cmp[1] = (smc_tag[1] == rd_tag_in) && smc_valid[1][rd_offset_in];

    smc_tag_cmp[2] = (smc_tag[2] == rd_tag_in) && smc_valid[2][rd_offset_in];

    smc_tag_cmp[3] = (smc_tag[3] == rd_tag_in) && smc_valid[3][rd_offset_in];

    smc_tag_cmp[4] = (smc_tag[4] == rd_tag_in) && smc_valid[4][rd_offset_in];

    smc_tag_cmp[5] = (smc_tag[5] == rd_tag_in) && smc_valid[5][rd_offset_in];

    smc_tag_cmp[6] = (smc_tag[6] == rd_tag_in) && smc_valid[6][rd_offset_in];

    smc_tag_cmp[7] = (smc_tag[7] == rd_tag_in) && smc_valid[7][rd_offset_in];

    smc_tag_cmp[8] = (smc_tag[8] == rd_tag_in) && smc_valid[8][rd_offset_in];

    smc_tag_cmp[9] = (smc_tag[9] == rd_tag_in) && smc_valid[9][rd_offset_in];

    smc_tag_cmp[10] = (smc_tag[10] == rd_tag_in) && smc_valid[10][rd_offset_in];

    smc_tag_cmp[11] = (smc_tag[11] == rd_tag_in) && smc_valid[11][rd_offset_in];

    smc_tag_cmp[12] = (smc_tag[12] == rd_tag_in) && smc_valid[12][rd_offset_in];

    smc_tag_cmp[13] = (smc_tag[13] == rd_tag_in) && smc_valid[13][rd_offset_in];

    smc_tag_cmp[14] = (smc_tag[14] == rd_tag_in) && smc_valid[14][rd_offset_in];

    smc_tag_cmp[15] = (smc_tag[15] == rd_tag_in) && smc_valid[15][rd_offset_in];

end


l2_priority_encoder_4 priority_encoder_cmp_4bits( 

    .data_in        (smc_tag_cmp),
    .data_out       (tag_hit_index),
    .data_out_mask  (),
    .nonzero_out    (tag_hit)
);



always @ *
begin
    if (rd_en && rd_diag_en)
    begin
        hit = 1'b0;
        hit_index = rd_index_in;
    end
    else
    begin
        if(rd_en)
        begin
            hit = tag_hit;
            hit_index = tag_hit_index;
        end
        else
        begin
            hit = 1'b0;
            hit_index = 0;
        end
    end
end
/*
        if(rd_en)
    begin
        if ((smc_tag[0] == rd_tag_in) && smc_valid[0][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd0;
        end
        else if ((smc_tag[1] == rd_tag_in) && smc_valid[1][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd1;
        end
        else if ((smc_tag[2] == rd_tag_in) && smc_valid[2][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd2;
        end
        else if ((smc_tag[3] == rd_tag_in) && smc_valid[3][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd3;
        end
        else if ((smc_tag[4] == rd_tag_in) && smc_valid[4][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd4;
        end
        else if ((smc_tag[5] == rd_tag_in) && smc_valid[5][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd5;
        end
        else if ((smc_tag[6] == rd_tag_in) && smc_valid[6][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd6;
        end
        else if ((smc_tag[7] == rd_tag_in) && smc_valid[7][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd7;
        end
        else if ((smc_tag[8] == rd_tag_in) && smc_valid[8][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd8;
        end
        else if ((smc_tag[9] == rd_tag_in) && smc_valid[9][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd9;
        end
        else if ((smc_tag[10] == rd_tag_in) && smc_valid[10][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd10;
        end
        else if ((smc_tag[11] == rd_tag_in) && smc_valid[11][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd11;
        end
        else if ((smc_tag[12] == rd_tag_in) && smc_valid[12][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd12;
        end
        else if ((smc_tag[13] == rd_tag_in) && smc_valid[13][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd13;
        end
        else if ((smc_tag[14] == rd_tag_in) && smc_valid[14][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd14;
        end
        else if ((smc_tag[15] == rd_tag_in) && smc_valid[15][rd_offset_in])
        begin
            hit = 1'b1;
            hit_index = 4'd15;
        end
        else
        begin
            hit = 1'b0;
            hit_index = 4'd0;
        end
    end
    else
    begin
        hit = 1'b0;
        hit_index = 4'd0;
    end

    end
end
*/


wire [4-1:0] tag_wr_hit_index;
wire tag_wr_hit;


reg [15:0] smc_tag_wr_cmp;

always @ *
begin

    smc_tag_wr_cmp[0] = (smc_tag[0] == wr_tag_in) && (smc_valid[0] != 0);

    smc_tag_wr_cmp[1] = (smc_tag[1] == wr_tag_in) && (smc_valid[1] != 0);

    smc_tag_wr_cmp[2] = (smc_tag[2] == wr_tag_in) && (smc_valid[2] != 0);

    smc_tag_wr_cmp[3] = (smc_tag[3] == wr_tag_in) && (smc_valid[3] != 0);

    smc_tag_wr_cmp[4] = (smc_tag[4] == wr_tag_in) && (smc_valid[4] != 0);

    smc_tag_wr_cmp[5] = (smc_tag[5] == wr_tag_in) && (smc_valid[5] != 0);

    smc_tag_wr_cmp[6] = (smc_tag[6] == wr_tag_in) && (smc_valid[6] != 0);

    smc_tag_wr_cmp[7] = (smc_tag[7] == wr_tag_in) && (smc_valid[7] != 0);

    smc_tag_wr_cmp[8] = (smc_tag[8] == wr_tag_in) && (smc_valid[8] != 0);

    smc_tag_wr_cmp[9] = (smc_tag[9] == wr_tag_in) && (smc_valid[9] != 0);

    smc_tag_wr_cmp[10] = (smc_tag[10] == wr_tag_in) && (smc_valid[10] != 0);

    smc_tag_wr_cmp[11] = (smc_tag[11] == wr_tag_in) && (smc_valid[11] != 0);

    smc_tag_wr_cmp[12] = (smc_tag[12] == wr_tag_in) && (smc_valid[12] != 0);

    smc_tag_wr_cmp[13] = (smc_tag[13] == wr_tag_in) && (smc_valid[13] != 0);

    smc_tag_wr_cmp[14] = (smc_tag[14] == wr_tag_in) && (smc_valid[14] != 0);

    smc_tag_wr_cmp[15] = (smc_tag[15] == wr_tag_in) && (smc_valid[15] != 0);

end



l2_priority_encoder_4 priority_encoder_wr_cmp_4bits( 

    .data_in        (smc_tag_wr_cmp),
    .data_out       (tag_wr_hit_index),
    .data_out_mask  (),
    .nonzero_out    (tag_wr_hit)
);





//avoid redundant entries
always @ *
begin
    if(wr_en || (flush_en && (addr_op == 2'd1)))
    begin
        wr_hit = tag_wr_hit;
        wr_hit_index = tag_wr_hit_index;
    end
    else
    begin
        wr_hit = 1'b0;
        wr_hit_index = 0;
    end
end


/*
always @ *
begin
    if(wr_en || (flush_en && (addr_op == 2'd1)))
    begin
        if ((smc_tag[0] == wr_tag_in) && (smc_valid[0] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd0;
        end
        else if ((smc_tag[1] == wr_tag_in) && (smc_valid[1] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd1;
        end
        else if ((smc_tag[2] == wr_tag_in) && (smc_valid[2] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd2;
        end
        else if ((smc_tag[3] == wr_tag_in) && (smc_valid[3] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd3;
        end
        else if ((smc_tag[4] == wr_tag_in) && (smc_valid[4] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd4;
        end
        else if ((smc_tag[5] == wr_tag_in) && (smc_valid[5] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd5;
        end
        else if ((smc_tag[6] == wr_tag_in) && (smc_valid[6] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd6;
        end
        else if ((smc_tag[7] == wr_tag_in) && (smc_valid[7] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd7;
        end
        else if ((smc_tag[8] == wr_tag_in) && (smc_valid[8] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd8;
        end
        else if ((smc_tag[9] == wr_tag_in) && (smc_valid[9] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd9;
        end
        else if ((smc_tag[10] == wr_tag_in) && (smc_valid[10] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd10;
        end
        else if ((smc_tag[11] == wr_tag_in) && (smc_valid[11] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd11;
        end
        else if ((smc_tag[12] == wr_tag_in) && (smc_valid[12] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd12;
        end
        else if ((smc_tag[13] == wr_tag_in) && (smc_valid[13] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd13;
        end
        else if ((smc_tag[14] == wr_tag_in) && (smc_valid[14] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd14;
        end
        else if ((smc_tag[15] == wr_tag_in) && (smc_valid[15] != 0))
        begin
            wr_hit = 1'b1;
            wr_hit_index = 4'd15;
        end
        else
        begin
            wr_hit = 1'b0;
            wr_hit_index = 4'd0;
        end
    end
    else
    begin
        wr_hit = 1'b0;
        wr_hit_index = 4'd0;
    end

end
*/

always @ *
begin
    data_out = smc_data[hit_index]>>(rd_offset_in * 30);
    valid_out = smc_valid[hit_index];
    tag_out = smc_tag[hit_index];
end


always @ *
begin
    entry_locked_and_mask = {16{1'b1}};
    entry_locked_or_mask = {16{1'b0}};
    if (!rst_n)
    begin
        entry_locked_and_mask = {16{1'b0}};
    end
    else if (wr_en && ~wr_diag_en)
    begin
        if(smc_valid_in)
        begin
            entry_locked_or_mask[wr_index] = 1'b1;
        end
        else
        begin
            entry_locked_and_mask[wr_index] = 1'b0;
        end
        if (rd_en && ~rd_diag_en && hit && (wr_index != hit_index) && entry_locked_f[hit_index])
        begin
            entry_locked_and_mask[hit_index] = 1'b0;
        end 
    end
    else if (rd_en && ~rd_diag_en && hit && entry_locked_f[hit_index])
    begin
        entry_locked_and_mask[hit_index] = 1'b0;
    end
end

always @ *
begin
    entry_locked_next = (entry_locked_f & entry_locked_and_mask) | entry_locked_or_mask;
end


always @ (posedge clk)
begin
    entry_locked_f <= entry_locked_next;
end


always @ *
begin
    entry_used_and_mask = {16{1'b1}};
    entry_used_or_mask = {16{1'b0}};
    if (!rst_n)
    begin
        entry_used_and_mask = {16{1'b0}};
    end
    else if (wr_en && ~wr_diag_en)
    begin
        if(smc_valid_in)
        begin
            entry_used_or_mask[wr_index] = 1'b1;
        end
        else
        begin
            entry_used_and_mask[wr_index] = 1'b0;
        end
        if (rd_en && ~rd_diag_en && hit && (wr_index != hit_index))
        begin
            entry_used_or_mask[hit_index] = 1'b1;
        end 
    end
    else if (rd_en && ~rd_diag_en && hit)
    begin
        entry_used_or_mask[hit_index] = 1'b1;
    end
end

always @ *
begin
    entry_used_next = (entry_used_f & entry_used_and_mask) | entry_used_or_mask;
    if (entry_used_next == {16{1'b1}})
    begin
        entry_used_next = {16{1'b0}};
    end
end


always @ (posedge clk)
begin
    entry_used_f <= entry_used_next;
end


wire [4-1:0] entry_replace_index;
wire replace_hit;


reg [15:0] replace_cmp;

always @ *
begin

    replace_cmp[0] = (~entry_used_f[0] && ~entry_locked_f[0]);

    replace_cmp[1] = (~entry_used_f[1] && ~entry_locked_f[1]);

    replace_cmp[2] = (~entry_used_f[2] && ~entry_locked_f[2]);

    replace_cmp[3] = (~entry_used_f[3] && ~entry_locked_f[3]);

    replace_cmp[4] = (~entry_used_f[4] && ~entry_locked_f[4]);

    replace_cmp[5] = (~entry_used_f[5] && ~entry_locked_f[5]);

    replace_cmp[6] = (~entry_used_f[6] && ~entry_locked_f[6]);

    replace_cmp[7] = (~entry_used_f[7] && ~entry_locked_f[7]);

    replace_cmp[8] = (~entry_used_f[8] && ~entry_locked_f[8]);

    replace_cmp[9] = (~entry_used_f[9] && ~entry_locked_f[9]);

    replace_cmp[10] = (~entry_used_f[10] && ~entry_locked_f[10]);

    replace_cmp[11] = (~entry_used_f[11] && ~entry_locked_f[11]);

    replace_cmp[12] = (~entry_used_f[12] && ~entry_locked_f[12]);

    replace_cmp[13] = (~entry_used_f[13] && ~entry_locked_f[13]);

    replace_cmp[14] = (~entry_used_f[14] && ~entry_locked_f[14]);

    replace_cmp[15] = (~entry_used_f[15] && ~entry_locked_f[15]);

end


l2_priority_encoder_4 priority_encoder_replace_cmp_4bits( 

    .data_in        (replace_cmp),
    .data_out       (entry_replace_index),
    .data_out_mask  (),
    .nonzero_out    (replace_hit)
);


always @ *
begin
    if (replace_hit)
    begin
        replace_index = entry_replace_index;
    end
    else
    begin
        replace_index = {4{1'b0}};
    end

end

/*
always @ *
begin
    if (~entry_used_f[0] && ~entry_locked_f[0])
    begin
        replace_index = 4'd0;
    end
    else if (~entry_used_f[1] && ~entry_locked_f[1])
    begin
        replace_index = 4'd1;
    end
    else if (~entry_used_f[2] && ~entry_locked_f[2])
    begin
        replace_index = 4'd2;
    end
    else if (~entry_used_f[3] && ~entry_locked_f[3])
    begin
        replace_index = 4'd3;
    end
    else if (~entry_used_f[4] && ~entry_locked_f[4])
    begin
        replace_index = 4'd4;
    end
    else if (~entry_used_f[5] && ~entry_locked_f[5])
    begin
        replace_index = 4'd5;
    end
    else if (~entry_used_f[6] && ~entry_locked_f[6])
    begin
        replace_index = 4'd6;
    end
    else if (~entry_used_f[7] && ~entry_locked_f[7])
    begin
        replace_index = 4'd7;
    end
    else if (~entry_used_f[8] && ~entry_locked_f[8])
    begin
        replace_index = 4'd8;
    end
    else if (~entry_used_f[9] && ~entry_locked_f[9])
    begin
        replace_index = 4'd9;
    end
    else if (~entry_used_f[10] && ~entry_locked_f[10])
    begin
        replace_index = 4'd10;
    end
    else if (~entry_used_f[11] && ~entry_locked_f[11])
    begin
        replace_index = 4'd11;
    end
    else if (~entry_used_f[12] && ~entry_locked_f[12])
    begin
        replace_index = 4'd12;
    end
    else if (~entry_used_f[13] && ~entry_locked_f[13])
    begin
        replace_index = 4'd13;
    end
    else if (~entry_used_f[14] && ~entry_locked_f[14])
    begin
        replace_index = 4'd14;
    end
    else if (~entry_used_f[15] && ~entry_locked_f[15])
    begin
        replace_index = 4'd15;
    end
    else
    begin
        replace_index = 4'dx;
    end

end
*/

always @ *
begin
    if (wr_en && wr_diag_en)
    begin
        wr_index = wr_index_in;
    end
    else if ((flush_en || wr_en) && wr_hit)
    begin
        wr_index = wr_hit_index;
    end
    else
    begin
        wr_index = replace_index;
    end
end


always @ (posedge clk)
begin
    if (!rst_n)
    begin
        data_mem_f[0] <= {138{1'b0}};
        data_mem_f[1] <= {138{1'b0}};
        data_mem_f[2] <= {138{1'b0}};
        data_mem_f[3] <= {138{1'b0}};
        data_mem_f[4] <= {138{1'b0}};
        data_mem_f[5] <= {138{1'b0}};
        data_mem_f[6] <= {138{1'b0}};
        data_mem_f[7] <= {138{1'b0}};
        data_mem_f[8] <= {138{1'b0}};
        data_mem_f[9] <= {138{1'b0}};
        data_mem_f[10] <= {138{1'b0}};
        data_mem_f[11] <= {138{1'b0}};
        data_mem_f[12] <= {138{1'b0}};
        data_mem_f[13] <= {138{1'b0}};
        data_mem_f[14] <= {138{1'b0}};
        data_mem_f[15] <= {138{1'b0}};

    end
    else if (flush_en)
    begin
        case (addr_op)
        2'd0:
        begin
            data_mem_f[0][123:120] <= {4{1'b0}};
            data_mem_f[1][123:120] <= {4{1'b0}};
            data_mem_f[2][123:120] <= {4{1'b0}};
            data_mem_f[3][123:120] <= {4{1'b0}};
            data_mem_f[4][123:120] <= {4{1'b0}};
            data_mem_f[5][123:120] <= {4{1'b0}};
            data_mem_f[6][123:120] <= {4{1'b0}};
            data_mem_f[7][123:120] <= {4{1'b0}};
            data_mem_f[8][123:120] <= {4{1'b0}};
            data_mem_f[9][123:120] <= {4{1'b0}};
            data_mem_f[10][123:120] <= {4{1'b0}};
            data_mem_f[11][123:120] <= {4{1'b0}};
            data_mem_f[12][123:120] <= {4{1'b0}};
            data_mem_f[13][123:120] <= {4{1'b0}};
            data_mem_f[14][123:120] <= {4{1'b0}};
            data_mem_f[15][123:120] <= {4{1'b0}};

        end
        2'd1:
        begin
            if (wr_hit)
            begin
                data_mem_f[wr_index][120+wr_offset_in] <= 1'b0;
                
            end
        end
        2'd2:
        begin
            if ((smc_sdid[0] == wr_sdid_in) && (smc_valid[0] != 0))
                data_mem_f[0][123:120] <= {4{1'b0}};
            if ((smc_sdid[1] == wr_sdid_in) && (smc_valid[1] != 0))
                data_mem_f[1][123:120] <= {4{1'b0}};
            if ((smc_sdid[2] == wr_sdid_in) && (smc_valid[2] != 0))
                data_mem_f[2][123:120] <= {4{1'b0}};
            if ((smc_sdid[3] == wr_sdid_in) && (smc_valid[3] != 0))
                data_mem_f[3][123:120] <= {4{1'b0}};
            if ((smc_sdid[4] == wr_sdid_in) && (smc_valid[4] != 0))
                data_mem_f[4][123:120] <= {4{1'b0}};
            if ((smc_sdid[5] == wr_sdid_in) && (smc_valid[5] != 0))
                data_mem_f[5][123:120] <= {4{1'b0}};
            if ((smc_sdid[6] == wr_sdid_in) && (smc_valid[6] != 0))
                data_mem_f[6][123:120] <= {4{1'b0}};
            if ((smc_sdid[7] == wr_sdid_in) && (smc_valid[7] != 0))
                data_mem_f[7][123:120] <= {4{1'b0}};
            if ((smc_sdid[8] == wr_sdid_in) && (smc_valid[8] != 0))
                data_mem_f[8][123:120] <= {4{1'b0}};
            if ((smc_sdid[9] == wr_sdid_in) && (smc_valid[9] != 0))
                data_mem_f[9][123:120] <= {4{1'b0}};
            if ((smc_sdid[10] == wr_sdid_in) && (smc_valid[10] != 0))
                data_mem_f[10][123:120] <= {4{1'b0}};
            if ((smc_sdid[11] == wr_sdid_in) && (smc_valid[11] != 0))
                data_mem_f[11][123:120] <= {4{1'b0}};
            if ((smc_sdid[12] == wr_sdid_in) && (smc_valid[12] != 0))
                data_mem_f[12][123:120] <= {4{1'b0}};
            if ((smc_sdid[13] == wr_sdid_in) && (smc_valid[13] != 0))
                data_mem_f[13][123:120] <= {4{1'b0}};
            if ((smc_sdid[14] == wr_sdid_in) && (smc_valid[14] != 0))
                data_mem_f[14][123:120] <= {4{1'b0}};
            if ((smc_sdid[15] == wr_sdid_in) && (smc_valid[15] != 0))
                data_mem_f[15][123:120] <= {4{1'b0}};

        end
        default:
        begin
            data_mem_f[wr_index] <= data_mem_f[wr_index];
        end
        endcase
    end
    else if (wr_en)
    begin
        if (wr_diag_en)
        begin
            case (addr_op)
            2'd0:
            begin
                case (wr_offset_in)
                2'd0:
                begin
                    data_mem_f[wr_index][30-1:0] <= 
                    data_in[30-1:0];
                end
                2'd1:
                begin
                    data_mem_f[wr_index][30*2-1:30] <= 
                    data_in[30-1:0];
                end
                2'd2:
                begin
                    data_mem_f[wr_index][30*3-1:30*2] <= 
                    data_in[30-1:0];
                end
                2'd3:
                begin
                    data_mem_f[wr_index][30*4-1:30*3] <= 
                    data_in[30-1:0];
                end
                default:
                begin
                    data_mem_f[wr_index] <= data_mem_f[wr_index];
                end
                endcase
            end
            2'd1:
            begin
                data_mem_f[wr_index][123:120] <= data_in[4-1:0];
            end
            2'd2: 
            begin
                data_mem_f[wr_index][137:124] <= data_in[14-1:0];
            end
            default:
            begin
                data_mem_f[wr_index] <= data_mem_f[wr_index];
            end
            endcase
        end
        else
        begin
            data_mem_f[wr_index] <= {wr_tag_in, smc_valid_in, smc_data_in};
        end
    end
end


endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2_state.v
//  Created On    : 2014-02-24
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : The state array in the L2 cache
//
//
//==================================================================================================

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : l2.h.pyv
//  Created On    : 2014-02-20
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : header file for the L2 cache
//
//
//==================================================================================================

// devices.xml



// Input buffer for pipeline1













// Input buffer for pipeline2














// Output buffer















// L2 cache configuration







//`define L2_SIZE                  65536
//`define L2_SIZE_WIDTH            16






//`define L2_LINE_SIZE             64
//`define L2_LINE_SIZE_WIDTH       6













//`define L2_WAYS                  4
//`define L2_WAYS_WIDTH            2
//`define L2_WAY_0                 2'b00
//`define L2_WAY_1                 2'b01
//`define L2_WAY_2                 2'b10
//`define L2_WAY_3                 2'b11





// Tag array







//`define L2_TAG_INDEX_WIDTH      8
//`define L2_TAG_WIDTH            26
//`define L2_TAG_WAY_WIDTH        26
//`define L2_TAG_ARRAY_WIDTH      104


// Tag Address decomposition 




//`define L2_TAG_INDEX            13:6
//`define L2_TAG                  39:14


//Data array












//`define L2_DATA_INDEX_WIDTH         12 








// Data Address decomposition 







//Dir array



//`define L2_DIR_INDEX_WIDTH      10 





//State array

















//Whether the cache line is in Icaches or Dcaches







//`define L2_OWNER_X_WIDTH        3
//`define L2_OWNER_Y_WIDTH        3
//`define L2_OWNER_XY             2:0
//`define L2_OWNER_X              2:0
//`define L2_OWNER_Y              5:3




//Round Robin selection














// State decomposition 












//MSHR array



































//`define L2_MSHR_CMP_ADDR        13:6
//`define L2_MSHR_ADDR            39:0
//`define L2_MSHR_WAY             41:40
//`define L2_MSHR_MSHRID          49:42
//`define L2_MSHR_CACHE_TYPE      50
//`define L2_MSHR_DATA_SIZE       53:51
//`define L2_MSHR_MSG_TYPE        61:54
//`define L2_MSHR_L2_MISS         62
//`define L2_MSHR_SRC_CHIPID      76:63
//`define L2_MSHR_SRC_X           84:77
//`define L2_MSHR_SRC_Y           92:85
//`define L2_MSHR_SRC_FBITS       96:93
//`define L2_MSHR_SDID            106:97
//`define L2_MSHR_LSID            112:107      
//`define L2_MSHR_MISS_LSID       118:113
//`define L2_MSHR_SMC_MISS        119
//`define L2_MSHR_RECYCLED        120
//`define L2_MSHR_INV_FWD_PENDING 121


//SMC array


































//Message destination_type







//L2 public sharer beyond the maximum clump size



//L2 registers



//Special addresses





















//L2 core ID





//L2 dir array reuse







//Control Signal 








//AMO ALU OP macros












//Control Signal in Stage 1























































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module l2_state(


    input wire clk,
    input wire rst_n,
    input wire pdout_en,
    input wire deepsleep,

    input wire rd_en,
    input wire wr_en,
    input wire [9-1:0] rd_addr,
    input wire [9-1:0] wr_addr,
    input wire [15*4+2+4-1:0] data_in,
    input wire [15*4+2+4-1:0] data_mask_in,

    output reg [15*4+2+4-1:0] data_out,
    output wire [15*4+2+4-1:0] pdata_out,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data

);




//Need to bypass the read data if both read and write are valid for the same index in the same cycle


reg [15*4+2+4-1:0] data_in_buf;
reg [15*4+2+4-1:0] data_mask_in_buf;
wire [15*4+2+4-1:0] data_out_real;

always @ (posedge clk)
begin
    data_in_buf <= data_in;
    data_mask_in_buf <= data_mask_in;
end

reg bypass_f;
reg bypass_next;

always @ *
begin
    if (rd_en && wr_en && (rd_addr == wr_addr))
    begin
        bypass_next = 1'b1;
    end
    else
    begin
        bypass_next = 1'b0;
    end
end


always @ (posedge clk)
begin
    bypass_f <= bypass_next;
end

always @ *
begin
    if (bypass_f)
    begin

        data_out[0] = data_mask_in_buf[0] ? data_in_buf[0] : data_out_real[0];
    

        data_out[1] = data_mask_in_buf[1] ? data_in_buf[1] : data_out_real[1];
    

        data_out[2] = data_mask_in_buf[2] ? data_in_buf[2] : data_out_real[2];
    

        data_out[3] = data_mask_in_buf[3] ? data_in_buf[3] : data_out_real[3];
    

        data_out[4] = data_mask_in_buf[4] ? data_in_buf[4] : data_out_real[4];
    

        data_out[5] = data_mask_in_buf[5] ? data_in_buf[5] : data_out_real[5];
    

        data_out[6] = data_mask_in_buf[6] ? data_in_buf[6] : data_out_real[6];
    

        data_out[7] = data_mask_in_buf[7] ? data_in_buf[7] : data_out_real[7];
    

        data_out[8] = data_mask_in_buf[8] ? data_in_buf[8] : data_out_real[8];
    

        data_out[9] = data_mask_in_buf[9] ? data_in_buf[9] : data_out_real[9];
    

        data_out[10] = data_mask_in_buf[10] ? data_in_buf[10] : data_out_real[10];
    

        data_out[11] = data_mask_in_buf[11] ? data_in_buf[11] : data_out_real[11];
    

        data_out[12] = data_mask_in_buf[12] ? data_in_buf[12] : data_out_real[12];
    

        data_out[13] = data_mask_in_buf[13] ? data_in_buf[13] : data_out_real[13];
    

        data_out[14] = data_mask_in_buf[14] ? data_in_buf[14] : data_out_real[14];
    

        data_out[15] = data_mask_in_buf[15] ? data_in_buf[15] : data_out_real[15];
    

        data_out[16] = data_mask_in_buf[16] ? data_in_buf[16] : data_out_real[16];
    

        data_out[17] = data_mask_in_buf[17] ? data_in_buf[17] : data_out_real[17];
    

        data_out[18] = data_mask_in_buf[18] ? data_in_buf[18] : data_out_real[18];
    

        data_out[19] = data_mask_in_buf[19] ? data_in_buf[19] : data_out_real[19];
    

        data_out[20] = data_mask_in_buf[20] ? data_in_buf[20] : data_out_real[20];
    

        data_out[21] = data_mask_in_buf[21] ? data_in_buf[21] : data_out_real[21];
    

        data_out[22] = data_mask_in_buf[22] ? data_in_buf[22] : data_out_real[22];
    

        data_out[23] = data_mask_in_buf[23] ? data_in_buf[23] : data_out_real[23];
    

        data_out[24] = data_mask_in_buf[24] ? data_in_buf[24] : data_out_real[24];
    

        data_out[25] = data_mask_in_buf[25] ? data_in_buf[25] : data_out_real[25];
    

        data_out[26] = data_mask_in_buf[26] ? data_in_buf[26] : data_out_real[26];
    

        data_out[27] = data_mask_in_buf[27] ? data_in_buf[27] : data_out_real[27];
    

        data_out[28] = data_mask_in_buf[28] ? data_in_buf[28] : data_out_real[28];
    

        data_out[29] = data_mask_in_buf[29] ? data_in_buf[29] : data_out_real[29];
    

        data_out[30] = data_mask_in_buf[30] ? data_in_buf[30] : data_out_real[30];
    

        data_out[31] = data_mask_in_buf[31] ? data_in_buf[31] : data_out_real[31];
    

        data_out[32] = data_mask_in_buf[32] ? data_in_buf[32] : data_out_real[32];
    

        data_out[33] = data_mask_in_buf[33] ? data_in_buf[33] : data_out_real[33];
    

        data_out[34] = data_mask_in_buf[34] ? data_in_buf[34] : data_out_real[34];
    

        data_out[35] = data_mask_in_buf[35] ? data_in_buf[35] : data_out_real[35];
    

        data_out[36] = data_mask_in_buf[36] ? data_in_buf[36] : data_out_real[36];
    

        data_out[37] = data_mask_in_buf[37] ? data_in_buf[37] : data_out_real[37];
    

        data_out[38] = data_mask_in_buf[38] ? data_in_buf[38] : data_out_real[38];
    

        data_out[39] = data_mask_in_buf[39] ? data_in_buf[39] : data_out_real[39];
    

        data_out[40] = data_mask_in_buf[40] ? data_in_buf[40] : data_out_real[40];
    

        data_out[41] = data_mask_in_buf[41] ? data_in_buf[41] : data_out_real[41];
    

        data_out[42] = data_mask_in_buf[42] ? data_in_buf[42] : data_out_real[42];
    

        data_out[43] = data_mask_in_buf[43] ? data_in_buf[43] : data_out_real[43];
    

        data_out[44] = data_mask_in_buf[44] ? data_in_buf[44] : data_out_real[44];
    

        data_out[45] = data_mask_in_buf[45] ? data_in_buf[45] : data_out_real[45];
    

        data_out[46] = data_mask_in_buf[46] ? data_in_buf[46] : data_out_real[46];
    

        data_out[47] = data_mask_in_buf[47] ? data_in_buf[47] : data_out_real[47];
    

        data_out[48] = data_mask_in_buf[48] ? data_in_buf[48] : data_out_real[48];
    

        data_out[49] = data_mask_in_buf[49] ? data_in_buf[49] : data_out_real[49];
    

        data_out[50] = data_mask_in_buf[50] ? data_in_buf[50] : data_out_real[50];
    

        data_out[51] = data_mask_in_buf[51] ? data_in_buf[51] : data_out_real[51];
    

        data_out[52] = data_mask_in_buf[52] ? data_in_buf[52] : data_out_real[52];
    

        data_out[53] = data_mask_in_buf[53] ? data_in_buf[53] : data_out_real[53];
    

        data_out[54] = data_mask_in_buf[54] ? data_in_buf[54] : data_out_real[54];
    

        data_out[55] = data_mask_in_buf[55] ? data_in_buf[55] : data_out_real[55];
    

        data_out[56] = data_mask_in_buf[56] ? data_in_buf[56] : data_out_real[56];
    

        data_out[57] = data_mask_in_buf[57] ? data_in_buf[57] : data_out_real[57];
    

        data_out[58] = data_mask_in_buf[58] ? data_in_buf[58] : data_out_real[58];
    

        data_out[59] = data_mask_in_buf[59] ? data_in_buf[59] : data_out_real[59];
    

        data_out[60] = data_mask_in_buf[60] ? data_in_buf[60] : data_out_real[60];
    

        data_out[61] = data_mask_in_buf[61] ? data_in_buf[61] : data_out_real[61];
    

        data_out[62] = data_mask_in_buf[62] ? data_in_buf[62] : data_out_real[62];
    

        data_out[63] = data_mask_in_buf[63] ? data_in_buf[63] : data_out_real[63];
    

        data_out[64] = data_mask_in_buf[64] ? data_in_buf[64] : data_out_real[64];
    

        data_out[65] = data_mask_in_buf[65] ? data_in_buf[65] : data_out_real[65];
    

    end
    else
    begin
        data_out = data_out_real;
    end
end

 // sram_2rw_256x66 l2_state_array (
 sram_l2_state l2_state_array (
     .RESET_N(rst_n),
     .MEMCLK         (clk),

     .CEA            (rd_en),
     .RDWENA          (1'b1),
     .AA             (rd_addr),
     .BWA             (),
     .DINA            (),
     .DOUTA           (data_out_real),

     .CEB            (wr_en),
     .RDWENB            (1'b0),
     .AB             (wr_addr),
     .BWB             (data_mask_in),
     .DINB            (data_in),
     .DOUTB           (),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(8'd15)

 );





endmodule
