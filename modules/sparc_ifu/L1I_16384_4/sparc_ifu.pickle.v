// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *   Description:
 *      This module implements a 16-bit counter to be used by Execution
 *      Drafting
 */

module sparc_ifu_esl_counter
#(
    parameter   COUNT_BIT_WIDTH = 16
)
(
    input                               clk,
    input                               rst_n,

    // Counter control
    input                               step,
    input                               clear,
    input                               set,

    // Counter output
    output reg [COUNT_BIT_WIDTH-1:0]    count_f
);

    //
    // Signal Declarations
    //

    // Counter next state
    reg [COUNT_BIT_WIDTH-1:0]          count_next;

    //
    // Sequential logic
    //
    
    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            count_f <= {COUNT_BIT_WIDTH{1'b0}};
        else
            count_f <= count_next;
    end

    //
    // Combinational logic
    //

    always @ *
    begin
        count_next = count_f;
        if (clear)
            count_next = {COUNT_BIT_WIDTH{1'b0}};
        else if (set)
            count_next = {{(COUNT_BIT_WIDTH-1){1'b0}}, 1'b1};
        else if (step)
            count_next = count_f + {{(COUNT_BIT_WIDTH-1){1'b0}}, 1'b1};
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to HTSM.
 */

module sparc_ifu_esl_htsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    input               clk,
    input               rst_n,

    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_htsm_trigger,
   
    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Pseudo-random bit
    input               pseudo_rand_f,

    // Difference in VA PCs lessthan the threshold
    input               esl_pc_va_diff_lt_thresh_s,

    // The counter reached the configured timeout value
    input               esl_counter_timeout,

    // The LSB of the shift register
    input               esl_shiftreg_lsb,

    // Thread with minimum PC
    input [3:0]         esl_min_pc_va_s,

    // VA PCs equal (including offset)
    input               esl_pcs_va_eql_s,

    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,

    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap PC in bf or f
    input               esl_brtrp_target_pc_bf_f,

    // Outputs to core and ED FSM
    output reg [2:0]    esl_htsm_state_next,
    output reg [3:0]    esl_htsm_fcl_nextthr_bf,
    output reg          esl_htsm_fcl_switch_bf,
    output reg          esl_htsm_fcl_ntr_s,
    output reg          esl_htsm_lfsr_step,
    output reg          esl_htsm_timeout_counter_step,
    output reg          esl_htsm_timeout_counter_clear,
    output reg          esl_htsm_timeout_counter_set,
    output reg          esl_htsm_pc_va_diff_offset_we,
    output reg          esl_htsm_pc_va_diff_offset_clear,
    output reg          esl_htsm_timeout_shiftreg_step,
    output reg          esl_htsm_timeout_shiftreg_set,
    output reg          esl_htsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //
    
    // Register to keep track of which thread we are issuing
    // when sliding thread past each other
    reg esl_htsm_sliding_thread_f;
    reg esl_htsm_sliding_thread_next;

    //
    // Sequential Logic
    //
    
    // Flip-flop to keep track of which thread is sliding
    always @ (posedge clk)
    begin
        if (~rst_n)
            esl_htsm_sliding_thread_f <= 1'b0;
        else
            esl_htsm_sliding_thread_f <= esl_htsm_sliding_thread_next;
    end
    

    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should always be running
        esl_htsm_lfsr_step = 1'b1;

        // Default is to clear the counter
        esl_htsm_timeout_counter_step = 1'b0;
        esl_htsm_timeout_counter_clear = 1'b1;
        esl_htsm_timeout_counter_set = 1'b0;

        // Default is not to set the offset register
        esl_htsm_pc_va_diff_offset_we = 1'b0;
        esl_htsm_pc_va_diff_offset_clear = 1'b0;

        // Default is to set the timeout shift register
        esl_htsm_timeout_shiftreg_step = 1'b0;
        esl_htsm_timeout_shiftreg_set = 1'b1;

        // Default is to keep the same sliding thread
        esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

        // Default to comparing with configured timeout
        esl_htsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_htsm_trigger && (esl_state_f == DIVERGED))
        begin
            // Always compare to configured timeout when in diverged
            esl_htsm_timeout_counter_cmp_config = 1'b1;
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_htsm_state_next = DIVERGED;
                esl_htsm_fcl_nextthr_bf = 4'b0000;
                esl_htsm_fcl_switch_bf = 1'b0;
                esl_htsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave counter alone
                esl_htsm_timeout_counter_step = 1'b0;
                esl_htsm_timeout_counter_clear = 1'b0;
                esl_htsm_timeout_counter_set = 1'b0;

                // Leave the shift register alone
                esl_htsm_timeout_shiftreg_step = 1'b0;
                esl_htsm_timeout_shiftreg_set = 1'b0;

                // Keep same sliding thread
                esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_htsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_htsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                    end
                    else
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'bxxxx;
                    end
                    esl_htsm_fcl_switch_bf = 1'b1;
                    esl_htsm_fcl_ntr_s = 1'b1;

                    // Leave counter alone
                    esl_htsm_timeout_counter_step = 1'b0;
                    esl_htsm_timeout_counter_clear = 1'b0;
                    esl_htsm_timeout_counter_set = 1'b0;

                    // Leave the shift register alone
                    esl_htsm_timeout_shiftreg_step = 1'b0;
                    esl_htsm_timeout_shiftreg_set = 1'b0;

                    // Keep same sliding thread
                    esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_htsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_htsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Clear counter
                        esl_htsm_timeout_counter_step = 1'b0;
                        esl_htsm_timeout_counter_clear = 1'b1;
                        esl_htsm_timeout_counter_set = 1'b0;

                        // Set the shift register back to 1
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Thread 0 becomes sliding thread
                        esl_htsm_sliding_thread_next = 1'b0;
                    end
                    else
                    begin
                        // If the VA PCs + offset are equal, we must go to diverged
                        // different code, issuing thread0, and begin sliding threads
                        // past each other
                        if (esl_pcs_va_eql_s)
                        begin
                            // Go to diverged different code
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;

                            // Select thread 0
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                            
                            // Executed one for thread0 which is where we need
                            // to start, so we will reset this counter here to
                            // start counting for thread 1
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b1;
                            
                            // Shift the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b1;
                            esl_htsm_timeout_shiftreg_set = 1'b0;

                            // Thread 1 is now the sliding thread
                            esl_htsm_sliding_thread_next = 1'b1; 
                        end
                        // Otherwise, do the same as STSM except choose random thread
                        // when beyond the threshold
                        else
                        begin
                            // Always stay in diverged state
                            esl_htsm_state_next = DIVERGED;
                            // Select thread with the minimum VA PC if the difference is less
                            // than a threshold, otherwise alternate
                            if (esl_pc_va_diff_lt_thresh_s)
                            begin
                                // If we have hit the timeout in selecting the minimum PC,
                                // select the maximum PC
                                if (esl_counter_timeout)
                                begin
                                    if (esl_min_pc_va_s == 4'b0001)
                                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                                    else
                                        esl_htsm_fcl_nextthr_bf = 4'b0001;

                                    // Clear the timer
                                    esl_htsm_timeout_counter_step = 1'b0;
                                    esl_htsm_timeout_counter_clear = 1'b1;
                                    esl_htsm_timeout_counter_set = 1'b0;
                                end
                                // Otherwise, select minimum PC and increment timeout
                                else
                                begin
                                    esl_htsm_fcl_nextthr_bf = esl_min_pc_va_s;

                                    // Increment counter
                                    esl_htsm_timeout_counter_step = 1'b1;
                                    esl_htsm_timeout_counter_clear = 1'b0;
                                    esl_htsm_timeout_counter_set = 1'b0;
                                end
                            end
                            else
                            begin
                                // Select random thread
                                if (pseudo_rand_f)
                                    esl_htsm_fcl_nextthr_bf = 4'b0010;
                                else
                                    esl_htsm_fcl_nextthr_bf = 4'b0001;
 
                                // Clear the timer
                                esl_htsm_timeout_counter_step = 1'b0;
                                esl_htsm_timeout_counter_clear = 1'b1;
                                esl_htsm_timeout_counter_set = 1'b0;
                            end
                        end
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Reset the shiftreg
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Keep same sliding thread
                        esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                    end
                end
            end
        end
        else if (esl_htsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Always compare to shift register in this state
            esl_htsm_timeout_counter_cmp_config = 1'b0;
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                esl_htsm_fcl_nextthr_bf = 4'b0000;
                esl_htsm_fcl_switch_bf = 1'b0;
                esl_htsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave the timeout counter alone
                esl_htsm_timeout_counter_step = 1'b0;
                esl_htsm_timeout_counter_clear = 1'b0;
                esl_htsm_timeout_counter_set = 1'b0;

                // Leave the shift register alone
                esl_htsm_timeout_shiftreg_step = 1'b0;
                esl_htsm_timeout_shiftreg_set = 1'b0;

                // Keep same sliding thread
                esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

                // Do not set offset
                esl_htsm_pc_va_diff_offset_we = 1'b0;
                esl_htsm_pc_va_diff_offset_clear = 1'b0;
            end
            // Otherwise, both threads are ready
            else
            begin 
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_htsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                    end
                    else
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'bxxxx;
                    end
                    esl_htsm_fcl_switch_bf = 1'b1;
                    esl_htsm_fcl_ntr_s = 1'b1;

                    // Leave the timeout counter alone
                    esl_htsm_timeout_counter_step = 1'b0;
                    esl_htsm_timeout_counter_clear = 1'b0;
                    esl_htsm_timeout_counter_set = 1'b0;

                    // Leave the shift register alone
                    esl_htsm_timeout_shiftreg_step = 1'b0;
                    esl_htsm_timeout_shiftreg_set = 1'b0;

                    // Keep same sliding thread
                    esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

                    // Do not set offset
                    esl_htsm_pc_va_diff_offset_we = 1'b0;
                    esl_htsm_pc_va_diff_offset_clear = 1'b0;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged, update offset
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                        begin
                            esl_htsm_state_next = CONVERGED_DRAFT;

                            // Update offset to current difference in VA's
                            esl_htsm_pc_va_diff_offset_we = 1'b1;
                            esl_htsm_pc_va_diff_offset_clear = 1'b0;
                        end
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                        begin
                            esl_htsm_state_next = DIVERGED_DRAFT;
    
                            // Do not update offset
                            esl_htsm_pc_va_diff_offset_we = 1'b0;
                            esl_htsm_pc_va_diff_offset_clear = 1'b0;
                        end

                        // Select thr0 for next cycle
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Clear the timeout counter
                        esl_htsm_timeout_counter_step = 1'b0;
                        esl_htsm_timeout_counter_clear = 1'b1;
                        esl_htsm_timeout_counter_set = 1'b0;

                        // Reset the shift register
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Sliding thread is back to thread 0
                        esl_htsm_sliding_thread_next = 1'b0;
                    end
                    else
                    begin
                        // The LSB of the shift register should only
                        // ever be 1 after the shift register rolls
                        // around and not when we first enter this state
                        // (shiftreg should be 16'b2 entering this state
                        // for the first time). In the case the shiftreg
                        // rolls around, we declare diverged
                        if (esl_shiftreg_lsb)
                        begin
                            esl_htsm_state_next = DIVERGED;
                                
                            // Issue the current sliding thread
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;

                            // Clear the timeout counter
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b1;
                            esl_htsm_timeout_counter_set = 1'b0;

                            // Reset the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b0;
                            esl_htsm_timeout_shiftreg_set = 1'b1;

                            // Sliding thread is back to thread 0
                            esl_htsm_sliding_thread_next = 1'b0;
                        end
                        // Check if the counter reached the shift register value
                        else if (esl_counter_timeout)
                        begin
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                            
                            // If so, issue the sliding thread,
                            // reset shift reg counter, shift
                            // the shift register, and invert
                            // sliding thread
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;

                            // Set the timeout counter
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b1;

                            // Step the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b1;
                            esl_htsm_timeout_shiftreg_set = 1'b1;

                            // Invert sliding thread
                            esl_htsm_sliding_thread_next = ~esl_htsm_sliding_thread_f;
                        end
                        else
                        begin
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                            
                            // If not, issue the sliding thread and
                            // increment counter
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;
                           
                            // Step the timeout counter
                            esl_htsm_timeout_counter_step = 1'b1;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b0;
 
                            // Leave the shift register alone
                            esl_htsm_timeout_shiftreg_step = 1'b0;
                            esl_htsm_timeout_shiftreg_set = 1'b0;

                            // Same sliding thread
                            esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                        end

                        // Do not set the offset register
                        esl_htsm_pc_va_diff_offset_we = 1'b0; 
                        esl_htsm_pc_va_diff_offset_clear = 1'b0;
                    end
                end
            end
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_htsm_state_next = 3'bxx;
            esl_htsm_fcl_nextthr_bf = 4'bxxxx;
            esl_htsm_fcl_switch_bf = 1'bx;
            esl_htsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
//  Description:
//      An LFSR for the Execution Drafting random thread synchronization method.
//      The LFSR provides pseudo-randomness in selecting a random thread to execute.
//      It is a 16-bit LFSR with the following polynomial:
//          x^16 + x^14 + x^13 + x^11 + 1
*/

module sparc_ifu_esl_lfsr 
(
    input               clk,
    input               rst_n,

    // Seeding the LFSR
    input [15:0]        lfsr_seed,
    input               lfsr_ld,

    // Enable signal for LFSR
    input               lfsr_step,

    // LFSR state output
    output reg [15:0]   lfsr_state_f,

    // LFSR bit stream output
    output reg          lfsr_out_f
);

    //
    // Signal Declarations
    //
    
    // LFSR next state
    reg [15:0]          lfsr_state_next;

    //
    // Sequential logic
    //

    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            lfsr_state_f <= 16'b0;
        else
            lfsr_state_f <= lfsr_state_next;
    end
    
    //
    // Combinational Logic
    // 
    
    always @ *
    begin
        // Next state logic
        lfsr_state_next = lfsr_state_f;
        if (rst_n && lfsr_ld)
            lfsr_state_next = lfsr_seed;
        else if (rst_n && lfsr_step)
            lfsr_state_next = {lfsr_state_f[14:0], 
                               lfsr_state_f[15] ^ lfsr_state_f[13] ^ lfsr_state_f[12] ^ lfsr_state_f[10]};

        // Output bitstream comes from the 16th state bit
        lfsr_out_f = lfsr_state_f[15];
    end

endmodule // sparc_esl_lfsr
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to RTSM.
 */

module sparc_ifu_esl_rtsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_rtsm_trigger,

    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s, 

    // Pseudo-random bit
    input               pseudo_rand_f,
  
    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,
 
    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap PC in bf or f
    input               esl_brtrp_target_pc_bf_f,
 
    // Outputs to core and ED FSM
    output reg [2:0]    esl_rtsm_state_next,   
    output reg [3:0]    esl_rtsm_fcl_nextthr_bf,
    output reg          esl_rtsm_fcl_switch_bf,
    output reg          esl_rtsm_fcl_ntr_s,
    output reg          esl_rtsm_lfsr_step,
    output reg          esl_rtsm_timeout_counter_step,
    output reg          esl_rtsm_timeout_counter_clear,
    output reg          esl_rtsm_timeout_counter_set,
    output reg          esl_rtsm_pc_va_diff_offset_we,
    output reg          esl_rtsm_pc_va_diff_offset_clear,
    output reg          esl_rtsm_timeout_shiftreg_step,
    output reg          esl_rtsm_timeout_shiftreg_set,
    output reg          esl_rtsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //

    //
    // Sequential Logic
    //
    
    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should always be running
        esl_rtsm_lfsr_step = 1'b1;

        // Counter should never be running (always clear)
        esl_rtsm_timeout_counter_step = 1'b0;
        esl_rtsm_timeout_counter_clear = 1'b1; 
        esl_rtsm_timeout_counter_set = 1'b0;

        // Never use offset register
        esl_rtsm_pc_va_diff_offset_we = 1'b0;
        esl_rtsm_pc_va_diff_offset_clear = 1'b1;

        // Never use shift register
        esl_rtsm_timeout_shiftreg_step = 1'b0;
        esl_rtsm_timeout_shiftreg_set = 1'b1;

        // Doesn't really matter what we set this to
        // as we never check whether counter times out
        esl_rtsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_rtsm_trigger && (esl_state_f == DIVERGED))
        begin
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_rtsm_state_next = DIVERGED;
                esl_rtsm_fcl_nextthr_bf = 4'b0000;
                esl_rtsm_fcl_switch_bf = 1'b0;
                esl_rtsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_rtsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_rtsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_rtsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_rtsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_rtsm_fcl_nextthr_bf = 4'b0010;
                    end
                    esl_rtsm_fcl_switch_bf = 1'b1;
                    esl_rtsm_fcl_ntr_s = 1'b1;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_rtsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_rtsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_rtsm_fcl_nextthr_bf = 4'b0001;
                        esl_rtsm_fcl_switch_bf = 1'b1;
                        esl_rtsm_fcl_ntr_s = 1'b1;
                    end
                    else
                    begin
                        // Always stay in diverged state
                        esl_rtsm_state_next = DIVERGED;
                        // Select random thread
                        if (pseudo_rand_f)
                            esl_rtsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_rtsm_fcl_nextthr_bf = 4'b0001;
                        esl_rtsm_fcl_switch_bf = 1'b1;
                        esl_rtsm_fcl_ntr_s = 1'b1;
                    end
                end
            end
        end
        else if (esl_rtsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0; 
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_rtsm_state_next = 3'bx;
            esl_rtsm_fcl_nextthr_bf = 4'bxxxx;
            esl_rtsm_fcl_switch_bf = 1'bx;
            esl_rtsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *   Description:
 *      This module implements a 49-bit shift register with wrap around
 *      to be used by Execution Drafting
 */

module sparc_ifu_esl_shiftreg
#(
    parameter SHIFT_REG_BIT_WIDTH = 16
)
(
    input                                   clk,
    input                                   rst_n,

    // Counter control
    input                                   step,
    input                                   set,

    // Counter output
    output reg [SHIFT_REG_BIT_WIDTH-1:0]    shift_reg_f
);

    //
    // Signal Declarations
    //

    // Counter next state
    reg [SHIFT_REG_BIT_WIDTH-1:0]          shift_reg_next;

    //
    // Sequential logic
    //
    
    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            shift_reg_f <= {SHIFT_REG_BIT_WIDTH{1'b0}};
        else
            shift_reg_f <= shift_reg_next;
    end

    //
    // Combinational logic
    //

    always @ *
    begin
        shift_reg_next = shift_reg_f;
        if (set)
            shift_reg_next = {{(SHIFT_REG_BIT_WIDTH-1){1'b0}}, 1'b1};
        else if (step)
            shift_reg_next = {shift_reg_f[SHIFT_REG_BIT_WIDTH-2:0], shift_reg_f[SHIFT_REG_BIT_WIDTH-1]};
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to STSM.
 */

module sparc_ifu_esl_stsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_stsm_trigger,
   
    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Difference in VA PCs lessthan the threshold
    input               esl_pc_va_diff_lt_thresh_s,

    // The counter reached the timeout value
    input               esl_counter_timeout,

    // Thread with minimum PC
    input [3:0]         esl_min_pc_va_s,

    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,

    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap target PC in bf or f
    input               esl_brtrp_target_pc_bf_f,

    // Outputs to core and ED FSM
    output reg [2:0]    esl_stsm_state_next,
    output reg [3:0]    esl_stsm_fcl_nextthr_bf,
    output reg          esl_stsm_fcl_switch_bf,
    output reg          esl_stsm_fcl_ntr_s,
    output reg          esl_stsm_lfsr_step,
    output reg          esl_stsm_timeout_counter_step,
    output reg          esl_stsm_timeout_counter_clear,
    output reg          esl_stsm_timeout_counter_set,
    output reg          esl_stsm_pc_va_diff_offset_we,
    output reg          esl_stsm_pc_va_diff_offset_clear,
    output reg          esl_stsm_timeout_shiftreg_step,
    output reg          esl_stsm_timeout_shiftreg_set,
    output reg          esl_stsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //

    //
    // Sequential Logic
    //
    
    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should never be running
        esl_stsm_lfsr_step = 1'b0;

        // Default is to clear the counter
        esl_stsm_timeout_counter_step = 1'b0;
        esl_stsm_timeout_counter_clear = 1'b1;
        esl_stsm_timeout_counter_set = 1'b0;

        // Never use offset register
        esl_stsm_pc_va_diff_offset_we = 1'b0;
        esl_stsm_pc_va_diff_offset_clear = 1'b1;

        // Never use the shift register
        esl_stsm_timeout_shiftreg_step = 1'b0;
        esl_stsm_timeout_shiftreg_set = 1'b1;

        // Always compare to configured timeout
        esl_stsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_stsm_trigger && (esl_state_f == DIVERGED))
        begin
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_stsm_state_next = DIVERGED;
                esl_stsm_fcl_nextthr_bf = 4'b0000;
                esl_stsm_fcl_switch_bf = 1'b0;
                esl_stsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave counter alone
                esl_stsm_timeout_counter_step = 1'b0;
                esl_stsm_timeout_counter_clear = 1'b0;
                esl_stsm_timeout_counter_set = 1'b0;
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_stsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_stsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_stsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_stsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_stsm_fcl_nextthr_bf = 4'b0010;
                    end
                    esl_stsm_fcl_switch_bf = 1'b1;
                    esl_stsm_fcl_ntr_s = 1'b1;

                    // Leave counter alone
                    esl_stsm_timeout_counter_step = 1'b0;
                    esl_stsm_timeout_counter_clear = 1'b0;
                    esl_stsm_timeout_counter_set = 1'b0;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_stsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_stsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_stsm_fcl_nextthr_bf = 4'b0001;
                        esl_stsm_fcl_switch_bf = 1'b1;
                        esl_stsm_fcl_ntr_s = 1'b1;

                        // Clear counter
                        esl_stsm_timeout_counter_step = 1'b0;
                        esl_stsm_timeout_counter_clear = 1'b1;
                        esl_stsm_timeout_counter_set = 1'b0;
                    end
                    else
                    begin
                        // Always stay in diverged state
                        esl_stsm_state_next = DIVERGED;
                        // Select thread with the minimum VA PC if the difference is less
                        // than a threshold, otherwise alternate
                        if (esl_pc_va_diff_lt_thresh_s)
                        begin
                            // If we have hit the timeout in selecting the minimum PC,
                            // select the maximum PC
                            if (esl_counter_timeout)
                            begin
                                if (esl_min_pc_va_s == 4'b0001)
                                    esl_stsm_fcl_nextthr_bf = 4'b0010;
                                else
                                    esl_stsm_fcl_nextthr_bf = 4'b0001;

                                // Clear the timer
                                esl_stsm_timeout_counter_step = 1'b0;
                                esl_stsm_timeout_counter_clear = 1'b1;
                                esl_stsm_timeout_counter_set = 1'b0;
                            end
                            // Otherwise, select minimum PC and increment timeout
                            else
                            begin
                                esl_stsm_fcl_nextthr_bf = esl_min_pc_va_s;
                                // Increment counter
                                esl_stsm_timeout_counter_step = 1'b1;
                                esl_stsm_timeout_counter_clear = 1'b0;
                                esl_stsm_timeout_counter_set = 1'b0;
                            end
                        end
                        else
                        begin
                            if (fcl_esl_thr_f == 4'b0001)
                                esl_stsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_stsm_fcl_nextthr_bf = 4'b0001;
                            
                            // Clear the timer
                            esl_stsm_timeout_counter_step = 1'b0;
                            esl_stsm_timeout_counter_clear = 1'b1;
                            esl_stsm_timeout_counter_set = 1'b0;
                        end
                        esl_stsm_fcl_switch_bf = 1'b1;
                        esl_stsm_fcl_ntr_s = 1'b1;
                    end
                end
            end     
        end
        else if (esl_stsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0; 
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_stsm_state_next = 3'bxx;
            esl_stsm_fcl_nextthr_bf = 4'bxxxx;
            esl_stsm_fcl_switch_bf = 1'bx;
            esl_stsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/********************************************************************
 * Author: Sam Payne
 * 
 * Module encapsulates an asynchronus FIFO used for bridging signals
 * across clock domains, parameters allow for different sized modules
 * compatible with wide range of frequencies.
 *
 * * *******************************************************************/



module async_fifo 
#(
	parameter DSIZE = 64,
	parameter ASIZE = 5,
	parameter MEMSIZE = 16 // should be 2 ^ (ASIZE-1)
)
(
	rdata, 
	rempty,
	rclk,
	ren,
	wdata,
	wfull,
	wclk,
	wval,
	wreset,
	rreset
	);

//Inputs and Outputs
output  [DSIZE-1:0] 	rdata;
output			rempty;
output 			wfull;
input	[DSIZE-1:0]	wdata;
input			wval;
input			ren;
input			rclk;
input			wclk;
input 			wreset;
input			rreset;

//Internal Registers
reg	[ASIZE-1:0]	g_wptr;
reg	[ASIZE-1:0]	g_rptr;

reg	[ASIZE-1:0]	g_rsync1, g_rsync2;
reg	[ASIZE-1:0]	g_wsync1, g_wsync2;

//Memory
reg	[DSIZE-1:0] 	fifo[MEMSIZE-1:0];

wire [ASIZE-1:0] b_wptr;
wire [ASIZE-1:0] b_wptr_next;
wire [ASIZE-1:0] g_wptr_next;
wire [ASIZE-1:0] b_rptr;
wire [ASIZE-1:0] b_rptr_next;
wire [ASIZE-1:0] g_rptr_next;

/********************************************************************
COMBINATIONAL LOGIC
********************************************************************/

//convert gray to binary
assign b_wptr[ASIZE-1:0] = ({1'b0, b_wptr[ASIZE-1:1]} ^ g_wptr[ASIZE-1:0]);
assign b_rptr[ASIZE-1:0] = ({1'b0, b_rptr[ASIZE-1:1]} ^ g_rptr[ASIZE-1:0]);

//increment
assign b_wptr_next = b_wptr + 1;
assign b_rptr_next = b_rptr + 1;

//convert binary to gray
assign g_wptr_next[ASIZE-1:0] = {1'b0, b_wptr_next[ASIZE-1:1]} ^ b_wptr_next[ASIZE-1:0];
assign g_rptr_next[ASIZE-1:0] = {1'b0, b_rptr_next[ASIZE-1:1]} ^ b_rptr_next[ASIZE-1:0];

//full and empty signals
assign wfull =  (g_wptr[ASIZE-1]   != g_rsync2[ASIZE-1]  ) && 
		(g_wptr[ASIZE-2]   != g_rsync2[ASIZE-2]  ) &&
		(g_wptr[ASIZE-3:0] == g_rsync2[ASIZE-3:0]) ||
		(wreset || rreset);

assign rempty =  (g_wsync2[ASIZE-1:0] == g_rptr[ASIZE-1:0]) ||
	         (wreset || rreset);

//output values
assign rdata = fifo[b_rptr[ASIZE-2:0]];

/********************************************************************
SEQUENTIAL LOGIC
********************************************************************/

//transfer register values
always @(posedge rclk) begin
	if (rreset) begin
		g_rptr <= 0;
	end
	else if (ren && !rempty) begin
		g_rptr <= g_rptr_next;
	end

	g_wsync1 <= g_wptr;
	g_wsync2 <= g_wsync1;
end

always @(posedge wclk) begin
	if (wreset) begin
		g_wptr <= 0;
	end
	else if (wval && !wfull) begin
		fifo[b_wptr[ASIZE-2:0]] <= wdata;
		g_wptr <= g_wptr_next;
	end

	g_rsync1 <= g_rptr;
	g_rsync2 <= g_rsync1;

	
end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs, modified to be synthesizable

module bram_1r1w_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
  input wire MEMCLK,
  input wire RESET_N,
  input wire CEA,
  input wire [ADDR_WIDTH-1:0] AA,
  input wire [ADDR_WIDTH-1:0] AB,

  input wire RDWENA,
  input wire CEB,
  input wire RDWENB,
  input wire [DATA_WIDTH-1:0] BWA,
  input wire [DATA_WIDTH-1:0] DINA,
  output reg [DATA_WIDTH-1:0] DOUTA,
  input wire [DATA_WIDTH-1:0] BWB,
  input wire [DATA_WIDTH-1:0] DINB,
  output wire [DATA_WIDTH-1:0] DOUTB
  // input wire [`BIST_OP_WIDTH-1:0] BIST_COMMAND,
  // input wire [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DIN,
  // output reg [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DOUT,
  // input wire [`BIST_ID_WIDTH-1:0] SRAMID
);

wire                            write_enable_in;
wire                            read_enable_in;

// Temporary storage for write data
reg                             write_enable_in_reg;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg   [BITMASK_WIDTH-1:0 ]      WRITE_BIT_MASK_REG;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
// reg   [DATA_WIDTH-1:0    ]      DOUTB_r;

reg                             read_enable_in_reg;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_write_en;
reg                            bram_write_en_muxed;
wire                            bram_read_en;
wire                            bram_write_read_en;
reg  [DATA_WIDTH-1:0    ]      bram_data_write_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_in;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;
wire  [DATA_WIDTH-1:0    ]      last_wrote_data;
wire                            rw_conflict;
reg                             rw_conflict_r;
wire                            ww_conflict;
reg                             ww_conflict_r;

/* renaming signals */
assign read_enable_in    = CEA & (RDWENA == 1'b1);
assign write_enable_in   = CEB & (RDWENB == 1'b0);
wire [ADDR_WIDTH-1:0    ] READ_ADDRESS = AA;
wire [ADDR_WIDTH-1:0    ] WRITE_ADDRESS = AB;
wire [BITMASK_WIDTH-1:0    ] WRITE_BIT_MASK = BWB;

// Intermediate logic for write processing
always @(posedge MEMCLK) begin
  write_enable_in_reg <= write_enable_in;
  WRITE_ADDRESS_REG   <= WRITE_ADDRESS;
  WRITE_BIT_MASK_REG  <= WRITE_BIT_MASK;
  DIN_r <= DINB;
  read_enable_in_reg  <= read_enable_in;
  bram_data_in_r <= bram_data_in;
  rw_conflict_r  <= rw_conflict;
  ww_conflict_r  <= ww_conflict;
  // DOUTB_r  <= DOUTB;
end

// determining read-write and write-write conflict for data bypassing
assign rw_conflict      = write_enable_in_reg & read_enable_in & (WRITE_ADDRESS_REG == READ_ADDRESS);
assign ww_conflict      = write_enable_in_reg & write_enable_in & (WRITE_ADDRESS_REG == WRITE_ADDRESS);
assign DOUTB = {DATA_WIDTH{1'bx}}; // port B is always used for write

// calculate the correct read and write data after accoutning for conflicts
always @ * begin
  bram_data_in = (DIN_r & WRITE_BIT_MASK_REG);
  if (ww_conflict_r)
    bram_data_in = bram_data_in | (bram_data_in_r & ~WRITE_BIT_MASK_REG);
  else
    bram_data_in = bram_data_in | (bram_data_write_read_out_reg & ~WRITE_BIT_MASK_REG);
  

  // note: DOUT retains value if read enable is not asserted
  // which is why default value is not set for DOUT
  if (read_enable_in_reg) begin
    DOUTA = bram_data_read_out_reg; 
    if (rw_conflict_r) begin
      DOUTA = bram_data_in_r;
    end
  end
end

// synthesizable BRAM
assign bram_write_en      = write_enable_in_reg;
assign bram_read_en         = (read_enable_in) & ~rw_conflict;             // do not read in case of a conflict
assign bram_write_read_en         = (write_enable_in) & ~ww_conflict;             // do not read in case of a conflict

reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_write_read_out_reg;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
    ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_read_en) begin
    bram_data_read_out_reg <= ram[READ_ADDRESS];
  end
  if (bram_write_read_en) begin
    bram_data_write_read_out_reg <= ram[WRITE_ADDRESS];
  end
end
// END BRAM


/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = WRITE_ADDRESS_REG;
      bram_write_en_muxed = bram_write_en;
      bram_data_in_muxed = bram_data_in;
   end
end


endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs

module bram_1rw_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
    input                         MEMCLK,
    input wire RESET_N,
    input                         CE,
    input   [ADDR_WIDTH-1:0]      A,
    input                         RDWEN,
    input   [BITMASK_WIDTH-1:0]   BW,
    input   [DATA_WIDTH-1:0]      DIN,
    output  [DATA_WIDTH-1:0]      DOUT
);

wire                            write_en;
wire                            read_en;

// Temporary storage for write data
reg                             wen_r;
reg   [ADDR_WIDTH-1:0    ]      A_r;
reg   [BITMASK_WIDTH-1:0 ]      BW_r;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
reg   [DATA_WIDTH-1:0    ]      DOUT_r;

reg                             ren_r;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_wen;
wire                            bram_ren;
reg  [DATA_WIDTH-1:0    ]      bram_data_out;
wire  [DATA_WIDTH-1:0    ]      bram_data_in;
wire  [DATA_WIDTH-1:0    ]      up_to_date_data;
wire                            rw_conflict;
reg                             rw_conflict_r;



reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg                            bram_write_en_muxed;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;

assign write_en   = CE & (RDWEN == 1'b0);
assign read_en    = CE & (RDWEN == 1'b1);


// Intermediate logic for write processing
always @(posedge MEMCLK) begin
   wen_r <= write_en;
   A_r   <= A;
   BW_r  <= BW;
   DIN_r <= DIN;
end

always @(posedge MEMCLK) begin
  ren_r  <= read_en;
end

always @(posedge MEMCLK)
   bram_data_in_r <= bram_data_in;

always @(posedge MEMCLK)
   rw_conflict_r  <= rw_conflict;

always @(posedge MEMCLK)
  DOUT_r  <= DOUT;

assign bram_data_in = (up_to_date_data & ~BW_r) | (DIN_r & BW_r);

// processing of read in case if it just in the next cycle after read to the same address
assign rw_conflict      = wen_r & CE & (A_r == A);                         // read or write to the same address
assign up_to_date_data  = rw_conflict_r ? bram_data_in_r : bram_data_out;  // delay of mem is 1 cycle
assign bram_ren         = (read_en | write_en) & ~rw_conflict;             // do not read in case of a conflict
                                                                        // to make behaviour of a memory robust
assign bram_wen      = wen_r;

assign DOUT          = ren_r ? up_to_date_data : DOUT_r;

// BRAM
reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_out;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
      ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_ren) begin
    bram_data_out <= ram[A];
  end
end
// END BRAM

 // undefined by default

/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = A_r;
      bram_write_en_muxed = bram_wen;
      bram_data_in_muxed = bram_data_in;
   end
end













endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : synchronizer.v
//  Created On    : 2014-01-31 12:52:57
//  Last Modified : 2018-11-29 17:02:47
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   :
//==================================================================================================





module synchronizer (
    clk,
    presyncdata,
    syncdata
    );

// synopsys template
parameter SIZE = 1;

input wire clk;
input wire [SIZE-1:0] presyncdata;
output reg [SIZE-1:0] syncdata;













  reg [SIZE-1:0] presyncdata_tmp;



    // bw_u1_syncff_4x u_synchronizer_syncff [SIZE-1:0](.q(presyncdata_tmp),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

    // bw_u1_soff_2x u_synchronizer_ff[SIZE-1:0] (.q(syncdata),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata_tmp),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

always @ (posedge clk)
begin
    presyncdata_tmp <= presyncdata;
    syncdata        <= presyncdata_tmp;
end

endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : clk_gating_latch.v
//  Created On    : 2015-01-26 14:10:43
//  Last Modified : 2019-04-17 11:56:55
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   : Latch for glitchless clock gating
//==================================================================================================

module clk_gating_latch (
    input wire clk,
    input wire clk_en,
    output wire clk_out
);

// use clock buffer on FPGA
// note that not all FPGAs have enough of these available
// so we use the latch as a fallback on certain boards (e.g., vc707)




 // PITON_FPGA_SYNTH

  wire clk_en_sync;
  reg clk_en_sync_latch;

  assign clk_out = clk & clk_en_sync_latch;

  synchronizer sync(
      .clk            (clk),
      .presyncdata    (clk_en),
      .syncdata       (clk_en_sync)
  );

  // if possible, replace this with a native clock gate from the std cell lib
  // clk_en_sync_latch changes only on the negative duty of the cycle
  always @ (clk or clk_en_sync)
      if (~clk) clk_en_sync_latch = clk_en_sync;



endmodule // clk_gating_latch
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/****************************************************************************
 *
 *   FILE: credit_to_valrdy.v
 *
 *   Modified: Yaosheng Fu
 *   Date: May 2 2014

 ***************************************************************************/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

module credit_to_valrdy (
   clk,
   reset,
   //credit based interface	
   data_in,
   valid_in,
   yummy_in,
            
   //val/rdy interface
   data_out,
   valid_out,
   ready_out
);

   input	 clk;
   input	 reset;
   input [64-1:0]	 data_in;
   input	 valid_in;
   input     ready_out;
    
   output	 yummy_in;
   output	 valid_out;
   output [64-1:0] data_out;
   
   wire	 thanksIn;

   wire valid_out_temp;

   assign valid_out = valid_out_temp;

   network_input_blk_multi_out #(.LOG2_NUMBER_FIFO_ELEMENTS(2)) data(
      .clk(clk),
      .reset(reset),
      .data_in(data_in),
      .valid_in(valid_in),

      .thanks_in(valid_out & ready_out),

      .yummy_out(yummy_in),
      .data_val(data_out),
      .data_val1(/*not used*/),
      .data_avail(valid_out_temp));

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: m1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
// 64 bit nor gate with first 32 bits out

module zznor64_32 ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32



////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate

module zzor36 ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
	     | a[32] | a[33] | a[34] | a[35]); 
   
endmodule // zzor36



////////////////////////////////////////////////////////////////////////////////
// 32 bit or gate

module zzor32 ( z, a );
  input  [31:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

endmodule // zzor32



////////////////////////////////////////////////////////////////////////////////
// 24 bit nor gate

module zznor24 ( z, a );
  input  [23:0] a;
  output        z;

  assign z =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	      | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]); 

endmodule // zznor24



////////////////////////////////////////////////////////////////////////////////
// 16 bit nor gate

module zznor16 ( z, a );
  input  [15:0] a;
  output        z;

  assign z =  ~(a[0] | a[1] | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]); 

endmodule // zznor16



////////////////////////////////////////////////////////////////////////////////
// 8 bit or gate

module zzor8 ( z, a );
  input  [7:0] a;
  output       z;

  assign z =  (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7]); 
   
endmodule // zzor8




////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd13 ( rs1_data, rs2_data, cin, adder_out );

  input  [12:0] rs1_data;   // 1st input operand
  input  [12:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [12:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd13



////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd56 ( rs1_data, rs2_data, cin, adder_out );

  input  [55:0] rs1_data;   // 1st input operand
  input  [55:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [55:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd56



////////////////////////////////////////////////////////////////////////////////

module zzadd48 ( rs1_data, rs2_data, cin, adder_out );

  input  [47:0] rs1_data;   // 1st input operand
  input  [47:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [47:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd48



////////////////////////////////////////////////////////////////////////////////
//  This adder is primarily used in the multiplier.
//  The cin to out path is optimized.

module zzadd34c ( rs1_data, rs2_data, cin, adder_out );

  input  [33:0] rs1_data;
  input  [33:0] rs2_data;
  input         cin;

  output [33:0] adder_out;

  assign adder_out = rs1_data + rs2_data + cin;


endmodule // zzadd34c



////////////////////////////////////////////////////////////////////////////////

module zzadd32 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [31:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd32



////////////////////////////////////////////////////////////////////////////////

module zzadd18 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [17:0] rs1_data;   // 1st input operand
  input  [17:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [17:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd18



////////////////////////////////////////////////////////////////////////////////

module zzadd8 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [7:0] rs1_data;   // 1st input operand
  input  [7:0] rs2_data;   // 2nd input operand
  input        cin;        // carry in

  output [7:0] adder_out;  // result of add & decrement
  output       cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd8



////////////////////////////////////////////////////////////////////////////////
// Special 4-operand 32b adder used in spu_shamd5
//  Description:        This block implements the 4-operand 32-bit adder for SPU
//			It takes four 32-bit operands. It add them together and
//			output the 32-bit results to adder_out. The overflow of
//			32th bit and higher will be ignored.

module zzadd32op4 ( rs1_data, rs2_data, rs3_data, rs4_data, adder_out );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input  [31:0] rs3_data;   // 3rd input operand
  input  [31:0] rs4_data;   // 4th input operand

  output [31:0] adder_out;  // result of add

  assign adder_out = rs1_data + rs2_data + rs3_data + rs4_data;

endmodule // zzadd32op4


////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc alu.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out.  It outputs the overflow
//			and carry condition codes for both 64 bit and 32 bit operations.

module zzadd64 ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64



///////////////////////////////////////////////////////////////////////
/*
//      Description: This is the ffu VIS adder.  It can do either
//                              2 16 bit adds or 1 32 bit add.
*/

module zzadd32v (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
   a, b, cin, add32
   ) ;
   input [31:0] a;
   input [31:0] b;
   input        cin;
   input        add32;

   output [31:0] z;

   wire          cout15; // carry out from lower 16 bit add
   wire          cin16; // carry in to the upper 16 bit add
   wire          cout31; // carry out from the upper 16 bit add

   assign        cin16 = (add32)? cout15: cin;

   assign      {cout15, z[15:0]} = a[15:0]+b[15:0]+ cin;
   assign      {cout31, z[31:16]} = a[31:16]+b[31:16]+ cin16;

endmodule // zzadd32v




////////////////////////////////////////////////////////////////////////////////
// 64-bit incrementer

module zzinc64 ( in, out );

  input  [63:0] in;

  output [63:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc64


////////////////////////////////////////////////////////////////////////////////
// 48-bit incrementer

module zzinc48 ( in, out, overflow );

  input  [47:0] in;

  output [47:0] out;      // result of increment
  output        overflow; // overflow

  assign out      = in + 1'b1;
  assign overflow = ~in[47] & out[47];

endmodule // zzinc48


////////////////////////////////////////////////////////////////////////////////
// 32-bit incrementer

module zzinc32 ( in, out );

  input  [31:0] in;

  output [31:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc32


////////////////////////////////////////////////////////////////////////////////

module zzecc_exu_chkecc2 ( q,ce, ue, ne, d, p, vld );
   input [63:0] d;
   input [7:0]  p;
   input        vld;
   output [6:0] q;
   output       ce,
                ue,
                ne;

   wire       parity;

   assign     ce = vld & parity;

   assign ue = vld & ~parity & (q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);

   assign ne = ~vld | ~(parity | q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);


   assign q[0] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10]
               ^ d[11] ^ d[13] ^ d[15] ^ d[17] ^ d[19] ^ d[21] ^ d[23]
               ^ d[25] ^ d[26] ^ d[28] ^ d[30] ^ d[32] ^ d[34] ^ d[36]
               ^ d[38] ^ d[40] ^ d[42] ^ d[44] ^ d[46] ^ d[48] ^ d[50]
               ^ d[52] ^ d[54] ^ d[56] ^ d[57] ^ d[59] ^ d[61] ^ d[63]
               ^ p[0]  ;

   assign q[1] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[10]
               ^ d[12] ^ d[13] ^ d[16] ^ d[17] ^ d[20] ^ d[21] ^ d[24]
               ^ d[25] ^ d[27] ^ d[28] ^ d[31] ^ d[32] ^ d[35] ^ d[36]
               ^ d[39] ^ d[40] ^ d[43] ^ d[44] ^ d[47] ^ d[48] ^ d[51]
               ^ d[52] ^ d[55] ^ d[56] ^ d[58] ^ d[59] ^ d[62] ^ d[63]
               ^ p[1]  ;

   assign q[2] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[29] ^ d[30] ^ d[31] ^ d[32] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[45] ^ d[46] ^ d[47] ^ d[48] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
               ^ p[2]  ;

   assign q[3] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[3]  ;

   assign q[4] = d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[4]  ;

   assign q[5] = d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31] ^ d[32]
               ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
               ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[5]  ;

   assign q[6] = d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63] ^ p[6] ;

   assign parity = d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
                 ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
                 ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
                 ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
                 ^ d[32] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
                 ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46] ^ d[47]
                 ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53] ^ d[54] ^ d[55]
                 ^ d[56] ^ d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
                 ^ p[0]  ^ p[1]  ^ p[2]  ^ p[3]  ^ p[4]  ^ p[5]  ^ p[6]  ^ p[7];

endmodule // zzecc_exu_chkecc2



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_24b_gen ( din, dout, parity ) ;

// Input Ports
input  [23:0] din ;

// Output Ports
output [23:0] dout ;
output [5:0]  parity ;

wire   [23:0] dout ;
wire   [5:0]  parity ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire          p30 ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |  |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |  |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |  |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |  |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |  |  |* |  |* |* |  |  |* |* |  |* |  |  | * |   | * | * |   | * |   |   | * | * |   |   | * |   | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p30 = din[0]  ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5]  ^
             din[7]  ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^
             din[17] ^ din[18] ^ din[21] ^ din[23] ;

assign dout   = din ;
assign parity = {p30, p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_30b_cor ( din, parity, dout, corrected_bit ) ;

// Input Ports
input  [23:0] din ;
input  [4:0]  parity ;

// Output Ports
output [23:0] dout ;
output [4:0]  corrected_bit ;

wire   [23:0] dout ;
wire   [4:0]  corrected_bit ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire [23:0]   error_bit ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |* |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |* |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |* |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |* |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   | * | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |* |* |* |* |* |* |* |* |* |* |* |* |* |* | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = parity[0] ^
             din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = parity[1] ^
             din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = parity[2] ^
             din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = parity[3] ^
             din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = parity[4] ^
             din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign  error_bit[0]  = !p16 & !p8 & !p4 &  p2 &  p1 ; // 3
assign  error_bit[1]  = !p16 & !p8 &  p4 & !p2 &  p1 ; // 5
assign  error_bit[2]  = !p16 & !p8 &  p4 &  p2 & !p1 ; // 6
assign  error_bit[3]  = !p16 & !p8 &  p4 &  p2 &  p1 ; // 7
assign  error_bit[4]  = !p16 &  p8 & !p4 & !p2 &  p1 ; // 9
assign  error_bit[5]  = !p16 &  p8 & !p4 &  p2 & !p1 ; // 10
assign  error_bit[6]  = !p16 &  p8 & !p4 &  p2 &  p1 ; // 11
assign  error_bit[7]  = !p16 &  p8 &  p4 & !p2 & !p1 ; // 12
assign  error_bit[8]  = !p16 &  p8 &  p4 & !p2 &  p1 ; // 13
assign  error_bit[9]  = !p16 &  p8 &  p4 &  p2 & !p1 ; // 14
assign  error_bit[10] = !p16 &  p8 &  p4 &  p2 &  p1 ; // 15
assign  error_bit[11] =  p16 & !p8 & !p4 & !p2 &  p1 ; // 17
assign  error_bit[12] =  p16 & !p8 & !p4 &  p2 & !p1 ; // 18
assign  error_bit[13] =  p16 & !p8 & !p4 &  p2 &  p1 ; // 19
assign  error_bit[14] =  p16 & !p8 &  p4 & !p2 & !p1 ; // 20
assign  error_bit[15] =  p16 & !p8 &  p4 & !p2 &  p1 ; // 21
assign  error_bit[16] =  p16 & !p8 &  p4 &  p2 & !p1 ; // 22
assign  error_bit[17] =  p16 & !p8 &  p4 &  p2 &  p1 ; // 23
assign  error_bit[18] =  p16 &  p8 & !p4 & !p2 & !p1 ; // 24
assign  error_bit[19] =  p16 &  p8 & !p4 & !p2 &  p1 ; // 25
assign  error_bit[20] =  p16 &  p8 & !p4 &  p2 & !p1 ; // 26
assign  error_bit[21] =  p16 &  p8 & !p4 &  p2 &  p1 ; // 27
assign  error_bit[22] =  p16 &  p8 &  p4 & !p2 & !p1 ; // 28
assign  error_bit[23] =  p16 &  p8 &  p4 & !p2 &  p1 ; // 29

assign  dout          = din ^ error_bit ;
assign  corrected_bit = {p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_ecc39
//Function: Error Detection and Correction
//
//

module zzecc_sctag_ecc39 ( dout, cflag, pflag, parity, din);

   //Output: 32bit corrected data
   output[31:0] dout;
   output [5:0] cflag;
   output 	pflag;
   
   //Input: 32bit data din
   input [31:0] din;
   input [6:0]	parity;

   wire 	c0,c1,c2,c3,c4,c5;
   wire [31:0] 	err_bit_pos;

   //refer to the comments in parity_gen_32b.v for the position description
   
   assign c0= parity[0]^(din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   
   assign c1= parity[1]^(din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   
   assign c2= parity[2]^(din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   
   assign c3= parity[3]^(din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   
   assign c4= parity[4]^(din[11]^din[12])^(din[13]^din[14])^
                    (din[15]^din[16])^(din[17]^din[18])^(din[19]^din[20])^
                    (din[21]^din[22])^(din[23]^din[24])^din[25];

   assign c5= parity[5]^(din[26]^din[27])^(din[28]^din[29])^
		    (din[30]^din[31]);

   //generate total parity flag
   assign pflag= c0 ^
		(( (((parity[1]^parity[2])^(parity[3]^parity[4])) ^
		 ((parity[5]^parity[6])^(din[2]^din[5]))) ^		 
		 (((din[7]^din[9])^(din[12]^din[14])) ^
		 ((din[16]^din[18])^(din[20]^din[22]))) ) ^
		 ((din[24]^din[27])^(din[29]^din[31])) );
   
   assign cflag= {c5,c4,c3,c2,c1,c0};
   
   //6 to 32 decoder
   assign err_bit_pos[0] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[1] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[2] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[3] = (c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[4] = (c0)&(~c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[5] = (~c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[6] = (c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[7] = (~c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[8] = (c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[9] = (~c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[10] = (c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[11] = (c0)&(~c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[12] = (~c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[13] = (c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[14] = (~c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[15] = (c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[16] = (~c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[17] = (c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[18] = (~c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[19] = (c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[20] = (~c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[21] = (c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[22] = (~c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[23] = (c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[24] = (~c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[25] = (c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[26] = (c0)&(~c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[27] = (~c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[28] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[29] = (~c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[30] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[31] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(c5);

   //correct the error bit, it can only correct one error bit.
   
   assign dout = din ^ err_bit_pos;

endmodule // zzecc_sctag_ecc39


////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_pgen_32b
//Function: Generate 7 parity bits for 32bits input data
//

module zzecc_sctag_pgen_32b ( dout, parity, din);

   //Output: 32bit dout and 7bit parity bit
   output[31:0] dout;
   output [6:0] parity;

   //Input: 32bit data din
   input [31:0] din;

   //input data passing through this module
   assign dout = din ;

   //generate parity bits based on the hamming codes
   //the method to generate parity bit is shown as follows
   //1   2  3  4  5  6  7  8  9 10 11 12 13 14  15  16  17  18  19
   //P1 P2 d0 P4 d1 d2 d3 P8 d4 d5 d6 d7 d8 d9 d10 P16 d11 d12 d13 
   //
   // 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 
   //d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 P32 d26 d27 d28
   //
   // 36  37  38       
   //d29 d30 d31
   //For binary numbers B1-B2-B3-B4-B5-B6:
   //B1=1 for (1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,...)
   //B2=1 for (2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39...)
   //B3=1 for (4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,39....)
   //B4=1 for (8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,....)
   //B5=1 for (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,...)
   //B6=1 for (32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49...)
   //Parity bit P1,P2,P4,P8,P16,P32 can be generated from the above group of
   //bits B1=1,B2=1,B3=1,B4=1,B5=1,B6=1 respectively.

   //use parity[5:0] to stand for P1,P2,P4,P8,P16,P32
   assign parity[0] = (din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   //
   assign parity[1] = (din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   //
   assign parity[2] = (din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   //
   assign parity[3] = (din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[4] = (din[11]^din[12])^(din[13]^din[14])^(din[15]^din[16])
                     ^(din[17]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[5] = (din[26]^din[27])^(din[28]^din[29])^(din[30]^din[31]);

   //the last parity bit is the xor of all 38bits
   //assign parity[6] = (^din)^(^parity[5:0]);
   //it can be further simplified as:
   //din= d0  d1  d2  d3  d4  d5  d6  d7  d8  d9 d10 d11 d12 d13 d14 d15 
   //p0 =  x   x       x   x       x       x       x   x       x       x
   //p1 =  x       x   x       x   x           x   x       x   x
   //p2 =      x   x   x               x   x   x   x               x   x
   //p3 =                  x   x   x   x   x   x   x  
   //p4 =                                              x   x   x   x   x
   //p5 =
   //-------------------------------------------------------------------
   //Total 3   3   3   4   3   3   4   3   4   4   5   3   3   4   3   4 
   //
   //din=d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 
   //p0=       x       x       x       x       x   x       x       x    
   //p1=   x   x           x   x           x   x       x   x           x
   //p2=   x   x                   x   x   x   x               x   x   x
   //p3=           x   x   x   x   x   x   x   x
   //p4=   x   x   x   x   x   x   x   x   x   x
   //p5=                                           x   x   x   x   x   x
   //-------------------------------------------------------------------
   //total 4   5   3   4   4   5   4   5   5   6   3   3   4   3   4   4

   //so total=even number, the corresponding bit will not show up in the
   //final xor tree.
   assign parity[6] =  din[0] ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5] ^ din[7]
		    ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^ din[17]
		    ^ din[18] ^ din[21] ^ din[23] ^ din[24] ^ din[26]
		    ^ din[27] ^ din[29];
   
endmodule // zzecc_sctag_pgen_32b

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree

module zzpar34 ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
	      ^ d[32] ^ d[33]; 

endmodule // zzpar34



////////////////////////////////////////////////////////////////////////////////
// 32 bit parity tree

module zzpar32 ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]; 

endmodule // zzpar32



////////////////////////////////////////////////////////////////////////////////
// 28 bit parity tree

module zzpar28 ( z, d );
   input  [27:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27]; 

endmodule // zzpar28



////////////////////////////////////////////////////////////////////////////////
// 16 bit parity tree

module zzpar16 ( z, d );
   input  [15:0] d;
   output        z;

   assign z = d[0] ^ d[1] ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	    ^ d[8] ^ d[9] ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]; 
   
endmodule // zzpar16



////////////////////////////////////////////////////////////////////////////////
// 8 bit parity tree

module zzpar8 ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8



////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority

module zzpenc64 (/*AUTOARG*/
   // Outputs
   z, 
   // Inputs
  a 
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64

////////////////////////////////////////////////////////////////////////////////
//    4-bit 60x buffers

module zzbufh_60x4 (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [3:0] a;
   output [3:0] z;

   assign z = a;

endmodule //zzbufh_60x4

// LVT modules added below

module zzadd64_lv ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64_lv

module zzpar8_lv ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8_lv


module zzpar32_lv ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31];

endmodule // zzpar32_lv



module zznor64_32_lv ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32_lv

////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority
//    LVT version

module zzpenc64_lv (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64_lv

////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate
// LVT version

module zzor36_lv ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
             | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
             | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
             | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
             | a[32] | a[33] | a[34] | a[35]);

endmodule // zzor36_lv

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree
// LVT version

module zzpar34_lv ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
              ^ d[32] ^ d[33];

endmodule // zzpar34_lv


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: mul64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/*//////////////////////////////////////////////////////////////////////
//
//  Module Name: mul64
//  Description:        *This block implements the multiplier used in the modular multiplier
//                       unit (MUL) and be shared by sparc EXU and the streaming unit (SPU).
//                       It is also used as the 54x54 multiplier in the FPU.
//                      *It takes two 64-bit unsign data and accumulated operand and do the
//                       64x64 MAC operation at two cycle thruput and 5 cycle latency.
//                      *The mul_valid signal indicate the beginning of a new operation.
//                       It MUST be dis-asserted at the next cycle to have the proper 2-cycle
//                       latency operation in the csa array. If there are two back-to-back
//                       cycle operation, the first operation result will be incorrect.
//                      *Results are avaliable on the 5th cycle of the mul_valid as shows
//
//			*Following inputs should tie to "0" when used as a 64x64 multiplier
//			 - areg 
//			 - accreg 
//			 - x2
//
//                         Cycle-0  | Cycle-1 | Cycle-2 | Cycle-3 | Cycle-4 | Cycle-5
//                       1st        *         |         |         |         |
//                       rs1, rs2   ^         |         |         |         | 1st results
//                       valid=1    | valid=0 |         *         |         | avaliable
//                                1st         | 2nd OP  ^         |         |
//                                setup       | valid=1 |         |         |
//                                            |        2nd        |         |
//                                            |       setup       |         |
//
*/

//PITON_PROTO enables all FPGA related modifications



























































module mul64 (rs1_l, rs2, valid, areg, accreg, x2, out, rclk, si, so, se, mul_rst_l, mul_step);

input  [63:0]  	rs1_l;			// op1
input  [63:0]  	rs2;			// op2
input	       	valid;			// begin of the MUL operation
input  [96:0]  	areg;			// accumulated input for ACCUM
input  [135:129] accreg;		// direct input from ACCUM [135:129]
input	       	x2;			// for op1*op2*2
input	       	rclk, si, se, mul_rst_l, mul_step;
output  	so;
output [135:0] 	out;

wire	       	cyc1, cyc2, cyc3;	// cycle stage of MUL
wire [2:0]	b0, b1, b2,  b3,  b4,  b5,  b6,  b7;
wire [2:0]	b8, b9, b10, b11, b12, b13, b14, b15;
wire	    	b16;
wire [63:0]	op1_l, op1;
wire [81:0]	a0sum, a1sum, a0s, a1s; 
wire [81:4]	a0cout, a1cout, a0c, a1c;
wire		pcoutx2, psumx2;
wire 		x2_c1, x2_c2, x2_c3, x2_c2c3;

wire [98:0]	psum, pcout;
wire [98:30]	pcout_in, pc;
wire [98:31]	psum_in, ps;
wire [96:0]	ary2_cout, addin_cout;
wire [97:0]	ary2_sum,  addin_sum ;
wire		add_cin, addin_cin, add_co31, add_co96;
wire [103:0]	addout;
wire		clk_enb0, clk_enb1;
wire 		rst;
wire		clk;
wire		tm_l;

  assign clk = rclk;
  assign rst = ~mul_rst_l; 
  assign tm_l = ~se;

  clken_buf	ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));

  /////////////////////////////////////////////////////////////////////
  // 	States count
  /////////////////////////////////////////////////////////////////////
  dffr_s  cyc1_dff(.din(valid), .clk(clk_enb0), .q(cyc1), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc2_dff(.din(cyc1),  .clk(clk_enb0), .q(cyc2), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc3_dff(.din(cyc2),  .clk(clk_enb0), .q(cyc3), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c1_dff(.din(x2),    .clk(clk_enb0), .q(x2_c1), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c2_dff(.din(x2_c1), .clk(clk_enb0), .q(x2_c2), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c3_dff(.din(x2_c2), .clk(clk_enb0), .q(x2_c3), .rst(rst), .se(se), .si(), .so());

  assign x2_c2c3 =  x2_c2 | x2_c3 ;
	
  /////////////////////////////////////////////////////////////////////
  // 	Enable flops for op1
  /////////////////////////////////////////////////////////////////////
  clken_buf	ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(valid & mul_step)), .tmb_l(tm_l));
  dff_s #(64)  	ffrs1  (.din(rs1_l[63:0]), .clk(clk_enb1), .q(op1_l[63:0]),
			.se(se), .si(), .so());




  assign op1[63:0] = ~op1_l[63:0];

  mul_booth	 booth (.head (valid),
			.b_in (rs2),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (b8),
			.b9   (b9),
			.b10  (b10),
			.b11  (b11),
			.b12  (b12),
			.b13  (b13),
			.b14  (b14),
			.b15  (b15),
			.b16  (b16),
			.clk  (clk), .se(se), .si(), .so(), .mul_step(mul_step), .tm_l(tm_l));
			
  /////////////////////////////////////////////////////////////////////
  // 	Two Array1 inst ary1_a0 & ary1_a1 with the ouput flops 
  /////////////////////////////////////////////////////////////////////
  mul_array1	ary1_a0(.cout (a0cout[81:4]),
			.sum  (a0sum[81:0]),
			.a    (op1),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (3'b000),
			.head (cyc1),
			.bot  (1'b0)); //array a is never at the bottom of 33-pp rows
 
  dff_s #(78)  a0cot_dff (.din(a0cout[81:4]), .clk(clk_enb0), .q(a0c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a0sum_dff (.din(a0sum[81:0]), .clk(clk_enb0), .q(a0s[81:0]),
			.se(se), .si(), .so());

  mul_array1	ary1_a1(.cout (a1cout[81:4]),
			.sum  (a1sum[81:0]),
			.a    (op1),
			.b0   (b8),
			.b1   (b9),
			.b2   (b10),
			.b3   (b11),
			.b4   (b12),
			.b5   (b13),
			.b6   (b14),
			.b7   (b15),
			.b8   ({1'b0,b16,1'b0}),
			.head (1'b0),	//array b is never at the head of 33-pp rows
			.bot  (cyc2)); 

  dff_s #(78)  a1cot_dff (.din(a1cout[81:4]), .clk(clk_enb0), .q(a1c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a1sum_dff (.din(a1sum[81:0]), .clk(clk_enb0), .q(a1s[81:0]),
			.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Array2 with the reorder output mux-flops
  /////////////////////////////////////////////////////////////////////
  mul_array2 	 array2(.pcoutx2 (pcoutx2),
			.psumx2  (psumx2),
			.pcout 	 (pcout[98:0]),
			.psum    (psum[98:0]), 
			.a0c     (a0c[81:4]),
			.a0s     (a0s[81:0]),
			.a1c     (a1c[81:4]),
			.a1s     (a1s[81:0]),
			.pc	 (pc[98:30]),
			.ps	 (ps[98:31]),
			.areg    (areg[96:0]),
			.bot     (cyc3),
			.x2      (x2_c2c3));
 
  //// Outpput re-order muxes and flops	////
  dp_mux2es #(97)  ary2_cmux (.dout(ary2_cout[96:0]),
                              .in0(pcout[96:0]),
                              .in1({pcout[95:0],pcoutx2}),
                              .sel(x2_c2c3));
  dff_s #(97)  a2cot_dff (.din(ary2_cout[96:0]), .clk(clk_enb0), .q(addin_cout[96:0]), 
              		.se(se), .si(), .so());

  dp_mux2es #(98) ary2_smux (.dout(ary2_sum[97:0]),
                             .in0(psum[97:0]),
                             .in1({psum[96:0],psumx2}),
                             .sel(x2_c2c3));
  dff_s #(98)  a2sum_dff (.din(ary2_sum[97:0]), .clk(clk_enb0), .q(addin_sum[97:0]), 
			.se(se), .si(), .so());

  //// Pseudo sum & cout logic and flops ////
  assign psum_in[98:32]  = psum[98:32] & {67{cyc2}} ;
  assign psum_in[31]     = psum[31] & x2_c2 ;

  assign pcout_in[98:31] = pcout[98:31] & {68{cyc2}} ;
  assign pcout_in[30]    = pcout[30] & x2_c2 ;
  
  dff_s #(68)  psum_dff  (.din(psum_in[98:31]), .clk(clk_enb0), .q(ps[98:31]),
                	.se(se), .si(), .so());
  dff_s #(69)  pcout_dff (.din(pcout_in[98:30]), .clk(clk_enb0), .q(pc[98:30]),
            		.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Adder (104-bit) 
  /////////////////////////////////////////////////////////////////////

  assign 	add_cin = add_co31 & cyc3 ;

  assign {add_co31,addout[31:0]} =   {{1'b0},addin_sum[31:0]} 
		     		   + {{1'b0},addin_cout[30:0],addin_cin} ;


  assign {add_co96,addout[96:32]} =  addin_sum[97:32]	
				  + addin_cout[96:31]
				  + {{65'b0},add_co31} ;

  assign 	addout[103:97] =  accreg[135:129] + {{6'b0},add_co96} ;

  /////////////////////////////////////////////////////////////////////
  // 	Pipe adder outputs  
  /////////////////////////////////////////////////////////////////////

  dff_s  	      co31_dff (.din(add_cin), .clk(clk_enb0), .q(addin_cin),
       			.se(se), .si(), .so());

  dff_s #(104)   out_dff (.din(addout[103:0]), .clk(clk_enb0), .q(out[135:32]),
              		.se(se), .si(), .so());

  dff_s #(32)    pip_dff (.din(out[63:32]), .clk(clk_enb0), .q(out[31:0]),
               		.se(se), .si(), .so());

endmodule // mul64




////////////////////////////////////////////////////////////////////////
//	Sub-moudle for mul64
////////////////////////////////////////////////////////////////////////

module mul_array1 ( cout, sum, a, b0, b1, b2, b3, b4, b5, b6, b7, b8,
     bot, head );

input  bot, head;
output [81:4]  cout;
output [81:0]  sum;
input [2:0]  b6;
input [2:0]  b3;
input [2:0]  b8;
input [2:0]  b2;
input [2:0]  b1;
input [2:0]  b7;
input [63:0]  a;
input [2:0]  b0;
input [2:0]  b4;
input [2:0]  b5;

// Buses in the design

wire  [1:0]  b5n;
wire  [1:0]  b2n;
wire  [68:1]  c0;
wire  [69:0]  s1;
wire  [68:1]  c1;
wire  [69:0]  s2;
wire  [68:1]  c2;
wire  [70:4]  s_1;
wire  [69:2]  s0;
wire  [76:10]  s_2;
wire  [70:2]  c_1;
wire  [76:10]  c_2;
wire  [75:11]  co;

mul_negen p1n ( .b(b5[2:0]), .n1(b5n[1]), .n0(b5n[0]));
mul_negen p0n ( .b(b2[2:0]), .n1(b2n[1]), .n0(b2n[0]));
mul_csa42  sc3_71_ ( .c(s_2[71]), .cin(co[70]), .a(c_1[70]),
     .b(c_2[70]), .cout(co[71]), .sum(sum[71]), .d(s1[65]),
     .carry(cout[71]));
mul_csa42  sc3_75_ ( .c(s_2[75]), .cin(co[74]), .a(1'b0),
     .b(c_2[74]), .cout(co[75]), .sum(sum[75]), .d(s1[69]),
     .carry(cout[75]));
mul_csa42  sc3_74_ ( .c(s_2[74]), .cin(co[73]), .a(1'b0),
     .b(c_2[73]), .cout(co[74]), .sum(sum[74]), .d(s1[68]),
     .carry(cout[74]));
mul_csa42  sc3_73_ ( .c(s_2[73]), .cin(co[72]), .a(1'b0),
     .b(c_2[72]), .cout(co[73]), .sum(sum[73]), .d(s1[67]),
     .carry(cout[73]));
mul_csa42  sc3_72_ ( .c(s_2[72]), .cin(co[71]), .a(1'b0),
     .b(c_2[71]), .cout(co[72]), .sum(sum[72]), .d(s1[66]),
     .carry(cout[72]));
mul_csa42  sc3_76_ ( .c(s_2[76]), .cin(co[75]), .a(1'b0),
     .b(c_2[75]), .cout(), .sum(sum[76]), .d(1'b0),
     .carry(cout[76]));
mul_csa42  sc3_70_ ( .c(s_2[70]), .cin(co[69]), .a(c_1[69]),
     .b(c_2[69]), .cout(co[70]), .sum(sum[70]), .d(s_1[70]),
     .carry(cout[70]));
mul_csa42  sc3_69_ ( .c(s_2[69]), .cin(co[68]), .a(c_1[68]),
     .b(c_2[68]), .cout(co[69]), .sum(sum[69]), .d(s_1[69]),
     .carry(cout[69]));
mul_csa42  sc3_68_ ( .c(s_2[68]), .cin(co[67]), .a(c_1[67]),
     .b(c_2[67]), .cout(co[68]), .sum(sum[68]), .d(s_1[68]),
     .carry(cout[68]));
mul_csa42  sc3_67_ ( .c(s_2[67]), .cin(co[66]), .a(c_1[66]),
     .b(c_2[66]), .cout(co[67]), .sum(sum[67]), .d(s_1[67]),
     .carry(cout[67]));
mul_csa42  sc3_66_ ( .c(s_2[66]), .cin(co[65]), .a(c_1[65]),
     .b(c_2[65]), .cout(co[66]), .sum(sum[66]), .d(s_1[66]),
     .carry(cout[66]));
mul_csa42  sc3_65_ ( .c(s_2[65]), .cin(co[64]), .a(c_1[64]),
     .b(c_2[64]), .cout(co[65]), .sum(sum[65]), .d(s_1[65]),
     .carry(cout[65]));
mul_csa42  sc3_64_ ( .c(s_2[64]), .cin(co[63]), .a(c_1[63]),
     .b(c_2[63]), .cout(co[64]), .sum(sum[64]), .d(s_1[64]),
     .carry(cout[64]));
mul_csa42  sc3_63_ ( .c(s_2[63]), .cin(co[62]), .a(c_1[62]),
     .b(c_2[62]), .cout(co[63]), .sum(sum[63]), .d(s_1[63]),
     .carry(cout[63]));
mul_csa42  sc3_62_ ( .c(s_2[62]), .cin(co[61]), .a(c_1[61]),
     .b(c_2[61]), .cout(co[62]), .sum(sum[62]), .d(s_1[62]),
     .carry(cout[62]));
mul_csa42  sc3_61_ ( .c(s_2[61]), .cin(co[60]), .a(c_1[60]),
     .b(c_2[60]), .cout(co[61]), .sum(sum[61]), .d(s_1[61]),
     .carry(cout[61]));
mul_csa42  sc3_60_ ( .c(s_2[60]), .cin(co[59]), .a(c_1[59]),
     .b(c_2[59]), .cout(co[60]), .sum(sum[60]), .d(s_1[60]),
     .carry(cout[60]));
mul_csa42  sc3_59_ ( .c(s_2[59]), .cin(co[58]), .a(c_1[58]),
     .b(c_2[58]), .cout(co[59]), .sum(sum[59]), .d(s_1[59]),
     .carry(cout[59]));
mul_csa42  sc3_58_ ( .c(s_2[58]), .cin(co[57]), .a(c_1[57]),
     .b(c_2[57]), .cout(co[58]), .sum(sum[58]), .d(s_1[58]),
     .carry(cout[58]));
mul_csa42  sc3_57_ ( .c(s_2[57]), .cin(co[56]), .a(c_1[56]),
     .b(c_2[56]), .cout(co[57]), .sum(sum[57]), .d(s_1[57]),
     .carry(cout[57]));
mul_csa42  sc3_56_ ( .c(s_2[56]), .cin(co[55]), .a(c_1[55]),
     .b(c_2[55]), .cout(co[56]), .sum(sum[56]), .d(s_1[56]),
     .carry(cout[56]));
mul_csa42  sc3_55_ ( .c(s_2[55]), .cin(co[54]), .a(c_1[54]),
     .b(c_2[54]), .cout(co[55]), .sum(sum[55]), .d(s_1[55]),
     .carry(cout[55]));
mul_csa42  sc3_54_ ( .c(s_2[54]), .cin(co[53]), .a(c_1[53]),
     .b(c_2[53]), .cout(co[54]), .sum(sum[54]), .d(s_1[54]),
     .carry(cout[54]));
mul_csa42  sc3_53_ ( .c(s_2[53]), .cin(co[52]), .a(c_1[52]),
     .b(c_2[52]), .cout(co[53]), .sum(sum[53]), .d(s_1[53]),
     .carry(cout[53]));
mul_csa42  sc3_52_ ( .c(s_2[52]), .cin(co[51]), .a(c_1[51]),
     .b(c_2[51]), .cout(co[52]), .sum(sum[52]), .d(s_1[52]),
     .carry(cout[52]));
mul_csa42  sc3_51_ ( .c(s_2[51]), .cin(co[50]), .a(c_1[50]),
     .b(c_2[50]), .cout(co[51]), .sum(sum[51]), .d(s_1[51]),
     .carry(cout[51]));
mul_csa42  sc3_50_ ( .c(s_2[50]), .cin(co[49]), .a(c_1[49]),
     .b(c_2[49]), .cout(co[50]), .sum(sum[50]), .d(s_1[50]),
     .carry(cout[50]));
mul_csa42  sc3_49_ ( .c(s_2[49]), .cin(co[48]), .a(c_1[48]),
     .b(c_2[48]), .cout(co[49]), .sum(sum[49]), .d(s_1[49]),
     .carry(cout[49]));
mul_csa42  sc3_48_ ( .c(s_2[48]), .cin(co[47]), .a(c_1[47]),
     .b(c_2[47]), .cout(co[48]), .sum(sum[48]), .d(s_1[48]),
     .carry(cout[48]));
mul_csa42  sc3_47_ ( .c(s_2[47]), .cin(co[46]), .a(c_1[46]),
     .b(c_2[46]), .cout(co[47]), .sum(sum[47]), .d(s_1[47]),
     .carry(cout[47]));
mul_csa42  sc3_46_ ( .c(s_2[46]), .cin(co[45]), .a(c_1[45]),
     .b(c_2[45]), .cout(co[46]), .sum(sum[46]), .d(s_1[46]),
     .carry(cout[46]));
mul_csa42  sc3_45_ ( .c(s_2[45]), .cin(co[44]), .a(c_1[44]),
     .b(c_2[44]), .cout(co[45]), .sum(sum[45]), .d(s_1[45]),
     .carry(cout[45]));
mul_csa42  sc3_44_ ( .c(s_2[44]), .cin(co[43]), .a(c_1[43]),
     .b(c_2[43]), .cout(co[44]), .sum(sum[44]), .d(s_1[44]),
     .carry(cout[44]));
mul_csa42  sc3_43_ ( .c(s_2[43]), .cin(co[42]), .a(c_1[42]),
     .b(c_2[42]), .cout(co[43]), .sum(sum[43]), .d(s_1[43]),
     .carry(cout[43]));
mul_csa42  sc3_42_ ( .c(s_2[42]), .cin(co[41]), .a(c_1[41]),
     .b(c_2[41]), .cout(co[42]), .sum(sum[42]), .d(s_1[42]),
     .carry(cout[42]));
mul_csa42  sc3_41_ ( .c(s_2[41]), .cin(co[40]), .a(c_1[40]),
     .b(c_2[40]), .cout(co[41]), .sum(sum[41]), .d(s_1[41]),
     .carry(cout[41]));
mul_csa42  sc3_40_ ( .c(s_2[40]), .cin(co[39]), .a(c_1[39]),
     .b(c_2[39]), .cout(co[40]), .sum(sum[40]), .d(s_1[40]),
     .carry(cout[40]));
mul_csa42  sc3_39_ ( .c(s_2[39]), .cin(co[38]), .a(c_1[38]),
     .b(c_2[38]), .cout(co[39]), .sum(sum[39]), .d(s_1[39]),
     .carry(cout[39]));
mul_csa42  sc3_38_ ( .c(s_2[38]), .cin(co[37]), .a(c_1[37]),
     .b(c_2[37]), .cout(co[38]), .sum(sum[38]), .d(s_1[38]),
     .carry(cout[38]));
mul_csa42  sc3_37_ ( .c(s_2[37]), .cin(co[36]), .a(c_1[36]),
     .b(c_2[36]), .cout(co[37]), .sum(sum[37]), .d(s_1[37]),
     .carry(cout[37]));
mul_csa42  sc3_36_ ( .c(s_2[36]), .cin(co[35]), .a(c_1[35]),
     .b(c_2[35]), .cout(co[36]), .sum(sum[36]), .d(s_1[36]),
     .carry(cout[36]));
mul_csa42  sc3_35_ ( .c(s_2[35]), .cin(co[34]), .a(c_1[34]),
     .b(c_2[34]), .cout(co[35]), .sum(sum[35]), .d(s_1[35]),
     .carry(cout[35]));
mul_csa42  sc3_34_ ( .c(s_2[34]), .cin(co[33]), .a(c_1[33]),
     .b(c_2[33]), .cout(co[34]), .sum(sum[34]), .d(s_1[34]),
     .carry(cout[34]));
mul_csa42  sc3_33_ ( .c(s_2[33]), .cin(co[32]), .a(c_1[32]),
     .b(c_2[32]), .cout(co[33]), .sum(sum[33]), .d(s_1[33]),
     .carry(cout[33]));
mul_csa42  sc3_32_ ( .c(s_2[32]), .cin(co[31]), .a(c_1[31]),
     .b(c_2[31]), .cout(co[32]), .sum(sum[32]), .d(s_1[32]),
     .carry(cout[32]));
mul_csa42  sc3_31_ ( .c(s_2[31]), .cin(co[30]), .a(c_1[30]),
     .b(c_2[30]), .cout(co[31]), .sum(sum[31]), .d(s_1[31]),
     .carry(cout[31]));
mul_csa42  sc3_30_ ( .c(s_2[30]), .cin(co[29]), .a(c_1[29]),
     .b(c_2[29]), .cout(co[30]), .sum(sum[30]), .d(s_1[30]),
     .carry(cout[30]));
mul_csa42  sc3_29_ ( .c(s_2[29]), .cin(co[28]), .a(c_1[28]),
     .b(c_2[28]), .cout(co[29]), .sum(sum[29]), .d(s_1[29]),
     .carry(cout[29]));
mul_csa42  sc3_28_ ( .c(s_2[28]), .cin(co[27]), .a(c_1[27]),
     .b(c_2[27]), .cout(co[28]), .sum(sum[28]), .d(s_1[28]),
     .carry(cout[28]));
mul_csa42  sc3_27_ ( .c(s_2[27]), .cin(co[26]), .a(c_1[26]),
     .b(c_2[26]), .cout(co[27]), .sum(sum[27]), .d(s_1[27]),
     .carry(cout[27]));
mul_csa42  sc3_26_ ( .c(s_2[26]), .cin(co[25]), .a(c_1[25]),
     .b(c_2[25]), .cout(co[26]), .sum(sum[26]), .d(s_1[26]),
     .carry(cout[26]));
mul_csa42  sc3_25_ ( .c(s_2[25]), .cin(co[24]), .a(c_1[24]),
     .b(c_2[24]), .cout(co[25]), .sum(sum[25]), .d(s_1[25]),
     .carry(cout[25]));
mul_csa42  sc3_24_ ( .c(s_2[24]), .cin(co[23]), .a(c_1[23]),
     .b(c_2[23]), .cout(co[24]), .sum(sum[24]), .d(s_1[24]),
     .carry(cout[24]));
mul_csa42  sc3_23_ ( .c(s_2[23]), .cin(co[22]), .a(c_1[22]),
     .b(c_2[22]), .cout(co[23]), .sum(sum[23]), .d(s_1[23]),
     .carry(cout[23]));
mul_csa42  sc3_22_ ( .c(s_2[22]), .cin(co[21]), .a(c_1[21]),
     .b(c_2[21]), .cout(co[22]), .sum(sum[22]), .d(s_1[22]),
     .carry(cout[22]));
mul_csa42  sc3_21_ ( .c(s_2[21]), .cin(co[20]), .a(c_1[20]),
     .b(c_2[20]), .cout(co[21]), .sum(sum[21]), .d(s_1[21]),
     .carry(cout[21]));
mul_csa42  sc3_20_ ( .c(s_2[20]), .cin(co[19]), .a(c_1[19]),
     .b(c_2[19]), .cout(co[20]), .sum(sum[20]), .d(s_1[20]),
     .carry(cout[20]));
mul_csa42  sc3_19_ ( .c(s_2[19]), .cin(co[18]), .a(c_1[18]),
     .b(c_2[18]), .cout(co[19]), .sum(sum[19]), .d(s_1[19]),
     .carry(cout[19]));
mul_csa42  sc3_18_ ( .c(s_2[18]), .cin(co[17]), .a(c_1[17]),
     .b(c_2[17]), .cout(co[18]), .sum(sum[18]), .d(s_1[18]),
     .carry(cout[18]));
mul_csa42  sc3_17_ ( .c(s_2[17]), .cin(co[16]), .a(c_1[16]),
     .b(c_2[16]), .cout(co[17]), .sum(sum[17]), .d(s_1[17]),
     .carry(cout[17]));
mul_csa42  sc3_16_ ( .c(s_2[16]), .cin(co[15]), .a(c_1[15]),
     .b(c_2[15]), .cout(co[16]), .sum(sum[16]), .d(s_1[16]),
     .carry(cout[16]));
mul_csa42  sc3_15_ ( .c(s_2[15]), .cin(co[14]), .a(c_1[14]),
     .b(c_2[14]), .cout(co[15]), .sum(sum[15]), .d(s_1[15]),
     .carry(cout[15]));
mul_csa42  sc3_14_ ( .c(s_2[14]), .cin(co[13]), .a(c_1[13]),
     .b(c_2[13]), .cout(co[14]), .sum(sum[14]), .d(s_1[14]),
     .carry(cout[14]));
mul_csa42  sc3_13_ ( .c(s_2[13]), .cin(co[12]), .a(c_1[12]),
     .b(c_2[12]), .cout(co[13]), .sum(sum[13]), .d(s_1[13]),
     .carry(cout[13]));
mul_csa42  sc3_12_ ( .c(s_2[12]), .cin(co[11]), .a(c_1[11]),
     .b(c_2[11]), .cout(co[12]), .sum(sum[12]), .d(s_1[12]),
     .carry(cout[12]));
mul_csa42  sc3_11_ ( .c(s_2[11]), .cin(1'b0),
     .a(c_1[10]), .b(c_2[10]), .cout(co[11]), .sum(sum[11]),
     .d(s_1[11]), .carry(cout[11]));
mul_csa32  sc2_2_70_ ( .c(c1[63]), .b(c2[57]), .a(s2[58]),
     .cout(c_2[70]), .sum(s_2[70]));
mul_csa32  sc2_2_69_ ( .c(c1[62]), .b(c2[56]), .a(s2[57]),
     .cout(c_2[69]), .sum(s_2[69]));
mul_csa32  sc2_2_68_ ( .c(c1[61]), .b(c2[55]), .a(s2[56]),
     .cout(c_2[68]), .sum(s_2[68]));
mul_csa32  sc2_2_67_ ( .c(c1[60]), .b(c2[54]), .a(s2[55]),
     .cout(c_2[67]), .sum(s_2[67]));
mul_csa32  sc2_2_66_ ( .c(c1[59]), .b(c2[53]), .a(s2[54]),
     .cout(c_2[66]), .sum(s_2[66]));
mul_csa32  sc2_2_65_ ( .c(c1[58]), .b(c2[52]), .a(s2[53]),
     .cout(c_2[65]), .sum(s_2[65]));
mul_csa32  sc2_2_64_ ( .c(c1[57]), .b(c2[51]), .a(s2[52]),
     .cout(c_2[64]), .sum(s_2[64]));
mul_csa32  sc2_2_63_ ( .c(c1[56]), .b(c2[50]), .a(s2[51]),
     .cout(c_2[63]), .sum(s_2[63]));
mul_csa32  sc2_2_62_ ( .c(c1[55]), .b(c2[49]), .a(s2[50]),
     .cout(c_2[62]), .sum(s_2[62]));
mul_csa32  sc2_2_61_ ( .c(c1[54]), .b(c2[48]), .a(s2[49]),
     .cout(c_2[61]), .sum(s_2[61]));
mul_csa32  sc2_2_60_ ( .c(c1[53]), .b(c2[47]), .a(s2[48]),
     .cout(c_2[60]), .sum(s_2[60]));
mul_csa32  sc2_2_59_ ( .c(c1[52]), .b(c2[46]), .a(s2[47]),
     .cout(c_2[59]), .sum(s_2[59]));
mul_csa32  sc2_2_58_ ( .c(c1[51]), .b(c2[45]), .a(s2[46]),
     .cout(c_2[58]), .sum(s_2[58]));
mul_csa32  sc2_2_57_ ( .c(c1[50]), .b(c2[44]), .a(s2[45]),
     .cout(c_2[57]), .sum(s_2[57]));
mul_csa32  sc2_2_56_ ( .c(c1[49]), .b(c2[43]), .a(s2[44]),
     .cout(c_2[56]), .sum(s_2[56]));
mul_csa32  sc2_2_55_ ( .c(c1[48]), .b(c2[42]), .a(s2[43]),
     .cout(c_2[55]), .sum(s_2[55]));
mul_csa32  sc2_2_54_ ( .c(c1[47]), .b(c2[41]), .a(s2[42]),
     .cout(c_2[54]), .sum(s_2[54]));
mul_csa32  sc2_2_53_ ( .c(c1[46]), .b(c2[40]), .a(s2[41]),
     .cout(c_2[53]), .sum(s_2[53]));
mul_csa32  sc2_2_52_ ( .c(c1[45]), .b(c2[39]), .a(s2[40]),
     .cout(c_2[52]), .sum(s_2[52]));
mul_csa32  sc2_2_51_ ( .c(c1[44]), .b(c2[38]), .a(s2[39]),
     .cout(c_2[51]), .sum(s_2[51]));
mul_csa32  sc2_2_50_ ( .c(c1[43]), .b(c2[37]), .a(s2[38]),
     .cout(c_2[50]), .sum(s_2[50]));
mul_csa32  sc2_2_49_ ( .c(c1[42]), .b(c2[36]), .a(s2[37]),
     .cout(c_2[49]), .sum(s_2[49]));
mul_csa32  sc2_2_48_ ( .c(c1[41]), .b(c2[35]), .a(s2[36]),
     .cout(c_2[48]), .sum(s_2[48]));
mul_csa32  sc2_2_47_ ( .c(c1[40]), .b(c2[34]), .a(s2[35]),
     .cout(c_2[47]), .sum(s_2[47]));
mul_csa32  sc2_2_46_ ( .c(c1[39]), .b(c2[33]), .a(s2[34]),
     .cout(c_2[46]), .sum(s_2[46]));
mul_csa32  sc2_2_45_ ( .c(c1[38]), .b(c2[32]), .a(s2[33]),
     .cout(c_2[45]), .sum(s_2[45]));
mul_csa32  sc2_2_44_ ( .c(c1[37]), .b(c2[31]), .a(s2[32]),
     .cout(c_2[44]), .sum(s_2[44]));
mul_csa32  sc2_2_43_ ( .c(c1[36]), .b(c2[30]), .a(s2[31]),
     .cout(c_2[43]), .sum(s_2[43]));
mul_csa32  sc2_2_42_ ( .c(c1[35]), .b(c2[29]), .a(s2[30]),
     .cout(c_2[42]), .sum(s_2[42]));
mul_csa32  sc2_2_41_ ( .c(c1[34]), .b(c2[28]), .a(s2[29]),
     .cout(c_2[41]), .sum(s_2[41]));
mul_csa32  sc2_2_40_ ( .c(c1[33]), .b(c2[27]), .a(s2[28]),
     .cout(c_2[40]), .sum(s_2[40]));
mul_csa32  sc2_2_39_ ( .c(c1[32]), .b(c2[26]), .a(s2[27]),
     .cout(c_2[39]), .sum(s_2[39]));
mul_csa32  sc2_2_38_ ( .c(c1[31]), .b(c2[25]), .a(s2[26]),
     .cout(c_2[38]), .sum(s_2[38]));
mul_csa32  sc2_2_37_ ( .c(c1[30]), .b(c2[24]), .a(s2[25]),
     .cout(c_2[37]), .sum(s_2[37]));
mul_csa32  sc2_2_36_ ( .c(c1[29]), .b(c2[23]), .a(s2[24]),
     .cout(c_2[36]), .sum(s_2[36]));
mul_csa32  sc2_2_35_ ( .c(c1[28]), .b(c2[22]), .a(s2[23]),
     .cout(c_2[35]), .sum(s_2[35]));
mul_csa32  sc2_2_34_ ( .c(c1[27]), .b(c2[21]), .a(s2[22]),
     .cout(c_2[34]), .sum(s_2[34]));
mul_csa32  sc2_2_33_ ( .c(c1[26]), .b(c2[20]), .a(s2[21]),
     .cout(c_2[33]), .sum(s_2[33]));
mul_csa32  sc2_2_32_ ( .c(c1[25]), .b(c2[19]), .a(s2[20]),
     .cout(c_2[32]), .sum(s_2[32]));
mul_csa32  sc2_2_31_ ( .c(c1[24]), .b(c2[18]), .a(s2[19]),
     .cout(c_2[31]), .sum(s_2[31]));
mul_csa32  sc2_2_30_ ( .c(c1[23]), .b(c2[17]), .a(s2[18]),
     .cout(c_2[30]), .sum(s_2[30]));
mul_csa32  sc2_2_29_ ( .c(c1[22]), .b(c2[16]), .a(s2[17]),
     .cout(c_2[29]), .sum(s_2[29]));
mul_csa32  sc2_2_28_ ( .c(c1[21]), .b(c2[15]), .a(s2[16]),
     .cout(c_2[28]), .sum(s_2[28]));
mul_csa32  sc2_2_27_ ( .c(c1[20]), .b(c2[14]), .a(s2[15]),
     .cout(c_2[27]), .sum(s_2[27]));
mul_csa32  sc2_2_26_ ( .c(c1[19]), .b(c2[13]), .a(s2[14]),
     .cout(c_2[26]), .sum(s_2[26]));
mul_csa32  sc2_2_25_ ( .c(c1[18]), .b(c2[12]), .a(s2[13]),
     .cout(c_2[25]), .sum(s_2[25]));
mul_csa32  sc2_2_24_ ( .c(c1[17]), .b(c2[11]), .a(s2[12]),
     .cout(c_2[24]), .sum(s_2[24]));
mul_csa32  sc2_2_23_ ( .c(c1[16]), .b(c2[10]), .a(s2[11]),
     .cout(c_2[23]), .sum(s_2[23]));
mul_csa32  sc2_2_22_ ( .c(c1[15]), .b(c2[9]), .a(s2[10]),
     .cout(c_2[22]), .sum(s_2[22]));
mul_csa32  sc2_2_21_ ( .c(c1[14]), .b(c2[8]), .a(s2[9]),
     .cout(c_2[21]), .sum(s_2[21]));
mul_csa32  sc2_2_20_ ( .c(c1[13]), .b(c2[7]), .a(s2[8]),
     .cout(c_2[20]), .sum(s_2[20]));
mul_csa32  sc2_2_19_ ( .c(c1[12]), .b(c2[6]), .a(s2[7]),
     .cout(c_2[19]), .sum(s_2[19]));
mul_csa32  sc2_2_18_ ( .c(c1[11]), .b(c2[5]), .a(s2[6]),
     .cout(c_2[18]), .sum(s_2[18]));
mul_csa32  sc2_2_17_ ( .c(c1[10]), .b(c2[4]), .a(s2[5]),
     .cout(c_2[17]), .sum(s_2[17]));
mul_csa32  sc2_2_16_ ( .c(c1[9]), .b(c2[3]), .a(s2[4]),
     .cout(c_2[16]), .sum(s_2[16]));
mul_csa32  sc2_2_15_ ( .c(c1[8]), .b(c2[2]), .a(s2[3]),
     .cout(c_2[15]), .sum(s_2[15]));
mul_csa32  sc2_2_14_ ( .c(c1[7]), .b(c2[1]), .a(s2[2]),
     .cout(c_2[14]), .sum(s_2[14]));
mul_csa32  sc2_2_13_ ( .c(c1[6]), .b(s1[7]), .a(s2[1]),
     .cout(c_2[13]), .sum(s_2[13]));
mul_csa32  sc2_2_12_ ( .c(c1[5]), .b(s1[6]), .a(s2[0]),
     .cout(c_2[12]), .sum(s_2[12]));
mul_csa32  sc2_2_11_ ( .c(c1[4]), .b(s1[5]), .a(b5n[1]),
     .cout(c_2[11]), .sum(s_2[11]));
mul_csa32  sc2_2_10_ ( .c(c1[3]), .b(s1[4]), .a(b5n[0]),
     .cout(c_2[10]), .sum(s_2[10]));
mul_csa32  sc2_2_76_ ( .c(1'b1), .b(c2[63]), .a(s2[64]),
     .cout(c_2[76]), .sum(s_2[76]));
mul_csa32  sc2_2_77_ ( .c(c_2[76]), .b(c2[64]), .a(s2[65]),
     .cout(cout[77]), .sum(sum[77]));
mul_csa32  sc2_1_9_ ( .c(s1[3]), .b(c0[8]), .a(s0[9]), .cout(c_1[9]),
     .sum(s_1[9]));
mul_csa32  sc2_1_8_ ( .c(s1[2]), .b(c0[7]), .a(s0[8]), .cout(c_1[8]),
     .sum(s_1[8]));
mul_csa32  sc2_1_3_ ( .c(c_1[2]), .b(c0[2]), .a(s0[3]),
     .cout(c_1[3]), .sum(sum[3]));
mul_csa32  sc3_10_ ( .c(s_2[10]), .b(s_1[10]), .a(c_1[9]),
     .cout(cout[10]), .sum(sum[10]));
mul_csa32  sc3_9_ ( .c(c1[2]), .sum(sum[9]), .cout(cout[9]),
     .a(c_1[8]), .b(s_1[9]));
mul_csa32  sc3_8_ ( .c(c1[1]), .sum(sum[8]), .cout(cout[8]),
     .a(c_1[7]), .b(s_1[8]));
mul_csa32  sc2_2_71_ ( .c(c1[64]), .b(c2[58]), .a(s2[59]),
     .cout(c_2[71]), .sum(s_2[71]));
mul_csa32  sc2_2_75_ ( .c(c1[68]), .b(c2[62]), .a(s2[63]),
     .cout(c_2[75]), .sum(s_2[75]));
mul_csa32  sc2_2_74_ ( .c(c1[67]), .b(c2[61]), .a(s2[62]),
     .cout(c_2[74]), .sum(s_2[74]));
mul_csa32  sc2_2_73_ ( .c(c1[66]), .b(c2[60]), .a(s2[61]),
     .cout(c_2[73]), .sum(s_2[73]));
mul_csa32  sc2_2_72_ ( .c(c1[65]), .b(c2[59]), .a(s2[60]),
     .cout(c_2[72]), .sum(s_2[72]));
mul_csa32  sc2_1_69_ ( .c(s1[63]), .sum(s_1[69]), .cout(c_1[69]),
     .a(s0[69]), .b(c0[68]));
mul_csa32  sc2_1_68_ ( .c(s1[62]), .sum(s_1[68]), .cout(c_1[68]),
     .a(s0[68]), .b(c0[67]));
mul_csa32  sc2_1_67_ ( .c(s1[61]), .sum(s_1[67]), .cout(c_1[67]),
     .a(s0[67]), .b(c0[66]));
mul_csa32  sc2_1_66_ ( .c(s1[60]), .sum(s_1[66]), .cout(c_1[66]),
     .a(s0[66]), .b(c0[65]));
mul_csa32  sc2_1_65_ ( .c(s1[59]), .sum(s_1[65]), .cout(c_1[65]),
     .a(s0[65]), .b(c0[64]));
mul_csa32  sc2_1_64_ ( .c(s1[58]), .sum(s_1[64]), .cout(c_1[64]),
     .a(s0[64]), .b(c0[63]));
mul_csa32  sc2_1_63_ ( .c(s1[57]), .sum(s_1[63]), .cout(c_1[63]),
     .a(s0[63]), .b(c0[62]));
mul_csa32  sc2_1_62_ ( .c(s1[56]), .sum(s_1[62]), .cout(c_1[62]),
     .a(s0[62]), .b(c0[61]));
mul_csa32  sc2_1_61_ ( .c(s1[55]), .sum(s_1[61]), .cout(c_1[61]),
     .a(s0[61]), .b(c0[60]));
mul_csa32  sc2_1_60_ ( .c(s1[54]), .sum(s_1[60]), .cout(c_1[60]),
     .a(s0[60]), .b(c0[59]));
mul_csa32  sc2_1_59_ ( .c(s1[53]), .sum(s_1[59]), .cout(c_1[59]),
     .a(s0[59]), .b(c0[58]));
mul_csa32  sc2_1_58_ ( .c(s1[52]), .sum(s_1[58]), .cout(c_1[58]),
     .a(s0[58]), .b(c0[57]));
mul_csa32  sc2_1_57_ ( .c(s1[51]), .sum(s_1[57]), .cout(c_1[57]),
     .a(s0[57]), .b(c0[56]));
mul_csa32  sc2_1_56_ ( .c(s1[50]), .sum(s_1[56]), .cout(c_1[56]),
     .a(s0[56]), .b(c0[55]));
mul_csa32  sc2_1_55_ ( .c(s1[49]), .sum(s_1[55]), .cout(c_1[55]),
     .a(s0[55]), .b(c0[54]));
mul_csa32  sc2_1_54_ ( .c(s1[48]), .sum(s_1[54]), .cout(c_1[54]),
     .a(s0[54]), .b(c0[53]));
mul_csa32  sc2_1_53_ ( .c(s1[47]), .sum(s_1[53]), .cout(c_1[53]),
     .a(s0[53]), .b(c0[52]));
mul_csa32  sc2_1_52_ ( .c(s1[46]), .sum(s_1[52]), .cout(c_1[52]),
     .a(s0[52]), .b(c0[51]));
mul_csa32  sc2_1_51_ ( .c(s1[45]), .sum(s_1[51]), .cout(c_1[51]),
     .a(s0[51]), .b(c0[50]));
mul_csa32  sc2_1_50_ ( .c(s1[44]), .sum(s_1[50]), .cout(c_1[50]),
     .a(s0[50]), .b(c0[49]));
mul_csa32  sc2_1_49_ ( .c(s1[43]), .sum(s_1[49]), .cout(c_1[49]),
     .a(s0[49]), .b(c0[48]));
mul_csa32  sc2_1_48_ ( .c(s1[42]), .sum(s_1[48]), .cout(c_1[48]),
     .a(s0[48]), .b(c0[47]));
mul_csa32  sc2_1_47_ ( .c(s1[41]), .sum(s_1[47]), .cout(c_1[47]),
     .a(s0[47]), .b(c0[46]));
mul_csa32  sc2_1_46_ ( .c(s1[40]), .sum(s_1[46]), .cout(c_1[46]),
     .a(s0[46]), .b(c0[45]));
mul_csa32  sc2_1_45_ ( .c(s1[39]), .sum(s_1[45]), .cout(c_1[45]),
     .a(s0[45]), .b(c0[44]));
mul_csa32  sc2_1_44_ ( .c(s1[38]), .sum(s_1[44]), .cout(c_1[44]),
     .a(s0[44]), .b(c0[43]));
mul_csa32  sc2_1_43_ ( .c(s1[37]), .sum(s_1[43]), .cout(c_1[43]),
     .a(s0[43]), .b(c0[42]));
mul_csa32  sc2_1_42_ ( .c(s1[36]), .sum(s_1[42]), .cout(c_1[42]),
     .a(s0[42]), .b(c0[41]));
mul_csa32  sc2_1_41_ ( .c(s1[35]), .sum(s_1[41]), .cout(c_1[41]),
     .a(s0[41]), .b(c0[40]));
mul_csa32  sc2_1_40_ ( .c(s1[34]), .sum(s_1[40]), .cout(c_1[40]),
     .a(s0[40]), .b(c0[39]));
mul_csa32  sc2_1_39_ ( .c(s1[33]), .sum(s_1[39]), .cout(c_1[39]),
     .a(s0[39]), .b(c0[38]));
mul_csa32  sc2_1_38_ ( .c(s1[32]), .sum(s_1[38]), .cout(c_1[38]),
     .a(s0[38]), .b(c0[37]));
mul_csa32  sc2_1_37_ ( .c(s1[31]), .sum(s_1[37]), .cout(c_1[37]),
     .a(s0[37]), .b(c0[36]));
mul_csa32  sc2_1_36_ ( .c(s1[30]), .sum(s_1[36]), .cout(c_1[36]),
     .a(s0[36]), .b(c0[35]));
mul_csa32  sc2_1_35_ ( .c(s1[29]), .sum(s_1[35]), .cout(c_1[35]),
     .a(s0[35]), .b(c0[34]));
mul_csa32  sc2_1_34_ ( .c(s1[28]), .sum(s_1[34]), .cout(c_1[34]),
     .a(s0[34]), .b(c0[33]));
mul_csa32  sc2_1_33_ ( .c(s1[27]), .sum(s_1[33]), .cout(c_1[33]),
     .a(s0[33]), .b(c0[32]));
mul_csa32  sc2_1_32_ ( .c(s1[26]), .sum(s_1[32]), .cout(c_1[32]),
     .a(s0[32]), .b(c0[31]));
mul_csa32  sc2_1_31_ ( .c(s1[25]), .sum(s_1[31]), .cout(c_1[31]),
     .a(s0[31]), .b(c0[30]));
mul_csa32  sc2_1_30_ ( .c(s1[24]), .sum(s_1[30]), .cout(c_1[30]),
     .a(s0[30]), .b(c0[29]));
mul_csa32  sc2_1_29_ ( .c(s1[23]), .sum(s_1[29]), .cout(c_1[29]),
     .a(s0[29]), .b(c0[28]));
mul_csa32  sc2_1_28_ ( .c(s1[22]), .sum(s_1[28]), .cout(c_1[28]),
     .a(s0[28]), .b(c0[27]));
mul_csa32  sc2_1_27_ ( .c(s1[21]), .sum(s_1[27]), .cout(c_1[27]),
     .a(s0[27]), .b(c0[26]));
mul_csa32  sc2_1_26_ ( .c(s1[20]), .sum(s_1[26]), .cout(c_1[26]),
     .a(s0[26]), .b(c0[25]));
mul_csa32  sc2_1_25_ ( .c(s1[19]), .sum(s_1[25]), .cout(c_1[25]),
     .a(s0[25]), .b(c0[24]));
mul_csa32  sc2_1_24_ ( .c(s1[18]), .sum(s_1[24]), .cout(c_1[24]),
     .a(s0[24]), .b(c0[23]));
mul_csa32  sc2_1_23_ ( .c(s1[17]), .sum(s_1[23]), .cout(c_1[23]),
     .a(s0[23]), .b(c0[22]));
mul_csa32  sc2_1_22_ ( .c(s1[16]), .sum(s_1[22]), .cout(c_1[22]),
     .a(s0[22]), .b(c0[21]));
mul_csa32  sc2_1_21_ ( .c(s1[15]), .sum(s_1[21]), .cout(c_1[21]),
     .a(s0[21]), .b(c0[20]));
mul_csa32  sc2_1_20_ ( .c(s1[14]), .sum(s_1[20]), .cout(c_1[20]),
     .a(s0[20]), .b(c0[19]));
mul_csa32  sc2_1_19_ ( .c(s1[13]), .sum(s_1[19]), .cout(c_1[19]),
     .a(s0[19]), .b(c0[18]));
mul_csa32  sc2_1_18_ ( .c(s1[12]), .sum(s_1[18]), .cout(c_1[18]),
     .a(s0[18]), .b(c0[17]));
mul_csa32  sc2_1_17_ ( .c(s1[11]), .sum(s_1[17]), .cout(c_1[17]),
     .a(s0[17]), .b(c0[16]));
mul_csa32  sc2_1_16_ ( .c(s1[10]), .sum(s_1[16]), .cout(c_1[16]),
     .a(s0[16]), .b(c0[15]));
mul_csa32  sc2_1_15_ ( .c(s1[9]), .sum(s_1[15]), .cout(c_1[15]),
     .a(s0[15]), .b(c0[14]));
mul_csa32  sc2_1_14_ ( .c(s1[8]), .sum(s_1[14]), .cout(c_1[14]),
     .a(s0[14]), .b(c0[13]));
mul_csa32  sc2_1_7_ ( .c(s1[1]), .b(c0[6]), .a(s0[7]), .cout(c_1[7]),
     .sum(s_1[7]));
mul_csa32  sc2_1_6_ ( .c(s1[0]), .b(c0[5]), .a(s0[6]), .cout(c_1[6]),
     .sum(s_1[6]));
mul_csa32  sc2_1_5_ ( .c(b2n[1]), .b(c0[4]), .a(s0[5]),
     .cout(c_1[5]), .sum(s_1[5]));
mul_csa32  sc2_1_4_ ( .c(b2n[0]), .b(c0[3]), .a(s0[4]),
     .cout(c_1[4]), .sum(s_1[4]));
mul_ha sc2_1_10_ ( .sum(s_1[10]), .cout(c_1[10]), .a(s0[10]),
     .b(c0[9]));
mul_ha sc3_7_ ( .sum(sum[7]), .cout(cout[7]), .a(c_1[6]),
     .b(s_1[7]));
mul_ha sc3_6_ ( .sum(sum[6]), .cout(cout[6]), .a(c_1[5]),
     .b(s_1[6]));
mul_ha sc3_5_ ( .sum(sum[5]), .cout(cout[5]), .a(c_1[4]),
     .b(s_1[5]));
mul_ha sc3_4_ ( .sum(sum[4]), .cout(cout[4]), .a(c_1[3]),
     .b(s_1[4]));
mul_ha sc2_2_81_ ( .sum(sum[81]), .cout(cout[81]), .a(s2[69]),
     .b(c2[68]));
mul_ha sc2_2_80_ ( .sum(sum[80]), .cout(cout[80]), .a(s2[68]),
     .b(c2[67]));
mul_ha sc2_2_79_ ( .sum(sum[79]), .cout(cout[79]), .a(s2[67]),
     .b(c2[66]));
mul_ha sc2_2_78_ ( .sum(sum[78]), .cout(cout[78]), .a(s2[66]),
     .b(c2[65]));
mul_ha sc2_1_70_ ( .sum(s_1[70]), .cout(c_1[70]),
     .a(1'b1), .b(s1[64]));
mul_ha sc2_1_2_ ( .sum(sum[2]), .cout(c_1[2]), .a(s0[2]), .b(c0[1]));
mul_ha sc2_1_13_ ( .sum(s_1[13]), .cout(c_1[13]), .a(s0[13]),
     .b(c0[12]));
mul_ha sc2_1_12_ ( .sum(s_1[12]), .cout(c_1[12]), .a(s0[12]),
     .b(c0[11]));
mul_ha sc2_1_11_ ( .sum(s_1[11]), .cout(c_1[11]), .a(s0[11]),
     .b(c0[10]));
mul_ppgenrow3 I2 ( .head(1'b0), .bot(bot), .b2(b8[2:0]),
     .b1(b7[2:0]), .b0(b6[2:0]), .a(a[63:0]), .sum(s2[69:0]),
     .cout(c2[68:1]));
mul_ppgenrow3 I1 ( .head(1'b0), .bot(1'b1),
     .b2(b5[2:0]), .b1(b4[2:0]), .b0(b3[2:0]), .a(a[63:0]),
     .sum(s1[69:0]), .cout(c1[68:1]));
mul_ppgenrow3 I0 ( .head(head), .bot(1'b1), .b2(b2[2:0]),
     .b1(b1[2:0]), .b0(b0[2:0]), .a(a[63:0]), .sum({s0[69:2],
     sum[1:0]}), .cout(c0[68:1]));

endmodule // mul_array1

module mul_array2 ( pcout, pcoutx2, psum, psumx2, a0c, a0s, a1c, a1s,
     areg, bot, pc, ps, x2 );

output  pcoutx2, psumx2;
input  bot, x2;
output [98:0]  psum;
output [98:0]  pcout;
input [81:4]  a1c;
input [98:30]  pc;
input [98:31]  ps;
input [81:0]  a0s;
input [96:0]  areg;
input [81:0]  a1s;
input [81:4]  a0c;

// Buses in the design
wire  [81:15]  s3;
wire  [81:15]  c3;
wire  [96:0]  ain;
wire  [67:20]  co;
wire  [82:0]  s1;
wire  [96:0]  c2;
wire  [82:0]  c1;
wire  [96:0]  s2;
wire	      ainx2, s1x2, c1x2;

mul_mux2 sh_82_ ( .d1(areg[83]), .z(ain[82]), .d0(areg[82]), .s(x2));
mul_mux2 sh_68_ ( .d1(areg[69]), .z(ain[68]), .d0(areg[68]), .s(x2));
mul_mux2 sh_67_ ( .d1(areg[68]), .z(ain[67]), .d0(areg[67]), .s(x2));
mul_mux2 sh_66_ ( .d1(areg[67]), .z(ain[66]), .d0(areg[66]), .s(x2));
mul_mux2 sh_65_ ( .d1(areg[66]), .z(ain[65]), .d0(areg[65]), .s(x2));
mul_mux2 sh_64_ ( .d1(areg[65]), .z(ain[64]), .d0(areg[64]), .s(x2));
mul_mux2 sh_63_ ( .d1(areg[64]), .z(ain[63]), .d0(areg[63]), .s(x2));
mul_mux2 sh_62_ ( .d1(areg[63]), .z(ain[62]), .d0(areg[62]), .s(x2));
mul_mux2 sh_61_ ( .d1(areg[62]), .z(ain[61]), .d0(areg[61]), .s(x2));
mul_mux2 sh_60_ ( .d1(areg[61]), .z(ain[60]), .d0(areg[60]), .s(x2));
mul_mux2 sh_59_ ( .d1(areg[60]), .z(ain[59]), .d0(areg[59]), .s(x2));
mul_mux2 sh_58_ ( .d1(areg[59]), .z(ain[58]), .d0(areg[58]), .s(x2));
mul_mux2 sh_57_ ( .d1(areg[58]), .z(ain[57]), .d0(areg[57]), .s(x2));
mul_mux2 sh_56_ ( .d1(areg[57]), .z(ain[56]), .d0(areg[56]), .s(x2));
mul_mux2 sh_55_ ( .d1(areg[56]), .z(ain[55]), .d0(areg[55]), .s(x2));
mul_mux2 sh_54_ ( .d1(areg[55]), .z(ain[54]), .d0(areg[54]), .s(x2));
mul_mux2 sh_53_ ( .d1(areg[54]), .z(ain[53]), .d0(areg[53]), .s(x2));
mul_mux2 sh_52_ ( .d1(areg[53]), .z(ain[52]), .d0(areg[52]), .s(x2));
mul_mux2 sh_51_ ( .d1(areg[52]), .z(ain[51]), .d0(areg[51]), .s(x2));
mul_mux2 sh_50_ ( .d1(areg[51]), .z(ain[50]), .d0(areg[50]), .s(x2));
mul_mux2 sh_49_ ( .d1(areg[50]), .z(ain[49]), .d0(areg[49]), .s(x2));
mul_mux2 sh_48_ ( .d1(areg[49]), .z(ain[48]), .d0(areg[48]), .s(x2));
mul_mux2 sh_47_ ( .d1(areg[48]), .z(ain[47]), .d0(areg[47]), .s(x2));
mul_mux2 sh_46_ ( .d1(areg[47]), .z(ain[46]), .d0(areg[46]), .s(x2));
mul_mux2 sh_45_ ( .d1(areg[46]), .z(ain[45]), .d0(areg[45]), .s(x2));
mul_mux2 sh_44_ ( .d1(areg[45]), .z(ain[44]), .d0(areg[44]), .s(x2));
mul_mux2 sh_43_ ( .d1(areg[44]), .z(ain[43]), .d0(areg[43]), .s(x2));
mul_mux2 sh_42_ ( .d1(areg[43]), .z(ain[42]), .d0(areg[42]), .s(x2));
mul_mux2 sh_41_ ( .d1(areg[42]), .z(ain[41]), .d0(areg[41]), .s(x2));
mul_mux2 sh_40_ ( .d1(areg[41]), .z(ain[40]), .d0(areg[40]), .s(x2));
mul_mux2 sh_39_ ( .d1(areg[40]), .z(ain[39]), .d0(areg[39]), .s(x2));
mul_mux2 sh_38_ ( .d1(areg[39]), .z(ain[38]), .d0(areg[38]), .s(x2));
mul_mux2 sh_37_ ( .d1(areg[38]), .z(ain[37]), .d0(areg[37]), .s(x2));
mul_mux2 sh_36_ ( .d1(areg[37]), .z(ain[36]), .d0(areg[36]), .s(x2));
mul_mux2 sh_35_ ( .d1(areg[36]), .z(ain[35]), .d0(areg[35]), .s(x2));
mul_mux2 sh_34_ ( .d1(areg[35]), .z(ain[34]), .d0(areg[34]), .s(x2));
mul_mux2 sh_33_ ( .d1(areg[34]), .z(ain[33]), .d0(areg[33]), .s(x2));
mul_mux2 sh_32_ ( .d1(areg[33]), .z(ain[32]), .d0(areg[32]), .s(x2));
mul_mux2 sh_31_ ( .d1(areg[32]), .z(ain[31]), .d0(areg[31]), .s(x2));
mul_mux2 sh_30_ ( .d1(areg[31]), .z(ain[30]), .d0(areg[30]), .s(x2));
mul_mux2 sh_29_ ( .d1(areg[30]), .z(ain[29]), .d0(areg[29]), .s(x2));
mul_mux2 sh_28_ ( .d1(areg[29]), .z(ain[28]), .d0(areg[28]), .s(x2));
mul_mux2 sh_27_ ( .d1(areg[28]), .z(ain[27]), .d0(areg[27]), .s(x2));
mul_mux2 sh_26_ ( .d1(areg[27]), .z(ain[26]), .d0(areg[26]), .s(x2));
mul_mux2 sh_25_ ( .d1(areg[26]), .z(ain[25]), .d0(areg[25]), .s(x2));
mul_mux2 sh_24_ ( .d1(areg[25]), .z(ain[24]), .d0(areg[24]), .s(x2));
mul_mux2 sh_23_ ( .d1(areg[24]), .z(ain[23]), .d0(areg[23]), .s(x2));
mul_mux2 sh_22_ ( .d1(areg[23]), .z(ain[22]), .d0(areg[22]), .s(x2));
mul_mux2 sh_21_ ( .d1(areg[22]), .z(ain[21]), .d0(areg[21]), .s(x2));
mul_mux2 sh_20_ ( .d1(areg[21]), .z(ain[20]), .d0(areg[20]), .s(x2));
mul_mux2 sh_96_ ( .d1(1'b0), .z(ain[96]), .d0(areg[96]),
     .s(x2));
mul_mux2 sh_95_ ( .d1(areg[96]), .z(ain[95]), .d0(areg[95]), .s(x2));
mul_mux2 sh_94_ ( .d1(areg[95]), .z(ain[94]), .d0(areg[94]), .s(x2));
mul_mux2 sh_93_ ( .d1(areg[94]), .z(ain[93]), .d0(areg[93]), .s(x2));
mul_mux2 sh_92_ ( .d1(areg[93]), .z(ain[92]), .d0(areg[92]), .s(x2));
mul_mux2 sh_91_ ( .d1(areg[92]), .z(ain[91]), .d0(areg[91]), .s(x2));
mul_mux2 sh_90_ ( .d1(areg[91]), .z(ain[90]), .d0(areg[90]), .s(x2));
mul_mux2 sh_89_ ( .d1(areg[90]), .z(ain[89]), .d0(areg[89]), .s(x2));
mul_mux2 sh_88_ ( .d1(areg[89]), .z(ain[88]), .d0(areg[88]), .s(x2));
mul_mux2 sh_87_ ( .d1(areg[88]), .z(ain[87]), .d0(areg[87]), .s(x2));
mul_mux2 sh_86_ ( .d1(areg[87]), .z(ain[86]), .d0(areg[86]), .s(x2));
mul_mux2 sh_85_ ( .d1(areg[86]), .z(ain[85]), .d0(areg[85]), .s(x2));
mul_mux2 sh_84_ ( .d1(areg[85]), .z(ain[84]), .d0(areg[84]), .s(x2));
mul_mux2 sh_0_ ( .d1(areg[1]), .z(ain[0]), .d0(areg[0]), .s(x2));
mul_mux2 sh_81_ ( .d1(areg[82]), .z(ain[81]), .d0(areg[81]), .s(x2));
mul_mux2 sh_80_ ( .d1(areg[81]), .z(ain[80]), .d0(areg[80]), .s(x2));
mul_mux2 sh_79_ ( .d1(areg[80]), .z(ain[79]), .d0(areg[79]), .s(x2));
mul_mux2 sh_78_ ( .d1(areg[79]), .z(ain[78]), .d0(areg[78]), .s(x2));
mul_mux2 sh_77_ ( .d1(areg[78]), .z(ain[77]), .d0(areg[77]), .s(x2));
mul_mux2 sh_76_ ( .d1(areg[77]), .z(ain[76]), .d0(areg[76]), .s(x2));
mul_mux2 sh_75_ ( .d1(areg[76]), .z(ain[75]), .d0(areg[75]), .s(x2));
mul_mux2 sh_74_ ( .d1(areg[75]), .z(ain[74]), .d0(areg[74]), .s(x2));
mul_mux2 sh_73_ ( .d1(areg[74]), .z(ain[73]), .d0(areg[73]), .s(x2));
mul_mux2 sh_72_ ( .d1(areg[73]), .z(ain[72]), .d0(areg[72]), .s(x2));
mul_mux2 sh_71_ ( .d1(areg[72]), .z(ain[71]), .d0(areg[71]), .s(x2));
mul_mux2 sh_70_ ( .d1(areg[71]), .z(ain[70]), .d0(areg[70]), .s(x2));
mul_mux2 sh_69_ ( .d1(areg[70]), .z(ain[69]), .d0(areg[69]), .s(x2));
mul_mux2 sh_19_ ( .d1(areg[20]), .z(ain[19]), .d0(areg[19]), .s(x2));
mul_mux2 sh_18_ ( .d1(areg[19]), .z(ain[18]), .d0(areg[18]), .s(x2));
mul_mux2 sh_17_ ( .d1(areg[18]), .z(ain[17]), .d0(areg[17]), .s(x2));
mul_mux2 sh_16_ ( .d1(areg[17]), .z(ain[16]), .d0(areg[16]), .s(x2));
mul_mux2 sh_15_ ( .d1(areg[16]), .z(ain[15]), .d0(areg[15]), .s(x2));
mul_mux2 sh_4_ ( .d1(areg[5]), .z(ain[4]), .d0(areg[4]), .s(x2));
mul_mux2 sh_3_ ( .d1(areg[4]), .z(ain[3]), .d0(areg[3]), .s(x2));
mul_mux2 sh_2_ ( .d1(areg[3]), .z(ain[2]), .d0(areg[2]), .s(x2));
mul_mux2 sh_1_ ( .d1(areg[2]), .z(ain[1]), .d0(areg[1]), .s(x2));
mul_mux2 shx2 ( .d1(areg[0]), .z(ainx2), .d0(1'b0),
     .s(x2));
mul_mux2 sh_83_ ( .d1(areg[84]), .z(ain[83]), .d0(areg[83]), .s(x2));
mul_mux2 sh_14_ ( .d1(areg[15]), .z(ain[14]), .d0(areg[14]), .s(x2));
mul_mux2 sh_13_ ( .d1(areg[14]), .z(ain[13]), .d0(areg[13]), .s(x2));
mul_mux2 sh_12_ ( .d1(areg[13]), .z(ain[12]), .d0(areg[12]), .s(x2));
mul_mux2 sh_11_ ( .d1(areg[12]), .z(ain[11]), .d0(areg[11]), .s(x2));
mul_mux2 sh_10_ ( .d1(areg[11]), .z(ain[10]), .d0(areg[10]), .s(x2));
mul_mux2 sh_9_ ( .d1(areg[10]), .z(ain[9]), .d0(areg[9]), .s(x2));
mul_mux2 sh_8_ ( .d1(areg[9]), .z(ain[8]), .d0(areg[8]), .s(x2));
mul_mux2 sh_7_ ( .d1(areg[8]), .z(ain[7]), .d0(areg[7]), .s(x2));
mul_mux2 sh_6_ ( .d1(areg[7]), .z(ain[6]), .d0(areg[6]), .s(x2));
mul_mux2 sh_5_ ( .d1(areg[6]), .z(ain[5]), .d0(areg[5]), .s(x2));
mul_csa42  sc3_68_ ( .cin(co[67]), .d(1'b0),
     .carry(c3[68]), .c(c2[67]), .b(s2[68]), .a(1'b0),
     .cout(), .sum(s3[68]));
mul_csa42  sc3_67_ ( .cin(co[66]), .d(1'b0),
     .carry(c3[67]), .c(c2[66]), .b(s2[67]), .a(s1[67]), .cout(co[67]),
     .sum(s3[67]));
mul_csa42  sc3_66_ ( .cin(co[65]), .d(c1[65]), .carry(c3[66]),
     .c(c2[65]), .b(s2[66]), .a(s1[66]), .cout(co[66]), .sum(s3[66]));
mul_csa42  sc3_65_ ( .cin(co[64]), .d(c1[64]), .carry(c3[65]),
     .c(c2[64]), .b(s2[65]), .a(s1[65]), .cout(co[65]), .sum(s3[65]));
mul_csa42  sc3_64_ ( .cin(co[63]), .d(c1[63]), .carry(c3[64]),
     .c(c2[63]), .b(s2[64]), .a(s1[64]), .cout(co[64]), .sum(s3[64]));
mul_csa42  sc3_63_ ( .cin(co[62]), .d(c1[62]), .carry(c3[63]),
     .c(c2[62]), .b(s2[63]), .a(s1[63]), .cout(co[63]), .sum(s3[63]));
mul_csa42  sc3_62_ ( .cin(co[61]), .d(c1[61]), .carry(c3[62]),
     .c(c2[61]), .b(s2[62]), .a(s1[62]), .cout(co[62]), .sum(s3[62]));
mul_csa42  sc3_61_ ( .cin(co[60]), .d(c1[60]), .carry(c3[61]),
     .c(c2[60]), .b(s2[61]), .a(s1[61]), .cout(co[61]), .sum(s3[61]));
mul_csa42  sc3_60_ ( .cin(co[59]), .d(c1[59]), .carry(c3[60]),
     .c(c2[59]), .b(s2[60]), .a(s1[60]), .cout(co[60]), .sum(s3[60]));
mul_csa42  sc3_59_ ( .cin(co[58]), .d(c1[58]), .carry(c3[59]),
     .c(c2[58]), .b(s2[59]), .a(s1[59]), .cout(co[59]), .sum(s3[59]));
mul_csa42  sc3_58_ ( .cin(co[57]), .d(c1[57]), .carry(c3[58]),
     .c(c2[57]), .b(s2[58]), .a(s1[58]), .cout(co[58]), .sum(s3[58]));
mul_csa42  sc3_57_ ( .cin(co[56]), .d(c1[56]), .carry(c3[57]),
     .c(c2[56]), .b(s2[57]), .a(s1[57]), .cout(co[57]), .sum(s3[57]));
mul_csa42  sc3_56_ ( .cin(co[55]), .d(c1[55]), .carry(c3[56]),
     .c(c2[55]), .b(s2[56]), .a(s1[56]), .cout(co[56]), .sum(s3[56]));
mul_csa42  sc3_55_ ( .cin(co[54]), .d(c1[54]), .carry(c3[55]),
     .c(c2[54]), .b(s2[55]), .a(s1[55]), .cout(co[55]), .sum(s3[55]));
mul_csa42  sc3_54_ ( .cin(co[53]), .d(c1[53]), .carry(c3[54]),
     .c(c2[53]), .b(s2[54]), .a(s1[54]), .cout(co[54]), .sum(s3[54]));
mul_csa42  sc3_53_ ( .cin(co[52]), .d(c1[52]), .carry(c3[53]),
     .c(c2[52]), .b(s2[53]), .a(s1[53]), .cout(co[53]), .sum(s3[53]));
mul_csa42  sc3_52_ ( .cin(co[51]), .d(c1[51]), .carry(c3[52]),
     .c(c2[51]), .b(s2[52]), .a(s1[52]), .cout(co[52]), .sum(s3[52]));
mul_csa42  sc3_51_ ( .cin(co[50]), .d(c1[50]), .carry(c3[51]),
     .c(c2[50]), .b(s2[51]), .a(s1[51]), .cout(co[51]), .sum(s3[51]));
mul_csa42  sc3_50_ ( .cin(co[49]), .d(c1[49]), .carry(c3[50]),
     .c(c2[49]), .b(s2[50]), .a(s1[50]), .cout(co[50]), .sum(s3[50]));
mul_csa42  sc3_49_ ( .cin(co[48]), .d(c1[48]), .carry(c3[49]),
     .c(c2[48]), .b(s2[49]), .a(s1[49]), .cout(co[49]), .sum(s3[49]));
mul_csa42  sc3_48_ ( .cin(co[47]), .d(c1[47]), .carry(c3[48]),
     .c(c2[47]), .b(s2[48]), .a(s1[48]), .cout(co[48]), .sum(s3[48]));
mul_csa42  sc3_47_ ( .cin(co[46]), .d(c1[46]), .carry(c3[47]),
     .c(c2[46]), .b(s2[47]), .a(s1[47]), .cout(co[47]), .sum(s3[47]));
mul_csa42  sc3_46_ ( .cin(co[45]), .d(c1[45]), .carry(c3[46]),
     .c(c2[45]), .b(s2[46]), .a(s1[46]), .cout(co[46]), .sum(s3[46]));
mul_csa42  sc3_45_ ( .cin(co[44]), .d(c1[44]), .carry(c3[45]),
     .c(c2[44]), .b(s2[45]), .a(s1[45]), .cout(co[45]), .sum(s3[45]));
mul_csa42  sc3_44_ ( .cin(co[43]), .d(c1[43]), .carry(c3[44]),
     .c(c2[43]), .b(s2[44]), .a(s1[44]), .cout(co[44]), .sum(s3[44]));
mul_csa42  sc3_43_ ( .cin(co[42]), .d(c1[42]), .carry(c3[43]),
     .c(c2[42]), .b(s2[43]), .a(s1[43]), .cout(co[43]), .sum(s3[43]));
mul_csa42  sc3_42_ ( .cin(co[41]), .d(c1[41]), .carry(c3[42]),
     .c(c2[41]), .b(s2[42]), .a(s1[42]), .cout(co[42]), .sum(s3[42]));
mul_csa42  sc3_41_ ( .cin(co[40]), .d(c1[40]), .carry(c3[41]),
     .c(c2[40]), .b(s2[41]), .a(s1[41]), .cout(co[41]), .sum(s3[41]));
mul_csa42  sc3_40_ ( .cin(co[39]), .d(c1[39]), .carry(c3[40]),
     .c(c2[39]), .b(s2[40]), .a(s1[40]), .cout(co[40]), .sum(s3[40]));
mul_csa42  sc3_39_ ( .cin(co[38]), .d(c1[38]), .carry(c3[39]),
     .c(c2[38]), .b(s2[39]), .a(s1[39]), .cout(co[39]), .sum(s3[39]));
mul_csa42  sc3_38_ ( .cin(co[37]), .d(c1[37]), .carry(c3[38]),
     .c(c2[37]), .b(s2[38]), .a(s1[38]), .cout(co[38]), .sum(s3[38]));
mul_csa42  sc3_37_ ( .cin(co[36]), .d(c1[36]), .carry(c3[37]),
     .c(c2[36]), .b(s2[37]), .a(s1[37]), .cout(co[37]), .sum(s3[37]));
mul_csa42  sc3_36_ ( .cin(co[35]), .d(c1[35]), .carry(c3[36]),
     .c(c2[35]), .b(s2[36]), .a(s1[36]), .cout(co[36]), .sum(s3[36]));
mul_csa42  sc3_35_ ( .cin(co[34]), .d(c1[34]), .carry(c3[35]),
     .c(c2[34]), .b(s2[35]), .a(s1[35]), .cout(co[35]), .sum(s3[35]));
mul_csa42  sc3_34_ ( .cin(co[33]), .d(c1[33]), .carry(c3[34]),
     .c(c2[33]), .b(s2[34]), .a(s1[34]), .cout(co[34]), .sum(s3[34]));
mul_csa42  sc3_33_ ( .cin(co[32]), .d(c1[32]), .carry(c3[33]),
     .c(c2[32]), .b(s2[33]), .a(s1[33]), .cout(co[33]), .sum(s3[33]));
mul_csa42  sc3_32_ ( .cin(co[31]), .d(c1[31]), .carry(c3[32]),
     .c(c2[31]), .b(s2[32]), .a(s1[32]), .cout(co[32]), .sum(s3[32]));
mul_csa42  sc3_31_ ( .cin(co[30]), .d(c1[30]), .carry(c3[31]),
     .c(c2[30]), .b(s2[31]), .a(s1[31]), .cout(co[31]), .sum(s3[31]));
mul_csa42  sc3_30_ ( .cin(co[29]), .d(c1[29]), .carry(c3[30]),
     .c(c2[29]), .b(s2[30]), .a(s1[30]), .cout(co[30]), .sum(s3[30]));
mul_csa42  sc3_29_ ( .cin(co[28]), .d(c1[28]), .carry(c3[29]),
     .c(c2[28]), .b(s2[29]), .a(s1[29]), .cout(co[29]), .sum(s3[29]));
mul_csa42  sc3_28_ ( .cin(co[27]), .d(c1[27]), .carry(c3[28]),
     .c(c2[27]), .b(s2[28]), .a(s1[28]), .cout(co[28]), .sum(s3[28]));
mul_csa42  sc3_27_ ( .cin(co[26]), .d(c1[26]), .carry(c3[27]),
     .c(c2[26]), .b(s2[27]), .a(s1[27]), .cout(co[27]), .sum(s3[27]));
mul_csa42  sc3_26_ ( .cin(co[25]), .d(c1[25]), .carry(c3[26]),
     .c(c2[25]), .b(s2[26]), .a(s1[26]), .cout(co[26]), .sum(s3[26]));
mul_csa42  sc3_25_ ( .cin(co[24]), .d(c1[24]), .carry(c3[25]),
     .c(c2[24]), .b(s2[25]), .a(s1[25]), .cout(co[25]), .sum(s3[25]));
mul_csa42  sc3_24_ ( .cin(co[23]), .d(c1[23]), .carry(c3[24]),
     .c(c2[23]), .b(s2[24]), .a(s1[24]), .cout(co[24]), .sum(s3[24]));
mul_csa42  sc3_23_ ( .cin(co[22]), .d(c1[22]), .carry(c3[23]),
     .c(c2[22]), .b(s2[23]), .a(s1[23]), .cout(co[23]), .sum(s3[23]));
mul_csa42  sc3_22_ ( .cin(co[21]), .d(c1[21]), .carry(c3[22]),
     .c(c2[21]), .b(s2[22]), .a(s1[22]), .cout(co[22]), .sum(s3[22]));
mul_csa42  sc3_21_ ( .cin(co[20]), .d(c1[20]), .carry(c3[21]),
     .c(c2[20]), .b(s2[21]), .a(s1[21]), .cout(co[21]), .sum(s3[21]));
mul_csa42  sc3_20_ ( .cin(1'b0), .d(c1[19]),
     .carry(c3[20]), .c(c2[19]), .b(s2[20]), .a(s1[20]), .cout(co[20]),
     .sum(s3[20]));
mul_csa32  sc4_82_ ( .c(c3[81]), .b(s2[82]), .a(ain[82]),
     .cout(pcout[82]), .sum(psum[82]));
mul_csa32  sc4_68_ ( .c(c3[67]), .b(s3[68]), .a(ain[68]),
     .cout(pcout[68]), .sum(psum[68]));
mul_csa32  sc4_67_ ( .c(c3[66]), .b(s3[67]), .a(ain[67]),
     .cout(pcout[67]), .sum(psum[67]));
mul_csa32  sc4_66_ ( .c(c3[65]), .b(s3[66]), .a(ain[66]),
     .cout(pcout[66]), .sum(psum[66]));
mul_csa32  sc4_65_ ( .c(c3[64]), .b(s3[65]), .a(ain[65]),
     .cout(pcout[65]), .sum(psum[65]));
mul_csa32  sc4_64_ ( .c(c3[63]), .b(s3[64]), .a(ain[64]),
     .cout(pcout[64]), .sum(psum[64]));
mul_csa32  sc4_63_ ( .c(c3[62]), .b(s3[63]), .a(ain[63]),
     .cout(pcout[63]), .sum(psum[63]));
mul_csa32  sc4_62_ ( .c(c3[61]), .b(s3[62]), .a(ain[62]),
     .cout(pcout[62]), .sum(psum[62]));
mul_csa32  sc4_61_ ( .c(c3[60]), .b(s3[61]), .a(ain[61]),
     .cout(pcout[61]), .sum(psum[61]));
mul_csa32  sc4_60_ ( .c(c3[59]), .b(s3[60]), .a(ain[60]),
     .cout(pcout[60]), .sum(psum[60]));
mul_csa32  sc4_59_ ( .c(c3[58]), .b(s3[59]), .a(ain[59]),
     .cout(pcout[59]), .sum(psum[59]));
mul_csa32  sc4_58_ ( .c(c3[57]), .b(s3[58]), .a(ain[58]),
     .cout(pcout[58]), .sum(psum[58]));
mul_csa32  sc4_57_ ( .c(c3[56]), .b(s3[57]), .a(ain[57]),
     .cout(pcout[57]), .sum(psum[57]));
mul_csa32  sc4_56_ ( .c(c3[55]), .b(s3[56]), .a(ain[56]),
     .cout(pcout[56]), .sum(psum[56]));
mul_csa32  sc4_55_ ( .c(c3[54]), .b(s3[55]), .a(ain[55]),
     .cout(pcout[55]), .sum(psum[55]));
mul_csa32  sc4_54_ ( .c(c3[53]), .b(s3[54]), .a(ain[54]),
     .cout(pcout[54]), .sum(psum[54]));
mul_csa32  sc4_53_ ( .c(c3[52]), .b(s3[53]), .a(ain[53]),
     .cout(pcout[53]), .sum(psum[53]));
mul_csa32  sc4_52_ ( .c(c3[51]), .b(s3[52]), .a(ain[52]),
     .cout(pcout[52]), .sum(psum[52]));
mul_csa32  sc4_51_ ( .c(c3[50]), .b(s3[51]), .a(ain[51]),
     .cout(pcout[51]), .sum(psum[51]));
mul_csa32  sc4_50_ ( .c(c3[49]), .b(s3[50]), .a(ain[50]),
     .cout(pcout[50]), .sum(psum[50]));
mul_csa32  sc4_49_ ( .c(c3[48]), .b(s3[49]), .a(ain[49]),
     .cout(pcout[49]), .sum(psum[49]));
mul_csa32  sc4_48_ ( .c(c3[47]), .b(s3[48]), .a(ain[48]),
     .cout(pcout[48]), .sum(psum[48]));
mul_csa32  sc4_47_ ( .c(c3[46]), .b(s3[47]), .a(ain[47]),
     .cout(pcout[47]), .sum(psum[47]));
mul_csa32  sc4_46_ ( .c(c3[45]), .b(s3[46]), .a(ain[46]),
     .cout(pcout[46]), .sum(psum[46]));
mul_csa32  sc4_45_ ( .c(c3[44]), .b(s3[45]), .a(ain[45]),
     .cout(pcout[45]), .sum(psum[45]));
mul_csa32  sc4_44_ ( .c(c3[43]), .b(s3[44]), .a(ain[44]),
     .cout(pcout[44]), .sum(psum[44]));
mul_csa32  sc4_43_ ( .c(c3[42]), .b(s3[43]), .a(ain[43]),
     .cout(pcout[43]), .sum(psum[43]));
mul_csa32  sc4_42_ ( .c(c3[41]), .b(s3[42]), .a(ain[42]),
     .cout(pcout[42]), .sum(psum[42]));
mul_csa32  sc4_41_ ( .c(c3[40]), .b(s3[41]), .a(ain[41]),
     .cout(pcout[41]), .sum(psum[41]));
mul_csa32  sc4_40_ ( .c(c3[39]), .b(s3[40]), .a(ain[40]),
     .cout(pcout[40]), .sum(psum[40]));
mul_csa32  sc4_39_ ( .c(c3[38]), .b(s3[39]), .a(ain[39]),
     .cout(pcout[39]), .sum(psum[39]));
mul_csa32  sc4_38_ ( .c(c3[37]), .b(s3[38]), .a(ain[38]),
     .cout(pcout[38]), .sum(psum[38]));
mul_csa32  sc4_37_ ( .c(c3[36]), .b(s3[37]), .a(ain[37]),
     .cout(pcout[37]), .sum(psum[37]));
mul_csa32  sc4_36_ ( .c(c3[35]), .b(s3[36]), .a(ain[36]),
     .cout(pcout[36]), .sum(psum[36]));
mul_csa32  sc4_35_ ( .c(c3[34]), .b(s3[35]), .a(ain[35]),
     .cout(pcout[35]), .sum(psum[35]));
mul_csa32  sc4_34_ ( .c(c3[33]), .b(s3[34]), .a(ain[34]),
     .cout(pcout[34]), .sum(psum[34]));
mul_csa32  sc4_33_ ( .c(c3[32]), .b(s3[33]), .a(ain[33]),
     .cout(pcout[33]), .sum(psum[33]));
mul_csa32  sc4_32_ ( .c(c3[31]), .b(s3[32]), .a(ain[32]),
     .cout(pcout[32]), .sum(psum[32]));
mul_csa32  sc4_31_ ( .c(c3[30]), .b(s3[31]), .a(ain[31]),
     .cout(pcout[31]), .sum(psum[31]));
mul_csa32  sc4_30_ ( .c(c3[29]), .b(s3[30]), .a(ain[30]),
     .cout(pcout[30]), .sum(psum[30]));
mul_csa32  sc4_29_ ( .c(c3[28]), .b(s3[29]), .a(ain[29]),
     .cout(pcout[29]), .sum(psum[29]));
mul_csa32  sc4_28_ ( .c(c3[27]), .b(s3[28]), .a(ain[28]),
     .cout(pcout[28]), .sum(psum[28]));
mul_csa32  sc4_27_ ( .c(c3[26]), .b(s3[27]), .a(ain[27]),
     .cout(pcout[27]), .sum(psum[27]));
mul_csa32  sc4_26_ ( .c(c3[25]), .b(s3[26]), .a(ain[26]),
     .cout(pcout[26]), .sum(psum[26]));
mul_csa32  sc4_25_ ( .c(c3[24]), .b(s3[25]), .a(ain[25]),
     .cout(pcout[25]), .sum(psum[25]));
mul_csa32  sc4_24_ ( .c(c3[23]), .b(s3[24]), .a(ain[24]),
     .cout(pcout[24]), .sum(psum[24]));
mul_csa32  sc4_23_ ( .c(c3[22]), .b(s3[23]), .a(ain[23]),
     .cout(pcout[23]), .sum(psum[23]));
mul_csa32  sc4_22_ ( .c(c3[21]), .b(s3[22]), .a(ain[22]),
     .cout(pcout[22]), .sum(psum[22]));
mul_csa32  sc4_21_ ( .c(c3[20]), .b(s3[21]), .a(ain[21]),
     .cout(pcout[21]), .sum(psum[21]));
mul_csa32  sc4_20_ ( .c(c3[19]), .b(s3[20]), .a(ain[20]),
     .cout(pcout[20]), .sum(psum[20]));
mul_csa32  sc4_96_ ( .c(c2[95]), .b(s2[96]), .a(ain[96]),
     .cout(pcout[96]), .sum(psum[96]));
mul_csa32  sc4_95_ ( .c(c2[94]), .b(s2[95]), .a(ain[95]),
     .cout(pcout[95]), .sum(psum[95]));
mul_csa32  sc4_94_ ( .c(c2[93]), .b(s2[94]), .a(ain[94]),
     .cout(pcout[94]), .sum(psum[94]));
mul_csa32  sc4_93_ ( .c(c2[92]), .b(s2[93]), .a(ain[93]),
     .cout(pcout[93]), .sum(psum[93]));
mul_csa32  sc4_92_ ( .c(c2[91]), .b(s2[92]), .a(ain[92]),
     .cout(pcout[92]), .sum(psum[92]));
mul_csa32  sc4_91_ ( .c(c2[90]), .b(s2[91]), .a(ain[91]),
     .cout(pcout[91]), .sum(psum[91]));
mul_csa32  sc4_90_ ( .c(c2[89]), .b(s2[90]), .a(ain[90]),
     .cout(pcout[90]), .sum(psum[90]));
mul_csa32  sc4_89_ ( .c(c2[88]), .b(s2[89]), .a(ain[89]),
     .cout(pcout[89]), .sum(psum[89]));
mul_csa32  sc4_88_ ( .c(c2[87]), .b(s2[88]), .a(ain[88]),
     .cout(pcout[88]), .sum(psum[88]));
mul_csa32  sc4_87_ ( .c(c2[86]), .b(s2[87]), .a(ain[87]),
     .cout(pcout[87]), .sum(psum[87]));
mul_csa32  sc4_86_ ( .c(c2[85]), .b(s2[86]), .a(ain[86]),
     .cout(pcout[86]), .sum(psum[86]));
mul_csa32  sc4_85_ ( .c(c2[84]), .b(s2[85]), .a(ain[85]),
     .cout(pcout[85]), .sum(psum[85]));
mul_csa32  sc4_84_ ( .c(c2[83]), .b(s2[84]), .a(ain[84]),
     .cout(pcout[84]), .sum(psum[84]));
mul_csa32  sc4_81_ ( .c(c3[80]), .b(s3[81]), .a(ain[81]),
     .cout(pcout[81]), .sum(psum[81]));
mul_csa32  sc4_80_ ( .c(c3[79]), .b(s3[80]), .a(ain[80]),
     .cout(pcout[80]), .sum(psum[80]));
mul_csa32  sc4_79_ ( .c(c3[78]), .b(s3[79]), .a(ain[79]),
     .cout(pcout[79]), .sum(psum[79]));
mul_csa32  sc4_78_ ( .c(c3[77]), .b(s3[78]), .a(ain[78]),
     .cout(pcout[78]), .sum(psum[78]));
mul_csa32  sc4_77_ ( .c(c3[76]), .b(s3[77]), .a(ain[77]),
     .cout(pcout[77]), .sum(psum[77]));
mul_csa32  sc4_76_ ( .c(c3[75]), .b(s3[76]), .a(ain[76]),
     .cout(pcout[76]), .sum(psum[76]));
mul_csa32  sc4_75_ ( .c(c3[74]), .b(s3[75]), .a(ain[75]),
     .cout(pcout[75]), .sum(psum[75]));
mul_csa32  sc4_74_ ( .c(c3[73]), .b(s3[74]), .a(ain[74]),
     .cout(pcout[74]), .sum(psum[74]));
mul_csa32  sc4_73_ ( .c(c3[72]), .b(s3[73]), .a(ain[73]),
     .cout(pcout[73]), .sum(psum[73]));
mul_csa32  sc4_72_ ( .c(c3[71]), .b(s3[72]), .a(ain[72]),
     .cout(pcout[72]), .sum(psum[72]));
mul_csa32  sc4_71_ ( .c(c3[70]), .b(s3[71]), .a(ain[71]),
     .cout(pcout[71]), .sum(psum[71]));
mul_csa32  sc4_70_ ( .c(c3[69]), .b(s3[70]), .a(ain[70]),
     .cout(pcout[70]), .sum(psum[70]));
mul_csa32  sc4_69_ ( .c(c3[68]), .b(s3[69]), .a(ain[69]),
     .cout(pcout[69]), .sum(psum[69]));
mul_csa32  acc_4_ ( .c(c2[3]), .sum(psum[4]), .cout(pcout[4]),
     .a(ain[4]), .b(s2[4]));
mul_csa32  acc_3_ ( .c(c2[2]), .sum(psum[3]), .cout(pcout[3]),
     .a(ain[3]), .b(s2[3]));
mul_csa32  acc_2_ ( .c(c2[1]), .sum(psum[2]), .cout(pcout[2]),
     .a(ain[2]), .b(s2[2]));
mul_csa32  acc_1_ ( .c(c2[0]), .sum(psum[1]), .cout(pcout[1]),
     .a(ain[1]), .b(s2[1]));
mul_csa32  sc3_97_ ( .c(c2[96]), .sum(psum[97]), .cout(pcout[97]),
     .a(a1s[81]), .b(a1c[80]));
mul_csa32  sc1_19_ ( .c(a1s[3]), .b(pc[50]), .a(ps[51]),
     .cout(c1[19]), .sum(s1[19]));
mul_csa32  sc1_18_ ( .c(a1s[2]), .b(pc[49]), .a(ps[50]),
     .cout(c1[18]), .sum(s1[18]));
mul_csa32  sc1_17_ ( .c(a1s[1]), .b(pc[48]), .a(ps[49]),
     .cout(c1[17]), .sum(s1[17]));
mul_csa32  sc1_16_ ( .c(a1s[0]), .b(pc[47]), .a(ps[48]),
     .cout(c1[16]), .sum(s1[16]));
mul_csa32  sc1_15_ ( .c(1'b0), .b(pc[46]), .a(ps[47]),
     .cout(c1[15]), .sum(s1[15]));
mul_csa32  sc4_83_ ( .c(c2[82]), .b(s2[83]), .a(ain[83]),
     .cout(pcout[83]), .sum(psum[83]));
mul_csa32  sc2_83_ ( .c(c1[82]), .b(a1c[66]), .a(a1s[67]),
     .cout(c2[83]), .sum(s2[83]));
mul_csa32  sc2_19_ ( .c(a0c[18]), .b(a0s[19]), .a(s1[19]),
     .cout(c2[19]), .sum(s2[19]));
mul_csa32  sc2_18_ ( .c(a0c[17]), .b(a0s[18]), .a(s1[18]),
     .cout(c2[18]), .sum(s2[18]));
mul_csa32  sc2_17_ ( .c(a0c[16]), .b(a0s[17]), .a(s1[17]),
     .cout(c2[17]), .sum(s2[17]));
mul_csa32  sc2_16_ ( .c(a0c[15]), .b(a0s[16]), .a(s1[16]),
     .cout(c2[16]), .sum(s2[16]));
mul_csa32  sc2_15_ ( .c(a0c[14]), .b(a0s[15]), .a(s1[15]),
     .cout(c2[15]), .sum(s2[15]));
mul_csa32  sc1_81_ ( .c(a0s[81]), .b(a1c[64]), .a(a1s[65]),
     .cout(c1[81]), .sum(s1[81]));
mul_csa32  sc1_80_ ( .c(a0s[80]), .b(a1c[63]), .a(a1s[64]),
     .cout(c1[80]), .sum(s1[80]));
mul_csa32  sc1_79_ ( .c(a0s[79]), .b(a1c[62]), .a(a1s[63]),
     .cout(c1[79]), .sum(s1[79]));
mul_csa32  sc1_78_ ( .c(a0s[78]), .b(a1c[61]), .a(a1s[62]),
     .cout(c1[78]), .sum(s1[78]));
mul_csa32  sc1_77_ ( .c(a0s[77]), .b(a1c[60]), .a(a1s[61]),
     .cout(c1[77]), .sum(s1[77]));
mul_csa32  sc1_76_ ( .c(a0s[76]), .b(a1c[59]), .a(a1s[60]),
     .cout(c1[76]), .sum(s1[76]));
mul_csa32  sc1_75_ ( .c(a0s[75]), .b(a1c[58]), .a(a1s[59]),
     .cout(c1[75]), .sum(s1[75]));
mul_csa32  sc1_74_ ( .c(a0s[74]), .b(a1c[57]), .a(a1s[58]),
     .cout(c1[74]), .sum(s1[74]));
mul_csa32  sc1_73_ ( .c(a0s[73]), .b(a1c[56]), .a(a1s[57]),
     .cout(c1[73]), .sum(s1[73]));
mul_csa32  sc1_72_ ( .c(a0s[72]), .b(a1c[55]), .a(a1s[56]),
     .cout(c1[72]), .sum(s1[72]));
mul_csa32  sc1_71_ ( .c(a0s[71]), .b(a1c[54]), .a(a1s[55]),
     .cout(c1[71]), .sum(s1[71]));
mul_csa32  sc1_70_ ( .c(a0s[70]), .b(a1c[53]), .a(a1s[54]),
     .cout(c1[70]), .sum(s1[70]));
mul_csa32  sc1_69_ ( .c(a0s[69]), .b(a1c[52]), .a(a1s[53]),
     .cout(c1[69]), .sum(s1[69]));
mul_csa32  sc1_68_ ( .c(a0s[68]), .b(a1c[51]), .a(a1s[52]),
     .cout(c1[68]), .sum(s1[68]));
mul_csa32  sc3_19_ ( .c(c2[18]), .b(c1[18]), .a(s2[19]),
     .cout(c3[19]), .sum(s3[19]));
mul_csa32  sc3_18_ ( .c(c2[17]), .b(c1[17]), .a(s2[18]),
     .cout(c3[18]), .sum(s3[18]));
mul_csa32  sc3_17_ ( .c(c2[16]), .b(c1[16]), .a(s2[17]),
     .cout(c3[17]), .sum(s3[17]));
mul_csa32  sc3_16_ ( .c(c2[15]), .b(c1[15]), .a(s2[16]),
     .cout(c3[16]), .sum(s3[16]));
mul_csa32  sc3_15_ ( .c(c2[14]), .b(c1[14]), .a(s2[15]),
     .cout(c3[15]), .sum(s3[15]));
mul_csa32  sc1_82_ ( .c(a0c[81]), .b(a1c[65]), .a(a1s[66]),
     .cout(c1[82]), .sum(s1[82]));
mul_csa32  acc_14_ ( .c(c2[13]), .sum(psum[14]), .cout(pcout[14]),
     .a(ain[14]), .b(s2[14]));
mul_csa32  acc_13_ ( .c(c2[12]), .sum(psum[13]), .cout(pcout[13]),
     .a(ain[13]), .b(s2[13]));
mul_csa32  acc_12_ ( .c(c2[11]), .sum(psum[12]), .cout(pcout[12]),
     .a(ain[12]), .b(s2[12]));
mul_csa32  acc_11_ ( .c(c2[10]), .sum(psum[11]), .cout(pcout[11]),
     .a(ain[11]), .b(s2[11]));
mul_csa32  acc_10_ ( .c(c2[9]), .sum(psum[10]), .cout(pcout[10]),
     .a(ain[10]), .b(s2[10]));
mul_csa32  acc_9_ ( .c(c2[8]), .sum(psum[9]), .cout(pcout[9]),
     .a(ain[9]), .b(s2[9]));
mul_csa32  acc_8_ ( .c(c2[7]), .sum(psum[8]), .cout(pcout[8]),
     .a(ain[8]), .b(s2[8]));
mul_csa32  acc_7_ ( .c(c2[6]), .sum(psum[7]), .cout(pcout[7]),
     .a(ain[7]), .b(s2[7]));
mul_csa32  acc_6_ ( .c(c2[5]), .sum(psum[6]), .cout(pcout[6]),
     .a(ain[6]), .b(s2[6]));
mul_csa32  acc_5_ ( .c(c2[4]), .sum(psum[5]), .cout(pcout[5]),
     .a(ain[5]), .b(s2[5]));
mul_csa32  sc2_67_ ( .c(a0c[66]), .b(c1[66]), .a(a0s[67]),
     .cout(c2[67]), .sum(s2[67]));
mul_csa32  sc1_14_ ( .c(a0s[14]), .b(pc[45]), .a(ps[46]),
     .cout(c1[14]), .sum(s1[14]));
mul_csa32  sc1_13_ ( .c(a0s[13]), .b(pc[44]), .a(ps[45]),
     .cout(c1[13]), .sum(s1[13]));
mul_csa32  sc1_12_ ( .c(a0s[12]), .b(pc[43]), .a(ps[44]),
     .cout(c1[12]), .sum(s1[12]));
mul_csa32  sc1_11_ ( .c(a0s[11]), .b(pc[42]), .a(ps[43]),
     .cout(c1[11]), .sum(s1[11]));
mul_csa32  sc1_10_ ( .c(a0s[10]), .b(pc[41]), .a(ps[42]),
     .cout(c1[10]), .sum(s1[10]));
mul_csa32  sc1_9_ ( .c(a0s[9]), .b(pc[40]), .a(ps[41]), .cout(c1[9]),
     .sum(s1[9]));
mul_csa32  sc1_8_ ( .c(a0s[8]), .b(pc[39]), .a(ps[40]), .cout(c1[8]),
     .sum(s1[8]));
mul_csa32  sc1_7_ ( .c(a0s[7]), .b(pc[38]), .a(ps[39]), .cout(c1[7]),
     .sum(s1[7]));
mul_csa32  sc1_6_ ( .c(a0s[6]), .b(pc[37]), .a(ps[38]), .cout(c1[6]),
     .sum(s1[6]));
mul_csa32  sc1_5_ ( .c(a0s[5]), .b(pc[36]), .a(ps[37]), .cout(c1[5]),
     .sum(s1[5]));
mul_csa32  sc2_14_ ( .c(a0c[13]), .b(c1[13]), .a(s1[14]),
     .cout(c2[14]), .sum(s2[14]));
mul_csa32  sc2_13_ ( .c(a0c[12]), .b(c1[12]), .a(s1[13]),
     .cout(c2[13]), .sum(s2[13]));
mul_csa32  sc2_12_ ( .c(a0c[11]), .b(c1[11]), .a(s1[12]),
     .cout(c2[12]), .sum(s2[12]));
mul_csa32  sc2_11_ ( .c(a0c[10]), .b(c1[10]), .a(s1[11]),
     .cout(c2[11]), .sum(s2[11]));
mul_csa32  sc2_10_ ( .c(a0c[9]), .b(c1[9]), .a(s1[10]),
     .cout(c2[10]), .sum(s2[10]));
mul_csa32  sc2_9_ ( .c(a0c[8]), .b(c1[8]), .a(s1[9]), .cout(c2[9]),
     .sum(s2[9]));
mul_csa32  sc2_8_ ( .c(a0c[7]), .b(c1[7]), .a(s1[8]), .cout(c2[8]),
     .sum(s2[8]));
mul_csa32  sc2_7_ ( .c(a0c[6]), .b(c1[6]), .a(s1[7]), .cout(c2[7]),
     .sum(s2[7]));
mul_csa32  sc2_6_ ( .c(a0c[5]), .b(c1[5]), .a(s1[6]), .cout(c2[6]),
     .sum(s2[6]));
mul_csa32  sc2_5_ ( .c(a0c[4]), .b(c1[4]), .a(s1[5]), .cout(c2[5]),
     .sum(s2[5]));
mul_csa32  sc2_82_ ( .c(c2[81]), .b(c1[81]), .a(s1[82]),
     .cout(c2[82]), .sum(s2[82]));
mul_csa32  sc1_4_ ( .c(a0s[4]), .b(pc[35]), .a(ps[36]), .cout(c1[4]),
     .sum(s1[4]));
mul_csa32  sc1_3_ ( .c(a0s[3]), .b(pc[34]), .a(ps[35]), .cout(c1[3]),
     .sum(s1[3]));
mul_csa32  sc1_2_ ( .c(a0s[2]), .b(pc[33]), .a(ps[34]), .cout(c1[2]),
     .sum(s1[2]));
mul_csa32  sc1_1_ ( .c(a0s[1]), .b(pc[32]), .a(ps[33]), .cout(c1[1]),
     .sum(s1[1]));
mul_csa32  sc2_66_ ( .c(a0c[65]), .b(a0s[66]), .a(a1c[49]),
     .cout(c2[66]), .sum(s2[66]));
mul_csa32  sc2_65_ ( .c(a0c[64]), .b(a0s[65]), .a(a1c[48]),
     .cout(c2[65]), .sum(s2[65]));
mul_csa32  sc2_64_ ( .c(a0c[63]), .b(a0s[64]), .a(a1c[47]),
     .cout(c2[64]), .sum(s2[64]));
mul_csa32  sc2_63_ ( .c(a0c[62]), .b(a0s[63]), .a(a1c[46]),
     .cout(c2[63]), .sum(s2[63]));
mul_csa32  sc2_62_ ( .c(a0c[61]), .b(a0s[62]), .a(a1c[45]),
     .cout(c2[62]), .sum(s2[62]));
mul_csa32  sc2_61_ ( .c(a0c[60]), .b(a0s[61]), .a(a1c[44]),
     .cout(c2[61]), .sum(s2[61]));
mul_csa32  sc2_60_ ( .c(a0c[59]), .b(a0s[60]), .a(a1c[43]),
     .cout(c2[60]), .sum(s2[60]));
mul_csa32  sc2_59_ ( .c(a0c[58]), .b(a0s[59]), .a(a1c[42]),
     .cout(c2[59]), .sum(s2[59]));
mul_csa32  sc2_58_ ( .c(a0c[57]), .b(a0s[58]), .a(a1c[41]),
     .cout(c2[58]), .sum(s2[58]));
mul_csa32  sc2_57_ ( .c(a0c[56]), .b(a0s[57]), .a(a1c[40]),
     .cout(c2[57]), .sum(s2[57]));
mul_csa32  sc2_56_ ( .c(a0c[55]), .b(a0s[56]), .a(a1c[39]),
     .cout(c2[56]), .sum(s2[56]));
mul_csa32  sc2_55_ ( .c(a0c[54]), .b(a0s[55]), .a(a1c[38]),
     .cout(c2[55]), .sum(s2[55]));
mul_csa32  sc2_54_ ( .c(a0c[53]), .b(a0s[54]), .a(a1c[37]),
     .cout(c2[54]), .sum(s2[54]));
mul_csa32  sc2_53_ ( .c(a0c[52]), .b(a0s[53]), .a(a1c[36]),
     .cout(c2[53]), .sum(s2[53]));
mul_csa32  sc2_52_ ( .c(a0c[51]), .b(a0s[52]), .a(a1c[35]),
     .cout(c2[52]), .sum(s2[52]));
mul_csa32  sc2_51_ ( .c(a0c[50]), .b(a0s[51]), .a(a1c[34]),
     .cout(c2[51]), .sum(s2[51]));
mul_csa32  sc2_50_ ( .c(a0c[49]), .b(a0s[50]), .a(a1c[33]),
     .cout(c2[50]), .sum(s2[50]));
mul_csa32  sc2_49_ ( .c(a0c[48]), .b(a0s[49]), .a(a1c[32]),
     .cout(c2[49]), .sum(s2[49]));
mul_csa32  sc2_48_ ( .c(a0c[47]), .b(a0s[48]), .a(a1c[31]),
     .cout(c2[48]), .sum(s2[48]));
mul_csa32  sc2_47_ ( .c(a0c[46]), .b(a0s[47]), .a(a1c[30]),
     .cout(c2[47]), .sum(s2[47]));
mul_csa32  sc2_46_ ( .c(a0c[45]), .b(a0s[46]), .a(a1c[29]),
     .cout(c2[46]), .sum(s2[46]));
mul_csa32  sc2_45_ ( .c(a0c[44]), .b(a0s[45]), .a(a1c[28]),
     .cout(c2[45]), .sum(s2[45]));
mul_csa32  sc2_44_ ( .c(a0c[43]), .b(a0s[44]), .a(a1c[27]),
     .cout(c2[44]), .sum(s2[44]));
mul_csa32  sc2_43_ ( .c(a0c[42]), .b(a0s[43]), .a(a1c[26]),
     .cout(c2[43]), .sum(s2[43]));
mul_csa32  sc2_42_ ( .c(a0c[41]), .b(a0s[42]), .a(a1c[25]),
     .cout(c2[42]), .sum(s2[42]));
mul_csa32  sc2_41_ ( .c(a0c[40]), .b(a0s[41]), .a(a1c[24]),
     .cout(c2[41]), .sum(s2[41]));
mul_csa32  sc2_40_ ( .c(a0c[39]), .b(a0s[40]), .a(a1c[23]),
     .cout(c2[40]), .sum(s2[40]));
mul_csa32  sc2_39_ ( .c(a0c[38]), .b(a0s[39]), .a(a1c[22]),
     .cout(c2[39]), .sum(s2[39]));
mul_csa32  sc2_38_ ( .c(a0c[37]), .b(a0s[38]), .a(a1c[21]),
     .cout(c2[38]), .sum(s2[38]));
mul_csa32  sc2_37_ ( .c(a0c[36]), .b(a0s[37]), .a(a1c[20]),
     .cout(c2[37]), .sum(s2[37]));
mul_csa32  sc2_36_ ( .c(a0c[35]), .b(a0s[36]), .a(a1c[19]),
     .cout(c2[36]), .sum(s2[36]));
mul_csa32  sc2_35_ ( .c(a0c[34]), .b(a0s[35]), .a(a1c[18]),
     .cout(c2[35]), .sum(s2[35]));
mul_csa32  sc2_34_ ( .c(a0c[33]), .b(a0s[34]), .a(a1c[17]),
     .cout(c2[34]), .sum(s2[34]));
mul_csa32  sc2_33_ ( .c(a0c[32]), .b(a0s[33]), .a(a1c[16]),
     .cout(c2[33]), .sum(s2[33]));
mul_csa32  sc2_32_ ( .c(a0c[31]), .b(a0s[32]), .a(a1c[15]),
     .cout(c2[32]), .sum(s2[32]));
mul_csa32  sc2_31_ ( .c(a0c[30]), .b(a0s[31]), .a(a1c[14]),
     .cout(c2[31]), .sum(s2[31]));
mul_csa32  sc2_30_ ( .c(a0c[29]), .b(a0s[30]), .a(a1c[13]),
     .cout(c2[30]), .sum(s2[30]));
mul_csa32  sc2_29_ ( .c(a0c[28]), .b(a0s[29]), .a(a1c[12]),
     .cout(c2[29]), .sum(s2[29]));
mul_csa32  sc2_28_ ( .c(a0c[27]), .b(a0s[28]), .a(a1c[11]),
     .cout(c2[28]), .sum(s2[28]));
mul_csa32  sc2_27_ ( .c(a0c[26]), .b(a0s[27]), .a(a1c[10]),
     .cout(c2[27]), .sum(s2[27]));
mul_csa32  sc2_26_ ( .c(a0c[25]), .b(a0s[26]), .a(a1c[9]),
     .cout(c2[26]), .sum(s2[26]));
mul_csa32  sc2_25_ ( .c(a0c[24]), .b(a0s[25]), .a(a1c[8]),
     .cout(c2[25]), .sum(s2[25]));
mul_csa32  sc2_24_ ( .c(a0c[23]), .b(a0s[24]), .a(a1c[7]),
     .cout(c2[24]), .sum(s2[24]));
mul_csa32  sc2_23_ ( .c(a0c[22]), .b(a0s[23]), .a(a1c[6]),
     .cout(c2[23]), .sum(s2[23]));
mul_csa32  sc2_22_ ( .c(a0c[21]), .b(a0s[22]), .a(a1c[5]),
     .cout(c2[22]), .sum(s2[22]));
mul_csa32  sc2_21_ ( .c(a0c[20]), .b(a0s[21]), .a(a1c[4]),
     .cout(c2[21]), .sum(s2[21]));
mul_csa32  sc2_20_ ( .c(a0c[19]), .b(a0s[20]), .a(1'b0),
     .cout(c2[20]), .sum(s2[20]));
mul_csa32  sc1_66_ ( .c(a1s[50]), .b(pc[97]), .a(ps[98]),
     .cout(c1[66]), .sum(s1[66]));
mul_csa32  sc1_65_ ( .c(a1s[49]), .b(pc[96]), .a(ps[97]),
     .cout(c1[65]), .sum(s1[65]));
mul_csa32  sc1_64_ ( .c(a1s[48]), .b(pc[95]), .a(ps[96]),
     .cout(c1[64]), .sum(s1[64]));
mul_csa32  sc1_63_ ( .c(a1s[47]), .b(pc[94]), .a(ps[95]),
     .cout(c1[63]), .sum(s1[63]));
mul_csa32  sc1_62_ ( .c(a1s[46]), .b(pc[93]), .a(ps[94]),
     .cout(c1[62]), .sum(s1[62]));
mul_csa32  sc1_61_ ( .c(a1s[45]), .b(pc[92]), .a(ps[93]),
     .cout(c1[61]), .sum(s1[61]));
mul_csa32  sc1_60_ ( .c(a1s[44]), .b(pc[91]), .a(ps[92]),
     .cout(c1[60]), .sum(s1[60]));
mul_csa32  sc1_59_ ( .c(a1s[43]), .b(pc[90]), .a(ps[91]),
     .cout(c1[59]), .sum(s1[59]));
mul_csa32  sc1_58_ ( .c(a1s[42]), .b(pc[89]), .a(ps[90]),
     .cout(c1[58]), .sum(s1[58]));
mul_csa32  sc1_57_ ( .c(a1s[41]), .b(pc[88]), .a(ps[89]),
     .cout(c1[57]), .sum(s1[57]));
mul_csa32  sc1_56_ ( .c(a1s[40]), .b(pc[87]), .a(ps[88]),
     .cout(c1[56]), .sum(s1[56]));
mul_csa32  sc1_55_ ( .c(a1s[39]), .b(pc[86]), .a(ps[87]),
     .cout(c1[55]), .sum(s1[55]));
mul_csa32  sc1_54_ ( .c(a1s[38]), .b(pc[85]), .a(ps[86]),
     .cout(c1[54]), .sum(s1[54]));
mul_csa32  sc1_53_ ( .c(a1s[37]), .b(pc[84]), .a(ps[85]),
     .cout(c1[53]), .sum(s1[53]));
mul_csa32  sc1_52_ ( .c(a1s[36]), .b(pc[83]), .a(ps[84]),
     .cout(c1[52]), .sum(s1[52]));
mul_csa32  sc1_51_ ( .c(a1s[35]), .b(pc[82]), .a(ps[83]),
     .cout(c1[51]), .sum(s1[51]));
mul_csa32  sc1_50_ ( .c(a1s[34]), .b(pc[81]), .a(ps[82]),
     .cout(c1[50]), .sum(s1[50]));
mul_csa32  sc1_49_ ( .c(a1s[33]), .b(pc[80]), .a(ps[81]),
     .cout(c1[49]), .sum(s1[49]));
mul_csa32  sc1_48_ ( .c(a1s[32]), .b(pc[79]), .a(ps[80]),
     .cout(c1[48]), .sum(s1[48]));
mul_csa32  sc1_47_ ( .c(a1s[31]), .b(pc[78]), .a(ps[79]),
     .cout(c1[47]), .sum(s1[47]));
mul_csa32  sc1_46_ ( .c(a1s[30]), .b(pc[77]), .a(ps[78]),
     .cout(c1[46]), .sum(s1[46]));
mul_csa32  sc1_45_ ( .c(a1s[29]), .b(pc[76]), .a(ps[77]),
     .cout(c1[45]), .sum(s1[45]));
mul_csa32  sc1_44_ ( .c(a1s[28]), .b(pc[75]), .a(ps[76]),
     .cout(c1[44]), .sum(s1[44]));
mul_csa32  sc1_43_ ( .c(a1s[27]), .b(pc[74]), .a(ps[75]),
     .cout(c1[43]), .sum(s1[43]));
mul_csa32  sc1_42_ ( .c(a1s[26]), .b(pc[73]), .a(ps[74]),
     .cout(c1[42]), .sum(s1[42]));
mul_csa32  sc1_41_ ( .c(a1s[25]), .b(pc[72]), .a(ps[73]),
     .cout(c1[41]), .sum(s1[41]));
mul_csa32  sc1_40_ ( .c(a1s[24]), .b(pc[71]), .a(ps[72]),
     .cout(c1[40]), .sum(s1[40]));
mul_csa32  sc1_39_ ( .c(a1s[23]), .b(pc[70]), .a(ps[71]),
     .cout(c1[39]), .sum(s1[39]));
mul_csa32  sc1_38_ ( .c(a1s[22]), .b(pc[69]), .a(ps[70]),
     .cout(c1[38]), .sum(s1[38]));
mul_csa32  sc1_37_ ( .c(a1s[21]), .b(pc[68]), .a(ps[69]),
     .cout(c1[37]), .sum(s1[37]));
mul_csa32  sc1_36_ ( .c(a1s[20]), .b(pc[67]), .a(ps[68]),
     .cout(c1[36]), .sum(s1[36]));
mul_csa32  sc1_35_ ( .c(a1s[19]), .b(pc[66]), .a(ps[67]),
     .cout(c1[35]), .sum(s1[35]));
mul_csa32  sc1_34_ ( .c(a1s[18]), .b(pc[65]), .a(ps[66]),
     .cout(c1[34]), .sum(s1[34]));
mul_csa32  sc1_33_ ( .c(a1s[17]), .b(pc[64]), .a(ps[65]),
     .cout(c1[33]), .sum(s1[33]));
mul_csa32  sc1_32_ ( .c(a1s[16]), .b(pc[63]), .a(ps[64]),
     .cout(c1[32]), .sum(s1[32]));
mul_csa32  sc1_31_ ( .c(a1s[15]), .b(pc[62]), .a(ps[63]),
     .cout(c1[31]), .sum(s1[31]));
mul_csa32  sc1_30_ ( .c(a1s[14]), .b(pc[61]), .a(ps[62]),
     .cout(c1[30]), .sum(s1[30]));
mul_csa32  sc1_29_ ( .c(a1s[13]), .b(pc[60]), .a(ps[61]),
     .cout(c1[29]), .sum(s1[29]));
mul_csa32  sc1_28_ ( .c(a1s[12]), .b(pc[59]), .a(ps[60]),
     .cout(c1[28]), .sum(s1[28]));
mul_csa32  sc1_27_ ( .c(a1s[11]), .b(pc[58]), .a(ps[59]),
     .cout(c1[27]), .sum(s1[27]));
mul_csa32  sc1_26_ ( .c(a1s[10]), .b(pc[57]), .a(ps[58]),
     .cout(c1[26]), .sum(s1[26]));
mul_csa32  sc1_25_ ( .c(a1s[9]), .b(pc[56]), .a(ps[57]),
     .cout(c1[25]), .sum(s1[25]));
mul_csa32  sc1_24_ ( .c(a1s[8]), .b(pc[55]), .a(ps[56]),
     .cout(c1[24]), .sum(s1[24]));
mul_csa32  sc1_23_ ( .c(a1s[7]), .b(pc[54]), .a(ps[55]),
     .cout(c1[23]), .sum(s1[23]));
mul_csa32  sc1_22_ ( .c(a1s[6]), .b(pc[53]), .a(ps[54]),
     .cout(c1[22]), .sum(s1[22]));
mul_csa32  sc1_21_ ( .c(a1s[5]), .b(pc[52]), .a(ps[53]),
     .cout(c1[21]), .sum(s1[21]));
mul_csa32  sc1_20_ ( .c(a1s[4]), .b(pc[51]), .a(ps[52]),
     .cout(c1[20]), .sum(s1[20]));
mul_csa32  sc2_81_ ( .c(a0c[80]), .b(c1[80]), .a(s1[81]),
     .cout(c2[81]), .sum(s2[81]));
mul_csa32  sc2_80_ ( .c(a0c[79]), .b(c1[79]), .a(s1[80]),
     .cout(c2[80]), .sum(s2[80]));
mul_csa32  sc2_79_ ( .c(a0c[78]), .b(c1[78]), .a(s1[79]),
     .cout(c2[79]), .sum(s2[79]));
mul_csa32  sc2_78_ ( .c(a0c[77]), .b(c1[77]), .a(s1[78]),
     .cout(c2[78]), .sum(s2[78]));
mul_csa32  sc2_77_ ( .c(a0c[76]), .b(c1[76]), .a(s1[77]),
     .cout(c2[77]), .sum(s2[77]));
mul_csa32  sc2_76_ ( .c(a0c[75]), .b(c1[75]), .a(s1[76]),
     .cout(c2[76]), .sum(s2[76]));
mul_csa32  sc2_75_ ( .c(a0c[74]), .b(c1[74]), .a(s1[75]),
     .cout(c2[75]), .sum(s2[75]));
mul_csa32  sc2_74_ ( .c(a0c[73]), .b(c1[73]), .a(s1[74]),
     .cout(c2[74]), .sum(s2[74]));
mul_csa32  sc2_73_ ( .c(a0c[72]), .b(c1[72]), .a(s1[73]),
     .cout(c2[73]), .sum(s2[73]));
mul_csa32  sc2_72_ ( .c(a0c[71]), .b(c1[71]), .a(s1[72]),
     .cout(c2[72]), .sum(s2[72]));
mul_csa32  sc2_71_ ( .c(a0c[70]), .b(c1[70]), .a(s1[71]),
     .cout(c2[71]), .sum(s2[71]));
mul_csa32  sc2_70_ ( .c(a0c[69]), .b(c1[69]), .a(s1[70]),
     .cout(c2[70]), .sum(s2[70]));
mul_csa32  sc2_69_ ( .c(a0c[68]), .b(c1[68]), .a(s1[69]),
     .cout(c2[69]), .sum(s2[69]));
mul_csa32  sc2_68_ ( .c(a0c[67]), .b(c1[67]), .a(s1[68]),
     .cout(c2[68]), .sum(s2[68]));
mul_csa32  acc_19_ ( .c(c3[18]), .b(s3[19]), .a(ain[19]),
     .cout(pcout[19]), .sum(psum[19]));
mul_csa32  acc_18_ ( .c(c3[17]), .b(s3[18]), .a(ain[18]),
     .cout(pcout[18]), .sum(psum[18]));
mul_csa32  acc_17_ ( .c(c3[16]), .b(s3[17]), .a(ain[17]),
     .cout(pcout[17]), .sum(psum[17]));
mul_csa32  acc_16_ ( .c(c3[15]), .b(s3[16]), .a(ain[16]),
     .cout(pcout[16]), .sum(psum[16]));
mul_csa32  acc_15_ ( .c(1'b0), .b(s3[15]), .a(ain[15]),
     .cout(pcout[15]), .sum(psum[15]));
mul_csa32  sc1_0_ ( .c(a0s[0]), .sum(s1[0]), .cout(c1[0]),
     .a(ps[32]), .b(pc[31]));
mul_csa32  sc1_67_ ( .c(a1c[50]), .b(pc[98]), .a(a1s[51]),
     .cout(c1[67]), .sum(s1[67]));
mul_ha acc_0_ ( .sum(psum[0]), .cout(pcout[0]), .a(ain[0]),
     .b(s2[0]));
mul_ha sc3_98_ ( .sum(psum[98]), .cout(pcout[98]), .a(bot),
     .b(a1c[81]));
mul_ha sc2_96_ ( .b(a1c[79]), .a(a1s[80]), .cout(c2[96]),
     .sum(s2[96]));
mul_ha sc2_95_ ( .b(a1c[78]), .a(a1s[79]), .cout(c2[95]),
     .sum(s2[95]));
mul_ha sc2_94_ ( .b(a1c[77]), .a(a1s[78]), .cout(c2[94]),
     .sum(s2[94]));
mul_ha sc2_93_ ( .b(a1c[76]), .a(a1s[77]), .cout(c2[93]),
     .sum(s2[93]));
mul_ha sc2_92_ ( .b(a1c[75]), .a(a1s[76]), .cout(c2[92]),
     .sum(s2[92]));
mul_ha sc2_91_ ( .b(a1c[74]), .a(a1s[75]), .cout(c2[91]),
     .sum(s2[91]));
mul_ha sc2_90_ ( .b(a1c[73]), .a(a1s[74]), .cout(c2[90]),
     .sum(s2[90]));
mul_ha sc2_89_ ( .b(a1c[72]), .a(a1s[73]), .cout(c2[89]),
     .sum(s2[89]));
mul_ha sc2_88_ ( .b(a1c[71]), .a(a1s[72]), .cout(c2[88]),
     .sum(s2[88]));
mul_ha sc2_87_ ( .b(a1c[70]), .a(a1s[71]), .cout(c2[87]),
     .sum(s2[87]));
mul_ha sc2_86_ ( .b(a1c[69]), .a(a1s[70]), .cout(c2[86]),
     .sum(s2[86]));
mul_ha sc2_85_ ( .b(a1c[68]), .a(a1s[69]), .cout(c2[85]),
     .sum(s2[85]));
mul_ha sc2_84_ ( .b(a1c[67]), .a(a1s[68]), .cout(c2[84]),
     .sum(s2[84]));
mul_ha sc3_81_ ( .b(c2[80]), .a(s2[81]), .cout(c3[81]),
     .sum(s3[81]));
mul_ha sc3_80_ ( .b(c2[79]), .a(s2[80]), .cout(c3[80]),
     .sum(s3[80]));
mul_ha sc3_79_ ( .b(c2[78]), .a(s2[79]), .cout(c3[79]),
     .sum(s3[79]));
mul_ha sc3_78_ ( .b(c2[77]), .a(s2[78]), .cout(c3[78]),
     .sum(s3[78]));
mul_ha sc3_77_ ( .b(c2[76]), .a(s2[77]), .cout(c3[77]),
     .sum(s3[77]));
mul_ha sc3_76_ ( .b(c2[75]), .a(s2[76]), .cout(c3[76]),
     .sum(s3[76]));
mul_ha sc3_75_ ( .b(c2[74]), .a(s2[75]), .cout(c3[75]),
     .sum(s3[75]));
mul_ha sc3_74_ ( .b(c2[73]), .a(s2[74]), .cout(c3[74]),
     .sum(s3[74]));
mul_ha sc3_73_ ( .b(c2[72]), .a(s2[73]), .cout(c3[73]),
     .sum(s3[73]));
mul_ha sc3_72_ ( .b(c2[71]), .a(s2[72]), .cout(c3[72]),
     .sum(s3[72]));
mul_ha sc3_71_ ( .b(c2[70]), .a(s2[71]), .cout(c3[71]),
     .sum(s3[71]));
mul_ha sc3_70_ ( .b(c2[69]), .a(s2[70]), .cout(c3[70]),
     .sum(s3[70]));
mul_ha sc3_69_ ( .b(c2[68]), .a(s2[69]), .cout(c3[69]),
     .sum(s3[69]));
mul_ha accx2 ( .sum(psumx2), .cout(pcoutx2), .a(ainx2), .b(s1x2));
mul_ha sc2_4_ ( .sum(s2[4]), .cout(c2[4]), .a(s1[4]), .b(c1[3]));
mul_ha sc2_3_ ( .sum(s2[3]), .cout(c2[3]), .a(s1[3]), .b(c1[2]));
mul_ha sc2_2_ ( .sum(s2[2]), .cout(c2[2]), .a(s1[2]), .b(c1[1]));
mul_ha sc2_1_ ( .sum(s2[1]), .cout(c2[1]), .a(s1[1]), .b(c1[0]));
mul_ha sc2_0_ ( .sum(s2[0]), .cout(c2[0]), .a(s1[0]), .b(c1x2));
mul_ha sc1x2 ( .sum(s1x2), .cout(c1x2), .a(ps[31]), .b(pc[30]));

endmodule //mul_array2

module mul_csa32 (sum, cout, a, b, c);

output sum, cout;
input a, b, c;

wire x, y0, y1, y2;

assign x = a ^ b;
assign sum = c ^ x;

assign y0 = a & b ;
assign y1 = a & c ;
assign y2 = b & c ;

assign cout = y0 | y1 | y2 ;

endmodule //mul_csa32

module mul_csa42 (sum, carry, cout, a, b, c, d, cin);

output sum, carry, cout;
input a, b, c, d, cin;

wire x, y, z;

assign x = a ^ b;
assign y = c ^ d;
assign z = x ^ y;

assign sum = z ^ cin ;

assign carry = (b & ~z) | (cin & z);

assign cout = (d & ~y) | (a & y);

endmodule // mul_csa42

module mul_ha ( cout, sum, a, b );
output  cout, sum;
input  a, b;

assign sum = a ^ b;
assign cout = a & b ;

endmodule //mul_ha

module mul_negen ( n0, n1, b );
output  n0, n1;
input [2:0]  b;

assign n0 = b[2] & b[1] & ~b[0] ;
assign n1 = b[2] & b[1] & b[0] ;

endmodule //mul_negen

module mul_ppgen3lsb4 (cout, p0_l, p1_l, sum, a, b0, b1 );

output  p0_l, p1_l;
output [3:0]  sum;
output [3:1]  cout;
input [3:0]  a;
input [2:0]  b0;
input [2:0]  b1;

wire b0n, b0n_0, b0n_1, b1n_0, b1n_1;
wire p0_0, p0_1, p0_2, p0_3, p1_2, p1_3;
wire p0_l_0, p0_l_1, p0_l_2, p1_l_2;

assign b0n = b0n_1 | (b0n_0 & p0_0) ;
assign sum[0] = b0n_0 ^ p0_0 ;

mul_negen p0n ( .b(b0[2:0]), .n1(b0n_1), .n0(b0n_0));
mul_negen p1n ( .b(b1[2:0]), .n1(b1n_1), .n0(b1n_0));
mul_csa32  sc1_2_ ( .c(b1n_0), .sum(sum[2]), .cout(cout[2]),
     .a(p0_2), .b(p1_2));
mul_csa32  sc1_3_ ( .c(b1n_1), .sum(sum[3]), .cout(cout[3]),
     .a(p0_3), .b(p1_3));
mul_ha sc1_1_ ( .sum(sum[1]), .cout(cout[1]), .a(p0_1),
     .b(b0n));
mul_ppgen p0_3_ ( .pm1_l(p0_l_2), .p_l(p0_l), .b(b0[2:0]), .a(a[3]),
     .z(p0_3));
mul_ppgen p1_3_ ( .pm1_l(p1_l_2), .p_l(p1_l), .b(b1[2:0]), .a(a[1]),
     .z(p1_3));
mul_ppgen p0_2_ ( .pm1_l(p0_l_1), .p_l(p0_l_2), .b(b0[2:0]),
     .a(a[2]), .z(p0_2));
mul_ppgen p0_1_ ( .pm1_l(p0_l_0), .p_l(p0_l_1), .b(b0[2:0]),
     .a(a[1]), .z(p0_1));
mul_ppgen p0_0_ ( .pm1_l(1'b1), .p_l(p0_l_0),
     .b(b0[2:0]), .a(a[0]), .z(p0_0));
mul_ppgen p1_2_ ( .pm1_l(1'b1), .p_l(p1_l_2),
     .b(b1[2:0]), .a(a[0]), .z(p1_2));

endmodule // mul_ppgen3lsb4

module mul_ppgen3sign ( cout, sum, am1, am2, am3, am4, b0, b1, b2,
     bot, head, p0m1_l, p1m1_l, p2m1_l );
input  am1, am2, am3, am4;
input  bot, head, p0m1_l, p1m1_l, p2m1_l;
output [5:0]  sum;
output [4:0]  cout;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net37, net42, net075, net088, net0117; 
wire net47, net073, net38, net0118, net078, net8, net15, net43, net48, net35;
wire p2_l_67, p2_l_66, p2_l_65, p2_l_64; 
wire p1_l_65, p1_l_64; 

assign sum[5] = bot & net075 ;
assign net0117 = head & net088 ; 
assign net37 = ~net0117 ;
assign net42 = head ^ net088 ;

mul_ppgensign p0_64_ ( .b(b0[2:0]), .z(net47), .p_l(net088),
     .pm1_l(p0m1_l));
mul_ppgensign p2_68_ ( .pm1_l(p2_l_67), .b(b2[2:0]), .z(net073),
     .p_l(net075));
mul_ppgensign p1_66_ ( .pm1_l(p1_l_65), .b(b1[2:0]), .z(net38),
     .p_l(net0118));
mul_ha sc1_68_ ( .b(net073), .a(1'b1), .cout(cout[4]),
     .sum(sum[4]));
mul_ppgen p2_67_ ( .pm1_l(p2_l_66), .b(b2[2:0]), .a(am1), .z(net078),
     .p_l(p2_l_67));
mul_ppgen p2_66_ ( .pm1_l(p2_l_65), .b(b2[2:0]), .a(am2), .z(net8),
     .p_l(p2_l_66));
mul_ppgen p2_65_ ( .pm1_l(p2_l_64), .p_l(p2_l_65), .b(b2[2:0]),
     .a(am3), .z(net15));
mul_ppgen p1_65_ ( .pm1_l(p1_l_64), .p_l(p1_l_65), .b(b1[2:0]),
     .a(am1), .z(net43));
mul_ppgen p1_64_ ( .pm1_l(p1m1_l), .p_l(p1_l_64), .b(b1[2:0]),
     .a(am2), .z(net48));
mul_ppgen p2_64_ ( .pm1_l(p2m1_l), .p_l(p2_l_64), .b(b2[2:0]),
     .a(am4), .z(net35));
mul_csa32  sc1_67_ ( .c(net078), .b(net0117), .a(net0118),
     .cout(cout[3]), .sum(sum[3]));
mul_csa32  sc1_66_ ( .c(net8), .b(net37), .a(net38), .cout(cout[2]),
     .sum(sum[2]));
mul_csa32  sc1_65_ ( .c(net15), .b(net42), .a(net43), .cout(cout[1]),
     .sum(sum[1]));
mul_csa32  sc1_64_ ( .c(net35), .b(net47), .a(net48), .cout(cout[0]),
     .sum(sum[0]));

endmodule //mul_ppgen3sign

module mul_ppgen3 ( cout, p0_l, p1_l, p2_l, sum, am2, am4,
     a, b0, b1, b2, p0m1_l, p1m1_l, p2m1_l );
output  cout, p0_l, p1_l, p2_l, sum;
input  am2, am4;
input  a, p0m1_l, p1m1_l, p2m1_l;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net046, net32, net043;

mul_csa32  sc1 ( .a(net046), .b(net32), .cout(cout), .sum(sum),
     .c(net043));
mul_ppgen p2 ( .pm1_l(p2m1_l), .p_l(p2_l), .b(b2[2:0]), .a(am4),
     .z(net043));
mul_ppgen p1 ( .pm1_l(p1m1_l), .p_l(p1_l), .b(b1[2:0]), .a(am2),
     .z(net046));
mul_ppgen p0 ( .pm1_l(p0m1_l), .p_l(p0_l), .b(b0[2:0]), .a(a),
     .z(net32));

endmodule // mul_ppgen3

module mul_ppgenrow3 ( cout, sum, a, b0, b1, b2, bot, head );

output [68:1]  cout;
output [69:0]  sum;
input [63:0]  a;
input [2:0]  b2;
input [2:0]  b0;
input [2:0]  b1;
input  bot, head;

// Buses in the design
wire  [63:4]  p2_l;
wire  [63:3]  p1_l;
wire  [63:3]  p0_l;

mul_ppgen3sign I2 ( .am4(a[60]), .am3(a[61]), .am2(a[62]),
     .am1(a[63]), .p2m1_l(p2_l[63]), .p1m1_l(p1_l[63]),
     .p0m1_l(p0_l[63]), .b2(b2[2:0]), .head(head), .bot(bot),
     .sum(sum[69:64]), .cout(cout[68:64]), .b1(b1[2:0]), .b0(b0[2:0]));
mul_ppgen3 I1_63_ ( .p2_l(p2_l[63]), .b2(b2[2:0]),
     .am2(a[61]), .a(a[63]), .p2m1_l(p2_l[62]),
     .p1m1_l(p1_l[62]), .p0m1_l(p0_l[62]), .am4(a[59]), .sum(sum[63]),
     .cout(cout[63]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[63]),
     .p0_l(p0_l[63]));
mul_ppgen3 I1_62_ ( .p2_l(p2_l[62]), .b2(b2[2:0]), 
     .am2(a[60]), .a(a[62]), .p2m1_l(p2_l[61]),
     .p1m1_l(p1_l[61]), .p0m1_l(p0_l[61]), .am4(a[58]), .sum(sum[62]),
     .cout(cout[62]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[62]),
     .p0_l(p0_l[62]));
mul_ppgen3 I1_61_ ( .p2_l(p2_l[61]), .b2(b2[2:0]), 
     .am2(a[59]), .a(a[61]), .p2m1_l(p2_l[60]),
     .p1m1_l(p1_l[60]), .p0m1_l(p0_l[60]), .am4(a[57]), .sum(sum[61]),
     .cout(cout[61]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[61]),
     .p0_l(p0_l[61]));
mul_ppgen3 I1_60_ ( .p2_l(p2_l[60]), .b2(b2[2:0]), 
     .am2(a[58]), .a(a[60]), .p2m1_l(p2_l[59]),
     .p1m1_l(p1_l[59]), .p0m1_l(p0_l[59]), .am4(a[56]), .sum(sum[60]),
     .cout(cout[60]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[60]),
     .p0_l(p0_l[60]));
mul_ppgen3 I1_59_ ( .p2_l(p2_l[59]), .b2(b2[2:0]), 
     .am2(a[57]), .a(a[59]), .p2m1_l(p2_l[58]),
     .p1m1_l(p1_l[58]), .p0m1_l(p0_l[58]), .am4(a[55]), .sum(sum[59]),
     .cout(cout[59]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[59]),
     .p0_l(p0_l[59]));
mul_ppgen3 I1_58_ ( .p2_l(p2_l[58]), .b2(b2[2:0]), 
     .am2(a[56]), .a(a[58]), .p2m1_l(p2_l[57]),
     .p1m1_l(p1_l[57]), .p0m1_l(p0_l[57]), .am4(a[54]), .sum(sum[58]),
     .cout(cout[58]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[58]),
     .p0_l(p0_l[58]));
mul_ppgen3 I1_57_ ( .p2_l(p2_l[57]), .b2(b2[2:0]), 
     .am2(a[55]), .a(a[57]), .p2m1_l(p2_l[56]),
     .p1m1_l(p1_l[56]), .p0m1_l(p0_l[56]), .am4(a[53]), .sum(sum[57]),
     .cout(cout[57]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[57]),
     .p0_l(p0_l[57]));
mul_ppgen3 I1_56_ ( .p2_l(p2_l[56]), .b2(b2[2:0]), 
     .am2(a[54]), .a(a[56]), .p2m1_l(p2_l[55]),
     .p1m1_l(p1_l[55]), .p0m1_l(p0_l[55]), .am4(a[52]), .sum(sum[56]),
     .cout(cout[56]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[56]),
     .p0_l(p0_l[56]));
mul_ppgen3 I1_55_ ( .p2_l(p2_l[55]), .b2(b2[2:0]), 
     .am2(a[53]), .a(a[55]), .p2m1_l(p2_l[54]),
     .p1m1_l(p1_l[54]), .p0m1_l(p0_l[54]), .am4(a[51]), .sum(sum[55]),
     .cout(cout[55]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[55]),
     .p0_l(p0_l[55]));
mul_ppgen3 I1_54_ ( .p2_l(p2_l[54]), .b2(b2[2:0]), 
     .am2(a[52]), .a(a[54]), .p2m1_l(p2_l[53]),
     .p1m1_l(p1_l[53]), .p0m1_l(p0_l[53]), .am4(a[50]), .sum(sum[54]),
     .cout(cout[54]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[54]),
     .p0_l(p0_l[54]));
mul_ppgen3 I1_53_ ( .p2_l(p2_l[53]), .b2(b2[2:0]), 
     .am2(a[51]), .a(a[53]), .p2m1_l(p2_l[52]),
     .p1m1_l(p1_l[52]), .p0m1_l(p0_l[52]), .am4(a[49]), .sum(sum[53]),
     .cout(cout[53]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[53]),
     .p0_l(p0_l[53]));
mul_ppgen3 I1_52_ ( .p2_l(p2_l[52]), .b2(b2[2:0]), 
     .am2(a[50]), .a(a[52]), .p2m1_l(p2_l[51]),
     .p1m1_l(p1_l[51]), .p0m1_l(p0_l[51]), .am4(a[48]), .sum(sum[52]),
     .cout(cout[52]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[52]),
     .p0_l(p0_l[52]));
mul_ppgen3 I1_51_ ( .p2_l(p2_l[51]), .b2(b2[2:0]), 
     .am2(a[49]), .a(a[51]), .p2m1_l(p2_l[50]),
     .p1m1_l(p1_l[50]), .p0m1_l(p0_l[50]), .am4(a[47]), .sum(sum[51]),
     .cout(cout[51]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[51]),
     .p0_l(p0_l[51]));
mul_ppgen3 I1_50_ ( .p2_l(p2_l[50]), .b2(b2[2:0]), 
     .am2(a[48]), .a(a[50]), .p2m1_l(p2_l[49]),
     .p1m1_l(p1_l[49]), .p0m1_l(p0_l[49]), .am4(a[46]), .sum(sum[50]),
     .cout(cout[50]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[50]),
     .p0_l(p0_l[50]));
mul_ppgen3 I1_49_ ( .p2_l(p2_l[49]), .b2(b2[2:0]), 
     .am2(a[47]), .a(a[49]), .p2m1_l(p2_l[48]),
     .p1m1_l(p1_l[48]), .p0m1_l(p0_l[48]), .am4(a[45]), .sum(sum[49]),
     .cout(cout[49]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[49]),
     .p0_l(p0_l[49]));
mul_ppgen3 I1_48_ ( .p2_l(p2_l[48]), .b2(b2[2:0]), 
     .am2(a[46]), .a(a[48]), .p2m1_l(p2_l[47]),
     .p1m1_l(p1_l[47]), .p0m1_l(p0_l[47]), .am4(a[44]), .sum(sum[48]),
     .cout(cout[48]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[48]),
     .p0_l(p0_l[48]));
mul_ppgen3 I1_47_ ( .p2_l(p2_l[47]), .b2(b2[2:0]), 
     .am2(a[45]), .a(a[47]), .p2m1_l(p2_l[46]),
     .p1m1_l(p1_l[46]), .p0m1_l(p0_l[46]), .am4(a[43]), .sum(sum[47]),
     .cout(cout[47]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[47]),
     .p0_l(p0_l[47]));
mul_ppgen3 I1_46_ ( .p2_l(p2_l[46]), .b2(b2[2:0]), 
     .am2(a[44]), .a(a[46]), .p2m1_l(p2_l[45]),
     .p1m1_l(p1_l[45]), .p0m1_l(p0_l[45]), .am4(a[42]), .sum(sum[46]),
     .cout(cout[46]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[46]),
     .p0_l(p0_l[46]));
mul_ppgen3 I1_45_ ( .p2_l(p2_l[45]), .b2(b2[2:0]), 
     .am2(a[43]), .a(a[45]), .p2m1_l(p2_l[44]),
     .p1m1_l(p1_l[44]), .p0m1_l(p0_l[44]), .am4(a[41]), .sum(sum[45]),
     .cout(cout[45]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[45]),
     .p0_l(p0_l[45]));
mul_ppgen3 I1_44_ ( .p2_l(p2_l[44]), .b2(b2[2:0]), 
     .am2(a[42]), .a(a[44]), .p2m1_l(p2_l[43]),
     .p1m1_l(p1_l[43]), .p0m1_l(p0_l[43]), .am4(a[40]), .sum(sum[44]),
     .cout(cout[44]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[44]),
     .p0_l(p0_l[44]));
mul_ppgen3 I1_43_ ( .p2_l(p2_l[43]), .b2(b2[2:0]), 
     .am2(a[41]), .a(a[43]), .p2m1_l(p2_l[42]),
     .p1m1_l(p1_l[42]), .p0m1_l(p0_l[42]), .am4(a[39]), .sum(sum[43]),
     .cout(cout[43]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[43]),
     .p0_l(p0_l[43]));
mul_ppgen3 I1_42_ ( .p2_l(p2_l[42]), .b2(b2[2:0]), 
     .am2(a[40]), .a(a[42]), .p2m1_l(p2_l[41]),
     .p1m1_l(p1_l[41]), .p0m1_l(p0_l[41]), .am4(a[38]), .sum(sum[42]),
     .cout(cout[42]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[42]),
     .p0_l(p0_l[42]));
mul_ppgen3 I1_41_ ( .p2_l(p2_l[41]), .b2(b2[2:0]), 
     .am2(a[39]), .a(a[41]), .p2m1_l(p2_l[40]),
     .p1m1_l(p1_l[40]), .p0m1_l(p0_l[40]), .am4(a[37]), .sum(sum[41]),
     .cout(cout[41]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[41]),
     .p0_l(p0_l[41]));
mul_ppgen3 I1_40_ ( .p2_l(p2_l[40]), .b2(b2[2:0]), 
     .am2(a[38]), .a(a[40]), .p2m1_l(p2_l[39]),
     .p1m1_l(p1_l[39]), .p0m1_l(p0_l[39]), .am4(a[36]), .sum(sum[40]),
     .cout(cout[40]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[40]),
     .p0_l(p0_l[40]));
mul_ppgen3 I1_39_ ( .p2_l(p2_l[39]), .b2(b2[2:0]), 
     .am2(a[37]), .a(a[39]), .p2m1_l(p2_l[38]),
     .p1m1_l(p1_l[38]), .p0m1_l(p0_l[38]), .am4(a[35]), .sum(sum[39]),
     .cout(cout[39]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[39]),
     .p0_l(p0_l[39]));
mul_ppgen3 I1_38_ ( .p2_l(p2_l[38]), .b2(b2[2:0]), 
     .am2(a[36]), .a(a[38]), .p2m1_l(p2_l[37]),
     .p1m1_l(p1_l[37]), .p0m1_l(p0_l[37]), .am4(a[34]), .sum(sum[38]),
     .cout(cout[38]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[38]),
     .p0_l(p0_l[38]));
mul_ppgen3 I1_37_ ( .p2_l(p2_l[37]), .b2(b2[2:0]), 
     .am2(a[35]), .a(a[37]), .p2m1_l(p2_l[36]),
     .p1m1_l(p1_l[36]), .p0m1_l(p0_l[36]), .am4(a[33]), .sum(sum[37]),
     .cout(cout[37]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[37]),
     .p0_l(p0_l[37]));
mul_ppgen3 I1_36_ ( .p2_l(p2_l[36]), .b2(b2[2:0]), 
     .am2(a[34]), .a(a[36]), .p2m1_l(p2_l[35]),
     .p1m1_l(p1_l[35]), .p0m1_l(p0_l[35]), .am4(a[32]), .sum(sum[36]),
     .cout(cout[36]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[36]),
     .p0_l(p0_l[36]));
mul_ppgen3 I1_35_ ( .p2_l(p2_l[35]), .b2(b2[2:0]), 
     .am2(a[33]), .a(a[35]), .p2m1_l(p2_l[34]),
     .p1m1_l(p1_l[34]), .p0m1_l(p0_l[34]), .am4(a[31]), .sum(sum[35]),
     .cout(cout[35]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[35]),
     .p0_l(p0_l[35]));
mul_ppgen3 I1_34_ ( .p2_l(p2_l[34]), .b2(b2[2:0]), 
     .am2(a[32]), .a(a[34]), .p2m1_l(p2_l[33]),
     .p1m1_l(p1_l[33]), .p0m1_l(p0_l[33]), .am4(a[30]), .sum(sum[34]),
     .cout(cout[34]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[34]),
     .p0_l(p0_l[34]));
mul_ppgen3 I1_33_ ( .p2_l(p2_l[33]), .b2(b2[2:0]), 
     .am2(a[31]), .a(a[33]), .p2m1_l(p2_l[32]),
     .p1m1_l(p1_l[32]), .p0m1_l(p0_l[32]), .am4(a[29]), .sum(sum[33]),
     .cout(cout[33]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[33]),
     .p0_l(p0_l[33]));
mul_ppgen3 I1_32_ ( .p2_l(p2_l[32]), .b2(b2[2:0]), 
     .am2(a[30]), .a(a[32]), .p2m1_l(p2_l[31]),
     .p1m1_l(p1_l[31]), .p0m1_l(p0_l[31]), .am4(a[28]), .sum(sum[32]),
     .cout(cout[32]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[32]),
     .p0_l(p0_l[32]));
mul_ppgen3 I1_31_ ( .p2_l(p2_l[31]), .b2(b2[2:0]), 
     .am2(a[29]), .a(a[31]), .p2m1_l(p2_l[30]),
     .p1m1_l(p1_l[30]), .p0m1_l(p0_l[30]), .am4(a[27]), .sum(sum[31]),
     .cout(cout[31]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[31]),
     .p0_l(p0_l[31]));
mul_ppgen3 I1_30_ ( .p2_l(p2_l[30]), .b2(b2[2:0]), 
     .am2(a[28]), .a(a[30]), .p2m1_l(p2_l[29]),
     .p1m1_l(p1_l[29]), .p0m1_l(p0_l[29]), .am4(a[26]), .sum(sum[30]),
     .cout(cout[30]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[30]),
     .p0_l(p0_l[30]));
mul_ppgen3 I1_29_ ( .p2_l(p2_l[29]), .b2(b2[2:0]), 
     .am2(a[27]), .a(a[29]), .p2m1_l(p2_l[28]),
     .p1m1_l(p1_l[28]), .p0m1_l(p0_l[28]), .am4(a[25]), .sum(sum[29]),
     .cout(cout[29]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[29]),
     .p0_l(p0_l[29]));
mul_ppgen3 I1_28_ ( .p2_l(p2_l[28]), .b2(b2[2:0]), 
     .am2(a[26]), .a(a[28]), .p2m1_l(p2_l[27]),
     .p1m1_l(p1_l[27]), .p0m1_l(p0_l[27]), .am4(a[24]), .sum(sum[28]),
     .cout(cout[28]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[28]),
     .p0_l(p0_l[28]));
mul_ppgen3 I1_27_ ( .p2_l(p2_l[27]), .b2(b2[2:0]), 
     .am2(a[25]), .a(a[27]), .p2m1_l(p2_l[26]),
     .p1m1_l(p1_l[26]), .p0m1_l(p0_l[26]), .am4(a[23]), .sum(sum[27]),
     .cout(cout[27]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[27]),
     .p0_l(p0_l[27]));
mul_ppgen3 I1_26_ ( .p2_l(p2_l[26]), .b2(b2[2:0]), 
     .am2(a[24]), .a(a[26]), .p2m1_l(p2_l[25]),
     .p1m1_l(p1_l[25]), .p0m1_l(p0_l[25]), .am4(a[22]), .sum(sum[26]),
     .cout(cout[26]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[26]),
     .p0_l(p0_l[26]));
mul_ppgen3 I1_25_ ( .p2_l(p2_l[25]), .b2(b2[2:0]), 
     .am2(a[23]), .a(a[25]), .p2m1_l(p2_l[24]),
     .p1m1_l(p1_l[24]), .p0m1_l(p0_l[24]), .am4(a[21]), .sum(sum[25]),
     .cout(cout[25]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[25]),
     .p0_l(p0_l[25]));
mul_ppgen3 I1_24_ ( .p2_l(p2_l[24]), .b2(b2[2:0]), 
     .am2(a[22]), .a(a[24]), .p2m1_l(p2_l[23]),
     .p1m1_l(p1_l[23]), .p0m1_l(p0_l[23]), .am4(a[20]), .sum(sum[24]),
     .cout(cout[24]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[24]),
     .p0_l(p0_l[24]));
mul_ppgen3 I1_23_ ( .p2_l(p2_l[23]), .b2(b2[2:0]), 
     .am2(a[21]), .a(a[23]), .p2m1_l(p2_l[22]),
     .p1m1_l(p1_l[22]), .p0m1_l(p0_l[22]), .am4(a[19]), .sum(sum[23]),
     .cout(cout[23]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[23]),
     .p0_l(p0_l[23]));
mul_ppgen3 I1_22_ ( .p2_l(p2_l[22]), .b2(b2[2:0]), 
     .am2(a[20]), .a(a[22]), .p2m1_l(p2_l[21]),
     .p1m1_l(p1_l[21]), .p0m1_l(p0_l[21]), .am4(a[18]), .sum(sum[22]),
     .cout(cout[22]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[22]),
     .p0_l(p0_l[22]));
mul_ppgen3 I1_21_ ( .p2_l(p2_l[21]), .b2(b2[2:0]), 
     .am2(a[19]), .a(a[21]), .p2m1_l(p2_l[20]),
     .p1m1_l(p1_l[20]), .p0m1_l(p0_l[20]), .am4(a[17]), .sum(sum[21]),
     .cout(cout[21]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[21]),
     .p0_l(p0_l[21]));
mul_ppgen3 I1_20_ ( .p2_l(p2_l[20]), .b2(b2[2:0]), 
     .am2(a[18]), .a(a[20]), .p2m1_l(p2_l[19]),
     .p1m1_l(p1_l[19]), .p0m1_l(p0_l[19]), .am4(a[16]), .sum(sum[20]),
     .cout(cout[20]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[20]),
     .p0_l(p0_l[20]));
mul_ppgen3 I1_19_ ( .p2_l(p2_l[19]), .b2(b2[2:0]), 
     .am2(a[17]), .a(a[19]), .p2m1_l(p2_l[18]),
     .p1m1_l(p1_l[18]), .p0m1_l(p0_l[18]), .am4(a[15]), .sum(sum[19]),
     .cout(cout[19]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[19]),
     .p0_l(p0_l[19]));
mul_ppgen3 I1_18_ ( .p2_l(p2_l[18]), .b2(b2[2:0]), 
     .am2(a[16]), .a(a[18]), .p2m1_l(p2_l[17]),
     .p1m1_l(p1_l[17]), .p0m1_l(p0_l[17]), .am4(a[14]), .sum(sum[18]),
     .cout(cout[18]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[18]),
     .p0_l(p0_l[18]));
mul_ppgen3 I1_17_ ( .p2_l(p2_l[17]), .b2(b2[2:0]), 
     .am2(a[15]), .a(a[17]), .p2m1_l(p2_l[16]),
     .p1m1_l(p1_l[16]), .p0m1_l(p0_l[16]), .am4(a[13]), .sum(sum[17]),
     .cout(cout[17]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[17]),
     .p0_l(p0_l[17]));
mul_ppgen3 I1_16_ ( .p2_l(p2_l[16]), .b2(b2[2:0]), 
     .am2(a[14]), .a(a[16]), .p2m1_l(p2_l[15]),
     .p1m1_l(p1_l[15]), .p0m1_l(p0_l[15]), .am4(a[12]), .sum(sum[16]),
     .cout(cout[16]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[16]),
     .p0_l(p0_l[16]));
mul_ppgen3 I1_15_ ( .p2_l(p2_l[15]), .b2(b2[2:0]), 
     .am2(a[13]), .a(a[15]), .p2m1_l(p2_l[14]),
     .p1m1_l(p1_l[14]), .p0m1_l(p0_l[14]), .am4(a[11]), .sum(sum[15]),
     .cout(cout[15]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[15]),
     .p0_l(p0_l[15]));
mul_ppgen3 I1_14_ ( .p2_l(p2_l[14]), .b2(b2[2:0]), 
     .am2(a[12]), .a(a[14]), .p2m1_l(p2_l[13]),
     .p1m1_l(p1_l[13]), .p0m1_l(p0_l[13]), .am4(a[10]), .sum(sum[14]),
     .cout(cout[14]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[14]),
     .p0_l(p0_l[14]));
mul_ppgen3 I1_13_ ( .p2_l(p2_l[13]), .b2(b2[2:0]), 
     .am2(a[11]), .a(a[13]), .p2m1_l(p2_l[12]),
     .p1m1_l(p1_l[12]), .p0m1_l(p0_l[12]), .am4(a[9]), .sum(sum[13]),
     .cout(cout[13]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[13]),
     .p0_l(p0_l[13]));
mul_ppgen3 I1_12_ ( .p2_l(p2_l[12]), .b2(b2[2:0]), 
     .am2(a[10]), .a(a[12]), .p2m1_l(p2_l[11]),
     .p1m1_l(p1_l[11]), .p0m1_l(p0_l[11]), .am4(a[8]), .sum(sum[12]),
     .cout(cout[12]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[12]),
     .p0_l(p0_l[12]));
mul_ppgen3 I1_11_ ( .p2_l(p2_l[11]), .b2(b2[2:0]), 
     .am2(a[9]), .a(a[11]), .p2m1_l(p2_l[10]),
     .p1m1_l(p1_l[10]), .p0m1_l(p0_l[10]), .am4(a[7]), .sum(sum[11]),
     .cout(cout[11]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[11]),
     .p0_l(p0_l[11]));
mul_ppgen3 I1_10_ ( .p2_l(p2_l[10]), .b2(b2[2:0]), 
     .am2(a[8]), .a(a[10]), .p2m1_l(p2_l[9]),
     .p1m1_l(p1_l[9]), .p0m1_l(p0_l[9]), .am4(a[6]), .sum(sum[10]),
     .cout(cout[10]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[10]),
     .p0_l(p0_l[10]));
mul_ppgen3 I1_9_ ( .p2_l(p2_l[9]), .b2(b2[2:0]), 
     .am2(a[7]), .a(a[9]), .p2m1_l(p2_l[8]),
     .p1m1_l(p1_l[8]), .p0m1_l(p0_l[8]), .am4(a[5]), .sum(sum[9]),
     .cout(cout[9]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[9]),
     .p0_l(p0_l[9]));
mul_ppgen3 I1_8_ ( .p2_l(p2_l[8]), .b2(b2[2:0]), 
     .am2(a[6]), .a(a[8]), .p2m1_l(p2_l[7]),
     .p1m1_l(p1_l[7]), .p0m1_l(p0_l[7]), .am4(a[4]), .sum(sum[8]),
     .cout(cout[8]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[8]),
     .p0_l(p0_l[8]));
mul_ppgen3 I1_7_ ( .p2_l(p2_l[7]), .b2(b2[2:0]), 
     .am2(a[5]), .a(a[7]), .p2m1_l(p2_l[6]),
     .p1m1_l(p1_l[6]), .p0m1_l(p0_l[6]), .am4(a[3]), .sum(sum[7]),
     .cout(cout[7]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[7]),
     .p0_l(p0_l[7]));
mul_ppgen3 I1_6_ ( .p2_l(p2_l[6]), .b2(b2[2:0]), 
     .am2(a[4]), .a(a[6]), .p2m1_l(p2_l[5]),
     .p1m1_l(p1_l[5]), .p0m1_l(p0_l[5]), .am4(a[2]), .sum(sum[6]),
     .cout(cout[6]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[6]),
     .p0_l(p0_l[6]));
mul_ppgen3 I1_5_ ( .p2_l(p2_l[5]), .b2(b2[2:0]), 
     .am2(a[3]), .a(a[5]), .p2m1_l(p2_l[4]),
     .p1m1_l(p1_l[4]), .p0m1_l(p0_l[4]), .am4(a[1]), .sum(sum[5]),
     .cout(cout[5]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[5]),
     .p0_l(p0_l[5]));
mul_ppgen3 I1_4_ ( .p2_l(p2_l[4]), .b2(b2[2:0]), 
     .am2(a[2]), .a(a[4]), .p2m1_l(1'b1),
     .p1m1_l(p1_l[3]), .p0m1_l(p0_l[3]), .am4(a[0]), .sum(sum[4]),
     .cout(cout[4]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[4]),
     .p0_l(p0_l[4]));
mul_ppgen3lsb4 I0 ( .cout(cout[3:1]), .a(a[3:0]), .sum(sum[3:0]),
     .p1_l(p1_l[3]), .p0_l(p0_l[3]), .b1(b1[2:0]), .b0(b0[2:0]));

endmodule //mul_ppgenrow3

module mul_ppgensign ( p_l, z, b, pm1_l );
output  p_l, z;
input  pm1_l;
input [2:0]  b;

assign p_l = ~(b[1] & b[2]);
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgensign

module mul_ppgen ( p_l, z, a, b, pm1_l );
output  p_l, z;
input  a, pm1_l;
input [2:0]  b;

assign p_l = ~((a ^ b[2]) & b[1]) ;
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgen

module mul_mux2 ( z, d0, d1, s );
output  z;
input  d0, d1, s;

assign z = s ? d1 : d0 ;

endmodule // mul_mux2 

module mul_booth(
	head,
        b_in,
        b0, b1, b2, b3, b4, b5, b6, b7,
	b8, b9, b10, b11, b12, b13, b14, b15, b16,
	clk, se, si, so, mul_step, tm_l
	);
input		head;		// begin of the MUL operation
input   [63:0] 	b_in;
input		clk, se, si, mul_step, tm_l;
output  [2:0]  	b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
output 		b16;
output 		so;

wire  [63:31] 	b;
wire [2:0] 	b0_in0, b1_in0,  b2_in0,  b3_in0,  b4_in0,  b5_in0,  b6_in0,  b7_in0 ;
wire [2:0] 	b8_in0, b9_in0, b10_in0, b11_in0, b12_in0, b13_in0, b14_in0, b15_in0 ;
wire [2:0] 	b0_in1, b1_in1,  b2_in1,  b3_in1,  b4_in1,  b5_in1,  b6_in1,  b7_in1 ;
wire [2:0] 	b8_in1, b9_in1, b10_in1, b11_in1, b12_in1, b13_in1, b14_in1, b15_in1 ;
wire 	   	b16_in1;

wire [2:0] 	b0_outmx, b1_outmx, b2_outmx, b3_outmx, b4_outmx, b5_outmx, b6_outmx;
wire [2:0] 	b7_outmx, b8_outmx, b9_outmx, b10_outmx, b11_outmx, b12_outmx, b13_outmx;
wire [2:0] 	b14_outmx, b15_outmx;
wire 	   	b16_outmx;
wire		clk_enb0, clk_enb1;


  mul_bodec 		encode0_a(
				.x  (1'b0),
				.b  (b_in[15:0]),
				.b0 (b0_in0),
				.b1 (b1_in0),
				.b2 (b2_in0),
				.b3 (b3_in0),
				.b4 (b4_in0),
				.b5 (b5_in0),
				.b6 (b6_in0),
				.b7 (b7_in0)
				);
				//remove 16th row since it's never the last row
				//b8_in0 = 3'b010; 
  mul_bodec		encode0_b(
				.x  (b_in[15]),
				.b  (b_in[31:16]),
				.b0 (b8_in0),
				.b1 (b9_in0),
				.b2 (b10_in0),
				.b3 (b11_in0),
				.b4 (b12_in0),
				.b5 (b13_in0),
				.b6 (b14_in0),
				.b7 (b15_in0)
				);
				// remove 32th row since it's never the last row 
				// b16_in0 = 3'b010 ;

  // Pipe picked address [63:31] and hold flop

  clken_buf     ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));
  clken_buf     ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(head & mul_step)), .tmb_l(tm_l));

  dff_s 			hld_dff0(.din(b_in[31]), .clk(clk_enb1), .q(b[31]),
                        	.se(se), .si(), .so());
  dff_s #(32) 		hld_dff(.din(b_in[63:32]), .clk(clk_enb1), .q(b[63:32]),
				.se(se), .si(), .so());

  mul_bodec     	encode1_a(
                        	.x  (b[31]),
                        	.b  (b[47:32]),
                        	.b0 (b0_in1),
                        	.b1 (b1_in1),
                        	.b2 (b2_in1),
                        	.b3 (b3_in1),
                        	.b4 (b4_in1),
                        	.b5 (b5_in1),
                        	.b6 (b6_in1),
                        	.b7 (b7_in1)
                        	);
                        	//remove 16th row since it's never the last row
                        	//b8_in1 = 3'b010;
  mul_bodec     	encode1_b(
                        	.x  (b[47]),
                        	.b  (b[63:48]),
                        	.b0 (b8_in1),
                        	.b1 (b9_in1),
                        	.b2 (b10_in1),
                        	.b3 (b11_in1),
                        	.b4 (b12_in1),
                        	.b5 (b13_in1),
                        	.b6 (b14_in1),
                        	.b7 (b15_in1)
                        	);
				assign b16_in1 = b[63] ;

// Select booth encoded b outputs and flop based on the cycle0 and cycle1 

  dp_mux2es #(3)    out_mux0(.dout(b0_outmx[2:0]),
                        .in0(b0_in0[2:0]),
                        .in1(b0_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux1(.dout(b1_outmx[2:0]),
                        .in0(b1_in0[2:0]),
                        .in1(b1_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux2(.dout(b2_outmx[2:0]),
                        .in0(b2_in0[2:0]),
                        .in1(b2_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux3(.dout(b3_outmx[2:0]),
                        .in0(b3_in0[2:0]),
                        .in1(b3_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux4(.dout(b4_outmx[2:0]),
                        .in0(b4_in0[2:0]),
                        .in1(b4_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux5(.dout(b5_outmx[2:0]),
                        .in0(b5_in0[2:0]),
                        .in1(b5_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux6(.dout(b6_outmx[2:0]),
                        .in0(b6_in0[2:0]),
                        .in1(b6_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux7(.dout(b7_outmx[2:0]),
                        .in0(b7_in0[2:0]),
                        .in1(b7_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux8(.dout(b8_outmx[2:0]),
                        .in0(b8_in0[2:0]),
                        .in1(b8_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux9(.dout(b9_outmx[2:0]),
                        .in0(b9_in0[2:0]),
                        .in1(b9_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux10(.dout(b10_outmx[2:0]),
                        .in0(b10_in0[2:0]),
                        .in1(b10_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux11(.dout(b11_outmx[2:0]),
                        .in0(b11_in0[2:0]),
                        .in1(b11_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux12(.dout(b12_outmx[2:0]),
                        .in0(b12_in0[2:0]),
                        .in1(b12_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux13(.dout(b13_outmx[2:0]),
                        .in0(b13_in0[2:0]),
                        .in1(b13_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux14(.dout(b14_outmx[2:0]),
                        .in0(b14_in0[2:0]),
                        .in1(b14_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux15(.dout(b15_outmx[2:0]),
                        .in0(b15_in0[2:0]),
                        .in1(b15_in1[2:0]),
                        .sel(~head));
  dp_mux2es         out_mux16(.dout(b16_outmx),
                        .in0(1'b0),
                        .in1(b16_in1),
                        .sel(~head));

  dff_s #(3)    out_dff0 (.din(b0_outmx[2:0]), .clk(clk_enb0), .q(b0[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff1 (.din(b1_outmx[2:0]), .clk(clk_enb0), .q(b1[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff2 (.din(b2_outmx[2:0]), .clk(clk_enb0), .q(b2[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff3 (.din(b3_outmx[2:0]), .clk(clk_enb0), .q(b3[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff4 (.din(b4_outmx[2:0]), .clk(clk_enb0), .q(b4[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff5 (.din(b5_outmx[2:0]), .clk(clk_enb0), .q(b5[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff6 (.din(b6_outmx[2:0]), .clk(clk_enb0), .q(b6[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff7 (.din(b7_outmx[2:0]), .clk(clk_enb0), .q(b7[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff8 (.din(b8_outmx[2:0]), .clk(clk_enb0), .q(b8[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff9 (.din(b9_outmx[2:0]), .clk(clk_enb0), .q(b9[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff10 (.din(b10_outmx[2:0]), .clk(clk_enb0), .q(b10[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff11 (.din(b11_outmx[2:0]), .clk(clk_enb0), .q(b11[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff12 (.din(b12_outmx[2:0]), .clk(clk_enb0), .q(b12[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff13 (.din(b13_outmx[2:0]), .clk(clk_enb0), .q(b13[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff14 (.din(b14_outmx[2:0]), .clk(clk_enb0), .q(b14[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff15 (.din(b15_outmx[2:0]), .clk(clk_enb0), .q(b15[2:0]),
			.se(se), .si(), .so());
  dff_s 	      out_dff16 (.din(b16_outmx), .clk(clk_enb0), .q(b16),
			.se(se), .si(), .so());
endmodule //mul_booth

module mul_bodec (x, b,  
        b0, b1, b2, b3, b4, b5, b6, b7);

input	x;
input   [15:0] 	b;
output  [2:0] 	b0, b1, b2, b3, b4, b5, b6, b7; 

assign b0[2] = b[1];
assign b0[1] = ~((b[1] & b[0] & x) | (~b[1] & ~b[0] & ~x)) ;
assign b0[0] = (~b[1] & b[0] & x) | (b[1] & ~b[0] & ~x) ;

assign b1[2] = b[3]; 
assign b1[1] = ~((b[3] & b[2] & b[1]) | (~b[3] & ~b[2] & ~b[1])) ;
assign b1[0] = (~b[3] & b[2] & b[1]) | (b[3] & ~b[2] & ~b[1]) ;

assign b2[2] = b[5]; 
assign b2[1] = ~((b[5] & b[4] & b[3]) | (~b[5] & ~b[4] & ~b[3])) ;
assign b2[0] = (~b[5] & b[4] & b[3]) | (b[5] & ~b[4] & ~b[3]) ;

assign b3[2] = b[7] ;
assign b3[1] = ~((b[7] & b[6] & b[5]) | (~b[7] & ~b[6] & ~b[5])) ;
assign b3[0] = (~b[7] & b[6] & b[5]) | (b[7] & ~b[6] & ~b[5]) ;

assign b4[2] = b[9] ;
assign b4[1] = ~((b[9] & b[8] & b[7]) | (~b[9] & ~b[8] & ~b[7])) ;
assign b4[0] = (~b[9] & b[8] & b[7]) | (b[9] & ~b[8] & ~b[7]) ;

assign b5[2] = b[11] ;
assign b5[1] = ~((b[11] & b[10] & b[9]) | (~b[11] & ~b[10] & ~b[9])) ;
assign b5[0] = (~b[11] & b[10] & b[9]) | (b[11] & ~b[10] & ~b[9]) ;

assign b6[2] = b[13] ;
assign b6[1] = ~((b[13] & b[12] & b[11]) | (~b[13] & ~b[12] & ~b[11])) ;
assign b6[0] = (~b[13] & b[12] & b[11]) | (b[13] & ~b[12] & ~b[11]) ;

assign b7[2] = b[15] ;
assign b7[1] = ~((b[15] & b[14] & b[13]) | (~b[15] & ~b[14] & ~b[13])) ;
assign b7[0] = (~b[15] & b[14] & b[13]) | (b[15] & ~b[14] & ~b[13]) ;

endmodule // mul_bodec

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_clib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: swrvr_clib.v
//      Description: Design control behavioural library
*/                 





// POSITVE-EDGE TRIGGERED FLOP with SCAN
module dff_s (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;










endmodule // dff_s

// POSITVE-EDGE TRIGGERED FLOP with SCAN for Shadow-scan
module dff_sscan (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;










always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;

assign so={SIZE{1'b0}};


endmodule // dff_sscan

// POSITVE-EDGE TRIGGERED FLOP without SCAN
module dff_ns (din, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)

	q[SIZE-1:0]  <= din[SIZE-1:0] ;

endmodule // dff_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET
module dffr_s (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= ((rst) ? {SIZE{1'b0}}  : din[SIZE-1:0] );










endmodule // dffr_s

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET_L
module dffrl_s (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};










endmodule // dffrl_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, without SCAN
module dffr_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];
   
endmodule // dffr_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, without SCAN
module dffrl_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};

endmodule // dffrl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN and FUNCTIONAL ENABLE
module dffe_s (din, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// en	se	out
//------------------
// x	1	sin ; scan dominates
// 1  	0	din
// 0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) ;









endmodule // dffe_s

// POSITIVE-EDGE TRIGGERED FLOP with enable, without SCAN
module dffe_ns (din, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)
  q[SIZE-1:0] <= en ? din[SIZE-1:0] : q[SIZE-1:0];

endmodule // dffe_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET, FUNCTIONAL ENABLE, SCAN.
module dffre_s (din, rst, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 1	x	x	0   ; reset dominates
// 0	x	1	sin ; scan dominates
// 0	1  	0	din
// 0 	0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= (rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) ;











endmodule // dffre_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, FUNCTIONAL ENABLE, SCAN.
module dffrle_s (din, rst_l, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 0	x	x	0   ; reset dominates
// 1	x	1	sin ; scan dominates
// 1	1  	0	din
// 1 	0 	0	q
//


always @ (posedge clk)
	 q[SIZE-1:0]  <= (rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}}) ;










endmodule // dffrle_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, ENABLE, without SCAN.
module dffre_ns (din, rst, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 1	x	0   ; reset dominates
// 0	1  	din
// 0 	0 	q
//

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0]);

endmodule // dffre_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, ENABLE, without SCAN.
module dffrle_ns (din, rst_l, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 0	x	0   ; reset dominates
// 1	1  	din
// 1 	0 	q
//

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}} ;

endmodule // dffrle_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET
module dffr_async (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or posedge rst)
	q[SIZE-1:0]  <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];










endmodule // dffr_async

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET_L
module dffrl_async (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or negedge rst_l)
 
  if (!rst_l) q[SIZE-1:0] <= {SIZE{1'b0}}; else q[SIZE-1:0]  <= din[SIZE-1:0];
 












endmodule // dffrl_async

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET, without SCAN
//module dffr_async_ns (din, clk, rst, q);
//// synopsys template
//parameter SIZE = 1;
//input   [SIZE-1:0]      din ;   // data in
//input                   clk ;   // clk or scan clk
//input                   rst ;   // reset
//output  [SIZE-1:0]      q ;     // output
//reg     [SIZE-1:0]      q ;
// Reset dominates
//// synopsys async_set_reset "rst"
//always @ (posedge clk or posedge rst)
//        if(rst) q[SIZE-1:0]  <= {SIZE{1'b0}};
//        else if(clk) q[SIZE-1:0]  <= din[SIZE-1:0];
//endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET_L, without SCAN
module dffrl_async_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

// Reset dominates
// synopsys async_set_reset "rst_l"
 reg [SIZE-1:0] q;   
always @ (posedge clk or negedge rst_l) begin
 
    if (~rst_l) begin
        q[SIZE-1:0] <=  {SIZE{1'b0}};
    end else begin
        q[SIZE-1:0] <=  ({SIZE{rst_l}} & din[SIZE-1:0]);
    end
 



end

//   reg  [SIZE-1:0]   qm, qs, qm_l, qs_l, qm_f, qs_f;
//   wire              s_l;
//   assign            s_l = 1'b1;
//
//   always @ (rst_l or qm)   qm_l = ~(qm & {SIZE{rst_l}});
//   always @ (s_l or qs)   qs_l = ~(qs & {SIZE{s_l}});
//   always @ (s_l or qm_l) qm_f = ~(qm_l & {SIZE{s_l}});
//   always @ (rst_l or qs_l) qs_f = ~(qs_l & {SIZE{rst_l}});
//
//   always @ (clk or din or qm_f)
//      qm <= clk ? qm_f : din;
//
//   always @ (clk or qm_l or qs_f)
//      qs <= clk ? qm_l : qs_f;
//
//   assign q  = ~qs;

endmodule // dffrl_async_ns

// 2:1 MUX WITH DECODED SELECTS
module mux2ds (dout, in0, in1, sel0, sel1) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel0;
input			sel1;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;

// priority encoding takes care of mutex'ing selects.




wire [1:0] sel = {sel1, sel0}; // 0in one_hot
   
always @ (sel0 or sel1 or in0 or in1)

	case ({sel1,sel0}) // synopsys infer_mux
		2'b01 :	dout = in0 ;
		2'b10 : dout = in1 ;
		2'b11 : dout = {SIZE{1'bx}} ;
		2'b00 : dout = {SIZE{1'bx}} ;
			// 2'b00 : // E.g. 4state vs. 2state modelling.
			// begin
			//	`ifdef FOUR_STATE
			//		dout = {SIZE{1'bx}};
			//	`else
			//		begin
			//		dout = {SIZE{1'b0}};
			//		$error();
			//		end
			//	`endif
			// end
		default : dout = {SIZE{1'bx}};
	endcase

endmodule // mux2ds

// 3:1 MUX WITH DECODED SELECTS
module mux3ds (dout, in0, in1, in2, sel0, sel1, sel2) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0;
input			sel1;
input			sel2;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or in0 or in1 or in2)

	case ({sel2,sel1,sel0}) 
		3'b001 : dout = in0 ;
		3'b010 : dout = in1 ;
		3'b100 : dout = in2 ;
		3'b000 : dout = {SIZE{1'bx}} ;
		3'b011 : dout = {SIZE{1'bx}} ;
		3'b101 : dout = {SIZE{1'bx}} ;
		3'b110 : dout = {SIZE{1'bx}} ;
		3'b111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux3ds

// 4:1 MUX WITH DECODED SELECTS
module mux4ds (dout, in0, in1, in2, in3, sel0, sel1, sel2, sel3) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0;
input			sel1;
input			sel2;
input			sel3;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [3:0] sel = {sel3,sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or sel3 or in0 or in1 or in2 or in3)

	case ({sel3,sel2,sel1,sel0}) 
		4'b0001 : dout = in0 ;
		4'b0010 : dout = in1 ;
		4'b0100 : dout = in2 ;
		4'b1000 : dout = in3 ;
		4'b0000 : dout = {SIZE{1'bx}} ;
		4'b0011 : dout = {SIZE{1'bx}} ;
		4'b0101 : dout = {SIZE{1'bx}} ;
		4'b0110 : dout = {SIZE{1'bx}} ;
		4'b0111 : dout = {SIZE{1'bx}} ;
		4'b1001 : dout = {SIZE{1'bx}} ;
		4'b1010 : dout = {SIZE{1'bx}} ;
		4'b1011 : dout = {SIZE{1'bx}} ;
		4'b1100 : dout = {SIZE{1'bx}} ;
		4'b1101 : dout = {SIZE{1'bx}} ;
		4'b1110 : dout = {SIZE{1'bx}} ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux4ds

// SINK FOR UNLOADED INPUT PORTS
module sink (in);
// synopsys template

parameter SIZE = 1;

input [SIZE-1:0] in;

// Alexey
// `ifdef PITON_PROTO
   // As of version 8.2 XST does not remove this module without the
   // following additional dead code

   wire    a;

   assign		a = | in;

// `endif

endmodule //sink

// SOURCE FOR UNDRIVEN OUTPUT PORTS
module source (out) ;
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0] out;
// 
// Once 4state/2state model established
// then enable check.
// `ifdef FOUR_STATE
// leda check for x_or_z_in rhs_of assign turned off
// assign  out = {SIZE{1'bx}};
//`else
assign  out = {SIZE{1'b0}};
//`endif

endmodule //source

// 2:1 MUX WITH PRIORITY ENCODED SELECTS
//module mux2es (dout, in0, in1, sel0, sel1) ;
//
//parameter SIZE = 1;
//
//output 	[SIZE-1:0] 	dout;
//input	[SIZE-1:0]	in0;
//input	[SIZE-1:0]	in1;
//input			sel0;
//input			sel1;
//
//// reg declaration does not imply state being maintained
//// across cycles. Used to construct case statement and
//// always updated by inputs every cycle.
//reg	[SIZE-1:0]	dout ;
//
//// must take into account lack of mutex selects.
//// there is no reason for handling of x and z conditions.
//// This will be dictated by design.
//always @ (sel0 or sel1 or in0 or in1)
//
//	case ({sel1,sel0})
//		2'b1x : dout = in1 ; // 10(in1),11(z) 
//		2'b0x :	dout = in0 ; // 01(in0),00(x)
//	endcase
//
//endmodule // mux2es

// CLK Header for gating off the clock of
// a FF.
// clk - output of the clk header
// rclk - input clk
// enb_l - Active low clock enable
// tmb_l  - Active low clock enable ( in scan mode, this input is !se )

module clken_buf (clk, rclk, enb_l, tmb_l);
output clk;
input  rclk, enb_l, tmb_l;
reg    clken;

  always @ (rclk or enb_l or tmb_l)
    if (!rclk)  //latch opens on rclk low phase
      clken = !enb_l | !tmb_l;
  assign clk = clken & rclk;

endmodule



// The following flops are maintained and used in ENET , MAC IP  ONLY
// -- Mimi X61467

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys sync_set_reset "set_l"
always @ (posedge clk)
  q[SIZE-1:0] <= set_l ? din[SIZE-1:0] : {SIZE{1'b1}};

endmodule // dffsl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_async_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys async_set_reset "set_l"
always @ (posedge clk or negedge set_l) begin

    if (~set_l) begin
        q[SIZE-1:0] <= {SIZE{1'b1}};
    end else begin
        q[SIZE-1:0] <= ({SIZE{~set_l}} | din[SIZE-1:0]);
    end



end
endmodule // dffsl_async_ns

// POSITIVE-EDGE TRIGGERED FLOP WITH SET_H , without SCAN.

module dffr_ns_r1 (din, clk, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_ns_r1

// POSITIVE-EDGE TRIGGERED ASYNC RESET_H FLOP , without SCAN.

module dffr_async_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset dominates
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];

endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_r1 (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset to 1
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_r1


// NEGATIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_cl_r1 (din, clkl, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clkl ;  // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (negedge clkl or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_cl_r1

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_dlib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// DP library

// 2:1 MUX WITH ENCODED SELECT
module dp_mux2es (dout, in0, in1, sel) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel;

reg	[SIZE-1:0]	dout ;

always @ (sel or in0 or in1)

 begin
	   case (sel)
	     1'b1: dout = in1 ; 
	     1'b0: dout = in0;
	     default: 
         begin
            if (in0 == in1) begin
               dout = in0;
            end
            else
              dout = {SIZE{1'bx}};
         end
	   endcase // case(sel)
 end

endmodule // dp_mux2es

// ----------------------------------------------------------------------


// 4:1 MUX WITH DECODED SELECTS
module dp_mux4ds (dout, in0, in1, in2, in3, 
		     sel0_l, sel1_l, sel2_l, sel3_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [3:0] sel = {sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3)

	case ({sel3_l,sel2_l,sel1_l,sel0_l})
		4'b1110 : dout = in0 ;
		4'b1101 : dout = in1 ;
		4'b1011 : dout = in2 ;
		4'b0111 : dout = in3 ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux4ds

// ----------------------------------------------------------------------


// 5:1 MUX WITH DECODED SELECTS
module dp_mux5ds (dout, in0, in1, in2, in3,  in4,
		     sel0_l, sel1_l, sel2_l, sel3_l, sel4_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [4:0] sel = {sel4_l,sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or sel4_l or
		in0 or in1 or in2 or in3 or in4)

	case ({sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		5'b11110 : dout = in0 ;
		5'b11101 : dout = in1 ;
		5'b11011 : dout = in2 ;
		5'b10111 : dout = in3 ;
		5'b01111 : dout = in4 ;
		5'b11111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux5ds

// --------------------------------------------------------------------

// 8:1 MUX WITH DECODED SELECTS
module dp_mux8ds (dout, in0, in1, in2, in3, 
			in4, in5, in6, in7,
		     sel0_l, sel1_l, sel2_l, sel3_l,
		     sel4_l, sel5_l, sel6_l, sel7_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input	[SIZE-1:0]	in5;
input	[SIZE-1:0]	in6;
input	[SIZE-1:0]	in7;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;
input			sel5_l;
input			sel6_l;
input			sel7_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;






wire [7:0] sel = {sel7_l,sel6_l,sel5_l,sel4_l,
                  sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3 or
	  sel4_l or sel5_l or sel6_l or sel7_l or in4 or in5 or in6 or in7)

	case ({sel7_l,sel6_l,sel5_l,sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		8'b11111110 : dout = in0 ;
		8'b11111101 : dout = in1 ;
		8'b11111011 : dout = in2 ;
		8'b11110111 : dout = in3 ;
		8'b11101111 : dout = in4 ;
		8'b11011111 : dout = in5 ;
		8'b10111111 : dout = in6 ;
		8'b01111111 : dout = in7 ;
		8'b11111111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux8ds


// ----------------------------------------------------------------------


// 3:1 MUX WITH DECODED SELECTS
module dp_mux3ds (dout, in0, in1, in2, 
		     sel0_l, sel1_l, sel2_l);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0_l;
input			sel1_l;
input			sel2_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or in0 or in1 or in2)

	case ({sel2_l,sel1_l,sel0_l})
		3'b110 : dout = in0 ;
		3'b101 : dout = in1 ;
		3'b011 : dout = in2 ;
	        default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux3ds

// ----------------------------------------------------------------------


// 2:1 MUX WITH DECODED SELECTS
module dp_mux2ds (dout, in0, in1,
             sel0_l, sel1_l);
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0]  dout;
input   [SIZE-1:0]  in0;
input   [SIZE-1:0]  in1;
input           sel0_l;
input           sel1_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg [SIZE-1:0]  dout ;





wire [1:0] sel = {sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or in0 or in1)

    case ({sel1_l,sel0_l})
        3'b10 : dout = in0 ;
        3'b01 : dout = in1 ;
            default : dout = {SIZE{1'bx}} ;
    endcase

endmodule // dp_mux3ds

// ---------------------------------------------------------------------


module dp_buffer(dout, in);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in;

assign dout = in;

endmodule // dp_buffer









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: test_stub_scan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// ____________________________________________________________________________
//
//  test_stub_bist - Test Stub with Scan Support
// ____________________________________________________________________________
//
// Description: DBB interface for test signal generation
// ____________________________________________________________________________

module test_stub_scan (/*AUTOARG*/
// Outputs
mux_drive_disable, mem_write_disable, sehold, se, testmode_l, 
mem_bypass, so_0, so_1, so_2, 
// Inputs
ctu_tst_pre_grst_l, arst_l, global_shift_enable, 
ctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, 
ctu_tst_short_chain, long_chain_so_0, short_chain_so_0, 
long_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2
);

   input        ctu_tst_pre_grst_l;
   input        arst_l;                // no longer used
   input        global_shift_enable;
   input        ctu_tst_scan_disable;  // redefined as pin_based_scan
   input        ctu_tst_scanmode;
   input 	ctu_tst_macrotest;
   input 	ctu_tst_short_chain;
   input 	long_chain_so_0;
   input 	short_chain_so_0;
   input 	long_chain_so_1;
   input 	short_chain_so_1;
   input 	long_chain_so_2;
   input 	short_chain_so_2;
   
   output 	mux_drive_disable;
   output 	mem_write_disable;
   output 	sehold;
   output 	se;
   output 	testmode_l;
   output 	mem_bypass;
   output 	so_0;
   output 	so_1;
   output 	so_2;

   wire         pin_based_scan;
   wire         short_chain_en;
   wire         short_chain_select;

   // INTERNAL CLUSTER CONNECTIONS
   //
   // Scan Chain Hookup
   // =================
   //
   // Scan chains have two configurations: long and short.
   // The short chain is typically the first tenth of the
   // long chain. The short chain should contain memory
   // collar flops for deep arrays. The CTU determines
   // which configuration is selected. Up to three chains
   // are supported.
   //
   // The scanout connections from the long and short
   // chains connect to the following inputs:
   //
   // long_chain_so_0, short_chain_so_0 (mandatory)
   // long_chain_so_1, short_chain_so_1 (optional)
   // long_chain_so_2, short_chain_so_2 (optional)
   //
   // The test stub outputs should connect directly to the
   // scanout port(s) of the cluster:
   //
   // so_0 (mandatory), so_1 (optional), so_2 (optional)
   //
   //
   // Static Output Signals
   // =====================
   //
   // testmode_l
   //
   // Local testmode control for overriding gated
   // clocks, asynchronous resets, etc. Asserted
   // for all shift-based test modes.
   //
   // mem_bypass
   //
   // Memory bypass control for arrays without output
   // flops. Allows testing of shadow logic. Asserted
   // for scan test; de-asserted for macrotest.
   //
   //
   // Dynamic Output Signals
   // ======================
   //
   // sehold
   //
   // The sehold signal needs to be set for macrotest
   // to allow holding flops in the array collars
   // to retain their shifted data during capture.
   // Inverted version of scan enable during macrotest.
   //
   // mux_drive_disable (for mux/long chain protection)
   //
   // Activate one-hot mux protection circuitry during
   // scan shift and reset. Formerly known as rst_tri_en.
   // Also used by long chain memories with embedded
   // control.
   //
   // mem_write_disable (for short chain protection)
   //
   // Protects contents of short chain memories during
   // shift and POR.
   //
   // se

   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;
   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;
   assign  sehold             = ctu_tst_macrotest & ~se;
   assign  se                 = global_shift_enable;
   assign  testmode_l         = ~ctu_tst_scanmode;
   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;
   assign  pin_based_scan     = ctu_tst_scan_disable;
   assign  short_chain_en     = ~(pin_based_scan & se);
   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;
   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;
   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;
   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;
   
endmodule // test_stub_scan
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: u1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
//
// basic gates {
//
////////////////////////////////////////////////////////////////////////


//bw_u1_inv_0p6x
//
//

module bw_u1_inv_0p6x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1x
//
//

module bw_u1_inv_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1p4x
//
//

module bw_u1_inv_1p4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_2x
//
//

module bw_u1_inv_2x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_3x
//
//

module bw_u1_inv_3x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_4x
//
//

module bw_u1_inv_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule



//bw_u1_inv_5x
//
//

module bw_u1_inv_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_8x
//
//

module bw_u1_inv_8x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_10x
//
//

module bw_u1_inv_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_15x
//
//

module bw_u1_inv_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_20x
//
//

module bw_u1_inv_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_30x
//
//

module bw_u1_inv_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_40x
//
//

module bw_u1_inv_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_15x
//
//

module bw_u1_invh_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_25x
//
//

module bw_u1_invh_25x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_30x
//
//

module bw_u1_invh_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_50x
//
//

module bw_u1_invh_50x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_60x
//
//

module bw_u1_invh_60x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule




//bw_u1_nand2_0p4x
//
//
module bw_u1_nand2_0p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_0p6x
//
//
module bw_u1_nand2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1x
//
//
module bw_u1_nand2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1p4x
//
//
module bw_u1_nand2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_2x
//
//
module bw_u1_nand2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_3x
//
//
module bw_u1_nand2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_4x
//
//
module bw_u1_nand2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_5x
//
//
module bw_u1_nand2_5x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_7x
//
//
module bw_u1_nand2_7x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_10x
//
//
module bw_u1_nand2_10x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_15x
//
//
module bw_u1_nand2_15x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand3_0p4x
//
//
module bw_u1_nand3_0p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule




//bw_u1_nand3_0p6x
//
//
module bw_u1_nand3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule



//bw_u1_nand3_1x

//
//
module bw_u1_nand3_1x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_1p4x

//
//
module bw_u1_nand3_1p4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_2x

//
//
module bw_u1_nand3_2x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_3x

//
//
module bw_u1_nand3_3x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_4x

//
//
module bw_u1_nand3_4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_5x

//
//
module bw_u1_nand3_5x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_7x

//
//
module bw_u1_nand3_7x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_10x

//
//
module bw_u1_nand3_10x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand4_0p6x

//
//
module bw_u1_nand4_0p6x (
    z,
    a,  
    b,  
    c,  
    d );
    
    output z;
    input  a;
    input  b;
    input  c;
    input  d;
    
    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1x
//
//
module bw_u1_nand4_1x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1p4x
//
//
module bw_u1_nand4_1p4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_2x
//
//
module bw_u1_nand4_2x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_3x
//
//
module bw_u1_nand4_3x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_4x
//
//
module bw_u1_nand4_4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_6x
//
//

module bw_u1_nand4_6x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nand4_8x
//
//

module bw_u1_nand4_8x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nor2_0p6x
//
//

module bw_u1_nor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1x
//
//

module bw_u1_nor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1p4x
//
//

module bw_u1_nor2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_2x
//
//

module bw_u1_nor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_3x
//
//

module bw_u1_nor2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_4x
//
//

module bw_u1_nor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_6x
//
//

module bw_u1_nor2_6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_8x
//
//

module bw_u1_nor2_8x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_12x
//
//

module bw_u1_nor2_12x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule




//bw_u1_nor3_0p6x
//
//

module bw_u1_nor3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1x
//
//

module bw_u1_nor3_1x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1p4x
//
//

module bw_u1_nor3_1p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_2x
//
//

module bw_u1_nor3_2x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_3x
//
//

module bw_u1_nor3_3x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_4x
//
//

module bw_u1_nor3_4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_6x
//
//

module bw_u1_nor3_6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_8x
//
//

module bw_u1_nor3_8x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_aoi21_0p4x
//
// 
module bw_u1_aoi21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_1x
//
// 
module bw_u1_aoi21_1x (

    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a  ));

endmodule
//bw_u1_aoi21_2x
//
// 
module bw_u1_aoi21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_4x
//
// 
module bw_u1_aoi21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_8x
//
// 
module bw_u1_aoi21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_12x
//
// 
module bw_u1_aoi21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi22_0p4x
//
// 
module bw_u1_aoi22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_1x
//
// 
module bw_u1_aoi22_1x (
    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;


    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_2x
//
// 
module bw_u1_aoi22_2x (


    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;
 
    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_4x
//
// 
module bw_u1_aoi22_4x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_8x
//
// 
module bw_u1_aoi22_8x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi211_0p3x
//
// 
module bw_u1_aoi211_0p3x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_1x
//
// 
module bw_u1_aoi211_1x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_2x
//
// 
module bw_u1_aoi211_2x (



    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_4x
//
// 
module bw_u1_aoi211_4x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_8x
//
// 
module bw_u1_aoi211_8x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_oai21_0p4x
//
//
module bw_u1_oai21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_1x
//
//
module bw_u1_oai21_1x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_2x
//
//
module bw_u1_oai21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_4x
//
//
module bw_u1_oai21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_8x
//
//
module bw_u1_oai21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_12x
//
//
module bw_u1_oai21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai22_0p4x
// 
module bw_u1_oai22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_1x
// 
module bw_u1_oai22_1x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_2x
// 
module bw_u1_oai22_2x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_4x
// 
module bw_u1_oai22_4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_8x
// 
module bw_u1_oai22_8x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai211_0p3x
//
//
module bw_u1_oai211_0p3x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_1x
//
//
module bw_u1_oai211_1x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_2x
//
//
module bw_u1_oai211_2x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_4x
//
//
module bw_u1_oai211_4x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_8x
//
//
module bw_u1_oai211_8x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_aoi31_1x
//
// 
module bw_u1_aoi31_1x (


    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_2x
//
// 
module bw_u1_aoi31_2x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_4x
//
// 
module bw_u1_aoi31_4x (
    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_8x
//
// 
module bw_u1_aoi31_8x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi32_1x
//
// 
module bw_u1_aoi32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_2x
//
// 
module bw_u1_aoi32_2x (
    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_4x
//
// 
module bw_u1_aoi32_4x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_8x
//
// 
module bw_u1_aoi32_8x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 
    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi33_1x
//
//
module bw_u1_aoi33_1x (




    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_2x
//
//
module bw_u1_aoi33_2x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_4x
//
//
module bw_u1_aoi33_4x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_8x
//
//
module bw_u1_aoi33_8x (
       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi221_1x
//
// 
module bw_u1_aoi221_1x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_2x
//
// 
module bw_u1_aoi221_2x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_4x
//
// 
module bw_u1_aoi221_4x (



    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_8x
//
// 
module bw_u1_aoi221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi222_1x
//
//
module bw_u1_aoi222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_aoi222_2x
//
//
module bw_u1_aoi222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi222_4x
//
//
module bw_u1_aoi222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi311_1x
//
//
module bw_u1_aoi311_1x (

    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_2x
//
//
module bw_u1_aoi311_2x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_4x
//
//
module bw_u1_aoi311_4x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;


    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_8x
//
//
module bw_u1_aoi311_8x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_oai31_1x
//
//
module bw_u1_oai31_1x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_2x
//
//
module bw_u1_oai31_2x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_4x
//
//
module bw_u1_oai31_4x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_8x
//
//
module bw_u1_oai31_8x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai32_1x
//
//
module bw_u1_oai32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_2x
//
//
module bw_u1_oai32_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_4x
//
//
module bw_u1_oai32_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_8x
//
//
module bw_u1_oai32_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai33_1x
//
//
module bw_u1_oai33_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_2x
//
//
module bw_u1_oai33_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_4x
//
//
module bw_u1_oai33_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_8x
//
//
module bw_u1_oai33_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai221_1x
//
//
module bw_u1_oai221_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_2x
//
//
module bw_u1_oai221_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_4x
//
//
module bw_u1_oai221_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_8x
//
//
module bw_u1_oai221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai222_1x
//
//
module bw_u1_oai222_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_2x
//
//
module bw_u1_oai222_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_4x
//
//
module bw_u1_oai222_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai311_1x
//
//
module bw_u1_oai311_1x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_2x
//
//
module bw_u1_oai311_2x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_4x
//
//
module bw_u1_oai311_4x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 | c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_8x
//
//
module bw_u1_oai311_8x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_muxi21_0p6x



module bw_u1_muxi21_0p6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_1x



module bw_u1_muxi21_1x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule







//bw_u1_muxi21_2x



module bw_u1_muxi21_2x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_4x



module bw_u1_muxi21_4x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule




//bw_u1_muxi21_6x


module bw_u1_muxi21_6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule

//bw_u1_muxi31d_4x
//

module bw_u1_muxi31d_4x (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
        zmuxi31d_prim i0 ( z, d0, d1, d2, s0, s1, s2 );
endmodule

//bw_u1_muxi41d_4x
//

module bw_u1_muxi41d_4x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule

//bw_u1_muxi41d_6x
//

module bw_u1_muxi41d_6x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule
 

//bw_u1_xor2_0p6x
//
// 
module bw_u1_xor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_1x
//
// 
module bw_u1_xor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_2x
//
// 
module bw_u1_xor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_4x
//
// 
module bw_u1_xor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xnor2_0p6x
//
// 
module bw_u1_xnor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_1x
//
// 
module bw_u1_xnor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_2x
//
// 
module bw_u1_xnor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_4x
//
// 
module bw_u1_xnor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule

//bw_u1_buf_1x
//

module bw_u1_buf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_buf_5x
//

module bw_u1_buf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_10x
//

module bw_u1_buf_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_15x
//

module bw_u1_buf_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_20x
//

module bw_u1_buf_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_30x
//

module bw_u1_buf_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_40x
//

module bw_u1_buf_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_ao2222_1x
//
//
module bw_u1_ao2222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_ao2222_2x
//
//
module bw_u1_ao2222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_ao2222_4x
//
//
module bw_u1_ao2222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

////////////////////////////////////////////////////////////////////////
//
// flipflops {
//
////////////////////////////////////////////////////////////////////////

//      scanable D-flipflop with scanout

module bw_u1_soff_1x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_2x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_8x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

//      fast scanable D-flipflop with scanout with inverted Q output

module bw_u1_soffi_4x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule
  
module bw_u1_soffi_8x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule

//      scanable D-flipflop with scanout with 2-to-1 input mux

module bw_u1_soffm2_4x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

module bw_u1_soffm2_8x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

//      scanable D-flipflop with scanout with sync reset-bar

module bw_u1_soffr_2x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule
  
module bw_u1_soffr_4x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

module bw_u1_soffr_8x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

//bw_u1_soffasr_2x

module bw_u1_soffasr_2x (q, so, ck, d, r_l, s_l, se, sd);
output q, so;
input  ck, d, r_l, s_l, se, sd;
        zsoffasr_prim i0 (q, so, ck, d, r_l, s_l, se, sd);
endmodule


//bw_u1_ckbuf_1p5x


module bw_u1_ckbuf_1p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_3x


module bw_u1_ckbuf_3x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_4p5x


module bw_u1_ckbuf_4p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_6x


module bw_u1_ckbuf_6x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_7x
//

module bw_u1_ckbuf_7x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_8x
//
module bw_u1_ckbuf_8x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_11x
//

module bw_u1_ckbuf_11x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_14x
//

module bw_u1_ckbuf_14x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_17x
//

module bw_u1_ckbuf_17x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_19x
//

module bw_u1_ckbuf_19x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_22x
//

module bw_u1_ckbuf_22x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_25x
//

module bw_u1_ckbuf_25x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_28x
//

module bw_u1_ckbuf_28x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_30x
//

module bw_u1_ckbuf_30x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_33x
//

module bw_u1_ckbuf_33x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_40x
//

module bw_u1_ckbuf_40x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


// gated clock buffers


module bw_u1_ckenbuf_6x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

module bw_u1_ckenbuf_14x (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule   

////////////////////////////////////////////////////////////////////////
//
// half cells
//
////////////////////////////////////////////////////////////////////////



module bw_u1_zhinv_0p6x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_1x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_1p4x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_2x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_3x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_4x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhnand2_0p4x (z, a, b);
output z;
input  a, b;
        nand (z, a, b);
endmodule


module bw_u1_zhnand2_0p6x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1p4x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_2x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_3x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_1x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_2x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule


module bw_u1_zhnand4_0p6x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_1x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_2x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule


        
module bw_u1_zhnor2_0p6x (z, a, b);
output z;
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_1x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_2x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule



module bw_u1_zhnor3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nor (z, a, b, c);
endmodule


module bw_u1_zhaoi21_0p4x (z,b1,b2,a);

    output z;   
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));
    
endmodule



module bw_u1_zhaoi21_1x (z, a, b1, b2);

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule



module bw_u1_zhoai21_1x (z,b1,b2,a );
    
    output z;
    input  b1;
    input  b2;  
    input  a;
  
    assign z = ~(( b1 | b2 ) & ( a ));
      
endmodule




module bw_u1_zhoai211_0p3x (z, a, b, c1, c2);
    output z; 
    input  c1;  
    input  c2;
    input  b;
    input  a;
      
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





module bw_u1_zhoai211_1x (z, a, b, c1, c2);
output z;
input  a, b, c1, c2;
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





/////////////// Scan data lock up latch ///////////////

module bw_u1_scanlg_2x (so, sd, ck, se);
output so;
input sd, ck, se;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd or se )
       if (~ck) so_l <= ~(sd & se) ;

endmodule

module bw_u1_scanl_2x (so, sd, ck);
output so;
input sd, ck;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd )
       if (~ck) so_l <= ~sd ;

endmodule



////////////////// Synchronizer ////////////////

module bw_u1_syncff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;

reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r;

endmodule




////////////////////////////////////////////////////////////////////////
//
// non library cells
// 
////////////////////////////////////////////////////////////////////////

// These cells are used only in custom DP macros
// Do not use in any block design without prior permission


module bw_u1_zzeccxor2_5x (z, a, b); 
 output z; 
 input a, b;
    assign z = ( a ^ b );

endmodule



module bw_u1_zzmulcsa42_5x (sum, carry, cout, a, b, c, d, cin);
output sum, carry, cout;
input  a, b, c, d, cin;
wire and_cin_b, or_cin_b, xor_a_c_d, and_or_cin_b_xor_a_c_d;
wire and_a_c, and_a_d, and_c_d;
        assign sum   = cin ^ a ^ b ^ c ^ d;
        assign carry = cin & b | (cin | b) & (a ^ c ^ d);
        assign cout  = a & c | a & d | c & d;
endmodule



module bw_u1_zzmulcsa32_5x (sum, cout, a, b, c);
output sum, cout;
input  a, b, c;
wire and_a_b, and_a_c, and_b_c;
        assign sum  = a ^ b ^ c ;
        assign cout = a & b | a & c | b & c ;
endmodule



module bw_u1_zzmulppmuxi21_2x ( z, d0, d1, s );
output  z;
input  d0, d1, s;
    assign z = s ? ~d1 : ~d0;
endmodule



module bw_u1_zzmulnand2_2x ( z, a, b );
output z;
input  a;
input  b;
    assign z = ~( a & b );
endmodule



// Primitives




module zmuxi31d_prim (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
// for Blacktie



wire [2:0] sel = {s0,s1,s2}; // 0in one_hot
reg z;
    always @ (s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s2,d2,s1,d1,s0,d0})
            6'b0?0?10: z = 1'b1;  
            6'b0?0?11: z = 1'b0;  
            6'b0?100?: z = 1'b1;  
            6'b0?110?: z = 1'b0;  
            6'b0?1010: z = 1'b1;  
            6'b0?1111: z = 1'b0;  
            6'b100?0?: z = 1'b1;  
            6'b110?0?: z = 1'b0;  
            6'b100?10: z = 1'b1;  
            6'b110?11: z = 1'b0;  
            6'b10100?: z = 1'b1;  
            6'b11110?: z = 1'b0;  
            6'b101010: z = 1'b1;  
            6'b111111: z = 1'b0;  
            default: z = 1'bx;
        endcase
endmodule







module zmuxi41d_prim (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
// for Blacktie



wire [3:0] sel = {s0,s1,s2,s3}; // 0in one_hot
reg z;
    always @ (s3 or d3 or s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s3,d3,s2,d2,s1,d1,s0,d0})
            8'b0?0?0?10: z = 1'b1;
            8'b0?0?0?11: z = 1'b0;
            8'b0?0?100?: z = 1'b1;
            8'b0?0?110?: z = 1'b0;
            8'b0?0?1010: z = 1'b1;
            8'b0?0?1111: z = 1'b0;
            8'b0?100?0?: z = 1'b1;
            8'b0?110?0?: z = 1'b0;
            8'b0?100?10: z = 1'b1;
            8'b0?110?11: z = 1'b0;
            8'b0?10100?: z = 1'b1;
            8'b0?11110?: z = 1'b0;
            8'b0?101010: z = 1'b1;
            8'b0?111111: z = 1'b0;
            8'b100?0?0?: z = 1'b1;
            8'b110?0?0?: z = 1'b0;
            8'b100?0?10: z = 1'b1;
            8'b110?0?11: z = 1'b0;
            8'b100?100?: z = 1'b1;
            8'b110?110?: z = 1'b0;
            8'b100?1010: z = 1'b1;
            8'b110?1111: z = 1'b0;
            8'b10100?0?: z = 1'b1;
            8'b11110?0?: z = 1'b0;
            8'b10100?10: z = 1'b1;
            8'b11110?11: z = 1'b0;
            8'b1010100?: z = 1'b1;
            8'b1111110?: z = 1'b0;
            8'b10101010: z = 1'b1;
            8'b11111111: z = 1'b0;
            default: z = 1'bx;
        endcase   
endmodule



module zsoff_prim (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r ;
endmodule


module zsoffr_prim (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (d & r_l) ;
  assign q  = q_r;
  assign so = q_r;
endmodule


module zsoffi_prim (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q_l = ~q_r;
  assign so  = q_r;
endmodule



module zsoffm2_prim (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (s ? d1 : d0) ;
  assign q  = q_r;
  assign so = q_r;
endmodule

module zsoffasr_prim (q, so, ck, d, r_l, s_l, se, sd);
  output q, so;
  input ck, d, r_l, s_l, se, sd;

  // asynchronous reset and asynchronous set
  // (priority: r_l > s_l > se > d)
  reg q;
  wire so;

  always @ (posedge ck or negedge r_l or negedge s_l) begin
		if(~r_l) q <= 1'b0;
		else if (~s_l) q <= r_l;
		else if (se) q <= r_l & s_l & sd;
		else q <= r_l & s_l & (~se) & d;
  end

  assign so = q | ~se;

endmodule



module zckenbuf_prim (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
reg    clken;

  always @ (rclk or en_l or tm_l)
    if (!rclk)  //latch opens on rclk low phase
      clken <= ~en_l | ~tm_l;
  assign clk = clken & rclk;

endmodule

module bw_mckbuf_40x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_33x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_30x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_28x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_25x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_22x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_19x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_17x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_14x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_11x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_8x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_7x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_6x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_4p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_3x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_1p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

//bw_u1_minbuf_1x
//

module bw_u1_minbuf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_4x
//

module bw_u1_minbuf_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_5x
//

module bw_u1_minbuf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

module bw_u1_ckenbuf_4p5x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

// dummy fill modules to get rid of DFT "CAP" property errors (bug 5487)

module bw_u1_fill_1x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_2x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_3x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_4x(\vdd! );
input \vdd! ;
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_in.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:	ucb_bus_in (ucb bus inbound interface block)
//  Description:	This interface block is instaniated by the
//                      UCB modules and IO Bridge to receive packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
			// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Interface signal list declarations
////////////////////////////////////////////////////////////////////////
module ucb_bus_in (/*AUTOARG*/
   // Outputs
   stall, indata_buf_vld, indata_buf,
   // Inputs
   rst_l, clk, vld, data, stall_a1
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;


////////////////////////////////////////////////////////////////////////
// Signal declarations
////////////////////////////////////////////////////////////////////////
   // Global interface
   input                     rst_l;
   input 		     clk;


   // UCB bus interface
   input 		     vld;
   input [UCB_BUS_WIDTH-1:0] data;
   output 		     stall;


   // Local interface
   output 		     indata_buf_vld;
   output [REG_WIDTH+63:0]   indata_buf;
   input 		     stall_a1; // would this prevent indata_buf to change?


   // Internal signals
   wire 		     vld_d1;
   wire 		     stall_d1;
   wire [UCB_BUS_WIDTH-1:0]  data_d1;
   wire 		     skid_buf0_en;
   wire 		     vld_buf0;
   wire [UCB_BUS_WIDTH-1:0]  data_buf0;
   wire 		     skid_buf1_en;
   wire 		     vld_buf1;
   wire [UCB_BUS_WIDTH-1:0]  data_buf1;
   wire 		     skid_buf0_sel;
   wire 		     skid_buf1_sel;
   wire 		     vld_mux;
   wire [UCB_BUS_WIDTH-1:0]  data_mux;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec_next;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec;
   wire [REG_WIDTH+63:0]     indata_buf_next;
   wire 		     indata_vec0_d1;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    * This is to make signals going between IOB and UCB flop-to-flop
    * to improve timing.
    ************************************************************/
   dffrle_ns #(1) vld_d1_ff (.din(vld),
			     .rst_l(rst_l),
			     .en(~stall_d1),
			     .clk(clk),
			     .q(vld_d1));

   dffe_ns #(UCB_BUS_WIDTH) data_d1_ff (.din(data),
					.en(~stall_d1),
					.clk(clk),
					.q(data_d1));

   dffrl_ns #(1) stall_ff (.din(stall_a1),
			   .clk(clk),
			   .rst_l(rst_l),
			   .q(stall));

   dffrl_ns #(1) stall_d1_ff (.din(stall),
			      .clk(clk),
			      .rst_l(rst_l),
			      .q(stall_d1));


   /************************************************************
    * Skid buffer
    * We need a two deep skid buffer to handle stalling.
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   // Buffer 0
   assign 	 skid_buf0_en = stall_a1 & ~stall;

   dffrle_ns #(1) vld_buf0_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf0_en),
			       .clk(clk),
			       .q(vld_buf0));

   dffe_ns #(UCB_BUS_WIDTH) data_buf0_ff (.din(data_d1),
					  .en(skid_buf0_en),
					  .clk(clk),
					  .q(data_buf0));

   // Buffer 1
   dffrl_ns #(1) skid_buf1_en_ff (.din(skid_buf0_en),
				  .clk(clk),
				  .rst_l(rst_l),
				  .q(skid_buf1_en));

   dffrle_ns #(1) vld_buf1_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf1_en),
			       .clk(clk),
			       .q(vld_buf1));

   dffe_ns #(UCB_BUS_WIDTH) data_buf1_ff (.din(data_d1),
					  .en(skid_buf1_en),
					  .clk(clk),
					  .q(data_buf1));


   /************************************************************
    * Mux between skid buffer and interface flop
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   assign 	 skid_buf0_sel = ~stall_a1 & stall;

   dffrl_ns #(1) skid_buf1_sel_ff (.din(skid_buf0_sel),
				   .clk(clk),
				   .rst_l(rst_l),
				   .q(skid_buf1_sel));

   assign 	 vld_mux = skid_buf0_sel ? vld_buf0 :
		           skid_buf1_sel ? vld_buf1 :
		                           vld_d1;

   assign 	 data_mux = skid_buf0_sel ? data_buf0 :
		            skid_buf1_sel ? data_buf1 :
		                            data_d1;


   /************************************************************
    * Assemble inbound data
    ************************************************************/
   // valid vector
   assign 	 indata_vec_next = {vld_mux,
				    indata_vec[(REG_WIDTH+64)/UCB_BUS_WIDTH-1:1]};
   dffrle_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) indata_vec_ff (.din(indata_vec_next),
							    .en(~stall_a1),
							    .rst_l(rst_l),
							    .clk(clk),
							    .q(indata_vec));

   // data buffer
   assign 	 indata_buf_next = {data_mux,
				    indata_buf[REG_WIDTH+63:UCB_BUS_WIDTH]};
   dffe_ns #(REG_WIDTH+64) indata_buf_ff (.din(indata_buf_next),
					  .en(~stall_a1),
					  .clk(clk),
					  .q(indata_buf));

   // detect a new packet
   dffrle_ns #(1) indata_vec0_d1_ff (.din(indata_vec[0]),
				     .rst_l(rst_l),
				     .en(~stall_a1),
				     .clk(clk),
				     .q(indata_vec0_d1));

   assign        indata_buf_vld = indata_vec[0] & ~indata_vec0_d1;


endmodule // ucb_bus_in
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_out.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:        ucb_bus_out (ucb bus outbound interface block)
//	Description:	This interface block is instantiated by the
//                      UCB modules and IO Bridge to transmit packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which
                        // contains the time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module ucb_bus_out (/*AUTOARG*/
   // Outputs
   vld, data, outdata_buf_busy,
   // Inputs
   clk, rst_l, stall, outdata_buf_in, outdata_vec_in, outdata_buf_wr
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;            // maximum data bits that needs to
                                        // be sent.  Set to 64 or 128

   // Globals
   input                                clk;
   input 				rst_l;


   // UCB bus interface
   output 				vld;
   output [UCB_BUS_WIDTH-1:0] 		data;
   input 				stall;


   // Local interface
   output 				outdata_buf_busy;  // busy outputting, can't accept data into buffer
   input [REG_WIDTH+63:0] 		outdata_buf_in;
   input [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] outdata_vec_in; // indicating how much data to send
   input 				outdata_buf_wr;


   // Local signals
   wire 				stall_d1;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec_next;
   wire [REG_WIDTH+63:0] 		outdata_buf;
   reg [REG_WIDTH+63:0] 		outdata_buf_next;
   wire 				load_outdata;
   wire 				shift_outdata;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    ************************************************************/
   assign 	 vld = outdata_vec[0];
   // assign 	 data = vld ? outdata_buf[UCB_BUS_WIDTH-1:0] : `UCB_BUS_WIDTH'b0;
   assign    data = outdata_buf[UCB_BUS_WIDTH-1:0];

   dffrl_ns #(1) stall_d1_ff (.din(stall),
                              .clk(clk),
                              .rst_l(rst_l),
                              .q(stall_d1));


   /************************************************************
    * Outbound Data
    ************************************************************/
   // accept new data only if there is none being processed
   assign 	 load_outdata = outdata_buf_wr & ~outdata_buf_busy;

   assign 	 outdata_buf_busy = outdata_vec[0] | stall_d1;

   // only shifts when then input vector is a straight valids
   assign 	 shift_outdata = outdata_vec[0] & ~stall_d1;

   assign 	 outdata_vec_next =
		 load_outdata  ? outdata_vec_in:
		 shift_outdata ? outdata_vec >> 1:
	                         outdata_vec;
   dffrl_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) outdata_vec_ff (.din(outdata_vec_next),
							    .clk(clk),
							    .rst_l(rst_l),
							    .q(outdata_vec));

   // assign 	 outdata_buf_next =
		 // load_outdata  ? outdata_buf_in:
		 // shift_outdata ? (outdata_buf >> UCB_BUS_WIDTH):
	  //                        outdata_buf;
   always @ *
   begin
      if (load_outdata)
         outdata_buf_next = outdata_buf_in;
      else if (shift_outdata)
      begin
         outdata_buf_next = outdata_buf >> UCB_BUS_WIDTH;
         if (outdata_vec[1] == 1'b0)
            outdata_buf_next[UCB_BUS_WIDTH-1:0] = 0;
      end
      else
         outdata_buf_next = outdata_buf; // no shifting
   end

   dff_ns #(REG_WIDTH+64) outdata_buf_ff (.din(outdata_buf_next),
					  .clk(clk),
					  .q(outdata_buf));


endmodule // ucb_bus_out






// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//File: valrdy_to_credit.v (modified from space_avail_top.v)
//
//Modified: Yaosheng Fu
//May 2, 2014
//
//Function: This module keeps track of how many spots are free in the NIB that
//	we are sending to
//
//State: count_f, yummy_out_f, valid_in_f
//
//Instantiates: 
//

module valrdy_to_credit (
            clk,
            reset,
                
            //val/rdy interface
            data_in,
            valid_in,
            ready_in,

			//credit based interface	
            data_out,
            valid_out,
		    yummy_out);

parameter BUFFER_SIZE = 4;
parameter BUFFER_BITS = 3;
   
input clk;
input reset;

 
input [64-1:0]	 data_in;
 input valid_in;			// sending data to the output
 input yummy_out;			// output consumed data

output [64-1:0]  data_out;
 output valid_out;
 output ready_in;		// is there space available?


//This is the state
 reg yummy_out_f;
 reg valid_temp_f;
 reg [BUFFER_BITS-1:0] count_f;

reg is_one_f;
 reg is_two_or_more_f;

//wires
 wire [BUFFER_BITS-1:0] count_plus_1;
 wire [BUFFER_BITS-1:0] count_minus_1;
 wire up;
 wire down;

 wire valid_temp;

//wire regs
  reg [BUFFER_BITS-1:0] count_temp;


//assigns
assign data_out = data_in;
assign valid_temp = valid_in & ready_in;
assign valid_out = valid_temp;

assign count_plus_1 = count_f + 1'b1;
assign count_minus_1 = count_f - 1'b1;
assign ready_in = is_two_or_more_f;
assign up = yummy_out_f & ~valid_temp_f;
assign down = ~yummy_out_f & valid_temp_f;

always @ (count_f or count_plus_1 or count_minus_1 or up or down)
begin
	case (count_f)
	0:
		begin
			if(up)
			begin
				count_temp <= count_plus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	BUFFER_SIZE:
		begin
			if(down)
			begin
				count_temp <= count_minus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	default:
		begin
			case ({up, down})
				2'b10:	count_temp <= count_plus_1;
				2'b01:	count_temp <= count_minus_1;
				default:	count_temp <= count_f;
			endcase
		end
	endcase
end

//wire top_bits_zero_temp = ~| count_temp[BUFFER_BITS-1:1];
 wire top_bits_zero_temp = count_temp < 3 ? 1 : 0;

always @ (posedge clk)
begin
	if(reset)
	begin
	   count_f <= BUFFER_SIZE;
	   yummy_out_f <= 1'b0;
	   valid_temp_f <= 1'b0;
	   is_one_f <= (BUFFER_SIZE == 1);
	   is_two_or_more_f <= (BUFFER_SIZE >= 2);
	end
	else
	begin
	   count_f <= count_temp;
	   yummy_out_f <= yummy_out;
	   valid_temp_f <= valid_temp;
	   is_one_f         <= top_bits_zero_temp & count_temp[0];
   	   is_two_or_more_f <= ~top_bits_zero_temp;
	end
end

endmodule
      
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




// Uncomment to define USE_GENERIC_SRAM_IMPLEMENTATION to use the old unsynthesizable BRAM
// `define USE_GENERIC_SRAM_IMPLEMENTATION




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

// Tile config

// devices.xml





// NoC interface





















// NodeID decomposition








//========================
//Packet format
//=========================

//Header decomposition































// these shifted fields are added for convienience
// HEADER 2








// HEADER 3








//NoC header information










// Width of MSG_ADDR field - you're probably looking for PHY_ADDR_WIDTH


//Coherence information





//Requests from L15 to L2
// Should always make #0 an error








//condition satisfied

//condition not satisfied

//Both SWAP and LDSTUB are the same for L2









//RISC-V AMO requests









//RISC-V AMO L2-internal phase 1









//RISC-V AMO L2-internal phase 2












//Forward requests from L2 to L15







//Memory requests from L2 to DRAM






//Forward acks from L15 to L2







//Memory acks from memory to L2









//Acks from L2 to L15


//TODO



//Only exist within L2





//`define MSG_TYPE_LOAD_REQ           8'd31 if this is enabled, don't use 31





// These should be defined in l2.vh, not the global defines











//Physical address










//Transition data size












//`define HOME_ID_MASK_X          10:10
//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only


// Tri: dynamically adjust these parameters based on how many tiles are available
//  Assumption: 8x8 topology























































//`define DMBR_TAG_WIDTH 4

//Clumpy Shared Memory






////////////////////////////////////////////
// SOME CONFIGURATION REGISTERS DEFINES
////////////////////////////////////////////
// example: read/write to csm_en would be 0xba_0000_0100

// `define ASI_ADDRESS_MASK    `L15_ADDR_TYPE
// `define CONFIG_ASI_ADDRESS  `L15_ADDR_TYPE_WIDTH'hba










// DMBR Config register 1 fields















// DMBR Config register 2 fields



//Home allocation method






//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only

































//`define TTE_CSM_WIDTH           64
//`define TTE_CSM                 63:0
//`define TTE_CSM_VALID           63
//`define TTE_CSM_SZL             62:61
//`define TTE_CSM_NFO             60
//`define TTE_CSM_IE              59
//`define TTE_CSM_SOFT2           58:49
//`define TTE_CSM_SZH             48
//`define TTE_CSM_DIAG            47:40
//`define TTE_CSM_RES1            39
//`define TTE_CSM_SDID            38:29
//`define TTE_CSM_HDID            28:19
//`define TTE_CSM_LSID            18:13
//`define TTE_CSM_SOFT            12:8
//`define TTE_CSM_RES2            7
//`define TTE_CSM_LOCK            6
//`define TTE_CSM_CP              5
//`define TTE_CSM_CV              4
//`define TTE_CSM_E               3
//`define TTE_CSM_P               2
//`define TTE_CSM_W               1
//`define TTE_CSM_RES3            0







//`define HOME_ID_X_POS_WIDTH         3
//`define HOME_ID_X_POS               2:0
//`define HOME_ID_Y_POS_WIDTH         3
//`define HOME_ID_Y_POS               5:3

// Packet format for home id





/////////////////////////////////////
// BIST
/////////////////////////////////////

// the data width from tap to individual sram wrappers



//deprecated































/////////////////////////////////////
// IDs for JTAG-Core interface
/////////////////////////////////////

// 48b for writing the PC reset vector

// 94b for reading the sscan data











// Execution Drafting Synchronization Method Values





// Execution Drafting timeout counter bit width


// Configuration registers












// Execution Drafting configuration register bit positions








// Execution Drafting configuration register default values
// ED disabled, STSM sync method, LFSR seed = 16'b0, LFSR load = 1'b0,
// Counter Timeout = 16'd32



//Clumpy sharer memory configuration registers
























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]






// `define L15_CACHELINE_WIDTH 128

















// devices.xml
// this is used in the ariane SV packages to derive the parameterization



















































// 7

// 7




// 16B cache lines

// 10




// 40 - 4 (16B line) - 7 (index width) = 29

// 11

// 39


// this need to be defined when L1.5 has more sets than L1D
// for correct operations
// `define L15_WMT_EXTENDED_ALIAS


// `define L15_WMT_ALIAS_WIDTH 4
// `define L15_WMT_ALIAS_LOW `L1D_SET_IDX_HI+1

// `define L15_WMT_ALIAS_HI `L15_WMT_ALIAS_LOW + `L15_WMT_ALIAS_WIDTH - 1












// `define L15_WMT_ENTRY_0_MASK 1*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_1_MASK 2*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_2_MASK 3*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_3_MASK 4*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_0_VALID_MASK 1*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_1_VALID_MASK 2*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_2_VALID_MASK 3*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_3_VALID_MASK 4*`L15_WMT_ENTRY_WIDTH-1


  
  


  
  







// LRU array storage
// keeps 6 bits per cache set: 4 "used" bits, 1 each cache line, and 2 bits for wayid round robin (4w)





// source





// MSHR






// controls how many mshr there are
// `define L15_MSHR_COUNT 10
// should be more than the count above when 2^n











// pipeline OPs




// `define L15_MSHR_ALLOCATE_TYPE_WIDTH 2
// `define L15_MSHR_ALLOCATE_TYPE_LD 2'd1
// `define L15_MSHR_ALLOCATE_TYPE_ST 2'd2
// `define L15_MSHR_ALLOCATE_TYPE_IFILL 2'd3









































































































// `define PCX_REQ_SIZE_WIDTH 4


























// define the width of the flattened, native L15 interface, used for ARIANE_RV64 option



























// [L15_DTAG_OP_WIDTH-1:0]































//`define L15_S3_MESI_WRITE_TAGCHECK_WAY_M_IF_LRSC_SET 3'd7






























































// `define L15_NOC1_DUMMY_GEN_NOC1_CREDIT 5'd11










































// L2 shared states


// `define L15_NOC2_ACK_STATE_WIDTH 2
// `define L15_NOC2_ACK_STATE_S 2'd1
// `define L15_NOC2_ACK_STATE_E 2'd2
// `define L15_NOC2_ACK_STATE_M 2'd3

// `define L15_NOC1_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC1_REQTYPE_WRITEBACK_GUARD `MSG_TYPE_WBGUARD_REQ
// `define L15_NOC1_REQTYPE_LD_REQUEST `MSG_TYPE_LOAD_REQ
// `define L15_NOC1_REQTYPE_LD_PREFETCH_REQUEST `MSG_TYPE_PREFETCH_REQ
// `define L15_NOC1_REQTYPE_LD_NC_REQUEST `MSG_TYPE_NC_LOAD_REQ
// `define L15_NOC1_REQTYPE_IFILL_REQUEST `MSG_TYPE_LOAD_REQ
// // `define L15_NOC1_REQTYPE_WRITETHROUGH_REQUEST 6'd4
// `define L15_NOC1_REQTYPE_ST_REQUEST `MSG_TYPE_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_REQUEST `MSG_TYPE_BLK_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_INIT_REQUEST `MSG_TYPE_BLKINIT_STORE_REQ
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE_ST_UPGRADE_REQUEST 6
// // `define L15_NOC1_REQTYPE_ST_FILL_REQUEST 6'd6
// `define L15_NOC1_REQTYPE_CAS_REQUEST `MSG_TYPE_CAS_REQ
// `define L15_NOC1_REQTYPE_SWAP_REQUEST `MSG_TYPE_SWAP_REQ

// `define L15_NOC3_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC3_REQTYPE_WRITEBACK `MSG_TYPE_WB_REQ
// `define L15_NOC3_REQTYPE_NO_DATA_FWD_ACK `MSG_TYPE_NODATA_ACK
// `define L15_NOC3_REQTYPE_DATA_FWD_ACK `MSG_TYPE_DATA_ACK

// `define L2_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L2_REQTYPE_INVALIDATE 6'd1
// `define L2_REQTYPE_DOWNGRADE 6'd2
// `define L2_REQTYPE_ACKDT_LD_NC 6'd3
// `define L2_REQTYPE_ACKDT_IFILL 6'd4
// `define L2_REQTYPE_ACKDT_LD 6'd5
// `define L2_REQTYPE_ACKDT_ST_IM 6'd6
// `define L2_REQTYPE_ACKDT_ST_SM 6'd7
// `define L2_REQTYPE_ACK_WRITETHROUGH 6'd8
// `define L2_REQTYPE_ACK_ATOMIC 6'd9






































// NOC1 ENCODER











// NOC3 ENCODER










// NOC2 BUFFER





// DMBR
// put this here for now, should be moved to a more appropriate location


// NOC1 CREDIT MANAGEMENT
// becareful, the noc1buffer module assumes these are power of two
// also, please change the corresponding pyv value in noc1buffer.v.pyv























// `define L15_NOC1BUFFER_BLKSTORE_LO  `L15_NOC1BUFFER_PREFETCH_HI + 1
// `define L15_NOC1BUFFER_BLKSTORE_HI  `L15_NOC1BUFFER_BLKSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_BLKINITSTORE_LO  `L15_NOC1BUFFER_BLKSTORE_HI + 1
// `define L15_NOC1BUFFER_BLKINITSTORE_HI  `L15_NOC1BUFFER_BLKINITSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_DATA_INDEX_LO  `L15_NOC1BUFFER_BLKINITSTORE_HI + 1
































// `define L15_CPUID_ADDRESS 40'h9800000900






////////////////
// CSM
////////////////



// Tri: save space on l15 sram






















//HMC array
































//Special addresses for HMC


//`define L15_ADDR_TYPE_TAG_ACCESS     8'hb4 // later
//`define L15_ADDR_TYPE_STATE_ACCESS   8'hb6 // later
//`define L15_ADDR_TYPE_DIR_ACCESS     8'hb1 // later
//`define L15_ADDR_TYPE_CTRL_REG       8'hb9
//`define L15_ADDR_TYPE_DIS_FLUSH      8'hbc, 8'hbd, 8'hbe, 8'hbf
// `define L15_ADDR_TYPE_HMT_BASE_REG      8'hb7


















// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml



module flat_id_to_xy(
    input  [(6-1):0] flat_id,
    output reg [(8-1):0] x_coord,
    output reg [(8-1):0] y_coord
);

    always @*
    begin
        case (flat_id)
        
//(`NOC_Y_WIDTH+`NOC_X_WIDTH)'d0: 
6'd0: 
begin
    x_coord = 8'd0;
    y_coord = 8'd0;
end

        default:
        begin
            x_coord = 8'dX;
            y_coord = 8'dX;
        end
        endcase
    end
endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]

















































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml



module xy_to_flat_id(
    input  [(8-1):0] x_coord,
    input  [(8-1):0] y_coord,
    output reg [(6-1):0] flat_id
);
    
    
    always @*
    begin
        case (x_coord)
        
8'd0:
begin
     case (y_coord)

    // (x,y) = (0, 0)
    8'd0:
    begin
        flat_id = 6'd0;
    end
     default:
     begin
         flat_id = 6'dX;
     end
     endcase
end

        default:
        begin
            flat_id = 6'dX;
        end
        endcase
    end
endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_1rw_128x78
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [7-1:0] A,
input wire RDWEN,
input wire [78-1:0] BW,
input wire [78-1:0] DIN,
output wire [78-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [78-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (128),
   .ADDR_WIDTH    (7),
   .BITMASK_WIDTH (78),
   .DATA_WIDTH    (78)
)   sram_1rw_128x78 (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// Author: Tri Nguyen

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE







module sram_l1d_data_piton
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6:0] A,
input wire RDWEN,
input wire [287:0] BW,
input wire [287:0] DIN,
output wire [287:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);
reg [287:0] cache [(256/2)-1:0];

integer i;
initial
begin
   for (i = 0; i < (256/2); i = i + 1)
   begin
      cache[i] = 0;
   end
end



   reg [287:0] dout_f;

   assign DOUT = dout_f;

   always @ (posedge MEMCLK)
   begin
      if (CE)
      begin
         if (RDWEN == 1'b0)
            cache[A] <= (DIN & BW) | (cache[A] & ~BW);
         else
            dout_f <= cache[A];
      end
   end

endmodule



















































































/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1d_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [(6+1)-1:0] A,
input wire RDWEN,
input wire [(33*2)-1:0] BW,
input wire [(33*2)-1:0] DIN,
output wire [(33*2)-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [(33*2)-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         ((256/2)),
   .ADDR_WIDTH    ((6+1)),
   .BITMASK_WIDTH ((33*2)),
   .DATA_WIDTH    ((33*2))
)   sram_l1d_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1i_data
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+2-1:0] A,
input wire RDWEN,
input wire [272-1:0] BW,
input wire [272-1:0] DIN,
output wire [272-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [272-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((16384/32/4))*2),
   .ADDR_WIDTH    (6+2),
   .BITMASK_WIDTH (272),
   .DATA_WIDTH    (272)
)   sram_l1i_data (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1i_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+1-1:0] A,
input wire RDWEN,
input wire [132-1:0] BW,
input wire [132-1:0] DIN,
output wire [132-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [132-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((16384/32/4))),
   .ADDR_WIDTH    (6+1),
   .BITMASK_WIDTH (132),
   .DATA_WIDTH    (132)
)   sram_l1i_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule

// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the generic portions of the Execution Drafting
 *      FSM.  Anything common to all synchronization methods is implemented
 *      here.  
 *
 *  Note: While the interface to this module supports 4 threads, the logic
 *  only supports 2
 */

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module sparc_ifu_esl_fsm
(
    input               clk,
    input               rst_n,

    // Configuration bits input
    input               config_esl_en,
    input [1:0]         config_esl_sync_method,

    // Counter timeout configuration value
    input [15:0]        config_esl_counter_timeout,

    // LFSR management signals
    input [15:0]        config_esl_lfsr_seed,
    input               config_esl_lfsr_ld,

    // Thread active signals from FSM
    input [3:0]         swl_esl_thr_active,

    // Thread ready signals from FSM, both non-speculative
    // ready and speculative ready
    input [3:0]         swl_esl_thr_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy_next,

    // Whether to use speculative rdy vector, meaning
    // there is no non-speculative ready thread
    input               swl_esl_use_spec,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Thread in F stage
    input [3:0]         fcl_esl_thr_f,

    // Rollback on this cycle
    input               fcl_esl_rb_stg_s,

    // Information about threads in thread select stage
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,
    input               esl_ctrl_flow_diverged_late_s,
    input               esl_pcs_pa_page_bndry_s,
    input               esl_any_trap_bf,
    input [3:0]         esl_min_pc_va_s,
    input               esl_pc_va_diff_lt_thresh_s,
    input               esl_pcs_va_eql_s,
    input               esl_unresolved_br,
    input               esl_brtrp_target_pc_bf_f,
    input               swl_esl_icmiss_out,

    // Synchronization output
    output reg [3:0]    esl_fcl_nextthr_bf,
    output reg          esl_fcl_stall_bf,
    output reg          esl_fcl_switch_bf,
    output reg          esl_fdp_sync_pcs_bf,
    output reg          esl_fcl_ntr_s,
    output reg          esl_fdp_issue_prev_inst_next_s,
    output reg          esl_fcl_force_running_s,
    output reg          esl_pc_va_diff_offset_we,
    output reg          esl_pc_va_diff_offset_clear
);

    //
    // Parameter Definitions
    //

    // State definitions
    localparam  DIVERGED = 0;
    localparam  DIVERGED_DRAFT = 1;
    localparam  CONVERGED = 2;
    localparam  CONVERGED_DRAFT = 3;
    localparam  DIVERGED_DIFFERENT_CODE_RCFG0 = 4;
    localparam  RCFG1 = 5;
    localparam  RCFG2 = 6;
    localparam  RCFG3 = 7;

    //
    // Signal Declarations
    //
    
    // LFSR control and output
    reg         esl_lfsr_step;
    wire        pseudo_rand_f;

    // Timeout counter control and output
    reg                                         esl_timeout_counter_step;
    reg                                         esl_timeout_counter_clear;
    reg                                         esl_timeout_counter_set;
    wire [16-1:0]    esl_timeout_counter_count_f;

    // Shift Register control and output
    reg                                         esl_timeout_shiftreg_step;
    reg                                         esl_timeout_shiftreg_set;
    wire [16-1:0]    esl_timeout_shiftreg_f;

    // Control signals for comparator for timeout control.
    // 1'b1 - Compare to configured timeout
    // 1'b0 - Compare to shift register
    reg                                         esl_timeout_counter_cmp_config;

    // Next state output decisions
    wire [2:0]  esl_stsm_state_next;
    wire [2:0]  esl_rtsm_state_next;
    wire [2:0]  esl_htsm_state_next;
    wire [2:0]  esl_rcfg_state_next;

    // Thread select output decisions
    wire [3:0]  esl_stsm_fcl_nextthr_bf;
    wire [3:0]  esl_rtsm_fcl_nextthr_bf;
    wire [3:0]  esl_htsm_fcl_nextthr_bf;
    wire [3:0]  esl_rcfg_fcl_nextthr_bf;

    // Thread switch output decisions
    wire        esl_stsm_fcl_switch_bf;
    wire        esl_rtsm_fcl_switch_bf;
    wire        esl_htsm_fcl_switch_bf;
    wire        esl_rcfg_fcl_switch_bf;

    // Thread switch out/ready output decisions
    wire        esl_stsm_fcl_ntr_s;
    wire        esl_rtsm_fcl_ntr_s;
    wire        esl_htsm_fcl_ntr_s;
    wire        esl_rcfg_fcl_ntr_s;

    // LFSR step outputs
    wire        esl_stsm_lfsr_step;
    wire        esl_rtsm_lfsr_step;
    wire        esl_htsm_lfsr_step;
    wire        esl_rcfg_lfsr_step;

    // Timeout counter step and clear outputs
    wire        esl_stsm_timeout_counter_step;
    wire        esl_stsm_timeout_counter_clear;
    wire        esl_stsm_timeout_counter_set;
    wire        esl_rtsm_timeout_counter_step;
    wire        esl_rtsm_timeout_counter_clear;
    wire        esl_rtsm_timeout_counter_set;
    wire        esl_htsm_timeout_counter_step;
    wire        esl_htsm_timeout_counter_clear;
    wire        esl_htsm_timeout_counter_set;
    wire        esl_rcfg_timeout_counter_step;
    wire        esl_rcfg_timeout_counter_clear;
    wire        esl_rcfg_timeout_counter_set;

    // Shift register step and set outputs
    wire        esl_stsm_timeout_shiftreg_step;
    wire        esl_stsm_timeout_shiftreg_set;
    wire        esl_rtsm_timeout_shiftreg_step;
    wire        esl_rtsm_timeout_shiftreg_set;
    wire        esl_htsm_timeout_shiftreg_step;
    wire        esl_htsm_timeout_shiftreg_set;
    wire        esl_rcfg_timeout_shiftreg_step;
    wire        esl_rcfg_timeout_shiftreg_set;

    // Timeout counter comparison control signal output
    wire        esl_stsm_timeout_counter_cmp_config;
    wire        esl_rtsm_timeout_counter_cmp_config;
    wire        esl_htsm_timeout_counter_cmp_config;
    wire        esl_rcfg_timeout_counter_cmp_config;

    // Counter timeout comparison result
    reg         esl_counter_timeout;

    // Offset register control outputs
    wire        esl_stsm_pc_va_diff_offset_we;
    wire        esl_stsm_pc_va_diff_offset_clear;
    wire        esl_rtsm_pc_va_diff_offset_we;
    wire        esl_rtsm_pc_va_diff_offset_clear;
    wire        esl_htsm_pc_va_diff_offset_we;
    wire        esl_htsm_pc_va_diff_offset_clear;
    wire        esl_rcfg_pc_va_diff_offset_we;
    wire        esl_rcfg_pc_va_diff_offset_clear;

    // State declarations
    reg [2:0]   state_f;
    reg [2:0]   state_prev_f;
    reg [2:0]   state_next;

    // Signals to trigger the sync method submodules
    // that we need a thread select decision from it
    reg         esl_stsm_trigger;
    reg         esl_rtsm_trigger;
    reg         esl_htsm_trigger;
    reg         esl_rcfg_trigger; 

    //
    // Sequential Logic
    //

    // State sequential logic
    always @ (posedge clk)
    begin
        if (~rst_n)
        begin
            state_f <= DIVERGED;
            state_prev_f <= DIVERGED;
        end
        else
        begin
            state_f <= state_next;
            state_prev_f <= state_f;
        end
    end

    //
    // Combinational Logic
    //

    // Next state and output logic
    always @ *
    begin
        // Default values
        state_next = state_f;
        esl_fcl_nextthr_bf = 4'b0000;
        esl_fcl_stall_bf = 1'b0;
        esl_fcl_switch_bf = 1'b0;
        esl_fdp_sync_pcs_bf = 1'b0;
        esl_fcl_ntr_s = 1'b0;
        esl_fdp_issue_prev_inst_next_s = 1'b0;
        esl_fcl_force_running_s = 1'b0;
        esl_stsm_trigger = 1'b0;
        esl_rtsm_trigger = 1'b0;
        esl_htsm_trigger = 1'b0;
        esl_rcfg_trigger = 1'b0;

        // If no threads are active, just idle
        if (swl_esl_thr_active == 4'b0000)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0000;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = 1'b0;
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = 1'b0; 
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // If only thr0 is active, just select it
        else if (swl_esl_thr_active == 4'b0001)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0001;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[0];
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[0];
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // If only thr1 is active, just select it
        else if (swl_esl_thr_active == 4'b0010)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0010;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // Otherwise, if both threads are active - need to synchronize
        else if (swl_esl_thr_active == 4'b0011)
        begin
            case (state_f)
                DIVERGED:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s; 
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                DIVERGED_DRAFT:
                begin
                    // Select thr1 and go back to diverged
                    state_next = DIVERGED;
                    esl_fcl_nextthr_bf = 4'b0010;
                    esl_fcl_stall_bf = 1'b0;
                    esl_fcl_switch_bf = 1'b1;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fcl_ntr_s = 1'b1;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                end
                CONVERGED:
                begin
                    // If we diverge due to a page boundary, a branch,
                    // a trap, or a rollback, start fetching for thr1 
                    // again and go to diverged (should reconverge very
                    // quickly after a rollback)
                    if (esl_pcs_pa_page_bndry_s | esl_ctrl_flow_diverged_late_s | 
                        esl_any_trap_bf | fcl_esl_rb_stg_s)
                    begin
                        state_next = DIVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
                        // BUG FIX: Fixes bug of executing an instruction
                        // twice in this case. The instruction for thread
                        // 0 may have just executed on the previous cycle
                        // if we went from CONVERGED->DIVERGED->CONVERGED
                        // without stalling at all.  Thus, the PC just got
                        // updated and we need to synchronize for one more
                        // cycle.  However, in all other cases we should
                        // not sync the PCs, since they may diverge and
                        // we are asking to fetch for thread 1 on the next
                        // cycle, which causes thread 1's PC to change.
                        // BE CAREFUL CHANGING THIS
                        if (state_prev_f != CONVERGED)
                            esl_fdp_sync_pcs_bf = 1'b1;
                        else
                            esl_fdp_sync_pcs_bf = 1'b0;
                        esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
                        esl_fdp_issue_prev_inst_next_s = 1'b0;
                        esl_fcl_force_running_s = 1'b0;
                    end
                    // If at least one thread is not ready, we will just wait
                    // TODO: We may want to change this
                    else if (!(swl_esl_thr_sprdy_or_urdy[0] && 
                               (swl_esl_thr_sprdy_or_urdy[1] || swl_esl_thr_sprdy_or_urdy_next[1])))
                    begin
                        state_next = CONVERGED;
                        esl_fcl_nextthr_bf = 4'b0000;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = 1'b0;
                        // BUG FIX: In the case an I-cache miss occurs,
                        // we do not want to sync the pcs until we know
                        // we are not going to diverge due to a branch later.
                        // If we have a branch followed by another instruction
                        // that misses in the I-cache, thread1 does not
                        // get info that it also missed in the cache
                        // and may skip the instruction that missed
                        if (swl_esl_icmiss_out && esl_unresolved_br)
                            esl_fdp_sync_pcs_bf = 1'b0;
                        else
                            esl_fdp_sync_pcs_bf = 1'b1;
                        esl_fcl_ntr_s = 1'b1; // Note: This switches out any running thread
                        esl_fdp_issue_prev_inst_next_s = 1'b0;
                        esl_fcl_force_running_s = 1'b0;
                    end
                    // Otherwise, both threads are ready
                    else
                    begin 
                        // If instruction for thr0 is not ready, need to wait
                        if (!fcl_esl_tinst_vld_s[0])
                        begin
                            state_next = CONVERGED;
                            esl_fcl_nextthr_bf = 4'b0001;
                            esl_fcl_stall_bf = 1'b0;
                            esl_fcl_switch_bf = 1'b1;
                            esl_fdp_sync_pcs_bf = 1'b1;
                            esl_fcl_ntr_s = 1'b1;
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                        // Otherwise, both threads are ready and 
                        // thr0 instruction is ready
                        else
                        begin
                            state_next = CONVERGED_DRAFT;
                            esl_fcl_nextthr_bf = 4'b0001;
                            esl_fcl_stall_bf = 1'b0;
                            esl_fcl_switch_bf = 1'b1;
                            esl_fdp_sync_pcs_bf = 1'b1;
                            esl_fcl_ntr_s = 1'b1;
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                    end 
                end
                CONVERGED_DRAFT:
                begin
                    // If we diverge due to a page boundary, a branch,
                    // a trap, or a rollback, start fetching for thr1 
                    // again and go to diverged (should reconverge very
                    // quickly after a rollback)  
                    if (esl_pcs_pa_page_bndry_s | esl_ctrl_flow_diverged_late_s |
                        esl_any_trap_bf | fcl_esl_rb_stg_s)
                    begin
                        state_next = DIVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
                        esl_fdp_sync_pcs_bf = 1'b0;
                        esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
                        // BUFIX: If the instruction was rolled back,
                        // then NOP is in the previous instruction
                        // register as the previous instruction
                        // was killed. It may be possible to 
                        // grab that instruction from not being
                        // MUXED to a NOP before the execdraft
                        // replay mux to improve performance, but
                        // leaving this as a TODO
                        // BUG FIX: Trap takes precedence over rollback,
                        // need to still draft in case of trap
                        if (fcl_esl_rb_stg_s && !esl_any_trap_bf)
                        begin
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                        else
                        begin
                            esl_fdp_issue_prev_inst_next_s = 1'b1;
                            esl_fcl_force_running_s = 1'b1;
                        end
                    end
                    // Otherwise, we issue previous instruction for thr1
                    // and do not fetch
                    else
                    begin
                        state_next = CONVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b1;
                        esl_fcl_switch_bf = 1'b1;
                        esl_fdp_sync_pcs_bf = 1'b1;
                        esl_fcl_ntr_s = 1'b1;
                        esl_fdp_issue_prev_inst_next_s = 1'b1;
                        esl_fcl_force_running_s = 1'b1;
                    end
                end
                DIVERGED_DIFFERENT_CODE_RCFG0:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase 
                end
                RCFG1:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                RCFG2:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                RCFG3:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                default:
                begin
                    state_next = 3'bx;
                    esl_fcl_nextthr_bf = 4'bxxxx;
                    esl_fcl_stall_bf = 1'bx;
                    esl_fcl_switch_bf = 1'bx;
                    esl_fdp_sync_pcs_bf = 1'bx;
                    esl_fcl_ntr_s = 1'bx;
                    esl_fdp_issue_prev_inst_next_s = 1'bx;
                    esl_fcl_force_running_s = 1'bx;
                end 
            endcase
        end
    end

    // Signal multiplexing for signals going into shared submodules (counter, LFSR
    // and offset register)
    always @ *
    begin
        case (config_esl_sync_method)
            2'b00:
            begin
                esl_lfsr_step = esl_stsm_lfsr_step;
                esl_timeout_counter_step = esl_stsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_stsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_stsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_stsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_stsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_stsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_stsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_stsm_timeout_counter_cmp_config;
            end
            2'b01:
            begin
                esl_lfsr_step = esl_rtsm_lfsr_step;
                esl_timeout_counter_step = esl_rtsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_rtsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_rtsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_rtsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_rtsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_rtsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_rtsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_rtsm_timeout_counter_cmp_config;
            end
            2'b10:
            begin
                esl_lfsr_step = esl_htsm_lfsr_step;
                esl_timeout_counter_step = esl_htsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_htsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_htsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_htsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_htsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_htsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_htsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_htsm_timeout_counter_cmp_config;
            end
            2'b11:
            begin
                esl_lfsr_step = esl_rcfg_lfsr_step;
                esl_timeout_counter_step = esl_rcfg_timeout_counter_step;
                esl_timeout_counter_clear = esl_rcfg_timeout_counter_clear;
                esl_timeout_counter_set = esl_rcfg_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_rcfg_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_rcfg_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_rcfg_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_rcfg_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_rcfg_timeout_counter_cmp_config;
            end
            default:
            begin
                esl_lfsr_step = 1'bx;
                esl_timeout_counter_step = 1'bx;
                esl_timeout_counter_clear = 1'bx;
                esl_timeout_counter_set = 1'bx;
                esl_pc_va_diff_offset_we = 1'bx;
                esl_pc_va_diff_offset_clear = 1'bx;
                esl_timeout_shiftreg_step = 1'bx;
                esl_timeout_shiftreg_set = 1'bx;
            end
        endcase 
    end

    // Counter threshold comparisons
    always @ *
    begin
        esl_counter_timeout = (esl_timeout_counter_count_f >= 
                              (esl_timeout_counter_cmp_config ? config_esl_counter_timeout 
                                                              : esl_timeout_shiftreg_f));
    end

    //
    // Sub-module instantiations
    //

    // LFSR for pseudo random bits (shared resource)
    sparc_ifu_esl_lfsr lfsr
    (
        .clk (clk),
        .rst_n (rst_n),
        .lfsr_seed (config_esl_lfsr_seed),
        .lfsr_ld (config_esl_lfsr_ld),
        .lfsr_step (config_esl_en & esl_lfsr_step),
        .lfsr_state_f (),
        .lfsr_out_f (pseudo_rand_f)
    );

    // Timeout counter (shared resource)
    sparc_ifu_esl_counter 
    #(
        .COUNT_BIT_WIDTH (16)
    ) cfg_timeout_counter
    (
        .clk (clk),
        .rst_n (rst_n),
        .step (config_esl_en & esl_timeout_counter_step),
        .clear (config_esl_en & esl_timeout_counter_clear),
        .set (config_esl_en & esl_timeout_counter_set),
        .count_f (esl_timeout_counter_count_f)
    );

    // Shift register which sets one of the possible timeouts
    // for above counter (shared resource)
    sparc_ifu_esl_shiftreg 
    #(
        .SHIFT_REG_BIT_WIDTH (16)
    ) timeout_shiftreg
    (
        .clk (clk),
        .rst_n (rst_n),
        .step (config_esl_en & esl_timeout_shiftreg_step),
        .set (config_esl_en & esl_timeout_shiftreg_set),
        .shift_reg_f (esl_timeout_shiftreg_f)
    );

    // STSM synchronization mechanism
    sparc_ifu_esl_stsm 
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) stsm
    (
        .esl_stsm_trigger (esl_stsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_counter_timeout (esl_counter_timeout),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_stsm_state_next (esl_stsm_state_next),
        .esl_stsm_fcl_nextthr_bf (esl_stsm_fcl_nextthr_bf),
        .esl_stsm_fcl_switch_bf (esl_stsm_fcl_switch_bf),
        .esl_stsm_fcl_ntr_s (esl_stsm_fcl_ntr_s),
        .esl_stsm_lfsr_step (esl_stsm_lfsr_step),
        .esl_stsm_timeout_counter_step (esl_stsm_timeout_counter_step),
        .esl_stsm_timeout_counter_clear (esl_stsm_timeout_counter_clear),
        .esl_stsm_timeout_counter_set (esl_stsm_timeout_counter_set),
        .esl_stsm_pc_va_diff_offset_we (esl_stsm_pc_va_diff_offset_we),
        .esl_stsm_pc_va_diff_offset_clear (esl_stsm_pc_va_diff_offset_clear),
        .esl_stsm_timeout_shiftreg_step (esl_stsm_timeout_shiftreg_step),
        .esl_stsm_timeout_shiftreg_set (esl_stsm_timeout_shiftreg_set),
        .esl_stsm_timeout_counter_cmp_config (esl_stsm_timeout_counter_cmp_config)
    );

    // RTSM synchronization mechanism
    sparc_ifu_esl_rtsm 
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) rtsm
    (
        .esl_rtsm_trigger (esl_rtsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .pseudo_rand_f (pseudo_rand_f),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_rtsm_state_next (esl_rtsm_state_next),
        .esl_rtsm_fcl_nextthr_bf (esl_rtsm_fcl_nextthr_bf),
        .esl_rtsm_fcl_switch_bf (esl_rtsm_fcl_switch_bf),
        .esl_rtsm_fcl_ntr_s (esl_rtsm_fcl_ntr_s),
        .esl_rtsm_lfsr_step (esl_rtsm_lfsr_step),
        .esl_rtsm_timeout_counter_step (esl_rtsm_timeout_counter_step),
        .esl_rtsm_timeout_counter_clear (esl_rtsm_timeout_counter_clear),
        .esl_rtsm_timeout_counter_set (esl_rtsm_timeout_counter_set),
        .esl_rtsm_pc_va_diff_offset_we (esl_rtsm_pc_va_diff_offset_we),
        .esl_rtsm_pc_va_diff_offset_clear (esl_rtsm_pc_va_diff_offset_clear),
        .esl_rtsm_timeout_shiftreg_step (esl_rtsm_timeout_shiftreg_step),
        .esl_rtsm_timeout_shiftreg_set (esl_rtsm_timeout_shiftreg_set),
        .esl_rtsm_timeout_counter_cmp_config (esl_rtsm_timeout_counter_cmp_config)
    );

    // HTSM synchronization mechanism
    sparc_ifu_esl_htsm
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) htsm
    (
        .clk (clk),
        .rst_n (rst_n),
        .esl_htsm_trigger (esl_htsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .pseudo_rand_f (pseudo_rand_f),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_counter_timeout (esl_counter_timeout),
        .esl_shiftreg_lsb (esl_timeout_shiftreg_f[0]),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .esl_pcs_va_eql_s (esl_pcs_va_eql_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_htsm_state_next (esl_htsm_state_next),
        .esl_htsm_fcl_nextthr_bf (esl_htsm_fcl_nextthr_bf),
        .esl_htsm_fcl_switch_bf (esl_htsm_fcl_switch_bf),
        .esl_htsm_fcl_ntr_s (esl_htsm_fcl_ntr_s),
        .esl_htsm_lfsr_step (esl_htsm_lfsr_step),
        .esl_htsm_timeout_counter_step (esl_htsm_timeout_counter_step),
        .esl_htsm_timeout_counter_clear (esl_htsm_timeout_counter_clear),
        .esl_htsm_timeout_counter_set (esl_htsm_timeout_counter_set),
        .esl_htsm_pc_va_diff_offset_we (esl_htsm_pc_va_diff_offset_we),
        .esl_htsm_pc_va_diff_offset_clear (esl_htsm_pc_va_diff_offset_clear),
        .esl_htsm_timeout_shiftreg_step (esl_htsm_timeout_shiftreg_step),
        .esl_htsm_timeout_shiftreg_set (esl_htsm_timeout_shiftreg_set),
        .esl_htsm_timeout_counter_cmp_config (esl_htsm_timeout_counter_cmp_config)
    );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_frf.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: bw_r_frf
// Description: This is the floating point register file.  It has one R/W port that is
//     78 bits (64 bits data, 14 bits ecc) wide.
*/


// trin 4/18/16: always use nowrapper implementation
//  all others will fail floating point tests



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module bw_r_frf (/*AUTOARG*/
   // Outputs
   so, frf_dp_data,
   // Inputs
   rclk, si, se, sehold, rst_tri_en, ctl_frf_wen, ctl_frf_ren,
   dp_frf_data, ctl_frf_addr,


   // sram wrapper interface
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data

   ) ;
   input rclk;
   input si;
   input se;
   input sehold;
   input rst_tri_en;
   input [1:0] ctl_frf_wen;
   input ctl_frf_ren;
   input [77:0] dp_frf_data;
   input [6:0]   ctl_frf_addr;

   output so;
   output [77:0] frf_dp_data;

   wire [7:0]    regfile_index;
  //  wire [7:0]   regfile_index_low;
    // wire [7:0] regfile_index_high;
   //
   reg [77:0] frf_dp_data_f;

   assign frf_dp_data = frf_dp_data_f;

  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;

   // reg            rst_tri_en_negedge;
   // wire           ren_d1;
   // wire [6:0]     addr_d1;
   // wire [1:0]     wen_d1;
   // wire [77:0]    write_data_d1;
   // wire [77:0]    sehold_write_data;
   // wire [9:0]     sehold_cntl_data;

   // wire [9:0]     cntl_scan_data;
   // wire [38:0]    write_scan_data_hi;
   // wire [38:0]    write_scan_data_lo;
   // wire [38:0]    read_scan_data_hi;
   // wire [38:0]    read_scan_data_lo;

   // wire           real_se;
   // assign         real_se = se & ~sehold;

   // This is for sas comparisons
   assign        regfile_index[7:0] = {ctl_frf_addr[6:0], 1'b0};

   // assign        regfile_index_low[7:0] = {addr_d1[6:0], 1'b0};
   // assign        regfile_index_high[7:0] = {addr_d1[6:0], 1'b1};

   // assign         sehold_write_data[77:0] = (sehold)? write_data_d1[77:0]: dp_frf_data[77:0];
   // assign sehold_cntl_data[9:0] = (sehold)? {addr_d1[6:0],wen_d1[1:0], ren_d1}:
   //                                          {ctl_frf_addr[6:0],ctl_frf_wen[1:0],ctl_frf_ren};
   // All inputs go through flop
   // dff_s #(39) datain_dff1(.din(sehold_write_data[77:39]), .clk(rclk), .q(write_data_d1[77:39]),
   //                       .se(real_se), .si({cntl_scan_data[0],write_scan_data_lo[38:1]}),
   //                       .so(write_scan_data_hi[38:0]));
   // dff_s #(39) datain_dff2(.din(sehold_write_data[38:0]), .clk(rclk), .q(write_data_d1[38:0]),
   //                       .se(real_se), .si(write_scan_data_hi[38:0]), .so(write_scan_data_lo[38:0]));
   // dff_s #(10) controlin_dff(.din(sehold_cntl_data[9:0]),
   //                         .q({addr_d1[6:0],wen_d1[1:0],ren_d1}),
   //                         .clk(rclk), .se(real_se), .si({si,cntl_scan_data[9:1]}), .so(cntl_scan_data[9:0]));


   wire [77:0] write_mask = {{39{ctl_frf_wen[1]}},{39{ctl_frf_wen[0]}}};
   wire ctl_frf_wens = ctl_frf_wen[1] | ctl_frf_wen[0];

   wire [77:0] read_data;
sram_1rw_128x78 regfile
//sram_configurable_frf regfile
(
  .MEMCLK(rclk),
  .RESET_N(!rst_tri_en),
  .CE(ctl_frf_wens | ctl_frf_ren),
  .A(ctl_frf_addr),
  .DIN(dp_frf_data),
  .BW(write_mask),
  .RDWEN(~ctl_frf_wens),
  .DOUT(read_data),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(8'd5)
);

   always @ (posedge rclk)
   begin
      frf_dp_data_f <= read_data;
   end

   // dff_s #(39) dataout_dff1(.din(read_data[77:39]), .clk(rclk), .q(frf_dp_data[77:39]),
   //                        .se(real_se), .si(read_scan_data_lo[38:0]), .so(read_scan_data_hi[38:0]));
   // dff_s #(39) dataout_dff2(.din(read_data[38:0]), .clk(rclk), .q(frf_dp_data[38:0]),
   //                        .se(real_se), .si({read_scan_data_hi[37:0],write_scan_data_lo[0]}),
   //                        .so(read_scan_data_lo[38:0]));
   // assign so = read_scan_data_hi[38];


   // always @ (negedge rclk) begin
   //    // latch rst_tri_en
   //    rst_tri_en_negedge <= rst_tri_en;
   // end

endmodule // sparc_ffu_frf


































































































































// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_icd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_icd
 //  Description:
 //    The ICD contains the icache data.
 //    32B line size.
 //    Write BW: 16B
 //    Read BW: 16Bx2 (fetdata and topdata), collapsed to 4Bx2
 //    Associativity: 4
 //    Write boundary: 34b (32b inst + parity + predec bit)
 //    NOTES:
 //    1. No clock enable.  Rd/Wr enable is used to trigger the
 //    operation.
 //    2. 2:1 mux on address input.  Selects provided externally.
 //    3. 3:1 mux on data input.   Selects provided and guaranteed
 //    exclusive, externally.
 //
 */


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting






















//PITON_PROTO enables all FPGA related modifications






















































































































































































































































































































































































module bw_r_icd(

    // sram wrapper interface
    sram_icache_w10_rtap_data,
    sram_icache_w32_rtap_data,
    rtap_srams_bist_command,
    rtap_srams_bist_data,


    icd_wsel_fetdata_s1, icd_wsel_topdata_s1, icd_fuse_repair_value,
    icd_fuse_repair_en, so, rclk, se, si, reset_l, sehold, fdp_icd_index_bf,
    ifq_icd_index_bf, fcl_icd_index_sel_ifq_bf, ifq_icd_wrway_bf,
    ifq_icd_worden_bf, ifq_icd_wrdata_i2, fcl_icd_rdreq_bf,
    fcl_icd_wrreq_bf, bist_ic_data, rst_tri_en, ifq_icd_data_sel_old_i2,
    ifq_icd_data_sel_fill_i2, ifq_icd_data_sel_bist_i2, fuse_icd_wren,
    fuse_icd_rid, fuse_icd_repair_value, fuse_icd_repair_en,
    efc_spc_fuse_clk1);

    // sram wrapper interface
    output [4-1:0] sram_icache_w10_rtap_data;
    output [4-1:0] sram_icache_w32_rtap_data;
    input  [4-1:0] rtap_srams_bist_command;
    input  [4-1:0] rtap_srams_bist_data;

    input           rclk;
    input           se;
    input           si;
    input           reset_l;
    input           sehold;
    input   [(6 + 5):2]      fdp_icd_index_bf;
    input   [(6 + 5):2]      ifq_icd_index_bf;
    input           fcl_icd_index_sel_ifq_bf;
    input   [1:0]       ifq_icd_wrway_bf;
    input   [3:0]       ifq_icd_worden_bf;
    input   [135:0]     ifq_icd_wrdata_i2;
    input           fcl_icd_rdreq_bf;
    input           fcl_icd_wrreq_bf;
    input   [7:0]       bist_ic_data;
    input           rst_tri_en;
    input           ifq_icd_data_sel_old_i2;
    input           ifq_icd_data_sel_fill_i2;
    input           ifq_icd_data_sel_bist_i2;
    input           fuse_icd_wren;
    input   [3:0]       fuse_icd_rid;
    input   [7:0]       fuse_icd_repair_value;
    input   [1:0]       fuse_icd_repair_en;
    input           efc_spc_fuse_clk1;
    output  [135:0]     icd_wsel_fetdata_s1;
    output  [135:0]     icd_wsel_topdata_s1;
    output  [7:0]       icd_fuse_repair_value;
    output  [1:0]       icd_fuse_repair_en;
    output          so;

    reg [7:0]       icd_fuse_repair_value;
    reg [1:0]       icd_fuse_repair_en;
    reg [135:0]     fetdata_f;
    reg [135:0]     topdata_f;
    // reg [135:0]     fetdata_sa;
    // reg [135:0]     topdata_sa;
    reg [135:0]     fetdata_s1;
    reg [135:0]     topdata_s1;
    wire            clk;
    wire    [135:0]     next_wrdata_bf;
    reg    [135:0]     wrdata_f;
    wire    [135:0]     bist_data_expand;
    wire [(6 + 5):2]     index_bf;
    reg [(6 + 5):2]      index_f;
    reg [(6 + 5):2]      index_s1;
    // reg [`IC_IDX_HI:0]      wr_index0;
    // reg [`IC_IDX_HI:0]      wr_index1;
    // reg [`IC_IDX_HI:0]      wr_index2;
    // reg [`IC_IDX_HI:0]      wr_index3;
    // reg         rdreq_f;
    // reg         wrreq_f;
    // reg [3:0]       worden_f;
    reg [1:0]       wrway_f;


    assign clk = rclk;
    assign index_bf = (fcl_icd_index_sel_ifq_bf ? ifq_icd_index_bf :
        fdp_icd_index_bf);

    // wire [`IC_IDX_HI:2] top_index = {index_f[`IC_IDX_HI:3] , 1'b1};

    always @ (posedge clk)
    begin
        wrway_f <= ifq_icd_wrway_bf;
        index_f <= index_bf;
        index_s1 <= index_f;
    end

    assign bist_data_expand = 136'b0;
    assign icd_wsel_fetdata_s1 = fetdata_s1;
    assign icd_wsel_topdata_s1 = topdata_s1;

    // mux3ds #(136) icden_mux(
    //     .dout               (next_wrdata_bf),
    //     .in0                (wrdata_f),
    //     .in1                (ifq_icd_wrdata_i2),
    //     .in2                (bist_data_expand),
    //     .sel0               (ifq_icd_data_sel_old_i2),
    //     .sel1               (ifq_icd_data_sel_fill_i2),
    //     .sel2               (ifq_icd_data_sel_bist_i2));
    // dffe_s #(136) wrdata_reg(
    //     .din                (next_wrdata_bf),
    //     .clk                (clk),
    //     .q              (wrdata_f),
    //     .en             ((~sehold)),
    //     .se             (se));

    assign next_wrdata_bf = ifq_icd_data_sel_old_i2 ? wrdata_f :
                            ifq_icd_data_sel_fill_i2 ? ifq_icd_wrdata_i2 : bist_data_expand;

    always @ (posedge clk)
    begin
        wrdata_f <= next_wrdata_bf;
    end

    wire  [543:0] read_data_f;
    wire [543:0] wrdata_expanded_bf;
    reg  [543:0] wrmask_expanded_bf;
    wire [135:0] wrmask_bf;

sram_l1i_data icache_way_10
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[271:0]),
    .BW(wrmask_expanded_bf[271:0]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[271:0]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w10_rtap_data),
    .SRAMID(8'd1)
);


sram_l1i_data icache_way_32
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[543:272]),
    .BW(wrmask_expanded_bf[543:272]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[543:272]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w32_rtap_data),
    .SRAMID(8'd2)
);


    // reg  [543:0] read_data_s1;
    wire [33:0]     icdata_ary_00_00;
    wire [33:0]     icdata_ary_00_01;
    wire [33:0]     icdata_ary_00_10;
    wire [33:0]     icdata_ary_00_11;
    wire [33:0]     icdata_ary_01_00;
    wire [33:0]     icdata_ary_01_01;
    wire [33:0]     icdata_ary_01_10;
    wire [33:0]     icdata_ary_01_11;
    wire [33:0]     icdata_ary_10_00;
    wire [33:0]     icdata_ary_10_01;
    wire [33:0]     icdata_ary_10_10;
    wire [33:0]     icdata_ary_10_11;
    wire [33:0]     icdata_ary_11_00;
    wire [33:0]     icdata_ary_11_01;
    wire [33:0]     icdata_ary_11_10;
    wire [33:0]     icdata_ary_11_11;
    // reg [135:0]     fetdata_s1;
    // reg [135:0]     topdata_s1;

    assign {icdata_ary_11_00,icdata_ary_11_01,icdata_ary_11_10,icdata_ary_11_11,
            icdata_ary_10_00,icdata_ary_10_01,icdata_ary_10_10,icdata_ary_10_11,
            icdata_ary_01_00,icdata_ary_01_01,icdata_ary_01_10,icdata_ary_01_11,
            icdata_ary_00_00,icdata_ary_00_01,icdata_ary_00_10,icdata_ary_00_11} = read_data_f;

    // way, word

    always @ *
    begin
      case (index_f[3:2])
        2'b00:
        begin
          fetdata_f = {icdata_ary_11_00, icdata_ary_10_00, icdata_ary_01_00, icdata_ary_00_00};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b01:
        begin
          fetdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b10:
        begin
          fetdata_f = {icdata_ary_11_10, icdata_ary_10_10, icdata_ary_01_10, icdata_ary_00_10};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
        2'b11:
        begin
          fetdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
      endcase
    end

    // always @ (posedge clk)
    // begin
    // end

    ///WRITE

    assign wrdata_expanded_bf = {4{next_wrdata_bf}};
    assign wrmask_bf = {{34{ifq_icd_worden_bf[0]}},{34{ifq_icd_worden_bf[1]}},{34{ifq_icd_worden_bf[2]}},{34{ifq_icd_worden_bf[3]}}};

    always @ *
    begin
        case (ifq_icd_wrway_bf)
          2'b11:
          begin
            wrmask_expanded_bf = {wrmask_bf, 136'b0, 136'b0, 136'b0};
          end
          2'b10:
          begin
            wrmask_expanded_bf = {136'b0, wrmask_bf, 136'b0, 136'b0};
          end
          2'b01:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, wrmask_bf, 136'b0};
          end
          2'b00:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, 136'b0, wrmask_bf};
          end
        endcase
    end

    always @ (posedge clk)
    begin
        fetdata_s1 <= fetdata_f;
        topdata_s1 <= topdata_f;
    end


endmodule


 // IBM









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1i_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1i_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

//`include "iop.h"
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1i_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [15:0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [3:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [15:0] debug_data_bmask;
reg [15:0] debug_data_in;
reg [15:0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [15:0] mem [0:((16384/32/4/4))-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [15:0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [15:0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[6-2:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[6-2:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
integer memidx;
reg [15:0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      // mem[0] <= 16'b0;
      // mem[1] <= 16'b0;
      // mem[2] <= 16'b0;
      // mem[3] <= 16'b0;
      // mem[4] <= 16'b0;
      // mem[5] <= 16'b0;
      // mem[6] <= 16'b0;
      // mem[7] <= 16'b0;
      // mem[8] <= 16'b0;
      // mem[9] <= 16'b0;
      // mem[10] <= 16'b0;
      // mem[11] <= 16'b0;
      // mem[12] <= 16'b0;
      // mem[13] <= 16'b0;
      // mem[14] <= 16'b0;
      // mem[15] <= 16'b0;
      // mem[16] <= 16'b0;
      // mem[17] <= 16'b0;
      // mem[18] <= 16'b0;
      // mem[19] <= 16'b0;
      // mem[20] <= 16'b0;
      // mem[21] <= 16'b0;
      // mem[22] <= 16'b0;
      // mem[23] <= 16'b0;
      // mem[24] <= 16'b0;
      // mem[25] <= 16'b0;
      // mem[26] <= 16'b0;
      // mem[27] <= 16'b0;
      // mem[28] <= 16'b0;
      // mem[29] <= 16'b0;
      // mem[30] <= 16'b0;
      // mem[31] <= 16'b0;
      
      // genvar memidx;
      // generate
      // for (memidx = 0; memidx < `IC_VAL_SET_COUNT; memidx = memidx + 1) begin
      //   mem[memidx] <= 16b'0;
      // end
      
      for (memidx = 0; memidx < ((16384/32/4/4)); memidx = memidx + 1) begin
        mem[memidx] <= 16'b0;
      end
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [15:0] read1;
reg [15:0] read2;
reg [15:0] read3;
reg [15:0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[3:0];
      2'b01:
         read3 = read2[7:4];
      2'b10:
         read3 = read2[11:8];
      2'b11:
         read3 = read2[15:12];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0];
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[15:0] = bist_data_reg[15:0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1i_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_scm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Store Buffer of Load/Store Unit (CAM Side)
//		 - Physically divided into CAM and DATA RAMs.
//                              - CAM RAM has a single cam port and a single
//                              port for read/writes. The cam port is for loads,
//                              write for stores, read for test/diagnostic purposes.
//                              rd or write can be simultaneous with cam. can rd and cam
//                              a single entry simultaneously. cannot write and cam
//                              the same entry.
//                              - DATA RAM read occurs for a load raw match in the
//                              stb CAM RAM. DATA RAM write occurs a store. Both
//                              actions are architecturally guaranteed to be
//                              mutex.
//                              - Write occurs simultaneously to both arrays.
//                              - Reads are not necessarily simultaneous and are
//                              controlled by individual read signals.
//                              - Certain bits are maintained outside the array
//                              in the stb's control section, such as the valid
//                              bits.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications






module bw_r_scm (/*AUTOARG*/
   // Outputs

    stb_rcsm_ramc,

   stb_rdata_ramc, stb_ld_full_raw, stb_ld_partial_raw,
   stb_cam_hit_ptr, stb_cam_hit, stb_cam_mhit,
   // Inputs

   stb_cam_csm,stb_alt_wr_csm,

   stb_cam_data, stb_alt_wr_data, stb_camwr_data, stb_alt_wsel,
   stb_cam_vld, stb_cam_cm_tid, stb_cam_sqsh_msk, stb_cam_rw_ptr,
   stb_cam_wptr_vld, stb_cam_rptr_vld, stb_cam_rw_tid,
   stb_quad_ld_cam, rclk, rst_tri_en
   ) ;

parameter NUMENTRIES = 32 ;				// number of entries in stb

input	[44:15]		stb_cam_data ;	  // data for compare; disjoint msb
input	[44:15]		stb_alt_wr_data ;	  // data for compare; disjoint msb
input	[14:0]		stb_camwr_data ;  // data for compare/write; common lsb
input			stb_alt_wsel ;
input			stb_cam_vld ;	  // cam is required.
input	[1:0]		stb_cam_cm_tid ;  // thread id for cam operation.
input	[7:0]		stb_cam_sqsh_msk; // mask for squashing cam results.

input 	[2:0]		stb_cam_rw_ptr ;  // wr pointer for single port.
input 	     		stb_cam_wptr_vld ;// write pointer vld
input 	     		stb_cam_rptr_vld ;// write pointer vld
input	[1:0]		stb_cam_rw_tid ;  // thread id for rw.
input 			stb_quad_ld_cam ; // quad-ld cam.

input			rclk ;		  // clock

//input			scan_ena ;	  // no longer required !
//input	[7:0]		adj ;

input			rst_tri_en ;


input   [32:0] stb_cam_csm;
input   [32:0] stb_alt_wr_csm;

output  [32:0] stb_rcsm_ramc;


output	[44:0]		stb_rdata_ramc ;  // rd data from CAM RAM.
// raw output is muxed on a thread basis.
output	[7:0]		stb_ld_full_raw ; // ld with full raw.
output	[7:0]		stb_ld_partial_raw ; // ld with partial raw.
output	[2:0]		stb_cam_hit_ptr ;
output			stb_cam_hit ;	  // any hit in stb
output			stb_cam_mhit ;	  // multiple hits in stb


/*UTOREG*/
// Beginning of automatic regs (for this module's undeclared outputs)
// End of automatics
reg [44:0]		stb_rdata_ramc ;
reg [31:0]		rw_wdline ;
reg [44:0]		stb_ramc [NUMENTRIES-1:0] /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */;
reg [44:0]		ramc_entry ;
reg [36:0]		cam_tag ;
reg [31:0]		ptag_hit ;
reg [7:0]		cam_bmask ;
reg [31:0]		byte_match ;
reg [31:0]		byte_overlap ;
reg [31:0]		ld_full_raw ;
reg [31:0]		ld_partial_raw ;
reg [44:15]		alt_wr_data ;
reg [44:15]		pipe_wr_data ;
reg [14:0]		camwr_data ;
reg			wptr_vld ;
reg			rptr_vld_tmp ;
reg [1:0]	  	cam_tid ;
reg [1:0]	  	cam_vld ;
reg			alt_wsel ;

wire		rptr_vld ;
wire 		ldq ;
wire	[7:0]	sqsh_msk ;
wire 	[7:0]	ld_full_raw_mx ;
wire    [7:0]	ld_partial_raw_mx ;
wire	[7:0]	ptag_hit_mx ;
wire	[7:0]	byte_overlap_mx ;
wire	[7:0]	byte_match_mx ;
wire	[7:0]	cam_hit ;
wire	[44:0]	wdata_ramc ;
wire	[44:0]	cam_data ;
wire	[44:15] wr_data ;

reg	[4:0]	stb_addr;



reg [32:0] stb_rcsm_ramc;
reg [32:0] stb_csm_ramc [NUMENTRIES-1:0];
reg [32:0] pipe_wr_csm;
wire [32:0] wcsm_ramc;
reg [32:0] alt_wr_csm;


integer	i,j,k,l ;


wire	scan_ena ;
assign	scan_ena = 1'b0 ;

//=========================================================================================
//	generate wordlines
//=========================================================================================

assign	sqsh_msk[7:0]	= stb_cam_sqsh_msk[7:0];

// cam_vld and cam_tid_tmp are set-up a phase earlier.
// Comment out - Now setup to posedge.
/*always @(negedge clk)
	begin
		cam_tid_tmp[1:0]	<= stb_cam_cm_tid[1:0] ;
		cam_vld_tmp		<= stb_cam_vld ;
	end */
















always @(posedge rclk)
	begin
		pipe_wr_data[44:15] <= stb_cam_data[44:15];
		alt_wr_data[44:15] <= stb_alt_wr_data[44:15];
		camwr_data[14:0] <= stb_camwr_data[14:0];
		wptr_vld 	<= stb_cam_wptr_vld ;
		rptr_vld_tmp 	<= stb_cam_rptr_vld ;
		cam_tid[1:0]	<= stb_cam_cm_tid[1:0] ;
		//cam_tid[1:0]	<= cam_tid_tmp[1:0] ;
 		//ldq 		<=  stb_quad_ld_cam ; Bug 2870
		alt_wsel 	<= stb_alt_wsel ;


		pipe_wr_csm <= stb_cam_csm;
        alt_wr_csm  <= stb_alt_wr_csm;


                stb_addr	<= {stb_cam_rw_tid[1:0],stb_cam_rw_ptr[2:0]};

	end

assign 	ldq =  stb_quad_ld_cam ;
assign  rptr_vld = rptr_vld_tmp | rst_tri_en ;

//=========================================================================================
//	write or read to/from memory
//=========================================================================================

// For blk-st, select out-of-pipe.
assign	wr_data[44:15] = alt_wsel ?
                alt_wr_data[44:15] : pipe_wr_data[44:15] ;

assign	wdata_ramc[44:0] = {wr_data[44:15],camwr_data[14:0]};

assign wcsm_ramc = alt_wsel ? alt_wr_csm : pipe_wr_csm;




// Write
always @ (negedge rclk)
	begin

	if(wptr_vld) begin
		if(~rst_tri_en) begin
			stb_ramc[stb_addr] <= wdata_ramc[44:0];
            stb_csm_ramc[stb_addr] <= wcsm_ramc;
			stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
            stb_rcsm_ramc <= wcsm_ramc;
                end else begin
			stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
            stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
		end
	end






















// Read

		if(rptr_vld & ~scan_ena) begin
			if (rptr_vld & wptr_vld & ~rst_tri_en) begin
				stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
                stb_rcsm_ramc <= wcsm_ramc;
			end
			else begin
				stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
                stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
			end
		end


















	end

























































//=========================================================================================
//	CAM contents of CAM RAM
//=========================================================================================

// - Generate full/partial raw for incoming load.
// - Output signals need to be qualified with per entry
// vlds before causing any subsequent event, the read of
// the DATA RAM specifically.
// - full_raw & vld will cause rd of DATA RAM.
// - partial_raw & vld will cause ld to follow corresponding
// st on way out to xbar.
// - logic to generate partial and full raws may be done outside
// but that would require an additional signal per entry to
// be output.

// Mapping of cam/write data
//
//	| 	40-3=37b(pa)	| 1b(stquad) 	|	8b(bytemask)	| <- use
//	|	45:9		| 8		|	7:0		| <- input port
//				**^ stquad rm'ed

assign	cam_data[44:0] = {stb_cam_data[44:15],stb_camwr_data[14:0]};

always @ (posedge rclk)
	begin

		for (l=0;l<NUMENTRIES;l=l+1)
				begin
				ramc_entry[44:0] = stb_ramc[l] ;

				cam_tag[36:0] = ramc_entry[44:8] ;
				cam_bmask[7:0] = ramc_entry[7:0] ;
				//stq =	ramc_entry[8] ;			// additional bit -stq

				// Prior to adding stb_quad_ld_cam port.
				/*ptag_hit[l] =
					((cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~stq) | stq)) & stcam_vld_tmp & ~scan_ena ;*/
				// Modification.
				// * remove ramc_entry[8]. Or keep it but it won't be used.
				// * Instead we'll control this from outside.
				ptag_hit[l] =
					(cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~ldq) | ldq) & stb_cam_vld & ~scan_ena ;
				byte_match[l] = |(cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;
				// Simplification :
				byte_overlap[l] = |(~cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;

				end
	end

// Mux the raw signals down to 8b quantities. Squash mask comes mid-way thru cycle.


assign	byte_overlap_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_overlap[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_overlap[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_overlap[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_overlap[31:24] : 8'bxxxx_xxxx ;

assign	byte_match_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_match[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_match[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_match[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_match[31:24] : 8'bxxxx_xxxx ;

assign	ptag_hit_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? ptag_hit[7:0] :
		(cam_tid[1:0] == 2'b01) ? ptag_hit[15:8] :
			(cam_tid[1:0] == 2'b10) ? ptag_hit[23:16] :
				(cam_tid[1:0] == 2'b11) ? ptag_hit[31:24] : 8'bxxxx_xxxx ;

assign	stb_ld_full_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_ld_partial_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] &  byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;

assign	cam_hit[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_cam_hit = |(cam_hit[7:0]);

// The stb data is meant to be read for single hit full raw case. It may actually be read
// for full raw, partial raw or multiple hit case but the read output will be ignored for
// partial and multiple hit case. Multiple hits will not cause a hazard as the ptr is first
// encoded and then decoded to form the wdline for the stb-data
// Use cam_hit result to void false hits.
assign	stb_cam_hit_ptr[0] 	=  cam_hit[1] | cam_hit[3] | cam_hit[5] | cam_hit[7] ;
assign	stb_cam_hit_ptr[1] 	=  cam_hit[2] | cam_hit[3] | cam_hit[6] | cam_hit[7] ;
assign	stb_cam_hit_ptr[2] 	=  cam_hit[4] | cam_hit[5] | cam_hit[6] | cam_hit[7] ;

//Generating multiple hits
assign  stb_cam_mhit            =  (cam_hit[0]  & cam_hit[1]) | (cam_hit[2] & cam_hit[3])  |
                                   (cam_hit[4]  & cam_hit[5]) | (cam_hit[6] & cam_hit[7])  |
                                   ((cam_hit[0] | cam_hit[1]) & (cam_hit[2] | cam_hit[3])) |
                                   ((cam_hit[4] | cam_hit[5]) & (cam_hit[6] | cam_hit[7])) |
                                   ((|cam_hit[3:0]) & (|cam_hit[7:4]));

//--------------------------------------------------------------
// Error Checking.
//--------------------------------------------------------------

// 1. simultaneous rd/wr on single port - terminate
// 2. simultaneous cam and wr - terminate
// * PUT OUTSIDE OF SRAM RTL, AS RST NOT AVAILABLE. *

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x152b.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    DCache Fill Queue of Load Store Unit.
//                      - Contains invalidates and loads.
//                      - loads will bypass and/or fill dcache.
//                      - Entry at head of queue may have to
//                      be held for multiple passes.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_rf32x152b(dout, so, rd_en, rd_adr, wr_en, wr_adr, din, si, se,
  sehold, rclk, rst_tri_en, reset_l);

  parameter   NUMENTRIES  = 32;

  input [4:0]   rd_adr;
  input     rd_en;
  input     wr_en;
  input [4:0]   wr_adr;
  input [151:0]   din;
  input     rclk;
  input     reset_l;
  input     rst_tri_en;
  input     sehold;
  input     si;
  input     se;
  output  [151:0]   dout;
  // reg [151:0]   dout;
  output      so;

  wire      clk;
  wire      wr_vld;

  reg [151:0]   mem[(NUMENTRIES - 1):0];  /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */
  // reg rd_en_d1;
  reg [4:0]   rd_adr_d1;

  assign clk = rclk;
  assign wr_vld = ((wr_en & (~rst_tri_en)) & reset_l);

  always @(posedge clk) begin
    if (wr_vld) begin
      mem[wr_adr] = din;
    end
    // rd_en_d1 <= rd_en;
    rd_adr_d1 <= rd_adr;
  end

  assign dout = mem[rd_adr_d1];

endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1d_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1d_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

//`include "iop.h"

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1d_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [(4*2-1):0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [2-1:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [(4*2-1):0] debug_data_bmask;
reg [(4*2-1):0] debug_data_in;
reg [(4*2-1):0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [(4*2-1):0] mem [0:((256/2)/4)-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [(4*2-1):0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [(4*2-1):0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[4:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[4:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
reg [(4*2-1):0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      mem[0] <= 16'b0;
      mem[1] <= 16'b0;
      mem[2] <= 16'b0;
      mem[3] <= 16'b0;
      mem[4] <= 16'b0;
      mem[5] <= 16'b0;
      mem[6] <= 16'b0;
      mem[7] <= 16'b0;
      mem[8] <= 16'b0;
      mem[9] <= 16'b0;
      mem[10] <= 16'b0;
      mem[11] <= 16'b0;
      mem[12] <= 16'b0;
      mem[13] <= 16'b0;
      mem[14] <= 16'b0;
      mem[15] <= 16'b0;
      mem[16] <= 16'b0;
      mem[17] <= 16'b0;
      mem[18] <= 16'b0;
      mem[19] <= 16'b0;
      mem[20] <= 16'b0;
      mem[21] <= 16'b0;
      mem[22] <= 16'b0;
      mem[23] <= 16'b0;
      mem[24] <= 16'b0;
      mem[25] <= 16'b0;
      mem[26] <= 16'b0;
      mem[27] <= 16'b0;
      mem[28] <= 16'b0;
      mem[29] <= 16'b0;
      mem[30] <= 16'b0;
      mem[31] <= 16'b0;
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [(4*2-1):0] read1;
reg [(4*2-1):0] read2;
reg [(4*2-1):0] read3;
reg [(4*2-1):0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[`L1D_SET_IDX_HI:2] == write_address_y[`L1D_SET_IDX_HI:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[2*1-1 -: 2];
      2'b01:
         read3 = read2[2*2-1 -: 2];
      2'b10:
         read3 = read2[2*3-1 -: 2];
      2'b11:
         read3 = read2[2*4-1 -: 2];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0]; // trin reconfig
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[(4*2-1):0] = bist_data_reg[(4*2-1):0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1d_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x80.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Trap Stack Array
//			- Dual-Ported.
//			- Port1 - Write Port; Used by wrpr, trap insertion.
//			Write occurs in W Stage. (M1:M2:W).
//			- Port2 - Read Port; Used by rdpr, done/retry.
//			Read occurs in E Stage.
//			- Arranged as 6(trap-levels/thread) x 4 threads = 24 entries.
//			Trap-level and thread id used to index array.
*/
////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications



















































































































































































































































module bw_r_rf32x80(/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rd_en, rd_adr, wr_en, nib_wr_en, wr_adr, din,
   si, se, sehold, rclk, rst_tri_en, reset_l);

parameter NUM_TPL = 6 ;         // 6 supported trap levels.
parameter NUM_ENTRIES = 32 ;    // 8 entries per thread

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
input [4:0]   rd_adr;     // read adr.
input         rd_en;      // read pointer
input         wr_en;      // write pointer vld
input [19:0]  nib_wr_en;  // enable write of a byte in tsa.
input [4:0]   wr_adr;     // write adr.
input [79:0] din;         // wr data for tsa.
input         rclk;       // clock
input         reset_l;    // active low reset
input         rst_tri_en; // reset and scan
input         sehold;     // scan hold
input         si;         // scan in
input         se;         // scan enable

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics
output  [79:0] dout ; // rd data for tsa.
output          so ;   // scan out write

   wire [159:0] write_mask; // write-mask
   reg [3:0] rd_adr_d1;
   reg [3:0] rd_adr_d2;
   reg read_en_d1;
   reg read_en_d2;

// for sastasks?
// reg [79:0]      temp_tlvl = 0;

   // memory
   reg [79:0] inq_ary [NUM_ENTRIES-1:0];

   // read
   assign dout = inq_ary[rd_adr_d1];

   // write
   always @ (posedge rclk)
   begin
      if (!reset_l)
      begin
         // assume flops
         inq_ary[00] <= 80'b0;
         inq_ary[01] <= 80'b0;
         inq_ary[02] <= 80'b0;
         inq_ary[03] <= 80'b0;
         inq_ary[04] <= 80'b0;
         inq_ary[05] <= 80'b0;
         inq_ary[06] <= 80'b0;
         inq_ary[07] <= 80'b0;
         inq_ary[08] <= 80'b0;
         inq_ary[09] <= 80'b0;
         inq_ary[10] <= 80'b0;
         inq_ary[11] <= 80'b0;
         inq_ary[12] <= 80'b0;
         inq_ary[13] <= 80'b0;
         inq_ary[14] <= 80'b0;
         inq_ary[15] <= 80'b0;
         inq_ary[16] <= 80'b0;
         inq_ary[17] <= 80'b0;
         inq_ary[18] <= 80'b0;
         inq_ary[19] <= 80'b0;
         inq_ary[20] <= 80'b0;
         inq_ary[21] <= 80'b0;
         inq_ary[22] <= 80'b0;
         inq_ary[23] <= 80'b0;
         inq_ary[24] <= 80'b0;
         inq_ary[25] <= 80'b0;
         inq_ary[26] <= 80'b0;
         inq_ary[27] <= 80'b0;
         inq_ary[28] <= 80'b0;
         inq_ary[29] <= 80'b0;
         inq_ary[30] <= 80'b0;
         inq_ary[31] <= 80'b0;
      end
      else
      begin
         if (wr_en)
         begin
            inq_ary[wr_adr] <= (din & write_mask) | (inq_ary[wr_adr] & ~write_mask);
         end
      end
   end

   // pipeline crap
   always @ (posedge rclk)
   begin
      // din_d1 <= din;
      rd_adr_d1 <= rd_adr;
      rd_adr_d2 <= rd_adr_d1;
      // wr_adr_d1 <= wr_adr;
      // wr_en_d1 <= wr_en;
      // word_wen_d1 <= word_wen;
      // byte_wen_d1 <= byte_wen;
      read_en_d1 <= rd_en;
      read_en_d2 <= read_en_d1;
   end

assign  write_mask[79:0] =
    {{4{nib_wr_en[19]}},
     {4{nib_wr_en[18]}},
     {4{nib_wr_en[17]}},
     {4{nib_wr_en[16]}},
     {4{nib_wr_en[15]}},
     {4{nib_wr_en[14]}},
     {4{nib_wr_en[13]}},
     {4{nib_wr_en[12]}},
     {4{nib_wr_en[11]}},
     {4{nib_wr_en[10]}},
     {4{nib_wr_en[9]}},
     {4{nib_wr_en[8]}},
     {4{nib_wr_en[7]}},
     {4{nib_wr_en[6]}},
     {4{nib_wr_en[5]}},
     {4{nib_wr_en[4]}},
     {4{nib_wr_en[3]}},
     {4{nib_wr_en[2]}},
     {4{nib_wr_en[1]}},
     {4{nib_wr_en[0]}}
    };

endmodule











// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dcd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================


// devices.xml


////////////////////////////////////////////////////////////////////////
/*
//  Module Name:
//  Description:  LSU Data Cache.
//      - Physically-Indexed Physically Tagged (PIPT)
//      - 8KB
//      - 4 way set-associative.
//      - 16B lines
//      - 2:1 column select by choosing either lower
//      or upper half of 16B line.
//      - Parity protected on a byte basis.
//      - Byte enables for byte-wide stores.
//
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include  "sys.h" // system level definition file which contains the
                  // time scale definition

//`include "iop.h"
//`include "fabric.h"











//PITON_PROTO enables all FPGA related modifications






////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_dcd ( /*AUTOARG*/
   // Outputs
   so, dcache_rdata_wb, dcache_rparity_wb, dcache_rparity_err_wb,
   dcache_rdata_msb_m,
   // dcache_rdata_msb_w0_m, dcache_rdata_msb_w1_m,
   // dcache_rdata_msb_w2_m, dcache_rdata_msb_w3_m,
   dcd_fuse_repair_value, dcd_fuse_repair_en,
   // Inputs
   dcache_rd_addr_e, dcache_alt_addr_e, dcache_rvld_e, dcache_wvld_e,
   dcache_wdata_e, dcache_wr_rway_e, dcache_byte_wr_en_e,
   dcache_alt_rsel_way_e, dcache_rsel_way_wb, dcache_alt_mx_sel_e,
   si, se, sehold, rst_tri_en, arst_l, rclk, dcache_alt_data_w0_m,
   dcache_arry_data_sel_m, efc_spc_fuse_clk1, fuse_dcd_wren,
   fuse_dcd_rid, fuse_dcd_repair_value, fuse_dcd_repair_en,


   // sram wrapper interface
   sram_dcache_w01_rtap_data,
   sram_dcache_w23_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   ) ;


output [4-1:0] sram_dcache_w01_rtap_data;
output [4-1:0] sram_dcache_w23_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;

input [(6 + 4):3]    dcache_rd_addr_e;     // read cache index [`L1D_ADDRESS_HI:4] + bit [3] offset
input [(6 + 4):3]    dcache_alt_addr_e;    // write/bist/diagnostic read cache index + offset

input           dcache_rvld_e;        // read accesses d$.
input           dcache_wvld_e;        // valid write setup to m-stage.

input [144-1:0]   dcache_wdata_e;       // write data - 16Bx8 + 8b parity.
input [2-1:0]     dcache_wr_rway_e;     // replacement way for load miss/store.
input [15:0]    dcache_byte_wr_en_e;  // 16b byte wr enable for stores.

input [2-1:0]     dcache_alt_rsel_way_e ; // bist/diagnostic read way select
input [2-1:0]     dcache_rsel_way_wb;     // load way select, connect to cache_way_hit
input           dcache_alt_mx_sel_e;

input           si;
input           se;
input           sehold;

output          so;

input   rst_tri_en ;

input           arst_l; // used for redundancy flops - do not reset on wrm reset.

input           rclk;

output reg [63:0]  dcache_rdata_wb;
output reg [7:0]   dcache_rparity_wb;
output reg         dcache_rparity_err_wb;

//=================================
//    dc_fill critical path
//=================================
   input [63:0] dcache_alt_data_w0_m; //from qdp1
   input        dcache_arry_data_sel_m;            //from dctl

   // output [7:0] dcache_rdata_msb_w0_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w1_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w2_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w3_m;    //to dcdp
  
  wire [7:0] dcache_rdata_msb_w0_m;    //to dcdp


  wire [7:0] dcache_rdata_msb_w1_m;    //to dcdp



   output [8*2-1:0] dcache_rdata_msb_m;    //to dcdp

//-----------------------------------------------------------------------------
// 32KB block fuse inputs
//-----------------------------------------------------------------------------
// efuse non ovl clks
input           efc_spc_fuse_clk1;

input           fuse_dcd_wren;          //redundancy register write enable, qualified
input [2:0]     fuse_dcd_rid;           //redundancy register id
input [7:0]     fuse_dcd_repair_value;  //data in for redundancy register
input [1:0]     fuse_dcd_repair_en;     //enable bits to turn on redundancy
output [7:0]    dcd_fuse_repair_value;  //data out for redundancy register
output [1:0]    dcd_fuse_repair_en;     //enable bits out

// Memory declaration.
wire  [(6 + 4):3]    dcache_rwaddr_e ;
wire  [(6 + 4):3]    dcache_raddr_e ;



// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a;


  wire [144-1:0]   temp_w0a;


  wire [144-1:0]   temp_w1a;



// this particular macro contains 2 ways
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way_mask_e = { {8{dcache_byte_wr_en_e[0]}},
//                             {8{dcache_byte_wr_en_e[1]}},
//                             {8{dcache_byte_wr_en_e[2]}},
//                             {8{dcache_byte_wr_en_e[3]}},
//                             {8{dcache_byte_wr_en_e[4]}},
//                             {8{dcache_byte_wr_en_e[5]}},
//                             {8{dcache_byte_wr_en_e[6]}},
//                             {8{dcache_byte_wr_en_e[7]}},
//                             {8{dcache_byte_wr_en_e[8]}},
//                             {8{dcache_byte_wr_en_e[9]}},
//                             {8{dcache_byte_wr_en_e[10]}},
//                             {8{dcache_byte_wr_en_e[11]}},
//                             {8{dcache_byte_wr_en_e[12]}},
//                             {8{dcache_byte_wr_en_e[13]}},
//                             {8{dcache_byte_wr_en_e[14]}},
//                             {8{dcache_byte_wr_en_e[15]}}
//                           };

// Includes data(128b)+parity(16b).
wire [144-1:0] way_mask_e =
    {{8{dcache_byte_wr_en_e[15]}},{8{dcache_byte_wr_en_e[14]}},{8{dcache_byte_wr_en_e[13]}},
     {8{dcache_byte_wr_en_e[12]}},{8{dcache_byte_wr_en_e[11]}},{8{dcache_byte_wr_en_e[10]}},
     {8{dcache_byte_wr_en_e[9]}}, {8{dcache_byte_wr_en_e[8]}}, {8{dcache_byte_wr_en_e[7]}},
     {8{dcache_byte_wr_en_e[6]}}, {8{dcache_byte_wr_en_e[5]}}, {8{dcache_byte_wr_en_e[4]}},
     {8{dcache_byte_wr_en_e[3]}}, {8{dcache_byte_wr_en_e[2]}}, {8{dcache_byte_wr_en_e[1]}},
     {8{dcache_byte_wr_en_e[0]}}, dcache_byte_wr_en_e[15:0]} ;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way2_write_mask = {144{dcache_wr_rway_e[2]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way3_write_mask = {144{dcache_wr_rway_e[3]}} & way_mask_e;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a_reg;

  wire [144-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
  wire [144-1:0]   temp_w0a_reg;


  wire [144-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
  wire [144-1:0]   temp_w1a_reg;





// !MERGE_L1_DCACHE && SRAM_LSU_DCACHE


sram_l1d_data_piton dcache_way_01
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way1_write_mask, way0_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w1a_reg, temp_w0a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w01_rtap_data),
  .SRAMID(8'd3)
);

sram_l1d_data_piton dcache_way_23
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way3_write_mask, way2_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w3a_reg, temp_w2a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w23_rtap_data),
  .SRAMID(8'd4)
);










































 // MERGE_L1_DCACHE












































 // SRAM_LSU_DCACHE

reg [(6 + 4):3]    dcache_rwaddr_m ;
reg [(6 + 4):3]    dcache_raddr_m ;
reg           dcache_rvld_m ;
reg           wvld_m ;
reg [144-1:0]   dcache_wdata_m ;
reg [127:0]   rw_wdline ;
reg [2-1:0]     dcache_wr_rway_m ;

// reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.
// reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.
// reg [63:0]    dcache_rdata_w2_wb;   // way2 64b data.
// reg [63:0]    dcache_rdata_w3_wb;   // way3 64b data.
reg [15:0]    byte_wr_enable ;

reg           dcache_alt_mx_sel_m, dcache_alt_mx_sel_wb;
reg [2-1:0]     dcache_alt_rsel_way_m, dcache_alt_rsel_way_wb;


wire            dcache_wvld_m ;
// wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
// wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
// wire  [63:0]    dcache_rdata_w2_m;    // way2 64b data.
// wire  [63:0]    dcache_rdata_w3_m;    // way3 64b data.
// wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
// wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
// wire  [7:0]     dcache_rparity_w2_m;  // way2 8b parity.
// wire  [7:0]     dcache_rparity_w3_m;  // way3 8b parity.

   // wire [7:0]   rd_parity_err_w0_m;
   // wire [7:0]   rd_parity_err_w1_m;
   // wire [7:0]   rd_parity_err_w2_m;
   // wire [7:0]   rd_parity_err_w3_m;


wire  [144-1:0]   way_mask ;
wire  [144-1:0]   way_mask_inv ;

//calculated parity based on read-out data
// wire [7:0]  gen_dcache_parity_w0_m;
// wire [7:0]  gen_dcache_parity_w1_m;
// wire [7:0]  gen_dcache_parity_w2_m;
// wire [7:0]  gen_dcache_parity_w3_m;

   wire     clk;
   assign   clk = rclk;


    wire [7:0]  gen_dcache_parity_w0_m;
    wire [7:0]   rd_parity_err_w0_m;
    wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
    wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
    reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.


    wire [7:0]  gen_dcache_parity_w1_m;
    wire [7:0]   rd_parity_err_w1_m;
    wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
    wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
    reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.



//=========================================================================================
//  Staging
//=========================================================================================

// BIST Rd used fill address port.
assign  dcache_rwaddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

assign  dcache_raddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

always @(posedge clk)
  begin
    dcache_alt_mx_sel_m   <= sehold ? dcache_alt_mx_sel_m : dcache_alt_mx_sel_e;

    dcache_alt_rsel_way_m <= sehold ? dcache_alt_rsel_way_m : dcache_alt_rsel_way_e;

    dcache_rwaddr_m[(6 + 4):3] <= sehold ? dcache_rwaddr_m[(6 + 4):3] : dcache_rwaddr_e[(6 + 4):3] ;

    dcache_raddr_m[(6 + 4):3] <= sehold ? dcache_raddr_m[(6 + 4):3] : dcache_raddr_e[(6 + 4):3] ;

    dcache_rvld_m         <= sehold ? dcache_rvld_m  : dcache_rvld_e ;

    wvld_m                <= sehold ?  wvld_m : dcache_wvld_e ;

    dcache_wdata_m[144-1:0] <= sehold ?  dcache_wdata_m[144-1:0] : dcache_wdata_e[144-1:0] ;

    dcache_wr_rway_m[2-1:0] <= sehold ?  dcache_wr_rway_m[2-1:0] : dcache_wr_rway_e[2-1:0] ;

    byte_wr_enable[15:0]  <= sehold ? byte_wr_enable[15:0] : dcache_byte_wr_en_e[15:0] ;

  end

always @ (posedge clk)
  begin
// JC modified begin
//    dcache_alt_mx_sel_wb <= dcache_alt_mx_sel_m;
//    dcache_alt_rsel_way_wb  <= dcache_alt_rsel_way_m;
    dcache_alt_mx_sel_wb <= sehold ? dcache_alt_mx_sel_wb :dcache_alt_mx_sel_m;
    dcache_alt_rsel_way_wb  <= sehold ? dcache_alt_rsel_way_wb :dcache_alt_rsel_way_m;
// JC modified end
  end

assign  dcache_wvld_m = wvld_m & ~rst_tri_en ;




















 // `ifndef SRAM_LSU_DCACHE

//removed stablizer, zero out without read (for IBM sram too)
// assign  temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w0a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w1a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w2a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w3a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;


  assign  temp_w0a[144-1:0] = dcache_rvld_m? temp_w0a_reg[144-1:0]: 144'b0;


  assign  temp_w1a[144-1:0] = dcache_rvld_m? temp_w1a_reg[144-1:0]: 144'b0;



 // `ifndef SRAM_LSU_DCACHE

// Prior to SA, column mux (64(D)+8(P))x4 bits. Assume parity is
// at the end of the 144b line. Entry is wX||Parity

// // Select either upper or lower 64b from each of the 4 ways.
// assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w0a[79:16] ;
// assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w1a[79:16] ;
// assign  dcache_rdata_w2_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w2a[79:16] ;
// assign  dcache_rdata_w3_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w3a[79:16] ;


  assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[144-1:80] : temp_w0a[79:16] ;


  assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[144-1:80] : temp_w1a[79:16] ;



   wire [7:0] dcache_msb_w0_m;
   wire [7:0] dcache_alt_data_w0_msb_m;

//MSB sent out to dcdp in M stage
assign dcache_msb_w0_m[7:0]=
    {dcache_rdata_w0_m[63],
     dcache_rdata_w0_m[55],
     dcache_rdata_w0_m[47],
     dcache_rdata_w0_m[39],
     dcache_rdata_w0_m[31],
     dcache_rdata_w0_m[23],
     dcache_rdata_w0_m[15],
     dcache_rdata_w0_m[07]} ;

assign dcache_alt_data_w0_msb_m [7:0]=
    {dcache_alt_data_w0_m[63],
     dcache_alt_data_w0_m[55],
     dcache_alt_data_w0_m[47],
     dcache_alt_data_w0_m[39],
     dcache_alt_data_w0_m[31],
     dcache_alt_data_w0_m[23],
     dcache_alt_data_w0_m[15],
     dcache_alt_data_w0_m[07]} ;

//2-to-1 mux
assign dcache_rdata_msb_w0_m[7:0] = dcache_arry_data_sel_m ?
                                    dcache_msb_w0_m[7:0] :
                                    dcache_alt_data_w0_msb_m[7:0];

// assign dcache_rdata_msb_w1_m[7:0]=
//     {dcache_rdata_w1_m[63],
//      dcache_rdata_w1_m[55],
//      dcache_rdata_w1_m[47],
//      dcache_rdata_w1_m[39],
//      dcache_rdata_w1_m[31],
//      dcache_rdata_w1_m[23],
//      dcache_rdata_w1_m[15],
//      dcache_rdata_w1_m[07]} ;

// assign dcache_rdata_msb_w2_m[7:0]=
//     {dcache_rdata_w2_m[63],
//      dcache_rdata_w2_m[55],
//      dcache_rdata_w2_m[47],
//      dcache_rdata_w2_m[39],
//      dcache_rdata_w2_m[31],
//      dcache_rdata_w2_m[23],
//      dcache_rdata_w2_m[15],
//      dcache_rdata_w2_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;


  assign dcache_rdata_msb_w1_m[7:0]=
    {dcache_rdata_w1_m[63],
     dcache_rdata_w1_m[55],
     dcache_rdata_w1_m[47],
     dcache_rdata_w1_m[39],
     dcache_rdata_w1_m[31],
     dcache_rdata_w1_m[23],
     dcache_rdata_w1_m[15],
     dcache_rdata_w1_m[07]} ;



assign dcache_rdata_msb_m[(8*(0+1))-1 -: 8] = dcache_rdata_msb_w0_m;
assign dcache_rdata_msb_m[(8*(1+1))-1 -: 8] = dcache_rdata_msb_w1_m;


   // wire [63:0] rdata_w0_m;
   // wire [63:0] rdata_w1_m;
   // wire [63:0] rdata_w2_m;
   // wire [63:0] rdata_w3_m;
wire [63:0] rdata_w0_m;
wire [63:0] rdata_w1_m;


//2-to-1 mux
//dcache_alt_mx_sel default 0001 (way 0) when not in MBIST mode (logic in qdp2)
assign rdata_w0_m[63:0] = dcache_arry_data_sel_m ?
                          dcache_rdata_w0_m[63:0] : dcache_alt_data_w0_m[63:0];

// //assign rdata_w0_m[63:0] = dcache_rdata_w0_m[63:0];
// assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];
// assign rdata_w2_m[63:0] = dcache_rdata_w2_m[63:0];
// assign rdata_w3_m[63:0] = dcache_rdata_w3_m[63:0];
   

  assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];



// // Select upper half or lower half of parity.
// assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
// assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
// assign  dcache_rparity_w2_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w2a[15:8] : temp_w2a[7:0] ;
// assign  dcache_rparity_w3_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w3a[15:8] : temp_w3a[7:0] ;

//    reg [7:0] dcache_rparity_w0_wb;
//    reg [7:0] dcache_rparity_w1_wb;
//    reg [7:0] dcache_rparity_w2_wb;
//    reg [7:0] dcache_rparity_w3_wb;

//    reg [7:0] rd_parity_err_w0_wb;
//    reg [7:0] rd_parity_err_w1_wb;
//    reg [7:0] rd_parity_err_w2_wb;
//    reg [7:0] rd_parity_err_w3_wb;


  assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
  reg [7:0] dcache_rparity_w0_wb;
  reg [7:0] rd_parity_err_w0_wb;


  assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
  reg [7:0] dcache_rparity_w1_wb;
  reg [7:0] rd_parity_err_w1_wb;




// Stage to WB
always  @(posedge clk)
  begin
    // dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
    // dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
    // dcache_rdata_w2_wb[63:0] <= rdata_w2_m[63:0] ;
    // dcache_rdata_w3_wb[63:0] <= rdata_w3_m[63:0] ;

    // dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
    // dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
    // dcache_rparity_w2_wb[7:0] <=  dcache_rparity_w2_m[7:0];
    // dcache_rparity_w3_wb[7:0] <=  dcache_rparity_w3_m[7:0];

    // rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];
    // rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];
    // rd_parity_err_w2_wb [7:0] <= rd_parity_err_w2_m[7:0];
    // rd_parity_err_w3_wb [7:0] <= rd_parity_err_w3_m[7:0];


  dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
  dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
  rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];


  dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
  dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
  rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];



  end

//parity calculation and check are done in M stage for 4 way data
   // wire rd_parity_err_w0;
   // wire rd_parity_err_w1;
   // wire rd_parity_err_w2;
   // wire rd_parity_err_w3;

// lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
//                 .data_in        (dcache_rdata_w0_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w0_m[7:0])
//         );

// assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0]) :
//                                                   8'hff;


// lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
//                 .data_in        (dcache_rdata_w1_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w1_m[7:0])
//         );

// assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0]) :
//                                                  8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w2 (
//                 .data_in        (dcache_rdata_w2_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w2_m[7:0])
//         );
// assign rd_parity_err_w2_m[7:0] = dcache_rvld_m ? (dcache_rparity_w2_m[7:0] ^ gen_dcache_parity_w2_m[7:0])  :
//                                                    8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w3 (
//                 .data_in        (dcache_rdata_w3_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w3_m[7:0])
//         );
// assign rd_parity_err_w3_m[7:0] =  dcache_rvld_m ? (dcache_rparity_w3_m[7:0] ^ gen_dcache_parity_w3_m[7:0]) :
//                                                   8'hff;


  wire rd_parity_err_w0;
  lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
                  .data_in        (dcache_rdata_w0_m[63:0]),
                  .parity_out     (gen_dcache_parity_w0_m[7:0])
          );
  assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0])  :
                                                     8'hff;


  wire rd_parity_err_w1;
  lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
                  .data_in        (dcache_rdata_w1_m[63:0]),
                  .parity_out     (gen_dcache_parity_w1_m[7:0])
          );
  assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0])  :
                                                     8'hff;



// way select mux on READ
// Select one of four ways from indexed cache set.

wire [2-1:0] dcache_rd_sel_way_wb;
assign dcache_rd_sel_way_wb[2-1:0] = dcache_alt_mx_sel_wb ? dcache_alt_rsel_way_wb[2-1:0] :
                                                          dcache_rsel_way_wb[2-1:0];

// assign  dcache_rdata_wb[63:0]  =
//  (dcache_rd_sel_way_wb[0] ? dcache_rdata_w0_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[1] ? dcache_rdata_w1_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[2] ? dcache_rdata_w2_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[3] ? dcache_rdata_w3_wb[63:0] : 64'b0);


always @ *
begin
dcache_rdata_wb[63:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w0_wb[63:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w1_wb[63:0];
end


//parity err in W-stage, cache_way_hit may not be one-hot
// assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);
// assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);
// assign rd_parity_err_w2 =   |(rd_parity_err_w2_wb[7:0]);
// assign rd_parity_err_w3 =   |(rd_parity_err_w3_wb[7:0]);


  assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);


  assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);



// assign dcache_rparity_err_wb = rd_parity_err_w3 & dcache_rd_sel_way_wb[3] |
//                                rd_parity_err_w2 & dcache_rd_sel_way_wb[2] |
//                                rd_parity_err_w1 & dcache_rd_sel_way_wb[1] |
//                                rd_parity_err_w0 & dcache_rd_sel_way_wb[0] ;

always @ *
begin
dcache_rparity_err_wb = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w0;
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w1;
end


//mux4ds #(64) dcache_rdata_wb_mx (
//  .in0  (dcache_rdata_w0_wb[63:0]),
//  .in1  (dcache_rdata_w1_wb[63:0]),
//  .in2  (dcache_rdata_w2_wb[63:0]),
//  .in3  (dcache_rdata_w3_wb[63:0]),
//  .sel0 (dcache_rd_sel_way_wb[0]),
//  .sel1 (dcache_rd_sel_way_wb[1]),
//  .sel2 (dcache_rd_sel_way_wb[2]),
//  .sel3 (dcache_rd_sel_way_wb[3]),
//  .dout (dcache_rdata_wb[63:0])
//);

// dcache_rparity_wb only used by MBIST
//mux4ds #(8) dcache_rparity_wb_mx (
//  .in0 (dcache_rparity_w0_wb[7:0]),
//  .in1 (dcache_rparity_w1_wb[7:0]),
//  .in2 (dcache_rparity_w2_wb[7:0]),
//  .in3 (dcache_rparity_w3_wb[7:0]),
//  .sel0(dcache_alt_rsel_way_wb[0]),
//  .sel1(dcache_alt_rsel_way_wb[1]),
//  .sel2(dcache_alt_rsel_way_wb[2]),
//  .sel3(dcache_alt_rsel_way_wb[3]),
//  .dout(dcache_rparity_wb[7:0])
//);

// assign  dcache_rparity_wb[7:0] =
// ( dcache_rd_sel_way_wb[0] ? dcache_rparity_w0_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[1] ? dcache_rparity_w1_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[2] ? dcache_rparity_w2_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[3] ? dcache_rparity_w3_wb[7:0] : 8'b0 ) ;
always @ *
begin
dcache_rparity_wb[7:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w0_wb[7:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w1_wb[7:0];
end













































 // `ifndef SRAM_LSU_DCACHE // FPGA

endmodule









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dct.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_dct.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */

// devices.xml



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications






































































































































































module bw_r_dct(
  // rdtag_w0_y, rdtag_w1_y, rdtag_w2_y, 
  rdtag_y, 
  // rdtag_w3_y, 
  so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, 

  wrtag_x, wrtag_y,
  // wrtag_w0_y, wrtag_w1_y, wrtag_w2_y,
  // wrtag_w3_y, wrtag_w0_x, wrtag_w1_x, wrtag_w2_x,
  // wrtag_w3_x, 
  adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [2-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;

  input [33-1:0]    wrtag_y;
  input [33-1:0]    wrtag_x;
  input [2-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [(33*2)-1:0]    rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [2-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [131:0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({2 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // wire [131:0] write_bus_x = {wrtag_x,wrtag_x,wrtag_x,wrtag_x};
  // wire [131:0] write_bus_mask_x = {{33{we[3]}}, {33{we[2]}}, {33{we[1]}}, {33{we[0]}}};

  wire [33*2-1:0] write_bus_x = {2{wrtag_x}};
  wire [33*2-1:0] write_bus_mask_x;
  
  assign write_bus_mask_x[33*(0+1)-1 -: 33] = {33{we[0]}};


  assign write_bus_mask_x[33*(1+1)-1 -: 33] = {33{we[1]}};




  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

  wire  [(33*2)-1:0]    rdtag_y;

sram_l1d_tag cache
(
  .MEMCLK(rclk),
    .RESET_N(reset_l),
  .CE(wrreq_x | rdreq_x),
  .A(index_x),
  .DIN(write_bus_x),
  .BW(write_bus_mask_x),
  .RDWEN(~wrreq_x),
  .DOUT(rdtag_y),

  // .BIST_COMMAND(rtap_srams_bist_command),
  // .BIST_DIN(rtap_srams_bist_data),
  // .BIST_DOUT(sram_dcache_w01_rtap_data),
  // .SRAMID(`BIST_ID_L1_DCACHE_W01)
  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(sramid)
);

  // assign rdtag_y = {rdtag_w3_y, rdtag_w2_y, rdtag_w1_y, rdtag_w0_y};




endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_dtlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/

// devices.xml


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































module bw_r_dtlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   // cache_ptag_w0, cache_ptag_w1, 
   // cache_ptag_w2, cache_ptag_w3, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input    [(33*2)+1-1:0]      cache_ptag;          // way3 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w0;       	// way1 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w1;       	// way2 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w2;       	// way0 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w3;       	// way3 30b(D)/29b(I) tag.
input	[2-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;

// input    [29:0]      cache_ptag_w0;          // way1 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w1;          // way2 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w2;          // way0 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w3;          // way3 30b(D)/29b(I) tag.

wire cache_ptag_va_10 = cache_ptag[(33*2)];


wire [33-1:0] cache_ptag_w0_tmp = cache_ptag[33*(0+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w0 = {cache_ptag_w0_tmp[(29+1)-2:0],cache_ptag_va_10};


wire [33-1:0] cache_ptag_w1_tmp = cache_ptag[33*(1+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w1 = {cache_ptag_w1_tmp[(29+1)-2:0],cache_ptag_va_10};




input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[2-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[2-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [2-1:0]		cache_set_vld_g;
// reg	[29:0]		cache_ptag_w0_g,cache_ptag_w1_g;
// reg	[29:0]		cache_ptag_w2_g,cache_ptag_w3_g;
reg [29:0]      cache_ptag_w0_g;
reg [29:0]      cache_ptag_w1_g;

reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.


 

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[2-1:0]  	<= cache_set_vld[2-1:0] ;
			// cache_ptag_w0_g[29:0] 	<= cache_ptag_w0[29:0] ;
			// cache_ptag_w1_g[29:0] 	<= cache_ptag_w1[29:0] ;
			// cache_ptag_w2_g[29:0] 	<= cache_ptag_w2[29:0] ;
			// cache_ptag_w3_g[29:0] 	<= cache_ptag_w3[29:0] ;
         
 cache_ptag_w0_g[(29+1)-1:0]   <= cache_ptag_w0[(29+1)-1:0];


 cache_ptag_w1_g[(29+1)-1:0]   <= cache_ptag_w1[(29+1)-1:0];

 
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


// assign	cache_way_hit[0] = 
// 	(cache_ptag_w0_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[0];
// assign	cache_way_hit[1] = 
// 	(cache_ptag_w1_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[1];
// assign	cache_way_hit[2] = 
// 	(cache_ptag_w2_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[2];
// assign	cache_way_hit[3] = 
// 	(cache_ptag_w3_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[3];


    assign  cache_way_hit[0] = 
       (cache_ptag_w0_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[0];


    assign  cache_way_hit[1] = 
       (cache_ptag_w1_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[1];



assign	cache_hit = |cache_way_hit[2-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)
	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end



//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_ict.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_ict.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


// devices.xml












//PITON_PROTO enables all FPGA related modifications


































































































































































module bw_r_ict(rdtag_y, so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, wrtag_y,
  wrtag_x, adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [4-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_y;
  input [4-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [((((39 - (6 + 5))+1) * 4)-1):0] rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [4-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [((((39 - (6 + 5))+1) * 4)-1):0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({4 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // assign write_bus_x[`IC_PHYS_TAG_WAY0_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY1_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY2_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY3_MASK] = wrtag_x;

  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

// real SRAM instance
wire [33*4-1 : 0] write_bus_mask_x = {
{33{we[3]}},
{33{we[2]}},
{33{we[1]}},
{33{we[0]}}

};

  wire [32:0] wrtag_x_phys = wrtag_x;
  wire [33*4-1 : 0] write_bus_x_phys = {4{wrtag_x_phys}};
  // wire [`IC_PHYS_TAG_MASK_ALL] write_bus_x_phys = {wrtag_x_phys, wrtag_x_phys, wrtag_x_phys, wrtag_x_phys};
  wire [33*4-1 : 0] rdtag_y_phys;

  // assign rdtag_y[`IC_TLB_TAG_WAY0_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY0_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY1_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY1_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY2_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY2_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY3_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY3_MASK];

  // truncate tags from 33 bits to appropriate size
  
  wire [32:0] rdtag_y_phys_WAY0 = rdtag_y_phys[33*1-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*1-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY0[(((39 - (6 + 5))+1)-1):0];
  

  wire [32:0] rdtag_y_phys_WAY1 = rdtag_y_phys[33*2-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*2-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY1[(((39 - (6 + 5))+1)-1):0];
  

  wire [32:0] rdtag_y_phys_WAY2 = rdtag_y_phys[33*3-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*3-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY2[(((39 - (6 + 5))+1)-1):0];
  

  wire [32:0] rdtag_y_phys_WAY3 = rdtag_y_phys[33*4-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*4-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY3[(((39 - (6 + 5))+1)-1):0];
  


  sram_l1i_tag cache
  (
    .MEMCLK(rclk),
      .RESET_N(reset_l),
    .CE(wrreq_x | rdreq_x),
    .A(index_x),
    .DIN(write_bus_x_phys),
    .BW(write_bus_mask_x),
    .RDWEN(~wrreq_x),
    .DOUT(rdtag_y_phys),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(sramid)
  );

endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_itlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// devices.xml


///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used








































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // is default implementation in openpiton







module bw_r_itlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input  	[((((39 - (6 + 5))+1) * 4)-1):0]    	cache_ptag;       	// way1 30b(D)/29b(I) tag.
input	[4-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;



input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[4-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[4-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [4-1:0]		cache_set_vld_g;
reg	[((((39 - (6 + 5))+1) * 4)-1):0]		cache_ptag_g;
reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.

 



always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[4-1:0]  	<= cache_set_vld[4-1:0] ;
			cache_ptag_g[((((39 - (6 + 5))+1) * 4)-1):0] 	<= cache_ptag[((((39 - (6 + 5))+1) * 4)-1):0] ;
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


   assign   cache_way_hit[0] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*1-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[0];


   assign   cache_way_hit[1] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*2-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[1];


   assign   cache_way_hit[2] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*3-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[2];


   assign   cache_way_hit[3] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*4-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[3];



assign	cache_hit = |cache_way_hit[4-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)

	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end

//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module encapsulates different Execution Drafting synchronization methods
 *      into one module and multiplexes between them based on configuration bits.  It
 *      also supplies more succinct inputs to the synchronization methods derived from
 *      signals from the IFU and derives the correct outputs to go to the IFU.
 *
 *  Note: While the interface to this module supports 4 threads, the logic only supports 2
 */

module sparc_ifu_esl
(
    input               clk,
    input               rst_n,

    // Configuration bits input
    input               config_esl_en,
    input [1:0]         config_esl_sync_method,

    // LFSR management signals for RTSM
    input [15:0]        config_esl_lfsr_seed,
    input               config_esl_lfsr_ld,

    // Threshold configuration signal for PC difference
    input [49:0]        config_esl_pc_diff_thresh,

    // Counter timeout configuration value
    input [15:0]        config_esl_counter_timeout,

    // Active threads from thread FSMs
    input [3:0]         swl_esl_thr_active,

    // Threads ready from thread FSMs, both
    // non-speculative ready and speculative ready
    input [3:0]         swl_esl_thr_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy_next,

    // Use speculative ready vector, meaning no
    // thread is non-speculatively ready
    input               swl_esl_use_spec,

    // Thread in F stage
    input [3:0]         fcl_esl_thr_f,

    // Instructions to be in S2 TIRs next
    input [32:0]        fdp_esl_t0inst_next_s2,

    input [32:0]        fdp_esl_t1inst_next_s2,















    // Physical address of above instructions
    input [39:2]        fdp_esl_t0inst_paddr_next_s2,

    input [39:2]        fdp_esl_t1inst_paddr_next_s2,















    // Virtual address of above instructions
    input [48:0]        fdp_esl_t0pc_next_s2,

    input [48:0]        fdp_esl_t1pc_next_s2,















    // Above instructions valid on the next cycle?
    input [3:0]         fcl_esl_tinst_vld_next_s,

    // Branch taken in E and M stage (taken in M stage if br was taken in previous stage)
    input               fcl_esl_brtaken_e,
    input               fcl_esl_brtaken_m,

    // Threads in E and M
    input [3:0]         fcl_esl_thr_e,
    input [3:0]         fcl_esl_thr_m,

    // Valid instructions in D, E and M
    input               fcl_esl_inst_vld_d,
    input               fcl_esl_inst_vld_e,
    input               fcl_esl_inst_vld_m,

    // Trap on this cycle
    input [3:0]         fcl_esl_thr_trap_bf,

    // Rollback on this cycle
    input               fcl_esl_rb_stg_s,

    // Unresolved branch instructions
    input               dcl_esl_br_inst_d,
    input               dcl_esl_br_inst_e,

    // Whether a branch target pc is in bf of f
    input [3:0]         fdp_esl_brtrp_target_pc_bf_f,

    // Whether there is an outstanding I-cache miss to thr0
    input               swl_esl_icmiss_out,

    // Next thread to fetch for
    output [3:0]        esl_fcl_nextthr_bf,

    // Stall fetch (i.e. should it fetch)
    output              esl_fcl_stall_bf,

    // Whether to switch to esl_fcl_nextthr_bf
    output              esl_fcl_switch_bf,

    // Sync PCs between leader and follower threads
    output              esl_fdp_sync_pcs_bf,

    // If the thread to be issued is ready (i.e. should it be issued)
    output              esl_fcl_ntr_s,

    // Issue previously issued instruction for
    // next thread
    output              esl_fdp_issue_prev_inst_next_s,

    // Output signal to force s2 to be running on next cycle
    output              esl_fcl_force_running_s
);

    //
    // Parameter Definitions
    //

    //
    // Signal Declarations
    //

    // Derived inputs to thread select modules
    reg         esl_tirs_eql_s;
    reg [1:0]   esl_t0inst_next_op1;
    reg [1:0]   esl_t1inst_next_op1;
    reg [2:0]   esl_t0inst_next_op2;
    reg [2:0]   esl_t1inst_next_op2;
    reg [5:0]   esl_t0inst_next_op3;
    reg [5:0]   esl_t1inst_next_op3;
    reg [8:0]   esl_t0inst_next_opf;
    reg [8:0]   esl_t1inst_next_opf;
    reg [2:0]   esl_t0inst_next_br_rcond;
    reg [2:0]   esl_t1inst_next_br_rcond;
    reg [3:0]   esl_t0inst_next_br_cond;
    reg [3:0]   esl_t1inst_next_br_cond;
    reg [4:0]   esl_t0inst_next_fcn;
    reg [4:0]   esl_t1inst_next_fcn;
    reg [5:0]   esl_t0inst_next_opf_low;
    reg [5:0]   esl_t1inst_next_opf_low;
    reg [3:0]   esl_t0inst_next_mv_cond;
    reg [3:0]   esl_t1inst_next_mv_cond;
    reg [2:0]   esl_t0inst_next_mv_rcond;
    reg [2:0]   esl_t1inst_next_mv_rcond;
    reg         esl_t0inst_next_x;
    reg         esl_t1inst_next_x;
    reg [4:0]   esl_t0inst_next_rd;
    reg [4:0]   esl_t1inst_next_rd;
    reg         esl_tirs_op1_eql;
    reg         esl_tirs_op2_eql;
    reg         esl_tirs_op3_eql;
    reg         esl_tirs_opf_eql;
    reg         esl_tirs_br_rcond_eql;
    reg         esl_tirs_br_cond_eql;
    reg         esl_tirs_fcn_eql;
    reg         esl_tirs_opf_low_eql;
    reg         esl_tirs_mv_cond_eql;
    reg         esl_tirs_mv_rcond_eql;
    reg         esl_tirs_x_eql;
    reg         esl_tirs_rd_eql;
    reg         esl_ops_eql_s;
    reg         esl_pcs_pa_eql_s;
    reg         esl_ctrl_flow_diverged_late_s;
    reg         esl_pcs_pa_page_bndry_s;
    reg         esl_any_trap_bf;
    reg [49:0]  esl_pc_va_diff_s;
    reg [49:0]  esl_pc_va_diff_offset_s;
    reg [49:0]  esl_pc_va_diff_abs_s;
    reg [3:0]   esl_min_pc_va_s;
    reg         esl_pc_va_diff_lt_thresh_s;
    reg         esl_pcs_va_eql_s;
    reg         esl_unresolved_br;
    reg         esl_brtrp_target_pc_bf_f;

    // Register that may be updated with PC VA difference
    // for offset calculation
    reg [49:0]  esl_pc_va_diff_offset_f;

    // Control outputs from ESL FSM to offset register
    wire        esl_pc_va_diff_offset_we;
    wire        esl_pc_va_diff_offset_clear;













    //
    // Sequential Logic
    //

    // Register that gets updated with PC VA difference
    // when instructed to do so
    always @ (posedge clk)
    begin
        if (~rst_n | esl_pc_va_diff_offset_clear)
            esl_pc_va_diff_offset_f <= 50'b0;
        else if (esl_pc_va_diff_offset_we)
            esl_pc_va_diff_offset_f <= esl_pc_va_diff_s;
    end

    //
    // Combinational Logic
    //

    // Derive inputs to sub-synchronization modules
    always @ *
    begin
        // Thread instructions equal
        esl_tirs_eql_s = (fdp_esl_t0inst_next_s2 == fdp_esl_t1inst_next_s2);
      
        // Thread instructions opcodes
        esl_t0inst_next_op1 = fdp_esl_t0inst_next_s2[31:30];
        esl_t1inst_next_op1 = fdp_esl_t1inst_next_s2[31:30];
        esl_t0inst_next_op2 = fdp_esl_t0inst_next_s2[24:22];
        esl_t1inst_next_op2 = fdp_esl_t1inst_next_s2[24:22];
        esl_t0inst_next_op3 = fdp_esl_t0inst_next_s2[24:19];
        esl_t1inst_next_op3 = fdp_esl_t1inst_next_s2[24:19];
        esl_t0inst_next_opf = fdp_esl_t0inst_next_s2[13:5];
        esl_t1inst_next_opf = fdp_esl_t1inst_next_s2[13:5];
        esl_t0inst_next_br_rcond = fdp_esl_t0inst_next_s2[27:25];
        esl_t1inst_next_br_rcond = fdp_esl_t1inst_next_s2[27:25];
        esl_t0inst_next_br_cond = fdp_esl_t0inst_next_s2[28:25];
        esl_t1inst_next_br_cond = fdp_esl_t1inst_next_s2[28:25];
        esl_t0inst_next_fcn = fdp_esl_t0inst_next_s2[29:25];
        esl_t1inst_next_fcn = fdp_esl_t1inst_next_s2[29:25];
        esl_t0inst_next_opf_low = fdp_esl_t0inst_next_s2[10:5];
        esl_t1inst_next_opf_low = fdp_esl_t1inst_next_s2[10:5];
        esl_t0inst_next_mv_cond = fdp_esl_t0inst_next_s2[17:14];
        esl_t1inst_next_mv_cond = fdp_esl_t1inst_next_s2[17:14];
        esl_t0inst_next_mv_rcond = fdp_esl_t0inst_next_s2[12:10];
        esl_t1inst_next_mv_rcond = fdp_esl_t1inst_next_s2[12:10];
        esl_t0inst_next_x = fdp_esl_t0inst_next_s2[12];
        esl_t1inst_next_x = fdp_esl_t1inst_next_s2[12];
        esl_t0inst_next_rd = fdp_esl_t0inst_next_s2[29:25];
        esl_t1inst_next_rd = fdp_esl_t1inst_next_s2[29:25];    
    
        // Thread instruction opcodes equal
        esl_tirs_op1_eql = (esl_t0inst_next_op1 == esl_t1inst_next_op1);
        esl_tirs_op2_eql = (esl_t0inst_next_op2 == esl_t1inst_next_op2);
        esl_tirs_op3_eql = (esl_t0inst_next_op3 == esl_t1inst_next_op3);
        esl_tirs_opf_eql = (esl_t0inst_next_opf == esl_t1inst_next_opf);
        esl_tirs_br_rcond_eql = (esl_t0inst_next_br_rcond == esl_t1inst_next_br_rcond);
        esl_tirs_br_cond_eql = (esl_t0inst_next_br_cond == esl_t1inst_next_br_cond);
        esl_tirs_fcn_eql = (esl_t0inst_next_fcn == esl_t1inst_next_fcn);
        esl_tirs_opf_low_eql = (esl_t0inst_next_opf_low == esl_t1inst_next_opf_low);
        esl_tirs_mv_cond_eql = (esl_t0inst_next_mv_cond == esl_t1inst_next_mv_cond);
        esl_tirs_mv_rcond_eql = (esl_t0inst_next_mv_rcond == esl_t1inst_next_mv_rcond);
        esl_tirs_x_eql = (esl_t0inst_next_x == esl_t1inst_next_x);
        esl_tirs_rd_eql = (esl_t0inst_next_rd == esl_t1inst_next_rd);

        // Determine if opcode of two instructions is equal
        // This logic is derived from SPARC V9 instruction formats
        case (esl_t0inst_next_op1)
            2'b00:
            begin
                // Branchs and SETHI, need to check op2
                
                // If branch on integer register with predication, need to
                // check rcond code
                if (esl_t0inst_next_op2 == 3'b011)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql & esl_tirs_br_rcond_eql;
                // If branch on floating-point condition codes or branch on floating
                // point condition codes with prediction or branch on integer
                // condition codes or branch on integer condition codes with
                // prediction, need to check cond code
                else if (esl_t0inst_next_op2 == 3'b110 || esl_t0inst_next_op2 == 3'b101 || 
                         esl_t0inst_next_op2 == 3'b010 || esl_t0inst_next_op2 == 3'b001)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql & esl_tirs_br_cond_eql;
                // Otherwise, just need to check op2
                else
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql;
            end
            2'b01:
            begin
                // Call instruction, just need to check op1
                esl_ops_eql_s = esl_tirs_op1_eql;
            end
            2'b10:
            begin
                // Arithmetic and Misc. (FP) instructions

                // If Done/Retry, need to check fcn
                if (esl_t0inst_next_op3 == 6'b111110)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                end
                // If floating-point add or subtract or floating-point compare
                // or floating-point to integer conversion or convert between
                // floating point formats or convert integer to floating-point
                // or floating-point move or floating-point muldiv, or floating-point
                // square root or floating-point move on condition or impl. dep., 
                // need to check opf
                else if (esl_t0inst_next_op3 == 6'b110100 || esl_t0inst_next_op3 == 6'b110101 ||
                         esl_t0inst_next_op3 == 6'b110110)
                begin
                    // If floating point move on condition, need to check cond
                    if (esl_t0inst_next_op3 == 6'b110101 &&
                        (esl_t0inst_next_opf_low == 6'b000001 ||
                         esl_t0inst_next_opf_low == 6'b000010 ||
                         esl_t0inst_next_opf_low == 6'b000011))
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_low_eql &
                                        esl_tirs_mv_cond_eql;
                    // If floating point move on integer condition, need to check rcond
                    else if (esl_t0inst_next_op3 == 6'b110101 &&
                        (esl_t0inst_next_opf_low[4:0] == 5'b00101 ||
                         esl_t0inst_next_opf_low[4:0] == 5'b00110 ||
                         esl_t0inst_next_opf_low[4:0] == 5'b00111))
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_low_eql &
                                        esl_tirs_mv_rcond_eql;
                    // Otherwise, just need to check opf
                    else
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_eql;
                end
                // If move on condition, need to check cond
                else if (esl_t0inst_next_op3 == 6'b101100)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_mv_cond_eql;
                end
                // If move on regiser condition, need to check rcond
                else if (esl_t0inst_next_op3 == 6'b101111)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_mv_rcond_eql;
                end
                // If save or restore, need to check fcn
                else if (esl_t0inst_next_op3 == 6'b110001)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                end
                // If a shift type, need to check x
                else if (esl_t0inst_next_op3 == 6'b100101 || esl_t0inst_next_op3 == 6'b100110 ||
                         esl_t0inst_next_op3 == 6'b100111)
                begin    
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_x_eql;
                end
                // If software initiated reset, need to check rd
                else if (esl_t0inst_next_op3 == 6'b110000 && esl_t0inst_next_rd == 5'b01111)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_rd_eql;
                end
                // If trap on integer condition codes, need to check cond
                else if (esl_t0inst_next_op3 == 6'b111010)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_br_cond_eql;
                end
                // Otherwise, just need to check op3
                else
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql;
                end
            end
            2'b11:
            begin
                // Loads and Stores, need to check op3
                
                // If load/store floating point state register, need to check rd
                if (esl_t0inst_next_op3 == 6'b100001 || esl_t0inst_next_op3 == 6'b100101)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_rd_eql;
                // If prefetch, need to check fcn
                else if (esl_t0inst_next_op3 == 6'b101101 || esl_t0inst_next_op3 == 6'b111101)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                // Otherwise, just need to check op3
                else
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql;
            end
            default:
                esl_ops_eql_s = 1'bx;
        endcase

        // Thread PC physical addresses equal
        esl_pcs_pa_eql_s = (fdp_esl_t0inst_paddr_next_s2 == fdp_esl_t1inst_paddr_next_s2) &
                           fcl_esl_tinst_vld_next_s[0] & fcl_esl_tinst_vld_next_s[1];

        // Control flow diverged
        esl_ctrl_flow_diverged_late_s = ((fcl_esl_brtaken_e & ~fcl_esl_brtaken_m) |
                                         (~fcl_esl_brtaken_e & fcl_esl_brtaken_m)) &
                                        (fcl_esl_thr_e == 4'b0010) &
                                        (fcl_esl_thr_m == 4'b0001) &
                                        fcl_esl_inst_vld_e & fcl_esl_inst_vld_m;

        // Check if this is the last instruction in a page (i.e. PA mod 8K is 8K - 4)
        esl_pcs_pa_page_bndry_s = ({fdp_esl_t0inst_paddr_next_s2, 2'b0} % 40'd8192) == 40'd8188;

        // Check if any trap occurred
        esl_any_trap_bf = fcl_esl_thr_trap_bf[0] | fcl_esl_thr_trap_bf[1];

        // Difference in PCs
        esl_pc_va_diff_s = ({1'b0, fdp_esl_t0pc_next_s2} - {1'b0, fdp_esl_t1pc_next_s2});

        // Difference in PCs plus offset
        esl_pc_va_diff_offset_s = esl_pc_va_diff_s + esl_pc_va_diff_offset_f;
        
        // Take absolute value of difference
        esl_pc_va_diff_abs_s = esl_pc_va_diff_offset_s;
        if (esl_pc_va_diff_abs_s[49])
            esl_pc_va_diff_abs_s = (~esl_pc_va_diff_abs_s) + 1;

        // Get minimum PC
        if (~esl_pc_va_diff_offset_s[49])
            esl_min_pc_va_s = 4'b0010;
        else
            esl_min_pc_va_s = 4'b0001;

        // Evaluate if difference is less than thresh
        esl_pc_va_diff_lt_thresh_s = (esl_pc_va_diff_abs_s < config_esl_pc_diff_thresh);

        // Evaluate if VA PCs are equal (including offset)
        esl_pcs_va_eql_s = (esl_pc_va_diff_offset_s == 50'b0);

        // Any unresolved branches in pipe?
        esl_unresolved_br = (dcl_esl_br_inst_d & fcl_esl_inst_vld_d) |
                            (dcl_esl_br_inst_e & fcl_esl_inst_vld_e);

        // A branch or trap PC is in bf or f
        esl_brtrp_target_pc_bf_f = |fdp_esl_brtrp_target_pc_bf_f[1:0];
    end

    //
    // Sub-module Instantiations
    //

    // FSM submodule - implements generic FSM logic for all synchronization
    // methods and multiplexes the synchronization method specific portion
    // according to config_esl_sync_method
    sparc_ifu_esl_fsm esl_fsm
    (
        .clk (clk),
        .rst_n (rst_n),
        .config_esl_en (config_esl_en),
        .config_esl_sync_method (config_esl_sync_method),
        .config_esl_counter_timeout (config_esl_counter_timeout),
        .config_esl_lfsr_seed (config_esl_lfsr_seed),
        .config_esl_lfsr_ld (config_esl_lfsr_ld),
        .swl_esl_thr_active (swl_esl_thr_active),
        .swl_esl_thr_urdy (swl_esl_thr_urdy),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .swl_esl_thr_sprdy_or_urdy_next (swl_esl_thr_sprdy_or_urdy_next),
        .swl_esl_use_spec (swl_esl_use_spec),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_next_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_ctrl_flow_diverged_late_s (esl_ctrl_flow_diverged_late_s),
        .esl_pcs_pa_page_bndry_s (esl_pcs_pa_page_bndry_s),
        .esl_any_trap_bf (esl_any_trap_bf),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_pcs_va_eql_s (esl_pcs_va_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .swl_esl_icmiss_out (swl_esl_icmiss_out),
        .esl_fcl_nextthr_bf (esl_fcl_nextthr_bf),
        .esl_fcl_stall_bf (esl_fcl_stall_bf),
        .esl_fcl_switch_bf (esl_fcl_switch_bf),
        .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
        .esl_fcl_ntr_s (esl_fcl_ntr_s),
        .esl_fdp_issue_prev_inst_next_s (esl_fdp_issue_prev_inst_next_s),
        .esl_fcl_force_running_s (esl_fcl_force_running_s),
        .esl_pc_va_diff_offset_we (esl_pc_va_diff_offset_we),
        .esl_pc_va_diff_offset_clear (esl_pc_va_diff_offset_clear)
    );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_rndrob.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_rndrob
//  Description:	
//  Round robin scheduler.  Least priority to the last granted
//  customer.  If no requests, the priority remains the same. 
//
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_rndrob(/*AUTOARG*/
   // Outputs
   grant_vec, so, 
   // Inputs
   clk, reset, se, si, req_vec, advance, rst_tri_enable
   );

   input     clk, reset, se, si;

   input [3:0]  req_vec;
   
   input 	advance;
   input 	rst_tri_enable;
   
   output [3:0] grant_vec;
   
   output 	so;

   wire [3:0] 	next_pv,
		pv,
		gv,
		park_vec;
   
   
   assign 	pv =  advance ? grant_vec : 
	                        park_vec;

   assign 	next_pv[3:1] = pv[3:1] & {3{~reset}};
   assign 	next_pv[0] = pv[0] | reset;
   
   dff_s #(4)  park_reg(.din  (next_pv),
		    .clk  (clk),
		    .q    (park_vec),
		    .se   (se), .si(), .so());

   // if noone requests, don't advance, otherwise we'll go back to 0
   // and will not be fair to other requestors
   assign gv[0] = park_vec[3] & req_vec[0] |
		  park_vec[2] & ~req_vec[3] & req_vec[0] |
		  park_vec[1] & ~req_vec[2] & ~req_vec[3] & req_vec[0] |
	          ~req_vec[1] & ~req_vec[2] & ~req_vec[3];
   
   assign gv[1] = park_vec[0] & req_vec[1] |
		  park_vec[3] & ~req_vec[0] & req_vec[1] |
		  park_vec[2] & ~req_vec[3] & ~req_vec[0] & req_vec[1] |
	          req_vec[1] & ~req_vec[2] & ~req_vec[3] & ~req_vec[0];

   assign gv[2] = park_vec[1] & req_vec[2] |
		  park_vec[0] & ~req_vec[1] & req_vec[2] |
		  park_vec[3] & ~req_vec[0] & ~req_vec[1] & req_vec[2] |
		  req_vec[2] & ~req_vec[3] & ~req_vec[0] & ~req_vec[1];

   assign gv[3] = park_vec[2] & req_vec[3] |
		  park_vec[1] & ~req_vec[2] & req_vec[3] |
		  park_vec[0] & ~req_vec[1] & ~req_vec[2] & req_vec[3] |
		  req_vec[3] & ~req_vec[0] & ~req_vec[1] & ~req_vec[2];

   assign grant_vec[0] = gv[0] | rst_tri_enable;
   assign grant_vec[3:1] = gv[3:1] & {3{~rst_tri_enable}};
   

endmodule // sparc_ifu_rndrob

   
   
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Wraps the IFU to tie unused signals when no SPU is present

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting












// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module sparc_ifu_nospu_wrap 
(
    input [2:0] 	  exu_tlu_wsr_data_m,

    output         ifu_exu_addr_mask_d,


    output         ifu_tlu_inst_vld_w,
    output         ifu_tlu_flush_w,
    output         ifu_lsu_alt_space_e,
    output         ifu_tlu_ttype_vld_m,
    output [4:0]   ifu_exu_muldivop_d,
    output [1:0]   ifu_lsu_thrid_s,

    input [58:0]   tlu_itlb_tte_tag_w2,
    input [42:0]   tlu_itlb_tte_data_w2,
    input          tlu_itlb_rw_index_vld_g,
    input [5:0]    tlu_itlb_rw_index_g,
    input [40:0]   tlu_idtlb_dmp_key_g,
    input          tlu_itlb_dmp_all_g,


    input [62:0]           tlu_sscan_data,
    input [15:0]           lsu_sscan_data,


    input                arst_l,
    // input [3:0]          const_cpuid,
    // input [7:0]          const_maskid,
    // input                ctu_tck,
    input [47:0]         exu_ifu_brpc_e,
    input [7:0]          exu_ifu_cc_d,
    input                exu_ifu_ecc_ce_m,
    input                exu_ifu_ecc_ue_m,
    input [7:0]          exu_ifu_err_reg_m,
    input [7:0]          exu_ifu_err_synd_m,
    input                exu_ifu_inj_ack,
    input [3:0]          exu_ifu_longop_done_g,
    input [3:0]          exu_ifu_oddwin_s,
    input                exu_ifu_regn_e,
    input                exu_ifu_regz_e,
    input                exu_ifu_spill_e,
    input                exu_ifu_va_oor_m,
    input [1:0]          ffu_ifu_cc_vld_w2,
    input [7:0]          ffu_ifu_cc_w2,
    input                ffu_ifu_ecc_ce_w2,
    input                ffu_ifu_ecc_ue_w2,
    input [5:0]          ffu_ifu_err_reg_w2,
    input [13:0]         ffu_ifu_err_synd_w2,
    input                ffu_ifu_fpop_done_w2,
    input                ffu_ifu_fst_ce_w,
    input                ffu_ifu_inj_ack,
    input                ffu_ifu_stallreq,
    input [1:0]          ffu_ifu_tid_w2,
    input                gdbginit_l,
    input                grst_l,
    input [3:0]          lsu_ifu_addr_real_l,
    input [17:0]         lsu_ifu_asi_addr,
    input                lsu_ifu_asi_load,
    input [7:0]          lsu_ifu_asi_state,
    input [1:0]          lsu_ifu_asi_thrid,
    input                lsu_ifu_asi_vld,
    input [145-1:130]lsu_ifu_cpxpkt_i1_144_130,
    input [127:0]        lsu_ifu_cpxpkt_i1_127_0,
    input                lsu_ifu_dc_parity_error_w2,
    input                lsu_ifu_dcache_data_perror,
    input                lsu_ifu_dcache_tag_perror,
    input                lsu_ifu_direct_map_l1,
    input                lsu_ifu_dtlb_data_su,
    input                lsu_ifu_dtlb_data_ue,
    input                lsu_ifu_dtlb_tag_ue,
    input [47:4]         lsu_ifu_err_addr,
    input [1:0]          lsu_ifu_error_tid,
    input [3:0]          lsu_ifu_icache_en,
    input [3:0]          lsu_ifu_inj_ack,
    input                lsu_ifu_io_error,
    input                lsu_ifu_l2_corr_error,
    input                lsu_ifu_l2_unc_error,
    input [(6 + 5):5] lsu_ifu_ld_icache_index,
    input [1:0]          lsu_ifu_ld_pcxpkt_tid,
    input                lsu_ifu_ld_pcxpkt_vld,
    input [1:0]          lsu_ifu_ldst_cmplt,
    input                lsu_ifu_ldst_miss_g,
    input                lsu_ifu_ldsta_internal_e,
    input                lsu_ifu_pcxpkt_ack_d,
    input                lsu_ifu_stallreq,
    input [3:0]          lsu_ifu_stbcnt0,
    input [3:0]          lsu_ifu_stbcnt1,
    input [3:0]          lsu_ifu_stbcnt2,
    input [3:0]          lsu_ifu_stbcnt3,
    input [47:0]         lsu_ifu_stxa_data,
    input                lsu_ifu_t0_tlz,
    input                lsu_ifu_t1_tlz,
    input                lsu_ifu_t2_tlz,
    input                lsu_ifu_t3_tlz,
    input [2:0]          lsu_pid_state0,
    input [2:0]          lsu_pid_state1,
    input [2:0]          lsu_pid_state2,
    input [2:0]          lsu_pid_state3,
    input [12:0]         lsu_t0_pctxt_state,
    input [12:0]         lsu_t1_pctxt_state,
    input                rclk,
    input [3:0]          tlu_hpstate_enb,
    input [3:0]          tlu_hpstate_ibe,
    input [3:0]          tlu_hpstate_priv,
    input [1:0]          tlu_idtlb_dmp_thrid_g,
    input                tlu_ifu_flush_pipe_w,
    input [3:0]          tlu_ifu_hintp_vld,
    input [3:0]          tlu_ifu_hwint_i3,
    input                tlu_ifu_nukeint_i2,
    input [1:0]          tlu_ifu_pstate_ie,
    input [3:0]          tlu_ifu_pstate_pef,
    input [1:0]          tlu_ifu_rerr_vld,
    input                tlu_ifu_resumint_i2,
    input                tlu_ifu_rstint_i2,
    input [3:0]          tlu_ifu_rstthr_i2,
    input [1:0]          tlu_ifu_sftint_vld,
    input [1:0]          tlu_ifu_trap_tid_w1,
    input                tlu_ifu_trapnpc_vld_w1,
    input [48:0]         tlu_ifu_trapnpc_w2,
    input                tlu_ifu_trappc_vld_w1,
    input [48:0]         tlu_ifu_trappc_w2,
    input                tlu_itlb_data_rd_g,
    input                tlu_itlb_dmp_actxt_g,
    input                tlu_itlb_dmp_nctxt_g,
    input                tlu_itlb_dmp_vld_g,
    input                tlu_itlb_invalidate_all_g,
    input                tlu_itlb_tag_rd_g,
    input                tlu_itlb_wr_vld_g,
    input [3:0]          tlu_lsu_pstate_am,
    input [3:0]          tlu_lsu_pstate_priv,
    input [3:0]          tlu_lsu_redmode,
    
    input                tlu_itlb_csm_rd_g,
    input [31:0] tlu_itlb_tte_csm_w2,
    input                tlu_itlb_wr_csm_sel_g,

    input [2-1:0]   cfg_ifu_csm_itlb_state,
    input [14-1:0]      cfg_ifu_csm_itlb_chipid,
    input [8-1:0]           cfg_ifu_csm_itlb_x,
    input [8-1:0]           cfg_ifu_csm_itlb_y,
    input [10-1:0]        cfg_ifu_csm_itlb_hdid,
    input [6-1:0]        cfg_ifu_csm_itlb_hd_size,
    input [10-1:0]        cfg_ifu_csm_itlb_sdid,
    input [6-1:0]        cfg_ifu_csm_itlb_lsid,

    


    input                config_dtu_esl_en,
    input [1:0]          config_dtu_esl_sync_method,
    input [15:0]         config_esl_lfsr_seed,
    input                config_esl_lfsr_ld,
    input [49:0]         config_esl_pc_diff_thresh,
    input [15:0]         config_esl_counter_timeout,

    // jtag

    output [2:0]         ifu_exu_aluop_d,
    output               ifu_exu_casa_d,
    output               ifu_exu_dbrinst_d,
    output               ifu_exu_disable_ce_e,
    output               ifu_exu_dontmv_regz0_e,
    output               ifu_exu_dontmv_regz1_e,
    output [7:0]         ifu_exu_ecc_mask,
    output               ifu_exu_enshift_d,
    output               ifu_exu_flushw_e,
    output               ifu_exu_ialign_d,
    output [31:0]        ifu_exu_imm_data_d,
    output               ifu_exu_inj_irferr,
    output               ifu_exu_inst_vld_e,
    output               ifu_exu_inst_vld_w,
    output               ifu_exu_invert_d,
    output               ifu_exu_kill_e,
    output               ifu_exu_muls_d,
    output               ifu_exu_nceen_e,
    output [47:0]        ifu_exu_pc_d,
    output [63:0]        ifu_exu_pcver_e,
    output               ifu_exu_range_check_jlret_d,
    output               ifu_exu_range_check_other_d,
    output [4:0]         ifu_exu_rd_d,
    output               ifu_exu_rd_exusr_e,
    output               ifu_exu_rd_ffusr_e,
    output               ifu_exu_rd_ifusr_e,
    output               ifu_exu_ren1_s,
    output               ifu_exu_ren2_s,
    output               ifu_exu_ren3_s,
    output               ifu_exu_restore_d,
    output               ifu_exu_restored_e,
    output               ifu_exu_return_d,
    output [4:0]         ifu_exu_rs1_s,
    output               ifu_exu_rs1_vld_d,
    output [4:0]         ifu_exu_rs2_s,
    output               ifu_exu_rs2_vld_d,
    output [4:0]         ifu_exu_rs3_s,
    output               ifu_exu_rs3e_vld_d,
    output               ifu_exu_rs3o_vld_d,
    output               ifu_exu_save_d,
    output               ifu_exu_saved_e,
    output               ifu_exu_setcc_d,
    output               ifu_exu_sethi_inst_d,
    output [2:0]         ifu_exu_shiftop_d,
    output               ifu_exu_tagop_d,
    output               ifu_exu_tcc_e,
    output [1:0]         ifu_exu_tid_s2,
    output               ifu_exu_ttype_vld_m,
    output               ifu_exu_tv_d,
    output               ifu_exu_use_rsr_e_l,
    output               ifu_exu_usecin_d,
    output               ifu_exu_useimm_d,
    output               ifu_exu_wen_d,
    output               ifu_exu_wsr_inst_d,
    output [1:0]         ifu_ffu_fcc_num_d,
    output               ifu_ffu_fld_d,
    output               ifu_ffu_fpop1_d,
    output               ifu_ffu_fpop2_d,
    output [8:0]         ifu_ffu_fpopcode_d,
    output [4:0]         ifu_ffu_frd_d,
    output [4:0]         ifu_ffu_frs1_d,
    output [4:0]         ifu_ffu_frs2_d,
    output               ifu_ffu_fst_d,
    output               ifu_ffu_inj_frferr,
    output               ifu_ffu_ldfsr_d,
    output               ifu_ffu_ldst_size_d,
    output               ifu_ffu_ldxfsr_d,
    output               ifu_ffu_mvcnd_m,
    output               ifu_ffu_quad_op_e,
    output               ifu_ffu_stfsr_d,
    output               ifu_ffu_visop_d,
    output               ifu_lsu_alt_space_d,
    output               ifu_lsu_asi_ack,
    output               ifu_lsu_asi_rd_unc,
    output               ifu_lsu_casa_e,
    output [2:0]         ifu_lsu_destid_s,
    output [3:0]         ifu_lsu_error_inj,
    output               ifu_lsu_fwd_data_vld,
    output               ifu_lsu_fwd_wr_ack,
    output               ifu_lsu_ibuf_busy,
    output [7:0]         ifu_lsu_imm_asi_d,
    output               ifu_lsu_imm_asi_vld_d,
    output               ifu_lsu_inv_clear,
    output               ifu_lsu_ld_inst_e,
    output               ifu_lsu_ldst_dbl_e,
    output               ifu_lsu_ldst_fp_e,
    output [1:0]         ifu_lsu_ldst_size_e,
    output               ifu_lsu_ldstub_e,
    output               ifu_lsu_ldxa_data_vld_w2,
    output [63:0]        ifu_lsu_ldxa_data_w2,
    output               ifu_lsu_ldxa_illgl_va_w2,
    output [1:0]         ifu_lsu_ldxa_tid_w2,
    output               ifu_lsu_memref_d,
    output [3:0]         ifu_lsu_nceen,
    output [51:0]        ifu_lsu_pcxpkt_e,
    output               ifu_lsu_pcxreq_d,
    output               ifu_lsu_pref_inst_e,
    output [4:0]         ifu_lsu_rd_e,
    output               ifu_lsu_sign_ext_e,
    output               ifu_lsu_st_inst_e,
    output               ifu_lsu_swap_e,
    output               ifu_lsu_wsr_inst_d,
    output               ifu_mmu_trap_m,
    output               ifu_tlu_alt_space_d,
    output               ifu_tlu_done_inst_d,
    output               ifu_tlu_flsh_inst_e,
    output               ifu_tlu_flush_m,
    output               ifu_tlu_hwint_m,
    output               ifu_tlu_icmiss_e,
    output [8:0]         ifu_tlu_imm_asi_d,
    output               ifu_tlu_immu_miss_m,
    output               ifu_tlu_inst_vld_m,
    output               ifu_tlu_itlb_done,
    output [3:0]         ifu_tlu_l2imiss,
    output               ifu_tlu_mb_inst_e,
    output [48:0]        ifu_tlu_npc_m,
    output [48:0]        ifu_tlu_pc_m,
    output               ifu_tlu_pc_oor_e,
    output               ifu_tlu_priv_violtn_m,
    output               ifu_tlu_retry_inst_d,
    output               ifu_tlu_rsr_inst_d,
    output               ifu_tlu_rstint_m,
    output               ifu_tlu_sftint_m,
    output               ifu_tlu_sir_inst_m,
    output [6:0]         ifu_tlu_sraddr_d,
    output [6:0]         ifu_tlu_sraddr_d_v2,
    output [1:0]         ifu_tlu_thrid_d,
    output [1:0]         ifu_tlu_thrid_e,
    output               ifu_tlu_trap_m,
    output [8:0]         ifu_tlu_ttype_m,

    
    output [32:0]     ifu_lsu_pcxcsm_e,
    

    // jtag debug
    output wire [94-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [47:0] rtap_core_data_47_0,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data
);

// trin: removing useless input/outp
// wire mux_drive_disable = ~grst_l;
// wire mem_write_disable = ~grst_l;
wire mux_drive_disable = 1'b0;
wire mem_write_disable = 1'b0;
wire [3:0]  const_cpuid = 4'b0;
wire [7:0]  const_maskid = 8'b0;           // To ifu of sparc_ifu.v

    sparc_ifu ifu(
                 // scan
                 // .short_si0              (1'bx),
                 // .short_si1              (1'bx),
                 // .short_so0              (),
                 // .short_so1              (),
                 // .si0                    (1'bx),
                 // .so0                    (),
                 
                 .grst_l                 (grst_l),
                 .arst_l                 (arst_l),
                 .gdbginit_l             (gdbginit_l),
                 
                 .lsu_ifu_quad_asi_e    (1'b0),

                 .lsu_ifu_addr_real_l  (lsu_ifu_addr_real_l),
                 
                 .lsu_ifu_dtlb_data_ue  (lsu_ifu_dtlb_data_ue),
                 .lsu_ifu_dtlb_tag_ue   (lsu_ifu_dtlb_tag_ue),
                 .lsu_ifu_dtlb_data_su  (lsu_ifu_dtlb_data_su),

                 .tlu_ifu_hintp_vld       (tlu_ifu_hintp_vld),
                 .tlu_ifu_rerr_vld        ({2'bx, tlu_ifu_rerr_vld}),

                 .lsu_ifu_t0_tlz        (lsu_ifu_t0_tlz),
                 .lsu_ifu_t1_tlz        (lsu_ifu_t1_tlz),
                 .lsu_ifu_t2_tlz        (lsu_ifu_t2_tlz),
                 .lsu_ifu_t3_tlz        (lsu_ifu_t3_tlz),
                 
                 .lsu_ifu_ldst_miss_g   (lsu_ifu_ldst_miss_g),
                 .tlu_ifu_flush_pipe_w  (tlu_ifu_flush_pipe_w),

                 .lsu_idtlb_mrgn        (8'bx),

                 // .mbist_loop_on_address (mbist_loop_on_address),
                 
                 .ifu_tlu_imm_asi_d     (ifu_tlu_imm_asi_d),

                 // bus width difference
                 .lsu_ifu_cpxpkt_i1     ({lsu_ifu_cpxpkt_i1_144_130, 2'bx, lsu_ifu_cpxpkt_i1_127_0}),
                     /*AUTOINST*/
                 // Outputs

                 
                 .ifu_lsu_pcxcsm_e       (ifu_lsu_pcxcsm_e), 
                 
                 .ifu_exu_addr_mask_d   (ifu_exu_addr_mask_d),
                 .ifu_tlu_inst_vld_w    (ifu_tlu_inst_vld_w),
                 .ifu_tlu_flush_w       (ifu_tlu_flush_w),
                 .ifu_lsu_alt_space_e   (ifu_lsu_alt_space_e),
                 .ifu_tlu_ttype_vld_m   (ifu_tlu_ttype_vld_m),
                 .ifu_exu_muldivop_d    (ifu_exu_muldivop_d),
                 .ifu_lsu_thrid_s       (ifu_lsu_thrid_s),
                 // .mbist_write_data      (mbist_write_data),
                 .ifu_exu_aluop_d       (ifu_exu_aluop_d),
                 .ifu_exu_casa_d        (ifu_exu_casa_d),
                 .ifu_exu_dbrinst_d     (ifu_exu_dbrinst_d),
                 .ifu_exu_disable_ce_e  (ifu_exu_disable_ce_e),
                 .ifu_exu_dontmv_regz0_e(ifu_exu_dontmv_regz0_e),
                 .ifu_exu_dontmv_regz1_e(ifu_exu_dontmv_regz1_e),
                 .ifu_exu_ecc_mask      (ifu_exu_ecc_mask),
                 .ifu_exu_enshift_d     (ifu_exu_enshift_d),
                 .ifu_exu_flushw_e      (ifu_exu_flushw_e),
                 .ifu_exu_ialign_d      (ifu_exu_ialign_d),
                 .ifu_exu_imm_data_d    (ifu_exu_imm_data_d),
                 .ifu_exu_inj_irferr    (ifu_exu_inj_irferr),
                 .ifu_exu_inst_vld_e    (ifu_exu_inst_vld_e),
                 .ifu_exu_inst_vld_w    (ifu_exu_inst_vld_w),
                 .ifu_exu_invert_d      (ifu_exu_invert_d),
                 .ifu_exu_kill_e        (ifu_exu_kill_e),
                 .ifu_exu_muls_d        (ifu_exu_muls_d),
                 .ifu_exu_nceen_e       (ifu_exu_nceen_e),
                 .ifu_exu_pc_d          (ifu_exu_pc_d),
                 .ifu_exu_pcver_e       (ifu_exu_pcver_e),
                 .ifu_exu_range_check_jlret_d(ifu_exu_range_check_jlret_d),
                 .ifu_exu_range_check_other_d(ifu_exu_range_check_other_d),
                 .ifu_exu_rd_d          (ifu_exu_rd_d),
                 .ifu_exu_rd_exusr_e    (ifu_exu_rd_exusr_e),
                 .ifu_exu_rd_ffusr_e    (ifu_exu_rd_ffusr_e),
                 .ifu_exu_rd_ifusr_e    (ifu_exu_rd_ifusr_e),
                 .ifu_exu_ren1_s        (ifu_exu_ren1_s),
                 .ifu_exu_ren2_s        (ifu_exu_ren2_s),
                 .ifu_exu_ren3_s        (ifu_exu_ren3_s),
                 .ifu_exu_restore_d     (ifu_exu_restore_d),
                 .ifu_exu_restored_e    (ifu_exu_restored_e),
                 .ifu_exu_return_d      (ifu_exu_return_d),
                 .ifu_exu_rs1_s         (ifu_exu_rs1_s),
                 .ifu_exu_rs1_vld_d     (ifu_exu_rs1_vld_d),
                 .ifu_exu_rs2_s         (ifu_exu_rs2_s),
                 .ifu_exu_rs2_vld_d     (ifu_exu_rs2_vld_d),
                 .ifu_exu_rs3_s         (ifu_exu_rs3_s),
                 .ifu_exu_rs3e_vld_d    (ifu_exu_rs3e_vld_d),
                 .ifu_exu_rs3o_vld_d    (ifu_exu_rs3o_vld_d),
                 .ifu_exu_save_d        (ifu_exu_save_d),
                 .ifu_exu_saved_e       (ifu_exu_saved_e),
                 .ifu_exu_setcc_d       (ifu_exu_setcc_d),
                 .ifu_exu_sethi_inst_d  (ifu_exu_sethi_inst_d),
                 .ifu_exu_shiftop_d     (ifu_exu_shiftop_d),
                 .ifu_exu_tagop_d       (ifu_exu_tagop_d),
                 .ifu_exu_tcc_e         (ifu_exu_tcc_e),
                 .ifu_exu_tid_s2        (ifu_exu_tid_s2),
                 .ifu_exu_ttype_vld_m   (ifu_exu_ttype_vld_m),
                 .ifu_exu_tv_d          (ifu_exu_tv_d),
                 .ifu_exu_use_rsr_e_l   (ifu_exu_use_rsr_e_l),
                 .ifu_exu_usecin_d      (ifu_exu_usecin_d),
                 .ifu_exu_useimm_d      (ifu_exu_useimm_d),
                 .ifu_exu_wen_d         (ifu_exu_wen_d),
                 .ifu_exu_wsr_inst_d    (ifu_exu_wsr_inst_d),
                 .ifu_ffu_fcc_num_d     (ifu_ffu_fcc_num_d),
                 .ifu_ffu_fld_d         (ifu_ffu_fld_d),
                 .ifu_ffu_fpop1_d       (ifu_ffu_fpop1_d),
                 .ifu_ffu_fpop2_d       (ifu_ffu_fpop2_d),
                 .ifu_ffu_fpopcode_d    (ifu_ffu_fpopcode_d),
                 .ifu_ffu_frd_d         (ifu_ffu_frd_d),
                 .ifu_ffu_frs1_d        (ifu_ffu_frs1_d),
                 .ifu_ffu_frs2_d        (ifu_ffu_frs2_d),
                 .ifu_ffu_fst_d         (ifu_ffu_fst_d),
                 .ifu_ffu_inj_frferr    (ifu_ffu_inj_frferr),
                 .ifu_ffu_ldfsr_d       (ifu_ffu_ldfsr_d),
                 .ifu_ffu_ldst_size_d   (ifu_ffu_ldst_size_d),
                 .ifu_ffu_ldxfsr_d      (ifu_ffu_ldxfsr_d),
                 .ifu_ffu_mvcnd_m       (ifu_ffu_mvcnd_m),
                 .ifu_ffu_quad_op_e     (ifu_ffu_quad_op_e),
                 .ifu_ffu_stfsr_d       (ifu_ffu_stfsr_d),
                 .ifu_ffu_visop_d       (ifu_ffu_visop_d),
                 .ifu_lsu_alt_space_d   (ifu_lsu_alt_space_d),
                 .ifu_lsu_asi_ack       (ifu_lsu_asi_ack),
                 .ifu_lsu_asi_rd_unc    (ifu_lsu_asi_rd_unc),
                 .ifu_lsu_casa_e        (ifu_lsu_casa_e),
                 .ifu_lsu_destid_s      (ifu_lsu_destid_s),
                 .ifu_lsu_error_inj     (ifu_lsu_error_inj),
                 .ifu_lsu_fwd_data_vld  (ifu_lsu_fwd_data_vld),
                 .ifu_lsu_fwd_wr_ack    (ifu_lsu_fwd_wr_ack),
                 .ifu_lsu_ibuf_busy     (ifu_lsu_ibuf_busy),
                 .ifu_lsu_imm_asi_d     (ifu_lsu_imm_asi_d),
                 .ifu_lsu_imm_asi_vld_d (ifu_lsu_imm_asi_vld_d),
                 .ifu_lsu_inv_clear     (ifu_lsu_inv_clear),
                 .ifu_lsu_ld_inst_e     (ifu_lsu_ld_inst_e),
                 .ifu_lsu_ldst_dbl_e    (ifu_lsu_ldst_dbl_e),
                 .ifu_lsu_ldst_fp_e     (ifu_lsu_ldst_fp_e),
                 .ifu_lsu_ldst_size_e   (ifu_lsu_ldst_size_e),
                 .ifu_lsu_ldstub_e      (ifu_lsu_ldstub_e),
                 .ifu_lsu_ldxa_data_vld_w2(ifu_lsu_ldxa_data_vld_w2),
                 .ifu_lsu_ldxa_data_w2  (ifu_lsu_ldxa_data_w2),
                 .ifu_lsu_ldxa_illgl_va_w2(ifu_lsu_ldxa_illgl_va_w2),
                 .ifu_lsu_ldxa_tid_w2   (ifu_lsu_ldxa_tid_w2),
                 .ifu_lsu_memref_d      (ifu_lsu_memref_d),
                 .ifu_lsu_nceen         (ifu_lsu_nceen),
                 .ifu_lsu_pcxpkt_e      (ifu_lsu_pcxpkt_e),
                 .ifu_lsu_pcxreq_d      (ifu_lsu_pcxreq_d),
                 .ifu_lsu_pref_inst_e   (ifu_lsu_pref_inst_e),
                 .ifu_lsu_rd_e          (ifu_lsu_rd_e),
                 .ifu_lsu_sign_ext_e    (ifu_lsu_sign_ext_e),
                 .ifu_lsu_st_inst_e     (ifu_lsu_st_inst_e),
                 .ifu_lsu_swap_e        (ifu_lsu_swap_e),
                 .ifu_lsu_wsr_inst_d    (ifu_lsu_wsr_inst_d),
                 .ifu_mmu_trap_m        (ifu_mmu_trap_m),
                 .ifu_spu_inst_vld_w    (),
                 .ifu_spu_nceen         (),
                 .ifu_spu_trap_ack      (),
                 .ifu_tlu_alt_space_d   (ifu_tlu_alt_space_d),
                 .ifu_tlu_done_inst_d   (ifu_tlu_done_inst_d),
                 .ifu_tlu_flsh_inst_e   (ifu_tlu_flsh_inst_e),
                 .ifu_tlu_flush_m       (ifu_tlu_flush_m),
                 .ifu_tlu_hwint_m       (ifu_tlu_hwint_m),
                 .ifu_tlu_icmiss_e      (ifu_tlu_icmiss_e),
                 .ifu_tlu_immu_miss_m   (ifu_tlu_immu_miss_m),
                 .ifu_tlu_inst_vld_m    (ifu_tlu_inst_vld_m),
                 .ifu_tlu_itlb_done     (ifu_tlu_itlb_done),
                 .ifu_tlu_l2imiss       (ifu_tlu_l2imiss),
                 .ifu_tlu_mb_inst_e     (ifu_tlu_mb_inst_e),
                 .ifu_tlu_npc_m         (ifu_tlu_npc_m),
                 .ifu_tlu_pc_m          (ifu_tlu_pc_m),
                 .ifu_tlu_pc_oor_e      (ifu_tlu_pc_oor_e),
                 .ifu_tlu_priv_violtn_m (ifu_tlu_priv_violtn_m),
                 .ifu_tlu_retry_inst_d  (ifu_tlu_retry_inst_d),
                 .ifu_tlu_rsr_inst_d    (ifu_tlu_rsr_inst_d),
                 .ifu_tlu_rstint_m      (ifu_tlu_rstint_m),
                 .ifu_tlu_sftint_m      (ifu_tlu_sftint_m),
                 .ifu_tlu_sir_inst_m    (ifu_tlu_sir_inst_m),
                 .ifu_tlu_sraddr_d      (ifu_tlu_sraddr_d),
                 .ifu_tlu_sraddr_d_v2   (ifu_tlu_sraddr_d_v2),
                 .ifu_tlu_thrid_d       (ifu_tlu_thrid_d),
                 .ifu_tlu_thrid_e       (ifu_tlu_thrid_e),
                 .ifu_tlu_trap_m        (ifu_tlu_trap_m),
                 .ifu_tlu_ttype_m       (ifu_tlu_ttype_m),
                 // Inputs

                 
                 .tlu_itlb_csm_rd_g     (tlu_itlb_csm_rd_g), 
                 .tlu_itlb_tte_csm_w2   ({1'bx, tlu_itlb_tte_csm_w2}),
                 .tlu_itlb_wr_csm_sel_g (tlu_itlb_wr_csm_sel_g), 

                 .cfg_ifu_csm_itlb_state       (cfg_ifu_csm_itlb_state),
                 .cfg_ifu_csm_itlb_chipid      (cfg_ifu_csm_itlb_chipid),
                 .cfg_ifu_csm_itlb_x           (cfg_ifu_csm_itlb_x),
                 .cfg_ifu_csm_itlb_y           (cfg_ifu_csm_itlb_y),
                 .cfg_ifu_csm_itlb_hdid        (cfg_ifu_csm_itlb_hdid),
                 .cfg_ifu_csm_itlb_hd_size     (cfg_ifu_csm_itlb_hd_size),
                 .cfg_ifu_csm_itlb_sdid        (cfg_ifu_csm_itlb_sdid),
                 .cfg_ifu_csm_itlb_lsid        (cfg_ifu_csm_itlb_lsid),

                 
                 .exu_tlu_wsr_data_m    (exu_tlu_wsr_data_m),
                 .lsu_ictag_mrgn        (4'bx),
                 .tlu_itlb_tte_tag_w2   (tlu_itlb_tte_tag_w2),
                 .tlu_itlb_tte_data_w2  (tlu_itlb_tte_data_w2),
                 .tlu_itlb_rw_index_vld_g(tlu_itlb_rw_index_vld_g),
                 .tlu_itlb_rw_index_g   (tlu_itlb_rw_index_g),
                 .tlu_idtlb_dmp_key_g   (tlu_idtlb_dmp_key_g),
                 .tlu_itlb_dmp_all_g    (tlu_itlb_dmp_all_g),
                 .const_cpuid           (const_cpuid),
                 .const_maskid          (const_maskid),
                 // .ctu_tck               (ctu_tck),
                 .exu_ifu_brpc_e        (exu_ifu_brpc_e),
                 .exu_ifu_cc_d          (exu_ifu_cc_d),
                 .exu_ifu_ecc_ce_m      (exu_ifu_ecc_ce_m),
                 .exu_ifu_ecc_ue_m      (exu_ifu_ecc_ue_m),
                 .exu_ifu_err_reg_m     (exu_ifu_err_reg_m),
                 .exu_ifu_err_synd_m    (exu_ifu_err_synd_m),
                 .exu_ifu_inj_ack       (exu_ifu_inj_ack),
                 .exu_ifu_longop_done_g (exu_ifu_longop_done_g),
                 .exu_ifu_oddwin_s      (exu_ifu_oddwin_s),
                 .exu_ifu_regn_e        (exu_ifu_regn_e),
                 .exu_ifu_regz_e        (exu_ifu_regz_e),
                 .exu_ifu_spill_e       (exu_ifu_spill_e),
                 .exu_ifu_va_oor_m      (exu_ifu_va_oor_m),
                 .ffu_ifu_cc_vld_w2     ({2'bx, ffu_ifu_cc_vld_w2}),
                 .ffu_ifu_cc_w2         (ffu_ifu_cc_w2),
                 .ffu_ifu_ecc_ce_w2     (ffu_ifu_ecc_ce_w2),
                 .ffu_ifu_ecc_ue_w2     (ffu_ifu_ecc_ue_w2),
                 .ffu_ifu_err_reg_w2    (ffu_ifu_err_reg_w2),
                 .ffu_ifu_err_synd_w2   (ffu_ifu_err_synd_w2),
                 .ffu_ifu_fpop_done_w2  (ffu_ifu_fpop_done_w2),
                 .ffu_ifu_fst_ce_w      (ffu_ifu_fst_ce_w),
                 .ffu_ifu_inj_ack       (ffu_ifu_inj_ack),
                 .ffu_ifu_stallreq      (ffu_ifu_stallreq),
                 .ffu_ifu_tid_w2        (ffu_ifu_tid_w2),
                 .lsu_ifu_asi_addr      (lsu_ifu_asi_addr),
                 .lsu_ifu_asi_load      (lsu_ifu_asi_load),
                 .lsu_ifu_asi_state     (lsu_ifu_asi_state),
                 .lsu_ifu_asi_thrid     (lsu_ifu_asi_thrid),
                 .lsu_ifu_asi_vld       (lsu_ifu_asi_vld),
                 .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                 .lsu_ifu_dcache_data_perror(lsu_ifu_dcache_data_perror),
                 .lsu_ifu_dcache_tag_perror(lsu_ifu_dcache_tag_perror),
                 .lsu_ifu_direct_map_l1 (lsu_ifu_direct_map_l1),
                 .lsu_ifu_err_addr      (lsu_ifu_err_addr),
                 .lsu_ifu_error_tid     (lsu_ifu_error_tid),
                 .lsu_ifu_icache_en     (lsu_ifu_icache_en),
                 .lsu_ifu_inj_ack       (lsu_ifu_inj_ack),
                 .lsu_ifu_io_error      (lsu_ifu_io_error),
                 .lsu_ifu_l2_corr_error (lsu_ifu_l2_corr_error),
                 .lsu_ifu_l2_unc_error  (lsu_ifu_l2_unc_error),
                 .lsu_ifu_ld_icache_index(lsu_ifu_ld_icache_index),
                 .lsu_ifu_ld_pcxpkt_tid (lsu_ifu_ld_pcxpkt_tid),
                 .lsu_ifu_ld_pcxpkt_vld (lsu_ifu_ld_pcxpkt_vld),
                 .lsu_ifu_ldst_cmplt    ({2'bx, lsu_ifu_ldst_cmplt}),
                 .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                 .lsu_ifu_pcxpkt_ack_d  (lsu_ifu_pcxpkt_ack_d),
                 .lsu_ifu_stallreq      (lsu_ifu_stallreq),
                 .lsu_ifu_stbcnt0       (lsu_ifu_stbcnt0),
                 .lsu_ifu_stbcnt1       (lsu_ifu_stbcnt1),
                 .lsu_ifu_stbcnt2       (lsu_ifu_stbcnt2),
                 .lsu_ifu_stbcnt3       (lsu_ifu_stbcnt3),
                 .lsu_ifu_stxa_data     (lsu_ifu_stxa_data),
                 .lsu_pid_state0        (lsu_pid_state0),
                 .lsu_pid_state1        (lsu_pid_state1),
                 .lsu_pid_state2        (lsu_pid_state2),
                 .lsu_pid_state3        (lsu_pid_state3),
                 .lsu_t0_pctxt_state    (lsu_t0_pctxt_state),
                 .lsu_t1_pctxt_state    (lsu_t1_pctxt_state),
                 .lsu_t2_pctxt_state    (13'bx),
                 .lsu_t3_pctxt_state    (13'bx),
                 // .mbist_bisi_mode       (mbist_bisi_mode),
                 // .mbist_dcache_data_in  (mbist_dcache_data_in),
                 // .mbist_loop_mode       (mbist_loop_mode),
                 // .mbist_start           (mbist_start),
                 // .mbist_stop_on_fail    (mbist_stop_on_fail),
                 // .mbist_stop_on_next_fail(mbist_stop_on_next_fail),
                 // .mbist_userdata_mode   (mbist_userdata_mode),
                 .rclk                  (rclk),
                 .se                    (1'b0),
                 .sehold                (1'b0),
                 .spu_ifu_corr_err_w2   (1'b0),
                 .spu_ifu_err_addr_w2   (36'h000000000),
                 .spu_ifu_int_w2        (1'b0),
                 .spu_ifu_mamem_err_w1  (1'b0),
                 .spu_ifu_ttype_tid_w2  (2'b00),
                 .spu_ifu_ttype_vld_w2  (1'b0),
                 .spu_ifu_ttype_w2      (1'b0),
                 .spu_ifu_unc_err_w1    (1'b0),
                 // .testmode_l            (1'bx),
                 .tlu_hpstate_enb       (tlu_hpstate_enb),
                 .tlu_hpstate_ibe       (tlu_hpstate_ibe),
                 .tlu_hpstate_priv      (tlu_hpstate_priv),
                 .tlu_idtlb_dmp_thrid_g (tlu_idtlb_dmp_thrid_g),
                 .tlu_ifu_hwint_i3      (tlu_ifu_hwint_i3),
                 .tlu_ifu_nukeint_i2    (tlu_ifu_nukeint_i2),
                 .tlu_ifu_pstate_ie     ({2'bx, tlu_ifu_pstate_ie}),
                 .tlu_ifu_pstate_pef    (tlu_ifu_pstate_pef),
                 .tlu_ifu_resumint_i2   (tlu_ifu_resumint_i2),
                 .tlu_ifu_rstint_i2     (tlu_ifu_rstint_i2),
                 .tlu_ifu_rstthr_i2     (tlu_ifu_rstthr_i2),
                 .tlu_ifu_sftint_vld    ({2'bx, tlu_ifu_sftint_vld}),
                 .tlu_ifu_trap_tid_w1   (tlu_ifu_trap_tid_w1),
                 .tlu_ifu_trapnpc_vld_w1(tlu_ifu_trapnpc_vld_w1),
                 .tlu_ifu_trapnpc_w2    (tlu_ifu_trapnpc_w2),
                 .tlu_ifu_trappc_vld_w1 (tlu_ifu_trappc_vld_w1),
                 .tlu_ifu_trappc_w2     (tlu_ifu_trappc_w2),
                 .tlu_itlb_data_rd_g    (tlu_itlb_data_rd_g),
                 .tlu_itlb_dmp_actxt_g  (tlu_itlb_dmp_actxt_g),
                 .tlu_itlb_dmp_nctxt_g  (tlu_itlb_dmp_nctxt_g),
                 .tlu_itlb_dmp_vld_g    (tlu_itlb_dmp_vld_g),
                 .tlu_itlb_invalidate_all_g(tlu_itlb_invalidate_all_g),
                 .tlu_itlb_tag_rd_g     (tlu_itlb_tag_rd_g),
                 .tlu_itlb_wr_vld_g     (tlu_itlb_wr_vld_g),
                 .tlu_lsu_pstate_am     (tlu_lsu_pstate_am),
                 .tlu_lsu_pstate_priv   (tlu_lsu_pstate_priv),
                 .tlu_lsu_redmode       (tlu_lsu_redmode),

                 .mem_write_disable       (mem_write_disable),
                 .mux_drive_disable       (mux_drive_disable),

                 .tlu_sscan_data    (tlu_sscan_data),
                 .lsu_sscan_data    (lsu_sscan_data),

                 // interface to srams
                 .srams_rtap_data (srams_rtap_data),
                 .rtap_srams_bist_command (rtap_srams_bist_command),
                 .rtap_srams_bist_data (rtap_srams_bist_data),

                 .config_dtu_esl_en     (config_dtu_esl_en),
                 .config_dtu_esl_sync_method (config_dtu_esl_sync_method),
                 .config_esl_lfsr_seed (config_esl_lfsr_seed),
                 .config_esl_lfsr_ld (config_esl_lfsr_ld),
                 .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
                 .config_esl_counter_timeout (config_esl_counter_timeout),

    .core_rtap_data          (core_rtap_data),
    .rtap_core_val         (rtap_core_val),
    .rtap_core_threadid         (rtap_core_threadid),
    .rtap_core_id         (rtap_core_id),
    .rtap_core_data         ({{(94-48){1'bx}}, rtap_core_data_47_0})


                 ); 

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Description:
//    The instruction fetch unit (IFU) contains the icache, ifq and
//    fetch dp.
*/

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting












// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module sparc_ifu (/*AUTOARG*/
   // Outputs
   
   ifu_lsu_pcxcsm_e,
   


   // sram wrapper interface
   rtap_srams_bist_command,
   rtap_srams_bist_data,
   srams_rtap_data,
   
   // mbist_icache_fail, mbist_done,
   // mbist_dcache_write, mbist_dcache_word, mbist_dcache_way,
   // mbist_dcache_read, mbist_dcache_index, mbist_dcache_fail,


   ifu_tlu_ttype_m, ifu_tlu_trap_m, ifu_tlu_thrid_e, ifu_tlu_thrid_d,
   ifu_tlu_sraddr_d_v2, ifu_tlu_sraddr_d, ifu_tlu_sir_inst_m,
   ifu_tlu_sftint_m, ifu_tlu_rstint_m, ifu_tlu_rsr_inst_d,
   ifu_tlu_retry_inst_d, ifu_tlu_priv_violtn_m, ifu_tlu_pc_oor_e,
   ifu_tlu_pc_m, ifu_tlu_npc_m, ifu_tlu_mb_inst_e, ifu_tlu_l2imiss,
   ifu_tlu_itlb_done, ifu_tlu_inst_vld_m, ifu_tlu_immu_miss_m,
   ifu_tlu_imm_asi_d, ifu_tlu_icmiss_e, ifu_tlu_hwint_m,
   ifu_tlu_flush_m, ifu_tlu_flsh_inst_e, ifu_tlu_done_inst_d,
   ifu_tlu_alt_space_d, ifu_spu_trap_ack, ifu_spu_nceen,
   ifu_spu_inst_vld_w, ifu_mmu_trap_m, ifu_lsu_wsr_inst_d,
   ifu_lsu_swap_e, ifu_lsu_st_inst_e, ifu_lsu_sign_ext_e,
   ifu_lsu_rd_e, ifu_lsu_pref_inst_e, ifu_lsu_pcxreq_d,
   ifu_lsu_pcxpkt_e, ifu_lsu_nceen, ifu_lsu_memref_d,
   ifu_lsu_ldxa_tid_w2, ifu_lsu_ldxa_illgl_va_w2,
   ifu_lsu_ldxa_data_w2, ifu_lsu_ldxa_data_vld_w2, ifu_lsu_ldstub_e,
   ifu_lsu_ldst_size_e, ifu_lsu_ldst_fp_e, ifu_lsu_ldst_dbl_e,
   ifu_lsu_ld_inst_e, ifu_lsu_inv_clear, ifu_lsu_imm_asi_vld_d,
   ifu_lsu_imm_asi_d, ifu_lsu_ibuf_busy, ifu_lsu_fwd_wr_ack,
   ifu_lsu_fwd_data_vld, ifu_lsu_error_inj, ifu_lsu_destid_s,
   ifu_lsu_casa_e, ifu_lsu_asi_rd_unc, ifu_lsu_asi_ack,
   ifu_lsu_alt_space_d, ifu_ffu_visop_d, ifu_ffu_stfsr_d,
   ifu_ffu_quad_op_e, ifu_ffu_mvcnd_m, ifu_ffu_ldxfsr_d,
   ifu_ffu_ldst_size_d, ifu_ffu_ldfsr_d, ifu_ffu_inj_frferr,
   ifu_ffu_fst_d, ifu_ffu_frs2_d, ifu_ffu_frs1_d, ifu_ffu_frd_d,
   ifu_ffu_fpopcode_d, ifu_ffu_fpop2_d, ifu_ffu_fpop1_d,
   ifu_ffu_fld_d, ifu_ffu_fcc_num_d, ifu_exu_wsr_inst_d,
   ifu_exu_wen_d, ifu_exu_useimm_d, ifu_exu_usecin_d,
   ifu_exu_use_rsr_e_l, ifu_exu_tv_d, ifu_exu_ttype_vld_m,
   ifu_exu_tid_s2, ifu_exu_tcc_e, ifu_exu_tagop_d, ifu_exu_shiftop_d,
   ifu_exu_sethi_inst_d, ifu_exu_setcc_d, ifu_exu_saved_e,
   ifu_exu_save_d, ifu_exu_rs3o_vld_d, ifu_exu_rs3e_vld_d,
   ifu_exu_rs3_s, ifu_exu_rs2_vld_d, ifu_exu_rs2_s,
   ifu_exu_rs1_vld_d, ifu_exu_rs1_s, ifu_exu_return_d,
   ifu_exu_restored_e, ifu_exu_restore_d, ifu_exu_ren3_s,
   ifu_exu_ren2_s, ifu_exu_ren1_s, ifu_exu_rd_ifusr_e,
   ifu_exu_rd_ffusr_e, ifu_exu_rd_exusr_e, ifu_exu_rd_d,
   ifu_exu_range_check_other_d, ifu_exu_range_check_jlret_d,
   ifu_exu_pcver_e, ifu_exu_pc_d, ifu_exu_nceen_e, ifu_exu_muls_d,
   ifu_exu_kill_e, ifu_exu_invert_d, ifu_exu_inst_vld_w,
   ifu_exu_inst_vld_e, ifu_exu_inj_irferr, ifu_exu_imm_data_d,
   ifu_exu_ialign_d, ifu_exu_flushw_e, ifu_exu_enshift_d,
   ifu_exu_ecc_mask, ifu_exu_dontmv_regz1_e, ifu_exu_dontmv_regz0_e,
   ifu_exu_disable_ce_e, ifu_exu_dbrinst_d, ifu_exu_casa_d,
   ifu_exu_aluop_d, ifu_exu_addr_mask_d,
   // so0, short_so0, short_so1,
   ifu_tlu_inst_vld_w, ifu_tlu_flush_w, ifu_lsu_alt_space_e,
   ifu_tlu_ttype_vld_m, ifu_exu_muldivop_d, ifu_lsu_thrid_s,
   // mbist_write_data,
   // Inputs
   
   tlu_itlb_csm_rd_g, tlu_itlb_tte_csm_w2,
   tlu_itlb_wr_csm_sel_g,

   cfg_ifu_csm_itlb_state, cfg_ifu_csm_itlb_chipid,cfg_ifu_csm_itlb_x,
   cfg_ifu_csm_itlb_y, cfg_ifu_csm_itlb_hdid,cfg_ifu_csm_itlb_hd_size,
   cfg_ifu_csm_itlb_sdid,cfg_ifu_csm_itlb_lsid,

   

   tlu_lsu_redmode, tlu_lsu_pstate_priv, tlu_lsu_pstate_am,
   tlu_itlb_wr_vld_g, tlu_itlb_tag_rd_g, tlu_itlb_invalidate_all_g,
   tlu_itlb_dmp_vld_g, tlu_itlb_dmp_nctxt_g, tlu_itlb_dmp_actxt_g,
   tlu_itlb_data_rd_g, tlu_ifu_trappc_w2, tlu_ifu_trappc_vld_w1,
   tlu_ifu_trapnpc_w2, tlu_ifu_trapnpc_vld_w1, tlu_ifu_trap_tid_w1,
   tlu_ifu_sftint_vld, tlu_ifu_rstthr_i2, tlu_ifu_rstint_i2,
   tlu_ifu_resumint_i2, tlu_ifu_rerr_vld, tlu_ifu_pstate_pef,
   tlu_ifu_pstate_ie, tlu_ifu_nukeint_i2, tlu_ifu_hwint_i3,
   tlu_ifu_hintp_vld, tlu_ifu_flush_pipe_w, tlu_idtlb_dmp_thrid_g,
   tlu_hpstate_priv, tlu_hpstate_ibe, tlu_hpstate_enb, 
   // testmode_l,
   spu_ifu_unc_err_w1, spu_ifu_ttype_w2, spu_ifu_ttype_vld_w2,
   spu_ifu_ttype_tid_w2, spu_ifu_mamem_err_w1, spu_ifu_int_w2,
   spu_ifu_err_addr_w2, spu_ifu_corr_err_w2, sehold, se, rclk,

   // mbist_userdata_mode, mbist_stop_on_next_fail, mbist_stop_on_fail,
   // mbist_start, mbist_loop_on_address, mbist_loop_mode,
   // mbist_dcache_data_in, mbist_bisi_mode, 

   lsu_t3_pctxt_state, lsu_t2_pctxt_state, lsu_t1_pctxt_state, lsu_t0_pctxt_state,
   lsu_pid_state3, lsu_pid_state2, lsu_pid_state1, lsu_pid_state0,
   lsu_ifu_t3_tlz, lsu_ifu_t2_tlz, lsu_ifu_t1_tlz, lsu_ifu_t0_tlz,
   lsu_ifu_stxa_data, lsu_ifu_stbcnt3, lsu_ifu_stbcnt2,
   lsu_ifu_stbcnt1, lsu_ifu_stbcnt0, lsu_ifu_stallreq,
   lsu_ifu_quad_asi_e, lsu_ifu_pcxpkt_ack_d,
   lsu_ifu_ldsta_internal_e, lsu_ifu_ldst_miss_g, lsu_ifu_ldst_cmplt,
   lsu_ifu_ld_pcxpkt_vld, lsu_ifu_ld_pcxpkt_tid,
   lsu_ifu_ld_icache_index, lsu_ifu_l2_unc_error,
   lsu_ifu_l2_corr_error, lsu_ifu_io_error, lsu_ifu_inj_ack,
   lsu_ifu_icache_en, lsu_ifu_error_tid, lsu_ifu_err_addr,
   lsu_ifu_dtlb_tag_ue, lsu_ifu_dtlb_data_ue, lsu_ifu_dtlb_data_su,
   lsu_ifu_direct_map_l1, lsu_ifu_dcache_tag_perror,
   lsu_ifu_dcache_data_perror, lsu_ifu_dc_parity_error_w2,
   lsu_ifu_cpxpkt_i1, lsu_ifu_asi_vld, lsu_ifu_asi_thrid,
   lsu_ifu_asi_state, lsu_ifu_asi_load, lsu_ifu_asi_addr,
   lsu_ifu_addr_real_l, grst_l, gdbginit_l, ffu_ifu_tid_w2,
   ffu_ifu_stallreq, ffu_ifu_inj_ack, ffu_ifu_fst_ce_w,
   ffu_ifu_fpop_done_w2, ffu_ifu_err_synd_w2, ffu_ifu_err_reg_w2,
   ffu_ifu_ecc_ue_w2, ffu_ifu_ecc_ce_w2, ffu_ifu_cc_w2,
   ffu_ifu_cc_vld_w2, exu_ifu_va_oor_m, exu_ifu_spill_e,
   exu_ifu_regz_e, exu_ifu_regn_e, exu_ifu_oddwin_s,
   exu_ifu_longop_done_g, exu_ifu_inj_ack, exu_ifu_err_synd_m,
   exu_ifu_err_reg_m, exu_ifu_ecc_ue_m, exu_ifu_ecc_ce_m,
   exu_ifu_cc_d, exu_ifu_brpc_e, 
   // efc_spc_ifuse_dshift,
   // efc_spc_ifuse_data, efc_spc_ifuse_ashift, efc_spc_fuse_clk2,
   // efc_spc_fuse_clk1,
   const_maskid, const_cpuid, arst_l,
   mem_write_disable, mux_drive_disable, exu_tlu_wsr_data_m,
   lsu_ictag_mrgn, lsu_idtlb_mrgn, 
   // si0, short_si0, short_si1,
   tlu_itlb_tte_tag_w2, tlu_itlb_tte_data_w2,
   tlu_itlb_rw_index_vld_g, tlu_itlb_rw_index_g, tlu_idtlb_dmp_key_g,
   tlu_itlb_dmp_all_g, lsu_sscan_data, tlu_sscan_data,
   config_dtu_esl_en, config_dtu_esl_sync_method,
   config_esl_lfsr_seed, config_esl_lfsr_ld, config_esl_pc_diff_thresh,
   config_esl_counter_timeout,

   // trin
   core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data


   );


   input [2:0] 	  exu_tlu_wsr_data_m;
   input [3:0]    lsu_ictag_mrgn;
   input [7:0]    lsu_idtlb_mrgn;

   // eco 5362
   output         ifu_exu_addr_mask_d;


   // scan ports

   // trin: removing scan ports
   // input                si0, short_si0,short_si1;
   // output               so0,short_so0,short_so1;
   wire si0 = 1'b0;
   wire short_si0 = 1'b0;
   wire short_si1 = 1'b0;
   wire so0,short_so0,short_so1;

   output         ifu_tlu_inst_vld_w;	// From fcl of sparc_ifu_fcl.v
   output         ifu_tlu_flush_w;	  // From fcl of sparc_ifu_fcl.v
   output         ifu_lsu_alt_space_e;    // From dec of sparc_ifu_dec.v
   output         ifu_tlu_ttype_vld_m;// From fcl of sparc_ifu_fcl.v
   output [4:0]   ifu_exu_muldivop_d;
   output [1:0]   ifu_lsu_thrid_s;

   // itlb inputs
   input [58:0]   tlu_itlb_tte_tag_w2;
   input [42:0]   tlu_itlb_tte_data_w2;
   input          tlu_itlb_rw_index_vld_g;
   input [5:0]    tlu_itlb_rw_index_g;
   input [40:0]   tlu_idtlb_dmp_key_g;
   input          tlu_itlb_dmp_all_g;

   // sscan rename
   input [15:0]   lsu_sscan_data;
   input [62:0]   tlu_sscan_data;

   // output [7:0]   mbist_write_data;     // From mbist of sparc_ifu_mbist.v

   /*AUTOINPUT*/
   // Beginning of automatic inputs (from unused autoinst inputs)
   input                arst_l;                 // To swl of sparc_ifu_swl.v, ...
   input [3:0]          const_cpuid;            // To swl of sparc_ifu_swl.v, ...
   input [7:0]          const_maskid;           // To fdp of sparc_ifu_fdp.v
   // input                rtap_sscan_se;           // To sscan of sparc_ifu_sscan.v
   // input                ctu_tck;                // To sscan of sparc_ifu_sscan.v

   input [47:0]         exu_ifu_brpc_e;         // To fdp of sparc_ifu_fdp.v
   input [7:0]          exu_ifu_cc_d;           // To dcl of sparc_ifu_dcl.v
   input                exu_ifu_ecc_ce_m;       // To fcl of sparc_ifu_fcl.v, ...
   input                exu_ifu_ecc_ue_m;       // To errctl of sparc_ifu_errctl.v
   input [7:0]          exu_ifu_err_reg_m;      // To errdp of sparc_ifu_errdp.v
   input [7:0]          exu_ifu_err_synd_m;     // To errdp of sparc_ifu_errdp.v
   input                exu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input [3:0]          exu_ifu_longop_done_g;  // To swl of sparc_ifu_swl.v
   input [3:0]          exu_ifu_oddwin_s;       // To fcl of sparc_ifu_fcl.v
   input                exu_ifu_regn_e;         // To dcl of sparc_ifu_dcl.v
   input                exu_ifu_regz_e;         // To fcl of sparc_ifu_fcl.v
   input                exu_ifu_spill_e;        // To swl of sparc_ifu_swl.v
   input                exu_ifu_va_oor_m;       // To fcl of sparc_ifu_fcl.v
   input [3:0]          ffu_ifu_cc_vld_w2;      // To dcl of sparc_ifu_dcl.v
   input [7:0]          ffu_ifu_cc_w2;          // To dcl of sparc_ifu_dcl.v
   input                ffu_ifu_ecc_ce_w2;      // To errctl of sparc_ifu_errctl.v
   input                ffu_ifu_ecc_ue_w2;      // To errctl of sparc_ifu_errctl.v
   input [5:0]          ffu_ifu_err_reg_w2;     // To errdp of sparc_ifu_errdp.v
   input [13:0]         ffu_ifu_err_synd_w2;    // To errdp of sparc_ifu_errdp.v
   input                ffu_ifu_fpop_done_w2;   // To swl of sparc_ifu_swl.v
   input                ffu_ifu_fst_ce_w;       // To swl of sparc_ifu_swl.v, ...
   input                ffu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input                ffu_ifu_stallreq;       // To fcl of sparc_ifu_fcl.v
   input [1:0]          ffu_ifu_tid_w2;         // To swl of sparc_ifu_swl.v, ...
   input                gdbginit_l;             // To swl of sparc_ifu_swl.v, ...
   input                grst_l;                 // To swl of sparc_ifu_swl.v, ...
   input [3:0]          lsu_ifu_addr_real_l;    // To fcl of sparc_ifu_fcl.v
   input [17:0]         lsu_ifu_asi_addr;       // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_asi_load;       // To ifqctl of sparc_ifu_ifqctl.v
   input [7:0]          lsu_ifu_asi_state;      // To ifqctl of sparc_ifu_ifqctl.v
   input [1:0]          lsu_ifu_asi_thrid;      // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_asi_vld;        // To ifqctl of sparc_ifu_ifqctl.v
   input [145-1:0]lsu_ifu_cpxpkt_i1;     // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_dc_parity_error_w2;// To swl of sparc_ifu_swl.v, ...
   input                lsu_ifu_dcache_data_perror;// To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dcache_tag_perror;// To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_direct_map_l1;  // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_dtlb_data_su;   // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dtlb_data_ue;   // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dtlb_tag_ue;    // To errctl of sparc_ifu_errctl.v
   input [47:4]         lsu_ifu_err_addr;       // To errdp of sparc_ifu_errdp.v
   input [1:0]          lsu_ifu_error_tid;      // To errctl of sparc_ifu_errctl.v
   input [3:0]          lsu_ifu_icache_en;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          lsu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_io_error;       // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_l2_corr_error;  // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_l2_unc_error;   // To errctl of sparc_ifu_errctl.v
   input [(6 + 5):5] lsu_ifu_ld_icache_index;// To invctl of sparc_ifu_invctl.v
   input [1:0]          lsu_ifu_ld_pcxpkt_tid;  // To invctl of sparc_ifu_invctl.v
   input                lsu_ifu_ld_pcxpkt_vld;  // To invctl of sparc_ifu_invctl.v
   input [3:0]          lsu_ifu_ldst_cmplt;     // To swl of sparc_ifu_swl.v
   input                lsu_ifu_ldst_miss_g;    // To swl of sparc_ifu_swl.v
   input                lsu_ifu_ldsta_internal_e;// To dec of sparc_ifu_dec.v, ...
   input                lsu_ifu_pcxpkt_ack_d;   // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_quad_asi_e;     // To swl of sparc_ifu_swl.v
   input                lsu_ifu_stallreq;       // To fcl of sparc_ifu_fcl.v
   input [3:0]          lsu_ifu_stbcnt0;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt1;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt2;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt3;        // To swl of sparc_ifu_swl.v
   input [47:0]         lsu_ifu_stxa_data;      // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_t0_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t1_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t2_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t3_tlz;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state0;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state1;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state2;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state3;         // To fcl of sparc_ifu_fcl.v
   input [12:0]         lsu_t0_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t1_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t2_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t3_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   // input                mbist_bisi_mode;        // To mbist of sparc_ifu_mbist.v
   // input [71:0]         mbist_dcache_data_in;   // To mbist of sparc_ifu_mbist.v
   // input                mbist_loop_mode;        // To mbist of sparc_ifu_mbist.v
   // input                mbist_loop_on_address;  // To mbist of sparc_ifu_mbist.v
   // input                mbist_start;            // To mbist of sparc_ifu_mbist.v
   // input                mbist_stop_on_fail;     // To mbist of sparc_ifu_mbist.v
   // input                mbist_stop_on_next_fail;// To mbist of sparc_ifu_mbist.v
   // input                mbist_userdata_mode;    // To mbist of sparc_ifu_mbist.v
   input                rclk;                   // To dec of sparc_ifu_dec.v, ...
   input                se;                     // To dec of sparc_ifu_dec.v, ...
   input                sehold;                 // To fcl of sparc_ifu_fcl.v, ...
   input                spu_ifu_corr_err_w2;    // To errctl of sparc_ifu_errctl.v
   input [39:4]         spu_ifu_err_addr_w2;    // To errdp of sparc_ifu_errdp.v
   input                spu_ifu_int_w2;         // To errctl of sparc_ifu_errctl.v
   input                spu_ifu_mamem_err_w1;   // To errctl of sparc_ifu_errctl.v
   input [1:0]          spu_ifu_ttype_tid_w2;   // To fcl of sparc_ifu_fcl.v, ...
   input                spu_ifu_ttype_vld_w2;   // To fcl of sparc_ifu_fcl.v
   input                spu_ifu_ttype_w2;       // To fcl of sparc_ifu_fcl.v
   input                spu_ifu_unc_err_w1;     // To errctl of sparc_ifu_errctl.v
   input [3:0]          tlu_hpstate_enb;        // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_hpstate_ibe;        // To swl of sparc_ifu_swl.v
   input [3:0]          tlu_hpstate_priv;       // To fcl of sparc_ifu_fcl.v
   input [1:0]          tlu_idtlb_dmp_thrid_g;  // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_flush_pipe_w;   // To swl of sparc_ifu_swl.v, ...
   input [3:0]          tlu_ifu_hintp_vld;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_hwint_i3;       // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_nukeint_i2;     // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_pstate_ie;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_pstate_pef;     // To swl of sparc_ifu_swl.v
   input [3:0]          tlu_ifu_rerr_vld;       // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_resumint_i2;    // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_rstint_i2;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_rstthr_i2;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_sftint_vld;     // To fcl of sparc_ifu_fcl.v
   input [1:0]          tlu_ifu_trap_tid_w1;    // To swl of sparc_ifu_swl.v, ...
   input                tlu_ifu_trapnpc_vld_w1; // To fcl of sparc_ifu_fcl.v
   input [48:0]         tlu_ifu_trapnpc_w2;     // To fdp of sparc_ifu_fdp.v
   input                tlu_ifu_trappc_vld_w1;  // To swl of sparc_ifu_swl.v, ...
   input [48:0]         tlu_ifu_trappc_w2;      // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_data_rd_g;     // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_dmp_actxt_g;   // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_dmp_nctxt_g;   // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_dmp_vld_g;     // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_invalidate_all_g;// To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_tag_rd_g;      // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_wr_vld_g;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_lsu_pstate_am;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_lsu_pstate_priv;    // To fcl of sparc_ifu_fcl.v, ...
   input [3:0]          tlu_lsu_redmode;        // To fcl of sparc_ifu_fcl.v
   // End of automatics
   
   input                tlu_itlb_csm_rd_g;
   input [32:0]     tlu_itlb_tte_csm_w2;
   input                tlu_itlb_wr_csm_sel_g;

   input [2-1:0]   cfg_ifu_csm_itlb_state;
   input [14-1:0]      cfg_ifu_csm_itlb_chipid;
   input [8-1:0]           cfg_ifu_csm_itlb_x;
   input [8-1:0]           cfg_ifu_csm_itlb_y;
   input [10-1:0]        cfg_ifu_csm_itlb_hdid;
   input [6-1:0]        cfg_ifu_csm_itlb_hd_size;
   input [10-1:0]        cfg_ifu_csm_itlb_sdid;
   input [6-1:0]        cfg_ifu_csm_itlb_lsid;

   


   input                config_dtu_esl_en;
   input [1:0]          config_dtu_esl_sync_method;
   input [15:0]         config_esl_lfsr_seed;
   input                config_esl_lfsr_ld;
   input [49:0]         config_esl_pc_diff_thresh;
   input [15:0]         config_esl_counter_timeout;


   /*AUTOOUTPUT*/
   // Beginning of automatic outputs (from unused autoinst outputs)
   output [2:0]         ifu_exu_aluop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_casa_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_dbrinst_d;      // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_disable_ce_e;   // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_dontmv_regz0_e; // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_dontmv_regz1_e; // From dcl of sparc_ifu_dcl.v
   output [7:0]         ifu_exu_ecc_mask;       // From errctl of sparc_ifu_errctl.v
   output               ifu_exu_enshift_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_flushw_e;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_ialign_d;       // From dec of sparc_ifu_dec.v
   output [31:0]        ifu_exu_imm_data_d;     // From imd of sparc_ifu_imd.v
   output               ifu_exu_inj_irferr;     // From errctl of sparc_ifu_errctl.v
   output               ifu_exu_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_inst_vld_w;     // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_invert_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_kill_e;         // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_muls_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_nceen_e;        // From errctl of sparc_ifu_errctl.v
   output [47:0]        ifu_exu_pc_d;           // From fdp of sparc_ifu_fdp.v
   output [63:0]        ifu_exu_pcver_e;        // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_range_check_jlret_d;// From dec of sparc_ifu_dec.v
   output               ifu_exu_range_check_other_d;// From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rd_d;           // From imd of sparc_ifu_imd.v
   output               ifu_exu_rd_exusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rd_ffusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rd_ifusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_ren1_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ren2_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ren3_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_restore_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_restored_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_return_d;       // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs1_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs1_vld_d;      // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs2_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs2_vld_d;      // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs3_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs3e_vld_d;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rs3o_vld_d;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_save_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_saved_e;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_setcc_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_sethi_inst_d;   // From dec of sparc_ifu_dec.v
   output [2:0]         ifu_exu_shiftop_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_tagop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_tcc_e;          // From dcl of sparc_ifu_dcl.v
   output [1:0]         ifu_exu_tid_s2;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ttype_vld_m;    // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_tv_d;           // From dec of sparc_ifu_dec.v
   output               ifu_exu_use_rsr_e_l;    // From dec of sparc_ifu_dec.v
   output               ifu_exu_usecin_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_useimm_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_wen_d;          // From dec of sparc_ifu_dec.v
   output               ifu_exu_wsr_inst_d;     // From dec of sparc_ifu_dec.v
   output [1:0]         ifu_ffu_fcc_num_d;      // From imd of sparc_ifu_imd.v
   output               ifu_ffu_fld_d;          // From dec of sparc_ifu_dec.v
   output               ifu_ffu_fpop1_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_fpop2_d;        // From dec of sparc_ifu_dec.v
   output [8:0]         ifu_ffu_fpopcode_d;     // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frd_d;          // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frs1_d;         // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frs2_d;         // From imd of sparc_ifu_imd.v
   output               ifu_ffu_fst_d;          // From dec of sparc_ifu_dec.v
   output               ifu_ffu_inj_frferr;     // From errctl of sparc_ifu_errctl.v
   output               ifu_ffu_ldfsr_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_ldst_size_d;    // From dec of sparc_ifu_dec.v
   output               ifu_ffu_ldxfsr_d;       // From dec of sparc_ifu_dec.v
   output               ifu_ffu_mvcnd_m;        // From dcl of sparc_ifu_dcl.v
   output               ifu_ffu_quad_op_e;      // From dec of sparc_ifu_dec.v
   output               ifu_ffu_stfsr_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_visop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_lsu_alt_space_d;    // From dec of sparc_ifu_dec.v
   output               ifu_lsu_asi_ack;        // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_asi_rd_unc;     // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_casa_e;         // From dec of sparc_ifu_dec.v
   output [2:0]         ifu_lsu_destid_s;       // From ifqctl of sparc_ifu_ifqctl.v
   output [3:0]         ifu_lsu_error_inj;      // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_fwd_data_vld;   // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_fwd_wr_ack;     // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_ibuf_busy;      // From ifqctl of sparc_ifu_ifqctl.v
   output [7:0]         ifu_lsu_imm_asi_d;      // From imd of sparc_ifu_imd.v
   output               ifu_lsu_imm_asi_vld_d;  // From imd of sparc_ifu_imd.v
   output               ifu_lsu_inv_clear;      // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_ld_inst_e;      // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldst_dbl_e;     // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldst_fp_e;      // From dec of sparc_ifu_dec.v
   output [1:0]         ifu_lsu_ldst_size_e;    // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldstub_e;       // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldxa_data_vld_w2;// From errctl of sparc_ifu_errctl.v
   output [63:0]        ifu_lsu_ldxa_data_w2;   // From errdp of sparc_ifu_errdp.v
   output               ifu_lsu_ldxa_illgl_va_w2;// From ifqctl of sparc_ifu_ifqctl.v
   output [1:0]         ifu_lsu_ldxa_tid_w2;    // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_memref_d;       // From dec of sparc_ifu_dec.v
   output [3:0]         ifu_lsu_nceen;          // From errctl of sparc_ifu_errctl.v
   output [51:0]        ifu_lsu_pcxpkt_e;       // From ifqdp of sparc_ifu_ifqdp.v
   output               ifu_lsu_pcxreq_d;       // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_pref_inst_e;    // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_lsu_rd_e;           // From imd of sparc_ifu_imd.v
   output               ifu_lsu_sign_ext_e;     // From dec of sparc_ifu_dec.v
   output               ifu_lsu_st_inst_e;      // From dec of sparc_ifu_dec.v
   output               ifu_lsu_swap_e;         // From dec of sparc_ifu_dec.v
   output               ifu_lsu_wsr_inst_d;     // From dec of sparc_ifu_dec.v
   output               ifu_mmu_trap_m;         // From fcl of sparc_ifu_fcl.v
   output               ifu_spu_inst_vld_w;     // From fcl of sparc_ifu_fcl.v
   output [3:0]         ifu_spu_nceen;          // From errctl of sparc_ifu_errctl.v
   output               ifu_spu_trap_ack;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_alt_space_d;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_done_inst_d;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_flsh_inst_e;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_flush_m;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_hwint_m;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_icmiss_e;       // From fcl of sparc_ifu_fcl.v
   output [8:0]         ifu_tlu_imm_asi_d;      // From imd of sparc_ifu_imd.v
   output               ifu_tlu_immu_miss_m;    // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_inst_vld_m;     // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_itlb_done;      // From fcl of sparc_ifu_fcl.v
   output [3:0]         ifu_tlu_l2imiss;        // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_tlu_mb_inst_e;      // From dec of sparc_ifu_dec.v
   output [48:0]        ifu_tlu_npc_m;          // From fdp of sparc_ifu_fdp.v
   output [48:0]        ifu_tlu_pc_m;           // From fdp of sparc_ifu_fdp.v
   output               ifu_tlu_pc_oor_e;       // From fdp of sparc_ifu_fdp.v
   output               ifu_tlu_priv_violtn_m;  // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_retry_inst_d;   // From dec of sparc_ifu_dec.v
   output               ifu_tlu_rsr_inst_d;     // From dec of sparc_ifu_dec.v
   output               ifu_tlu_rstint_m;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_sftint_m;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_sir_inst_m;     // From dec of sparc_ifu_dec.v
   output [6:0]         ifu_tlu_sraddr_d;       // From imd of sparc_ifu_imd.v
   output [6:0]         ifu_tlu_sraddr_d_v2;    // From imd of sparc_ifu_imd.v
   output [1:0]         ifu_tlu_thrid_d;        // From fcl of sparc_ifu_fcl.v
   output [1:0]         ifu_tlu_thrid_e;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_trap_m;         // From fcl of sparc_ifu_fcl.v
   output [8:0]         ifu_tlu_ttype_m;        // From fcl of sparc_ifu_fcl.v
   // End of automatics
   
   output [32:0]     ifu_lsu_pcxcsm_e;       // From ifqdp of sparc_ifu_ifqdp.v
   

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire                 dcl_fcl_bcregz0_e;      // From dcl of sparc_ifu_dcl.v
   wire                 dcl_fcl_bcregz1_e;      // From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_bcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_bpcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_br_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_call_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immbr_sel_br_d; // From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_movcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_movr_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_sethi_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_simm13_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_swl_tcc_done_m;     // From dcl of sparc_ifu_dcl.v
   wire                 dcl_esl_br_inst_d;
   wire                 dcl_esl_br_inst_e;
   wire [2:0]           dec_dcl_cctype_d;       // From dec of sparc_ifu_dec.v
   wire                 dec_fcl_rdsr_sel_pc_d;  // From dec of sparc_ifu_dec.v
   wire                 dec_fcl_rdsr_sel_thr_d; // From dec of sparc_ifu_dec.v
   wire                 dec_imd_call_inst_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_allfp_d;        // From dec of sparc_ifu_dec.v
   wire                 dec_swl_br_done_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_div_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_fpop_d;         // From dec of sparc_ifu_dec.v
   wire                 dec_swl_frf_lower_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_frf_upper_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_ld_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_ll_done_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_mul_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_rdsr_sel_thr_d; // From dec of sparc_ifu_dec.v
   wire                 dec_swl_st_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_sta_inst_e;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_std_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_wrt_tcr_w;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_wrtfprs_w;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_br_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_flush_sonly_e;  // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_fpdis_e;        // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_illinst_e;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_imask_hit_e;    // From dec of sparc_ifu_dec.v
   wire [3:0]           dtu_fcl_nextthr_bf;     // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_ntr_s;          // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_privop_e;       // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_retract_d;      // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_rollback_g;     // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_running_s;      // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_sir_inst_e;     // From dec of sparc_ifu_dec.v
   wire [3:0]           dtu_fcl_thr_active;     // From swl of sparc_ifu_swl.v
   wire [40:0]          dtu_fdp_thrconf_e;      // From swl of sparc_ifu_swl.v
   wire                 dtu_ifq_kill_latest_d;  // From dec of sparc_ifu_dec.v
   wire                 dtu_inst_anull_e;       // From dcl of sparc_ifu_dcl.v
   wire [31:0]          dtu_inst_d;             // From imd of sparc_ifu_imd.v
   wire                 dtu_reset;              // From swl of sparc_ifu_swl.v
   wire                 esl_fcl_stall_bf;       // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_switch_bf;      // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fdp_sync_pcs_bf;    // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_ntr_s;          // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fdp_issue_prev_inst_s; // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_force_running_s;
   wire                 erb_dtu_ifeterr_d1;     // From errctl of sparc_ifu_errctl.v
   wire [38:0]          erb_dtu_imask;          // From errdp of sparc_ifu_errdp.v
   wire [3:0]           erb_fcl_ce_trapvec;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_ifet_uevec_d1;  // From errctl of sparc_ifu_errctl.v
   wire                 erb_fcl_itlb_ce_d1;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_spu_uetrap;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_ue_trapvec;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_ifq_ifeterr_d1;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_ifq_itlberr_s1;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_reset;              // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_asi_thr_l;      // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_err_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_icd_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_itlb_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_misc_s_l;// From errctl of sparc_ifu_errctl.v
   wire [4-1:0]           erc_erd_asiway_s1_l;    // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_frf_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_irf_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_itlb_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_lsu_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_l1pa_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_l2pa_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_other_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_pcd1_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_mx0_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_mx1_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_old_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_wrt_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_addr_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_en_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_inj_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_stat_l;// From errctl of sparc_ifu_errctl.v
   wire [1:0]           erc_erd_erren_asidata;  // From errctl of sparc_ifu_errctl.v
   wire [31:0]          erc_erd_errinj_asidata; // From errctl of sparc_ifu_errctl.v
   wire [22:0]          erc_erd_errstat_asidata;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_ld_imask;       // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_ict_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_imask_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_other_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_pgsz_b0;        // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_pgsz_b1;        // From errctl of sparc_ifu_errctl.v
   wire                 erd_erc_fetpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire                 erd_erc_nirpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire [3:0]           erd_erc_tagpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire [1:0]           erd_erc_tlbd_pe_s1;     // From errdp of sparc_ifu_errdp.v
   wire [1:0]           erd_erc_tlbt_pe_s1;     // From errdp of sparc_ifu_errdp.v
   wire [2:0]           erd_erc_tte_pgsz;       // From errdp of sparc_ifu_errdp.v
   wire                 fcl_dcl_regz_e;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dec_dslot_s;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dec_intr_vld_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_ely_inst_vld_d; // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_hprivmode_d;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_hprivmode_w2;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_inst_vld_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_intr_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_nuke_thr_w;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_privmode_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_resum_thr_w;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_rst_thr_w;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_stall_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_sync_intr_d;    // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_dtu_thr_f;          // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_tlzero_d;       // From fcl of sparc_ifu_fcl.v
   wire [1:0]           fcl_erb_asi_tid_f;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_erb_clear_iferr;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_ievld_s1;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_immuevld_s1;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_inst_issue_d;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_inst_vld_d1;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_itlbrd_data_s;  // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_itlbrd_vld_s;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_tevld_s1;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_curr_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_dmp_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_sw_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_dmpthr_l;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_curr_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_nir_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_nop_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_switch_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_mask32b_f;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_next_ctxt_bf_l; // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_next_thr_bf_l;  // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcd_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pce_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcf_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcs_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nirthr_s1_l;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_inc_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_old_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_tnpc_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_oddwin_s;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_br_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_nosw_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_swpc_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcoor_f;        // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_pcoor_vec_f;    // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_rbinst_sel_inste_s;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_pc_e_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_thr_e_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_ver_e_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tctxt_sel_prim; // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thr_s1_l;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thr_s2_l;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_npcw_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_old_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_pcf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_tnpc_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_curr_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_ifq_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_old_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_rb_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_brpc_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_old_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_pcp4_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_trap_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_err_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_pcs_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_rb_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_trap_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_usenir_sel_nir_s1;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_index_sel_ifq_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_rdreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ict_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icv_rdreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icv_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_ifq_canthr;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_grant_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_icache_en_s_l;  // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_icmiss_s1;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_rdreq_s1;       // From fcl of sparc_ifu_fcl.v
   wire [1:0]           fcl_ifq_thr_s1;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_imd_oddwin_d;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_flush_w;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_flush_wake_w;   // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_swl_int_activate_i3;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_swcvld_s;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_swout_f;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_tlbmiss_s1;     // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_tinst_vld_next_s; // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_brtaken_e;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_brtaken_m;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_e;          // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_m;          // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_inst_vld_d;
   wire                 fcl_esl_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_inst_vld_m;     // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_trap_bf;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_rb_stg_s;  // From fcl of sparc_ifu_fcl.v
   wire [31:0]          fdp_dtu_inst_s;         // From fdp of sparc_ifu_fdp.v
   wire [47:0]          fdp_erb_pc_f;           // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_ibit_s;         // From fdp of sparc_ifu_fdp.v
   wire [5:2]           fdp_fcl_op3_s;          // From fdp of sparc_ifu_fdp.v
   wire [1:0]           fdp_fcl_op_s;           // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_pc_oor_e;       // From fdp of sparc_ifu_fdp.v
   wire [3:0]           fdp_fcl_pc_oor_vec_f;   // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_swc_s2;         // From fdp of sparc_ifu_fdp.v
   wire [32:0]          fdp_esl_t0inst_next_s2; // From fdp of sparc_ifu_fdp.v

   wire [32:0]          fdp_esl_t1inst_next_s2; // From fdp of sparc_ifu_fdp.v














   wire [39:2]          fdp_esl_t0inst_paddr_next_s2; // From fdp of sparc_ifu_fdp.v

   wire [39:2]          fdp_esl_t1inst_paddr_next_s2; // From fdp of sparc_ifu_fdp.v














   wire [48:0]          fdp_esl_t0pc_next_s2;   // From fdp of sparc_ifu_fdp.v

   wire [48:0]          fdp_esl_t1pc_next_s2;   // From fdp of sparc_ifu_fdp.v














   wire [3:0]           fdp_esl_brtrp_target_pc_bf_f;
   wire [(6 + 5):5]          fdp_icv_index_bf;       // From fdp of sparc_ifu_fdp.v

   wire [1:0]           icd_fuse_repair_en;     // From icd of bw_r_icd.v
   assign icd_fuse_repair_en = 2'b0;
   wire [7:0]           icd_fuse_repair_value;  // From icd of bw_r_icd.v
   assign icd_fuse_repair_value = 8'bx;
   wire                 fdp_fcl_jtag_breakpoint_hit;

   wire [135:0]         icd_wsel_fetdata_s1;    // From icd of bw_r_icd.v
   wire [135:0]         icd_wsel_topdata_s1;    // From icd of bw_r_icd.v
   wire [3:0]           icv_itlb_valid_f;       // From icv of sram_l1i_val.v
   wire                 ifc_ifd_addr_sel_asi_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_bist_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_fill_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_old_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_errinv_e;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_filladdr4_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_finst_sel_l;    // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_idx_sel_fwd_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_en_l;    // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_asi_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_fwd_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_inq_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_lsu_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ld_inq_i1;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_ldmil_sel_new;  // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_milfill_sel_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_milreq_sel_d_l; // From ifqctl of sparc_ifu_ifqctl.v
   wire [4:2]           ifc_ifd_pcxline_adj_d;  // From ifqctl of sparc_ifu_ifqctl.v
   wire [1:0]           ifc_ifd_repway_s;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_reqvalid_e;     // From ifqctl of sparc_ifu_ifqctl.v
   wire [1:0]           ifc_ifd_thrid_e;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_uncached_e;     // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_inv_asireq_i2;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_inv_ifqadv_i2;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifd_ifc_4bpkt_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_asi_vachklo_i2; // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:2]           ifd_ifc_asiaddr_i2;     // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxce_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxms_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxnc_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [(143 - 140 + 1):0]ifd_ifc_cpxreq_i1;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_cpxreq_nxt;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_cpxthr_nxt;     // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxue_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxvld_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid0;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid1;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid2;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid3;        // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_fwd2ic_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset0;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset1;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset2;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset3;    // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_iobpkt_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_miladdr4_i2;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_milhit_s;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_newdestid_s;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [4:2]           ifd_ifc_pcxline_d;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [145-1:0]ifd_inv_ifqop_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_inv_wrway_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [39:2]          ifq_fdp_fill_paddr;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifq_dtu_pred_rdy;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifq_dtu_thrrdy;         // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_erraddr_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_erren_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_errinj_i2;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_errstat_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_imask_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire [47:0]          ifq_erb_asidata_i2;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifq_erb_asiway_f;       // From invctl of sparc_ifu_invctl.v
   wire                 ifq_erb_asiwr_i2;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ce_rep;         // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_fwdrd_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ifet_ce;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_io_ue;          // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_l2_ue;          // From ifqctl of sparc_ifu_ifqctl.v
   wire [1:0]           ifq_erb_l2err_tid;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_rdinst_f;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_rdtag_f;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ue_rep;         // From ifqctl of sparc_ifu_ifqctl.v
   wire [(6 + 5):4]  ifq_erb_wrindex_f;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifq_fcl_asi_tid_bf;     // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_asird_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifq_fcl_fill_thr;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_flush_sonly_e;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_icd_wrreq_bf;   // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_ictv_wrreq_bf;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_invreq_bf;      // From invctl of sparc_ifu_invctl.v
   wire                 ifq_fcl_rdreq_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_stallreq;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_wrreq_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [32:0]          ifq_fdp_fill_inst;      // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifq_icd_data_sel_bist_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_icd_data_sel_fill_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_icd_data_sel_old_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire [(6 + 5):2]  ifq_icd_index_bf;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifq_icd_worden_bf;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [135:0]         ifq_icd_wrdata_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifq_icd_wrway_bf;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [4-1:0]           ifq_ict_dec_wrway_bf;   // From invctl of sparc_ifu_invctl.v
   wire                 ifq_icv_wrdata_bf;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [15:0]          ifq_icv_wren_bf;        // From invctl of sparc_ifu_invctl.v
   wire [(6 + 5):5]  ifq_icv_wrindex_bf;     // From invctl of sparc_ifu_invctl.v
   wire                 ifq_swl_stallreq;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 imd_dcl_abit_d;         // From imd of sparc_ifu_imd.v
   wire [3:0]           imd_dcl_brcond_d;       // From imd of sparc_ifu_imd.v
   wire [7:0]           imd_dcl_mvcond_d;       // From imd of sparc_ifu_imd.v
   wire                 inv_ifc_inv_pending;    // From invctl of sparc_ifu_invctl.v
   // wire [7:0]           mbist_icache_index;     // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_read;      // From mbist of sparc_ifu_mbist.v
   // wire [1:0]           mbist_icache_way;       // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_word;      // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_write;     // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_ifq_run_bist;     // From mbist of sparc_ifu_mbist.v
   wire [3:0]           swl_dcl_thr_d;          // From swl of sparc_ifu_swl.v
   wire [3:0]           swl_dcl_thr_w2;         // From swl of sparc_ifu_swl.v
   wire                 swl_dec_divbusy_e;      // From swl of sparc_ifu_swl.v
   wire                 swl_dec_fp_enable_d;    // From swl of sparc_ifu_swl.v
   wire                 swl_dec_fpbusy_e;       // From swl of sparc_ifu_swl.v
   wire                 swl_dec_ibe_e;          // From swl of sparc_ifu_swl.v
   wire                 swl_dec_mulbusy_e;      // From swl of sparc_ifu_swl.v
   wire [10:0]          swl_sscan_thrstate;     // From swl of sparc_ifu_swl.v
   wire [33:0]          wsel_fdp_fetdata_s1;    // From wseldp of sparc_ifu_wseldp.v
   wire [33:0]          wsel_fdp_topdata_s1;    // From wseldp of sparc_ifu_wseldp.v
   wire                 wsr_fixed_inst_w;       // From dec of sparc_ifu_dec.v
   // End of automatics

   
   wire [32:0]      itlb_ifq_csm_s;
   wire                 fcl_itlb_csm_rd_vld_bf;
   

   // tlb not auto instantiated
   wire           fcl_itlb_invall_f_l;	// From fcl of sparc_ifu_fcl.v

   wire           itlb_fcl_imiss_s_l;     // To fcl of sparc_ifu_fcl.v
   wire           itlb_fcl_tlbmiss_f_l;   // To fcl of sparc_ifu_fcl.v
   wire [4-1:0]     itlb_wsel_waysel_s1;     // To icd of sparc_ifu_icd.v
   wire [39:10]   itlb_ifq_paddr_s;       // To ifqdp of sparc_ifu_ifqdp.v, ...
   wire [42:0]    itlb_rd_tte_data;       // To errdp of sparc_ifu_errdp.v
   wire [58:0]    itlb_rd_tte_tag;        // To errdp of sparc_ifu_errdp.v

   wire           fcl_itlb_addr_mask_l;   // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_bypass_bf; // From fcl of sparc_ifu_fcl.v
   wire [2:0]     fcl_itlb_cam_pid_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_real_bf;   // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_vld_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_data_rd_vld_bf;// From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_dmp_vld_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_dmp_all_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_tag_rd_vld_bf; // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_wr_vld_bf;     // From fcl of sparc_ifu_fcl.v
   wire [47:2]    fdp_icd_vaddr_bf;       // From fdp of sparc_ifu_fdp.v
   wire [12:0]    fdp_itlb_ctxt_bf;       // From fdp of sparc_ifu_fdp.v
   wire [((((39 - (6 + 5))+1) * 4)-1):0]    ict_itlb_tags_f;        // From ict of bw_r_ict.v

   // sscan rename
   wire [3:0]       ifq_sscan_data;         // From ifqctl of sparc_ifu_ifqctl.v
   // bist rename
   // wire [7:0]       mbist_icache_wdata;


   // rptr bus for bist read of icache
   wire [67:0]      wsel_mbist_icache_data;

   // bus width mismatch
   wire [(39 - (6 + 5)):0] ifq_ict_wrtag_f;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [(39 - (6 + 5)):0] ifq_ict_wrtag_bf;        // Tri: earlier signal for ibm srams

   // scan wires
   wire                scan0_1;
   wire                scan0_2;
   wire                scan0_3;
   wire                scan0_4;
   wire                scan0_5;
   wire                scan0_6;
   wire                scan0_7;
   wire                scan0_8;
   wire                scan0_9;
   wire                scan0_10;
   wire                scan0_11;
   wire                scan0_12;
   wire                scan0_13;

   wire                short_scan1_1;
   wire                short_scan0_1;
   wire                short_scan0_2;
//----------------------------------------------------------------------
// Code start here
//----------------------------------------------------------------------
   // sram wrapper interface
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_icache_w10_rtap_data;
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_itag_rtap_data;
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_icache_w32_rtap_data;
   wire [4-1:0] sram_icache_w10_rtap_data;
   wire [4-1:0] sram_itag_rtap_data;
   wire [4-1:0] sram_icache_w32_rtap_data;
   wire [4-1:0] icv_rtap_data;
   input  [4-1:0] rtap_srams_bist_command;
   input  [4-1:0] rtap_srams_bist_data;
   output [4-1:0] srams_rtap_data;

   assign srams_rtap_data = sram_itag_rtap_data
                                 | sram_icache_w10_rtap_data
                                 | sram_icache_w32_rtap_data;
                                 // | icv_rtap_data;

   // jtag interface
   output wire [94-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;
   // assign core_rtap_data = `CORE_JTAG_BUS_WIDTH'd0;

   reg [3:0] ctu_sscan_tid;
   always @ *
   begin
      if (rtap_core_threadid == 2'd0)
         ctu_sscan_tid = 4'b0001;
      else if (rtap_core_threadid == 2'd1)
         ctu_sscan_tid = 4'b0010;
      else if (rtap_core_threadid == 2'd2)
         ctu_sscan_tid = 4'b0100;
      else if (rtap_core_threadid == 2'd3)
         ctu_sscan_tid = 4'b1000;
   end

   // sloppy implementation of overriding icache enable
   reg [3:0] lsu_ifu_icache_en_muxed;
   reg [3:0] lsu_ifu_icache_en_jtag;
   reg [3:0] lsu_ifu_icache_en_jtag_next;
   reg lsu_ifu_icache_en_locked;
   reg lsu_ifu_icache_en_locked_next;
   always @ *
   begin
      lsu_ifu_icache_en_locked_next = lsu_ifu_icache_en_locked;
      lsu_ifu_icache_en_jtag_next = lsu_ifu_icache_en_jtag;
      if (rtap_core_val && rtap_core_id == 4'd8)
      begin
         lsu_ifu_icache_en_locked_next = rtap_core_data[4];
         lsu_ifu_icache_en_jtag_next = rtap_core_data[3:0];
      end

      lsu_ifu_icache_en_muxed = lsu_ifu_icache_en;
      if (lsu_ifu_icache_en_locked)
         lsu_ifu_icache_en_muxed = lsu_ifu_icache_en_jtag;
   end
   always @ (posedge rclk)
   begin
      if (!arst_l)
      begin
         lsu_ifu_icache_en_locked = 1'b0;
         lsu_ifu_icache_en_jtag = 0;
      end
      else
      begin
         lsu_ifu_icache_en_locked = lsu_ifu_icache_en_locked_next;
         lsu_ifu_icache_en_jtag = lsu_ifu_icache_en_jtag_next;
      end
   end

   input          mem_write_disable;
   input          mux_drive_disable;


//   sparc_ifu_dtu dtu(
//		     .thr_config_in_w (exu_tlu_wsr_data_w[2:0]),
//		      /*AUTOINST*/);

   // decode
   sparc_ifu_dec dec(
                     .so                (scan0_1),
                     .si                (si0),
			/*AUTOINST*/
                     // Outputs
                     .ifu_exu_aluop_d   (ifu_exu_aluop_d[2:0]),
                     .ifu_exu_invert_d  (ifu_exu_invert_d),
                     .ifu_exu_useimm_d  (ifu_exu_useimm_d),
                     .ifu_exu_usecin_d  (ifu_exu_usecin_d),
                     .ifu_exu_enshift_d (ifu_exu_enshift_d),
                     .ifu_exu_tagop_d   (ifu_exu_tagop_d),
                     .ifu_exu_tv_d      (ifu_exu_tv_d),
                     .ifu_exu_muls_d    (ifu_exu_muls_d),
                     .ifu_exu_ialign_d  (ifu_exu_ialign_d),
                     .ifu_exu_range_check_jlret_d(ifu_exu_range_check_jlret_d),
                     .ifu_exu_range_check_other_d(ifu_exu_range_check_other_d),
                     .ifu_exu_shiftop_d (ifu_exu_shiftop_d[2:0]),
                     .ifu_exu_muldivop_d(ifu_exu_muldivop_d[4:0]),
                     .ifu_exu_wen_d     (ifu_exu_wen_d),
                     .ifu_exu_setcc_d   (ifu_exu_setcc_d),
                     .ifu_exu_rd_ifusr_e(ifu_exu_rd_ifusr_e),
                     .ifu_exu_rd_exusr_e(ifu_exu_rd_exusr_e),
                     .ifu_exu_rd_ffusr_e(ifu_exu_rd_ffusr_e),
                     .ifu_exu_rs1_vld_d (ifu_exu_rs1_vld_d),
                     .ifu_exu_rs2_vld_d (ifu_exu_rs2_vld_d),
                     .ifu_exu_rs3e_vld_d(ifu_exu_rs3e_vld_d),
                     .ifu_exu_rs3o_vld_d(ifu_exu_rs3o_vld_d),
                     .ifu_exu_use_rsr_e_l(ifu_exu_use_rsr_e_l),
                     .ifu_exu_save_d    (ifu_exu_save_d),
                     .ifu_exu_restore_d (ifu_exu_restore_d),
                     .ifu_exu_return_d  (ifu_exu_return_d),
                     .ifu_exu_flushw_e  (ifu_exu_flushw_e),
                     .ifu_exu_saved_e   (ifu_exu_saved_e),
                     .ifu_exu_restored_e(ifu_exu_restored_e),
                     .ifu_tlu_rsr_inst_d(ifu_tlu_rsr_inst_d),
                     .ifu_lsu_wsr_inst_d(ifu_lsu_wsr_inst_d),
                     .ifu_exu_wsr_inst_d(ifu_exu_wsr_inst_d),
                     .ifu_tlu_done_inst_d(ifu_tlu_done_inst_d),
                     .ifu_tlu_retry_inst_d(ifu_tlu_retry_inst_d),
                     .ifu_lsu_ld_inst_e (ifu_lsu_ld_inst_e),
                     .ifu_lsu_st_inst_e (ifu_lsu_st_inst_e),
                     .ifu_lsu_pref_inst_e(ifu_lsu_pref_inst_e),
                     .ifu_lsu_alt_space_e(ifu_lsu_alt_space_e),
                     .ifu_lsu_alt_space_d(ifu_lsu_alt_space_d),
                     .ifu_tlu_alt_space_d(ifu_tlu_alt_space_d),
                     .ifu_lsu_memref_d  (ifu_lsu_memref_d),
                     .ifu_lsu_sign_ext_e(ifu_lsu_sign_ext_e),
                     .ifu_lsu_ldstub_e  (ifu_lsu_ldstub_e),
                     .ifu_lsu_casa_e    (ifu_lsu_casa_e),
                     .ifu_exu_casa_d    (ifu_exu_casa_d),
                     .ifu_lsu_swap_e    (ifu_lsu_swap_e),
                     .ifu_tlu_mb_inst_e (ifu_tlu_mb_inst_e),
                     .ifu_tlu_sir_inst_m(ifu_tlu_sir_inst_m),
                     .ifu_tlu_flsh_inst_e(ifu_tlu_flsh_inst_e),
                     .ifu_lsu_ldst_dbl_e(ifu_lsu_ldst_dbl_e),
                     .ifu_lsu_ldst_fp_e (ifu_lsu_ldst_fp_e),
                     .ifu_lsu_ldst_size_e(ifu_lsu_ldst_size_e[1:0]),
                     .ifu_ffu_fpop1_d   (ifu_ffu_fpop1_d),
                     .ifu_ffu_visop_d   (ifu_ffu_visop_d),
                     .ifu_ffu_fpop2_d   (ifu_ffu_fpop2_d),
                     .ifu_ffu_fld_d     (ifu_ffu_fld_d),
                     .ifu_ffu_fst_d     (ifu_ffu_fst_d),
                     .ifu_ffu_ldst_size_d(ifu_ffu_ldst_size_d),
                     .ifu_ffu_ldfsr_d   (ifu_ffu_ldfsr_d),
                     .ifu_ffu_ldxfsr_d  (ifu_ffu_ldxfsr_d),
                     .ifu_ffu_stfsr_d   (ifu_ffu_stfsr_d),
                     .ifu_ffu_quad_op_e (ifu_ffu_quad_op_e),
                     .dec_fcl_rdsr_sel_pc_d(dec_fcl_rdsr_sel_pc_d),
                     .dec_fcl_rdsr_sel_thr_d(dec_fcl_rdsr_sel_thr_d),
                     .dec_imd_call_inst_d(dec_imd_call_inst_d),
                     .dtu_fcl_flush_sonly_e(dtu_fcl_flush_sonly_e),
                     .dtu_fcl_illinst_e (dtu_fcl_illinst_e),
                     .dtu_fcl_fpdis_e   (dtu_fcl_fpdis_e),
                     .dtu_fcl_privop_e  (dtu_fcl_privop_e),
                     .dtu_fcl_imask_hit_e(dtu_fcl_imask_hit_e),
                     .dtu_fcl_br_inst_d (dtu_fcl_br_inst_d),
                     .dtu_fcl_sir_inst_e(dtu_fcl_sir_inst_e),
                     .dtu_ifq_kill_latest_d(dtu_ifq_kill_latest_d),
                     .dec_swl_wrt_tcr_w (dec_swl_wrt_tcr_w),
                     .dec_swl_wrtfprs_w (dec_swl_wrtfprs_w),
                     .dec_swl_ll_done_d (dec_swl_ll_done_d),
                     .dec_swl_br_done_d (dec_swl_br_done_d),
                     .dec_swl_rdsr_sel_thr_d(dec_swl_rdsr_sel_thr_d),
                     .dec_swl_ld_inst_d (dec_swl_ld_inst_d),
                     .dec_swl_sta_inst_e(dec_swl_sta_inst_e),
                     .dec_swl_std_inst_d(dec_swl_std_inst_d),
                     .dec_swl_st_inst_d (dec_swl_st_inst_d),
                     .dec_swl_fpop_d    (dec_swl_fpop_d),
                     .dec_swl_allfp_d   (dec_swl_allfp_d),
                     .dec_swl_frf_upper_d(dec_swl_frf_upper_d),
                     .dec_swl_frf_lower_d(dec_swl_frf_lower_d),
                     .dec_swl_div_inst_d(dec_swl_div_inst_d),
                     .dec_swl_mul_inst_d(dec_swl_mul_inst_d),
                     .wsr_fixed_inst_w  (wsr_fixed_inst_w),
                     .ifu_exu_sethi_inst_d(ifu_exu_sethi_inst_d),
                     .dec_dcl_cctype_d  (dec_dcl_cctype_d[2:0]),
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),
                     .dtu_inst_d        (dtu_inst_d[31:0]),
                     .erb_dtu_imask     (erb_dtu_imask[38:0]),
                     .swl_dec_ibe_e     (swl_dec_ibe_e),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                     .fcl_dtu_tlzero_d  (fcl_dtu_tlzero_d),
                     .fcl_dtu_privmode_d(fcl_dtu_privmode_d),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .fcl_dtu_ely_inst_vld_d(fcl_dtu_ely_inst_vld_d),
                     .fcl_dec_intr_vld_d(fcl_dec_intr_vld_d),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dec_dslot_s   (fcl_dec_dslot_s),
                     .swl_dec_mulbusy_e (swl_dec_mulbusy_e),
                     .swl_dec_fpbusy_e  (swl_dec_fpbusy_e),
                     .swl_dec_divbusy_e (swl_dec_divbusy_e),
                     .swl_dec_fp_enable_d(swl_dec_fp_enable_d));


   // Pipeline Control and Switch Logic
   sparc_ifu_swl swl(
                     .so                (scan0_2),
                     .si                (scan0_1),
		                 .thr_config_in_m	(exu_tlu_wsr_data_m[2:0]),
                     .extra_longlat_compl(4'b0),

		                 /*AUTOINST*/
                     // Outputs
                     .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
                     .dtu_reset         (dtu_reset),
                     .swl_dec_mulbusy_e (swl_dec_mulbusy_e),
                     .swl_dec_divbusy_e (swl_dec_divbusy_e),
                     .swl_dec_fpbusy_e  (swl_dec_fpbusy_e),
                     .swl_dec_fp_enable_d(swl_dec_fp_enable_d),
                     .swl_dec_ibe_e     (swl_dec_ibe_e),
                     .dtu_fcl_ntr_s     (dtu_fcl_ntr_s),
                     .dtu_fcl_running_s (dtu_fcl_running_s),
                     .dtu_fcl_rollback_g(dtu_fcl_rollback_g),
                     .dtu_fcl_retract_d (dtu_fcl_retract_d),
                     .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                     .dtu_fcl_nextthr_bf(dtu_fcl_nextthr_bf[3:0]),
                     .swl_dcl_thr_d     (swl_dcl_thr_d[3:0]),
                     .swl_dcl_thr_w2    (swl_dcl_thr_w2[3:0]),
                     .esl_fcl_stall_bf  (esl_fcl_stall_bf),
                     .esl_fcl_switch_bf (esl_fcl_switch_bf),
                     .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
                     .esl_fcl_ntr_s     (esl_fcl_ntr_s),
                     .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),
                     .esl_fcl_force_running_s (esl_fcl_force_running_s),
                     .dtu_fdp_thrconf_e (dtu_fdp_thrconf_e[40:0]),
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),
                     .gdbginit_l        (gdbginit_l),
                     .arst_l            (arst_l),
                     .grst_l            (grst_l),
                     .ctu_sscan_tid     (ctu_sscan_tid[3:0]),
                     .ifq_dtu_thrrdy    (ifq_dtu_thrrdy[3:0]),
                     .ifq_dtu_pred_rdy  (ifq_dtu_pred_rdy[3:0]),
                     .ifu_tlu_inst_vld_w(ifu_tlu_inst_vld_w),
                     .ifu_tlu_ttype_vld_m(ifu_tlu_ttype_vld_m),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_hprivmode_w2(fcl_dtu_hprivmode_w2),
                     .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                     .fcl_swl_flush_w   (fcl_swl_flush_w),
                     .fcl_dtu_sync_intr_d(fcl_dtu_sync_intr_d),
                     .fcl_dtu_nuke_thr_w(fcl_dtu_nuke_thr_w),
                     .fcl_dtu_rst_thr_w (fcl_dtu_rst_thr_w),
                     .fcl_dtu_resum_thr_w(fcl_dtu_resum_thr_w),
                     .fcl_dtu_thr_f     (fcl_dtu_thr_f[3:0]),
                     .tlu_hpstate_ibe   (tlu_hpstate_ibe[3:0]),
                     .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                     .tlu_ifu_trappc_vld_w1(tlu_ifu_trappc_vld_w1),
                     .dec_swl_ll_done_d (dec_swl_ll_done_d),
                     .dec_swl_br_done_d (dec_swl_br_done_d),
                     .dec_swl_rdsr_sel_thr_d(dec_swl_rdsr_sel_thr_d),
                     .dec_swl_std_inst_d(dec_swl_std_inst_d),
                     .dec_swl_sta_inst_e(dec_swl_sta_inst_e),
                     .wsr_fixed_inst_w  (wsr_fixed_inst_w),
                     .dec_swl_ld_inst_d (dec_swl_ld_inst_d),
                     .dec_swl_mul_inst_d(dec_swl_mul_inst_d),
                     .dec_swl_div_inst_d(dec_swl_div_inst_d),
                     .dec_swl_fpop_d    (dec_swl_fpop_d),
                     .dec_swl_allfp_d   (dec_swl_allfp_d),
                     .dec_swl_frf_upper_d(dec_swl_frf_upper_d),
                     .dec_swl_frf_lower_d(dec_swl_frf_lower_d),
                     .dec_swl_wrtfprs_w (dec_swl_wrtfprs_w),
                     .dcl_swl_tcc_done_m(dcl_swl_tcc_done_m),
                     .exu_ifu_longop_done_g(exu_ifu_longop_done_g[3:0]),
                     .exu_ifu_spill_e   (exu_ifu_spill_e),
                     .lsu_ifu_ldst_cmplt(lsu_ifu_ldst_cmplt[3:0]),
                     .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                     .lsu_ifu_stbcnt0   (lsu_ifu_stbcnt0[3:0]),
                     .lsu_ifu_stbcnt1   (lsu_ifu_stbcnt1[3:0]),
                     .lsu_ifu_stbcnt2   (lsu_ifu_stbcnt2[3:0]),
                     .lsu_ifu_stbcnt3   (lsu_ifu_stbcnt3[3:0]),
                     .lsu_ifu_quad_asi_e(lsu_ifu_quad_asi_e),
                     .ffu_ifu_fpop_done_w2(ffu_ifu_fpop_done_w2),
                     .ffu_ifu_tid_w2    (ffu_ifu_tid_w2[1:0]),
                     .ffu_ifu_fst_ce_w  (ffu_ifu_fst_ce_w),
                     .tlu_ifu_trap_tid_w1(tlu_ifu_trap_tid_w1[1:0]),
                     .tlu_ifu_pstate_pef(tlu_ifu_pstate_pef[3:0]),
                     .lsu_ifu_ldst_miss_g(lsu_ifu_ldst_miss_g),
                     .fcl_swl_int_activate_i3(fcl_swl_int_activate_i3[3:0]),
                     .fcl_swl_flush_wake_w(fcl_swl_flush_wake_w),
                     .ifq_swl_stallreq  (ifq_swl_stallreq),
                     .fcl_dtu_stall_bf  (fcl_dtu_stall_bf),
                     .fcl_swl_swout_f   (fcl_swl_swout_f),
                     .fcl_swl_swcvld_s  (fcl_swl_swcvld_s),
                     .fdp_fcl_swc_s2    (fdp_fcl_swc_s2),
                     .fcl_ifq_icmiss_s1 (fcl_ifq_icmiss_s1),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .const_cpuid       (const_cpuid[3:0]),
                     .dec_swl_wrt_tcr_w (dec_swl_wrt_tcr_w),
                     .dec_swl_st_inst_d (dec_swl_st_inst_d),
                     .config_dtu_esl_en (config_dtu_esl_en),
                     .config_dtu_esl_sync_method (config_dtu_esl_sync_method),
                     .config_esl_lfsr_seed (config_esl_lfsr_seed),
                     .config_esl_lfsr_ld (config_esl_lfsr_ld),
                     .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
                     .config_esl_counter_timeout (config_esl_counter_timeout),
                     .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

                     .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














                     .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

                     .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














                     .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

                     .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














                     .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
                     .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
                     .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
                     .fcl_esl_thr_e (fcl_esl_thr_e),
                     .fcl_esl_thr_m (fcl_esl_thr_m),
                     .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
                     .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
                     .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
                     .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
                     .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
                     .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
                     .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
                     .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),


                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)
                     );

   // Branch Logic
   sparc_ifu_dcl  dcl(
                      .so               (scan0_3),
                      .si               (scan0_2),
		                  .dtu_dcl_opf2_d	(dtu_inst_d[7]),
                      .fdp_dcl_op_s     (fdp_dtu_inst_s[31:30]),
                      .fdp_dcl_op3_s    (fdp_dtu_inst_s[24:19]),

		                  /*AUTOINST*/
                      // Outputs
                      .ifu_exu_kill_e   (ifu_exu_kill_e),
                      .ifu_exu_dontmv_regz0_e(ifu_exu_dontmv_regz0_e),
                      .ifu_exu_dontmv_regz1_e(ifu_exu_dontmv_regz1_e),
                      .ifu_exu_tcc_e    (ifu_exu_tcc_e),
                      .ifu_exu_dbrinst_d(ifu_exu_dbrinst_d),
                      .ifu_ffu_mvcnd_m  (ifu_ffu_mvcnd_m),
                      .dcl_fcl_bcregz0_e(dcl_fcl_bcregz0_e),
                      .dcl_fcl_bcregz1_e(dcl_fcl_bcregz1_e),
                      .dtu_inst_anull_e (dtu_inst_anull_e),
                      .dcl_swl_tcc_done_m(dcl_swl_tcc_done_m),
                      .dcl_imd_immdata_sel_simm13_d_l(dcl_imd_immdata_sel_simm13_d_l),
                      .dcl_imd_immdata_sel_movcc_d_l(dcl_imd_immdata_sel_movcc_d_l),
                      .dcl_imd_immdata_sel_sethi_d_l(dcl_imd_immdata_sel_sethi_d_l),
                      .dcl_imd_immdata_sel_movr_d_l(dcl_imd_immdata_sel_movr_d_l),
                      .dcl_imd_broff_sel_call_d_l(dcl_imd_broff_sel_call_d_l),
                      .dcl_imd_broff_sel_br_d_l(dcl_imd_broff_sel_br_d_l),
                      .dcl_imd_broff_sel_bcc_d_l(dcl_imd_broff_sel_bcc_d_l),
                      .dcl_imd_broff_sel_bpcc_d_l(dcl_imd_broff_sel_bpcc_d_l),
                      .dcl_imd_immbr_sel_br_d(dcl_imd_immbr_sel_br_d),
                      .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
                      .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .dtu_reset        (dtu_reset),
                      .exu_ifu_cc_d     (exu_ifu_cc_d[7:0]),
                      .fcl_dcl_regz_e   (fcl_dcl_regz_e),
                      .exu_ifu_regn_e   (exu_ifu_regn_e),
                      .ffu_ifu_cc_w2    (ffu_ifu_cc_w2[7:0]),
                      .ffu_ifu_cc_vld_w2(ffu_ifu_cc_vld_w2[3:0]),
                      .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                      .swl_dcl_thr_d    (swl_dcl_thr_d[3:0]),
                      .swl_dcl_thr_w2   (swl_dcl_thr_w2[3:0]),
                      .imd_dcl_brcond_d (imd_dcl_brcond_d[3:0]),
                      .imd_dcl_mvcond_d (imd_dcl_mvcond_d[7:0]),
                      .imd_dcl_abit_d   (imd_dcl_abit_d),
                      .dec_dcl_cctype_d (dec_dcl_cctype_d[2:0]),
                      .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                      .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                      .ifu_tlu_flush_w  (ifu_tlu_flush_w));

/*   sparc_ifu_imd AUTO_TEMPLATE(
                         .dcl_imd_call_inst_d (dec_imd_call_inst_d),
                         );

*/
   sparc_ifu_imd  imd(
                      .so               (scan0_4),
                      .si               (scan0_3),

                      /*AUTOINST*/
                      // Outputs
                      .ifu_exu_imm_data_d(ifu_exu_imm_data_d[31:0]),
                      .dtu_inst_d       (dtu_inst_d[31:0]),
                      .ifu_exu_rd_d     (ifu_exu_rd_d[4:0]),
                      .ifu_lsu_rd_e     (ifu_lsu_rd_e[4:0]),
                      .ifu_lsu_imm_asi_d(ifu_lsu_imm_asi_d[7:0]),
                      .ifu_tlu_imm_asi_d(ifu_tlu_imm_asi_d[8:0]),
                      .ifu_lsu_imm_asi_vld_d(ifu_lsu_imm_asi_vld_d),
                      .ifu_tlu_sraddr_d (ifu_tlu_sraddr_d[6:0]),
                      .ifu_tlu_sraddr_d_v2(ifu_tlu_sraddr_d_v2[6:0]),
                      .imd_dcl_brcond_d (imd_dcl_brcond_d[3:0]),
                      .imd_dcl_mvcond_d (imd_dcl_mvcond_d[7:0]),
                      .imd_dcl_abit_d   (imd_dcl_abit_d),
                      .ifu_ffu_frs1_d   (ifu_ffu_frs1_d[4:0]),
                      .ifu_ffu_frs2_d   (ifu_ffu_frs2_d[4:0]),
                      .ifu_ffu_frd_d    (ifu_ffu_frd_d[4:0]),
                      .ifu_ffu_fpopcode_d(ifu_ffu_fpopcode_d[8:0]),
                      .ifu_ffu_fcc_num_d(ifu_ffu_fcc_num_d[1:0]),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .fdp_dtu_inst_s   (fdp_dtu_inst_s[31:0]),
                      .fcl_imd_oddwin_d (fcl_imd_oddwin_d),
                      .dcl_imd_immdata_sel_simm13_d_l(dcl_imd_immdata_sel_simm13_d_l),
                      .dcl_imd_immdata_sel_movcc_d_l(dcl_imd_immdata_sel_movcc_d_l),
                      .dcl_imd_immdata_sel_sethi_d_l(dcl_imd_immdata_sel_sethi_d_l),
                      .dcl_imd_immdata_sel_movr_d_l(dcl_imd_immdata_sel_movr_d_l),
                      .dcl_imd_broff_sel_call_d_l(dcl_imd_broff_sel_call_d_l),
                      .dcl_imd_broff_sel_br_d_l(dcl_imd_broff_sel_br_d_l),
                      .dcl_imd_broff_sel_bcc_d_l(dcl_imd_broff_sel_bcc_d_l),
                      .dcl_imd_broff_sel_bpcc_d_l(dcl_imd_broff_sel_bpcc_d_l),
                      .dcl_imd_immbr_sel_br_d(dcl_imd_immbr_sel_br_d),
                      .dcl_imd_call_inst_d(dec_imd_call_inst_d)); // Templated

   sparc_ifu_fdp  fdp(
                      .so               (scan0_5),
                      .si               (scan0_4),
                     .fdp_itlb_ctxt_bf (fdp_itlb_ctxt_bf[12:0]),
                      .fdp_icd_vaddr_bf (fdp_icd_vaddr_bf[47:2]),
                      .icd_fdp_fetdata_s1(wsel_fdp_fetdata_s1[32:0]),
                      .icd_fdp_topdata_s1(wsel_fdp_topdata_s1[32:0]),
                      // eco 5362
                      .fcl_fdp_addr_mask_d(ifu_exu_addr_mask_d),
                      /*AUTOINST*/
                      // Outputs
                      .fdp_icv_index_bf (fdp_icv_index_bf[(6 + 5):5]),
                      .fdp_erb_pc_f     (fdp_erb_pc_f[47:0]),
                      .fdp_dtu_inst_s   (fdp_dtu_inst_s[31:0]),
                      .ifu_exu_pc_d     (ifu_exu_pc_d[47:0]),
                      .ifu_exu_rs1_s    (ifu_exu_rs1_s[4:0]),
                      .ifu_exu_rs2_s    (ifu_exu_rs2_s[4:0]),
                      .ifu_exu_rs3_s    (ifu_exu_rs3_s[4:0]),
                      .ifu_tlu_pc_m     (ifu_tlu_pc_m[48:0]),
                      .ifu_tlu_npc_m    (ifu_tlu_npc_m[48:0]),
                      .ifu_tlu_pc_oor_e (ifu_tlu_pc_oor_e),
                      .ifu_exu_pcver_e  (ifu_exu_pcver_e[63:0]),
                      .fdp_fcl_swc_s2   (fdp_fcl_swc_s2),
                      .fdp_fcl_pc_oor_vec_f(fdp_fcl_pc_oor_vec_f[3:0]),
                      .fdp_fcl_pc_oor_e (fdp_fcl_pc_oor_e),
                      .fdp_fcl_op_s     (fdp_fcl_op_s[1:0]),
                      .fdp_fcl_op3_s    (fdp_fcl_op3_s[5:2]),
                      .fdp_fcl_ibit_s   (fdp_fcl_ibit_s),
                      .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

                      .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














                      .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

                      .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














                      .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

                      .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














                      .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .const_maskid     (const_maskid[7:0]),
                      .lsu_t0_pctxt_state(lsu_t0_pctxt_state[12:0]),
                      .lsu_t1_pctxt_state(lsu_t1_pctxt_state[12:0]),
                      .lsu_t2_pctxt_state(lsu_t2_pctxt_state[12:0]),
                      .lsu_t3_pctxt_state(lsu_t3_pctxt_state[12:0]),
                      .exu_ifu_brpc_e   (exu_ifu_brpc_e[47:0]),
                      .tlu_ifu_trappc_w2(tlu_ifu_trappc_w2[48:0]),
                      .tlu_ifu_trapnpc_w2(tlu_ifu_trapnpc_w2[48:0]),
                      .tlu_itlb_dmp_nctxt_g(tlu_itlb_dmp_nctxt_g),
                      .tlu_itlb_dmp_actxt_g(tlu_itlb_dmp_actxt_g),
                      .tlu_itlb_tte_tag_w2(tlu_itlb_tte_tag_w2[12:0]),
                      .dtu_fdp_thrconf_e(dtu_fdp_thrconf_e[40:0]),
                      .ifq_fdp_fill_inst(ifq_fdp_fill_inst[32:0]),
                      .fcl_fdp_oddwin_s (fcl_fdp_oddwin_s),
                      .fcl_fdp_pcoor_vec_f(fcl_fdp_pcoor_vec_f[3:0]),
                      .fcl_fdp_pcoor_f  (fcl_fdp_pcoor_f),
                      .fcl_fdp_mask32b_f(fcl_fdp_mask32b_f),
                      .fcl_fdp_tctxt_sel_prim(fcl_fdp_tctxt_sel_prim[3:0]),
                      .fcl_fdp_usenir_sel_nir_s1(fcl_fdp_usenir_sel_nir_s1),
                      .fcl_fdp_rbinst_sel_inste_s(fcl_fdp_rbinst_sel_inste_s[3:0]),
                      .fcl_fdp_thrtnpc_sel_tnpc_l(fcl_fdp_thrtnpc_sel_tnpc_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_npcw_l(fcl_fdp_thrtnpc_sel_npcw_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_pcf_l(fcl_fdp_thrtnpc_sel_pcf_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_old_l(fcl_fdp_thrtnpc_sel_old_l[3:0]),
                      .fcl_fdp_thr_s1_l (fcl_fdp_thr_s1_l[3:0]),
                      .fcl_fdp_next_thr_bf_l(fcl_fdp_next_thr_bf_l[3:0]),
                      .fcl_fdp_next_ctxt_bf_l(fcl_fdp_next_ctxt_bf_l[3:0]),
                      .fcl_fdp_thr_s2_l (fcl_fdp_thr_s2_l[3:0]),
                      .fcl_fdp_nirthr_s1_l(fcl_fdp_nirthr_s1_l[3:0]),
                      .fcl_fdp_tpcbf_sel_pcp4_bf_l(fcl_fdp_tpcbf_sel_pcp4_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_brpc_bf_l(fcl_fdp_tpcbf_sel_brpc_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_trap_bf_l(fcl_fdp_tpcbf_sel_trap_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_old_bf_l(fcl_fdp_tpcbf_sel_old_bf_l[3:0]),
                      .fcl_fdp_pcbf_sel_swpc_bf_l(fcl_fdp_pcbf_sel_swpc_bf_l),
                      .fcl_fdp_pcbf_sel_nosw_bf_l(fcl_fdp_pcbf_sel_nosw_bf_l),
                      .fcl_fdp_pcbf_sel_br_bf_l(fcl_fdp_pcbf_sel_br_bf_l),
                      .fcl_fdp_trrbpc_sel_trap_bf_l(fcl_fdp_trrbpc_sel_trap_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_rb_bf_l(fcl_fdp_trrbpc_sel_rb_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_err_bf_l(fcl_fdp_trrbpc_sel_err_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_pcs_bf_l(fcl_fdp_trrbpc_sel_pcs_bf_l[3:0]),
                      .fcl_fdp_noswpc_sel_tnpc_l_bf(fcl_fdp_noswpc_sel_tnpc_l_bf),
                      .fcl_fdp_noswpc_sel_old_l_bf(fcl_fdp_noswpc_sel_old_l_bf),
                      .fcl_fdp_noswpc_sel_inc_l_bf(fcl_fdp_noswpc_sel_inc_l_bf),
                      .fcl_fdp_nextpcs_sel_pce_f_l(fcl_fdp_nextpcs_sel_pce_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcd_f_l(fcl_fdp_nextpcs_sel_pcd_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcs_f_l(fcl_fdp_nextpcs_sel_pcs_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcf_f_l(fcl_fdp_nextpcs_sel_pcf_f_l[3:0]),
                      .fcl_fdp_rdsr_sel_pc_e_l(fcl_fdp_rdsr_sel_pc_e_l),
                      .fcl_fdp_rdsr_sel_ver_e_l(fcl_fdp_rdsr_sel_ver_e_l),
                      .fcl_fdp_rdsr_sel_thr_e_l(fcl_fdp_rdsr_sel_thr_e_l),
                      .fcl_fdp_inst_sel_curr_s_l(fcl_fdp_inst_sel_curr_s_l),
                      .fcl_fdp_inst_sel_switch_s_l(fcl_fdp_inst_sel_switch_s_l),
                      .fcl_fdp_inst_sel_nir_s_l(fcl_fdp_inst_sel_nir_s_l),
                      .fcl_fdp_inst_sel_nop_s_l(fcl_fdp_inst_sel_nop_s_l),
                      .fcl_fdp_tinst_sel_curr_s_l(fcl_fdp_tinst_sel_curr_s_l[3:0]),
                      .fcl_fdp_tinst_sel_rb_s_l(fcl_fdp_tinst_sel_rb_s_l[3:0]),
                      .fcl_fdp_tinst_sel_old_s_l(fcl_fdp_tinst_sel_old_s_l[3:0]),
                      .fcl_fdp_tinst_sel_ifq_s_l(fcl_fdp_tinst_sel_ifq_s_l[3:0]),
                      .fcl_fdp_dmpthr_l (fcl_fdp_dmpthr_l[3:0]),
                      .fcl_fdp_ctxt_sel_dmp_bf_l(fcl_fdp_ctxt_sel_dmp_bf_l),
                      .fcl_fdp_ctxt_sel_sw_bf_l(fcl_fdp_ctxt_sel_sw_bf_l),
                      .fcl_fdp_ctxt_sel_curr_bf_l(fcl_fdp_ctxt_sel_curr_bf_l),
                      .itlb_fdp_paddr_s(itlb_ifq_paddr_s[39:10]),
                      .fcl_fdp_tlbmiss_s1 (fcl_fdp_tlbmiss_s1),
                      .ifq_fdp_fill_paddr(ifq_fdp_fill_paddr[39:2]),
                      .config_dtu_esl_en (config_dtu_esl_en),
                      .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
                      .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),

                     .fdp_fcl_jtag_breakpoint_hit(fdp_fcl_jtag_breakpoint_hit),

                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)
                      );

   sparc_ifu_fcl fcl(
                     .so                (short_scan1_1),
                     .si                (short_si1),
                     .rst_tri_en        (mux_drive_disable),

                     // keep around in case we need it later
                     .ifu_reset_l       (),

		                 .fdp_fcl_va2_bf    (fdp_icd_vaddr_bf[2]),
                     .itlb_fcl_priv_s1  (itlb_rd_tte_data[4]),
                     .tlu_fcl_dmp_pid_bf (tlu_itlb_tte_tag_w2[58:56]),
                     .tlu_fcl_dmp_real_bf (tlu_itlb_tte_tag_w2[55]),
                     .itlb_fcl_cp_s1    (itlb_rd_tte_data[7]),
                     // need these here since itlb is not auto inst'ed
		                 .fcl_itlb_invall_f_l(fcl_itlb_invall_f_l),
                     .fcl_itlb_cam_vld_bf(fcl_itlb_cam_vld_bf),
                     .fcl_itlb_cam_bypass_bf(fcl_itlb_cam_bypass_bf),
                     .fcl_itlb_addr_mask_l(fcl_itlb_addr_mask_l),
                     .fcl_itlb_cam_real_bf(fcl_itlb_cam_real_bf),
                     .fcl_itlb_cam_pid_bf(fcl_itlb_cam_pid_bf[2:0]),
                     .fcl_itlb_wr_vld_bf(fcl_itlb_wr_vld_bf),
                     .fcl_itlb_dmp_vld_bf(fcl_itlb_dmp_vld_bf),
                     .fcl_itlb_dmp_all_bf(fcl_itlb_dmp_all_bf),
                     .fcl_itlb_tag_rd_vld_bf(fcl_itlb_tag_rd_vld_bf),
                     .fcl_itlb_data_rd_vld_bf(fcl_itlb_data_rd_vld_bf),

                     // eco 5362
                     .fcl_fdp_addr_mask_d(ifu_exu_addr_mask_d),

		      /*AUTOINST*/
                     // Outputs

                     
                     .fcl_itlb_csm_rd_vld_bf(fcl_itlb_csm_rd_vld_bf),
                     
                     .fcl_icd_rdreq_bf  (fcl_icd_rdreq_bf),
                     .fcl_icv_rdreq_bf  (fcl_icv_rdreq_bf),
                     .fcl_icd_wrreq_bf  (fcl_icd_wrreq_bf),
                     .fcl_ict_wrreq_bf  (fcl_ict_wrreq_bf),
                     .fcl_icv_wrreq_bf  (fcl_icv_wrreq_bf),
                     .fcl_icd_index_sel_ifq_bf(fcl_icd_index_sel_ifq_bf),
                     .fcl_ifq_grant_bf  (fcl_ifq_grant_bf),
                     .fcl_ifq_icmiss_s1 (fcl_ifq_icmiss_s1),
                     .fcl_ifq_rdreq_s1  (fcl_ifq_rdreq_s1),
                     .fcl_ifq_icache_en_s_l(fcl_ifq_icache_en_s_l),
                     .fcl_ifq_thr_s1    (fcl_ifq_thr_s1[1:0]),
                     .fcl_ifq_canthr    (fcl_ifq_canthr[3:0]),
                     .fcl_erb_ievld_s1  (fcl_erb_ievld_s1),
                     .fcl_erb_tevld_s1  (fcl_erb_tevld_s1),
                     .fcl_erb_immuevld_s1(fcl_erb_immuevld_s1),
                     .ifu_lsu_thrid_s   (ifu_lsu_thrid_s[1:0]),
                     .fcl_erb_asi_tid_f (fcl_erb_asi_tid_f[1:0]),
                     .fcl_erb_clear_iferr(fcl_erb_clear_iferr[3:0]),
                     .fcl_erb_itlbrd_vld_s(fcl_erb_itlbrd_vld_s),
                     .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                     .fcl_dec_dslot_s   (fcl_dec_dslot_s),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .fcl_dtu_ely_inst_vld_d(fcl_dtu_ely_inst_vld_d),
                     .fcl_dec_intr_vld_d(fcl_dec_intr_vld_d),
                     .fcl_erb_inst_issue_d(fcl_erb_inst_issue_d),
                     .fcl_erb_inst_vld_d1(fcl_erb_inst_vld_d1),
                     .ifu_tlu_inst_vld_m(ifu_tlu_inst_vld_m),
                     .ifu_exu_inst_vld_e(ifu_exu_inst_vld_e),
                     .ifu_exu_inst_vld_w(ifu_exu_inst_vld_w),
                     .ifu_spu_inst_vld_w(ifu_spu_inst_vld_w),
                     .ifu_tlu_inst_vld_w(ifu_tlu_inst_vld_w),
                     .ifu_tlu_flush_w   (ifu_tlu_flush_w),
                     .ifu_tlu_flush_m   (ifu_tlu_flush_m),
                     .fcl_swl_int_activate_i3(fcl_swl_int_activate_i3[3:0]),
                     .fcl_swl_flush_wake_w(fcl_swl_flush_wake_w),
                     .fcl_swl_flush_w   (fcl_swl_flush_w),
                     .fcl_dcl_regz_e    (fcl_dcl_regz_e),
                     .ifu_tlu_thrid_e   (ifu_tlu_thrid_e[1:0]),
                     .ifu_tlu_thrid_d   (ifu_tlu_thrid_d[1:0]),
                     .ifu_tlu_immu_miss_m(ifu_tlu_immu_miss_m),
                     .ifu_tlu_priv_violtn_m(ifu_tlu_priv_violtn_m),
                     .ifu_tlu_icmiss_e  (ifu_tlu_icmiss_e),
                     .ifu_tlu_ttype_vld_m(ifu_tlu_ttype_vld_m),
                     .ifu_exu_ttype_vld_m(ifu_exu_ttype_vld_m),
                     .ifu_mmu_trap_m    (ifu_mmu_trap_m),
                     .ifu_tlu_trap_m    (ifu_tlu_trap_m),
                     .ifu_tlu_ttype_m   (ifu_tlu_ttype_m[8:0]),
                     .ifu_tlu_hwint_m   (ifu_tlu_hwint_m),
                     .ifu_tlu_sftint_m  (ifu_tlu_sftint_m),
                     .ifu_tlu_rstint_m  (ifu_tlu_rstint_m),
                     .fcl_dtu_rst_thr_w (fcl_dtu_rst_thr_w),
                     .fcl_dtu_resum_thr_w(fcl_dtu_resum_thr_w),
                     .ifu_tlu_itlb_done (ifu_tlu_itlb_done),
                     .ifu_spu_trap_ack  (ifu_spu_trap_ack),
                     .ifu_exu_tid_s2    (ifu_exu_tid_s2[1:0]),
                     .ifu_exu_ren1_s    (ifu_exu_ren1_s),
                     .ifu_exu_ren2_s    (ifu_exu_ren2_s),
                     .ifu_exu_ren3_s    (ifu_exu_ren3_s),
                     .ifu_exu_disable_ce_e(ifu_exu_disable_ce_e),
                     .fcl_dtu_sync_intr_d(fcl_dtu_sync_intr_d),
                     .fcl_dtu_tlzero_d  (fcl_dtu_tlzero_d),
                     .fcl_dtu_privmode_d(fcl_dtu_privmode_d),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_hprivmode_w2(fcl_dtu_hprivmode_w2),
                     .fcl_dtu_nuke_thr_w(fcl_dtu_nuke_thr_w),
                     .fcl_swl_swout_f   (fcl_swl_swout_f),
                     .fcl_dtu_stall_bf  (fcl_dtu_stall_bf),
                     .fcl_swl_swcvld_s  (fcl_swl_swcvld_s),
                     .fcl_dtu_thr_f     (fcl_dtu_thr_f[3:0]),
                     .fcl_imd_oddwin_d  (fcl_imd_oddwin_d),
                     .fcl_fdp_oddwin_s  (fcl_fdp_oddwin_s),
                     .fcl_fdp_pcoor_vec_f(fcl_fdp_pcoor_vec_f[3:0]),
                     .fcl_fdp_pcoor_f   (fcl_fdp_pcoor_f),
                     .fcl_fdp_mask32b_f (fcl_fdp_mask32b_f),
                     .fcl_fdp_tctxt_sel_prim(fcl_fdp_tctxt_sel_prim[3:0]),
                     .fcl_fdp_usenir_sel_nir_s1(fcl_fdp_usenir_sel_nir_s1),
                     .fcl_fdp_rbinst_sel_inste_s(fcl_fdp_rbinst_sel_inste_s[3:0]),
                     .fcl_fdp_thrtnpc_sel_tnpc_l(fcl_fdp_thrtnpc_sel_tnpc_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_npcw_l(fcl_fdp_thrtnpc_sel_npcw_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_pcf_l(fcl_fdp_thrtnpc_sel_pcf_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_old_l(fcl_fdp_thrtnpc_sel_old_l[3:0]),
                     .fcl_fdp_thr_s1_l  (fcl_fdp_thr_s1_l[3:0]),
                     .fcl_fdp_next_thr_bf_l(fcl_fdp_next_thr_bf_l[3:0]),
                     .fcl_fdp_next_ctxt_bf_l(fcl_fdp_next_ctxt_bf_l[3:0]),
                     .fcl_fdp_nirthr_s1_l(fcl_fdp_nirthr_s1_l[3:0]),
                     .fcl_fdp_thr_s2_l  (fcl_fdp_thr_s2_l[3:0]),
                     .fcl_fdp_tpcbf_sel_pcp4_bf_l(fcl_fdp_tpcbf_sel_pcp4_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_brpc_bf_l(fcl_fdp_tpcbf_sel_brpc_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_trap_bf_l(fcl_fdp_tpcbf_sel_trap_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_old_bf_l(fcl_fdp_tpcbf_sel_old_bf_l[3:0]),
                     .fcl_fdp_pcbf_sel_nosw_bf_l(fcl_fdp_pcbf_sel_nosw_bf_l),
                     .fcl_fdp_pcbf_sel_swpc_bf_l(fcl_fdp_pcbf_sel_swpc_bf_l),
                     .fcl_fdp_pcbf_sel_br_bf_l(fcl_fdp_pcbf_sel_br_bf_l),
                     .fcl_fdp_trrbpc_sel_trap_bf_l(fcl_fdp_trrbpc_sel_trap_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_rb_bf_l(fcl_fdp_trrbpc_sel_rb_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_err_bf_l(fcl_fdp_trrbpc_sel_err_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_pcs_bf_l(fcl_fdp_trrbpc_sel_pcs_bf_l[3:0]),
                     .fcl_fdp_noswpc_sel_tnpc_l_bf(fcl_fdp_noswpc_sel_tnpc_l_bf),
                     .fcl_fdp_noswpc_sel_old_l_bf(fcl_fdp_noswpc_sel_old_l_bf),
                     .fcl_fdp_noswpc_sel_inc_l_bf(fcl_fdp_noswpc_sel_inc_l_bf),
                     .fcl_fdp_nextpcs_sel_pce_f_l(fcl_fdp_nextpcs_sel_pce_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcd_f_l(fcl_fdp_nextpcs_sel_pcd_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcs_f_l(fcl_fdp_nextpcs_sel_pcs_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcf_f_l(fcl_fdp_nextpcs_sel_pcf_f_l[3:0]),
                     .fcl_fdp_inst_sel_curr_s_l(fcl_fdp_inst_sel_curr_s_l),
                     .fcl_fdp_inst_sel_switch_s_l(fcl_fdp_inst_sel_switch_s_l),
                     .fcl_fdp_inst_sel_nir_s_l(fcl_fdp_inst_sel_nir_s_l),
                     .fcl_fdp_inst_sel_nop_s_l(fcl_fdp_inst_sel_nop_s_l),
                     .fcl_fdp_tinst_sel_curr_s_l(fcl_fdp_tinst_sel_curr_s_l[3:0]),
                     .fcl_fdp_tinst_sel_rb_s_l(fcl_fdp_tinst_sel_rb_s_l[3:0]),
                     .fcl_fdp_tinst_sel_old_s_l(fcl_fdp_tinst_sel_old_s_l[3:0]),
                     .fcl_fdp_tinst_sel_ifq_s_l(fcl_fdp_tinst_sel_ifq_s_l[3:0]),
                     .fcl_fdp_dmpthr_l  (fcl_fdp_dmpthr_l[3:0]),
                     .fcl_fdp_ctxt_sel_dmp_bf_l(fcl_fdp_ctxt_sel_dmp_bf_l),
                     .fcl_fdp_ctxt_sel_sw_bf_l(fcl_fdp_ctxt_sel_sw_bf_l),
                     .fcl_fdp_ctxt_sel_curr_bf_l(fcl_fdp_ctxt_sel_curr_bf_l),
                     .fcl_fdp_rdsr_sel_pc_e_l(fcl_fdp_rdsr_sel_pc_e_l),
                     .fcl_fdp_rdsr_sel_thr_e_l(fcl_fdp_rdsr_sel_thr_e_l),
                     .fcl_fdp_rdsr_sel_ver_e_l(fcl_fdp_rdsr_sel_ver_e_l),
                     .fcl_fdp_tlbmiss_s1 (fcl_fdp_tlbmiss_s1),
                     .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
                     .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
                     .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
                     .fcl_esl_thr_e (fcl_esl_thr_e),
                     .fcl_esl_thr_m (fcl_esl_thr_m),
                     .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
                     .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
                     .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
                     .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
                     .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
                     // Inputs
                     
                     .tlu_itlb_csm_rd_g (tlu_itlb_csm_rd_g),
                     
                     .rclk              (rclk),
                     .grst_l            (grst_l),
                     .arst_l            (arst_l),
                     .se                (se),
                     .sehold            (sehold),
                     .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                     .exu_ifu_va_oor_m  (exu_ifu_va_oor_m),
                     .exu_ifu_oddwin_s  (exu_ifu_oddwin_s[3:0]),
                     .spu_ifu_ttype_tid_w2(spu_ifu_ttype_tid_w2[1:0]),
                     .spu_ifu_ttype_vld_w2(spu_ifu_ttype_vld_w2),
                     .spu_ifu_ttype_w2  (spu_ifu_ttype_w2),
                     .erb_fcl_spu_uetrap(erb_fcl_spu_uetrap[3:0]),
                     .exu_ifu_regz_e    (exu_ifu_regz_e),
                     .dcl_fcl_bcregz0_e (dcl_fcl_bcregz0_e),
                     .dcl_fcl_bcregz1_e (dcl_fcl_bcregz1_e),
                     .dtu_fcl_rollback_g(dtu_fcl_rollback_g),
                     .dtu_fcl_retract_d (dtu_fcl_retract_d),
                     .dtu_fcl_br_inst_d (dtu_fcl_br_inst_d),
                     .dtu_fcl_sir_inst_e(dtu_fcl_sir_inst_e),
                     .dtu_fcl_privop_e  (dtu_fcl_privop_e),
                     .dtu_fcl_fpdis_e   (dtu_fcl_fpdis_e),
                     .dtu_fcl_imask_hit_e(dtu_fcl_imask_hit_e),
                     .dtu_fcl_illinst_e (dtu_fcl_illinst_e),
                     .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                     .dec_fcl_rdsr_sel_pc_d(dec_fcl_rdsr_sel_pc_d),
                     .dec_fcl_rdsr_sel_thr_d(dec_fcl_rdsr_sel_thr_d),
                     .ifq_fcl_wrreq_bf  (ifq_fcl_wrreq_bf),
                     .ifq_fcl_icd_wrreq_bf(ifq_fcl_icd_wrreq_bf),
                     .ifq_fcl_ictv_wrreq_bf(ifq_fcl_ictv_wrreq_bf),
                     .ifq_fcl_rdreq_bf  (ifq_fcl_rdreq_bf),
                     .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                     .ifq_fcl_asird_bf  (ifq_fcl_asird_bf),
                     .ifq_fcl_invreq_bf (ifq_fcl_invreq_bf),
                     .erb_fcl_itlb_ce_d1(erb_fcl_itlb_ce_d1),
                     .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                     .erb_fcl_ifet_uevec_d1(erb_fcl_ifet_uevec_d1[3:0]),
                     .erb_fcl_ue_trapvec(erb_fcl_ue_trapvec[3:0]),
                     .erb_fcl_ce_trapvec(erb_fcl_ce_trapvec[3:0]),
                     .dtu_fcl_nextthr_bf(dtu_fcl_nextthr_bf[3:0]),
                     .dtu_fcl_ntr_s     (dtu_fcl_ntr_s),
                     .dtu_fcl_running_s (dtu_fcl_running_s),
                     .dtu_fcl_flush_sonly_e(dtu_fcl_flush_sonly_e),
                     .fdp_fcl_swc_s2    (fdp_fcl_swc_s2),
                     .itlb_fcl_tlbmiss_f_l(itlb_fcl_tlbmiss_f_l),
                     .itlb_fcl_imiss_s_l(itlb_fcl_imiss_s_l),
                     .fdp_fcl_pc_oor_vec_f(fdp_fcl_pc_oor_vec_f[3:0]),
                     .fdp_fcl_pc_oor_e  (fdp_fcl_pc_oor_e),
                     .fdp_fcl_op_s      (fdp_fcl_op_s[1:0]),
                     .fdp_fcl_op3_s     (fdp_fcl_op3_s[5:2]),
                     .fdp_fcl_ibit_s    (fdp_fcl_ibit_s),
                     .lsu_ifu_stallreq  (lsu_ifu_stallreq),
                     .ffu_ifu_stallreq  (ffu_ifu_stallreq),
                     .ifq_fcl_stallreq  (ifq_fcl_stallreq),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .ifq_fcl_fill_thr  (ifq_fcl_fill_thr[3:0]),
                     .ifq_fcl_flush_sonly_e(ifq_fcl_flush_sonly_e),
                     .tlu_ifu_trap_tid_w1(tlu_ifu_trap_tid_w1[1:0]),
                     .tlu_ifu_trappc_vld_w1(tlu_ifu_trappc_vld_w1),
                     .tlu_ifu_trapnpc_vld_w1(tlu_ifu_trapnpc_vld_w1),
                     .tlu_lsu_pstate_priv(tlu_lsu_pstate_priv[3:0]),
                     .tlu_lsu_pstate_am (tlu_lsu_pstate_am[3:0]),
                     .tlu_hpstate_priv  (tlu_hpstate_priv[3:0]),
                     .tlu_lsu_redmode   (tlu_lsu_redmode[3:0]),
                     .tlu_hpstate_enb   (tlu_hpstate_enb[3:0]),
                     .lsu_ifu_addr_real_l(lsu_ifu_addr_real_l[3:0]),
                     .lsu_pid_state0    (lsu_pid_state0[2:0]),
                     .lsu_pid_state1    (lsu_pid_state1[2:0]),
                     .lsu_pid_state2    (lsu_pid_state2[2:0]),
                     .lsu_pid_state3    (lsu_pid_state3[2:0]),
                     .lsu_ifu_icache_en (lsu_ifu_icache_en_muxed[3:0]),
                     .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                     .lsu_ifu_t0_tlz    (lsu_ifu_t0_tlz),
                     .lsu_ifu_t1_tlz    (lsu_ifu_t1_tlz),
                     .lsu_ifu_t2_tlz    (lsu_ifu_t2_tlz),
                     .lsu_ifu_t3_tlz    (lsu_ifu_t3_tlz),
                     .tlu_ifu_hwint_i3  (tlu_ifu_hwint_i3[3:0]),
                     .tlu_ifu_pstate_ie (tlu_ifu_pstate_ie[3:0]),
                     .tlu_ifu_sftint_vld(tlu_ifu_sftint_vld[3:0]),
                     .tlu_ifu_hintp_vld (tlu_ifu_hintp_vld[3:0]),
                     .tlu_ifu_rerr_vld  (tlu_ifu_rerr_vld[3:0]),
                     .tlu_ifu_rstthr_i2 (tlu_ifu_rstthr_i2[3:0]),
                     .tlu_ifu_rstint_i2 (tlu_ifu_rstint_i2),
                     .tlu_ifu_resumint_i2(tlu_ifu_resumint_i2),
                     .tlu_ifu_nukeint_i2(tlu_ifu_nukeint_i2),
                     .tlu_itlb_wr_vld_g (tlu_itlb_wr_vld_g),
                     .tlu_itlb_dmp_vld_g(tlu_itlb_dmp_vld_g),
                     .tlu_itlb_dmp_all_g(tlu_itlb_dmp_all_g),
                     .tlu_itlb_data_rd_g(tlu_itlb_data_rd_g),
                     .tlu_itlb_tag_rd_g (tlu_itlb_tag_rd_g),
                     .tlu_itlb_invalidate_all_g(tlu_itlb_invalidate_all_g),
                     .tlu_idtlb_dmp_thrid_g(tlu_idtlb_dmp_thrid_g[1:0]),
                     .exu_ifu_ecc_ce_m  (exu_ifu_ecc_ce_m),
                     .ffu_ifu_fst_ce_w  (ffu_ifu_fst_ce_w),
                     .config_dtu_esl_en (config_dtu_esl_en),
                     .esl_fcl_stall_bf  (esl_fcl_stall_bf),
                     .esl_fcl_switch_bf (esl_fcl_switch_bf),
                     .esl_fcl_ntr_s (esl_fcl_ntr_s),
                     .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),
                     .esl_fcl_force_running_s (esl_fcl_force_running_s),

                     .fdp_fcl_jtag_breakpoint_hit(fdp_fcl_jtag_breakpoint_hit),

                     // .core_rtap_data          (core_rtap_data),
                     .rtap_core_val         (rtap_core_val),
                     .rtap_core_threadid         (rtap_core_threadid),
                     .rtap_core_id         (rtap_core_id),
                     .rtap_core_data         (rtap_core_data)
                     );

//   sparc_ifu_itlb itlb(
//                        .adj    (lsu_idtlb_mrgn[7:0]),
//			                  .reset  (fcl_itlb_invall_bf),
//                        .tlu_itlb_dmp_actxt_g(tlu_itlb_dmp_actxt_g),
//                        .itlb_vaddr_offset_f (fdp_erb_pc_f[`IC_IDX_HI:(`IC_IDX_HI-1)]),
//			                  /*AUTOINST*/
//                        // Outputs
//                        .ifu_lsu_tlb_writeable(ifu_lsu_tlb_writeable),
//                        .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
//                        .itlb_icd_waysel_s1(itlb_icd_waysel_s1[`IC_WAY_ARRAY_MASK]),
//                        .itlb_fcl_imiss_s_l(itlb_fcl_imiss_s_l),
//                        .itlb_fcl_tlbmiss_f_l(itlb_fcl_tlbmiss_f_l),
//                        .itlb_fcl_priv_s1(itlb_fcl_priv_s1),
//                        .itlb_rd_tte_data(itlb_rd_tte_data[42:0]),
//                        .itlb_rd_tte_tag(itlb_rd_tte_tag[58:0]),
//                        .so             (so),
                        // Inputs
//                        .clk            (clk),
//                        .se             (se),
//                        .si             (si),
//                        .fdp_icd_vaddr_bf(fdp_icd_vaddr_bf[47:10]),
//                        .fdp_itlb_ctxt_bf(fdp_itlb_ctxt_bf[12:0]),
//                        .ict_itlb_tags_f(ict_itlb_tags_f[`IC_TAG_ALL_HI:0]),
//                        .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
//                        .fcl_itlb_cam_vld_bf(fcl_itlb_cam_vld_bf),
//                        .fcl_itlb_wr_vld_bf(fcl_itlb_wr_vld_bf),
//                        .fcl_itlb_addr_mask_l(fcl_itlb_addr_mask_l),
//                        .fcl_itlb_dmp_vld_bf(fcl_itlb_dmp_vld_bf),
//                        .fcl_itlb_tag_rd_vld_bf(fcl_itlb_tag_rd_vld_bf),
//                        .fcl_itlb_data_rd_vld_bf(fcl_itlb_data_rd_vld_bf),
//                        .fcl_itlb_cam_real_bf(fcl_itlb_cam_real_bf),
//                        .fcl_itlb_cam_pid_bf(fcl_itlb_cam_pid_bf[2:0]),
//                        .tlu_itlb_tte_tag_w2(tlu_itlb_tte_tag_w2[58:0]),
//                        .tlu_itlb_tte_data_w2(tlu_itlb_tte_data_w2[42:0]),
//                        .tlu_itlb_rw_index_vld_g(tlu_itlb_rw_index_vld_g),
//                        .tlu_itlb_rw_index_g(tlu_itlb_rw_index_g[5:0]),
//                        .tlu_idtlb_dmp_key_g(tlu_idtlb_dmp_key_g[40:0]),
//                        .tlu_itlb_dmp_by_ctxt_g(tlu_itlb_dmp_by_ctxt_g),
//                        .tlu_itlb_dmp_all_g(tlu_itlb_dmp_all_g));

   bw_r_itlb itlb(
		              .tlb_pgnum_crit	(),
		              // Outputs
                       
                       .tlb_rd_tte_csm         (itlb_ifq_csm_s),
                       .tlb_rd_tte_csm_crit    (),
                       

		              .tlb_rd_tte_tag	 (itlb_rd_tte_tag[58:0]),  // 2
		              .tlb_rd_tte_data (itlb_rd_tte_data[42:0]), // 2
		              .tlb_pgnum	     (itlb_ifq_paddr_s[39:10]), // 2
		              .tlb_cam_hit	   (itlb_fcl_tlbmiss_f_l),    // 1
		              .cache_way_hit   (itlb_wsel_waysel_s1[4-1:0]), // 2
		              .cache_hit       (itlb_fcl_imiss_s_l),      // 2
		              .so		(short_scan0_1),

		                  // Inputs
                  
                  .tlb_wr_tte_csm_thrid   (tlu_idtlb_dmp_thrid_g[1:0]),
                  .tlb_wr_tte_csm         (tlu_itlb_tte_csm_w2),
                  .tlb_rd_csm_vld         (fcl_itlb_csm_rd_vld_bf),
                  .tlb_wr_csm_sel         (tlu_itlb_wr_csm_sel_g),

                  .cfg_csm_tlb_state      (cfg_ifu_csm_itlb_state),
                  .cfg_csm_tlb_chipid     (cfg_ifu_csm_itlb_chipid),
                  .cfg_csm_tlb_x          (cfg_ifu_csm_itlb_x),
                  .cfg_csm_tlb_y          (cfg_ifu_csm_itlb_y),
                  .cfg_csm_tlb_hdid       (cfg_ifu_csm_itlb_hdid),
                  .cfg_csm_tlb_hd_size    (cfg_ifu_csm_itlb_hd_size),
                  .cfg_csm_tlb_sdid       (cfg_ifu_csm_itlb_sdid),
                  .cfg_csm_tlb_lsid       (cfg_ifu_csm_itlb_lsid),

                  

                  .rclk          (rclk),
                  .rst_tri_en    (mem_write_disable),
		              .tlb_cam_vld	(fcl_itlb_cam_vld_bf),       // 0

//`ifdef SPARC_HPV_EN
                  .tlb_cam_key   ({fdp_icd_vaddr_bf[47:28],  // 0
                                   1'b1,
                                   fdp_icd_vaddr_bf[27:22],
                                   1'b1,
                                   fdp_icd_vaddr_bf[21:16],
                                   1'b1,
                                   fdp_icd_vaddr_bf[15:13],
                                   1'b1,
                                   fcl_itlb_cam_real_bf,  // g is the same as r
                                   fcl_itlb_cam_real_bf}),// this is the r bit

//`else // !`ifdef SPARC_HPV_EN
//                  .tlb_cam_key ({1'b0, // unused          // 0
//                                 fdp_icd_vaddr_bf[47:35],
//					                       1'b1, // v47_22
//					                       fdp_icd_vaddr_bf[34:22],
//					                       fdp_icd_vaddr_bf[21:20],
//					                       1'b1, // v21_19
//					                       fdp_icd_vaddr_bf[19],
//					                       fdp_icd_vaddr_bf[18:17],
//					                       1'b1, // v18_16
//					                       fdp_icd_vaddr_bf[16],
//					                       fdp_icd_vaddr_bf[15:14],
//					                       1'b1, // v15_13
//					                       fdp_icd_vaddr_bf[13], // global bit
//					                       1'b0}),  // all r's are zero
//
//                  .tlb_cam_real     (fcl_itlb_cam_real_bf),    // 0
//		              .tlb_demap_ctxt 	(tlu_itlb_dmp_by_ctxt_g),  // 0
//`endif

                  .tlb_cam_pid    (fcl_itlb_cam_pid_bf[2:0]),  // 0
		              .tlb_demap_key	(tlu_idtlb_dmp_key_g[40:0]), // 0

		              .tlb_addr_mask_l (fcl_itlb_addr_mask_l),      // 0
		              .tlb_ctxt		     (fdp_itlb_ctxt_bf[12:0]),    // 0

		              .tlb_wr_vld	    (fcl_itlb_wr_vld_bf),         // 0
		              .tlb_wr_tte_tag	(tlu_itlb_tte_tag_w2[58:0]),  // 1
		              .tlb_wr_tte_data(tlu_itlb_tte_data_w2[42:0]), // 1

		              .tlb_rd_tag_vld	 (fcl_itlb_tag_rd_vld_bf),    // 0
		              .tlb_rd_data_vld (fcl_itlb_data_rd_vld_bf),   // 0
		              .tlb_rw_index_vld(tlu_itlb_rw_index_vld_g),   // 0
		              .tlb_rw_index	   (tlu_itlb_rw_index_g[5:0]),  // 0

		              .tlb_demap	    (fcl_itlb_dmp_vld_bf),        // 0
		              .tlb_demap_all	(fcl_itlb_dmp_all_bf),        // 0
                  .tlb_demap_auto (tlu_itlb_dmp_actxt_g),

// trin: since the TLB is configured at fixed 30b per entry, this is the only way to do it
//    until TLB is also parameterized
                    .cache_ptag  (ict_itlb_tags_f),

		              .cache_set_vld	(icv_itlb_valid_f[3:0]),     // 1

		              .tlb_bypass	    (fcl_itlb_cam_bypass_bf),    // 0
		              .tlb_bypass_va	(fdp_icd_vaddr_bf[12:10]),   // 0

		              .si		(short_si0),
		              .se		(se),
                  .hold (sehold),
		              .adj		    (lsu_idtlb_mrgn[7:0]),
                 // tlb expects this to be asynchronous reset!
                  .arst_l     (arst_l),
		              .rst_soft_l (fcl_itlb_invall_f_l));  // 1


   sparc_ifu_wseldp wseldp(
                           .so          (scan0_6),
                           .si          (scan0_5),
                           .wsel_mbist_icache_data(wsel_mbist_icache_data[67:0]),
                           // .wsel_mbist_icache_data(),
                         /*AUTOINST*/
                           // Outputs
                           .wsel_fdp_fetdata_s1(wsel_fdp_fetdata_s1[33:0]),
                           .wsel_fdp_topdata_s1(wsel_fdp_topdata_s1[33:0]),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .icd_wsel_fetdata_s1(icd_wsel_fetdata_s1[135:0]),
                           .icd_wsel_topdata_s1(icd_wsel_topdata_s1[135:0]),
                           .itlb_wsel_waysel_s1(itlb_wsel_waysel_s1[4-1:0]),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[1:0]));


//   sparc_ifu_icd icd
   bw_r_icd icd(
                .so                     (scan0_8),
                .si                     (scan0_7),
			           .fdp_icd_index_bf  (fdp_icd_vaddr_bf[(6 + 5):2]),
                 .ifq_icd_index_bf  ({ifq_icd_index_bf[(6 + 5):2]}),
                 .bist_ic_data      (8'b0),
                 // .bist_ic_data      (mbist_icache_wdata[7:0]),
                 .rst_tri_en        (mem_write_disable),
                 .reset_l           (arst_l),
			           /*AUTOINST*/
                // Outputs
                .icd_wsel_fetdata_s1    (icd_wsel_fetdata_s1[135:0]),
                .icd_wsel_topdata_s1    (icd_wsel_topdata_s1[135:0]),
                .icd_fuse_repair_value  (icd_fuse_repair_value[7:0]),
                .icd_fuse_repair_en     (icd_fuse_repair_en[1:0]),
                // Inputs
                .rclk                   (rclk),
                .se                     (se),
                .sehold                 (sehold),
                .fcl_icd_index_sel_ifq_bf(fcl_icd_index_sel_ifq_bf),
                .ifq_icd_wrway_bf       (ifq_icd_wrway_bf[1:0]),
                .ifq_icd_worden_bf      (ifq_icd_worden_bf[3:0]),
                .ifq_icd_wrdata_i2      (ifq_icd_wrdata_i2[135:0]),
                .fcl_icd_rdreq_bf       (fcl_icd_rdreq_bf),
                .fcl_icd_wrreq_bf       (fcl_icd_wrreq_bf),
                .ifq_icd_data_sel_old_i2(ifq_icd_data_sel_old_i2),
                .ifq_icd_data_sel_fill_i2(ifq_icd_data_sel_fill_i2),
                .ifq_icd_data_sel_bist_i2(ifq_icd_data_sel_bist_i2),
                .fuse_icd_wren          (1'b0),
                .fuse_icd_rid           (4'b0),
                .fuse_icd_repair_value  (8'b0),
                .fuse_icd_repair_en     (2'b0),
                .efc_spc_fuse_clk1      (1'b0),
                // .efc_spc_fuse_clk1      (efc_spc_fuse_clk1),

                // interface to srams
                .sram_icache_w10_rtap_data (sram_icache_w10_rtap_data),
                .sram_icache_w32_rtap_data (sram_icache_w32_rtap_data),
                .rtap_srams_bist_command (rtap_srams_bist_command),
                .rtap_srams_bist_data (rtap_srams_bist_data)
                );

/*   bw_r_ict AUTO_TEMPLATE(
                     // Inputs
                     .adj          (lsu_ictag_mrgn[3:0]),
                     .reset_l      (arst_l),
		                 .index0_x     (fdp_icd_vaddr_bf[`IC_IDX_HI:5]),
                     .index1_x     (ifq_icd_index_bf[`IC_IDX_HI:5]),
                     .index_sel_x  (fcl_icd_index_sel_ifq_bf),
                     .dec_wrway_x  (ifq_ict_dec_wrway_bf[`IC_WAY_ARRAY_MASK]),
                     .wrtag_w0_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w1_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w2_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w3_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .rdreq_x      (fcl_icd_rdreq_bf),
                     .wrreq_x      (fcl_ict_wrreq_bf));
 */

   bw_r_ict ict(
                 .so                    (short_scan0_2),
                 .si                    (short_scan0_1),
                 .rdtag_y    (ict_itlb_tags_f),
                 .rst_tri_en        (mem_write_disable),

                     /*AUTOINST*/
                 // Inputs
                 .rclk                  (rclk),
                 .se                    (se),
                 .reset_l               (arst_l),                // Templated
                 .sehold                (sehold),
                 .index0_x              (fdp_icd_vaddr_bf[(6 + 5):5]), // Templated
                 .index1_x              (ifq_icd_index_bf[(6 + 5):5]), // Templated
                 .index_sel_x           (fcl_icd_index_sel_ifq_bf), // Templated
                 .dec_wrway_x           (ifq_ict_dec_wrway_bf[4-1:0]), // Templated
                 .rdreq_x               (fcl_icd_rdreq_bf),      // Templated
                 .wrreq_x               (fcl_ict_wrreq_bf),      // Templated
                 .wrtag_y            (ifq_ict_wrtag_f),// Templated
                 .wrtag_x            (ifq_ict_wrtag_bf),// Templated
                 .adj                   (lsu_ictag_mrgn[3:0]),

                 // debug interface
                 .sramid   (8'd9),
                 .srams_rtap_data   (sram_itag_rtap_data),
                 .rtap_srams_bist_command   (rtap_srams_bist_command),
                 .rtap_srams_bist_data   (rtap_srams_bist_data)
                 );
//     sparc_ifu_icv icv
/*   sram_l1i_val AUTO_TEMPLATE(
                    // Outputs
                    .dout          (icv_itlb_valid_f[3:0]),
                    .so            (short_so0),
                    // Inputs
                    .clk           (clk),
                    .se            (se),
                    .sehold        (sehold),
                    .si            (short_scan0_2),
                    .rst_tri_en        (mem_write_disable),
                    .reset_l       (arst_l),
		                .rd_adr2       (fdp_icv_index_bf[`IC_IDX_HI:5]),
                    .rd_adr1       (ifq_icv_wrindex_bf[`IC_IDX_HI:5]),
                    .wr_adr        (ifq_icv_wrindex_bf[`IC_IDX_HI:7]),
                    .rd_adr1_sel   (fcl_ifq_grant_bf),
                    .din           (ifq_icv_wrdata_bf),
                    .bit_wen       (ifq_icv_wren_bf[15:0]),
                    .rd_en         (fcl_icv_rdreq_bf),
                    .wr_en         (fcl_icv_wrreq_bf));
 */
   sram_l1i_val  icv(/*AUTOINST*/
                     // Outputs
                     .dout              (icv_itlb_valid_f[3:0]), // Templated
                     .so                (short_so0),             // Templated
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),                    // Templated
                     .si                (short_scan0_2),         // Templated
                     .reset_l           (arst_l),                // Templated
                     .sehold            (sehold),                // Templated
                     .rst_tri_en        (mem_write_disable),     // Templated
                     .rd_adr1           (ifq_icv_wrindex_bf[(6 + 5):5]), // Templated
                     .rd_adr2           (fdp_icv_index_bf[(6 + 5):5]), // Templated
                     .rd_adr1_sel       (fcl_ifq_grant_bf),      // Templated
                     .rd_en             (fcl_icv_rdreq_bf),      // Templated
                     .wr_adr            (ifq_icv_wrindex_bf[(6 + 5):7]), // Templated
                     .wr_en             (fcl_icv_wrreq_bf),      // Templated
                     .bit_wen           (ifq_icv_wren_bf[15:0]), // Templated
                     .din               (ifq_icv_wrdata_bf),

                     // debug interface
                     .sramid            (8'd11),
                     .rtap_srams_bist_command   (rtap_srams_bist_command),
                     .rtap_srams_bist_data      (rtap_srams_bist_data),
                     .srams_rtap_data           (icv_rtap_data)
                     );     // Templated
   sparc_ifu_ifqdp ifqdp(
                         .so            (short_so1),
                         .si            (short_scan1_1),
                        .ifq_ict_wrtag_f(ifq_ict_wrtag_f[(39 - (6 + 5)):0]),
                        .ifq_ict_wrtag_bf(ifq_ict_wrtag_bf[(39 - (6 + 5)):0]),
                         .fdp_ifq_paddr_f(fdp_erb_pc_f[9:2]),
                         /*AUTOINST*/
                         // Outputs
                         
                         .ifu_lsu_pcxcsm_e(ifu_lsu_pcxcsm_e),
                         

                         .ifu_lsu_pcxpkt_e(ifu_lsu_pcxpkt_e[51:0]),
                         .ifq_fdp_fill_inst(ifq_fdp_fill_inst[32:0]),
                         .ifq_erb_asidata_i2(ifq_erb_asidata_i2[47:0]),
                         .ifd_inv_ifqop_i2(ifd_inv_ifqop_i2[145-1:0]),
                         .ifq_icd_index_bf(ifq_icd_index_bf[(6 + 5):2]),
                         .ifq_icd_wrdata_i2(ifq_icd_wrdata_i2[135:0]),
                         .ifq_erb_wrindex_f(ifq_erb_wrindex_f[(6 + 5):4]),
                         .ifq_icd_wrway_bf(ifq_icd_wrway_bf[1:0]),
                         .ifd_ifc_milhit_s(ifd_ifc_milhit_s[3:0]),
                         .ifd_ifc_instoffset0(ifd_ifc_instoffset0[1:0]),
                         .ifd_ifc_instoffset1(ifd_ifc_instoffset1[1:0]),
                         .ifd_ifc_instoffset2(ifd_ifc_instoffset2[1:0]),
                         .ifd_ifc_instoffset3(ifd_ifc_instoffset3[1:0]),
                         .ifd_ifc_cpxthr_nxt(ifd_ifc_cpxthr_nxt[1:0]),
                         .ifd_ifc_cpxreq_nxt(ifd_ifc_cpxreq_nxt[3:0]),
                         .ifd_ifc_cpxreq_i1(ifd_ifc_cpxreq_i1[(143 - 140 + 1):0]),
                         .ifd_ifc_destid0(ifd_ifc_destid0[2:0]),
                         .ifd_ifc_destid1(ifd_ifc_destid1[2:0]),
                         .ifd_ifc_destid2(ifd_ifc_destid2[2:0]),
                         .ifd_ifc_destid3(ifd_ifc_destid3[2:0]),
                         .ifd_ifc_newdestid_s(ifd_ifc_newdestid_s[2:0]),
                         .ifd_ifc_pcxline_d(ifd_ifc_pcxline_d[4:2]),
                         .ifd_ifc_asi_vachklo_i2(ifd_ifc_asi_vachklo_i2),
                         .ifd_ifc_cpxvld_i2(ifd_ifc_cpxvld_i2),
                         .ifd_ifc_asiaddr_i2(ifd_ifc_asiaddr_i2[3:2]),
                         .ifd_ifc_iobpkt_i2(ifd_ifc_iobpkt_i2),
                         .ifd_ifc_fwd2ic_i2(ifd_ifc_fwd2ic_i2),
                         .ifd_ifc_4bpkt_i2(ifd_ifc_4bpkt_i2),
                         .ifd_ifc_cpxnc_i2(ifd_ifc_cpxnc_i2),
                         .ifd_ifc_cpxce_i2(ifd_ifc_cpxce_i2),
                         .ifd_ifc_cpxue_i2(ifd_ifc_cpxue_i2),
                         .ifd_ifc_cpxms_i2(ifd_ifc_cpxms_i2),
                         .ifd_ifc_miladdr4_i2(ifd_ifc_miladdr4_i2[3:0]),
                         .ifd_inv_wrway_i2(ifd_inv_wrway_i2[1:0]),
                         .ifq_fdp_fill_paddr(ifq_fdp_fill_paddr[39:2]),
                         // Inputs
                         
                         .itlb_ifq_csm_s (itlb_ifq_csm_s),
                         
                         .rclk          (rclk),
                         .se            (se),
                         .lsu_ifu_cpxpkt_i1(lsu_ifu_cpxpkt_i1[145-1:0]),
                         .lsu_ifu_asi_addr(lsu_ifu_asi_addr[17:0]),
                         .lsu_ifu_stxa_data(lsu_ifu_stxa_data[47:0]),
                         .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
                         .ifc_ifd_reqvalid_e(ifc_ifd_reqvalid_e),
                         .ifc_ifd_filladdr4_i2(ifc_ifd_filladdr4_i2),
                         .ifc_ifd_repway_s(ifc_ifd_repway_s[1:0]),
                         .ifc_ifd_uncached_e(ifc_ifd_uncached_e),
                         .ifc_ifd_thrid_e(ifc_ifd_thrid_e[1:0]),
                         .ifc_ifd_pcxline_adj_d(ifc_ifd_pcxline_adj_d[4:2]),
                         .ifc_ifd_errinv_e(ifc_ifd_errinv_e),
                         .ifc_ifd_ldmil_sel_new(ifc_ifd_ldmil_sel_new[3:0]),
                         .ifc_ifd_ld_inq_i1(ifc_ifd_ld_inq_i1),
                         .ifc_ifd_idx_sel_fwd_i2(ifc_ifd_idx_sel_fwd_i2),
                         .ifc_ifd_milreq_sel_d_l(ifc_ifd_milreq_sel_d_l[3:0]),
                         .ifc_ifd_milfill_sel_i2_l(ifc_ifd_milfill_sel_i2_l[3:0]),
                         .ifc_ifd_finst_sel_l(ifc_ifd_finst_sel_l[3:0]),
                         .ifc_ifd_ifqbyp_sel_fwd_l(ifc_ifd_ifqbyp_sel_fwd_l),
                         .ifc_ifd_ifqbyp_sel_inq_l(ifc_ifd_ifqbyp_sel_inq_l),
                         .ifc_ifd_ifqbyp_sel_asi_l(ifc_ifd_ifqbyp_sel_asi_l),
                         .ifc_ifd_ifqbyp_sel_lsu_l(ifc_ifd_ifqbyp_sel_lsu_l),
                         .ifc_ifd_ifqbyp_en_l(ifc_ifd_ifqbyp_en_l),
                         .ifc_ifd_addr_sel_bist_i2_l(ifc_ifd_addr_sel_bist_i2_l),
                         .ifc_ifd_addr_sel_asi_i2_l(ifc_ifd_addr_sel_asi_i2_l),
                         .ifc_ifd_addr_sel_old_i2_l(ifc_ifd_addr_sel_old_i2_l),
                         .ifc_ifd_addr_sel_fill_i2_l(ifc_ifd_addr_sel_fill_i2_l),
                         .mbist_icache_way(2'b0),
                         .mbist_icache_word(1'b0),
                         .mbist_icache_index(8'b0)
                         );

   sparc_ifu_ifqctl ifqctl(
                           .so          (scan0_9),
                           .si          (scan0_8),
                           .ifd_ifc_cpxvalid_i1(lsu_ifu_cpxpkt_i1[144]),
			   .lsu_ifu_cpxpkt_wayvld_i1 (lsu_ifu_cpxpkt_i1[133]),
                           .ifq_sscan_data(ifq_sscan_data[3:0]),
                           .rst_tri_en  (mux_drive_disable),

                           /*AUTOINST*/
                           // Outputs
                           .ifu_lsu_inv_clear(ifu_lsu_inv_clear),
                           .ifu_lsu_ibuf_busy(ifu_lsu_ibuf_busy),
                           .ifu_lsu_asi_ack(ifu_lsu_asi_ack),
                           .ifu_lsu_ldxa_illgl_va_w2(ifu_lsu_ldxa_illgl_va_w2),
                           .ifu_lsu_fwd_wr_ack(ifu_lsu_fwd_wr_ack),
                           .ifu_lsu_pcxreq_d(ifu_lsu_pcxreq_d),
                           .ifu_lsu_destid_s(ifu_lsu_destid_s[2:0]),
                           .ifu_tlu_l2imiss(ifu_tlu_l2imiss[3:0]),
                           .ifq_fcl_stallreq(ifq_fcl_stallreq),
                           .ifq_swl_stallreq(ifq_swl_stallreq),
                           .ifq_fcl_flush_sonly_e(ifq_fcl_flush_sonly_e),
                           .ifq_fcl_wrreq_bf(ifq_fcl_wrreq_bf),
                           .ifq_fcl_rdreq_bf(ifq_fcl_rdreq_bf),
                           .ifq_fcl_icd_wrreq_bf(ifq_fcl_icd_wrreq_bf),
                           .ifq_fcl_ictv_wrreq_bf(ifq_fcl_ictv_wrreq_bf),
                           .ifq_erb_fwdrd_bf(ifq_erb_fwdrd_bf),
                           .ifq_erb_rdtag_f(ifq_erb_rdtag_f),
                           .ifq_erb_rdinst_f(ifq_erb_rdinst_f),
                           .ifq_erb_asi_erren_i2(ifq_erb_asi_erren_i2),
                           .ifq_erb_asi_errstat_i2(ifq_erb_asi_errstat_i2),
                           .ifq_erb_asi_errinj_i2(ifq_erb_asi_errinj_i2),
                           .ifq_erb_asi_erraddr_i2(ifq_erb_asi_erraddr_i2),
                           .ifq_erb_asi_imask_i2(ifq_erb_asi_imask_i2),
                           .ifq_erb_asiwr_i2(ifq_erb_asiwr_i2),
                           .ifq_fcl_asird_bf(ifq_fcl_asird_bf),
                           .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                           .ifq_erb_ue_rep(ifq_erb_ue_rep),
                           .ifq_erb_ce_rep(ifq_erb_ce_rep),
                           .ifq_erb_l2_ue(ifq_erb_l2_ue),
                           .ifq_erb_io_ue(ifq_erb_io_ue),
                           .ifq_erb_ifet_ce(ifq_erb_ifet_ce),
                           .ifq_erb_l2err_tid(ifq_erb_l2err_tid[1:0]),
                           .ifq_icv_wrdata_bf(ifq_icv_wrdata_bf),
                           .ifq_icd_worden_bf(ifq_icd_worden_bf[3:0]),
                           .ifq_fcl_fill_thr(ifq_fcl_fill_thr[3:0]),
                           .ifq_dtu_thrrdy(ifq_dtu_thrrdy[3:0]),
                           .ifq_dtu_pred_rdy(ifq_dtu_pred_rdy[3:0]),
                           .ifc_ifd_filladdr4_i2(ifc_ifd_filladdr4_i2),
                           .ifc_ifd_reqvalid_e(ifc_ifd_reqvalid_e),
                           .ifc_ifd_idx_sel_fwd_i2(ifc_ifd_idx_sel_fwd_i2),
                           .ifc_ifd_errinv_e(ifc_ifd_errinv_e),
                           .ifc_ifd_uncached_e(ifc_ifd_uncached_e),
                           .ifc_ifd_thrid_e(ifc_ifd_thrid_e[1:0]),
                           .ifc_ifd_pcxline_adj_d(ifc_ifd_pcxline_adj_d[4:2]),
                           .ifc_inv_asireq_i2(ifc_inv_asireq_i2),
                           .ifc_ifd_repway_s(ifc_ifd_repway_s[1:0]),
                           .ifc_ifd_milfill_sel_i2_l(ifc_ifd_milfill_sel_i2_l[3:0]),
                           .ifc_ifd_finst_sel_l(ifc_ifd_finst_sel_l[3:0]),
                           .ifc_ifd_milreq_sel_d_l(ifc_ifd_milreq_sel_d_l[3:0]),
                           .ifc_ifd_ifqbyp_sel_fwd_l(ifc_ifd_ifqbyp_sel_fwd_l),
                           .ifc_ifd_ifqbyp_sel_inq_l(ifc_ifd_ifqbyp_sel_inq_l),
                           .ifc_ifd_ifqbyp_sel_asi_l(ifc_ifd_ifqbyp_sel_asi_l),
                           .ifc_ifd_ifqbyp_sel_lsu_l(ifc_ifd_ifqbyp_sel_lsu_l),
                           .ifc_ifd_ifqbyp_en_l(ifc_ifd_ifqbyp_en_l),
                           .ifc_ifd_addr_sel_bist_i2_l(ifc_ifd_addr_sel_bist_i2_l),
                           .ifc_ifd_addr_sel_asi_i2_l(ifc_ifd_addr_sel_asi_i2_l),
                           .ifc_ifd_addr_sel_old_i2_l(ifc_ifd_addr_sel_old_i2_l),
                           .ifc_ifd_addr_sel_fill_i2_l(ifc_ifd_addr_sel_fill_i2_l),
                           .ifq_icd_data_sel_bist_i2(ifq_icd_data_sel_bist_i2),
                           .ifq_icd_data_sel_fill_i2(ifq_icd_data_sel_fill_i2),
                           .ifq_icd_data_sel_old_i2(ifq_icd_data_sel_old_i2),
                           .ifc_ifd_ldmil_sel_new(ifc_ifd_ldmil_sel_new[3:0]),
                           .ifc_ifd_ld_inq_i1(ifc_ifd_ld_inq_i1),
                           .ifc_inv_ifqadv_i2(ifc_inv_ifqadv_i2),
                           // Inputs
                           .ifd_ifc_milhit_s(ifd_ifc_milhit_s[3:0]),
                           .ifd_ifc_instoffset0(ifd_ifc_instoffset0[1:0]),
                           .ifd_ifc_instoffset1(ifd_ifc_instoffset1[1:0]),
                           .ifd_ifc_instoffset2(ifd_ifc_instoffset2[1:0]),
                           .ifd_ifc_instoffset3(ifd_ifc_instoffset3[1:0]),
                           .ifd_ifc_cpxreq_i1(ifd_ifc_cpxreq_i1[(143 - 140 + 1):0]),
                           .ifd_ifc_cpxreq_nxt(ifd_ifc_cpxreq_nxt[3:0]),
                           .ifd_ifc_cpxthr_nxt(ifd_ifc_cpxthr_nxt[1:0]),
                           .ifd_ifc_cpxvld_i2(ifd_ifc_cpxvld_i2),
                           .ifd_ifc_iobpkt_i2(ifd_ifc_iobpkt_i2),
                           .ifd_ifc_4bpkt_i2(ifd_ifc_4bpkt_i2),
                           .ifd_ifc_cpxnc_i2(ifd_ifc_cpxnc_i2),
                           .ifd_ifc_fwd2ic_i2(ifd_ifc_fwd2ic_i2),
                           .ifd_ifc_cpxce_i2(ifd_ifc_cpxce_i2),
                           .ifd_ifc_cpxue_i2(ifd_ifc_cpxue_i2),
                           .ifd_ifc_cpxms_i2(ifd_ifc_cpxms_i2),
                           .ifd_ifc_miladdr4_i2(ifd_ifc_miladdr4_i2[3:0]),
                           .ifd_ifc_asiaddr_i2(ifd_ifc_asiaddr_i2[3:2]),
                           .ifd_ifc_asi_vachklo_i2(ifd_ifc_asi_vachklo_i2),
                           .ifd_ifc_destid0(ifd_ifc_destid0[2:0]),
                           .ifd_ifc_destid1(ifd_ifc_destid1[2:0]),
                           .ifd_ifc_destid2(ifd_ifc_destid2[2:0]),
                           .ifd_ifc_destid3(ifd_ifc_destid3[2:0]),
                           .ifd_ifc_newdestid_s(ifd_ifc_newdestid_s[2:0]),
                           .ifd_ifc_pcxline_d(ifd_ifc_pcxline_d[4:2]),
                           .inv_ifc_inv_pending(inv_ifc_inv_pending),
                           .fcl_ifq_icmiss_s1(fcl_ifq_icmiss_s1),
                           .fcl_ifq_rdreq_s1(fcl_ifq_rdreq_s1),
                           .fcl_ifq_thr_s1(fcl_ifq_thr_s1[1:0]),
                           .fcl_ifq_canthr(fcl_ifq_canthr[3:0]),
                           .fcl_ifq_grant_bf(fcl_ifq_grant_bf),
                           .dtu_ifq_kill_latest_d(dtu_ifq_kill_latest_d),
                           .erb_ifq_ifeterr_d1(erb_ifq_ifeterr_d1),
                           .erb_ifq_itlberr_s1(erb_ifq_itlberr_s1),
                           .lsu_ifu_pcxpkt_ack_d(lsu_ifu_pcxpkt_ack_d),
                           .lsu_ifu_direct_map_l1(lsu_ifu_direct_map_l1),
                           .lsu_ifu_asi_vld(lsu_ifu_asi_vld),
                           .lsu_ifu_asi_state(lsu_ifu_asi_state[7:0]),
                           .lsu_ifu_asi_load(lsu_ifu_asi_load),
                           .lsu_ifu_asi_thrid(lsu_ifu_asi_thrid[1:0]),
                           .fcl_ifq_icache_en_s_l(fcl_ifq_icache_en_s_l),
                           .mbist_ifq_run_bist(1'b0),
                           .mbist_icache_write(1'b0),
                           .mbist_icache_read(1'b0),
                           .ctu_sscan_tid(ctu_sscan_tid[3:0]),
                           .rclk        (rclk),
                           .se          (se),
                           .gdbginit_l  (gdbginit_l),
                           .arst_l      (arst_l),
                           .grst_l      (grst_l),
                           .sehold      (sehold));

   sparc_ifu_invctl invctl(
                           .so          (scan0_10),
                           .si          (scan0_9),
                           /*AUTOINST*/
                           // Outputs
                           .inv_ifc_inv_pending(inv_ifc_inv_pending),
                           .ifq_icv_wrindex_bf(ifq_icv_wrindex_bf[(6 + 5):5]),
                           .ifq_icv_wren_bf(ifq_icv_wren_bf[15:0]),
                           .ifq_ict_dec_wrway_bf(ifq_ict_dec_wrway_bf[4-1:0]),
                           .ifq_fcl_invreq_bf(ifq_fcl_invreq_bf),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[1:0]),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .const_cpuid (const_cpuid[2:0]),
                           .mbist_icache_write(1'b0),
                           // .mbist_icache_write(mbist_icache_write),
                           .lsu_ifu_ld_icache_index(lsu_ifu_ld_icache_index[(6 + 5):5]),
                           .lsu_ifu_ld_pcxpkt_vld(lsu_ifu_ld_pcxpkt_vld),
                           .lsu_ifu_ld_pcxpkt_tid(lsu_ifu_ld_pcxpkt_tid[1:0]),
                           .ifc_inv_ifqadv_i2(ifc_inv_ifqadv_i2),
                           .ifc_inv_asireq_i2(ifc_inv_asireq_i2),
                           .ifq_icd_index_bf(ifq_icd_index_bf[(6 + 5):5]),
                           .ifd_inv_ifqop_i2(ifd_inv_ifqop_i2[145-1:0]),
                           .ifd_inv_wrway_i2(ifd_inv_wrway_i2[1:0]));


   sparc_ifu_errdp  errdp(
                          .so           (scan0_11),
                          .si           (scan0_10),
                         .ifq_erb_wrtag_f(ifq_ict_wrtag_f[(39 - (6 + 5))-1:0]),
                          .ict_itlb_tags_f(ict_itlb_tags_f),
                          .wsel_erb_asidata_s({wsel_mbist_icache_data[65:64],
                                               wsel_mbist_icache_data[31:0]}),
                          // .wsel_erb_asidata_s(34'b0),

			                    /*AUTOINST*/
                          // Outputs
                          .ifu_lsu_ldxa_data_w2(ifu_lsu_ldxa_data_w2[63:0]),
                          .erb_dtu_imask(erb_dtu_imask[38:0]),
                          .erd_erc_tlbt_pe_s1(erd_erc_tlbt_pe_s1[1:0]),
                          .erd_erc_tlbd_pe_s1(erd_erc_tlbd_pe_s1[1:0]),
                          .erd_erc_tagpe_s1(erd_erc_tagpe_s1[3:0]),
                          .erd_erc_nirpe_s1(erd_erc_nirpe_s1),
                          .erd_erc_fetpe_s1(erd_erc_fetpe_s1),
                          .erd_erc_tte_pgsz(erd_erc_tte_pgsz[2:0]),
                          // Inputs
                          .rclk         (rclk),
                          .se           (se),
                          .erb_reset    (erb_reset),
                          .itlb_rd_tte_data(itlb_rd_tte_data[42:0]),
                          .itlb_rd_tte_tag(itlb_rd_tte_tag[58:0]),
                          .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
                          .wsel_fdp_fetdata_s1(wsel_fdp_fetdata_s1[33:0]),
                          .wsel_fdp_topdata_s1(wsel_fdp_topdata_s1[33:0]),
                          .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
                          .lsu_ifu_err_addr(lsu_ifu_err_addr[47:4]),
                          .spu_ifu_err_addr_w2(spu_ifu_err_addr_w2[39:4]),
                          .fdp_erb_pc_f (fdp_erb_pc_f[47:0]),
                          .exu_ifu_err_reg_m(exu_ifu_err_reg_m[7:0]),
                          .exu_ifu_err_synd_m(exu_ifu_err_synd_m[7:0]),
                          .ffu_ifu_err_reg_w2(ffu_ifu_err_reg_w2[5:0]),
                          .ffu_ifu_err_synd_w2(ffu_ifu_err_synd_w2[13:0]),
                          .tlu_itlb_rw_index_g(tlu_itlb_rw_index_g[5:0]),
                          .erc_erd_pgsz_b0(erc_erd_pgsz_b0),
                          .erc_erd_pgsz_b1(erc_erd_pgsz_b1),
                          .erc_erd_erren_asidata(erc_erd_erren_asidata[1:0]),
                          .erc_erd_errstat_asidata(erc_erd_errstat_asidata[22:0]),
                          .erc_erd_errinj_asidata(erc_erd_errinj_asidata[31:0]),
                          .ifq_erb_asidata_i2(ifq_erb_asidata_i2[47:0]),
                          .ifq_erb_wrindex_f(ifq_erb_wrindex_f[(6 + 5):4]),
                          .erc_erd_asiway_s1_l(erc_erd_asiway_s1_l[4-1:0]),
                          .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                          .erc_erd_ld_imask(erc_erd_ld_imask),
                          .erc_erd_asisrc_sel_icd_s_l(erc_erd_asisrc_sel_icd_s_l),
                          .erc_erd_asisrc_sel_misc_s_l(erc_erd_asisrc_sel_misc_s_l),
                          .erc_erd_asisrc_sel_err_s_l(erc_erd_asisrc_sel_err_s_l),
                          .erc_erd_asisrc_sel_itlb_s_l(erc_erd_asisrc_sel_itlb_s_l),
                          .erc_erd_errasi_sel_en_l(erc_erd_errasi_sel_en_l),
                          .erc_erd_errasi_sel_stat_l(erc_erd_errasi_sel_stat_l),
                          .erc_erd_errasi_sel_inj_l(erc_erd_errasi_sel_inj_l),
                          .erc_erd_errasi_sel_addr_l(erc_erd_errasi_sel_addr_l),
                          .erc_erd_miscasi_sel_ict_l(erc_erd_miscasi_sel_ict_l),
                          .erc_erd_miscasi_sel_imask_l(erc_erd_miscasi_sel_imask_l),
                          .erc_erd_miscasi_sel_other_l(erc_erd_miscasi_sel_other_l),
                          .erc_erd_asi_thr_l(erc_erd_asi_thr_l[3:0]),
                          .erc_erd_eadr0_sel_irf_l(erc_erd_eadr0_sel_irf_l[3:0]),
                          .erc_erd_eadr0_sel_itlb_l(erc_erd_eadr0_sel_itlb_l[3:0]),
                          .erc_erd_eadr0_sel_frf_l(erc_erd_eadr0_sel_frf_l[3:0]),
                          .erc_erd_eadr0_sel_lsu_l(erc_erd_eadr0_sel_lsu_l[3:0]),
                          .erc_erd_eadr1_sel_pcd1_l(erc_erd_eadr1_sel_pcd1_l[3:0]),
                          .erc_erd_eadr1_sel_l1pa_l(erc_erd_eadr1_sel_l1pa_l[3:0]),
                          .erc_erd_eadr1_sel_l2pa_l(erc_erd_eadr1_sel_l2pa_l[3:0]),
                          .erc_erd_eadr1_sel_other_l(erc_erd_eadr1_sel_other_l[3:0]),
                          .erc_erd_eadr2_sel_mx1_l(erc_erd_eadr2_sel_mx1_l[3:0]),
                          .erc_erd_eadr2_sel_wrt_l(erc_erd_eadr2_sel_wrt_l[3:0]),
                          .erc_erd_eadr2_sel_mx0_l(erc_erd_eadr2_sel_mx0_l[3:0]),
                          .erc_erd_eadr2_sel_old_l(erc_erd_eadr2_sel_old_l[3:0]));

   sparc_ifu_errctl errctl(
                           .so          (scan0_12),
                           .si          (scan0_11),
                          .ifu_tlu_inst_vld_w(ifu_spu_inst_vld_w),

                           /*AUTOINST*/
                           // Outputs
                           .erc_erd_pgsz_b0(erc_erd_pgsz_b0),
                           .erc_erd_pgsz_b1(erc_erd_pgsz_b1),
                           .ifu_lsu_asi_rd_unc(ifu_lsu_asi_rd_unc),
                           .ifu_lsu_ldxa_tid_w2(ifu_lsu_ldxa_tid_w2[1:0]),
                           .ifu_lsu_ldxa_data_vld_w2(ifu_lsu_ldxa_data_vld_w2),
                           .ifu_lsu_fwd_data_vld(ifu_lsu_fwd_data_vld),
                           .ifu_lsu_error_inj(ifu_lsu_error_inj[3:0]),
                           .ifu_exu_ecc_mask(ifu_exu_ecc_mask[7:0]),
                           .ifu_exu_inj_irferr(ifu_exu_inj_irferr),
                           .ifu_ffu_inj_frferr(ifu_ffu_inj_frferr),
                           .ifu_exu_nceen_e(ifu_exu_nceen_e),
                           .ifu_lsu_nceen(ifu_lsu_nceen[3:0]),
                           .ifu_spu_nceen(ifu_spu_nceen[3:0]),
                           .erb_fcl_spu_uetrap(erb_fcl_spu_uetrap[3:0]),
                           .erb_ifq_itlberr_s1(erb_ifq_itlberr_s1),
                           .erb_ifq_ifeterr_d1(erb_ifq_ifeterr_d1),
                           .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                           .erb_fcl_itlb_ce_d1(erb_fcl_itlb_ce_d1),
                           .erb_fcl_ce_trapvec(erb_fcl_ce_trapvec[3:0]),
                           .erb_fcl_ue_trapvec(erb_fcl_ue_trapvec[3:0]),
                           .erb_fcl_ifet_uevec_d1(erb_fcl_ifet_uevec_d1[3:0]),
                           .erc_erd_errstat_asidata(erc_erd_errstat_asidata[22:0]),
                           .erc_erd_errinj_asidata(erc_erd_errinj_asidata[31:0]),
                           .erc_erd_erren_asidata(erc_erd_erren_asidata[1:0]),
                           .erc_erd_eadr0_sel_irf_l(erc_erd_eadr0_sel_irf_l[3:0]),
                           .erc_erd_eadr0_sel_itlb_l(erc_erd_eadr0_sel_itlb_l[3:0]),
                           .erc_erd_eadr0_sel_frf_l(erc_erd_eadr0_sel_frf_l[3:0]),
                           .erc_erd_eadr0_sel_lsu_l(erc_erd_eadr0_sel_lsu_l[3:0]),
                           .erc_erd_asiway_s1_l(erc_erd_asiway_s1_l[4-1:0]),
                           .erc_erd_eadr1_sel_pcd1_l(erc_erd_eadr1_sel_pcd1_l[3:0]),
                           .erc_erd_eadr1_sel_l1pa_l(erc_erd_eadr1_sel_l1pa_l[3:0]),
                           .erc_erd_eadr1_sel_l2pa_l(erc_erd_eadr1_sel_l2pa_l[3:0]),
                           .erc_erd_eadr1_sel_other_l(erc_erd_eadr1_sel_other_l[3:0]),
                           .erc_erd_eadr2_sel_mx1_l(erc_erd_eadr2_sel_mx1_l[3:0]),
                           .erc_erd_eadr2_sel_wrt_l(erc_erd_eadr2_sel_wrt_l[3:0]),
                           .erc_erd_eadr2_sel_mx0_l(erc_erd_eadr2_sel_mx0_l[3:0]),
                           .erc_erd_eadr2_sel_old_l(erc_erd_eadr2_sel_old_l[3:0]),
                           .erc_erd_asi_thr_l(erc_erd_asi_thr_l[3:0]),
                           .erc_erd_asisrc_sel_icd_s_l(erc_erd_asisrc_sel_icd_s_l),
                           .erc_erd_asisrc_sel_misc_s_l(erc_erd_asisrc_sel_misc_s_l),
                           .erc_erd_asisrc_sel_err_s_l(erc_erd_asisrc_sel_err_s_l),
                           .erc_erd_asisrc_sel_itlb_s_l(erc_erd_asisrc_sel_itlb_s_l),
                           .erc_erd_errasi_sel_en_l(erc_erd_errasi_sel_en_l),
                           .erc_erd_errasi_sel_stat_l(erc_erd_errasi_sel_stat_l),
                           .erc_erd_errasi_sel_inj_l(erc_erd_errasi_sel_inj_l),
                           .erc_erd_errasi_sel_addr_l(erc_erd_errasi_sel_addr_l),
                           .erc_erd_miscasi_sel_ict_l(erc_erd_miscasi_sel_ict_l),
                           .erc_erd_miscasi_sel_imask_l(erc_erd_miscasi_sel_imask_l),
                           .erc_erd_miscasi_sel_other_l(erc_erd_miscasi_sel_other_l),
                           .erc_erd_ld_imask(erc_erd_ld_imask),
                           .erb_reset   (erb_reset),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .arst_l      (arst_l),
                           .grst_l      (grst_l),
                           .erd_erc_tte_pgsz(erd_erc_tte_pgsz[2:0]),
                           .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
                           .fcl_erb_ievld_s1(fcl_erb_ievld_s1),
                           .fcl_erb_tevld_s1(fcl_erb_tevld_s1),
                           .fcl_erb_immuevld_s1(fcl_erb_immuevld_s1),
                           .fcl_erb_inst_issue_d(fcl_erb_inst_issue_d),
                           .fcl_erb_inst_vld_d1(fcl_erb_inst_vld_d1),
                           .ifu_lsu_thrid_s(ifu_lsu_thrid_s[1:0]),
                           .fcl_erb_asi_tid_f(fcl_erb_asi_tid_f[1:0]),
                           .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                           .fcl_erb_clear_iferr(fcl_erb_clear_iferr[3:0]),
                           .fcl_erb_itlbrd_vld_s(fcl_erb_itlbrd_vld_s),
                           .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                           .erd_erc_tagpe_s1(erd_erc_tagpe_s1[3:0]),
                           .erd_erc_nirpe_s1(erd_erc_nirpe_s1),
                           .erd_erc_fetpe_s1(erd_erc_fetpe_s1),
                           .erd_erc_tlbt_pe_s1(erd_erc_tlbt_pe_s1[1:0]),
                           .erd_erc_tlbd_pe_s1(erd_erc_tlbd_pe_s1[1:0]),
                           .tlu_lsu_pstate_priv(tlu_lsu_pstate_priv[3:0]),
			   .tlu_hpstate_priv  (tlu_hpstate_priv[3:0]),
                           .lsu_ifu_dtlb_data_su(lsu_ifu_dtlb_data_su),
                           .lsu_ifu_dtlb_data_ue(lsu_ifu_dtlb_data_ue),
                           .lsu_ifu_dtlb_tag_ue(lsu_ifu_dtlb_tag_ue),
                           .lsu_ifu_dcache_data_perror(lsu_ifu_dcache_data_perror),
                           .lsu_ifu_dcache_tag_perror(lsu_ifu_dcache_tag_perror),
                           .lsu_ifu_l2_unc_error(lsu_ifu_l2_unc_error),
                           .lsu_ifu_l2_corr_error(lsu_ifu_l2_corr_error),
                           .lsu_ifu_io_error(lsu_ifu_io_error),
                           .lsu_ifu_error_tid(lsu_ifu_error_tid[1:0]),
                           .spu_ifu_unc_err_w1(spu_ifu_unc_err_w1),
                           .spu_ifu_mamem_err_w1(spu_ifu_mamem_err_w1),
                           .spu_ifu_corr_err_w2(spu_ifu_corr_err_w2),
                           .spu_ifu_int_w2(spu_ifu_int_w2),
                           .spu_ifu_ttype_tid_w2(spu_ifu_ttype_tid_w2[1:0]),
                           .lsu_ifu_inj_ack(lsu_ifu_inj_ack[3:0]),
                           .ffu_ifu_ecc_ce_w2(ffu_ifu_ecc_ce_w2),
                           .ffu_ifu_ecc_ue_w2(ffu_ifu_ecc_ue_w2),
                           .ffu_ifu_inj_ack(ffu_ifu_inj_ack),
                           .ffu_ifu_tid_w2(ffu_ifu_tid_w2[1:0]),
                           .exu_ifu_ecc_ce_m(exu_ifu_ecc_ce_m),
                           .exu_ifu_ecc_ue_m(exu_ifu_ecc_ue_m),
                           .exu_ifu_inj_ack(exu_ifu_inj_ack),
                           .ifq_erb_ue_rep(ifq_erb_ue_rep),
                           .ifq_erb_ce_rep(ifq_erb_ce_rep),
                           .ifq_erb_l2_ue(ifq_erb_l2_ue),
                           .ifq_erb_io_ue(ifq_erb_io_ue),
                           .ifq_erb_ifet_ce(ifq_erb_ifet_ce),
                           .ifq_erb_l2err_tid(ifq_erb_l2err_tid[1:0]),
                           .ifq_erb_rdtag_f(ifq_erb_rdtag_f),
                           .ifq_erb_rdinst_f(ifq_erb_rdinst_f),
                           .ifq_erb_asi_erren_i2(ifq_erb_asi_erren_i2),
                           .ifq_erb_asi_errstat_i2(ifq_erb_asi_errstat_i2),
                           .ifq_erb_asi_errinj_i2(ifq_erb_asi_errinj_i2),
                           .ifq_erb_asi_erraddr_i2(ifq_erb_asi_erraddr_i2),
                           .ifq_erb_asi_imask_i2(ifq_erb_asi_imask_i2),
                           .ifq_erb_asiwr_i2(ifq_erb_asiwr_i2),
                           .ifq_fcl_asird_bf(ifq_fcl_asird_bf),
                           .ifq_erb_fwdrd_bf(ifq_erb_fwdrd_bf),
                           .ifq_erb_asidata_i2(ifq_erb_asidata_i2[31:0]),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[1:0]));

   // BIST Controller
//   sparc_ifu_icd_arr_bist bist(// Outputs
//			       .Test_fdp_icd_index_bf_0 (bist_ic_index[8:0]),
//			       .Test_ifq_icd_wrway_bf_0 (bist_ic_way),
//			       .Test_ifq_icd_wrdata_f_0 ({null_data[135:2],
//							  bist_ic_data[1:0]}),
//			       .Test_fcl_icd_rdreq_bf_0 (bist_ic_read),
//			       .Test_fcl_icd_wrreq_bf_0 (bist_ic_write),
//			       .Test_ifq_icd_worden_bf_0 (bist_ic_worden),
//			       .tselect (),
//			       .tst_done (),
//			       .fail_h (),
//			       .scan_out (),
//			       // Inputs
//			       .clk (clk),
//			       .diag_clk(1'b0),
//			       .rst_l (rst_l),
//			       .test_h (1'b0),
//			       .debugz (1'b0),
//			       .hold_l (1'b1),
//			       .Test_icd_fdp_topdata_s1_0 (icd_fdp_topdata_s1),
//			       .Test_icd_fdp_fetdata_s1_0 (icd_fdp_fetdata_s1));

   // sparc_ifu_mbist mbist(
   //                       .mbist_icache_data_in(wsel_mbist_icache_data[67:0]),
   //                       .mbist_si      (scan0_12),
   //                       .mbist_se      (se),

   //                       .mbist_icache_wdata(mbist_icache_wdata[7:0]),
   //                       .mbist_dcache_wdata(mbist_write_data[7:0]),

   //                       .mbist_so      (scan0_13),
   //                       .rclk           (rclk),

   //                       /*AUTOINST*/
   //                       // Outputs
   //                       .mbist_dcache_read(mbist_dcache_read),
   //                       .mbist_dcache_write(mbist_dcache_write),
   //                       .mbist_dcache_word(mbist_dcache_word),
   //                       .mbist_dcache_index(mbist_dcache_index[6:0]),
   //                       .mbist_dcache_way(mbist_dcache_way[1:0]),
   //                       .mbist_icache_read(mbist_icache_read),
   //                       .mbist_icache_write(mbist_icache_write),
   //                       .mbist_icache_index(mbist_icache_index[7:0]),
   //                       .mbist_icache_word(mbist_icache_word),
   //                       .mbist_icache_way(mbist_icache_way[1:0]),
   //                       .mbist_ifq_run_bist(mbist_ifq_run_bist),
   //                       .mbist_done    (mbist_done),
   //                       .mbist_dcache_fail(mbist_dcache_fail),
   //                       .mbist_icache_fail(mbist_icache_fail),
   //                       // Inputs
   //                       .grst_l        (grst_l),
   //                       .arst_l        (arst_l),
   //                       .mbist_start   (mbist_start),
   //                       .mbist_userdata_mode(mbist_userdata_mode),
   //                       .mbist_bisi_mode(mbist_bisi_mode),
   //                       .mbist_loop_mode(mbist_loop_mode),
   //                       .mbist_loop_on_address(mbist_loop_on_address),
   //                       .mbist_stop_on_fail(mbist_stop_on_fail),
   //                       .mbist_stop_on_next_fail(mbist_stop_on_next_fail),
   //                       .mbist_dcache_data_in(mbist_dcache_data_in[71:0]));


   // sparc_ifu_sscan sscan(
   //                       .so            (so0),
   //                       .si            (scan0_13),
   //                       .ifq_sscan_test_data(ifq_sscan_data[3:0]),
   //                       .lsu_sscan_test_data(lsu_sscan_data[15:0]),
   //                       .tlu_sscan_test_data(tlu_sscan_data[62:0]),
   //                       /*AUTOINST*/
   //                       // Outputs
   //                       .sparc_sscan(sparc_sscan),
   //                       // Inputs
   //                       .rtap_sscan_snap(rtap_sscan_snap),
   //                       .rtap_sscan_se  (rtap_sscan_se),
   //                       .ctu_tck       (ctu_tck),
   //                       .se            (se),
   //                       .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
   //                       .rclk          (rclk));

// trin: we need this module to read out shadow scan; scan chain is removed though.
// `ifdef NO_SCAN
// `else
sparc_ifu_sscan sscan(
   .ifq_sscan_test_data(ifq_sscan_data[3:0]),
   .lsu_sscan_test_data(lsu_sscan_data[15:0]),
   .tlu_sscan_test_data(tlu_sscan_data[62:0]),
   // Inputs
   .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
   .rclk          (rclk),

   .core_rtap_data          (core_rtap_data),
   .rtap_core_val         (rtap_core_val),
   .rtap_core_threadid         (rtap_core_threadid),
   .rtap_core_id         (rtap_core_id),
   .rtap_core_data         (rtap_core_data)
   );
// `endif   

   // floating outputs
   // sink #(`IC_TAG_UNUSED_SZ) s0(.in (ict_itlb_tags_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s1(.in (ict_itlb_tag1_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s2(.in (ict_itlb_tag2_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s3(.in (ict_itlb_tag3_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(2) s4(.in (fuse_icd_rid[5:4]));

endmodule
// Local Variables:
// verilog-library-directories:("." "../../../srams/rtl" "../../../common/rtl")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_cmp35.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_cmp37
//  Description:	
//  37 bit comparator for MIL hit detection
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_cmp35(/*AUTOARG*/
   // Outputs
   hit, 
   // Inputs
   a, b, valid
   );

   input [34:0] a, b;
   input 	valid;
   
   output 	hit;

   reg 		hit;
   wire 	valid;
   wire [34:0] 	a, b;

   always @ (a or b or valid)
     begin
	if ((a==b) & valid)
	  hit = 1'b1;
	else
	  hit = 1'b0;
     end // always @ (a or b or valid)

endmodule // sparc_ifu_cmp35

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_ctr5.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ctr5
//  Description:	
//  5 bit counter for starvation detect
*/

module sparc_ifu_ctr5(/*AUTOARG*/
   // Outputs
   limit, so, 
   // Inputs
   clk, se, si, rst_ctr_l
   );

   input     clk;
   input     se, si;

   input     rst_ctr_l;

   output    limit;
   output    so;
   
   wire [4:0] count,
	      count_nxt,
	      sum;
   
   assign   sum[0] = ~count[0];
   assign   sum[1] = count[1] ^ count[0];
   assign   sum[2] = count[2] ^ (count[1] & count[0]);
   assign   sum[3] = count[3] ^ (count[2] & count[1] & count[0]);
   assign   sum[4] = count[4] ^ (count[3] & count[2] & count[1] & count[0]);
   assign   count_nxt = sum & {5{rst_ctr_l}};

   dff_s #(5) cnt_reg(.din (count_nxt),
		                .q   (count),
		                .clk (clk),
		                .se  (se), .si(), .so());

   // limit set to 24 for now
   assign   limit = count[4] & count[3];
   
   
endmodule
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_dcl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_dcl
//  Description:	
//   The decode control logic block does branch condition evaluation,
//   delay slot management, and appropriate condition code
//   selection.  It also executes the tcc instruction and kills the E
//   stage instruction if a move did not succeed.  The DCL block is
//   also responsible for generating the correct select signals to
//   choose the branch offset and immediate operand.
//
*/
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//












































module sparc_ifu_dcl(/*AUTOARG*/
   // Outputs
   ifu_exu_kill_e, ifu_exu_dontmv_regz0_e, ifu_exu_dontmv_regz1_e, 
   ifu_exu_tcc_e, ifu_exu_dbrinst_d, ifu_ffu_mvcnd_m, 
   dcl_fcl_bcregz0_e, dcl_fcl_bcregz1_e, dtu_inst_anull_e, 
   dcl_swl_tcc_done_m, dcl_imd_immdata_sel_simm13_d_l, 
   dcl_imd_immdata_sel_movcc_d_l, dcl_imd_immdata_sel_sethi_d_l, 
   dcl_imd_immdata_sel_movr_d_l, dcl_imd_broff_sel_call_d_l, 
   dcl_imd_broff_sel_br_d_l, dcl_imd_broff_sel_bcc_d_l, 
   dcl_imd_broff_sel_bpcc_d_l, dcl_imd_immbr_sel_br_d, so,
   dcl_esl_br_inst_d, dcl_esl_br_inst_e,
   // Inputs
   rclk, se, si, dtu_reset, exu_ifu_cc_d, fcl_dcl_regz_e, 
   exu_ifu_regn_e, ffu_ifu_cc_w2, ffu_ifu_cc_vld_w2, 
   tlu_ifu_flush_pipe_w, swl_dcl_thr_d, swl_dcl_thr_w2, 
   imd_dcl_brcond_d, imd_dcl_mvcond_d, fdp_dcl_op_s, fdp_dcl_op3_s, 
   imd_dcl_abit_d, dec_dcl_cctype_d, dtu_dcl_opf2_d, 
   fcl_dtu_inst_vld_e, fcl_dtu_intr_vld_e, ifu_tlu_flush_w
   );

   input    rclk, 
            se, 
            si, 
            dtu_reset;
   
   input [7:0] exu_ifu_cc_d;         // latest CCs from EXU
   
   input       fcl_dcl_regz_e,        // rs1=0
	             exu_ifu_regn_e;        // rs1<0

   input [7:0] ffu_ifu_cc_w2;
   input [3:0] ffu_ifu_cc_vld_w2;

   input       tlu_ifu_flush_pipe_w;
   
   input [3:0] swl_dcl_thr_d,
	             swl_dcl_thr_w2;
   
   input [3:0] imd_dcl_brcond_d;     // branch condition type
   input [7:0] imd_dcl_mvcond_d;     // mov condition type

   input [1:0] fdp_dcl_op_s;
   input [5:0] fdp_dcl_op3_s;
   input       imd_dcl_abit_d;	      // anull bit for cond branch
   input [2:0] dec_dcl_cctype_d;     // which cond codes to use
   input       dtu_dcl_opf2_d;

   input       fcl_dtu_inst_vld_e;
   input       fcl_dtu_intr_vld_e;
   input       ifu_tlu_flush_w;

   output      ifu_exu_kill_e,
		           ifu_exu_dontmv_regz0_e,
		           ifu_exu_dontmv_regz1_e,
		           ifu_exu_tcc_e;
   output      ifu_exu_dbrinst_d;

   output      ifu_ffu_mvcnd_m;
   
   output      dcl_fcl_bcregz0_e,
               dcl_fcl_bcregz1_e;

   output      dtu_inst_anull_e;
   output      dcl_swl_tcc_done_m;

   output      dcl_imd_immdata_sel_simm13_d_l,      // imm data select
	             dcl_imd_immdata_sel_movcc_d_l,
	             dcl_imd_immdata_sel_sethi_d_l,
	             dcl_imd_immdata_sel_movr_d_l;

   output      dcl_imd_broff_sel_call_d_l,      // dir branch offset select
	             dcl_imd_broff_sel_br_d_l,
	             dcl_imd_broff_sel_bcc_d_l,
	             dcl_imd_broff_sel_bpcc_d_l;

   output      dcl_imd_immbr_sel_br_d;
   
   output      so;

   output      dcl_esl_br_inst_d;
   output      dcl_esl_br_inst_e;

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------

   wire [7:0]  cc_breval_e,
	             fp_breval_d;

   wire        abit_e;

   wire        cond_brtaken_e,
	             anull_all,
	             anull_ubr,
	             anull_cbr;

   wire [3:0]  anull_next_e,
               anull_e,
               thr_anull_d;

   wire        inst_anull_d,
               inst_anull_e;

   wire [3:0]  flush_abit;
   wire        all_flush_w,
               all_flush_w2;

   wire        br_always_e;
   
   wire        sel_movcc,
	             sel_movr;

   wire [3:0]  br_cond_e,
	             br_cond_d;
   wire [3:0]  thr_vld_e;
   
   wire [3:0]  ls_brcond_d,
               ls_brcond_e;
   wire [1:0]  ccfp_sel;

   wire [3:0]  cc_e;

   wire [1:0]  curr_fcc_d;

   wire [7:0]  fcc_d;

   wire [7:0]  t0_fcc_d,
	             t1_fcc_d,
	             t2_fcc_d,
	             t3_fcc_d,
	             t0_fcc_nxt,
	             t1_fcc_nxt,
	             t2_fcc_nxt,
	             t3_fcc_nxt;

   wire        use_fcc0_d,
	             use_fcc1_d,
	             use_fcc2_d,
	             use_fcc3_d;

   wire [3:0]  thr_e,
	             thr_dec_d;
//	             fcc_dec_d,
//	             fcc_dec_e;
   
   wire [1:0]  op_d;
   wire [5:0]  op3_d;

   wire        use_xcc_d,
	             ltz_e,
	             cc_eval0,
	             cc_eval1,
	             fp_eval0_d,
	             fp_eval1_d,
	             fp_eval_d,
	             fp_eval_e,
	             r_eval1,
	             r_eval0,
	             ccfp_eval,
	             ccbr_taken_e,
	             mvbr_sel_br_d,
	             cc_mvbr_d,
	             cc_mvbr_e,
	             fpcond_mvbr_d,
	             fpcond_mvbr_e;

   wire        call_inst_e,
               call_inst_d,
	             dbr_inst_d,
	             dbr_inst_e,
	             ibr_inst_d,
	             ibr_inst_e,
	             mov_inst_d,
	             mov_inst_e,
               tcc_done_e,
	             tcc_inst_d,
	             tcc_inst_e;

   wire        clk;
   

   
//----------------------------------------------------------------------
// Code start here 
//----------------------------------------------------------------------
   assign      clk = rclk;
   

   // S Stage Operands
   dff_s #(2) opreg(.din  (fdp_dcl_op_s),
		              .clk  (clk),
		              .q    (op_d),
		              .se   (se), .si(), .so());

   dff_s #(6) op3_reg(.din  (fdp_dcl_op3_s),
		                .clk  (clk),
		                .q    (op3_d),
		                .se   (se), .si(), .so());

   dff_s abite_reg(.din  (imd_dcl_abit_d),
		             .clk  (clk),
		             .q    (abit_e),
		             .se   (se), .si(), .so());

   // need to protect from scan contention
   dff_s #(4) thre_reg(.din (swl_dcl_thr_d),
                     .q   (thr_e),
                     .clk (clk), .se(se), .si(), .so());

   //------------------------------
   // Choose correct immediate data
   //------------------------------
   // movcc if op3 = 101100
   assign dcl_imd_immdata_sel_movcc_d_l = ~(op_d[1] &
					                                  op3_d[5] & ~op3_d[4] & 
                                            op3_d[3] & ~op3_d[0]);

   // movr if op3 = 101111
   //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   // Reduced the number of terms in the eqn to help with timing 
   // path, the result of which is that the immediate data sent to the
   // exu for a FLUSH instruction is INCORRECT!  (It is decoded as a
   // MOVR).  However, since our architecture completely ignores the
   // address of the flush, this should be ok.  Confirmed with Sanjay
   // 03/31/03. (v1.29 -> 1.30)
   // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   assign dcl_imd_immdata_sel_movr_d_l = ~(op_d[1] &
				                                   op3_d[5] & op3_d[3] &
				                                   op3_d[1] & op3_d[0]);
   
   // sethi if op3 = 100xx
   assign dcl_imd_immdata_sel_sethi_d_l = ~(~op_d[1]);

   // everything else
   assign dcl_imd_immdata_sel_simm13_d_l = 
                   	        ~(dcl_imd_immdata_sel_movcc_d_l &
                              dcl_imd_immdata_sel_movr_d_l  &
	                            dcl_imd_immdata_sel_sethi_d_l);

   //------------------------------
   // Choose correct branch offset
   //------------------------------
   // call or ld/store
   assign dcl_imd_broff_sel_call_d_l = ~(op_d[0]);

   // branch on register
   assign dcl_imd_broff_sel_br_d_l = ~(~op_d[0] & 
				                               op3_d[4] & op3_d[3]);
   // branch w/o prediction
   assign dcl_imd_broff_sel_bcc_d_l = ~(~op_d[0] & 
					                              op3_d[4] & ~op3_d[3]);
   // everything else
   assign dcl_imd_broff_sel_bpcc_d_l = ~(~op_d[0] & 
					                               ~op3_d[4]);

   //------------------------------------
   // mark branch/conditional instrctions
   //------------------------------------
   // call
   assign call_inst_d = ~op_d[1] & op_d[0];
   dff_s #(1) call_inste_reg(.din  (call_inst_d),
			                     .clk  (clk),
			                     .q    (call_inst_e),
			                     .se   (se), .si(), .so());

   // call or branch but not nop/sethi
   assign dbr_inst_d = ~op_d[1] & (op_d[0] | op3_d[4] | op3_d[3]);
   
   // Choose between branch offset and immediate operand
   assign dcl_imd_immbr_sel_br_d = dbr_inst_d;

   // tell exu to use pc instead of rs1
   assign ifu_exu_dbrinst_d = ~op_d[1];

   dff_s #(1) dbr_inste_reg(.din  (dbr_inst_d),
			                    .clk  (clk),
			                    .q    (dbr_inst_e),
			                    .se   (se), .si(), .so());

   // jmpl + return
   assign ibr_inst_d = op_d[1] & ~op_d[0] &
		                    op3_d[5] &  op3_d[4] &  op3_d[3] & 
                        ~op3_d[2] & ~op3_d[1];
   dff_s #(1) ibr_inste_reg(.din  (ibr_inst_d),
			                    .clk  (clk),
			                    .q    (ibr_inst_e),
			                    .se   (se), .si(), .so());   

   assign dcl_esl_br_inst_d = dbr_inst_d | ibr_inst_d;
   assign dcl_esl_br_inst_e = dbr_inst_e | ibr_inst_e;
   // mov
   assign mov_inst_d = (op_d[1] & ~op_d[0] &
			                  op3_d[5] & ~op3_d[4] & op3_d[3] & op3_d[2] & 
			                  (~op3_d[1] & ~op3_d[0] | op3_d[1] & op3_d[0]));

   dff_s #(1) mov_inste_reg(.din  (mov_inst_d),
			                    .clk  (clk),
			                    .q    (mov_inst_e),
			                    .se   (se), .si(), .so());
   // tcc
   assign tcc_inst_d = op_d[1] & ~op_d[0] &
		                   op3_d[5] &  op3_d[4] &  op3_d[3] & 
		                   ~op3_d[2] &  op3_d[1] & ~op3_d[0];
   dff_s #(1) tcc_inste_reg(.din  (tcc_inst_d),
			                    .clk  (clk),
			                    .q    (tcc_inst_e),
			                    .se   (se), .si(), .so());

   assign mvbr_sel_br_d = ~op_d[1] & ~op_d[0] |          // br
	                         op3_d[3] & ~op3_d[2] & op3_d[1] & ~op3_d[0]; // tcc
   
   assign cc_mvbr_d = ~(~op_d[1] & ~op_d[0] & op3_d[4] & op3_d[3] |  // bpr
			                  op_d[1] & ~op_d[0] & op3_d[5] & ~op3_d[4] &
			                  op3_d[3] & op3_d[2] & op3_d[1] & op3_d[0] |  // movr
			                  op_d[1] & ~op_d[0] & op3_d[5] & op3_d[4] &
			                  ~op3_d[3] & op3_d[2] & ~op3_d[1] & op3_d[0] &
			                  dtu_dcl_opf2_d);                             // fmovr


   //---------------------------
   // FCC Logic
   //--------------------------
   // choose current fcc
   assign use_fcc0_d = ~dec_dcl_cctype_d[1] & ~dec_dcl_cctype_d[0];
   assign use_fcc1_d = ~dec_dcl_cctype_d[1] &  dec_dcl_cctype_d[0];
   assign use_fcc2_d =  dec_dcl_cctype_d[1] & ~dec_dcl_cctype_d[0];
   assign use_fcc3_d =  dec_dcl_cctype_d[1] &  dec_dcl_cctype_d[0];
   
   mux4ds #(2) fcc_mux(.dout (curr_fcc_d[1:0]),
		                   .in0  (fcc_d[1:0]),
		                   .in1  (fcc_d[3:2]),
		                   .in2  (fcc_d[5:4]),
		                   .in3  (fcc_d[7:6]),
		                   .sel0 (use_fcc0_d),
		                   .sel1 (use_fcc1_d),
		                   .sel2 (use_fcc2_d),
		                   .sel3 (use_fcc3_d));

   // decode to make next step easier
//   assign fcc_dec_d[0] = ~curr_fcc_d[1] & ~curr_fcc_d[0];
//   assign fcc_dec_d[1] = ~curr_fcc_d[1] &  curr_fcc_d[0];
//   assign fcc_dec_d[2] =  curr_fcc_d[1] & ~curr_fcc_d[0];
//   assign fcc_dec_d[3] =  curr_fcc_d[1] &  curr_fcc_d[0];

//   dff #(4) fcce_reg(.din (fcc_dec_d),
//		                 .q   (fcc_dec_e),
//		                 .clk (clk),
//		                 .se  (se), .si(), .so());
   
   
   //------------------
   // CC Logic for BCC
   //------------------
   // Choose appropriate CCs
   //
   // dec_cctype is 3 bits
   // 10X  icc
   // 11X  xcc
   // 000  fcc0
   // 001  fcc1
   // 010  fcc2
   // 011  fcc3
//   assign use_xcc_d = (dec_dcl_cctype_d[2] | op3_d[3]) & dec_dcl_cctype_d[1];
   assign use_xcc_d = dec_dcl_cctype_d[1];   
   assign fpcond_mvbr_d = ~dec_dcl_cctype_d[2] & ~tcc_inst_d;

   dff_s fpbr_reg(.din  (fpcond_mvbr_d),
		            .clk  (clk),
		            .q    (fpcond_mvbr_e),
		            .se   (se), .si(), .so());
   
   // mux between xcc and icc
//   assign cc_d =  use_xcc_d ?  exu_ifu_cc_d[7:4] :      // xcc
//			                         exu_ifu_cc_d[3:0];       // icc
//   dff #(4)  ccreg_e(.din  (cc_d),
//		                 .clk  (clk),
//		                 .q    (cc_e),
//		                 .se   (se),  .si(), .so());

   bw_u1_soffm2_4x UZsize_ccreg0_e(.d0 (exu_ifu_cc_d[0]),
                                   .d1 (exu_ifu_cc_d[4]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[0]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg1_e(.d0 (exu_ifu_cc_d[1]),
                                   .d1 (exu_ifu_cc_d[5]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[1]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg2_e(.d0 (exu_ifu_cc_d[2]),
                                   .d1 (exu_ifu_cc_d[6]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[2]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg3_e(.d0 (exu_ifu_cc_d[3]),
                                   .d1 (exu_ifu_cc_d[7]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[3]),
                                   .ck (clk), .se(se), .sd(), .so());
   
   
   //------------------------------
   // Evaluate Branch
   //------------------------------
   // Select correct branch condition
   assign sel_movcc = ~mvbr_sel_br_d & cc_mvbr_d;
   assign sel_movr = ~mvbr_sel_br_d & ~cc_mvbr_d;
   
   // br_cond is the same as the "cond" field = inst[28:25] for bcc
   mux3ds #(4)  brcond_mux(.dout   (br_cond_d),
			                     .in0    (imd_dcl_brcond_d),  // br or tcc
			                     .in1    (imd_dcl_mvcond_d[7:4]),  // movcc
			                     .in2    (imd_dcl_mvcond_d[3:0]),  // movr
			                     .sel0   (mvbr_sel_br_d),
			                     .sel1   (sel_movcc),
			                     .sel2   (sel_movr));
   
   dff_s #(4)  brcond_e_reg(.din  (br_cond_d),
			                    .clk  (clk),
			                    .q    (br_cond_e),
			                    .se   (se), .si(), .so());

   // Branch Type Decode
   assign ls_brcond_d[0]  =  ~br_cond_d[1] & ~br_cond_d[0];
   assign ls_brcond_d[1]  =  ~br_cond_d[1] &  br_cond_d[0];
   assign ls_brcond_d[2]  =   br_cond_d[1] & ~br_cond_d[0];
   assign ls_brcond_d[3]  =   br_cond_d[1] &  br_cond_d[0];

   dff_s #(4)  lsbrc_e_reg(.din  (ls_brcond_d),
			                   .clk  (clk),
			                   .q    (ls_brcond_e),
			                   .se   (se), .si(), .so());
   
   // Evaluate potential integer CC branches
   assign ltz_e = (cc_e[3] ^ cc_e[1]);

   assign cc_breval_e[0] = 1'b0;                       // BPN
   assign cc_breval_e[1] = cc_e[2];	               // BPE
   assign cc_breval_e[2] = cc_e[2] | ltz_e;        // BPLE
   assign cc_breval_e[3] = ltz_e;                      // BPL
   assign cc_breval_e[4] = cc_e[2] | cc_e[0];  // BPLEU
   assign cc_breval_e[5] = cc_e[0];                // BPCS
   assign cc_breval_e[6] = cc_e[3];                // BPNEG
   assign cc_breval_e[7] = cc_e[1];                // BPVS 

   // mux to choose right condition
   assign cc_eval0 = cc_breval_e[0] & ls_brcond_e[0] |
		                 cc_breval_e[1] & ls_brcond_e[1] |
		                 cc_breval_e[2] & ls_brcond_e[2] |
		                 cc_breval_e[3] & ls_brcond_e[3];

   assign cc_eval1 = cc_breval_e[4] & ls_brcond_e[0] |
		                 cc_breval_e[5] & ls_brcond_e[1] |
		                 cc_breval_e[6] & ls_brcond_e[2] |
		                 cc_breval_e[7] & ls_brcond_e[3];

   // Evaluate FP CC branches in D stage
   assign fp_breval_d[0] = 1'b0;                            // FBN / A
   assign fp_breval_d[1] = (curr_fcc_d[1] | curr_fcc_d[0]); // FBNE / E
   assign fp_breval_d[2] = curr_fcc_d[1] ^ curr_fcc_d[0];   // FBLG / UE
   assign fp_breval_d[3] = curr_fcc_d[0];                   // FBUL / GE
   assign fp_breval_d[4] = ~curr_fcc_d[1] & curr_fcc_d[0];  // FBL / UGE
   assign fp_breval_d[5] = curr_fcc_d[1];                   // FBUG / LE
   assign fp_breval_d[6] = curr_fcc_d[1] & ~curr_fcc_d[0];  // FBG / ULE
   assign fp_breval_d[7] = curr_fcc_d[1] & curr_fcc_d[0];   // FBU / O
   
   assign fp_eval0_d = fp_breval_d[0] & ls_brcond_d[0] |
		                 fp_breval_d[1] & ls_brcond_d[1] |
		                 fp_breval_d[2] & ls_brcond_d[2] |
		                 fp_breval_d[3] & ls_brcond_d[3];

   assign fp_eval1_d = fp_breval_d[4] & ls_brcond_d[0] |
		                 fp_breval_d[5] & ls_brcond_d[1] |
		                 fp_breval_d[6] & ls_brcond_d[2] |
		                 fp_breval_d[7] & ls_brcond_d[3];

   assign fp_eval_d = br_cond_d[2] ? fp_eval1_d :
                                     fp_eval0_d;

   dff_s #(1) fpev_ff(.din (fp_eval_d),
		                .q   (fp_eval_e),
		                .clk (clk),
		                .se  (se), .si(), .so());

   // merge eval0, eval1 and fp condition codes
   assign ccfp_sel[0] = ~fpcond_mvbr_e & ~br_cond_e[2];
   assign ccfp_sel[1] = ~fpcond_mvbr_e &  br_cond_e[2];
//   assign ccfp_sel[2] =  fpcond_mvbr_e & ~br_cond_e[2];
//   assign ccfp_sel[3] =  fpcond_mvbr_e &  br_cond_e[2];
   
   assign ccfp_eval = ccfp_sel[0] & cc_eval0 |
		                  ccfp_sel[1] & cc_eval1 | 
		                  fpcond_mvbr_e & fp_eval_e;
   
   // invert branch condition if this is an inverted br type
//   assign ccbr_taken_e = (ccfp_eval ^ br_cond_e[3]) & cc_mvbr_e;
   assign ccbr_taken_e = ccfp_eval ? (cc_mvbr_e & ~br_cond_e[3]) :
                                       (cc_mvbr_e & br_cond_e[3]);

   assign br_always_e = (~br_cond_e[0] & ~br_cond_e[1] & ~br_cond_e[2] & 
	                       br_cond_e[3] & cc_mvbr_e);

   //--------------
   // For BRZ
   // -------------
   // Calculate Cond Assuming Z=1 And Z=0.  Then Mux
//   assign r_eval1 = ((exu_ifu_regn_e | ~br_cond_e[1] | ~br_cond_e[0]) ^
//		                  br_cond_e[2]) & ~cc_mvbr_e;
   assign r_eval1 = exu_ifu_regn_e ? (~br_cond_e[2] & ~cc_mvbr_e) :
                                       (((br_cond_e[1] & br_cond_e[0]) ^ 
                                         ~br_cond_e[2]) & ~cc_mvbr_e);
   
//   assign r_eval0 = ((exu_ifu_regn_e & br_cond_e[1]) ^
//                      br_cond_e[2]) & ~cc_mvbr_e;
   assign r_eval0 = exu_ifu_regn_e ? ((br_cond_e[1] ^ br_cond_e[2]) & 
                                       ~cc_mvbr_e) :
                                       (br_cond_e[2] & ~cc_mvbr_e);

   dff_s #(1) regcc_ff(.din  (cc_mvbr_d),
		                 .clk  (clk),
		                 .q    (cc_mvbr_e),
		                 .se   (se), .si(), .so());

   // Evaluate Final Branch condition
   // 3:1 mux
//   assign cond_brtaken_e = cc_mvbr_e      ?  ccbr_taken_e :
//		                       exu_ifu_regz_e ?       r_eval1 :
//		                                              r_eval0;
   // 2:1 mux
//   assign cond_brtaken_e = exu_ifu_regz_e ? (r_eval1 | ccbr_taken_e) :
//                                              (r_eval0 | ccbr_taken_e);

   //////// Chandra ////////

   wire   temp0, temp1, cond_brtaken_e_l;

   // limit loading on this signal
//   wire   regz_buf_e;
//   bw_u1_buf_5x UZfix_regz_bf(.a (exu_ifu_regz_e),
//                              .z (regz_buf_e));
   
   assign temp0 = (r_eval0 | ccbr_taken_e);
   assign temp1 = (r_eval1 | ccbr_taken_e);

   bw_u1_muxi21_6x UZsize_cbtmux(.z(cond_brtaken_e_l), 
                                  .d0(temp0), 
                                  .d1(temp1), 
                                  .s(fcl_dcl_regz_e));
   
   bw_u1_inv_20x UZsize_cbtinv(.z(cond_brtaken_e), 
                                .a(cond_brtaken_e_l));

   ////////////////////////

   assign dcl_fcl_bcregz0_e = (temp0 & dbr_inst_e | ibr_inst_e | 
                               call_inst_e) & ~dtu_inst_anull_e;
   assign dcl_fcl_bcregz1_e = (temp1 & dbr_inst_e | ibr_inst_e | 
                               call_inst_e) & ~dtu_inst_anull_e;

//   assign ifu_exu_dontmove_e = mov_inst_e & ~cond_brtaken_e;
   assign ifu_exu_dontmv_regz0_e = ~temp0 & mov_inst_e;
   assign ifu_exu_dontmv_regz1_e = ~temp1 & mov_inst_e;

   // branch condition to FPU
   dff_s #(1) fpcond_ff(.din  (cond_brtaken_e),
		                  .q    (ifu_ffu_mvcnd_m),
		                  .clk  (clk),
		                  .se   (se), .si(), .so());		    

   // branch / move completion and anull signals
//   assign dtu_fcl_brtaken_e = ~dtu_inst_anull_e & 
//	                            (ibr_inst_e | call_inst_e |
//			                         dbr_inst_e & cond_brtaken_e);

   // if mov didn't succeed kill write back and bypass
   // need to check thread as well
//   assign ifu_exu_kill_e = dtu_inst_anull_e | 
//	                   ~fcl_dtu_inst_vld_e;  // don't need this anymore
   assign ifu_exu_kill_e = dtu_inst_anull_e;


   // signal trap if tcc succeeds
   assign ifu_exu_tcc_e = ~dtu_inst_anull_e & tcc_inst_e & ccbr_taken_e & 
                          fcl_dtu_inst_vld_e;

   assign tcc_done_e = ~dtu_inst_anull_e & tcc_inst_e & ~ccbr_taken_e & 
                       fcl_dtu_inst_vld_e;   

   dff_s #(1) tccm_ff(.din (tcc_done_e),
                    .q   (dcl_swl_tcc_done_m),
                    .clk (clk),
                    .se  (se), .si(), .so());
   
   // logic to anull delay slot, if this branch itsel is not anulled
   assign anull_cbr  =  abit_e & dbr_inst_e & ~br_always_e & ~call_inst_e;
   assign anull_ubr  =  abit_e & dbr_inst_e & br_always_e & ~call_inst_e;

   assign anull_all =  anull_ubr  | anull_cbr & ~cond_brtaken_e;

   // check which thread to anull
   assign thr_vld_e = thr_e & {4{fcl_dtu_inst_vld_e}};

   assign all_flush_w = tlu_ifu_flush_pipe_w | ifu_tlu_flush_w;
   dff_s #(1) flshw2_ff(.din (all_flush_w),
                      .q   (all_flush_w2),
                      .clk (clk), .se(se), .si(), .so());

   assign flush_abit = swl_dcl_thr_w2 & {4{all_flush_w2}};
   
   assign anull_next_e = ((~anull_e & {4{anull_all}} & thr_vld_e) |
 	                        (anull_e & ~(thr_e & {4{fcl_dtu_inst_vld_e |
                                                  fcl_dtu_intr_vld_e}}))) & 
                           ~flush_abit;
   
   // anull_e needs to be per thread
   dffr_s #(4) anull_ff(.din  (anull_next_e),
		                  .clk  (clk),
		                  .rst  (dtu_reset),
		                  .q    (anull_e),
		                  .se   (se), .si(), .so());

   // 
//   assign thr_dec_e[0] = swl_dcl_thr_e[0] | rst_tri_enable;
//   assign thr_dec_e[3:1] = swl_dcl_thr_e[3:1] & {3{~rst_tri_enable}};

   assign thr_anull_d = swl_dcl_thr_d & anull_next_e;
   assign inst_anull_d =  (|thr_anull_d[3:0]);
   dff_s #(1) ina_ff(.din (inst_anull_d),
                   .q   (inst_anull_e),
                   .clk (clk), .se (se), .si(), .so());
                   
   assign dtu_inst_anull_e = inst_anull_e;

//   mux4ds dcla_mux(.dout (this_inst_anull_e),  
//		               .in0  (anull_e[0]),
//		               .in1  (anull_e[1]),
//		               .in2  (anull_e[2]),
//		               .in3  (anull_e[3]),
//		               .sel0 (thr_dec_e[0]),
//		               .sel1 (thr_dec_e[1]),
//		               .sel2 (thr_dec_e[2]),
//		               .sel3 (thr_dec_e[3]));
//   assign dtu_inst_anull_e = this_inst_anull_e & fcl_dtu_inst_vld_e;


//--------------------
// Copy of FCC
//--------------------
   // FCC's are maintained in the ffu.  A copy is kept here to run the
   // FP branch instructions.
   
   // load FCC from FFU
   mux2ds #(8)  t0_fcc_mux(.dout (t0_fcc_nxt[7:0]),
			                     .in0  (t0_fcc_d[7:0]),
			                     .in1  (ffu_ifu_cc_w2[7:0]),
			                     .sel0  (~ffu_ifu_cc_vld_w2[0]),
			                     .sel1  (ffu_ifu_cc_vld_w2[0]));
   
   dffr_s #(8) t0_fcc_reg(.din (t0_fcc_nxt[7:0]),
		                    .q   (t0_fcc_d[7:0]),
		                    .rst (dtu_reset),
		                    .clk (clk),  .se  (se), .si(), .so());
 // Use two threads unless this is defined

   mux2ds #(8)  t1_fcc_mux(.dout (t1_fcc_nxt[7:0]),
                                 .in0  (t1_fcc_d[7:0]),
                                 .in1  (ffu_ifu_cc_w2[7:0]),
                                 .sel0  (~ffu_ifu_cc_vld_w2[1]),
                                 .sel1  (ffu_ifu_cc_vld_w2[1]));

   // thread0 fcc registers

   dffr_s #(8) t1_fcc_reg(.din (t1_fcc_nxt[7:0]),
                            .q   (t1_fcc_d[7:0]),
                            .rst (dtu_reset),
                            .clk (clk),  .se  (se), .si(), .so());

   // choose thread
   assign thr_dec_d[0] = swl_dcl_thr_d[0];
   assign thr_dec_d[3:1] = swl_dcl_thr_d[3:1];

   mux2ds #(8) fcc0d_mx(.dout (fcc_d[7:0]),
                            .in0  (t0_fcc_d[7:0]),
                            .in1  (t1_fcc_d[7:0]),
                            .sel0 (thr_dec_d[0]),
                            .sel1 (thr_dec_d[1]));



























































































































 // `ifndef CONFIG_NUM_THREADS
   
endmodule // sparc_ifu_dcl

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_dec.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_dec
//  Description:	
//  The decode block implements the sparc instruction decode ROM
//  It has a purely combinational part and some staging flops
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_dec(/*AUTOARG*/
   // Outputs
   so, ifu_exu_aluop_d, ifu_exu_invert_d, ifu_exu_useimm_d, 
   ifu_exu_usecin_d, ifu_exu_enshift_d, ifu_exu_tagop_d, 
   ifu_exu_tv_d, ifu_exu_muls_d, ifu_exu_ialign_d, 
   ifu_exu_range_check_jlret_d, ifu_exu_range_check_other_d, 
   ifu_exu_shiftop_d, ifu_exu_muldivop_d, ifu_exu_wen_d, 
   ifu_exu_setcc_d, ifu_exu_rd_ifusr_e, ifu_exu_rd_exusr_e, 
   ifu_exu_rd_ffusr_e, ifu_exu_rs1_vld_d, ifu_exu_rs2_vld_d, 
   ifu_exu_rs3e_vld_d, ifu_exu_rs3o_vld_d, ifu_exu_use_rsr_e_l, 
   ifu_exu_save_d, ifu_exu_restore_d, ifu_exu_return_d, 
   ifu_exu_flushw_e, ifu_exu_saved_e, ifu_exu_restored_e, 
   ifu_tlu_rsr_inst_d, ifu_lsu_wsr_inst_d, ifu_exu_wsr_inst_d, 
   ifu_tlu_done_inst_d, ifu_tlu_retry_inst_d, ifu_lsu_ld_inst_e, 
   ifu_lsu_st_inst_e, ifu_lsu_pref_inst_e, ifu_lsu_alt_space_e, 
   ifu_lsu_alt_space_d, ifu_tlu_alt_space_d, ifu_lsu_memref_d, 
   ifu_lsu_sign_ext_e, ifu_lsu_ldstub_e, ifu_lsu_casa_e, 
   ifu_exu_casa_d, ifu_lsu_swap_e, ifu_tlu_mb_inst_e, 
   ifu_tlu_sir_inst_m, ifu_tlu_flsh_inst_e, ifu_lsu_ldst_dbl_e, 
   ifu_lsu_ldst_fp_e, ifu_lsu_ldst_size_e, ifu_ffu_fpop1_d, 
   ifu_ffu_visop_d, ifu_ffu_fpop2_d, ifu_ffu_fld_d, ifu_ffu_fst_d, 
   ifu_ffu_ldst_size_d, ifu_ffu_ldfsr_d, ifu_ffu_ldxfsr_d, 
   ifu_ffu_stfsr_d, ifu_ffu_quad_op_e, dec_fcl_rdsr_sel_pc_d, 
   dec_fcl_rdsr_sel_thr_d, dec_imd_call_inst_d, 
   dtu_fcl_flush_sonly_e, dtu_fcl_illinst_e, dtu_fcl_fpdis_e, 
   dtu_fcl_privop_e, dtu_fcl_imask_hit_e, dtu_fcl_br_inst_d, 
   dtu_fcl_sir_inst_e, dtu_ifq_kill_latest_d, dec_swl_wrt_tcr_w, 
   dec_swl_wrtfprs_w, dec_swl_ll_done_d, dec_swl_br_done_d, 
   dec_swl_rdsr_sel_thr_d, dec_swl_ld_inst_d, dec_swl_sta_inst_e, 
   dec_swl_std_inst_d, dec_swl_st_inst_d, dec_swl_fpop_d, 
   dec_swl_allfp_d, dec_swl_frf_upper_d, dec_swl_frf_lower_d, 
   dec_swl_div_inst_d, dec_swl_mul_inst_d, wsr_fixed_inst_w, 
   ifu_exu_sethi_inst_d, dec_dcl_cctype_d, 
   // Inputs
   rclk, se, si, dtu_inst_d, erb_dtu_imask, swl_dec_ibe_e, 
   dtu_inst_anull_e, lsu_ifu_ldsta_internal_e, fcl_dtu_tlzero_d, 
   fcl_dtu_privmode_d, fcl_dtu_hprivmode_d, fcl_dtu_inst_vld_d, 
   fcl_dtu_ely_inst_vld_d, fcl_dec_intr_vld_d, fcl_dtu_inst_vld_e, 
   fcl_dec_dslot_s, swl_dec_mulbusy_e, swl_dec_fpbusy_e, 
   swl_dec_divbusy_e, swl_dec_fp_enable_d
   );

   input          rclk, 
                  se, 
                  si;
   input [31:0]   dtu_inst_d;	// fed in at Switch (S) stage.
   input [38:0]   erb_dtu_imask;
   input          swl_dec_ibe_e;
   input          dtu_inst_anull_e;
   input          lsu_ifu_ldsta_internal_e;
   input          fcl_dtu_tlzero_d;
   input          fcl_dtu_privmode_d;
   input          fcl_dtu_hprivmode_d;
   input          fcl_dtu_inst_vld_d,
                  fcl_dtu_ely_inst_vld_d,
                  fcl_dec_intr_vld_d,
		              fcl_dtu_inst_vld_e;  // qual with this is not necessary

   input          fcl_dec_dslot_s;

   input          swl_dec_mulbusy_e;
   input          swl_dec_fpbusy_e;
   input          swl_dec_divbusy_e;
   input          swl_dec_fp_enable_d;


   output         so;
   
   // to EXU
   output [2:0]   ifu_exu_aluop_d;// 000 - add/sub
                                  // 001 - and
                                  // 010 - or
                                  // 011 - xor
                                  // 1X0 - movcc
                                  // 1x1 - movr
   output         ifu_exu_invert_d;   // invert rs2 operand
   output         ifu_exu_useimm_d;
   output         ifu_exu_usecin_d;   // use c from icc
   output         ifu_exu_enshift_d;  // turn on shifter

   output         ifu_exu_tagop_d,     
		              ifu_exu_tv_d,     
		              ifu_exu_muls_d,
                  ifu_exu_ialign_d,
		              ifu_exu_range_check_jlret_d,		
		              ifu_exu_range_check_other_d;

   output [2:0] ifu_exu_shiftop_d;  // b2 - 32b(0) or 64b(1)
                                    // b1 - unsigned(0)  or signed(1)
                                    // b0 - left(0) or right(1) shift
   
   output [4:0] ifu_exu_muldivop_d; // b4 - is_mul
                                    // b3 - is_div
                                    // b2 - 64b if 1, 32b if 0
                                    // b1 - signed if 1, unsigned if 0
                                    // b0 - set cc's
   
   output       ifu_exu_wen_d;      // write to rd
   output       ifu_exu_setcc_d;    // b0 - write to icc/xcc

   output       ifu_exu_rd_ifusr_e,
		            ifu_exu_rd_exusr_e,
		            ifu_exu_rd_ffusr_e;

   output       ifu_exu_rs1_vld_d,
		            ifu_exu_rs2_vld_d,
		            ifu_exu_rs3e_vld_d,
		            ifu_exu_rs3o_vld_d;
   
   output       ifu_exu_use_rsr_e_l;
   
   output       ifu_exu_save_d, 
		            ifu_exu_restore_d,
		            ifu_exu_return_d,
		            ifu_exu_flushw_e,
		            ifu_exu_saved_e,
		            ifu_exu_restored_e;

   // to TLU
   output       ifu_tlu_rsr_inst_d,
		            ifu_lsu_wsr_inst_d,
		            ifu_exu_wsr_inst_d,
		            ifu_tlu_done_inst_d,
		            ifu_tlu_retry_inst_d;
   
   // to LSU 
   output       ifu_lsu_ld_inst_e,   // ld inst or atomic
		            ifu_lsu_st_inst_e,   // store or atomic
                ifu_lsu_pref_inst_e,
		            ifu_lsu_alt_space_e, // alt space -- to be removed
		            ifu_lsu_alt_space_d, // never x -- to be removed
		            ifu_tlu_alt_space_d, // sometimes x but faster
		            ifu_lsu_memref_d;    // alerts lsu of upcoming ldst
//		            ifu_lsu_imm_asi_vld_d;

   output       ifu_lsu_sign_ext_e,
		            ifu_lsu_ldstub_e,
		            ifu_lsu_casa_e,
		            ifu_exu_casa_d,
		            ifu_lsu_swap_e;

   output       ifu_tlu_mb_inst_e,
		            ifu_tlu_sir_inst_m,
		            ifu_tlu_flsh_inst_e;

   output       ifu_lsu_ldst_dbl_e,
		            ifu_lsu_ldst_fp_e;
   
   output [1:0] ifu_lsu_ldst_size_e;
   
   // to SPU
//   output 	ifu_spu_scpy_inst_e,
//		ifu_spu_scmp_inst_e;

   // to FFU
   output       ifu_ffu_fpop1_d;
   output       ifu_ffu_visop_d;
   output       ifu_ffu_fpop2_d;
   output       ifu_ffu_fld_d;
   output       ifu_ffu_fst_d;
   output       ifu_ffu_ldst_size_d;
   
   output       ifu_ffu_ldfsr_d,
		            ifu_ffu_ldxfsr_d,
		            ifu_ffu_stfsr_d;
   output       ifu_ffu_quad_op_e;

   // within IFU
   output       dec_fcl_rdsr_sel_pc_d,
		            dec_fcl_rdsr_sel_thr_d;

   output       dec_imd_call_inst_d;

   output       dtu_fcl_flush_sonly_e,
//                dec_fcl_kill4sta_e,
		            dtu_fcl_illinst_e,
		            dtu_fcl_fpdis_e,
		            dtu_fcl_privop_e,
		            dtu_fcl_imask_hit_e,
		            dtu_fcl_br_inst_d,
		            dtu_fcl_sir_inst_e;

   output       dtu_ifq_kill_latest_d;
   
   // within DTU
   output       dec_swl_wrt_tcr_w,
		            dec_swl_wrtfprs_w,
		            dec_swl_ll_done_d,
                dec_swl_br_done_d,
		            dec_swl_rdsr_sel_thr_d,
		            dec_swl_ld_inst_d,
		            dec_swl_sta_inst_e,
		            dec_swl_std_inst_d,
		            dec_swl_st_inst_d,
		            dec_swl_fpop_d,
		            dec_swl_allfp_d,
		            dec_swl_frf_upper_d,
		            dec_swl_frf_lower_d,
		            dec_swl_div_inst_d,
		            dec_swl_mul_inst_d,
		            wsr_fixed_inst_w,
		            ifu_exu_sethi_inst_d;   // can be sethi or no-op

   output [2:0] dec_dcl_cctype_d;       // 0yy - fcc(yy)
                                        // 100 - icc
                                        // 110 - xcc
                                        // 1X1 - illegal inst!
   
   //------------------------------------------------------------
   // Declarations
   //------------------------------------------------------------
   // Internal Signals
   wire [1:0]   op;
   wire [2:0]   op2;
   wire [5:0]   op3;
   wire [8:0]   opf;

   wire         brsethi_inst,  // op types
		            call_inst,
		            arith_inst,
		            mem_inst;
   wire         sethi_or_nop;
   wire [15:0]  op3_lo;        // decode op3[3:0]
   wire [3:0]   op3_hi;        // decode op3[5:4]

   wire         dbr_inst_d, 
		            ibr_inst_d,    // jmpl or return
		            jmpl_inst_d,
		            retn_inst_d,
		            sethi_inst_d;

   wire         rdsr_done_d,
                rdpr_done_d;
   wire         dslot_d;
   
   wire         use_rsr_d_l;
   
   wire         flushw_d,
		            saved_d,
		            restored_d;
   wire         save_retn_done_d;
   wire         privop_d,
		            privop_e,
                hprivop_d,
                hprivop_e,
                valid_hp_rs_d,
                valid_hp_rd_d,
		            inv_reg_access_d,
                rsvchk_fail_d,
		            ill_inst_d,
		            ill_inst_e;

   wire         inst12_5_nonzero_d,
                inst11_8_nonzero_d,
                inst9_5_nonzero_d,
                rs2_nonzero_d;

   wire         state_chg_inst_d,
		            state_chg_inst_e,
		            flush_inst_d;

   wire         cctype_sel_imov,   // select which CC's to use
		            cctype_sel_fmov,
		            cctype_sel_bcc,
		            cctype_sel_bpcc;

   wire         rs1_vld_d,
		            rs2_vld_d,
		            rs3_vld_d,
		            rs4_vld_d;

   wire [4:0]   rs1,
		            rd;
   
   wire         rs1_00,           // decoded rs1
		            rs1_01,
		            rs1_02,
		            rs1_05,
		            rs1_06,
		            rs1_07,
		            rs1_09_0e,
		            rs1_0f,
                rs1_10,
		            rs1_12,
		            rs1_13,
		            rs1_14_15,
		            rs1_16_17,
                rs1_19,
		            rs1_1a,
		            rs1_1b,
		            rs1_1c_1f,
		            rd_00,
		            rd_01,
		            rd_04,
		            rd_05,
		            rd_06,
		            rd_07,
		            rd_09,
		            rd_0f,
                rd_10,
		            rd_11,
		            rd_12,
                rd_13,
                rd_18,
		            rd_1a,
		            rd_1b,
		            rd_1c_1f,
                rd_1f,
		            rs1_1f;

   wire         fcn0;
   
   wire         rd_ifusr_d,
		            rd_ifusr_e,
                rd_ffusr_d,
		            rd_ffusr_e,
		            rd_exusr_d,
		            rd_exusr_e;
   wire         wsr_fixed_inst_e,
		            wsr_fixed_inst_m,
		            wsr_inst_next_e,
		            wsr_fixed_inst_d;

   wire         wrt_tcr_d,
		            wrt_tcr_e,
		            wrt_tcr_qual_e,
		            wrt_tcr_m;
	 
   wire         wrt_fprs_d,
		            wrt_fprs_e,
		            wrt_fprs_qual_e,
		            wrt_fprs_m;
	 
   wire         prefetch,
                impl_prefetch,
                illegal_prefetch,
                noop_prefetch,
                pref_done_d,
                prefetch_d,
                prefetch_e;

   wire [2:0]   lstype_d,
		            lstype_e;
   wire [1:0]   lssize_d;
   wire         ldst_dbl_d,
		            ldst_fp_d,
		            sta_inst_d,
//                kill_for_sta_d,
                sta_nostf_d,
		            sta_inst_e,
                sta_nostf_e,
		            sext_d,
		            ldstub_d,
		            casa_d,
                casa_e,
		            swap_d;

   wire         mb_mask_d,
		            mb_inst_d,
		            mb_inst_e;

   wire         sir_inst_d,
		            sir_inst_e,
//		            kill_sir_d,
		            flag_sir_d,
		            flag_sir_e;
   
   wire         fpld_d,
		            fpop1_d,
                visop_d,
                int_align_d,
		            fpop2_d;
   wire         quad_ffuop_d;

   wire         allfp_d,
		            any_fpinst_d,
		            fpdis_trap_d,
		            fpdis_trap_e,
		            fcc_mov_d,
		            fcc_branch_d;
   
   wire         rs2_hit,
		            opf_hit,
		            ibit_hit,
		            rs1_hit,
		            op3_hit,
		            rd_hit,
		            op_hit,
		            imask_hit,
		            imask_hit_e;

   wire         clk;
   

//----------------------------------------------------------------------
// Code Begins Here
//----------------------------------------------------------------------
   assign       clk = rclk;

   
   assign   op  = dtu_inst_d[31:30];
   assign   op2 = dtu_inst_d[24:22];
   assign   op3 = dtu_inst_d[24:19];
   assign   opf = dtu_inst_d[13:5];

   // decode op
   assign   brsethi_inst = ~op[1] & ~op[0];
   assign   call_inst    = ~op[1] &  op[0];
   assign   arith_inst   =  op[1] & ~op[0];
   assign   mem_inst     =  op[1] &  op[0];

   // partial decode op2
   assign   sethi_or_nop = op2[2] & ~op2[1] & ~op2[0];
   
   // decode op3
   assign   op3_hi[0] = ~op3[5] & ~op3[4];
   assign   op3_hi[1] = ~op3[5] &  op3[4];
   assign   op3_hi[2] =  op3[5] & ~op3[4];
   assign   op3_hi[3] =  op3[5] &  op3[4];
   
   assign   op3_lo[0]  = ~op3[3] & ~op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[1]  = ~op3[3] & ~op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[2]  = ~op3[3] & ~op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[3]  = ~op3[3] & ~op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[4]  = ~op3[3] &  op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[5]  = ~op3[3] &  op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[6]  = ~op3[3] &  op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[7]  = ~op3[3] &  op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[8]  =  op3[3] & ~op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[9]  =  op3[3] & ~op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[10] =  op3[3] & ~op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[11] =  op3[3] & ~op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[12] =  op3[3] &  op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[13] =  op3[3] &  op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[14] =  op3[3] &  op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[15] =  op3[3] &  op3[2] &  op3[1] &  op3[0];

   //-------------------------
   // Branch and Move Controls
   //-------------------------
   // brtype
   assign dbr_inst_d = brsethi_inst & (op2[1] | op2[0]) |   // regular branch
	                     call_inst;
   assign jmpl_inst_d = arith_inst & op3_hi[3] & op3_lo[8];  // jmpl
   assign retn_inst_d = arith_inst & op3_hi[3] & op3_lo[9];  // retn
   assign ibr_inst_d = jmpl_inst_d | retn_inst_d;
   assign sethi_inst_d = brsethi_inst & sethi_or_nop;
   assign ifu_exu_sethi_inst_d = sethi_inst_d;
   
   assign dec_swl_br_done_d = (dbr_inst_d | jmpl_inst_d); // br compl.
                                                  // retn has separate
                                                  // completion signal
   assign dtu_fcl_br_inst_d = dbr_inst_d | ibr_inst_d;
   assign dec_imd_call_inst_d = call_inst;

   // MV-BR Condition
   assign   cctype_sel_imov  =  op[1] & ~op3[4];
   assign   cctype_sel_fmov  =  op[1] & op3[4];
   assign   cctype_sel_bcc  = ~op[1] &  op2[1];
   assign   cctype_sel_bpcc = ~op[1] & ~op2[1];

   mux4ds  #(3) cctype_mux(.dout  (dec_dcl_cctype_d),
			                   .in0   ({dtu_inst_d[18], dtu_inst_d[12:11]}),
			                   .in1   (dtu_inst_d[13:11]),
			                   // op2[2]=1 for fp branch
			                   .in2   ({~op2[2], 2'b00}),
			                   .in3   ({~op2[2], dtu_inst_d[21:20]}),
			                   .sel0  (cctype_sel_imov),
			                   .sel1  (cctype_sel_fmov),
			                   .sel2  (cctype_sel_bcc),
			                   .sel3  (cctype_sel_bpcc));

   //-------------
   // ALU Controls
   //-------------
   // mov bit
   assign ifu_exu_aluop_d[2] = brsethi_inst & sethi_or_nop |   // sethi
                       	    arith_inst & op3_hi[2] & op3[3];   // mov, rd

   // aluop
   assign ifu_exu_aluop_d[1] = (arith_inst & 
	                              ((op3_hi[3] & (op3_lo[0] |   // wr
                                               op3_lo[2] |   // wrpr
                                               op3_lo[3])) | // wrhpr
				                         (~op3[5] & op3[1]))         // xor, or
                                );
				
   // aluop/mov type
   assign ifu_exu_aluop_d[0] = (arith_inst & 
	                              ((op3_hi[3] & (op3_lo[0] |
                                               op3_lo[2] |
                                               op3_lo[3])) | // wr
				                         (~op3[5] & op3[0])        | // xor, and
				                         (op3_hi[2] & op3_lo[15]))   // movr
                                );
   
   // invert rs2
   assign ifu_exu_invert_d  = arith_inst &
	                      (~op3[5] & op3[2]  |   // sub, andn, orn, xorn
	                       op3_hi[2] & (op3_lo[3] | op3_lo[1])); // tag sub

   assign ifu_exu_usecin_d   = arith_inst & ~op3[5] & op3[3];   // addc, subc

   // tagged ops
   assign ifu_exu_tagop_d = arith_inst & op3_hi[2] & ~op3[3] & ~op3[2] &
	                          fcl_dtu_inst_vld_d;
   assign ifu_exu_tv_d = ifu_exu_tagop_d & op3[1];
   assign ifu_exu_muls_d  = arith_inst & op3_hi[2] & op3_lo[4] & 
	                          ~swl_dec_divbusy_e & fcl_dtu_ely_inst_vld_d;

   // memory for ibr and ldst address range check
   assign ifu_exu_range_check_other_d = mem_inst & ~prefetch; // ld, st, atom
   assign ifu_exu_range_check_jlret_d = arith_inst & op3_hi[3] &    
                                        (op3_lo[8] | op3_lo[9]); // jmpl, retn
   
   //--------------
   // SHFT Controls
   //--------------
   // enable shifter and choose shift output
   // This can be simplified a great deal if MULScc could also be
   // decoded as a shift instruction.
   // 9/26/01: No can do! Mulscc is implemented now
   assign ifu_exu_enshift_d = arith_inst & op3_hi[2] &
                       	       (op3_lo[5] | op3_lo[6] | op3_lo[7]); 
   // unsigned or signed (1 => signed)
   assign ifu_exu_shiftop_d[0] = op3[0];
   // left or right (1 => right)
   assign ifu_exu_shiftop_d[1] = op3[1];
   // shift 32b or 64b (1 => 64)
   assign ifu_exu_shiftop_d[2] = dtu_inst_d[12];   // was sh32_64


   //-------------------
   // Writeback Controls
   //-------------------
   //  write to icc/xcc
   assign ifu_exu_setcc_d = arith_inst & 
	                     (op3_hi[1] & (~op3[3] | ~op3[1] & ~op3[0]) |
	                      op3_hi[2] & (~op3[3] & ~op3[2])); // tagged op
   //  write to rd
   assign ifu_exu_wen_d = ((~rd_00) & brsethi_inst & sethi_or_nop | // sethi
	                         (~rd_00) & arith_inst &  // all single cycle insts
	                         (~op3[5] & ~op3[3]    |     // alu ops
			                      ~op3[5] & op3_lo[8]  |     // addC
			                      ~op3[5] & op3_lo[12] |     // subC
			                      op3_hi[2] &                
			                      (~op3[3] & ~op3_lo[4] |    // shft, tag, ~muls
			                       // need to kill if rd to invalid reg
			                       // all vld regs will retn in W stage
			                       op3_lo[8] & ~rs1_0f | op3_lo[10]  | // rd
                             op3_lo[9] | // rdhpr
			                       op3_lo[12] | op3_lo[15])| // mov
			                      op3_hi[3] &
			                      (op3_lo[8]  |    // jmpl
			                       op3_lo[12] |    // save
			                       op3_lo[13] |    // restore
                             op3_lo[6] & int_align_d)  // vis int align
			                      )           |    
	                         call_inst);
   
   //-----------------
   // MUL/DIV Controls
   //-----------------
   // is mul
   assign dec_swl_mul_inst_d = (arith_inst &
				                        ((op3_hi[0] &
				                          (op3_lo[9]  |      // mulx
				                           op3_lo[10] |      // umul
				                           op3_lo[11])) |    // smul
				                         (op3_hi[1] &        
				                          (op3_lo[10] |      // umulcc
				                           op3_lo[11])))     // smulcc
				                        );

   assign ifu_exu_muldivop_d[4] = dec_swl_mul_inst_d & ~swl_dec_mulbusy_e & 
                                  fcl_dtu_ely_inst_vld_d;
   
   // is div
   assign dec_swl_div_inst_d = (arith_inst &
				                        ((op3_hi[0] &
				                          (op3_lo[13]  |     // udivx
				                           op3_lo[14]  |     // udiv
				                           op3_lo[15]))  |   // sdiv
				                         (op3_hi[2] & 
				                          (op3_lo[13]   |    // sdivx
				                           op3_lo[4]))  |    // muls
				                         (op3_hi[1] &
				                          (op3_lo[14] |      // udivcc
				                           op3_lo[15])))     // sdivcc
				                        );

   assign ifu_exu_muldivop_d[3] = dec_swl_div_inst_d & ~swl_dec_divbusy_e &
				                          op3[3] & fcl_dtu_ely_inst_vld_d; // not muls
   
   // 64b or 32b (1 => 64b)
   assign ifu_exu_muldivop_d[2] = ~op3[1];

   // signed or unsigned (1 => signed)
   assign ifu_exu_muldivop_d[1] = op3_hi[2] |          // sdivx
	                                (op3[1] & op3[0]);   // smul, sdiv
   // set cc as well?
   assign ifu_exu_muldivop_d[0] = op3[4];

   //-------------------------
   // FP controls
   //-------------------------

   // portion of vis that is actually an int instruction
   assign int_align_d = (~opf[8] & ~opf[7] & ~opf[6] & ~opf[5] & 
                         opf[4] & opf[3] & ~opf[2] & ~opf[0]);
   assign ifu_exu_ialign_d = arith_inst & op3_hi[3] & op3_lo[6] &
                             int_align_d & fcl_dtu_inst_vld_d;
   

   assign fpop1_d = arith_inst & op3_hi[3] & op3_lo[4];
   assign fpop2_d = arith_inst & op3_hi[3] & op3_lo[5];
   assign visop_d = arith_inst & op3_hi[3] & op3_lo[6];
   assign fpld_d = mem_inst & op3[5] & ~op3[3] & ~op3[2];

   // FP stores don't switch out and don't block the fpu
   assign dec_swl_fpop_d = (fpop1_d | fpop2_d | fpld_d | visop_d);
   assign allfp_d = (fpop1_d | fpop2_d | fpld_d | visop_d |
	                   mem_inst & op3[5] & ~op3[3] & op3[2]);
   assign dec_swl_allfp_d = allfp_d;

   assign ifu_ffu_ldfsr_d = op3_lo[1] & op3_hi[2] & ~rd[0];
   assign ifu_ffu_ldxfsr_d = op3_lo[1] & op3_hi[2] & rd[0];	  
   assign ifu_ffu_stfsr_d = op3_lo[5] & op3_hi[2];	  

   assign ifu_ffu_fpop1_d = fpop1_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;
   assign ifu_ffu_fpop2_d = fpop2_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;
   assign ifu_ffu_visop_d = visop_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;

   assign ifu_ffu_fld_d =  mem_inst & op3[5] & ~op3[3] & ~op3[2] & 
			                     fcl_dtu_ely_inst_vld_d & ~swl_dec_fpbusy_e;
   
   assign ifu_ffu_fst_d =  mem_inst & op3[5] & ~op3[3] & op3[2] & 
		                       fcl_dtu_ely_inst_vld_d & ~swl_dec_fpbusy_e;

   // ldqf and stqf are not fpops
   assign quad_ffuop_d = (opf[1] & opf[0] & (fpop1_d | fpop2_d) |
	                        fpop1_d & opf[3] & opf[2] & // exc div
	                        ~(~opf[7] & opf[6] & ~opf[5])) &
	                         swl_dec_fp_enable_d & fcl_dtu_inst_vld_d;

   dff_s #(1) qope_ff(.din  (quad_ffuop_d),
		              .q    (ifu_ffu_quad_op_e),
		              .clk  (clk), .se(se), .si(), .so());

   // quiet traps -- flush the pipe but don't take a trap till later
//   assign dec_swl_qtrap_d = mem_inst & op3[5] & op3_lo[6] & fcl_dtu_inst_vld_d;  // stq
//   dff #(1) qtrpe_ff(.din  (dec_swl_qtrap_d),
//		   .q    (dtu_fcl_qtrap_e),
//		   .clk  (clk), .se(se), .si(), .so());

   // FP Enabled check
   assign fcc_branch_d = ~op[1] & ~op[0] & op3[5] & (op3[4] | op3[3]);
   assign fcc_mov_d = op[1] & ~op[0] & op3_hi[2] & op3_lo[12] & 
	                    ~dtu_inst_d[18];
   
   assign any_fpinst_d = allfp_d | fcc_branch_d | fcc_mov_d | 
                         arith_inst & op3_hi[2] & op3_lo[8] & rs1_13 | // rd gsr
                         arith_inst & op3_hi[3] & op3_lo[0] & rd_13;   // wr gsr
   
   assign fpdis_trap_d = any_fpinst_d & ~swl_dec_fp_enable_d & 
                         fcl_dtu_inst_vld_d;
   dff_s #(1) fpdise_ff(.din (fpdis_trap_d),
		                .q   (fpdis_trap_e),
		                .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_fpdis_e = fpdis_trap_e;

   // FRF dirty bits
   // bit 0 is the msb for double and quad
   assign dec_swl_frf_upper_d = rd[0] & (mem_inst & op3_lo[3] |  // fld
					                    fpop1_d & (opf[7] | opf[6] & opf[5]) & 
                                         (opf[3] | ~opf[2]) |
					                    fpop1_d & ~opf[7] & opf[1] & ~opf[0] |
					                    fpop2_d & opf[1] | 
                              visop_d & ~opf[0]);
   
   assign dec_swl_frf_lower_d = ~rd[0] & (mem_inst & op3_lo[3] |  // fld
					                    fpop1_d & (opf[7] | opf[6] & opf[5]) & 
                                          (opf[3] | ~opf[2]) |
					                    fpop1_d & ~opf[7] & opf[1] & ~opf[0] |
					                    fpop2_d & opf[1] | 
                              visop_d & ~opf[0]) |
				                      (fpop2_d & ~opf[1] |  // all sgl ops wrt lower
	                             fpop1_d & opf[7] & ~opf[3] & opf[2] |
                                     //bug 6470 - fdtoi,fstoi,fqtoi
	                             (fpop1_d & (opf[7:6]==2'b11) & (opf[3:2]==2'b00)) |
                                     //bug6470 - end
				                       fpop1_d & ~opf[7] & ~opf[1] & opf[0] |
                               visop_d & opf[0] |
				                       mem_inst & op3_lo[0] & op3[5]);
   
   
   //-------------------------
   // Special Reg R/W Controls
   //-------------------------
   // decode rs1
   assign rs1 = dtu_inst_d[18:14];
   assign rs1_00 = ~rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & ~rs1[0]; // Y
   assign rs1_01 = ~rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & rs1[0]; //
   assign rs1_02 = ~rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0];  // CCR
   assign rs1_05 = ~rs1[4] & ~rs1[3] & rs1[2] & ~rs1[1] & rs1[0]; // PC
   assign rs1_06 = ~rs1[4] & ~rs1[3] & rs1[2] & rs1[1] & ~rs1[0]; // fprs
   assign rs1_07 = ~rs1[4] & ~rs1[3] & rs1[2] & rs1[1] & rs1[0]; //
   assign rs1_0f = ~rs1[4] & rs1[3] & rs1[2] & rs1[1] & rs1[0];   // mem#
   assign rs1_10 = rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & ~rs1[0];   
   assign rs1_12 = rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0];
   assign rs1_13 = rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & rs1[0];
   assign rs1_14_15 = rs1[4] & ~rs1[3] & rs1[2] & ~rs1[1];   
   assign rs1_16_17 = rs1[4] & ~rs1[3] & rs1[2] & rs1[1];
   assign rs1_19 = rs1[4] & rs1[3] & ~rs1[2] & ~rs1[1] & rs1[0];
   assign rs1_1f = rs1[4] & rs1[3] & rs1[2] & rs1[1] & rs1[0];    // 
   assign rs1_1a = rs1[4] & rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0]; // THR
   assign rs1_1b = rs1[4] & rs1[3] & ~rs1[2] & rs1[1] & rs1[0];
   assign rs1_1c_1f = rs1[4] & rs1[3] & rs1[2];
   assign rs1_09_0e = ~rs1[4] & rs1[3] &          // all window mgmt regs
	              (rs1[2] & ~rs1[1] | rs1[1] & ~rs1[0] |
		             rs1[0] & ~rs1[2]);

   // decode rd
   assign rd = dtu_inst_d[29:25];
   assign rd_00 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & ~rd[0]; // mem#
   assign rd_01 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & rd[0]; // 
   assign rd_04 = ~rd[4] & ~rd[3] & rd[2] & ~rd[1] & ~rd[0]; //  tick
   assign rd_05 = ~rd[4] & ~rd[3] & rd[2] & ~rd[1] & rd[0];  //  PC
   assign rd_06 = ~rd[4] & ~rd[3] & rd[2] & rd[1] & ~rd[0]; 
   assign rd_07 = ~rd[4] & ~rd[3] & rd[2] & rd[1] & rd[0]; 
   assign rd_09 = ~rd[4] & rd[3] & ~rd[2] & ~rd[1] & rd[0]; // CWP
   assign rd_0f = ~rd[4] & rd[3] & rd[2] & rd[1] & rd[0];   // not impl
   assign rd_10 = rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & ~rd[0];   // gl
   assign rd_11 = rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & rd[0];   // pic
   assign rd_12 = rd[4] & ~rd[3] & ~rd[2] & rd[1] & ~rd[0];   // not impl
   assign rd_13 = rd[4] & ~rd[3] & ~rd[2] & rd[1] & rd[0];   // GSR
   assign rd_18 = rd[4] & rd[3] & ~rd[2] & ~rd[1] & ~rd[0]; // stick   
   assign rd_1a = rd[4] & rd[3] & ~rd[2] & rd[1] & ~rd[0]; // Thr
   assign rd_1b = rd[4] & rd[3] & ~rd[2] & rd[1] & rd[0];
   assign rd_1c_1f = rd[4] & rd[3] & rd[2];
   assign rd_1f = rd[4] & rd[3] & rd[2] & rd[1] & rd[0];
   
   assign ifu_lsu_wsr_inst_d = arith_inst & fcl_dtu_ely_inst_vld_d & 
	                       op3_hi[3] & (op3_lo[0] | op3_lo[2] | op3_lo[3]);
   assign ifu_exu_wsr_inst_d = ifu_lsu_wsr_inst_d;

   assign ifu_tlu_rsr_inst_d = arith_inst & fcl_dtu_ely_inst_vld_d & 
	                       op3_hi[2] & (op3_lo[8] & ~rs1_0f | // ~membar
                                      op3_lo[9] |           // hpr
					                            op3_lo[10]);          // pr

   assign rdsr_done_d = arith_inst & op3_hi[2] & op3_lo[8] & ~mb_inst_d;
   assign rdpr_done_d = arith_inst & op3_hi[2] & (op3_lo[10] | op3_lo[9]);
   
   // all wrpr's except cwp are fixed length
   // 
   assign wsr_fixed_inst_d = arith_inst & op3_hi[3] & 
                               (op3_lo[2] & ~rd_09 |  // wrpr exc. cwp 
	                              op3_lo[0] & ~rd_1a |  // wr exc. thr
                                op3_lo[3]);           // wrhpr
   
	                     
   dff_s #(1) wre_ff(.din (wsr_fixed_inst_d),
		             .clk (clk),
		             .q   (wsr_fixed_inst_e),
		             .se  (se), .si(), .so());

   assign wsr_inst_next_e = (~dtu_inst_anull_e) & wsr_fixed_inst_e & 
	                          fcl_dtu_inst_vld_e;
   
   dff_s #(1) wrm_ff(.din (wsr_inst_next_e),
		             .clk (clk),
		             .q   (wsr_fixed_inst_m),
		             .se  (se), .si(), .so());

   dff_s #(1) wrw_ff(.din (wsr_fixed_inst_m),
		             .clk (clk),
		             .q   (wsr_fixed_inst_w),
		             .se  (se), .si(), .so());

   assign use_rsr_d_l = ~(ifu_tlu_rsr_inst_d | ibr_inst_d | call_inst);
   
   dff_s #(1) rdsre_ff(.din (use_rsr_d_l),
		               .clk (clk),
		               .q   (ifu_exu_use_rsr_e_l),
		               .se  (se), .si(), .so());

   assign flush_inst_d = fcl_dtu_inst_vld_d & arith_inst & 
	                       op3_hi[3] & op3_lo[11];

   dff_s #(1) flsh_ff(.din (flush_inst_d),
		              .q   (ifu_tlu_flsh_inst_e),
		              .clk (clk),
		              .se  (se), .si(), .so());
   

   // If machine state is changed kill the already fetched instructions
   assign state_chg_inst_d = ifu_lsu_wsr_inst_d | flush_inst_d |
	                           ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d;

   
   dff_s #(1) schg_ff(.din (state_chg_inst_d),
		                .clk (clk),
		                .q   (state_chg_inst_e),
//		               .rst (reset),
		                .se  (se), .si(), .so());

//   assign sta_inst_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d & 
//                       (~op3[5] & ~op3[3] & op3[2] |
//			                  op3[5] & (op3_lo[4] | op3_lo[7]) |
//			                  ~op3[5] & op3_lo[14]);
   assign sta_inst_d = mem_inst & op3[4] & op3[2] & fcl_dtu_inst_vld_d & ~prefetch;

   assign sta_nostf_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d & 
                       (~op3[5] & ~op3[3] & op3[2] |
			                  ~op3[5] & op3_lo[14]);

   dff_s #(1) sta_ff (.din (sta_inst_d),
		              .clk (clk),
		              .q   (sta_inst_e),
		              .se  (se), .si(), .so());

   dff_s #(1) stanf_ff (.din (sta_nostf_d),
		                  .clk (clk),
		                  .q   (sta_nostf_e),
		                  .se  (se), .si(), .so());

  assign dec_swl_sta_inst_e = sta_nostf_e;
 
   // Mov qualification with inst_vld_e to FCL?  Done
   assign dtu_fcl_flush_sonly_e = (sta_inst_e & lsu_ifu_ldsta_internal_e |
                                   state_chg_inst_e);

   dff_s #(1) ds_ff(.din (fcl_dec_dslot_s),
                  .q   (dslot_d),
                  .clk (clk), .se(se), .si(), .so());

   // suppress ifetch if arch state changes in delay slot (if not 
   // suppressed, it may cause in error in the L2 for an unmapped 
   // address). 
//   assign dtu_ifq_kill_latest_d = ifu_lsu_wsr_inst_d | flush_inst_d |
//	                              ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d |  
//                                sta_inst_d;
   assign dtu_ifq_kill_latest_d = (((arith_inst & op3_hi[3] & 
                                     (op3_lo[2] | op3_lo[3] | op3_lo[0]) |// wr
                                     mem_inst & op3[4] & op3[2]) & 
                                    fcl_dtu_ely_inst_vld_d) |
                                   fcl_dec_intr_vld_d) & dslot_d; // in DS

//   assign kill_for_sta_d = mem_inst & op3[4] & op3[2] & 
                           // ~op3[5] &  // sta - excl stf and pref
//                           fcl_dtu_ely_inst_vld_d & dslot_d; // in DS
   
//   dff #(1) kfste_ff(.din (kill_for_sta_d),
//                     .q   (kill_for_sta_e),
//                     .clk (clk), .se(se), .si(), .so());
//   assign dec_fcl_kill4sta_e = kill_for_sta_e;
   
   assign rd_ifusr_d = arith_inst & op3_hi[2] & 
	                     (op3_lo[9] & rs1_06    |  // rdhpr - ver
			                  op3_lo[8] & (rs1_05 |    // rdsr - pc
				                             rs1_1a |    // rdsr - thr
				                             rs1_06))  | // rdsr - fprs
		                     jmpl_inst_d |                    // jmpl
	                     call_inst;                         // call
   
   assign rd_exusr_d = arith_inst & op3_hi[2] &
	        (op3_lo[10] & rs1_09_0e |         // rdpr (wind)
			     op3_lo[8] & (rs1_00 | rs1_02));  // rdsr (y + ccr)

   assign rd_ffusr_d = arith_inst & op3_hi[2] &
			                 op3_lo[8] & rs1_13;  // rdsr (gsr)
   
   dff_s #(1) ifusr_ff(.din  (rd_ifusr_d),
		               .clk  (clk),
		               .q    (rd_ifusr_e),
		               .se   (se), .si(), .so());
   dff_s #(1) ffusr_ff(.din  (rd_ffusr_d),
		               .clk  (clk),
		               .q    (rd_ffusr_e),
		               .se   (se), .si(), .so());
   dff_s #(1) exusr_ff(.din  (rd_exusr_d),
		               .clk  (clk),
		               .q    (rd_exusr_e),
		               .se   (se), .si(), .so());

   // make sure they are exclusive
   assign ifu_exu_rd_ifusr_e = rd_ifusr_e;
   assign ifu_exu_rd_exusr_e = rd_exusr_e;
   assign ifu_exu_rd_ffusr_e = rd_ffusr_e;

   // choose which of IFU special regs should be read
   // call, jmpl or rdpc (05) => pc
   assign dec_fcl_rdsr_sel_pc_d = ~dtu_inst_d[31] | op3_hi[3] | ~rs1[1] & rs1[0];
   // read thread conf (1a) or fprs (06)
   assign dec_fcl_rdsr_sel_thr_d = dtu_inst_d[31] & op3_hi[2] & op3_lo[8] & ~rs1[0];
   // else version reg (rdhpr 06)

   //   dff #(1) rdfprs_ff(.din (rs1[4]),
   //		    .q   (dec_swl_rdsr_sel_thr_e),
   //		    .clk (clk), .se(se), .si(), .so());
   assign dec_swl_rdsr_sel_thr_d = rs1[4];

   assign wrt_tcr_d = arith_inst & fcl_dtu_inst_vld_d & 
	                    op3_hi[3] & op3_lo[0] & rd_1a;

   dff_s #(1) tcre_ff(.din  (wrt_tcr_d),
		                .clk  (clk),
		                .q    (wrt_tcr_e),
		                .se   (se), .si(), .so());

   assign wrt_tcr_qual_e = wrt_tcr_e & (~dtu_inst_anull_e) & 
					                               fcl_dtu_inst_vld_e;

   dff_s #(1) tcrm_ff(.din  (wrt_tcr_qual_e),
		              .clk  (clk),
		              .q    (wrt_tcr_m),
		              .se   (se), .si(), .so());
   
   dff_s #(1) tcrw_ff(.din  (wrt_tcr_m),
		              .clk  (clk),
		              .q    (dec_swl_wrt_tcr_w),
		              .se   (se), .si(), .so());

   // FPRS write
   assign wrt_fprs_d = arith_inst & fcl_dtu_inst_vld_d & 
	                     op3_hi[3] & op3_lo[0] & rd_06;
   dff_s #(1) fprse_ff(.din  (wrt_fprs_d),
		               .clk  (clk),
		               .q    (wrt_fprs_e),
		               .se   (se), .si(), .so());
   assign wrt_fprs_qual_e = wrt_fprs_e & (~dtu_inst_anull_e) & 
					                                 fcl_dtu_inst_vld_e;
   dff_s #(1) fprsm_ff(.din  (wrt_fprs_qual_e),
		               .clk  (clk),
		               .q    (wrt_fprs_m),
		               .se   (se), .si(), .so());
   dff_s #(1) fprsw_ff(.din  (wrt_fprs_m),
		               .clk  (clk),
		               .q    (dec_swl_wrtfprs_w),
		               .se   (se), .si(), .so());

   //----------------
   // RF/RML Controls
   //----------------
   // Reg Valid Signals for doing ECC

   //bug6777 - cas decode is incorrect
   //         ~(op3_hi[3] & dtu_inst_d[22] & mem_inst); // CAS
   assign ifu_exu_useimm_d = ~dtu_inst_d[31] | 
	                      dtu_inst_d[13] & 
	                     ~(op3_hi[3] & dtu_inst_d[22] & ~op3[0] & mem_inst); // CAS

   // alternately try: ~ren2_d | ~23 | ~22
   assign rs1_vld_d = (brsethi_inst & op2[1] & op2[0] |
		                   arith_inst & (~op3[5] |
				                             op3_hi[2] & ~op3[3] |
				                             op3_hi[2] & op3_lo[13] |
				                             op3_hi[2] & op3_lo[15] |
				                             op3_hi[3] & op3_lo[0]  |
				                             op3_hi[3] & op3_lo[2]  |
				                             op3_hi[3] & op3_lo[3]  |
				                             op3_hi[3] & op3_lo[5] & 
                                     ~opf[4] & ~opf[3] & opf[2] |  // fmovr
				                             op3_hi[3] & op3_lo[6] & int_align_d  |
				                             op3_hi[3] & op3[3] & ~op3[2] |
				                             op3_hi[3] & op3[3] & ~op3[1]) |
		                   mem_inst & (~op3[5] |
				                           ~op3[3] |
				                           op3[4] & op3[3] & op3[2]));

   assign ifu_exu_rs1_vld_d = rs1_vld_d;

   assign rs2_vld_d = (arith_inst & (~op3[5] |
				                             op3_hi[2] & (~op3[3] | op3[2]) |
				                             op3_hi[3] & op3_lo[0]  |
				                             op3_hi[3] & op3_lo[2]  |
				                             op3_hi[3] & op3_lo[3]  |
				                             op3_hi[3] & op3_lo[6] & int_align_d  |
				                             op3_hi[3] & op3[3] & ~op3[2] |
				                             op3_hi[3] & op3[3] & ~op3[1]) &
		                               ~dtu_inst_d[13] |
		                   mem_inst & (~op3[5] |
				                           ~op3[3]) & ~dtu_inst_d[13] |
		                   mem_inst & op3_hi[3] & (op3_lo[12] |   // cas
					                                     op3_lo[14]));

   assign ifu_exu_rs2_vld_d = rs2_vld_d;

   assign rs3_vld_d = mem_inst & (~op3[5] & ~op3[3] & op3[2] | // all st
				                          ~op3[5] & op3[3] & op3[2] | // swp,stx,ldstub
				                          op3_hi[3] & (op3_lo[12] |   // cas
					                                     op3_lo[14])) |
                      arith_inst & (op3_hi[2] & (op3_lo[12] | 
                                                 op3_lo[15]));
   
   // for std and stq(=stda) & ~stf
   assign rs4_vld_d = mem_inst & ~op3[5] & op3_lo[7];

   // rs3even = rs4 + rs3 & ~rd[0]
   // rs3odd = rs4 + rs3 & rd[0]
   // needs both to distinguish std
   assign ifu_exu_rs3e_vld_d = rs4_vld_d | rs3_vld_d & ~rd[0];
   assign ifu_exu_rs3o_vld_d = rs4_vld_d | rs3_vld_d & rd[0];

   // RML control signals
   assign ifu_exu_save_d = arith_inst & op3_hi[3] & op3_lo[12] & 
                           fcl_dtu_inst_vld_d;
   assign ifu_exu_restore_d = arith_inst & op3_hi[3] & fcl_dtu_inst_vld_d &
              	        (op3_lo[13] |       // restore
		                     op3_lo[9]);        // return
   assign ifu_exu_return_d = arith_inst & op3_hi[3] & op3_lo[9] & 
                             fcl_dtu_inst_vld_d;   

   assign save_retn_done_d = arith_inst & op3_hi[3] & (op3_lo[12] | op3_lo[9]);
   assign saved_d = arith_inst & op3_hi[3] & op3_lo[1] & ~dtu_inst_d[25] & 
                    fcl_dtu_inst_vld_d;
   assign restored_d = arith_inst & op3_hi[3] & op3_lo[1] & dtu_inst_d[25] & 
                     fcl_dtu_inst_vld_d;
   assign flushw_d = arith_inst & op3_hi[2] & op3_lo[11] & fcl_dtu_inst_vld_d;
   
   dff_s #(1) savd_ff(.din  (saved_d),
		              .clk  (clk),
		              .q    (ifu_exu_saved_e),
		              .se   (se), .si(), .so());
   dff_s #(1) restd_ff(.din  (restored_d),
		               .clk  (clk),
		               .q    (ifu_exu_restored_e),
		               .se   (se), .si(), .so());
   dff_s #(1) flushw_ff(.din  (flushw_d),
		                .clk  (clk),
		                .q    (ifu_exu_flushw_e),
		                .se   (se), .si(), .so());

   //-----------------------
   // TLU Controls and Traps
   //-----------------------
   // Done/Retry
   assign ifu_tlu_done_inst_d = arith_inst & op3_hi[3] & op3_lo[14] &
	                        fcl_dtu_ely_inst_vld_d & 
	                        ~dtu_inst_d[25];   // inst_d[25] = lsb of fcn
   assign ifu_tlu_retry_inst_d = arith_inst & op3_hi[3] & op3_lo[14] & 
	                        fcl_dtu_ely_inst_vld_d & dtu_inst_d[25];

   // SIR
   assign sir_inst_d = arith_inst & op3_hi[3] & op3_lo[0] & 
	               rs1_00 & rd_0f & dtu_inst_d[13];

//   assign kill_sir_d = sir_inst_d & ~(fcl_dtu_privmode_d | fcl_dtu_hprivmode_d);
//bug 6484 - flag sir instrn. to tlu only in hpriv mode
//   assign flag_sir_d = sir_inst_d & (fcl_dtu_privmode_d | fcl_dtu_hprivmode_d);

   assign flag_sir_d = sir_inst_d & fcl_dtu_hprivmode_d;

   dff_s #(1) sire_ff(.din (flag_sir_d),
		              .q   (sir_inst_e),
		              .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_sir_inst_e = sir_inst_e;

//bug 6484 - kill sir instrn. to tlu if bits other than opcode bits cause illegal instrn.
//   assign flag_sir_e = sir_inst_e & fcl_dtu_inst_vld_e & ~dtu_inst_anull_e;

   assign flag_sir_e = sir_inst_e & fcl_dtu_inst_vld_e & ~dtu_inst_anull_e & ~ill_inst_e;

   dff_s #(1) sirm_ff(.din (flag_sir_e),
		              .q   (ifu_tlu_sir_inst_m),
		              .clk (clk), .se(se), .si(), .so());
   

   // Privileged opcode trap
   assign fcn0 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1];

	 //op3_lo[0] & rd[4] & ~(rd_12 | rd_13 | 
	 //rd[3] & ~rd_1a |
   //rd_1f)) | 

   assign privop_d = (op3_hi[3] & (op3_lo[14] | // done/retr
				                           op3_lo[2] |         // wrpr
                                   // & (~rd[4] & ~rd_0f | rd_10) |
                                   // op3_lo[3] |         // wrhpr
                                   // & valid_hp_rd_d |  
				                           op3_lo[1] |  // savd,restd
				                           op3_lo[0] & ((rd[4] & ~(rd_11 | rd_12 | rd_13 | rd_1b |
							                                             rd[3] & rd[2])) |
                                                rd_04)) | // wrasr
		                                                   
		                  op3_hi[2] & (op3_lo[10] |        // rdpr
                                   // & (~rs1[4] | rs1_10 | rs1_1f) |
                                   // op3_lo[9] |         // rdhpr
                                   // & valid_hp_rs_d |
				                           op3_lo[8] &           // rdasr & ~mem#
				                           (rs1_10 | rs1_16_17 | // perf + sftint
                                    rs1_19 | rs1_1a))    // stick, thrd stat
		                  ) & arith_inst & ~(fcl_dtu_privmode_d | 
                                         fcl_dtu_hprivmode_d);

   // hp regs 0,1,3 and 5, 6 and 1f are implemented
   // 6 is read only

   assign valid_hp_rd_d = (~rd[4] & ~rd[3] & rd[0] & 
                           (~rd[2] | ~rd[1]) |      // 1,3,5
                           rd_00 | rd_1f );          // 0, 1f
   assign valid_hp_rs_d = (~rs1[4] & ~rs1[3] & rs1[0] & 
                           (~rs1[2] | ~rs1[1]) |
                           rs1_00 | rs1_06 | rs1_1f);
   
   assign hprivop_d = arith_inst & ~fcl_dtu_hprivmode_d & 
                      (op3_hi[3] & op3_lo[3] |      // wrhpr
                       // & valid_hp_rd_d 
                       op3_hi[2] & op3_lo[9] |      // rdhpr
                       // & valid_hp_rs_d 
                       // bug 6484 ----
                       sir_inst_d |
                       //  ----
                       op3_hi[3] & op3_lo[0] & 
                          (rd_04 | rd_18) & fcl_dtu_privmode_d |   // wrsr s/tick
                       op3_hi[3] & op3_lo[2] & 
                          rd_04 & fcl_dtu_privmode_d);             // wrpr
          
   dff_s #(1) prope_ff(.din (privop_d),
		                 .q   (privop_e),
		                 .clk (clk), .se(se), .si(), .so());

   dff_s #(1) hprope_ff(.din (hprivop_d),
		                 .q   (hprivop_e),
		                 .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_privop_e = privop_e & ~hprivop_e;
//   assign dtu_fcl_hprivop_e = hprivop_e & ~dtu_inst_anull_e;   

   // Illegal Instruction Trap
   // when they are accessed.  
   assign inv_reg_access_d = arith_inst & (op3_hi[2] & op3_lo[8] &    // rd asr
					                                 (rs1_01 | rs1_07 |         // 1, 7
                                            ~rs1[4] & rs1[3] & ~rs1_0f |  // 8-E, F=mem#
					                                  rs1_12 | rs1_14_15 |      // 13 is gsr
                                                                   // 14-15 are WO
                                            rs1_1b | 
                                            rs1_1c_1f) |
   
					                                 op3_hi[3] & op3_lo[0] &   // wr asr
					                                 (rd_01 | rd_05 | rd_07 |
                                            ~rd[4] & rd[3] & ~rd_0f | // 8-E, F is sir
					                                  rd_12 | rd_1b | 
                                            rd_1c_1f)
                                           );

   // reserved field checking (more done in ill_inst check below)
   assign inst12_5_nonzero_d = (|dtu_inst_d[12:5]);
   assign inst11_8_nonzero_d = (|dtu_inst_d[11:8]);
   assign inst9_5_nonzero_d = (|dtu_inst_d[9:5]);
   assign rs2_nonzero_d = (|dtu_inst_d[4:0]);

   // rsv check is not complete, but most of the important 
   // holes are covered
   assign rsvchk_fail_d = (arith_inst & ((~op3[5] |  // arith
                                          op3_hi[2] & op3_lo[13] | // sdivx
                                          op3_hi[2] & ~op3[3] & ~op3[2] | // tag
                                          op3_hi[2] & op3_lo[4] |  // mulscc
                                          op3_hi[3] & op3_lo[11] | // flsh
                                          op3_hi[3] & op3[3] & ~op3[1]) & // sav,jmp
                                         ~dtu_inst_d[13] & inst12_5_nonzero_d |
   
                                         op3_hi[2] & (op3[3] & ~op3[2] &  // rd/rdpr
                                                      ~(rs1_0f & 
                                                        dtu_inst_d[13]) | // ~mem#
                                                      op3_lo[11]) &  // flshw
                                         (inst12_5_nonzero_d | 
                                          rs2_nonzero_d | 
                                          dtu_inst_d[13]) |
   
                                         op3_hi[3] & ~op3[3] & ~op3[2] & // wr/pr
                                         ~rd_0f &  // ~sir
                                         ~dtu_inst_d[13] & inst12_5_nonzero_d |
   
				                                 op3_hi[2] & op3_lo[12] &  // movcc
                                         ~dtu_inst_d[13] & 
                                         (inst9_5_nonzero_d | dtu_inst_d[10]) |
   
                                         op3_hi[2] & op3_lo[15] &  // movr
                                         ~dtu_inst_d[13] & 
                                         inst9_5_nonzero_d |

                                         op3_hi[3] & op3_lo[11] &  // flsh
                                         ~rd_00 |

                                         op3_hi[2] & op3_lo[11] &  // flshw
                                         (~rd_00 | ~rs1_00) |

				                                 op3_hi[2] & 
                                         (op3_lo[5] | op3_lo[6] | 
                                          op3_lo[7]) & // shft
                                         (inst11_8_nonzero_d |
                                          dtu_inst_d[7] |
                                          dtu_inst_d[6] |
                                          dtu_inst_d[5] & (~dtu_inst_d[12] |
                                                           ~dtu_inst_d[13]))
                                         ) |
   
		                       mem_inst & (~op3[4] & ~dtu_inst_d[13] &  // ld/st
                                       inst12_5_nonzero_d |
                                       op3_hi[3] & 
                                       (op3_lo[12] | op3_lo[14]) &  // cas
                                       dtu_inst_d[13] & inst12_5_nonzero_d) |
				       
				       ((op[1] & ~op[0]) & (op3[5] & op3[4] & op3[3] & ~op3[2] & ~op3[1] & op3[0]) & |rd) // RETURN(rd != 0), bug 4490

                           );
   


   assign ill_inst_d = (brsethi_inst & (~op2[2] & ~op2[1] & ~op2[0] |  // ill inst
					                              op2[2] & op2[1] & op2[0] | // null
					                              op2[1] & op2[0] &  // wrong bpr cond
					                              (~dtu_inst_d[25] & ~dtu_inst_d[26] |
                                         dtu_inst_d[28]) | // b28 has to be 0
					                              ~op2[2] & ~op2[1] & op2[0] & // bpcc
					                              dtu_inst_d[20]) |
			                  arith_inst & (op3_hi[1] & (op3_lo[9] | op3_lo[13]) |
				                              op3_hi[3] & (op3_lo[15] | // null
						                                       op3_lo[7]) | // impdep2
				                              op3_hi[3] & op3_lo[14] & 
				                              (~fcn0 | fcl_dtu_tlzero_d |
                                       rs2_nonzero_d | inst12_5_nonzero_d |
                                       dtu_inst_d[13] | ~rs1_00) |  // done/retr
				                              op3_hi[2] & op3_lo[12] & // movcc
				                              dtu_inst_d[18] & dtu_inst_d[11] |
				                              op3_hi[2] & op3_lo[15] &  // movr
				                              ~dtu_inst_d[11] & ~dtu_inst_d[10] |
				                              op3_hi[2] & op3_lo[14] | // popc
				                              op3_hi[2] & op3_lo[9] &  //rdhpr
                                      (~valid_hp_rs_d | rs1_01 & fcl_dtu_tlzero_d) |
				                              op3_hi[2] & op3_lo[10] &      // rdpr
				                              (rs1[4] & ~rs1_10 | // not gl
                                       rs1_0f | 
				                               ~rs1[4] & ~rs1[3] & ~rs1[2] & fcl_dtu_tlzero_d) |
				                              op3_hi[2] & op3_lo[8] & 
                                      (rs1_0f & (~rd_00 |
                                                 dtu_inst_d[12] |
                                                 dtu_inst_d[7] |
                                                 inst11_8_nonzero_d)) | // mem#
				                              op3_hi[3] & op3_lo[1] & 
                                      (~fcn0 | ~rs1_00 | rs2_nonzero_d |
                                       inst12_5_nonzero_d |
                                       dtu_inst_d[13]) | // savd, restd
				                              op3_hi[3] & op3_lo[10] & 
                                      (inst11_8_nonzero_d |
                                       dtu_inst_d[7] & 
                                       ~(fcl_dtu_privmode_d |
                                         fcl_dtu_hprivmode_d) |
                                       dtu_inst_d[29] |
                                       ~dtu_inst_d[13] & (dtu_inst_d[6] |
                                                          dtu_inst_d[5])) |// tcc
                                      op3_hi[3] & op3_lo[3] &   // wrhpr
                                      (~valid_hp_rd_d | rd_01 & fcl_dtu_tlzero_d) |
				                              op3_hi[3] & op3_lo[2] &   // wrpr
				                              (rd[4] & ~rd_10 | rd_0f | // gl=0x10
				                               ~rd[4] & ~rd[3] & ~rd[2] & fcl_dtu_tlzero_d) |
				                              op3_hi[3] & op3_lo[0] &  
				                              (rd_0f & ~(rs1_00 & dtu_inst_d[13]))  // sir
                                      ) |
			                  mem_inst & (~op3[5] & op3_lo[12] |
				                            op3[5] & (op3_lo[2] | op3_lo[6]) | // stqf, ldqf
				                            op3[5] & op3[3] & ~op3[2] |
				                            op3_hi[2] & (op3_lo[12] | 
						                                     op3_lo[14] | op3_lo[15]) |
				                            op3_hi[3] & (op3_lo[1] | op3_lo[5] |
						                                     op3_lo[15]) |    //  null
				                            ~op3[5] & op3_lo[3] & rd[0] | // ldd w/ odd rd
				                            op3[5] & op3_lo[1] & ~fcn0 |  // ldfsr
				                            op3[5] & op3_lo[13] & // prefetch
				                              illegal_prefetch |
				                            op3[5] & op3_lo[5] & ~fcn0 | // stfsr
				                            ~op3[5] & op3_lo[7] & rd[0])  | // std w/ odd rd
			                  inv_reg_access_d |
                        rsvchk_fail_d);
   
   dff_s #(1) illinste_ff(.din (ill_inst_d),
		                  .q   (ill_inst_e),
		                  .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_illinst_e = (ill_inst_e | 
//                               imask_hit_e |
                               hprivop_e);
   
				    
   //-------------
   // LSU Controls
   //-------------
   // prefetch
   assign prefetch    = op3_lo[13] & op3[5];

   assign impl_prefetch = ~rd[4] & ~rd[3] & ~rd[2] | // 0-3
                           rd[4] & ~rd[3];           // 10-17 (hex)
   assign noop_prefetch = rd_04 | rd[4] & rd[3];     // 4, 18-1f
      
   assign illegal_prefetch = ~rd[4] & rd[2] & (rd[1] | rd[0]) | // 5-7
                             ~rd[4] & rd[3];                    // 8-f
   
   assign prefetch_d = mem_inst & prefetch & impl_prefetch & 
                       fcl_dtu_inst_vld_d;
   assign pref_done_d = mem_inst & prefetch & noop_prefetch;

   assign dec_swl_ll_done_d = (pref_done_d | rdsr_done_d | rdpr_done_d |
                               save_retn_done_d);

   // alt space
   assign lstype_d[2] = mem_inst & op3[4] & fcl_dtu_inst_vld_d;
   // store
   assign lstype_d[1] = mem_inst & op3[2] & ~prefetch & fcl_dtu_inst_vld_d &
                        ~quad_ffuop_d;
   // load
   assign lstype_d[0] = mem_inst & ~prefetch & fcl_dtu_inst_vld_d &
	                      (~op3[2] | op3[3]) & (~op3_lo[14] | op3[5]) &
                        ~quad_ffuop_d;

   
   // only the stda instruction needs to be flagged
   assign dec_swl_std_inst_d = mem_inst & op3_hi[1] & op3_lo[7] &
	                             fcl_dtu_inst_vld_d;
   
   assign sext_d = op3[3] & ~op3[2]; // load sign extension
   assign ldstub_d = mem_inst & ~op3[5] & op3_lo[13] & fcl_dtu_inst_vld_d;
   assign casa_d = mem_inst & op3[5] & (op3_lo[12] | op3_lo[14]) & 
                                         fcl_dtu_inst_vld_d;
   assign swap_d = mem_inst & op3_lo[15] & fcl_dtu_inst_vld_d;

   // load inst for speculation
   // fp loads are not speculated on
   // ldd is not speculated on
   assign dec_swl_ld_inst_d = mem_inst & ~op3[2] & 
	                            ~op3[5] & ~op3_lo[3];

   // store, atomic or flush inst for stb flow control
   // TBD: no need to full decode this if timing is a problem
   assign dec_swl_st_inst_d = mem_inst & op3[2] |   // st, pref, cas, ldstb
                              arith_inst & op3_hi[3] & op3_lo[11];  // flsh
   
   // size(out) 00-b 01-h 10-w 11-x/q/d
   assign lssize_d[0] =  (op3[1] & ~op3_lo[15]) |   // stx,ld/sth,ld/stq, 
                                                    // ldx, ldd, std, ~swap
			                     op3[5] & (op3_lo[1] | op3_lo[5]) & rd[0]; // ldxfsr
   

   assign lssize_d[1] =  ~(op3[1]^op3[0])      |  // ~ld/st b,h
                          (op3[5] & op3_lo[2]) |  // ld/stq 
                          op3_lo[14]           |  // stx, casx
	                        op3_hi[2] & (op3_lo[1] | op3_lo[5]);  // ldst fsr

   assign ifu_ffu_ldst_size_d = ~(op3[1] & op3[0]); // ldf, stf
//   assign ifu_ffu_ldst_size_d[1] = op3[1] & op3[0];    // lddf, stdf
   

   assign ldst_fp_d   =  op3[5] & ~op3[3] & fcl_dtu_inst_vld_d & 
                         ~swl_dec_fpbusy_e;

   assign ldst_dbl_d  =  (~op3[3] & op3[1] & op3[0] | // ldd(f), std(f)
	                        op3[5] & (op3_lo[2] | op3_lo[6])) &   // ldq, stq
			                     fcl_dtu_inst_vld_d;

   // mem bar
   assign mb_mask_d = dtu_inst_d[1] |   // #storeload
	                    dtu_inst_d[5] |   // #memissue
  	                  dtu_inst_d[6];    // #sync
   
   assign mb_inst_d = arith_inst & op3_hi[2] & op3_lo[8] & 
	                    rs1_0f & rd_00 & fcl_dtu_inst_vld_d & 
	                    dtu_inst_d[13] & mb_mask_d;


   dff_s #(3) lstype_reg(.din (lstype_d),
		                 .clk (clk),
		                 .q   (lstype_e),
		                 .se  (se), .si(), .so());
   dff_s #(2) lssize_reg(.din (lssize_d),
		                 .clk (clk),
		                 .q   (ifu_lsu_ldst_size_e),
		                 .se  (se), .si(), .so());
   dff_s #(1) lsfp_reg(.din (ldst_fp_d),
		               .clk (clk),
		               .q   (ifu_lsu_ldst_fp_e),
		               .se  (se), .si(), .so());
   dff_s #(1) lsdbl_reg(.din (ldst_dbl_d),
		                .clk (clk),
		                .q   (ifu_lsu_ldst_dbl_e),
		                .se  (se), .si(), .so());

   dff_s #(1) sext_reg(.din(sext_d),
                     .clk(clk),
                     .q(ifu_lsu_sign_ext_e),
                     .se(se), .si(), .so());
   dff_s #(1) casa_reg(.din(casa_d),
                     .clk(clk),
                     .q(casa_e),
                     .se(se), .si(), .so());
   dff_s #(1) ldstub_reg(.din(ldstub_d),
                       .clk(clk),
                       .q(ifu_lsu_ldstub_e),
                       .se(se), .si(), .so());
   dff_s #(1) swap_reg(.din(swap_d),
                     .clk(clk),
                     .q(ifu_lsu_swap_e),
                     .se(se), .si(), .so());

   dff_s #(1) pfe_ff(.din (prefetch_d),
                   .q   (prefetch_e),
                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) mb_ff(.din (mb_inst_d),
		            .q   (mb_inst_e),
		            .clk (clk),
                .se(se), .si(), .so());

   assign ifu_lsu_casa_e = casa_e;
   assign ifu_exu_casa_d = casa_d;

//   assign ifu_lsu_ld_inst_e = lstype_e[0] & (~dtu_inst_anull_e) & 
//			                          ~ifu_ffu_quad_op_e & fcl_dtu_inst_vld_e;
//   assign ifu_lsu_st_inst_e = lstype_e[1] & (~dtu_inst_anull_e) & 
//			                          ~ifu_ffu_quad_op_e & fcl_dtu_inst_vld_e;

   assign ifu_lsu_ld_inst_e = lstype_e[0];
   assign ifu_lsu_st_inst_e = lstype_e[1];

   // temporary
//   assign ifu_lsu_alt_space_e = lstype_e[2] & ~dtu_inst_anull_e & 
//	                              fcl_dtu_inst_vld_e;

   assign ifu_lsu_alt_space_e = lstype_e[2];
   assign ifu_lsu_alt_space_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d;
   assign ifu_tlu_alt_space_d = op3[4] & fcl_dtu_ely_inst_vld_d;
//   assign ifu_lsu_imm_asi_vld_d = op3[4] & ~dtu_inst_d[13];
   assign ifu_lsu_memref_d = mem_inst & fcl_dtu_ely_inst_vld_d;
   
   assign ifu_tlu_mb_inst_e = mb_inst_e & ~dtu_inst_anull_e & 
	                            fcl_dtu_inst_vld_e;

   assign ifu_lsu_pref_inst_e = fcl_dtu_inst_vld_e & prefetch_e &
                                ~dtu_inst_anull_e;

   //------------
   // IMASK
   //------------
   assign rs2_hit = (dtu_inst_d[4:0] == erb_dtu_imask[4:0]);
   assign opf_hit = (dtu_inst_d[12:5] == erb_dtu_imask[12:5]);
   assign ibit_hit = (dtu_inst_d[13] == erb_dtu_imask[13]);
   assign rs1_hit = (dtu_inst_d[18:14] == erb_dtu_imask[18:14]);
   assign op3_hit = (dtu_inst_d[24:19] == erb_dtu_imask[24:19]);
   assign rd_hit = (dtu_inst_d[29:25] == erb_dtu_imask[29:25]);
   assign op_hit = (dtu_inst_d[31:30] == erb_dtu_imask[31:30]);

   assign imask_hit = (rs2_hit  | ~erb_dtu_imask[32]) &
                      (opf_hit  | ~erb_dtu_imask[33]) &
                      (ibit_hit | ~erb_dtu_imask[34]) &
                      (rs1_hit  | ~erb_dtu_imask[35]) &
                      (op3_hit  | ~erb_dtu_imask[36]) &
                      (rd_hit   | ~erb_dtu_imask[37]) &
                      (op_hit   | ~erb_dtu_imask[38]) &
                      (|erb_dtu_imask[38:32]) & 
                      fcl_dtu_inst_vld_d;
   
   dff_s #(1) imsk_ff(.din (imask_hit),
		              .q   (imask_hit_e),
		              .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_imask_hit_e = imask_hit_e & swl_dec_ibe_e;
   

   //-------------
   // SPU Controls
   //-------------

//   assign scpy_inst_d = arith_inst & op3_hi[3] & op3_lo[7] & // use impdep 2
//	                ~dtu_inst_d[13] & dtu_inst_d[12];    // i=0 always
//   assign scmp_inst_d = arith_inst & op3_hi[3] & op3_lo[7] & 
//	                ~dtu_inst_d[13] & ~dtu_inst_d[12];
//
//   dff #(1) scpy_ff (.din (scpy_inst_d),
//		   .clk (clk),
//		   .q   (scpy_inst_e),
//		   .se  (se), .si(), .so());
//
//   assign ifu_spu_scpy_inst_e = scpy_inst_e & ~dtu_inst_anull_e & 
//	                        fcl_dtu_inst_vld_e;
//   
//   dff #(1) scmp_ff (.din (scmp_inst_d),
//		   .q   (scmp_inst_e),
//		   .clk (clk), .se  (se), .si(), .so());
//
//   assign ifu_spu_scmp_inst_e = scmp_inst_e & ~dtu_inst_anull_e & 
//	                        fcl_dtu_inst_vld_e;
//
//
   
endmodule // sparc_ifu_dec

// Local Variables:
// verilog-library-directories:("../rtl" ".")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_errctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_errctl
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module sparc_ifu_errctl(/*AUTOARG*/
   // Outputs
   erc_erd_pgsz_b0, erc_erd_pgsz_b1, ifu_lsu_asi_rd_unc, 
   ifu_lsu_ldxa_tid_w2, ifu_lsu_ldxa_data_vld_w2, 
   ifu_lsu_fwd_data_vld, ifu_lsu_error_inj, ifu_exu_ecc_mask, 
   ifu_exu_inj_irferr, ifu_ffu_inj_frferr, ifu_exu_nceen_e, 
   ifu_lsu_nceen, ifu_spu_nceen, erb_fcl_spu_uetrap, 
   erb_ifq_itlberr_s1, erb_ifq_ifeterr_d1, erb_dtu_ifeterr_d1, 
   erb_fcl_itlb_ce_d1, erb_fcl_ce_trapvec, erb_fcl_ue_trapvec, 
   erb_fcl_ifet_uevec_d1, erc_erd_errstat_asidata, 
   erc_erd_errinj_asidata, erc_erd_erren_asidata, 
   erc_erd_eadr0_sel_irf_l, erc_erd_eadr0_sel_itlb_l, 
   erc_erd_eadr0_sel_frf_l, erc_erd_eadr0_sel_lsu_l, 
   erc_erd_asiway_s1_l, erc_erd_eadr1_sel_pcd1_l, 
   erc_erd_eadr1_sel_l1pa_l, erc_erd_eadr1_sel_l2pa_l, 
   erc_erd_eadr1_sel_other_l, erc_erd_eadr2_sel_mx1_l, 
   erc_erd_eadr2_sel_wrt_l, erc_erd_eadr2_sel_mx0_l, 
   erc_erd_eadr2_sel_old_l, erc_erd_asi_thr_l, 
   erc_erd_asisrc_sel_icd_s_l, erc_erd_asisrc_sel_misc_s_l, 
   erc_erd_asisrc_sel_err_s_l, erc_erd_asisrc_sel_itlb_s_l, 
   erc_erd_errasi_sel_en_l, erc_erd_errasi_sel_stat_l, 
   erc_erd_errasi_sel_inj_l, erc_erd_errasi_sel_addr_l, 
   erc_erd_miscasi_sel_ict_l, erc_erd_miscasi_sel_imask_l, 
   erc_erd_miscasi_sel_other_l, erc_erd_ld_imask, erb_reset, so, 
   // Inputs
   rclk, se, si, arst_l, grst_l, erd_erc_tte_pgsz, icv_itlb_valid_f, 
   fcl_erb_ievld_s1, fcl_erb_tevld_s1, fcl_erb_immuevld_s1, 
   fcl_erb_inst_issue_d, fcl_erb_inst_vld_d1, ifu_tlu_inst_vld_w, 
   ifu_lsu_thrid_s, fcl_erb_asi_tid_f, ifq_fcl_asi_tid_bf, 
   fcl_erb_clear_iferr, fcl_erb_itlbrd_vld_s, fcl_erb_itlbrd_data_s, 
   erd_erc_tagpe_s1, erd_erc_nirpe_s1, erd_erc_fetpe_s1, 
   erd_erc_tlbt_pe_s1, erd_erc_tlbd_pe_s1, tlu_lsu_pstate_priv, tlu_hpstate_priv,
   lsu_ifu_dtlb_data_su, lsu_ifu_dtlb_data_ue, lsu_ifu_dtlb_tag_ue, 
   lsu_ifu_dcache_data_perror, lsu_ifu_dcache_tag_perror, 
   lsu_ifu_l2_unc_error, lsu_ifu_l2_corr_error, lsu_ifu_io_error, 
   lsu_ifu_error_tid, spu_ifu_unc_err_w1, spu_ifu_mamem_err_w1, 
   spu_ifu_corr_err_w2, spu_ifu_int_w2, spu_ifu_ttype_tid_w2, 
   lsu_ifu_inj_ack, ffu_ifu_ecc_ce_w2, ffu_ifu_ecc_ue_w2, 
   ffu_ifu_inj_ack, ffu_ifu_tid_w2, exu_ifu_ecc_ce_m, 
   exu_ifu_ecc_ue_m, exu_ifu_inj_ack, ifq_erb_ue_rep, ifq_erb_ce_rep, 
   ifq_erb_l2_ue, ifq_erb_io_ue, ifq_erb_ifet_ce, ifq_erb_l2err_tid, 
   ifq_erb_rdtag_f, ifq_erb_rdinst_f, ifq_erb_asi_erren_i2, 
   ifq_erb_asi_errstat_i2, ifq_erb_asi_errinj_i2, 
   ifq_erb_asi_erraddr_i2, ifq_erb_asi_imask_i2, ifq_erb_asiwr_i2, 
   ifq_fcl_asird_bf, ifq_erb_fwdrd_bf, ifq_erb_asidata_i2, 
   ifq_erb_asiway_f
   );

   input        rclk, 
                se, 
                si,
                arst_l,
                grst_l;

   input [2:0]  erd_erc_tte_pgsz;

   input [3:0]  icv_itlb_valid_f;

   input        fcl_erb_ievld_s1,
		            fcl_erb_tevld_s1,
		            fcl_erb_immuevld_s1;

   input        fcl_erb_inst_issue_d;
   input        fcl_erb_inst_vld_d1;
   
   input        ifu_tlu_inst_vld_w;

   input [1:0]  ifu_lsu_thrid_s,
		            fcl_erb_asi_tid_f,
		            ifq_fcl_asi_tid_bf;
   
   input [3:0]  fcl_erb_clear_iferr;

   input        fcl_erb_itlbrd_vld_s,
		            fcl_erb_itlbrd_data_s;	
   
   input [3:0]  erd_erc_tagpe_s1;
   input        erd_erc_nirpe_s1,
		            erd_erc_fetpe_s1;
   input [1:0]  erd_erc_tlbt_pe_s1,
		            erd_erc_tlbd_pe_s1;

   input [3:0]  tlu_lsu_pstate_priv;
   input [3:0]  tlu_hpstate_priv;   

   input        lsu_ifu_dtlb_data_su,
		            lsu_ifu_dtlb_data_ue,
		            lsu_ifu_dtlb_tag_ue,
		            lsu_ifu_dcache_data_perror,
		            lsu_ifu_dcache_tag_perror,
		            lsu_ifu_l2_unc_error,
		            lsu_ifu_l2_corr_error,
		            lsu_ifu_io_error;
   input [1:0]  lsu_ifu_error_tid;

   input        spu_ifu_unc_err_w1,  // 1 cycle earlier for timing reasons
                spu_ifu_mamem_err_w1,// 1 cycle earlier for timing reasons
                spu_ifu_corr_err_w2,
                spu_ifu_int_w2;
   
   input [1:0]  spu_ifu_ttype_tid_w2;

   input [3:0]  lsu_ifu_inj_ack;

   input        ffu_ifu_ecc_ce_w2;
   input        ffu_ifu_ecc_ue_w2;
   input        ffu_ifu_inj_ack;
   input [1:0]  ffu_ifu_tid_w2;
   
   input        exu_ifu_ecc_ce_m,
		            exu_ifu_ecc_ue_m;
   input        exu_ifu_inj_ack;
   
   input        ifq_erb_ue_rep;
   input        ifq_erb_ce_rep;
   input        ifq_erb_l2_ue;
   input        ifq_erb_io_ue;
   input        ifq_erb_ifet_ce;
   input [1:0]  ifq_erb_l2err_tid;

   input        ifq_erb_rdtag_f;
   input        ifq_erb_rdinst_f;
   input        ifq_erb_asi_erren_i2;
   input        ifq_erb_asi_errstat_i2;
   input        ifq_erb_asi_errinj_i2;
   input        ifq_erb_asi_erraddr_i2;
   input        ifq_erb_asi_imask_i2;
   input        ifq_erb_asiwr_i2;
   input        ifq_fcl_asird_bf;
   input        ifq_erb_fwdrd_bf;
   input [31:0] ifq_erb_asidata_i2;
   input [1:0]  ifq_erb_asiway_f;

   output       erc_erd_pgsz_b0;
   output       erc_erd_pgsz_b1;

   output       ifu_lsu_asi_rd_unc;
   output [1:0] ifu_lsu_ldxa_tid_w2;
   output       ifu_lsu_ldxa_data_vld_w2;
   output       ifu_lsu_fwd_data_vld;
   output [3:0] ifu_lsu_error_inj;

   output [7:0] ifu_exu_ecc_mask;
   output       ifu_exu_inj_irferr;
   output       ifu_ffu_inj_frferr;
   
   output       ifu_exu_nceen_e;
   output [3:0] ifu_lsu_nceen;
   output [3:0] ifu_spu_nceen;  //  copy going north

   output [3:0] erb_fcl_spu_uetrap;

   output       erb_ifq_itlberr_s1;
   output       erb_ifq_ifeterr_d1;
   output       erb_dtu_ifeterr_d1;
   output       erb_fcl_itlb_ce_d1;
   output [3:0] erb_fcl_ce_trapvec;
   output [3:0] erb_fcl_ue_trapvec;   
   output [3:0] erb_fcl_ifet_uevec_d1;

   output [22:0] erc_erd_errstat_asidata;
   output [31:0] erc_erd_errinj_asidata;
   output [1:0]  erc_erd_erren_asidata; 

   // mux selects
   output [3:0]  erc_erd_eadr0_sel_irf_l,
		             erc_erd_eadr0_sel_itlb_l,
		             erc_erd_eadr0_sel_frf_l,
		             erc_erd_eadr0_sel_lsu_l;

   output [3:0]  erc_erd_asiway_s1_l;
   
   output [3:0]  erc_erd_eadr1_sel_pcd1_l,
		             erc_erd_eadr1_sel_l1pa_l,
		             erc_erd_eadr1_sel_l2pa_l,
		             erc_erd_eadr1_sel_other_l;
   
   output [3:0]  erc_erd_eadr2_sel_mx1_l,
		             erc_erd_eadr2_sel_wrt_l,
		             erc_erd_eadr2_sel_mx0_l,
		             erc_erd_eadr2_sel_old_l;

   output [3:0]  erc_erd_asi_thr_l;

   output        erc_erd_asisrc_sel_icd_s_l,  
		             erc_erd_asisrc_sel_misc_s_l,
		             erc_erd_asisrc_sel_err_s_l,
		             erc_erd_asisrc_sel_itlb_s_l;

   output        erc_erd_errasi_sel_en_l,
		             erc_erd_errasi_sel_stat_l,
		             erc_erd_errasi_sel_inj_l,
		             erc_erd_errasi_sel_addr_l;

   output        erc_erd_miscasi_sel_ict_l,
		             erc_erd_miscasi_sel_imask_l,
		             erc_erd_miscasi_sel_other_l;

   output        erc_erd_ld_imask;
   output        erb_reset,
                 so;

   // Local Signals

   wire          spu_unc_err_w2,
                 spu_mamem_err_w2;
   
   wire          lsu_dtlb_data_su,        
		             lsu_dtlb_data_ue,        
		             lsu_dtlb_tag_ue,         
		             lsu_dcache_data_perror,  
		             lsu_dcache_tag_perror,   
		             lsu_l2_unc_error,        
		             lsu_l2_corr_error,       
		             lsu_io_error;            
   wire [1:0]    lsu_error_tid;           
   
   wire [3:0]    valid_s1;

   wire [1:0]    tid_d,
                 ffu_tid_w3,
                 l2ierr_tid,
                 spu_tid_w2,
                 asi_tid_w2,
		             asi_tid_s1;
   
   wire [3:0]    thr_e,
                 thr_d,
		             thr_d1,
		             thr_m,
		             thr_w,
                 ffu_thr_w3,
		             asi_thr_s,
                 asi_thr_w2,
		             asi_thr_i2,
		             thr_lsu_err,
                 thr_spu_err,
		             thr_l2ie;
   
   wire          itlb_feterr_s1,
		             tlb_feterr_d1,
                 itlb_errtr_s1_l,
                 itlb_errtr_d1_l;
   
   wire          tlb_fet_ce_d1,
		             tlb_fet_ue_d1;
   
   wire [3:0]    alltag_err_s1;
   
   wire          itlb_tagerr_s1,
		             itlb_dataerr_s1,
		             insterr_d1,
                 insterr_s1,
		             insterr_qual_d1,
		             ictagerr_s1,
		             ictagerr_d1,
		             ictagerr_qual_d1;

   wire          asi_daterr_d1,
		             asi_tagerr_d1,
		             asi_rd_err_d1;

   wire          asi_ttevld_s1,
		             asi_tdevld_s1;
   
   wire [3:0]    any_tlbasi_err;

   wire [3:0]    dmdu,
		             dmdu_nxt,
		             dmsu,
		             dmsu_nxt,
		             dmt,
		             dmt_nxt,
		             ddc,
		             ddc_nxt,
		             dtc,
		             dtc_nxt,
		             ldau,
		             ldau_nxt,
		             ncu,
		             ncu_nxt,
                 mau,
                 mau_nxt,
		             any_lsu_err,
		             any_lsu_ue,
		             any_lsu_ce,
                 any_spu_ce,
                 any_spu_ue,
		             imt,
		             imt_nxt,
		             frc,
		             frc_nxt,
		             irc,
		             irc_nxt,
		             fru,
		             fru_nxt,
		             iru,
		             iru_nxt,
		             any_rf_err,
		             any_rf_ce,
		             any_rf_ue,
		             any_irf_err,
		             any_frf_err,
		             idc,
		             idc_nxt,
		             itc,
		             itc_nxt,
		             imdu,
		             imdu_nxt,
		             any_err_vld,
		             any_ue_vld,
//		             any_ce_vld,
		             early_idc,
		             early_idc_nxt,
		             early_itc,
		             early_itc_nxt,
		             early_imdu,
		             early_imdu_nxt,
		             early_ldau,
		             early_ldau_nxt,
		             early_ncu,
		             early_ncu_nxt,
		             early_l2ce,
		             early_l2ce_nxt,
		             any_ifu_ce,
		             any_ifu_ue,
		             any_ifu_err,
		             any_iferr_vld;

   wire [3:0]    meu,
		             meu_nxt,
		             mec,
		             mec_nxt,
		             priv,
		             priv_nxt,
		             early_meu,
		             early_meu_nxt,
		             early_mec,
		             early_mec_nxt,
		             early_priv,
		             early_priv_nxt;

   wire [22:0]   err_stat0,
		             err_stat1,
		             err_stat2,
		             err_stat3;

   wire [3:0]    ifet_ce_vld,
                 ifet_ue_vld;

   wire [3:0]    l2if_unc_err,
		             l2if_corr_err;

   wire [3:0]    ce_trapvec,
		             ue_trapvec,
		             ifu_ce_trap;

   wire          wrt_errinj_i2;
   wire [7:0]    ecc_mask,
		             ecc_mask_nxt;

   wire [1:0]    errinj_ctl,
		             errinj_ctl_nxt;
   wire [5:0]    errinj_vec,
		             errinj_vec_nxt,
		             corr_errinj_vec;
   
//   wire [3:0]    icache_pa_err_d1;

   wire          irf_ce_w,
                 irf_ce_unq,
		             irf_ue_w,
                 irf_ue_unq;

   wire [3:0]    sel_lsu_err,
		             sel_ifuspu_err,
		             sel_rftlb_err;

   wire          clr_err_qual_e,
                 clr_elyff_e,
                 clr_elyff_m,
                 clr_elyff_w;
   
   wire [3:0]    early_err_vec_e,
		             clear_ely_reg_w,
		             mov_ely_reg_w;

   wire [3:0]    clear_iferr_d1;

   wire [1:0]    asi_way_s1;
   wire [3:0]    dec_asiway_s1;

   wire [3:0]    asi_wrt_err_stat,
		             asi_wrt_err_en,
//		             asi_wrt_err_inj,
		             asi_wrt_err_addr;
   
   wire          dmdu_wrt_data,
		             dmsu_wrt_data,
		             imdu_wrt_data,
		             idc_wrt_data,
		             itc_wrt_data,
		             ddc_wrt_data,
		             dtc_wrt_data,
		             imt_wrt_data,
		             dmt_wrt_data,
		             ldau_wrt_data,
		             ncu_wrt_data,
                 mau_wrt_data,
		             fru_wrt_data,
		             frc_wrt_data,
		             iru_wrt_data,
		             irc_wrt_data,
		             meu_wrt_data,
		             mec_wrt_data,
		             priv_wrt_data;

   wire          nceen_wrt_data,
		             ceen_wrt_data;

   wire [3:0]    ceen,
		             ceen_nxt,
		             nceen,
		             nceen_nxt;

   wire          nceen_d;

   wire          rdtag_s,
		             rdinst_s,
		             asi_erren_f,
		             asi_errstat_f,
		             asi_errinj_f,
		             asi_erraddr_f,
		             asi_imask_f,
		             asi_erren_s,
		             asi_errstat_s,
		             asi_errinj_s,
		             asi_erraddr_s,
		             asi_imask_s;

   wire          asird_f,
		             asird_s;
   wire          fwdrd_f,
                 fwdrd_s,
                 asifwd_rd_s,
                 rdinst_f,
                 fwdrd_d;
   
   wire          ldxa_data_vld_s,
                 ldxa_data_vld_d;

   wire          err_asi_s;
   wire          erb_reset_l;

   wire          ffu_ce_w3;
   wire          ffu_ue_w3;   

   wire [3:0] 	 any_lsu_ue_priv_state;
   wire [3:0] 	 any_priv_state;
   
   wire          clk;
   
   
//   
// Code Begins Here
//
   assign        clk = rclk;
   
   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (erb_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign       erb_reset = ~erb_reset_l;


   
   // need to encode page size before sending it back
   assign erc_erd_pgsz_b0 = (erd_erc_tte_pgsz[2] | 
	                            erd_erc_tte_pgsz[1] | 
                              erd_erc_tte_pgsz[0]);

   assign erc_erd_pgsz_b1 = (~erd_erc_tte_pgsz[2] & 
	                           erd_erc_tte_pgsz[1]);
   

   // Don't need this with SPARC_HPV_EN
   // default to tte_lock_d1 = 0
   // 05/30/03: tlb correctible errors disabled.
   // so treat as if lock = 1 and force ue.
//   dff #(1) lk_ff(.din (erd_erc_tte_lock_s1),
//		              .q   (tte_lock_d1),
//		              .clk (clk), .se(se), .si(), .so());

//-----------------------
// Basic pipeline signals
//-----------------------
   // thr_s1 also contains asi tid
   dff_s #(2) tidd_reg(.din (ifu_lsu_thrid_s),
		                 .q   (tid_d),
		                 .clk (clk), .se(se), .si(), .so());

   assign thr_d[0] = ~tid_d[1] & ~tid_d[0];
   assign thr_d[1] = ~tid_d[1] &  tid_d[0];
   assign thr_d[2] =  tid_d[1] & ~tid_d[0];
   assign thr_d[3] =  tid_d[1] &  tid_d[0];

   dff_s #(4) thre_reg(.din (thr_d),
		                 .q   (thr_e),
		                 .clk (clk), .se(se), .si(), .so());
   assign thr_d1 = thr_e;

   dff_s #(4) thrm_reg(.din (thr_e),
		                 .q   (thr_m),
		                 .clk (clk),  .se(se), .si(), .so());
   dff_s #(4) thrw_reg(.din (thr_m),
		                 .q   (thr_w),
		                 .clk (clk),  .se(se), .si(), .so());


//-----------------------------
// lsu flops (added for timing)
//-----------------------------
   // all the lsu signals go to the final mux in the errdp, to help
   // with timing.  This is no longer necessary, in fact it is no
   // longer desired, since we have added the flop below to stage all
   // the lsu signals.  However, the design is not changed, to save
   // the extra effort in physical composition to rip up the errdp.
   dff_s #(10) lspipe_reg(.din ({lsu_ifu_dtlb_data_su,        
                               lsu_ifu_dtlb_data_ue,        
                               lsu_ifu_dtlb_tag_ue,         
                               lsu_ifu_dcache_data_perror,  
                               lsu_ifu_dcache_tag_perror,   
                               lsu_ifu_l2_unc_error,        
                               lsu_ifu_l2_corr_error,       
                               lsu_ifu_io_error,            
                               lsu_ifu_error_tid[1:0]}),
                        .q   ({lsu_dtlb_data_su,        
                               lsu_dtlb_data_ue,        
                               lsu_dtlb_tag_ue,         
                               lsu_dcache_data_perror,  
                               lsu_dcache_tag_perror,   
                               lsu_l2_unc_error,        
                               lsu_l2_corr_error,       
                               lsu_io_error,            
                               lsu_error_tid[1:0]}),
                        .clk (clk), .se(se), .si(), .so());

   assign any_priv_state = tlu_lsu_pstate_priv | tlu_hpstate_priv;
   
   //Bug 6821: added so that lsu ue's errors pickup the delayed priv level
   dff_s #(4) lsu_priv_reg(.din (any_priv_state),
                        .q   (any_lsu_ue_priv_state),
                        .clk (clk), .se(se), .si(), .so());
   
   // thread from lsu
   assign thr_lsu_err[0] = ~lsu_error_tid[1] & ~lsu_error_tid[0];
   assign thr_lsu_err[1] = ~lsu_error_tid[1] &  lsu_error_tid[0];
   assign thr_lsu_err[2] =  lsu_error_tid[1] & ~lsu_error_tid[0];
   assign thr_lsu_err[3] =  lsu_error_tid[1] &  lsu_error_tid[0];

   // thread from spu
   // From Farnad: tid is ready several cycles before everything else.
   // In the ifu, I will assume 1 cycle before
   dff_s #(2) sptid_reg(.din (spu_ifu_ttype_tid_w2),
                      .q   (spu_tid_w2),
                      .clk (clk), .se(se), .so(), .si());
   
   dff_s #(2) spe1_reg(.din ({spu_ifu_unc_err_w1, 
                            spu_ifu_mamem_err_w1}),
                      .q   ({spu_unc_err_w2,
                             spu_mamem_err_w2}),
                      .clk (clk), .se(se), .so(), .si());

   assign thr_spu_err[0] = ~spu_tid_w2[1] & ~spu_tid_w2[0];
   assign thr_spu_err[1] = ~spu_tid_w2[1] &  spu_tid_w2[0];
   assign thr_spu_err[2] =  spu_tid_w2[1] & ~spu_tid_w2[0];
   assign thr_spu_err[3] =  spu_tid_w2[1] &  spu_tid_w2[0];

   // thread from ifq
   dff_s #(2) ifqthr_reg(.din (ifq_erb_l2err_tid),
                       .q   (l2ierr_tid),
                       .clk (clk), .se(se), .so(), .si());
   
   assign thr_l2ie[0] = ~l2ierr_tid[1] & ~l2ierr_tid[0];
   assign thr_l2ie[1] = ~l2ierr_tid[1] &  l2ierr_tid[0];
   assign thr_l2ie[2] =  l2ierr_tid[1] & ~l2ierr_tid[0];
   assign thr_l2ie[3] =  l2ierr_tid[1] &  l2ierr_tid[0];
   
   
//---------------------------------------
// Error Detection -- icache errors
//---------------------------------------
   // itlb inst fetch errors
   assign itlb_feterr_s1 = (erd_erc_tlbd_pe_s1[0] ^ erd_erc_tlbd_pe_s1[1]) & 
			                       fcl_erb_immuevld_s1;
   assign erb_ifq_itlberr_s1 = itlb_feterr_s1 & nceen_d;
   dff_s #(1) itfete_ff(.din (itlb_feterr_s1),
		                  .q   (tlb_feterr_d1),
		                  .clk (clk), .se(se), .si(), .so());

   assign itlb_errtr_s1_l = ~erb_ifq_itlberr_s1;
   dff_s #(1) itume_ff(.din (itlb_errtr_s1_l),
		                 .q   (itlb_errtr_d1_l),
		                 .clk (clk), .se(se), .si(), .so());
   
//   assign tlb_fet_ce_d1 = tlb_feterr_d1 & ~tte_lock_d1;
//   assign tlb_fet_ue_d1 = tlb_feterr_d1 & tte_lock_d1;
   assign tlb_fet_ce_d1 = 1'b0;
   assign tlb_fet_ue_d1 = tlb_feterr_d1;
   

   // instruction errors
//   assign insterr_s1 = (erd_erc_nirpe_s1 | erd_erc_fetpe_s1) & 
//			                   fcl_erb_ievld_s1;
//   dff #(1)  inserr_ff(.din (insterr_s1),
//		                   .q   (insterr_d1),
//		                   .clk (clk), .se(se), .si(), .so());

   assign insterr_s1 = (erd_erc_fetpe_s1 | erd_erc_nirpe_s1) &
                         fcl_erb_ievld_s1;
   
   dff_s #(1)  feterr_ff(.din (insterr_s1),
		                   .q   (insterr_d1),
		                   .clk (clk), .se(se), .si(), .so());
//   dff #(1)  nirerr_ff(.din (erd_erc_nirpe_s1),
//		                   .q   (nirpe_d1),
//		                   .clk (clk), .se(se), .si(), .so());
//   dff #(1)  ievld1_ff(.din (fcl_erb_ievld_s1),
//		                   .q   (ievld_d1),
//		                   .clk (clk), .se(se), .si(), .so());

   assign insterr_qual_d1 = insterr_d1 & ~tlb_feterr_d1;

   // tag errors
   dff_s #(4)  vld_reg(.din (icv_itlb_valid_f),
		                 .q   (valid_s1),
		                 .clk (clk), .se(se), .si(), .so());
   assign alltag_err_s1 = erd_erc_tagpe_s1 & valid_s1;

   assign ictagerr_s1 = (|alltag_err_s1[3:0]) & fcl_erb_tevld_s1;
   dff_s #(1)  itagerr_ff(.din (ictagerr_s1),
		                    .q   (ictagerr_d1),
		                    .clk (clk), .se(se), .si(), .so());

   assign  ictagerr_qual_d1 = ictagerr_d1 & ~insterr_d1 & 
	                            ~tlb_feterr_d1;

   // Corrective action for IFU errors
   // force an imiss if there is a inst/tag parity error
   assign  erb_ifq_ifeterr_d1 = (ictagerr_d1 | insterr_d1) & itlb_errtr_d1_l;

   // moved qualification with inst_vld_d1 to the dtu.
   assign  erb_dtu_ifeterr_d1 = erb_ifq_ifeterr_d1;
   //assign  erb_dtu_ifeterr_d1 = erb_ifq_ifeterr_d1 & fcl_erb_inst_vld_d1;
//   assign  icache_pa_err_d1 = {4{ictagerr_d1 | insterr_d1}} & thr_d1;

   // force a tlbmiss if there is a correctible tlb data parity error
   assign  erb_fcl_itlb_ce_d1 = tlb_fet_ce_d1;

   // take a precise trap if there is an uncorrectible error
   assign  erb_fcl_ifet_uevec_d1 = ({4{tlb_fet_ue_d1 & fcl_erb_inst_vld_d1}} & 
				                            thr_d1  | 
				                            {4{ifq_erb_l2_ue | ifq_erb_io_ue}} & 
				                            thr_l2ie) & nceen;

   // errors in ifetch to l2 or iob
   assign  l2if_unc_err = {4{ifq_erb_l2_ue | ifq_erb_io_ue}} & thr_l2ie;
   assign  l2if_corr_err = {4{ifq_erb_ifet_ce}} & thr_l2ie;
   
   
//-------------------------------------
// Error Detection -- itlb asi errors
//-------------------------------------   
   assign  itlb_tagerr_s1 = (erd_erc_tlbt_pe_s1[0] ^ erd_erc_tlbt_pe_s1[1]) & 
			                        asi_ttevld_s1;
   assign  itlb_dataerr_s1 = (erd_erc_tlbd_pe_s1[0] ^ erd_erc_tlbd_pe_s1[1]) & 
			                         asi_tdevld_s1;

   dff_s #(1) itdate_ff(.din (itlb_dataerr_s1),
		                  .q   (asi_daterr_d1),
		                  .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ittage_ff(.din (itlb_tagerr_s1),
		                  .q   (asi_tagerr_d1),
		                  .clk (clk), .se(se), .si(), .so());

   assign  asi_rd_err_d1 = asi_daterr_d1 | asi_tagerr_d1;
   assign  ifu_lsu_asi_rd_unc = asi_rd_err_d1;
   
   assign  any_tlbasi_err = {4{asi_rd_err_d1}} & asi_thr_w2;


//------------------------------
// RF errors
//------------------------------   
   dff_s #(1) irfu_ff(.din (exu_ifu_ecc_ue_m),
		                .q   (irf_ue_unq),
		                .clk (clk), .se (se), .si(), .so());
   dff_s #(1) irfc_ff(.din (exu_ifu_ecc_ce_m),
		                .q   (irf_ce_unq),
		                .clk (clk), .se (se), .si(), .so());
   assign  irf_ce_w = irf_ce_unq & ifu_tlu_inst_vld_w;
   assign  irf_ue_w = irf_ue_unq & ifu_tlu_inst_vld_w;
   
//------------------
// Error Logging
//------------------
   // List of all logged errors
   // itlbt  u
   // itlbd  u/c
   // ict  c
   // icd  c
   // irf  c/u
   // frf  c/u
   // dtlb d/t u
   // dct  c
   // dcd  c
   // mau  u
   // l2-d u
   // l2-i u
   // dram u -- not any more
   // io   u
   //
   // Errors not logged but causing a trap
   // l2-d c
   // l2-i c
   // l2-s c
   // 

   // latest errors have highest priority
   // lsu is latest and sometimes asynchronous
   // spu has low priority
   // irf/frf are always "current"
   // ifu errors are speculative ("early")
   // All lsu errors are prioritised at the source
   assign  dmdu_nxt =  {4{lsu_dtlb_data_ue & ~erb_reset}} & thr_lsu_err &
		                    ~any_ue_vld |
	                      dmdu & ~({4{dmdu_wrt_data}} & asi_wrt_err_stat);
   // 6310
   assign  dmsu_nxt =  {4{lsu_dtlb_data_su & ~erb_reset}} & thr_lsu_err &
		                   ~any_ue_vld |
	                     dmsu & ~({4{dmsu_wrt_data}} & asi_wrt_err_stat);
   assign  dmt_nxt =  {4{lsu_dtlb_tag_ue & ~erb_reset}} & thr_lsu_err &
		                  ~any_ue_vld |
	                    dmt & ~({4{dmt_wrt_data}} & asi_wrt_err_stat);
   assign  ddc_nxt =  {4{lsu_dcache_data_perror & ~erb_reset}} & thr_lsu_err &
		                  ~any_err_vld |
	                    ddc & ~({4{ddc_wrt_data}} & asi_wrt_err_stat);
   assign  dtc_nxt =  {4{lsu_dcache_tag_perror & ~erb_reset}} & thr_lsu_err &
		                  ~any_err_vld |
	                    dtc & ~({4{dtc_wrt_data}} & asi_wrt_err_stat);

   assign  ldau_nxt = (mov_ely_reg_w & early_ldau | 
	                     {4{lsu_l2_unc_error}} & thr_lsu_err |
	                     {4{spu_unc_err_w2}} & thr_spu_err) &
		                    ~any_ue_vld |
	                     ldau & ~({4{ldau_wrt_data}} & asi_wrt_err_stat);

   assign  ncu_nxt = (mov_ely_reg_w & early_ncu |  
	                    {4{lsu_io_error}} & thr_lsu_err) &
		                   ~any_ue_vld |
 	                   ncu & ~({4{ncu_wrt_data}} & asi_wrt_err_stat);

   assign  any_lsu_ue = thr_lsu_err & {4{lsu_dtlb_data_ue |
                                         lsu_dtlb_data_su |
					                               lsu_dtlb_tag_ue |
					                               lsu_l2_unc_error |
					                               lsu_io_error}};

   assign  any_lsu_ce = thr_lsu_err & 
	                      {4{(lsu_dcache_data_perror |
			                      lsu_dcache_tag_perror |
			                      lsu_l2_corr_error) &
                           ~lsu_dtlb_data_ue & 
                           ~lsu_dtlb_data_su}};

   assign  any_lsu_err = (any_lsu_ue |
			                    thr_lsu_err & {4{lsu_dcache_data_perror |
					                                 lsu_dcache_tag_perror}});

   // MAmem parity error
   assign mau_nxt = {4{spu_mamem_err_w2}} & thr_spu_err & 
                    ~any_ue_vld |
                    mau &  ~({4{mau_wrt_data}} & asi_wrt_err_stat);

   assign any_spu_ce = {4{spu_ifu_corr_err_w2 & ~spu_unc_err_w2}} & thr_spu_err;
   assign any_spu_ue = {4{spu_unc_err_w2 |
                          spu_mamem_err_w2}} & thr_spu_err;
				 
   // tlb asi read error
   assign imt_nxt =  {4{asi_tagerr_d1 & ~erb_reset}} & asi_thr_w2 &
		                 ~any_ue_vld |
	                   imt & ~({4{imt_wrt_data}} & asi_wrt_err_stat);

   dff_s #(2) ffu_err_reg(.din ({ffu_ifu_ecc_ce_w2,
                               ffu_ifu_ecc_ue_w2}),
                        .q   ({ffu_ce_w3,
                               ffu_ue_w3}),
                        .clk (clk), .se(se), .si(), .so());

   dff_s #(2) fptid_reg(.din (ffu_ifu_tid_w2[1:0]),
		                  .q   (ffu_tid_w3[1:0]),
		                  .clk (clk),  .se(se), .si(), .so());

   assign ffu_thr_w3[0] = ~ffu_tid_w3[1] & ~ffu_tid_w3[0];
   assign ffu_thr_w3[1] = ~ffu_tid_w3[1] &  ffu_tid_w3[0];
   assign ffu_thr_w3[2] =  ffu_tid_w3[1] & ~ffu_tid_w3[0];
   assign ffu_thr_w3[3] =  ffu_tid_w3[1] &  ffu_tid_w3[0];
   
   
   // regfile error
   //Bug6420: log frc and irc bits as well when fru and iru are detected simulatneously
   assign frc_nxt =  {4{ffu_ce_w3 & ~erb_reset}} &    
	              ffu_thr_w3 & ~any_err_vld & ~any_lsu_err |
	              frc & ~({4{frc_wrt_data}} & asi_wrt_err_stat);
   
   assign fru_nxt =  {4{ffu_ue_w3 & ~erb_reset}} & ffu_thr_w3 &
		            ~any_ue_vld & ~any_lsu_ue |
	              fru & ~({4{fru_wrt_data}} & asi_wrt_err_stat);

   //Bug6420
   assign irc_nxt =  {4{irf_ce_w & ~erb_reset}} & thr_w &   
		                ~any_err_vld & ~any_lsu_err |
	                  irc & ~({4{irc_wrt_data}} & asi_wrt_err_stat);
   
   assign iru_nxt =  {4{irf_ue_w & ~erb_reset}} & thr_w &
		               ~any_ue_vld & ~any_lsu_ue |
	                 iru & ~({4{iru_wrt_data}} & asi_wrt_err_stat);

   assign any_irf_err = thr_w & {4{irf_ce_w | irf_ue_w}};
   assign any_frf_err = ffu_thr_w3 & {4{ffu_ce_w3 | ffu_ue_w3}};

   //Bug6420
   assign any_rf_ce = thr_w & {4{irf_ce_w}} |
	                    ffu_thr_w3 & {4{ffu_ce_w3}};
   assign any_rf_ue = thr_w & {4{irf_ue_w}} |
	                    ffu_thr_w3 & {4{ffu_ue_w3}};
   assign any_rf_err = any_irf_err | any_frf_err;


   // ifu errors
   assign idc_nxt =  mov_ely_reg_w & ~any_err_vld & early_idc |
	              idc & ~({4{idc_wrt_data}} & asi_wrt_err_stat);
   
   assign itc_nxt =  mov_ely_reg_w & ~any_err_vld & early_itc | 
	             itc & ~({4{itc_wrt_data}} & asi_wrt_err_stat);

   // bug 6310
   assign imdu_nxt =  (mov_ely_reg_w & early_imdu |
		                   {4{asi_daterr_d1 & ~erb_reset}} & asi_thr_w2) &
                        ~any_ue_vld |
	                    imdu & ~({4{imdu_wrt_data}} & asi_wrt_err_stat);
   
//   assign imdc_nxt =  mov_ely_reg_w & ~any_err_vld & early_imdc |
//	                    imdc & ~({4{imdc_wrt_data}} & asi_wrt_err_stat);
   
   dff_s #(64) errvec_reg(.din ({imt_nxt, imdu_nxt, idc_nxt, itc_nxt, 
			                         iru_nxt, irc_nxt, fru_nxt, frc_nxt,
  	                           dmt_nxt, dmdu_nxt, dmsu_nxt, ddc_nxt, dtc_nxt, 
			                         ldau_nxt, ncu_nxt, mau_nxt}),
		                    .q   ({imt, imdu, idc, itc, 
			                         iru, irc, fru, frc,
  	                           dmt, dmdu, dmsu, ddc, dtc, 
			                         ldau, ncu, mau}),
		                    .clk (clk),
		                    .se  (se), .si(), .so());
		      
   assign any_err_vld = imt | imdu | idc | itc | iru | irc | fru | frc |
  	                    dmt | dmdu | dmsu | ddc | dtc | ldau | ncu | mau;

   assign any_ue_vld =  imt | imdu | iru | fru |
  	                    dmt | dmdu | dmsu | ldau | ncu | mau;
   
//   assign any_ce_vld =  imdc | idc | itc | irc | frc |
//  	                dmdc | ddc | dtc;

   // IFU errors
   assign any_ifu_ue = {4{(ifq_erb_l2_ue | ifq_erb_io_ue) & ~erb_reset}} & 
	                     thr_l2ie |
	                     {4{tlb_fet_ue_d1 & ~erb_reset}} & thr_d1;
   
   assign any_ifu_ce = {4{ifq_erb_ifet_ce & ~erb_reset}} & thr_l2ie |
	                     {4{(tlb_fet_ce_d1 | insterr_qual_d1 | 
			                     ictagerr_qual_d1) & ~erb_reset}} & 
                       thr_d1;

   assign any_ifu_err = any_ifu_ce | any_ifu_ue;
   

   assign ifet_ce_vld = early_idc | early_itc | early_l2ce;
   assign ifet_ue_vld = early_imdu | early_ldau | early_ncu;

   // l2ce's are not logged in sparc, so leave them out
   assign any_iferr_vld = ifet_ue_vld | early_idc | early_itc;   

   // Early errors
   assign early_idc_nxt = {4{insterr_qual_d1}} & thr_d1 &
	                  ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                  early_idc & ~clear_iferr_d1 &
	                  ~mov_ely_reg_w;
   
   assign early_itc_nxt =  {4{ictagerr_qual_d1}} & thr_d1 &
		                ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                  early_itc & ~clear_iferr_d1 &
	                  ~mov_ely_reg_w;	  

   assign early_imdu_nxt =  {4{tlb_fet_ue_d1}} & thr_d1 &
		                 ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_imdu & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
	  
//   assign early_imdc_nxt =  {4{tlb_fet_ce_d1}} & thr_d1 &
//		                 ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
//	                   early_imdc & ~clear_iferr_d1 &
//	                   ~mov_ely_reg_w;

   assign early_ldau_nxt = {4{ifq_erb_l2_ue & ~erb_reset}} & thr_l2ie & 
	                   ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_ldau & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
   
   assign early_ncu_nxt = {4{ifq_erb_io_ue & ~erb_reset}} & thr_l2ie & 
	                   ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_ncu & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;

   assign early_l2ce_nxt =  {4{ifq_erb_ifet_ce}} & thr_l2ie &
		                 ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                   early_l2ce & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
   
   dffr_s #(24) elyerr_reg(.din ({early_idc_nxt, 
			                          early_itc_nxt, 
			                          early_imdu_nxt,
			                          early_ldau_nxt,
			                          early_ncu_nxt,
			                          early_l2ce_nxt}),
		                     .q   ({early_idc,
			                          early_itc,
			                          early_imdu,
			                          early_ldau,
			                          early_ncu,
			                          early_l2ce}),
		                     .clk (clk),
		                     .rst (erb_reset),
		                     .se  (se), .si(), .so());

   // Multipl errors
   assign meu_nxt = any_ue_vld & (any_lsu_ue | any_rf_ue | any_tlbasi_err |
                                  any_spu_ue |
		                              mov_ely_reg_w & ifet_ue_vld) |
// known bug - wontfix                            
//                                    mov_ely_reg_w & early_meu |
                    meu & ~({4{meu_wrt_data}} & asi_wrt_err_stat);

   assign mec_nxt = any_err_vld & (any_lsu_ce | any_rf_ce |
		                               mov_ely_reg_w & ifet_ce_vld) |
// known bug - wontfix                     
//                     mov_ely_reg_w & early_mec |
	                  mec & ~({4{mec_wrt_data}} & asi_wrt_err_stat);

   //Bug6821
   assign priv_nxt = 	  ~any_err_vld & (any_lsu_ue_priv_state & any_lsu_ue | 
					  any_priv_state & (any_lsu_ce | any_rf_err | any_tlbasi_err) |
					  mov_ely_reg_w & early_priv) |
			  priv & ~({4{priv_wrt_data}} & asi_wrt_err_stat);
   
   dffr_s #(12) me_reg(.din ({meu_nxt, 
			                      mec_nxt, 
			                      priv_nxt}),
		                 .q   ({meu,
			                      mec,
			                      priv}),
		                 .clk (clk),
		                 .rst (erb_reset),
		                 .se  (se), .si(), .so());

   // Early multiple errors
   assign early_meu_nxt = any_ifu_ue & ifet_ue_vld | 
	                  early_meu & ~clear_iferr_d1 & ~mov_ely_reg_w;

   assign early_mec_nxt = any_ifu_ce & any_iferr_vld |
	                  early_mec & ~clear_iferr_d1 & ~mov_ely_reg_w;

   // bug 6155 & 6821
   assign early_priv_nxt = any_priv_state & ~any_iferr_vld & ~any_rf_err & ~any_lsu_err & any_ifu_err |
	                   early_priv & ~clear_iferr_d1 & ~mov_ely_reg_w;
   
   dffr_s #(12) elyme_reg(.din ({early_meu_nxt, 
			                         early_mec_nxt, 
			                         early_priv_nxt}),
		                    .q   ({early_meu,
			                         early_mec,
			                         early_priv}),
		                    .clk (clk),
		                    .rst (erb_reset),
		                    .se  (se), .si(), .so());

   // pipeline progress
   dff_s #(1) clre_ff(.din (fcl_erb_inst_issue_d),
                    .q   (clr_elyff_e),
                    .clk (clk), .se(se), .si(), .so());
   assign early_err_vec_e = (any_iferr_vld | early_l2ce) & thr_e;
   assign clr_err_qual_e = (|early_err_vec_e[3:0]) & clr_elyff_e;
   
   dff_s #(1) clrm_ff(.din (clr_err_qual_e),
                    .q   (clr_elyff_m),
                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) clrw_ff(.din (clr_elyff_m),
                    .q   (clr_elyff_w),
                    .clk (clk), .se(se), .si(), .so());

   // fix for 6142 and 6159
   // delay err reg clear by one cycle to prevent clearing your own errors
   dff_s #(4) clree_reg(.din (fcl_erb_clear_iferr),
                      .q   (clear_iferr_d1),
                      .clk (clk), .se(se), .si(), .so());
   

   assign clear_ely_reg_w = {4{clr_elyff_w}} & thr_w & 
	                          (any_iferr_vld | early_l2ce);  // why again?
   assign mov_ely_reg_w = clear_ely_reg_w & 
                          {4{ifu_tlu_inst_vld_w & ~erb_reset}};


   // asi error status output
   assign err_stat0 = {meu[0], mec[0], priv[0],
		                   3'b100,                    // rw, enc, ma
		                   imdu[0], imt[0], 
		                   dmdu[0], dmt[0],
		                   idc[0], itc[0], ddc[0], dtc[0],
		                   irc[0], iru[0], frc[0], fru[0],
		                   ldau[0], ncu[0],
                       dmsu[0], 1'b0, mau[0]};
   
   assign err_stat1 = {meu[1], mec[1], priv[1],
		                   3'b100,
		                   imdu[1], imt[1], 
		                   dmdu[1], dmt[1],
		                   idc[1], itc[1], ddc[1], dtc[1],
		                   irc[1], iru[1], frc[1], fru[1],
		                   ldau[1], ncu[1],
                       dmsu[1], 1'b0, mau[1]};
   
   assign err_stat2 = {meu[2], mec[2], priv[2],
		                   3'b100,
		                   imdu[2], imt[2], 
		                   dmdu[2], dmt[2],
		                   idc[2], itc[2], ddc[2], dtc[2],
		                   irc[2], iru[2], frc[2], fru[2],
		                   ldau[2], ncu[2],
                       dmsu[2], 1'b0, mau[2]};
   
   assign err_stat3 = {meu[3], mec[3], priv[3],
		                   3'b100,
		                   imdu[3], imt[3], 
		                   dmdu[3], dmt[3],
		                   idc[3], itc[3], ddc[3], dtc[3],
		                   irc[3], iru[3], frc[3], fru[3],
		                   ldau[3], ncu[3],
                       dmsu[3], 1'b0, mau[3]};

   mux4ds #(23) err_stat_asi(.dout (erc_erd_errstat_asidata),
			                       .in0  (err_stat0),
			                       .in1  (err_stat1),
			                       .in2  (err_stat2),
			                       .in3  (err_stat3),
			                       .sel0 (asi_thr_s[0]),
			                       .sel1 (asi_thr_s[1]),
			                       .sel2 (asi_thr_s[2]),
			                       .sel3 (asi_thr_s[3]));

//----------------------------------
// Error Address Selection   
//----------------------------------

   // TBD: Uncorrectible errors have to overwrite correctible errors
   // mux 0
   // FRF errors are mutex with everything else
   // ITLB asi errors are mutex with everything else
   // ASI writes are mutex with everything else
   // only one of these errors could occur at a given time
   assign  erc_erd_eadr0_sel_lsu_l = ~(sel_lsu_err);

   assign  erc_erd_eadr0_sel_irf_l =  ~(~sel_lsu_err & any_irf_err);

   assign  erc_erd_eadr0_sel_itlb_l = ~(~sel_lsu_err & ~any_irf_err & 
					                              any_tlbasi_err);

   assign  erc_erd_eadr0_sel_frf_l = ~(~sel_lsu_err & ~any_irf_err & 
				                               ~any_tlbasi_err);

   // mux 1
   // l1 pa and tlb feterr can be simultaneous
   // TBD: need to reorder and make spu lower priority?
   assign  erc_erd_eadr1_sel_other_l = ~(any_spu_ue);
   
   assign  erc_erd_eadr1_sel_l2pa_l = ~(~any_spu_ue & 
                                        (l2if_unc_err | l2if_corr_err));

   assign  erc_erd_eadr1_sel_pcd1_l = ~(~l2if_unc_err & ~l2if_corr_err & 
					                              ~any_spu_ue & 
                                        thr_d1 & {4{tlb_feterr_d1}});

   assign  erc_erd_eadr1_sel_l1pa_l = ~(~l2if_unc_err & ~l2if_corr_err & 
					                              ({4{~tlb_feterr_d1}} | ~thr_d1) & 
                                        ~any_spu_ue);

//   assign  erc_erd_eadr1_sel_other_l = ~(~l2if_unc_err & ~l2if_corr_err & 
//					                           {4{~tlb_feterr_d1}} & ~icache_pa_err_d1);


   // mux2
   assign sel_lsu_err = ~any_err_vld & any_lsu_err |
	                      ~any_ue_vld & any_lsu_ue;

   assign sel_ifuspu_err = (~any_err_vld & ~any_iferr_vld & any_ifu_err |
                            ~any_ue_vld & any_spu_ue |
			                      ~any_ue_vld & ~ifet_ue_vld & any_ifu_ue);

   assign sel_rftlb_err = ~any_ue_vld & (any_rf_ue |
					                               any_tlbasi_err) |
			                    ~any_err_vld & any_rf_ce;
   
   
   assign  erc_erd_eadr2_sel_wrt_l = ~(asi_wrt_err_addr);

   assign  erc_erd_eadr2_sel_mx0_l = ~(~asi_wrt_err_addr & 
				                               (sel_lsu_err | 
					                              sel_rftlb_err));
   
   assign  erc_erd_eadr2_sel_mx1_l = ~(~sel_lsu_err & 
				                               ~asi_wrt_err_addr &
				                               ~sel_rftlb_err &
				                               sel_ifuspu_err);
   
   assign  erc_erd_eadr2_sel_old_l = ~(~sel_lsu_err & 
				                               ~asi_wrt_err_addr &
				                               ~sel_rftlb_err &
				                               ~sel_ifuspu_err);
   
//-----------------------------
// Error Enable Reg
//-----------------------------
   assign nceen_nxt = asi_wrt_err_en & {4{nceen_wrt_data}} |
	                    ~asi_wrt_err_en & nceen;
   
   assign ceen_nxt = asi_wrt_err_en & {4{ceen_wrt_data}} |
	                   ~asi_wrt_err_en & ceen;

   dffr_s #(8) err_en_reg(.din ({nceen_nxt, ceen_nxt}),
		                    .q   ({nceen, ceen}),
		                    .rst (erb_reset),
		                    .clk (clk), .se(se), .si(), .so());

   assign nceen_d = (thr_d[0] & nceen[0] |
                     thr_d[1] & nceen[1] |
                     thr_d[2] & nceen[2] |
                     thr_d[3] & nceen[3]);
   
   dff_s #(1) nce_ff(.din (nceen_d),
                   .q   (ifu_exu_nceen_e),
                   .clk (clk), .se(se), .si(), .so());

   assign ifu_lsu_nceen = nceen;
   assign ifu_spu_nceen = nceen;

   assign ifu_ce_trap = mov_ely_reg_w & ifet_ce_vld;
   assign ce_trapvec =  (ifu_ce_trap |
			                   any_rf_ce |
			                   {4{ifq_erb_ce_rep}} & thr_l2ie |
                         any_spu_ce |
			                   any_lsu_ce) & ceen;

   dff_s #(4) ceint_reg(.din (ce_trapvec),
		                  .q   (erb_fcl_ce_trapvec),
		                  .clk (clk), .se(se), .si(), .so());

   assign ue_trapvec =  ({4{ifq_erb_ue_rep}} & thr_l2ie |
                         any_spu_ue & {4{spu_ifu_int_w2}}) & nceen;

   assign erb_fcl_spu_uetrap = any_spu_ue & nceen;
   
   dff_s #(4) ueint_reg(.din (ue_trapvec),
		                  .q   (erb_fcl_ue_trapvec),
		                  .clk (clk), .se(se), .si(), .so());


   mux4ds #(2) err_en_asi(.dout (erc_erd_erren_asidata),
			                    .in0  ({nceen[0], ceen[0]}),
			                    .in1  ({nceen[1], ceen[1]}),
			                    .in2  ({nceen[2], ceen[2]}),
			                    .in3  ({nceen[3], ceen[3]}),
			                    .sel0 (asi_thr_s[0]),
			                    .sel1 (asi_thr_s[1]),
			                    .sel2 (asi_thr_s[2]),
			                    .sel3 (asi_thr_s[3]));

//-------------------------
// Error Inject
//-------------------------
   assign wrt_errinj_i2 = (ifq_erb_asi_errinj_i2 & ifq_erb_asiwr_i2);
   assign ecc_mask_nxt =  wrt_errinj_i2 ?  ifq_erb_asidata_i2[7:0] :
                                           ecc_mask[7:0];
   
   assign errinj_ctl_nxt[1:0] = wrt_errinj_i2 ? ifq_erb_asidata_i2[31:30] :
	                                              errinj_ctl[1:0];

   // correct for single shot
   assign errinj_vec_nxt[5:0] = wrt_errinj_i2 ? ifq_erb_asidata_i2[29:24] :
	                              errinj_ctl[0] ? corr_errinj_vec :
	                                              errinj_vec;

   dffr_s #(16) errinj_reg(.din ({errinj_ctl_nxt,
			                          errinj_vec_nxt,
			                          ecc_mask_nxt}),
		                     .q   ({errinj_ctl,
			                          errinj_vec,
			                          ecc_mask}),
		                     .rst (erb_reset),
		                     .clk (clk), .se (se), .si(), .so());
   
   assign ifu_exu_ecc_mask = ecc_mask;
   assign ifu_exu_inj_irferr = errinj_vec[1] & errinj_ctl[1];
   assign ifu_ffu_inj_frferr = errinj_vec[0] & errinj_ctl[1];
   assign ifu_lsu_error_inj[3:0] = errinj_vec[5:2] & {4{errinj_ctl[1]}};

   assign corr_errinj_vec[5:0] = errinj_vec[5:0] & ~{lsu_ifu_inj_ack[3:0], 
						                                         exu_ifu_inj_ack,
						                                         ffu_ifu_inj_ack};
   assign erc_erd_errinj_asidata = {errinj_ctl,
				                            errinj_vec,
				                            16'b0,
				                            ecc_mask};
   
//--------------------------
//  ASI Stuff
//--------------------------

   dff_s #(2) asiways_reg(.din (ifq_erb_asiway_f),
		                    .q   (asi_way_s1),
		                    .clk (clk), .se(se), .si(), .so());

   assign dec_asiway_s1[0] = ~asi_way_s1[1] & ~asi_way_s1[0];
   assign dec_asiway_s1[1] = ~asi_way_s1[1] &  asi_way_s1[0];
   assign dec_asiway_s1[2] =  asi_way_s1[1] & ~asi_way_s1[0];
   assign dec_asiway_s1[3] =  asi_way_s1[1] &  asi_way_s1[0];
   
   assign erc_erd_asiway_s1_l = ~dec_asiway_s1;
   
   assign asi_thr_i2[0] = ~ifq_fcl_asi_tid_bf[1] & ~ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[1] = ~ifq_fcl_asi_tid_bf[1] &  ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[2] =  ifq_fcl_asi_tid_bf[1] & ~ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[3] =  ifq_fcl_asi_tid_bf[1] &  ifq_fcl_asi_tid_bf[0];

   dff_s #(2) asi_tids_reg(.din (fcl_erb_asi_tid_f),
			                    .q   (asi_tid_s1),
			                    .clk (clk), .se(se), .si(), .so());
   dff_s #(2) asi_tidw2_reg(.din (asi_tid_s1),
			                    .q   (asi_tid_w2),
			                    .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_tid_w2 = asi_tid_w2;

   assign erc_erd_asi_thr_l = ~asi_thr_s;

   assign asi_thr_s[0] = ~asi_tid_s1[1] & ~asi_tid_s1[0];
   assign asi_thr_s[1] = ~asi_tid_s1[1] &  asi_tid_s1[0];
   assign asi_thr_s[2] =  asi_tid_s1[1] & ~asi_tid_s1[0];
   assign asi_thr_s[3] =  asi_tid_s1[1] &  asi_tid_s1[0];

   assign asi_thr_w2[0] = ~asi_tid_w2[1] & ~asi_tid_w2[0];
   assign asi_thr_w2[1] = ~asi_tid_w2[1] &  asi_tid_w2[0];
   assign asi_thr_w2[2] =  asi_tid_w2[1] & ~asi_tid_w2[0];
   assign asi_thr_w2[3] =  asi_tid_w2[1] &  asi_tid_w2[0];

   
   // F stage flops
   dff_s #(1) asi_en_ff(.din (ifq_erb_asi_erren_i2),
		                  .q   (asi_erren_f),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_stat_ff(.din (ifq_erb_asi_errstat_i2),
		                    .q   (asi_errstat_f),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_addr_ff(.din (ifq_erb_asi_erraddr_i2),
		                    .q   (asi_erraddr_f),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_inj_ff(.din (ifq_erb_asi_errinj_i2),
		                   .q   (asi_errinj_f),
		                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_im_ff(.din (ifq_erb_asi_imask_i2),
		                  .q   (asi_imask_f),
		                  .clk (clk), .se(se), .si(), .so());

   // S stage Flops
   dff_s #(1) asi_ens_ff(.din (asi_erren_f),
		                   .q   (asi_erren_s),
		                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_stats_ff(.din (asi_errstat_f),
		                     .q   (asi_errstat_s),
		                     .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_addrs_ff(.din (asi_erraddr_f),
		                     .q   (asi_erraddr_s),
		                     .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_injs_ff(.din (asi_errinj_f),
		                    .q   (asi_errinj_s),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_ims_ff(.din (asi_imask_f),
		                   .q   (asi_imask_s),
		                   .clk (clk), .se(se), .si(), .so());

   // ASI Reads
   // All ASI reads except TLB
   dff_s #(1) asi_rdf_ff(.din (ifq_fcl_asird_bf),
		                   .q   (asird_f),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asi_rds_ff(.din (asird_f),
		                   .q   (asird_s),
		                   .clk (clk), .se(se), .si(), .so());

   // fwd reads
   dff_s #(1) fwd_rdf_ff(.din (ifq_erb_fwdrd_bf),
		                   .q   (fwdrd_f),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) fwd_rds_ff(.din (fwdrd_f),
		                   .q   (fwdrd_s),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) fwd_rdd_ff(.din (fwdrd_s),
		                   .q   (fwdrd_d),
		                   .clk (clk), .se(se), .si(), .so());

   assign ifu_lsu_fwd_data_vld = fwdrd_d;
   assign asifwd_rd_s = asird_s | fwdrd_s;

   
   // asi reads from icache
   dff_s #(1) ic_rdts_ff(.din (ifq_erb_rdtag_f),
		                   .q   (rdtag_s),
		                   .clk (clk), .se(se), .si(), .so());

   // forward requests also read instruction memory
   assign rdinst_f = fwdrd_f | ifq_erb_rdinst_f;
   
   dff_s #(1) ic_rdds_ff(.din (rdinst_f),
		                   .q   (rdinst_s),
		                   .clk (clk), .se(se), .si(), .so());


//   assign rst_tri_en = 1'b0;

   // pick err asi source
   assign erc_erd_errasi_sel_en_l   = ~asi_erren_s;
   assign erc_erd_errasi_sel_stat_l = ~asi_errstat_s | asi_erren_s;
   assign erc_erd_errasi_sel_inj_l  = ~asi_errinj_s | asi_errstat_s | 
                                       asi_erren_s;
   assign erc_erd_errasi_sel_addr_l =  asi_erren_s | asi_errstat_s | 
	                                     asi_errinj_s;	

   assign err_asi_s = (asi_erren_s | asi_errstat_s | asi_errinj_s | 
	                     asi_erraddr_s);

   // pick other asi source
   assign erc_erd_miscasi_sel_ict_l = ~rdtag_s;
   assign erc_erd_miscasi_sel_imask_l = ~asi_imask_s | rdtag_s;
   assign erc_erd_miscasi_sel_other_l = rdtag_s | asi_imask_s;

   // pick source for final asi loads
   assign erc_erd_asisrc_sel_icd_s_l = ~(asifwd_rd_s & rdinst_s);
   assign erc_erd_asisrc_sel_err_s_l = ~(asifwd_rd_s & ~rdinst_s & err_asi_s);
   assign erc_erd_asisrc_sel_misc_s_l = ~(asifwd_rd_s & ~rdinst_s & ~err_asi_s);
   assign erc_erd_asisrc_sel_itlb_s_l = ~(~asifwd_rd_s);

   // is this asi read valid (for checking parity)
   assign asi_ttevld_s1 = fcl_erb_itlbrd_vld_s & ~fcl_erb_itlbrd_data_s;
   assign asi_tdevld_s1 = fcl_erb_itlbrd_vld_s & fcl_erb_itlbrd_data_s;

   assign ldxa_data_vld_s = fcl_erb_itlbrd_vld_s | asird_s;
//   assign ifu_lsu_ldxa_data_vld_w1 = ldxa_data_vld_s;
   
   dff_s #(1) asirdd_ff(.din (ldxa_data_vld_s),
                      .q   (ldxa_data_vld_d),
                      .clk (clk),
                      .se  (se), .si(), .so());
   
   assign ifu_lsu_ldxa_data_vld_w2 = ldxa_data_vld_d;
   

   // ASI Writes
   assign asi_wrt_err_en = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                 ifq_erb_asi_erren_i2}};
   assign asi_wrt_err_stat = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                   ifq_erb_asi_errstat_i2}};
   // err inj is common to the core
//   assign asi_wrt_err_inj = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
//					                                  ifq_erb_asi_errinj_i2}};
   assign asi_wrt_err_addr = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                   ifq_erb_asi_erraddr_i2}};   

   assign erc_erd_ld_imask = ifq_erb_asiwr_i2 & ifq_erb_asi_imask_i2;


   // ASI Write Data
   assign  meu_wrt_data  = ifq_erb_asidata_i2[31];
   assign  mec_wrt_data  = ifq_erb_asidata_i2[30];
   assign  priv_wrt_data = ifq_erb_asidata_i2[29];

   assign  imdu_wrt_data = ifq_erb_asidata_i2[25];
   assign  imt_wrt_data  = ifq_erb_asidata_i2[24];
   assign  dmdu_wrt_data = ifq_erb_asidata_i2[23];
   assign  dmt_wrt_data  = ifq_erb_asidata_i2[22];
   assign  idc_wrt_data  = ifq_erb_asidata_i2[21];
   assign  itc_wrt_data  = ifq_erb_asidata_i2[20];
   assign  ddc_wrt_data  = ifq_erb_asidata_i2[19];
   assign  dtc_wrt_data  = ifq_erb_asidata_i2[18];
   assign  irc_wrt_data  = ifq_erb_asidata_i2[17];
   assign  iru_wrt_data  = ifq_erb_asidata_i2[16];
   assign  frc_wrt_data  = ifq_erb_asidata_i2[15];
   assign  fru_wrt_data  = ifq_erb_asidata_i2[14];
   assign  ldau_wrt_data = ifq_erb_asidata_i2[13];
   assign  ncu_wrt_data  = ifq_erb_asidata_i2[12];  
   assign  dmsu_wrt_data = ifq_erb_asidata_i2[11];
   assign  mau_wrt_data  = ifq_erb_asidata_i2[9];
  
   assign nceen_wrt_data = ifq_erb_asidata_i2[1];  
   assign ceen_wrt_data  = ifq_erb_asidata_i2[0];  

   //
   sink s0(.in (ifq_erb_asidata_i2[8]));
   sink s1(.in (ifq_erb_asidata_i2[10]));
   
endmodule
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_fcl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_fcl
//  Description:	
//  The FCL is the fetch control logic.  It controls the PC datapath
//  and the fetch/next instruction datapath.  It also manages access
//  to the icache data, tags, vbits and to the tlb.
//  The FCL starts fetching from the reset PC upon reset.  It is up to
//  the DTU to specify which thread to fetch from.  Only T0 is set to
//  the reset PC.  If the decode unit specifies any other thread, it
//  will fetch from an indeterminate address.
//  The fetch block automatically stalls the machine when an Imiss is
//  detected and there is no thread to switch to.  
// 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting














module sparc_ifu_fcl(/*AUTOARG*/
   // Outputs
   
   fcl_itlb_csm_rd_vld_bf,
   
   fcl_icd_rdreq_bf, fcl_icv_rdreq_bf, fcl_icd_wrreq_bf, 
   fcl_ict_wrreq_bf, fcl_icv_wrreq_bf, fcl_icd_index_sel_ifq_bf, 
   fcl_ifq_grant_bf, fcl_ifq_icmiss_s1, fcl_ifq_rdreq_s1, 
   fcl_ifq_icache_en_s_l, fcl_ifq_thr_s1, fcl_ifq_canthr, 
   fcl_itlb_cam_vld_bf, fcl_itlb_cam_bypass_bf, fcl_itlb_addr_mask_l, 
   fcl_itlb_cam_real_bf, fcl_itlb_cam_pid_bf, fcl_itlb_wr_vld_bf, 
   fcl_itlb_dmp_vld_bf, fcl_itlb_dmp_all_bf, fcl_itlb_tag_rd_vld_bf, 
   fcl_itlb_invall_f_l, fcl_itlb_data_rd_vld_bf, fcl_erb_ievld_s1, 
   fcl_erb_tevld_s1, fcl_erb_immuevld_s1, ifu_lsu_thrid_s, 
   fcl_erb_asi_tid_f, fcl_erb_clear_iferr, fcl_erb_itlbrd_vld_s, 
   fcl_erb_itlbrd_data_s, fcl_dec_dslot_s, fcl_dtu_inst_vld_e, 
   fcl_dtu_intr_vld_e, fcl_dtu_inst_vld_d, fcl_dtu_ely_inst_vld_d, 
   fcl_dec_intr_vld_d, fcl_erb_inst_issue_d, fcl_erb_inst_vld_d1, 
   ifu_tlu_inst_vld_m, ifu_exu_inst_vld_e, ifu_exu_inst_vld_w, 
   ifu_spu_inst_vld_w, ifu_tlu_inst_vld_w, ifu_tlu_flush_w, 
   ifu_tlu_flush_m, fcl_swl_int_activate_i3, fcl_swl_flush_wake_w, 
   fcl_swl_flush_w, fcl_dcl_regz_e, ifu_tlu_thrid_e, ifu_tlu_thrid_d, 
   ifu_tlu_immu_miss_m, ifu_tlu_priv_violtn_m, ifu_tlu_icmiss_e, 
   ifu_tlu_ttype_vld_m, ifu_exu_ttype_vld_m, ifu_mmu_trap_m, 
   ifu_tlu_trap_m, ifu_tlu_ttype_m, ifu_tlu_hwint_m, 
   ifu_tlu_sftint_m, ifu_tlu_rstint_m, fcl_dtu_rst_thr_w, 
   fcl_dtu_resum_thr_w, ifu_tlu_itlb_done, ifu_spu_trap_ack, 
   ifu_exu_tid_s2, ifu_exu_ren1_s, ifu_exu_ren2_s, ifu_exu_ren3_s, 
   ifu_exu_disable_ce_e, fcl_dtu_sync_intr_d, fcl_dtu_tlzero_d, 
   fcl_dtu_privmode_d, fcl_dtu_hprivmode_d, fcl_dtu_hprivmode_w2, 
   fcl_dtu_nuke_thr_w, fcl_swl_swout_f, fcl_dtu_stall_bf, 
   fcl_swl_swcvld_s, fcl_dtu_thr_f, fcl_imd_oddwin_d, 
   fcl_fdp_oddwin_s, fcl_fdp_pcoor_vec_f, fcl_fdp_pcoor_f, 
   fcl_fdp_mask32b_f, fcl_fdp_addr_mask_d, fcl_fdp_tctxt_sel_prim, 
   fcl_fdp_usenir_sel_nir_s1, fcl_fdp_rbinst_sel_inste_s, 
   fcl_fdp_thrtnpc_sel_tnpc_l, fcl_fdp_thrtnpc_sel_npcw_l, 
   fcl_fdp_thrtnpc_sel_pcf_l, fcl_fdp_thrtnpc_sel_old_l, 
   fcl_fdp_thr_s1_l, fcl_fdp_next_thr_bf_l, fcl_fdp_next_ctxt_bf_l, 
   fcl_fdp_nirthr_s1_l, fcl_fdp_thr_s2_l, 
   fcl_fdp_tpcbf_sel_pcp4_bf_l, fcl_fdp_tpcbf_sel_brpc_bf_l, 
   fcl_fdp_tpcbf_sel_trap_bf_l, fcl_fdp_tpcbf_sel_old_bf_l, 
   fcl_fdp_pcbf_sel_nosw_bf_l, fcl_fdp_pcbf_sel_swpc_bf_l, 
   fcl_fdp_pcbf_sel_br_bf_l, fcl_fdp_trrbpc_sel_trap_bf_l, 
   fcl_fdp_trrbpc_sel_rb_bf_l, fcl_fdp_trrbpc_sel_err_bf_l, 
   fcl_fdp_trrbpc_sel_pcs_bf_l, fcl_fdp_noswpc_sel_tnpc_l_bf, 
   fcl_fdp_noswpc_sel_old_l_bf, fcl_fdp_noswpc_sel_inc_l_bf, 
   fcl_fdp_nextpcs_sel_pce_f_l, fcl_fdp_nextpcs_sel_pcd_f_l, 
   fcl_fdp_nextpcs_sel_pcs_f_l, fcl_fdp_nextpcs_sel_pcf_f_l, 
   fcl_fdp_inst_sel_curr_s_l, fcl_fdp_inst_sel_switch_s_l, 
   fcl_fdp_inst_sel_nir_s_l, fcl_fdp_inst_sel_nop_s_l, 
   fcl_fdp_tinst_sel_curr_s_l, fcl_fdp_tinst_sel_rb_s_l, 
   fcl_fdp_tinst_sel_old_s_l, fcl_fdp_tinst_sel_ifq_s_l, 
   fcl_fdp_dmpthr_l, fcl_fdp_ctxt_sel_dmp_bf_l, 
   fcl_fdp_ctxt_sel_sw_bf_l, fcl_fdp_ctxt_sel_curr_bf_l, 
   fcl_fdp_rdsr_sel_pc_e_l, fcl_fdp_rdsr_sel_thr_e_l, 
   fcl_fdp_rdsr_sel_ver_e_l, so, ifu_reset_l, 
   fcl_fdp_tlbmiss_s1, fcl_esl_tinst_vld_next_s,
   fcl_esl_brtaken_e, fcl_esl_brtaken_m, fcl_esl_thr_e, fcl_esl_thr_m,
   fcl_esl_inst_vld_d, fcl_esl_inst_vld_e, fcl_esl_inst_vld_m, 
   fcl_esl_thr_trap_bf, fcl_esl_rb_stg_s,
   // Inputs
   
   tlu_itlb_csm_rd_g,
   
   rclk, grst_l, arst_l, se, sehold, si, rst_tri_en, 
   tlu_ifu_flush_pipe_w, exu_ifu_va_oor_m, exu_ifu_oddwin_s, 
   spu_ifu_ttype_tid_w2, spu_ifu_ttype_vld_w2, spu_ifu_ttype_w2, 
   erb_fcl_spu_uetrap, exu_ifu_regz_e, dcl_fcl_bcregz0_e, 
   dcl_fcl_bcregz1_e, dtu_fcl_rollback_g, dtu_fcl_retract_d, 
   dtu_fcl_br_inst_d, dtu_fcl_sir_inst_e, dtu_fcl_privop_e, 
   dtu_fcl_fpdis_e, dtu_fcl_imask_hit_e, dtu_fcl_illinst_e, 
   dtu_fcl_thr_active, dec_fcl_rdsr_sel_pc_d, dec_fcl_rdsr_sel_thr_d, 
   ifq_fcl_wrreq_bf, ifq_fcl_icd_wrreq_bf, ifq_fcl_ictv_wrreq_bf, 
   ifq_fcl_rdreq_bf, ifq_fcl_asi_tid_bf, ifq_fcl_asird_bf, 
   ifq_fcl_invreq_bf, erb_fcl_itlb_ce_d1, erb_dtu_ifeterr_d1, 
   erb_fcl_ifet_uevec_d1, erb_fcl_ue_trapvec, erb_fcl_ce_trapvec, 
   dtu_fcl_nextthr_bf, dtu_fcl_ntr_s, dtu_fcl_running_s, 
   dtu_fcl_flush_sonly_e, fdp_fcl_swc_s2, fdp_fcl_va2_bf, 
   itlb_fcl_tlbmiss_f_l, itlb_fcl_priv_s1, itlb_fcl_cp_s1, 
   itlb_fcl_imiss_s_l, fdp_fcl_pc_oor_vec_f, fdp_fcl_pc_oor_e, 
   fdp_fcl_op_s, fdp_fcl_op3_s, fdp_fcl_ibit_s, lsu_ifu_stallreq, 
   ffu_ifu_stallreq, ifq_fcl_stallreq, dtu_inst_anull_e, 
   ifq_fcl_fill_thr, ifq_fcl_flush_sonly_e, tlu_ifu_trap_tid_w1, 
   tlu_ifu_trappc_vld_w1, tlu_ifu_trapnpc_vld_w1, 
   tlu_lsu_pstate_priv, tlu_lsu_pstate_am, tlu_hpstate_priv, 
   tlu_lsu_redmode, tlu_hpstate_enb, lsu_ifu_addr_real_l, 
   lsu_pid_state0, lsu_pid_state1, lsu_pid_state2, lsu_pid_state3, 
   lsu_ifu_icache_en, lsu_ifu_dc_parity_error_w2, lsu_ifu_t0_tlz, 
   lsu_ifu_t1_tlz, lsu_ifu_t2_tlz, lsu_ifu_t3_tlz, tlu_ifu_hwint_i3, 
   tlu_ifu_pstate_ie, tlu_ifu_sftint_vld, tlu_ifu_hintp_vld, 
   tlu_ifu_rerr_vld, tlu_ifu_rstthr_i2, tlu_ifu_rstint_i2, 
   tlu_ifu_resumint_i2, tlu_ifu_nukeint_i2, tlu_itlb_wr_vld_g, 
   tlu_itlb_dmp_vld_g, tlu_itlb_dmp_all_g, tlu_itlb_data_rd_g, 
   tlu_itlb_tag_rd_g, tlu_itlb_invalidate_all_g, tlu_fcl_dmp_pid_bf, 
   tlu_fcl_dmp_real_bf, tlu_idtlb_dmp_thrid_g, exu_ifu_ecc_ce_m, 
   ffu_ifu_fst_ce_w, config_dtu_esl_en, esl_fcl_stall_bf, 
   esl_fcl_switch_bf, esl_fcl_ntr_s, esl_fdp_issue_prev_inst_s,
   esl_fcl_force_running_s,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data,
   fdp_fcl_jtag_breakpoint_hit
   );

   input  rclk,
	        grst_l,
          arst_l,
	        se,
          sehold,
	        si;

   input  rst_tri_en;


   input  tlu_ifu_flush_pipe_w;	// flush pipe on a trap
   input  exu_ifu_va_oor_m;
   input [3:0] exu_ifu_oddwin_s;

   input [1:0] spu_ifu_ttype_tid_w2;
   input       spu_ifu_ttype_vld_w2;
   input       spu_ifu_ttype_w2;

   input [3:0] erb_fcl_spu_uetrap;  // use m3
   
//   input       dtu_fcl_brtaken_e;    // branch taken
   input       exu_ifu_regz_e;
   input       dcl_fcl_bcregz0_e,
               dcl_fcl_bcregz1_e;
   
   input       dtu_fcl_rollback_g;
   input       dtu_fcl_retract_d;
   input       dtu_fcl_br_inst_d;
   input       dtu_fcl_sir_inst_e;
   input       dtu_fcl_privop_e,
		           dtu_fcl_fpdis_e,
               dtu_fcl_imask_hit_e,
		           dtu_fcl_illinst_e;
   input [3:0] dtu_fcl_thr_active;

   input       dec_fcl_rdsr_sel_pc_d,
		           dec_fcl_rdsr_sel_thr_d;
   
   input       ifq_fcl_wrreq_bf;
   input       ifq_fcl_icd_wrreq_bf,
		           ifq_fcl_ictv_wrreq_bf,
		           ifq_fcl_rdreq_bf;

   input [1:0] ifq_fcl_asi_tid_bf;
   input       ifq_fcl_asird_bf;
   
   input       ifq_fcl_invreq_bf;

   input       erb_fcl_itlb_ce_d1;
   input       erb_dtu_ifeterr_d1;
   input [3:0] erb_fcl_ifet_uevec_d1,
		           erb_fcl_ue_trapvec,
		           erb_fcl_ce_trapvec;   
   
   input [3:0] dtu_fcl_nextthr_bf;   // thread to switch to
   input       dtu_fcl_ntr_s,        // next thread ready for ex
               dtu_fcl_running_s;

   input       dtu_fcl_flush_sonly_e;
//               dec_fcl_kill4sta_e;

   input       fdp_fcl_swc_s2,       // instruction switch condition
		           fdp_fcl_va2_bf,       // bit 2 of vaddr
		           itlb_fcl_tlbmiss_f_l,  // itlb miss
		           itlb_fcl_priv_s1,     // privileged access page
		           itlb_fcl_cp_s1,       // uncached access page
		           itlb_fcl_imiss_s_l;     // icache miss in s1

   input [3:0] fdp_fcl_pc_oor_vec_f;
   input       fdp_fcl_pc_oor_e;

   input [1:0] fdp_fcl_op_s;
   input [5:2] fdp_fcl_op3_s;
   input       fdp_fcl_ibit_s;

   input       lsu_ifu_stallreq,
	             ffu_ifu_stallreq,
               ifq_fcl_stallreq;
   
   input       dtu_inst_anull_e;

   input [3:0] ifq_fcl_fill_thr;     // fill inst goes to this
                                   	 // thread instruction register
   input       ifq_fcl_flush_sonly_e;

   input [1:0] tlu_ifu_trap_tid_w1;     // thr for which trappc is sent
   input       tlu_ifu_trappc_vld_w1,   // ld pc on trap or done/retry
		           tlu_ifu_trapnpc_vld_w1;  // ld Npc for a retry

   input [3:0] tlu_lsu_pstate_priv;     // may need to flop these three
   input [3:0] tlu_lsu_pstate_am;
   input [3:0] tlu_hpstate_priv;
   input [3:0] tlu_lsu_redmode;
   input [3:0] tlu_hpstate_enb;

   input [3:0] lsu_ifu_addr_real_l;
   input [2:0] lsu_pid_state0,
               lsu_pid_state1,
               lsu_pid_state2,
               lsu_pid_state3;
   input [3:0] lsu_ifu_icache_en;

   input       lsu_ifu_dc_parity_error_w2;
   

//   input       lsu_ifu_flush_ireg;  // not needed any more
   input       lsu_ifu_t0_tlz,
 		           lsu_ifu_t1_tlz,
 		           lsu_ifu_t2_tlz,
 		           lsu_ifu_t3_tlz;

   input [3:0] tlu_ifu_hwint_i3,        // normal interrupt
		           tlu_ifu_pstate_ie,
		           tlu_ifu_sftint_vld,
		           tlu_ifu_hintp_vld,
		           tlu_ifu_rerr_vld,
		           tlu_ifu_rstthr_i2;       // reset or idle interrupt

   input       tlu_ifu_rstint_i2,       // reset to a dead thread
		           tlu_ifu_resumint_i2,
		           tlu_ifu_nukeint_i2;

   input       tlu_itlb_wr_vld_g,
		           tlu_itlb_dmp_vld_g,
               tlu_itlb_dmp_all_g,
		           tlu_itlb_data_rd_g,
		           tlu_itlb_tag_rd_g;
   input       tlu_itlb_invalidate_all_g;

   input [2:0] tlu_fcl_dmp_pid_bf;
   input       tlu_fcl_dmp_real_bf;
   input [1:0] tlu_idtlb_dmp_thrid_g;

   input       exu_ifu_ecc_ce_m;
   input       ffu_ifu_fst_ce_w;
  
   input       config_dtu_esl_en;
   input       esl_fcl_stall_bf;
   input       esl_fcl_switch_bf;
   input       esl_fcl_ntr_s;
   input       esl_fdp_issue_prev_inst_s;
   input       esl_fcl_force_running_s;

   
   input       tlu_itlb_csm_rd_g;
   
   
   // jtag
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data; 
   
   // to icd
   output      fcl_icd_rdreq_bf,
               fcl_icv_rdreq_bf,
		           fcl_icd_wrreq_bf,
		           fcl_ict_wrreq_bf,
		           fcl_icv_wrreq_bf;

   output      fcl_icd_index_sel_ifq_bf;
   output      fcl_ifq_grant_bf;
   
   // to ifq
   output      fcl_ifq_icmiss_s1;  // if icache turned off
   output      fcl_ifq_rdreq_s1;
   output      fcl_ifq_icache_en_s_l;
   
   output [1:0] fcl_ifq_thr_s1;
   output [3:0] fcl_ifq_canthr;     // cancel ifetch to this thread

   // to itlb
   output       fcl_itlb_cam_vld_bf,
                fcl_itlb_cam_bypass_bf,
		            fcl_itlb_addr_mask_l,
                fcl_itlb_cam_real_bf;

   output [2:0] fcl_itlb_cam_pid_bf;
   
   output       fcl_itlb_wr_vld_bf,
		            fcl_itlb_dmp_vld_bf,
                fcl_itlb_dmp_all_bf,
		            fcl_itlb_tag_rd_vld_bf,
		            fcl_itlb_invall_f_l,
		            fcl_itlb_data_rd_vld_bf;
  
   
   output       fcl_itlb_csm_rd_vld_bf;
   
   
   // to erb
   output       fcl_erb_ievld_s1,
		            fcl_erb_tevld_s1,
		            fcl_erb_immuevld_s1;

   output [1:0] ifu_lsu_thrid_s,
		            fcl_erb_asi_tid_f;

   output [3:0] fcl_erb_clear_iferr;
   

   output       fcl_erb_itlbrd_vld_s,
		            fcl_erb_itlbrd_data_s;

   output       fcl_dec_dslot_s;
   output       fcl_dtu_inst_vld_e,
                fcl_dtu_intr_vld_e,
		            fcl_dtu_inst_vld_d,
                fcl_dtu_ely_inst_vld_d,
                fcl_dec_intr_vld_d,
		            fcl_erb_inst_issue_d,
		            fcl_erb_inst_vld_d1,
		            ifu_tlu_inst_vld_m,
//		            ifu_lsu_inst_vld_m,
		            ifu_exu_inst_vld_e,
		            ifu_exu_inst_vld_w,
		            ifu_spu_inst_vld_w,
		            ifu_tlu_inst_vld_w;
   
   output       ifu_tlu_flush_w;
   output       ifu_tlu_flush_m;

   output [3:0] fcl_swl_int_activate_i3;
   output       fcl_swl_flush_wake_w;
   output       fcl_swl_flush_w;

   output       fcl_dcl_regz_e;
   
   // to tlu
   output [1:0] ifu_tlu_thrid_e;
   output [1:0] ifu_tlu_thrid_d;

   output       ifu_tlu_immu_miss_m,
		            ifu_tlu_priv_violtn_m;
	 
   output       ifu_tlu_icmiss_e;
   output       ifu_tlu_ttype_vld_m;
   output       ifu_exu_ttype_vld_m;
   output       ifu_mmu_trap_m;
   output       ifu_tlu_trap_m;
   output [8:0] ifu_tlu_ttype_m;
   
   output       ifu_tlu_hwint_m;
   output       ifu_tlu_sftint_m;
//   output       ifu_tlu_hintp_m;
//   output       ifu_tlu_rerr_m;
   output       ifu_tlu_rstint_m;
   output       fcl_dtu_rst_thr_w;
   output       fcl_dtu_resum_thr_w;

   output       ifu_tlu_itlb_done;

   output       ifu_spu_trap_ack;
   
   // to exu
   output [1:0] ifu_exu_tid_s2;
   output       ifu_exu_ren1_s,
		            ifu_exu_ren2_s,
		            ifu_exu_ren3_s;

   output       ifu_exu_disable_ce_e;  // to exu and ffu
   
   
   // to dtu
   output       fcl_dtu_sync_intr_d;
   output       fcl_dtu_tlzero_d;
   output       fcl_dtu_privmode_d;
   output       fcl_dtu_hprivmode_d;
   output       fcl_dtu_hprivmode_w2;
   output       fcl_dtu_nuke_thr_w;
   output       fcl_swl_swout_f;
   output       fcl_dtu_stall_bf;
//   output       fcl_dtu_switch_s;     // indicates to the DTU that a
                                      // switch took place to next_thr
   output       fcl_swl_swcvld_s;
   output [3:0] fcl_dtu_thr_f;
   output       fcl_imd_oddwin_d;
   
   // to fdp
   output       fcl_fdp_oddwin_s;
   output [3:0] fcl_fdp_pcoor_vec_f;
   output       fcl_fdp_pcoor_f;
   output       fcl_fdp_mask32b_f;
   output       fcl_fdp_addr_mask_d;

   output [3:0] fcl_fdp_tctxt_sel_prim;

   
   // 2:1 mux selects
   output       fcl_fdp_usenir_sel_nir_s1;   // same as usenir_d2
   output [3:0] fcl_fdp_rbinst_sel_inste_s;

   output [3:0] fcl_fdp_thrtnpc_sel_tnpc_l,  // load npc
		            fcl_fdp_thrtnpc_sel_npcw_l,
		            fcl_fdp_thrtnpc_sel_pcf_l,
		            fcl_fdp_thrtnpc_sel_old_l;
   
   output [3:0] fcl_fdp_thr_s1_l;            // s1 thr for thrNIR input mux
   
   // other mux selects   
   output [3:0] fcl_fdp_next_thr_bf_l,  // for thrpc output mux
                fcl_fdp_next_ctxt_bf_l, // for ctxt output mux
		            fcl_fdp_nirthr_s1_l,    // select NIR in s1 stage
		            fcl_fdp_thr_s2_l;       // s2 thr for thr_inst_reg

   output [3:0] fcl_fdp_tpcbf_sel_pcp4_bf_l, // selects for thread PC muxes
		            fcl_fdp_tpcbf_sel_brpc_bf_l,
		            fcl_fdp_tpcbf_sel_trap_bf_l,
		            fcl_fdp_tpcbf_sel_old_bf_l;

   output       fcl_fdp_pcbf_sel_nosw_bf_l,      // F stage pc mux selects
		            fcl_fdp_pcbf_sel_swpc_bf_l,
		            fcl_fdp_pcbf_sel_br_bf_l;

   output [3:0] fcl_fdp_trrbpc_sel_trap_bf_l, 
		            fcl_fdp_trrbpc_sel_rb_bf_l,
		            fcl_fdp_trrbpc_sel_err_bf_l,
		            fcl_fdp_trrbpc_sel_pcs_bf_l;

   output       fcl_fdp_noswpc_sel_tnpc_l_bf,    // next pc select,
		            fcl_fdp_noswpc_sel_old_l_bf,		 // dont need anymore
		            fcl_fdp_noswpc_sel_inc_l_bf;

   output [3:0] fcl_fdp_nextpcs_sel_pce_f_l,  
		            fcl_fdp_nextpcs_sel_pcd_f_l,
		            fcl_fdp_nextpcs_sel_pcs_f_l,  
		            fcl_fdp_nextpcs_sel_pcf_f_l;

   output       fcl_fdp_inst_sel_curr_s_l,   // selects for inst_s2
		            fcl_fdp_inst_sel_switch_s_l,
		            fcl_fdp_inst_sel_nir_s_l,
		            fcl_fdp_inst_sel_nop_s_l;

   output [3:0] fcl_fdp_tinst_sel_curr_s_l,  // selects for tinst regs
		            fcl_fdp_tinst_sel_rb_s_l,		
		            fcl_fdp_tinst_sel_old_s_l,
		            fcl_fdp_tinst_sel_ifq_s_l;

   output [3:0] fcl_fdp_dmpthr_l;

   output       fcl_fdp_ctxt_sel_dmp_bf_l,
		            fcl_fdp_ctxt_sel_sw_bf_l,
		            fcl_fdp_ctxt_sel_curr_bf_l;

   output       fcl_fdp_rdsr_sel_pc_e_l,
                fcl_fdp_rdsr_sel_thr_e_l,
                fcl_fdp_rdsr_sel_ver_e_l;
   
   output       so,
                ifu_reset_l;

   output       fcl_fdp_tlbmiss_s1;   
   output [3:0] fcl_esl_tinst_vld_next_s;
   output       fcl_esl_brtaken_e;
   output       fcl_esl_brtaken_m;
   output [3:0] fcl_esl_thr_e;
   output [3:0] fcl_esl_thr_m;
   output       fcl_esl_inst_vld_d;
   output       fcl_esl_inst_vld_e;
   output       fcl_esl_inst_vld_m;
   output [3:0] fcl_esl_thr_trap_bf;
   output       fcl_esl_rb_stg_s;

   // input       rtap_core_stallreq;
   input       fdp_fcl_jtag_breakpoint_hit;

   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------
   reg [3:0]    fcl_fdp_tpcbf_sel_old_bf_l,
		            fcl_fdp_tpcbf_sel_pcp4_bf_l,
		            fcl_fdp_tpcbf_sel_trap_bf_l,
		            fcl_fdp_tpcbf_sel_brpc_bf_l;
   
   wire         fcl_fdp_inst_sel_nop_s_l,
                fcl_fdp_inst_sel_nir_s_l,
		            fcl_fdp_inst_sel_curr_s_l,
		            fcl_fdp_inst_sel_switch_s_l;
   

   // local signals
   wire         //sw_itlb_on,
                sw_itlb_real,
		            sw_itlb_am,
		            //this_itlb_on,
                this_itlb_real,
		            itlb_on;

   wire [3:0]   xlate_en,
                xlate_en_d1;
   
   wire [2:0]   sw_pid_bf,
                curr_pid_bf;

   wire         pid_sel_sw,
                pid_sel_curr,
                pid_sel_dmp;
   
   wire         itlb_access_gnt,
		            itlb_access_en,
                itlb_write_en,
                ctxt_sel_dmp,
		            itlb_access_done,
                itlb_write_done,
		            itlb_rd_access_done,
		            itlb_rd_access_done_d1,
		            itlb_rd_access_done_d2,
		            itlb_rd_req_bf,
		            itlb_rd_req_f,
		            itlb_data_rd_f,
                itlb_data_rd_s;
   
   wire [1:0]   asi_tid_bf;
   wire [1:0]   spu_tid_w2;
   
   wire         fetch_bf,	// fetch an instruction next cycle
                allow_ifq_access_icd_bf,
                inst_access_bf,
                ia1_bf,
                ia0_bf,
                no_instacc_bf;
   
   wire         cam_vld_bf,
                tlb_invall_bf,
                tlb_invall_f,
//                tlb_invall_req_bf,
                inst_vld_bf;
   
   wire         rdreq_bf,     // read from I$ next cycle
		            rdreq_f;
   
   wire         ic_wrreq_bf;
   
   wire         running_s2,
                valid_s,
		            running_s1,
                ely_running_s1,
		            running_d,
		            running_e,
		            running_m,
    		        inst_vld_f,
		            inst_vld_s,
                inst_vld_s_crit,
		            inst_vld_s1,
		            inst_vld_s2,    // valid bit of S stage
	 	                            // instruction.  If this is 0,
		                            // convert inst to no-op
                    inst_vld_s2_ed,
		            inst_vld_d,
                inst_vld_d_crit,
		            inst_vld_d1,
		            inst_vld_e,
		            inst_vld_qual_e,
		            inst_vld_m,
		            inst_vld_w;

   wire         inst_vld_w_crit;
   
   wire         no_iftrap_m,
                no_iftrap_w;

   wire         stall_f,
		            stall_s1,
		            stall_s1_nxt,
                ely_stall_thisthr_f,
                part_stall_thisthr_f,
		            stall_thisthr_f;
   wire         rdreq_s1;

   wire         usenir_bf,
		            usenir_f,
		            usenir_s1;
   
   wire [3:0]   tinst_vld_s,    // valid bit of thr instr register
		                            // in s stage
		            tinst_vld_nxt;

   wire [3:0]   val_thr_s1,
		            val_thr_f,
                thr_e_v2,
		            val_thr_e;
   
   wire         flush_sonly_qual_e,
                flush_sonly_all_m,
                flush_sonly_qual_m,
                ims_flush_sonly_m,
                ims_flush_sonly_w,
                ims_flush_coll_m,
                ims_flush_coll_w,
                flush_sonly_m;

   wire         flush_pipe_w;
   
   wire         kill_thread_d,
//		            kill_thread_e,
		            kill_thread_m,
                kill_local_m,
                ely_kill_thread_s2,
                ely_kill_thread_m,
		            kill_thread_s2;
   
   wire [3:0]   clear_s_d1,
                flush_thr_w,
                late_flush_w2;

   wire         utrap_flush_w,
                utrap_flush_m,
                flush_pipe_w2;
   
   wire         kill_curr_f,
                kill_curr_d,
                kill_curr_e,
                kill_curr_m;
   
   wire [3:0]   canthr_f,
                canthr_s_early,
		            canthr_s;
   wire         canthr_sw;
   wire         canthr_sm,
                canthr_sd;

   wire         forcemiss_f,   // force an icache miss (if icache is off)
		            forcemiss_s1,
                icmiss_for_perf,
//                ic_miss_sw_s1,
		            ic_miss_s1;    // icache miss (forced or not)

   wire [3:0]   icache_en_d1;

   wire         icache_on_bf,
		            icache_on_f,
		            icache_on_s1,
                uncached_page_s1;
//		            sw_icache_on,
//		            this_icache_on;
   
   wire         imsto_thisthr_s1,
                iferrto_thisthr_d1,
                retract_iferr_d1,
                retract_iferr_qual_d1,
                retract_inst_d,
                retract_iferr_e;
//   wire         intrto_thisthr_d;
//   wire         imsto_nextthr_s1;

   wire         mark4rb_w,
                mark4rb_m,
                mark4rb_e,
                mark4rb_d,
                mark4rb_s;
   
   wire [3:0]   tlbmiss_s2,
		            tlbmiss_d,
		            nir_tlbmiss_vec,
		            nir_tlbmiss_next;

   wire [3:0]   delay_slot_vec,
                delay_slot_vec_nxt;
   
   wire         tlb_cam_miss_f,
                tlb_cam_miss_s1,
                nir_tlbmiss_s1,
		            tlbmiss_s1_crit,
		            tlbmiss_s1;
   
   wire         cam_vld_f,
		            cam_vld_s1;
   
   wire         immu_fault_f,
		            immu_miss_d,
		            immu_miss_crit_d,
		            immu_miss_qual_d,
		            immu_miss_e,
//                immu_miss_qual_e,
                immu_miss_m,
                addr_real_e;
   wire [3:0]   itlb_addr_real_l,
                itlb_addr_real;
   wire [3:0]   pstate_am_d1;
   
   wire         pc_oor_s1,
                pc_oor_s2,
                pc_oor_s,
		            pc_oor_f;
   wire         set_oor_m;
   wire         addr_mask_32b_m;
   
   wire         priv_mode_s1,
                priv_mode_f,
                hpriv_mode_s1,
                hpriv_mode_w,
                hpriv_mode_w2,
                hpriv_mode_f;

   wire         inst_acc_exc_s1,
		            inst_acc_exc_d,
		            inst_acc_exc_e;
   wire [3:0]   inst_acc_vec_s2,
		            inst_acc_vec_d;
   
   wire         priv_violtn_e,
                priv_violtn_m;

   wire         trap_e,
		            trap_m;
   
   wire         ttype_sel_spuma_e,
 		            ttype_sel_spuenc_e,
		            ttype_sel_corr_err_e,
		            ttype_sel_unc_err_e,		
		            ttype_sel_res_err_e,		
		            ttype_sel_hstk_cmp_e,		
		            ttype_sel_pcoor_e,
		            ttype_sel_immu_miss_e, 
		            ttype_sel_real_trans_e, 
		            ttype_sel_icache_err_e,
		            ttype_sel_priv_viol_e, 
		            ttype_sel_privop_e,    
		            ttype_sel_illinst_e,
		            ttype_sel_ibe_e,
		            ttype_sel_sir_e,
		            ttype_sel_fpdis_e;
   
   wire [8:0]   ttype_e;
   
   wire [3:0]   next_nir_privvec,
		            nir_privvec;
   wire         nir_priv_s1,
		            priv_inst_s1;
   
   wire         tlzero_s2;
   wire [3:0]   tlzero_vec_d1;

   wire         nuke_thr_w,
                resum_thr_w,
                rst_thr_w;

   wire [3:0]   spu_thr;
//   wire [3:0]   rst_thr_bf;
   
   wire [3:0]   async_rst_i3,
                async_rst_i4,
		            next_rst_i2,
		            rstint_i2,
		            rstint_i3,
		            resumint_i2,
		            resumint_i3,
                next_resum_i2,
		            nuke_thr_i2,
		            next_nuke_i2,
		            nuke_thr_i3,
		            next_sftint_i2,
                next_hintp_i2,
                next_rerr_i2,
		            next_hwint_i3,
		            sftint_i3,
                hintp_i3,
                rerr_i3,
		            hwint_i4,
		            next_ceint_i2,
		            ceint_i3,
		            next_ueint_i2,
		            ueint_i3,
		            next_spuint0_i2,
		            spuint0_i3,
		            next_spuint1_i2,
		            spuint1_i3;

   wire [3:0]   intr_in_pipe;

   wire [3:0]   hypv_int_en,
                hypv_int_en_d1;
   wire [3:0]   supv_int_en,
                supv_int_en_d1;

   wire [3:0]   ifet_ue_vec_d1,
		            ifet_ue_vec_e;
   wire         ifet_ue_e;

   wire [3:0]   any_intr_vec_f,
                any_intr_vec_s,
                intr_pending_nxt,
                intr_pending_s,
                supv_masked_intr_s,
                hypv_masked_intr_s;

   wire         spuint0_m,
                spuint0_trap_m,
//                spuint0_qual_m,
		            spuint0_e,
		            spuint0_qual_e,
                spuint0_w,
                spuint0_trap_w,
 		            spuint1_m,
                spuint1_trap_m,
//                spuint1_qual_m,
		            spuint1_e,
		            spuint1_qual_e,
                spuint1_w,
                spuint1_trap_w,
                hwint_m,
                hwint_e,
                rstint_m,
//                rstint_qual_m,
                resumint_m,
                resumint_qual_m,
                sftint_m,
                sftint_e,
                sftint_qual_e,
                hintp_e,
                hintp_qual_e,
                hintp_m,
                rerr_e,
                rerr_qual_e,
                rerr_m,
                nuke_thr_m,
                nuke_thr_qual_m,
		            ceint_m,
                ceint_trap_m,
                ceint_trap_w,
//                ceint_qual_m,
                ceint_qual_w,
		            ceint_e,
		            ceint_qual_e,
		            ueint_m,
                ueint_trap_m,
                ueint_trap_w,
//                ueint_qual_m,
                ueint_qual_w,
                ueint_qual_e,
		            ueint_e;

   wire         disr_trap_m,
                rb_intr_m,
                rb_intr_w,
                any_intr_m;
   
   wire         force_intr_s;
   wire         intr_vld_s,
		            intr_vld_d,
		            intr_vld_e,
		            intr_vld_m,
		            intr_vld_w,
                intr_vld_qual_s,
		            intr_vld_qual_d,
		            intr_vld_qual_e,
		            intr_vld_qual_m;
   
   wire         kill_intr_f,
		            kill_intr_d,
		            kill_intr_e;
   
//	 wire         kill_intr_m;
   
   wire         rst_stallreq,
                rst_stallreq_l,
                all_stallreq,
                rst_itlb_stv_l,
                arst_vld_f,
                arst_vld_f_l,
                arst_vld_s,
                arst_vld_s_l,
                async_intr_vld_s,
                itlb_starv_alert,
                rst_sw_bf,
                rst_sw_bf_l,
                sw_for_real_rst_bf,
                rst_stallreq_d0,
		            rst_stallreq_d1,
		            rst_stallreq_d2;

   wire         lsu_stallreq_d1,
                ffu_stallreq_d1;
   
   wire [3:0]   rstint_penc;
   
   wire         usep_bf,
                set_usen_bf,
                usen_iso_bf,
		            usen_bf;
   wire         va2_f;
   wire         ntpc_thisthr;
   
   wire [3:0]   thr_usen_nxt,
 		            thr_usen_bf;
   
   wire         brto_nxtthr_bf_l,  // intermediate signal for icadr sel
//                brto_nxtthr_bf,
//                thr_match_ne_norst,
                sw_match_ne_norst,
                brtaken_buf_e,
                brtaken_unq_e,
                brtaken_e,
                brtaken_m;
   
   wire         switch_bf,   // switch in next cycle unless stall
                switch_qual_bf,
		            switch_s2;  // switch in this cycle
   
   wire         rstt,       // set thr_f to the reset pkt thread
		            swt,        // switch to nextthr_bf
		            samet;      // don't change thread

   wire [3:0]   thr_f_crit,
                thr_f_dec,
                thr_f_flop;

   wire [3:0]   thr_f,      // = thr_s2
		            thr_bf,
		            thr_s1,     // = thr_d
		            thr_s1_next,
                dec_thr_s1_l,
		            thr_d,
		            thr_e,
		            thr_m,
		            thr_w2,
		            thr_w;

   wire         tm_fd_l;
   
   wire         thr_match_fw,
		            thr_match_fw2,
		            thr_match_dw,
		            thr_match_dw2,
		            thr_match_em,
		            thr_match_ew,
		            thr_match_ew2,
		            same_thr_mw2,
		            thr_match_mw,
		            thr_match_fm,
		            thr_match_de,
		            thr_match_dm,
		            thr_match_fe,
		            thr_match_fd,
		            thr_match_fs1,
		            thr_match_nw,
		            thr_match_nd,
		            thr_match_ne;
//		            thr_match_ft;

   wire         rb2_inst_d,
		            rb2_inst_e,
		            rb1_inst_s,
		            rb1_inst_d,
		            rb0_inst_bf,
		            rb0_inst_s,
		            rt2_inst_e,
		            rt1_inst_s,
		            rt1_inst_d,
		            rt0_inst_bf,
		            rt0_inst_s;
   
   wire [3:0]   rb_w2,
                rb_for_iferr_e,
		            rb_froms,
		            rb_frome,
		            rb_fromd;
   
   wire         rb_stg_s,
		            rb_stg_d,
                rb_stg_d_crit,
		            rb_stg_e;
   
   wire         icadr_selbr_l,
//		            icadr_selsw,
//                icadr_selbr,
                icadr_selsw_l;

   wire         sw_or_async_stall;
   
   wire [3:0]   trap_thr;
   
   wire [3:0]   load_tpc,     // thread pc reg input select
		            load_bpc,     // these should be exclusive in normal mode
		            load_pcp4;    // but not during scan shift or reset
   
   wire         irf_ce_w,
		            irf_ce_m,
                any_ce_w,
		            rb_stg_w;

   wire [3:0]   ce_cnt0,
                ce_cnt0_nxt,
                ce_cnt1,
                ce_cnt1_nxt,
                ce_cnt_rst;
   
   wire         ce_val0_d,
                ce_val1_d,
                disable_ce_e,
                disable_ce_d;
   
   wire [3:0]   ntpc_vld,     // use thr_nextpc_f
		            ntpc_vld_nxt;
   
   wire [1:0]   sas_thrid_w;
   
   wire         rdsr_sel_pc_e,
		    		    rdsr_sel_thr_e;

   wire [1:0]   trap_tid_w2;
   wire         trappc_vld_w2, 
                trapnpc_vld_w2;

   wire         fcl_reset,
                fcl_reset_l;

   // some monitor is looking for this signal
//   wire         fcl_swl_flush_wait_w=1'b0;
   wire         clk;
   
   wire [3:0]   nextthr_bf_buf,
                nextthr_final_bf;


//
// Code start here 
//
   assign       clk = rclk;
   
//----------------------------------------------------------------------
// Fetch Unit Controls
//----------------------------------------------------------------------

   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (fcl_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign   fcl_reset = ~fcl_reset_l;
   assign   ifu_reset_l = fcl_reset_l;
   

//-----------------------------------
// TLB Operations
//-----------------------------------

   dff_s #(4) real_reg(.din (lsu_ifu_addr_real_l),
                     .q   (itlb_addr_real_l),
                     .clk (clk), .se(se), .si(), .so());
   assign   itlb_addr_real = ~itlb_addr_real_l;

   // ITLB on signal

//`ifdef SPARC_HPV_EN   
   assign   xlate_en = (~tlu_hpstate_enb & lsu_ifu_addr_real_l |
                        tlu_hpstate_enb & ~tlu_hpstate_priv) & 
                         ~tlu_lsu_redmode;
   
//`else
//   assign   xlate_en = lsu_ifu_addr_real_l;
//`endif

   dff_s #(4) xlate_reg(.din (xlate_en),
                      .q   (xlate_en_d1),
                      .clk (clk), .se(se), .si(), .so());
   
//   assign sw_itlb_on = ((nextthr_bf_buf & xlate_en_d1) == 4'b0) ?
//		                     1'b0 : 1'b1;
//   assign this_itlb_on = ((thr_f & xlate_en_d1) == 4'b0) ?
//			                     1'b0 : 1'b1;
//   assign itlb_on = switch_bf ? sw_itlb_on : this_itlb_on;
   assign itlb_on = (nextthr_final_bf[0] & xlate_en_d1[0] |
                     nextthr_final_bf[1] & xlate_en_d1[1] |
                     nextthr_final_bf[2] & xlate_en_d1[2] |
                     nextthr_final_bf[3] & xlate_en_d1[3]);
   

   // flop xlate_en (done) addr_real and icache_en if timing is 
   // not cutting it

   // Hypervisor signals
   assign sw_itlb_real = ((nextthr_bf_buf & itlb_addr_real) == 4'b0) ?
		                     1'b0 : 1'b1;
   assign this_itlb_real = ((thr_f & itlb_addr_real) == 4'b0) ?
			                     1'b0 : 1'b1;

//   assign fcl_itlb_cam_real_bf = switch_bf ? sw_itlb_real : this_itlb_real;

   mux3ds  creal_mx(.dout (fcl_itlb_cam_real_bf),
                    .in0  (sw_itlb_real),
                    .in1  (this_itlb_real),
                    .in2  (tlu_fcl_dmp_real_bf),
                    .sel0 (pid_sel_sw),
                    .sel1 (pid_sel_curr),
                    .sel2 (pid_sel_dmp));

   // Partition ID
   mux4ds #(3) swpid_mux (.dout (sw_pid_bf[2:0]),
                          .in0  (lsu_pid_state0[2:0]),
                          .in1  (lsu_pid_state1[2:0]),
                          .in2  (lsu_pid_state2[2:0]),
                          .in3  (lsu_pid_state3[2:0]),
                          .sel0 (nextthr_bf_buf[0]),
                          .sel1 (nextthr_bf_buf[1]),
                          .sel2 (nextthr_bf_buf[2]),
                          .sel3 (nextthr_bf_buf[3]));

   mux4ds #(3) currpid_mux (.dout (curr_pid_bf[2:0]),
                            .in0  (lsu_pid_state0[2:0]),
                            .in1  (lsu_pid_state1[2:0]),
                            .in2  (lsu_pid_state2[2:0]),
                            .in3  (lsu_pid_state3[2:0]),
                            .sel0 (thr_f[0]),
                            .sel1 (thr_f[1]),
                            .sel2 (thr_f[2]),
                            .sel3 (thr_f[3]));

//   assign fcl_itlb_cam_pid_bf[2:0] = switch_bf ?  
//                                       sw_pid_bf[2:0] : 
//                                       curr_pid_bf[2:0];

//   assign pid_sel_dmp = tlu_itlb_dmp_actxt_g & ctxt_sel_dmp;
   assign pid_sel_dmp = ctxt_sel_dmp;   
   assign pid_sel_curr = ~pid_sel_dmp & ~switch_bf;
   assign pid_sel_sw = ~pid_sel_dmp & switch_bf;
   mux3ds #(3) ipid_mx(.dout (fcl_itlb_cam_pid_bf[2:0]),
                       .in0  (sw_pid_bf[2:0]),
                       .in1  (curr_pid_bf[2:0]),
                       .in2  (tlu_fcl_dmp_pid_bf[2:0]),
                       .sel0 (pid_sel_sw),
                       .sel1 (pid_sel_curr),
                       .sel2 (pid_sel_dmp));
   
   // ITLB address mask
   dff_s #(4) am_reg(.din (tlu_lsu_pstate_am),
                   .q   (pstate_am_d1),
                   .clk (clk), .se(se), .si(), .so());
   
   assign sw_itlb_am = ((nextthr_bf_buf & pstate_am_d1) == 4'b0) ?
		                     1'b0 : 1'b1;
   assign fcl_itlb_addr_mask_l = switch_bf ? 
                                 ~sw_itlb_am : ~fcl_fdp_mask32b_f;

   dff_s #(4) tlz_reg(.din ({lsu_ifu_t3_tlz,
                           lsu_ifu_t2_tlz,
                           lsu_ifu_t1_tlz,
                           lsu_ifu_t0_tlz}),
                    .q   (tlzero_vec_d1[3:0]),
                    .clk (clk), .se (se), .si(), .so());
                           

   // TLB context select
   assign fcl_fdp_tctxt_sel_prim = tlzero_vec_d1 & itlb_addr_real_l;
//   assign fcl_fdp_tctxt_sel_prim[1] = lsu_ifu_t1_tlz & itlb_addr_real_l[1];
//   assign fcl_fdp_tctxt_sel_prim[2] = lsu_ifu_t2_tlz & itlb_addr_real_l[2];
//   assign fcl_fdp_tctxt_sel_prim[3] = lsu_ifu_t3_tlz & itlb_addr_real_l[3];
   

   // Access to TLB
   // ITLB may be accessed even when icache is off
   assign cam_vld_bf = itlb_on & inst_access_bf;
                        
   assign fcl_itlb_cam_vld_bf = cam_vld_bf;
   assign fcl_itlb_cam_bypass_bf = ~cam_vld_bf;
   
   dff_s #(1) itlb_onf_ff(.din (cam_vld_bf),
		                    .q   (cam_vld_f),
		                    .clk (clk),
		                    .se  (se), .si(), .so());

   dff_s #(1) itlb_ons1_ff(.din (cam_vld_f),
		                     .q   (cam_vld_s1),
		                     .clk (clk),
		                     .se  (se), .si(), .so());

   // allow rd/wr/demap access to tlb
   // itlb access is granted only every other cycle
   // (not enough time to turn the request from mmu around)
//   assign itlb_access_en = ~cam_vld_bf & ~ifq_fcl_asird_bf & 
//                           ~itlb_access_done;
//
//   assign itlb_write_en = ~cam_vld_bf & ~ifq_fcl_asird_bf & 
//                           ~itlb_write_done & 
//                           (~tlu_itlb_dmp_vld_g | itlb_access_done);

// Save some timing   
//   assign itlb_write_en = (~itlb_on | no_instacc_bf) & ~ifq_fcl_asird_bf &
//                          ~itlb_write_done & 
//                          (~tlu_itlb_dmp_vld_g | itlb_access_done);

   assign itlb_write_en = no_instacc_bf & ~ifq_fcl_asird_bf & 
                          ~itlb_write_done &  
                          (~tlu_itlb_dmp_vld_g | itlb_access_done);
   assign itlb_access_en = no_instacc_bf & ~ifq_fcl_asird_bf &
                           ~itlb_access_done;

   // reset tlb
//   dff #(1) itlbrst_ff(.din (tlu_itlb_invalidate_all_g),
//		                   .q   (tlb_invall_req_bf),
//		                   .clk (clk), .se(se), .si(), .so());
//   assign tlb_invall_bf = tlb_invall_req_bf & ~itlb_access_done;
   assign tlb_invall_bf = sehold ? tlb_invall_f :
                           (tlu_itlb_invalidate_all_g & itlb_access_en);
   dff_s #(1) itlbrstf_ff(.din (tlb_invall_bf),
		                    .q   (tlb_invall_f),
		                    .clk (clk), .se(se), .si(), .so());

   assign fcl_itlb_wr_vld_bf = tlu_itlb_wr_vld_g & itlb_write_en;
   assign fcl_itlb_dmp_vld_bf = tlu_itlb_dmp_vld_g & itlb_access_en;
   assign fcl_itlb_dmp_all_bf = tlu_itlb_dmp_all_g & tlu_itlb_dmp_vld_g & 
                                itlb_access_en;

//   assign fcl_itlb_invall_bf = tlb_invall_bf & itlb_access_en | fcl_reset;
   assign fcl_itlb_invall_f_l = ~tlb_invall_f;

   assign fcl_itlb_data_rd_vld_bf = tlu_itlb_data_rd_g & itlb_access_en & 
	                                  ~itlb_rd_access_done_d2 &
                                    ~itlb_rd_access_done_d1;
 
   assign fcl_itlb_tag_rd_vld_bf = tlu_itlb_tag_rd_g & itlb_access_en &
	                                 ~itlb_rd_access_done_d2 &
                                   ~itlb_rd_access_done_d1;

   
   assign fcl_itlb_csm_rd_vld_bf = tlu_itlb_csm_rd_g & itlb_access_en & 
	                                  ~itlb_rd_access_done_d2 &
                                    ~itlb_rd_access_done_d1;
   

   assign rst_itlb_stv_l = ((tlu_itlb_invalidate_all_g |
                             tlu_itlb_dmp_vld_g |
                             tlu_itlb_data_rd_g |
                             
                             tlu_itlb_csm_rd_g  | 
                             
                             tlu_itlb_tag_rd_g) & ~itlb_access_done |
                            tlu_itlb_wr_vld_g & ~itlb_write_done) &
                             ~fcl_reset;

   sparc_ifu_ctr5 starv_ctr(
			                      // Outputs
			                      .limit	(itlb_starv_alert),
			                      .so	(so),
			                      // Inputs
			                      .clk	(clk),
			                      .se	(se),
			                      .si	(si),
			                      .rst_ctr_l (rst_itlb_stv_l));


   assign itlb_rd_req_bf = fcl_itlb_data_rd_vld_bf | fcl_itlb_tag_rd_vld_bf | fcl_itlb_csm_rd_vld_bf;

   // tlb access request
   assign itlb_access_gnt = (fcl_itlb_data_rd_vld_bf |
                             fcl_itlb_csm_rd_vld_bf  | 
			                       fcl_itlb_tag_rd_vld_bf  |
//                             tlb_invall_bf & itlb_access_en |
                             tlb_invall_bf |
                             fcl_itlb_dmp_vld_bf);











   dff_s #(1) tlb_gnt1_ff(.din (itlb_access_gnt),
		                  .q   (itlb_access_done),
		                  .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_rd_ff(.din (itlb_rd_req_bf),
		                .q   (itlb_rd_req_f),
		                .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_wrt1_ff(.din (fcl_itlb_wr_vld_bf),
		                    .q   (itlb_write_done),
		                    .clk (clk), .se  (se), .si(), .so());
   

   // TBD:
   // reads need to wait one more cycle.  Others can ack without this
   // second delay.
   assign itlb_rd_access_done = itlb_rd_req_f & itlb_access_done;
   
   dff_s #(1) tlb_rd1_ff(.din (itlb_rd_access_done),
		                  .q   (itlb_rd_access_done_d1),
		                  .clk (clk), .se  (se), .si(), .so());
   dff_s #(1) tlb_rd2_ff(.din (itlb_rd_access_done_d1),
		                   .q   (itlb_rd_access_done_d2),
		                  .clk (clk), .se  (se), .si(), .so());
   assign ifu_tlu_itlb_done = ~itlb_rd_req_f & itlb_access_done |
                               itlb_write_done | 
	                             itlb_rd_access_done_d2;

   assign fcl_erb_itlbrd_vld_s = itlb_rd_access_done_d1;
   
   assign asi_tid_bf = ifq_fcl_asird_bf ? ifq_fcl_asi_tid_bf :
	                                        tlu_idtlb_dmp_thrid_g;
   
   dff_s #(2) asi_tid_reg(.din (asi_tid_bf),
		                  .q   (fcl_erb_asi_tid_f),
		                  .clk (clk), .se(se), .si(), .so());
   
		    
   // Remember if we read tag or data
   dff_s #(1) tlb_rddf_ff(.din (fcl_itlb_data_rd_vld_bf),
		                  .q   (itlb_data_rd_f),
		                  .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_rdds_ff(.din (itlb_data_rd_f),
		                  .q   (itlb_data_rd_s),
		                  .clk (clk), .se  (se), .si(), .so());

   // pick itlb ldxa data
   assign fcl_erb_itlbrd_data_s =  itlb_data_rd_s;

   // Demap thread
   assign fcl_fdp_dmpthr_l[0] = ~(~tlu_idtlb_dmp_thrid_g[1] & ~tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[1] = ~(~tlu_idtlb_dmp_thrid_g[1] & tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[2] = ~(tlu_idtlb_dmp_thrid_g[1] & ~tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[3] = ~(tlu_idtlb_dmp_thrid_g[1] & tlu_idtlb_dmp_thrid_g[0]);

   // Select appropriate context for TLB
   // ctxt_sel_dmp is itlb_access_en without the asird signal
   assign ctxt_sel_dmp = no_instacc_bf & ~itlb_access_done;
   assign fcl_fdp_ctxt_sel_dmp_bf_l = ~ctxt_sel_dmp;   
   assign fcl_fdp_ctxt_sel_sw_bf_l = ctxt_sel_dmp | ~switch_bf;
   assign fcl_fdp_ctxt_sel_curr_bf_l = ctxt_sel_dmp | switch_bf;
   
   
//--------------------------
// Fetch Request and Stall
//--------------------------
   
   // Determine if we need can continue fetching next cycle
//   assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq) &
//                   (switch_bf |
//                    ~(part_stall_thisthr_f | fdp_fcl_swc_s2));
//                    ~(stall_thisthr_f | fdp_fcl_swc_s2 | immu_fault_f));

   // mmckeown: Added stall due to execution drafting here
   wire esl_stallreq = config_dtu_esl_en & esl_fcl_stall_bf;
   // trin: add stall signal from jtag (debuggin)
   //  going to flop it so the input doesn't affect the logic timing
   //  and the stall signal doesn't have to be precise anyway

// trin
// always @ *
// begin
//    rtap_lsu_ctlbits_wr_en = 0;
//    if (rtap_core_val && rtap_core_id == `JTAG_CORE_ID_LSU_CONTROL_BITS)
//    begin
//       if (rtap_core_threadid == 2'd0)
//          rtap_lsu_ctlbits_wr_en = 4'b0001;
//       else if (rtap_core_threadid == 2'd1)
//          rtap_lsu_ctlbits_wr_en = 4'b0010;
//       else if (rtap_core_threadid == 2'd2)
//          rtap_lsu_ctlbits_wr_en = 4'b0100;
//       else if (rtap_core_threadid == 2'd3)
//          rtap_lsu_ctlbits_wr_en = 4'b1000;
//    end
//    rtap_lsu_ctlbits_data = rtap_core_data[13:0];
// end

   // reg rtap_core_stallreq_f;
   // always @ (posedge rclk)
   // begin
   //    if (!grst_l)
   //       rtap_core_stallreq_f <= 1'b0;
   //    else
   //       rtap_core_stallreq_f <= rtap_core_stallreq;
   // end
   // assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq & ~rtap_core_stallreq_f) &
   //                     (switch_bf |  // replace with ntr_s?
   //                      ~(part_stall_thisthr_f  
   //                        | fdp_fcl_swc_s2
   //                        )
   //                      );
   // assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq) &
   //                     (switch_bf |  // replace with ntr_s?
   //                      ~(part_stall_thisthr_f  
   //                        | fdp_fcl_swc_s2
   //                        )
   //                      );
   // trin note: thankfully this signal is flopped so long latency of
   // other signals doesn't affect it too much

   reg jtag_breakpoint_stall_en;
   wire jtag_breakpoint_stall;

   always @ (posedge clk)
   begin
      if (!fcl_reset_l)
      begin
         jtag_breakpoint_stall_en <= 1'b0;
      end
      else
      begin
         if (rtap_core_val && rtap_core_id == 4'd7)
            jtag_breakpoint_stall_en <= 1'b1;
      end
   end


   assign jtag_breakpoint_stall = fdp_fcl_jtag_breakpoint_hit & jtag_breakpoint_stall_en;

   assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq & ~jtag_breakpoint_stall) &
                       (switch_bf |  // replace with ntr_s?
                        ~(part_stall_thisthr_f  
                          | fdp_fcl_swc_s2
                          )
                        );

   // dtu_fcl_running_s should be a part of this eqn, since it is assumed
   // by the ifill completion prediction logic in the swl
//   assign inst_access_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
//                            (switch_bf & ~usen_iso_bf |
//                             ~switch_bf & ~ely_stall_thisthr_f &
//                             dtu_fcl_running_s & 
//                             ~ely_kill_thread_s2 &
//                             //~fdp_fcl_swc_s2 & // take out for tim reasons
//                             ~usep_bf));

   assign ia0_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
                    (switch_bf |
                     ~ely_stall_thisthr_f &
                     dtu_fcl_running_s & 
                     ~ely_kill_thread_s2 &
                     ~usep_bf));

   assign ia1_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
                    (~switch_bf & ~ely_stall_thisthr_f &
                     dtu_fcl_running_s & 
                     ~ely_kill_thread_s2 &
                     ~usep_bf));
   

   assign inst_access_bf = usen_iso_bf ? ia1_bf : ia0_bf;
   // needs to work even if usen_iso_bf is X - not nec. 11/06/03
//   dp_mux2es #(1) ia_mx(.dout (inst_access_bf),
//                        .in0  (ia0_bf),
//                        .in1  (ia1_bf),
//                        .sel  (usen_iso_bf));
   
   

//   assign allow_ifq_access_icd_bf = (all_stallreq | rs
//                                     ~switch_bf & 
//                                     (usep_bf | stall_f) |
//                                     switch_bf & usen_bf);
   assign allow_ifq_access_icd_bf = ~inst_access_bf;
   
   // earlier version for critical stuff
   assign no_instacc_bf = all_stallreq | fcl_reset | rst_stallreq |
                          ~dtu_fcl_ntr_s & (ely_stall_thisthr_f | usep_bf);
   
   // check if icache is on
   dff_s #(4) ic_en_reg(.din (lsu_ifu_icache_en),
                      .q   (icache_en_d1),
                      .clk (clk), .se(se), .si(), .so());
   
//   assign sw_icache_on = (nextthr_bf_buf[0] & icache_en_d1[0] |
//                          nextthr_bf_buf[1] & icache_en_d1[1] |
//                          nextthr_bf_buf[2] & icache_en_d1[2] |
//                          nextthr_bf_buf[3] & icache_en_d1[3]);
//   assign this_icache_on = (thr_f[0] & icache_en_d1[0] |
//                            thr_f[1] & icache_en_d1[1] |
//                            thr_f[2] & icache_en_d1[2] |
//                            thr_f[3] & icache_en_d1[3]);
//   assign icache_on_bf = switch_bf ? sw_icache_on : this_icache_on;

   assign icache_on_bf = (nextthr_final_bf[0] & icache_en_d1[0] |
                          nextthr_final_bf[1] & icache_en_d1[1] |
                          nextthr_final_bf[2] & icache_en_d1[2] |
                          nextthr_final_bf[3] & icache_en_d1[3]);

   // remember if icache was turned on
   dff_s #(1) icef_ff(.din (icache_on_bf),
		              .q   (icache_on_f),
		              .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ices_ff(.din (icache_on_f),
		              .q   (icache_on_s1),
		              .clk (clk), .se(se), .si(), .so());

   // check if cp is set
   assign uncached_page_s1 = ~itlb_fcl_cp_s1 & cam_vld_s1;
   assign fcl_ifq_icache_en_s_l = ~icache_on_s1 | uncached_page_s1;
   
   // Read from the icache only if 
   //   we need to fetch AND 
   //   the icache is on AND 
   //   we are not using the NIR 
   assign rdreq_bf = icache_on_bf & inst_access_bf;

   assign fcl_icd_rdreq_bf = rdreq_bf | ifq_fcl_rdreq_bf;

   // split off driver to icv to reduce load
   assign fcl_icv_rdreq_bf = rdreq_bf | ifq_fcl_rdreq_bf;
   
   // Read req pipe
   dffr_s #(1)  rdreq_ff(.din  (rdreq_bf),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (rdreq_f),
		                 .se   (se), .si(), .so());
   // Remember if we fetched in the last cycle
   dff_s #(1)  rdreqs1_ff (.din  (rdreq_f),
		                   .clk  (clk),
		                   .q    (rdreq_s1),
		                   .se   (se), .si(), .so());
   assign fcl_ifq_rdreq_s1 = ~stall_s1;

   // Use NIR pipe
   assign usenir_bf = switch_bf ? usen_bf : usep_bf;
   
   dffr_s #(1)  unf_ff(.din  (usenir_bf),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (usenir_f),
		                 .se   (se), .si(), .so());
   // Remember if we fetched in the last cycle
   dff_s #(1)  uns1_ff (.din  (usenir_f),
		                  .clk  (clk),
		                  .q    (usenir_s1),
		                  .se   (se), .si(), .so());


   // Write signal to icache if no access from pipe
   assign ic_wrreq_bf = allow_ifq_access_icd_bf & ifq_fcl_wrreq_bf;

   assign fcl_icd_wrreq_bf = ic_wrreq_bf | ifq_fcl_icd_wrreq_bf;
   assign fcl_ict_wrreq_bf = ic_wrreq_bf | ifq_fcl_ictv_wrreq_bf;
   assign fcl_icv_wrreq_bf = ic_wrreq_bf | ifq_fcl_ictv_wrreq_bf |
                             ifq_fcl_invreq_bf;

   // synopsys translate_off
   always @ (posedge clk)
   begin
	    if (fcl_icd_rdreq_bf & fcl_icd_wrreq_bf)
	      begin
		 // 0in <fire -message "ERROR: sparc_ifu_fcl: rd and wr req to I$ at the same time"

           
			 $display( "CACHE_CONTENTION", "ERROR: sparc_ifu_fcl: rd and wr req to I$ at the same time");
             $finish();

	      end
   end
   // synopsys translate_on
   

   //-------------------------
   // Valid Instruction Pipe
   //-------------------------
   // F stage
   assign inst_vld_bf = fetch_bf;
   dff_s #(1) inst_vld_ff(.din (inst_vld_bf),
		                  .clk (clk),
		                  .q   (inst_vld_f),
		                  .se  (se), .si(), .so());

   assign stall_f = ~inst_vld_f | kill_curr_f;
   assign stall_thisthr_f = stall_f | imsto_thisthr_s1 | // intrto_thisthr_d |
	                          kill_thread_s2 | rb_stg_s | ~dtu_fcl_running_s | 
                            iferrto_thisthr_d1;

   // mmckeown: stall signal ignoring whether there is a valid instruction in F
   wire stall_ed_s2 = kill_curr_f | imsto_thisthr_s1 | kill_thread_s2 |
                      rb_stg_s | ~dtu_fcl_running_s | iferrto_thisthr_d1;

   assign part_stall_thisthr_f = stall_f | 
                                 imsto_thisthr_s1 |
                                 ~dtu_fcl_running_s | 
                                 ely_kill_thread_s2 |
	                               rb_stg_s;
   
   assign ely_stall_thisthr_f = stall_f | rb_stg_s;
   
   // mmckeown: pipe forward next thread ready in s stage to determine
   //           if thread is ready for ED in S2
   dff_s #(1) inst_vld_s2_ed_f (.din (esl_fcl_force_running_s),
                              .clk (clk),
                              .q (inst_vld_s2_ed),
                              .se (se), .si (), .so ());   

//   assign stall_s1_nxt = stall_thisthr_f | intr_vld_s | tmsto_thisthr_f;
   assign stall_s1_nxt = stall_thisthr_f; //| intr_vld_s;
   
   // S1 stage
   dff_s #(1) stalld_ff(.din (stall_s1_nxt),
		                  .clk (clk),
		                  .q   (stall_s1),
		                  .se  (se), .si(), .so());

   assign inst_vld_s1 = ~stall_s1 & ~ic_miss_s1 & ~kill_curr_d;
   assign val_thr_s1 = thr_s1 & {4{inst_vld_s1}}; // 4b

   // S2 stage
   assign val_thr_f = thr_f & {4{~stall_f & ~rb_stg_s & dtu_fcl_running_s}};
   // mmckeown: Need to add this signal to kill instructions in TIRs when
   //           converged so that they don't get executed when we fall
   //           out of being converged
   wire [3:0] val_thr_s2_ed = thr_f & {4{config_dtu_esl_en & esl_fdp_issue_prev_inst_s}};

   // Tag the S stage thr inst register as containing a valid inst or not
   assign tinst_vld_nxt = (ifq_fcl_fill_thr |  
                           (rb_w2 & ~rb_for_iferr_e) | // set
                                 // mmckeown: This will invalidate
                                 // instructions when drafting
			                     val_thr_s1 & ~(val_thr_f | val_thr_s2_ed) |
                           //			   val_thr_s1 |
			                     tinst_vld_s & ~(val_thr_f | val_thr_s2_ed)) &
			                      ~(clear_s_d1 |
                              {4{erb_dtu_ifeterr_d1 & inst_vld_d1 & 
                                 ~rb_stg_e}} & thr_e);   // reset

   dffr_s #(4) tinst_reg(.din  (tinst_vld_nxt),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (tinst_vld_s),
		                 .se   (se), .si(), .so());
   assign fcl_esl_tinst_vld_next_s = tinst_vld_nxt;

   // Does current thread have valid inst in s2
   // mmckeown: Valid instruction is s2 if we are drafting. This would
   //           not be high when we are drafting otherwise
   assign inst_vld_s2 = ((thr_f_crit & (tinst_vld_s | val_thr_s2_ed)) == 4'b0000) ?
			                    {1'b0} :  {1'b1};          

   assign inst_vld_s = ~switch_s2 & inst_vld_s1 | 
	                      switch_s2 & inst_vld_s2;
   // mmckeown: For instruction in S to be valid, we should have said
   //           so from execution drafting logic
   assign inst_vld_s_crit = ~switch_s2 & ~stall_s1 & ~kill_curr_d | 
	                      switch_s2 & inst_vld_s2;

   assign valid_s = inst_vld_s & ~stall_f &  // f and s2 have same thread
                       dtu_fcl_running_s &
	                     ~(ely_kill_thread_s2 | rb_stg_s);

   // mmckeown: S2 needs to be running if we are replaying something
   //           when converged
   // BUG FIX: Instruction in D needs to be valid when a immu fault (page
   // fault) occurs, so we have to add immu_fault_f into this signal
   assign running_s2 = (inst_vld_s & ~stall_thisthr_f) || 
                       (config_dtu_esl_en && (inst_vld_s2_ed || immu_fault_f) && ~stall_ed_s2);
   
   // D stage
   dff_s #(1) rund_ff(.din (running_s2),
		              .clk (clk),
		              .q   (inst_vld_d),
		              .se  (se), .si(), .so());
   dff_s #(1) eivd_ff(.din (running_s2),
		                .clk (clk),
		                .q   (inst_vld_d_crit),
		                .se  (se), .si(), .so());
   assign fcl_erb_inst_issue_d = inst_vld_d & ~intr_vld_d;
   assign running_d = inst_vld_d & ~kill_thread_d & ~rb_stg_d & 
	                    ~intr_vld_d;
   assign fcl_esl_inst_vld_d = running_d;

   // E stage
   dff_s #(1) rune_ff(.din (running_d),
		              .clk (clk),
		              .q   (inst_vld_e),
		              .se  (se), .si(), .so());

   assign running_e = inst_vld_e & ~dtu_inst_anull_e & 
	                    ~kill_curr_e & ~rb_stg_e &
                      ~(thr_match_em & ifu_tlu_flush_m);
   assign fcl_esl_inst_vld_e = running_e;                   
   assign inst_vld_qual_e = inst_vld_e & ~rb_stg_e;
   assign val_thr_e = thr_e_v2 & {4{inst_vld_qual_e}} & ~late_flush_w2 &
                      ~(thr_w & {4{utrap_flush_w}});
   
   
   // M stage
   dff_s #(1) runm_ff(.din (running_e),
		              .clk (clk),
		              .q   (inst_vld_m),
		              .se  (se), .si(), .so());
   assign running_m = (inst_vld_m | intr_vld_m) & ~kill_thread_m;
   assign fcl_esl_inst_vld_m = running_m;
   
   assign ifu_tlu_inst_vld_m = (inst_vld_m | intr_vld_m) & ~kill_curr_m;
   // less critical
   // assign ifu_lsu_inst_vld_m = ifu_tlu_inst_vld_m;
   
   // W stage
   dff_s #(1) runw_ff(.din (running_m),
		              .q   (inst_vld_w),
		              .clk (clk), .se  (se), .si(), .so());   

   dff_s #(1) iw_ff(.din (running_m),
		              .q   (inst_vld_w_crit),
		              .clk (clk), .se  (se), .si(), .so());   
   
   // synopsys translate_off
//   wire         sas_m,
//		            inst_done_w_for_sas;
   
//   assign sas_m = inst_vld_m & ~kill_thread_m & 
//	                ~(exu_ifu_ecc_ce_m & inst_vld_m & ~trap_m);

//   dff #(1) sasw_ff(.din (sas_m),
//		              .clk (clk),
//		              .q   (inst_done_w_for_sas),
//		              .se  (se), .si(), .so());   
   // synopsys translate_on

   // need to kill branch by E stage, so qual with rb_stg_X
   assign fcl_dtu_inst_vld_e = inst_vld_e & ~rb_stg_e & ~kill_curr_e;
   assign fcl_dtu_intr_vld_e = intr_vld_e & ~rb_stg_e & ~kill_curr_e;
   assign fcl_dtu_inst_vld_d = inst_vld_d & ~kill_curr_d &
	                             ~rb_stg_d_crit & ~immu_miss_crit_d;
   assign fcl_dtu_ely_inst_vld_d = inst_vld_d_crit;
   assign ifu_tlu_inst_vld_w = inst_vld_w;
   assign ifu_exu_inst_vld_w = inst_vld_w_crit;
   assign ifu_spu_inst_vld_w = inst_vld_w;
   assign ifu_exu_inst_vld_e = fcl_dtu_inst_vld_e;
   
   assign flush_sonly_qual_e = dtu_fcl_flush_sonly_e & inst_vld_e &
//                               ~dec_fcl_kill4sta_e &
                               ~rb_stg_e & ~dtu_inst_anull_e & ~kill_curr_e;
   

   dff_s #(1) flshm_ff(.din (flush_sonly_qual_e),
                     .q   (flush_sonly_m),
                     .clk (clk),
                     .se  (se), .si(), .so());

   dff_s #(1) imflshm_ff(.din (ifq_fcl_flush_sonly_e),
                       .q   (ims_flush_sonly_m),
                       .clk (clk),
                       .se  (se), .si(), .so());
   // detect collision between two different types of retractions
   assign ims_flush_coll_m = ims_flush_sonly_m & ~canthr_sm & 
                             retract_iferr_e;
   dff_s #(1) imflshw_ff(.din (ims_flush_coll_m),
                       .q   (ims_flush_sonly_w),
                       .clk (clk),
                       .se  (se), .si(), .so());
   assign ims_flush_coll_w = ims_flush_sonly_w & ~canthr_sw;
   assign flush_sonly_qual_m = (ims_flush_sonly_m & ~canthr_sm & 
                                ~retract_iferr_e |
                                flush_sonly_m & inst_vld_m & ~kill_local_m &
                                ~kill_curr_m);
   assign flush_sonly_all_m = (ims_flush_sonly_m & ~canthr_sm | 
                               flush_sonly_m & inst_vld_m);

//   assign flush_sonly_qual_m = flush_sonly_m & ~canthr_sm;
//   assign qtrap_flush_e = dtu_fcl_qtrap_e & inst_vld_e & ~dtu_inst_anull_e & 
//	                  ~rb_stg_e;
   
//------------------------------   
// Instruction Kill Logic
//------------------------------
   
   // kill_s2 is the same as kill_f
   assign kill_thread_s2 = thr_match_fw & rb_stg_w |
//	                         thr_match_ft & trappc_vld_w2 |
	                         thr_match_fm & (flush_sonly_all_m) |
                           kill_curr_f;
   
   assign ely_kill_thread_s2 = thr_match_fw & utrap_flush_w |
//	                             thr_match_ft & trappc_vld_w2 |
	                             thr_match_fm & (flush_sonly_all_m) |
                               kill_curr_f;
   
   assign kill_thread_d = thr_match_dw & rb_stg_w |
	                        thr_match_dm & (flush_sonly_all_m) |
                          kill_curr_d;

   // M and E still need full qualification with flush pipe   
//   assign kill_thread_e = thr_match_ew & utrap_flush_w | 
//                          thr_match_ew & tlu_ifu_flush_pipe_w | 
//                          kill_curr_e ;
   assign ely_kill_thread_m = thr_match_mw & utrap_flush_w |
//                              mark4rb_m |
                              kill_curr_m;
   assign kill_thread_m = ely_kill_thread_m | 
                          thr_match_mw & tlu_ifu_flush_pipe_w;
   
   assign kill_local_m = thr_match_mw & (utrap_flush_w | intr_vld_w);

   assign flush_pipe_w = rb_stg_w | tlu_ifu_flush_pipe_w;
//   assign part_flush_w = ifu_tlu_flush_w | tlu_ifu_flush_pipe_w;
//   assign kill_nextthr_w = thr_match_nw & flush_pipe_w;
   assign flush_thr_w = thr_w & {4{flush_pipe_w}};
   dff_s #(1) fp_ff(.din (flush_pipe_w),
                  .q   (flush_pipe_w2),
                  .clk (clk), .se(se), .si(), .so());

//   assign clear_s_stage =  thr_e & {4{flush_sonly_qual_e}};
//   assign clear_s_stage =  trap_thr & {4{trappc_vld_w2}} |
//	                         {4{dummy_flush_ireg}} | 
//	                         thr_e & {4{flush_sonly_qual_e}};
                           //  | flush_thr_w 

   assign canthr_f = thr_e & {4{flush_sonly_qual_e}} | 
                     (rb_w2 & ~rb_for_iferr_e) | rb_froms;

//   dff #(4) cls_reg(.din (clear_s_stage),
//		                .q   (clear_s_early),
//		                .clk (clk), .se(se), .si(), .so());

   // ***NOTE***
   // Don't use clear_s_d1 to generate fcl_ifq_canthr, since clear_s_d1 
   // includes ifeterr!
   // first term could be just flush_sonly_m & inst_vld_m & thr_m
   assign clear_s_d1 = thr_m & {4{flush_sonly_all_m}} |
                       late_flush_w2 | 
                       trap_thr & {4{trappc_vld_w2}};

   assign fcl_erb_clear_iferr = thr_m & {4{ims_flush_sonly_m | 
                                           flush_sonly_m}} |
                                late_flush_w2 | 
                                trap_thr & {4{trappc_vld_w2}};


   dff_s #(4) cm_reg(.din (canthr_f),
		               .q   (canthr_s_early),
		               .clk (clk),
		               .se  (se), .si(), .so());

   assign canthr_s = canthr_s_early | late_flush_w2 | 
                     trap_thr & {4{trappc_vld_w2}};          
   
//   assign fcl_ifq_canthr = clear_s_stage | rb_w2 | rb_froms | 
//	                         canthr_s;
   assign fcl_ifq_canthr = canthr_s;

   assign canthr_sm = (canthr_s[0] & thr_m[0] | 
                       canthr_s[1] & thr_m[1] | 
                       canthr_s[2] & thr_m[2] | 
                       canthr_s[3] & thr_m[3]);

   assign canthr_sw = (canthr_s[0] & thr_w[0] | 
                       canthr_s[1] & thr_w[1] | 
                       canthr_s[2] & thr_w[2] | 
                       canthr_s[3] & thr_w[3]);

   assign canthr_sd = (canthr_s[0] & thr_d[0] | 
                       canthr_s[1] & thr_d[1] | 
                       canthr_s[2] & thr_d[2] | 
                       canthr_s[3] & thr_d[3]) |
                        thr_match_dw & utrap_flush_w;

   dff_s #(4) fpw2_reg(.din (flush_thr_w),
                     .q   (late_flush_w2),
                     .clk (clk), .se(se), .si(), .so());

//   assign late_flush_w2 = thr_w2 & {4{flush_pipe_w2}};
   
   assign kill_curr_f = (thr_f_crit[0] & late_flush_w2[0] |
                         thr_f_crit[1] & late_flush_w2[1] |
                         thr_f_crit[2] & late_flush_w2[2] |
                         thr_f_crit[3] & late_flush_w2[3]);
   assign kill_curr_d = (thr_d[0] & late_flush_w2[0] |
                         thr_d[1] & late_flush_w2[1] |
                         thr_d[2] & late_flush_w2[2] |
                         thr_d[3] & late_flush_w2[3]);
   assign kill_curr_e = (thr_e_v2[0] & late_flush_w2[0] |
                         thr_e_v2[1] & late_flush_w2[1] |
                         thr_e_v2[2] & late_flush_w2[2] |
                         thr_e_v2[3] & late_flush_w2[3]) |
                          thr_match_ew & utrap_flush_w;
   
//   assign kill_curr_m = (thr_m[0] & late_flush_w2[0] |
//                         thr_m[1] & late_flush_w2[1] |
//                         thr_m[2] & late_flush_w2[2] |
//                         thr_m[3] & late_flush_w2[3]);
   assign kill_curr_m = same_thr_mw2 & flush_pipe_w2;
   
   //------------------------------
   // track I$ misses
   //------------------------------
   
   // force a miss if a fetch and icache is off
   // forcemiss triggers a fill vld_grequest to L2, so set to zero by default
   assign forcemiss_f = inst_vld_f & ~icache_on_f;
   dffr_s #(1)  miss_ff(.din (forcemiss_f),
		                  .clk (clk),
		                  .rst (fcl_reset),
		                  .q   (forcemiss_s1),
		                  .se  (se), .si(), .so());

   //ooooooooooooooooooooooooooooooooooooooooooooooooooooooo
   // removed imiss_s_l from this signal for timing fix  
   // Perf Hit: 0.2% TPCC, 0.4% JBB
//   assign ic_miss_sw_s1 = (~itlb_fcl_imiss_s_l & rdreq_s1 |
//                             tlb_cam_miss_s1 | 
//                             forcemiss_s1);
//   assign ic_miss_sw_s1 =   tlb_cam_miss_s1 | 
//                            forcemiss_s1;
   //ooooooooooooooooooooooooooooooooooooooooooooooooooooooo
   
   assign ic_miss_s1 =  (~itlb_fcl_imiss_s_l & rdreq_s1 |
			                   forcemiss_s1) & 
                        ~stall_s1 & ~tlbmiss_s1_crit & ~pc_oor_s1 & 
                        ~rb_stg_d_crit & ~canthr_sd;

   assign icmiss_for_perf =  (~itlb_fcl_imiss_s_l & rdreq_s1) & 
                        ~stall_s1 & ~tlbmiss_s1_crit & ~pc_oor_s1 & 
                        ~rb_stg_d & ~canthr_sd;

//   assign fcl_ifq_icmiss_s1 = ic_miss_s1 & ~ely_kill_thread_d;  // use buffer
   assign fcl_ifq_icmiss_s1 = ic_miss_s1;  // use buffer   

   // for perf counters (d1=e)
   dff_s #(1) icmd1_ff(.din (icmiss_for_perf),
                     .q   (ifu_tlu_icmiss_e),
                     .clk (clk), .se(se), .si(), .so());
   
   // I$ miss is always to thr_s1.  Below we check to see if this is
   // the same as thr_f (=thr_s2) which is the "current thread"
//   assign imsto_thisthr_s1 = thr_match_fd & ic_miss_s1;
//   assign imsto_nextthr_s1 = thr_match_nd & (ic_miss_s1 | tlbmiss_s1);

   assign imsto_thisthr_s1 = thr_match_fd & ic_miss_s1;
//   assign imsto_nextthr_s1 = thr_match_nd & (ic_miss_sw_s1);
//   assign intrto_thisthr_d = thr_match_fd & fcl_dtu_sync_intr_d;

   assign iferrto_thisthr_d1 = thr_match_fe & erb_dtu_ifeterr_d1 & 
                               inst_vld_d1;
   

//------------------------------
// track itlb misses
//------------------------------

   // default to hit when camming is turned off
   assign tlb_cam_miss_f = ~itlb_fcl_tlbmiss_f_l & cam_vld_f;
   dff_s #(1) tlbmsf_ff(.din (tlb_cam_miss_f),
		                  .clk (clk),
		                  .q   (tlb_cam_miss_s1),
		                  .se  (se), .si(), .so());
   
   // mmckeown: Need to draft the tlbmiss bit as well
   // when we repeat instruction for follower thread
   wire [3:0] tlbmiss_s2_bf_exec_draft;

   // tlb miss logic
   // va hole has higher priority than immu miss
   assign tlbmiss_s2_bf_exec_draft = (({4{tlbmiss_s1 & ~pc_oor_s1 & ~rb_stg_d}} & thr_s1) |
			                  ({4{erb_fcl_itlb_ce_d1 & inst_vld_d1 & 
                            ~rb_stg_e}} & thr_e &
			                   (~thr_d | {4{~inst_vld_d | ~thr_match_de}})) |
			                  ({4{immu_miss_e}} & rb_frome) |
			                  ({4{immu_miss_d}} & rb_fromd & ~rb_frome) |  // set
			                  tlbmiss_d & (~thr_d | {4{~inst_vld_d}}) & ~rb_w2) & 
			                 ~(clear_s_d1); // reset

   // always pass through thread 0
   assign tlbmiss_s2[0] = tlbmiss_s2_bf_exec_draft[0];

   // need to draft the tlbmiss bit in case thread0 had a tlb miss
   wire exec_draft_replay_tlbmiss_mux_sel = config_dtu_esl_en ? esl_fdp_issue_prev_inst_s : 1'b0;
   dp_mux2es  #(3)  exec_draft_replay_tlbmiss_mux (.dout (tlbmiss_s2[3:1]),
                                                   .in0 (tlbmiss_s2_bf_exec_draft[3:1]),
                                                   .in1 ({3{immu_miss_d}} & thr_f[3:1]),
                                                   .sel(exec_draft_replay_tlbmiss_mux_sel));

//   assign tlbmiss_s2 = (({4{tlbmiss_s1 & ~pc_oor_s1 & ~rb_stg_d}} & thr_s1) |
//			({4{erb_fcl_itlb_ce_d1 & inst_vld_qual_d1}} & thr_e |
//			 tlbmiss_d & (~thr_e | {4{~inst_vld_qual_e}}) & 
//			 ~rb_w2) & ~(clear_s_stage); // reset

   dffr_s #(4) tlbmiss_reg(.din (tlbmiss_s2),
		                     .q   (tlbmiss_d),
		                     .clk (clk),
		                     .rst (fcl_reset),
		                     .se  (se), .si(), .so());

   assign immu_fault_f = (thr_f_crit[0] & (tlbmiss_d[0] | inst_acc_vec_d[0]) |
			                    thr_f_crit[1] & (tlbmiss_d[1] | inst_acc_vec_d[1]) |
			                    thr_f_crit[2] & (tlbmiss_d[2] | inst_acc_vec_d[2]) |
			                    thr_f_crit[3] & (tlbmiss_d[3] | inst_acc_vec_d[3])) &
                           switch_s2|  
			                     // D stage miss
			                     (tlbmiss_s1 | pc_oor_s1) & thr_match_fs1;
	                         // S stage miss

   assign immu_miss_crit_d = (thr_d[0] & tlbmiss_d[0] |
			                        thr_d[1] & tlbmiss_d[1] |
			                        thr_d[2] & tlbmiss_d[2] |
			                        thr_d[3] & tlbmiss_d[3]);
   
   // TBD: move this to the E stage, post RB
   assign immu_miss_d = immu_miss_crit_d & inst_vld_d | 
			                  thr_match_de & erb_fcl_itlb_ce_d1 & inst_vld_d1;

   // don't need to do this, once everyone switches to immu_miss_m
   assign immu_miss_qual_d = immu_miss_d & ~kill_thread_d &
	                            ~(immu_miss_e & thr_match_de & 
                                inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e &
                                ~kill_curr_e);
   
   dff_s immu_misse_ff(.din (immu_miss_qual_d),
		                 .clk (clk),
		                 .q   (immu_miss_e),
		                 .se  (se), .si(), .so());

   
   // flop this and send in M
//   assign ifu_tlu_immu_miss_e = immu_miss_e & ~addr_real_e & 
//                                inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e;
//   assign ifu_tlu_immu_miss_e = 1'b0;
   
//   assign immu_miss_qual_e = immu_miss_e & //~addr_real_e & 
// //                             ~(immu_miss_m & thr_match_em) &
//                             inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e;

//   dff #(1) immu_msm_ff(.din (immu_miss_qual_e),
   dff_s #(1) immu_msm_ff(.din (immu_miss_e),
                        .q   (immu_miss_m),
                        .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_immu_miss_m = immu_miss_m & inst_vld_m & ~kill_curr_m;

   assign addr_real_e = (itlb_addr_real[0] & thr_e[0] |
                         itlb_addr_real[1] & thr_e[1] |
                         itlb_addr_real[2] & thr_e[2] |
                         itlb_addr_real[3] & thr_e[3]);

   // store tlbmiss state for NIR
   assign nir_tlbmiss_next = ({4{tlb_cam_miss_s1 & ~stall_s1}} & thr_s1 |
			                        nir_tlbmiss_vec & (~thr_s1 | {4{stall_s1}}));

   dffr_s #(4) nirtlbm_reg(.din (nir_tlbmiss_next),
		                   .clk (clk),
		                   .q   (nir_tlbmiss_vec),
		                   .rst (fcl_reset),
		                   .se  (se), .si(), .so());

   assign nir_tlbmiss_s1 = (nir_tlbmiss_vec[0] & thr_s1[0] |
			                      nir_tlbmiss_vec[1] & thr_s1[1] |
			                      nir_tlbmiss_vec[2] & thr_s1[2] |
			                      nir_tlbmiss_vec[3] & thr_s1[3]);

   assign tlbmiss_s1_crit = ~usenir_s1 ? tlb_cam_miss_s1 :
	                                       nir_tlbmiss_s1;

   assign tlbmiss_s1 = tlbmiss_s1_crit & ~stall_s1;
   
   assign fcl_fdp_tlbmiss_s1 = tlbmiss_s1;

//---------------------------------
//  Privilege Mode and VA Hole
//---------------------------------
   assign addr_mask_32b_m = (thr_m[0] & pstate_am_d1[0] |
			                       thr_m[1] & pstate_am_d1[1] |
			                       thr_m[2] & pstate_am_d1[2] |
			                       thr_m[3] & pstate_am_d1[3]);
   
   assign fcl_fdp_mask32b_f = (thr_f[0] & pstate_am_d1[0] |
			                         thr_f[1] & pstate_am_d1[1] |
			                         thr_f[2] & pstate_am_d1[2] |
			                         thr_f[3] & pstate_am_d1[3]);

   dff_s #(1) amd_ff(.din (fcl_fdp_mask32b_f),
		               .q   (fcl_fdp_addr_mask_d),
		               .clk (clk), .se(se), .si(), .so());

   // keep track of whether pc is outside va hole
   assign set_oor_m = exu_ifu_va_oor_m & brtaken_m & ~addr_mask_32b_m;
   assign fcl_fdp_pcoor_vec_f = fdp_fcl_pc_oor_vec_f | {4{set_oor_m}} & thr_m;
   
   assign fcl_fdp_pcoor_f =  (thr_f[0] & fcl_fdp_pcoor_vec_f[0] |
			                        thr_f[1] & fcl_fdp_pcoor_vec_f[1] |
			                        thr_f[2] & fcl_fdp_pcoor_vec_f[2] |
			                        thr_f[3] & fcl_fdp_pcoor_vec_f[3]);
   
   assign pc_oor_f = fcl_fdp_pcoor_f  & ~part_stall_thisthr_f;
   dff_s oors1_ff(.din (pc_oor_f),
		            .q   (pc_oor_s1),
		            .clk (clk), .se(se), .si(), .so());

   // track privilege mode of current page
   assign priv_mode_f = (thr_f[0] & tlu_lsu_pstate_priv[0] |
			                   thr_f[1] & tlu_lsu_pstate_priv[1] |
			                   thr_f[2] & tlu_lsu_pstate_priv[2] |
			                   thr_f[3] & tlu_lsu_pstate_priv[3]);

   dff_s #(1) priv_ff(.din (priv_mode_f),
                    .q   (priv_mode_s1),
                    .clk (clk), .se(se), .si(), .so());
   
   // s1 and d are the same thread
   assign fcl_dtu_privmode_d = priv_mode_s1;

   // hyper privilege
   assign hpriv_mode_f = (thr_f[0] & tlu_hpstate_priv[0] |
			                    thr_f[1] & tlu_hpstate_priv[1] |
			                    thr_f[2] & tlu_hpstate_priv[2] |
			                    thr_f[3] & tlu_hpstate_priv[3]);

   assign hpriv_mode_w = (thr_w[0] & tlu_hpstate_priv[0] |
			                    thr_w[1] & tlu_hpstate_priv[1] |
			                    thr_w[2] & tlu_hpstate_priv[2] |
			                    thr_w[3] & tlu_hpstate_priv[3]);
   
   dff_s #(1) hprivd_ff(.din (hpriv_mode_f),
                     .q   (hpriv_mode_s1),
                     .clk (clk), .se(se), .si(), .so());

   assign fcl_dtu_hprivmode_d = hpriv_mode_s1;

   dff_s #(1) hprivw2_ff(.din (hpriv_mode_w),
                     .q   (hpriv_mode_w2),
                     .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_hprivmode_w2 = hpriv_mode_w2;

   // determine if priv page has been accessed in non priv mode
   // or if we have fallen into the VA hole
   assign inst_acc_exc_s1 = (priv_inst_s1 & ~(priv_mode_s1 | hpriv_mode_s1) & 
			                       ~tlbmiss_s1_crit & cam_vld_s1 | 
			                       pc_oor_s1) & ~stall_s1 & ~rb_stg_d;
   assign pc_oor_s2 = (thr_f[0] & inst_acc_vec_d[0] |
                       thr_f[1] & inst_acc_vec_d[1] |
                       thr_f[2] & inst_acc_vec_d[2] |
                       thr_f[3] & inst_acc_vec_d[3]);
   assign pc_oor_s = (tm_fd_l) ? pc_oor_s2 : pc_oor_s1;
      
   assign inst_acc_vec_s2 = (({4{inst_acc_exc_s1}} & thr_s1) |
			                       ({4{inst_acc_exc_e}} & rb_frome) |
			                       ({4{inst_acc_exc_d}} & rb_fromd & ~rb_frome) |
	                           inst_acc_vec_d & (~thr_d | {4{~inst_vld_d}}) & 
			                       ~rb_w2) &
			                        ~(clear_s_d1);
	 
   dffr_s #(4) instaccd_reg(.din (inst_acc_vec_s2),
			                  .q   (inst_acc_vec_d),
			                  .rst (fcl_reset),
			                  .clk (clk), .se (se), .si(), .so());

   assign inst_acc_exc_d = (thr_d[0] & inst_acc_vec_d[0] |
			                      thr_d[1] & inst_acc_vec_d[1] |
			                      thr_d[2] & inst_acc_vec_d[2] |
			                      thr_d[3] & inst_acc_vec_d[3]);

   dff_s #(1) instacce_ff(.din (inst_acc_exc_d),
		                  .q   (inst_acc_exc_e),
		                  .clk (clk), .se(se), .si(), .so());

   // TLU needs to know if this is a priv violtn
   assign priv_violtn_e = inst_acc_exc_e & ~fdp_fcl_pc_oor_e;
   dff_s #(1) privm_ff(.din (priv_violtn_e),
		               .q   (priv_violtn_m),
		               .clk (clk),  .se  (se), .si(), .so());

   assign ifu_tlu_priv_violtn_m = priv_violtn_m & inst_vld_m & ~kill_curr_m;
   
   // NIR privilege bit
   assign next_nir_privvec = {4{itlb_fcl_priv_s1 & ~stall_s1 & 
                                cam_vld_s1}} & thr_s1 |
	                           nir_privvec & (~thr_s1 | {4{stall_s1}});

   dffr_s #(4) nir_priv_reg(.din (next_nir_privvec),
			                  .q   (nir_privvec),
			                  .rst (fcl_reset),
			                  .clk (clk), .se(se), .si(), .so());
   
   assign nir_priv_s1 = (nir_privvec[0] & thr_s1[0] |
			                   nir_privvec[1] & thr_s1[1] |
			                   nir_privvec[2] & thr_s1[2] |
			                   nir_privvec[3] & thr_s1[3]);
   
   assign priv_inst_s1 = ~usenir_s1 ? (itlb_fcl_priv_s1 & cam_vld_s1) : 
                                        nir_priv_s1;

//-------------------------
// Errors
//-------------------------

   // decide when the errors are valid
   assign running_s1 = ~stall_s1 & ~kill_thread_d & ~rb_stg_d & ~pc_oor_s1 &
	                     ~tlb_cam_miss_s1 & ~retract_inst_d;
//   assign ely_running_s1 = ~stall_s1 & ~rb_stg_d & ~pc_oor_s1 & 
//                           ~tlb_cam_miss_s1 & ~retract_inst_d & ~kill_curr_d;
   assign ely_running_s1 = ~stall_s1 & ~rb_stg_d_crit & ~pc_oor_s1 & 
                           ~tlb_cam_miss_s1 & ~kill_curr_d;
   assign fcl_erb_ievld_s1 = ely_running_s1 & rdreq_s1 & itlb_fcl_imiss_s_l;
   assign fcl_erb_tevld_s1 = ely_running_s1 & rdreq_s1;

   assign fcl_erb_immuevld_s1 = ely_running_s1 & cam_vld_s1;

//   assign fcl_erb_ttevld_s1 = asird_s & rdtag_s;
//   assign fcl_erb_tdevld_s1 = asird_s & ~rdtag_s;
   
   dff_s #(1) d1vld_ff(.din (running_s1),
		                 .q   (inst_vld_d1),
		                 .clk (clk), .se(se), .si(), .so());
//   assign inst_vld_qual_d1 = inst_vld_d1 & ~kill_thread_e & 
//	                           ~flush_sonly_qual_e & ~rb_stg_e;
   assign fcl_erb_inst_vld_d1 = inst_vld_d1;
   

   // ifetch unc. error
   assign ifet_ue_vec_d1 = (erb_fcl_ifet_uevec_d1 |
	                          ifet_ue_vec_e & ~val_thr_e) &   // reset
			                       ~(clear_s_d1);                 // wins

   dffr_s #(4) ifuerr_reg(.din (ifet_ue_vec_d1),
		                  .q   (ifet_ue_vec_e),
		                  .rst (fcl_reset),
		                  .clk (clk), .se(se), .si(), .so());

   assign ifet_ue_e = (ifet_ue_vec_e[0] & thr_e[0] | 
		                   ifet_ue_vec_e[1] & thr_e[1] | 
		                   ifet_ue_vec_e[2] & thr_e[2] | 
		                   ifet_ue_vec_e[3] & thr_e[3]);


//----------------------
// Other I side traps
//----------------------
   // Determine if we are in Trap Level 0
   assign tlzero_s2 = (thr_f[0] & tlzero_vec_d1[0] |
		                   thr_f[1] & tlzero_vec_d1[1] |
		                   thr_f[2] & tlzero_vec_d1[2] |
		                   thr_f[3] & tlzero_vec_d1[3]);
   dff_s #(1) tlzd_ff(.din (tlzero_s2),
		              .q   (fcl_dtu_tlzero_d),
		              .clk (clk), .se(se), .si(), .so());

   // Collect all IFU traps
   assign trap_e = (immu_miss_e | inst_acc_exc_e | dtu_fcl_illinst_e |
		                dtu_fcl_fpdis_e | dtu_fcl_privop_e | ifet_ue_e |
		                dtu_fcl_imask_hit_e | dtu_fcl_sir_inst_e) & 
                     inst_vld_e;

   dff_s trapm_ff(.din (trap_e),
		            .q   (trap_m),
		            .clk (clk),
		            .se  (se), .si(), .so());

   assign no_iftrap_m = ~ifu_tlu_ttype_vld_m;
   dff_s trapw_ff(.din (no_iftrap_m),
		            .q   (no_iftrap_w),
		            .clk (clk),
		            .se  (se), .si(), .so());
   
   // south is very critical
   assign ifu_tlu_ttype_vld_m = (trap_m & inst_vld_m | 
                                 disr_trap_m) & ~kill_curr_m & ~kill_local_m;
   // less critical going east
   assign ifu_exu_ttype_vld_m = trap_m & inst_vld_m;

   // less critical going southwest
   assign ifu_mmu_trap_m = trap_m;

   // less critical going south   
   assign ifu_tlu_trap_m = trap_m;
   
   // trap type priority encode
   // Decreasing priority is
   //   pc out of range           i_acc_exc
   //   immu parity error         i_acc_err
   //   immu miss                 i_acc_mmu_ms
   //   icache/tag parity error   i_acc_err
   //   privilege page            i_acc_exc
   //   privilege opcode          priv_opc
   //   illegal non-fp inst       ill_inst
   //   soft reset                sir
   //   fp disabled               fp_disabled
   //   illegal fp instruction    ill_inst

   // Clean this up!!
   assign ttype_sel_spuma_e = spuint1_qual_e;
   assign ttype_sel_spuenc_e = spuint0_qual_e;
   assign ttype_sel_corr_err_e = ceint_qual_e;
   assign ttype_sel_unc_err_e = ueint_qual_e;
   assign ttype_sel_res_err_e = rerr_qual_e;
   assign ttype_sel_hstk_cmp_e = hintp_qual_e;
   
   assign ttype_sel_pcoor_e = fdp_fcl_pc_oor_e & inst_acc_exc_e;
   assign ttype_sel_icache_err_e = ifet_ue_e; 
   assign ttype_sel_immu_miss_e = ~fdp_fcl_pc_oor_e & immu_miss_e & 
                                  ~addr_real_e;
   assign ttype_sel_real_trans_e = ~fdp_fcl_pc_oor_e & immu_miss_e & 
                                   addr_real_e;    
   assign ttype_sel_priv_viol_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                           inst_acc_exc_e;
   assign ttype_sel_ibe_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                        ~inst_acc_exc_e & dtu_fcl_imask_hit_e;
   assign ttype_sel_privop_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                       ~inst_acc_exc_e & dtu_fcl_privop_e;
   assign ttype_sel_illinst_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                        ~inst_acc_exc_e & dtu_fcl_illinst_e;
   assign ttype_sel_sir_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                    ~inst_acc_exc_e & ~dtu_fcl_illinst_e &
	                     dtu_fcl_sir_inst_e;
   
   assign ttype_sel_fpdis_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                      ~inst_acc_exc_e & ~dtu_fcl_illinst_e &
	                       dtu_fcl_fpdis_e;

   // mux in the trap type
   assign ttype_e[8:0] = ttype_sel_unc_err_e    ? 9'h078  :
                   ttype_sel_hstk_cmp_e   ? 9'h05e    :
	                 ttype_sel_spuma_e      ? 9'h074     :
	                 ttype_sel_spuenc_e     ? 9'h070    :
	                 ttype_sel_corr_err_e   ? 9'h063  :
                   ttype_sel_res_err_e    ? 9'h07e :
          
	                 ttype_sel_pcoor_e      ? 9'h008  :
	                 ttype_sel_immu_miss_e  ? 9'h064   :
	                 ttype_sel_real_trans_e ? 9'h03e :
	                 ttype_sel_icache_err_e ? 9'h00a  :
	                 ttype_sel_priv_viol_e  ? 9'h008  :
	                 ttype_sel_ibe_e        ? 9'h076   :
	                 ttype_sel_privop_e     ? 9'h011 :
	                 ttype_sel_illinst_e    ? 9'h010 :
	                 ttype_sel_sir_e        ? 9'h004      :
	                 ttype_sel_fpdis_e      ? 9'h020 :
	                                           9'h1ff;

   dff_s #(9) ttype_reg(.din (ttype_e[8:0]),
		                .q   (ifu_tlu_ttype_m[8:0]),
		                .clk (clk), .se(se), .si(), .so());
	 
//------------------------------
// Interrupts and Resets
//------------------------------
   // Process resets to see if they are sync or async
   assign intr_in_pipe = ({4{intr_vld_d}} & thr_d |
                          {4{intr_vld_e}} & thr_e |
                          {4{intr_vld_m}} & thr_m |
                          {4{intr_vld_w}} & thr_w);

//   assign async_rst_i2 = tlu_ifu_rstthr_i2  & {4{tlu_ifu_rstint_i2}} &
   assign async_rst_i3 = (rstint_i3 | nuke_thr_i3 | resumint_i3) & 
                           ~dtu_fcl_thr_active & ~intr_in_pipe;

   dff_s #(4) asyrst4_reg(.din (async_rst_i3),
                        .q   (async_rst_i4),
                        .clk (clk), .se(se), .si(), .so());
   
   // stall pipe before switching in rst thread
   assign rst_stallreq_d0 = (|async_rst_i4[3:0]);
   assign rst_stallreq = rst_stallreq_d0 | rst_stallreq_d1 | rst_stallreq_d2;

   dff_s #(2) stlreq_reg(.din ({lsu_ifu_stallreq,
                              ffu_ifu_stallreq}),
                       .q   ({lsu_stallreq_d1,
                              ffu_stallreq_d1}),
                       .clk (clk), .se(se), .si(), .so());
   
   assign all_stallreq = ifq_fcl_stallreq | lsu_stallreq_d1 | 
                         ffu_stallreq_d1 | itlb_starv_alert;

   // leave out stall from ifq which goes directly to swl
   assign fcl_dtu_stall_bf = lsu_stallreq_d1 | ffu_stallreq_d1 | 
                             itlb_starv_alert | rst_stallreq;

   // priority encode rst interrupts
   // this could lead to obvious starvation of thr3, the assumption is that
   // idle/resume/reset interrupts do not occur very frequently
   assign rstint_penc[0] = async_rst_i4[0];
   assign rstint_penc[1] = ~async_rst_i4[0] & async_rst_i4[1];
   assign rstint_penc[2] = ~async_rst_i4[0] & ~async_rst_i4[1]  & 
	                          async_rst_i4[2];
   assign rstint_penc[3] = ~async_rst_i4[0] & ~async_rst_i4[1]  & 
	                         ~async_rst_i4[2];

   // BF - switch in rst thread
   dff_s #(1) asyncr1_ff(.din (rst_stallreq_d0),
		                   .q   (rst_stallreq_d1),
		                   .clk (clk), .se(se), .si(), .so());
   assign arst_vld_f_l = ~arst_vld_f;
   assign arst_vld_s_l = ~arst_vld_s;
   bw_u1_nand3_4x UZsize_rstsw_n3(.z (rst_sw_bf_l),
                                  .a (arst_vld_f_l),
                                  .b (arst_vld_s_l),
                                  .c (rst_stallreq_d1));
   assign rst_sw_bf = ~rst_sw_bf_l;

   // double check if asyn intrs are still valid
   assign sw_for_real_rst_bf = rst_sw_bf & rst_stallreq_d0;
   
   // F
   dff_s #(1) asyncr2_ff(.din (sw_for_real_rst_bf),
		                   .q   (rst_stallreq_d2),
		                   .clk (clk), .se(se), .si(), .so());
//   assign arst_vld_f = rst_stallreq_d2 & any_rstnuke_f;
   assign arst_vld_f = rst_stallreq_d2;   

   // hold thread till reset of curr thread is processed
//   assign rst_thr_bf = arst_vld_f ? thr_f : rstint_penc;
   
   // S issue to pipe
   dff_s #(1) rstvlds_ff(.din (arst_vld_f),
		                   .q   (arst_vld_s),
		                   .clk (clk), .se(se), .si(), .so());
   assign async_intr_vld_s = arst_vld_s & ~kill_intr_f; // & any_rstnuke_f 


   //
   // thread wise interrupts
   //
   assign rstint_i2 = {4{tlu_ifu_rstint_i2}} & tlu_ifu_rstthr_i2;
   assign resumint_i2 = {4{tlu_ifu_resumint_i2}} & tlu_ifu_rstthr_i2;
   assign nuke_thr_i2 =  {4{tlu_ifu_nukeint_i2}} & tlu_ifu_rstthr_i2;

   assign next_rst_i2 = rstint_i2 | 
	                      rstint_i3 & (~(thr_w & {4{fcl_dtu_rst_thr_w}}));
   assign next_resum_i2 = resumint_i2 | 
	                        resumint_i3 & (~(thr_w & {4{fcl_dtu_resum_thr_w}})) 
                          & ~rstint_i2;

   assign next_nuke_i2  = (nuke_thr_i2 | nuke_thr_i3) & 
                            (~(thr_w & {4{fcl_dtu_nuke_thr_w}})) & 
	                       ~(rstint_i2 | resumint_i2);

   assign next_sftint_i2 = tlu_ifu_sftint_vld;
   assign next_hwint_i3 = tlu_ifu_hwint_i3;
   assign next_hintp_i2 = tlu_ifu_hintp_vld;
   assign next_rerr_i2 = tlu_ifu_rerr_vld;
   
   assign next_ceint_i2 = erb_fcl_ce_trapvec |
	                        ceint_i3 & (~(thr_w & {4{ceint_qual_w}}));

   assign next_ueint_i2 = erb_fcl_ue_trapvec |
	                        ueint_i3 & (~(thr_w & {4{ueint_qual_w}}));

   // From Farnad: tid is ready several cycles before everything else
   // I will assume 1 cycle before in the ifu
   dff_s #(2) sptid_reg(.din (spu_ifu_ttype_tid_w2),
                      .q   (spu_tid_w2),
                      .clk (clk), .se(se), .so(), .si());
   
   assign spu_thr[0] = ~spu_tid_w2[1] & ~spu_tid_w2[0];
   assign spu_thr[1] = ~spu_tid_w2[1] &  spu_tid_w2[0];
   assign spu_thr[2] =  spu_tid_w2[1] & ~spu_tid_w2[0];
   assign spu_thr[3] =  spu_tid_w2[1] &  spu_tid_w2[0];

   assign next_spuint1_i2 = {4{spu_ifu_ttype_vld_w2 & spu_ifu_ttype_w2}} & 
	                          spu_thr & ~erb_fcl_spu_uetrap |
	                          spuint1_i3 & ~({4{spuint1_w}} & thr_w);

   assign next_spuint0_i2 = {4{spu_ifu_ttype_vld_w2 & ~spu_ifu_ttype_w2}} & 
	                          spu_thr & ~erb_fcl_spu_uetrap |
	                          spuint0_i3 & ~({4{spuint0_w}} & thr_w);


   dffr_s #(4) rst_reg(.din  (next_rst_i2),
		                 .q    (rstint_i3),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .se   (se), .si(), .so());

   dffr_s #(4) resum_reg(.din  (next_resum_i2),
		                   .q    (resumint_i3),
		                   .clk  (clk),
		                   .rst  (fcl_reset),
		                   .se   (se), .si(), .so());

   dffr_s #(4) nuke_reg(.din  (next_nuke_i2),
		                  .q    (nuke_thr_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk),
		                  .se   (se), .si(), .so());

   dffr_s #(4) sfti_reg(.din  (next_sftint_i2),
		                  .q    (sftint_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) hstki_reg(.din  (next_hintp_i2),
		                  .q    (hintp_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) reri_reg(.din  (next_rerr_i2),
		                  .q    (rerr_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) hwi_reg(.din  (next_hwint_i3),
		                 .q    (hwint_i4),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) spui0_reg(.din  (next_spuint0_i2),
		                   .q    (spuint0_i3),
		                   .rst  (fcl_reset),
		                   .clk  (clk), .se   (se), .si(), .so());
   
   dffr_s #(4) spui1_reg(.din  (next_spuint1_i2),
		                   .q    (spuint1_i3),
		                   .rst  (fcl_reset),
		                   .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) cei_reg(.din  (next_ceint_i2),
		                 .q    (ceint_i3),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) uei_reg(.din  (next_ueint_i2),
		                 .q    (ueint_i3),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   assign supv_int_en = (~tlu_hpstate_priv | ~tlu_hpstate_enb) & 
                         tlu_ifu_pstate_ie & dtu_fcl_thr_active;
   assign hypv_int_en = ~tlu_hpstate_priv & tlu_hpstate_enb | 
                        tlu_ifu_pstate_ie & dtu_fcl_thr_active;
   
   dff_s #(4) spvie_ff(.din (supv_int_en),
                     .q   (supv_int_en_d1),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(4) hpvie_ff(.din (hypv_int_en),
                     .q   (hypv_int_en_d1),
                     .clk (clk), .se(se), .si(), .so());

   // force an interrupt by putting nop on pipe
   // use this signal instead of hw_int_s to help with crit path
   assign supv_masked_intr_s = (sftint_i3        |
			                          rerr_i3);
   assign hypv_masked_intr_s = (hwint_i4         |
			                          hintp_i3         |
			                          ceint_i3         |
			                          ueint_i3         |
			                          spuint0_i3       |
			                          spuint1_i3);

   assign fcl_swl_int_activate_i3 = hypv_masked_intr_s |
                                    supv_masked_intr_s;

    // keep track of rolled back interrupts
   assign intr_pending_nxt =  (({4{intr_vld_e}} & rb_frome) |
                               ({4{intr_vld_d}} & rb_fromd & ~rb_frome) |
                                intr_pending_s) & ~clear_s_d1;
   
   dffr_s #(4) ipend_reg(.din (intr_pending_nxt),
                       .q   (intr_pending_s),
                       .rst (fcl_reset),
                       .clk (clk), .se(se), .si(), .so());

   assign any_intr_vec_f = (supv_masked_intr_s & supv_int_en_d1 |
                            hypv_masked_intr_s & hypv_int_en_d1 |
                            intr_pending_s    |
			                      rstint_i3         |
                            resumint_i3       |
			                      nuke_thr_i3);

   dff_s #(4) anyints_reg(.din (any_intr_vec_f),
                        .q   (any_intr_vec_s),
                        .clk (clk), .se(se), .si(), .so());
			
   assign force_intr_s = (thr_f_crit[0] & any_intr_vec_s[0] |
                          thr_f_crit[1] & any_intr_vec_s[1] |
                          thr_f_crit[2] & any_intr_vec_s[2] |
                          thr_f_crit[3] & any_intr_vec_s[3]) &
	                         ~kill_intr_f;

   // interrupt and reset signal pipe
   // VA hole trap has higher priority than interrupt
   //   - since the VA hole marker is lost once the intr is taken
   assign intr_vld_s = force_intr_s & (valid_s & ~pc_oor_s | 
                                       async_intr_vld_s);

   assign intr_vld_qual_s = intr_vld_s & ~iferrto_thisthr_d1;
   dff_s #(1) any_intrd_ff(.din (intr_vld_qual_s),
		                     .q   (intr_vld_d),	
		                     .clk (clk),	
		                     .se  (se), .so(), .si());
   assign fcl_dec_intr_vld_d = intr_vld_d;
   assign intr_vld_qual_d = intr_vld_d & ~kill_intr_d & ~kill_thread_d & 
	                           ~rb_stg_d;

   dff_s #(1) intr_vlde_ff(.din (intr_vld_qual_d),
		                   .q   (intr_vld_e),
		                   .clk (clk), .se  (se), .so(), .si());

   assign intr_vld_qual_e = intr_vld_e & ~kill_curr_e & ~rb_stg_e & 
	                    ~kill_intr_e & ~dtu_inst_anull_e &
                      ~(thr_match_em & ifu_tlu_flush_m);
   
   dff_s #(1) intr_vldm_ff(.din (intr_vld_qual_e),
		                   .q   (intr_vld_m),
		                   .clk (clk), .se  (se), .so(), .si());

   assign intr_vld_qual_m = intr_vld_m & ~kill_thread_m & ~mark4rb_m;

   dff_s #(1) intr_vldw_ff(.din (intr_vld_qual_m),
		                   .q   (intr_vld_w),
		                   .clk (clk), .se  (se), .so(), .si());

   // Reset and Idle are prioritized in M.  All others in E
   // reset interrupt
   assign rstint_m = (rstint_i3[0] & thr_m[0] |
			                rstint_i3[1] & thr_m[1] |
			                rstint_i3[2] & thr_m[2] |
			                rstint_i3[3] & thr_m[3]);

   assign ifu_tlu_rstint_m = rstint_m & intr_vld_m & ~kill_local_m & 
                             ~kill_curr_m;
//   assign rstint_qual_m = rstint_m & ~ely_kill_thread_m & intr_vld_m;
   dff_s #(1) rstw_ff(.din (rstint_m),
                    .q   (rst_thr_w),
                    .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_rst_thr_w = rst_thr_w & intr_vld_w;

   // resume interrupt
   assign resumint_m = (resumint_i3[0] & thr_m[0] |
			                  resumint_i3[1] & thr_m[1] |
			                  resumint_i3[2] & thr_m[2] |
			                  resumint_i3[3] & thr_m[3]);
   assign resumint_qual_m = resumint_m & ~rstint_m;
   
   dff_s #(1) resumw_ff(.din (resumint_qual_m),
                      .q   (resum_thr_w),
                      .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_resum_thr_w = resum_thr_w & intr_vld_w;

   // idle interrupt
   assign nuke_thr_m = (nuke_thr_i3[0] & thr_m[0] |
				                nuke_thr_i3[1] & thr_m[1] |
				                nuke_thr_i3[2] & thr_m[2] |
				                nuke_thr_i3[3] & thr_m[3]);

   assign nuke_thr_qual_m = nuke_thr_m & ~rstint_m & ~resumint_m;

   dff_s #(1) nukw_ff(.din (nuke_thr_qual_m),
                    .q   (nuke_thr_w),
                    .clk (clk),
                    .se  (se), .si(), .so());
   assign fcl_dtu_nuke_thr_w = nuke_thr_w & intr_vld_w;
   
   // uncorrected ecc
   assign ueint_e = (ueint_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                 ueint_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                 ueint_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                 ueint_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign ueint_qual_e = ueint_e & intr_vld_e;

   dff_s #(1) uem_ff (.din (ueint_qual_e),
                    .q   (ueint_m),
                    .clk (clk), .se (se), .si(), .so());
                    
//   assign ueint_m = (ueint_i3[0] & thr_m[0] |
//		                 ueint_i3[1] & thr_m[1] |
//		                 ueint_i3[2] & thr_m[2] |
//		                 ueint_i3[3] & thr_m[3]);
   
   assign ueint_trap_m = ueint_m & intr_vld_m & 
                         ~(rstint_m | resumint_m | nuke_thr_m);
   
//   assign ueint_qual_m = ueint_trap_m & ~ely_kill_thread_m;
   dff_s #(1) ueintw_ff(.din (ueint_trap_m),
                      .q   (ueint_trap_w),
                      .clk (clk), .se(se), .si(), .so());
   assign ueint_qual_w = ueint_trap_w & intr_vld_w;

   // hstk match interrupt
   assign hintp_e = (hintp_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
			               hintp_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
			               hintp_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
			               hintp_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign hintp_qual_e = hintp_e & intr_vld_e & ~ueint_e;

   dff_s #(1) hintpm_ff (.din (hintp_qual_e),
                       .q   (hintp_m),
                       .clk (clk), .se (se), .si(), .so());

//   assign ifu_tlu_hintp_m = hintp_m & ~kill_local_m & intr_vld_m & 
//	                    ~(rstint_m | nuke_thr_m | ueint_m);
   
   // hw int
   assign hwint_e = (hwint_i4[0] & thr_e[0] & hypv_int_en_d1[0] |
			               hwint_i4[1] & thr_e[1] & hypv_int_en_d1[1] |
			               hwint_i4[2] & thr_e[2] & hypv_int_en_d1[2] |
			               hwint_i4[3] & thr_e[3] & hypv_int_en_d1[3]);
   dff_s #(1) hwe_ff(.din (hwint_e),
                   .q   (hwint_m),
                   .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_hwint_m = hwint_m & intr_vld_m & ~kill_local_m &
                     ~kill_curr_m & 
	                   ~(rstint_m | resumint_m | nuke_thr_m | ueint_m | hintp_m);
   

   // spu interrupt
   assign spuint1_e = (spuint1_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                   spuint1_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                   spuint1_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                   spuint1_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign spuint1_qual_e = spuint1_e & intr_vld_e & ~ueint_e & ~hintp_e;

//   assign spuint1_m = (spuint1_i3[0] & thr_m[0] |
//		                   spuint1_i3[1] & thr_m[1] |
//		                   spuint1_i3[2] & thr_m[2] |
//		                   spuint1_i3[3] & thr_m[3]);

   dff_s #(1) spu1m_ff(.din (spuint1_qual_e),
                     .q   (spuint1_m),
                     .clk (clk), .se(se), .si(), .so());

   assign spuint1_trap_m = spuint1_m & intr_vld_m & 
	                    ~(rstint_m | resumint_m | nuke_thr_m | hwint_m);

//   assign spuint1_qual_m = spuint1_trap_m & ~ely_kill_thread_m;
   
   dff_s #(1) spiw1_ff(.din (spuint1_trap_m),
		                 .q   (spuint1_trap_w),
		                 .clk (clk), .se(se), .si(), .so());
   assign spuint1_w = spuint1_trap_w & intr_vld_w;
   
   assign spuint0_e = (spuint0_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                   spuint0_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                   spuint0_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                   spuint0_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   
   assign spuint0_qual_e = spuint0_e & intr_vld_e & ~ueint_e &
			                     ~spuint1_e & ~hintp_e;

//   assign spuint0_m = (spuint0_i3[0] & thr_m[0] |
//		                   spuint0_i3[1] & thr_m[1] |
//		                   spuint0_i3[2] & thr_m[2] |
//		                   spuint0_i3[3] & thr_m[3]);
   dff_s #(1) spu0m_ff(.din (spuint0_qual_e),
                     .q   (spuint0_m),
                     .clk (clk), .se(se), .si(), .so());

   assign spuint0_trap_m = spuint0_m & intr_vld_m &
             	        ~(rstint_m | nuke_thr_m | resumint_m |
		                    hwint_m);
   
//   assign spuint0_qual_m = spuint0_trap_m & ~kill_thread_m;

   dff_s #(1) spiw0_ff(.din (spuint0_trap_m),
		                 .q   (spuint0_trap_w),
		                 .clk (clk), .se(se), .si(), .so());
   assign spuint0_w = spuint0_trap_w & intr_vld_w;
   
//   assign ifu_spu_trap_ack = {spuint1_w, spuint0_w};
   assign ifu_spu_trap_ack = spuint1_w;   
   
   
   // software interrupts
   assign sftint_e = (sftint_i3[0] & thr_e[0] & supv_int_en_d1[0] |
			                sftint_i3[1] & thr_e[1] & supv_int_en_d1[1] |
			                sftint_i3[2] & thr_e[2] & supv_int_en_d1[2] |
			                sftint_i3[3] & thr_e[3] & supv_int_en_d1[3]);

   assign sftint_qual_e = sftint_e & ~spuint0_e & intr_vld_e & 
                          ~ueint_e & ~spuint1_e & ~hintp_e;
   
   dff_s #(1) swm_ff(.din (sftint_qual_e),
                   .q   (sftint_m),
                   .clk (clk), .se(se), .si(), .so());

   // if nothing else, signal sftint!
//   assign ifu_tlu_sftint_m = (sftint_m & 
//	                            ~(rstint_m | nuke_thr_m | hintp_m | resumint_m |
//				                        hwint_m | spuint1_m | spuint0_m | ueint_m) |
//                              ~(ceint_m | rerr_m)) & 
//                               ~kill_local_m & intr_vld_m;

   assign ifu_tlu_sftint_m = (sftint_m & 
	                            ~(rstint_m | nuke_thr_m | hintp_m | resumint_m |
				                        hwint_m | spuint1_m | spuint0_m | ueint_m)) & 
                               ~kill_local_m & ~kill_curr_m & intr_vld_m;
   

   // corrected ecc interrupt
   assign ceint_e = (ceint_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                 ceint_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                 ceint_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                 ceint_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign ceint_qual_e = ceint_e & intr_vld_e & ~ueint_e & 
                          ~spuint1_e & ~spuint0_e & ~hintp_e;

//   assign ceint_m = (ceint_i3[0] & thr_m[0] |
//		                 ceint_i3[1] & thr_m[1] |
//		                 ceint_i3[2] & thr_m[2] |
//		                 ceint_i3[3] & thr_m[3]);
   dff_s #(1) cem_ff(.din (ceint_qual_e),
                   .q   (ceint_m),
                   .clk (clk), .se(se), .si(), .so());
   
   assign ceint_trap_m = ceint_m & intr_vld_m & 
	                 ~(rstint_m | nuke_thr_m | resumint_m |
		                 sftint_m | hwint_m);
   
//   assign ceint_qual_m = ceint_trap_m & ~ely_kill_thread_m;
   dff_s #(1) ceintw_ff(.din (ceint_trap_m),
                      .q   (ceint_trap_w),
                      .clk (clk), .se(se), .si(), .so());
   assign ceint_qual_w = ceint_trap_w & intr_vld_w;

   // resumable error interrupt
   assign rerr_e = (rerr_i3[0] & thr_e[0] & supv_int_en_d1[0] |
		                 rerr_i3[1] & thr_e[1] & supv_int_en_d1[1] |
		                 rerr_i3[2] & thr_e[2] & supv_int_en_d1[2] |
		                 rerr_i3[3] & thr_e[3] & supv_int_en_d1[3]);
   assign rerr_qual_e = rerr_e & intr_vld_e & ~ueint_e & ~ceint_e &
                        ~spuint1_e & ~spuint0_e & ~hintp_e;
   
   dff_s #(1) rem_ff(.din (rerr_qual_e),
                   .q   (rerr_m),
                   .clk (clk), .se(se), .si(), .so());
   
//   assign rerr_m = (rerr_i3[0] & thr_m[0] |
//			              rerr_i3[1] & thr_m[1] |
//			              rerr_i3[2] & thr_m[2] |
//			              rerr_i3[3] & thr_m[3]);

//   assign ifu_tlu_rerr_m = rerr_m & ~kill_local_m & intr_vld_m & 
//	                    ~(rstint_m | nuke_thr_m | ueint_m | ceint_m);

   assign disr_trap_m = (ueint_m | hintp_m | spuint0_m | spuint1_m |
                         ceint_m | rerr_m) & ~rstint_m & ~nuke_thr_m &
                          ~resumint_m & intr_vld_m;

   // check if a scheduled interrupt evaporated...
   assign any_intr_m = (ueint_m | ceint_m | spuint0_m | spuint1_m |
                        hintp_m | rerr_m | sftint_m | hwint_m | 
                        rstint_m | nuke_thr_m | resumint_m);
   
   // ..and rollback if that is the case
   assign rb_intr_m = ~any_intr_m & intr_vld_m;
   dff_s #(1) rbint_ff(.din (rb_intr_m),
                     .q   (rb_intr_w),
                     .clk (clk), .se(se), .si(), .so());

   // use synchronous interrupt signal to switch out thread in swl
//   assign fcl_dtu_sync_intr_d = (intr_vld_d | immu_miss_crit_d) & ~rb_stg_d;
   assign fcl_dtu_sync_intr_d = (intr_vld_d) & ~rb_stg_d_crit;   
   
   // kill the next three interrupts.  After that you are on your own.
//   assign kill_intr_m = ((thr_m & thr_w) == 4'b0) ?
//			                    1'b0 : (intr_vld_w);
   assign kill_intr_e = ((thr_e & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);
   assign kill_intr_d = ((thr_d & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);
   assign kill_intr_f = ((thr_f & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);

//--------------------------------
// check if we are in a delay slot
//--------------------------------
   // remember if the current instruction is a delay slot
   assign delay_slot_vec_nxt = ({4{dtu_fcl_br_inst_d & inst_vld_d & 
                                   ~rb_stg_d}} & thr_d | // set
                                delay_slot_vec &
                                ~(thr_d & {4{inst_vld_d &
                                             ~rb_stg_d &
                                             ~intr_vld_d}})) &
                                 ~(trap_thr & {4{trappc_vld_w2}});
                                // & ~late_flush_w2;
   // Need to be a little pessimitic: can't clear the delay slot vec
   // after a utrap, since we may still be in the delay slot when we
   // re-execute

   dffr_s #(4) ds_reg(.din (delay_slot_vec_nxt),
                    .q   (delay_slot_vec),
                    .rst (fcl_reset),
                    .clk (clk), .se(se), .si(), .so());
   assign fcl_dec_dslot_s = (delay_slot_vec[0] & thr_f[0] |
                             delay_slot_vec[1] & thr_f[1] |
                             delay_slot_vec[2] & thr_f[2] |
                             delay_slot_vec[3] & thr_f[3]);
   

//------------------------------
// NIR control
//------------------------------
   // use nir if va[2] of previous fetch is a zero (i.e lower word)
   dff_s #(1) va2_ff(.din (fdp_fcl_va2_bf),
		               .clk (clk),
		               .q   (va2_f),
		               .se  (se), .si(), .so());
   
   assign usep_bf = rdreq_f & ~va2_f & ~ntpc_thisthr & ~stall_f;
   assign set_usen_bf = usep_bf & ~ely_stall_thisthr_f & dtu_fcl_running_s;
   
   // need to kill usen if trap or interrupt or flush
   assign thr_usen_nxt = ({4{set_usen_bf}} &  thr_f  |    // set usen
			                    thr_usen_bf  & ~val_thr_f) &    // keep old value
			                     ~((thr_d & {4{dtu_fcl_br_inst_d}})  |
		                         (thr_s1 & {4{ic_miss_s1}})  |
                             (thr_e & {4{erb_dtu_ifeterr_d1 & inst_vld_d1}}) |
			                       (clear_s_d1) |
			                       (ntpc_vld)  |
			                       (rb_w2 | rb_froms));     // reset usen (wins)
                         // & ~dtu_fcl_flush_nir
   
   dffr_s #(4) thr_usen_reg(.din  (thr_usen_nxt),
			                  .clk  (clk),
			                  .q    (thr_usen_bf),
			                  .rst  (fcl_reset),
			                  .se   (se), .si(), .so());
   
   /*
   // Use hand instantiated mux
   bw_u1_ao2222_4x UZsize_usn_mx(.z   (usen_iso_bf)
		                            .a2  (thr_usen_bf[0]),
		                            .b2  (thr_usen_bf[1]),
		                            .c2  (thr_usen_bf[2]),
		                            .d2  (thr_usen_bf[3]),
		                            .a1  (nextthr_bf_buf[0]),
		                            .b1  (nextthr_bf_buf[1]),
		                            .c1  (nextthr_bf_buf[2]),
		                            .d1  (nextthr_bf_buf[3]));

    // isolate from critical path
    bw_u1_buf_5x  UZsize_usn_iso(.z(usen_bf), .a(usen_iso_bf));
    */
                                
   assign usen_iso_bf = (thr_usen_bf[0] & nextthr_bf_buf[0] |
                         thr_usen_bf[1] & nextthr_bf_buf[1] |
                         thr_usen_bf[2] & nextthr_bf_buf[2] |
                         thr_usen_bf[3] & nextthr_bf_buf[3]);
   assign usen_bf = usen_iso_bf;

   
   
//------------------------------
// Switch Control
//------------------------------   
   // Switch IF
   //   1. Another thread is ready OR
   //   2. We hit a switch condition or Imiss and another thread is
   //      speculatively ready
   //   3. No thread is running and another thread is speculatively ready
   //   4. The DTU calls for a thread switch and another thread is ready
   //   (NOTE: if we hit a switch condition or Imiss and no thread is
   //    speculatively or otherwise ready we stall the pipe).
   //
   //   New plan:  switch if another thread is ready or spec ready.
   //

//   assign switch_bf = dtu_fcl_ntr_s;
   // mmckeown: when execution drafting is enabled, this is determined by
   // the switch_bf signal from ESL
   bw_u1_buf_20x UZsize_swbuf(.a (config_dtu_esl_en ? esl_fcl_switch_bf : dtu_fcl_ntr_s),
                              .z (switch_bf));
   
//   assign switch_bf = dtu_fcl_ntr_s & ~imsto_nextthr_s1;
//   assign switch_bf = dtu_fcl_ntr_s & ~(imsto_nextthr_s1 | kill_nextthr_w | 
//                                        intrto_nextthr_d);   
   
//   assign fcl_dtu_switch_s = switch_bf & ~all_stallreq & ~rst_stallreq;
//   assign fcl_dtu_switch_s = switch_bf & ~kill_nextthr_w;

   // TBD: No need to send this anymore, since switch_bf = ntr_s
//   assign fcl_dtu_switch_s = switch_bf;  // sw out curr and sw in next

   assign fcl_swl_swout_f = stall_f;     // sw out curr but don't sw in next
   // Note: need fcl_swl_swout_f and dtu_fcl_running_s to sync swl and
   // fcl at all times.  

   // mmckeown: when execution drafting is enabled, this is determined by
   //           ntr_s, not from the same thing as bf 
   assign switch_qual_bf = (config_dtu_esl_en ? esl_fcl_ntr_s : switch_bf) & ~rst_stallreq;
   dff_s #(1) sw_ff (.din  (switch_qual_bf),
		               .clk  (clk),
		               .q    (switch_s2),
		               .se   (se), .si(), .so());

   dff_s #(1) tmfn_ff (.din  (switch_bf),
		                 .clk  (clk),
		                 .q    (tm_fd_l),
		                 .se   (se), .si(), .so());

   // need to qual with immu_fault to avoid X's
//   assign fcl_dtu_swc_s = fdp_fcl_swc_s2 & inst_vld_s_crit & 
//                          ~immu_fault_f & ~part_stall_thisthr_f;
//   assign fcl_dtu_swc_s = fdp_fcl_swc_s2 & inst_vld_s_crit & 
//                          ~immu_fault_f & ~imsto_thisthr_s1 & ~rb_stg_s;
   assign fcl_swl_swcvld_s = inst_vld_s_crit & ~immu_fault_f & 
                             ~imsto_thisthr_s1 & ~rb_stg_s;
     

//------------------------------   
// Thread pipe
//------------------------------

//`ifdef VERPLEX
//   $constraint nthr_1h4 ($one_hot(dtu_fcl_nextthr_bf[3:0]));
//   $constraint thrf_1h4 ($one_hot(thr_f[3:0]));
//`endif
   
   // Keep track the thread in each pipe stage
   assign rstt = (~fcl_reset & (rst_stallreq_d1 & ~arst_vld_f)) | rst_tri_en;
   assign swt =  (~rst_stallreq_d1 & ~arst_vld_f & switch_bf | fcl_reset) & 
                   ~rst_tri_en;
   assign samet = (~rst_stallreq_d1 & ~switch_bf | arst_vld_f) & 
                    ~fcl_reset & ~rst_tri_en;
   
   mux3ds #(4)  nxttthr_mux(.dout  (thr_bf[3:0]),      
			                      .in0   (thr_f[3:0]),       
			                      .in1   (nextthr_bf_buf[3:0]),
			                      .in2   (rstint_penc[3:0]), 
			                      .sel0  (samet),
			                      .sel1  (swt),
			                      .sel2  (rstt));

   assign thr_match_nw = (thr_w[0] & nextthr_bf_buf[0] | 
			                    thr_w[1] & nextthr_bf_buf[1] | 
			                    thr_w[2] & nextthr_bf_buf[2] | 
			                    thr_w[3] & nextthr_bf_buf[3]);

   assign thr_match_nd = (thr_d[0] & nextthr_bf_buf[0] | 
			                    thr_d[1] & nextthr_bf_buf[1] | 
			                    thr_d[2] & nextthr_bf_buf[2] | 
			                    thr_d[3] & nextthr_bf_buf[3]);

//   assign thr_match_ne = (thr_e[0] & dtu_fcl_nextthr_bf[0] | 
//			                    thr_e[1] & dtu_fcl_nextthr_bf[1] | 
//			                    thr_e[2] & dtu_fcl_nextthr_bf[2] | 
//			                    thr_e[3] & dtu_fcl_nextthr_bf[3]);
   // qualify inst_vld_e in fcl itself

//   bw_u1_ao2222_4x UZsize_tmne(.z  (thr_match_ne),
//                               .a1 (val_thr_e[0]),
//                               .b1 (val_thr_e[1]),
//                               .c1 (val_thr_e[2]),
//                               .d1 (val_thr_e[3]),
//                               .a2 (dtu_fcl_nextthr_bf[0]),
//                               .b2 (dtu_fcl_nextthr_bf[1]),
//                               .c2 (dtu_fcl_nextthr_bf[2]),
//                               .d2 (dtu_fcl_nextthr_bf[3]));

   wire   tmne_10,
          tmne_32;
   bw_u1_aoi22_2x UZsize_tmne10(.z (tmne_10),
                                .a1 (dtu_fcl_nextthr_bf[0]),
                                .b1 (dtu_fcl_nextthr_bf[1]),
                                .a2 (val_thr_e[0]),
                                .b2 (val_thr_e[1]));
   bw_u1_aoi22_2x UZsize_tmne32(.z (tmne_32),
                                .a1 (dtu_fcl_nextthr_bf[2]),
                                .b1 (dtu_fcl_nextthr_bf[3]),
                                .a2 (val_thr_e[2]),
                                .b2 (val_thr_e[3]));
   bw_u1_nand2_4x UZsize_tmne30(.z (thr_match_ne),
                                .a (tmne_10),
                                .b (tmne_32));
   

   dff_s #(4) thrf_reg(.din   (thr_bf),     // thr_f may be 4'b0000 but it has 
		                 .clk   (clk),        // to reset to 4'b0001
		                 .q     (thr_f_flop),
		                 .se    (se),  .si(), .so());

   bw_u1_buf_10x UZsize_tfcrit0(.a (thr_f_flop[0]), .z(thr_f_crit[0]));
   bw_u1_buf_10x UZsize_tfcrit1(.a (thr_f_flop[1]), .z(thr_f_crit[1]));
   bw_u1_buf_10x UZsize_tfcrit2(.a (thr_f_flop[2]), .z(thr_f_crit[2]));
   bw_u1_buf_10x UZsize_tfcrit3(.a (thr_f_flop[3]), .z(thr_f_crit[3]));

   bw_u1_buf_10x UZsize_tfncr0(.a (thr_f_flop[0]), .z(thr_f[0]));
   bw_u1_buf_10x UZsize_tfncr1(.a (thr_f_flop[1]), .z(thr_f[1]));
   bw_u1_buf_10x UZsize_tfncr2(.a (thr_f_flop[2]), .z(thr_f[2]));
   bw_u1_buf_10x UZsize_tfncr3(.a (thr_f_flop[3]), .z(thr_f[3]));

   assign     ifu_exu_tid_s2[1] = thr_f[3] | thr_f[2];
   assign     ifu_exu_tid_s2[0] = thr_f[3] | thr_f[1];
   assign     ifu_lsu_thrid_s = ifu_exu_tid_s2;
   assign     fcl_dtu_thr_f = thr_f;
   
//   assign thr_s1_next = inst_vld_f ? thr_f : thr_s1;
   assign     thr_s1_next[0] = thr_f[0];
   assign     thr_s1_next[1] = ~thr_f[0] & thr_f[1];
   assign     thr_s1_next[2] = ~thr_f[0] & ~thr_f[1] & thr_f[2];
   assign     thr_s1_next[3] = ~thr_f[0] & ~thr_f[1] & ~thr_f[2];
   
//`ifdef VERPLEX
//   $constraint thr_s1_1h4 ($one_hot(thr_s1_next[3:0]));
//`endif
   
   dff_s #(4) thrs1_reg(.din   (thr_s1_next),
		    .clk   (clk),
		    .q     (thr_s1),
		    .se    (se), .si(), .so());
   
   dff_s #(4) thrd_reg(.din    (thr_s1_next), 
                    .clk   (clk),
                    .q     (thr_d),
                    .se    (se), .si(), .so());
   
   assign fcl_ifq_thr_s1[0] = thr_s1[3] | thr_s1[1];
   assign fcl_ifq_thr_s1[1] = thr_s1[3] | thr_s1[2];

   assign ifu_tlu_thrid_d[1] = thr_d[3] | thr_d[2];
   assign ifu_tlu_thrid_d[0] = thr_d[3] | thr_d[1];
   
   assign thr_match_fs1 = (thr_d[0] & thr_f_crit[0] | 
			                     thr_d[1] & thr_f_crit[1] | 
			                     thr_d[2] & thr_f_crit[2] | 
			                     thr_d[3] & thr_f_crit[3]);
   assign thr_match_fd = thr_match_fs1;
   assign thr_match_fe = (thr_e[0] & thr_f[0] | 
			                    thr_e[1] & thr_f[1] | 
			                    thr_e[2] & thr_f[2] | 
			                    thr_e[3] & thr_f[3]);
   assign thr_match_fm = (thr_m[0] & thr_f[0] | 
			                    thr_m[1] & thr_f[1] | 
			                    thr_m[2] & thr_f[2] | 
			                    thr_m[3] & thr_f[3]);
//   assign thr_match_ft = (trap_thr[0] & thr_f[0] | 
//			  trap_thr[1] & thr_f[1] | 
//			  trap_thr[2] & thr_f[2] | 
//			  trap_thr[3] & thr_f[3]);
   
   dffr_s #(4) thre_reg(.din   (thr_d),    
		    .clk   (clk),
		    .rst   (fcl_reset),
		    .q     (thr_e),
		    .se    (se), .si(), .so());
   assign fcl_esl_thr_e = thr_e;

   dffr_s #(4) thre2_reg(.din   (thr_d),    
		    .clk   (clk),
		    .rst   (fcl_reset),
		    .q     (thr_e_v2),
		    .se    (se), .si(), .so());

   assign     ifu_tlu_thrid_e[1] = thr_e[3] | thr_e[2];
   assign     ifu_tlu_thrid_e[0] = thr_e[3] | thr_e[1];

   assign thr_match_de = (thr_d[0] & thr_e[0] | 
			                    thr_d[1] & thr_e[1] | 
			                    thr_d[2] & thr_e[2] | 
			                    thr_d[3] & thr_e[3]);
			  
   assign thr_match_dm = (thr_d[0] & thr_m[0] | 
			                    thr_d[1] & thr_m[1] | 
			                    thr_d[2] & thr_m[2] | 
			                    thr_d[3] & thr_m[3]);

   dff_s #(4) thrm_reg(.din   (thr_e),    
		   .clk   (clk),
		   .q     (thr_m),
		   .se    (se), .si(), .so());
   assign fcl_esl_thr_m = thr_m;

   dff_s #(4) thrw_reg(.din   (thr_m),    
		   .clk   (clk),
		   .q     (thr_w),
		   .se    (se), .si(), .so());

   assign sas_thrid_w[1] = thr_w[3] | thr_w[2];
   assign sas_thrid_w[0] = thr_w[3] | thr_w[1];
   
   assign thr_match_fw = (thr_f[0] & thr_w[0] | 
			                    thr_f[1] & thr_w[1] | 
			                    thr_f[2] & thr_w[2] | 
			                    thr_f[3] & thr_w[3]);
	 
   assign thr_match_fw2 = (thr_f[0] & thr_w2[0] | 
			                     thr_f[1] & thr_w2[1] | 
			                     thr_f[2] & thr_w2[2] | 
			                     thr_f[3] & thr_w2[3]);

   assign thr_match_dw = (thr_d[0] & thr_w[0] | 
			                    thr_d[1] & thr_w[1] | 
			                    thr_d[2] & thr_w[2] | 
			                    thr_d[3] & thr_w[3]);

   assign thr_match_dw2 = (thr_d[0] & thr_w2[0] | 
			                     thr_d[1] & thr_w2[1] | 
			                     thr_d[2] & thr_w2[2] | 
			                     thr_d[3] & thr_w2[3]);
	 
   assign thr_match_em = (thr_e[0] & thr_m[0] | 
			                    thr_e[1] & thr_m[1] | 
			                    thr_e[2] & thr_m[2] | 
			                    thr_e[3] & thr_m[3]);

   assign thr_match_ew = (thr_e_v2[0] & thr_w[0] | 
			                    thr_e_v2[1] & thr_w[1] | 
			                    thr_e_v2[2] & thr_w[2] | 
			                    thr_e_v2[3] & thr_w[3]);

   dff_s #(1) stmw2_ff(.din (thr_match_ew),
                     .q   (same_thr_mw2),
                     .clk (clk), .se (se), .si(), .so());
   
   assign thr_match_ew2 = (thr_e[0] & thr_w2[0] | 
			                     thr_e[1] & thr_w2[1] | 
			                     thr_e[2] & thr_w2[2] | 
			                     thr_e[3] & thr_w2[3]);
	 
   assign thr_match_mw = (thr_m[0] & thr_w[0] | 
			                    thr_m[1] & thr_w[1] | 
			                    thr_m[2] & thr_w[2] | 
			                    thr_m[3] & thr_w[3]);
			  
   dff_s #(4) thrw2_reg(.din   (thr_w),    
		    .clk   (clk),
		    .q     (thr_w2),
		    .se    (se), .si(), .so());
   

//-------------------------
// Rollback
//-------------------------

   // 04/05/02
   // Looks like we made a mistake with rollback.  Should never
   // rollback to S.  In the event of a dmiss or mul contention, just
   // kill all the instructions and rollback to F.  This adds one
   // cycle to the dmiss penalty and to the mul latency if we have to
   // wait, both not a very high price to pay.  This would have saved
   // lots of hours of design and verif time.
   //    
   assign rb2_inst_d = thr_match_dw & inst_vld_d & dtu_fcl_rollback_g;
   assign rb1_inst_s = thr_match_fw & inst_vld_s & dtu_fcl_rollback_g;
   assign rb0_inst_bf = thr_match_nw & switch_bf & dtu_fcl_rollback_g;

//   assign rt1_inst_s = thr_match_fd & inst_vld_s & retract_inst_d;
//   assign rt0_inst_bf = thr_match_nd & dtu_fcl_ntr_s & retract_inst_d;

//   assign retract_iferr_d = thr_match_de & erb_dtu_ifeterr_d1 & inst_vld_d1 &
//                            ~kill_curr_e & fcl_dtu_inst_vld_d;
   assign retract_iferr_d1 = erb_dtu_ifeterr_d1 & inst_vld_d1;

   assign retract_inst_d = retract_iferr_d1 & thr_match_de & 
                           fcl_dtu_inst_vld_d |
                           mark4rb_d | 
                           dtu_fcl_retract_d;

   assign rt1_inst_s = thr_match_fd & inst_vld_s & dtu_fcl_retract_d | 
                       mark4rb_s;
//                     | thr_match_fe & inst_vld_s & retract_iferr_d1;

   // TBD:  This is not necessary since the thread will switch out and
   // stall whatever makes its way to the S stage.
   // NOTE: rb0_inst *is needed* however.
   assign rt0_inst_bf = thr_match_nd & switch_bf & dtu_fcl_retract_d;
//                      | thr_match_ne & dtu_fcl_ntr_s & retract_iferr_d1;

   assign retract_iferr_qual_d1 = retract_iferr_d1 & thr_match_de &
                                  fcl_dtu_inst_vld_d &
                                  ~(dtu_fcl_rollback_g & thr_match_ew);

   dff_s rbe_ff(.din (rb2_inst_d),
	      .q   (rb2_inst_e),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rte_ff(.din (retract_inst_d),
	      .q   (rt2_inst_e),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rbd_ff(.din (rb1_inst_s),
	      .q   (rb1_inst_d),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rtd_ff(.din (rt1_inst_s),
	      .q   (rt1_inst_d),
	      .clk (clk),
	      .se  (se), .si(), .so());
   
   dff_s rbs_ff(.din (rb0_inst_bf),
	      .q   (rb0_inst_s),
	      .clk (clk),
	      .se  (se), .si(), .so());

   // TBD: is this necessary?
   dff_s rts_ff(.din (rt0_inst_bf),
	      .q   (rt0_inst_s),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rtiferr_ff(.din (retract_iferr_qual_d1),
                  .q   (retract_iferr_e),
                  .clk (clk),
                  .se  (se), .si(), .so());
  
   // mmckeown: Adding this to know if there will be a roll
   // back on this stage, as we need to declare diverged
   // if so, we should reconverge very quickly after a 
   // rollback.
   assign fcl_esl_rb_stg_s = rb_stg_s;

   assign rb_stg_s = (rb0_inst_s | rt0_inst_s) & tm_fd_l |
	                   (rb1_inst_d | rt1_inst_d) & ~tm_fd_l;
   assign rb_stg_d_crit = rb1_inst_d | rt1_inst_d;
   assign rb_stg_e = rb2_inst_e | rt2_inst_e;

   bw_u1_buf_5x UZsize_rbd_buf(.a (rb_stg_d_crit),
                               .z (rb_stg_d));
   
   // determine rollback amount
   assign rb_frome = {4{(rb2_inst_e | rt2_inst_e) & 
                        (inst_vld_e | intr_vld_e)}} & thr_e;
   assign rb_fromd = {4{(rb1_inst_d | rt1_inst_d) & 
                        (inst_vld_d | intr_vld_d)}} & thr_d;
   assign rb_froms = {4{rb_stg_s & inst_vld_s_crit}} & thr_f;   
   assign rb_w2 = rb_frome | rb_fromd;
   assign rb_for_iferr_e = {4{retract_iferr_e}} & thr_e;

//------------------------------   
// Branch Control
//------------------------------
   // final portion of branch evaluation
   wire brtaken_e_l;   
   bw_u1_buf_20x UZsize_bcbf(.z(fcl_dcl_regz_e), 
                             .a(exu_ifu_regz_e));
      
   bw_u1_muxi21_6x UZsize_bcmux(.z(brtaken_e_l), 
                                .d0(dcl_fcl_bcregz0_e), 
                                .d1(dcl_fcl_bcregz1_e), 
                                .s(exu_ifu_regz_e));

   bw_u1_inv_15x UZsize_bcinv(.z(brtaken_e), 
                              .a(brtaken_e_l));

   // Branch is taken in the E stage to thr_e.  Below we check to see
   // if this is the same as the next thread we will switch to

   // isolate non critical section
   bw_u1_buf_5x UZsize_btbuf(.z (brtaken_unq_e),
                             .a (brtaken_e));
   assign brtaken_buf_e = brtaken_unq_e & inst_vld_qual_e & ~kill_curr_e;
   assign fcl_esl_brtaken_e = brtaken_buf_e;

//   assign thr_match_ne_norst = thr_match_ne & ~rst_sw_bf;
//   assign brto_nxtthr_bf  = thr_match_ne & brtaken_e;
   bw_u1_nand2_4x UZsize_btkn_ntl(.a (brtaken_e),
                                  .b (thr_match_ne),
                                  .z (brto_nxtthr_bf_l));

//   bw_u1_inv_8x UZsize_btkn_bf(.a (brto_nxtthr_bf_l),
//                               .z (brto_nxtthr_bf));

   dff_s #(1) br_ff(.din (brtaken_buf_e),
		              .q   (brtaken_m),
		              .clk (clk),
		              .se  (se), .si(), .so());
   assign fcl_esl_brtaken_m = brtaken_m;
   

//----------------------------------------------------------------------
// PC related control
//----------------------------------------------------------------------

   // Choose next IC address
   // IC address is chosen from
   //    1. Next PC assuming no switch 
   //    2. Branch PC if E stage branch is to next thread
   //    3. Saved F stage Thread PC if we switch threads

   assign fcl_icd_index_sel_ifq_bf = allow_ifq_access_icd_bf;
   assign fcl_ifq_grant_bf = allow_ifq_access_icd_bf;

   // Select branch PC
//   assign fcl_fdp_icaddr_sel_br_bf_l = ~(~all_stallreq &
//					                               brto_nxtthr_bf    &
//					                               switch_bf);
//
//   // Select the switch PC from thread PC register
//   assign fcl_fdp_icaddr_sel_swpc_bf_l = ~(~all_stallreq &
//					                                 ~usen_bf &
//					                                 ~brto_nxtthr_bf &
//					                                 switch_bf);
//
//   // Select current thread's next PC or IC write addr (PC/PC+4/I$ wraddr)
//   assign fcl_fdp_icaddr_sel_curr_bf_l = ~(~all_stallreq &
//					                                 ~(stall_f | usep_bf) & 
//					                                 ~switch_bf);
//   
//   assign fcl_fdp_icaddr_sel_ifq_bf_l = ~(all_stallreq |
//					                                (stall_f | usep_bf) & ~switch_bf |
//					                                ~brto_nxtthr_bf & usen_bf &
//					                                (switch_bf | stall_f | usep_bf));
   
   

//   assign sw_or_async_stall = (switch_bf & ~rst_stallreq | rst_sw_bf);
   wire   sw_or_async_stall_l;
   assign rst_stallreq_l = ~rst_stallreq;
   bw_u1_aoi21_4x UZsize_swstl_aoi(.z  (sw_or_async_stall_l),
                                   .a  (rst_sw_bf),
                                   .b1 (switch_bf),
                                   .b2 (rst_stallreq_l));
   assign sw_or_async_stall = ~sw_or_async_stall_l;

//   assign icadr_selbr = sw_or_async_stall & brto_nxtthr_bf;
   assign sw_match_ne_norst = sw_or_async_stall & thr_match_ne;
   bw_u1_nand2_10x UZfix_icad_br(.a (brtaken_e),
                                 .b (sw_match_ne_norst),
                                 .z (icadr_selbr_l));

//   assign icadr_selsw = sw_or_async_stall & ~brto_nxtthr_bf;
   bw_u1_nand2_15x UZfix_icad_sw(.a (brto_nxtthr_bf_l),
                                 .b (sw_or_async_stall),
                                 .z (icadr_selsw_l));
   

   // select next PC
   assign fcl_fdp_pcbf_sel_br_bf_l = icadr_selbr_l;
   assign fcl_fdp_pcbf_sel_swpc_bf_l = icadr_selsw_l ;
   assign fcl_fdp_pcbf_sel_nosw_bf_l = ~sw_or_async_stall_l;

   // Select PC to switch to in the event of a switch
   // No need to protect during scan
   // NOTE: SWL guarantees nextthr_bf is one hot
//   assign fcl_fdp_next_thr_bf_l = rst_stallreq_d1 ? ~rstint_penc :
//                                                    ~dtu_fcl_nextthr_bf;

   wire [3:0] next_thr_bf_l;
   wire       nt_sel_rst;
   assign     nt_sel_rst = rst_stallreq_d1 | rst_tri_en;
   
   bw_u1_muxi21_2x UZfix_nthr_mx0(.z (next_thr_bf_l[0]),
                                  .d0 (dtu_fcl_nextthr_bf[0]),
                                  .d1 (rstint_penc[0]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx1(.z (next_thr_bf_l[1]),
                                  .d0 (dtu_fcl_nextthr_bf[1]),
                                  .d1 (rstint_penc[1]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx2(.z (next_thr_bf_l[2]),
                                  .d0 (dtu_fcl_nextthr_bf[2]),
                                  .d1 (rstint_penc[2]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx3(.z (next_thr_bf_l[3]),
                                  .d0 (dtu_fcl_nextthr_bf[3]),
                                  .d1 (rstint_penc[3]),
                                  .s  (nt_sel_rst));
   assign     fcl_fdp_next_thr_bf_l = next_thr_bf_l;
   

//   assign nextthr_bf_buf = dtu_fcl_nextthr_bf;
   bw_u1_buf_20x UZsize_ntbf0(.a (dtu_fcl_nextthr_bf[0]),
                              .z (nextthr_bf_buf[0]));
   bw_u1_buf_20x UZsize_ntbf1(.a (dtu_fcl_nextthr_bf[1]),
                              .z (nextthr_bf_buf[1]));
   bw_u1_buf_20x UZsize_ntbf2(.a (dtu_fcl_nextthr_bf[2]),
                              .z (nextthr_bf_buf[2]));
   bw_u1_buf_20x UZsize_ntbf3(.a (dtu_fcl_nextthr_bf[3]),
                              .z (nextthr_bf_buf[3]));
   // use 6x
   assign fcl_fdp_next_ctxt_bf_l[2:0] = ~nextthr_bf_buf[2:0] | {3{rst_tri_en}};
   assign fcl_fdp_next_ctxt_bf_l[3] = ~nextthr_bf_buf[3] & ~rst_tri_en;

//   assign nextthr_final_bf = switch_bf ? dtu_fcl_nextthr_bf : thr_f;
   wire [3:0] nextthr_final_bf_l;
   bw_u1_muxi21_2x UZfix_ntfmux0(.z  (nextthr_final_bf_l[0]),
                                .d0 (thr_f[0]),
                                .d1 (dtu_fcl_nextthr_bf[0]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf0(.z (nextthr_final_bf[0]),
                                 .a (nextthr_final_bf_l[0]));

   bw_u1_muxi21_2x UZfix_ntfmux1(.z  (nextthr_final_bf_l[1]),
                                .d0 (thr_f[1]),
                                .d1 (dtu_fcl_nextthr_bf[1]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf1(.z (nextthr_final_bf[1]),
                                 .a (nextthr_final_bf_l[1]));

   bw_u1_muxi21_2x UZfix_ntfmux2(.z  (nextthr_final_bf_l[2]),
                                .d0 (thr_f[2]),
                                .d1 (dtu_fcl_nextthr_bf[2]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf2(.z (nextthr_final_bf[2]),
                                 .a (nextthr_final_bf_l[2]));

   bw_u1_muxi21_2x UZfix_ntfmux3(.z  (nextthr_final_bf_l[3]),
                                .d0 (thr_f[3]),
                                .d1 (dtu_fcl_nextthr_bf[3]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf3(.z (nextthr_final_bf[3]),
                                 .a (nextthr_final_bf_l[3]));
   
   
   // decode trap thread
   dff_s #(2) ld_trp_reg(.din ({tlu_ifu_trappc_vld_w1,
                              tlu_ifu_trapnpc_vld_w1}),
                       .q   ({trappc_vld_w2,
                              trapnpc_vld_w2}),
                       .clk (clk), .se(se), .si(), .so());

   dff_s #(2) trp_tid_reg(.din (tlu_ifu_trap_tid_w1[1:0]),
                        .q   (trap_tid_w2[1:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign trap_thr[0] = ~trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[1] = ~trap_tid_w2[1] &  trap_tid_w2[0];
   assign trap_thr[2] =  trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[3] =  trap_tid_w2[1] &  trap_tid_w2[0];

   assign load_tpc[3:0] = {4{trappc_vld_w2}} & trap_thr |
	                   rb_w2 |
	                   {4{rb_stg_w | ims_flush_coll_w}} & thr_w |
//                     {4{dec_fcl_kill4sta_e}} & thr_e |
	                   {4{flush_sonly_qual_m}} & thr_m;
   // mmckeown: determine if trap this cycle
   assign fcl_esl_thr_trap_bf = load_tpc;

   assign load_bpc[3:0] = {4{brtaken_buf_e}} & thr_e;
   assign load_pcp4[3:0] = {4{~part_stall_thisthr_f &
                              ~iferrto_thisthr_d1 |
                              arst_vld_f |
                              async_intr_vld_s}}     & thr_f;

   always @ (/*AUTOSENSE*/load_bpc or load_pcp4 or load_tpc)
     begin
//	      if (fcl_reset)
//	        begin // RESET PC is loaded to T0
//	           fcl_fdp_tpcbf_sel_old_bf_l = 4'b0001;
//	           fcl_fdp_tpcbf_sel_pcp4_bf_l = 4'b1110;
//	           fcl_fdp_tpcbf_sel_trap_bf_l = 4'b1111;
//	           fcl_fdp_tpcbf_sel_brpc_bf_l = 4'b1111;
//	        end // if (reset)
//	      else 
//	        begin
	      fcl_fdp_tpcbf_sel_old_bf_l = (load_bpc | load_tpc | load_pcp4);
	      fcl_fdp_tpcbf_sel_brpc_bf_l = ~load_bpc | load_tpc | load_pcp4;
	      fcl_fdp_tpcbf_sel_pcp4_bf_l = ~load_pcp4 | load_tpc;
	      fcl_fdp_tpcbf_sel_trap_bf_l = ~load_tpc;
     end // always @ (...

   // Track correctible errors
   assign irf_ce_m = exu_ifu_ecc_ce_m & ~trap_m & inst_vld_m & ~kill_curr_m;
   dff_s #(1) irfcew_ff(.din (irf_ce_m),
		                .q   (irf_ce_w),
		                .clk (clk), .se(se), .si(), .so());

   // track if ldhit was actually a miss
   // D and S stage are rolled back through the normal D stage retract
   // process.  
   assign mark4rb_d = lsu_ifu_dc_parity_error_w2 & thr_match_dw2 & 
                      (inst_vld_d | intr_vld_d);
   assign mark4rb_s = lsu_ifu_dc_parity_error_w2 & thr_match_fw2 & 
                      (inst_vld_s | intr_vld_s);

   assign mark4rb_e = lsu_ifu_dc_parity_error_w2 & thr_match_ew2 & 
                      (inst_vld_e | intr_vld_e) & 
                        ~dtu_inst_anull_e & ~kill_curr_e;

   dff_s #(2) markrb_reg(.din ({mark4rb_m,
                              mark4rb_e}),
                       .q   ({mark4rb_w,
                              mark4rb_m}),
                       .clk (clk),
                       .se  (se), .si(), .so());
   
   // Rollback from W on irf/frf ce and on a dcache parity error
   assign rb_stg_w = irf_ce_w & inst_vld_w & no_iftrap_w | 
	                   ffu_ifu_fst_ce_w & inst_vld_w & no_iftrap_w |
                     rb_intr_w & intr_vld_w |
                     mark4rb_w |
                     fcl_dtu_resum_thr_w | 
		                 fcl_dtu_nuke_thr_w;

   // flush after hardware micro trap
//   assign ifu_tlu_flush_w = irf_ce_w | fcl_dtu_nuke_thr_w | mark4rb_w |
//                            fcl_dtu_resum_thr_w;
   // very critical
   assign ifu_tlu_flush_m = (exu_ifu_ecc_ce_m & inst_vld_m & ~trap_m |
                             (resumint_m | nuke_thr_m) & 
                             intr_vld_m & ~rstint_m |
                             rb_intr_m | 
                             mark4rb_m);
   assign utrap_flush_m =  ifu_tlu_flush_m & ~kill_local_m;
   dff_s #(1) flw_ff(.din (utrap_flush_m),
                   .q   (utrap_flush_w),
                   .clk (clk), .se(se), .si(), .so());
   assign ifu_tlu_flush_w = utrap_flush_w;
   assign fcl_swl_flush_w =  (irf_ce_w & inst_vld_w & no_iftrap_w | 
                              rb_intr_w & intr_vld_w |
                              mark4rb_w |
                              fcl_dtu_resum_thr_w | 
		                          fcl_dtu_nuke_thr_w);

   // tells swl to flush and then wake up
   assign fcl_swl_flush_wake_w = fcl_swl_flush_w & ~mark4rb_w;
   
   // if the same instruction keeps hitting ce's disable ce detection
   // count how many ce's occur to a given thread
   assign any_ce_w = ffu_ifu_fst_ce_w | irf_ce_w;
   
   assign ce_cnt1_nxt = (({4{any_ce_w & inst_vld_w}} & thr_w & 
                          ce_cnt0) ^ ce_cnt1) & ~ce_cnt_rst;
   assign ce_cnt0_nxt = (({4{any_ce_w & inst_vld_w}} & thr_w) ^ 
                         ce_cnt0) & ~ce_cnt_rst;

   assign ce_cnt_rst = thr_w & {4{inst_vld_w & ~any_ce_w}} | {4{fcl_reset}};

   dff_s #(8) cecnt_reg(.din ({ce_cnt1_nxt, ce_cnt0_nxt}),
                      .q   ({ce_cnt1, ce_cnt0}),
                      .clk (clk),
                      .se(se), .si(), .so());

   // find the count for the current d stage thread
   assign ce_val1_d = (thr_d[0] & ce_cnt1[0] | 
                       thr_d[1] & ce_cnt1[1] | 
                       thr_d[2] & ce_cnt1[2] | 
                       thr_d[3] & ce_cnt1[3]);

   assign ce_val0_d = (thr_d[0] & ce_cnt0[0] | 
                       thr_d[1] & ce_cnt0[1] | 
                       thr_d[2] & ce_cnt0[2] | 
                       thr_d[3] & ce_cnt0[3]);

   // if count hits 3 disable ce's
   assign disable_ce_d = ce_val1_d & ce_val0_d;

   dff_s #(1) disce_ff(.din (disable_ce_d),
                     .q   (disable_ce_e),
                     .clk (clk), .se(se), .si(), .so());
   assign ifu_exu_disable_ce_e = disable_ce_e;
   
   // select error/trap/utrap rollback PC
   assign fcl_fdp_trrbpc_sel_trap_bf_l = 
		                ~({4{trappc_vld_w2}} & trap_thr);

   assign fcl_fdp_trrbpc_sel_err_bf_l = 
                  ({4{trappc_vld_w2}} & trap_thr) |
	                 ~({4{rb_stg_w}} & thr_w);
   
   assign fcl_fdp_trrbpc_sel_rb_bf_l = 
                  ({4{trappc_vld_w2}} & trap_thr) |
		               ({4{rb_stg_w}} & thr_w) |		   
	                ~(rb_frome & rb_fromd);
   
   assign fcl_fdp_trrbpc_sel_pcs_bf_l = 
                 ({4{trappc_vld_w2}} & trap_thr) | 
		               ({4{rb_stg_w}} & thr_w) |		   
	                 (rb_frome & rb_fromd);
   
   // select next S stage Thr PC
   assign fcl_fdp_nextpcs_sel_pce_f_l = ~rb_frome;
   assign fcl_fdp_nextpcs_sel_pcd_f_l = rb_frome | ~rb_fromd;
   assign fcl_fdp_nextpcs_sel_pcf_f_l = rb_frome | rb_fromd |
	                                ~(thr_f & {4{~part_stall_thisthr_f &
                                               ~iferrto_thisthr_d1 |
                                               arst_vld_f |
                                               async_intr_vld_s}});
   assign fcl_fdp_nextpcs_sel_pcs_f_l = rb_frome | rb_fromd | 
	                                (thr_f & {4{~part_stall_thisthr_f &
                                              ~iferrto_thisthr_d1 |
                                              arst_vld_f |
                                              async_intr_vld_s}});
   
   // next S2 stage pc and npc select
   assign thr_f_dec[3:1] = thr_f_crit[3:1] & {3{~rst_tri_en}};
   assign thr_f_dec[0] = thr_f_crit[0] | rst_tri_en;
   assign fcl_fdp_thr_s2_l = ~thr_f_dec;     // thr_f = thr_s2


   // Select NextPC from
   //    1. Trap NextPC (if the tnpc is valid)
   //    2. reset PC
   //    3. incremented PC (PC+4)
   //    4. old PC (in the event of a stall)

   // Load the trap PC to the BF stage NPC.  (The BF stage NPC is used
   // only for storing the next PC from the TLU
   assign fcl_fdp_thrtnpc_sel_tnpc_l = ~({4{trapnpc_vld_w2}} & trap_thr);

   assign fcl_fdp_thrtnpc_sel_npcw_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                       ~({4{rb_stg_w}} & thr_w);

   assign fcl_fdp_thrtnpc_sel_pcf_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                      ({4{rb_stg_w}} & thr_w) |
	                                        (~({4{ims_flush_coll_w}} & thr_w) &
                                           ~({4{flush_sonly_qual_m}} & thr_m));
                                       //   {4{dec_fcl_kill4sta_e}} & thr_e);
   
   assign fcl_fdp_thrtnpc_sel_old_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                      ({4{rb_stg_w}} & thr_w) |
	                                      ({4{ims_flush_coll_w}} & thr_w) |
                                        ({4{flush_sonly_qual_m}} & thr_m);
                                         // {4{dec_fcl_kill4sta_e}} & thr_e);
   
   assign ntpc_vld_nxt = fcl_fdp_thrtnpc_sel_old_l | 
	                       ntpc_vld & ({4{(part_stall_thisthr_f |
                                         iferrto_thisthr_d1) & 
                                        ~arst_vld_f &
                                        ~async_intr_vld_s}} | ~thr_f) &
                                  ~({4{trappc_vld_w2}} & trap_thr);
   
   dffr_s #(4) ntpcv_reg(.din  (ntpc_vld_nxt),
		     .clk  (clk),
		     .q    (ntpc_vld),
		     .rst  (fcl_reset),
		     .se   (se), .si(), .so());

   assign ntpc_thisthr = (thr_f[0] & ntpc_vld[0] |
			                    thr_f[1] & ntpc_vld[1] |
			                    thr_f[2] & ntpc_vld[2] |
			                    thr_f[3] & ntpc_vld[3]);

//   assign fcl_fdp_noswpc_sel_rst_l_bf = 1'b1; 
   assign fcl_fdp_noswpc_sel_tnpc_l_bf = ~ntpc_thisthr;
   assign fcl_fdp_noswpc_sel_old_l_bf = ntpc_thisthr | inst_vld_f | arst_vld_f;
   assign fcl_fdp_noswpc_sel_inc_l_bf = ntpc_thisthr | ~inst_vld_f & ~arst_vld_f;
   
   
   // Don't need noswpc_sel_old anymore (this is always 1)
//   always @(/*AUTOSENSE*/ntpc_vld or reset or thr_f)
//     begin
//	      if (reset)
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b0;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;
//	        end
//	      else if ((ntpc_vld & thr_f) != 4'b0000)
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b0;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;	
//	        end // if ((ntpc_vld & thr_f) != 4'b0000)
////	else if (ely_stall_thisthr_f)
////	  begin
////	     fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
////	     fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
////	     fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
////	     fcl_fdp_noswpc_sel_old_l_bf = 1'b0;	     
////	  end // if (ely_stall_thisthr_f)
//	      else 
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b0;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;	
//	        end // else: 
//	      
//     end // always @ (...

   // NOTE: direct branch vs indirect branch select goes from dtu to fdp

//----------------------------------------------------------------------
// Instruction Register Related Control
//----------------------------------------------------------------------

   // use NIR if no read previously
   assign fcl_fdp_usenir_sel_nir_s1 = usenir_s1;


   assign  fcl_fdp_inst_sel_nop_s_l = ~(ely_stall_thisthr_f | 
                                        ~inst_vld_s_crit | 
                                        force_intr_s | 
                                        immu_fault_f);
   
   assign  fcl_fdp_inst_sel_switch_s_l = ~switch_s2 |
                                        (ely_stall_thisthr_f | 
                                         ~inst_vld_s_crit | 
                                         force_intr_s | 
                                         immu_fault_f);

   assign  fcl_fdp_inst_sel_nir_s_l = ~usenir_s1 |
                                        (switch_s2 |
                                         ely_stall_thisthr_f | 
                                         ~inst_vld_s_crit | 
                                         force_intr_s | 
                                         immu_fault_f);
   
   assign  fcl_fdp_inst_sel_curr_s_l = (usenir_s1 |
                                        switch_s2 |
                                        ely_stall_thisthr_f | 
                                        ~inst_vld_s_crit | 
                                        force_intr_s | 
                                        immu_fault_f);
   
   
   // Instruction Output Mux
//   always @ (/*AUTOSENSE*/ely_stall_thisthr_f or force_intr_s
//             or immu_fault_f or inst_vld_s_crit or switch_s2
//             or usenir_s1)
//     begin
//	      if (ely_stall_thisthr_f | ~inst_vld_s_crit | force_intr_s | 
//            immu_fault_f) 
//	        begin // stalled or imiss
//	           fcl_fdp_inst_sel_nop_s_l = 1'b0;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else if (switch_s2) 
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b0;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else if (usenir_s1) 
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b0;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b0;
//	        end // else: !if(switch_s2 | stall_s1)
//     end // always @ (...

   // thread IR input muxes
   assign fcl_fdp_tinst_sel_rb_s_l   = ~rb_w2;
   assign fcl_fdp_tinst_sel_ifq_s_l  = rb_w2 | ~ifq_fcl_fill_thr;
   assign fcl_fdp_tinst_sel_curr_s_l = ~val_thr_s1 | rb_w2 | ifq_fcl_fill_thr; 
   assign fcl_fdp_tinst_sel_old_s_l  = val_thr_s1 | rb_w2 | ifq_fcl_fill_thr; 

   // Select rollback instruction
   assign fcl_fdp_rbinst_sel_inste_s = {4{rb2_inst_e | rt2_inst_e}} & 
                                       thr_e;

   // thread NIR input muxes  (2:1 no need to protect)
   assign fcl_fdp_thr_s1_l = ~thr_s1 | {4{stall_s1}};

   // select appropriate NIR
   assign dec_thr_s1_l[0] = ~(thr_s1[0] | rst_tri_en);
   assign dec_thr_s1_l[3:1] = ~(thr_s1[3:1] & {3{~rst_tri_en}});
   
   assign fcl_fdp_nirthr_s1_l = dec_thr_s1_l; 
   

//--------------------
// rdsr data to exu
//--------------------   

   dff_s #(1) pcrsr_ff(.din  (dec_fcl_rdsr_sel_pc_d),
		               .clk  (clk),
		               .q    (rdsr_sel_pc_e),
		               .se   (se), .si(), .so());
   dff_s #(1) thrrsr_ff(.din  (dec_fcl_rdsr_sel_thr_d),
		                .clk  (clk),
		                .q    (rdsr_sel_thr_e),
		                .se   (se), .si(), .so());
   // make sure they are exclusive
   assign fcl_fdp_rdsr_sel_pc_e_l = ~rdsr_sel_pc_e;
   assign fcl_fdp_rdsr_sel_thr_e_l = ~(~rdsr_sel_pc_e & rdsr_sel_thr_e);
   assign fcl_fdp_rdsr_sel_ver_e_l = ~(~rdsr_sel_pc_e & ~rdsr_sel_thr_e);

//--------------------------------------------------------------
// Reg file control
//--------------------------------------------------------------

// Some decode is done here since these signals are in the crit path

   // Regfile enables are only power saving features.  So they don't
   // have to be exact, as long as they are on, a super set of when
   // they need to be on.

   // mmckeown: inst_vld_f not high when doing a replay, so we need
   //           to add this condition

   // Enable rs3 if store or atomic or mov
   assign ifu_exu_ren3_s =  (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed))
                            & fdp_fcl_op_s[1] & fdp_fcl_op3_s[2] &
	                         (fdp_fcl_op_s[0] | fdp_fcl_op3_s[5]);

   // enable rs2 if i=0 and !branch or CAS
   // cas not fully decoded;  i=inst[13];
   assign ifu_exu_ren2_s = (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed)) 
                           & fdp_fcl_op_s[1] &
			               (~fdp_fcl_ibit_s | fdp_fcl_op_s[0] & fdp_fcl_op3_s[5]);

   // rs1 is read if this is not (a branch on cc or no-op/sethi)
   assign ifu_exu_ren1_s = (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed)) 
                           & (fdp_fcl_op_s[1] |     // not br/call
			               fdp_fcl_op3_s[4] & fdp_fcl_op3_s[3]);  // BPR

   //-------------------------------------
   // Generate oddwin signal for rs and rd
   //-------------------------------------
   assign fcl_fdp_oddwin_s = (exu_ifu_oddwin_s[0] & thr_f[0] |
                              exu_ifu_oddwin_s[1] & thr_f[1] |
                              exu_ifu_oddwin_s[2] & thr_f[2] |
                              exu_ifu_oddwin_s[3] & thr_f[3]);

   dff_s #(1) oddwin_ff(.din (fcl_fdp_oddwin_s),
		                  .clk (clk),
		                  .q   (fcl_imd_oddwin_d),
		                  .se  (se), .si(), .so());
   

   sink #(2) s0(.in (sas_thrid_w));
endmodule // sparc_ifu_fcl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_fdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_fdp
//  Description:
//    The fdp contains the pc's for all four threads and the PC and
//    nPC for all pipestages register.  The fetcher also contains two
//    adders for doing PC + br_offset and PC + 4.
//    The fdp also holds the last fetched icache data for each thread
//    and the next instruction register, which has the top half of the
//    double instruction bundle which is fetched from the icache.
*/
////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting
















//`define VER_MAXTL      {5'b0, fcl_fdp_hprivmode_e, 2'b10}
//`define VER_IMPL_MASK  24'h002301

//`define VERSION_REG_HPV  {`VER_MANUF, `VER_IMPL_MASK, `VER_MAXGL, 5'b0, fcl_fdp_hprivmode_e, 2'b10, `VER_MAXWIN}

//`define VERSION_REG      {`VER_MANUF, `VER_IMPL_MASK, `VER_MAXGL, 8'h06, `VER_MAXWIN}

//PITON_PROTO enables all FPGA related modifications





module sparc_ifu_fdp(/*AUTOARG*/
   // Outputs
   so, fdp_itlb_ctxt_bf, fdp_icd_vaddr_bf, fdp_icv_index_bf,
   fdp_erb_pc_f, fdp_dtu_inst_s, ifu_exu_pc_d, ifu_exu_rs1_s,
   ifu_exu_rs2_s, ifu_exu_rs3_s, ifu_tlu_pc_m, ifu_tlu_npc_m,
   ifu_tlu_pc_oor_e, ifu_exu_pcver_e, fdp_fcl_swc_s2,
   fdp_fcl_pc_oor_vec_f, fdp_fcl_pc_oor_e, fdp_fcl_op_s,
   fdp_fcl_op3_s, fdp_fcl_ibit_s,
   fdp_esl_t0inst_next_s2,

   fdp_esl_t1inst_next_s2,














   fdp_esl_t0inst_paddr_next_s2,

   fdp_esl_t1inst_paddr_next_s2,














   fdp_esl_t0pc_next_s2,

   fdp_esl_t1pc_next_s2,














   fdp_esl_brtrp_target_pc_bf_f,
   // Inputs
   rclk, se, si, const_maskid, lsu_t0_pctxt_state,
   lsu_t1_pctxt_state, lsu_t2_pctxt_state, lsu_t3_pctxt_state,
   exu_ifu_brpc_e, tlu_ifu_trappc_w2, tlu_ifu_trapnpc_w2,
   tlu_itlb_dmp_nctxt_g, tlu_itlb_dmp_actxt_g, tlu_itlb_tte_tag_w2,
   dtu_fdp_thrconf_e, icd_fdp_fetdata_s1, icd_fdp_topdata_s1,
   ifq_fdp_fill_inst, fcl_fdp_oddwin_s, fcl_fdp_pcoor_vec_f,
   fcl_fdp_pcoor_f, fcl_fdp_mask32b_f, fcl_fdp_addr_mask_d,
   fcl_fdp_tctxt_sel_prim, fcl_fdp_usenir_sel_nir_s1,
   fcl_fdp_rbinst_sel_inste_s, fcl_fdp_thrtnpc_sel_tnpc_l,
   fcl_fdp_thrtnpc_sel_npcw_l, fcl_fdp_thrtnpc_sel_pcf_l,
   fcl_fdp_thrtnpc_sel_old_l, fcl_fdp_thr_s1_l,
   fcl_fdp_next_thr_bf_l, fcl_fdp_next_ctxt_bf_l, fcl_fdp_thr_s2_l,
   fcl_fdp_nirthr_s1_l, fcl_fdp_tpcbf_sel_pcp4_bf_l,
   fcl_fdp_tpcbf_sel_brpc_bf_l, fcl_fdp_tpcbf_sel_trap_bf_l,
   fcl_fdp_tpcbf_sel_old_bf_l, fcl_fdp_pcbf_sel_swpc_bf_l,
   fcl_fdp_pcbf_sel_nosw_bf_l, fcl_fdp_pcbf_sel_br_bf_l,
   fcl_fdp_trrbpc_sel_trap_bf_l, fcl_fdp_trrbpc_sel_rb_bf_l,
   fcl_fdp_trrbpc_sel_err_bf_l, fcl_fdp_trrbpc_sel_pcs_bf_l,
   fcl_fdp_noswpc_sel_tnpc_l_bf, fcl_fdp_noswpc_sel_old_l_bf,
   fcl_fdp_noswpc_sel_inc_l_bf, fcl_fdp_nextpcs_sel_pce_f_l,
   fcl_fdp_nextpcs_sel_pcd_f_l, fcl_fdp_nextpcs_sel_pcs_f_l,
   fcl_fdp_nextpcs_sel_pcf_f_l, fcl_fdp_rdsr_sel_pc_e_l,
   fcl_fdp_rdsr_sel_ver_e_l, fcl_fdp_rdsr_sel_thr_e_l,
   fcl_fdp_inst_sel_curr_s_l, fcl_fdp_inst_sel_switch_s_l,
   fcl_fdp_inst_sel_nir_s_l, fcl_fdp_inst_sel_nop_s_l,
   fcl_fdp_tinst_sel_curr_s_l, fcl_fdp_tinst_sel_rb_s_l,
   fcl_fdp_tinst_sel_old_s_l, fcl_fdp_tinst_sel_ifq_s_l,
   fcl_fdp_dmpthr_l, fcl_fdp_ctxt_sel_dmp_bf_l,
   fcl_fdp_ctxt_sel_sw_bf_l, fcl_fdp_ctxt_sel_curr_bf_l,
   itlb_fdp_paddr_s, fcl_fdp_tlbmiss_s1, ifq_fdp_fill_paddr,
   config_dtu_esl_en, esl_fdp_sync_pcs_bf, esl_fdp_issue_prev_inst_s,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data,

   fdp_fcl_jtag_breakpoint_hit
   );

   input       rclk,
	             se,
	             si;

   input [7:0] const_maskid;

   input [12:0] lsu_t0_pctxt_state,   // primary context
		            lsu_t1_pctxt_state,
		            lsu_t2_pctxt_state,
		            lsu_t3_pctxt_state;

   //   input 	 exu_ifu_va_oor_e;
   input [47:0] exu_ifu_brpc_e;        // br address for dir branch

   input [48:0] tlu_ifu_trappc_w2,     // trap/exception PC
		            tlu_ifu_trapnpc_w2;    // next trap PC

   input        tlu_itlb_dmp_nctxt_g,
		            tlu_itlb_dmp_actxt_g;

   input [12:0] tlu_itlb_tte_tag_w2;

//   input [`IC_IDX_HI:4] ifq_fdp_icindex_bf;   // index + 1 bit for 16B write

   input [40:0]         dtu_fdp_thrconf_e;

   input [32:0]         icd_fdp_fetdata_s1,    // 4 inst + 4 sw bits
		                    icd_fdp_topdata_s1;    // next instruction

   input [32:0]         ifq_fdp_fill_inst;    // icache miss return

   input                fcl_fdp_oddwin_s;
   input [3:0]          fcl_fdp_pcoor_vec_f;
   input                fcl_fdp_pcoor_f;
   input                fcl_fdp_mask32b_f;
   input                fcl_fdp_addr_mask_d;
   input [3:0]          fcl_fdp_tctxt_sel_prim;

   // 2:1 mux selects
   input                fcl_fdp_usenir_sel_nir_s1;   // same as usenir_d2
   input [3:0]          fcl_fdp_rbinst_sel_inste_s;  // rollback 1 or 2

   input [3:0]          fcl_fdp_thrtnpc_sel_tnpc_l,  // load npc
	                      fcl_fdp_thrtnpc_sel_npcw_l,
		                    fcl_fdp_thrtnpc_sel_pcf_l,
	                      fcl_fdp_thrtnpc_sel_old_l;

   input [3:0]          fcl_fdp_thr_s1_l;            // s2 thr (64*5 muxes)

   // other mux selects
   input [3:0]          fcl_fdp_next_thr_bf_l;  // for thrpc output mux
   input [3:0]          fcl_fdp_next_ctxt_bf_l; // for ctxt output mux

   input [3:0]          fcl_fdp_thr_s2_l;       // s2 thr (64*5 muxes)
   input [3:0]          fcl_fdp_nirthr_s1_l;        // same as thr_s1, but protected

   input [3:0]          fcl_fdp_tpcbf_sel_pcp4_bf_l, // selects for thread PC muxes
	                      fcl_fdp_tpcbf_sel_brpc_bf_l,
	                      fcl_fdp_tpcbf_sel_trap_bf_l,
	                      fcl_fdp_tpcbf_sel_old_bf_l;

   input                fcl_fdp_pcbf_sel_swpc_bf_l,
	                      fcl_fdp_pcbf_sel_nosw_bf_l,
	                      fcl_fdp_pcbf_sel_br_bf_l;

   input [3:0]          fcl_fdp_trrbpc_sel_trap_bf_l,
	                      fcl_fdp_trrbpc_sel_rb_bf_l,
	                      fcl_fdp_trrbpc_sel_err_bf_l,
	                      fcl_fdp_trrbpc_sel_pcs_bf_l;

   input                fcl_fdp_noswpc_sel_tnpc_l_bf,    // next pc select from trap,
	                      fcl_fdp_noswpc_sel_old_l_bf,
	                      fcl_fdp_noswpc_sel_inc_l_bf;

   input [3:0]          fcl_fdp_nextpcs_sel_pce_f_l,
	                      fcl_fdp_nextpcs_sel_pcd_f_l,
	                      fcl_fdp_nextpcs_sel_pcs_f_l,
	                      fcl_fdp_nextpcs_sel_pcf_f_l;

   input                fcl_fdp_rdsr_sel_pc_e_l,
	                      fcl_fdp_rdsr_sel_ver_e_l,
	                      fcl_fdp_rdsr_sel_thr_e_l;

   input                fcl_fdp_inst_sel_curr_s_l,       // selects for inst_s2
	                      fcl_fdp_inst_sel_switch_s_l,
	                      fcl_fdp_inst_sel_nir_s_l,
	                      fcl_fdp_inst_sel_nop_s_l;

   input [3:0]          fcl_fdp_tinst_sel_curr_s_l, // selects for tinst regs
	                      fcl_fdp_tinst_sel_rb_s_l,
	                      fcl_fdp_tinst_sel_old_s_l,
	                      fcl_fdp_tinst_sel_ifq_s_l;

   input [3:0]          fcl_fdp_dmpthr_l;

   input                fcl_fdp_ctxt_sel_dmp_bf_l,
	                      fcl_fdp_ctxt_sel_sw_bf_l,
	                      fcl_fdp_ctxt_sel_curr_bf_l;

   input [39:10]        itlb_fdp_paddr_s;
   input                fcl_fdp_tlbmiss_s1;
   input [39:2]         ifq_fdp_fill_paddr;

   input                config_dtu_esl_en;
   input                esl_fdp_issue_prev_inst_s;
   input                esl_fdp_sync_pcs_bf;

   // jtag
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

   output wire fdp_fcl_jtag_breakpoint_hit;

   output               so;
   output [12:0]        fdp_itlb_ctxt_bf;
   output [47:2]        fdp_icd_vaddr_bf;   // 11:2 is index to ic
   output [(6 + 5):5]        fdp_icv_index_bf;
   output [47:0]        fdp_erb_pc_f;
   output [31:0]        fdp_dtu_inst_s;     // 32b inst + switch bit

   output [47:0]        ifu_exu_pc_d;       // PC for rel branch
   output [4:0]         ifu_exu_rs1_s,      // reg file read address
		                    ifu_exu_rs2_s,
		                    ifu_exu_rs3_s;

   output [48:0]        ifu_tlu_pc_m,
		                    ifu_tlu_npc_m;

   output               ifu_tlu_pc_oor_e;

   output [63:0]        ifu_exu_pcver_e;    // PCs to different dests.

   output               fdp_fcl_swc_s2;       // tells whether to switch or not
   output [3:0]         fdp_fcl_pc_oor_vec_f; // PC va hole check
   output               fdp_fcl_pc_oor_e;

   output [1:0]         fdp_fcl_op_s;
   output [5:2]         fdp_fcl_op3_s;
   output               fdp_fcl_ibit_s;

   output [32:0]        fdp_esl_t0inst_next_s2;

   output [32:0]        fdp_esl_t1inst_next_s2;















   output [39:2]        fdp_esl_t0inst_paddr_next_s2;

   output [39:2]        fdp_esl_t1inst_paddr_next_s2;















   output [48:0]        fdp_esl_t0pc_next_s2;

   output [48:0]        fdp_esl_t1pc_next_s2;















   output [3:0]         fdp_esl_brtrp_target_pc_bf_f;

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------

   // local signals

   // Contexts
   wire [12:0] 	curr_ctxt,
		            sw_ctxt,
		            dmp_ctxt,
		            dmp_ctxt_unq,
		            dmp_ctxt1,
		            dmp_ctxt2,
		            t0_ctxt_bf,
		            t1_ctxt_bf,
		            t2_ctxt_bf,
		            t3_ctxt_bf;

   // PCs
   // wire [48:0]  t0pc_f, t1pc_f, t2pc_f, t3pc_f,         // F stage thread PC
   reg  [48:0]  t0pc_f, t1pc_f, t2pc_f, t3pc_f;         // F stage thread PC
		            // t0pc_s, t1pc_s, t2pc_s, t3pc_s,         // S stage thr pc
   wire [48:0]    t0pc_s, t1pc_s, t2pc_s, t3pc_s,         // S stage thr pc
		            t0_next_pcs_f, t1_next_pcs_f, t2_next_pcs_f, t3_next_pcs_f,
                    t1_next_pcs_bf_execdraft_f, t2_next_pcs_bf_execdraft_f,
                    t3_next_pcs_bf_execdraft_f,
		            t0npc_bf, t1npc_bf, t2npc_bf, t3npc_bf, // Next PC in
							                                          // BF stage
                    t1npc_bf_execdraft_bf,
                    t2npc_bf_execdraft_bf,
                    t3npc_bf_execdraft_bf,
		            pc_s, pc_d, pc_e, pc_m, pc_w,
		            npc_s, npc_d, npc_e, npc_m, npc_w,
		            pc_d_adj, npc_d_adj;

   wire [47:0]  pc_bf,
		            swpc_bf,                // PC of next thread if not branch
                pc_f;

   wire [48:0]  nextpc_nosw_bf,         // next pc if no switch
		            am_mask;

   // trap PCs and rollback PCs
   wire [48:0]  t0_trap_rb_pc_bf,
		            t1_trap_rb_pc_bf,
		            t2_trap_rb_pc_bf,
		            t3_trap_rb_pc_bf;

   wire [48:0]  thr_trappc_bf,
		            t0_trapnpc_f,
		            t1_trapnpc_f,
		            t2_trapnpc_f,
		            t3_trapnpc_f,
		            trapnpc0_bf,
		            trapnpc1_bf,
		            trapnpc2_bf,
		            trapnpc3_bf;

   // Branch PCs
   wire [48:0]  pcinc_f;                // incr output
   wire [9:2]   pcinc_s;                // Piped forward incremented PC

   // Instruction Words
   wire [32:0]  inst_s2,                // instruction to switch to in S
                    fdp_inst_bf_execdraft_s,
		            fdp_inst_s,             // instruction to be sent to D
                    fdp_inst_s_prev,
		            t0inst_s1,              // input to thr inst reg in S
		            t1inst_s1,
		            t2inst_s1,
		            t3inst_s1,
		            t0inst_s2,              // thr inst reg output
		            t1inst_s2,
		            t2inst_s2,
		            t3inst_s2;

   // Instruction words paddr
   wire [39:2]  inst_paddr_s2,
                fdp_inst_paddr_s,
                t0inst_paddr_s1,
                t1inst_paddr_s1,
                t2inst_paddr_s1,
                t3inst_paddr_s1,
                t0inst_paddr_s2,
                t1inst_paddr_s2,
                t2inst_paddr_s2,
                t3inst_paddr_s2;

   wire [32:0]  inst_s1;                // fetched instruction in S
   wire [32:0]  inst_s1_bf1;            // buf version of inst_s1

   wire [9:2]   pc_offset_s;            // Pipe forwarded version of pc_f
   wire [39:2]  fetpaddr_s1;            // The physical address of fetched instruction
   wire [39:2]  inst_paddr_s1;          // fetched instruction in S paddr
   wire [39:2]  inst_paddr_s1_bf1;      // buf version of inst_paddr_s1

   wire [32:0]  rb_inst0_s,             // instruction to rollback to
		            rb_inst1_s,             // instruction to rollback to
		            rb_inst2_s,             // instruction to rollback to
		            rb_inst3_s,             // instruction to rollback to
		            inst_d,                 //   rollback 1
		            inst_e;                 //   rollback 2

   // Rollback instructions paddr
   wire [39:2]  rb_inst0_paddr_s,
                rb_inst1_paddr_s,
                rb_inst2_paddr_s,
                rb_inst3_paddr_s,
                inst_paddr_d,
                inst_paddr_e;


   // Next instruction word
   wire [32:0]  nirdata_s1,             // next inst reg contents
		            t0nir,                  // thread NIR reg output
		            t1nir,
		            t2nir,
		            t3nir;

   // NIR physical addresses
   wire [39:2]  toppaddr_s1,
                nirpaddr_s1,
                t0nir_paddr,
                t1nir_paddr,
                t2nir_paddr,
                t3nir_paddr;

   wire         clk;


   //
   // Code start here
   //
   assign       clk = rclk;

//----------------------------------------------------------------------
// Context Reg
//----------------------------------------------------------------------
   assign t0_ctxt_bf = lsu_t0_pctxt_state & {13{fcl_fdp_tctxt_sel_prim[0]}};

 // Use two threads unless this is defined

   assign t1_ctxt_bf = lsu_t1_pctxt_state & {13{fcl_fdp_tctxt_sel_prim[1]}};

   dp_mux2ds #(13) sw_ctxt_mux(.dout (sw_ctxt),
                   .in0  (t0_ctxt_bf),
                   .in1  (t1_ctxt_bf),
                   .sel0_l (fcl_fdp_next_ctxt_bf_l[0]),
                   .sel1_l (fcl_fdp_next_ctxt_bf_l[1]));

   dp_mux2ds #(13) curr_ctxt_mux(.dout (curr_ctxt),
                 .in0  (t0_ctxt_bf),
                 .in1  (t1_ctxt_bf),
                 .sel0_l (fcl_fdp_thr_s2_l[0]),
                 .sel1_l (fcl_fdp_thr_s2_l[1]));

   dp_mux2ds #(13) dmp_ctxt_mux(.dout (dmp_ctxt_unq),
                  .in0  (lsu_t0_pctxt_state),
                  .in1  (lsu_t1_pctxt_state),
                  .sel0_l (fcl_fdp_dmpthr_l[0]),
                  .sel1_l (fcl_fdp_dmpthr_l[1]));







































































































 // `ifndef CONFIG_NUM_THREADS

   assign dmp_ctxt1 = dmp_ctxt_unq & {13{~(tlu_itlb_dmp_nctxt_g |
					                                 tlu_itlb_dmp_actxt_g)}};
//`ifdef SPARC_HPV_EN
   assign dmp_ctxt2 = {tlu_itlb_tte_tag_w2[12:7],tlu_itlb_tte_tag_w2[6:0]} &
	                    {13{tlu_itlb_dmp_actxt_g}};
//`else
//  assign dmp_ctxt2 = {tlu_itlb_tte_tag_w2[13:8],tlu_itlb_tte_tag_w2[6:0]} &
//	                    {13{tlu_itlb_dmp_actxt_g}};
//`endif

   assign dmp_ctxt = dmp_ctxt1 | dmp_ctxt2;

   dp_mux3ds #(13) ctxt_mux (.dout (fdp_itlb_ctxt_bf),
			                     .in0  (curr_ctxt),
			                     .in1  (sw_ctxt),
			                     .in2  (dmp_ctxt),
			                     .sel0_l  (fcl_fdp_ctxt_sel_curr_bf_l),
			                     .sel1_l  (fcl_fdp_ctxt_sel_sw_bf_l),
			                     .sel2_l  (fcl_fdp_ctxt_sel_dmp_bf_l));


// ----------------------------------------------------------------------
// PC datapath
// ----------------------------------------------------------------------

   // pc/thr to exu for rdsr instruction
   // this is the only 64 bit cell in the IFU
   dp_mux3ds #(64) ver_mux(.dout (ifu_exu_pcver_e[63:0]),
			                   .in0  ({{16{pc_e[47]}}, pc_e[47:0]}),
			                   .in1  ({16'h003e,
                                 16'h0023,
                                 const_maskid[7:0],
                                 8'h03,
                                 8'h06,
                                 8'h07}),
			                   .in2  ({12'b0,
                                 dtu_fdp_thrconf_e[40:29],
                                 4'b0,
                                 dtu_fdp_thrconf_e[28:9],
                                 2'b0,
                                 dtu_fdp_thrconf_e[8:3],
                                 5'b0,
                                 dtu_fdp_thrconf_e[2:0]}),
			                   .sel0_l  (fcl_fdp_rdsr_sel_pc_e_l),
			                   .sel1_l  (fcl_fdp_rdsr_sel_ver_e_l),
			                   .sel2_l  (fcl_fdp_rdsr_sel_thr_e_l));

    // mmckeown: track if there is a branch
    // target PC in the F stage for ExecD
    reg [3:0] brtrp_target_pc_bf, brtrp_target_pc_f;
    reg [3:0]          rtap_ifu_pc_wr_en; // moved from below
    assign fdp_esl_brtrp_target_pc_bf_f = brtrp_target_pc_bf | brtrp_target_pc_f;

   // Select the next thread pc (for F stage)
   dp_mux4ds #(49) t0_pcbf_mux(.dout (t0npc_bf),
			                       .in0 ({fcl_fdp_pcoor_vec_f[0], t0pc_f[47:0]}),
			                       .in1 (nextpc_nosw_bf),
			                       .in2 (t0_trap_rb_pc_bf),
			                       .in3 ({1'b0, exu_ifu_brpc_e}),
			                       .sel0_l (fcl_fdp_tpcbf_sel_old_bf_l[0]),
			                       .sel1_l (fcl_fdp_tpcbf_sel_pcp4_bf_l[0]),
			                       .sel2_l (fcl_fdp_tpcbf_sel_trap_bf_l[0]),
			                       .sel3_l (fcl_fdp_tpcbf_sel_brpc_bf_l[0]));

    always @ *
    begin
        if (~fcl_fdp_tpcbf_sel_brpc_bf_l[0] | ~fcl_fdp_tpcbf_sel_trap_bf_l[0])
            brtrp_target_pc_bf[0] = 1'b1;
        else if (~fcl_fdp_tpcbf_sel_old_bf_l[0])
            brtrp_target_pc_bf[0] = brtrp_target_pc_f[0];
        else
            brtrp_target_pc_bf[0] = 1'b0;
    end
    always @ (posedge rclk)
    begin
        if (rtap_ifu_pc_wr_en[0])
            brtrp_target_pc_f[0] <= 1'b1;
        else
            brtrp_target_pc_f[0] <= brtrp_target_pc_bf[0];
    end
   

 // Use two threads unless this is defined

   // mmckeown: adding an extra mux here to synchronize leader and follower pcs
   wire exec_draft_pcf_sync_mux_sel = config_dtu_esl_en ? esl_fdp_sync_pcs_bf : 1'b0;
   dp_mux2es  #(49)  exec_draft_pcf_sync_mux1 (.dout (t1npc_bf),
                                               .in0 (t1npc_bf_execdraft_bf),
                                               .in1 (t0pc_f),
                                               .sel (exec_draft_pcf_sync_mux_sel));

   dp_mux4ds #(49) t1_pcbf_mux(.dout (t1npc_bf_execdraft_bf),
                                   .in0 ({fcl_fdp_pcoor_vec_f[1], t1pc_f[47:0]}),
                                   .in1 (nextpc_nosw_bf),
                                   .in2 (t1_trap_rb_pc_bf),
                                   .in3 ({1'b0, exu_ifu_brpc_e}),
                                   .sel0_l (fcl_fdp_tpcbf_sel_old_bf_l[1]),
                                   .sel1_l (fcl_fdp_tpcbf_sel_pcp4_bf_l[1]),
                                   .sel2_l (fcl_fdp_tpcbf_sel_trap_bf_l[1]),
                                   .sel3_l (fcl_fdp_tpcbf_sel_brpc_bf_l[1]));   
    
    always @ *
    begin
        if (~fcl_fdp_tpcbf_sel_brpc_bf_l[1] | ~fcl_fdp_tpcbf_sel_trap_bf_l[1])
            brtrp_target_pc_bf[1] = 1'b1;
        else if (~fcl_fdp_tpcbf_sel_old_bf_l[1])
            brtrp_target_pc_bf[1] = brtrp_target_pc_f[1];
        else
            brtrp_target_pc_bf[1] = 1'b0;
    end
    always @ (posedge rclk)
    begin
        if (rtap_ifu_pc_wr_en[1])
            brtrp_target_pc_f[1] <= 1'b1;
        else
            brtrp_target_pc_f[1] <= brtrp_target_pc_bf[1];
    end



















































































































































































































 // `ifndef CONFIG_NUM_THREADS

   // // F stage thread PC regs;  use low power thr flop
   // dff_s  #(49)  t0_pcf_reg(.din (t0npc_bf),
			//                   .clk (clk),
			//                   .q   (t0pc_f),
			//                   .se  (se), .si(), .so());

  // trin: modified t0pc_f for jtag overwrites

// reg [3:0]          rtap_ifu_pc_wr_en; mmckeown: moved this up as it is used
// above
reg [47:0]         rtap_ifu_pc_data;
always @ *
begin
  rtap_ifu_pc_wr_en = 0;
  if (rtap_core_val && rtap_core_id == 4'd3)
  begin
     if (rtap_core_threadid == 2'd0)
        rtap_ifu_pc_wr_en = 4'b0001;
     else if (rtap_core_threadid == 2'd1)
        rtap_ifu_pc_wr_en = 4'b0010;
     else if (rtap_core_threadid == 2'd2)
        rtap_ifu_pc_wr_en = 4'b0100;
     else if (rtap_core_threadid == 2'd3)
        rtap_ifu_pc_wr_en = 4'b1000;
  end
  rtap_ifu_pc_data = rtap_core_data[47:0];
end

  always @ (posedge clk)
  begin
    if (rtap_ifu_pc_wr_en[0])
      t0pc_f <= rtap_ifu_pc_data;
    else
      t0pc_f <= t0npc_bf;
  end


 // Use two threads unless this is defined

   // dff_s  #(49)  t1_pcf_reg(.din (t1npc_bf),
   //                            .clk (clk),
   //                            .q   (t1pc_f),
   //                            .se  (se), .si(), .so());

  always @ (posedge clk)
  begin
    if (rtap_ifu_pc_wr_en[1])
      t1pc_f <= rtap_ifu_pc_data;
    else
      t1pc_f <= t1npc_bf;
  end

   assign fdp_fcl_pc_oor_vec_f = {2'b0, t1pc_f[48], t0pc_f[48]};

   // select the pc to be used on a switch -- need to protect
   dp_mux2ds #(48) swpc_mux(.dout (swpc_bf),
                                .in0 (t0pc_f[47:0]),
                                .in1 (t1pc_f[47:0]),
                                .sel0_l (fcl_fdp_next_thr_bf_l[0]),
                                .sel1_l (fcl_fdp_next_thr_bf_l[1]));





























































































































 // `ifndef CONFIG_NUM_THREADS

   // choose between I$ write address and read address
   // need mux only for lower 11 bits (2+3 + ICINDEX_SIZE)
//   dp_mux2es #(48) ifqfdp_mux(.dout (icaddr_nosw_bf[47:0]),
//	     .in0  (nextpc_nosw_bf[47:0]),
//	     .in1  ({{37{1'b0}}, ifq_fdp_icindex_bf, 4'b0}),
//	     .sel  (fcl_fdp_ifqfdp_sel_ifq_bf));  // 1=ifq

   // implements switch and branch
   // can we cut this down to 11 bits? No! tlb needs all 48

//   dp_mux4ds #(48) nxt_icaddr_mux(.dout  (icaddr_bf),
//				                        .in0   (swpc_bf[47:0]),
//				                        .in1   (nextpc_nosw_bf[47:0]),
//				                        .in2   ({8'b0, {`IC_TAG_SZ{1'b0}},
//                                         ifq_fdp_icindex_bf, 4'b0}),
//				                        .in3   (exu_ifu_brpc_e[47:0]),
//				                        .sel0_l (fcl_fdp_icaddr_sel_swpc_bf_l),
//				                        .sel1_l (fcl_fdp_icaddr_sel_curr_bf_l),
//				                        .sel2_l (fcl_fdp_icaddr_sel_ifq_bf_l),
//				                        .sel3_l (fcl_fdp_icaddr_sel_br_bf_l));

//   assign fdp_icd_vaddr_bf = icaddr_bf[47:0];
   // this goes to the itlb, icd and ict on top of fdp
   // this is !!very critical!!
   assign fdp_icd_vaddr_bf = pc_bf[47:2];

   // create separate output for the icv to the left
   assign fdp_icv_index_bf = pc_bf[(6 + 5):5];

   // Place this mux as close to the top (itlb) as possible
   dp_mux3ds #(48) pcbf_mux(.dout  (pc_bf[47:0]),
			  .in0   (swpc_bf[47:0]),
			  .in1   (nextpc_nosw_bf[47:0]),
			  .in2   (exu_ifu_brpc_e[47:0]),
			  .sel0_l (fcl_fdp_pcbf_sel_swpc_bf_l),
			  .sel1_l (fcl_fdp_pcbf_sel_nosw_bf_l),
			  .sel2_l (fcl_fdp_pcbf_sel_br_bf_l));

   dff_s #(48)  pcf_reg(.din  (pc_bf),
		    .clk  (clk),
		    .q    (pc_f),
		    .se   (se), .si(), .so());


// trin: adding basic breakpointing capability on the VA pc
reg [47:0] jtag_breakpoint_pc;

always @ (posedge rclk)
begin
   if (rtap_core_val && rtap_core_id == 4'd7)
   begin
      jtag_breakpoint_pc <= rtap_core_data[47:0];
   end
end


assign fdp_fcl_jtag_breakpoint_hit = (pc_bf[47:0] == jtag_breakpoint_pc[47:0]);

   assign fdp_erb_pc_f = pc_f[47:0];

    // trappc mux (choose trap pc vs rollback/uTrap pc)
   dp_mux4ds #(49) trap_pc0_mux(.dout (t0_trap_rb_pc_bf),
			      .in0  (tlu_ifu_trappc_w2),
			      .in1  (pc_d_adj),
			      .in2  (t0pc_s),
			      .in3  (pc_w),
			      .sel0_l  (fcl_fdp_trrbpc_sel_trap_bf_l[0]),
			      .sel1_l  (fcl_fdp_trrbpc_sel_rb_bf_l[0]),
			      .sel2_l  (fcl_fdp_trrbpc_sel_pcs_bf_l[0]),
			      .sel3_l  (fcl_fdp_trrbpc_sel_err_bf_l[0]));

 // Use two threads unless this is defined

   dp_mux4ds #(49) trap_pc1_mux(.dout (t1_trap_rb_pc_bf),
                  .in0  (tlu_ifu_trappc_w2),
                  .in1  (pc_d_adj),
                  .in2  (t1pc_s),
                  .in3  (pc_w),
                  .sel0_l  (fcl_fdp_trrbpc_sel_trap_bf_l[1]),
                  .sel1_l  (fcl_fdp_trrbpc_sel_rb_bf_l[1]),
                  .sel2_l  (fcl_fdp_trrbpc_sel_pcs_bf_l[1]),
                  .sel3_l  (fcl_fdp_trrbpc_sel_err_bf_l[1]));









































































 // `ifndef CONFIG_NUM_THREADS

   // can reduce this to a 2:1 mux since reset pc is not used any more and
   // pc_f is not needed.
   dp_mux3ds #(49) pcp4_mux(.dout  (nextpc_nosw_bf),
			  .in0   (pcinc_f),
			  .in1   (thr_trappc_bf),
			  .in2   ({fcl_fdp_pcoor_f, pc_f[47:0]}),
			  .sel0_l (fcl_fdp_noswpc_sel_inc_l_bf),
			  .sel1_l (fcl_fdp_noswpc_sel_tnpc_l_bf),
			  .sel2_l (fcl_fdp_noswpc_sel_old_l_bf));


   // next S stage thread pc mux per thread
   // Use advtpcs signal which works for stall (Aug '01)
   // Merged pc_e/pc_d into the eqn to allow for rollback
   dp_mux4ds #(49) t0pcf_mux(.dout (t0_next_pcs_f),
			   .in0  (t0pc_s),
			   .in1  ({fcl_fdp_pcoor_vec_f[0], t0pc_f[47:0]}),
			   .in2  (pc_d_adj),
			   .in3  (pc_e),
			   .sel0_l (fcl_fdp_nextpcs_sel_pcs_f_l[0]),
			   .sel1_l (fcl_fdp_nextpcs_sel_pcf_f_l[0]),
			   .sel2_l (fcl_fdp_nextpcs_sel_pcd_f_l[0]),
			   .sel3_l (fcl_fdp_nextpcs_sel_pce_f_l[0]));

 // Use two threads unless this is defined

   // mmckeown: adding an extra mux here to synchronize leader and follower pcs
   wire exec_draft_pcs_sync_mux_sel = config_dtu_esl_en ? esl_fdp_sync_pcs_bf : 1'b0;
   dp_mux2es  #(49)  exec_draft_pcs_sync_mux1 (.dout (t1_next_pcs_f),
                                               .in0 (t1_next_pcs_bf_execdraft_f),
                                               .in1 (t0pc_s),
                                               .sel (exec_draft_pcs_sync_mux_sel));

   dp_mux4ds #(49) t1pcf_mux(.dout (t1_next_pcs_bf_execdraft_f),
               .in0  (t1pc_s),
               .in1  ({fcl_fdp_pcoor_vec_f[1], t1pc_f[47:0]}),
               .in2  (pc_d_adj),
               .in3  (pc_e),
               .sel0_l (fcl_fdp_nextpcs_sel_pcs_f_l[1]),
               .sel1_l (fcl_fdp_nextpcs_sel_pcf_f_l[1]),
               .sel2_l (fcl_fdp_nextpcs_sel_pcd_f_l[1]),
               .sel3_l (fcl_fdp_nextpcs_sel_pce_f_l[1]));

















































































































 // `ifndef CONFIG_NUM_THREADS

   // S stage thread PC regs;  use low power thr flop
   dff_s  #(49)  t0pcs_reg(.din  (t0_next_pcs_f),
		                   .q    (t0pc_s),
		                   .clk  (clk),  .se(se), .si(), .so());
   assign fdp_esl_t0pc_next_s2 = t0_next_pcs_f;

 // Use two threads unless this is defined

   dff_s  #(49)  t1pcs_reg(.din  (t1_next_pcs_f),
                           .q    (t1pc_s),
                           .clk  (clk),  .se(se), .si(), .so());
   assign fdp_esl_t1pc_next_s2 = t1_next_pcs_bf_execdraft_f;

   // S stage PC mux -- need to protect
   dp_mux2ds #(49) pcs_mux(.dout (pc_s),
             .in0  (t0pc_s),
             .in1  (t1pc_s),
             .sel0_l (fcl_fdp_thr_s2_l[0]),
             .sel1_l (fcl_fdp_thr_s2_l[1]));

   // S stage next PC mux -- need to protect
   dp_mux2ds #(49) npcs_mux(.dout (npc_s),
              .in0  (t0_next_pcs_f),
              .in1  (t1_next_pcs_f),
              .sel0_l (fcl_fdp_thr_s2_l[0]),
              .sel1_l (fcl_fdp_thr_s2_l[1]));



































































































 // `ifndef CONFIG_NUM_THREADS

   // D stage PC and nPC
   dff_s  #(49)  pcd_reg(.din (pc_s),
		                 .q   (pc_d),
		                 .clk (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcd_reg(.din  (npc_s),
		                  .q    (npc_d),
		                  .clk  (clk), .se(se), .si(), .so());

   assign am_mask = {{17{~fcl_fdp_addr_mask_d}}, 32'hffffffff};

   // nand2
   assign pc_d_adj = pc_d & am_mask;
   assign npc_d_adj = npc_d & am_mask;

   assign ifu_exu_pc_d = pc_d_adj[47:0];

   // E stage PC and nPC
   dff_s  #(49)  pce_reg(.din (pc_d_adj),
		                 .q   (pc_e),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s  #(49)  npce_reg(.din  (npc_d_adj),
		                  .q    (npc_e),
		                  .clk (clk), .se(se), .si(), .so());

   assign fdp_fcl_pc_oor_e = pc_e[48];
   assign ifu_tlu_pc_oor_e = pc_e[48];

   // M stage PC and nPC
   dff_s  #(49)  pcm_reg(.din  (pc_e),
		                 .q    (pc_m),
		                 .clk  (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcm_reg(.din (npc_e),
		                  .q   (npc_m),
		                  .clk (clk), .se(se), .si(), .so());
   assign ifu_tlu_pc_m = pc_m[48:0];
   assign ifu_tlu_npc_m = npc_m[48:0];

   // W stage PC and nPC
   dff_s  #(49)  pcw_reg(.din  (pc_m),
		                 .q    (pc_w),
		                 .clk  (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcw_reg(.din (npc_m),
		                  .q   (npc_w),
		                  .clk (clk), .se(se), .si(), .so());

//   assign ifu_tlu_pc_w = pc_w;
//   assign ifu_tlu_npc_w = npc_w;

   // PC incrementer
   // can we fit the ofl logic on the side of the incrementer?
   assign pcinc_f[1:0] = pc_f[1:0];
   sparc_ifu_incr46 pc_inc(.a     (pc_f[47:2]),
			                     .a_inc (pcinc_f[47:2]),
			                     .ofl   ());   // ofl output not needed

//   assign pcinc_f[48] = inc_ofl & ~fcl_fdp_mask32b_f | fcl_fdp_pcoor_f;
   assign pcinc_f[48] = ~pc_f[47] & pcinc_f[47] & ~fcl_fdp_mask32b_f |
                        fcl_fdp_pcoor_f;

   // Enable for thr trapnpc reg
   dp_mux4ds #(49) t0tnpc_mux(.dout (trapnpc0_bf),
			                        .in0  (tlu_ifu_trapnpc_w2),
			                        .in1  (npc_w),
                              .in2  (t0pc_f),
			                        .in3  (t0_trapnpc_f),
			                        .sel0_l  (fcl_fdp_thrtnpc_sel_tnpc_l[0]),
			                        .sel1_l  (fcl_fdp_thrtnpc_sel_npcw_l[0]),
			                        .sel2_l  (fcl_fdp_thrtnpc_sel_pcf_l[0]),
			                        .sel3_l  (fcl_fdp_thrtnpc_sel_old_l[0]));
 // Use two threads unless this is defined

   dp_mux4ds #(49) t1tnpc_mux(.dout (trapnpc1_bf),
                .in0  (tlu_ifu_trapnpc_w2),
                .in1  (npc_w),
          .in2  (t1pc_f),
                .in3  (t1_trapnpc_f),
                .sel0_l  (fcl_fdp_thrtnpc_sel_tnpc_l[1]),
                .sel1_l  (fcl_fdp_thrtnpc_sel_npcw_l[1]),
          .sel2_l  (fcl_fdp_thrtnpc_sel_pcf_l[1]),
                .sel3_l  (fcl_fdp_thrtnpc_sel_old_l[1]));









































































 // `ifndef CONFIG_NUM_THREADS

   // thread next trap pc reg
   dff_s #(49) t0tnpcf_reg(.din  (trapnpc0_bf),
		                   .q    (t0_trapnpc_f),
		                   .clk  (clk),  .se(se), .si(), .so());
 // Use two threads unless this is defined

   dff_s #(49) t1tnpcf_reg(.din  (trapnpc1_bf),
                           .q    (t1_trapnpc_f),
                           .clk  (clk),  .se(se), .si(), .so());

   dp_mux2ds #(49) nxttpc_mux(.dout (thr_trappc_bf),
                .in0  (t0_trapnpc_f),
                .in1  (t1_trapnpc_f),
                .sel0_l (fcl_fdp_thr_s2_l[0]), // thr_s2 = thr_f
                .sel1_l (fcl_fdp_thr_s2_l[1]));





























































 // `ifndef CONFIG_NUM_THREADS

   // During rst nextpc_nosw_bf = PO_RESET_PC.  All thread PC_f registers,
   // the icaddr_f register and the nextpc register should be loaded
   // with nextpc_nosw_bf during reset.
   // Eventually, we will load the reset_pc from the trap logic unit,
   // which will arrive on the trap_pc bus.


   // TBD in PC datapath:
   // 1.  Add useNIR bit to PCs  -- DONE
   // 2.  Add support for ifq request grant -- DONE
   // 3.  Generate icache read signal (from fcl?) -- DONE
   // 4.  Rollback functionality -- DONE
   // 5.  PC range checks -- DONE
   // 6.  Change PC to 48 bit value -- DONE


//----------------------------------------------------------------------
// Fetched Instruction Datapath
//----------------------------------------------------------------------

// This is logically 33 bits wide.  The NIR and IR datapaths are laid
// side by side, making this a 66bit datapath.  The NIR path is
// potentially a little longer.

// mmckeown
// Added datapath for physical address

   // Pipe forward the PC in F
   dff_s #(8) pc_paddr_s_reg(.din (pc_f[9:2]),
                             .q (pc_offset_s[9:2]),
                             .clk (clk), .se(se), .si(), .so());

   // Physical address of fetched instruction. pgnum comes from itlb, the offset
   // comes from the offset in the PC, and the bottom 2 bits are always 0
   assign fetpaddr_s1[39:2] = {itlb_fdp_paddr_s[39:10] & {30{~fcl_fdp_tlbmiss_s1}},
                               pc_offset_s[9:2]};

   // choose between NIR data and fetched data
   dp_mux2es #(33)  usenir_mux(.dout (inst_s1),
			                       .in0  (icd_fdp_fetdata_s1[32:0]),
			                       .in1  (nirdata_s1),
			                       .sel  (fcl_fdp_usenir_sel_nir_s1));  // 1=nir

   dp_mux2es #(38)  usenir_paddr_mux (.dout(inst_paddr_s1[39:2]),
                                      .in0 (fetpaddr_s1[39:2]),
                                      .in1 (nirpaddr_s1[39:2]),
                                      .sel (fcl_fdp_usenir_sel_nir_s1));

   // mmckeown: latch previous issued instruction in case of
   //           replay for execution drafting
   dff_s #(33) fdp_inst_s_prev_reg (.din (fdp_inst_s),
                                    .q (fdp_inst_s_prev),
                                    .clk (clk), .se (se), .si(), .so());

   // mmckeown: adding an extra mux here to be able to execute the
   //           previous instruction for execution drafting
   wire exec_draft_replay_mux_sel = config_dtu_esl_en ? esl_fdp_issue_prev_inst_s : 1'b0;
   dp_mux2es  #(33)  exec_draft_replay_mux (.dout (fdp_inst_s),
                                            .in0 (fdp_inst_bf_execdraft_s),
                                            .in1 (fdp_inst_s_prev),
                                            .sel(exec_draft_replay_mux_sel));
   // Instruction Output Mux
   // CHANGE: now 4:1
   dp_mux4ds  #(33)  instout_mux(.dout (fdp_inst_bf_execdraft_s),
			                         .in0 (icd_fdp_fetdata_s1[32:0]),
			                         .in1 (inst_s2),
			                         .in2 ({32'h01000000, 1'b0}),
			                         .in3 (nirdata_s1[32:0]),
			                         .sel0_l (fcl_fdp_inst_sel_curr_s_l),
			                         .sel1_l (fcl_fdp_inst_sel_switch_s_l),
			                         .sel2_l (fcl_fdp_inst_sel_nop_s_l),
			                         .sel3_l (fcl_fdp_inst_sel_nir_s_l));

   dp_mux4ds  #(38)  instout_paddr_mux (.dout (fdp_inst_paddr_s[39:2]),
                                        .in0 (fetpaddr_s1[39:2]),
                                        .in1 (inst_paddr_s2[39:2]),
                                        .in2 (38'b0),
                                        .in3 (nirpaddr_s1[39:2]),
                                        .sel0_l (fcl_fdp_inst_sel_curr_s_l),
                                        .sel1_l (fcl_fdp_inst_sel_switch_s_l),
                                        .sel2_l (fcl_fdp_inst_sel_nop_s_l),
                                        .sel3_l (fcl_fdp_inst_sel_nir_s_l));

   assign fdp_fcl_swc_s2 = fdp_inst_s[0];

   assign fdp_fcl_op_s = fdp_inst_s[32:31];
   assign fdp_fcl_op3_s = fdp_inst_s[25:22];
   assign fdp_fcl_ibit_s = fdp_inst_s[14];

   assign fdp_dtu_inst_s = fdp_inst_s[32:1];

   // CHANGE: Random logic to fix timing paths
   // output pin on RHS, as close to IRF as possible
   // 16x drivers
   // nand2-xor-invert
   assign ifu_exu_rs1_s[4] = fdp_inst_s[19] ^
			                       (fdp_inst_s[18] & fcl_fdp_oddwin_s);
   assign ifu_exu_rs1_s[3:0] = fdp_inst_s[18:15];

   assign ifu_exu_rs2_s[4] = (fdp_inst_s[5] ^
			                        (fdp_inst_s[4] & fcl_fdp_oddwin_s));
   assign ifu_exu_rs2_s[3:0] = fdp_inst_s[4:1];

   assign ifu_exu_rs3_s[4] = (fdp_inst_s[30] ^
			                        (fdp_inst_s[29] & fcl_fdp_oddwin_s));
   assign ifu_exu_rs3_s[3:0] = fdp_inst_s[29:26];


   dp_buffer #(33) insts1_buf(inst_s1_bf1, inst_s1[32:0]);

   dp_buffer #(38) inst_paddrs1_buf(inst_paddr_s1_bf1[39:2], inst_paddr_s1[39:2]);

   // Thread instruction muxes
   dp_mux4ds #(33)  t0inst_mux(.dout (t0inst_s1),
			     .in0 (ifq_fdp_fill_inst),
			     .in1 (inst_s1_bf1),
			     .in2 (t0inst_s2),
			     .in3 (rb_inst0_s),
			     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[0]),
			     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[0]),
			     .sel2_l (fcl_fdp_tinst_sel_old_s_l[0]),
			     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[0]));

   dp_mux4ds #(38) t0inst_paddr_mux (.dout (t0inst_paddr_s1[39:2]),
                                     .in0 (ifq_fdp_fill_paddr[39:2]),
                                     .in1 (inst_paddr_s1_bf1[39:2]),
                                     .in2 (t0inst_paddr_s2[39:2]),
                                     .in3 (rb_inst0_paddr_s[39:2]),
                                     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[0]),
                                     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[0]),
                                     .sel2_l (fcl_fdp_tinst_sel_old_s_l[0]),
                                     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[0]));

 // Use two threads unless this is defined

   dp_mux4ds #(33)  t1inst_mux(.dout (t1inst_s1),
                 .in0 (ifq_fdp_fill_inst),
                 .in1 (inst_s1_bf1),
                 .in2 (t1inst_s2),
                 .in3 (rb_inst1_s),
                 .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[1]),
                 .sel1_l (fcl_fdp_tinst_sel_curr_s_l[1]),
                 .sel2_l (fcl_fdp_tinst_sel_old_s_l[1]),
                 .sel3_l (fcl_fdp_tinst_sel_rb_s_l[1]));

   dp_mux4ds #(38) t1inst_paddr_mux (.dout (t1inst_paddr_s1[39:2]),
                                     .in0 (ifq_fdp_fill_paddr[39:2]),
                                     .in1 (inst_paddr_s1_bf1[39:2]),
                                     .in2 (t1inst_paddr_s2[39:2]),
                                     .in3 (rb_inst1_paddr_s[39:2]),
                                     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[1]),
                                     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[1]),
                                     .sel2_l (fcl_fdp_tinst_sel_old_s_l[1]),
                                     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[1]));





































































































































 // `ifndef CONFIG_NUM_THREADS

   // Thread Instruction Register
   dff_s #(33) t0_inst_reg(.din  (t0inst_s1),
		                   .q    (t0inst_s2),
		                   .clk  (clk),  .se(se), .si(), .so());
   dff_s #(38) t0_inst_paddr_reg (.din (t0inst_paddr_s1[39:2]),
                                  .q (t0inst_paddr_s2[39:2]),
                                  .clk (clk), .se(se), .si(), .so());
   assign fdp_esl_t0inst_next_s2 = t0inst_s1;
   assign fdp_esl_t0inst_paddr_next_s2 = t0inst_paddr_s1;

 // Use two threads unless this is defined

   dff_s #(33) t1_inst_reg(.din  (t1inst_s1),
                           .q    (t1inst_s2),
                           .clk  (clk),  .se(se), .si(), .so());
   dff_s #(38) t1_inst_paddr_reg (.din (t1inst_paddr_s1),
                                  .q (t1inst_paddr_s2),
                                  .clk (clk), .se(se), .si(), .so());
   assign fdp_esl_t1inst_next_s2 = t1inst_s1;
   assign fdp_esl_t1inst_paddr_next_s2 = t1inst_paddr_s1;

   // switch instruction mux -- choose the instruction to switch to
   // fcl keep track of which t*inst_s2 is valid
   dp_mux2ds  #(33) swinst_mux(.dout (inst_s2),
                 .in0  (t0inst_s2),
                 .in1  (t1inst_s2),
                 .sel0_l (fcl_fdp_thr_s2_l[0]),
                 .sel1_l (fcl_fdp_thr_s2_l[1]));

   dp_mux2ds #(38) swinst_paddr_mux (.dout (inst_paddr_s2),
                                     .in0 (t0inst_paddr_s2),
                                     .in1 (t1inst_paddr_s2),
                                     .sel0_l (fcl_fdp_thr_s2_l[0]),
                                     .sel1_l (fcl_fdp_thr_s2_l[1]));




























































































































 // `ifndef CONFIG_NUM_THREADS

   // Rollback instruction
   dff_s #(33) rbinst_d_reg(.din (fdp_inst_s[32:0]),
			                  .q   (inst_d),
			                  .clk (clk),
			                  .se  (se), .si(), .so());
   dff_s #(38) rbinst_paddr_d_reg (.din (fdp_inst_paddr_s[39:2]),
                                   .q (inst_paddr_d),
                                   .clk (clk),
                                   .se (se), .si(), .so());

   dff_s #(33) rbinst_e_reg(.din (inst_d),
			                  .q   (inst_e),
			                  .clk (clk),
			                  .se  (se), .si(), .so());
   dff_s #(38) rbinst_paddr_e_reg (.din (inst_paddr_d),
                                   .q (inst_paddr_e),
                                   .clk (clk),
                                   .se (se), .si(), .so());

   dp_mux2es #(33) rbinst0_mux(.dout (rb_inst0_s),
			                       .in0  (inst_d),
			                       .in1  (inst_e),
			                       .sel  (fcl_fdp_rbinst_sel_inste_s[0]));
   dp_mux2es #(38) rbinst0_paddr_mux (.dout (rb_inst0_paddr_s),
                                      .in0 (inst_paddr_d),
                                      .in1 (inst_paddr_e),
                                      .sel  (fcl_fdp_rbinst_sel_inste_s[0]));

 // Use two threads unless this is defined

   dp_mux2es #(33) rbinst1_mux(.dout (rb_inst1_s),
                                   .in0  (inst_d),
                                   .in1  (inst_e),
                                   .sel  (fcl_fdp_rbinst_sel_inste_s[1]));
   dp_mux2es #(38) rbinst1_paddr_mux (.dout (rb_inst1_paddr_s),
                                      .in0 (inst_paddr_d),
                                      .in1 (inst_paddr_e),
                                      .sel  (fcl_fdp_rbinst_sel_inste_s[1]));



































































 // `ifndef CONFIG_NUM_THREADS

//----------------------------------------------------------------------
// Next Instruction Datapath
//----------------------------------------------------------------------

   // Thread next instruction muxes
//   dp_mux2es #(33) t0nir_mux(.dout (t0nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t0nir),
//			                     .sel (fcl_fdp_thr_s1_l[0]));  // 0=new
//   dp_mux2es #(33) t1nir_mux(.dout (t1nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t1nir),
//			                     .sel (fcl_fdp_thr_s1_l[1]));
//   dp_mux2es #(33) t2nir_mux(.dout (t2nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t2nir),
//			                     .sel (fcl_fdp_thr_s1_l[2]));
//   dp_mux2es #(33) t3nir_mux(.dout (t3nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t3nir),
//			                     .sel (fcl_fdp_thr_s1_l[3]));

   // mmckeown
   // Added datapath for physical address to NIRs

   // Pipe forward the offset of the incremented PC in F
   // (incremented PC because this is the second instruction
   // fetched)
   dff_s #(8) pcinc_s_reg (.din(pcinc_f[9:2]),
                           .q(pcinc_s[9:2]),
                           .clk(clk), .se(se), .si(), .so());

   // Physical address for NIR. pgnum comes from itlb, the offset
   // comes from the offset in the incremented PC (as this is the instruction
   // following the one that was fetched), and the bottom 2 bits are always 0
   assign toppaddr_s1 = {itlb_fdp_paddr_s[39:10] & {30{~fcl_fdp_tlbmiss_s1}}, pcinc_s[9:2]};

   // Thread Next Instruction Register
   wire   clk_nir0;



   bw_u1_ckenbuf_6x  ckennir0(.rclk (rclk),
                              .clk  (clk_nir0),
                              .en_l (fcl_fdp_thr_s1_l[0]),
                              .tm_l (~se));










   dff_s #(33) t0nir_reg(.din  (icd_fdp_topdata_s1[32:0]),
		                   .q    (t0nir),
		                   .clk  (clk_nir0), .se(se), .si(), .so());
   dff_s #(38) t0nir_paddr_reg (.din (toppaddr_s1[39:2]),
                                .q (t0nir_paddr[39:2]),
                                .clk (clk_nir0), .se(se), .si(), .so ());


 // Use two threads unless this is defined

   wire   clk_nir1;



   bw_u1_ckenbuf_6x  ckennir1(.rclk (rclk),
                              .clk  (clk_nir1),
                              .en_l (fcl_fdp_thr_s1_l[1]),
                              .tm_l (~se));









   dff_s #(33) t1nir_reg(.din  (icd_fdp_topdata_s1[32:0]),
                           .q    (t1nir),
                           .clk  (clk_nir1), .se(se), .si(), .so());
   dff_s #(38) t1nir_paddr_reg (.din (toppaddr_s1[39:2]),
                                .q (t1nir_paddr[39:2]),
                                .clk (clk_nir1), .se(se), .si(), .so());


   // Next thread NIR mux  (nir output mux)
   dp_mux2ds  #(33) nextnir_mux(.dout (nirdata_s1),
                                  .in0 (t0nir),
                              .in1 (t1nir),
                                  .sel0_l (fcl_fdp_nirthr_s1_l[0]),
                                  .sel1_l (fcl_fdp_nirthr_s1_l[1]));

   dp_mux2ds  #(38) nextnir_paddr_mux (.dout (nirpaddr_s1),
                                       .in0 (t0nir_paddr),
                                       .in1 (t1nir_paddr),
                                       .sel0_l (fcl_fdp_nirthr_s1_l[0]),
                                       .sel1_l (fcl_fdp_nirthr_s1_l[1]));


























































































































































































































 // `ifndef CONFIG_NUM_THREADS

   // TBD in fetched instruction DP:
   // 1. Rollback -- DONE
   // 2. Icache parity check (increase fet data and top data to 34 bits)

endmodule // sparc_ifu_fdp

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_wseldp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_wsel
//  Description:	
//     Way selects removed from icache and done here 
*/

module sparc_ifu_wseldp (/*AUTOARG*/
   // Outputs
   wsel_fdp_fetdata_s1, wsel_fdp_topdata_s1, wsel_mbist_icache_data, 
   so, 
   // Inputs
   rclk, se, si, icd_wsel_fetdata_s1, icd_wsel_topdata_s1, 
   itlb_wsel_waysel_s1, ifq_erb_asiway_f
   );

   input          rclk, 
                  se,
                  si;

   input  [135:0] icd_wsel_fetdata_s1,
                  icd_wsel_topdata_s1;

   input [3:0]    itlb_wsel_waysel_s1;
   input [1:0]    ifq_erb_asiway_f;

   output [33:0]  wsel_fdp_fetdata_s1;
   output [33:0]  wsel_fdp_topdata_s1;

   output [67:0]  wsel_mbist_icache_data;

   output         so;
   
   // local signals
   wire [3:0]     dec_asiway_s_l,
                  waysel_buf_s1;
   wire [1:0]     asiway_s;
   
   wire [33:0]    rdc_fetdata_s1,
                  rdc_topdata_s1,
                  erb_asidata_s,                  
                  asi_topdata_s;
   wire           clk;
   
   //
   // Code begins here
   //
   //------------------
   // Control Portion
   //------------------

   assign   clk = rclk;
   
   // flop and decode waysel
   dff_s #(2) asiway_reg(.din (ifq_erb_asiway_f),
                       .q   (asiway_s),
                       .clk (clk), .se(se), .si(), .so());
   assign   dec_asiway_s_l[0] = ~(~asiway_s[1] & ~asiway_s[0]);
   assign   dec_asiway_s_l[1] = ~(~asiway_s[1] &  asiway_s[0]);
   assign   dec_asiway_s_l[2] = ~( asiway_s[1] & ~asiway_s[0]);
   assign   dec_asiway_s_l[3] = ~( asiway_s[1] &  asiway_s[0]);

   //--------------------------
   // Datapath Section
   //--------------------------

   // buffer wayselect from itlb
   // align these buffers with the corresponding pins in itlb
   assign   waysel_buf_s1 = itlb_wsel_waysel_s1;

   // Very Timing Critical Wayselect Muxes
   // !!Cannot be a one-hot mux!!
   // use ao2222
//   bw_u1_ao2222_2x #(34) fetway_mx(.z   (rdc_fetdata_s1[33:0]),
//                                   .a2  (icd_wsel_fetdata_s1[33:0]),
//                                   .b2  (icd_wsel_fetdata_s1[67:34]),
//                                   .c2  (icd_wsel_fetdata_s1[101:68]),
//                                   .d2  (icd_wsel_fetdata_s1[135:102]),
//                                   .a1  (waysel_buf_s1[0]),
//                                   .b1  (waysel_buf_s1[1]),
//                                   .c1  (waysel_buf_s1[2]),
//                                   .d1  (waysel_buf_s1[3]));

//   bw_u1_ao2222_2x #(34) topway_mx(.z   (rdc_topdata_s1[33:0]),
//                                   .a2  (icd_wsel_topdata_s1[33:0]),
//                                   .b2  (icd_wsel_topdata_s1[67:34]),
//                                   .c2  (icd_wsel_topdata_s1[101:68]),
//                                   .d2  (icd_wsel_topdata_s1[135:102]),
//                                   .a1  (waysel_buf_s1[0]),
//                                   .b1  (waysel_buf_s1[1]),
//                                   .c1  (waysel_buf_s1[2]),
//                                   .d1  (waysel_buf_s1[3]));

   assign rdc_fetdata_s1 = icd_wsel_fetdata_s1[33:0] & {34{waysel_buf_s1[0]}} |
                         icd_wsel_fetdata_s1[67:34] & {34{waysel_buf_s1[1]}}  |
                         icd_wsel_fetdata_s1[101:68] & {34{waysel_buf_s1[2]}} |
                         icd_wsel_fetdata_s1[135:102] & {34{waysel_buf_s1[3]}};
   
   assign rdc_topdata_s1 = icd_wsel_topdata_s1[33:0] & {34{waysel_buf_s1[0]}} |
                         icd_wsel_topdata_s1[67:34] & {34{waysel_buf_s1[1]}}  |
                         icd_wsel_topdata_s1[101:68] & {34{waysel_buf_s1[2]}} |
                         icd_wsel_topdata_s1[135:102] & {34{waysel_buf_s1[3]}};

   // buffer and send to fdp
   assign   wsel_fdp_fetdata_s1 = rdc_fetdata_s1;
   assign   wsel_fdp_topdata_s1 = rdc_topdata_s1;
   
   // mux for asi data, not critical
   dp_mux4ds #(34) asid_mx(.dout (erb_asidata_s[33:0]),
                           .in0  (icd_wsel_fetdata_s1[33:0]),
                           .in1  (icd_wsel_fetdata_s1[67:34]),
                           .in2  (icd_wsel_fetdata_s1[101:68]),
                           .in3  (icd_wsel_fetdata_s1[135:102]),
                           .sel0_l (dec_asiway_s_l[0]),
                           .sel1_l (dec_asiway_s_l[1]),
                           .sel2_l (dec_asiway_s_l[2]),
                           .sel3_l (dec_asiway_s_l[3]));

   dp_mux4ds #(34) asitop_mx(.dout (asi_topdata_s[33:0]),
                           .in0  (icd_wsel_topdata_s1[33:0]),
                           .in1  (icd_wsel_topdata_s1[67:34]),
                           .in2  (icd_wsel_topdata_s1[101:68]),
                           .in3  (icd_wsel_topdata_s1[135:102]),
                           .sel0_l (dec_asiway_s_l[0]),
                           .sel1_l (dec_asiway_s_l[1]),
                           .sel2_l (dec_asiway_s_l[2]),
                           .sel3_l (dec_asiway_s_l[3]));

   // buffer before sending to bist/errdp
   assign wsel_mbist_icache_data = {asi_topdata_s[33:32], 
                                    erb_asidata_s[33:32], 
                                    asi_topdata_s[31:0],
                                    erb_asidata_s[31:0]};

// Everything below can be ignored for physical implementation
// monitor for waysel -- moved here from itlb
// Keeping this around for 0-in. cmp level check is in icache_mutex_mon.v

















 
endmodule // sparc_ifu_wseldp

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_sscan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// trin (10/11/14):
// I'm rewriting this so data doesn't have to be shifted out
//  bit by bit

// module sparc_ifu_sscan( ctu_sscan_snap, ctu_sscan_se, lsu_sscan_test_data, 
// tlu_sscan_test_data, swl_sscan_thrstate, ifq_sscan_test_data, sparc_sscan_so, rclk, si, so, se);

// input ctu_sscan_snap;
// // input ctu_sscan_se;
// // input ctu_tck;
// // input si;
// // input se;
// input [10:0] swl_sscan_thrstate;
// input [3:0] ifq_sscan_test_data;
// input [15:0] lsu_sscan_test_data;
// input [62:0] tlu_sscan_test_data;
// input rclk;

// // output sparc_sscan_so;
// // output so;
// output 

//////////////////////////////////////////////////////////////////

// wire snap_f;
// wire [93:0] snap_data, snap_data_f, snap_data_ff;

// `ifdef CONNECT_SHADOW_SCAN
// wire [92:0] sscan_shift_data;
// `endif

////////

// dff_s #(1) snap_inst0(.q(snap_f), .din(ctu_sscan_snap), .clk(rclk), .se(se), .si(), .so());

// assign snap_data = {ifq_sscan_test_data, tlu_sscan_test_data, lsu_sscan_test_data, swl_sscan_thrstate};

// dffe_s #(94) snap_inst1(.q(snap_data_f), .din(snap_data), .clk(rclk), .en(snap_f), .se(se), .si(), .so());

// `ifdef CONNECT_SHADOW_SCAN
// dff_sscan #(94) snap_inst2(.q(snap_data_ff), .din(snap_data_f), .clk(ctu_tck), .se(ctu_sscan_se), 
// 		     .si({sscan_shift_data, 1'b0}),
// 		     .so({sparc_sscan_so, sscan_shift_data}));
// `else
// dff_s #(94) snap_inst2(.q(snap_data_ff), .din(snap_data_f), .clk(ctu_tck), .se(ctu_sscan_se), 
// 		     .si(), .so());

// assign sparc_sscan_so = 1'b0;
// `endif

// sink #(94) s0(.in (snap_data_ff));

module sparc_ifu_sscan(
    input wire [10:0] swl_sscan_thrstate,
    input wire [3:0] ifq_sscan_test_data,
    input wire [15:0] lsu_sscan_test_data,
    input wire [62:0] tlu_sscan_test_data,
    input wire rclk,

    // jtag debug
    output reg [94-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [94-1:0] rtap_core_data
    // output reg [93:0] sparc_sscan
    );

reg [93:0] snap_data;
reg [93:0] snap_data_next;
reg rtap_sscan_snap;
reg rtap_sscan_snap_f;

always @ (posedge rclk)
begin
    snap_data <= snap_data_next;
    rtap_sscan_snap_f <= rtap_sscan_snap;
end

always @ *
begin
    rtap_sscan_snap = 0;
    if (rtap_core_val && rtap_core_id == 4'd5)
        rtap_sscan_snap = 1'b1;

    if (rtap_sscan_snap)
        snap_data_next = {ifq_sscan_test_data, tlu_sscan_test_data, lsu_sscan_test_data, swl_sscan_thrstate};
    else
        snap_data_next = snap_data;

    core_rtap_data = 0;
    if (rtap_sscan_snap_f)
        core_rtap_data = snap_data;
end

endmodule     
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_ifqctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqctl
//  Description:	
//  Contains the control logic for the ifq and mil.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting














module sparc_ifu_ifqctl(/*AUTOARG*/
   // Outputs
   ifu_lsu_inv_clear, ifu_lsu_ibuf_busy, ifu_lsu_asi_ack, 
   ifu_lsu_ldxa_illgl_va_w2, ifu_lsu_fwd_wr_ack, ifu_lsu_pcxreq_d, 
   ifu_lsu_destid_s, ifu_tlu_l2imiss, ifq_fcl_stallreq, 
   ifq_swl_stallreq, ifq_fcl_flush_sonly_e, ifq_fcl_wrreq_bf, 
   ifq_fcl_rdreq_bf, ifq_fcl_icd_wrreq_bf, ifq_fcl_ictv_wrreq_bf, 
   ifq_erb_fwdrd_bf, ifq_erb_rdtag_f, ifq_erb_rdinst_f, 
   ifq_erb_asi_erren_i2, ifq_erb_asi_errstat_i2, 
   ifq_erb_asi_errinj_i2, ifq_erb_asi_erraddr_i2, 
   ifq_erb_asi_imask_i2, ifq_erb_asiwr_i2, ifq_fcl_asird_bf, 
   ifq_fcl_asi_tid_bf, ifq_erb_ue_rep, ifq_erb_ce_rep, ifq_erb_l2_ue, 
   ifq_erb_io_ue, ifq_erb_ifet_ce, ifq_erb_l2err_tid, 
   ifq_icv_wrdata_bf, ifq_icd_worden_bf, ifq_fcl_fill_thr, 
   ifq_dtu_thrrdy, ifq_dtu_pred_rdy, ifc_ifd_filladdr4_i2, 
   ifc_ifd_reqvalid_e, ifc_ifd_idx_sel_fwd_i2, ifc_ifd_errinv_e, 
   ifc_ifd_uncached_e, ifc_ifd_thrid_e, ifc_ifd_pcxline_adj_d, 
   ifc_inv_asireq_i2, ifc_ifd_repway_s, ifq_sscan_data, 
   ifc_ifd_milfill_sel_i2_l, ifc_ifd_finst_sel_l, 
   ifc_ifd_milreq_sel_d_l, ifc_ifd_ifqbyp_sel_fwd_l, 
   ifc_ifd_ifqbyp_sel_inq_l, ifc_ifd_ifqbyp_sel_asi_l, 
   ifc_ifd_ifqbyp_sel_lsu_l, ifc_ifd_ifqbyp_en_l, 
   ifc_ifd_addr_sel_bist_i2_l, ifc_ifd_addr_sel_asi_i2_l, 
   ifc_ifd_addr_sel_old_i2_l, ifc_ifd_addr_sel_fill_i2_l, 
   ifq_icd_data_sel_bist_i2, ifq_icd_data_sel_fill_i2, 
   ifq_icd_data_sel_old_i2, ifc_ifd_ldmil_sel_new, ifc_ifd_ld_inq_i1, 
   ifc_inv_ifqadv_i2, so, 
   // Inputs
   lsu_ifu_cpxpkt_wayvld_i1, ifd_ifc_milhit_s, ifd_ifc_instoffset0, ifd_ifc_instoffset1, 
   ifd_ifc_instoffset2, ifd_ifc_instoffset3, ifd_ifc_cpxvalid_i1, 
   ifd_ifc_cpxreq_i1, ifd_ifc_cpxreq_nxt, ifd_ifc_cpxthr_nxt, 
   ifd_ifc_cpxvld_i2, ifd_ifc_iobpkt_i2, ifd_ifc_4bpkt_i2, 
   ifd_ifc_cpxnc_i2, ifd_ifc_fwd2ic_i2, ifd_ifc_cpxce_i2, 
   ifd_ifc_cpxue_i2, ifd_ifc_cpxms_i2, ifd_ifc_miladdr4_i2, 
   ifd_ifc_asiaddr_i2, ifd_ifc_asi_vachklo_i2, ifd_ifc_destid0, 
   ifd_ifc_destid1, ifd_ifc_destid2, ifd_ifc_destid3, 
   ifd_ifc_newdestid_s, ifd_ifc_pcxline_d, inv_ifc_inv_pending, 
   fcl_ifq_icmiss_s1, fcl_ifq_rdreq_s1, fcl_ifq_thr_s1, 
   fcl_ifq_canthr, fcl_ifq_grant_bf, dtu_ifq_kill_latest_d, 
   erb_ifq_ifeterr_d1, erb_ifq_itlberr_s1, lsu_ifu_pcxpkt_ack_d, 
   lsu_ifu_direct_map_l1, lsu_ifu_asi_vld, lsu_ifu_asi_state, 
   lsu_ifu_asi_load, lsu_ifu_asi_thrid, fcl_ifq_icache_en_s_l, 
   mbist_ifq_run_bist, mbist_icache_write, mbist_icache_read, 
   ctu_sscan_tid, rclk, se, si, gdbginit_l, arst_l, grst_l, 
   rst_tri_en, sehold
   );

   input          lsu_ifu_cpxpkt_wayvld_i1;
   input [3:0]	  ifd_ifc_milhit_s;      // if an Imiss hits in MIL
   input [1:0]    ifd_ifc_instoffset0; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset1; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset2; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset3; // to select inst to TIR

   input         ifd_ifc_cpxvalid_i1;
   input [(143 - 140 + 1):0] ifd_ifc_cpxreq_i1;

   input [3:0]   ifd_ifc_cpxreq_nxt;
   input [1:0]   ifd_ifc_cpxthr_nxt;
   input         ifd_ifc_cpxvld_i2;
   
   input         ifd_ifc_iobpkt_i2;
   input         ifd_ifc_4bpkt_i2;
   input         ifd_ifc_cpxnc_i2;
   input         ifd_ifc_fwd2ic_i2;
   input         ifd_ifc_cpxce_i2,
		             ifd_ifc_cpxue_i2,
                 ifd_ifc_cpxms_i2;
   
   input [3:0]   ifd_ifc_miladdr4_i2;

   input [3:2]   ifd_ifc_asiaddr_i2;
   input         ifd_ifc_asi_vachklo_i2;

   input [2:0]   ifd_ifc_destid0,
		             ifd_ifc_destid1,
		             ifd_ifc_destid2,
		             ifd_ifc_destid3,
		             ifd_ifc_newdestid_s;
   input [4:2]   ifd_ifc_pcxline_d;
//   input [7:0]   ifd_ifc_mil_repway_s;   

   input         inv_ifc_inv_pending;
   
   input         fcl_ifq_icmiss_s1;   // icache miss
   input         fcl_ifq_rdreq_s1;

   input [1:0]   fcl_ifq_thr_s1;

   input [3:0]   fcl_ifq_canthr;        // cancel the imiss reqs to
                                        // these threads
   input         fcl_ifq_grant_bf;

   input         dtu_ifq_kill_latest_d;
   input         erb_ifq_ifeterr_d1;
   input         erb_ifq_itlberr_s1;
   
   input         lsu_ifu_pcxpkt_ack_d;
   input         lsu_ifu_direct_map_l1;

   input         lsu_ifu_asi_vld;
   input [7:0]   lsu_ifu_asi_state;
   input         lsu_ifu_asi_load;
   input [1:0]   lsu_ifu_asi_thrid;

   input         fcl_ifq_icache_en_s_l;
   
   input         mbist_ifq_run_bist,
                 mbist_icache_write,
		             mbist_icache_read;

   input [3:0]   ctu_sscan_tid;

   input         rclk, 
                 se, 
                 si,
                 gdbginit_l,
                 arst_l,
                 grst_l;

   input         rst_tri_en;
   input         sehold;
   
   // outputs
   output        ifu_lsu_inv_clear;
   output        ifu_lsu_ibuf_busy;
   output        ifu_lsu_asi_ack;
   output        ifu_lsu_ldxa_illgl_va_w2;

   output        ifu_lsu_fwd_wr_ack;
   
   output        ifu_lsu_pcxreq_d;
   output [2:0]  ifu_lsu_destid_s;

   output [3:0]  ifu_tlu_l2imiss;
   
   output        ifq_fcl_stallreq;
   output        ifq_swl_stallreq;
   output        ifq_fcl_flush_sonly_e;
   
   output        ifq_fcl_wrreq_bf;
   output        ifq_fcl_rdreq_bf;
   
   output        ifq_fcl_icd_wrreq_bf,
		             ifq_fcl_ictv_wrreq_bf;
   output        ifq_erb_fwdrd_bf;
   output        ifq_erb_rdtag_f;
   output        ifq_erb_rdinst_f;
   output        ifq_erb_asi_erren_i2;
   output        ifq_erb_asi_errstat_i2;
   output        ifq_erb_asi_errinj_i2;
   output        ifq_erb_asi_erraddr_i2;
   output        ifq_erb_asi_imask_i2;
   output        ifq_erb_asiwr_i2;
   
   output        ifq_fcl_asird_bf;
   output [1:0]  ifq_fcl_asi_tid_bf;

   output        ifq_erb_ue_rep;
   output        ifq_erb_ce_rep;
   output        ifq_erb_l2_ue;
   output        ifq_erb_io_ue;
   output        ifq_erb_ifet_ce;
   output [1:0]  ifq_erb_l2err_tid;

   output        ifq_icv_wrdata_bf;
   output [3:0]  ifq_icd_worden_bf;

   output [3:0]  ifq_fcl_fill_thr;     // should be same stage as 
   // fill_inst
   output [3:0]  ifq_dtu_thrrdy;
   output [3:0]  ifq_dtu_pred_rdy;
   
   output        ifc_ifd_filladdr4_i2;
   output        ifc_ifd_reqvalid_e;
   output        ifc_ifd_idx_sel_fwd_i2;

   output        ifc_ifd_errinv_e;
   output        ifc_ifd_uncached_e;
   output [1:0]  ifc_ifd_thrid_e;
   output [4:2]  ifc_ifd_pcxline_adj_d;

   output        ifc_inv_asireq_i2;

   output [1:0]  ifc_ifd_repway_s;

   output [3:0]  ifq_sscan_data;
   
   // mux selects
   output [3:0]  ifc_ifd_milfill_sel_i2_l;
   output [3:0]  ifc_ifd_finst_sel_l;
   output [3:0]  ifc_ifd_milreq_sel_d_l;
   output        ifc_ifd_ifqbyp_sel_fwd_l, // select next input to ifq pipe
		             ifc_ifd_ifqbyp_sel_inq_l,
		             ifc_ifd_ifqbyp_sel_asi_l,
		             ifc_ifd_ifqbyp_sel_lsu_l;
	 output        ifc_ifd_ifqbyp_en_l;
   
   output        ifc_ifd_addr_sel_bist_i2_l,
		             ifc_ifd_addr_sel_asi_i2_l,
                 ifc_ifd_addr_sel_old_i2_l,
		             ifc_ifd_addr_sel_fill_i2_l;

   output        ifq_icd_data_sel_bist_i2,
		             ifq_icd_data_sel_fill_i2,
		             ifq_icd_data_sel_old_i2;
	 
   // 2:1 mux selects
   output [3:0]  ifc_ifd_ldmil_sel_new;     // mil load enable

   
   output        ifc_ifd_ld_inq_i1;
   
   output        ifc_inv_ifqadv_i2;         // move a new op from ifq
	 // pipe to icache

   output        so;
   
   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------   
   // local signals
   wire [3:0]    thr_s1,      // s1 thread which missed in I$
		             thr_d1,
                 thr_e1,
		             dfthr_f,     // thread currently being filled in I$
                 dfthr_next_i2,
		             dfthr_i2,    // next thread to be filled from CPX
                 milfthr_i2,
		             dpcxthr_s,
		             dpcxthr_d;   // thread being transmitted to lsu

   wire [1:0]    thrid_d,
                 thrid_e;
   
   wire [3:0]    pcx_accept_d;

   wire          req_pending_d,
//		             req_pending_e,
		             req_accept_d,
//                 can_pcx_d,
                 pcxreq_vbit_d;
   
   wire [3:0]    comp_valid_s,
		             mil_valid_s,
                 mil_cancel;

   wire [3:0]    finst_i2,
                 finst0,
                 finst1,
                 finst2,
                 finst3;

   wire [2:0]    milchld0,
		             milchld1,
		             milchld2,
		             milchld3,
		             next_milchld,
		             milchld_d1;
   wire          milchld_vld_f,
		             next_milchld_i2,
		             milchld_vld_i2;

   wire [3:0]    mil0_state,
                 mil1_state,
                 mil2_state,
                 mil3_state;

   wire [2:0]    i2out;         // state machine output in i2 stage
   
   wire          any_milhit_qual_s,     // hit in MIL
                 any_qualhit_or_io_s,
		             icmiss_qual_s,
//		             reqq_empty,    // no pending requests in MIL
		             oldreq_valid,
		             next_wrreq_i2,
		             wrreq_f;
   wire          block_fetch_s1,
                 block_fetch_d1;

   wire [3:0]    mil_thr_ready,
                 all_retry_rdy_e1,
                 all_retry_rdy_m1;
   wire          retry_rdy_final_d1,
                 retry_rdy_e1;

   wire          rst_starv_ctr_l;
   wire          starv_alert;

   wire [3:0]    milhit_vec_s;
   wire          any_milhit_s;

   wire [1:0]    rand_repway_s;
//   wire [1:0]    mil_repway_s;

   wire [3:0]    errthr_d1,
		             err_vec_d1,
		             err_req;
   wire          errinv_d1;

   wire          ifeterr_qual_d1,
                 ifeterr_e1;
   wire          thr_match_d1e1;
   wire          ifqadv_i1;

   wire          ifqadvi2_nxt,
                 ifqadv_i2_ff;
   wire          access_grant_l;

   wire          addrbit4_i2;
   wire          addrbit4_nxt_i2;
   
   wire [3:0]    cpxreq_i2;
   wire [1:0]    cpxthr_i2;
   

   wire          uncached_i2,
                 uncached_s,
                 mil_vld_i2,
                 mil_uncan_i2,
                 mil_nc_i2,
                 mil_nc_e,
                 mil_nc_d,
		             uncached_fill_i2,
		             uncached_f;

   wire [3:0]    mil_nc_vec,
                 mil_nc_vec_nxt;
                 
   
   wire [3:0]    pcxreq_s,          // req bit from MIL
                 pcxreq_qual_s,
//		             newpcxreq_s,       // valid new request from latest miss
//		             oldpcxreq_s,
		             rr_gnt,          // round robin grant signal
		             fill_addr4_i2;    // fill address bit 4 - determines
	 // which 16B of the 32B line gets
	 // written. Assume 0 first then 1

   wire          newreq_valid,    // latest S stage miss creates request.
		             nextreq_valid_s, // if either a new req from i$ or old
				         // req from MIL is made in this cycle.
		             req_valid_d;     // req to LSU is valid

   wire          inq_vld,
		             inq_vld_nxt;

   wire          ic_pkt_i1;
   
//   wire          fill_this16b;

   wire [1:0]    filltid_i2,
		             next_filltid_i2,
		             filltid_f;

   wire          imissrtn_i2,   // input cpx is ifill return
                 imissrtn_next_i2,
                 imissrtn_f,
		             imissrtn_i1;   // pkt in inq is ifill ret

   wire          invalidate_i1;

   wire [3:0]    icmiss_thr_s,
		             icmiss_thr_d;
   wire          icmiss_d1,
                 icmiss_qual_d1;
   wire          canthr_s1,
                 canthr_d1,
                 canthr_s1_del1;
   wire          itlberr_d1;

   wire [2:0]    old_destid_s;

   wire          destid_iob_s,
                 destid_iob_d;

   wire          iosp_d1_l,
                 n763;
   
   wire [3:0]    wrt_tir;

   wire [3:0]    wr_complete_f;
   wire [3:0]    pred_rdy_i2;
   wire [3:0]    fill_retn_thr_i2;

   wire          filladdr4_f;
   
   wire [3:0]    milhit_to_thr_s,
		             icmiss_for_milchk,
                 qualhit_pe_s,
                 qualhit_or_io_s;
//		             milhit_qual_s;

   wire          l2_ue_i2,
		             l2_ce_i2,
		             io_ue_i2;
   wire          l2_miss_i2,
                 l2_miss_f;
//   wire [3:0]    l2ms_thr;
   
   wire          ce_rep_i2,
		             ue_rep_i2;

   wire          fwdreq_i2,
                 fwdreq_i3,
                 fwd_stall,
                 fwdwr_i3,
                 fwdrd_i3;

   wire          cpxnc_i3;

   wire          stallreq_d0,
                 stallreq_d1;

   wire          ifu_asireq_i1,
                 ifu_asireq_i0,
                 byp_sel_asi_l,
                 asird_i1,
		             asireq_i2,
                 asireq_i2_l,
		             asi_load_i1,
		             asi_load_i2,
		             asi_vld_next,
                 asi_vld_i0,
                 asi_vld_qual_i0;
   
   wire [7:0]    asi_state_i1;
   wire          asi_ic_data_i1,
		             asi_ic_data_i2,
		             asi_ic_tag_i1,
		             asi_ic_tag_i2;

   wire          asi_erren_i1,
		             asi_errstat_i1,
		             asi_errinj_i1,
		             asi_erraddr_i1,
		             asi_imask_i1;

   wire          asi_ic_data_unchk_i1,
		             asi_ic_tag_unchk_i1;

   wire          asi_erren_unchk_i1,
		             asi_errstat_unchk_i1,
		             asi_errinj_unchk_i1,
		             asi_erraddr_unchk_i1,
		             asi_imask_unchk_i1;

   wire          illva_i0,
                 illva_i1,
                 illva_i2,
                 illva_f,
                 illva_s,
                 illva_w2;

   wire [3:0]    word_sel_i2;
   wire          bist_op;

   wire          rdinst_bf,
		             rd_tag_bf;
   
   wire          errpkt_i1;
   
   wire          stpkt_i1,
                 strmack_i1,
		             ldpkt_i1,
		             evpkt_i1,
		             errpkt_i2;
   
   wire          icv_wrdata_i2,
		             icv_wbit_i2,
		             icv_wrdata_f;

   wire          rst_way_lfsr;

   wire          inq_wayvld_i1;
   wire          inq_wayvld_i1_nxt;
   wire          ldinv_i1;
   wire          ldinv_i2_nxt;
   wire          ldinv_i2;
	 
   wire          ifq_reset,
                 rnd_reset,
                 ifq_reset_l;
   

   wire          clk;
   
   
//----------------------------------------------------------------------
// Code start here 
//----------------------------------------------------------------------

   assign        clk = rclk;
   

   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (ifq_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign       ifq_reset = ~ifq_reset_l;

   
//---------
// MIL fsm
//---------   
   sparc_ifu_milfsm mil0(
 	                       .ifc_fsm_can_thisthr      (fcl_ifq_canthr[0]),        
                         //	.ifc_fsm_orphan_thisthr (orphan_thr_d1[0]),


	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[0]),    
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[0]),

                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),
	                       .ifc_fsm_imiss_thisthr_s  (icmiss_thr_s[0]),          
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),

	                       .ifc_fsm_hiton_thismil_s  (milhit_to_thr_s[0]),   

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[0]),
                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[0]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

                         .so                       (),

	                       .ifc_fsm_err_thisthr      (errthr_d1[0]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[0]),
		  
	                       .fsm_ifc_wrt_tir          (wrt_tir[0]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[0]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[0]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[0]),
                         .fsm_ifc_milstate         (mil0_state[3:0]),
			
	                       .fsm_ifc_thr_ready        (mil_thr_ready[0]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[0]),
	                       .fsm_ifc_pcxreq           (pcxreq_s[0]),       
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[0]),
	                       .fsm_ifc_milchld          (milchld0[2:0]));
   

   sparc_ifu_milfsm mil1(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[1]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[1]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[1]),   
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[1]),          
      
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[1]),   
	                       .ifc_fsm_imiss_thisthr_s   (icmiss_thr_s[1]),          

	                       .ifc_fsm_pcxaccept_thisthr   (pcx_accept_d[1]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         
                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[1]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[1]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[1]),

	                       .fsm_ifc_wrt_tir          (wrt_tir[1]),
                         .so                       (),	    
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[1]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[1]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[1]), 
	                       .fsm_ifc_mil_valid        (mil_valid_s[1]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[1]),
                         .fsm_ifc_milstate         (mil1_state[3:0]),

	                       .fsm_ifc_pcxreq           (pcxreq_s[1]),       
	                       .fsm_ifc_thr_ready        (mil_thr_ready[1]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[1]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[1]), 
	                       .fsm_ifc_milchld          (milchld1[2:0]));

   sparc_ifu_milfsm mil2(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[2]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[2]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[2]),
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[2]),          
			
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[2]),   
	                       .ifc_fsm_imiss_thisthr_s  (icmiss_thr_s[2]),          

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[2]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         

                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[2]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[2]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[2]),

                         .so                       (),	    
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[2]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[2]),
	                       .fsm_ifc_wrt_tir          (wrt_tir[2]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[2]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[2]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[2]),
                         .fsm_ifc_milstate         (mil2_state[3:0]),
			
	                       .fsm_ifc_pcxreq           (pcxreq_s[2]),       
	                       .fsm_ifc_thr_ready        (mil_thr_ready[2]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[2]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[2]), 
	                       .fsm_ifc_milchld          (milchld2[2:0]));


   sparc_ifu_milfsm mil3(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[3]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[3]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[3]),
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[3]), 
			
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[3]),   
	                       .ifc_fsm_imiss_thisthr_s   (icmiss_thr_s[3]),          

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[3]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         

                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[3]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[3]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[3]),

                         .so                       (),	
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[3]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[3]),
	                       .fsm_ifc_wrt_tir          (wrt_tir[3]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[3]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[3]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[3]),
                         .fsm_ifc_milstate         (mil3_state[3:0]),
			
	                       .fsm_ifc_pcxreq           (pcxreq_s[3]),           
	                       .fsm_ifc_thr_ready        (mil_thr_ready[3]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[3]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[3]),    
	                       .fsm_ifc_milchld          (milchld3[2:0]));


   
//-------------------------------------------
// Fill Return Control (IFU interfac to CPX)
//-------------------------------------------

   // use soffm2 for lower setup
   dffe_s #(4) cpxreq_reg(.din (ifd_ifc_cpxreq_nxt),
                        .q   (cpxreq_i2),
                        .en  (ifqadv_i1),
                        .clk (clk), .se(se), .si(), .so());
   dffe_s #(2) cpxthr_reg(.din (ifd_ifc_cpxthr_nxt),
                        .q   (cpxthr_i2),
                        .en  (ifqadv_i1),
                        .clk (clk), .se(se), .si(), .so());
   

   // Decode CPX request
   assign imissrtn_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0001}) ? 1'b1 : 1'b0;   
   assign imissrtn_i2 = (cpxreq_i2 == 4'b0001) ? ifd_ifc_cpxvld_i2 : 1'b0;

   assign imissrtn_next_i2 = ifc_inv_ifqadv_i2 ? imissrtn_i2 : imissrtn_f;
   
   dff_s #(1) imsf_ff(.din (imissrtn_next_i2),
                    .q   (imissrtn_f),
                    .clk (clk), .se (se), .si(), .so());
   
   // Determine if this is an IFILL RET to one of the threads
   assign fill_retn_thr_i2 = dfthr_i2 & {4{imissrtn_i2}};
   
   // decode current icache fill thread
   assign dfthr_f[0] = ~filltid_f[1] & ~filltid_f[0];
   assign dfthr_f[1] = ~filltid_f[1] &  filltid_f[0];
   assign dfthr_f[2] =  filltid_f[1] & ~filltid_f[0];
   assign dfthr_f[3] =  filltid_f[1] &  filltid_f[0];

//`ifdef IFU_SAT
//   assign ifc_ifd_uncached_s = fcl_ifq_icache_en_s_l;   
//`else   
//`endif

   assign uncached_s = ifd_ifc_newdestid_s[2] | fcl_ifq_icache_en_s_l;

   // timing fix: keep nc bit locally instead of in DP
   assign mil_nc_vec_nxt = ({4{uncached_s & fcl_ifq_rdreq_s1}} & 
                              thr_s1 & ~errthr_d1 |
                              mil_nc_vec & (mil_valid_s |
                                            errthr_d1));

   dff_s #(4) nc_reg(.din (mil_nc_vec_nxt),
                   .q   (mil_nc_vec),
                   .clk (clk), .se(se), .si(), .so());

   assign mil_nc_i2 = (dfthr_i2[0] & mil_nc_vec[0] |
                       dfthr_i2[1] & mil_nc_vec[1] |
                       dfthr_i2[2] & mil_nc_vec[2] |
                       dfthr_i2[3] & mil_nc_vec[3]);

   assign mil_nc_d = (dpcxthr_d[0] & mil_nc_vec[0] |
                      dpcxthr_d[1] & mil_nc_vec[1] |
                      dpcxthr_d[2] & mil_nc_vec[2] |
                      dpcxthr_d[3] & mil_nc_vec[3]);

   dff_s #(1) nce_ff(.din (mil_nc_d),
                   .q   (mil_nc_e),
                   .clk (clk), .se(se), .si(), .so());
   assign ifc_ifd_uncached_e = mil_nc_e;
   
//   assign uncached_fill_i2 = ifd_ifc_uncached_i2 | ifd_ifc_cpxnc_i2;
   assign uncached_fill_i2 = mil_nc_i2 | ifd_ifc_cpxnc_i2;   
   
   // uncached fill -- do not write to icache
   assign uncached_i2 = ifc_inv_ifqadv_i2 ? 
	                          uncached_fill_i2 : uncached_f;

   dff_s unc_ff(.din (uncached_i2),
	            .q   (uncached_f),
	            .clk (clk),
	            .se  (se), .si(), .so());

   // Determine if Icache write is done or 
   // if none is necessary (i.e. if this is a child process or NC)
   assign wr_complete_f = dfthr_f & {4{(wrreq_f & ifc_inv_ifqadv_i2 | 
                                        milchld_vld_f |
				                                uncached_f) & imissrtn_f}};

   // State Machine Outputs
   // One of these has to be chosen for I2 stage operation
   mux4ds #(3)  i2out_mux(.dout  (i2out),
		       .in0   (milchld0),
		       .in1   (milchld1),
		       .in2   (milchld2),
		       .in3   (milchld3),
		       .sel0  (dfthr_i2[0]),
		       .sel1  (dfthr_i2[1]),
		       .sel2  (dfthr_i2[2]),
		       .sel3  (dfthr_i2[3]));

   assign mil_vld_i2 = (mil_valid_s[0] & dfthr_i2[0] |
                        mil_valid_s[1] & dfthr_i2[1] |
                        mil_valid_s[2] & dfthr_i2[2] |
                        mil_valid_s[3] & dfthr_i2[3]);

   assign mil_uncan_i2 = (mil_valid_s[0] & ~mil_cancel[0] & dfthr_i2[0] |
                          mil_valid_s[1] & ~mil_cancel[1] & dfthr_i2[1] |
                          mil_valid_s[2] & ~mil_cancel[2] & dfthr_i2[2] |
                          mil_valid_s[3] & ~mil_cancel[3] & dfthr_i2[3]);

   // Don't make a wrreq if this is a child entry.  However, if this is
   // a child and the parent was cancelled, then go ahead and
   // write... is this really necessary?  Not for functionality.
   // 3/19: parent will write even if cancelled.  So never write child
   assign next_wrreq_i2 = imissrtn_i2 & mil_vld_i2 & ~uncached_fill_i2 &
	                  ~milchld_vld_i2 & ~ifd_ifc_4bpkt_i2; // was: iobpkt_i2

   assign addrbit4_i2 = (milfthr_i2[0] & fill_addr4_i2[0] |
                         milfthr_i2[1] & fill_addr4_i2[1] |
                         milfthr_i2[2] & fill_addr4_i2[2] |
                         milfthr_i2[3] & fill_addr4_i2[3]);

   assign addrbit4_nxt_i2= ifc_inv_ifqadv_i2 ? addrbit4_i2 : filladdr4_f;
   dff_s #(1) ab4_ff(.din (addrbit4_nxt_i2),
                   .q   (filladdr4_f),
                   .clk (clk),
                   .se  (se), .si(), .so());
   
   assign ifc_ifd_filladdr4_i2 = addrbit4_nxt_i2;

   assign next_milchld = ifc_inv_ifqadv_i2 ? 
	                          {(i2out[2] & imissrtn_i2), i2out[1:0]} :
	                          milchld_d1;

   // After the packet is processed, the child entry in the MIL,
   // pointed to by the reg below is processed next (if valid)
   dffr_s #(3)  milchldd_reg(.din  (next_milchld),
			                     .clk  (clk),
			                     .rst  (ifq_reset),
			                     .q    (milchld_d1),
			                     .se   (se), .si(), .so());

   assign milchld_vld_i2 = milchld_d1[2];
   assign next_milchld_i2 = ifc_inv_ifqadv_i2 ? milchld_d1[2] :
	                                              milchld_vld_f;
   
   dffr_s #(1) milchldf_ff(.din  (next_milchld_i2),
		       .q    (milchld_vld_f),
		       .clk  (clk),
		       .rst  (ifq_reset),
		       .se   (se), .si(), .so());

   // need this to avoid x's in the simulation
//   assign cpxthrid_adj_i2 = ifd_ifc_cpxthr_i2 &
//	                          {2{ifd_ifc_cpxreq_i2[`CPX_RQ_SIZE]}};

   // Determine if we should process the child or a new entry
//   assign next_thr_sel_milchld_i2 = ifc_inv_ifqadv_i2 & milchld_vld_i2 & 
//	                            ~errpkt_i2;
//   assign next_thr_sel_milchld_i2 = milchld_vld_i2 & ~errpkt_i2;
   
   
   // if previous mil entry had a child, process that next
//   mux2ds  #(2) filltid_mux(.dout  (filltid_i2),
//		                        .in0   (cpxthrid_adj_i2),
//		                        .in1   (milchld_d1[1:0]),
//		                        .sel0  (~milchld_vld_i2),
//		                        .sel1  (milchld_vld_i2));
   assign filltid_i2 = milchld_vld_i2 ? milchld_d1[1:0] :
                                        cpxthr_i2[1:0];

   // decode fill thread  (either cpx thread or MIL child thread from above)
   // need to qual with valid bit to avoid X's in simulation
//   assign cpxvld_or_milc_i2 = ifd_ifc_cpxreq_i2[`CPX_RQ_SIZE] | milchld_vld_i2;
   assign dfthr_i2[0] = ~filltid_i2[1] & ~filltid_i2[0];
   assign dfthr_i2[1] = ~filltid_i2[1] &  filltid_i2[0];
   assign dfthr_i2[2] =  filltid_i2[1] & ~filltid_i2[0];
   assign dfthr_i2[3] =  filltid_i2[1] &  filltid_i2[0];

   dp_mux2es  #(2)  thren_mux(.dout (next_filltid_i2),
			                        .in0  (filltid_f),
			                        .in1  (filltid_i2),
			                        .sel  (ifc_inv_ifqadv_i2));

   dff_s #(2) wrthr_reg(.din  (next_filltid_i2),
		                  .clk  (clk),
		                  .q    (filltid_f),
		                  .se   (se), .si(), .so());   


   dp_mux2es  #(4)  dthren_mux(.dout (dfthr_next_i2),
			                         .in0  (dfthr_f),
			                         .in1  (dfthr_i2),
			                         .sel  (ifc_inv_ifqadv_i2));
   

   // Early start of threads
   // Do we need a control bit to turn this off?
   // -- do it in SWL
   assign ifq_dtu_pred_rdy =  pred_rdy_i2 & {dfthr_next_i2[3:0]} &
                              {4{imissrtn_next_i2}};

// If timing is a problem resort to:
//   assign ifq_dtu_pred_rdy =  pred_rdy_i2 & {4{ifc_inv_ifqadv_i2}} &
//                              dfthr_i2 & {4{imissrtn_i2}};
   
   

   // pick 16B half cache line which contains the instruction we want
//   assign fill_this16b = ~(ifc_ifd_filladdr4_i2 ^ ifd_ifc_missaddr4_i2);
                         // | ifd_ifc_4bpkt_i2;

   // write to thread instruction register
//   assign ifq_fcl_fill_thr = wrt_tir & {4{fill_this16b | ifd_ifc_4bpkt_i2}};
//   assign ifq_fcl_fill_thr = wrt_tir & {4{fill_this16b}};
   assign ifq_fcl_fill_thr = wrt_tir | thr_d1 & {4{itlberr_d1 & 
                                                   ~canthr_d1 & 
                                                   icmiss_d1 & 
                                                   ~canthr_s1_del1}};

   // Select instruction to send to TIR
   // TBD: Need to find out how the inst from boot PROM is aligned -- Done
   // From kinkee 02/21/03: It is aligned to the correct 4B of the 16B 
   // packet.  The other locations are X.
   assign finst0[0] = ~ifd_ifc_instoffset0[1] & ~ifd_ifc_instoffset0[0];
   assign finst0[1] = ~ifd_ifc_instoffset0[1] &  ifd_ifc_instoffset0[0];
   assign finst0[2] =  ifd_ifc_instoffset0[1] & ~ifd_ifc_instoffset0[0];
   assign finst0[3] =  ifd_ifc_instoffset0[1] &  ifd_ifc_instoffset0[0];

   assign finst1[0] = ~ifd_ifc_instoffset1[1] & ~ifd_ifc_instoffset1[0];
   assign finst1[1] = ~ifd_ifc_instoffset1[1] &  ifd_ifc_instoffset1[0];
   assign finst1[2] =  ifd_ifc_instoffset1[1] & ~ifd_ifc_instoffset1[0];
   assign finst1[3] =  ifd_ifc_instoffset1[1] &  ifd_ifc_instoffset1[0];

   assign finst2[0] = ~ifd_ifc_instoffset2[1] & ~ifd_ifc_instoffset2[0];
   assign finst2[1] = ~ifd_ifc_instoffset2[1] &  ifd_ifc_instoffset2[0];
   assign finst2[2] =  ifd_ifc_instoffset2[1] & ~ifd_ifc_instoffset2[0];
   assign finst2[3] =  ifd_ifc_instoffset2[1] &  ifd_ifc_instoffset2[0];

   assign finst3[0] = ~ifd_ifc_instoffset3[1] & ~ifd_ifc_instoffset3[0];
   assign finst3[1] = ~ifd_ifc_instoffset3[1] &  ifd_ifc_instoffset3[0];
   assign finst3[2] =  ifd_ifc_instoffset3[1] & ~ifd_ifc_instoffset3[0];
   assign finst3[3] =  ifd_ifc_instoffset3[1] &  ifd_ifc_instoffset3[0];

//   mux4ds #(4) finst_mx(.dout (finst_i2),
//                        .in0  (finst0),
//                        .in1  (finst1),
//                        .in2  (finst2),
//                        .in3  (finst3),
//                        .sel0 (dfthr_i2[0]),
//                        .sel1 (dfthr_i2[1]),
//                        .sel2 (dfthr_i2[2]),
//                        .sel3 (dfthr_i2[3]));

   wire [3:0] finst_ev,
              finst_od,
              finst_i2_l;
   wire [1:0] filltid_i2_l;
   bw_u1_inv_10x UZsize_ftid_bf0(.z (filltid_i2_l[0]),
                                 .a (filltid_i2[0]));
   bw_u1_inv_20x UZsize_ftid_bf1(.z (filltid_i2_l[1]),
                                 .a (filltid_i2[1]));
   // use bw_u1_muxi21_4x
   assign finst_ev = filltid_i2_l[1] ? finst0 : finst2;
   assign finst_od = filltid_i2_l[1] ? finst1 : finst3;
   assign finst_i2_l = filltid_i2_l[0] ? (~finst_ev) : (~finst_od);
   assign finst_i2 = ~finst_i2_l;

   assign ifc_ifd_finst_sel_l = ~finst_i2;

   // pick MIL entry corresponding to current thread
   assign milfthr_i2[0] = ~cpxthr_i2[1] & ~cpxthr_i2[0];
   assign milfthr_i2[1] = ~cpxthr_i2[1] &  cpxthr_i2[0];
   assign milfthr_i2[2] =  cpxthr_i2[1] & ~cpxthr_i2[0];
   assign milfthr_i2[3] =  cpxthr_i2[1] &  cpxthr_i2[0];
   assign ifc_ifd_milfill_sel_i2_l = ~milfthr_i2;

   // write request
   // assign ifq_fcl_wrreq_bf = ifc_inv_ifqadv_i2 ? next_wrreq_i2 : wrreq_f;
   // assign ifq_fcl_wrreq_bf = ~ifc_inv_ifqadv_i2 | next_wrreq_i2;
   assign ifq_fcl_wrreq_bf = wrreq_f & ~ifc_inv_ifqadv_i2 | next_wrreq_i2;
   
   dffr_s #(1) wrreq_ff(.din (ifq_fcl_wrreq_bf),
		                  .clk (clk),
		                  .q   (wrreq_f),
		                  .rst (ifq_reset),
		                  .se  (se), .si(), .so());

   // starvation check
   // if a write is not granted for 24 cycles, sound the alarm
   sparc_ifu_ctr5 starv_ctr(
			                      // Outputs
			                      .limit	(starv_alert),
			                      .so	(so),
			                      // Inputs
			                      .clk	(clk),
			                      .se	(se),
			                      .si	(si),
			                      .rst_ctr_l (rst_starv_ctr_l));
   assign rst_starv_ctr_l = ~ifq_reset & wrreq_f;

   // advance in i2 when a write ack is received or if not a fill
   // Can help timing of this signal by doing
   //  ifqadv_nxt = ~ifq_fcl_wrreq_bf | fcl_icd_index_sel_ifq_bf
   assign access_grant_l = ~fcl_ifq_grant_bf;
   bw_u1_nand2_2x UZsize_acc_n2(.z (ifqadvi2_nxt),
                                .a (ifq_fcl_wrreq_bf),
                                .b (access_grant_l));
   dff_s #(1) qadv_ff(.din (ifqadvi2_nxt),
                    .q   (ifqadv_i2_ff),
                    .clk (clk), .se(se), .si(), .so());
   assign ifc_inv_ifqadv_i2 = ifqadv_i2_ff;

   

   // advance in i1 when a write ack is received AND there are no
   // child threads to be taken care of
   assign ifqadv_i1 = (ifc_inv_ifqadv_i2 & ~next_milchld[2] & ~fwd_stall) | 
                        ifq_reset; 

//-----------------------------------
// Errors and Error Packet
//-----------------------------------   

   assign errpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b1100}) ? 1'b1 : 1'b0;
   assign errpkt_i2 = (cpxreq_i2 == 4'b1100) ? ifd_ifc_cpxvld_i2 : 1'b0;

   // Reported Errors are not logged in ERB
   assign ce_rep_i2 = ifd_ifc_cpxce_i2 & ~ifd_ifc_cpxue_i2 & errpkt_i2 &
	                    ifc_inv_ifqadv_i2;
   assign ue_rep_i2 = ifd_ifc_cpxue_i2 & errpkt_i2 & ifc_inv_ifqadv_i2;

   dff_s #(1) cerep_ff(.din (ce_rep_i2),
		                 .q   (ifq_erb_ce_rep),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(1) uerep_ff(.din (ue_rep_i2),
		                 .q   (ifq_erb_ue_rep),
		                 .clk (clk), .se(se), .si(), .so());

//   dff #(2) ertid_reg(.din (filltid_i2),
//		                  .q   (ifq_erb_l2err_tid),
//		                  .clk (clk), .se(se), .si(), .so());
   // send thread id one cycle earlier to help crit path
   assign ifq_erb_l2err_tid = filltid_i2;
   
   // Ifetch Errors are logged in ERB
   assign l2_ce_i2 = ifd_ifc_cpxce_i2 & ~ifd_ifc_cpxue_i2 & imissrtn_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;
   assign l2_ue_i2 = ifd_ifc_cpxue_i2 & imissrtn_i2 & ~ifd_ifc_iobpkt_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;
   assign io_ue_i2 = ifd_ifc_cpxue_i2 & imissrtn_i2 & ifd_ifc_iobpkt_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;

   dff_s #(1) l2ce_ff(.din (l2_ce_i2),
		                .q   (ifq_erb_ifet_ce),
		                .clk (clk), .se(se), .si(), .so());
   dff_s #(1) l2ue_ff(.din (l2_ue_i2),
		                .q   (ifq_erb_l2_ue),
		                .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ioue_ff(.din (io_ue_i2),
		                .q   (ifq_erb_io_ue),
		                .clk (clk), .se(se), .si(), .so());

   assign l2_miss_i2 = ifd_ifc_cpxms_i2 & imissrtn_i2 & ifc_inv_ifqadv_i2;
   dff_s #(1) l2ms_ff(.din (l2_miss_i2),
		                .q   (l2_miss_f),
		                .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_l2imiss = dfthr_f & {4{l2_miss_f}};
   
//--------------------------------------------
// Miss Request Control (IFU interface to PCX)
//--------------------------------------------

   // decode imiss thread
   assign thr_s1[0] = ~fcl_ifq_thr_s1[0] & ~fcl_ifq_thr_s1[1];
   assign thr_s1[1] =  fcl_ifq_thr_s1[0] & ~fcl_ifq_thr_s1[1];
   assign thr_s1[2] = ~fcl_ifq_thr_s1[0] & fcl_ifq_thr_s1[1];
   assign thr_s1[3] =  fcl_ifq_thr_s1[0] & fcl_ifq_thr_s1[1];

   // signal ic miss to thread MIL state machines
   assign icmiss_thr_s = {4{fcl_ifq_icmiss_s1 & ~block_fetch_s1}} & thr_s1 & 
	                       ~icmiss_thr_d;

//   dff #(4) icmsreg(.din  (icmiss_thr_s),
//		                .clk  (clk),
//		                .q    (icmiss_thr_d),
//		                .se   (se), .si(), .so());

   dff_s #(1) icmsd_ff(.din  (fcl_ifq_icmiss_s1),
		                 .clk  (clk),
		                 .q    (icmiss_d1),
		                 .se   (se), .si(), .so());

   assign icmiss_qual_d1 = icmiss_d1 & ~(thr_match_d1e1 & ifeterr_e1);

   // bug 5926
   assign n763 = ~ifd_ifc_newdestid_s[2];
   dff_s #(1) iosp_ff(.din (n763),
		                .q   (iosp_d1_l),
		                .clk (clk), .se(se), .si(), .so());
   
   assign icmiss_thr_d = {4{icmiss_d1 | erb_ifq_ifeterr_d1 & iosp_d1_l}} & thr_d1 |
                         {4{ifeterr_e1}} & thr_e1;
   
   dff_s #(4) thrdreg(.din  (thr_s1),
		                .clk  (clk),
		                .q    (thr_d1),
		                .se   (se), .si(), .so());

   dff_s #(4) threreg(.din  (thr_d1),
		                .clk  (clk),
		                .q    (thr_e1),
		                .se   (se), .si(), .so());

   dff_s #(1) erre_ff(.din (ifeterr_qual_d1),
                    .q   (ifeterr_e1),
                    .clk (clk), .se(se), .si(), .so());
   assign thr_match_d1e1 =  (thr_d1[0] & thr_e1[0] |
                             thr_d1[1] & thr_e1[1] |
                             thr_d1[2] & thr_e1[2] |
                             thr_d1[3] & thr_e1[3]);

//   assign ifeterr_qual_d1 = ~(thr_match_d1e1 & ifeterr_e1) & ~canthr_d1 & 
//                               erb_ifq_ifeterr_d1;
   assign ifeterr_qual_d1 = ~(thr_match_d1e1 & ifeterr_e1) & 
                               erb_ifq_ifeterr_d1 & iosp_d1_l;
     
   assign errthr_d1 = (thr_d1 & {4{ifeterr_qual_d1 & ~block_fetch_d1}});
   
   // If misses to same thread, (in successive cycles), ignore
   assign ifc_ifd_ldmil_sel_new = (thr_s1 & {4{fcl_ifq_rdreq_s1}} &
				                           ~errthr_d1 & ~mil_valid_s);

   // Check hit in MIL -- a thread cannot hit 
   //   1. its own MIL
   //   2. an MIL that is being filled
   //   3. if it is to an IOB line
   assign qualhit_or_io_s = ifd_ifc_milhit_s & comp_valid_s & 
	                          ~thr_s1 & 
                            ~fill_retn_thr_i2 & 
                            {4{~ifd_ifc_newdestid_s[2]}};

   assign any_qualhit_or_io_s = (qualhit_or_io_s[0] |
		                             qualhit_or_io_s[1] |
		                             qualhit_or_io_s[2] |
		                             qualhit_or_io_s[3]);
   
//   assign milhit_qual_s = ifd_ifc_milhit_s & comp_valid_s & 
//	                        ~thr_s1 & 
//                          ~fill_retn_thr_i2 & 
//                          {4{~ifd_ifc_newdestid_s[2]}};
   
//   assign any_milhit_qual_s = any_qualhit_or_io_s & ~ifd_ifc_newdestid_s[2];
   assign any_milhit_qual_s = any_qualhit_or_io_s;   
   
   // Generate Replacement Way
   // Make sure a req doesn't go out to a different way than 
   // what is pending
   assign milhit_vec_s = ifd_ifc_milhit_s & (mil_valid_s | errthr_d1);
   assign any_milhit_s = (|milhit_vec_s[3:0]);
   
//   assign mil_repway_s = (ifd_ifc_mil_repway_s[7:6] & {2{milhit_vec_s[3]}} | 
//                          ifd_ifc_mil_repway_s[5:4] & {2{milhit_vec_s[2]}} | 
//                          ifd_ifc_mil_repway_s[3:2] & {2{milhit_vec_s[1]}} | 
//                          ifd_ifc_mil_repway_s[1:0] & {2{milhit_vec_s[0]}});

//   assign ifc_ifd_repway_s = any_milhit_s ? mil_repway_s : rand_repway_s;
   assign ifc_ifd_repway_s = rand_repway_s;   

   // pick any way at random
   // reset with dbg_init as well
   sparc_ifu_lfsr5  lfsr(.out (rand_repway_s),
			                   .clk  (clk),
			                   .advance (fcl_ifq_icmiss_s1),
			                   .reset (rst_way_lfsr),
			                   .se (se),
			                   .si (si),
			                   .so (so));

   assign rst_way_lfsr = ifq_reset | lsu_ifu_direct_map_l1 | ~gdbginit_l;

   // check if miss req is valid in a given pipe stage
   assign canthr_s1 = (fcl_ifq_canthr[0] & thr_s1[0] |
                       fcl_ifq_canthr[1] & thr_s1[1] |
                       fcl_ifq_canthr[2] & thr_s1[2] |
                       fcl_ifq_canthr[3] & thr_s1[3]);
   assign canthr_d1 = (fcl_ifq_canthr[0] & thr_d1[0] |
                       fcl_ifq_canthr[1] & thr_d1[1] |
                       fcl_ifq_canthr[2] & thr_d1[2] |
                       fcl_ifq_canthr[3] & thr_d1[3]);
   
   // retry a fetch if the imiss occurs while it is being filled
//   assign block_fetch_s1 = any_milhit_s & 
//                           ~(any_qualhit_or_io_s | ifd_ifc_newdestid_s[2]) |
//                           dtu_ifq_kill_latest_d;
   assign block_fetch_s1 = any_milhit_s & ~ifd_ifc_newdestid_s[2] &
                           ~any_qualhit_or_io_s | 
                           dtu_ifq_kill_latest_d |
                           erb_ifq_itlberr_s1;

   dff_s #(1) bfd_ff(.din (block_fetch_s1),
                   .q   (block_fetch_d1),
                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) tlbe_ff(.din (erb_ifq_itlberr_s1),
                    .q   (itlberr_d1),
                    .clk (clk), .se(se), .si(), .so());
   
//   assign retry_rdy_s1 = block_fetch_s1 & fcl_ifq_icmiss_s1;
//   dff #(1) retrd_ff(.din (retry_rdy_s1),
//                     .q   (retry_rdy_d1),
//                     .clk (clk), .se(se), .si(), .so());
   
   assign retry_rdy_final_d1 = block_fetch_d1 & (icmiss_qual_d1 | 
                                                 ifeterr_qual_d1);
   dff_s #(1) retre_ff(.din (retry_rdy_final_d1),
                     .q   (retry_rdy_e1),
                     .clk (clk), .se(se), .si(), .so());

   assign all_retry_rdy_e1 = {4{retry_rdy_e1}} & thr_e1;
   dff_s #(4) retrm_reg(.din (all_retry_rdy_e1),
                      .q   (all_retry_rdy_m1),
                     .clk (clk), .se(se), .si(), .so());
   
   assign ifq_dtu_thrrdy = mil_thr_ready | all_retry_rdy_m1;

//   assign retry_fetch_s1 = block_fetch_s1 & fcl_ifq_icmiss_s1 & 
//                           ~canthr_s1;
   dff_s #(1) cans_ff(.din (canthr_s1),
                    .q   (canthr_s1_del1),
                    .clk (clk), .se(se), .si(), .so());

   assign ifq_fcl_flush_sonly_e = (block_fetch_d1 & 
                                   (icmiss_qual_d1 & ~canthr_s1_del1 |
                                    ifeterr_qual_d1) & 
                                   ~canthr_d1 & ~itlberr_d1);

   // Determine which thread's MIL was hit, if at all
   // first check if this really was an imiss
   assign icmiss_for_milchk = thr_s1 & ~icmiss_thr_d & ~errthr_d1;
   assign icmiss_qual_s = (|icmiss_for_milchk[3:0]) & fcl_ifq_icmiss_s1 & 
                          ~dtu_ifq_kill_latest_d & ~erb_ifq_itlberr_s1;

   // since multiple requests can be outstanding when an error is
   // encountered, need to prioritise the mil hits.
   // TBD: there must be a cleaner way to do this!
   assign qualhit_pe_s[0] = qualhit_or_io_s[0];
   assign qualhit_pe_s[1] = ~qualhit_or_io_s[0] & qualhit_or_io_s[1];
   assign qualhit_pe_s[2] = ~qualhit_or_io_s[0] & ~qualhit_or_io_s[1] &
                             qualhit_or_io_s[2];
   assign qualhit_pe_s[3] = ~qualhit_or_io_s[0] & ~qualhit_or_io_s[1] &
                            ~qualhit_or_io_s[2] & qualhit_or_io_s[3];
   
   // A thread cannot hit on an MIL to the IOB
   assign milhit_to_thr_s = qualhit_pe_s & {4{icmiss_qual_s & 
                                                 ~ifd_ifc_newdestid_s[2]}};

   // Make Request to PCX if miss in Icache and MIL
   // determine if we need to send req to L2
//   assign newpcxreq_s = icmiss_for_milchk & ~fcl_ifq_canthr;
//   assign newreq_valid = fcl_ifq_icmiss_s1 & ~dtu_ifq_kill_latest_d & 
//	                       (newpcxreq_s[0] | 
//			                    newpcxreq_s[1] | 
//			                    newpcxreq_s[2] | 
//			                    newpcxreq_s[3]) & 
//                           (~any_milhit_s | ifd_ifc_newdestid_s[2]);

   assign newreq_valid = icmiss_qual_s &
                          (~any_milhit_s | ifd_ifc_newdestid_s[2]);

   // check if there are any old requests outstanding, that are not
   // current in  the D stage. 
   assign pcxreq_qual_s = pcxreq_s & ~(dpcxthr_d & {4{req_valid_d}});
   
//   assign reqq_empty = ~(|pcxreq_qual_s[3:0]);
//   assign oldpcxreq_s = pcxreq_qual_s & rr_gnt & ~fcl_ifq_canthr;
//   assign oldreq_valid = (|oldpcxreq_s);
//   assign oldpcxreq_s = pcxreq_qual_s & rr_gnt;   
   assign oldreq_valid = (|pcxreq_qual_s);
	  
   // Send out PCX request in round robin order if there are other
   // reqests pending.  If the request queue is empty send this req
//   assign nextreq_valid_s = ~reqq_empty | newreq_valid;
   
   assign nextreq_valid_s = oldreq_valid | newreq_valid | req_pending_d;

   assign rnd_reset = ifq_reset | ~gdbginit_l;
   
   // round robin assignment to pcx
   sparc_ifu_rndrob  pcxrndrob(.req_vec   (pcxreq_qual_s),
			                         .grant_vec (rr_gnt),
			                         .advance   (req_accept_d),
			                         .rst_tri_enable (rst_tri_en),
			                         .clk       (clk),
			                         .reset     (rnd_reset),
			                         .se  (se),
			                         .si (si),
			                         .so ());

   // if req queue is empty forward the new request to pcx
   // if not store it in the MIL
   assign dpcxthr_s  = req_pending_d ? dpcxthr_d :
	                     ~oldreq_valid ? thr_s1    : 
	                                     rr_gnt;
   dff_s #(4) pcxthr_ff(.din (dpcxthr_s),
		                  .clk (clk),
		                  .q   (dpcxthr_d),
		                  .se  (se), .si(), .so());

   assign thrid_d[0] = dpcxthr_d[3] | dpcxthr_d[1];
   assign thrid_d[1] = dpcxthr_d[3] | dpcxthr_d[2];
   dff_s #(2) tide_reg(.din (thrid_d),
                     .q   (thrid_e),
                     .clk (clk), .se(se), .si(), .so());
   assign ifc_ifd_thrid_e = thrid_e;
   
   // Determine the destination to which the request is made:
   mux4ds #(3) dest_mux(.dout (old_destid_s),
		                    .in0  (ifd_ifc_destid0[2:0]),
		                    .in1  (ifd_ifc_destid1[2:0]),
		                    .in2  (ifd_ifc_destid2[2:0]),
		                    .in3  (ifd_ifc_destid3[2:0]),
		                    .sel0 (rr_gnt[0]),
		                    .sel1 (rr_gnt[1]),
		                    .sel2 (rr_gnt[2]),
		                    .sel3 (rr_gnt[3]));
   
//   mux2ds #(3) fdest_mux(.dout (destid_s),
//		                     .in0  (ifd_ifc_newdestid_s),
//		                     .in1  (old_destid_s),
//		                     .sel0 (~oldreq_valid),
//		                     .sel1 (oldreq_valid));

//   assign destid_s  = req_pending_d ? ifu_lsu_destid_d    :
//	                    ~oldreq_valid ? ifd_ifc_newdestid_s : 
//	                                    old_destid_s;
   assign ifu_lsu_destid_s = oldreq_valid ? old_destid_s :
                                            ifd_ifc_newdestid_s;

   // remove this
   assign destid_iob_s  = req_pending_d ? destid_iob_d :
                                          ifu_lsu_destid_s[2];
   dff_s #(1) destd_reg(.din (destid_iob_s),
		                  .q   (destid_iob_d),
		                  .clk (clk), .se(se), .si(), .so());

   // If this is going to any L2 bank, zero out the line address 
   // for Rams 
   assign ifc_ifd_pcxline_adj_d[4:2] = ifd_ifc_pcxline_d[4:2] & 
                                       {3{destid_iob_d}};
   
   // advace req 
   dffr_s #(1) pcxreqvd_ff(.din  (nextreq_valid_s),
		                     .clk  (clk),
		                     .rst  (ifq_reset),
		                     .q    (req_valid_d),
		                     .se   (se), .si(), .so());

   assign ifu_lsu_pcxreq_d = req_valid_d;

//   assign req_pending_d = req_valid_d & ~can_pcx_d & ~lsu_ifu_pcxpkt_ack_d;
   assign req_pending_d = req_valid_d & ~(lsu_ifu_pcxpkt_ack_d & ~errinv_d1);
   assign req_accept_d = req_valid_d & lsu_ifu_pcxpkt_ack_d;
//   assign rr_advance_d = req_accept_d & ~errinv_d1

   // Signal to FSM if pcx request has been accepted by LSU
   assign pcx_accept_d = dpcxthr_d & {4{req_accept_d}};
   // Alternate implementation with canthr delayed by a cycle
//   assign pcxreq_vbit_d = req_valid_d & ~can_pcx_d;
//   assign pcx_accept_d = dpcxthr_d & {4{req_accept_d}} & ~fcl_ifq_canthr;

   // check if there was an error to this thread
   assign err_vec_d1 = dpcxthr_d & (errthr_d1 | err_req);
   assign errinv_d1 = (|err_vec_d1[3:0]);

   dff_s #(1) errinv_ff(.din (errinv_d1),
		                  .q   (ifc_ifd_errinv_e),
		                  .clk (clk), .se(se), .si(), .so());
   
   assign pcxreq_vbit_d = req_valid_d;   
   dff_s #(1) pcxreqve_ff(.din  (pcxreq_vbit_d),  // same as ifu_lsu_pcxreq_d
		                    .clk  (clk),
		                    .q    (ifc_ifd_reqvalid_e),
		                    .se   (se), .si(), .so());

//   dff #(1) pcxreqpe_ff(.din  (req_pending_d),
//		                    .clk  (clk),
//		                    .q    (req_pending_e),
//		                    .se   (se), .si(), .so());

   // advance pcx request if there is no prev request pending
   // the data is deliberately held valid for one extra cycle.  this
   // is legacy stuff.  LSU guarantees that the data is picked up
   // minimum 1 cycle after request is made. 
//   assign ifc_ifd_nxtpcx_sel_new_d = ~req_pending_e;
//   assign ifc_ifd_nxtpcx_sel_new_d = 1'b1;   

   // Select which MIL request to send out to PCX
   assign ifc_ifd_milreq_sel_d_l[0] = ~dpcxthr_d[0] & ~rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[1] = ~dpcxthr_d[1] | rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[2] = ~dpcxthr_d[2] | rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[3] = ~dpcxthr_d[3] | rst_tri_en;


//-----------------------------
// Invalidate Controls
//----------------------------
   assign stpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0100}) ? 1'b1 : 1'b0;
   assign strmack_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0110}) ? 1'b1 : 1'b0;
   assign evpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0011}) ? 1'b1 : 1'b0;
   assign ldpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0000}) ? 1'b1 : 1'b0;
   
   assign invalidate_i1 = (stpkt_i1 | strmack_i1 | evpkt_i1 | ldpkt_i1);
   assign ifu_lsu_inv_clear = ~(invalidate_i1 | inv_ifc_inv_pending);
//	 assign ifc_inv_wrreq_i2 = (imissrtn_i2 |
//                              asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                        mbist_icache_write);
   
//   assign wrt_en_wd0_i2 = inv_ifc_word0_inv_i2 & (stpkt_i2 | evpkt_i2) |
//                          ldinv_i2 & ~ifd_ifc_ldaddr5_i2 |
//		                      (imissrtn_i2 |
//                           asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                     mbist_icache_write) & 
//	                       ~ifd_ifc_missaddr5_i2;
//
//   assign wrt_en_wd1_i2 = inv_ifc_word1_inv_i2 & (stpkt_i2 | evpkt_i2) |
//			                      ldinv_i2 & ifd_ifc_ldaddr5_i2 |
//		                        (imissrtn_i2 |
//			                       asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                       mbist_icache_write) & 
//	                        ifd_ifc_missaddr5_i2;
   
   // calculate the ICV write data
   assign icv_wbit_i2 = imissrtn_i2 & ifc_ifd_filladdr4_i2 |
	                   asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 & 
	                   cpxreq_i2[2];
   
   assign icv_wrdata_i2 = ifc_inv_ifqadv_i2 ? icv_wbit_i2 : icv_wrdata_f;
   
//   mux2ds #(2) icv_damux(.dout (icv_wrdata_i2),
//		                     .in0  (icv_wrdata_f),
//		                     .in1  (icv_wbit_i2),
//		                     .sel0 (~ifc_inv_ifqadv_i2),
//		                     .sel1 (ifc_inv_ifqadv_i2));

   dff_s #(1) icv_daff(.din  (icv_wrdata_i2),
		                 .q    (icv_wrdata_f),
		                 .clk  (clk),
		                 .se   (se), .si(), .so());
   assign ifq_icv_wrdata_bf = icv_wrdata_i2;


// Begin ECO7010
   dp_mux2es #(1) wayvld_mux (.dout (inq_wayvld_i1_nxt),        //done
			      .in0 (lsu_ifu_cpxpkt_wayvld_i1),
			      .in1 (inq_wayvld_i1),
			      .sel(inq_vld));

   dff_s #(1) wayvld_ff (.din (inq_wayvld_i1_nxt),             //done
                       .q   (inq_wayvld_i1),
                       .clk (clk), .se(se), .si(), .so());
   
   assign ldinv_i1 = ldpkt_i1 & inq_wayvld_i1;  //done

   dp_mux2es #(1) ldinv_i2_mux (.dout (ldinv_i2_nxt),  //done
			      .in0 (ldinv_i1),
			      .in1 (ldinv_i2),
			      .sel(ifc_ifd_ifqbyp_en_l));

   dff_s #(1) ldinv_i2_ff (.din (ldinv_i2_nxt),   //done
			 .q   (ldinv_i2),
			 .clk (clk), .se(se), .si(), .so());   

//End ECO7010

//------------------------------------------------
// Fwd Request to read/write Icache
//------------------------------------------------
   // is this a fwd req to the L1I?
   assign fwdreq_i2 = (cpxreq_i2 == 4'b1010) ? 
                        (ifd_ifc_fwd2ic_i2 & ifd_ifc_4bpkt_i2 &
                         ifd_ifc_cpxvld_i2) : 1'b0;

   // detect first cycle of fwdpkt and stall
   assign fwd_stall = fwdreq_i2 & ~fwdreq_i3;
   
   dff_s #(1) freq_ff(.din (fwd_stall),
                    .q   (fwdreq_i3),
                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) cpx3_ff(.din (ifd_ifc_cpxnc_i2),
                    .q   (cpxnc_i3),
                    .clk (clk), .se(se), .si(), .so());

   // NC bit is also R/W_bar bit
   assign fwdrd_i3 = fwdreq_i3 & cpxnc_i3;
   assign fwdwr_i3 = fwdreq_i3 & ~cpxnc_i3;

   // ack back to the LSU to send fwd reply
   assign ifu_lsu_fwd_wr_ack = fwdwr_i3;
   assign ifc_ifd_idx_sel_fwd_i2 = fwdreq_i2;

   // let errctl know a fwd packet is coming
   assign ifq_erb_fwdrd_bf = fwdrd_i3;
   
//----------------------------------
// INQ controls -- now ibuf controls
//----------------------------------

// INQ removed 2/13/02   

   // Is the pkt in the inq a pkt that affects the icache?
   assign ic_pkt_i1 = invalidate_i1 | imissrtn_i1 | errpkt_i1;
   
//   assign inq_vld_nxt = ~inq_vld & ifd_ifc_cpxvalid_i1 & 
//	                      (~ifqadv_i1 | asireq_i1) | 
//	                      inq_vld & ((~ifqadv_i1 | asireq_i1) & ic_pkt_i1 |
//				                             ifd_ifc_cpxvalid_i1);

   // cut this down to 1 aoi gate
   assign inq_vld_nxt = (ifd_ifc_cpxvalid_i1 |
                         inq_vld & ic_pkt_i1) & (~ifqadv_i1 | ifu_asireq_i1);
   
   dffr_s #(1) inqv_ff(.din (inq_vld_nxt),
		                 .q   (inq_vld),
		                 .rst (ifq_reset),
		                 .clk (clk), .se(se), .si(), .so());

   assign ifc_ifd_ifqbyp_en_l = ~(ifqadv_i1 | fwd_stall);
   
   assign ifc_ifd_ifqbyp_sel_fwd_l = ~(fwd_stall & ~ifq_reset);
   assign ifc_ifd_ifqbyp_sel_asi_l = ~(~fwd_stall & ~ifq_reset & 
                                       ifu_asireq_i1);
   assign ifc_ifd_ifqbyp_sel_inq_l = ~(~fwd_stall & ~ifq_reset & 
                                       ~ifu_asireq_i1 & inq_vld);
   assign ifc_ifd_ifqbyp_sel_lsu_l = ~(~fwd_stall & ~ifu_asireq_i1 & 
                                       ~inq_vld | ifq_reset);

   assign byp_sel_asi_l = ~(ifqadv_i1 & ifu_asireq_i1);
   
//   assign ifu_lsu_ibuf_busy = inq_vld & (~ifqadv_i1 | asireq_i1);
//   assign ifc_ifd_ld_inq_i1 = ~inq_vld | ifqadv_i1 & ~asireq_i1;

   assign ifu_lsu_ibuf_busy = inq_vld;
   assign ifc_ifd_ld_inq_i1 = ~inq_vld;

//-----------------------------------------
// ASI access controls
//-----------------------------------------

   // need this to help with timing
   // - asi_vld is asserted only if the asi transaction is to an IFU asi
   //   register AND that register is not in the IMMU.
   // - it is held valid until an ack is signalled .
   // - the ack is not signalled for atleast 2 cycles
   assign asi_vld_next = lsu_ifu_asi_vld & byp_sel_asi_l & 
	                       ~asireq_i2 & ~illva_i2;  // not when ack is sent
   
   dff_s #(1) asiv0_ff(.din (asi_vld_next),
		                .q   (asi_vld_i0),
		                .clk (clk), .se(se), .si(), .so());
   assign asi_vld_qual_i0 = asi_vld_i0 & ~asireq_i2 & ~illva_i2 &
                            byp_sel_asi_l & ~illva_i1 &
                            lsu_ifu_asi_vld;

   dff_s #(8) asi_reg(.din (lsu_ifu_asi_state[7:0]),
		                .q   (asi_state_i1),
		                .clk (clk), .se(se), .si(), .so());

   dff_s #(2) asi_tid_reg(.din (lsu_ifu_asi_thrid[1:0]),
		                    .q   (ifq_fcl_asi_tid_bf[1:0]),
		                    .clk (clk), .se(se), .si(), .so());

//   assign ifu_lsu_asi_ack = ~byp_sel_asi_l;
   // Decided to wait one more cycle before sending the ack.
   assign ifu_lsu_asi_ack = asireq_i2 | illva_i2;   
   
   // ifu ASIs
   // icache data = 0x66
   assign asi_ic_data_unchk_i1 = ~asi_state_i1[7] & 
	        asi_state_i1[6] & 
	        asi_state_i1[5] & 
	        ~asi_state_i1[4] & 
	        ~asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_ic_data_i1 = asi_ic_data_unchk_i1;
   
   // icache tags = 0x67
   // writing to tag also writes to vbits
   assign asi_ic_tag_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_ic_tag_i1 = asi_ic_tag_unchk_i1;

   // error enable 0x4B
   assign asi_erren_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_erren_i1 =  asi_erren_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];
   
   // error status 0x4C
   assign asi_errstat_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      ~asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_errstat_i1 = asi_errstat_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // error addr 0x4D
   assign asi_erraddr_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      ~asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_erraddr_i1 =  asi_erraddr_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // error inject 0x43
   assign asi_errinj_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_errinj_i1 =  asi_errinj_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // imask 0x42, va=0x8
   assign asi_imask_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_imask_i1 = asi_imask_unchk_i1  &
          ~ifd_ifc_asi_vachklo_i2 &
          ifd_ifc_asiaddr_i2[2];  // this is actually va[3]

   // illegal va check
   assign illva_i0 = ((asi_erren_unchk_i1 |
                       asi_errstat_unchk_i1 |
                       asi_errinj_unchk_i1 |
                       asi_erraddr_unchk_i1) & (ifd_ifc_asi_vachklo_i2 |
                                                ifd_ifc_asiaddr_i2[2])) &
                       asi_vld_qual_i0;

   dff_s #(1) illvai1_ff(.din (illva_i0),
                       .q   (illva_i1),
                       .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvabf_ff(.din (illva_i1),
                     .q   (illva_i2),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvaf_ff(.din (illva_i2),
                     .q   (illva_f),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvas_ff(.din (illva_f),
                      .q   (illva_s),
                      .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvaw2_ff(.din (illva_s),
                       .q   (illva_w2),
                       .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_illgl_va_w2 = illva_w2;

   dff_s #(1) tagasi_ff(.din (asi_ic_tag_i1),
		                  .q   (asi_ic_tag_i2),
		                  .clk (clk), .se(se), .si(), .so());
   dff_s #(1) datasi_ff(.din (asi_ic_data_i1),
		                  .q   (asi_ic_data_i2),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asieeni2_ff(.din (asi_erren_i1),
		                    .q   (ifq_erb_asi_erren_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asieini2_ff(.din (asi_errinj_i1),
		                    .q   (ifq_erb_asi_errinj_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asiesti2_ff(.din (asi_errstat_i1),
		                    .q   (ifq_erb_asi_errstat_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asieadi2_ff(.din (asi_erraddr_i1),
		                    .q   (ifq_erb_asi_erraddr_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) imaski2_ff(.din (asi_imask_i1),
		                   .q   (ifq_erb_asi_imask_i2),
		                   .clk (clk), .se(se), .si(), .so());

   // All IFU asi requests
   assign ifu_asireq_i0 = (asi_ic_tag_i1 | asi_ic_data_i1 | asi_erren_i1 |
		                       asi_errinj_i1 | asi_errstat_i1 | asi_erraddr_i1 |
		                       asi_imask_i1) & asi_vld_qual_i0;

   dff_s #(1) asireq1_ff(.din  (ifu_asireq_i0),
		                   .q    (ifu_asireq_i1),
		                   .clk  (clk), .se(se), .si(), .so());
   
   dff_s #(1) asivld_ff(.din  (byp_sel_asi_l),
		                  .q    (asireq_i2_l),
		                  .clk  (clk), .se(se), .si(), .so());
   assign asireq_i2 = ~asireq_i2_l;
   assign ifc_inv_asireq_i2 = asireq_i2;

   // Stall if we are doing an asi op or fwdreq
  assign stallreq_d0 = (ifu_asireq_i0 | 
                         ~byp_sel_asi_l |
                         fwdreq_i2) | 
                          starv_alert | 
                          mbist_ifq_run_bist |
	                  ldinv_i1 & ~ifqadv_i1 |        //ECO 7010
                  	  ldinv_i2 & ~ifc_inv_ifqadv_i2; //ECO 7010

   dff_s #(1) stal_ff(.din (stallreq_d0),
                    .q   (stallreq_d1),
                    .clk (clk), .se(se), .si(), .so());

   // split into two to save repeater
   assign ifq_fcl_stallreq = stallreq_d1;
   assign ifq_swl_stallreq = stallreq_d1;

   dff_s #(1) asil1_ff(.din (lsu_ifu_asi_load),
		                 .q   (asi_load_i1),
		                 .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asil2_ff(.din (asi_load_i1),
		                 .q   (asi_load_i2),
		                 .clk (clk), .se(se), .si(), .so());

   // insert parity error in data and/or tag
   // Don't need to qualify with asireq and imissrtn...
   //   -- moved this to the DP since the qual is not necessary
//   assign ifc_ifd_insert_pe = (asireq_i2 | imissrtn_i2) & 
//				ifd_ifc_cpxue_i2;

   // decode asi
   // generate word selects
   // can use finst instead of word_sel_i2, but it screws up timing
   
   assign word_sel_i2[0] = ~ifd_ifc_asiaddr_i2[3] & ~ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[1] = ~ifd_ifc_asiaddr_i2[3] &  ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[2] =  ifd_ifc_asiaddr_i2[3] & ~ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[3] =  ifd_ifc_asiaddr_i2[3] &  ifd_ifc_asiaddr_i2[2];

   // this assumes asi requests are never stalled
   assign ifq_icd_worden_bf = (word_sel_i2 | {4{~asireq_i2 & ~fwdwr_i3  |
//                                                ~ifc_inv_ifqadv_i2 | 
                                                mbist_icache_write}});
// & (mbist_icache_worden | {4{~bist_op}});

   // choose where the ic address should come from
//   assign bist_op = (mbist_icache_read | mbist_icache_write);
   dff_s #(1) bist_run_ff(.din (mbist_ifq_run_bist),
                        .q   (bist_op),
                        .clk (clk), .se(se), .si(), .so());
   
   assign ifc_ifd_addr_sel_bist_i2_l = ~bist_op | sehold;
   assign ifc_ifd_addr_sel_old_i2_l = (bist_op | ifc_inv_ifqadv_i2) & ~sehold;
   assign ifc_ifd_addr_sel_asi_i2_l = bist_op | ~ifc_inv_ifqadv_i2 | 
                                      sehold | ~(asireq_i2 | fwdreq_i3);
   assign ifc_ifd_addr_sel_fill_i2_l = bist_op | ~ifc_inv_ifqadv_i2 | 
                                       sehold | asireq_i2 | fwdreq_i3;

   // choose where the data should come from
   assign ifq_icd_data_sel_bist_i2 = mbist_icache_write & ~sehold;
   assign ifq_icd_data_sel_fill_i2 = ~mbist_icache_write & ifc_inv_ifqadv_i2 &
                                     ~sehold;
   assign ifq_icd_data_sel_old_i2 = ~mbist_icache_write & ~ifc_inv_ifqadv_i2 |
                                     sehold;
   
   // generate icache controls
   assign ifq_fcl_rdreq_bf = asireq_i2 & asi_load_i2 & 
	                           (asi_ic_data_i2 | asi_ic_tag_i2) |
	                           mbist_icache_read |
                             fwdrd_i3;

   assign ifq_fcl_icd_wrreq_bf = asi_ic_data_i2 & asireq_i2 & ~asi_load_i2 |
	                               mbist_icache_write |
                                 fwdwr_i3;

   assign ifq_fcl_ictv_wrreq_bf = asi_ic_tag_i2 & asireq_i2 & ~asi_load_i2;

   assign rd_tag_bf = asi_ic_tag_i2 & asi_load_i2;
   dff_s #(1) asi_srcf_ff(.din (rd_tag_bf),
		               .q   (ifq_erb_rdtag_f),
		               .clk (clk), .se(se), .si(), .so());
   
   assign rdinst_bf = asi_ic_data_i2 & asi_load_i2;
   dff_s #(1) asi_inst_ff(.din (rdinst_bf),
		               .q   (ifq_erb_rdinst_f),
		               .clk (clk), .se(se), .si(), .so());

   assign asird_i1 = asi_load_i1 & (~byp_sel_asi_l | illva_i1);
   dff_s #(1) asirdq_ff(.din (asird_i1),
                      .q   (ifq_fcl_asird_bf),
                      .clk (clk), .se(se), .si(), .so());

   assign ifq_erb_asiwr_i2 = ~asi_load_i2 & asireq_i2;



   // Shadow scan mux
   mux4ds #(4) milss_mux(.dout (ifq_sscan_data[3:0]),
                         .in0  (mil0_state),
                         .in1  (mil1_state),
                         .in2  (mil2_state),
                         .in3  (mil3_state),
                         .sel0 (ctu_sscan_tid[0]),
                         .sel1 (ctu_sscan_tid[1]),
                         .sel2 (ctu_sscan_tid[2]),
                         .sel3 (ctu_sscan_tid[3]));
   

   
endmodule // sparc_ifu_ifqctl

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_ifqdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqdp
//  Description:
//  The IFQ is the icache fill queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.
//
*/

//FPGA_SYN enables all FPGA related modifications





////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module sparc_ifu_ifqdp(/*AUTOARG*/
   // Outputs
   
   ifu_lsu_pcxcsm_e,
   

   so, ifu_lsu_pcxpkt_e, ifq_fdp_fill_inst, ifq_erb_asidata_i2,
   ifd_inv_ifqop_i2, ifq_icd_index_bf, ifq_icd_wrdata_i2,
   ifq_ict_wrtag_f, ifq_ict_wrtag_bf, ifq_erb_wrindex_f, ifq_icd_wrway_bf,
   ifd_ifc_milhit_s, ifd_ifc_instoffset0, ifd_ifc_instoffset1,
   ifd_ifc_instoffset2, ifd_ifc_instoffset3, ifd_ifc_cpxthr_nxt,
   ifd_ifc_cpxreq_nxt, ifd_ifc_cpxreq_i1, ifd_ifc_destid0,
   ifd_ifc_destid1, ifd_ifc_destid2, ifd_ifc_destid3,
   ifd_ifc_newdestid_s, ifd_ifc_pcxline_d, ifd_ifc_asi_vachklo_i2,
   ifd_ifc_cpxvld_i2, ifd_ifc_asiaddr_i2, ifd_ifc_iobpkt_i2,
   ifd_ifc_fwd2ic_i2, ifd_ifc_4bpkt_i2, ifd_ifc_cpxnc_i2,
   ifd_ifc_cpxce_i2, ifd_ifc_cpxue_i2, ifd_ifc_cpxms_i2,
   ifd_ifc_miladdr4_i2, ifd_inv_wrway_i2, ifq_fdp_fill_paddr,
   // Inputs
   
   itlb_ifq_csm_s,
   

   rclk, se, si, lsu_ifu_cpxpkt_i1, lsu_ifu_asi_addr,
   lsu_ifu_stxa_data, itlb_ifq_paddr_s, fdp_ifq_paddr_f,
   ifc_ifd_reqvalid_e, ifc_ifd_filladdr4_i2, ifc_ifd_repway_s,
   ifc_ifd_uncached_e, ifc_ifd_thrid_e, ifc_ifd_pcxline_adj_d,
   ifc_ifd_errinv_e, ifc_ifd_ldmil_sel_new, ifc_ifd_ld_inq_i1,
   ifc_ifd_idx_sel_fwd_i2, ifc_ifd_milreq_sel_d_l,
   ifc_ifd_milfill_sel_i2_l, ifc_ifd_finst_sel_l,
   ifc_ifd_ifqbyp_sel_fwd_l, ifc_ifd_ifqbyp_sel_inq_l,
   ifc_ifd_ifqbyp_sel_asi_l, ifc_ifd_ifqbyp_sel_lsu_l,
   ifc_ifd_ifqbyp_en_l, ifc_ifd_addr_sel_bist_i2_l,
   ifc_ifd_addr_sel_asi_i2_l, ifc_ifd_addr_sel_old_i2_l,
   ifc_ifd_addr_sel_fill_i2_l, mbist_icache_way, mbist_icache_word,
   mbist_icache_index
   );

   input 	 rclk,
           se,
           si;

   input [145-1:0] lsu_ifu_cpxpkt_i1;
   input [17:0]   lsu_ifu_asi_addr;
   input [47:0]   lsu_ifu_stxa_data;

   input [39:10]  itlb_ifq_paddr_s;
   input [9:2]    fdp_ifq_paddr_f;

   // from ifqctl
   input         ifc_ifd_reqvalid_e;
   input         ifc_ifd_filladdr4_i2;
   input [1:0]   ifc_ifd_repway_s;
   input         ifc_ifd_uncached_e;
   input [1:0]   ifc_ifd_thrid_e;
   input [4:2]   ifc_ifd_pcxline_adj_d;

   input         ifc_ifd_errinv_e;

   // 2:1 mux selects
   input [3:0]   ifc_ifd_ldmil_sel_new;  // mil load enable

   input        ifc_ifd_ld_inq_i1;        // ld new cpxreq to in buffer
   input        ifc_ifd_idx_sel_fwd_i2;

   // other mux selects
   input [3:0]  ifc_ifd_milreq_sel_d_l,   // selects outgoing mil_req
		            ifc_ifd_milfill_sel_i2_l; // selects the mil entry just
	 // returned from the fill
	 // port
   input [3:0]  ifc_ifd_finst_sel_l;    // address to load to thr IR

   input        ifc_ifd_ifqbyp_sel_fwd_l, // select next input to process
		            ifc_ifd_ifqbyp_sel_inq_l,
		            ifc_ifd_ifqbyp_sel_asi_l,
		            ifc_ifd_ifqbyp_sel_lsu_l;
	 input        ifc_ifd_ifqbyp_en_l;

   input        ifc_ifd_addr_sel_bist_i2_l,
		            ifc_ifd_addr_sel_asi_i2_l,
                ifc_ifd_addr_sel_old_i2_l,
		            ifc_ifd_addr_sel_fill_i2_l;

   input [1:0]  mbist_icache_way;
   input        mbist_icache_word;
   input [7:0]  mbist_icache_index;
   
   input [32:0]    itlb_ifq_csm_s;

   output [32:0]   ifu_lsu_pcxcsm_e;
   

   output       so;

   output [51:0] ifu_lsu_pcxpkt_e;

   output [32:0] ifq_fdp_fill_inst;
   output [47:0] ifq_erb_asidata_i2;

   output [145-1:0] ifd_inv_ifqop_i2;

   output [(6 + 5):2]  ifq_icd_index_bf;   // index for wr and bist

   output [135:0]         ifq_icd_wrdata_i2;
   output [(39 - (6 + 5)):0]  ifq_ict_wrtag_f;      // fill tag
   output [(39 - (6 + 5)):0]  ifq_ict_wrtag_bf;      // fill tag
//   output [`IC_TAG_SZ-1:0] ifq_erb_wrtag_f;      // tag w/o parity
   output [(6 + 5):4]   ifq_erb_wrindex_f;
   output [1:0]            ifq_icd_wrway_bf;     // fill data way

   output [3:0]           ifd_ifc_milhit_s;     // if an Imiss hits in MIL
//   output [7:0]           ifd_ifc_mil_repway_s;

   output [1:0]           ifd_ifc_instoffset0;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset1;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset2;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset3;   // to select inst to TIR

   output [1:0]            ifd_ifc_cpxthr_nxt;
   output [3:0]            ifd_ifc_cpxreq_nxt;    // cpx reqtype + vbit
   output [(143 - 140 + 1):0] ifd_ifc_cpxreq_i1;    // cpx reqtype + vbit


   output [2:0]            ifd_ifc_destid0,
		                       ifd_ifc_destid1,
		                       ifd_ifc_destid2,
		                       ifd_ifc_destid3,
		                       ifd_ifc_newdestid_s;

   output [4:2]            ifd_ifc_pcxline_d;

   output                  ifd_ifc_asi_vachklo_i2;

   output                  ifd_ifc_cpxvld_i2;
   output [3:2]            ifd_ifc_asiaddr_i2;
   output                  ifd_ifc_iobpkt_i2;
   output                  ifd_ifc_fwd2ic_i2;
   output                  ifd_ifc_4bpkt_i2;
   output                  ifd_ifc_cpxnc_i2;
   output                  ifd_ifc_cpxce_i2,
		                       ifd_ifc_cpxue_i2,
                           ifd_ifc_cpxms_i2;

   output [3:0]            ifd_ifc_miladdr4_i2;

   output [1:0]            ifd_inv_wrway_i2;

   output [39:2]           ifq_fdp_fill_paddr;

   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------

   // local signals
   wire [39:0]             imiss_paddr_s;
   wire [9:2]              lcl_paddr_s;

   wire [42:2]             mil_entry0,         // mil entries
		                       mil_entry1,
		                       mil_entry2,
		                       mil_entry3;


   
   wire [32:0]          mil_csm_entry0;
   wire [32:0]          mil_csm_entry1;
   wire [32:0]          mil_csm_entry2;
   wire [32:0]          mil_csm_entry3;
   
    wire [32:0]          mil_csm_pcxreq_d;

   
//   wire [42:2]             mil0_in_s,          // inputs to mil
//		                       mil1_in_s,
//		                       mil2_in_s,
//		                       mil3_in_s;

   wire                    tag_par_s,
		                       tag_par_i2;

   wire [42:2]             newmil_entry_s;

   wire [42:2]             mil_pcxreq_d,        // outgoing request from mil
		                       pcxreq_d,            // mil or direct ic or prev req
		                       pcxreq_e;          // outgoing request to lsu

   wire [42:2]             fill_addr_i2,
		                       fill_addr_adj,
		                       icaddr_i2,
		                       asi_addr_i2,
		                       bist_addr_i2;

   wire [42:4]             wraddr_f;


   wire [145-1:0]   inq_cpxpkt_i1,   // output from inq
//			                     inq_cpxpkt_nxt,
			                     stxa_data_pkt,
                           fwd_data_pkt,
			                     ifqop_i1,
			                     ifqop_i2;        // ifq op currently being processed

   wire [3:0]              swc_i2;

   wire [135:0]            icdata_i2;

   wire [3:0]              parity_i2,
		                       par_i2;

   wire [17:0]             asi_va_i2,
                           asi_va_i1;
   wire [13:2]             asi_fwd_index;
   wire                    clk;


//   wire [`IC_IDX_HI:6]     inv_addr_i2;

   //
   // Code start here
   //

   assign                  clk = rclk;

   //----------------------------------------------------------------------
   // Instruction Miss - Fill Request Datapath
   //----------------------------------------------------------------------

   // new set of flops
   dff_s #(8) pcs_reg(.din (fdp_ifq_paddr_f[9:2]),
                    .q   (lcl_paddr_s[9:2]),
                    .clk (clk), .se(se), .si(), .so());


   // bits 1:0 are floating
   assign  imiss_paddr_s = {itlb_ifq_paddr_s[39:10],
                            lcl_paddr_s[9:2],
                            2'b0};

   // Check for hit in MIL
   // Should we enable the comps to save power? -- timing problem

   // compare only top 35 bits (bot 5 bits are line offset of 32B line)
   sparc_ifu_cmp35 milcmp0 (.hit (ifd_ifc_milhit_s[0]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry0[39:5]),
			                      .valid (1'b1)
			                      );

   sparc_ifu_cmp35 milcmp1 (.hit (ifd_ifc_milhit_s[1]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry1[39:5]),
			                      .valid (1'b1)
			                      );

   sparc_ifu_cmp35 milcmp2 (.hit (ifd_ifc_milhit_s[2]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry2[39:5]),
			                      .valid (1'b1)
			                      );
   sparc_ifu_cmp35 milcmp3 (.hit (ifd_ifc_milhit_s[3]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry3[39:5]),
			                      .valid (1'b1)
			                      );

   // Send replacement way to ctl logic
//   assign  ifd_ifc_mil_repway_s =  {mil_entry3[41:40],
//	                                  mil_entry2[41:40],
//	                                  mil_entry1[41:40],
//	                                  mil_entry0[41:40]};


   // calculate tag parity
   sparc_ifu_par32 tag_par(.in  ({{(32 - (39 - (6 + 5))){1'b0}},
                                  imiss_paddr_s[39:((6 + 5) + 1)]}),
			                     .out (tag_par_s));


   // Missed Instruction List
   // 43    - NOT cacheable
   // 42    - tag parity
   // 41:40 - repl way
   // 39:0  - paddr

   // Prepare Missed Instruction List entry
   assign  newmil_entry_s = {tag_par_s,
			                       ifc_ifd_repway_s,
			                       imiss_paddr_s[39:2]};

   // ldmil_sel is thr_s[3:0] & imiss_s
//   dp_mux2es  #(41)    milin_mux0(.dout (mil0_in_s),
//				                          .in0  (mil_entry0),
//				                          .in1  (newmil_entry_s),
//				                          .sel  (ifc_ifd_ldmil_sel_new[0]));
//   dp_mux2es  #(41)    milin_mux1(.dout (mil1_in_s),
//				                        .in0  (mil_entry1),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[1]));
//   dp_mux2es  #(41)    milin_mux2(.dout (mil2_in_s),
//				                        .in0  (mil_entry2),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[2]));
//   dp_mux2es  #(41)    milin_mux3(.dout (mil3_in_s),
//				                        .in0  (mil_entry3),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[3]));

   wire    clk_mil0;


   bw_u1_ckenbuf_6x  ckenmil0(.rclk (rclk),
                              .clk  (clk_mil0),
                              .en_l (~ifc_ifd_ldmil_sel_new[0]),
                              .tm_l (~se));

   wire    clk_mil1;


   bw_u1_ckenbuf_6x  ckenmil1(.rclk (rclk),
                              .clk  (clk_mil1),
                              .en_l (~ifc_ifd_ldmil_sel_new[1]),
                              .tm_l (~se));

   wire    clk_mil2;


   bw_u1_ckenbuf_6x  ckenmil2(.rclk (rclk),
                              .clk  (clk_mil2),
                              .en_l (~ifc_ifd_ldmil_sel_new[2]),
                              .tm_l (~se));

   wire    clk_mil3;


   bw_u1_ckenbuf_6x  ckenmil3(.rclk (rclk),
                              .clk  (clk_mil3),
                              .en_l (~ifc_ifd_ldmil_sel_new[3]),
                              .tm_l (~se));









   dff_s #(41)   mil0(.din  (newmil_entry_s),
		                .clk  (clk_mil0),
		                .q    (mil_entry0),
		                .se   (se), .si(), .so());








   dff_s #(41)   mil1(.din (newmil_entry_s),
		                .clk (clk_mil1),
		                .q   (mil_entry1),
		                .se  (se), .si(), .so());








   dff_s #(41)   mil2(.din (newmil_entry_s),
		                .clk (clk_mil2),
		                .q   (mil_entry2),
		                .se  (se), .si(), .so());








   dff_s #(41)   mil3(.din (newmil_entry_s),
		                .clk (clk_mil3),
		                .q   (mil_entry3),
		                .se  (se), .si(), .so());











   dff_s #(33)   milcsm0(.din  (itlb_ifq_csm_s),
		                .clk  (clk_mil0),
		                .q    (mil_csm_entry0),
		                .se   (se), .si(), .so());








   dff_s #(33)   milcsm1(.din (itlb_ifq_csm_s),
		                .clk (clk_mil1),
		                .q   (mil_csm_entry1),
		                .se  (se), .si(), .so());








   dff_s #(33)   milcsm2(.din (itlb_ifq_csm_s),
		                .clk (clk_mil2),
		                .q   (mil_csm_entry2),
		                .se  (se), .si(), .so());








   dff_s #(33)   milcsm3(.din (itlb_ifq_csm_s),
		                .clk (clk_mil3),
		                .q   (mil_csm_entry3),
		                .se  (se), .si(), .so());





   assign  ifd_ifc_newdestid_s = {imiss_paddr_s[39],
				                          imiss_paddr_s[7:6]};
   assign  ifd_ifc_destid0 = {mil_entry0[39],
			                        mil_entry0[7:6]};
   assign  ifd_ifc_destid1 = {mil_entry1[39],
			                        mil_entry1[7:6]};
   assign  ifd_ifc_destid2 = {mil_entry2[39],
			                        mil_entry2[7:6]};
   assign  ifd_ifc_destid3 = {mil_entry3[39],
			                        mil_entry3[7:6]};

   assign  ifd_ifc_instoffset0 = mil_entry0[3:2];
   assign  ifd_ifc_instoffset1 = mil_entry1[3:2];
   assign  ifd_ifc_instoffset2 = mil_entry2[3:2];
   assign  ifd_ifc_instoffset3 = mil_entry3[3:2];


   // MIL Request Out mux
   dp_mux4ds  #(41)  milreq_mux (.dout (mil_pcxreq_d),
			                         .in0  ({mil_entry0[42:2]}),
			                         .in1  ({mil_entry1[42:2]}),
			                         .in2  ({mil_entry2[42:2]}),
			                         .in3  ({mil_entry3[42:2]}),
			                         .sel0_l  (ifc_ifd_milreq_sel_d_l[0]),
			                         .sel1_l  (ifc_ifd_milreq_sel_d_l[1]),
			                         .sel2_l  (ifc_ifd_milreq_sel_d_l[2]),
			                         .sel3_l  (ifc_ifd_milreq_sel_d_l[3]));


   dp_mux4ds  #(33)  milreq_csm_mux (.dout (mil_csm_pcxreq_d),
			                         .in0  ({mil_csm_entry0[32:0]}),
			                         .in1  ({mil_csm_entry1[32:0]}),
			                         .in2  ({mil_csm_entry2[32:0]}),
			                         .in3  ({mil_csm_entry3[32:0]}),
			                         .sel0_l  (ifc_ifd_milreq_sel_d_l[0]),
			                         .sel1_l  (ifc_ifd_milreq_sel_d_l[1]),
			                         .sel2_l  (ifc_ifd_milreq_sel_d_l[2]),
			                         .sel3_l  (ifc_ifd_milreq_sel_d_l[3]));




   // Next PCX Request Mux
//   dp_mux3ds  #(44)  nxtpcx_mux (.dout  (pcxreq_d),
//			                         .in0   (mil_pcxreq_d),
//			                         .in1   (44'bx),
//			                         .in2   (pcxreq_e),
//			                         .sel0_l  (ifc_ifd_nxtpcx_sel_new_d_l),
//			                         .sel1_l  (ifc_ifd_nxtpcx_sel_err_d_l),
//			                         .sel2_l  (ifc_ifd_nxtpcx_sel_prev_d_l));


   // TBD: If destid == any L2 bank, need to zero out bit 4 for Rams
   //    -- done
   assign  ifd_ifc_pcxline_d[4:2] = mil_pcxreq_d[4:2];

   assign  pcxreq_d[42:5] = mil_pcxreq_d[42:5];
   assign  pcxreq_d[4:2] = ifc_ifd_pcxline_adj_d[4:2];
//   assign  pcxreq_d[1:0] = mil_pcxreq_d[1:0];  // dont need this

   dff_s #(41) pcxreq_reg (.din  (pcxreq_d),
			                    .clk  (clk),
			                    .q    (pcxreq_e),
			                    .se   (se), .si(), .so());

// CHANGE to regular dff
//   dffe #(44) pcxreq_reg (.din  (pcxreq_d),
//			                    .clk  (clk),
//			                    .q    (pcxreq_e),
//                          .en   (ifc_ifd_nxtpcx_sel_new_d),
//			                    .se   (se), .si(), .so());

   // PCX Req Reg -- req type is 5 bits
   assign   ifu_lsu_pcxpkt_e = {ifc_ifd_reqvalid_e,   // 51    - valid
			                          ifc_ifd_errinv_e,     // 50 - inv all ways
                                ifc_ifd_uncached_e,   // 49 - not cacheable
			                          {5'b10000},          // 48:44 - req type
			                          pcxreq_e[41:40],      // 43:42 - rep way
			                          ifc_ifd_thrid_e[1:0], // 41:40 - thrid
			                          pcxreq_e[39:2],       // 39:2  - word address
			                          2'b0};                // force to zero




dff_s #(33) pcxreq_csm2_reg (.din  (mil_csm_pcxreq_d),
                                         .clk  (clk),
                                         .q    (ifu_lsu_pcxcsm_e),
                                         .se   (se), .si(), .so());




   //----------------------------------------------------------------------
   // Fill Return Address
   //----------------------------------------------------------------------

   // MIL Fill Return Mux
   dp_mux4ds  #(41)  milfill_mux(.dout (fill_addr_i2),
			                         .in0 ( mil_entry0),
			                         .in1 ( mil_entry1),
			                         .in2 ( mil_entry2),
			                         .in3 ( mil_entry3),
			                         .sel0_l (ifc_ifd_milfill_sel_i2_l[0]),
			                         .sel1_l (ifc_ifd_milfill_sel_i2_l[1]),
			                         .sel2_l (ifc_ifd_milfill_sel_i2_l[2]),
			                         .sel3_l (ifc_ifd_milfill_sel_i2_l[3]));

   assign   ifd_ifc_miladdr4_i2[3:0]  = {mil_entry3[4],
                                         mil_entry2[4],
                                         mil_entry1[4],
                                         mil_entry0[4]};

   assign   ifd_ifc_iobpkt_i2 = fill_addr_i2[39];
   assign   fill_addr_adj = {fill_addr_i2[42:5],
			                       ifc_ifd_filladdr4_i2,
			                       fill_addr_i2[3:2]};
   // determine if this is cacheable in I$
   // moved to ifqctl
//   assign   ifd_ifc_uncached_i2 = fill_addr_i2[43];

   // merged with addren mux to save some timing
   dp_mux4ds #(41) icadr_mux(.dout (icaddr_i2),
			                       .in0  (fill_addr_adj),
			                       .in1  (asi_addr_i2),
			                       .in2  (bist_addr_i2),
                             .in3  ({wraddr_f[42:4], 2'b0}),
			                       .sel0_l (ifc_ifd_addr_sel_fill_i2_l),
			                       .sel1_l (ifc_ifd_addr_sel_asi_i2_l),
			                       .sel2_l (ifc_ifd_addr_sel_bist_i2_l),
                             .sel3_l (ifc_ifd_addr_sel_old_i2_l));

   // Paddr for fetch datapath
   assign ifq_fdp_fill_paddr = icaddr_i2[39:2];

   // way, 32B line sel
   assign ifd_inv_wrway_i2 =  icaddr_i2[41:40];

//   dp_mux2es  #(39)  addren_mux(.dout (wraddr_i2),
//			                        .in0  (wraddr_f),
//			                        .in1  (icaddr_i2[42:4]),
//			                        .sel  (ifc_ifd_ifqadv_i2));


   dff_s #(39) wraddr_reg(.din  (icaddr_i2[42:4]),
		                    .clk  (clk),
		                    .q    (wraddr_f[42:4]),
		                    .se   (se), .si(), .so());

   // tag = parity bit + `IC_TAG_SZ bits of address
   assign  ifq_erb_wrindex_f = wraddr_f[(6 + 5):4];
   assign  ifq_ict_wrtag_f = {wraddr_f[42], wraddr_f[39:((6 + 5) + 1)]};
   assign  ifq_ict_wrtag_bf = {icaddr_i2[42], icaddr_i2[39:((6 + 5) + 1)]};

   assign  ifq_icd_index_bf = icaddr_i2[(6 + 5):2];
   assign  ifq_icd_wrway_bf = icaddr_i2[41:40];

   //----------------------------------------------------------------------
   // Fill Return Data
   //----------------------------------------------------------------------
   // IFQ-IBUF
   // inq is the same size as the cpx_width
   // inq is replaced with a single flop, ibuf

   // ibuf enable mux
//   dp_mux2es  #(`CPX_WIDTH)  ifqen_mux(.dout (inq_cpxpkt_nxt),
//				                             .in0 (inq_cpxpkt_i1),
//				                             .in1 (lsu_ifu_cpxpkt_i1),
//				                             .sel (ifc_ifd_ld_inq_i1));

   wire    clk_ibuf1;


   bw_u1_ckenbuf_6x  ckenibuf(.rclk (rclk),
                              .clk  (clk_ibuf1),
                              .en_l (~ifc_ifd_ld_inq_i1),
                              .tm_l (~se));








   dff_s #(145) ibuf(.din (lsu_ifu_cpxpkt_i1),
			                  .q   (inq_cpxpkt_i1),
			                  .clk (clk_ibuf1),
			                  .se  (se), .si(), .so());


   assign  ifd_ifc_cpxreq_i1 = {inq_cpxpkt_i1[144],
			                          inq_cpxpkt_i1[143:140]};

   // ifq operand bypass mux
   // fill pkt is 128d+2w+2t+3iw+1v+1nc+4r = 140
   dp_mux4ds  #(145)  ifq_bypmux(.dout (ifqop_i1),
				                              .in0 (fwd_data_pkt),
				                              .in1 (inq_cpxpkt_i1),
				                              .in2 (stxa_data_pkt),
				                              .in3 (lsu_ifu_cpxpkt_i1),
				                              .sel0_l (ifc_ifd_ifqbyp_sel_fwd_l),
				                              .sel1_l (ifc_ifd_ifqbyp_sel_inq_l),
				                              .sel2_l (ifc_ifd_ifqbyp_sel_asi_l),
				                              .sel3_l (ifc_ifd_ifqbyp_sel_lsu_l));

   wire    clk_ifqop;


   bw_u1_ckenbuf_6x  ckenifop(.rclk (rclk),
                              .clk  (clk_ifqop),
                              .en_l (ifc_ifd_ifqbyp_en_l),
                              .tm_l (~se));








   dff_s #(145)  ifqop_reg(.din (ifqop_i1),
			                        .q   (ifqop_i2),
			                        .clk (clk_ifqop),
			                        .se  (se), .si(), .so());

   assign  ifd_inv_ifqop_i2 = ifqop_i2;

   // switch condition pre decode
   sparc_ifu_swpla  swpla0(.in  (ifqop_i2[31:0]),
			                     .out (swc_i2[0]));
   sparc_ifu_swpla  swpla1(.in  (ifqop_i2[63:32]),
			                     .out (swc_i2[1]));
   sparc_ifu_swpla  swpla2(.in  (ifqop_i2[95:64]),
			                     .out (swc_i2[2]));
   sparc_ifu_swpla  swpla3(.in  (ifqop_i2[127:96]),
			                     .out (swc_i2[3]));

   // Add Parity to each inst.
   sparc_ifu_par32 par0(.in  (ifqop_i2[31:0]),
			                  .out (par_i2[0]));
   sparc_ifu_par32 par1(.in  (ifqop_i2[63:32]),
			                  .out (par_i2[1]));
   sparc_ifu_par32 par2(.in  (ifqop_i2[95:64]),
			                  .out (par_i2[2]));
   sparc_ifu_par32 par3(.in  (ifqop_i2[127:96]),
			                  .out (par_i2[3]));

   // add 8 xor gates in the dp
   //   assign parity_i2 = par_i2 ^ swc_i2 ^ {4{ifc_ifd_insert_pe}};
   //   assign tag_par_i2 = par_i2[0] ^ ifc_ifd_insert_pe;

   // Make the par32 cell above, par33 and include cpxue_i2
   assign   parity_i2 = par_i2 ^ swc_i2 ^ {4{ifd_ifc_cpxue_i2}};
   assign   tag_par_i2 = par_i2[0] ^ ifd_ifc_cpxue_i2;

   // parity, swc, inst[31:0]
   assign   icdata_i2 = {parity_i2[3], ifqop_i2[127:96], swc_i2[3],
		                     parity_i2[2], ifqop_i2[95:64],  swc_i2[2],
		                     parity_i2[1], ifqop_i2[63:32],  swc_i2[1],
		                     parity_i2[0], ifqop_i2[31:0],   swc_i2[0]};

   // write data to icache
   assign ifq_icd_wrdata_i2 = icdata_i2;


   // very critical
   assign ifd_ifc_cpxreq_nxt   = ifqop_i1[143:140];
   assign ifd_ifc_cpxthr_nxt   = ifqop_i1[135:134];

   assign ifd_ifc_cpxvld_i2   = ifqop_i2[144];
   assign ifd_ifc_4bpkt_i2    = ifqop_i2[130];
   assign ifd_ifc_cpxce_i2    = ifqop_i2[137];
   assign ifd_ifc_cpxue_i2    = ifqop_i2[(137 + 1)];
   assign ifd_ifc_cpxms_i2    = ifqop_i2[(137 + 2)];
   assign ifd_ifc_cpxnc_i2    = ifqop_i2[136];
   assign ifd_ifc_fwd2ic_i2   = ifqop_i2[103];

   // instr sel mux to write to thread inst regsiter in S stage
   // instr is always BIG ENDIAN
   dp_mux4ds  #(33)  fillinst_mux(.dout (ifq_fdp_fill_inst),
				                        .in0 (icdata_i2[134:102]),
				                        .in1 (icdata_i2[100:68]),
				                        .in2 (icdata_i2[66:34]),
				                        .in3 (icdata_i2[32:0]),
				                        .sel0_l (ifc_ifd_finst_sel_l[0]),
				                        .sel1_l (ifc_ifd_finst_sel_l[1]),
				                        .sel2_l (ifc_ifd_finst_sel_l[2]),
				                        .sel3_l (ifc_ifd_finst_sel_l[3]));

   // synopsys translate_off
//`ifdef DEFINE_0IN
//`else
//   always @ (ifq_fdp_fill_inst or ifd_ifc_cpxreq_i2)
//     if (((^ifq_fdp_fill_inst[32:0]) == 1'bx) && (ifd_ifc_cpxreq_i2 == `CPX_IFILLPKT))
//       begin
//          $display("ifqdp.v: Imiss Return val = %h\n", ifqop_i2);
//          $display("IFQCPX", "Error: X's detected in Imiss Return Inst %h",
//                 ifq_fdp_fill_inst[31:0]);
//          $finish();
//       end
//`endif
   // synopsys translate_on


   // TBD: 1. inv way in fill pkt -- DONE
   //      2. inv packet -- DONE
   //      3. DFT pkt from TAP -- NO NEED
   //      4. Ld pkt to invalidate i$  -- DONE

   //----------------------------------------------------------------------
   // ASI Access
   //----------------------------------------------------------------------
   // mux stxa pkt into the cpx
   assign  stxa_data_pkt[144] = 1'b0;
   // vbits and parity are muxed into the cpxreq
   assign  stxa_data_pkt[143:140] = {1'b1, lsu_ifu_stxa_data[34:32]};
//   assign  stxa_data_pkt[`CPX_THRFIELD] = lsu_ifu_asi_thrid[1:0];
   assign  stxa_data_pkt[135:134] = 2'b0;
   // use parity to insert error in icache inst or tag
   assign  stxa_data_pkt[(137 + 1)] = lsu_ifu_stxa_data[32];
   assign  stxa_data_pkt[127:0] = {4{lsu_ifu_stxa_data[31:0]}};

   // other bits need to be tied off
   assign  stxa_data_pkt[133:128] = 6'b0;
   assign  stxa_data_pkt[137:136] = 2'b0;
   assign  stxa_data_pkt[139] = 1'b0;

   // format fwd data pkt in a similar way
   assign  fwd_data_pkt[144:(137 + 2)] = ifqop_i2[144:(137 + 2)];
   assign  fwd_data_pkt[(137 + 1)] = ifqop_i2[32];
   assign  fwd_data_pkt[137:128] = ifqop_i2[137:128];
   assign  fwd_data_pkt[127:0] = {4{ifqop_i2[31:0]}};



   dff_s #(16) stxa_ff(.din (lsu_ifu_stxa_data[47:32]),
		                 .q   (ifq_erb_asidata_i2[47:32]),
		                 .clk (clk), .se(se), .si(), .so());
   assign  ifq_erb_asidata_i2[31:0] = ifqop_i2[31:0];

   // va[63:32] is truncated
   // In this architecture we only need va[17:0]
   // rest of the bits ar ehere only for the address range check
   // 12 new muxes (10 for addr, 2 for way)
   // CHANGE: this mux has been moved before the asi_addr_reg, rather
   // than after.
   // Use mux flop soffm2?
   dp_mux2es #(12) asifwd_mx(.dout (asi_fwd_index[13:2]),
                             .in0  ({lsu_ifu_asi_addr[17:16],   // asi way
                                     lsu_ifu_asi_addr[12:3]}),  // asi addr
                             .in1  ({ifqop_i2[81:80],    // fwd rq way
                                     ifqop_i2[76:67]}),  // fwd rq addr
                             .sel  (ifc_ifd_idx_sel_fwd_i2));

   assign asi_va_i1 = {asi_fwd_index[13:12],
                       lsu_ifu_asi_addr[15:13],
                       asi_fwd_index[11:2],
                       lsu_ifu_asi_addr[2:0]};

   dff_s #(18) asi_addr_reg(.din (asi_va_i1[17:0]),  // 15:13 is not used
			                    .q   (asi_va_i2[17:0]),
			                    .clk (clk),
			                    .se  (se), .si(), .so());

   // 16b zero cmp: leave out bit 3!! (imask is 0x8)
   assign  ifd_ifc_asi_vachklo_i2 = (|asi_va_i2[16:4]) | (|asi_va_i2[2:0]);

   // mux in ifqop and asi_va_i2 to create new asi va?
   // asi va is shifted by 1 bit to look like 64b op
   assign    ifd_ifc_asiaddr_i2[3:2] = asi_va_i2[4:3];

   assign    asi_addr_i2 = {tag_par_i2,           // tag parity 42
			                      asi_va_i2[17:16],     // way 41:40
			                      ifqop_i2[27:0],       // tag 39:12
			                      asi_va_i2[12:3]       // index 11:2
                            };

   // bist has to go to icache in the same cycle
   // cannot flop it
   assign    bist_addr_i2 = {1'b0,                    // par
			                       mbist_icache_way[1:0],   // way 41:40
			                       28'b0,                   // tag 39:12
			                       mbist_icache_index[7:0], // index 11:4
                             mbist_icache_word,       // 3
			                       1'b0
			                       };

   // floating signals
   sink #(2) s0(.in (imiss_paddr_s[1:0]));
   sink s1(.in (pcxreq_e[42]));
   sink s2(.in (fill_addr_i2[4]));


endmodule // sparc_ifu_ifqdp



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_imd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_imd
//  Description:	
//  Contains the immediate operand datapath.  Has two outputs:  The
//  simm data to the EXU and the branch offset to the IFU.
*/


module sparc_ifu_imd(/*AUTOARG*/
   // Outputs
   ifu_exu_imm_data_d, dtu_inst_d, ifu_exu_rd_d, ifu_lsu_rd_e, 
   ifu_lsu_imm_asi_d, ifu_tlu_imm_asi_d, ifu_lsu_imm_asi_vld_d, ifu_tlu_sraddr_d, 
   ifu_tlu_sraddr_d_v2, imd_dcl_brcond_d, imd_dcl_mvcond_d, 
   imd_dcl_abit_d, so, ifu_ffu_frs1_d, ifu_ffu_frs2_d, ifu_ffu_frd_d, 
   ifu_ffu_fpopcode_d, ifu_ffu_fcc_num_d, 
   // Inputs
   rclk, se, si, fdp_dtu_inst_s, fcl_imd_oddwin_d, 
   dcl_imd_immdata_sel_simm13_d_l, dcl_imd_immdata_sel_movcc_d_l, 
   dcl_imd_immdata_sel_sethi_d_l, dcl_imd_immdata_sel_movr_d_l, 
   dcl_imd_broff_sel_call_d_l, dcl_imd_broff_sel_br_d_l, 
   dcl_imd_broff_sel_bcc_d_l, dcl_imd_broff_sel_bpcc_d_l, 
   dcl_imd_immbr_sel_br_d, dcl_imd_call_inst_d
   );

   input rclk, 
         se, 
         si;

   input [31:0] fdp_dtu_inst_s;          // instruction from fetch

   input        fcl_imd_oddwin_d;       // are we in an even or odd window
   
   input        dcl_imd_immdata_sel_simm13_d_l,  // imm data selects
		            dcl_imd_immdata_sel_movcc_d_l,
		            dcl_imd_immdata_sel_sethi_d_l,
		            dcl_imd_immdata_sel_movr_d_l;
   
   input        dcl_imd_broff_sel_call_d_l,      // dir branch offset select
		            dcl_imd_broff_sel_br_d_l,
		            dcl_imd_broff_sel_bcc_d_l,
		            dcl_imd_broff_sel_bpcc_d_l;

   input        dcl_imd_immbr_sel_br_d;  // use branch offset or simm data
   input        dcl_imd_call_inst_d;
   
   output [31:0] ifu_exu_imm_data_d;      // imm data to EXU
   output [31:0] dtu_inst_d;              // D stage inst to DEC

   output [4:0]  ifu_exu_rd_d,
		             ifu_lsu_rd_e;
   
   output [7:0]  ifu_lsu_imm_asi_d;       // ASI for ldA and stA
   output [8:0]  ifu_tlu_imm_asi_d;       // ASI for ldA and stA
   output        ifu_lsu_imm_asi_vld_d;
   output [6:0]  ifu_tlu_sraddr_d;
   output [6:0]  ifu_tlu_sraddr_d_v2;
   output [3:0]  imd_dcl_brcond_d;
   output [7:0]  imd_dcl_mvcond_d;

   output        imd_dcl_abit_d;         // anull bit for cond branch

   output        so;

   output [4:0]  ifu_ffu_frs1_d,
		             ifu_ffu_frs2_d,
		             ifu_ffu_frd_d;

   output [8:0]  ifu_ffu_fpopcode_d;
   output [1:0]  ifu_ffu_fcc_num_d;
	 

//-----------------------------------
// Declaration of local signals
//----------------------------------
   wire [4:0]  sraddr5;

   wire [31:0] imm_data_d;       // imm data 

   wire [31:0] dtu_inst_d,
		           simm13,
		           simm11,
		           simm10,
		           imm22,
		           dbr16,
		           dbcc22_nopred,
		           dbcc19_pred,
		           dcall,
		           broffset_d;
   
   wire        clk, ifu_lsu_imm_asi_vld_f;
   
   
//----------------------------------------------------------------------
// Code starts here 
//----------------------------------------------------------------------
   assign      clk = rclk;
   
   //--------
   // S Stage
   // Contains mostly random logic to help with decode in D stage
   //--------
   
   // Regfile operations:
   // REMOVED
//   assign ifu_exu_rs1_s = fdp_dtu_inst_s[18:14] ^ 
//			  {{fdp_dtu_inst_s[17] & dcl_imd_oddwin_s},  4'b0000};

//   assign ifu_exu_rs2_s = fdp_dtu_inst_s[4:0] ^ 
//			  {{fdp_dtu_inst_s[3] & dcl_imd_oddwin_s},  4'b0000};

//   assign ifu_exu_rs3_s = fdp_dtu_inst_s[29:25] ^ 
//			  {{fdp_dtu_inst_s[28] & dcl_imd_oddwin_s},  4'b0000};

//   assign imd_dcl_op_s = fdp_dtu_inst_s[31:30];
//   assign imd_dcl_op3_s = fdp_dtu_inst_s[24:19];
   
   //--------
   // D stage
   // Contains the immediate data and branch offset muxes
   //--------
   
   dff_s #(32) inst_d_reg(.din  (fdp_dtu_inst_s),
		      .clk  (clk),
		      .q    (dtu_inst_d),
		      .se   (se), .si(), .so());

   dff_s #(1) ifu_lsu_imm_asi_inst(.din  (fdp_dtu_inst_s[13]),
                      .clk  (clk),
                      .q    (ifu_lsu_imm_asi_vld_f),
                      .se   (se), .si(), .so());

   assign imd_dcl_abit_d = dtu_inst_d[29];

   // imm data select
   // sext12:0 -- add/sub/and/or/xor/taggedOP/jmpl/ld/store/atomic/div/mul/popc
   //             prefetch/return/restore/save/sir/wr/shft/flush
   //  !!!CAS does not use Imm data!!!
   //
   // sext10:0 -- movcc
   // sext9:0  -- movr
   // 21:0,10'b0 -- sethi

   assign simm13 = {{19{dtu_inst_d[12]}},dtu_inst_d[12:0]};
   assign simm11 = {{21{dtu_inst_d[10]}},dtu_inst_d[10:0]};
   assign simm10 = {{22{dtu_inst_d[9]}},dtu_inst_d[9:0]};
   assign imm22  = {dtu_inst_d[21:0], 10'b0};

   dp_mux4ds  #(32) immdata_mux(.dout (imm_data_d),
			  .in0  (simm13),
			  .in1  (simm11),
			  .in2  (simm10),
			  .in3  (imm22),
			  .sel0_l (dcl_imd_immdata_sel_simm13_d_l),
			  .sel1_l (dcl_imd_immdata_sel_movcc_d_l),
			  .sel2_l (dcl_imd_immdata_sel_movr_d_l),
			  .sel3_l (dcl_imd_immdata_sel_sethi_d_l));


   // branch offset select
   assign dbr16 = {{14{dtu_inst_d[21]}}, dtu_inst_d[21:20], 
		   dtu_inst_d[13:0], 2'b0};
   assign dbcc22_nopred = {{8{dtu_inst_d[21]}}, dtu_inst_d[21:0], 2'b0};
   assign dbcc19_pred = {{11{dtu_inst_d[18]}}, dtu_inst_d[18:0], 2'b0};
   assign dcall = {dtu_inst_d[29:0], 2'b0};

   dp_mux4ds  #(32) broffset_mux(.dout   (broffset_d[31:0]),
			   .in0    (dcall[31:0]),          // call
			   .in1    (dbr16[31:0]),          // br on reg
			   .in2    (dbcc22_nopred[31:0]),  // branch w/o pred
			   .in3    (dbcc19_pred[31:0]),    // branch w/ pred
			   .sel0_l (dcl_imd_broff_sel_call_d_l),
			   .sel1_l (dcl_imd_broff_sel_br_d_l),
			   .sel2_l (dcl_imd_broff_sel_bcc_d_l),
			   .sel3_l (dcl_imd_broff_sel_bpcc_d_l));

   dp_mux2es #(32) immbr_mux(.dout (ifu_exu_imm_data_d[31:0]),
			   .in0  (imm_data_d[31:0]),
			   .in1  (broffset_d[31:0]),
			   .sel  (dcl_imd_immbr_sel_br_d));

   // branch/move condition to dcl
   assign imd_dcl_brcond_d = dtu_inst_d[28:25];
   assign imd_dcl_mvcond_d = dtu_inst_d[17:10];

   // if call instruction set rd = 0f (15)
   assign ifu_exu_rd_d[3:0] = dtu_inst_d[28:25] | {4{dcl_imd_call_inst_d}};
   assign ifu_exu_rd_d[4] = (dtu_inst_d[29] & ~dcl_imd_call_inst_d) ^
			      (ifu_exu_rd_d[3] & fcl_imd_oddwin_d);
   
   dff_s #(5) rde_ff(.din (ifu_exu_rd_d[4:0]),
		 .clk (clk),
		 .q   (ifu_lsu_rd_e[4:0]),
		 .se  (se), .si(), .so());

   // read/write pr and read/write sr
   dp_mux2es #(5)  sraddr_mux(.dout (sraddr5[4:0]),
			    .in0  (dtu_inst_d[18:14]),  // rs1 for rdpr
			    .in1  (dtu_inst_d[29:25]),  // rd  for wrpr
			    .sel  (dtu_inst_d[23]));

   assign ifu_tlu_sraddr_d = {dtu_inst_d[19],                     // hpriv
                              {dtu_inst_d[20] & ~dtu_inst_d[19]}, // priv
                              sraddr5[4:0]};
   assign ifu_tlu_sraddr_d_v2 = ifu_tlu_sraddr_d;
   

   // asi fields for stA, ldA
   // same as fpopcode_d

   assign ifu_lsu_imm_asi_d[7:0] = dtu_inst_d[12:5];
   assign ifu_tlu_imm_asi_d[8:0] = dtu_inst_d[13:5];

   assign ifu_lsu_imm_asi_vld_d = ~ifu_lsu_imm_asi_vld_f;
   
   // fp reg fields
   assign ifu_ffu_frd_d = dtu_inst_d[29:25];
   assign ifu_ffu_fcc_num_d = dtu_inst_d[26:25];
   assign ifu_ffu_frs1_d = dtu_inst_d[18:14];
   assign ifu_ffu_fpopcode_d = dtu_inst_d[13:5];
   assign ifu_ffu_frs2_d = dtu_inst_d[4:0];
   
endmodule // sparc_ifu_imd
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_incr46.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Description:	
//  Contains the pc incrementer.
*/

module sparc_ifu_incr46(a, a_inc, ofl);
   input  [45:0]  a;
   output [45:0]  a_inc;
   output 	  ofl;
   
   reg [45:0] 	  a_inc;
   reg 		  ofl;
   
   always @ (a)
     begin
	      a_inc = a + (46'b1);
	      ofl = (~a[45]) & a_inc[45];
     end
   
   
   
endmodule // sparc_ifu_incr46


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_invctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_invctl
//  Description:
//  Control logic for handling invalidations to the icache
//
*/

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_invctl(/*AUTOARG*/
   // Outputs
   so, inv_ifc_inv_pending, ifq_icv_wrindex_bf, ifq_icv_wren_bf,
   ifq_ict_dec_wrway_bf, ifq_fcl_invreq_bf, ifq_erb_asiway_f,
   // Inputs
   rclk, se, si, const_cpuid, mbist_icache_write,
   lsu_ifu_ld_icache_index, lsu_ifu_ld_pcxpkt_vld,
   lsu_ifu_ld_pcxpkt_tid, ifc_inv_ifqadv_i2, ifc_inv_asireq_i2,
   ifq_icd_index_bf, ifd_inv_ifqop_i2, ifd_inv_wrway_i2
   );

   input        rclk,
                se,
                si;


   input [2:0]  const_cpuid;
   input        mbist_icache_write;

   input [(6 + 5):5]   lsu_ifu_ld_icache_index;
   input                  lsu_ifu_ld_pcxpkt_vld;
   input [1:0]            lsu_ifu_ld_pcxpkt_tid;

   input                  ifc_inv_ifqadv_i2;
   input                  ifc_inv_asireq_i2;

   input [(6 + 5):5]   ifq_icd_index_bf;
   input [145-1:0] ifd_inv_ifqop_i2;
   input [1:0]            ifd_inv_wrway_i2;


   output                 so;

   output                 inv_ifc_inv_pending;

   output [(6 + 5):5]  ifq_icv_wrindex_bf;
   output [15:0]          ifq_icv_wren_bf;
   output [3:0]           ifq_ict_dec_wrway_bf;
   output                 ifq_fcl_invreq_bf;
   output [1:0]           ifq_erb_asiway_f;


//----------------------------------------------------------------------
//  Local Signals
//----------------------------------------------------------------------

   wire [1:0]  invwd_way_i2;
   wire [1:0]  invwd0_way_i2 = invwd_way_i2;
   wire [1:0]  invwd1_way_i2 = invwd_way_i2;
   wire [1:0]  inv0_way_i2;
   wire [1:0]  inv1_way_i2;

   wire [1:0]  asi_way_f;

   wire        word_inv_i2;
   wire        word0_inv_i2 = word_inv_i2;
   wire        word1_inv_i2 = word_inv_i2;

   wire        ldinv_i2,
               ldpkt_i2,
               evpkt_i2,
               stpkt_i2,
               strmack_i2,
               imissrtn_i2;

   wire        invreq_i2,
               invalidate_i2,
               invalidate_f;

   wire        invall_i2,
               invpa5_i2;
   wire         invall_evict_i2;

   wire [1:0]  cpxthrid_i2;
   wire [3:0]  dcpxthr_i2;

   wire [1:0]  ldinv_way_i2;
   wire [1:0]  w0_way_i2,
               w1_way_i2,
               w0_way_f,
               w1_way_f;

   wire        pick_wr;
   wire        icv_wrreq_i2;

   wire [3:0]  wrt_en_wd_i2,
               wrt_en_wd_bf,
               wrt_en_wd_f;

   wire [3:0]  w0_dec_way_i2,
               w1_dec_way_i2;

   wire [3:0]  dec_wrway;

   wire        icvidx_sel_wr_i2,
               icvidx_sel_ld_i2,
               icvidx_sel_inv_i2;

   wire [15:0] wren_i2;


   wire [(6 + 5):6] inv_addr_i2;
   wire [(6 + 5):5] icaddr_i2;

   wire                missaddr5_i2;
   wire                missaddr6_i2;


   wire [3:0]          ldthr,
                       ldidx_sel_new;

   wire [(6 + 5):5] ldinv_addr_i2,
                       ldindex0,
                       ldindex1,
                       ldindex2,
                       ldindex3,
                       ldindex0_nxt,
                       ldindex1_nxt,
                       ldindex2_nxt,
                       ldindex3_nxt;

   wire                clk;


//
// Code Begins Here
//
   assign              clk = rclk;

   //----------------------------------------------------------------------
   // Extract Invalidate Packet For This Core
   //----------------------------------------------------------------------

   assign word_inv_i2 = ifd_inv_ifqop_i2[1];
   assign invwd_way_i2 = ifd_inv_ifqop_i2[5:2]; // trin: width mismatch okay

   //-----------------------------
   // Decode CPX Packet
   //-----------------------------
   // load
   assign ldpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0000}) ?
                       1'b1 : 1'b0;
   assign ldinv_i2 = ldpkt_i2 & ifd_inv_ifqop_i2[133];
   assign ldinv_way_i2= ifd_inv_ifqop_i2[132:131];

   // ifill
   assign imissrtn_i2 = ({ifd_inv_ifqop_i2[144],
                          ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0001}) ?
                          1'b1 : 1'b0;

   // store ack
   assign stpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0100}) ?
                       1'b1 : 1'b0;
   assign strmack_i2 = ({ifd_inv_ifqop_i2[144],
                         ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0110}) ?
                         1'b1 : 1'b0;
   assign invall_i2 = stpkt_i2 & ifd_inv_ifqop_i2[124] &
                      ifc_inv_ifqadv_i2;
   assign invpa5_i2 = ifd_inv_ifqop_i2[122];

   // evict
   assign evpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0011}) ?
                       1'b1 : 1'b0;
   assign invall_evict_i2 = evpkt_i2 & ifd_inv_ifqop_i2[124] &
                      ifc_inv_ifqadv_i2;

   // get thread id and decode
   assign  cpxthrid_i2 = ifd_inv_ifqop_i2[135:134];

   assign  dcpxthr_i2[0] = ~cpxthrid_i2[1] & ~cpxthrid_i2[0];
   assign  dcpxthr_i2[1] = ~cpxthrid_i2[1] &  cpxthrid_i2[0];
   assign  dcpxthr_i2[2] =  cpxthrid_i2[1] & ~cpxthrid_i2[0];
   assign  dcpxthr_i2[3] =  cpxthrid_i2[1] &  cpxthrid_i2[0];

   //-----------------------------------------------
   // Generate Write Way and Write Enables
   //-----------------------------------------------

   // decode way for tags
   assign  dec_wrway[0] = ~ifd_inv_wrway_i2[1] & ~ifd_inv_wrway_i2[0];
   assign  dec_wrway[1] = ~ifd_inv_wrway_i2[1] & ifd_inv_wrway_i2[0];
   assign  dec_wrway[2] = ifd_inv_wrway_i2[1] & ~ifd_inv_wrway_i2[0];
   assign  dec_wrway[3] = ifd_inv_wrway_i2[1] & ifd_inv_wrway_i2[0];

   assign  ifq_ict_dec_wrway_bf = dec_wrway;

   // way for asi
   dff_s #(2) asiwayf_reg(.din (ifd_inv_wrway_i2),
		                    .q   (asi_way_f),
		                    .clk (clk), .se(se), .si(), .so());

   assign  ifq_erb_asiway_f = asi_way_f;


   // Select which index/way to invalidate
   assign icv_wrreq_i2 = imissrtn_i2 | ifc_inv_asireq_i2 | mbist_icache_write;

   assign inv0_way_i2 = ~ifc_inv_ifqadv_i2 ? w0_way_f :
                        ldinv_i2           ? ldinv_way_i2 :
                                             invwd_way_i2;
   assign inv1_way_i2 = ~ifc_inv_ifqadv_i2 ? w1_way_f :
                        ldinv_i2           ? ldinv_way_i2 :
                                             invwd_way_i2;

   assign pick_wr = (imissrtn_i2 | ifc_inv_asireq_i2) & ifc_inv_ifqadv_i2 |
                     mbist_icache_write;
   assign w0_way_i2 = pick_wr ? ifd_inv_wrway_i2 :
                                inv0_way_i2;
   assign w1_way_i2 = pick_wr ? ifd_inv_wrway_i2 :
                                inv1_way_i2;

   dff_s #(4) wrway_reg(.din ({w0_way_i2, w1_way_i2}),
                      .q   ({w0_way_f, w1_way_f}),
                      .clk (clk), .se(se), .si(), .so());

   // determine the way in the ICV we are writing to
//   mux3ds #(2) w0_waymux(.dout  (w0_way_i2),
//		                     .in0   (ifd_inv_wrway_i2[1:0]),
//		                     .in1   (invwd0_way_i2[1:0]),
//		                     .in2   (ldinv_way_i2[1:0]),
//		                     .sel0  (icvidx_sel_wr_i2),
//		                     .sel1  (icvidx_sel_inv_i2),
//		                     .sel2  (icvidx_sel_ld_i2));

//   mux3ds #(2) w1_waymux(.dout  (w1_way_i2),
//		                     .in0   (ifd_inv_wrway_i2[1:0]),
//		                     .in1   (invwd1_way_i2[1:0]),
//		                     .in2   (ldinv_way_i2[1:0]),
//		                     .sel0  (icvidx_sel_wr_i2),
//		                     .sel1  (icvidx_sel_inv_i2),
//		                     .sel2  (icvidx_sel_ld_i2));

   // decode write way
   assign w0_dec_way_i2[0] = ~w0_way_i2[1] & ~w0_way_i2[0];
   assign w0_dec_way_i2[1] = ~w0_way_i2[1] &  w0_way_i2[0];
   assign w0_dec_way_i2[2] =  w0_way_i2[1] & ~w0_way_i2[0];
   assign w0_dec_way_i2[3] =  w0_way_i2[1] &  w0_way_i2[0];

   assign w1_dec_way_i2[0] = ~w1_way_i2[1] & ~w1_way_i2[0];
   assign w1_dec_way_i2[1] = ~w1_way_i2[1] &  w1_way_i2[0];
   assign w1_dec_way_i2[2] =  w1_way_i2[1] & ~w1_way_i2[0];
   assign w1_dec_way_i2[3] =  w1_way_i2[1] &  w1_way_i2[0];


   // determine if valid bit write to top 32B, bot 32B or both
   assign wrt_en_wd_i2[0] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           ~inv_addr_i2[6] |
                          ldinv_i2 & ~ldinv_addr_i2[5] & ~ldinv_addr_i2[6] |
		                      icv_wrreq_i2 & ~missaddr5_i2 & ~missaddr6_i2;

   assign wrt_en_wd_i2[1] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           ~inv_addr_i2[6] |
			                      ldinv_i2 & ldinv_addr_i2[5] & ~ldinv_addr_i2[6] |
		                        icv_wrreq_i2 & missaddr5_i2 & ~missaddr6_i2;

   assign wrt_en_wd_i2[2] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           inv_addr_i2[6] |
                          ldinv_i2 & ~ldinv_addr_i2[5] & ldinv_addr_i2[6] |
		                      icv_wrreq_i2 & ~missaddr5_i2 & missaddr6_i2;

   assign wrt_en_wd_i2[3] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           inv_addr_i2[6] |
			                      ldinv_i2 & ldinv_addr_i2[5] & ldinv_addr_i2[6] |
		                        icv_wrreq_i2 & missaddr5_i2 & missaddr6_i2;

   assign wrt_en_wd_bf = ifc_inv_ifqadv_i2 ? wrt_en_wd_i2 :
                                              wrt_en_wd_f;
   dff_s #(4) wrten_reg(.din (wrt_en_wd_bf),
                      .q   (wrt_en_wd_f),
                      .clk (clk), .se(se), .si(), .so());


   // Final Write Enable to ICV
   assign wren_i2[3:0] = (w0_dec_way_i2 & {4{wrt_en_wd_bf[0]}}) |
                           {4{(invall_i2 | invall_evict_i2) & ~invpa5_i2 & ~inv_addr_i2[6]}};

   assign wren_i2[7:4] = (w1_dec_way_i2 & {4{wrt_en_wd_bf[1]}}) |
                           {4{(invall_i2 | invall_evict_i2) & invpa5_i2 & ~inv_addr_i2[6]}};

   assign wren_i2[11:8] = (w0_dec_way_i2 & {4{wrt_en_wd_bf[2]}}) |
                            {4{(invall_i2 | invall_evict_i2) & ~invpa5_i2 & inv_addr_i2[6]}};

   assign wren_i2[15:12] = (w1_dec_way_i2 & {4{wrt_en_wd_bf[3]}}) |
                             {4{(invall_i2 | invall_evict_i2) & invpa5_i2 & inv_addr_i2[6]}};

   assign ifq_icv_wren_bf = wren_i2;

   // advance the wr way for the ICV array
//   mux2ds #(8) wren_mux(.dout  (next_wren_i2),
//		                    .in0   (wren_f),
//		                    .in1   (wren_i2),
//		                    .sel0  (~ifc_ifd_ifqadv_i2),
//		                    .sel1  (ifc_ifd_ifqadv_i2));

//   assign wren_bf = ifc_inv_ifqadv_i2 ? wren_i2 : wren_f;
//   dff #(8) icv_weff(.din  (wren_bf),
//		                 .q    (wren_f),
//		                 .clk  (clk),
//		                 .se   (se), .si(), .so());

//   assign ifq_icv_wren_bf[7:0] = wren_bf[7:0] & {8{~icvaddr6_i2}};
//   assign ifq_icv_wren_bf[15:8] = wren_bf[7:0] & {8{icvaddr6_i2}};


   //--------------------------
   // Invalidates
   //--------------------------
   assign invalidate_i2 = (stpkt_i2 | evpkt_i2 | strmack_i2) &
			                      (word_inv_i2 |
			                       ifd_inv_ifqop_i2[124]) |  // all ways
			                     ldinv_i2;

   mux2ds #(1) invf_mux(.dout (invreq_i2),
		                    .in0  (invalidate_f),
		                    .in1  (invalidate_i2),
		                    .sel0  (~ifc_inv_ifqadv_i2),
		                    .sel1  (ifc_inv_ifqadv_i2));

   dff_s #(1) invf_ff(.din  (invreq_i2),
		                .q    (invalidate_f),
		                .clk  (clk),
		                .se   (se), .si(), .so());

   // auto invalidate is done during bist
   // no need to qualify bist_write with ifqadv_i2 since bist is done
   // before anything else.
   assign ifq_fcl_invreq_bf = invreq_i2 | mbist_icache_write;

   // don't really need to OR with invalidate_f, since this will be
   // gone in a cycle
//   assign inv_ifc_inv_pending = invalidate_i2 | invalidate_f;
   assign inv_ifc_inv_pending = invalidate_i2;

   //---------------------------------
   // Get the ifill/invalidation index
   //---------------------------------

   // ifill index
   assign icaddr_i2[(6 + 5):5] = ifq_icd_index_bf[(6 + 5):5];
   assign missaddr5_i2 = ifq_icd_index_bf[5];
   assign missaddr6_i2 = ifq_icd_index_bf[6];

   // evict invalidate index
   //   assign    inv_addr_i2 = ifqop_i2[117:112];
   // assign inv_addr_i2 = ifd_inv_ifqop_i2[`CPX_INV_IDX_HI:`CPX_INV_IDX_LO];
   // trin: CPX is modified to accomodate up to 10 bits of icache indexing
   //    or 4096*4w*32B = 512KB
   wire [15:6] inv_addr_i2_full = { ifd_inv_ifqop_i2[27:24],
                          ifd_inv_ifqop_i2[117:112] };
   assign inv_addr_i2[(6 + 5):6] = inv_addr_i2_full[(6 + 5):6];

   // index for invalidates caused by a load
   // store dcache index when a load req is made

   assign ldthr[0] = ~lsu_ifu_ld_pcxpkt_tid[1] & ~lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[1] = ~lsu_ifu_ld_pcxpkt_tid[1] &  lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[2] =  lsu_ifu_ld_pcxpkt_tid[1] & ~lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[3] =  lsu_ifu_ld_pcxpkt_tid[1] &  lsu_ifu_ld_pcxpkt_tid[0];

   assign ldidx_sel_new = ldthr & {4{lsu_ifu_ld_pcxpkt_vld}};

//   dp_mux2es  #(`IC_IDX_SZ) t0_ldidx_mux(.dout (ldindex0_nxt),
//			                                   .in0  (ldindex0),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[0]));
   assign ldindex0_nxt = ldidx_sel_new[0] ? lsu_ifu_ld_icache_index :
                                            ldindex0;

//   dp_mux2es  #(`IC_IDX_SZ) t1_ldidx_mux(.dout (ldindex1_nxt),
//			                                   .in0  (ldindex1),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[1]));
   assign ldindex1_nxt = ldidx_sel_new[1] ? lsu_ifu_ld_icache_index :
                                            ldindex1;

//   dp_mux2es  #(`IC_IDX_SZ) t2_ldidx_mux(.dout (ldindex2_nxt),
//			                                   .in0  (ldindex2),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[2]));
   assign ldindex2_nxt = ldidx_sel_new[2] ? lsu_ifu_ld_icache_index :
                                            ldindex2;

//   dp_mux2es  #(`IC_IDX_SZ) t3_ldidx_mux(.dout (ldindex3_nxt),
//			                                   .in0  (ldindex3),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[3]));
   assign ldindex3_nxt = ldidx_sel_new[3] ? lsu_ifu_ld_icache_index :
                                            ldindex3;


   dff_s #(((6 + 5) - 4))  ldix0_reg(.din (ldindex0_nxt),
		                            .q   (ldindex0),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix1_reg(.din (ldindex1_nxt),
		                            .q   (ldindex1),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix2_reg(.din (ldindex2_nxt),
		                            .q   (ldindex2),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix3_reg(.din (ldindex3_nxt),
		                            .q   (ldindex3),
		                            .clk (clk), .se(se), .si(), .so());

   // Pick dcache index corresponding to current thread
   mux4ds #(((6 + 5) - 4)) ldinv_mux(.dout (ldinv_addr_i2),
			                            .in0  (ldindex0),
			                            .in1  (ldindex1),
			                            .in2  (ldindex2),
			                            .in3  (ldindex3),
			                            .sel0 (dcpxthr_i2[0]),
			                            .sel1 (dcpxthr_i2[1]),
			                            .sel2 (dcpxthr_i2[2]),
			                            .sel3 (dcpxthr_i2[3]));

   // Final Mux for Index
   assign icvidx_sel_wr_i2 = imissrtn_i2 | ifc_inv_asireq_i2 |
                             mbist_icache_write | ~ifc_inv_ifqadv_i2;
   assign icvidx_sel_ld_i2 = ldinv_i2 & ifc_inv_ifqadv_i2;
   assign icvidx_sel_inv_i2 = ~imissrtn_i2 & ~ldinv_i2 &
                              ~ifc_inv_asireq_i2 & ifc_inv_ifqadv_i2 &
                              ~mbist_icache_write;

   mux3ds #(((6 + 5) - 4)) icv_idx_mux(
                            .dout  (ifq_icv_wrindex_bf[(6 + 5):5]),
			                      .in0   (icaddr_i2[(6 + 5):5]),
			                      .in1   ({inv_addr_i2[(6 + 5):6], 1'b0}),
			                      .in2   (ldinv_addr_i2[(6 + 5):5]),
			                      .sel0  (icvidx_sel_wr_i2),
			                      .sel1  (icvidx_sel_inv_i2),
			                      .sel2  (icvidx_sel_ld_i2));

   sink #(145) s0(.in (ifd_inv_ifqop_i2));


endmodule // sparc_ifu_invctl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_lfsr5.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lfsr5
//  Description:	
//  The IFQ is the icache input queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_lfsr5 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   advance, clk, se, si, so, reset
   );

   input 	advance;
   
   input 	clk, se, si, so, reset;

   output [1:0] out;

   reg [4:0]    q_next;
   wire [4:0]   q;
   

/*
   always @ (posedge clk)
     begin
	out = $random;
     end // always @ posedge
 */

//   always @ (posedge clk)
//     begin
//	q[4:0] <= q_next[4:0];
//     end

   always @ (/*AUTOSENSE*/advance or q or reset)
     begin
	      if (reset)
	        q_next = 5'b11111;
	      else if (advance)
	        begin
	           // lfsr -- stable at 000000, period of 63
	           q_next[1] = q[0];
	           q_next[2] = q[1];
	           q_next[3] = q[2];
	           q_next[4] = q[3];
	           q_next[0] = q[1] ^ q[4];
	        end
	      else
	        q_next = q;
     end // always @ (...

   assign out = {q[0], q[2]};

   dff_s #(5) lfsr_reg(.din  (q_next),
                     .q    (q),
                     .clk  (clk), .se(se), .si(), .so());
   
endmodule // sparc_ifu_lfsr5

		
	       

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_lru4.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lru4
//  Description:	
//  LRU scheduler.  Least priority to the last granted
//  customer.  If no requests, the priority remains the same. 
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_lru4(/*AUTOARG*/
   // Outputs
   grant_vec, so, 
   // Inputs
   clk, reset, se, si, recent_vec, load_recent, req_vec, spec_vec, 
   use_spec
   );

   input     clk, reset, se, si;

   input [3:0] recent_vec;
   input       load_recent;
   input [3:0] req_vec,
               spec_vec;

   input       use_spec;
   
   output [3:0] grant_vec;
   
   output       so;


   wire [3:0]   used0,  // used0 is mru
		            used1,
		            used2,
		            used3;  // used3 is lru

   wire [3:0]   used23,
                used23_nxt;

   wire [3:0]   used0_buf, 
		            used1_buf,
		            used2_buf,
		            used3_buf; 

   wire [3:0]   sp_used0, 
		            sp_used1,
		            sp_used2,
		            sp_used3; 
   wire [3:0]   nosp_used0, 
		            nosp_used1,
		            nosp_used2,
		            nosp_used3; 

   wire [3:0]   used0_calc,
		            used0_nxt,
 		            used1_calc,
		            used1_nxt,
 		            used2_calc,
		            used2_nxt,
 		            used3_calc,
		            used3_nxt;

   wire         hit1,
		            hit2,
		            hit3;

   wire [3:0]   nospec_grant,
                spec_grant;
   
   wire         reqhit1,
		            reqhit2,
		            reqhit3,
                reqhit23;

   wire         spechit1,
		            spechit2,
		            spechit3,
                spechit23;

   wire         sel_u0,
		            sel_u1,
		            sel_u2,
		            sel_u3;

   wire         sel_su0,
		            sel_su1,
		            sel_su2,
		            sel_su3;

   dp_buffer #(4) use_buf0(.dout(used0_buf),
                      .in  (used0));
   dp_buffer #(4) use_buf1(.dout(used1_buf),
                      .in  (used1));
   dp_buffer #(4) use_buf2(.dout(used2_buf),
                      .in  (used2));
   dp_buffer #(4) use_buf3(.dout(used3_buf),
                      .in  (used3));
   

   // determine lru order for next cycle
//   assign hit0 = (used0_buf[0] & recent_vec[0] |
//		              used0_buf[1] & recent_vec[1] |
//		              used0_buf[2] & recent_vec[2] |
//		              used0_buf[3] & recent_vec[3]) & load_recent;

   assign hit1 = (used1_buf[0] & recent_vec[0] |
		              used1_buf[1] & recent_vec[1] |
		              used1_buf[2] & recent_vec[2] |
		              used1_buf[3] & recent_vec[3]) & load_recent;

   assign hit2 = (used2_buf[0] & recent_vec[0] |
		              used2_buf[1] & recent_vec[1] |
		              used2_buf[2] & recent_vec[2] |
		              used2_buf[3] & recent_vec[3]) & load_recent;

   assign hit3 = (used3_buf[0] & recent_vec[0] |
		              used3_buf[1] & recent_vec[1] |
		              used3_buf[2] & recent_vec[2] |
		              used3_buf[3] & recent_vec[3]) & load_recent;
   

   assign  used0_calc = load_recent          ?  recent_vec : used0_buf;
   assign  used1_calc = (hit3 | hit2 | hit1) ?  used0_buf  : used1_buf;
   assign  used2_calc = (hit3 | hit2)        ?  used1_buf  : used2_buf;
   assign  used3_calc = (hit3)               ?  used2_buf  : used3_buf;

   assign  used0_nxt = reset ? 4'b0001 : used0_calc;
   assign  used1_nxt = reset ? 4'b0010 : used1_calc;
   assign  used2_nxt = reset ? 4'b0100 : used2_calc;
   assign  used3_nxt = reset ? 4'b1000 : used3_calc;

   // use 4X4 matrix to hold lru info
   dff_s #(4) use0_reg(.din (used0_nxt),
		                 .q   (used0),
		                 .clk (clk), .se(se), .si(), .so());
   
   dff_s #(4) use1_reg(.din (used1_nxt),
		                 .q   (used1),
		                 .clk (clk), .se(se), .si(), .so());
   
   dff_s #(4) use2_reg(.din (used2_nxt),
		                 .q   (used2),
		                 .clk (clk), .se(se), .si(), .so());
   
   // used3 is lru
   dff_s #(4) use3_reg(.din (used3_nxt),
		                 .q   (used3),
		                 .clk (clk), .se(se), .si(), .so());

   assign  used23_nxt = used2_nxt | used3_nxt;
   
   dff_s #(4) use23_reg(.din (used23_nxt),
		                 .q   (used23),
		                 .clk (clk), .se(se), .si(), .so());
   

   // grant request based on lru

// save some loading on req_vec by not doing this   
//   assign  reqhit0 = (used0[0] & req_vec[0] |
//		      used0[1] & req_vec[1] |
//		      used0[2] & req_vec[2] |
//		      used0[3] & req_vec[3]);
   
   assign  reqhit1 = (used1[0] & req_vec[0] |
		                  used1[1] & req_vec[1] |
		                  used1[2] & req_vec[2] |
		                  used1[3] & req_vec[3]);
   
   assign  reqhit2 = (used2[0] & req_vec[0] |
		                  used2[1] & req_vec[1] |
		                  used2[2] & req_vec[2] |
		                  used2[3] & req_vec[3]);

   assign  reqhit3 = (used3[0] & req_vec[0] |
		                  used3[1] & req_vec[1] |
		                  used3[2] & req_vec[2] |
		                  used3[3] & req_vec[3]);

   assign  reqhit23 = (used23[0] & req_vec[0] |
		                   used23[1] & req_vec[1] |
		                   used23[2] & req_vec[2] |
		                   used23[3] & req_vec[3]);
   
   assign  sel_u3 = reqhit3;
   assign  sel_u2 = ~reqhit3 & reqhit2;
   assign  sel_u1 = ~reqhit23 & reqhit1;
   assign  sel_u0 = ~reqhit23 & ~reqhit1;
   
   assign  nosp_used0 = used0 & {4{~use_spec}};
   assign  nosp_used1 = used1 & {4{~use_spec}};
   assign  nosp_used2 = used2 & {4{~use_spec}};
   assign  nosp_used3 = used3 & {4{~use_spec}};

   mux4ds #(4) nsgnt_mux(.dout (nospec_grant),
		                     .in0  (nosp_used0),
		                     .in1  (nosp_used1),
		                     .in2  (nosp_used2),
		                     .in3  (nosp_used3),
		                     .sel0 (sel_u0),
		                     .sel1 (sel_u1),
		                     .sel2 (sel_u2),
		                     .sel3 (sel_u3));

   assign  spechit1 = (used1[0] & spec_vec[0] |
		                   used1[1] & spec_vec[1] |
		                   used1[2] & spec_vec[2] |
		                   used1[3] & spec_vec[3]);
   
   assign  spechit2 = (used2[0] & spec_vec[0] |
		                   used2[1] & spec_vec[1] |
		                   used2[2] & spec_vec[2] |
		                   used2[3] & spec_vec[3]);

   assign  spechit3 = (used3[0] & spec_vec[0] |
		                   used3[1] & spec_vec[1] |
		                   used3[2] & spec_vec[2] |
		                   used3[3] & spec_vec[3]);

   assign  spechit23 = (used23[0] & spec_vec[0] |
		                    used23[1] & spec_vec[1] |
		                    used23[2] & spec_vec[2] |
		                    used23[3] & spec_vec[3]);
   
   assign  sel_su3 = spechit3;
   assign  sel_su2 = ~spechit3 & spechit2;
   assign  sel_su1 = ~spechit23 & spechit1;
   assign  sel_su0 = ~spechit23 & ~spechit1;

   assign  sp_used0 = used0 & {4{use_spec}};
   assign  sp_used1 = used1 & {4{use_spec}};
   assign  sp_used2 = used2 & {4{use_spec}};
   assign  sp_used3 = used3 & {4{use_spec}};
   
   mux4ds #(4) sgnt_mux(.dout (spec_grant),
		                  .in0  (sp_used0),
		                  .in1  (sp_used1),
		                  .in2  (sp_used2),
		                  .in3  (sp_used3),
		                  .sel0 (sel_su0),
		                  .sel1 (sel_su1),
		                  .sel2 (sel_su2),
		                  .sel3 (sel_su3));

   assign  grant_vec = spec_grant | nospec_grant;
   

endmodule // sparc_ifu_lru4

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_milfsm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqdp
//  Description:	
//  The IFQ is the icache fill queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













//`define MILFSM_NULL   4'b0000
//`define MILFSM_WAIT   4'b1000
//`define MILFSM_REQ    4'b1100
//`define MILFSM_FILL0  4'b1001
//`define MILFSM_FILL1  4'b1011

//`define MIL_V  3
//`define MIL_R  2
//`define MIL_A  1
//`define MIL_F  0


module sparc_ifu_milfsm(/*AUTOARG*/
   // Outputs
   so, fsm_ifc_errreq, fsm_ifc_wrt_tir, fsm_ifc_comp_valid, 
   fsm_ifc_mil_valid, fsm_ifc_mil_cancel, fsm_ifc_thr_ready, 
   fsm_ifc_pred_rdy, fsm_ifc_pcxreq, fsm_ifc_addrbit4_i2, 
   fsm_ifc_milchld, fsm_ifc_milstate, 
   // Inputs
   ifc_fsm_can_thisthr, ifc_fsm_fill_thisthr_i2, 
   ifc_fsm_wr_complete_f, ifqadv_i2, ifd_ifc_4bpkt_i2, 
   fcl_ifq_thr_s1, ifc_fsm_imiss_thisthr_s, ifc_fsm_milhit_s, 
   ifc_fsm_hiton_thismil_s, ifc_fsm_pcxaccept_thisthr, 
   ifc_fsm_miladdr4, clk, se, si, reset, ifc_fsm_err_thisthr
   );

   input       ifc_fsm_can_thisthr,        
	             ifc_fsm_fill_thisthr_i2;
   
   input       ifc_fsm_wr_complete_f;

   input       ifqadv_i2;

   input       ifd_ifc_4bpkt_i2;
   input [1:0] fcl_ifq_thr_s1;             
   input       ifc_fsm_imiss_thisthr_s;
   input       ifc_fsm_milhit_s;
	 input       ifc_fsm_hiton_thismil_s,
               ifc_fsm_pcxaccept_thisthr;
   input       ifc_fsm_miladdr4;

   input       clk, 
               se, 
               si, 
               reset;

   input       ifc_fsm_err_thisthr;
   

   output      so;

   output      fsm_ifc_errreq;
   output      fsm_ifc_wrt_tir;

   output      fsm_ifc_comp_valid,
	             fsm_ifc_mil_valid,
               fsm_ifc_mil_cancel,
	             fsm_ifc_thr_ready;
   output      fsm_ifc_pred_rdy,
	             fsm_ifc_pcxreq,
	             fsm_ifc_addrbit4_i2;
	 
   output [2:0] fsm_ifc_milchld;

   output [3:0] fsm_ifc_milstate;
	 

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------


   // local variables
   reg [3:0] 	next_state;

   wire [3:0] 	milstate;

   wire [2:0]   local_milchld;
   
   wire 	milchld_valid;

   wire   fill_this16b;
   

   wire 	cancel_mil,
		      cancel_next;
   wire 	err_pending,
		      err_pending_next;
   
   wire 	valid_d1,
		valid_i2;
   
   wire [2:0] 	next_milchld;


   // Missed Instruction List State Machine
   // 3   - valid
   // 2   - req
   // 1   - addr for fill fill (1/0)
   // 0   - fill
   //
   // 2   - child valid
   // 1:0 - child thr ptr
   //


   always @(/*AUTOSENSE*/err_pending or ifc_fsm_err_thisthr
            or ifc_fsm_fill_thisthr_i2 or ifc_fsm_imiss_thisthr_s
            or ifc_fsm_milhit_s or ifc_fsm_pcxaccept_thisthr
            or ifc_fsm_wr_complete_f or ifd_ifc_4bpkt_i2 or ifqadv_i2
            or milstate)
     begin
	      case (milstate)  //  synopsys parallel_case
	        4'b0000: // null
	          begin
	             //ic_wrreq_i2 = 1'b0;	       
	             //  orphan_chld = 1'b0;
               next_state[1:0] = 2'b0;
               if (ifc_fsm_err_thisthr | ifc_fsm_imiss_thisthr_s)
		             begin
		                next_state[3] = 1'b1;
		                if (ifc_fsm_milhit_s & ~ifc_fsm_err_thisthr) 
		                  next_state[2] = 1'b0;  // MILFSM_WAIT
		                else
		                  next_state[2] = 1'b1;  // MILFSM_REQ;
		             end
	             else
		             next_state = milstate;
	          end // case: begin...
	        
	        4'b1100:  // req
	          begin
	             // ic_wrreq_i2 = 1'b0;		
	             // if canthr=1, the request will not be sent out in this cycle.
               if ((ifc_fsm_pcxaccept_thisthr) &
                   ~(ifc_fsm_err_thisthr | err_pending))
                 // two requests are made when there is an error.
                 // one, with errbit=1 gets back in invalidate response, 
                 // the other, with errbit=0, gets the regular ifill 
                 // return
		             begin
		                // we invalidate the icache on detecting an error
		                // only if this wasn't an MIL hit as well.  If it
		                // was an MIL we would have gone to the wait state
		                // already and it is too late to invalidate the cache
		                next_state = 4'b1000;
                    //		    orphan_chld = 1'b0;		    
		             end
//	             else if ((cancel_mil | ifc_fsm_can_thisthr) & 
//                        ~milchld_valid & ~ifc_fsm_hiton_thismil_s)
//		             begin
//		                next_state = `MILFSM_NULL;
//		             end
	             else
		             begin
		                next_state = milstate;
                    //		    orphan_chld = 1'b0;
		             end 
	          end // case: 4'b1100
          
	        4'b1000: // wait
	          begin
               //	       orphan_chld = 1'b0;
	             if (ifc_fsm_fill_thisthr_i2)
		             begin
		                // ic_wrreq_i2 = 1'b1;
                    if (ifd_ifc_4bpkt_i2 & ifqadv_i2) // 4B ifill from IOB
                      // don't want to advance too quickly and get fasle compl
                      next_state = 4'b0000;
                    else if (~ifd_ifc_4bpkt_i2)
		                  next_state = 4'b1001;
                    else
                      next_state = milstate;
		             end
	             else
		             begin
		                next_state = milstate;
		                //ic_wrreq_i2 = 1'b0;		    
		             end
	          end // case: 4'b1000
	        
	        4'b1001: // fill0
	          begin
               //	       orphan_chld = 1'b0;
               if (ifc_fsm_wr_complete_f)
		             begin
		                next_state = 4'b1011;
		                //ic_wrreq_i2 = 1'b1;
		             end
	             else
		             begin
		                next_state = milstate;
		                //ic_wrreq_i2 = 1'b1;
		             end
	          end // case: 4'b1001
          
	        4'b1011: // fill1
	          // Do we really need this state??  yes, to start thr
	          begin
               //	       orphan_chld = 1'b0;		    
	             if (ifc_fsm_wr_complete_f)
		             begin
		                //ic_wrreq_i2 = 1'b0; 		    
                    //		    if (delay_mil | ifc_fsm_imiss_thisthr_s)
                    //		      next_state = `MILFSM_REQ;
                    //		    else
		                next_state = 4'b0000;
		             end
	             else
		             begin
		                //ic_wrreq_i2 = 1'b1;
		                next_state = milstate;
		             end // else: !if(ifc_fsm_wr_complete_f)
	          end // case: 4'b10001
          
	        default:
	          begin
               // synopsys translate_off
		     // 0in <fire -message "MILSTATE, Error: SPARC/IFU/MILFSM: unknown state!"


               if ($time > (4* 1333))
                 begin
					$display ("MILSTATE", 
                            "Error: SPARC/IFU/MILFSM: unknown state! %b\n",milstate);
                    $finish();
                 end

               // synopsys translate_on               
	             next_state = milstate;
	             //ic_wrreq_i2 = 1'b0;		    
               //	       orphan_chld = 1'b0;	
	          end // case: default
	      endcase // casex(milstate)
     end // always @ (...
   

   // MIL state reg
   dffr_s #(4) milst_reg(.din  (next_state[3:0]),
		                   .q    (milstate[3:0]),
		                   .clk  (clk),
		                   .rst  (reset),
		                   .se   (se), .si(), .so());

   // Cancel - Delay state machine
   // -- not used anymore
   // C D
   // 0 0  - null
   // 1 0  - current thread cancelled but pending from L2
   // 1 1  - one ifill pending from L2, current thread will be sent
   //        out after that.
   
//   assign cancel_next = (ifc_fsm_can_thisthr | 
//			                   cancel_mil) & next_state[`MIL_V];    // reset wins

   assign cancel_next = (ifc_fsm_can_thisthr | cancel_mil) & 
                          (milstate[3] | ifc_fsm_imiss_thisthr_s |
                           ifc_fsm_err_thisthr);    // reset wins

   dffr_s #(1) can_ff(.din  (cancel_next),
		                .q    (cancel_mil),
		                .clk  (clk),
		                .rst  (reset),
		                .se   (se), .si(), .so());

   // track if we need to send out an error request
   assign err_pending_next = (ifc_fsm_err_thisthr & 
	                      (milstate[2] | ~milstate[3]) |
//	                      err_pending & next_state[`MIL_V]) &	
                        err_pending & milstate[3]) &
	                      ~ifc_fsm_pcxaccept_thisthr;
                         // & ~ifc_fsm_can_thisthr;
   
   dffr_s #(1) err_ff(.din (err_pending_next),
		                .q   (err_pending),
		                .clk (clk),
		                .rst (reset), .se(se), .si(), .so());
   assign fsm_ifc_errreq = err_pending;

   // Track secondary hits
   assign next_milchld[2] = ifc_fsm_hiton_thismil_s |    // hit on MIL by
   	                                                     // someone else
              			    fsm_ifc_milchld[2] & milstate[3]; // reset

   assign next_milchld[1:0] = ifc_fsm_hiton_thismil_s ? fcl_ifq_thr_s1 :
			                                                  fsm_ifc_milchld[1:0];

   dffr_s #(3) milchld_reg(.din  (next_milchld),
		                     .clk  (clk),
		                     .rst  (reset),
		                     .q    (local_milchld),
		                     .se   (se), .si(), .so());

   assign fsm_ifc_milchld[2] = local_milchld[2] & milstate[3];
   assign fsm_ifc_milchld[1:0] = local_milchld[1:0];
   
   assign milchld_valid = local_milchld[2] & milstate[3];

//   assign fsm_ifc_addrbit4_i2 = milstate[`MIL_F];
   assign fsm_ifc_addrbit4_i2 = milstate[0] & milstate[3] & 
                                (milstate[1] | ifc_fsm_wr_complete_f); 

   // determine if we want to fill from the first pkt or second pkt
   assign fill_this16b = ~(milstate[0] ^ ifc_fsm_miladdr4) |
                            ifd_ifc_4bpkt_i2;

   // write to thread inst reg (TIR)
//   assign fsm_ifc_wrt_tir =  (next_state[`MIL_F]) & ~cancel_mil & 
//	                     ifc_fsm_fill_thisthr_i2;
   assign fsm_ifc_wrt_tir =  (milstate[3] & ~milstate[2]) & 
			                         ~(cancel_mil | ifc_fsm_can_thisthr) & 
                               ifc_fsm_fill_thisthr_i2 &
                               fill_this16b;
	  
   // write to Icache 
//   assign fsm_ifc_wrreq_i2 = ic_wrreq_i2;
   assign valid_i2 = milstate[3] & ~fsm_ifc_thr_ready;
   
   dff_s vld_ff(.din (valid_i2),
	            .q   (valid_d1),
	            .clk (clk),
	            .se  (se), .si(), .so());

   // signal thread completion
   assign fsm_ifc_thr_ready = milstate[3] & milstate[0] &
	                      milstate[1] & ifc_fsm_wr_complete_f |
	                      ~milstate[3] & valid_d1;

   // predict ready assuming 2nd ifill happens in the next cycle
   assign fsm_ifc_pred_rdy =  milstate[3] & milstate[0] &
                              (ifc_fsm_wr_complete_f |
                               milstate[1]); //  & ifc_fsm_fill_thisthr_i2
   
   // set compare valid for mil hit signal
   assign fsm_ifc_comp_valid = milstate[3] &     // valid entry
	                             ~milstate[0] &    // not f0 or f1
                               ~milchld_valid;        // no chld already

   assign fsm_ifc_mil_valid = milstate[3];
   assign fsm_ifc_mil_cancel = cancel_mil;
   
   // In the request state or if we need to send an error invalidate, 
   // ask for bus from LSU. 
//   assign fsm_ifc_pcxreq = (milstate[`MIL_V] & milstate[`MIL_R] |
//			    err_pending | ifc_fsm_err_thisthr) & 
//	                   ~ifc_fsm_pcxaccept_thisthr & 
//                            (milchld_valid | ~cancel_mil);

//   assign fsm_ifc_pcxreq = (milstate[`MIL_V] & milstate[`MIL_R] & 
//	                          ~ifc_fsm_pcxaccept_thisthr & 
//                            (milchld_valid | ~cancel_mil));

   // removed pcx_accept from critical path
   assign fsm_ifc_pcxreq = milstate[3] & milstate[2];

   assign fsm_ifc_milstate = milstate;

   
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par16.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par16
//  Description:        
//    Generates 34b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par16 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [15:0] in;
   output 	out;

   assign  out = (^in[15:0]);

endmodule // sparc_ifu_par16

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par32.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par32
//  Description:        
//    Generates 32b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par32 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [31:0] in;
   output 	out;

   assign  out = (^in[31:0]);

endmodule // sparc_ifu_par32

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par34.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par34
//  Description:        
//    Generates 34b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par34 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [33:0] in;
   output 	out;

   assign  out = (^in[33:0]);

endmodule // sparc_ifu_par34

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_swl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_swl
//  Description:	
//  The switch logic manages the 4 threads.  It schedules the next
//  thread to be executed.   
*/
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_swl(/*AUTOARG*/
   // Outputs
   swl_sscan_thrstate, so, dtu_reset, swl_dec_mulbusy_e, 
   swl_dec_divbusy_e, swl_dec_fpbusy_e, swl_dec_fp_enable_d, 
   swl_dec_ibe_e, dtu_fcl_ntr_s, dtu_fcl_running_s, 
   dtu_fcl_rollback_g, dtu_fcl_retract_d, dtu_fcl_thr_active, 
   dtu_fcl_nextthr_bf, swl_dcl_thr_d, swl_dcl_thr_w2, 
   esl_fcl_stall_bf, esl_fcl_switch_bf, esl_fdp_sync_pcs_bf,
   esl_fcl_ntr_s, esl_fdp_issue_prev_inst_s, esl_fcl_force_running_s,
   dtu_fdp_thrconf_e, 
   // Inputs
   rclk, se, si, gdbginit_l, arst_l, grst_l, ctu_sscan_tid, 
   ifq_dtu_thrrdy, ifq_dtu_pred_rdy, ifu_tlu_inst_vld_w, 
   ifu_tlu_ttype_vld_m, fcl_dtu_hprivmode_d, fcl_dtu_hprivmode_w2, 
   tlu_ifu_flush_pipe_w, fcl_swl_flush_w, fcl_dtu_sync_intr_d, 
   fcl_dtu_nuke_thr_w, fcl_dtu_rst_thr_w, fcl_dtu_resum_thr_w, 
   fcl_dtu_thr_f, tlu_hpstate_ibe, lsu_ifu_ldsta_internal_e, 
   tlu_ifu_trappc_vld_w1, dec_swl_ll_done_d, dec_swl_br_done_d, 
   dec_swl_rdsr_sel_thr_d, dec_swl_std_inst_d, dec_swl_sta_inst_e, 
   wsr_fixed_inst_w, dec_swl_ld_inst_d, dec_swl_mul_inst_d, 
   dec_swl_div_inst_d, dec_swl_fpop_d, dec_swl_allfp_d, 
   dec_swl_frf_upper_d, dec_swl_frf_lower_d, dec_swl_wrtfprs_w, 
   dcl_swl_tcc_done_m, exu_ifu_longop_done_g, exu_ifu_spill_e, 
   lsu_ifu_ldst_cmplt, lsu_ifu_dc_parity_error_w2, lsu_ifu_stbcnt0, 
   lsu_ifu_stbcnt1, lsu_ifu_stbcnt2, lsu_ifu_stbcnt3, 
   lsu_ifu_quad_asi_e, ffu_ifu_fpop_done_w2, ffu_ifu_tid_w2, 
   ffu_ifu_fst_ce_w, tlu_ifu_trap_tid_w1, tlu_ifu_pstate_pef, 
   lsu_ifu_ldst_miss_g, fcl_swl_int_activate_i3, 
   fcl_swl_flush_wake_w, ifq_swl_stallreq, fcl_dtu_stall_bf, 
   fcl_swl_swout_f, fcl_swl_swcvld_s, fdp_fcl_swc_s2, 
   fcl_ifq_icmiss_s1, fcl_dtu_inst_vld_e, fcl_dtu_intr_vld_e, 
   fcl_dtu_inst_vld_d, erb_dtu_ifeterr_d1, dtu_inst_anull_e, 
   const_cpuid, thr_config_in_m, dec_swl_wrt_tcr_w, 
   dec_swl_st_inst_d, extra_longlat_compl, config_dtu_esl_en, 
   config_dtu_esl_sync_method, config_esl_lfsr_seed, 
   config_esl_lfsr_ld, config_esl_pc_diff_thresh, config_esl_counter_timeout, 
   fdp_esl_t0inst_next_s2, 

   fdp_esl_t1inst_next_s2, 














   fdp_esl_t0inst_paddr_next_s2,

   fdp_esl_t1inst_paddr_next_s2, 














   fdp_esl_t0pc_next_s2, 

   fdp_esl_t1pc_next_s2,














   fcl_esl_tinst_vld_next_s,
   fcl_esl_brtaken_e, fcl_esl_brtaken_m, fcl_esl_thr_e, fcl_esl_thr_m,
   fcl_esl_inst_vld_d, fcl_esl_inst_vld_e, fcl_esl_inst_vld_m, fcl_esl_thr_trap_bf,
   fcl_esl_rb_stg_s, dcl_esl_br_inst_d, dcl_esl_br_inst_e, fdp_esl_brtrp_target_pc_bf_f,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data

   );

   input       rclk, 
               se, 
               si,
               gdbginit_l,
               arst_l,
               grst_l;

   input [3:0] ctu_sscan_tid;   // guaranteed one-hot by ctu

   input [3:0] ifq_dtu_thrrdy;	      // ifq completion signals
   input [3:0] ifq_dtu_pred_rdy;	    // ifq almost done

   input       ifu_tlu_inst_vld_w,    //
	             ifu_tlu_ttype_vld_m;
   input       fcl_dtu_hprivmode_d;
   input       fcl_dtu_hprivmode_w2;
   input       tlu_ifu_flush_pipe_w;  // flush after a trap
   input       fcl_swl_flush_w;
   input       fcl_dtu_sync_intr_d;   // interrupt
   input       fcl_dtu_nuke_thr_w;    // sync suspend
   input       fcl_dtu_rst_thr_w;    // 
   input       fcl_dtu_resum_thr_w;    // 
   input [3:0] fcl_dtu_thr_f;

   input [3:0] tlu_hpstate_ibe;
   
   input       lsu_ifu_ldsta_internal_e,// sta to local reg
	             tlu_ifu_trappc_vld_w1, // trap completion
	             dec_swl_ll_done_d,   // rdsr completion
               dec_swl_br_done_d,
	             dec_swl_rdsr_sel_thr_d,
	             dec_swl_std_inst_d,    //
	             dec_swl_sta_inst_e,    // state change
	             wsr_fixed_inst_w,      // wrspr completion
	             dec_swl_ld_inst_d;     // load hit/compl. speculation

   input       dec_swl_mul_inst_d,
	             dec_swl_div_inst_d;
   input       dec_swl_fpop_d,
	             dec_swl_allfp_d;

   input       dec_swl_frf_upper_d,
	             dec_swl_frf_lower_d,
	             dec_swl_wrtfprs_w;
   
   input       dcl_swl_tcc_done_m;

   input [3:0] exu_ifu_longop_done_g; // save, restore, div, mul compl.
   input       exu_ifu_spill_e;
   input [3:0] lsu_ifu_ldst_cmplt;
   input       lsu_ifu_dc_parity_error_w2;

   input [3:0] lsu_ifu_stbcnt0,
	             lsu_ifu_stbcnt1,
	             lsu_ifu_stbcnt2,
	             lsu_ifu_stbcnt3;

//   input [3:0] lsu_ifu_stq_busy;
   input       lsu_ifu_quad_asi_e;
	 
   input       ffu_ifu_fpop_done_w2;
   input [1:0] ffu_ifu_tid_w2;
   input       ffu_ifu_fst_ce_w;
   
   input [1:0] tlu_ifu_trap_tid_w1;

   input [3:0] tlu_ifu_pstate_pef;

   input       lsu_ifu_ldst_miss_g;   // dcache hit or miss
   
   input [3:0] fcl_swl_int_activate_i3; // wake up thread on interrupt
   input       fcl_swl_flush_wake_w;

   // TBD: with the latest changes fcl_dtu_switch_s = dtu_fcl_ntr_s, so 
   // this input can be removed.
//   input       fcl_dtu_switch_s; // switch out curr, sw in next

   input       ifq_swl_stallreq;

   input       fcl_dtu_stall_bf,
               fcl_swl_swout_f,       // curr thread is stalled
	             fcl_swl_swcvld_s,
               fdp_fcl_swc_s2,        // thread stall condition
	             fcl_ifq_icmiss_s1;     // icache miss
   input       fcl_dtu_inst_vld_e,
               fcl_dtu_intr_vld_e,
	             fcl_dtu_inst_vld_d;

   input       erb_dtu_ifeterr_d1;

   input       dtu_inst_anull_e;      // anull delay slot

   input [3:0] const_cpuid;           // use 4 bits to allow future
                                      // expansion to 16 cores

   input [2:0] thr_config_in_m;       // write data to thread status reg
   input       dec_swl_wrt_tcr_w;     // write signal for thr status reg
   input       dec_swl_st_inst_d;

   input [3:0] extra_longlat_compl;   // spare signal, not used
  
   input       config_dtu_esl_en;       // Configuration for ESL - Enable signal
   input [1:0] config_dtu_esl_sync_method; // Configuration for ESL - Synchronization method

   input [15:0] config_esl_lfsr_seed;   // Configuration for ESL - LFSR seed
   input        config_esl_lfsr_ld;      // Configuration for ESL - LFSR load seed
 
   input [49:0] config_esl_pc_diff_thresh; // Configuration for ESL - STSM PC diff threshold
   input [15:0] config_esl_counter_timeout; // Configuration for ESL - STSM timeout
  
   input [32:0] fdp_esl_t0inst_next_s2;

   input [32:0] fdp_esl_t1inst_next_s2;















   input [39:2] fdp_esl_t0inst_paddr_next_s2;

   input [39:2] fdp_esl_t1inst_paddr_next_s2;















   input [48:0] fdp_esl_t0pc_next_s2;

   input [48:0] fdp_esl_t1pc_next_s2;














   
   input [3:0]  fcl_esl_tinst_vld_next_s;
   input        fcl_esl_brtaken_e;
   input        fcl_esl_brtaken_m;
   input [3:0]  fcl_esl_thr_e;
   input [3:0]  fcl_esl_thr_m;
   input        fcl_esl_inst_vld_d;
   input        fcl_esl_inst_vld_e;
   input        fcl_esl_inst_vld_m;
   input [3:0]  fcl_esl_thr_trap_bf;
   input        fcl_esl_rb_stg_s;

   input        dcl_esl_br_inst_d;
   input        dcl_esl_br_inst_e;

   input [3:0]  fdp_esl_brtrp_target_pc_bf_f;

   // jtag interface
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

   output [10:0] swl_sscan_thrstate;
   output        so;
   
   output      dtu_reset;

   output      swl_dec_mulbusy_e,
	             swl_dec_divbusy_e,
	             swl_dec_fpbusy_e,
	             swl_dec_fp_enable_d;

   output      swl_dec_ibe_e;
   
   // to fcl
   output      dtu_fcl_ntr_s,         // next thread ready
               dtu_fcl_running_s,
	             dtu_fcl_rollback_g,    // rollback on spec
	             dtu_fcl_retract_d;     // rollback on hw hazard

   output [3:0] dtu_fcl_thr_active;   // currently active threads
   
   output [3:0] dtu_fcl_nextthr_bf,   // thread to switch to when ntr=1
		            swl_dcl_thr_d,
		            swl_dcl_thr_w2;

   output       esl_fcl_stall_bf;
   output       esl_fcl_switch_bf;
   output       esl_fdp_sync_pcs_bf;

   output       esl_fcl_ntr_s;
   output       esl_fdp_issue_prev_inst_s;
   output       esl_fcl_force_running_s;

   // to fdp
   output [40:0] dtu_fdp_thrconf_e;   // thread conf for RDSR inst

//----------------------------------------------------------
// Declarations
//----------------------------------------------------------
   // local signals
//   wire [3:0]    count_nxt,
//	               count;
//   wire          proc0;
//   wire          start_on_rst;

   wire [3:0]    lru_fcl_nextthr_bf;   // thread to switch to when ntr=1 from lru
   wire [3:0]    esl_fcl_nextthr_bf;   // thread to switch to when ntr=1 from esl

   wire          esl_fdp_issue_prev_inst_next_s;

   wire [3:0]    swl_esl_thr_urdy;      // Input to ESL for which threads are ready
   wire [3:0]    swl_esl_thr_sprdy;

   wire          swl_esl_icmiss_out;

   wire          ibe_d,
                 ibe_e;

   wire [3:0]    completion,
		             wm_imiss,
		             wm_other,
		             spec_ld_d,
		             issue_spec_ld,
		             ldmiss,
		             ldhit_thr,
		             spec_ld_g,
		             imiss,
		             trap,
                 ldmiss_non_crit,
                 ldmiss_crit,
		             trp_no_retr,
//		             rb_thr_w,
                 rt_st_thr_d,
                 rt_st_thr_e,
		             schedule,
		             int_activate,
		             start_thread,
                 thaw_thread,
		             resum_thread,
		             nuke_thread,
		             rst_thread;

   wire          rollback_g,
                 rb_en_g,
                 rollback_g_l,
                 rollback_w2;
   

   wire          sched_nt;
   
   wire [3:0]    fixedop_done,
		             wsr_done_w3;

   wire          wsr_inst_w2,
                 wsr_inst_w3;
   
   wire          wsr_fixed_qual_w,
                 wsr_fixed_w2;

   wire          llinst_done_e;
   
   wire [3:0]    ll_done_e,
                 branch_done_d,
                 std_tcc_done_m;

   wire          sta_done_e,
		             killed_inst_done_e;
   wire [3:0]    killed_uniop_done_e;

   wire          uniop_d,
		             uniop_e;

//   wire          no_iftrap_m,
//                 no_iftrap_w;

   wire [3:0]    thr_s1,
                 thr_s2,
		             thr_f,
		             thr_d,
		             thr_e,
		             thr_m,
		             thr_w,
                 st_thr_w2,
		             st_thr_w3;

   wire          flush_pipe_w_nxt,
                 flush_all_w,
                 flush_pipe_w2,
                 flush_done_w,
                 fp_flush_done_w2,
                 fp_flush_done_w3,
		             flush_done_w2;

   wire          rbfor_fst_ce_w;
   
   wire [3:0]    flush_wake_w2,
                 fp_flush_wake_w3,
                 halt_thread;
   
   wire          wrt_spec_w,
                 wrt_spec_w2,
                 halt_w,
                 halt_w2,
		             en_spec_d,
		             en_spec_m,
		             en_spec_g,
		             spec_next;
   

   wire          ld_inst_e,
		             ld_inst_next_e,
                 ld_inst_qual_d,
		             ld_inst_m,
		             ld_inst_unq_w,
		             ld_inst_w,
                 ld_inst_w2;
	 
   wire          switch_out,
	               sw_cond_s,
	               swc_d,
	               swc_next_d,
	               swc_e;

   wire          trp_noretr_d;
   
   wire [3:0]    all_stall;

   wire [3:0]    rdy,
	               sprdy_or_urdy,
                   sprdy_or_urdy_next;

   wire          running_s2,
                 atr_s;

   wire [4:0]    thr0_state,
		             thr1_state,
		             thr2_state,
		             thr3_state;

  wire [4:0]    thr0_nstate,
                thr1_nstate,
                thr2_nstate,
                thr3_nstate;

   wire          use_spec;

   wire [3:0]    wrt_tcr_w2;

   wire [1:0]    enc_thr_d;

   wire          rd_thract_d,
		             rd_thract_e;
   wire [51:0]   fmt_thrconf_e,
                 thrconf_out_e,
                 fmt_thrconf_adj;

   wire          hprivmode_e,
                 rdsr_sel_thr_e;
   
   wire [2:0]    rd_tid_spec_e;

   wire [3:0]    mul_busy_d,
		             mul_busy_e,
		             div_busy_d,
		             div_busy_e,
		             fp_busy_d,
		             fp_busy_e;

   wire          true_fpbusy_e,
                 fpbusy_local_e,
                 true_mulbusy_e,
                 true_divbusy_e;

   wire          fbusy_nxt_d,
                 fbusy_crit_e,
                 fbusy_d3,
                 fbusy_d0,
                 fbusy_d1,
                 fbusy_d2,
                 dbusy_d3,
                 dbusy_d0,
                 dbusy_d1,
                 dbusy_d2,
                 mbusy_d3,
                 mbusy_d0,
                 mbusy_d1,
                 mbusy_d2;

   wire [3:0]    mul_wait,
		             mul_wait_nxt,
		             div_wait,
		             div_wait_nxt,
		             fp_wait,
		             fp_wait_nxt;

   wire          mul_wait_any,
		             div_wait_any,
		             fp_wait_any;

   wire [3:0]    mul_wake,
		             div_wake,
		             fp_wake;

   wire [3:0]    exu_lop_done,
		             mul_done,
		             div_done,
		             fp_done;

   wire [3:0]    retr_thr_wakeup;
   wire [3:0]    trap_thrrdy,
		             trap_thr;

   wire [3:0]    fp_thr,
		             fp_thrrdy;

   wire          same_thr_de,
		             same_thr_dg,
                 same_thr_fd,
                 same_thr_fe,
		             same_thr_fm,                 
		             same_thr_fg;


   wire          st_thisthr_e;
   
   wire          st_inst_e,
		             st_inst_qual_d,
		             st_inst_qual_e,
 		             st_inst_m,
 		             st_inst_g;
   
   wire          pipe_st_cnt_ge1,
 		             pipe_st_cnt_ge2,
 		             pipe_st_cnt_ge3;
   
   wire          pipe_st_d,
                 pipe_st_e,
 		             pipe_st_m,
 		             pipe_st_g;

   wire          all_dst_ge1,
 		             all_dst_ge2,
 		             all_dst_ge3,
 		             all_dst_eq4;

   wire          dst_cnt_ge1,
 		             dst_cnt_ge2,
 		             dst_cnt_ge3;
   
   
   wire [3:0]    stbcnt_s,
		             stbcnt_d;

   wire [3:0]    stb_stall,
		             stb_blocked,
		             stb_blocked_d1,
		             st_in_pipe,
		             stb_retry,
		             wm_stbwait,
		             stb_wait_nxt;
   
   wire          switch_store_d,
//		             retract_stall_d,
		             retract_store_e,
                 retract_st_next_d,
		             retract_store_d;

   wire          retract_iferr_d,
                 iferr_s,
                 iferr_d;

   wire          clear_wmo_e;

   wire          sw_st_e,
		             sw_st_m,
		             sw_st_g,
		             sw_st_w2;

   wire          std_inst_e;
//		             stq_inst_e,
//		             stq_inst_m,
//		             stq_inst_w,
//		             stq_inst_w2;
   wire          std_done_e;
   wire          std_done_m;
//   wire [3:0]    stq_busy,
//		             stq_in_pipe,
//		             stq_wait,
//		             stq_wait_next,
//		             stq_done_thr;

   wire [2:0]    fprs0,
		             fprs1,
		             fprs2,
		             fprs3,
		             fprs_d,
		             fprs_e,
		             fprs_wrt_data,
                 thr_config_in_w,
                 thr_config_in_w2,
		             fprs0_nxt,
		             fprs1_nxt,
		             fprs2_nxt,
		             fprs3_nxt;

   wire [1:0]    new_fprs;

   wire [3:0]    fprs_en_s,
		             fpen_vec_s;

   wire          wrt_fprs_w,
                 wrt_fprs_w2;
   
   wire [3:0]    sel_wrt,
		             fprs_sel_set,
		             fprs_sel_wrt,
		             fprs_sel_old;

   wire          fpen_s;

   wire [1:0]    trap_tid_w2;
   wire          trappc_vld_w2;

   wire          dtu_reset_l;
   wire          sched_reset;
   
   wire          clk;
   
   //
   // Code Begins Here
   //

   assign        clk = rclk;
   
   // reset buffer
   dffrl_async rstff(.din (grst_l),
                        .q   (dtu_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

   assign       dtu_reset = ~dtu_reset_l;
   

   //---------------------------------------------
   // Start off thread on reset using this counter
   //---------------------------------------------
//   dffr #(4) thrrdy_ctr(.din (count_nxt),
//		                    .clk (clk),
//		                    .q   (count),
//		                    .rst (dtu_reset),
//		                    .se (se), .si(), .so());
//
//   // count_nxt = count + 1, sticky at 8 = 1111
//   assign count_nxt[0] = ~count[0] | count[3];
//   assign count_nxt[1] = (count[1] ^ count[0]) | count[3];
//   assign count_nxt[2] = (count[2] ^ (count[1] & count[0])) | count[3]; 
//   assign count_nxt[3] = (count[3] ^ (count[2] & count[1] & count[0])) |
//	                       count[3]; 
//
//   assign proc0 = (const_cpuid == 4'b0000) ? 1'b1 : 1'b0;
//   assign start_on_rst = (~count[3] & count[2] & count[1] & count[0])
//                          & proc0;

//`ifdef IFU_SAT   
//   // temporary hack to start threads
//   reg [3:0]  auto_start;
//   always @ (posedge clk)
//     auto_start = 4'b0000;
//`endif
   
   //-----------------
   // completion logic
   //-----------------
   sparc_ifu_thrcmpl compl(
                           .reset       (dtu_reset),
			                     /*AUTOINST*/
                           // Outputs
                           .completion  (completion[3:0]),
                           .wm_imiss    (wm_imiss[3:0]),
                           .wm_other    (wm_other[3:0]),
                           .swl_esl_icmiss_out (swl_esl_icmiss_out),
                           // Inputs
                           .clk         (clk),
                           .se          (se),
                           .si          (si),
                           .fcl_ifq_icmiss_s1(fcl_ifq_icmiss_s1),
                           .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                           .sw_cond_s   (sw_cond_s),
                           .en_spec_g   (en_spec_g),
                           .atr_s       (atr_s),
                           .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                           .ifq_dtu_thrrdy(ifq_dtu_thrrdy[3:0]),
                           .ifq_dtu_pred_rdy(ifq_dtu_pred_rdy[3:0]),
                           .exu_lop_done(exu_lop_done[3:0]),
                           .branch_done_d(branch_done_d[3:0]),
                           .fixedop_done(fixedop_done[3:0]),
                           .ldmiss      (ldmiss[3:0]),
                           .spec_ld_d   (spec_ld_d[3:0]),
                           .trap        (trap[3:0]),
                           .retr_thr_wakeup(retr_thr_wakeup[3:0]),
                           .flush_wake_w2(flush_wake_w2[3:0]),
                           .ldhit_thr   (ldhit_thr[3:0]),
                           .spec_ld_g   (spec_ld_g[3:0]),
                           .clear_wmo_e (clear_wmo_e),
                           .wm_stbwait  (wm_stbwait[3:0]),
                           .stb_retry   (stb_retry[3:0]),
                           .rst_thread  (rst_thread[3:0]),
                           .trap_thrrdy (trap_thrrdy[3:0]),
                           .thr_s2      (thr_s2[3:0]),
                           .thr_e       (thr_e[3:0]),
                           .thr_s1      (thr_s1[3:0]),
                           .fp_thrrdy   (fp_thrrdy[3:0]),
                           .lsu_ifu_ldst_cmplt(lsu_ifu_ldst_cmplt[3:0]),
                           .sta_done_e  (sta_done_e),
                           .killed_inst_done_e(killed_inst_done_e));

   //------------
   // Thread Pipe
   //------------
   assign thr_f = fcl_dtu_thr_f;

//   assign thr_dec_f[0] = thr_f[0] | rst_tri_en;
//   assign thr_dec_f[3:1] = thr_f[3:1] & {3{~rst_tri_en}};

//   assign thr_dec_d[0] = thr_d[0] | rst_tri_en;
//   assign thr_dec_d[3:1] = thr_d[3:1] & {3{~rst_tri_en}};


   dff_s #(4) thrd_reg(.din  (thr_f[3:0]),
		   .clk  (clk),
		   .q    (thr_d[3:0]),
		   .se   (se), .si(), .so());

   assign     swl_dcl_thr_d = thr_d;

   dff_s #(4) thre_reg(.din  (thr_d),
		   .clk  (clk),
		   .q    (thr_e),
		   .se   (se), .si(), .so());

   dff_s #(4) thrm_reg(.din  (thr_e),
		   .clk  (clk),
		   .q    (thr_m),
		   .se   (se), .si(), .so());
   dff_s #(4) thrw_reg(.din  (thr_m),
		   .clk  (clk),
		   .q    (thr_w),
		   .se   (se), .si(), .so());

   dff_s #(4) thrw2_reg(.din  (thr_w),
		    .clk  (clk),
		    .q    (st_thr_w2),
		    .se   (se), .si(), .so());

   dff_s #(4) thrw3_reg(.din  (st_thr_w2),
		    .clk  (clk),
		    .q    (st_thr_w3),
		    .se   (se), .si(), .so());

   assign     swl_dcl_thr_w2 = st_thr_w2;

   // send ibe of curr thread to dec
   assign ibe_d = (thr_d[0] & tlu_hpstate_ibe[0] |
                   thr_d[1] & tlu_hpstate_ibe[1] |
                   thr_d[2] & tlu_hpstate_ibe[2] |
                   thr_d[3] & tlu_hpstate_ibe[3]);

   dff_s #(1) ibee_ff(.din (ibe_d),
                    .q   (ibe_e),
                    .clk (clk), .se(se), .si(), .so());
   assign swl_dec_ibe_e = ibe_e;

//----------------------------------------------------------------------
// Track Thread Execution
//----------------------------------------------------------------------

   // track instructions
   dff_s #(1) lle_ff(.din (dec_swl_ll_done_d),
                   .q   (llinst_done_e),
                   .clk (clk), .se (se), .si(), .so());
                   
   assign ll_done_e = thr_e & {4{llinst_done_e & fcl_dtu_inst_vld_e & 
                                 ~exu_ifu_spill_e}};
   assign std_tcc_done_m = thr_m & {4{dcl_swl_tcc_done_m | std_done_m}};

   assign wsr_fixed_qual_w  = wsr_fixed_inst_w & ifu_tlu_inst_vld_w & 
                              ~fcl_swl_flush_w;
   dff_s #(1) wsrw2_ff(.din (wsr_fixed_qual_w),
                     .q   (wsr_fixed_w2),
                     .clk (clk), .se(se), .si(), .so());
                     
   assign wsr_inst_w2  = wsr_fixed_w2 & ~flush_pipe_w2;

   // delay one cycle to allow tlu to finish
   dff_s #(1) wsw3_ff(.din (wsr_inst_w2),
                    .q   (wsr_inst_w3),
                    .clk (clk), .se(se), .si(), .so());

   assign wsr_done_w3 = {4{wsr_inst_w3}} & st_thr_w3;

   assign fixedop_done = (ll_done_e | wsr_done_w3 | std_tcc_done_m |
	                        wrt_tcr_w2 | extra_longlat_compl);

   assign branch_done_d = thr_d & {4{dec_swl_br_done_d & fcl_dtu_inst_vld_d}};

   assign sta_done_e = dec_swl_sta_inst_e & fcl_dtu_inst_vld_e & 
                       ~lsu_ifu_ldsta_internal_e;
   assign ld_inst_qual_d = dec_swl_ld_inst_d & fcl_dtu_inst_vld_d & 
                           ~iferr_d;
   dff_s #(1) lde_ff(.din  (ld_inst_qual_d),
		               .clk  (clk),
		               .q    (ld_inst_e),
		               .se   (se), .si(), .so());
   assign ld_inst_next_e = ld_inst_e;
//                         & ~dtu_inst_anull_e &    
//                           ~(lsu_ifu_ldsta_internal_e & 
//                             ifu_lsu_alt_space_e &
//                             fcl_dtu_inst_vld_e);
   
//   assign ld_inst_internal_e = ~dtu_inst_anull_e & ld_inst_e &
//                               (fcl_dtu_inst_vld_e & 
//                                lsu_ifu_ldsta_internal_e & 
//                                ifu_lsu_alt_space_e);
   
   dff_s #(1) ldm_ff(.din  (ld_inst_next_e),
		               .clk  (clk),
		               .q    (ld_inst_m),
		               .se   (se), .si(), .so());
   dff_s #(1) ldw_ff(.din  (ld_inst_m),
		               .clk  (clk),
		               .q    (ld_inst_unq_w),
		               .se   (se), .si(), .so());
   assign ld_inst_w = ifu_tlu_inst_vld_w & ld_inst_unq_w;
   dff_s #(1) ldw2_ff(.din  (ld_inst_w),
		               .clk  (clk),
		               .q    (ld_inst_w2),
		               .se   (se), .si(), .so());

   // track instruction status
   dff_s #(1) swcd_ff(.din  (sw_cond_s),
		                .clk  (clk),
		                .q    (swc_d),
		                .se   (se), .si(), .so());

   assign swc_next_d = (swc_d & ~dec_swl_br_done_d);
//			                   | fcl_dtu_sync_intr_d;
   
   dff_s #(1) swce_ff(.din  (swc_next_d),
		                .clk  (clk),
		                .q    (swc_e),
		                .se   (se), .si(), .so());

//bug6838,bug6989 - interrupt issued in annulled delay slot resets wm_other mask in e-stage; this
//                  reset causes switch logic to lose a long latency op(div) which set the wm_other mask
//                  in s-stage. Note that the div is issued to FPU. the ifu re-issues the interrupt - 
//                  which results in flush. this kills the long latency op and div is lost
//
//                  fix is to detect interrupt in anulled delay slot followed by long latency op and
//                  not reset the wm_other mask.
//
//       10/07/04 - fix changed to delay setting of wm_other mask from d-cycle to e-cycle. hence
//                  removing the kill in killed_inst_done_e
//
//   assign killed_inst_done_e = (fcl_dtu_inst_vld_e  & swc_e | //sw inst
//                                fcl_dtu_intr_vld_e) &  // any intr
//                                 dtu_inst_anull_e;

   assign killed_inst_done_e = fcl_dtu_inst_vld_e  & swc_e & //sw inst
                                 dtu_inst_anull_e;

   // a uniop is something that stalls all threads (looks like a uni
   // threaded machine)
   assign uniop_d = (dec_swl_allfp_d | //& swl_dec_fp_enable_d  
                     dec_swl_mul_inst_d | dec_swl_div_inst_d) & 
                      fcl_dtu_inst_vld_d;
   dff_s #(1) uniop_ff(.din  (uniop_d),
		                 .clk  (clk),
		                 .q    (uniop_e),
		                 .se   (se), .si(), .so());
   assign killed_uniop_done_e = thr_e & {4{dtu_inst_anull_e & uniop_e & 
                                           fcl_dtu_inst_vld_e |
                                           clear_wmo_e}};

//   assign sched_nt = fcl_dtu_switch_s & ~fcl_dtu_stall_bf;
   assign sched_nt = dtu_fcl_ntr_s & ~(fcl_dtu_stall_bf | ifq_swl_stallreq);   
   assign schedule = dtu_fcl_nextthr_bf & {4{sched_nt}};

   // speculate load hit if it is a load instruction
   // FP loads are not speculated on 
   assign spec_ld_d = thr_d & {4{ld_inst_qual_d & en_spec_d}};
   assign issue_spec_ld = thr_d & {4{ld_inst_qual_d & en_spec_d}} &
                          ~wm_imiss & ~wm_stbwait;

//   assign issue_spec_ld = thr_d & {4{dec_swl_ld_inst_d & en_spec_d & 
//                                     ~fcl_ifq_icmiss_s1}} & ~wm_imiss;
   
   assign spec_ld_g = (thr_w & {4{ld_inst_w & en_spec_g}});
   
   // actual load hit signal and load miss stall
//   assign rollback_g = en_spec_g & ld_inst_w & lsu_ifu_ldst_miss_g;
   // expand to gates:
   assign rb_en_g = en_spec_g & ld_inst_w;
   assign rollback_g_l = ~(lsu_ifu_ldst_miss_g & rb_en_g);
//   bw_u1_nand2_7x UZsize_rbgen(.a (lsu_ifu_ldst_miss_g),
//                               .b (rb_en_g),
//                               .z (rollback_g_l));
   assign rollback_g = ~rollback_g_l;
//   bw_u1_invh_25x UZsize_rbbuf(.a (rollback_g_l),
//                               .z (rollback_g));
   assign dtu_fcl_rollback_g = rollback_g;

   // delay restart of ldhit when en_spec=0 by 1 more cycle?
   
// assign rb_thr_w = thr_w & {4{en_spec_g & ld_inst_w & lsu_ifu_ldst_miss_g}};
// assign spec_ldmiss = rb_thr_w; // to thrcmpl
   
   assign ldhit_thr = (thr_w & {4{ld_inst_w & ~lsu_ifu_ldst_miss_g}} | 
                       thr_e & {4{ld_inst_e & dtu_inst_anull_e}});
   assign ldmiss_crit = thr_w & {4{ld_inst_w & lsu_ifu_ldst_miss_g}};
   assign ldmiss_non_crit = st_thr_w2 & {4{lsu_ifu_dc_parity_error_w2}};
                            // | thr_e & {4{ld_inst_internal_e}} 
                            
   assign ldmiss = ldmiss_crit | ldmiss_non_crit;
   
   assign rt_st_thr_d = thr_d & {4{retract_store_d}};
   assign rt_st_thr_e = thr_e & {4{retract_store_e}};

   dff_s #(1) rbw2_ff(.din (rollback_g),
                    .q   (rollback_w2),
                    .clk (clk), .se(se), .si(), .so());

   // traps and interrupts
   dff_s #(1) ld_trp_reg(.din (tlu_ifu_trappc_vld_w1),
                       .q   (trappc_vld_w2),
                       .clk (clk), .se(se), .si(), .so());

   dff_s #(2) trp_tid_reg(.din (tlu_ifu_trap_tid_w1[1:0]),
                        .q   (trap_tid_w2[1:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign trap_thr[0] = ~trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[1] = ~trap_tid_w2[1] &  trap_tid_w2[0];
   assign trap_thr[2] =  trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[3] =  trap_tid_w2[1] &  trap_tid_w2[0];

   assign trap_thrrdy = trap_thr & {4{trappc_vld_w2}};

   // fst processed directly in swl
   assign rbfor_fst_ce_w = ifu_tlu_inst_vld_w & ~tlu_ifu_flush_pipe_w & 
                           ffu_ifu_fst_ce_w & ~fcl_swl_flush_w;

//   dff #(1) fstce_ff(.din (rbfor_fst_ce_w),
//                     .q   (rbfor_fst_ce_w2),
//                     .clk (clk), .se(se), .si(), .so());
   
   assign flush_all_w = tlu_ifu_flush_pipe_w | fcl_swl_flush_w;
//   assign flush_pipe_w_nxt = tlu_ifu_flush_pipe_w & ~fcl_swl_flush_w;
   assign flush_pipe_w_nxt = tlu_ifu_flush_pipe_w & 
                             ~fcl_swl_flush_wake_w;   
   
   dff_s #(1) flpw2_ff(.din (flush_pipe_w_nxt),
                     .q   (flush_pipe_w2),
                     .clk (clk), .se(se), .si(), .so());

//   assign no_iftrap_m = ~ifu_tlu_ttype_vld_m;
//   dff #(1) trpw_ff(.din (no_iftrap_m),
//                    .q   (no_iftrap_w),
//                    .clk (clk), .se(se), .si(), .so());
   
//bug6838,bug6989 - change setting of trap for interrupt from d-cycle to e-cycle
//                  remove  thr_d & {4{fcl_dtu_sync_intr_d & ~iferr_d}} & ~rt_st_thr_e |
   
//   assign trap =  thr_w & {4{flush_all_w}} |
   assign trap =  st_thr_w2 & {4{flush_pipe_w2}} |
                  thr_w & {4{fcl_swl_flush_w}} |
                        thr_e & {4{fcl_dtu_intr_vld_e & ~dtu_inst_anull_e}} |
	                thr_m & {4{ifu_tlu_ttype_vld_m}};

   assign trp_no_retr = st_thr_w2 & {4{flush_pipe_w2 |
                                       lsu_ifu_dc_parity_error_w2 &
                                       ld_inst_w2    | 
                                       rollback_w2}}  |
	                      trap_thr & {4{trappc_vld_w2}} |
                        fp_flush_wake_w3 |
                        thr_w & {4{fcl_swl_flush_w}};
//	                       thr_m    & {4{ifu_tlu_ttype_vld_m}};

   assign trp_noretr_d = (thr_d[0] & trp_no_retr[0] | 
                          thr_d[1] & trp_no_retr[1] | 
                          thr_d[2] & trp_no_retr[2] | 
                          thr_d[3] & trp_no_retr[3]);
   
//   assign flush_done_w = fcl_swl_flush_w & ~fcl_swl_flush_wait_w;
   assign flush_done_w = fcl_swl_flush_wake_w;   
   dff_s #(1) flsh_ff(.din (flush_done_w),
		                .q   (flush_done_w2),
		                .clk (clk), .se(se), .si(), .so());
   assign flush_wake_w2 = {4{flush_done_w2}} & st_thr_w2 | fp_flush_wake_w3;

   // delay FP wakeup by one extra cycle to allow time for IRF CE
   // to be corrected.
   dff_s #(1) fpflsh_ff(.din (rbfor_fst_ce_w),
		                  .q   (fp_flush_done_w2),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) fpflw_ff(.din (fp_flush_done_w2),
		                 .q   (fp_flush_done_w3),
		                 .clk (clk), .se(se), .si(), .so());
   assign fp_flush_wake_w3 = st_thr_w3 & {4{fp_flush_done_w3}};
   
   // store buffer full
//   assign stbfull_on_curr_thr = stb_stall & thr_f;
//   assign stbfull_thisthr =  stbfull_on_curr_thr[0] |
//	                           stbfull_on_curr_thr[1] |
//	                           stbfull_on_curr_thr[2] |
//	                           stbfull_on_curr_thr[3];

//   assign stbfull_nextthr = ((stb_stall & dtu_fcl_nextthr_bf)
//			                       == 4'b0) ?
//			                        1'b0 : 1'b1;

   // imiss stall condition
   assign thr_s1 = thr_d;
   assign imiss = (thr_s1 & {4{fcl_ifq_icmiss_s1}}) | 
	                  (thr_e & {4{erb_dtu_ifeterr_d1}});  //

   // All Stall conditions
   assign all_stall = imiss | ldmiss_non_crit | trap | stb_stall | 
                      ldmiss_crit;

   // TBD: move to ifu -- done
//   assign ext_stallreq = ifq_dtu_stallreq | lsu_ifu_stallreq | 
//                         ffu_ifu_stallreq;  
                         // | other stall reqs
//   assign cpu_fcl_stallreq = ext_stallreq;
   
   // thread start and stop
//   assign switch_out = fcl_dtu_switch_s | fcl_dtu_stall_bf | fcl_swl_swout_f;
   assign switch_out = dtu_fcl_ntr_s | fcl_dtu_stall_bf | fcl_swl_swout_f |
                       ifq_swl_stallreq;

   // general stall condition
//   assign cpu_fcl_stallreq = ~dtu_fcl_ntr_s & (stbfull_thisthr) |
//                             dtu_fcl_ntr_s & (stbfull_nextthr) |
//	                           ext_stallreq;

   // ldmiss (i.e rollback) and flush_pipe are taken care of in FCL
   assign sw_cond_s = fdp_fcl_swc_s2 & fcl_swl_swcvld_s & ~iferr_s;

   // thread reset and other interrupts
   // added flop for timing reasons

//   assign async_rst_i3 = rst_thread & ~dtu_fcl_thr_active;
//   assign rst_thread   = rstthr_i3 & {4{rstint_i3}};
  // assign nuke_thread  = (rstthr_i3 & {4{nukeint_i3}} & 
//			                    ~dtu_fcl_thr_active) |   // if not active nuke 
			                                             // immediately
//			                     ({4{fcl_dtu_nuke_thr_ms}} & thr_m);
                                                   // else wait for signal

   assign resum_thread = ({4{fcl_dtu_resum_thr_w}} & thr_w);
   assign nuke_thread = ({4{fcl_dtu_nuke_thr_w}} & thr_w);
   assign rst_thread = ({4{fcl_dtu_rst_thr_w}} & thr_w);

   assign int_activate = fcl_swl_int_activate_i3 & ~wm_imiss;

//`ifdef IFU_SAT   
//   assign start_thread = {3'b0, start_on_rst} | auto_start | 
//                         resum_thread & (~wm_imiss | ifq_dtu_thrrdy);
//`else
   assign start_thread = resum_thread & (~wm_imiss | ifq_dtu_thrrdy) & 
                                          (~wm_stbwait | stb_retry);
   assign thaw_thread = resum_thread & (wm_imiss & ~ifq_dtu_thrrdy |
                                        wm_stbwait & ~stb_retry);
   
//`endif
   
   
//----------------------------------------------------------------------
// Thread FSM
//----------------------------------------------------------------------   

//trin
// jtag access
reg [3:0] rtap_ifu_thrfsm_wr_en;
reg [4:0] rtap_ifu_thrfsm_wr_data;

always @ *
begin
   rtap_ifu_thrfsm_wr_en = 0;
   if (rtap_core_val && rtap_core_id == 4'd2)
   begin
      if (rtap_core_threadid == 2'd0)
         rtap_ifu_thrfsm_wr_en = 4'b0001;
      else if (rtap_core_threadid == 2'd1)
         rtap_ifu_thrfsm_wr_en = 4'b0010;
      else if (rtap_core_threadid == 2'd2)
         rtap_ifu_thrfsm_wr_en = 4'b0100;
      else if (rtap_core_threadid == 2'd3)
         rtap_ifu_thrfsm_wr_en = 4'b1000;
   end
   rtap_ifu_thrfsm_wr_data = rtap_core_data[4:0];
end

   sparc_ifu_thrfsm  thrfsm0(
			     // Outputs




			     .so	(so),

			     .thr_state	(thr0_state[4:0]),
                 .thr_nstate (thr0_nstate[4:0]),
			     // Inputs
			     .completion(completion[0]),
			     .schedule	(schedule[0]),
			     .spec_ld	(issue_spec_ld[0]),
			     .ldhit	(ldhit_thr[0]),
			     .switch_out(switch_out),

			     .stall     (all_stall[0]),
			     .sw_cond	(sw_cond_s),

			     .int_activate(int_activate[0]),
			     .start_thread(start_thread[0]),
			     .thaw_thread(thaw_thread[0]),
			     .nuke_thread (nuke_thread[0]),
			     .rst_thread(rst_thread[0]),

			     .halt_thread (halt_thread[0]),
			     
           // jtag interface
           .rtap_ifu_thrfsm_wr_en(rtap_ifu_thrfsm_wr_en[0]),
           .rtap_ifu_thrfsm_wr_data(rtap_ifu_thrfsm_wr_data),

			     .clk	(clk),
			     .se	(se),
			     .si	(si),
			     .reset	(dtu_reset));

   sparc_ifu_thrfsm  thrfsm1(
			     // Outputs




			     .so	(so),

			     .thr_state	(thr1_state[4:0]),
                 .thr_nstate (thr1_nstate[4:0]),
			     // Inputs
			     .completion(completion[1]),
			     .schedule	(schedule[1]),
			     .spec_ld	(issue_spec_ld[1]),
			     .ldhit	(ldhit_thr[1]),
			     .switch_out(switch_out),

			     .stall     (all_stall[1]),
			     .sw_cond	(sw_cond_s),

			     .int_activate(int_activate[1]),
			     .start_thread(start_thread[1]),
			     .thaw_thread(thaw_thread[1]),
			     .nuke_thread (nuke_thread[1]),
			     .rst_thread(rst_thread[1]),

			     .halt_thread (halt_thread[1]),
			     
           // jtag interface
           .rtap_ifu_thrfsm_wr_en(rtap_ifu_thrfsm_wr_en[1]),
           .rtap_ifu_thrfsm_wr_data(rtap_ifu_thrfsm_wr_data),

			     .clk	(clk),
			     .se	(se),
			     .si	(si),
			     .reset	(dtu_reset));
   
// trin: since proc only has 2 threads, disabling the following state machines
 // Use two threads unless this is defined
assign thr2_state[4:0] = 5'b0;
assign thr3_state[4:0] = 5'b0;












































































 // ifdef CONFIG_NUM_THREADS

//----------------------------------------------------------------------
// Schedule Next Thread
//----------------------------------------------------------------------
   // rdy bit from thrfsm
   assign dtu_fcl_thr_active[0] = thr0_state[0];
   assign dtu_fcl_thr_active[1] = thr1_state[0];
   assign dtu_fcl_thr_active[2] = thr2_state[0];
   assign dtu_fcl_thr_active[3] = thr3_state[0];

   assign rdy[0] = thr0_state[3];
   assign rdy[1] = thr1_state[3];
   assign rdy[2] = thr2_state[3];
   assign rdy[3] = thr3_state[3];

   assign sprdy_or_urdy[0] = thr0_state[4];
   assign sprdy_or_urdy[1] = thr1_state[4];
   assign sprdy_or_urdy[2] = thr2_state[4];
   assign sprdy_or_urdy[3] = thr3_state[4];

   assign sprdy_or_urdy_next[0] = thr0_nstate[4];
   assign sprdy_or_urdy_next[1] = thr1_nstate[4];
   assign sprdy_or_urdy_next[2] = thr2_nstate[4];
   assign sprdy_or_urdy_next[3] = thr3_nstate[4]; 

   assign running_s2 = (thr0_state[2] |
			                  thr1_state[2] |
			                  thr2_state[2] |
			                  thr3_state[2]);

   assign dtu_fcl_running_s = running_s2;

   assign thr_s2 =  {thr3_state[2],
			               thr2_state[2],
			               thr1_state[2],
			               thr0_state[2]};

   // Next Thread Ready 
   assign dtu_fcl_ntr_s = config_dtu_esl_en ? esl_fcl_ntr_s 
                                            : (sprdy_or_urdy[0] | sprdy_or_urdy[1] | 
				                               sprdy_or_urdy[2] | sprdy_or_urdy[3]);

   // Any thread ready
   assign atr_s = dtu_fcl_ntr_s | running_s2;

   // decide which scheduler to use
   // timing note: see if use_spec can be generated in previous cycle
   assign use_spec = ~(rdy[3] | rdy[2] | rdy[1] | rdy[0]);

   // Select between thread select decision from LRU and ESL
   assign dtu_fcl_nextthr_bf = config_dtu_esl_en ? esl_fcl_nextthr_bf : lru_fcl_nextthr_bf;

   assign sched_reset = dtu_reset | ~gdbginit_l;
   // schedule ready threads using LRU
   sparc_ifu_lru4 thr_sched(// Outputs
			                      .grant_vec	(lru_fcl_nextthr_bf[3:0]),
			                      .so		(so),
			                      // Inputs
			                      .clk	(clk),
			                      .reset	(sched_reset),
			                      .se		(se),
			                      .si		(si),
			                      .recent_vec	(thr_e[3:0]),
			                      .load_recent(fcl_dtu_inst_vld_e),
			                      .req_vec	(rdy[3:0]),
                            .spec_vec (sprdy_or_urdy[3:0]),
                            .use_spec (use_spec));

   // Pipe forward issue previous instruction control signal
   dff_s #(1) issue_prev_inst_reg (.din (esl_fdp_issue_prev_inst_next_s),
                                   .q (esl_fdp_issue_prev_inst_s),
                                   .clk (clk), .se(se), .si(), .so());

   // Schedule ready threads using Execution Drafting
   sparc_ifu_esl esl_thr_sched
   (
      .clk (clk),
      .rst_n (~sched_reset),
      .config_esl_en (config_dtu_esl_en),
      .config_esl_sync_method (config_dtu_esl_sync_method),
      .config_esl_lfsr_seed (config_esl_lfsr_seed),
      .config_esl_lfsr_ld (config_esl_lfsr_ld),
      .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
      .config_esl_counter_timeout (config_esl_counter_timeout),
      .swl_esl_thr_active (dtu_fcl_thr_active),
      .swl_esl_thr_urdy (rdy),
      .swl_esl_thr_sprdy_or_urdy (sprdy_or_urdy),
      .swl_esl_thr_sprdy_or_urdy_next (sprdy_or_urdy_next),
      .swl_esl_use_spec (use_spec),
      .fcl_esl_thr_f (fcl_dtu_thr_f),
      .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

      .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














      .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

      .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














      .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

      .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














      .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
      .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
      .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
      .fcl_esl_thr_e (fcl_esl_thr_e),
      .fcl_esl_thr_m (fcl_esl_thr_m),
      .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
      .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
      .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
      .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
      .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
      .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
      .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
      .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),
      .swl_esl_icmiss_out (swl_esl_icmiss_out),
      .esl_fcl_nextthr_bf (esl_fcl_nextthr_bf),
      .esl_fcl_stall_bf (esl_fcl_stall_bf),
      .esl_fcl_switch_bf (esl_fcl_switch_bf),
      .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
      .esl_fcl_ntr_s (esl_fcl_ntr_s),
      .esl_fdp_issue_prev_inst_next_s (esl_fdp_issue_prev_inst_next_s),
      .esl_fcl_force_running_s (esl_fcl_force_running_s)
   );
      
//----------------------------------------------------------------------
// Thread Status (Config) Register
//----------------------------------------------------------------------
   // Read thread config
   assign enc_thr_d[1] = thr_d[3] | thr_d[2];
   assign enc_thr_d[0] = thr_d[3] | thr_d[1];   

   assign rd_thract_d = (thr0_state[0] & thr_d[0] |
                         thr1_state[0] & thr_d[1] |
                         thr2_state[0] & thr_d[2] |
                         thr3_state[0] & thr_d[3]);

   dff_s #(1) rdthr_ff(.din (rd_thract_d),
		                  .clk (clk),
		                  .q   (rd_thract_e),
		                  .se   (se), .si(), .so());

   dff_s #(3) rdcf_reg(.din ({enc_thr_d, en_spec_d}),
		                 .clk (clk),
		                 .q   (rd_tid_spec_e),
		                 .se   (se), .si(), .so());

   dff_s #(1) hpe_ff(.din (fcl_dtu_hprivmode_d),
		               .clk (clk),
		               .q   (hprivmode_e),
		               .se   (se), .si(), .so());
   dff_s #(1) rdthre_ff(.din (dec_swl_rdsr_sel_thr_d),
		                  .clk (clk),
		                  .q   (rdsr_sel_thr_e),
		                  .se   (se), .si(), .so());

   // TBD: read out all thread state, not just the current thread
   //      Done 9/26/02
   assign fmt_thrconf_e = {wm_stbwait,
                           wm_other,
                           wm_imiss,           // 51:40 - wait mask
                           4'b0,               // 39:36 - rsvd
                           thr0_state,
                           thr1_state,
                           thr2_state,
                           thr3_state,         // 35:16 - thr state
			                     {2'b0},             // 15:14 - rsvd
			                     const_cpuid,        // 13:10 - 4b cpu id
			                     rd_tid_spec_e[2:1], // 9:8 - 2b tid
			                     {5'b0},             // 7:3 - rsvd
			                     rd_tid_spec_e[0],   // 2 - en spec
			                     {1'b0},             // 1 - QOS/rsvd
			                     rd_thract_e};       // 0 - active

//`ifdef SPARC_HPV_EN
   assign fmt_thrconf_adj[51:1] = fmt_thrconf_e[51:1] & {51{hprivmode_e}};
   assign fmt_thrconf_adj[0] = fmt_thrconf_e[0];
//`else
//   assign fmt_thrconf_adj[51:0] = fmt_thrconf_e[51:0];
//`endif

//   assign thrconf_out_e[51:16] = (fmt_thrconf_e[51:16] & 
//                                      {36{hprivmode_e}});
   
//   mux2ds #(52) rdsr_mxe(.dout (thrconf_out_e[51:0]),
//		                     .in0  ({49'b0, fprs_e}),
//		                     .in1  (fmt_thrconf_adj[51:0]),
//		                     .sel0 (~rdsr_sel_thr_e),
//		                     .sel1 (rdsr_sel_thr_e));
   assign thrconf_out_e[51:0] = rdsr_sel_thr_e ? fmt_thrconf_adj[51:0] :
                                                 {49'b0, fprs_e};

   // leave out the zeros before sending to fdp
   assign dtu_fdp_thrconf_e = {thrconf_out_e[51:40], // 40:29
                               thrconf_out_e[35:16], // 28:9
                               thrconf_out_e[13:8],  // 8:3
                               thrconf_out_e[2:0]};

   // shadow scan outputs
   mux4ds #(11) sscan_mx(.dout (swl_sscan_thrstate[10:0]),
                         .in0  ({thr0_state[4:0], 
                                 wm_imiss[0],
                                 wm_other[0],
                                 wm_stbwait[0],
                                 mul_busy_e[0],
                                 div_busy_e[0],
                                 fp_busy_e[0]}),
                         .in1  ({thr1_state[4:0], 
                                 wm_imiss[1],
                                 wm_other[1],
                                 wm_stbwait[1],
                                 mul_busy_e[1],
                                 div_busy_e[1],
                                 fp_busy_e[1]}),
                         .in2  ({thr2_state[4:0], 
                                 wm_imiss[2],
                                 wm_other[2],
                                 wm_stbwait[2],
                                 mul_busy_e[2],
                                 div_busy_e[2],
                                 fp_busy_e[2]}),
                         .in3  ({thr3_state[4:0], 
                                 wm_imiss[3],
                                 wm_other[3],
                                 wm_stbwait[3],
                                 mul_busy_e[3],
                                 div_busy_e[3],
                                 fp_busy_e[3]}),
                         .sel0 (ctu_sscan_tid[0]),
                         .sel1 (ctu_sscan_tid[1]),
                         .sel2 (ctu_sscan_tid[2]),
                         .sel3 (ctu_sscan_tid[3]));
   
   // write to TCR
   assign wrt_spec_w = dec_swl_wrt_tcr_w & ifu_tlu_inst_vld_w & 
                       ~flush_all_w;

   assign spec_next = (wrt_spec_w2 & fcl_dtu_hprivmode_w2) ? 
                             thr_config_in_w2[2] : 
                             en_spec_d;
   
   assign halt_w = wrt_spec_w & ~thr_config_in_w[0];
   
   dff_s #(1) wrsw2_ff(.din (wrt_spec_w),
                     .q   (wrt_spec_w2),
                     .clk (clk), .se(se), .si(), .so());
   
   assign wrt_tcr_w2 = st_thr_w2 & {4{wrt_spec_w2}};
   
   dff_s #(1) hlt_ff(.din (halt_w),
                   .q   (halt_w2),
                   .clk (clk), .se(se), .si(), .so());
   assign halt_thread = st_thr_w2 & {4{halt_w2}};
   
   dffr_s #(1) enspec_ff(.din (spec_next),
		                   .clk (clk),
		                   .q   (en_spec_d),
		                   .rst (dtu_reset),
		                   .se  (se), .si(), .so());
   
   dff_s #(1) enspecm_ff(.din (rd_tid_spec_e[0]),
		                   .clk (clk),
		                   .q   (en_spec_m),
		                   .se  (se), .si(), .so());

   dff_s #(1) enspecw_ff(.din (en_spec_m),
		                   .clk (clk),
		                   .q   (en_spec_g),
		                   .se  (se), .si(), .so());


   //-----------------------------
   // Instruction Flow Control
   //-----------------------------

   // mul and div control (1 each per cpu)
   assign mul_busy_d = ({4{dec_swl_mul_inst_d & ~swl_dec_mulbusy_e &
                           fcl_dtu_inst_vld_d & ~iferr_d}} & thr_d &
//			                  ~rb_thr_w & ~rt_st_thr_e |          // set
                        ~rt_st_thr_e |
			                  mul_busy_e & ~killed_uniop_done_e) & 
			                   ~exu_ifu_longop_done_g & (~trp_no_retr);  // reset wins

   assign div_busy_d = ({4{dec_swl_div_inst_d & ~swl_dec_divbusy_e &
                           fcl_dtu_inst_vld_d & ~iferr_d}} & 
			                  thr_d  & ~rt_st_thr_e |        // set
			                  div_busy_e & ~killed_uniop_done_e) & 
			                   ~exu_ifu_longop_done_g & (~trp_no_retr); // reset wins

   assign fp_busy_d = ({4{dec_swl_allfp_d & // swl_dec_fp_enable_d &
                          fcl_dtu_inst_vld_d &
                          ~fpbusy_local_e & ~iferr_d}} & thr_d & 
		                   ~rt_st_thr_d & ~rt_st_thr_e |
                                  // FP could be a st
		                   fp_busy_e & ~killed_uniop_done_e) &
			                  {4{~ffu_ifu_fpop_done_w2}} & ~trp_no_retr; // reset wins

   dffr_s #(4) mulb_ff(.din (mul_busy_d),
		                 .q   (mul_busy_e),
		                 .clk (clk),
		                 .rst (dtu_reset),
		                 .se  (se), .si(), .so());
   assign true_mulbusy_e = (|mul_busy_e[3:0]);   
   assign mbusy_d0 = true_mulbusy_e & mul_wait_any;
   
   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_mulbusy_e = true_mulbusy_e | mbusy_d3 | mbusy_d1 | mbusy_d2;
   
   dffr_s #(4) divb_ff(.din (div_busy_d),
		                 .q   (div_busy_e),
		                 .clk (clk),
		                 .rst (dtu_reset),
		                 .se  (se), .si(), .so());
   assign true_divbusy_e = (|div_busy_e[3:0]);   
   assign dbusy_d0 = true_divbusy_e & div_wait_any;

   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_divbusy_e = true_divbusy_e | dbusy_d3 | dbusy_d1 | dbusy_d2;

   dffr_s #(4) fpb_ff(.din (fp_busy_d),
		                .q   (fp_busy_e),
		                .clk (clk),
		                .rst (dtu_reset),
		                .se  (se), .si(), .so());
   assign true_fpbusy_e = (|fp_busy_e[3:0]);
   assign fbusy_d0 = true_fpbusy_e & fp_wait_any;
   
   assign fbusy_nxt_d = (|fp_busy_d[3:0]) | fbusy_d0 | fbusy_d1 | fbusy_d2;
   dffr_s #(1) tfbe_ff(.din (fbusy_nxt_d),
                     .q   (fbusy_crit_e),
                     .clk (clk), 
                     .rst (dtu_reset), .se(se), .si(), .so());
   
   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_fpbusy_e = fbusy_crit_e;
   assign fpbusy_local_e = true_fpbusy_e | fbusy_d3 | fbusy_d1 | fbusy_d2;

   dff_s #(3) bd1_reg(.din ({mbusy_d0, dbusy_d0, fbusy_d0}),
                    .q   ({mbusy_d1, dbusy_d1, fbusy_d1}),
                    .clk (clk), .se(se), .si(), .so());

   dff_s #(3) bd2_reg(.din ({mbusy_d1, dbusy_d1, fbusy_d1}),
                    .q   ({mbusy_d2, dbusy_d2, fbusy_d2}),
                    .clk (clk), .se(se), .si(), .so());
   
   dff_s #(3) bd3_reg(.din ({mbusy_d2, dbusy_d2, fbusy_d2}),
                    .q   ({mbusy_d3, dbusy_d3, fbusy_d3}),
                    .clk (clk), .se(se), .si(), .so());
   
   // ifetch errors
   // If there was an error in the ifetch call back this instruction
   assign iferr_d = erb_dtu_ifeterr_d1 & same_thr_de;
   assign iferr_s = erb_dtu_ifeterr_d1 & same_thr_fe;
   assign retract_iferr_d =  erb_dtu_ifeterr_d1 & fcl_dtu_inst_vld_d & 
                             same_thr_de;

   // mul_inst is already already qualified with inst_vld
   // so is fpop
   // don't set retract if there is an iferr, since this will cancel
   // the pending imisses!  
   assign dtu_fcl_retract_d = ((dec_swl_mul_inst_d & swl_dec_mulbusy_e | 
			                          dec_swl_div_inst_d & swl_dec_divbusy_e |
			                          dec_swl_allfp_d & fpbusy_local_e) &
                                // & swl_dec_fp_enable_d 
                               fcl_dtu_inst_vld_d |
                               retract_store_d  
//                             |  retract_iferr_d
                               );

   // what does this do???
   // no need to stall after retract since thread is already switched out
//   assign retract_stall_d = (dec_swl_mul_inst_d & swl_dec_mulbusy_e | 
//			                       dec_swl_div_inst_d & swl_dec_divbusy_e |
//			                       dec_swl_allfp_d & swl_dec_fp_enable_d & 
//                             fpbusy_local_e);

   assign mul_wait_nxt = ({4{dec_swl_mul_inst_d & swl_dec_mulbusy_e &
                             fcl_dtu_inst_vld_d & ~iferr_d}} &
			                 thr_d  & ~rt_st_thr_e | mul_done |   // set
			                 mul_wait & ~retr_thr_wakeup  & ~killed_uniop_done_e) & 
			                 (~trp_no_retr);

   dffr_s #(4) mw_ff(.din (mul_wait_nxt[3:0]),
		               .q   (mul_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign mul_wait_any = (|mul_wait[3:0]);
   
   assign div_wait_nxt =  ({4{dec_swl_div_inst_d & swl_dec_divbusy_e &
                              fcl_dtu_inst_vld_d & ~iferr_d}} & 
                        thr_d  & ~rt_st_thr_e | div_done | // set 
			                  div_wait & ~retr_thr_wakeup & ~killed_uniop_done_e) & 
			                  (~trp_no_retr);
   
   dffr_s #(4) dw_ff(.din (div_wait_nxt[3:0]),
		               .q   (div_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign div_wait_any = (|div_wait[3:0]);

   assign fp_wait_nxt =  ({4{dec_swl_allfp_d & // swl_dec_fp_enable_d & 
                             fcl_dtu_inst_vld_d & fpbusy_local_e &
                             ~iferr_d}} &
			                    thr_d  & ~rt_st_thr_d & ~rt_st_thr_e |
                          fp_done |    // set 
			                    fp_wait & ~retr_thr_wakeup & ~killed_uniop_done_e) & 
			                     (~trp_no_retr);
   
   dffr_s #(4) fw_ff(.din (fp_wait_nxt[3:0]),
		               .q   (fp_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign fp_wait_any = (|fp_wait[3:0]);

   // wake up waiting threads when the unit is no longer busy
   // need to qual with trp_no_retr since trp can occur at the same
   // time as unit becoming unbusy.  
   assign mul_wake = mul_wait & {4{~true_mulbusy_e}} & ~trp_no_retr;
   assign div_wake = div_wait & {4{~true_divbusy_e}} & ~trp_no_retr;
   assign fp_wake  = fp_wait & {4{~true_fpbusy_e}} & ~trp_no_retr;
			      
//   assign retr_thr_wakeup = (mul_wait & {4{~swl_dec_mulbusy_e}} |
//	                     div_wait & {4{~swl_dec_divbusy_e}} | 
//	                     fp_wait & {4{~fpbusy_local_e}} | 
//			     wm_stbwait & stb_retry);

   assign retr_thr_wakeup = mul_wake | div_wake | fp_wake;
//	                  |  (wm_stbwait & stb_retry & ~wm_other);
   
   assign fp_thr[0] = ~ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
   assign fp_thr[1] = ~ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];
   assign fp_thr[2] =  ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
   assign fp_thr[3] =  ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];

   // Delay mul div completion to prevent one thread from hogging mul and div
   assign mul_done = exu_ifu_longop_done_g & mul_busy_e & {4{mul_wait_any}};
   assign div_done = exu_ifu_longop_done_g & div_busy_e & {4{div_wait_any}};
   assign fp_done = fp_thr & {4{ffu_ifu_fpop_done_w2}} & {4{fp_wait_any}};   

   assign fp_thrrdy = fp_thr & {4{ffu_ifu_fpop_done_w2}} & {4{~fp_wait_any}};
   
   // don't complete if another mul/div is waiting
   assign exu_lop_done = (exu_ifu_longop_done_g & 
			                    (~mul_busy_e | {4{~mul_wait_any}}) &
			                    (~div_busy_e | {4{~div_wait_any}}));

   // TBD:
   // 1.  Put in similar wakeup sequence for fp completion -- done
   // 2.  Is it worth doing a round robin wakeup when a deadlock problem
   //     exists even in that case? -- no need with lru scheduler

   
   //--------------------------
   // Store buffer flow control
   //--------------------------
   // store pipe
   assign st_inst_qual_d = dec_swl_st_inst_d & fcl_dtu_inst_vld_d;
   dff_s ste_ff(.din (st_inst_qual_d),
	            .q   (st_inst_e),
	            .clk (clk),
	            .se  (se), .si(), .so());
   assign st_inst_qual_e = st_inst_e & ~dtu_inst_anull_e;

   dff_s stm_ff(.din (st_inst_qual_e),
	            .q   (st_inst_m),
	            .clk (clk),
	            .se  (se), .si(), .so());
   dff_s stg_ff(.din (st_inst_m),
	            .q   (st_inst_g),
	            .clk (clk),
	            .se  (se), .si(), .so());

//   assign st_inst_qual_g = st_inst_g & ifu_tlu_inst_vld_w;
//   dff stw2_ff(.din (st_inst_qual_g),
//	             .q   (st_inst_w2),
//	             .clk (clk),
//               .se  (se), .si(), .so());

   // determine which of the above thread is to the D thread
   assign same_thr_de = (thr_d[0] & thr_e[0] |
			                   thr_d[1] & thr_e[1] |
			                   thr_d[2] & thr_e[2] |
			                   thr_d[3] & thr_e[3]);
   assign same_thr_dg = (thr_d[0] & thr_w[0] |
			                   thr_d[1] & thr_w[1] |
			                   thr_d[2] & thr_w[2] |
			                   thr_d[3] & thr_w[3]);

   assign same_thr_fd = (thr_f[0] & thr_d[0] |
			                   thr_f[1] & thr_d[1] |
			                   thr_f[2] & thr_d[2] |
			                   thr_f[3] & thr_d[3]);
   assign same_thr_fe = (thr_f[0] & thr_e[0] |
			                   thr_f[1] & thr_e[1] |
			                   thr_f[2] & thr_e[2] |
			                   thr_f[3] & thr_e[3]);
   assign same_thr_fm = (thr_f[0] & thr_m[0] |
			                   thr_f[1] & thr_m[1] |
			                   thr_f[2] & thr_m[2] |
			                   thr_f[3] & thr_m[3]);
   assign same_thr_fg = (thr_f[0] & thr_w[0] |
			                   thr_f[1] & thr_w[1] |
			                   thr_f[2] & thr_w[2] |
			                   thr_f[3] & thr_w[3]);

   assign pipe_st_e = same_thr_fe & st_inst_e;
   assign pipe_st_m = same_thr_fm & st_inst_m;
   assign pipe_st_g = same_thr_fg & st_inst_g;
   assign pipe_st_d = same_thr_fd & st_inst_qual_d;

   dff_s #(1) pste_ff(.din (pipe_st_d),
                    .q   (st_thisthr_e),
                    .clk (clk), .se(se), .si(), .so());

   // count the number of stores in the pipe to this thread (0-4)
   assign pipe_st_cnt_ge1 = pipe_st_e | pipe_st_m | pipe_st_g;
//	                          pipe_st_w2;

   assign pipe_st_cnt_ge2 = (pipe_st_e & pipe_st_m |
			                       pipe_st_e & pipe_st_g |
                             pipe_st_m & pipe_st_g);

//   assign pipe_st_cnt_ge2 = (pipe_st_e & pipe_st_m |
//			                       pipe_st_e & pipe_st_g |
//			                       pipe_st_e & pipe_st_w2 |
//			                       pipe_st_m & pipe_st_g |
//			                       pipe_st_m & pipe_st_w2 |
//	                           pipe_st_g & pipe_st_w2);

   assign pipe_st_cnt_ge3 = (pipe_st_e & pipe_st_m & pipe_st_g);
//			                       pipe_st_e & pipe_st_m & pipe_st_w2 |
//			                       pipe_st_e & pipe_st_g & pipe_st_w2 |
//			                       pipe_st_m & pipe_st_g & pipe_st_w2);

//   assign pipe_st_cnt_eq4 = pipe_st_e & pipe_st_m & pipe_st_g & 
//	                          pipe_st_w2;

   dff_s #(3) pstc_reg(.din ({pipe_st_cnt_ge1,
                            pipe_st_cnt_ge2,
                            pipe_st_cnt_ge3}),
                     .q   ({dst_cnt_ge1,
                            dst_cnt_ge2,
                            dst_cnt_ge3}),
                     .clk (clk), .se(se), .si(), .so());
   
   // get the number of taken store buffer entries to this thread
   mux4ds #(4) stbcnt_mux(.dout (stbcnt_s),
			                    .in0  (lsu_ifu_stbcnt0),
			                    .in1  (lsu_ifu_stbcnt1),
			                    .in2  (lsu_ifu_stbcnt2),
			                    .in3  (lsu_ifu_stbcnt3),
			                    .sel0 (thr_f[0]),
			                    .sel1 (thr_f[1]),
			                    .sel2 (thr_f[2]),
			                    .sel3 (thr_f[3]));

   dff_s #(4) stbd_reg(.din (stbcnt_s),
		                 .q   (stbcnt_d),
		                 .clk (clk),
		                 .se  (se), .si(), .so());

   assign all_dst_ge1 = dst_cnt_ge1 | st_thisthr_e;
   assign all_dst_ge2 = dst_cnt_ge1 & st_thisthr_e | dst_cnt_ge2;
   assign all_dst_ge3 = dst_cnt_ge2 & st_thisthr_e | dst_cnt_ge3;
   assign all_dst_eq4 = dst_cnt_ge3 & st_thisthr_e;

   // switch if taken entries + stores in pipe >= 8
   assign switch_store_d = stbcnt_d[3] & fcl_dtu_inst_vld_d | // 8
	            dec_swl_st_inst_d & fcl_dtu_inst_vld_d & 
	            (stbcnt_d[2] & stbcnt_d[1] & stbcnt_d[0] | // 7
		           stbcnt_d[2] & stbcnt_d[1] & all_dst_ge1 | // 6 + 1
		           stbcnt_d[2] & stbcnt_d[0] & all_dst_ge2 | // 5 + 2
		           stbcnt_d[2]               & all_dst_ge3 | // 4 + 3
		           stbcnt_d[1] & stbcnt_d[0] & all_dst_eq4); // 3 + 4

   assign stb_stall = {4{switch_store_d}} & thr_d;
   assign stb_blocked = {lsu_ifu_stbcnt3[3], lsu_ifu_stbcnt2[3],
			                   lsu_ifu_stbcnt1[3], lsu_ifu_stbcnt0[3]};

   dff_s #(4) stbb_reg(.din (stb_blocked),
		                 .q   (stb_blocked_d1),
		                 .clk (clk), .se(se), .si(), .so());
   
   // retract this thread if taken entries + stores in pipe >= 9
   assign retract_store_d = dec_swl_st_inst_d & fcl_dtu_inst_vld_d &
	        (stbcnt_d[3] | // 8
	         stbcnt_d[2] & stbcnt_d[1] & stbcnt_d[0] & all_dst_ge1 | // 7 + 1
	         stbcnt_d[2] & stbcnt_d[1] & all_dst_ge2 |  // 6 + 2
	         stbcnt_d[2] & stbcnt_d[0] & all_dst_ge3 |  // 5 + 3
	         stbcnt_d[2] & all_dst_eq4);                // 4 + 4

   // remember if we retracted a store so that we can clear wmo in 
   // the next cycle
   assign retract_st_next_d = (retract_store_d | retract_iferr_d) & 
                              ~(same_thr_dg & rollback_g) & 
                              ~trp_noretr_d;
   
   dff_s #(1) retr_se(.din (retract_st_next_d),
		                .q   (retract_store_e),
		                .clk (clk), .se (se), .si(), .so());

   // clear wmo if you set it already
   assign clear_wmo_e = retract_store_e & (swc_d & same_thr_de | swc_e);
// assign clear_wmo_e = retract_store_e;   


   // mark a switched out thread for wakeup
//   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d & ~rb_thr_w |   // set
//			                    wm_stbwait & ~stb_retry 
//  			                ~(thr_d & {4{swc_d}}) & 
//			                    ~(thr_e & {4{dec_swl_sta_inst_e & 
//				                               lsu_ifu_ldsta_internal_e}})   // reset
//			                    ) & ~trp_no_retr;  // this reset wins

//   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d & ~rb_thr_w |   // set
//			                    wm_stbwait & ~stb_retry) & ~trp_no_retr;

   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d |   // set
			                    wm_stbwait & ~stb_retry);
   
   dffr_s #(4) stbw_reg(.din (stb_wait_nxt),
		                  .q   (wm_stbwait),
		                  .clk (clk),
		                  .rst (dtu_reset),
		                  .se  (se), .si(), .so());

   // count to 4 and retry 
   dff_s stbrete_ff(.din (switch_store_d),
		              .q   (sw_st_e),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretm_ff(.din (sw_st_e),
		              .q   (sw_st_m),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretg_ff(.din (sw_st_m),
		              .q   (sw_st_g),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretw2_ff(.din (sw_st_g),
		               .q   (sw_st_w2),
		               .clk (clk),
		               .se  (se), .si(), .so());
//   assign stb_retry = {4{sw_st_w2}} & st_thr_w2 & ~stb_blocked;

   assign st_in_pipe = ({4{sw_st_e}} & thr_e |
			                  {4{sw_st_m}} & thr_m |
			                  {4{sw_st_g}} & thr_w |
			                  {4{sw_st_w2}} & st_thr_w2);

   // don't really need to AND with wm_stbwait with current logic, but
   // for future use, this is left as is 
   assign stb_retry = ~stb_blocked_d1 & ~st_in_pipe & wm_stbwait;


   //
   // Quad Stores
   //
   dff_s #(1) stde_ff(.din (dec_swl_std_inst_d),
		                .q   (std_inst_e),
		                .clk (clk), .se(se), .si(), .so());

//   assign stq_inst_e = std_inst_e & lsu_ifu_quad_asi_e & fcl_dtu_inst_vld_e;
   assign std_done_e = std_inst_e & ~lsu_ifu_quad_asi_e & fcl_dtu_inst_vld_e;
   dff_s #(1) stdm_ff(.din (std_done_e),
		                .q   (std_done_m),
		                .clk (clk), .se(se), .si(), .so());
   
//   dff #(1) stqm_ff(.din (stq_inst_e),
//		                .q   (stq_inst_m),
//		                .clk (clk), .se(se), .si(), .so());
//   dff #(1) stqw_ff(.din (stq_inst_m),
//		                .q   (stq_inst_w),
//		                .clk (clk), .se(se), .si(), .so());
//   dff #(1) stqw2_ff(.din (stq_inst_w),
//		                 .q   (stq_inst_w2),
//		                 .clk (clk), .se(se), .si(), .so());

//   assign stq_in_pipe = ({4{stq_inst_m}} & thr_m |
//			                   {4{stq_inst_w}} & thr_w |
//			                   {4{stq_inst_w2}} & st_thr_w2);

//   assign stq_busy = (stq_in_pipe | lsu_ifu_stq_busy);
//   assign stq_wait_next = thr_e & {4{stq_inst_e}} | 
//                 			    stq_wait & stq_busy;
   
//   dffr #(4) stqwait_reg(.din (stq_wait_next),
//		                     .q   (stq_wait),
//		                     .rst (dtu_reset),
//		                     .clk (clk), .se(se), .si(), .so());
//
//   assign stq_done_thr = stq_wait & ~stq_busy | thr_m & {4{std_done_m}};
   
   
   //-----------------------------
   // FPRS
   //-----------------------------
   dff_s #(3) wrtd_w_reg(.din (thr_config_in_m[2:0]),
                        .q   (thr_config_in_w[2:0]),
                        .clk (clk), .se(se), .si(), .so());

   dff_s #(3) wrtd_w2_reg(.din (thr_config_in_w[2:0]),
                        .q   (thr_config_in_w2[2:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign fprs_wrt_data = thr_config_in_w2;
   mux3ds #(3) fprs_mx0(.dout (fprs0_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs0),
		                    .in2  ({fprs0[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[0]),
		                    .sel1 (fprs_sel_old[0]),
		                    .sel2 (fprs_sel_set[0]));
   mux3ds #(3) fprs_mx1(.dout (fprs1_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs1),
		                    .in2  ({fprs1[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[1]),
		                    .sel1 (fprs_sel_old[1]),
		                    .sel2 (fprs_sel_set[1]));
   mux3ds #(3) fprs_mx2(.dout (fprs2_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs2),
		                    .in2  ({fprs2[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[2]),
		                    .sel1 (fprs_sel_old[2]),
		                    .sel2 (fprs_sel_set[2]));
   mux3ds #(3) fprs_mx3(.dout (fprs3_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs3),
		                    .in2  ({fprs3[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[3]),
		                    .sel1 (fprs_sel_old[3]),
		                    .sel2 (fprs_sel_set[3]));

   // make resettable for now.  Eventually change to non-reset
   // Done
   dff_s #(3) t0_fprs(.din (fprs0_nxt),
		                 .q   (fprs0),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t1_fprs(.din (fprs1_nxt),
		                 .q   (fprs1),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t2_fprs(.din (fprs2_nxt),
		                 .q   (fprs2),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t3_fprs(.din (fprs3_nxt),
		                 .q   (fprs3),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());

   assign fprs_en_s = {fprs3[2],fprs2[2],fprs1[2],fprs0[2]};
   assign fpen_vec_s = (tlu_ifu_pstate_pef & fprs_en_s & thr_f);
   assign fpen_s = (|fpen_vec_s[3:0]);
   dff_s #(1) fpend_ff(.din (fpen_s),
		                 .q   (swl_dec_fp_enable_d),
		                 .clk (clk), .se(se), .si(), .so());

   // unprotected since synopsys does not use one hot mux
   mux4ds #(3) curr_fprs_mx(.dout (fprs_d),
			                      .in0  (fprs0),
			                      .in1  (fprs1),
			                      .in2  (fprs2),
			                      .in3  (fprs3),
			                      .sel0 (thr_d[0]),
			                      .sel1 (thr_d[1]),
			                      .sel2 (thr_d[2]),
			                      .sel3 (thr_d[3]));

   dff_s #(3) fprse_reg(.din (fprs_d),
		                  .q   (fprs_e),
		                  .clk (clk), .se(se), .si(), .so());

   assign new_fprs[1] = dec_swl_frf_upper_d | fprs_d[1];
   assign new_fprs[0] = dec_swl_frf_lower_d | fprs_d[0];

   // writes to fprs are done by software
   assign wrt_fprs_w = ifu_tlu_inst_vld_w & dec_swl_wrtfprs_w &
			                 ~flush_all_w;

   dff_s #(1) fpwr_ff(.din (wrt_fprs_w),
                    .q   (wrt_fprs_w2),
                    .clk (clk), .se(se), .si(), .so());
   
   assign sel_wrt = st_thr_w2 & {4{wrt_fprs_w2}};
   assign fprs_sel_set = thr_d & {4{dec_swl_fpop_d & swl_dec_fp_enable_d &
                                    fcl_dtu_inst_vld_d}};
   assign fprs_sel_wrt = ~fprs_sel_set & sel_wrt;
   assign fprs_sel_old = ~sel_wrt & ~fprs_sel_set;

   sink #(52) s0(.in (thrconf_out_e));
   
   
endmodule // sparc_ifu_swl

// Local Variables:
// verilog-library-directories:("../../rtl" ".")
// End:
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_swpla.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lfsr5
//  Description:	
//  The IFQ is the icache input queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_swpla(/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [31:0]  in;
   output 	 out;

   wire [31:0] 	 in;
   reg 		 out;
   

   always @ (in)
     begin
	      if (in[31:30] == 2'b01)            // call
	        out = 1'b1;
	      else if (in[31:30] == 2'b00)       // branch, sethi, nop
	        begin
	           if (in[24:22] == 3'b100) // nop/sethi
	             out = 1'b0;
	           else // branch
	             out = 1'b1;
	        end // if (in[31:30] == 2'b00)
	      else if (in[31:30] == 2'b10)        // arith, shift, mem#, mov
	        begin
	           if (in[24:23] == 2'b11)  // wrpr, vis, save, jmpl
	             out = 1'b1;
	           else if (in[24] == 1'b0) // arith
	             begin
		              if (in[22] == 1'b0) // alu op
		                out = 1'b0;
		              else if ((in[22] == 1'b1) && (in[20:19] == 2'b00))
		                // subc or addc
		                out = 1'b0;
		              else // mul, div
		                out = 1'b1;
	             end // if (in[24] == 1'b0)
	           else // if (in[24:23] == 2'b10)  shft, mov, rdpr, tag
	             begin
		              if (in[22:19] == 4'h4) // mulscc
		                out = 1'b1;
		              else if (in[22] == 1'b0)  // shft, tag
		                out = 1'b0;
		              else if  ((in[22:19] == 4'hc) ||  (in[22:19] == 4'hf)) // mov
		                out = 1'b0;
//		              else if (in[22:19] == 4'ha)  // rdpr
//		                out = 1'b0;
		              else // rdsr, mem#, popc, flushw, rdpr
		                out = 1'b1;
	             end // if ((in[24] == 1'b1) && (in[23] == 1'b0))
	        end // if (in[31:30] == 2'b10)
	      else // ld st
	        begin
//	           if (in[24] & in[22] & in[21] & ~in[20] & in[19]) // prefetch
//	             out = 1'b0;
             if (in[24] | in[23] | ~in[21]) // fp, alt space or ld
	             out = 1'b1;
//	           else if (in[24]) // FP and CAS
//	             out = 1'b1;
//	           else if (in[23] & in[20] & in[19]) // stda
//	             out = 1'b1;
	           else if ((~in[23]) && (in[22:19] == 4'he))  // stx
	             out = 1'b0;
	           else if (in[22:21] == 2'b01) // other st
	             out = 1'b0;
	           else // other atomic
	             out = 1'b1;
	        end // else: !if(in[31:30] == 2'b10)
     end // always @ (in)

   sink #(32) s0(.in (in));
   
endmodule // sparc_ifu_swpla


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_thrcmpl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_thrcmpl
//  Description:	
//  The thread completion block processes the completion signals fomr
//  the different cpu blocks and generates a unified completion
//  signal. 
*/

module sparc_ifu_thrcmpl(/*AUTOARG*/
   // Outputs
   completion, wm_imiss, wm_other, swl_esl_icmiss_out,
   // Inputs
   clk, se, si, reset, fcl_ifq_icmiss_s1, erb_dtu_ifeterr_d1, 
   sw_cond_s, en_spec_g, atr_s, dtu_fcl_thr_active, ifq_dtu_thrrdy, 
   ifq_dtu_pred_rdy, exu_lop_done, branch_done_d, fixedop_done, 
   ldmiss, spec_ld_d, trap, retr_thr_wakeup, flush_wake_w2, 
   ldhit_thr, spec_ld_g, clear_wmo_e, wm_stbwait, stb_retry, 
   rst_thread, trap_thrrdy, thr_s2, thr_e, thr_s1, fp_thrrdy, 
   lsu_ifu_ldst_cmplt, sta_done_e, killed_inst_done_e
   );

   input     clk, se, si, reset;

   input     fcl_ifq_icmiss_s1;
   input     erb_dtu_ifeterr_d1;
   
   input     sw_cond_s;
   input     en_spec_g;
   input     atr_s;

   input [3:0] dtu_fcl_thr_active;
   input [3:0] ifq_dtu_thrrdy,         // I$ miss completion
               ifq_dtu_pred_rdy,
		           exu_lop_done,  // mul, div, wrpr, sav, rest
               branch_done_d,
		           fixedop_done;           // br, rdsr, wrs/pr, 
   input [3:0] ldmiss,
		           spec_ld_d,
		           trap,
		           retr_thr_wakeup,
		           flush_wake_w2,
		           ldhit_thr,
		           spec_ld_g;

   input       clear_wmo_e;
   input [3:0] wm_stbwait,
               stb_retry;

   input [3:0] rst_thread,
		           trap_thrrdy;

   input [3:0] thr_s2,
		           thr_e,
		           thr_s1;
   
   input [3:0] fp_thrrdy;

   input [3:0] lsu_ifu_ldst_cmplt;	   // sta local, ld and atomic done
   
   input       sta_done_e,
		           killed_inst_done_e;        // long lat op was killed
   
   // .. Other completion signals needed
   // 1. STA completion from LSU -- real mem done 10/03, local TBD
   // 2. Atomic completion  -- done
   // 3. membar completion (lsu) -- done
   // 4. flush completion (lsu)
   // 5. FP op completion (ffu)
   // 

   output [3:0] completion;
   output [3:0] wm_imiss;
   output [3:0] wm_other;
   output       swl_esl_icmiss_out;

   // local signals
   wire [3:0]   wm_imiss,
		            wm_other,
		            wmi_nxt,
		            wmo_nxt;

   wire [3:0]   clr_wmo_thr_e;
   
   wire [3:0]   ldst_thrrdy,
		            ld_thrrdy,
		            sta_thrrdy,
		            killed_thrrdy,
		            fp_thrrdy,
                pred_ifq_rdy,
                imiss_thrrdy,
		            other_thrrdy;
   //   wire [3:0] 	can_imiss;
   
   //---------------------------------------------------------------------- 
   // Code begins here
   //----------------------------------------------------------------------
   
   // Thread completion
   // Since an imiss can overlap with anything else, have to make sure
   // the imiss condition has been cleared.
   // Imiss itself has to make sure ALL OTHER conditions have been
   // cleared.  In this code, I am not checking for branches being
   // cleared, since Imiss is assumed to take much longer than a branch.
   // -- may not be a valid assumption, since milhits could be faster

//   assign  can_imiss = fcl_ifq_canthr;
                        // & (wm_imiss | ({4{fcl_ifq_icmiss_s1}} & thr_s1));
   
   dffr_s #(4) wmi_ff(.din (wmi_nxt),
		              .clk (clk),
		              .q   (wm_imiss),
		              .rst (reset),
		              .se  (se), .si(), .so());

   dffr_s #(4) wmo_ff(.din (wmo_nxt),
		              .clk (clk),
		              .q   (wm_other),
		              .rst (reset),
		              .se  (se), .si(), .so());

   assign  wmi_nxt = ({4{fcl_ifq_icmiss_s1}} & thr_s1) | // set
		                   ({4{erb_dtu_ifeterr_d1}} & thr_e) |
			                   (wm_imiss & ~imiss_thrrdy);    // reset

   // clear wm_other when we have a retracted store
   assign  clr_wmo_thr_e = {4{clear_wmo_e}} & thr_e;

   assign  wmo_nxt = (({4{sw_cond_s}} & thr_s2 & ~clr_wmo_thr_e) | 
		                  trap | ldmiss) & dtu_fcl_thr_active | 
                      rst_thread |  // set
		                  wm_other & dtu_fcl_thr_active &
		                  ~(other_thrrdy | spec_ld_d | clr_wmo_thr_e); // reset

   // A load hit signal is always for the load which is being filled
   // to the RF.  If speculation is enabled, the load would have
   // completed even before the hit signal.  So need to suppress the
   // completions signal.

   // load miss, st buf hit, ld/st alternate completion
   assign ldst_thrrdy = lsu_ifu_ldst_cmplt & ~spec_ld_g;   
   assign ld_thrrdy = ldhit_thr & {4{~en_spec_g}};
   assign sta_thrrdy = thr_e & {4{sta_done_e}};
   assign killed_thrrdy = thr_e & {4{killed_inst_done_e}};

   // everthing else
   assign other_thrrdy = (ldst_thrrdy     |     // ld, sta local, atomic
                          branch_done_d   |     // br
	                        ld_thrrdy       |     // load hit without spec
	                        exu_lop_done    |     // mul, div, win mgmt
	                        fixedop_done    |     // rdsr, wrspr
	                        killed_thrrdy   |     // ll op was anulled
    	                    retr_thr_wakeup |     // retract cond compl
	                        flush_wake_w2   |     // wake up after ecc 
	                        fp_thrrdy       |     // fp completion
	                        sta_thrrdy      |     // sta to real memory
                	        trap_thrrdy);         // trap

   // Imiss predicted ready
   assign pred_ifq_rdy = ifq_dtu_pred_rdy & {4{~atr_s}} & dtu_fcl_thr_active;
   assign imiss_thrrdy = pred_ifq_rdy | ifq_dtu_thrrdy;

   assign swl_esl_icmiss_out = (wm_imiss[0] & ~imiss_thrrdy[0]) | wmi_nxt[0];
   
//   assign completion = imiss_thrrdy & (~(wm_other | wm_stbwait) |
//					                               other_thrrdy) |       //see C1
//		                   other_thrrdy & (~(wm_imiss | wmi_nxt));

//   assign completion = (imiss_thrrdy & ~(wm_other | wm_stbwait) |
//		                    other_thrrdy & ~(wm_stbwait | wm_imiss) |
//                        stb_retry & ~(wm_other | wm_imiss) |
//                        imiss_thrrdy & other_thrrdy & ~wm_stbwait |
//                        imiss_thrrdy & stb_retry & ~wm_other |
//                        stb_retry & other_thrrdy & ~wm_imiss);

   assign completion = ((imiss_thrrdy | ~wm_imiss) &
                        (other_thrrdy | ~wm_other) &
                        (stb_retry | ~wm_stbwait) &
                        (wm_imiss | wm_other | wm_stbwait));

   // C1: should we do ~(wm_other | wmo_nxt)??
   // When an imiss is pending, we cannot be doing another fetch, so I
   // don't think so.  It seems nice and symmetric to put it in
   // though, unfortunately this results in a timing problem on swc_s 
   // and trap
   
endmodule // sparc_ifu_thrcmpl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_thrfsm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_swlthrfsm
//  Description:	
//  The switch logithrfsm contains the thread state machine.  
*/

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_thrfsm(/*AUTOARG*/
   // Outputs
   so, thr_state, thr_nstate,
   // Inputs
   completion, schedule, spec_ld, ldhit, stall, int_activate, 
   start_thread, thaw_thread, nuke_thread, rst_thread, switch_out, 
   halt_thread, sw_cond, clk, se, si, reset,
   // jtag interface
   rtap_ifu_thrfsm_wr_en, rtap_ifu_thrfsm_wr_data
   );

   // thread specific input
   input  completion,   // the op this thread was waiting for is complete
	        schedule,     // this thread was just switched in
	        spec_ld,      // speculative switch in
	        ldhit,        // speculation was correct
	        stall,        // stall thread for ldmiss, imiss or trap
	        int_activate, // activate this thread
          halt_thread,
	        start_thread,    // wake up this thread from dead state
	        nuke_thread,
          thaw_thread,
	        rst_thread;      // reset this thread

   // common inputs
   input  switch_out,   // this thread was just switched out
	        sw_cond;	// wait until completion signal is received

   input       clk, se, si, reset;

   // jtag interface
   input rtap_ifu_thrfsm_wr_en;
   input [4:0] rtap_ifu_thrfsm_wr_data;

   output      so;

   output reg [4:0] thr_state;
   output     [4:0] thr_nstate;

   // local signals
   reg [4:0]    next_state;

   assign thr_nstate = next_state;
   
   //
   // Code Begins Here
   //


//   assign       spec_rdy     = thr_state[`TCR_READY];

   always @ (/*AUTOSENSE*/ completion
             or halt_thread or int_activate or ldhit or nuke_thread
             or rst_thread or schedule or spec_ld or stall
             or start_thread or sw_cond or switch_out or thaw_thread 
             or thr_state)
     begin
	      case (thr_state[4:0])
          5'b00000:  // 5'b00000
	          begin
	             if (rst_thread | thaw_thread)
		             next_state = 5'b00001;
	             else if (start_thread)    
		             next_state = 5'b11001;
	             else  // all other interrupts ignored
		             next_state = thr_state[4:0];
	          end

	        5'b00010:  // 5'b00010
	          begin
	             if (nuke_thread)
		             next_state = 5'b00000;
	             else if (rst_thread | thaw_thread)
		             next_state = 5'b00001;
	             else if (int_activate | start_thread) 
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end
	        
	        5'b11001:       // 5'b11001
	          begin
	             if (stall)     
		             // trap also kills inst_s2 and nir
		             // Ldmiss should not happen in this state
		             next_state = 5'b00001;
	             else if (schedule)
		             next_state = 5'b00101;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_RDY

	        5'b00101:       // 5'b00101
	          begin
	             if (stall | sw_cond)
		             // trap also kills inst_s2 and nir
		             // ldmiss should not happen in this state		 
		             next_state = 5'b00001;
	             else if (switch_out)
	               // on an interrupt or thread stall, the fcl has to
	               // switch out the thread and inform the fsm 
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_RUN

	        5'b00001:       // 5'b00001
	          begin
	             if (nuke_thread) 
		             next_state = 5'b00000;
	             else if (halt_thread) // exclusive with above
		             next_state = 5'b00010;
	             else if (stall) // excl. with above
		             next_state = 5'b00001;
	             else if (spec_ld) // exclusive with above
		             next_state = 5'b10011;
	             else if (completion & ~halt_thread)
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_WAIT
	        
	        5'b10011:       // 5'b10011
	          begin
	             if (stall)
		             next_state = 5'b00001;
	             else if (schedule & ~ldhit) // exclusive
		             next_state = 5'b00111;
	             else if (schedule & ldhit)  // exclusive
		             next_state = 5'b00101;
	             else if (ldhit)
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_SPEC_RDY

	        5'b00111:       // 5'b00111
	          begin
	             if (stall | sw_cond)
		             next_state = 5'b00001;
	             else if ((ldhit) & switch_out)
		             next_state = 5'b11001;
	             else if ((ldhit) & ~switch_out)
		             next_state = 5'b00101;
	             else if (~(ldhit) & switch_out)
		             next_state = 5'b10011;
	             // on an interrupt or thread stall, the fcl has to
	             // switch out the thread and inform the fsm 
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_SPEC_RUN

//VCS coverage off
	        default:
	          begin
               // synopsys translate_off
		     // 0in <fire -message "thrfsm.v: Error! Invalid State"

           
	             $display("ILLEGAL_THR_STATE", "thrfsm.v: Error! Invalid State %b\n", thr_state);
                 $finish();
		     
               // synopsys translate_on
	             if (rst_thread)
		             next_state = 5'b00001;
	             else if (nuke_thread)
		             next_state = 5'b00000;		 
	             else 
		             next_state = thr_state[4:0];
	          end
//VCS coverage on
	      endcase // casex({thr_state[4:0]})
     end // always @ (...

   // trin: modifying for thread state overwrite
   // // thread config register (tcr)
   // dffr_s #(5) tcr(.din  (next_state),
	  //            .clk  (clk),
	  //            .q    (thr_state),
	  //            .rst  (reset),
	  //            .se   (se), .so(), .si());

   // flop jtag inputs to not affect timing
   always @ (posedge clk)
   begin
      if (reset)
      begin
         thr_state <= 5'b00000;
      end
      else
      begin
         if (rtap_ifu_thrfsm_wr_en)
            thr_state <= rtap_ifu_thrfsm_wr_data;
         else
            thr_state <= next_state;
      end
   end


endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_errdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_errdp
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// devices.xml


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)



// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_errdp(/*AUTOARG*/
   // Outputs
   so, ifu_lsu_ldxa_data_w2, erb_dtu_imask, erd_erc_tlbt_pe_s1, 
   erd_erc_tlbd_pe_s1, erd_erc_tagpe_s1, erd_erc_nirpe_s1, 
   erd_erc_fetpe_s1, erd_erc_tte_pgsz, 
   // Inputs
   rclk, se, si, erb_reset, itlb_rd_tte_data, itlb_rd_tte_tag, 
   itlb_ifq_paddr_s, wsel_fdp_fetdata_s1, wsel_fdp_topdata_s1, 
   wsel_erb_asidata_s, ict_itlb_tags_f, icv_itlb_valid_f, 
   lsu_ifu_err_addr, spu_ifu_err_addr_w2, fdp_erb_pc_f, 
   exu_ifu_err_reg_m, exu_ifu_err_synd_m, ffu_ifu_err_reg_w2, 
   ffu_ifu_err_synd_w2, tlu_itlb_rw_index_g, erc_erd_pgsz_b0, 
   erc_erd_pgsz_b1, erc_erd_erren_asidata, erc_erd_errstat_asidata, 
   erc_erd_errinj_asidata, ifq_erb_asidata_i2, ifq_erb_wrtag_f, 
   ifq_erb_wrindex_f, erc_erd_asiway_s1_l, fcl_erb_itlbrd_data_s, 
   erc_erd_ld_imask, erc_erd_asisrc_sel_icd_s_l, 
   erc_erd_asisrc_sel_misc_s_l, erc_erd_asisrc_sel_err_s_l, 
   erc_erd_asisrc_sel_itlb_s_l, erc_erd_errasi_sel_en_l, 
   erc_erd_errasi_sel_stat_l, erc_erd_errasi_sel_inj_l, 
   erc_erd_errasi_sel_addr_l, erc_erd_miscasi_sel_ict_l, 
   erc_erd_miscasi_sel_imask_l, erc_erd_miscasi_sel_other_l, 
   erc_erd_asi_thr_l, erc_erd_eadr0_sel_irf_l, 
   erc_erd_eadr0_sel_itlb_l, erc_erd_eadr0_sel_frf_l, 
   erc_erd_eadr0_sel_lsu_l, erc_erd_eadr1_sel_pcd1_l, 
   erc_erd_eadr1_sel_l1pa_l, erc_erd_eadr1_sel_l2pa_l, 
   erc_erd_eadr1_sel_other_l, erc_erd_eadr2_sel_mx1_l, 
   erc_erd_eadr2_sel_wrt_l, erc_erd_eadr2_sel_mx0_l, 
   erc_erd_eadr2_sel_old_l
   );

   input       rclk, 
               se, 
               si, 
               erb_reset;

   input [42:0] itlb_rd_tte_data;   // this is in s1
   input [58:0] itlb_rd_tte_tag;    // this is in s1
   input [39:10] itlb_ifq_paddr_s;
   input [33:0] wsel_fdp_fetdata_s1,    
		            wsel_fdp_topdata_s1;
   input [33:0] wsel_erb_asidata_s;
   
   input [((((39 - (6 + 5))+1) * 4)-1):0] ict_itlb_tags_f;
   input [3:0]              icv_itlb_valid_f;

   input [47:4]  lsu_ifu_err_addr;
   input [39:4]  spu_ifu_err_addr_w2;
   input [47:0]  fdp_erb_pc_f;
   
   input [7:0]   exu_ifu_err_reg_m;
   input [7:0]   exu_ifu_err_synd_m;
   input [5:0]   ffu_ifu_err_reg_w2;
   input [13:0]  ffu_ifu_err_synd_w2;
   input [5:0]   tlu_itlb_rw_index_g;

   input         erc_erd_pgsz_b0,
                 erc_erd_pgsz_b1;

   input [1:0]   erc_erd_erren_asidata;
   input [22:0]  erc_erd_errstat_asidata;
   input [31:0]  erc_erd_errinj_asidata;   
   input [47:0]  ifq_erb_asidata_i2;

   input [(39 - (6 + 5))-1:0] ifq_erb_wrtag_f;
   input [(6 + 5):4]   ifq_erb_wrindex_f;
   
   // mux selects
   input [3:0]  erc_erd_asiway_s1_l;
   input        fcl_erb_itlbrd_data_s;
   input        erc_erd_ld_imask;
   
   input        erc_erd_asisrc_sel_icd_s_l,  
		            erc_erd_asisrc_sel_misc_s_l,
		            erc_erd_asisrc_sel_err_s_l,
		            erc_erd_asisrc_sel_itlb_s_l;

   input        erc_erd_errasi_sel_en_l,
		            erc_erd_errasi_sel_stat_l,
		            erc_erd_errasi_sel_inj_l,
		            erc_erd_errasi_sel_addr_l;

   input        erc_erd_miscasi_sel_ict_l,
		            erc_erd_miscasi_sel_imask_l,
		            erc_erd_miscasi_sel_other_l;

   input [3:0]  erc_erd_asi_thr_l;   
	 
   input [3:0]  erc_erd_eadr0_sel_irf_l,
		            erc_erd_eadr0_sel_itlb_l,
		            erc_erd_eadr0_sel_frf_l,
		            erc_erd_eadr0_sel_lsu_l;
   
   input [3:0]  erc_erd_eadr1_sel_pcd1_l,
		            erc_erd_eadr1_sel_l1pa_l,
		            erc_erd_eadr1_sel_l2pa_l,
		            erc_erd_eadr1_sel_other_l;
   
   input [3:0]  erc_erd_eadr2_sel_mx1_l,
		            erc_erd_eadr2_sel_wrt_l,
		            erc_erd_eadr2_sel_mx0_l,
		            erc_erd_eadr2_sel_old_l;

   
   output       so;
   output [63:0] ifu_lsu_ldxa_data_w2;
   output [38:0] erb_dtu_imask;
//   output [9:0]  erb_ifq_paddr_s;
   
   output [1:0]  erd_erc_tlbt_pe_s1,
		             erd_erc_tlbd_pe_s1;
   output [3:0]  erd_erc_tagpe_s1;
   output        erd_erc_nirpe_s1,
		             erd_erc_fetpe_s1;

   output [2:0]  erd_erc_tte_pgsz;


//   
// local signals   
//

   wire [47:4]   lsu_err_addr;
   
   wire [((((39 - (6 + 5))+1) * 4)-1):0]  ictags_s1;
   wire [3:0]               icv_data_s1;
   reg  [34:0]              tag_asi_data;

   wire [47:4]              t0_eadr_mx0_out,
		                        t1_eadr_mx0_out,
		                        t2_eadr_mx0_out,
		                        t3_eadr_mx0_out,
 		                        t0_eadr_mx1_out,
		                        t1_eadr_mx1_out,
		                        t2_eadr_mx1_out,
		                        t3_eadr_mx1_out;
   
   wire [47:4]              t0_err_addr_nxt,
		                        t0_err_addr,
	 	                        t1_err_addr_nxt,
		                        t1_err_addr,
		                        t2_err_addr_nxt,
		                        t2_err_addr,
		                        t3_err_addr_nxt,
		                        t3_err_addr;
   
   wire [47:4]              err_addr_asidata;
	 
   wire [63:0]              formatted_tte_data,
		                        formatted_tte_tag,
		                        tlb_asi_data,
		                        misc_asi_data,
		                        err_asi_data,
                            ldxa_data_s,
                            ldxa_data_d;
   
   wire [39:4]              paddr_s1,
		                        paddr_d1;
   
   wire [39:4]              ifet_addr_f;
   
   wire [47:0]              pc_s1;
   wire [47:4]              pc_d1;
   wire [7:0]               irfaddr_w,
                            irfsynd_w;
   wire                     irfaddr_4_w;
   wire [5:0]               itlb_asi_index;

   wire [38:0]              imask_next;

   wire                     clk;
   
   
//
// Code Begins Here
//
   assign                   clk = rclk;
   
//-------------
// Tags
//-------------   
   dff_s #(((39 - (6 + 5))+1) * 4) tags_reg(.din (ict_itlb_tags_f),
		                           .q   (ictags_s1),
		                           .clk (clk),
		                           .se  (se), .si(), .so());

   dff_s #(4) vbits_reg(.din (icv_itlb_valid_f[3:0]),
		                  .q   (icv_data_s1),
		                  .clk (clk), .se(se), .si(), .so());

   // // check parity
   // sparc_ifu_par32  tag_par0(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY0_MASK]}),
			//                        .out (erd_erc_tagpe_s1[0]));
   // sparc_ifu_par32  tag_par1(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY1_MASK]}),
			//                        .out (erd_erc_tagpe_s1[1]));
   // sparc_ifu_par32  tag_par2(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY2_MASK]}),
			//                        .out (erd_erc_tagpe_s1[2]));
   // sparc_ifu_par32  tag_par3(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY3_MASK]}),
			//                        .out (erd_erc_tagpe_s1[3]));




















   
      sparc_ifu_par32  tag_par0(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*1-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[0]));
   

      sparc_ifu_par32  tag_par1(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*2-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[1]));
   

      sparc_ifu_par32  tag_par2(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*3-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[2]));
   

      sparc_ifu_par32  tag_par3(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*4-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[3]));
   



   // dp_mux4ds #(32) asitag_mux(.dout (tag_asi_data[31:0]),
			//  .in0  ({icv_data_s1[0], 1'b0, ictags_s1[28], 1'b0, ictags_s1[27:0]}),
			//  .in1  ({icv_data_s1[1], 1'b0, ictags_s1[57], 1'b0, ictags_s1[56:29]}),
			//  .in2  ({icv_data_s1[2], 1'b0, ictags_s1[86], 1'b0, ictags_s1[85:58]}),
			//  .in3  ({icv_data_s1[3], 1'b0, ictags_s1[115], 1'b0, ictags_s1[114:87]}),   
			 // .sel0_l (erc_erd_asiway_s1_l[0]),
			 // .sel1_l (erc_erd_asiway_s1_l[1]),
			 // .sel2_l (erc_erd_asiway_s1_l[2]),
			 // .sel3_l (erc_erd_asiway_s1_l[3]));

wire [((39 - (6 + 5))+2)-1:0] icv_data_s10 = {icv_data_s1[0], ictags_s1[((39 - (6 + 5))+1)*(0+1)-1], ictags_s1[((39 - (6 + 5))+1)*(0+1)-2 -: (39 - (6 + 5))]};
wire [((39 - (6 + 5))+2)-1:0] icv_data_s11 = {icv_data_s1[1], ictags_s1[((39 - (6 + 5))+1)*(1+1)-1], ictags_s1[((39 - (6 + 5))+1)*(1+1)-2 -: (39 - (6 + 5))]};
wire [((39 - (6 + 5))+2)-1:0] icv_data_s12 = {icv_data_s1[2], ictags_s1[((39 - (6 + 5))+1)*(2+1)-1], ictags_s1[((39 - (6 + 5))+1)*(2+1)-2 -: (39 - (6 + 5))]};
wire [((39 - (6 + 5))+2)-1:0] icv_data_s13 = {icv_data_s1[3], ictags_s1[((39 - (6 + 5))+1)*(3+1)-1], ictags_s1[((39 - (6 + 5))+1)*(3+1)-2 -: (39 - (6 + 5))]};


always @ *
begin
tag_asi_data = 0;

         if (erc_erd_asiway_s1_l[0] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s10[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s10[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s10[(39 - (6 + 5))+1];
         end
      

         else if (erc_erd_asiway_s1_l[1] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s11[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s11[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s11[(39 - (6 + 5))+1];
         end
      

         else if (erc_erd_asiway_s1_l[2] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s12[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s12[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s12[(39 - (6 + 5))+1];
         end
      

         else if (erc_erd_asiway_s1_l[3] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s13[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s13[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s13[(39 - (6 + 5))+1];
         end
      

end


//------------------
// Data
//------------------
   // parity check on instruction
   // This may have to be done in the next stage (at least partially)
   
   sparc_ifu_par34 nir_par(.in  (wsel_fdp_topdata_s1[33:0]),
			                     .out (erd_erc_nirpe_s1));
   sparc_ifu_par34 inst_par(.in  (wsel_fdp_fetdata_s1[33:0]),
			                      .out (erd_erc_fetpe_s1));

//----------------------------------------------------------------------
// TLB read data
//----------------------------------------------------------------------

//`ifdef SPARC_HPV_EN
   // don't include v(26) and u(24) bits in parity   
   sparc_ifu_par32 tt_tag_par0(.in  ({itlb_rd_tte_tag[33:27],
				                              itlb_rd_tte_tag[25],
				                              itlb_rd_tte_tag[23:0]}),
			                         .out (erd_erc_tlbt_pe_s1[0]));
//`else
//   // don't include v(28) and u(26) bits in parity
//   sparc_ifu_par32 tt_tag_par0(.in  ({itlb_rd_tte_tag[33:29],
//				                              itlb_rd_tte_tag[27],
//				                              itlb_rd_tte_tag[25:0]}),
//			                         .out (erd_erc_tlbt_pe_s1[0]));
//`endif // !`ifdef SPARC_HPV_EN
   
   
   sparc_ifu_par32 tt_tag_par1(.in  ({7'b0, itlb_rd_tte_tag[58:34]}),
			                         .out (erd_erc_tlbt_pe_s1[1]));
   
   sparc_ifu_par32 tt_data_par0(.in  (itlb_rd_tte_data[31:0]),
				                        .out (erd_erc_tlbd_pe_s1[0]));
   sparc_ifu_par16 tt_data_par1(.in  ({5'b0, itlb_rd_tte_data[42:32]}),
				                        .out (erd_erc_tlbd_pe_s1[1]));

//   assign erd_erc_tte_lock_s1 = itlb_rd_tte_data[`STLB_DATA_L];

   
//`ifdef	SPARC_HPV_EN
   assign erd_erc_tte_pgsz[2:0] = {itlb_rd_tte_data[23],
				                           itlb_rd_tte_data[16],
				                           itlb_rd_tte_data[12]};

   assign formatted_tte_tag[63:0] =
          {
//           `ifdef SUN4V_TAG_RD
           // implement this!
           itlb_rd_tte_tag[58:55],
//           `else
//         {4{itlb_rd_tte_tag[53]}},                                     // 4b
//           `endif

           itlb_rd_tte_tag[54],     // Parity                 1b
           itlb_rd_tte_tag[27], // mxsel2 - b27:22 vld    1b
           itlb_rd_tte_tag[17], // mxsel1 - b21:16 vld    1b
           itlb_rd_tte_tag[13], // mxsel0 - b15:13 vld    1b

           {8{itlb_rd_tte_tag[53]}},                                     // 8b
           itlb_rd_tte_tag[53:34], // 20b
           itlb_rd_tte_tag[33:28], // 6b
           itlb_rd_tte_tag[23:18], // 6b
           itlb_rd_tte_tag[16:14], // 3b
           itlb_rd_tte_tag[12:0]// 13b
           } ;
//`else
//   assign erd_erc_tte_pgsz[2:0] = {itlb_rd_tte_data[`STLB_DATA_21_19_SEL],
//				                           itlb_rd_tte_data[`STLB_DATA_18_16_SEL],
//				                           itlb_rd_tte_data[`STLB_DATA_15_13_SEL]};
//
//   assign formatted_tte_tag[63:0] =
//          {
//           {16{itlb_rd_tte_tag[54]}},                                    // 16b
//           itlb_rd_tte_tag[`STLB_TAG_VA_47_22_HI:`STLB_TAG_VA_47_22_LO], // 26b
//           itlb_rd_tte_tag[`STLB_TAG_VA_21_20_HI:`STLB_TAG_VA_21_20_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_19],
//           itlb_rd_tte_tag[`STLB_TAG_VA_18_17_HI:`STLB_TAG_VA_18_17_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_16],
//           itlb_rd_tte_tag[`STLB_TAG_VA_15_14_HI:`STLB_TAG_VA_15_14_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_13],
//           itlb_rd_tte_tag[`STLB_TAG_CTXT_12_7_HI:`STLB_TAG_CTXT_12_7_LO],//13b
//           itlb_rd_tte_tag[`STLB_TAG_CTXT_6_0_HI:`STLB_TAG_CTXT_6_0_LO]
//           } ;
//`endif // !`ifdef SPARC_HPV_EN
   

//`ifdef	SPARC_HPV_EN
   assign formatted_tte_data[63:0] =
          {      
           itlb_rd_tte_tag[26],           // V    (1b)
           erc_erd_pgsz_b1,                        // pg SZ msb 4m or 512k
           erc_erd_pgsz_b0,                        // pg sz lsb 4m or 64k
           itlb_rd_tte_data[10],       // NFO  (1b)
           itlb_rd_tte_data[9],        // IE   (1b)
           10'b0,                                  // soft2 
           itlb_rd_tte_data[23], // pgsz b2
           itlb_rd_tte_tag[24],

           itlb_rd_tte_data[42],      // Parity   (1b)
           itlb_rd_tte_data[23],   // mxsel2_l (1b)
           itlb_rd_tte_data[16],   // mxsel1_l (1b)
           itlb_rd_tte_data[12],   // mxsel0_l (1b)
  
           2'b0,                                   // unused diag 2b
           1'b0,                                   // ?? PA   (28b)
           itlb_rd_tte_data[41:30],
           itlb_rd_tte_data[29:24],
           itlb_rd_tte_data[22:17],
           itlb_rd_tte_data[15:13],
           6'b0,                                   // ?? 12-7 (6b)
           itlb_rd_tte_data[8],         // L    (1b)
           itlb_rd_tte_data[7],        // CP   (1b)
           itlb_rd_tte_data[6],        // CV   (1b)
           itlb_rd_tte_data[5],         // E    (1b)
           itlb_rd_tte_data[4],         // P    (1b)
           itlb_rd_tte_data[3],         // W    (1b)
	         1'b0
        } ;
//`else // !`ifdef SPARC_HPV_EN
//
//   assign formatted_tte_data[63:0] =
//          {      
//           itlb_rd_tte_tag[`STLB_TAG_V],           // V    (1b)
//           erc_erd_pgsz_b1,                        // pg SZ msb 4m or 512k
//           erc_erd_pgsz_b0,                        // pg sz lsb 4m or 64k
//           itlb_rd_tte_data[`STLB_DATA_NFO],       // NFO  (1b)
//           itlb_rd_tte_data[`STLB_DATA_IE],        // IE   (1b)
//           9'b0,                                   // soft2 58-42 (17b)
//           8'b0,                                   // diag 8b
//	         itlb_rd_tte_tag[`STLB_TAG_U],           // U    (1b)
//           1'b0,                                   // ?? PA   (28b)
//           itlb_rd_tte_data[`STLB_DATA_PA_39_22_HI:`STLB_DATA_PA_39_22_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_21_19_HI:`STLB_DATA_PA_21_19_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_18_16_HI:`STLB_DATA_PA_18_16_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_15_13_HI:`STLB_DATA_PA_15_13_LO],
//           6'b0,                                   // ?? 12-7 (6b)
//           itlb_rd_tte_data[`STLB_DATA_L],         // L    (1b)
//           itlb_rd_tte_data[`STLB_DATA_CP],        // CP   (1b)
//           itlb_rd_tte_data[`STLB_DATA_CV],        // CV   (1b)
//           itlb_rd_tte_data[`STLB_DATA_E],         // E    (1b)
//           itlb_rd_tte_data[`STLB_DATA_P],         // P    (1b)
//           itlb_rd_tte_data[`STLB_DATA_W],         // W    (1b)
//           itlb_rd_tte_data[`STLB_DATA_G]          // G    (1b)
//        } ;
//`endif // !`ifdef SPARC_HPV_EN
   
   

   // mux in all asi values
   dp_mux2es #(64) itlbrd_mux(.dout (tlb_asi_data[63:0]),
			    .in0  (formatted_tte_tag[63:0]),
			    .in1  (formatted_tte_data[63:0]),
			    .sel  (fcl_erb_itlbrd_data_s));

   dp_mux4ds #(64) err_mux(.dout (err_asi_data[63:0]),
			 .in0  ({62'b0, erc_erd_erren_asidata}),
			 .in1  ({32'b0, erc_erd_errstat_asidata, 9'b0}),
			 .in2  ({32'b0, erc_erd_errinj_asidata}),
			 .in3  ({16'b0, err_addr_asidata, 4'b0}),
			 .sel0_l (erc_erd_errasi_sel_en_l),
			 .sel1_l (erc_erd_errasi_sel_stat_l),
			 .sel2_l (erc_erd_errasi_sel_inj_l),
			 .sel3_l (erc_erd_errasi_sel_addr_l));

   dp_mux3ds #(64) misc_asi_mux(.dout (misc_asi_data[63:0]),
			      .in0  ({29'b0, 
				            tag_asi_data[34:0]}),
			      .in1  ({25'b0, erb_dtu_imask}),
			      .in2  (64'b0),
			      .sel0_l (erc_erd_miscasi_sel_ict_l),
			      .sel1_l (erc_erd_miscasi_sel_imask_l),
			      .sel2_l (erc_erd_miscasi_sel_other_l));

   // Final asi data
   // May need to add a flop to this mux output before sending it to the LSU
   dp_mux4ds #(64) final_asi_mux(.dout (ldxa_data_s),
			       .in0  (tlb_asi_data[63:0]),
			       .in1  (err_asi_data),
			       .in2  (misc_asi_data),
			       .in3  ({30'b0,
				             wsel_erb_asidata_s[0],
				             wsel_erb_asidata_s[33:1]}), 
			       .sel0_l (erc_erd_asisrc_sel_itlb_s_l),
			       .sel1_l (erc_erd_asisrc_sel_err_s_l),
			       .sel2_l (erc_erd_asisrc_sel_misc_s_l),
			       .sel3_l (erc_erd_asisrc_sel_icd_s_l));

   dff_s #(64) ldxa_reg(.din (ldxa_data_s),
                      .q   (ldxa_data_d),
                      .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_data_w2 = ldxa_data_d;

				   
//----------------------------------------
// Error Address
//----------------------------------------   

   assign ifet_addr_f = {ifq_erb_wrtag_f[(39 - (6 + 5))-1:0], 
                         ifq_erb_wrindex_f[(6 + 5):4]};

   // pc of latest access
   dff_s #(48) pcs1_reg(.din (fdp_erb_pc_f[47:0]),
		                  .q   (pc_s1[47:0]),
		                  .clk (clk), .se(se), .si(), .so());
   
   // Physical address
   assign paddr_s1[39:10] = itlb_ifq_paddr_s[39:10];
   assign paddr_s1[9:4]   = pc_s1[9:4];
   dff_s #(36) padd_reg(.din (paddr_s1[39:4]),
		                  .q   (paddr_d1[39:4]),
		                  .clk (clk), .se(se), .si(), .so());

//   assign erb_ifq_paddr_s[9:0] = pc_s1[9:0];

   // stage PC one more cycle
   dff_s #(44) pcd1_reg(.din (pc_s1[47:4]),
		                  .q   (pc_d1[47:4]),
		                  .clk (clk), .se(se), .si(), .so());

   // IRF address
   dff_s #(16) irf_reg(.din ({exu_ifu_err_reg_m[7:0],
                            exu_ifu_err_synd_m[7:0]}),
		                 .q   ({irfaddr_w[7:5], 
                            irfaddr_4_w,
                            irfaddr_w[3:0],
                            irfsynd_w[7:0]}),
		                 .clk (clk), .se(se), .si(), .so());

   // fix for bug 5594
   // nand2 + xnor
   assign irfaddr_w[4] = irfaddr_4_w ^ (irfaddr_w[5] & irfaddr_w[3]);

   // itlb asi address
   dff_s #(6) itlbidx_reg(.din (tlu_itlb_rw_index_g),
                        .q   (itlb_asi_index),
                        .clk (clk), .se(se), .si(), .so());


   // lsu error address
   dff_s #(44) lsadr_reg(.din (lsu_ifu_err_addr),
                       .q   (lsu_err_addr),
                       .clk (clk), .se(se), .si(), .so());

	  
   // mux in the different error addresses
   // thread 0
   dp_mux4ds #(44) t0_eadr_mx0(.dout  (t0_eadr_mx0_out),
			     .in0   ({24'b0, irfsynd_w[7:0], 4'b0, irfaddr_w[7:0]}),
			     .in1   ({38'b0, itlb_asi_index}),
			     .in2   ({17'b0, ffu_ifu_err_synd_w2[13:7], 
                    1'b0, ffu_ifu_err_synd_w2[6:0], 
                    6'b0, ffu_ifu_err_reg_w2[5:0]}),
			     .in3   (lsu_err_addr),
			     .sel0_l (erc_erd_eadr0_sel_irf_l[0]),
			     .sel1_l (erc_erd_eadr0_sel_itlb_l[0]),
			     .sel2_l (erc_erd_eadr0_sel_frf_l[0]),
			     .sel3_l (erc_erd_eadr0_sel_lsu_l[0]));

   dp_mux4ds #(44) t0_eadr_mx1(.dout  (t0_eadr_mx1_out),
			     .in0   (pc_d1[47:4]),
			     .in1   ({8'b0, paddr_d1[39:4]}),
			     .in2   ({8'b0, ifet_addr_f}),
			     .in3   ({8'b0, spu_ifu_err_addr_w2[39:4]}),
			     .sel0_l (erc_erd_eadr1_sel_pcd1_l[0]),
			     .sel1_l (erc_erd_eadr1_sel_l1pa_l[0]),
			     .sel2_l (erc_erd_eadr1_sel_l2pa_l[0]),
			     .sel3_l (erc_erd_eadr1_sel_other_l[0]));

   dp_mux4ds #(44) t0_eadr_mx2(.dout  (t0_err_addr_nxt),
			     .in0   (t0_eadr_mx0_out),
			     .in1   (t0_eadr_mx1_out),
			     .in2   (ifq_erb_asidata_i2[47:4]),
			     .in3   (t0_err_addr),
			     .sel0_l (erc_erd_eadr2_sel_mx0_l[0]),
			     .sel1_l (erc_erd_eadr2_sel_mx1_l[0]),
			     .sel2_l (erc_erd_eadr2_sel_wrt_l[0]),
			     .sel3_l (erc_erd_eadr2_sel_old_l[0]));

   dff_s #(44) t0_eadr_reg(.din (t0_err_addr_nxt),
		       .q   (t0_err_addr),
		       .clk (clk), .se(se), .si(), .so());

 // Use two threads unless this is defined

   // thread 1
   dp_mux4ds #(44) t1_eadr_mx0(.dout  (t1_eadr_mx0_out),
                 .in0   ({24'b0, irfsynd_w[7:0], 4'b0, irfaddr_w[7:0]}),
                 .in1   ({38'b0, itlb_asi_index}),
                 .in2   ({17'b0, ffu_ifu_err_synd_w2[13:7],
                    1'b0, ffu_ifu_err_synd_w2[6:0],
                    6'b0, ffu_ifu_err_reg_w2[5:0]}),
                 .in3   (lsu_err_addr),
                 .sel0_l (erc_erd_eadr0_sel_irf_l[1]),
                 .sel1_l (erc_erd_eadr0_sel_itlb_l[1]),
                 .sel2_l (erc_erd_eadr0_sel_frf_l[1]),
                 .sel3_l (erc_erd_eadr0_sel_lsu_l[1]));

   dp_mux4ds #(44) t1_eadr_mx1(.dout  (t1_eadr_mx1_out),
                 .in0   (pc_d1[47:4]),
                 .in1   ({8'b0, paddr_d1[39:4]}),
                 .in2   ({8'b0, ifet_addr_f}),
                 .in3   ({8'b0, spu_ifu_err_addr_w2[39:4]}),
//               .in3   ({44'b0}),
                 .sel0_l (erc_erd_eadr1_sel_pcd1_l[1]),
                 .sel1_l (erc_erd_eadr1_sel_l1pa_l[1]),
                 .sel2_l (erc_erd_eadr1_sel_l2pa_l[1]),
                 .sel3_l (erc_erd_eadr1_sel_other_l[1]));

   dp_mux4ds #(44) t1_eadr_mx2(.dout  (t1_err_addr_nxt),
                 .in0   (t1_eadr_mx0_out),
                 .in1   (t1_eadr_mx1_out),
                 .in2   (ifq_erb_asidata_i2[47:4]),
                 .in3   (t1_err_addr),
                 .sel0_l (erc_erd_eadr2_sel_mx0_l[1]),
                 .sel1_l (erc_erd_eadr2_sel_mx1_l[1]),
                 .sel2_l (erc_erd_eadr2_sel_wrt_l[1]),
                 .sel3_l (erc_erd_eadr2_sel_old_l[1]));

   dff_s #(44) t1_eadr_reg(.din (t1_err_addr_nxt),
               .q   (t1_err_addr),
               .clk (clk), .se(se), .si(), .so());

   // asi read
   dp_mux2ds #(44) asi_eadr_mx(.dout (err_addr_asidata),
                 .in0  (t0_err_addr),
                 .in1  (t1_err_addr),
                 .sel0_l (erc_erd_asi_thr_l[0]),
                 .sel1_l (erc_erd_asi_thr_l[1]));
















































































































































































































































































 // `ifndef CONFIG_NUM_THREADS
   
   // Instruction Mask
   dp_mux2es #(39) imask_en_mux(.dout (imask_next),
			      .in0  (erb_dtu_imask),
			      .in1  (ifq_erb_asidata_i2[38:0]),
			      .sel  (erc_erd_ld_imask));

   // need to reset top 7 bits only
   dffr_s #(39) imask_reg(.din (imask_next),
		      .q   (erb_dtu_imask),
		      .rst (erb_reset),
		      .clk (clk), .se(se), .si(), .so());

   sink #(4) s0(.in (pc_s1[3:0]));
   
endmodule // sparc_ifu_erb

