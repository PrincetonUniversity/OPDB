// ========== Copyright Header Begin ============================================
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ========== Copyright Header End ============================================

//==================================================================================================
//  Filename      : axi_lite_bridge.v
//  Created On    : 2015-10-20
//  Revision      :
//  Author        : Xiaohua Liang & Matthew Matl
//  Company       : Princeton University
//  Email         : xiaohua@princeton.edu & mmatl@princeton.edu
//
//  Description   : Translate the incoming message (in the Piton Messaging
//                  Protocol, via a val/rdy interface) to a series of AXI-Lite
//                  requests.
//==================================================================================================

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




// Uncomment to define USE_GENERIC_SRAM_IMPLEMENTATION to use the old unsynthesizable BRAM
// `define USE_GENERIC_SRAM_IMPLEMENTATION




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

// Tile config

// devices.xml





// NoC interface





















// NodeID decomposition








//========================
//Packet format
//=========================

//Header decomposition































// these shifted fields are added for convienience
// HEADER 2








// HEADER 3








//NoC header information










// Width of MSG_ADDR field - you're probably looking for PHY_ADDR_WIDTH


//Coherence information





//Requests from L15 to L2
// Should always make #0 an error








//condition satisfied

//condition not satisfied

//Both SWAP and LDSTUB are the same for L2









//RISC-V AMO requests









//RISC-V AMO L2-internal phase 1









//RISC-V AMO L2-internal phase 2












//Forward requests from L2 to L15







//Memory requests from L2 to DRAM






//Forward acks from L15 to L2







//Memory acks from memory to L2









//Acks from L2 to L15


//TODO



//Only exist within L2





//`define MSG_TYPE_LOAD_REQ           8'd31 if this is enabled, don't use 31





// These should be defined in l2.vh, not the global defines











//Physical address










//Transition data size












//`define HOME_ID_MASK_X          10:10
//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only


// Tri: dynamically adjust these parameters based on how many tiles are available
//  Assumption: 8x8 topology























































//`define DMBR_TAG_WIDTH 4

//Clumpy Shared Memory






////////////////////////////////////////////
// SOME CONFIGURATION REGISTERS DEFINES
////////////////////////////////////////////
// example: read/write to csm_en would be 0xba_0000_0100

// `define ASI_ADDRESS_MASK    `L15_ADDR_TYPE
// `define CONFIG_ASI_ADDRESS  `L15_ADDR_TYPE_WIDTH'hba










// DMBR Config register 1 fields















// DMBR Config register 2 fields



//Home allocation method






//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only

































//`define TTE_CSM_WIDTH           64
//`define TTE_CSM                 63:0
//`define TTE_CSM_VALID           63
//`define TTE_CSM_SZL             62:61
//`define TTE_CSM_NFO             60
//`define TTE_CSM_IE              59
//`define TTE_CSM_SOFT2           58:49
//`define TTE_CSM_SZH             48
//`define TTE_CSM_DIAG            47:40
//`define TTE_CSM_RES1            39
//`define TTE_CSM_SDID            38:29
//`define TTE_CSM_HDID            28:19
//`define TTE_CSM_LSID            18:13
//`define TTE_CSM_SOFT            12:8
//`define TTE_CSM_RES2            7
//`define TTE_CSM_LOCK            6
//`define TTE_CSM_CP              5
//`define TTE_CSM_CV              4
//`define TTE_CSM_E               3
//`define TTE_CSM_P               2
//`define TTE_CSM_W               1
//`define TTE_CSM_RES3            0







//`define HOME_ID_X_POS_WIDTH         3
//`define HOME_ID_X_POS               2:0
//`define HOME_ID_Y_POS_WIDTH         3
//`define HOME_ID_Y_POS               5:3

// Packet format for home id





/////////////////////////////////////
// BIST
/////////////////////////////////////

// the data width from tap to individual sram wrappers



//deprecated































/////////////////////////////////////
// IDs for JTAG-Core interface
/////////////////////////////////////

// 48b for writing the PC reset vector

// 94b for reading the sscan data











// Execution Drafting Synchronization Method Values





// Execution Drafting timeout counter bit width


// Configuration registers












// Execution Drafting configuration register bit positions








// Execution Drafting configuration register default values
// ED disabled, STSM sync method, LFSR seed = 16'b0, LFSR load = 1'b0,
// Counter Timeout = 16'd32



//Clumpy sharer memory configuration registers



























// this is non-standard


module noc_axilite_bridge #(
    // SLAVE_RESP_BYTEWIDTH = 0 enables variable width accesses
    // note that the accesses are still 64bit, but the
    // write-enables are generated according to the access size
    parameter SLAVE_RESP_BYTEWIDTH = 4,
    // swap endianess, needed when used in conjunction with a little endian core like Ariane
    parameter SWAP_ENDIANESS       = 0,
    // shift unaligned read data
    parameter ALIGN_RDATA          = 1
) (
    // Clock + Reset
    input  wire                                   clk,
    input  wire                                   rst,

    // Memory Splitter -> AXI SPI
    input  wire                                   splitter_bridge_val,
    input  wire [64-1:0]             splitter_bridge_data,
    output wire                                   bridge_splitter_rdy,

    // Memory Splitter <- AXI SPI
    output  reg                                   bridge_splitter_val,
    output  reg  [64-1:0]            bridge_splitter_data,
    input  wire                                   splitter_bridge_rdy,

    // AXI Write Address Channel Signals
    output  reg  [11-1:0]   m_axi_awaddr,
    output  reg                                   m_axi_awvalid,
    input  wire                                   m_axi_awready,

    // AXI Write Data Channel Signals
    output wire  [32-1:0]   m_axi_wdata,
    output  reg  [32/8-1:0] m_axi_wstrb,
    output  reg                                   m_axi_wvalid,
    input  wire                                   m_axi_wready,

    // AXI Read Address Channel Signals
    output  reg  [11-1:0]   m_axi_araddr,
    output  reg                                   m_axi_arvalid,
    input                                         m_axi_arready,

    // AXI Read Data Channel Signals
    input  wire [32-1:0]    m_axi_rdata,
    input  wire [2-1:0]    m_axi_rresp,
    input  wire                                   m_axi_rvalid,
    output  reg                                   m_axi_rready,

    // AXI Write Response Channel Signals
    input  wire [2-1:0]    m_axi_bresp,
    input  wire                                   m_axi_bvalid,
    output reg                                    m_axi_bready,

    // this does not belong to axi lite and is non-standard
    output  reg  [3-1:0]   w_reqbuf_size,
    output  reg  [3-1:0]   r_reqbuf_size
);

//==============================================================================
// Local Parameters
//==============================================================================

// States for Incoming Piton Messages
localparam MSG_STATE_INVAL      = 3'd0; // Invalid Message
localparam MSG_STATE_HEADER_0   = 3'd1; // Header 0
localparam MSG_STATE_HEADER_1   = 3'd2; // Header 1
localparam MSG_STATE_HEADER_2   = 3'd3; // Header 2
localparam MSG_STATE_DATA       = 3'd4; // Data Lines

// Types for Incoming Piton Messages
localparam MSG_TYPE_INVAL       = 2'd0; // Invalid Message
localparam MSG_TYPE_LOAD        = 2'd1; // Load Request
localparam MSG_TYPE_STORE       = 2'd2; // Store Request

// States for Buffer Status
localparam BUF_STATUS_INCOMP    = 2'd0; // Buffer not yet filled by one complete request/response
localparam BUF_STATUS_COMP      = 2'd1; // Buffer contains a complete but unsent request
localparam BUF_STATUS_WAITRESP  = 2'd2; // Request sent via AXI, waiting on response
localparam BUF_STATUS_RESPSEND  = 2'd3; // Response waiting to forward back to memory splitter

// ACK's
localparam LOAD_ACK = 1'd0;
localparam STORE_ACK = 1'd1;

//==============================================================================
// Local Variables
//==============================================================================

// Meta-registers for tracking incoming Piton packets (used in parsing)
 reg  [2:0]                          splitter_io_msg_state_f;
 reg  [1:0]                          splitter_io_msg_type_f;
 reg  [8-1:0]        splitter_io_msg_counter_f;

// Buffer registers for load requests
 reg  [64-1:0]          r_req_buf_header0_f;
 reg  [64-1:0]          r_req_buf_header1_f;
 reg  [64-1:0]          r_req_buf_header2_f;
 reg  [1:0]                          r_req_buf_status_f;

// Buffer registers for store requests
 reg  [64-1:0]          w_req_buf_header0_f;
 reg  [64-1:0]          w_req_buf_header1_f;
 reg  [64-1:0]          w_req_buf_header2_f;
 reg  [64-1:0]          w_req_buf_data0_f;
 wire [1:0]                          w_req_buf_status;
 reg  [1:0]                          w_addr_req_buf_status_f;
 reg  [1:0]                          w_data_req_buf_status_f;

// Buffer registers for load responses
 reg  [64-1:0]          r_resp_buf_header0_f;
 reg  [32-1:0] r_resp_buf_data0_f;
 reg  [2-1:0] r_resp_buf_rresp_f;
 reg  [1:0]                          r_resp_buf_status_f;

// Buffer registers for store responses
 reg  [64-1:0]          w_resp_buf_header0_f;
 reg  [2-1:0] w_resp_buf_bresp_f;
 wire [1:0]                          w_resp_buf_status;
 reg  [1:0]                          w_addr_resp_buf_status_f;
 reg  [1:0]                          w_data_resp_buf_status_f;

// Helper Signals for saving requests
 wire                         splitter_io_go;
 wire                         splitter_io_load_go;
 wire                         splitter_io_store_go;

 wire                         splitter_io_msg_is_load;
 wire                         splitter_io_msg_is_store;
 wire                         splitter_io_msg_is_load_next;
 wire                         splitter_io_msg_is_store_next;

 wire [2:0]                   splitter_io_msg_state_next;
 wire [2:0]                   splitter_io_msg_type_mux_out;
 wire [2:0]                   splitter_io_msg_type_next;
 wire [8-1:0] splitter_io_msg_counter_next;

// Helper Signals for sending responses
 wire                         m_axi_ar_go;
 wire                         m_axi_w_go;
 wire                         m_axi_aw_go;

 wire                         m_axi_b_go;
 wire                         m_axi_r_go;
 reg  [64-1:0]   a_axi_rdata_shifted;
 wire [64-1:0]   a_axi_rdata_masked;

 wire [64-1:0]   r_resp_buf_header0_next;
 wire [64-1:0]   w_resp_buf_header0_next;

 reg  [8-1:0] io_splitter_ack_load_counter_f;
 reg                          io_splitter_arb_f;
 reg                          io_splitter_ack_mux_sel;

 wire                         r_resp_buf_val;
 wire                         w_resp_buf_val;
 wire [64-1:0]   io_splitter_ack_store;
 wire [64-1:0]   io_splitter_ack_load;
 wire                         io_splitter_ack_load_go;
 wire                         io_splitter_ack_store_go;

//==============================================================================
// Read Requests From Splitter
//==============================================================================

    // What type of message is arriving currently?
    assign splitter_io_msg_type_mux_out =
        (!splitter_bridge_val) ? MSG_TYPE_INVAL :
        (((splitter_bridge_data[21:14] == 8'd31   )  ||
          (splitter_bridge_data[21:14] == 8'd14)  ||
          (splitter_bridge_data[21:14] == 8'd19   )     ) ? MSG_TYPE_LOAD  :
         ((splitter_bridge_data[21:14] == 8'd2   ) ||
          (splitter_bridge_data[21:14] == 8'd15) ||
          (splitter_bridge_data[21:14] == 8'd20   )    ) ? MSG_TYPE_STORE :
                                                                            MSG_TYPE_INVAL );

    // What type of message will we be receiving?
    assign splitter_io_msg_type_next =
        (splitter_io_msg_state_next == MSG_STATE_INVAL   ) ? MSG_TYPE_INVAL               :
        (splitter_io_msg_state_next == MSG_STATE_HEADER_0) ? splitter_io_msg_type_mux_out :
                                                             splitter_io_msg_type_f       ;
    // Is the current message a load or a store?
    assign splitter_io_msg_is_load       = (splitter_io_msg_type_f    == MSG_TYPE_LOAD );
    assign splitter_io_msg_is_store      = (splitter_io_msg_type_f    == MSG_TYPE_STORE);

    // Is the incoming message a load or a store?
    assign splitter_io_msg_is_load_next  = (splitter_io_msg_type_next == MSG_TYPE_LOAD );
    assign splitter_io_msg_is_store_next = (splitter_io_msg_type_next == MSG_TYPE_STORE);

    // Should we read data from splitter_bridge_data?
    assign splitter_io_go = splitter_bridge_val && bridge_splitter_rdy;

    // Should we read a load request (store request)?
    assign splitter_io_load_go  = splitter_io_msg_is_load_next  && splitter_io_go && (r_req_buf_status_f == BUF_STATUS_INCOMP);
    assign splitter_io_store_go = splitter_io_msg_is_store_next && splitter_io_go && (w_req_buf_status   == BUF_STATUS_INCOMP);

    // Next-State logic for incoming message parser
    assign splitter_io_msg_state_next =
        (splitter_io_msg_state_f == MSG_STATE_INVAL   ) ? MSG_STATE_HEADER_0  :
        (splitter_io_msg_state_f == MSG_STATE_HEADER_0) ? MSG_STATE_HEADER_1  :
        (splitter_io_msg_state_f == MSG_STATE_HEADER_1) ? MSG_STATE_HEADER_2  :
        (splitter_io_msg_counter_f == 0               ) ? MSG_STATE_HEADER_0  :
        (splitter_io_msg_state_f == MSG_STATE_HEADER_2) ? MSG_STATE_DATA      :
        (splitter_io_msg_state_f == MSG_STATE_DATA    ) ? MSG_STATE_DATA      :
                                                          MSG_STATE_INVAL     ;

    // Next-value logic for message counter
    assign splitter_io_msg_counter_next =
        (splitter_io_msg_state_next == MSG_STATE_HEADER_0) ? splitter_bridge_data[29:22] :
                                                             splitter_io_msg_counter_f - 1'b1  ;

    //--------------------------------------------------------------------------
    // Sequential Block for Splitter FSM State
    //--------------------------------------------------------------------------
    always @(posedge clk) begin
        if (rst) begin
            splitter_io_msg_state_f   <= MSG_STATE_INVAL;
            splitter_io_msg_type_f    <= MSG_TYPE_INVAL;
            splitter_io_msg_counter_f <= {8{1'b0}};
        end
        else begin
            splitter_io_msg_state_f   <= splitter_io_go ? splitter_io_msg_state_next
                                                        : splitter_io_msg_state_f;
            splitter_io_msg_type_f    <= splitter_io_go ? splitter_io_msg_type_next
                                                        : splitter_io_msg_type_f;
            splitter_io_msg_counter_f <= splitter_io_go ? splitter_io_msg_counter_next
                                                        : splitter_io_msg_counter_f;
        end
    end

    //--------------------------------------------------------------------------
    // Read headers and data for a load request
    //--------------------------------------------------------------------------
    always @(posedge clk) begin
        if (rst) begin
            r_req_buf_header0_f <= {64{1'b0}};
            r_req_buf_header1_f <= {64{1'b0}};
            r_req_buf_header2_f <= {64{1'b0}};
            r_req_buf_status_f  <= BUF_STATUS_INCOMP;
        end
        else begin
            r_req_buf_header0_f <= (splitter_io_load_go &
                                    (splitter_io_msg_state_next == MSG_STATE_HEADER_0)) ? splitter_bridge_data :
                                                                                          r_req_buf_header0_f  ;
            r_req_buf_header1_f <= (splitter_io_load_go &
                                    (splitter_io_msg_state_next == MSG_STATE_HEADER_1)) ? splitter_bridge_data :
                                                                                          r_req_buf_header1_f  ;
            r_req_buf_header2_f <= (splitter_io_load_go &
                                    (splitter_io_msg_state_next == MSG_STATE_HEADER_2)) ? splitter_bridge_data :
                                                                                          r_req_buf_header2_f  ;
            r_req_buf_status_f  <= (splitter_io_load_go &
                                    (splitter_io_msg_state_next == MSG_STATE_HEADER_2)) ? BUF_STATUS_COMP      :
                                   (m_axi_ar_go)                                        ? BUF_STATUS_INCOMP    :
                                                                                          r_req_buf_status_f   ;
        end
    end

    //--------------------------------------------------------------------------
    // Read headers and data for a store request
    //--------------------------------------------------------------------------
    wire    w_status_update;
    assign  w_status_update =   splitter_io_store_go &
                                (splitter_io_msg_state_next == MSG_STATE_DATA) &
                                (splitter_io_msg_counter_f == 8'd1);

    always @(posedge clk) begin
        if (rst) begin
            w_req_buf_header0_f     <= {64{1'b0}};
            w_req_buf_header1_f     <= {64{1'b0}};
            w_req_buf_header2_f     <= {64{1'b0}};
            w_req_buf_data0_f       <= {64{1'b0}};
            w_addr_req_buf_status_f <= BUF_STATUS_INCOMP;
            w_data_req_buf_status_f <= BUF_STATUS_INCOMP;
        end
        else begin
            w_req_buf_header0_f     <= (splitter_io_store_go &
                                        (splitter_io_msg_state_next == MSG_STATE_HEADER_0)) ? splitter_bridge_data    :
                                                                                              w_req_buf_header0_f     ;
            w_req_buf_header1_f     <= (splitter_io_store_go &
                                        (splitter_io_msg_state_next == MSG_STATE_HEADER_1)) ? splitter_bridge_data    :
                                                                                              w_req_buf_header1_f     ;
            w_req_buf_header2_f     <= (splitter_io_store_go &
                                        (splitter_io_msg_state_next == MSG_STATE_HEADER_2)) ? splitter_bridge_data    :
                                                                                              w_req_buf_header2_f     ;
            w_req_buf_data0_f       <= (splitter_io_store_go &
                                        (splitter_io_msg_state_next == MSG_STATE_DATA))     ? splitter_bridge_data    :
                                                                                              w_req_buf_data0_f       ;
            w_addr_req_buf_status_f <= w_status_update                                      ? BUF_STATUS_COMP         :
                                       m_axi_aw_go                                          ? BUF_STATUS_INCOMP       :
                                                                                              w_addr_req_buf_status_f ;
            w_data_req_buf_status_f <= w_status_update                                      ? BUF_STATUS_COMP         :
                                       m_axi_w_go                                           ? BUF_STATUS_INCOMP       :
                                                                                              w_data_req_buf_status_f ;
        end
    end

    // Calculate Store Request Status
    assign w_req_buf_status =
        ((w_addr_req_buf_status_f == BUF_STATUS_INCOMP) &&
         (w_data_req_buf_status_f == BUF_STATUS_INCOMP)    ) ? BUF_STATUS_INCOMP :
                                                               BUF_STATUS_COMP   ;

//==============================================================================
// Forward Requests to AXI
//==============================================================================

    wire [64-1:0]          paddings;
    reg  [32-1:0] m_axi_wdata_tmp;

    assign paddings = 0;


    // Calculate Valid, Addr, Data signals
    always @ (*) begin
        // Write Address Channel
        m_axi_awvalid = (w_req_buf_status == BUF_STATUS_COMP) && (w_addr_resp_buf_status_f == BUF_STATUS_INCOMP);
        m_axi_awaddr = {paddings[64-1:40], w_req_buf_header1_f[(16 + 40 - 1):(16 + 40 - 1)-39]};

        // Write Data Channel
        m_axi_wvalid    = (w_req_buf_status == BUF_STATUS_COMP) && (w_data_resp_buf_status_f == BUF_STATUS_INCOMP);
        m_axi_wdata_tmp = w_req_buf_data0_f[32-1:0];

        // Read Address Channel
        m_axi_arvalid = (r_req_buf_status_f == BUF_STATUS_COMP) && (r_resp_buf_status_f == BUF_STATUS_INCOMP);
        m_axi_araddr = {paddings[64-1:40], r_req_buf_header1_f[(16 + 40 - 1):(16 + 40 - 1)-39]};
    end

    // Calculate data size (which bytes are valid in our word)
    always @ (*) begin
        if (w_req_buf_header1_f[10:8] == 3'b000) begin
            m_axi_wstrb   = 8'b00000000;
            w_reqbuf_size = 3'b00;
        end
        else if (w_req_buf_header1_f[10:8] == 3'b001) begin
            m_axi_wstrb   = 8'b00000001;
            w_reqbuf_size = 3'b00;
        end
        else if (w_req_buf_header1_f[10:8] == 3'b010) begin
            m_axi_wstrb   = 8'b00000011;
            w_reqbuf_size = 3'b01;
        end
        else if (w_req_buf_header1_f[10:8] == 3'b011) begin
            m_axi_wstrb   = 8'b00001111;
            w_reqbuf_size = 3'b10;
        end
        else if (w_req_buf_header1_f[10:8] == 3'b100) begin
            m_axi_wstrb   = 8'b11111111;
            w_reqbuf_size = 3'b11;
        end
        else begin
            m_axi_wstrb   = 8'b11111111;
            w_reqbuf_size = 3'b11;
        end
    end

    generate
        if (SWAP_ENDIANESS) begin
            initial begin : p_endianess_check
              if (!(32 == 64 && 64 == 64))
                  $fatal(1,"swapped endianess only works for 64bit NOC and AXI bus");
            end
            // this only works for 64bits
            // the byte enables are already generated correctly and need not be swapped
            assign m_axi_wdata[56 +: 8] = m_axi_wdata_tmp[ 0 +: 8];
            assign m_axi_wdata[48 +: 8] = m_axi_wdata_tmp[ 8 +: 8];
            assign m_axi_wdata[40 +: 8] = m_axi_wdata_tmp[16 +: 8];
            assign m_axi_wdata[32 +: 8] = m_axi_wdata_tmp[24 +: 8];
            assign m_axi_wdata[24 +: 8] = m_axi_wdata_tmp[32 +: 8];
            assign m_axi_wdata[16 +: 8] = m_axi_wdata_tmp[40 +: 8];
            assign m_axi_wdata[ 8 +: 8] = m_axi_wdata_tmp[48 +: 8];
            assign m_axi_wdata[ 0 +: 8] = m_axi_wdata_tmp[56 +: 8];
        end else begin
            assign m_axi_wdata = m_axi_wdata_tmp;
        end
    endgenerate

    assign m_axi_ar_go = m_axi_arvalid && m_axi_arready;
    assign m_axi_w_go  = m_axi_wvalid & m_axi_wready;
    assign m_axi_aw_go = m_axi_awvalid & m_axi_awready;

//==============================================================================
// Receive AXI Response and Create Piton Response
//==============================================================================

    // Set ready signals
    always @( * ) begin
        m_axi_rready = (r_resp_buf_status_f == BUF_STATUS_WAITRESP);
        m_axi_bready = (w_resp_buf_status == BUF_STATUS_WAITRESP);
    end

    // Create response header
    assign r_resp_buf_header0_next[63:50] = r_req_buf_header2_f[63:50];
    assign r_resp_buf_header0_next[49:42]      = r_req_buf_header2_f[49:42];
    assign r_resp_buf_header0_next[41:34]      = r_req_buf_header2_f[41:34];
    assign r_resp_buf_header0_next[33:30]  = r_req_buf_header2_f[33:30]; //TODO check this...
    assign r_resp_buf_header0_next[29:22]     = 8'd8; //none loads always return 8 words // TODO
    assign r_resp_buf_header0_next[21:14]       = (r_req_buf_header0_f[21:14] == 8'd14) ? 8'd26 :
                                                      (r_req_buf_header0_f[21:14] == 8'd19) ? 8'd24 :
                                                      8'dx;
    assign r_resp_buf_header0_next[13:6]     = r_req_buf_header0_f[13:6];//TODO check this...
    assign r_resp_buf_header0_next[5:0]  = 6'd0; //reserved bits

    assign w_resp_buf_header0_next[63:50] = w_req_buf_header2_f[63:50];
    assign w_resp_buf_header0_next[49:42]      = w_req_buf_header2_f[49:42];
    assign w_resp_buf_header0_next[41:34]      = w_req_buf_header2_f[41:34];
    assign w_resp_buf_header0_next[33:30]  = w_req_buf_header2_f[33:30]; //TODO check this...
    assign w_resp_buf_header0_next[29:22]     = 8'd0;
    assign w_resp_buf_header0_next[21:14]       = (w_req_buf_header0_f[21:14] == 8'd15) ? 8'd27 :
                                                      (w_req_buf_header0_f[21:14] == 8'd20) ? 8'd25 :
                                                      8'dx;
    assign w_resp_buf_header0_next[13:6]     = w_req_buf_header0_f[13:6];//TODO check this...
    assign w_resp_buf_header0_next[5:0]  = 6'd0; //reserved bits

    // Calculate whether we're ready to accept a response
    assign m_axi_b_go = m_axi_bready && m_axi_bvalid;
    assign m_axi_r_go = m_axi_rready && m_axi_rvalid;


    // Shift AXI read data over so that the desired data is at the lowest bits
    generate
      if (ALIGN_RDATA) begin
        always @( * ) begin
            a_axi_rdata_shifted = (m_axi_rdata >> {m_axi_araddr[2:0], 3'b000});
        end
      end else begin
        always @( * ) begin
            a_axi_rdata_shifted = m_axi_rdata;
        end
      end
    endgenerate
    //`define PITON_FIXED_REQSIZE 1
    reg  [64-1:0]   a_axi_rdata_masked_tmp;

    generate
      if (SLAVE_RESP_BYTEWIDTH <= 0) begin
        // Select and clone the desired bytes
        always @( * ) begin
            case (r_req_buf_header1_f[10:8])
                3'b000: begin
                    a_axi_rdata_masked_tmp = {8{8'd0}};
                    r_reqbuf_size          = 3'b00;
                end
                3'b001: begin
                    a_axi_rdata_masked_tmp = {8{a_axi_rdata_shifted[7:0]}};
                    r_reqbuf_size          = 3'b00;
                end
                3'b010: begin
                    a_axi_rdata_masked_tmp = {4{a_axi_rdata_shifted[15:0]}};
                    r_reqbuf_size          = 3'b01;
                end
                3'b011: begin
                    a_axi_rdata_masked_tmp = {2{a_axi_rdata_shifted[31:0]}};
                    r_reqbuf_size          = 3'b10;
                end
                3'b100: begin
                    a_axi_rdata_masked_tmp = a_axi_rdata_shifted;
                    r_reqbuf_size          = 3'b11;
                end
                default: begin
                    a_axi_rdata_masked_tmp = a_axi_rdata_shifted;
                    r_reqbuf_size          = 3'b11;
                end
            endcase
        end
      end else if (SLAVE_RESP_BYTEWIDTH == 1) begin
          always @( * ) begin
              a_axi_rdata_masked_tmp = {8{m_axi_rdata[7:0]}};
              r_reqbuf_size          = 3'b00;

          end
      end else if (SLAVE_RESP_BYTEWIDTH == 2) begin
          always @( * ) begin
              a_axi_rdata_masked_tmp = {4{m_axi_rdata[15:0]}};
              r_reqbuf_size          = 3'b01;
          end
      end else if (SLAVE_RESP_BYTEWIDTH == 4) begin
          always @( * ) begin
              a_axi_rdata_masked_tmp = {2{m_axi_rdata[31:0]}};
              r_reqbuf_size          = 3'b10;
          end
      end else if (SLAVE_RESP_BYTEWIDTH == 8) begin
          always @( * ) begin
              a_axi_rdata_masked_tmp = m_axi_rdata;
              r_reqbuf_size          = 3'b11;
          end
      end else begin
          always @( * ) begin
              a_axi_rdata_masked_tmp = m_axi_rdata;
              r_reqbuf_size          = 3'b11;
          end
      end
    endgenerate

    generate
        if (SWAP_ENDIANESS) begin
            assign a_axi_rdata_masked[56 +: 8] = a_axi_rdata_masked_tmp[ 0 +: 8];
            assign a_axi_rdata_masked[48 +: 8] = a_axi_rdata_masked_tmp[ 8 +: 8];
            assign a_axi_rdata_masked[40 +: 8] = a_axi_rdata_masked_tmp[16 +: 8];
            assign a_axi_rdata_masked[32 +: 8] = a_axi_rdata_masked_tmp[24 +: 8];
            assign a_axi_rdata_masked[24 +: 8] = a_axi_rdata_masked_tmp[32 +: 8];
            assign a_axi_rdata_masked[16 +: 8] = a_axi_rdata_masked_tmp[40 +: 8];
            assign a_axi_rdata_masked[ 8 +: 8] = a_axi_rdata_masked_tmp[48 +: 8];
            assign a_axi_rdata_masked[ 0 +: 8] = a_axi_rdata_masked_tmp[56 +: 8];
        end else begin
            assign a_axi_rdata_masked = a_axi_rdata_masked_tmp;
        end
    endgenerate


    //--------------------------------------------------------------------------
    // Create Store Response
    //--------------------------------------------------------------------------
    always @(posedge clk) begin
        if (rst) begin
            w_resp_buf_header0_f     <=  {64{1'b0}};
            w_resp_buf_bresp_f       <=  {2{1'b0}};
            w_addr_resp_buf_status_f <=  BUF_STATUS_INCOMP;
            w_data_resp_buf_status_f <=  BUF_STATUS_INCOMP;
        end
        else begin
            w_resp_buf_header0_f     <=  m_axi_aw_go              ? w_resp_buf_header0_next  :
                                                                    w_resp_buf_header0_f     ;
            w_resp_buf_bresp_f       <=  m_axi_b_go               ? m_axi_bresp              :
                                                                    w_resp_buf_bresp_f       ;
            w_addr_resp_buf_status_f <=  m_axi_aw_go              ? BUF_STATUS_WAITRESP      :
                                         m_axi_b_go               ? BUF_STATUS_RESPSEND      :
                                         io_splitter_ack_store_go ? BUF_STATUS_INCOMP        :
                                                                    w_addr_resp_buf_status_f ;
            w_data_resp_buf_status_f <=  m_axi_w_go               ? BUF_STATUS_WAITRESP      :
                                         m_axi_b_go               ? BUF_STATUS_RESPSEND      :
                                         io_splitter_ack_store_go ? BUF_STATUS_INCOMP        :
                                                                    w_data_resp_buf_status_f ;
        end
    end

    // Calculate Store Response Status
    assign w_resp_buf_status =
        ((w_addr_resp_buf_status_f == BUF_STATUS_INCOMP  ) ||
         (w_data_resp_buf_status_f == BUF_STATUS_INCOMP  )    ) ? BUF_STATUS_INCOMP   :
        ((w_addr_resp_buf_status_f == BUF_STATUS_COMP    ) ||
         (w_data_resp_buf_status_f == BUF_STATUS_COMP    )    ) ? BUF_STATUS_COMP     :
        ((w_addr_resp_buf_status_f == BUF_STATUS_WAITRESP) ||
         (w_data_resp_buf_status_f == BUF_STATUS_WAITRESP)    ) ? BUF_STATUS_WAITRESP :
                                                                  BUF_STATUS_RESPSEND ;

    //--------------------------------------------------------------------------
    // Create Load Response
    //--------------------------------------------------------------------------
    always @(posedge clk) begin
        if (rst) begin
            r_resp_buf_header0_f <= {64{1'b0}};
            r_resp_buf_data0_f   <= {32{1'b0}};
            r_resp_buf_rresp_f   <= {2{1'b0}};
            r_resp_buf_status_f  <= BUF_STATUS_INCOMP;
        end
        else begin
            r_resp_buf_header0_f <= m_axi_ar_go                                        ? r_resp_buf_header0_next :
                                                                                         r_resp_buf_header0_f    ;
            r_resp_buf_data0_f   <= m_axi_r_go                                         ? a_axi_rdata_masked      :
                                                                                         r_resp_buf_data0_f      ;
            r_resp_buf_rresp_f   <= m_axi_r_go                                         ? m_axi_rresp             :
                                                                                         r_resp_buf_rresp_f      ;
            r_resp_buf_status_f  <= m_axi_ar_go                                        ? BUF_STATUS_WAITRESP     :
                                    m_axi_r_go                                         ? BUF_STATUS_RESPSEND     :
                                    (io_splitter_ack_load_go                       &
                                     (io_splitter_ack_load_counter_f == 0)         &
                                     ~(r_resp_buf_status_f == BUF_STATUS_WAITRESP)   ) ? BUF_STATUS_INCOMP       :
                                                                                         r_resp_buf_status_f     ;
        end
    end




//==============================================================================
// Send Piton Response Back to NOCs
//==============================================================================

    assign  r_resp_buf_val = (r_resp_buf_status_f == BUF_STATUS_RESPSEND);
    assign  w_resp_buf_val = (w_resp_buf_status == BUF_STATUS_RESPSEND);

    assign  io_splitter_ack_store = w_resp_buf_header0_f;
    assign  io_splitter_ack_load = (io_splitter_ack_load_counter_f == r_resp_buf_header0_f[29:22]) ? r_resp_buf_header0_f
                                                       : r_resp_buf_data0_f;

    assign  io_splitter_ack_load_go = (io_splitter_ack_mux_sel == LOAD_ACK) && (r_resp_buf_val) && splitter_bridge_rdy;
    assign  io_splitter_ack_store_go = (io_splitter_ack_mux_sel == STORE_ACK) && (w_resp_buf_val) && splitter_bridge_rdy;

    always @( * ) begin
        // val flag and output to splitter
        if (io_splitter_ack_mux_sel == LOAD_ACK) begin
            bridge_splitter_val = r_resp_buf_val;
            bridge_splitter_data = io_splitter_ack_load;
        end
        else begin
            bridge_splitter_val = w_resp_buf_val;
            bridge_splitter_data = io_splitter_ack_store;
        end
    end

    // Select whether to send a load ACK or a store ACK
    always @( * ) begin
        if (r_resp_buf_val && (!w_resp_buf_val)) begin
            io_splitter_ack_mux_sel = LOAD_ACK;
        end
        else if (w_resp_buf_val && (!r_resp_buf_val)) begin
            io_splitter_ack_mux_sel = STORE_ACK;
        end
        else if (w_resp_buf_val && r_resp_buf_val) begin
            if(io_splitter_ack_load_counter_f == r_resp_buf_header0_f[29:22]) begin
                io_splitter_ack_mux_sel = io_splitter_arb_f;
            end
            else begin
                io_splitter_ack_mux_sel = LOAD_ACK;
            end
        end
        else begin
            io_splitter_ack_mux_sel = LOAD_ACK;
        end
    end

    // Sequential updates to the arbitration selector and load flit counter
    always @(posedge clk) begin
        if (rst) begin
                io_splitter_arb_f <= 0;
                io_splitter_ack_load_counter_f <= 0;
        end
        else begin
            // Update Arbitration Reg
            if (w_resp_buf_val && r_resp_buf_val && io_splitter_ack_load_go) begin
                io_splitter_arb_f <= STORE_ACK;
            end
            else if (w_resp_buf_val && r_resp_buf_val && io_splitter_ack_store_go) begin
                io_splitter_arb_f <= LOAD_ACK;
            end

            // Update Load Flit Counter
            if (r_resp_buf_status_f == BUF_STATUS_WAITRESP) begin
                io_splitter_ack_load_counter_f <= r_resp_buf_header0_f[29:22];
            end
            else if(io_splitter_ack_load_go) begin
                if (io_splitter_ack_load_counter_f != 0) begin
                    io_splitter_ack_load_counter_f <= io_splitter_ack_load_counter_f - 1;
                end
            end

        end
    end

    assign bridge_splitter_rdy =
        ((splitter_io_msg_type_next == MSG_TYPE_INVAL) ||
         (splitter_io_msg_is_load_next && (r_req_buf_status_f == BUF_STATUS_INCOMP)) ||
         (splitter_io_msg_is_store_next && (w_req_buf_status == BUF_STATUS_INCOMP)));


endmodule
module PS_flops_EX_WB_alu (
 in_wfid,
 in_instr_pc,
 in_vgpr_dest_addr,
 in_sgpr_dest_addr,
 in_instr_done,
 in_vgpr_wr_en,
 in_sgpr_wr_en,
 in_vcc_wr_en,
 out_wfid,
 out_instr_pc,
 out_vgpr_dest_addr,
 out_sgpr_dest_addr,
 out_instr_done,
 out_vgpr_dest_wr_en,
 out_sgpr_dest_wr_en,
 out_vcc_wr_en,
 clk,
 rst
);

input [5:0] in_wfid;
input [31:0] in_instr_pc;
input [9:0] in_vgpr_dest_addr;
input [8:0] in_sgpr_dest_addr;
input in_instr_done;
input in_vgpr_wr_en;
input in_sgpr_wr_en;
input in_vcc_wr_en;

output [5:0] out_wfid;
output [31:0] out_instr_pc;
output [9:0] out_vgpr_dest_addr;
output [8:0] out_sgpr_dest_addr;
output out_instr_done;
output out_vgpr_dest_wr_en;
output out_sgpr_dest_wr_en;
output out_vcc_wr_en;

input clk;
input rst;

dff flop_wfid[5:0] (.q(out_wfid), .d(in_wfid), .clk(clk), .rst(rst));
dff flop_instr_pc[31:0] (.q(out_instr_pc), .d(in_instr_pc), .clk(clk), .rst(rst));
dff flop_vgpr_dest_addr[9:0] (.q(out_vgpr_dest_addr), .d(in_vgpr_dest_addr), .clk(clk), .rst(rst));
dff flop_sgpr_dest_addr[8:0] (.q(out_sgpr_dest_addr), .d(in_sgpr_dest_addr), .clk(clk), .rst(rst));
dff flop_instr_done (.q(out_instr_done), .d(in_instr_done), .clk(clk), .rst(rst));
dff flop_vgpr_wr_en (.q(out_vgpr_dest_wr_en), .d(in_vgpr_wr_en), .clk(clk), .rst(rst));
dff flop_sgpr_wr_en (.q(out_sgpr_dest_wr_en), .d(in_sgpr_wr_en), .clk(clk), .rst(rst));
dff flop_vcc_wr_en (.q(out_vcc_wr_en), .d(in_vcc_wr_en), .clk(clk), .rst(rst));

endmodule
module PS_flops_issue_alu (/*AUTOARG*/
   // Outputs
   out_alu_select, out_wfid, out_instr_pc, out_opcode, out_imm_value0,
   out_imm_value1, out_dest1_addr, out_dest2_addr,
   // Inputs
   in_alu_select, in_wfid, in_instr_pc, in_opcode, in_imm_value0,
   in_imm_value1, in_dest1_addr, in_dest2_addr, clk, rst
   );

input in_alu_select;
input [5:0] in_wfid;
input [31:0] in_instr_pc;
input [31:0] in_opcode;
input [15:0] in_imm_value0;
input [31:0] in_imm_value1;
input [11:0] in_dest1_addr;
input [11:0] in_dest2_addr;

output out_alu_select;
output [5:0]  out_wfid;
output [31:0] out_instr_pc;
output [31:0] out_opcode;
output [15:0] out_imm_value0;
output [31:0] out_imm_value1;
output [11:0] out_dest1_addr;
output [11:0] out_dest2_addr;

input clk;
input rst;

dff_en flop_alu_select (.q(out_alu_select), .d(in_alu_select), .en(1'b1), .clk(clk), .rst(rst));
dff_en flop_wfid[5:0] (.q(out_wfid), .d(in_wfid), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_instr_pc[31:0] (.q(out_instr_pc), .d(in_instr_pc), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_opcode[31:0] (.q(out_opcode), .d(in_opcode), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_imm_value0[15:0] (.q(out_imm_value0), .d(in_imm_value0), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_imm_value1[31:0] (.q(out_imm_value1), .d(in_imm_value1), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_dest1_addr[11:0] (.q(out_dest1_addr), .d(in_dest1_addr), .en(in_alu_select), .clk(clk), .rst(rst));
dff_en flop_dest2_addr[11:0] (.q(out_dest2_addr), .d(in_dest2_addr), .en(in_alu_select), .clk(clk), .rst(rst));

endmodule
/**
 * alu_definitions.v
 * File that contains all definitions used throughout alu
 * stage
 ***/





























 // _alu_definitions_v_

module alu(
           issue_source_reg1,
           issue_source_reg2,
           issue_source_reg3,
           issue_dest_reg1,
           issue_dest_reg2,
           issue_imm_value0,
           issue_imm_value1,
           issue_opcode,
           issue_wfid,
           issue_alu_select,
           vgpr_source1_data,
           vgpr_source2_data,
           vgpr_source3_data,
           sgpr_rd_data,
           exec_rd_exec_value,
           exec_rd_vcc_value,
           exec_rd_m0_value,
           exec_rd_scc_value,
           issue_instr_pc,
           rfa_queue_entry_serviced,
           vgpr_source1_rd_en,
           vgpr_source2_rd_en,
           vgpr_source3_rd_en,
           vgpr_source1_addr,
           vgpr_source2_addr,
           vgpr_source3_addr,
           vgpr_dest_addr,
           vgpr_dest_data,
           vgpr_wr_en,
           vgpr_wr_mask,
           exec_rd_wfid,
           exec_rd_en,
           exec_wr_vcc_wfid,
           exec_wr_vcc_en,
           exec_wr_vcc_value,
           sgpr_rd_en,
           sgpr_rd_addr,
           sgpr_wr_addr,
           sgpr_wr_en,
           sgpr_wr_data,
           sgpr_wr_mask,
           issue_alu_ready,
           vgpr_instr_done_wfid,
           vgpr_instr_done,
           rfa_queue_entry_valid,
           //tracemon_retire_valid,
           tracemon_retire_pc,
           clk,
           rst
           );

   parameter MODULE = 0;

   input clk;

   input rst;

   input issue_alu_select, exec_rd_scc_value, rfa_queue_entry_serviced;
   input [5:0] issue_wfid;
   input [11:0] issue_source_reg1, issue_source_reg2, issue_source_reg3,
		issue_dest_reg1, issue_dest_reg2;
   input [15:0] issue_imm_value0;
   input [31:0] issue_imm_value1, issue_opcode, sgpr_rd_data, exec_rd_m0_value,
		issue_instr_pc;
   input [63:0] exec_rd_exec_value, exec_rd_vcc_value;
   input [2047:0] vgpr_source1_data, vgpr_source2_data, vgpr_source3_data;

   output 	  vgpr_source1_rd_en, vgpr_source2_rd_en, vgpr_source3_rd_en, vgpr_wr_en,
		  exec_rd_en, exec_wr_vcc_en, sgpr_rd_en, sgpr_wr_en, issue_alu_ready,
		  vgpr_instr_done, rfa_queue_entry_valid;
   output [5:0]   exec_rd_wfid, exec_wr_vcc_wfid, vgpr_instr_done_wfid;
   output [8:0]   sgpr_rd_addr, sgpr_wr_addr;
   output [9:0]   vgpr_source1_addr, vgpr_source2_addr, vgpr_source3_addr,
		  vgpr_dest_addr;
   output [31:0]  tracemon_retire_pc;
   output [63:0]  vgpr_wr_mask, exec_wr_vcc_value, sgpr_wr_data, sgpr_wr_mask;
   output [2047:0] vgpr_dest_data;

   wire [31:0] 	   tracemon_retire_pc;
   //wire tracemon_retire_valid; //not needed in top level anymore

   wire [11:0] 	   rd_source1_addr;
   wire [11:0] 	   rd_source2_addr;
   wire [11:0] 	   rd_source3_addr;
   
   //PS_flops_issue_alu
   wire 	   cnt_alu_select;
   wire [31:0] 	   cnt_opcode;
   wire [11:0] 	   rd_dest1_addr;
   wire [11:0] 	   rd_dest2_addr;
   wire [5:0] 	   ex_wfid;
   wire [31:0] 	   ex_instr_pc;
   wire [15:0] 	   imm_value_0;
   wire [31:0] 	   imm_value_1;

   //alu_controller
   wire [3:0] 	   source1_mux_select;
   wire [3:0] 	   source2_mux_select;
   wire [3:0] 	   source3_mux_select;
   wire 	   src_buffer_wr_en;
   wire [31:0] 	   alu_control;
   wire 	   alu_start;
   wire [11:0] 	   ex_vgpr_dest_addr;
   wire [11:0] 	   ex_sgpr_dest_addr;
   wire 	   ex_vgpr_wr_en;
   wire 	   ex_sgpr_wr_en;
   wire 	   ex_instr_done;
   wire 	   ex_vcc_wr_en;
   wire 	   alu_ready;
   wire [9:0] 	   source1_src_constant;
   wire [9:0] 	   source2_src_constant;
   wire [9:0] 	   source3_src_constant;
   
   
   //src1_mux
   wire [2047:0]   source1_data;
   wire [2047:0]   source2_data;
   wire [2047:0]   source3_data;

   //src_shift_reg
   wire [511:0]    alu_source1_data;
   wire [511:0]    alu_source2_data;
   wire [511:0]    alu_source3_data;
   wire [15:0] 	   alu_source_vcc_value;
   wire [15:0] 	   alu_source_exec_value;


   //valu
   wire [511:0]    alu_vgpr_dest_data;
   wire [15:0] 	   alu_sgpr_dest_data;
   wire [15:0] 	   alu_dest_vcc_value;
   wire [15:0] 	   alu_dest_exec_value;
   wire            valu_done;

   //dest_shift_reg
   wire [2047:0]   queue_vgpr_dest_data;
   wire [63:0] 	   queue_sgpr_dest_data;
   wire [63:0] 	   queue_vgpr_wr_mask;
   wire [63:0] 	   queue_exec_wr_vcc_value;

   //PS_flops_EX_WB_alu
   wire 	   queue_vgpr_wr_en;
   wire 	   queue_sgpr_wr_en;
   wire [9:0] 	   queue_vgpr_dest_addr;
   wire [8:0] 	   queue_sgpr_dest_addr;
   wire [5:0] 	   queue_vgpr_instr_done_wfid;
   wire [31:0] 	   queue_tracemon_retire_pc;
   wire 	   queue_vgpr_instr_done;
   wire 	   queue_exec_wr_vcc_en;

   //wb_queue
   wire 	   queue_ready;
   wire 	   queue_empty;

   // TEST_HERE
   wire [31:0] 	   sgpr_rd_data_i;
   reg [31:0] exec_rd_m0_value_i;
   reg [63:0] exec_rd_exec_value_i, exec_rd_vcc_value_i;
   reg 	      exec_rd_scc_value_i;
   wire [2047:0] vgpr_source1_data_i, vgpr_source2_data_i, vgpr_source3_data_i;

   // Keep a single delay on exec signals
   always @ ( posedge clk or posedge rst ) begin
      if(rst) begin
	 //sgpr_rd_data_i <= 0;
	 exec_rd_m0_value_i <= 0;
	 exec_rd_exec_value_i <= 0;
	 exec_rd_vcc_value_i <= 0;
	 exec_rd_scc_value_i <= 0;
	 //vgpr_source1_data_i <= 0;
	 //vgpr_source2_data_i <= 0;
	 //vgpr_source3_data_i <= 0;
      end
      else begin
	 //sgpr_rd_data_i <= sgpr_rd_data;
	 exec_rd_m0_value_i <= exec_rd_m0_value;
	 exec_rd_exec_value_i <= exec_rd_exec_value;
	 exec_rd_vcc_value_i <= exec_rd_vcc_value;
	 exec_rd_scc_value_i <= exec_rd_scc_value;
	 //vgpr_source1_data_i <= vgpr_source1_data;
	 //vgpr_source2_data_i <= vgpr_source2_data;
	 //vgpr_source3_data_i <= vgpr_source3_data;
      end
   end
   assign sgpr_rd_data_i = sgpr_rd_data;
   assign vgpr_source1_data_i = vgpr_source1_data;
   assign vgpr_source2_data_i = vgpr_source2_data;
   assign vgpr_source3_data_i = vgpr_source3_data;
   
   
   assign rd_source1_addr = issue_source_reg1;
   assign rd_source2_addr = issue_source_reg2;
   assign rd_source3_addr = issue_source_reg3;

   assign exec_wr_vcc_wfid = vgpr_instr_done_wfid;
   //assign tracemon_retire_valid = vgpr_instr_done;  //not needed in top level anymore
   assign rfa_queue_entry_valid = vgpr_instr_done & ~queue_empty;
   assign exec_rd_wfid = issue_wfid;
   assign vgpr_source1_addr = rd_source1_addr[9:0];
   assign vgpr_source2_addr = rd_source2_addr[9:0];
   assign vgpr_source3_addr = rd_source3_addr[9:0];
   assign issue_alu_ready = alu_ready & queue_ready;
   assign sgpr_wr_mask = vgpr_wr_mask;

   assign sgpr_rd_addr = (rd_source1_addr[11:9] == 3'b110) ? rd_source1_addr[8:0] :
                         ((rd_source2_addr[11:9] == 3'b110) ? rd_source2_addr[8:0] :
                          ((rd_source3_addr[11:9] == 3'b110) ? rd_source3_addr[8:0] : 3'bx));

   
   PS_flops_issue_alu flops_issue_alu
     (
      .in_alu_select(issue_alu_select),
      .in_wfid(issue_wfid),
      .in_instr_pc(issue_instr_pc),
      .in_opcode(issue_opcode),
      .in_imm_value0(issue_imm_value0),
      .in_imm_value1(issue_imm_value1),
      .in_dest1_addr(issue_dest_reg1),
      .in_dest2_addr(issue_dest_reg2),
      .out_alu_select(cnt_alu_select),
      .out_wfid(ex_wfid),
      .out_instr_pc(ex_instr_pc),
      .out_opcode(cnt_opcode),
      .out_imm_value0(imm_value_0),
      .out_imm_value1(imm_value_1),
      .out_dest1_addr(rd_dest1_addr),
      .out_dest2_addr(rd_dest2_addr),
      .clk(clk),
      .rst(rst)
      );

   alu_controller #(.MODULE(MODULE)) alu_controller
     (
      .in_alu_select_flopped(cnt_alu_select),
      .in_alu_select(issue_alu_select),
      .in_source1_addr(rd_source1_addr),
      .in_source2_addr(rd_source2_addr),
      .in_source3_addr(rd_source3_addr),
      .in_dest1_addr(rd_dest1_addr),
      .in_dest2_addr(rd_dest2_addr),
      .in_opcode(cnt_opcode),
      .in_valu_done(valu_done),
      .out_alu_ready(alu_ready),
      .out_vcc_wr_en(ex_vcc_wr_en),
      .out_instr_done(ex_instr_done),
      .out_vgpr_wr_en(ex_vgpr_wr_en),
      .out_vgpr_dest_addr(ex_vgpr_dest_addr),
      .out_sgpr_wr_en(ex_sgpr_wr_en),
      .out_sgpr_dest_addr(ex_sgpr_dest_addr),
      .out_alu_control(alu_control),
      .out_alu_start(alu_start),
      .out_src_buffer_wr_en(src_buffer_wr_en),
      .out_source1_mux_select(source1_mux_select),
      .out_source2_mux_select(source2_mux_select),
      .out_source3_mux_select(source3_mux_select),
      .out_source1_src_constant(source1_src_constant),
      .out_source2_src_constant(source2_src_constant),
      .out_source3_src_constant(source3_src_constant),
      .out_vgpr_source1_rd_en(vgpr_source1_rd_en),
      .out_vgpr_source2_rd_en(vgpr_source2_rd_en),
      .out_vgpr_source3_rd_en(vgpr_source3_rd_en),
      .out_sgpr_rd_en(sgpr_rd_en),
      .out_exec_rd_en(exec_rd_en),
      .clk(clk),
      .rst(rst)
      );

   src_mux src1_mux
     (
      .src_constant(source1_src_constant),
      .sgpr_rd_data(sgpr_rd_data_i),
      .vgpr_source_data(vgpr_source1_data_i),
      .exec_rd_exec_value(exec_rd_exec_value_i),
      .exec_rd_vcc_value(exec_rd_vcc_value_i),
      .exec_rd_m0_value(exec_rd_m0_value_i),
      .exec_rd_scc_value(exec_rd_scc_value_i),
      .literal_constant(imm_value_1),
      .source_mux_select(source1_mux_select),
      .source_data(source1_data)
      );

   src_mux src2_mux
     (
      .src_constant(source2_src_constant),
      .sgpr_rd_data(sgpr_rd_data_i),
      .vgpr_source_data(vgpr_source2_data_i),
      .exec_rd_exec_value(exec_rd_exec_value_i),
      .exec_rd_vcc_value(exec_rd_vcc_value_i),
      .exec_rd_m0_value(exec_rd_m0_value_i),
      .exec_rd_scc_value(exec_rd_scc_value_i),
      .literal_constant(imm_value_1),
      .source_mux_select(source2_mux_select),
      .source_data(source2_data)
      );

   src_mux src3_mux
     (
      .src_constant(source3_src_constant),
      .sgpr_rd_data(sgpr_rd_data_i),
      .vgpr_source_data(vgpr_source3_data_i),
      .exec_rd_exec_value(exec_rd_exec_value_i),
      .exec_rd_vcc_value(exec_rd_vcc_value_i),
      .exec_rd_m0_value(exec_rd_m0_value_i),
      .exec_rd_scc_value(exec_rd_scc_value_i),
      .literal_constant(imm_value_1),
      .source_mux_select(source3_mux_select),
      .source_data(source3_data)
      );

   src_shift_reg src_shift_reg
     (
      .source1_data(source1_data),
      .source2_data(source2_data),
      .source3_data(source3_data),
      .source_vcc_value(exec_rd_vcc_value_i),
      .source_exec_value(exec_rd_exec_value_i),
      .src_buffer_wr_en(src_buffer_wr_en),
      .src_buffer_shift_en(valu_done),
      .alu_source1_data(alu_source1_data),
      .alu_source2_data(alu_source2_data),
      .alu_source3_data(alu_source3_data),
      .alu_source_vcc_value(alu_source_vcc_value),
      .alu_source_exec_value(alu_source_exec_value),
      .clk(clk),
      .rst(rst)
      );

   valu #(.MODULE(MODULE)) valu
     (
      .alu_source1_data(alu_source1_data),
      .alu_source2_data(alu_source2_data),
      .alu_source3_data(alu_source3_data),
      .alu_source_vcc_value(alu_source_vcc_value),
      .alu_source_exec_value(alu_source_exec_value),
      .alu_control(alu_control),
      .alu_start(alu_start),
      .alu_vgpr_dest_data(alu_vgpr_dest_data),
      .alu_sgpr_dest_data(alu_sgpr_dest_data),
      .alu_dest_vcc_value(alu_dest_vcc_value),
      .alu_dest_exec_value(alu_dest_exec_value),
      .valu_done(valu_done),
      .clk(clk),
      .rst(rst)
      );

   dest_shift_reg dest_shift_reg
     (
      .alu_vgpr_dest_data(alu_vgpr_dest_data),
      .alu_sgpr_dest_data(alu_sgpr_dest_data),
      .alu_dest_vcc_value(alu_dest_vcc_value),
      .alu_dest_exec_value(alu_dest_exec_value),
      .dest_buffer_wr_en(valu_done),
      .dest_buffer_shift_en(valu_done),
      .vgpr_dest_data(queue_vgpr_dest_data),
      .sgpr_dest_data(queue_sgpr_dest_data),
      .exec_wr_vcc_value(queue_exec_wr_vcc_value),
      .vgpr_wr_mask(queue_vgpr_wr_mask),
      .clk(clk),
      .rst(rst)
      );

   PS_flops_EX_WB_alu flops_EX_WB
     (
      .in_wfid(ex_wfid),
      .in_instr_pc(ex_instr_pc),
      .in_vgpr_dest_addr(ex_vgpr_dest_addr[9:0]),
      .in_sgpr_dest_addr(ex_sgpr_dest_addr[8:0]),
      .in_instr_done(ex_instr_done),
      .in_vgpr_wr_en(ex_vgpr_wr_en),
      .in_sgpr_wr_en(ex_sgpr_wr_en),
      .in_vcc_wr_en(ex_vcc_wr_en),
      .out_wfid(queue_vgpr_instr_done_wfid),
      .out_instr_pc(queue_tracemon_retire_pc),
      .out_vgpr_dest_addr(queue_vgpr_dest_addr),
      .out_sgpr_dest_addr(queue_sgpr_dest_addr),
      .out_instr_done(queue_vgpr_instr_done),
      .out_vgpr_dest_wr_en(queue_vgpr_wr_en),
      .out_sgpr_dest_wr_en(queue_sgpr_wr_en),
      .out_vcc_wr_en(queue_exec_wr_vcc_en),
      .clk(clk),
      .rst(rst)
      );

   alu_wb_queue wb_queue
     (
      .in_rfa_queue_entry_serviced(rfa_queue_entry_serviced),
      .in_vgpr_dest_data(queue_vgpr_dest_data),
      .in_sgpr_dest_data(queue_sgpr_dest_data),
      .in_exec_wr_vcc_value(queue_exec_wr_vcc_value),
      .in_vgpr_wr_mask(queue_vgpr_wr_mask),
      .in_wfid(queue_vgpr_instr_done_wfid),
      .in_instr_pc(queue_tracemon_retire_pc),
      .in_vgpr_dest_addr(queue_vgpr_dest_addr),
      .in_sgpr_dest_addr(queue_sgpr_dest_addr),
      .in_instr_done(queue_vgpr_instr_done),
      .in_vgpr_dest_wr_en(queue_vgpr_wr_en),
      .in_sgpr_dest_wr_en(queue_sgpr_wr_en),
      .in_vcc_wr_en(queue_exec_wr_vcc_en),
      .out_vgpr_dest_data(vgpr_dest_data),
      .out_sgpr_dest_data(sgpr_wr_data),
      .out_exec_wr_vcc_value(exec_wr_vcc_value),
      .out_vgpr_wr_mask(vgpr_wr_mask),
      .out_wfid(vgpr_instr_done_wfid),
      .out_instr_pc(tracemon_retire_pc),
      .out_vgpr_dest_addr(vgpr_dest_addr),
      .out_sgpr_dest_addr(sgpr_wr_addr),
      .out_instr_done(vgpr_instr_done),
      .out_vgpr_dest_wr_en(vgpr_wr_en),
      .out_sgpr_dest_wr_en(sgpr_wr_en),
      .out_vcc_wr_en(exec_wr_vcc_en),
      .out_queue_ready(queue_ready),
      .out_queue_empty(queue_empty),
      .clk(clk),
      .rst(rst)
      );

endmodule
/**
 * alu_definitions.v
 * File that contains all definitions used throughout alu
 * stage
 ***/





























 // _alu_definitions_v_

module alu_controller 
  (/*AUTOARG*/
   // Outputs
   out_alu_ready, out_vcc_wr_en, out_instr_done, out_vgpr_wr_en,
   out_vgpr_dest_addr, out_sgpr_wr_en, out_sgpr_dest_addr,
   out_alu_control, out_alu_start, out_src_buffer_wr_en,
   out_source1_mux_select, out_source2_mux_select,
   out_source3_mux_select, out_source1_src_constant,
   out_source2_src_constant, out_source3_src_constant,
   out_vgpr_source1_rd_en, out_vgpr_source2_rd_en,
   out_vgpr_source3_rd_en, out_sgpr_rd_en, out_exec_rd_en,
   // Inputs
   in_alu_select_flopped, in_alu_select, in_source1_addr,
   in_source2_addr, in_source3_addr, in_dest1_addr, in_dest2_addr,
   in_opcode, in_valu_done, clk, rst
   );

   parameter MODULE = 0;

   input in_alu_select_flopped;
   input in_alu_select;
   input [11:0] in_source1_addr;
   input [11:0] in_source2_addr;
   input [11:0] in_source3_addr;
   input [11:0] in_dest1_addr;
   input [11:0] in_dest2_addr;
   input [31:0] in_opcode;
   input 	in_valu_done;

   output 	out_alu_ready;
   output 	out_vcc_wr_en;
   output 	out_instr_done;
   output 	out_vgpr_wr_en;
   output [11:0] out_vgpr_dest_addr;
   output 	 out_sgpr_wr_en;
   output [11:0] out_sgpr_dest_addr;
   output [31:0] out_alu_control;
   output 	 out_alu_start;
   output 	 out_src_buffer_wr_en;
   output [3:0]  out_source1_mux_select;
   output [3:0]  out_source2_mux_select;
   output [3:0]  out_source3_mux_select;
   output [9:0]  out_source1_src_constant;
   output [9:0]  out_source2_src_constant;
   output [9:0]  out_source3_src_constant;
   
   output 	 out_vgpr_source1_rd_en;
   output 	 out_vgpr_source2_rd_en;
   output 	 out_vgpr_source3_rd_en;
   output 	 out_sgpr_rd_en;
   output 	 out_exec_rd_en;

   input 	 clk;
   input 	 rst;


   reg 		 out_vcc_wr_en;
   reg 		 out_instr_done;
   reg 		 out_vgpr_wr_en;
   reg 		 out_sgpr_wr_en;
   reg [31:0] 	 out_alu_control;
   reg 		 out_src_buffer_wr_en;
   wire 	 out_vgpr_source1_rd_en;
   wire 	 out_vgpr_source2_rd_en;
   wire 	 out_vgpr_source3_rd_en;
   wire 	 out_sgpr_rd_en;
   wire 	 out_exec_rd_en;
   reg [11:0] 	 out_vgpr_dest_addr;
   reg [11:0] 	 out_sgpr_dest_addr;
   reg [9:0] 	 out_source1_src_constant;
   reg [9:0] 	 out_source2_src_constant;
   reg [9:0] 	 out_source3_src_constant;
   reg [3:0] 	 out_source1_mux_select;
   reg [3:0] 	 out_source2_mux_select;
   reg [3:0] 	 out_source3_mux_select;

   wire 	 dec_vcc_wr_en;
   wire 	 dec_vgpr_wr_en;
   wire 	 dec_sgpr_wr_en;
   reg 		 dec_vgpr_source1_rd_en;
   reg 		 dec_vgpr_source2_rd_en;
   reg 		 dec_vgpr_source3_rd_en;
   wire 	 dec_sgpr_rd_en;
   wire 	 dec_exec_rd_en;
   reg [3:0] 	 dec_out_source1_mux_select;
   reg [3:0] 	 dec_out_source2_mux_select;
   reg [3:0] 	 dec_out_source3_mux_select;

   wire 	 RD, EX, WB;

   assign dec_sgpr_rd_en = 1'b1;
   assign dec_exec_rd_en = 1'b1;

   always @ (in_source1_addr) begin

      dec_vgpr_source1_rd_en <= 1'b0;
      casex(in_source1_addr)
	12'b0_11111111111 : //literal constant
          begin
             dec_out_source1_mux_select <= 4'b0000;
          end
	12'b0_0_?????????? : //constant value
          begin
             dec_out_source1_mux_select <= 4'b0001;
          end
	12'b1_0_?????????? : //read VGPR
          begin
             dec_out_source1_mux_select <= 4'b0010;
             dec_vgpr_source1_rd_en <= 1'b1;
          end
	12'b1_1_0_????????? : //read value from SGPR
          begin
             dec_out_source1_mux_select <= 4'b0011;
          end
	12'b1_1_1_0_0000_0001 : //read VCC_LO
          begin
             dec_out_source1_mux_select <= 4'b0100;
          end
	12'b1_1_1_0_0000_0010 : //read VCC_HI
          begin
             dec_out_source1_mux_select <= 4'b0101;
          end
	12'b1_1_1_0_0000_0100 : //read M0
          begin
             dec_out_source1_mux_select <= 4'b0110;
          end
	12'b1_1_1_0_0000_1000 : //read EXEC_LO
          begin
             dec_out_source1_mux_select <= 4'b0111;
          end
	12'b1_1_1_0_0001_0000 : //read EXEC_HI
          begin
             dec_out_source1_mux_select <= 4'b1000;
          end
	12'b1_1_1_0_0010_0000 : //read VCCZ
          begin
             dec_out_source1_mux_select <= 4'b1001;
          end
	12'b1_1_1_0_0100_0000 : //read EXECZ
          begin
             dec_out_source1_mux_select <= 4'b1010;
          end
	12'b1_1_1_0_1000_0000 : //read SCC
          begin
             dec_out_source1_mux_select <= 4'b1011;
          end
	default:
          begin
             dec_out_source1_mux_select <= 4'bx;
          end
      endcase
   end

   always @ (in_source2_addr) begin
      
      dec_vgpr_source2_rd_en <= 1'b0;
      casex(in_source2_addr)
	12'b0_11111111111 : //literal constant
          begin
             dec_out_source2_mux_select <= 4'b0000;
          end
	12'b0_0_?????????? : //constant value
          begin
             dec_out_source2_mux_select <= 4'b0001;
          end
	12'b1_0_?????????? : //read VGPR
          begin
             dec_out_source2_mux_select <= 4'b0010;
             dec_vgpr_source2_rd_en <= 1'b1;
          end
	12'b1_1_0_????????? : //read value from SGPR
          begin
             dec_out_source2_mux_select <= 4'b0011;
          end
	12'b1_1_1_0_0000_0001 : //read VCC_LO
          begin
             dec_out_source2_mux_select <= 4'b0100;
          end
	12'b1_1_1_0_0000_0010 : //read VCC_HI
          begin
             dec_out_source2_mux_select <= 4'b0101;
          end
	12'b1_1_1_0_0000_0100 : //read M0
          begin
             dec_out_source2_mux_select <= 4'b0110;
          end
	12'b1_1_1_0_0000_1000 : //read EXEC_LO
          begin
             dec_out_source2_mux_select <= 4'b0111;
          end
	12'b1_1_1_0_0001_0000 : //read EXEC_HI
          begin
             dec_out_source2_mux_select <= 4'b1000;
          end
	12'b1_1_1_0_0010_0000 : //read VCCZ
          begin
             dec_out_source2_mux_select <= 4'b1001;
          end
	12'b1_1_1_0_0100_0000 : //read EXECZ
          begin
             dec_out_source2_mux_select <= 4'b1010;
          end
	12'b1_1_1_0_1000_0000 : //read SCC
          begin
             dec_out_source2_mux_select <= 4'b1011;
          end
	default:
          begin
             dec_out_source2_mux_select <= 4'bx;
          end
      endcase
   end

   always @ (in_source3_addr) begin
      dec_vgpr_source3_rd_en <= 1'b0;
      casex(in_source3_addr)
	12'b0_11111111111 : //literal constant
          begin
             dec_out_source3_mux_select <= 4'b0000;
          end
	12'b0_0_?????????? : //constant value
          begin
             dec_out_source3_mux_select <= 4'b0001;
          end
	12'b1_0_?????????? : //read VGPR
          begin
             dec_out_source3_mux_select <= 4'b0010;
             dec_vgpr_source3_rd_en <= 1'b1;
          end
	12'b1_1_0_????????? : //read value from SGPR
          begin
             dec_out_source3_mux_select <= 4'b0011;
          end
	12'b1_1_1_0_0000_0001 : //read VCC_LO
          begin
             dec_out_source3_mux_select <= 4'b0100;
          end
	12'b1_1_1_0_0000_0010 : //read VCC_HI
          begin
             dec_out_source3_mux_select <= 4'b0101;
          end
	12'b1_1_1_0_0000_0100 : //read M0
          begin
             dec_out_source3_mux_select <= 4'b0110;
          end
	12'b1_1_1_0_0000_1000 : //read EXEC_LO
          begin
             dec_out_source3_mux_select <= 4'b0111;
          end
	12'b1_1_1_0_0001_0000 : //read EXEC_HI
          begin
             dec_out_source3_mux_select <= 4'b1000;
          end
	12'b1_1_1_0_0010_0000 : //read VCCZ
          begin
             dec_out_source3_mux_select <= 4'b1001;
          end
	12'b1_1_1_0_0100_0000 : //read EXECZ
          begin
             dec_out_source3_mux_select <= 4'b1010;
          end
	12'b1_1_1_0_1000_0000 : //read SCC
          begin
             dec_out_source3_mux_select <= 4'b1011;
          end
	default:
          begin
             dec_out_source3_mux_select <= 4'bx;
          end
      endcase
   end

   assign out_vgpr_source1_rd_en = dec_vgpr_source1_rd_en && in_alu_select;
   assign out_vgpr_source2_rd_en = dec_vgpr_source2_rd_en && in_alu_select;
   assign out_vgpr_source3_rd_en = dec_vgpr_source3_rd_en && in_alu_select;
   assign out_sgpr_rd_en = dec_sgpr_rd_en && in_alu_select;
   assign out_exec_rd_en = dec_exec_rd_en && in_alu_select;

   // Single cycle delay for the mux select and src_constant so
   // they arrive with the rest of the data
   always @ ( posedge clk or posedge rst ) begin
      if(rst) begin
	 out_source1_mux_select <= 0;
	 out_source2_mux_select <= 0;
	 out_source3_mux_select <= 0;
	 out_source1_src_constant <= 0;
	 out_source2_src_constant <= 0;
	 out_source3_src_constant <= 0;
      end
      else begin
	 out_source1_mux_select <= dec_out_source1_mux_select;
	 out_source2_mux_select <= dec_out_source2_mux_select;
	 out_source3_mux_select <= dec_out_source3_mux_select;
	 out_source1_src_constant <= in_source1_addr[9:0];
	 out_source2_src_constant <= in_source2_addr[9:0];
	 out_source3_src_constant <= in_source3_addr[9:0];
      end
   end
   
   always @* begin
      casex({in_dest1_addr[11:10], in_dest2_addr[11:10]})
	4'b10_??:
	  begin
	     out_vgpr_dest_addr <= in_dest1_addr;
	     out_sgpr_dest_addr <= in_dest2_addr;
	  end
	4'b11_??:
	  begin
	     out_vgpr_dest_addr <= in_dest2_addr;
	     out_sgpr_dest_addr <= in_dest1_addr;
	  end
	4'b??_10:
	  begin
	     out_vgpr_dest_addr <= in_dest2_addr;
	     out_sgpr_dest_addr <= in_dest1_addr;
	  end
	4'b??_11:
	  begin
	     out_vgpr_dest_addr <= in_dest1_addr;
	     out_sgpr_dest_addr <= in_dest2_addr;
	  end
	default:
	  begin
	     out_vgpr_dest_addr <= 12'bx;
	     out_sgpr_dest_addr <= 12'bx;
	  end
      endcase
   end


   generate
      if (MODULE == 0)
	simd_instr_decoder simd_instr_decoder 
	  (
	   .in_sgpr_dest_addr(out_sgpr_dest_addr),
	   .in_opcode(in_opcode),
	   .out_vcc_wr_en(dec_vcc_wr_en),
	   .out_vgpr_wr_en(dec_vgpr_wr_en),
	   .out_sgpr_wr_en(dec_sgpr_wr_en)
	   );
      else if (MODULE == 1)
	simf_instr_decoder simf_instr_decoder 
	  (
	   .in_sgpr_dest_addr(out_sgpr_dest_addr),
	   .in_opcode(in_opcode),
	   .out_vcc_wr_en(dec_vcc_wr_en),
	   .out_vgpr_wr_en(dec_vgpr_wr_en),
	   .out_sgpr_wr_en(dec_sgpr_wr_en)
	   );
endgenerate

   alu_fsm alu_fsm 
     (
      .in_alu_select(in_alu_select_flopped),
      .out_alu_start(out_alu_start),
      .in_valu_done(in_valu_done),
      .out_alu_ready(out_alu_ready),
      .RD(RD),
      .EX(EX),
      .WB(WB),
      .clk(clk),
      .rst(rst)
      );


   always @ (RD) begin
      casex(RD)
	1'b0 :
	  begin
	     out_src_buffer_wr_en <= 1'b0;
	  end
	1'b1 :
	  begin
	     out_src_buffer_wr_en <= 1'b1;
	  end
	default:
	  begin
	     out_src_buffer_wr_en <= 1'bx;
	  end
      endcase
   end

   always @ (EX or in_opcode) begin
      casex(EX)
	1'b0 :
	  begin
	     out_alu_control <= 32'd0;
	  end
	1'b1 :
	  begin
	     out_alu_control <= in_opcode;
	  end
	default :
	  begin
	     out_alu_control <= 32'dx;
	  end
      endcase
   end

   always @ (WB or dec_vcc_wr_en or dec_vgpr_wr_en or dec_sgpr_wr_en) begin
      casex(WB)
	1'b0 :
	  begin
	     out_vcc_wr_en <= 1'b0;
	     out_instr_done <= 1'b0;
	     out_vgpr_wr_en <= 1'b0;
	     out_sgpr_wr_en <= 1'b0;
	  end
	1'b1 :
	  begin
	     out_vcc_wr_en <= dec_vcc_wr_en;
	     out_instr_done <= 1'b1;
	     out_vgpr_wr_en <= dec_vgpr_wr_en;
	     out_sgpr_wr_en <= dec_sgpr_wr_en;
	  end
	default :
	  begin
	     out_vcc_wr_en <= 1'bx;
	     out_instr_done <= 1'bx;
	     out_vgpr_wr_en <= 1'bx;
	     out_sgpr_wr_en <= 1'bx;
	  end
      endcase
   end

endmodule







module alu_fsm (
 in_alu_select,
 out_alu_start,
 in_valu_done,
 out_alu_ready,
 RD,
 EX,
 WB,
 clk,
 rst
);

input in_alu_select;
input in_valu_done;

output out_alu_start;
output out_alu_ready;
output RD;
output EX;
output WB;

input clk;
input rst;

reg out_alu_ready;
reg RD;
reg WB;
reg [2:0] next_state;
reg next_EX;
reg next_alu_start;

wire [2:0] current_state;

dff state_flop[2:0] (.q(current_state), .d(next_state), .clk(clk), .rst(rst));
dff EX_flop (.q(EX), .d(next_EX), .clk(clk), .rst(rst));
dff alu_start_flop (.q(out_alu_start), .d(next_alu_start), .clk(clk), .rst(rst));

always @ (current_state or in_alu_select or in_valu_done) begin
	casex({current_state, in_alu_select, in_valu_done})
		{3'b000, 1'b0, 1'b0} :
			begin
				next_state <= 3'b000;
				out_alu_ready <= 1'b1;
				RD <= 1'b0;
				next_EX <= 1'b0;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b000, 1'b1, 1'b0} :
			begin
				next_state <= 3'b010;
				out_alu_ready <= 1'b0;
				RD <= 1'b1;
				next_EX <= 1'b1;
				next_alu_start <= 1'b1;
				WB <= 1'b0;
			end
		{3'b001, 1'b0, 1'b?} :
			begin
				next_state <= 3'b010;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b010, 1'b0, 1'b0} :
			begin
				next_state <= 3'b010;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b010, 1'b0, 1'b1} :
			begin
				next_state <= 3'b011;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b1;
				WB <= 1'b0;
			end
		{3'b011, 1'b0, 1'b0} :
			begin
				next_state <= 3'b011;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b011, 1'b0, 1'b1} :
			begin
				next_state <= 3'b100;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b1;
				WB <= 1'b0;
			end
		{3'b100, 1'b0, 1'b0} :
			begin
				next_state <= 3'b100;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b100, 1'b0, 1'b1} :
			begin
				next_state <= 3'b101;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b1;
				WB <= 1'b0;
			end
		{3'b101, 1'b0, 1'b0} :
			begin
				next_state <= 3'b101;
				out_alu_ready <= 1'b0;
				RD <= 1'b0;
				next_EX <= 1'b1;
				next_alu_start <= 1'b0;
				WB <= 1'b0;
			end
		{3'b101, 1'b0, 1'b1} :
			begin
				next_state <= 3'b000;
				out_alu_ready <= 1'b1;
				RD <= 1'b0;
				next_EX <= 1'b0;
				next_alu_start <= 1'b0;
				WB <= 1'b1;
			end
		default :
			begin
				next_state <= 3'bxxx;
				out_alu_ready <= 1'bx;
				RD <= 1'bx;
				next_EX <= 1'bx;
				next_alu_start <= 1'bx;
				WB <= 1'bx;
			end
	endcase
end

endmodule
module alu_wb_queue(
                  in_rfa_queue_entry_serviced,
                  in_vgpr_dest_data,
                  in_sgpr_dest_data,
                  in_exec_wr_vcc_value,
                  in_vgpr_wr_mask,
                  in_wfid,
                  in_instr_pc,
                  in_vgpr_dest_addr,
                  in_sgpr_dest_addr,
                  in_instr_done,
                  in_vgpr_dest_wr_en,
                  in_sgpr_dest_wr_en,
                  in_vcc_wr_en,
                  out_vgpr_dest_data,
                  out_sgpr_dest_data,
                  out_exec_wr_vcc_value,
                  out_vgpr_wr_mask,
                  out_wfid,
                  out_instr_pc,
                  out_vgpr_dest_addr,
                  out_sgpr_dest_addr,
                  out_instr_done,
                  out_vgpr_dest_wr_en,
                  out_sgpr_dest_wr_en,
                  out_vcc_wr_en,
                  out_queue_ready,
                  out_queue_empty,
                  clk,
                  rst
                  );

   parameter BITS = 2;
   parameter SIZE = 4;

   input in_rfa_queue_entry_serviced;

   input [2047:0] in_vgpr_dest_data;
   input [63:0] in_sgpr_dest_data;
   input [63:0]   in_exec_wr_vcc_value;
   input [63:0]   in_vgpr_wr_mask;
   input [5:0] in_wfid;
   input [31:0] in_instr_pc;
   input [9:0] in_vgpr_dest_addr;
   input [8:0] in_sgpr_dest_addr;
   input in_instr_done;
   input in_vgpr_dest_wr_en;
   input in_sgpr_dest_wr_en;
   input in_vcc_wr_en;

   output [2047:0] out_vgpr_dest_data;
   output [63:0]   out_sgpr_dest_data;
   output [63:0]   out_exec_wr_vcc_value;
   output [63:0]   out_vgpr_wr_mask;
   output [5:0] out_wfid;
   output [31:0] out_instr_pc;
   output [9:0] out_vgpr_dest_addr;
   output [8:0] out_sgpr_dest_addr;
   output out_instr_done;
   output out_vgpr_dest_wr_en;
   output out_sgpr_dest_wr_en;
   output out_vcc_wr_en;

   output out_queue_ready;
   output out_queue_empty;

   input clk;
   input rst;

   wire out_queue_writable;
   wire [2300:0] queue_wr_data;
   wire [2300:0] queue_rd_data;

   assign queue_wr_data = {in_vgpr_dest_data, in_sgpr_dest_data, in_exec_wr_vcc_value, in_vgpr_wr_mask, in_wfid, in_instr_pc, in_vgpr_dest_addr, in_sgpr_dest_addr, in_instr_done, in_vgpr_dest_wr_en, in_sgpr_dest_wr_en, in_vcc_wr_en};

   assign {out_vgpr_dest_data, out_sgpr_dest_data, out_exec_wr_vcc_value, out_vgpr_wr_mask, out_wfid, out_instr_pc, out_vgpr_dest_addr, out_sgpr_dest_addr, out_instr_done, out_vgpr_dest_wr_en, out_sgpr_dest_wr_en, out_vcc_wr_en} = queue_rd_data;

   wire [BITS - 1:0] tail;
   wire [BITS - 1:0] head;
   wire [BITS - 1:0] next_tail;
   wire [BITS - 1:0] next_next_tail;
   wire [BITS - 1:0] next_head;
   wire inc_tail;
   wire inc_head;
   wire [31:0] next_tail_dummy;
   wire [31:0] next_next_tail_dummy;
   wire [31:0] next_head_dummy;

   assign next_tail_dummy = tail + 1;
   assign next_next_tail_dummy = tail + 2;
   assign next_head_dummy = head + 1;
   assign next_tail = next_tail_dummy[BITS - 1:0];
   assign next_next_tail = next_next_tail_dummy[BITS - 1:0];
   assign next_head = next_head_dummy[BITS - 1:0];

   assign inc_tail = in_instr_done & out_queue_writable;
   assign inc_head = in_rfa_queue_entry_serviced;

   assign out_queue_writable = (head != next_tail);
   assign out_queue_ready = (head != next_next_tail) & out_queue_writable;
   assign out_queue_empty = (head == tail);

   dff_en Tail[BITS - 1:0] (.q(tail), .d(next_tail), .en(inc_tail), .clk(clk), .rst(rst));
   dff_en Head[BITS - 1:0] (.q(head), .d(next_head), .en(inc_head), .clk(clk), .rst(rst));

   queue_param_1r_1w #(.BITS(BITS), .SIZE(SIZE), .WIDTH(2301)) queue_reg(
     .in_wr_en(inc_tail),
     .in_wr_addr(tail),
     .in_wr_data(queue_wr_data),
     .in_rd_addr(head),
     .out_rd_data(queue_rd_data),
     .clk(clk),
     .rst(rst)
   );

endmodulemodule dest_shift_reg (
 alu_vgpr_dest_data,
 alu_sgpr_dest_data,
 alu_dest_vcc_value,
 alu_dest_exec_value,
 dest_buffer_wr_en,
 dest_buffer_shift_en,
 vgpr_dest_data,
 sgpr_dest_data,
 exec_wr_vcc_value,
 vgpr_wr_mask,
 clk,
 rst
);

input [511:0]   alu_vgpr_dest_data;
input [15:0]    alu_sgpr_dest_data;
input [15:0]    alu_dest_vcc_value;
input [15:0]    alu_dest_exec_value;
input           dest_buffer_wr_en;
input           dest_buffer_shift_en;
output [2047:0] vgpr_dest_data;
output [63:0]   sgpr_dest_data;
output [63:0]   exec_wr_vcc_value;
output [63:0]   vgpr_wr_mask;
input           clk;
input           rst;

shift_out #(32) vgpr_dest_shift(
  .data_in(alu_vgpr_dest_data),
  .wr_en(dest_buffer_wr_en),
  .shift_en(dest_buffer_shift_en),
  .data_out(vgpr_dest_data),
  .clk(clk),
  .rst(rst)
);

shift_out #(1) sgpr_dest_shift(
  .data_in(alu_sgpr_dest_data),
  .wr_en(dest_buffer_wr_en),
  .shift_en(dest_buffer_shift_en),
  .data_out(sgpr_dest_data),
  .clk(clk),
  .rst(rst)
);

shift_out #(1) exec_shift(
  .data_in(alu_dest_exec_value),
  .wr_en(dest_buffer_wr_en),
  .shift_en(dest_buffer_shift_en),
  .data_out(vgpr_wr_mask),
  .clk(clk),
  .rst(rst)
);

shift_out #(1) vcc_shift(
  .data_in(alu_dest_vcc_value),
  .wr_en(dest_buffer_wr_en),
  .shift_en(dest_buffer_shift_en),
  .data_out(exec_wr_vcc_value),
  .clk(clk),
  .rst(rst)
);

endmodule
module mux_2_to_1 (out, in, select);

  parameter WIDTH = 1;
  output [WIDTH-1:0] out;
  input [(2*WIDTH)-1:0] in;
  input select;

  reg [WIDTH-1:0] out;

  always @ (in or select) begin
    casex(select)
      1'b0: out <= in[WIDTH-1:0];
      1'b1: out <= in[(2*WIDTH)-1:WIDTH];
      default: out <= {WIDTH{1'bx}};
    endcase
  end
endmodule
module shift_in (
 data_in,
 wr_en,
 shift_en,
 data_out,
 clk,
 rst
);

parameter WIDTH=1;

input [(64*WIDTH)-1:0] data_in;
input wr_en;
input shift_en;
output [(16*WIDTH)-1:0] data_out;
input clk;
input rst;

wire [(64*WIDTH)-1:0] reg_in;
wire [(64*WIDTH)-1:0] reg_out;
reg line_wr_en;
reg s_or_w_;

always @ (shift_en or wr_en)
begin
  casex({shift_en,wr_en})
    2'b00:
      begin
        line_wr_en <= 1'b0;
        s_or_w_ <= 1'bx;
      end
    2'b01:
      begin
        line_wr_en <= 1'b1;
        s_or_w_ <= 1'b0;
      end
    2'b10:
      begin
        line_wr_en <= 1'b1;
        s_or_w_ <= 1'b1;
      end
    default:
      begin
        line_wr_en <= 1'bx;
        s_or_w_ <= 1'bx;
      end
  endcase
end

register #(WIDTH*16) reg_line[3:0](.out(reg_out), .in(reg_in), .wr_en(line_wr_en), .clk(clk), .rst(rst));

mux_2_to_1 #(WIDTH*16) line3_mux(.out(reg_in[(WIDTH*64)-1:(WIDTH*48)]), .in({{WIDTH*16{1'bx}},data_in[(WIDTH*64)-1:(WIDTH*48)]}), .select(s_or_w_));
mux_2_to_1 #(WIDTH*16) line2_mux(.out(reg_in[(WIDTH*48)-1:(WIDTH*32)]), .in({reg_out[(WIDTH*64)-1:WIDTH*48],data_in[(WIDTH*48)-1:(WIDTH*32)]}), .select(s_or_w_));
mux_2_to_1 #(WIDTH*16) line1_mux(.out(reg_in[(WIDTH*32)-1:(WIDTH*16)]), .in({reg_out[(WIDTH*48)-1:WIDTH*32],data_in[(WIDTH*32)-1:(WIDTH*16)]}), .select(s_or_w_));
mux_2_to_1 #(WIDTH*16) line0_mux(.out(reg_in[(WIDTH*16)-1:0]), .in({reg_out[(WIDTH*32)-1:WIDTH*16],data_in[(WIDTH*16)-1:0]}), .select(s_or_w_));

assign data_out = reg_out[(WIDTH*16)-1:0];

endmodule
module shift_out (
 data_in,
 wr_en,
 shift_en,
 data_out,
 clk,
 rst
);

parameter WIDTH=1;

input [(16*WIDTH)-1:0] data_in;
input wr_en;
input shift_en;
output [(64*WIDTH)-1:0] data_out;
input clk;
input rst;

wire [(64*WIDTH)-1:0] reg_in;
wire [3:0] line_wr_en;

assign reg_in[(WIDTH*16)-1:0] = data_out[(WIDTH*32)-1:(WIDTH*16)];
assign reg_in[(WIDTH*32)-1:(WIDTH*16)] = data_out[(WIDTH*48)-1:(WIDTH*32)];
assign reg_in[(WIDTH*48)-1:(WIDTH*32)] = data_out[(WIDTH*64)-1:(WIDTH*48)];
assign reg_in[(WIDTH*64)-1:(WIDTH*48)] = data_in;

assign line_wr_en[0:0] = wr_en;
assign line_wr_en[3:1] = {3{shift_en}};

register #(WIDTH*16) reg_line[3:0](.out(data_out), .in(reg_in), .wr_en(line_wr_en), .clk(clk), .rst(rst));

endmodule
module src_mux (
 src_constant,
 sgpr_rd_data,
 vgpr_source_data,
 exec_rd_exec_value,
 exec_rd_vcc_value,
 exec_rd_m0_value,
 exec_rd_scc_value,
 literal_constant,
 source_mux_select,
 source_data
);

input [9:0] src_constant;
input [31:0] sgpr_rd_data;
input [2047:0] vgpr_source_data;
input [63:0] exec_rd_exec_value;
input [63:0] exec_rd_vcc_value;
input [31:0] exec_rd_m0_value;
input exec_rd_scc_value;
input [3:0] source_mux_select;
input [31:0] literal_constant;
output [2047:0] source_data;

reg [2047:0] source_data;

always @ (src_constant or sgpr_rd_data or
 vgpr_source_data or exec_rd_exec_value or
 exec_rd_vcc_value or source_mux_select or literal_constant) begin

	casex(source_mux_select)
		4'b0000 : source_data <= {64{literal_constant}};
		4'b0001 : source_data <= {64{{22{src_constant[9]}}, src_constant}};
		4'b0010 : source_data <= vgpr_source_data;
		4'b0011 : source_data <= {64{sgpr_rd_data}};
		4'b0100 : source_data <= {64{exec_rd_vcc_value[31:0]}};
		4'b0101 : source_data <= {64{exec_rd_vcc_value[63:32]}};
		4'b0110 : source_data <= {64{exec_rd_m0_value}};
		4'b0111 : source_data <= {64{exec_rd_exec_value[31:0]}};
		4'b1000 : source_data <= {64{exec_rd_exec_value[63:32]}};
		4'b1001 : source_data <= {64{31'b0, !(&exec_rd_vcc_value)}};
		4'b1010 : source_data <= {64{31'b0, !(&exec_rd_exec_value)}};
		4'b1011 : source_data <= {64{31'b0, exec_rd_scc_value}};
		default: source_data <= {2048{1'bx}};
	endcase
end

endmodule
module src_shift_reg (
 source1_data,
 source2_data,
 source3_data,
 source_vcc_value,
 source_exec_value,
 src_buffer_wr_en,
 src_buffer_shift_en,
 alu_source1_data,
 alu_source2_data,
 alu_source3_data,
 alu_source_vcc_value,
 alu_source_exec_value,
 clk,
 rst
);

input [2047:0] source1_data;
input [2047:0] source2_data;
input [2047:0] source3_data;
input [63:0]   source_vcc_value;
input [63:0]   source_exec_value;
input          src_buffer_wr_en;
input          src_buffer_shift_en;
output [511:0] alu_source1_data;
output [511:0] alu_source2_data;
output [511:0] alu_source3_data;
output [15:0]  alu_source_vcc_value;
output [15:0]  alu_source_exec_value;
input          clk;
input          rst;

shift_in #(32) src1_shift(
  .data_in(source1_data),
  .wr_en(src_buffer_wr_en),
  .shift_en(src_buffer_shift_en),
  .data_out(alu_source1_data),
  .clk(clk),
  .rst(rst)
);

shift_in #(32) src2_shift(
  .data_in(source2_data),
  .wr_en(src_buffer_wr_en),
  .shift_en(src_buffer_shift_en),
  .data_out(alu_source2_data),
  .clk(clk),
  .rst(rst)
);

shift_in #(32) src3_shift(
  .data_in(source3_data),
  .wr_en(src_buffer_wr_en),
  .shift_en(src_buffer_shift_en),
  .data_out(alu_source3_data),
  .clk(clk),
  .rst(rst)
);

shift_in #(1) exec_shift(
  .data_in(source_exec_value),
  .wr_en(src_buffer_wr_en),
  .shift_en(src_buffer_shift_en),
  .data_out(alu_source_exec_value),
  .clk(clk),
  .rst(rst)
);

shift_in #(1) vcc_shift(
  .data_in(source_vcc_value),
  .wr_en(src_buffer_wr_en),
  .shift_en(src_buffer_shift_en),
  .data_out(alu_source_vcc_value),
  .clk(clk),
  .rst(rst)
);

endmodule
/**
 * alu_definitions.v
 * File that contains all definitions used throughout alu
 * stage
 ***/





























 // _alu_definitions_v_

module valu
  (
   alu_source1_data,
   alu_source2_data,
   alu_source3_data,
   alu_source_vcc_value,
   alu_source_exec_value,
   alu_control,
   alu_start,
   alu_vgpr_dest_data,
   alu_sgpr_dest_data,
   alu_dest_vcc_value,
   alu_dest_exec_value,
   valu_done,
   clk,
   rst
   );

   parameter MODULE = 0;

   input [511:0]  alu_source1_data;
   input [511:0]  alu_source2_data;
   input [511:0]  alu_source3_data;
   input [15:0]   alu_source_vcc_value;
   input [15:0]   alu_source_exec_value;
   input [31:0] 	alu_control;
   input          alu_start;
   output [511:0] alu_vgpr_dest_data;
   output [15:0]  alu_sgpr_dest_data;
   output [15:0]  alu_dest_vcc_value;
   output [15:0]  alu_dest_exec_value;
   output         valu_done;
   input 	  clk;
   input 	  rst;

   wire [15:0] alu_done;
   assign alu_dest_exec_value = alu_source_exec_value;
   assign valu_done = (&(alu_done | (~alu_source_exec_value))) & (|alu_control);

generate
   if (MODULE == 0)
      simd_alu simd_alu[15:0]
        (
         .alu_source1_data(alu_source1_data),
         .alu_source2_data(alu_source2_data),
         .alu_source3_data(alu_source3_data),
         .alu_source_vcc_value(alu_source_vcc_value),
         .alu_source_exec_value(alu_source_exec_value),
         .alu_control(alu_control),
         .alu_start(alu_start),
         .alu_vgpr_dest_data(alu_vgpr_dest_data),
         .alu_sgpr_dest_data(alu_sgpr_dest_data),
         .alu_dest_vcc_value(alu_dest_vcc_value),
         .alu_done(alu_done),
         .clk(clk),
         .rst(rst)
         );
   else if (MODULE == 1)
      simf_alu simf_alu[15:0]
        (
         .alu_source1_data(alu_source1_data),
         .alu_source2_data(alu_source2_data),
         .alu_source3_data(alu_source3_data),
         .alu_source_vcc_value(alu_source_vcc_value),
         .alu_source_exec_value(alu_source_exec_value),
         .alu_control(alu_control),
         .alu_start(alu_start),
         .alu_vgpr_dest_data(alu_vgpr_dest_data),
         .alu_sgpr_dest_data(alu_sgpr_dest_data),
         .alu_dest_vcc_value(alu_dest_vcc_value),
         .alu_done(alu_done),
         .clk(clk),
         .rst(rst)
         );
endgenerate

endmodule
module adder1bit (
	sum,
	cout,
	in1,
	in2,
	cin
);

output sum, cout;
input in1, in2, cin;

assign sum = in1 ^ in2 ^ cin;
assign cout = (in1 & in2) | (in2 & cin) | (cin & in1);

endmodule
module adder_param(
    in1,
    in2,
    cin,
    sum,
    cout
);

parameter WIDTH = 32;

input cin;
input[WIDTH-1:0] in1,in2;
output[WIDTH-1:0] sum;
output cout;

wire[WIDTH-1:0] cout_adders;

adder1bit adders[WIDTH-1:0](
	.sum(sum),
	.cout(cout_adders),
	.in1(in1),
	.in2(in2),
	.cin({cout_adders[WIDTH-2:0],cin})
);

assign cout = cout_adders[WIDTH-1];

endmodule
module circular_barrel_shift (
	output_val,
	input_val,
	shift_amt
);

output[39:0] output_val;

input[39:0] input_val;
input[5:0] shift_amt;

wire[39:0] shift_1, shift_2, shift_4, shift_8, shift_16; 

assign shift_1  = shift_amt[0] ? (input_val >> 1 | input_val << 39) : input_val;
assign shift_2  = shift_amt[1] ? (shift_1 >> 2 | shift_1 << 38) : shift_1;
assign shift_4  = shift_amt[2] ? (shift_2 >> 4 | shift_2 << 36) : shift_2;
assign shift_8  = shift_amt[3] ? (shift_4 >> 8 | shift_4 << 32) : shift_4;
assign shift_16 = shift_amt[4] ? (shift_8 >> 16 | shift_8 << 24) : shift_8;
assign output_val = shift_amt[5] ? (shift_16 >> 32 | shift_16 << 8) : shift_16;

endmodule
module decoder_10_to_1024 (out,in);
  output [1023:0] out;
  input [9:0] in;
// %%start_veriperl
// my $i;
// for($i=0; $i<1024; $i=$i+1)
// {
//   print "  assign out[$i] = (in == 10'd$i) ? 1'b1 : 1'b0;\n";
// }
// %%stop_veriperl
  assign out[0] = (in == 10'd0) ? 1'b1 : 1'b0;
  assign out[1] = (in == 10'd1) ? 1'b1 : 1'b0;
  assign out[2] = (in == 10'd2) ? 1'b1 : 1'b0;
  assign out[3] = (in == 10'd3) ? 1'b1 : 1'b0;
  assign out[4] = (in == 10'd4) ? 1'b1 : 1'b0;
  assign out[5] = (in == 10'd5) ? 1'b1 : 1'b0;
  assign out[6] = (in == 10'd6) ? 1'b1 : 1'b0;
  assign out[7] = (in == 10'd7) ? 1'b1 : 1'b0;
  assign out[8] = (in == 10'd8) ? 1'b1 : 1'b0;
  assign out[9] = (in == 10'd9) ? 1'b1 : 1'b0;
  assign out[10] = (in == 10'd10) ? 1'b1 : 1'b0;
  assign out[11] = (in == 10'd11) ? 1'b1 : 1'b0;
  assign out[12] = (in == 10'd12) ? 1'b1 : 1'b0;
  assign out[13] = (in == 10'd13) ? 1'b1 : 1'b0;
  assign out[14] = (in == 10'd14) ? 1'b1 : 1'b0;
  assign out[15] = (in == 10'd15) ? 1'b1 : 1'b0;
  assign out[16] = (in == 10'd16) ? 1'b1 : 1'b0;
  assign out[17] = (in == 10'd17) ? 1'b1 : 1'b0;
  assign out[18] = (in == 10'd18) ? 1'b1 : 1'b0;
  assign out[19] = (in == 10'd19) ? 1'b1 : 1'b0;
  assign out[20] = (in == 10'd20) ? 1'b1 : 1'b0;
  assign out[21] = (in == 10'd21) ? 1'b1 : 1'b0;
  assign out[22] = (in == 10'd22) ? 1'b1 : 1'b0;
  assign out[23] = (in == 10'd23) ? 1'b1 : 1'b0;
  assign out[24] = (in == 10'd24) ? 1'b1 : 1'b0;
  assign out[25] = (in == 10'd25) ? 1'b1 : 1'b0;
  assign out[26] = (in == 10'd26) ? 1'b1 : 1'b0;
  assign out[27] = (in == 10'd27) ? 1'b1 : 1'b0;
  assign out[28] = (in == 10'd28) ? 1'b1 : 1'b0;
  assign out[29] = (in == 10'd29) ? 1'b1 : 1'b0;
  assign out[30] = (in == 10'd30) ? 1'b1 : 1'b0;
  assign out[31] = (in == 10'd31) ? 1'b1 : 1'b0;
  assign out[32] = (in == 10'd32) ? 1'b1 : 1'b0;
  assign out[33] = (in == 10'd33) ? 1'b1 : 1'b0;
  assign out[34] = (in == 10'd34) ? 1'b1 : 1'b0;
  assign out[35] = (in == 10'd35) ? 1'b1 : 1'b0;
  assign out[36] = (in == 10'd36) ? 1'b1 : 1'b0;
  assign out[37] = (in == 10'd37) ? 1'b1 : 1'b0;
  assign out[38] = (in == 10'd38) ? 1'b1 : 1'b0;
  assign out[39] = (in == 10'd39) ? 1'b1 : 1'b0;
  assign out[40] = (in == 10'd40) ? 1'b1 : 1'b0;
  assign out[41] = (in == 10'd41) ? 1'b1 : 1'b0;
  assign out[42] = (in == 10'd42) ? 1'b1 : 1'b0;
  assign out[43] = (in == 10'd43) ? 1'b1 : 1'b0;
  assign out[44] = (in == 10'd44) ? 1'b1 : 1'b0;
  assign out[45] = (in == 10'd45) ? 1'b1 : 1'b0;
  assign out[46] = (in == 10'd46) ? 1'b1 : 1'b0;
  assign out[47] = (in == 10'd47) ? 1'b1 : 1'b0;
  assign out[48] = (in == 10'd48) ? 1'b1 : 1'b0;
  assign out[49] = (in == 10'd49) ? 1'b1 : 1'b0;
  assign out[50] = (in == 10'd50) ? 1'b1 : 1'b0;
  assign out[51] = (in == 10'd51) ? 1'b1 : 1'b0;
  assign out[52] = (in == 10'd52) ? 1'b1 : 1'b0;
  assign out[53] = (in == 10'd53) ? 1'b1 : 1'b0;
  assign out[54] = (in == 10'd54) ? 1'b1 : 1'b0;
  assign out[55] = (in == 10'd55) ? 1'b1 : 1'b0;
  assign out[56] = (in == 10'd56) ? 1'b1 : 1'b0;
  assign out[57] = (in == 10'd57) ? 1'b1 : 1'b0;
  assign out[58] = (in == 10'd58) ? 1'b1 : 1'b0;
  assign out[59] = (in == 10'd59) ? 1'b1 : 1'b0;
  assign out[60] = (in == 10'd60) ? 1'b1 : 1'b0;
  assign out[61] = (in == 10'd61) ? 1'b1 : 1'b0;
  assign out[62] = (in == 10'd62) ? 1'b1 : 1'b0;
  assign out[63] = (in == 10'd63) ? 1'b1 : 1'b0;
  assign out[64] = (in == 10'd64) ? 1'b1 : 1'b0;
  assign out[65] = (in == 10'd65) ? 1'b1 : 1'b0;
  assign out[66] = (in == 10'd66) ? 1'b1 : 1'b0;
  assign out[67] = (in == 10'd67) ? 1'b1 : 1'b0;
  assign out[68] = (in == 10'd68) ? 1'b1 : 1'b0;
  assign out[69] = (in == 10'd69) ? 1'b1 : 1'b0;
  assign out[70] = (in == 10'd70) ? 1'b1 : 1'b0;
  assign out[71] = (in == 10'd71) ? 1'b1 : 1'b0;
  assign out[72] = (in == 10'd72) ? 1'b1 : 1'b0;
  assign out[73] = (in == 10'd73) ? 1'b1 : 1'b0;
  assign out[74] = (in == 10'd74) ? 1'b1 : 1'b0;
  assign out[75] = (in == 10'd75) ? 1'b1 : 1'b0;
  assign out[76] = (in == 10'd76) ? 1'b1 : 1'b0;
  assign out[77] = (in == 10'd77) ? 1'b1 : 1'b0;
  assign out[78] = (in == 10'd78) ? 1'b1 : 1'b0;
  assign out[79] = (in == 10'd79) ? 1'b1 : 1'b0;
  assign out[80] = (in == 10'd80) ? 1'b1 : 1'b0;
  assign out[81] = (in == 10'd81) ? 1'b1 : 1'b0;
  assign out[82] = (in == 10'd82) ? 1'b1 : 1'b0;
  assign out[83] = (in == 10'd83) ? 1'b1 : 1'b0;
  assign out[84] = (in == 10'd84) ? 1'b1 : 1'b0;
  assign out[85] = (in == 10'd85) ? 1'b1 : 1'b0;
  assign out[86] = (in == 10'd86) ? 1'b1 : 1'b0;
  assign out[87] = (in == 10'd87) ? 1'b1 : 1'b0;
  assign out[88] = (in == 10'd88) ? 1'b1 : 1'b0;
  assign out[89] = (in == 10'd89) ? 1'b1 : 1'b0;
  assign out[90] = (in == 10'd90) ? 1'b1 : 1'b0;
  assign out[91] = (in == 10'd91) ? 1'b1 : 1'b0;
  assign out[92] = (in == 10'd92) ? 1'b1 : 1'b0;
  assign out[93] = (in == 10'd93) ? 1'b1 : 1'b0;
  assign out[94] = (in == 10'd94) ? 1'b1 : 1'b0;
  assign out[95] = (in == 10'd95) ? 1'b1 : 1'b0;
  assign out[96] = (in == 10'd96) ? 1'b1 : 1'b0;
  assign out[97] = (in == 10'd97) ? 1'b1 : 1'b0;
  assign out[98] = (in == 10'd98) ? 1'b1 : 1'b0;
  assign out[99] = (in == 10'd99) ? 1'b1 : 1'b0;
  assign out[100] = (in == 10'd100) ? 1'b1 : 1'b0;
  assign out[101] = (in == 10'd101) ? 1'b1 : 1'b0;
  assign out[102] = (in == 10'd102) ? 1'b1 : 1'b0;
  assign out[103] = (in == 10'd103) ? 1'b1 : 1'b0;
  assign out[104] = (in == 10'd104) ? 1'b1 : 1'b0;
  assign out[105] = (in == 10'd105) ? 1'b1 : 1'b0;
  assign out[106] = (in == 10'd106) ? 1'b1 : 1'b0;
  assign out[107] = (in == 10'd107) ? 1'b1 : 1'b0;
  assign out[108] = (in == 10'd108) ? 1'b1 : 1'b0;
  assign out[109] = (in == 10'd109) ? 1'b1 : 1'b0;
  assign out[110] = (in == 10'd110) ? 1'b1 : 1'b0;
  assign out[111] = (in == 10'd111) ? 1'b1 : 1'b0;
  assign out[112] = (in == 10'd112) ? 1'b1 : 1'b0;
  assign out[113] = (in == 10'd113) ? 1'b1 : 1'b0;
  assign out[114] = (in == 10'd114) ? 1'b1 : 1'b0;
  assign out[115] = (in == 10'd115) ? 1'b1 : 1'b0;
  assign out[116] = (in == 10'd116) ? 1'b1 : 1'b0;
  assign out[117] = (in == 10'd117) ? 1'b1 : 1'b0;
  assign out[118] = (in == 10'd118) ? 1'b1 : 1'b0;
  assign out[119] = (in == 10'd119) ? 1'b1 : 1'b0;
  assign out[120] = (in == 10'd120) ? 1'b1 : 1'b0;
  assign out[121] = (in == 10'd121) ? 1'b1 : 1'b0;
  assign out[122] = (in == 10'd122) ? 1'b1 : 1'b0;
  assign out[123] = (in == 10'd123) ? 1'b1 : 1'b0;
  assign out[124] = (in == 10'd124) ? 1'b1 : 1'b0;
  assign out[125] = (in == 10'd125) ? 1'b1 : 1'b0;
  assign out[126] = (in == 10'd126) ? 1'b1 : 1'b0;
  assign out[127] = (in == 10'd127) ? 1'b1 : 1'b0;
  assign out[128] = (in == 10'd128) ? 1'b1 : 1'b0;
  assign out[129] = (in == 10'd129) ? 1'b1 : 1'b0;
  assign out[130] = (in == 10'd130) ? 1'b1 : 1'b0;
  assign out[131] = (in == 10'd131) ? 1'b1 : 1'b0;
  assign out[132] = (in == 10'd132) ? 1'b1 : 1'b0;
  assign out[133] = (in == 10'd133) ? 1'b1 : 1'b0;
  assign out[134] = (in == 10'd134) ? 1'b1 : 1'b0;
  assign out[135] = (in == 10'd135) ? 1'b1 : 1'b0;
  assign out[136] = (in == 10'd136) ? 1'b1 : 1'b0;
  assign out[137] = (in == 10'd137) ? 1'b1 : 1'b0;
  assign out[138] = (in == 10'd138) ? 1'b1 : 1'b0;
  assign out[139] = (in == 10'd139) ? 1'b1 : 1'b0;
  assign out[140] = (in == 10'd140) ? 1'b1 : 1'b0;
  assign out[141] = (in == 10'd141) ? 1'b1 : 1'b0;
  assign out[142] = (in == 10'd142) ? 1'b1 : 1'b0;
  assign out[143] = (in == 10'd143) ? 1'b1 : 1'b0;
  assign out[144] = (in == 10'd144) ? 1'b1 : 1'b0;
  assign out[145] = (in == 10'd145) ? 1'b1 : 1'b0;
  assign out[146] = (in == 10'd146) ? 1'b1 : 1'b0;
  assign out[147] = (in == 10'd147) ? 1'b1 : 1'b0;
  assign out[148] = (in == 10'd148) ? 1'b1 : 1'b0;
  assign out[149] = (in == 10'd149) ? 1'b1 : 1'b0;
  assign out[150] = (in == 10'd150) ? 1'b1 : 1'b0;
  assign out[151] = (in == 10'd151) ? 1'b1 : 1'b0;
  assign out[152] = (in == 10'd152) ? 1'b1 : 1'b0;
  assign out[153] = (in == 10'd153) ? 1'b1 : 1'b0;
  assign out[154] = (in == 10'd154) ? 1'b1 : 1'b0;
  assign out[155] = (in == 10'd155) ? 1'b1 : 1'b0;
  assign out[156] = (in == 10'd156) ? 1'b1 : 1'b0;
  assign out[157] = (in == 10'd157) ? 1'b1 : 1'b0;
  assign out[158] = (in == 10'd158) ? 1'b1 : 1'b0;
  assign out[159] = (in == 10'd159) ? 1'b1 : 1'b0;
  assign out[160] = (in == 10'd160) ? 1'b1 : 1'b0;
  assign out[161] = (in == 10'd161) ? 1'b1 : 1'b0;
  assign out[162] = (in == 10'd162) ? 1'b1 : 1'b0;
  assign out[163] = (in == 10'd163) ? 1'b1 : 1'b0;
  assign out[164] = (in == 10'd164) ? 1'b1 : 1'b0;
  assign out[165] = (in == 10'd165) ? 1'b1 : 1'b0;
  assign out[166] = (in == 10'd166) ? 1'b1 : 1'b0;
  assign out[167] = (in == 10'd167) ? 1'b1 : 1'b0;
  assign out[168] = (in == 10'd168) ? 1'b1 : 1'b0;
  assign out[169] = (in == 10'd169) ? 1'b1 : 1'b0;
  assign out[170] = (in == 10'd170) ? 1'b1 : 1'b0;
  assign out[171] = (in == 10'd171) ? 1'b1 : 1'b0;
  assign out[172] = (in == 10'd172) ? 1'b1 : 1'b0;
  assign out[173] = (in == 10'd173) ? 1'b1 : 1'b0;
  assign out[174] = (in == 10'd174) ? 1'b1 : 1'b0;
  assign out[175] = (in == 10'd175) ? 1'b1 : 1'b0;
  assign out[176] = (in == 10'd176) ? 1'b1 : 1'b0;
  assign out[177] = (in == 10'd177) ? 1'b1 : 1'b0;
  assign out[178] = (in == 10'd178) ? 1'b1 : 1'b0;
  assign out[179] = (in == 10'd179) ? 1'b1 : 1'b0;
  assign out[180] = (in == 10'd180) ? 1'b1 : 1'b0;
  assign out[181] = (in == 10'd181) ? 1'b1 : 1'b0;
  assign out[182] = (in == 10'd182) ? 1'b1 : 1'b0;
  assign out[183] = (in == 10'd183) ? 1'b1 : 1'b0;
  assign out[184] = (in == 10'd184) ? 1'b1 : 1'b0;
  assign out[185] = (in == 10'd185) ? 1'b1 : 1'b0;
  assign out[186] = (in == 10'd186) ? 1'b1 : 1'b0;
  assign out[187] = (in == 10'd187) ? 1'b1 : 1'b0;
  assign out[188] = (in == 10'd188) ? 1'b1 : 1'b0;
  assign out[189] = (in == 10'd189) ? 1'b1 : 1'b0;
  assign out[190] = (in == 10'd190) ? 1'b1 : 1'b0;
  assign out[191] = (in == 10'd191) ? 1'b1 : 1'b0;
  assign out[192] = (in == 10'd192) ? 1'b1 : 1'b0;
  assign out[193] = (in == 10'd193) ? 1'b1 : 1'b0;
  assign out[194] = (in == 10'd194) ? 1'b1 : 1'b0;
  assign out[195] = (in == 10'd195) ? 1'b1 : 1'b0;
  assign out[196] = (in == 10'd196) ? 1'b1 : 1'b0;
  assign out[197] = (in == 10'd197) ? 1'b1 : 1'b0;
  assign out[198] = (in == 10'd198) ? 1'b1 : 1'b0;
  assign out[199] = (in == 10'd199) ? 1'b1 : 1'b0;
  assign out[200] = (in == 10'd200) ? 1'b1 : 1'b0;
  assign out[201] = (in == 10'd201) ? 1'b1 : 1'b0;
  assign out[202] = (in == 10'd202) ? 1'b1 : 1'b0;
  assign out[203] = (in == 10'd203) ? 1'b1 : 1'b0;
  assign out[204] = (in == 10'd204) ? 1'b1 : 1'b0;
  assign out[205] = (in == 10'd205) ? 1'b1 : 1'b0;
  assign out[206] = (in == 10'd206) ? 1'b1 : 1'b0;
  assign out[207] = (in == 10'd207) ? 1'b1 : 1'b0;
  assign out[208] = (in == 10'd208) ? 1'b1 : 1'b0;
  assign out[209] = (in == 10'd209) ? 1'b1 : 1'b0;
  assign out[210] = (in == 10'd210) ? 1'b1 : 1'b0;
  assign out[211] = (in == 10'd211) ? 1'b1 : 1'b0;
  assign out[212] = (in == 10'd212) ? 1'b1 : 1'b0;
  assign out[213] = (in == 10'd213) ? 1'b1 : 1'b0;
  assign out[214] = (in == 10'd214) ? 1'b1 : 1'b0;
  assign out[215] = (in == 10'd215) ? 1'b1 : 1'b0;
  assign out[216] = (in == 10'd216) ? 1'b1 : 1'b0;
  assign out[217] = (in == 10'd217) ? 1'b1 : 1'b0;
  assign out[218] = (in == 10'd218) ? 1'b1 : 1'b0;
  assign out[219] = (in == 10'd219) ? 1'b1 : 1'b0;
  assign out[220] = (in == 10'd220) ? 1'b1 : 1'b0;
  assign out[221] = (in == 10'd221) ? 1'b1 : 1'b0;
  assign out[222] = (in == 10'd222) ? 1'b1 : 1'b0;
  assign out[223] = (in == 10'd223) ? 1'b1 : 1'b0;
  assign out[224] = (in == 10'd224) ? 1'b1 : 1'b0;
  assign out[225] = (in == 10'd225) ? 1'b1 : 1'b0;
  assign out[226] = (in == 10'd226) ? 1'b1 : 1'b0;
  assign out[227] = (in == 10'd227) ? 1'b1 : 1'b0;
  assign out[228] = (in == 10'd228) ? 1'b1 : 1'b0;
  assign out[229] = (in == 10'd229) ? 1'b1 : 1'b0;
  assign out[230] = (in == 10'd230) ? 1'b1 : 1'b0;
  assign out[231] = (in == 10'd231) ? 1'b1 : 1'b0;
  assign out[232] = (in == 10'd232) ? 1'b1 : 1'b0;
  assign out[233] = (in == 10'd233) ? 1'b1 : 1'b0;
  assign out[234] = (in == 10'd234) ? 1'b1 : 1'b0;
  assign out[235] = (in == 10'd235) ? 1'b1 : 1'b0;
  assign out[236] = (in == 10'd236) ? 1'b1 : 1'b0;
  assign out[237] = (in == 10'd237) ? 1'b1 : 1'b0;
  assign out[238] = (in == 10'd238) ? 1'b1 : 1'b0;
  assign out[239] = (in == 10'd239) ? 1'b1 : 1'b0;
  assign out[240] = (in == 10'd240) ? 1'b1 : 1'b0;
  assign out[241] = (in == 10'd241) ? 1'b1 : 1'b0;
  assign out[242] = (in == 10'd242) ? 1'b1 : 1'b0;
  assign out[243] = (in == 10'd243) ? 1'b1 : 1'b0;
  assign out[244] = (in == 10'd244) ? 1'b1 : 1'b0;
  assign out[245] = (in == 10'd245) ? 1'b1 : 1'b0;
  assign out[246] = (in == 10'd246) ? 1'b1 : 1'b0;
  assign out[247] = (in == 10'd247) ? 1'b1 : 1'b0;
  assign out[248] = (in == 10'd248) ? 1'b1 : 1'b0;
  assign out[249] = (in == 10'd249) ? 1'b1 : 1'b0;
  assign out[250] = (in == 10'd250) ? 1'b1 : 1'b0;
  assign out[251] = (in == 10'd251) ? 1'b1 : 1'b0;
  assign out[252] = (in == 10'd252) ? 1'b1 : 1'b0;
  assign out[253] = (in == 10'd253) ? 1'b1 : 1'b0;
  assign out[254] = (in == 10'd254) ? 1'b1 : 1'b0;
  assign out[255] = (in == 10'd255) ? 1'b1 : 1'b0;
  assign out[256] = (in == 10'd256) ? 1'b1 : 1'b0;
  assign out[257] = (in == 10'd257) ? 1'b1 : 1'b0;
  assign out[258] = (in == 10'd258) ? 1'b1 : 1'b0;
  assign out[259] = (in == 10'd259) ? 1'b1 : 1'b0;
  assign out[260] = (in == 10'd260) ? 1'b1 : 1'b0;
  assign out[261] = (in == 10'd261) ? 1'b1 : 1'b0;
  assign out[262] = (in == 10'd262) ? 1'b1 : 1'b0;
  assign out[263] = (in == 10'd263) ? 1'b1 : 1'b0;
  assign out[264] = (in == 10'd264) ? 1'b1 : 1'b0;
  assign out[265] = (in == 10'd265) ? 1'b1 : 1'b0;
  assign out[266] = (in == 10'd266) ? 1'b1 : 1'b0;
  assign out[267] = (in == 10'd267) ? 1'b1 : 1'b0;
  assign out[268] = (in == 10'd268) ? 1'b1 : 1'b0;
  assign out[269] = (in == 10'd269) ? 1'b1 : 1'b0;
  assign out[270] = (in == 10'd270) ? 1'b1 : 1'b0;
  assign out[271] = (in == 10'd271) ? 1'b1 : 1'b0;
  assign out[272] = (in == 10'd272) ? 1'b1 : 1'b0;
  assign out[273] = (in == 10'd273) ? 1'b1 : 1'b0;
  assign out[274] = (in == 10'd274) ? 1'b1 : 1'b0;
  assign out[275] = (in == 10'd275) ? 1'b1 : 1'b0;
  assign out[276] = (in == 10'd276) ? 1'b1 : 1'b0;
  assign out[277] = (in == 10'd277) ? 1'b1 : 1'b0;
  assign out[278] = (in == 10'd278) ? 1'b1 : 1'b0;
  assign out[279] = (in == 10'd279) ? 1'b1 : 1'b0;
  assign out[280] = (in == 10'd280) ? 1'b1 : 1'b0;
  assign out[281] = (in == 10'd281) ? 1'b1 : 1'b0;
  assign out[282] = (in == 10'd282) ? 1'b1 : 1'b0;
  assign out[283] = (in == 10'd283) ? 1'b1 : 1'b0;
  assign out[284] = (in == 10'd284) ? 1'b1 : 1'b0;
  assign out[285] = (in == 10'd285) ? 1'b1 : 1'b0;
  assign out[286] = (in == 10'd286) ? 1'b1 : 1'b0;
  assign out[287] = (in == 10'd287) ? 1'b1 : 1'b0;
  assign out[288] = (in == 10'd288) ? 1'b1 : 1'b0;
  assign out[289] = (in == 10'd289) ? 1'b1 : 1'b0;
  assign out[290] = (in == 10'd290) ? 1'b1 : 1'b0;
  assign out[291] = (in == 10'd291) ? 1'b1 : 1'b0;
  assign out[292] = (in == 10'd292) ? 1'b1 : 1'b0;
  assign out[293] = (in == 10'd293) ? 1'b1 : 1'b0;
  assign out[294] = (in == 10'd294) ? 1'b1 : 1'b0;
  assign out[295] = (in == 10'd295) ? 1'b1 : 1'b0;
  assign out[296] = (in == 10'd296) ? 1'b1 : 1'b0;
  assign out[297] = (in == 10'd297) ? 1'b1 : 1'b0;
  assign out[298] = (in == 10'd298) ? 1'b1 : 1'b0;
  assign out[299] = (in == 10'd299) ? 1'b1 : 1'b0;
  assign out[300] = (in == 10'd300) ? 1'b1 : 1'b0;
  assign out[301] = (in == 10'd301) ? 1'b1 : 1'b0;
  assign out[302] = (in == 10'd302) ? 1'b1 : 1'b0;
  assign out[303] = (in == 10'd303) ? 1'b1 : 1'b0;
  assign out[304] = (in == 10'd304) ? 1'b1 : 1'b0;
  assign out[305] = (in == 10'd305) ? 1'b1 : 1'b0;
  assign out[306] = (in == 10'd306) ? 1'b1 : 1'b0;
  assign out[307] = (in == 10'd307) ? 1'b1 : 1'b0;
  assign out[308] = (in == 10'd308) ? 1'b1 : 1'b0;
  assign out[309] = (in == 10'd309) ? 1'b1 : 1'b0;
  assign out[310] = (in == 10'd310) ? 1'b1 : 1'b0;
  assign out[311] = (in == 10'd311) ? 1'b1 : 1'b0;
  assign out[312] = (in == 10'd312) ? 1'b1 : 1'b0;
  assign out[313] = (in == 10'd313) ? 1'b1 : 1'b0;
  assign out[314] = (in == 10'd314) ? 1'b1 : 1'b0;
  assign out[315] = (in == 10'd315) ? 1'b1 : 1'b0;
  assign out[316] = (in == 10'd316) ? 1'b1 : 1'b0;
  assign out[317] = (in == 10'd317) ? 1'b1 : 1'b0;
  assign out[318] = (in == 10'd318) ? 1'b1 : 1'b0;
  assign out[319] = (in == 10'd319) ? 1'b1 : 1'b0;
  assign out[320] = (in == 10'd320) ? 1'b1 : 1'b0;
  assign out[321] = (in == 10'd321) ? 1'b1 : 1'b0;
  assign out[322] = (in == 10'd322) ? 1'b1 : 1'b0;
  assign out[323] = (in == 10'd323) ? 1'b1 : 1'b0;
  assign out[324] = (in == 10'd324) ? 1'b1 : 1'b0;
  assign out[325] = (in == 10'd325) ? 1'b1 : 1'b0;
  assign out[326] = (in == 10'd326) ? 1'b1 : 1'b0;
  assign out[327] = (in == 10'd327) ? 1'b1 : 1'b0;
  assign out[328] = (in == 10'd328) ? 1'b1 : 1'b0;
  assign out[329] = (in == 10'd329) ? 1'b1 : 1'b0;
  assign out[330] = (in == 10'd330) ? 1'b1 : 1'b0;
  assign out[331] = (in == 10'd331) ? 1'b1 : 1'b0;
  assign out[332] = (in == 10'd332) ? 1'b1 : 1'b0;
  assign out[333] = (in == 10'd333) ? 1'b1 : 1'b0;
  assign out[334] = (in == 10'd334) ? 1'b1 : 1'b0;
  assign out[335] = (in == 10'd335) ? 1'b1 : 1'b0;
  assign out[336] = (in == 10'd336) ? 1'b1 : 1'b0;
  assign out[337] = (in == 10'd337) ? 1'b1 : 1'b0;
  assign out[338] = (in == 10'd338) ? 1'b1 : 1'b0;
  assign out[339] = (in == 10'd339) ? 1'b1 : 1'b0;
  assign out[340] = (in == 10'd340) ? 1'b1 : 1'b0;
  assign out[341] = (in == 10'd341) ? 1'b1 : 1'b0;
  assign out[342] = (in == 10'd342) ? 1'b1 : 1'b0;
  assign out[343] = (in == 10'd343) ? 1'b1 : 1'b0;
  assign out[344] = (in == 10'd344) ? 1'b1 : 1'b0;
  assign out[345] = (in == 10'd345) ? 1'b1 : 1'b0;
  assign out[346] = (in == 10'd346) ? 1'b1 : 1'b0;
  assign out[347] = (in == 10'd347) ? 1'b1 : 1'b0;
  assign out[348] = (in == 10'd348) ? 1'b1 : 1'b0;
  assign out[349] = (in == 10'd349) ? 1'b1 : 1'b0;
  assign out[350] = (in == 10'd350) ? 1'b1 : 1'b0;
  assign out[351] = (in == 10'd351) ? 1'b1 : 1'b0;
  assign out[352] = (in == 10'd352) ? 1'b1 : 1'b0;
  assign out[353] = (in == 10'd353) ? 1'b1 : 1'b0;
  assign out[354] = (in == 10'd354) ? 1'b1 : 1'b0;
  assign out[355] = (in == 10'd355) ? 1'b1 : 1'b0;
  assign out[356] = (in == 10'd356) ? 1'b1 : 1'b0;
  assign out[357] = (in == 10'd357) ? 1'b1 : 1'b0;
  assign out[358] = (in == 10'd358) ? 1'b1 : 1'b0;
  assign out[359] = (in == 10'd359) ? 1'b1 : 1'b0;
  assign out[360] = (in == 10'd360) ? 1'b1 : 1'b0;
  assign out[361] = (in == 10'd361) ? 1'b1 : 1'b0;
  assign out[362] = (in == 10'd362) ? 1'b1 : 1'b0;
  assign out[363] = (in == 10'd363) ? 1'b1 : 1'b0;
  assign out[364] = (in == 10'd364) ? 1'b1 : 1'b0;
  assign out[365] = (in == 10'd365) ? 1'b1 : 1'b0;
  assign out[366] = (in == 10'd366) ? 1'b1 : 1'b0;
  assign out[367] = (in == 10'd367) ? 1'b1 : 1'b0;
  assign out[368] = (in == 10'd368) ? 1'b1 : 1'b0;
  assign out[369] = (in == 10'd369) ? 1'b1 : 1'b0;
  assign out[370] = (in == 10'd370) ? 1'b1 : 1'b0;
  assign out[371] = (in == 10'd371) ? 1'b1 : 1'b0;
  assign out[372] = (in == 10'd372) ? 1'b1 : 1'b0;
  assign out[373] = (in == 10'd373) ? 1'b1 : 1'b0;
  assign out[374] = (in == 10'd374) ? 1'b1 : 1'b0;
  assign out[375] = (in == 10'd375) ? 1'b1 : 1'b0;
  assign out[376] = (in == 10'd376) ? 1'b1 : 1'b0;
  assign out[377] = (in == 10'd377) ? 1'b1 : 1'b0;
  assign out[378] = (in == 10'd378) ? 1'b1 : 1'b0;
  assign out[379] = (in == 10'd379) ? 1'b1 : 1'b0;
  assign out[380] = (in == 10'd380) ? 1'b1 : 1'b0;
  assign out[381] = (in == 10'd381) ? 1'b1 : 1'b0;
  assign out[382] = (in == 10'd382) ? 1'b1 : 1'b0;
  assign out[383] = (in == 10'd383) ? 1'b1 : 1'b0;
  assign out[384] = (in == 10'd384) ? 1'b1 : 1'b0;
  assign out[385] = (in == 10'd385) ? 1'b1 : 1'b0;
  assign out[386] = (in == 10'd386) ? 1'b1 : 1'b0;
  assign out[387] = (in == 10'd387) ? 1'b1 : 1'b0;
  assign out[388] = (in == 10'd388) ? 1'b1 : 1'b0;
  assign out[389] = (in == 10'd389) ? 1'b1 : 1'b0;
  assign out[390] = (in == 10'd390) ? 1'b1 : 1'b0;
  assign out[391] = (in == 10'd391) ? 1'b1 : 1'b0;
  assign out[392] = (in == 10'd392) ? 1'b1 : 1'b0;
  assign out[393] = (in == 10'd393) ? 1'b1 : 1'b0;
  assign out[394] = (in == 10'd394) ? 1'b1 : 1'b0;
  assign out[395] = (in == 10'd395) ? 1'b1 : 1'b0;
  assign out[396] = (in == 10'd396) ? 1'b1 : 1'b0;
  assign out[397] = (in == 10'd397) ? 1'b1 : 1'b0;
  assign out[398] = (in == 10'd398) ? 1'b1 : 1'b0;
  assign out[399] = (in == 10'd399) ? 1'b1 : 1'b0;
  assign out[400] = (in == 10'd400) ? 1'b1 : 1'b0;
  assign out[401] = (in == 10'd401) ? 1'b1 : 1'b0;
  assign out[402] = (in == 10'd402) ? 1'b1 : 1'b0;
  assign out[403] = (in == 10'd403) ? 1'b1 : 1'b0;
  assign out[404] = (in == 10'd404) ? 1'b1 : 1'b0;
  assign out[405] = (in == 10'd405) ? 1'b1 : 1'b0;
  assign out[406] = (in == 10'd406) ? 1'b1 : 1'b0;
  assign out[407] = (in == 10'd407) ? 1'b1 : 1'b0;
  assign out[408] = (in == 10'd408) ? 1'b1 : 1'b0;
  assign out[409] = (in == 10'd409) ? 1'b1 : 1'b0;
  assign out[410] = (in == 10'd410) ? 1'b1 : 1'b0;
  assign out[411] = (in == 10'd411) ? 1'b1 : 1'b0;
  assign out[412] = (in == 10'd412) ? 1'b1 : 1'b0;
  assign out[413] = (in == 10'd413) ? 1'b1 : 1'b0;
  assign out[414] = (in == 10'd414) ? 1'b1 : 1'b0;
  assign out[415] = (in == 10'd415) ? 1'b1 : 1'b0;
  assign out[416] = (in == 10'd416) ? 1'b1 : 1'b0;
  assign out[417] = (in == 10'd417) ? 1'b1 : 1'b0;
  assign out[418] = (in == 10'd418) ? 1'b1 : 1'b0;
  assign out[419] = (in == 10'd419) ? 1'b1 : 1'b0;
  assign out[420] = (in == 10'd420) ? 1'b1 : 1'b0;
  assign out[421] = (in == 10'd421) ? 1'b1 : 1'b0;
  assign out[422] = (in == 10'd422) ? 1'b1 : 1'b0;
  assign out[423] = (in == 10'd423) ? 1'b1 : 1'b0;
  assign out[424] = (in == 10'd424) ? 1'b1 : 1'b0;
  assign out[425] = (in == 10'd425) ? 1'b1 : 1'b0;
  assign out[426] = (in == 10'd426) ? 1'b1 : 1'b0;
  assign out[427] = (in == 10'd427) ? 1'b1 : 1'b0;
  assign out[428] = (in == 10'd428) ? 1'b1 : 1'b0;
  assign out[429] = (in == 10'd429) ? 1'b1 : 1'b0;
  assign out[430] = (in == 10'd430) ? 1'b1 : 1'b0;
  assign out[431] = (in == 10'd431) ? 1'b1 : 1'b0;
  assign out[432] = (in == 10'd432) ? 1'b1 : 1'b0;
  assign out[433] = (in == 10'd433) ? 1'b1 : 1'b0;
  assign out[434] = (in == 10'd434) ? 1'b1 : 1'b0;
  assign out[435] = (in == 10'd435) ? 1'b1 : 1'b0;
  assign out[436] = (in == 10'd436) ? 1'b1 : 1'b0;
  assign out[437] = (in == 10'd437) ? 1'b1 : 1'b0;
  assign out[438] = (in == 10'd438) ? 1'b1 : 1'b0;
  assign out[439] = (in == 10'd439) ? 1'b1 : 1'b0;
  assign out[440] = (in == 10'd440) ? 1'b1 : 1'b0;
  assign out[441] = (in == 10'd441) ? 1'b1 : 1'b0;
  assign out[442] = (in == 10'd442) ? 1'b1 : 1'b0;
  assign out[443] = (in == 10'd443) ? 1'b1 : 1'b0;
  assign out[444] = (in == 10'd444) ? 1'b1 : 1'b0;
  assign out[445] = (in == 10'd445) ? 1'b1 : 1'b0;
  assign out[446] = (in == 10'd446) ? 1'b1 : 1'b0;
  assign out[447] = (in == 10'd447) ? 1'b1 : 1'b0;
  assign out[448] = (in == 10'd448) ? 1'b1 : 1'b0;
  assign out[449] = (in == 10'd449) ? 1'b1 : 1'b0;
  assign out[450] = (in == 10'd450) ? 1'b1 : 1'b0;
  assign out[451] = (in == 10'd451) ? 1'b1 : 1'b0;
  assign out[452] = (in == 10'd452) ? 1'b1 : 1'b0;
  assign out[453] = (in == 10'd453) ? 1'b1 : 1'b0;
  assign out[454] = (in == 10'd454) ? 1'b1 : 1'b0;
  assign out[455] = (in == 10'd455) ? 1'b1 : 1'b0;
  assign out[456] = (in == 10'd456) ? 1'b1 : 1'b0;
  assign out[457] = (in == 10'd457) ? 1'b1 : 1'b0;
  assign out[458] = (in == 10'd458) ? 1'b1 : 1'b0;
  assign out[459] = (in == 10'd459) ? 1'b1 : 1'b0;
  assign out[460] = (in == 10'd460) ? 1'b1 : 1'b0;
  assign out[461] = (in == 10'd461) ? 1'b1 : 1'b0;
  assign out[462] = (in == 10'd462) ? 1'b1 : 1'b0;
  assign out[463] = (in == 10'd463) ? 1'b1 : 1'b0;
  assign out[464] = (in == 10'd464) ? 1'b1 : 1'b0;
  assign out[465] = (in == 10'd465) ? 1'b1 : 1'b0;
  assign out[466] = (in == 10'd466) ? 1'b1 : 1'b0;
  assign out[467] = (in == 10'd467) ? 1'b1 : 1'b0;
  assign out[468] = (in == 10'd468) ? 1'b1 : 1'b0;
  assign out[469] = (in == 10'd469) ? 1'b1 : 1'b0;
  assign out[470] = (in == 10'd470) ? 1'b1 : 1'b0;
  assign out[471] = (in == 10'd471) ? 1'b1 : 1'b0;
  assign out[472] = (in == 10'd472) ? 1'b1 : 1'b0;
  assign out[473] = (in == 10'd473) ? 1'b1 : 1'b0;
  assign out[474] = (in == 10'd474) ? 1'b1 : 1'b0;
  assign out[475] = (in == 10'd475) ? 1'b1 : 1'b0;
  assign out[476] = (in == 10'd476) ? 1'b1 : 1'b0;
  assign out[477] = (in == 10'd477) ? 1'b1 : 1'b0;
  assign out[478] = (in == 10'd478) ? 1'b1 : 1'b0;
  assign out[479] = (in == 10'd479) ? 1'b1 : 1'b0;
  assign out[480] = (in == 10'd480) ? 1'b1 : 1'b0;
  assign out[481] = (in == 10'd481) ? 1'b1 : 1'b0;
  assign out[482] = (in == 10'd482) ? 1'b1 : 1'b0;
  assign out[483] = (in == 10'd483) ? 1'b1 : 1'b0;
  assign out[484] = (in == 10'd484) ? 1'b1 : 1'b0;
  assign out[485] = (in == 10'd485) ? 1'b1 : 1'b0;
  assign out[486] = (in == 10'd486) ? 1'b1 : 1'b0;
  assign out[487] = (in == 10'd487) ? 1'b1 : 1'b0;
  assign out[488] = (in == 10'd488) ? 1'b1 : 1'b0;
  assign out[489] = (in == 10'd489) ? 1'b1 : 1'b0;
  assign out[490] = (in == 10'd490) ? 1'b1 : 1'b0;
  assign out[491] = (in == 10'd491) ? 1'b1 : 1'b0;
  assign out[492] = (in == 10'd492) ? 1'b1 : 1'b0;
  assign out[493] = (in == 10'd493) ? 1'b1 : 1'b0;
  assign out[494] = (in == 10'd494) ? 1'b1 : 1'b0;
  assign out[495] = (in == 10'd495) ? 1'b1 : 1'b0;
  assign out[496] = (in == 10'd496) ? 1'b1 : 1'b0;
  assign out[497] = (in == 10'd497) ? 1'b1 : 1'b0;
  assign out[498] = (in == 10'd498) ? 1'b1 : 1'b0;
  assign out[499] = (in == 10'd499) ? 1'b1 : 1'b0;
  assign out[500] = (in == 10'd500) ? 1'b1 : 1'b0;
  assign out[501] = (in == 10'd501) ? 1'b1 : 1'b0;
  assign out[502] = (in == 10'd502) ? 1'b1 : 1'b0;
  assign out[503] = (in == 10'd503) ? 1'b1 : 1'b0;
  assign out[504] = (in == 10'd504) ? 1'b1 : 1'b0;
  assign out[505] = (in == 10'd505) ? 1'b1 : 1'b0;
  assign out[506] = (in == 10'd506) ? 1'b1 : 1'b0;
  assign out[507] = (in == 10'd507) ? 1'b1 : 1'b0;
  assign out[508] = (in == 10'd508) ? 1'b1 : 1'b0;
  assign out[509] = (in == 10'd509) ? 1'b1 : 1'b0;
  assign out[510] = (in == 10'd510) ? 1'b1 : 1'b0;
  assign out[511] = (in == 10'd511) ? 1'b1 : 1'b0;
  assign out[512] = (in == 10'd512) ? 1'b1 : 1'b0;
  assign out[513] = (in == 10'd513) ? 1'b1 : 1'b0;
  assign out[514] = (in == 10'd514) ? 1'b1 : 1'b0;
  assign out[515] = (in == 10'd515) ? 1'b1 : 1'b0;
  assign out[516] = (in == 10'd516) ? 1'b1 : 1'b0;
  assign out[517] = (in == 10'd517) ? 1'b1 : 1'b0;
  assign out[518] = (in == 10'd518) ? 1'b1 : 1'b0;
  assign out[519] = (in == 10'd519) ? 1'b1 : 1'b0;
  assign out[520] = (in == 10'd520) ? 1'b1 : 1'b0;
  assign out[521] = (in == 10'd521) ? 1'b1 : 1'b0;
  assign out[522] = (in == 10'd522) ? 1'b1 : 1'b0;
  assign out[523] = (in == 10'd523) ? 1'b1 : 1'b0;
  assign out[524] = (in == 10'd524) ? 1'b1 : 1'b0;
  assign out[525] = (in == 10'd525) ? 1'b1 : 1'b0;
  assign out[526] = (in == 10'd526) ? 1'b1 : 1'b0;
  assign out[527] = (in == 10'd527) ? 1'b1 : 1'b0;
  assign out[528] = (in == 10'd528) ? 1'b1 : 1'b0;
  assign out[529] = (in == 10'd529) ? 1'b1 : 1'b0;
  assign out[530] = (in == 10'd530) ? 1'b1 : 1'b0;
  assign out[531] = (in == 10'd531) ? 1'b1 : 1'b0;
  assign out[532] = (in == 10'd532) ? 1'b1 : 1'b0;
  assign out[533] = (in == 10'd533) ? 1'b1 : 1'b0;
  assign out[534] = (in == 10'd534) ? 1'b1 : 1'b0;
  assign out[535] = (in == 10'd535) ? 1'b1 : 1'b0;
  assign out[536] = (in == 10'd536) ? 1'b1 : 1'b0;
  assign out[537] = (in == 10'd537) ? 1'b1 : 1'b0;
  assign out[538] = (in == 10'd538) ? 1'b1 : 1'b0;
  assign out[539] = (in == 10'd539) ? 1'b1 : 1'b0;
  assign out[540] = (in == 10'd540) ? 1'b1 : 1'b0;
  assign out[541] = (in == 10'd541) ? 1'b1 : 1'b0;
  assign out[542] = (in == 10'd542) ? 1'b1 : 1'b0;
  assign out[543] = (in == 10'd543) ? 1'b1 : 1'b0;
  assign out[544] = (in == 10'd544) ? 1'b1 : 1'b0;
  assign out[545] = (in == 10'd545) ? 1'b1 : 1'b0;
  assign out[546] = (in == 10'd546) ? 1'b1 : 1'b0;
  assign out[547] = (in == 10'd547) ? 1'b1 : 1'b0;
  assign out[548] = (in == 10'd548) ? 1'b1 : 1'b0;
  assign out[549] = (in == 10'd549) ? 1'b1 : 1'b0;
  assign out[550] = (in == 10'd550) ? 1'b1 : 1'b0;
  assign out[551] = (in == 10'd551) ? 1'b1 : 1'b0;
  assign out[552] = (in == 10'd552) ? 1'b1 : 1'b0;
  assign out[553] = (in == 10'd553) ? 1'b1 : 1'b0;
  assign out[554] = (in == 10'd554) ? 1'b1 : 1'b0;
  assign out[555] = (in == 10'd555) ? 1'b1 : 1'b0;
  assign out[556] = (in == 10'd556) ? 1'b1 : 1'b0;
  assign out[557] = (in == 10'd557) ? 1'b1 : 1'b0;
  assign out[558] = (in == 10'd558) ? 1'b1 : 1'b0;
  assign out[559] = (in == 10'd559) ? 1'b1 : 1'b0;
  assign out[560] = (in == 10'd560) ? 1'b1 : 1'b0;
  assign out[561] = (in == 10'd561) ? 1'b1 : 1'b0;
  assign out[562] = (in == 10'd562) ? 1'b1 : 1'b0;
  assign out[563] = (in == 10'd563) ? 1'b1 : 1'b0;
  assign out[564] = (in == 10'd564) ? 1'b1 : 1'b0;
  assign out[565] = (in == 10'd565) ? 1'b1 : 1'b0;
  assign out[566] = (in == 10'd566) ? 1'b1 : 1'b0;
  assign out[567] = (in == 10'd567) ? 1'b1 : 1'b0;
  assign out[568] = (in == 10'd568) ? 1'b1 : 1'b0;
  assign out[569] = (in == 10'd569) ? 1'b1 : 1'b0;
  assign out[570] = (in == 10'd570) ? 1'b1 : 1'b0;
  assign out[571] = (in == 10'd571) ? 1'b1 : 1'b0;
  assign out[572] = (in == 10'd572) ? 1'b1 : 1'b0;
  assign out[573] = (in == 10'd573) ? 1'b1 : 1'b0;
  assign out[574] = (in == 10'd574) ? 1'b1 : 1'b0;
  assign out[575] = (in == 10'd575) ? 1'b1 : 1'b0;
  assign out[576] = (in == 10'd576) ? 1'b1 : 1'b0;
  assign out[577] = (in == 10'd577) ? 1'b1 : 1'b0;
  assign out[578] = (in == 10'd578) ? 1'b1 : 1'b0;
  assign out[579] = (in == 10'd579) ? 1'b1 : 1'b0;
  assign out[580] = (in == 10'd580) ? 1'b1 : 1'b0;
  assign out[581] = (in == 10'd581) ? 1'b1 : 1'b0;
  assign out[582] = (in == 10'd582) ? 1'b1 : 1'b0;
  assign out[583] = (in == 10'd583) ? 1'b1 : 1'b0;
  assign out[584] = (in == 10'd584) ? 1'b1 : 1'b0;
  assign out[585] = (in == 10'd585) ? 1'b1 : 1'b0;
  assign out[586] = (in == 10'd586) ? 1'b1 : 1'b0;
  assign out[587] = (in == 10'd587) ? 1'b1 : 1'b0;
  assign out[588] = (in == 10'd588) ? 1'b1 : 1'b0;
  assign out[589] = (in == 10'd589) ? 1'b1 : 1'b0;
  assign out[590] = (in == 10'd590) ? 1'b1 : 1'b0;
  assign out[591] = (in == 10'd591) ? 1'b1 : 1'b0;
  assign out[592] = (in == 10'd592) ? 1'b1 : 1'b0;
  assign out[593] = (in == 10'd593) ? 1'b1 : 1'b0;
  assign out[594] = (in == 10'd594) ? 1'b1 : 1'b0;
  assign out[595] = (in == 10'd595) ? 1'b1 : 1'b0;
  assign out[596] = (in == 10'd596) ? 1'b1 : 1'b0;
  assign out[597] = (in == 10'd597) ? 1'b1 : 1'b0;
  assign out[598] = (in == 10'd598) ? 1'b1 : 1'b0;
  assign out[599] = (in == 10'd599) ? 1'b1 : 1'b0;
  assign out[600] = (in == 10'd600) ? 1'b1 : 1'b0;
  assign out[601] = (in == 10'd601) ? 1'b1 : 1'b0;
  assign out[602] = (in == 10'd602) ? 1'b1 : 1'b0;
  assign out[603] = (in == 10'd603) ? 1'b1 : 1'b0;
  assign out[604] = (in == 10'd604) ? 1'b1 : 1'b0;
  assign out[605] = (in == 10'd605) ? 1'b1 : 1'b0;
  assign out[606] = (in == 10'd606) ? 1'b1 : 1'b0;
  assign out[607] = (in == 10'd607) ? 1'b1 : 1'b0;
  assign out[608] = (in == 10'd608) ? 1'b1 : 1'b0;
  assign out[609] = (in == 10'd609) ? 1'b1 : 1'b0;
  assign out[610] = (in == 10'd610) ? 1'b1 : 1'b0;
  assign out[611] = (in == 10'd611) ? 1'b1 : 1'b0;
  assign out[612] = (in == 10'd612) ? 1'b1 : 1'b0;
  assign out[613] = (in == 10'd613) ? 1'b1 : 1'b0;
  assign out[614] = (in == 10'd614) ? 1'b1 : 1'b0;
  assign out[615] = (in == 10'd615) ? 1'b1 : 1'b0;
  assign out[616] = (in == 10'd616) ? 1'b1 : 1'b0;
  assign out[617] = (in == 10'd617) ? 1'b1 : 1'b0;
  assign out[618] = (in == 10'd618) ? 1'b1 : 1'b0;
  assign out[619] = (in == 10'd619) ? 1'b1 : 1'b0;
  assign out[620] = (in == 10'd620) ? 1'b1 : 1'b0;
  assign out[621] = (in == 10'd621) ? 1'b1 : 1'b0;
  assign out[622] = (in == 10'd622) ? 1'b1 : 1'b0;
  assign out[623] = (in == 10'd623) ? 1'b1 : 1'b0;
  assign out[624] = (in == 10'd624) ? 1'b1 : 1'b0;
  assign out[625] = (in == 10'd625) ? 1'b1 : 1'b0;
  assign out[626] = (in == 10'd626) ? 1'b1 : 1'b0;
  assign out[627] = (in == 10'd627) ? 1'b1 : 1'b0;
  assign out[628] = (in == 10'd628) ? 1'b1 : 1'b0;
  assign out[629] = (in == 10'd629) ? 1'b1 : 1'b0;
  assign out[630] = (in == 10'd630) ? 1'b1 : 1'b0;
  assign out[631] = (in == 10'd631) ? 1'b1 : 1'b0;
  assign out[632] = (in == 10'd632) ? 1'b1 : 1'b0;
  assign out[633] = (in == 10'd633) ? 1'b1 : 1'b0;
  assign out[634] = (in == 10'd634) ? 1'b1 : 1'b0;
  assign out[635] = (in == 10'd635) ? 1'b1 : 1'b0;
  assign out[636] = (in == 10'd636) ? 1'b1 : 1'b0;
  assign out[637] = (in == 10'd637) ? 1'b1 : 1'b0;
  assign out[638] = (in == 10'd638) ? 1'b1 : 1'b0;
  assign out[639] = (in == 10'd639) ? 1'b1 : 1'b0;
  assign out[640] = (in == 10'd640) ? 1'b1 : 1'b0;
  assign out[641] = (in == 10'd641) ? 1'b1 : 1'b0;
  assign out[642] = (in == 10'd642) ? 1'b1 : 1'b0;
  assign out[643] = (in == 10'd643) ? 1'b1 : 1'b0;
  assign out[644] = (in == 10'd644) ? 1'b1 : 1'b0;
  assign out[645] = (in == 10'd645) ? 1'b1 : 1'b0;
  assign out[646] = (in == 10'd646) ? 1'b1 : 1'b0;
  assign out[647] = (in == 10'd647) ? 1'b1 : 1'b0;
  assign out[648] = (in == 10'd648) ? 1'b1 : 1'b0;
  assign out[649] = (in == 10'd649) ? 1'b1 : 1'b0;
  assign out[650] = (in == 10'd650) ? 1'b1 : 1'b0;
  assign out[651] = (in == 10'd651) ? 1'b1 : 1'b0;
  assign out[652] = (in == 10'd652) ? 1'b1 : 1'b0;
  assign out[653] = (in == 10'd653) ? 1'b1 : 1'b0;
  assign out[654] = (in == 10'd654) ? 1'b1 : 1'b0;
  assign out[655] = (in == 10'd655) ? 1'b1 : 1'b0;
  assign out[656] = (in == 10'd656) ? 1'b1 : 1'b0;
  assign out[657] = (in == 10'd657) ? 1'b1 : 1'b0;
  assign out[658] = (in == 10'd658) ? 1'b1 : 1'b0;
  assign out[659] = (in == 10'd659) ? 1'b1 : 1'b0;
  assign out[660] = (in == 10'd660) ? 1'b1 : 1'b0;
  assign out[661] = (in == 10'd661) ? 1'b1 : 1'b0;
  assign out[662] = (in == 10'd662) ? 1'b1 : 1'b0;
  assign out[663] = (in == 10'd663) ? 1'b1 : 1'b0;
  assign out[664] = (in == 10'd664) ? 1'b1 : 1'b0;
  assign out[665] = (in == 10'd665) ? 1'b1 : 1'b0;
  assign out[666] = (in == 10'd666) ? 1'b1 : 1'b0;
  assign out[667] = (in == 10'd667) ? 1'b1 : 1'b0;
  assign out[668] = (in == 10'd668) ? 1'b1 : 1'b0;
  assign out[669] = (in == 10'd669) ? 1'b1 : 1'b0;
  assign out[670] = (in == 10'd670) ? 1'b1 : 1'b0;
  assign out[671] = (in == 10'd671) ? 1'b1 : 1'b0;
  assign out[672] = (in == 10'd672) ? 1'b1 : 1'b0;
  assign out[673] = (in == 10'd673) ? 1'b1 : 1'b0;
  assign out[674] = (in == 10'd674) ? 1'b1 : 1'b0;
  assign out[675] = (in == 10'd675) ? 1'b1 : 1'b0;
  assign out[676] = (in == 10'd676) ? 1'b1 : 1'b0;
  assign out[677] = (in == 10'd677) ? 1'b1 : 1'b0;
  assign out[678] = (in == 10'd678) ? 1'b1 : 1'b0;
  assign out[679] = (in == 10'd679) ? 1'b1 : 1'b0;
  assign out[680] = (in == 10'd680) ? 1'b1 : 1'b0;
  assign out[681] = (in == 10'd681) ? 1'b1 : 1'b0;
  assign out[682] = (in == 10'd682) ? 1'b1 : 1'b0;
  assign out[683] = (in == 10'd683) ? 1'b1 : 1'b0;
  assign out[684] = (in == 10'd684) ? 1'b1 : 1'b0;
  assign out[685] = (in == 10'd685) ? 1'b1 : 1'b0;
  assign out[686] = (in == 10'd686) ? 1'b1 : 1'b0;
  assign out[687] = (in == 10'd687) ? 1'b1 : 1'b0;
  assign out[688] = (in == 10'd688) ? 1'b1 : 1'b0;
  assign out[689] = (in == 10'd689) ? 1'b1 : 1'b0;
  assign out[690] = (in == 10'd690) ? 1'b1 : 1'b0;
  assign out[691] = (in == 10'd691) ? 1'b1 : 1'b0;
  assign out[692] = (in == 10'd692) ? 1'b1 : 1'b0;
  assign out[693] = (in == 10'd693) ? 1'b1 : 1'b0;
  assign out[694] = (in == 10'd694) ? 1'b1 : 1'b0;
  assign out[695] = (in == 10'd695) ? 1'b1 : 1'b0;
  assign out[696] = (in == 10'd696) ? 1'b1 : 1'b0;
  assign out[697] = (in == 10'd697) ? 1'b1 : 1'b0;
  assign out[698] = (in == 10'd698) ? 1'b1 : 1'b0;
  assign out[699] = (in == 10'd699) ? 1'b1 : 1'b0;
  assign out[700] = (in == 10'd700) ? 1'b1 : 1'b0;
  assign out[701] = (in == 10'd701) ? 1'b1 : 1'b0;
  assign out[702] = (in == 10'd702) ? 1'b1 : 1'b0;
  assign out[703] = (in == 10'd703) ? 1'b1 : 1'b0;
  assign out[704] = (in == 10'd704) ? 1'b1 : 1'b0;
  assign out[705] = (in == 10'd705) ? 1'b1 : 1'b0;
  assign out[706] = (in == 10'd706) ? 1'b1 : 1'b0;
  assign out[707] = (in == 10'd707) ? 1'b1 : 1'b0;
  assign out[708] = (in == 10'd708) ? 1'b1 : 1'b0;
  assign out[709] = (in == 10'd709) ? 1'b1 : 1'b0;
  assign out[710] = (in == 10'd710) ? 1'b1 : 1'b0;
  assign out[711] = (in == 10'd711) ? 1'b1 : 1'b0;
  assign out[712] = (in == 10'd712) ? 1'b1 : 1'b0;
  assign out[713] = (in == 10'd713) ? 1'b1 : 1'b0;
  assign out[714] = (in == 10'd714) ? 1'b1 : 1'b0;
  assign out[715] = (in == 10'd715) ? 1'b1 : 1'b0;
  assign out[716] = (in == 10'd716) ? 1'b1 : 1'b0;
  assign out[717] = (in == 10'd717) ? 1'b1 : 1'b0;
  assign out[718] = (in == 10'd718) ? 1'b1 : 1'b0;
  assign out[719] = (in == 10'd719) ? 1'b1 : 1'b0;
  assign out[720] = (in == 10'd720) ? 1'b1 : 1'b0;
  assign out[721] = (in == 10'd721) ? 1'b1 : 1'b0;
  assign out[722] = (in == 10'd722) ? 1'b1 : 1'b0;
  assign out[723] = (in == 10'd723) ? 1'b1 : 1'b0;
  assign out[724] = (in == 10'd724) ? 1'b1 : 1'b0;
  assign out[725] = (in == 10'd725) ? 1'b1 : 1'b0;
  assign out[726] = (in == 10'd726) ? 1'b1 : 1'b0;
  assign out[727] = (in == 10'd727) ? 1'b1 : 1'b0;
  assign out[728] = (in == 10'd728) ? 1'b1 : 1'b0;
  assign out[729] = (in == 10'd729) ? 1'b1 : 1'b0;
  assign out[730] = (in == 10'd730) ? 1'b1 : 1'b0;
  assign out[731] = (in == 10'd731) ? 1'b1 : 1'b0;
  assign out[732] = (in == 10'd732) ? 1'b1 : 1'b0;
  assign out[733] = (in == 10'd733) ? 1'b1 : 1'b0;
  assign out[734] = (in == 10'd734) ? 1'b1 : 1'b0;
  assign out[735] = (in == 10'd735) ? 1'b1 : 1'b0;
  assign out[736] = (in == 10'd736) ? 1'b1 : 1'b0;
  assign out[737] = (in == 10'd737) ? 1'b1 : 1'b0;
  assign out[738] = (in == 10'd738) ? 1'b1 : 1'b0;
  assign out[739] = (in == 10'd739) ? 1'b1 : 1'b0;
  assign out[740] = (in == 10'd740) ? 1'b1 : 1'b0;
  assign out[741] = (in == 10'd741) ? 1'b1 : 1'b0;
  assign out[742] = (in == 10'd742) ? 1'b1 : 1'b0;
  assign out[743] = (in == 10'd743) ? 1'b1 : 1'b0;
  assign out[744] = (in == 10'd744) ? 1'b1 : 1'b0;
  assign out[745] = (in == 10'd745) ? 1'b1 : 1'b0;
  assign out[746] = (in == 10'd746) ? 1'b1 : 1'b0;
  assign out[747] = (in == 10'd747) ? 1'b1 : 1'b0;
  assign out[748] = (in == 10'd748) ? 1'b1 : 1'b0;
  assign out[749] = (in == 10'd749) ? 1'b1 : 1'b0;
  assign out[750] = (in == 10'd750) ? 1'b1 : 1'b0;
  assign out[751] = (in == 10'd751) ? 1'b1 : 1'b0;
  assign out[752] = (in == 10'd752) ? 1'b1 : 1'b0;
  assign out[753] = (in == 10'd753) ? 1'b1 : 1'b0;
  assign out[754] = (in == 10'd754) ? 1'b1 : 1'b0;
  assign out[755] = (in == 10'd755) ? 1'b1 : 1'b0;
  assign out[756] = (in == 10'd756) ? 1'b1 : 1'b0;
  assign out[757] = (in == 10'd757) ? 1'b1 : 1'b0;
  assign out[758] = (in == 10'd758) ? 1'b1 : 1'b0;
  assign out[759] = (in == 10'd759) ? 1'b1 : 1'b0;
  assign out[760] = (in == 10'd760) ? 1'b1 : 1'b0;
  assign out[761] = (in == 10'd761) ? 1'b1 : 1'b0;
  assign out[762] = (in == 10'd762) ? 1'b1 : 1'b0;
  assign out[763] = (in == 10'd763) ? 1'b1 : 1'b0;
  assign out[764] = (in == 10'd764) ? 1'b1 : 1'b0;
  assign out[765] = (in == 10'd765) ? 1'b1 : 1'b0;
  assign out[766] = (in == 10'd766) ? 1'b1 : 1'b0;
  assign out[767] = (in == 10'd767) ? 1'b1 : 1'b0;
  assign out[768] = (in == 10'd768) ? 1'b1 : 1'b0;
  assign out[769] = (in == 10'd769) ? 1'b1 : 1'b0;
  assign out[770] = (in == 10'd770) ? 1'b1 : 1'b0;
  assign out[771] = (in == 10'd771) ? 1'b1 : 1'b0;
  assign out[772] = (in == 10'd772) ? 1'b1 : 1'b0;
  assign out[773] = (in == 10'd773) ? 1'b1 : 1'b0;
  assign out[774] = (in == 10'd774) ? 1'b1 : 1'b0;
  assign out[775] = (in == 10'd775) ? 1'b1 : 1'b0;
  assign out[776] = (in == 10'd776) ? 1'b1 : 1'b0;
  assign out[777] = (in == 10'd777) ? 1'b1 : 1'b0;
  assign out[778] = (in == 10'd778) ? 1'b1 : 1'b0;
  assign out[779] = (in == 10'd779) ? 1'b1 : 1'b0;
  assign out[780] = (in == 10'd780) ? 1'b1 : 1'b0;
  assign out[781] = (in == 10'd781) ? 1'b1 : 1'b0;
  assign out[782] = (in == 10'd782) ? 1'b1 : 1'b0;
  assign out[783] = (in == 10'd783) ? 1'b1 : 1'b0;
  assign out[784] = (in == 10'd784) ? 1'b1 : 1'b0;
  assign out[785] = (in == 10'd785) ? 1'b1 : 1'b0;
  assign out[786] = (in == 10'd786) ? 1'b1 : 1'b0;
  assign out[787] = (in == 10'd787) ? 1'b1 : 1'b0;
  assign out[788] = (in == 10'd788) ? 1'b1 : 1'b0;
  assign out[789] = (in == 10'd789) ? 1'b1 : 1'b0;
  assign out[790] = (in == 10'd790) ? 1'b1 : 1'b0;
  assign out[791] = (in == 10'd791) ? 1'b1 : 1'b0;
  assign out[792] = (in == 10'd792) ? 1'b1 : 1'b0;
  assign out[793] = (in == 10'd793) ? 1'b1 : 1'b0;
  assign out[794] = (in == 10'd794) ? 1'b1 : 1'b0;
  assign out[795] = (in == 10'd795) ? 1'b1 : 1'b0;
  assign out[796] = (in == 10'd796) ? 1'b1 : 1'b0;
  assign out[797] = (in == 10'd797) ? 1'b1 : 1'b0;
  assign out[798] = (in == 10'd798) ? 1'b1 : 1'b0;
  assign out[799] = (in == 10'd799) ? 1'b1 : 1'b0;
  assign out[800] = (in == 10'd800) ? 1'b1 : 1'b0;
  assign out[801] = (in == 10'd801) ? 1'b1 : 1'b0;
  assign out[802] = (in == 10'd802) ? 1'b1 : 1'b0;
  assign out[803] = (in == 10'd803) ? 1'b1 : 1'b0;
  assign out[804] = (in == 10'd804) ? 1'b1 : 1'b0;
  assign out[805] = (in == 10'd805) ? 1'b1 : 1'b0;
  assign out[806] = (in == 10'd806) ? 1'b1 : 1'b0;
  assign out[807] = (in == 10'd807) ? 1'b1 : 1'b0;
  assign out[808] = (in == 10'd808) ? 1'b1 : 1'b0;
  assign out[809] = (in == 10'd809) ? 1'b1 : 1'b0;
  assign out[810] = (in == 10'd810) ? 1'b1 : 1'b0;
  assign out[811] = (in == 10'd811) ? 1'b1 : 1'b0;
  assign out[812] = (in == 10'd812) ? 1'b1 : 1'b0;
  assign out[813] = (in == 10'd813) ? 1'b1 : 1'b0;
  assign out[814] = (in == 10'd814) ? 1'b1 : 1'b0;
  assign out[815] = (in == 10'd815) ? 1'b1 : 1'b0;
  assign out[816] = (in == 10'd816) ? 1'b1 : 1'b0;
  assign out[817] = (in == 10'd817) ? 1'b1 : 1'b0;
  assign out[818] = (in == 10'd818) ? 1'b1 : 1'b0;
  assign out[819] = (in == 10'd819) ? 1'b1 : 1'b0;
  assign out[820] = (in == 10'd820) ? 1'b1 : 1'b0;
  assign out[821] = (in == 10'd821) ? 1'b1 : 1'b0;
  assign out[822] = (in == 10'd822) ? 1'b1 : 1'b0;
  assign out[823] = (in == 10'd823) ? 1'b1 : 1'b0;
  assign out[824] = (in == 10'd824) ? 1'b1 : 1'b0;
  assign out[825] = (in == 10'd825) ? 1'b1 : 1'b0;
  assign out[826] = (in == 10'd826) ? 1'b1 : 1'b0;
  assign out[827] = (in == 10'd827) ? 1'b1 : 1'b0;
  assign out[828] = (in == 10'd828) ? 1'b1 : 1'b0;
  assign out[829] = (in == 10'd829) ? 1'b1 : 1'b0;
  assign out[830] = (in == 10'd830) ? 1'b1 : 1'b0;
  assign out[831] = (in == 10'd831) ? 1'b1 : 1'b0;
  assign out[832] = (in == 10'd832) ? 1'b1 : 1'b0;
  assign out[833] = (in == 10'd833) ? 1'b1 : 1'b0;
  assign out[834] = (in == 10'd834) ? 1'b1 : 1'b0;
  assign out[835] = (in == 10'd835) ? 1'b1 : 1'b0;
  assign out[836] = (in == 10'd836) ? 1'b1 : 1'b0;
  assign out[837] = (in == 10'd837) ? 1'b1 : 1'b0;
  assign out[838] = (in == 10'd838) ? 1'b1 : 1'b0;
  assign out[839] = (in == 10'd839) ? 1'b1 : 1'b0;
  assign out[840] = (in == 10'd840) ? 1'b1 : 1'b0;
  assign out[841] = (in == 10'd841) ? 1'b1 : 1'b0;
  assign out[842] = (in == 10'd842) ? 1'b1 : 1'b0;
  assign out[843] = (in == 10'd843) ? 1'b1 : 1'b0;
  assign out[844] = (in == 10'd844) ? 1'b1 : 1'b0;
  assign out[845] = (in == 10'd845) ? 1'b1 : 1'b0;
  assign out[846] = (in == 10'd846) ? 1'b1 : 1'b0;
  assign out[847] = (in == 10'd847) ? 1'b1 : 1'b0;
  assign out[848] = (in == 10'd848) ? 1'b1 : 1'b0;
  assign out[849] = (in == 10'd849) ? 1'b1 : 1'b0;
  assign out[850] = (in == 10'd850) ? 1'b1 : 1'b0;
  assign out[851] = (in == 10'd851) ? 1'b1 : 1'b0;
  assign out[852] = (in == 10'd852) ? 1'b1 : 1'b0;
  assign out[853] = (in == 10'd853) ? 1'b1 : 1'b0;
  assign out[854] = (in == 10'd854) ? 1'b1 : 1'b0;
  assign out[855] = (in == 10'd855) ? 1'b1 : 1'b0;
  assign out[856] = (in == 10'd856) ? 1'b1 : 1'b0;
  assign out[857] = (in == 10'd857) ? 1'b1 : 1'b0;
  assign out[858] = (in == 10'd858) ? 1'b1 : 1'b0;
  assign out[859] = (in == 10'd859) ? 1'b1 : 1'b0;
  assign out[860] = (in == 10'd860) ? 1'b1 : 1'b0;
  assign out[861] = (in == 10'd861) ? 1'b1 : 1'b0;
  assign out[862] = (in == 10'd862) ? 1'b1 : 1'b0;
  assign out[863] = (in == 10'd863) ? 1'b1 : 1'b0;
  assign out[864] = (in == 10'd864) ? 1'b1 : 1'b0;
  assign out[865] = (in == 10'd865) ? 1'b1 : 1'b0;
  assign out[866] = (in == 10'd866) ? 1'b1 : 1'b0;
  assign out[867] = (in == 10'd867) ? 1'b1 : 1'b0;
  assign out[868] = (in == 10'd868) ? 1'b1 : 1'b0;
  assign out[869] = (in == 10'd869) ? 1'b1 : 1'b0;
  assign out[870] = (in == 10'd870) ? 1'b1 : 1'b0;
  assign out[871] = (in == 10'd871) ? 1'b1 : 1'b0;
  assign out[872] = (in == 10'd872) ? 1'b1 : 1'b0;
  assign out[873] = (in == 10'd873) ? 1'b1 : 1'b0;
  assign out[874] = (in == 10'd874) ? 1'b1 : 1'b0;
  assign out[875] = (in == 10'd875) ? 1'b1 : 1'b0;
  assign out[876] = (in == 10'd876) ? 1'b1 : 1'b0;
  assign out[877] = (in == 10'd877) ? 1'b1 : 1'b0;
  assign out[878] = (in == 10'd878) ? 1'b1 : 1'b0;
  assign out[879] = (in == 10'd879) ? 1'b1 : 1'b0;
  assign out[880] = (in == 10'd880) ? 1'b1 : 1'b0;
  assign out[881] = (in == 10'd881) ? 1'b1 : 1'b0;
  assign out[882] = (in == 10'd882) ? 1'b1 : 1'b0;
  assign out[883] = (in == 10'd883) ? 1'b1 : 1'b0;
  assign out[884] = (in == 10'd884) ? 1'b1 : 1'b0;
  assign out[885] = (in == 10'd885) ? 1'b1 : 1'b0;
  assign out[886] = (in == 10'd886) ? 1'b1 : 1'b0;
  assign out[887] = (in == 10'd887) ? 1'b1 : 1'b0;
  assign out[888] = (in == 10'd888) ? 1'b1 : 1'b0;
  assign out[889] = (in == 10'd889) ? 1'b1 : 1'b0;
  assign out[890] = (in == 10'd890) ? 1'b1 : 1'b0;
  assign out[891] = (in == 10'd891) ? 1'b1 : 1'b0;
  assign out[892] = (in == 10'd892) ? 1'b1 : 1'b0;
  assign out[893] = (in == 10'd893) ? 1'b1 : 1'b0;
  assign out[894] = (in == 10'd894) ? 1'b1 : 1'b0;
  assign out[895] = (in == 10'd895) ? 1'b1 : 1'b0;
  assign out[896] = (in == 10'd896) ? 1'b1 : 1'b0;
  assign out[897] = (in == 10'd897) ? 1'b1 : 1'b0;
  assign out[898] = (in == 10'd898) ? 1'b1 : 1'b0;
  assign out[899] = (in == 10'd899) ? 1'b1 : 1'b0;
  assign out[900] = (in == 10'd900) ? 1'b1 : 1'b0;
  assign out[901] = (in == 10'd901) ? 1'b1 : 1'b0;
  assign out[902] = (in == 10'd902) ? 1'b1 : 1'b0;
  assign out[903] = (in == 10'd903) ? 1'b1 : 1'b0;
  assign out[904] = (in == 10'd904) ? 1'b1 : 1'b0;
  assign out[905] = (in == 10'd905) ? 1'b1 : 1'b0;
  assign out[906] = (in == 10'd906) ? 1'b1 : 1'b0;
  assign out[907] = (in == 10'd907) ? 1'b1 : 1'b0;
  assign out[908] = (in == 10'd908) ? 1'b1 : 1'b0;
  assign out[909] = (in == 10'd909) ? 1'b1 : 1'b0;
  assign out[910] = (in == 10'd910) ? 1'b1 : 1'b0;
  assign out[911] = (in == 10'd911) ? 1'b1 : 1'b0;
  assign out[912] = (in == 10'd912) ? 1'b1 : 1'b0;
  assign out[913] = (in == 10'd913) ? 1'b1 : 1'b0;
  assign out[914] = (in == 10'd914) ? 1'b1 : 1'b0;
  assign out[915] = (in == 10'd915) ? 1'b1 : 1'b0;
  assign out[916] = (in == 10'd916) ? 1'b1 : 1'b0;
  assign out[917] = (in == 10'd917) ? 1'b1 : 1'b0;
  assign out[918] = (in == 10'd918) ? 1'b1 : 1'b0;
  assign out[919] = (in == 10'd919) ? 1'b1 : 1'b0;
  assign out[920] = (in == 10'd920) ? 1'b1 : 1'b0;
  assign out[921] = (in == 10'd921) ? 1'b1 : 1'b0;
  assign out[922] = (in == 10'd922) ? 1'b1 : 1'b0;
  assign out[923] = (in == 10'd923) ? 1'b1 : 1'b0;
  assign out[924] = (in == 10'd924) ? 1'b1 : 1'b0;
  assign out[925] = (in == 10'd925) ? 1'b1 : 1'b0;
  assign out[926] = (in == 10'd926) ? 1'b1 : 1'b0;
  assign out[927] = (in == 10'd927) ? 1'b1 : 1'b0;
  assign out[928] = (in == 10'd928) ? 1'b1 : 1'b0;
  assign out[929] = (in == 10'd929) ? 1'b1 : 1'b0;
  assign out[930] = (in == 10'd930) ? 1'b1 : 1'b0;
  assign out[931] = (in == 10'd931) ? 1'b1 : 1'b0;
  assign out[932] = (in == 10'd932) ? 1'b1 : 1'b0;
  assign out[933] = (in == 10'd933) ? 1'b1 : 1'b0;
  assign out[934] = (in == 10'd934) ? 1'b1 : 1'b0;
  assign out[935] = (in == 10'd935) ? 1'b1 : 1'b0;
  assign out[936] = (in == 10'd936) ? 1'b1 : 1'b0;
  assign out[937] = (in == 10'd937) ? 1'b1 : 1'b0;
  assign out[938] = (in == 10'd938) ? 1'b1 : 1'b0;
  assign out[939] = (in == 10'd939) ? 1'b1 : 1'b0;
  assign out[940] = (in == 10'd940) ? 1'b1 : 1'b0;
  assign out[941] = (in == 10'd941) ? 1'b1 : 1'b0;
  assign out[942] = (in == 10'd942) ? 1'b1 : 1'b0;
  assign out[943] = (in == 10'd943) ? 1'b1 : 1'b0;
  assign out[944] = (in == 10'd944) ? 1'b1 : 1'b0;
  assign out[945] = (in == 10'd945) ? 1'b1 : 1'b0;
  assign out[946] = (in == 10'd946) ? 1'b1 : 1'b0;
  assign out[947] = (in == 10'd947) ? 1'b1 : 1'b0;
  assign out[948] = (in == 10'd948) ? 1'b1 : 1'b0;
  assign out[949] = (in == 10'd949) ? 1'b1 : 1'b0;
  assign out[950] = (in == 10'd950) ? 1'b1 : 1'b0;
  assign out[951] = (in == 10'd951) ? 1'b1 : 1'b0;
  assign out[952] = (in == 10'd952) ? 1'b1 : 1'b0;
  assign out[953] = (in == 10'd953) ? 1'b1 : 1'b0;
  assign out[954] = (in == 10'd954) ? 1'b1 : 1'b0;
  assign out[955] = (in == 10'd955) ? 1'b1 : 1'b0;
  assign out[956] = (in == 10'd956) ? 1'b1 : 1'b0;
  assign out[957] = (in == 10'd957) ? 1'b1 : 1'b0;
  assign out[958] = (in == 10'd958) ? 1'b1 : 1'b0;
  assign out[959] = (in == 10'd959) ? 1'b1 : 1'b0;
  assign out[960] = (in == 10'd960) ? 1'b1 : 1'b0;
  assign out[961] = (in == 10'd961) ? 1'b1 : 1'b0;
  assign out[962] = (in == 10'd962) ? 1'b1 : 1'b0;
  assign out[963] = (in == 10'd963) ? 1'b1 : 1'b0;
  assign out[964] = (in == 10'd964) ? 1'b1 : 1'b0;
  assign out[965] = (in == 10'd965) ? 1'b1 : 1'b0;
  assign out[966] = (in == 10'd966) ? 1'b1 : 1'b0;
  assign out[967] = (in == 10'd967) ? 1'b1 : 1'b0;
  assign out[968] = (in == 10'd968) ? 1'b1 : 1'b0;
  assign out[969] = (in == 10'd969) ? 1'b1 : 1'b0;
  assign out[970] = (in == 10'd970) ? 1'b1 : 1'b0;
  assign out[971] = (in == 10'd971) ? 1'b1 : 1'b0;
  assign out[972] = (in == 10'd972) ? 1'b1 : 1'b0;
  assign out[973] = (in == 10'd973) ? 1'b1 : 1'b0;
  assign out[974] = (in == 10'd974) ? 1'b1 : 1'b0;
  assign out[975] = (in == 10'd975) ? 1'b1 : 1'b0;
  assign out[976] = (in == 10'd976) ? 1'b1 : 1'b0;
  assign out[977] = (in == 10'd977) ? 1'b1 : 1'b0;
  assign out[978] = (in == 10'd978) ? 1'b1 : 1'b0;
  assign out[979] = (in == 10'd979) ? 1'b1 : 1'b0;
  assign out[980] = (in == 10'd980) ? 1'b1 : 1'b0;
  assign out[981] = (in == 10'd981) ? 1'b1 : 1'b0;
  assign out[982] = (in == 10'd982) ? 1'b1 : 1'b0;
  assign out[983] = (in == 10'd983) ? 1'b1 : 1'b0;
  assign out[984] = (in == 10'd984) ? 1'b1 : 1'b0;
  assign out[985] = (in == 10'd985) ? 1'b1 : 1'b0;
  assign out[986] = (in == 10'd986) ? 1'b1 : 1'b0;
  assign out[987] = (in == 10'd987) ? 1'b1 : 1'b0;
  assign out[988] = (in == 10'd988) ? 1'b1 : 1'b0;
  assign out[989] = (in == 10'd989) ? 1'b1 : 1'b0;
  assign out[990] = (in == 10'd990) ? 1'b1 : 1'b0;
  assign out[991] = (in == 10'd991) ? 1'b1 : 1'b0;
  assign out[992] = (in == 10'd992) ? 1'b1 : 1'b0;
  assign out[993] = (in == 10'd993) ? 1'b1 : 1'b0;
  assign out[994] = (in == 10'd994) ? 1'b1 : 1'b0;
  assign out[995] = (in == 10'd995) ? 1'b1 : 1'b0;
  assign out[996] = (in == 10'd996) ? 1'b1 : 1'b0;
  assign out[997] = (in == 10'd997) ? 1'b1 : 1'b0;
  assign out[998] = (in == 10'd998) ? 1'b1 : 1'b0;
  assign out[999] = (in == 10'd999) ? 1'b1 : 1'b0;
  assign out[1000] = (in == 10'd1000) ? 1'b1 : 1'b0;
  assign out[1001] = (in == 10'd1001) ? 1'b1 : 1'b0;
  assign out[1002] = (in == 10'd1002) ? 1'b1 : 1'b0;
  assign out[1003] = (in == 10'd1003) ? 1'b1 : 1'b0;
  assign out[1004] = (in == 10'd1004) ? 1'b1 : 1'b0;
  assign out[1005] = (in == 10'd1005) ? 1'b1 : 1'b0;
  assign out[1006] = (in == 10'd1006) ? 1'b1 : 1'b0;
  assign out[1007] = (in == 10'd1007) ? 1'b1 : 1'b0;
  assign out[1008] = (in == 10'd1008) ? 1'b1 : 1'b0;
  assign out[1009] = (in == 10'd1009) ? 1'b1 : 1'b0;
  assign out[1010] = (in == 10'd1010) ? 1'b1 : 1'b0;
  assign out[1011] = (in == 10'd1011) ? 1'b1 : 1'b0;
  assign out[1012] = (in == 10'd1012) ? 1'b1 : 1'b0;
  assign out[1013] = (in == 10'd1013) ? 1'b1 : 1'b0;
  assign out[1014] = (in == 10'd1014) ? 1'b1 : 1'b0;
  assign out[1015] = (in == 10'd1015) ? 1'b1 : 1'b0;
  assign out[1016] = (in == 10'd1016) ? 1'b1 : 1'b0;
  assign out[1017] = (in == 10'd1017) ? 1'b1 : 1'b0;
  assign out[1018] = (in == 10'd1018) ? 1'b1 : 1'b0;
  assign out[1019] = (in == 10'd1019) ? 1'b1 : 1'b0;
  assign out[1020] = (in == 10'd1020) ? 1'b1 : 1'b0;
  assign out[1021] = (in == 10'd1021) ? 1'b1 : 1'b0;
  assign out[1022] = (in == 10'd1022) ? 1'b1 : 1'b0;
  assign out[1023] = (in == 10'd1023) ? 1'b1 : 1'b0;
endmodule
module decoder_6_to_40 (out,in);
  output [39:0] out;
  input [5:0] in;
// %%start_veriperl
// my $i;
// for($i=0; $i<40; $i=$i+1)
// {
//   print "  assign out[$i] = (in == 6'd$i) ? 1'b1 : 1'b0;\n";
// }
// %%stop_veriperl
  assign out[0] = (in == 6'd0) ? 1'b1 : 1'b0;
  assign out[1] = (in == 6'd1) ? 1'b1 : 1'b0;
  assign out[2] = (in == 6'd2) ? 1'b1 : 1'b0;
  assign out[3] = (in == 6'd3) ? 1'b1 : 1'b0;
  assign out[4] = (in == 6'd4) ? 1'b1 : 1'b0;
  assign out[5] = (in == 6'd5) ? 1'b1 : 1'b0;
  assign out[6] = (in == 6'd6) ? 1'b1 : 1'b0;
  assign out[7] = (in == 6'd7) ? 1'b1 : 1'b0;
  assign out[8] = (in == 6'd8) ? 1'b1 : 1'b0;
  assign out[9] = (in == 6'd9) ? 1'b1 : 1'b0;
  assign out[10] = (in == 6'd10) ? 1'b1 : 1'b0;
  assign out[11] = (in == 6'd11) ? 1'b1 : 1'b0;
  assign out[12] = (in == 6'd12) ? 1'b1 : 1'b0;
  assign out[13] = (in == 6'd13) ? 1'b1 : 1'b0;
  assign out[14] = (in == 6'd14) ? 1'b1 : 1'b0;
  assign out[15] = (in == 6'd15) ? 1'b1 : 1'b0;
  assign out[16] = (in == 6'd16) ? 1'b1 : 1'b0;
  assign out[17] = (in == 6'd17) ? 1'b1 : 1'b0;
  assign out[18] = (in == 6'd18) ? 1'b1 : 1'b0;
  assign out[19] = (in == 6'd19) ? 1'b1 : 1'b0;
  assign out[20] = (in == 6'd20) ? 1'b1 : 1'b0;
  assign out[21] = (in == 6'd21) ? 1'b1 : 1'b0;
  assign out[22] = (in == 6'd22) ? 1'b1 : 1'b0;
  assign out[23] = (in == 6'd23) ? 1'b1 : 1'b0;
  assign out[24] = (in == 6'd24) ? 1'b1 : 1'b0;
  assign out[25] = (in == 6'd25) ? 1'b1 : 1'b0;
  assign out[26] = (in == 6'd26) ? 1'b1 : 1'b0;
  assign out[27] = (in == 6'd27) ? 1'b1 : 1'b0;
  assign out[28] = (in == 6'd28) ? 1'b1 : 1'b0;
  assign out[29] = (in == 6'd29) ? 1'b1 : 1'b0;
  assign out[30] = (in == 6'd30) ? 1'b1 : 1'b0;
  assign out[31] = (in == 6'd31) ? 1'b1 : 1'b0;
  assign out[32] = (in == 6'd32) ? 1'b1 : 1'b0;
  assign out[33] = (in == 6'd33) ? 1'b1 : 1'b0;
  assign out[34] = (in == 6'd34) ? 1'b1 : 1'b0;
  assign out[35] = (in == 6'd35) ? 1'b1 : 1'b0;
  assign out[36] = (in == 6'd36) ? 1'b1 : 1'b0;
  assign out[37] = (in == 6'd37) ? 1'b1 : 1'b0;
  assign out[38] = (in == 6'd38) ? 1'b1 : 1'b0;
  assign out[39] = (in == 6'd39) ? 1'b1 : 1'b0;
endmodule
module decoder_6b_40b_en(
    addr_in,
    en,
    out);

input[5:0] addr_in; 
wire[5:0] addr_in;

output[39:0] out;
wire[39:0] out;
input en; 
wire en;

reg[39:0] decoded_out;

always@(addr_in)
begin
    decoded_out = 40'd0;
    case (addr_in)
        0: decoded_out[0]=1'b1;
        1: decoded_out[1]=1'b1;
        2: decoded_out[2]=1'b1;
        3: decoded_out[3]=1'b1;
        4: decoded_out[4]=1'b1;
        5: decoded_out[5]=1'b1;
        6: decoded_out[6]=1'b1;
        7: decoded_out[7]=1'b1;
        8: decoded_out[8]=1'b1;
        9: decoded_out[9]=1'b1;
        10: decoded_out[10]=1'b1;
        11: decoded_out[11]=1'b1;
        12: decoded_out[12]=1'b1;
        13: decoded_out[13]=1'b1;
        14: decoded_out[14]=1'b1;
        15: decoded_out[15]=1'b1;
        16: decoded_out[16]=1'b1;
        17: decoded_out[17]=1'b1;
        18: decoded_out[18]=1'b1;
        19: decoded_out[19]=1'b1;
        20: decoded_out[20]=1'b1;
        21: decoded_out[21]=1'b1;
        22: decoded_out[22]=1'b1;
        23: decoded_out[23]=1'b1;
        24: decoded_out[24]=1'b1;
        25: decoded_out[25]=1'b1;
        26: decoded_out[26]=1'b1;
        27: decoded_out[27]=1'b1;
        28: decoded_out[28]=1'b1;
        29: decoded_out[29]=1'b1;
        30: decoded_out[30]=1'b1;
        31: decoded_out[31]=1'b1;
        32: decoded_out[32]=1'b1;
        33: decoded_out[33]=1'b1;
        34: decoded_out[34]=1'b1;
        35: decoded_out[35]=1'b1;
        36: decoded_out[36]=1'b1;
        37: decoded_out[37]=1'b1;
        38: decoded_out[38]=1'b1;
        39: decoded_out[39]=1'b1;
        default: decoded_out = 40'd0;
    endcase
end

assign out = (en)?decoded_out:40'd0;

endmodule
module decoder_9_to_512 (out,in);
  output [511:0] out;
  input [8:0] in;
// %%start_veriperl
// my $i;
// for($i=0; $i<512; $i=$i+1)
// {
//   print "  assign out[$i] = (in == 9'd$i) ? 1'b1 : 1'b0;\n";
// }
// %%stop_veriperl
  assign out[0] = (in == 9'd0) ? 1'b1 : 1'b0;
  assign out[1] = (in == 9'd1) ? 1'b1 : 1'b0;
  assign out[2] = (in == 9'd2) ? 1'b1 : 1'b0;
  assign out[3] = (in == 9'd3) ? 1'b1 : 1'b0;
  assign out[4] = (in == 9'd4) ? 1'b1 : 1'b0;
  assign out[5] = (in == 9'd5) ? 1'b1 : 1'b0;
  assign out[6] = (in == 9'd6) ? 1'b1 : 1'b0;
  assign out[7] = (in == 9'd7) ? 1'b1 : 1'b0;
  assign out[8] = (in == 9'd8) ? 1'b1 : 1'b0;
  assign out[9] = (in == 9'd9) ? 1'b1 : 1'b0;
  assign out[10] = (in == 9'd10) ? 1'b1 : 1'b0;
  assign out[11] = (in == 9'd11) ? 1'b1 : 1'b0;
  assign out[12] = (in == 9'd12) ? 1'b1 : 1'b0;
  assign out[13] = (in == 9'd13) ? 1'b1 : 1'b0;
  assign out[14] = (in == 9'd14) ? 1'b1 : 1'b0;
  assign out[15] = (in == 9'd15) ? 1'b1 : 1'b0;
  assign out[16] = (in == 9'd16) ? 1'b1 : 1'b0;
  assign out[17] = (in == 9'd17) ? 1'b1 : 1'b0;
  assign out[18] = (in == 9'd18) ? 1'b1 : 1'b0;
  assign out[19] = (in == 9'd19) ? 1'b1 : 1'b0;
  assign out[20] = (in == 9'd20) ? 1'b1 : 1'b0;
  assign out[21] = (in == 9'd21) ? 1'b1 : 1'b0;
  assign out[22] = (in == 9'd22) ? 1'b1 : 1'b0;
  assign out[23] = (in == 9'd23) ? 1'b1 : 1'b0;
  assign out[24] = (in == 9'd24) ? 1'b1 : 1'b0;
  assign out[25] = (in == 9'd25) ? 1'b1 : 1'b0;
  assign out[26] = (in == 9'd26) ? 1'b1 : 1'b0;
  assign out[27] = (in == 9'd27) ? 1'b1 : 1'b0;
  assign out[28] = (in == 9'd28) ? 1'b1 : 1'b0;
  assign out[29] = (in == 9'd29) ? 1'b1 : 1'b0;
  assign out[30] = (in == 9'd30) ? 1'b1 : 1'b0;
  assign out[31] = (in == 9'd31) ? 1'b1 : 1'b0;
  assign out[32] = (in == 9'd32) ? 1'b1 : 1'b0;
  assign out[33] = (in == 9'd33) ? 1'b1 : 1'b0;
  assign out[34] = (in == 9'd34) ? 1'b1 : 1'b0;
  assign out[35] = (in == 9'd35) ? 1'b1 : 1'b0;
  assign out[36] = (in == 9'd36) ? 1'b1 : 1'b0;
  assign out[37] = (in == 9'd37) ? 1'b1 : 1'b0;
  assign out[38] = (in == 9'd38) ? 1'b1 : 1'b0;
  assign out[39] = (in == 9'd39) ? 1'b1 : 1'b0;
  assign out[40] = (in == 9'd40) ? 1'b1 : 1'b0;
  assign out[41] = (in == 9'd41) ? 1'b1 : 1'b0;
  assign out[42] = (in == 9'd42) ? 1'b1 : 1'b0;
  assign out[43] = (in == 9'd43) ? 1'b1 : 1'b0;
  assign out[44] = (in == 9'd44) ? 1'b1 : 1'b0;
  assign out[45] = (in == 9'd45) ? 1'b1 : 1'b0;
  assign out[46] = (in == 9'd46) ? 1'b1 : 1'b0;
  assign out[47] = (in == 9'd47) ? 1'b1 : 1'b0;
  assign out[48] = (in == 9'd48) ? 1'b1 : 1'b0;
  assign out[49] = (in == 9'd49) ? 1'b1 : 1'b0;
  assign out[50] = (in == 9'd50) ? 1'b1 : 1'b0;
  assign out[51] = (in == 9'd51) ? 1'b1 : 1'b0;
  assign out[52] = (in == 9'd52) ? 1'b1 : 1'b0;
  assign out[53] = (in == 9'd53) ? 1'b1 : 1'b0;
  assign out[54] = (in == 9'd54) ? 1'b1 : 1'b0;
  assign out[55] = (in == 9'd55) ? 1'b1 : 1'b0;
  assign out[56] = (in == 9'd56) ? 1'b1 : 1'b0;
  assign out[57] = (in == 9'd57) ? 1'b1 : 1'b0;
  assign out[58] = (in == 9'd58) ? 1'b1 : 1'b0;
  assign out[59] = (in == 9'd59) ? 1'b1 : 1'b0;
  assign out[60] = (in == 9'd60) ? 1'b1 : 1'b0;
  assign out[61] = (in == 9'd61) ? 1'b1 : 1'b0;
  assign out[62] = (in == 9'd62) ? 1'b1 : 1'b0;
  assign out[63] = (in == 9'd63) ? 1'b1 : 1'b0;
  assign out[64] = (in == 9'd64) ? 1'b1 : 1'b0;
  assign out[65] = (in == 9'd65) ? 1'b1 : 1'b0;
  assign out[66] = (in == 9'd66) ? 1'b1 : 1'b0;
  assign out[67] = (in == 9'd67) ? 1'b1 : 1'b0;
  assign out[68] = (in == 9'd68) ? 1'b1 : 1'b0;
  assign out[69] = (in == 9'd69) ? 1'b1 : 1'b0;
  assign out[70] = (in == 9'd70) ? 1'b1 : 1'b0;
  assign out[71] = (in == 9'd71) ? 1'b1 : 1'b0;
  assign out[72] = (in == 9'd72) ? 1'b1 : 1'b0;
  assign out[73] = (in == 9'd73) ? 1'b1 : 1'b0;
  assign out[74] = (in == 9'd74) ? 1'b1 : 1'b0;
  assign out[75] = (in == 9'd75) ? 1'b1 : 1'b0;
  assign out[76] = (in == 9'd76) ? 1'b1 : 1'b0;
  assign out[77] = (in == 9'd77) ? 1'b1 : 1'b0;
  assign out[78] = (in == 9'd78) ? 1'b1 : 1'b0;
  assign out[79] = (in == 9'd79) ? 1'b1 : 1'b0;
  assign out[80] = (in == 9'd80) ? 1'b1 : 1'b0;
  assign out[81] = (in == 9'd81) ? 1'b1 : 1'b0;
  assign out[82] = (in == 9'd82) ? 1'b1 : 1'b0;
  assign out[83] = (in == 9'd83) ? 1'b1 : 1'b0;
  assign out[84] = (in == 9'd84) ? 1'b1 : 1'b0;
  assign out[85] = (in == 9'd85) ? 1'b1 : 1'b0;
  assign out[86] = (in == 9'd86) ? 1'b1 : 1'b0;
  assign out[87] = (in == 9'd87) ? 1'b1 : 1'b0;
  assign out[88] = (in == 9'd88) ? 1'b1 : 1'b0;
  assign out[89] = (in == 9'd89) ? 1'b1 : 1'b0;
  assign out[90] = (in == 9'd90) ? 1'b1 : 1'b0;
  assign out[91] = (in == 9'd91) ? 1'b1 : 1'b0;
  assign out[92] = (in == 9'd92) ? 1'b1 : 1'b0;
  assign out[93] = (in == 9'd93) ? 1'b1 : 1'b0;
  assign out[94] = (in == 9'd94) ? 1'b1 : 1'b0;
  assign out[95] = (in == 9'd95) ? 1'b1 : 1'b0;
  assign out[96] = (in == 9'd96) ? 1'b1 : 1'b0;
  assign out[97] = (in == 9'd97) ? 1'b1 : 1'b0;
  assign out[98] = (in == 9'd98) ? 1'b1 : 1'b0;
  assign out[99] = (in == 9'd99) ? 1'b1 : 1'b0;
  assign out[100] = (in == 9'd100) ? 1'b1 : 1'b0;
  assign out[101] = (in == 9'd101) ? 1'b1 : 1'b0;
  assign out[102] = (in == 9'd102) ? 1'b1 : 1'b0;
  assign out[103] = (in == 9'd103) ? 1'b1 : 1'b0;
  assign out[104] = (in == 9'd104) ? 1'b1 : 1'b0;
  assign out[105] = (in == 9'd105) ? 1'b1 : 1'b0;
  assign out[106] = (in == 9'd106) ? 1'b1 : 1'b0;
  assign out[107] = (in == 9'd107) ? 1'b1 : 1'b0;
  assign out[108] = (in == 9'd108) ? 1'b1 : 1'b0;
  assign out[109] = (in == 9'd109) ? 1'b1 : 1'b0;
  assign out[110] = (in == 9'd110) ? 1'b1 : 1'b0;
  assign out[111] = (in == 9'd111) ? 1'b1 : 1'b0;
  assign out[112] = (in == 9'd112) ? 1'b1 : 1'b0;
  assign out[113] = (in == 9'd113) ? 1'b1 : 1'b0;
  assign out[114] = (in == 9'd114) ? 1'b1 : 1'b0;
  assign out[115] = (in == 9'd115) ? 1'b1 : 1'b0;
  assign out[116] = (in == 9'd116) ? 1'b1 : 1'b0;
  assign out[117] = (in == 9'd117) ? 1'b1 : 1'b0;
  assign out[118] = (in == 9'd118) ? 1'b1 : 1'b0;
  assign out[119] = (in == 9'd119) ? 1'b1 : 1'b0;
  assign out[120] = (in == 9'd120) ? 1'b1 : 1'b0;
  assign out[121] = (in == 9'd121) ? 1'b1 : 1'b0;
  assign out[122] = (in == 9'd122) ? 1'b1 : 1'b0;
  assign out[123] = (in == 9'd123) ? 1'b1 : 1'b0;
  assign out[124] = (in == 9'd124) ? 1'b1 : 1'b0;
  assign out[125] = (in == 9'd125) ? 1'b1 : 1'b0;
  assign out[126] = (in == 9'd126) ? 1'b1 : 1'b0;
  assign out[127] = (in == 9'd127) ? 1'b1 : 1'b0;
  assign out[128] = (in == 9'd128) ? 1'b1 : 1'b0;
  assign out[129] = (in == 9'd129) ? 1'b1 : 1'b0;
  assign out[130] = (in == 9'd130) ? 1'b1 : 1'b0;
  assign out[131] = (in == 9'd131) ? 1'b1 : 1'b0;
  assign out[132] = (in == 9'd132) ? 1'b1 : 1'b0;
  assign out[133] = (in == 9'd133) ? 1'b1 : 1'b0;
  assign out[134] = (in == 9'd134) ? 1'b1 : 1'b0;
  assign out[135] = (in == 9'd135) ? 1'b1 : 1'b0;
  assign out[136] = (in == 9'd136) ? 1'b1 : 1'b0;
  assign out[137] = (in == 9'd137) ? 1'b1 : 1'b0;
  assign out[138] = (in == 9'd138) ? 1'b1 : 1'b0;
  assign out[139] = (in == 9'd139) ? 1'b1 : 1'b0;
  assign out[140] = (in == 9'd140) ? 1'b1 : 1'b0;
  assign out[141] = (in == 9'd141) ? 1'b1 : 1'b0;
  assign out[142] = (in == 9'd142) ? 1'b1 : 1'b0;
  assign out[143] = (in == 9'd143) ? 1'b1 : 1'b0;
  assign out[144] = (in == 9'd144) ? 1'b1 : 1'b0;
  assign out[145] = (in == 9'd145) ? 1'b1 : 1'b0;
  assign out[146] = (in == 9'd146) ? 1'b1 : 1'b0;
  assign out[147] = (in == 9'd147) ? 1'b1 : 1'b0;
  assign out[148] = (in == 9'd148) ? 1'b1 : 1'b0;
  assign out[149] = (in == 9'd149) ? 1'b1 : 1'b0;
  assign out[150] = (in == 9'd150) ? 1'b1 : 1'b0;
  assign out[151] = (in == 9'd151) ? 1'b1 : 1'b0;
  assign out[152] = (in == 9'd152) ? 1'b1 : 1'b0;
  assign out[153] = (in == 9'd153) ? 1'b1 : 1'b0;
  assign out[154] = (in == 9'd154) ? 1'b1 : 1'b0;
  assign out[155] = (in == 9'd155) ? 1'b1 : 1'b0;
  assign out[156] = (in == 9'd156) ? 1'b1 : 1'b0;
  assign out[157] = (in == 9'd157) ? 1'b1 : 1'b0;
  assign out[158] = (in == 9'd158) ? 1'b1 : 1'b0;
  assign out[159] = (in == 9'd159) ? 1'b1 : 1'b0;
  assign out[160] = (in == 9'd160) ? 1'b1 : 1'b0;
  assign out[161] = (in == 9'd161) ? 1'b1 : 1'b0;
  assign out[162] = (in == 9'd162) ? 1'b1 : 1'b0;
  assign out[163] = (in == 9'd163) ? 1'b1 : 1'b0;
  assign out[164] = (in == 9'd164) ? 1'b1 : 1'b0;
  assign out[165] = (in == 9'd165) ? 1'b1 : 1'b0;
  assign out[166] = (in == 9'd166) ? 1'b1 : 1'b0;
  assign out[167] = (in == 9'd167) ? 1'b1 : 1'b0;
  assign out[168] = (in == 9'd168) ? 1'b1 : 1'b0;
  assign out[169] = (in == 9'd169) ? 1'b1 : 1'b0;
  assign out[170] = (in == 9'd170) ? 1'b1 : 1'b0;
  assign out[171] = (in == 9'd171) ? 1'b1 : 1'b0;
  assign out[172] = (in == 9'd172) ? 1'b1 : 1'b0;
  assign out[173] = (in == 9'd173) ? 1'b1 : 1'b0;
  assign out[174] = (in == 9'd174) ? 1'b1 : 1'b0;
  assign out[175] = (in == 9'd175) ? 1'b1 : 1'b0;
  assign out[176] = (in == 9'd176) ? 1'b1 : 1'b0;
  assign out[177] = (in == 9'd177) ? 1'b1 : 1'b0;
  assign out[178] = (in == 9'd178) ? 1'b1 : 1'b0;
  assign out[179] = (in == 9'd179) ? 1'b1 : 1'b0;
  assign out[180] = (in == 9'd180) ? 1'b1 : 1'b0;
  assign out[181] = (in == 9'd181) ? 1'b1 : 1'b0;
  assign out[182] = (in == 9'd182) ? 1'b1 : 1'b0;
  assign out[183] = (in == 9'd183) ? 1'b1 : 1'b0;
  assign out[184] = (in == 9'd184) ? 1'b1 : 1'b0;
  assign out[185] = (in == 9'd185) ? 1'b1 : 1'b0;
  assign out[186] = (in == 9'd186) ? 1'b1 : 1'b0;
  assign out[187] = (in == 9'd187) ? 1'b1 : 1'b0;
  assign out[188] = (in == 9'd188) ? 1'b1 : 1'b0;
  assign out[189] = (in == 9'd189) ? 1'b1 : 1'b0;
  assign out[190] = (in == 9'd190) ? 1'b1 : 1'b0;
  assign out[191] = (in == 9'd191) ? 1'b1 : 1'b0;
  assign out[192] = (in == 9'd192) ? 1'b1 : 1'b0;
  assign out[193] = (in == 9'd193) ? 1'b1 : 1'b0;
  assign out[194] = (in == 9'd194) ? 1'b1 : 1'b0;
  assign out[195] = (in == 9'd195) ? 1'b1 : 1'b0;
  assign out[196] = (in == 9'd196) ? 1'b1 : 1'b0;
  assign out[197] = (in == 9'd197) ? 1'b1 : 1'b0;
  assign out[198] = (in == 9'd198) ? 1'b1 : 1'b0;
  assign out[199] = (in == 9'd199) ? 1'b1 : 1'b0;
  assign out[200] = (in == 9'd200) ? 1'b1 : 1'b0;
  assign out[201] = (in == 9'd201) ? 1'b1 : 1'b0;
  assign out[202] = (in == 9'd202) ? 1'b1 : 1'b0;
  assign out[203] = (in == 9'd203) ? 1'b1 : 1'b0;
  assign out[204] = (in == 9'd204) ? 1'b1 : 1'b0;
  assign out[205] = (in == 9'd205) ? 1'b1 : 1'b0;
  assign out[206] = (in == 9'd206) ? 1'b1 : 1'b0;
  assign out[207] = (in == 9'd207) ? 1'b1 : 1'b0;
  assign out[208] = (in == 9'd208) ? 1'b1 : 1'b0;
  assign out[209] = (in == 9'd209) ? 1'b1 : 1'b0;
  assign out[210] = (in == 9'd210) ? 1'b1 : 1'b0;
  assign out[211] = (in == 9'd211) ? 1'b1 : 1'b0;
  assign out[212] = (in == 9'd212) ? 1'b1 : 1'b0;
  assign out[213] = (in == 9'd213) ? 1'b1 : 1'b0;
  assign out[214] = (in == 9'd214) ? 1'b1 : 1'b0;
  assign out[215] = (in == 9'd215) ? 1'b1 : 1'b0;
  assign out[216] = (in == 9'd216) ? 1'b1 : 1'b0;
  assign out[217] = (in == 9'd217) ? 1'b1 : 1'b0;
  assign out[218] = (in == 9'd218) ? 1'b1 : 1'b0;
  assign out[219] = (in == 9'd219) ? 1'b1 : 1'b0;
  assign out[220] = (in == 9'd220) ? 1'b1 : 1'b0;
  assign out[221] = (in == 9'd221) ? 1'b1 : 1'b0;
  assign out[222] = (in == 9'd222) ? 1'b1 : 1'b0;
  assign out[223] = (in == 9'd223) ? 1'b1 : 1'b0;
  assign out[224] = (in == 9'd224) ? 1'b1 : 1'b0;
  assign out[225] = (in == 9'd225) ? 1'b1 : 1'b0;
  assign out[226] = (in == 9'd226) ? 1'b1 : 1'b0;
  assign out[227] = (in == 9'd227) ? 1'b1 : 1'b0;
  assign out[228] = (in == 9'd228) ? 1'b1 : 1'b0;
  assign out[229] = (in == 9'd229) ? 1'b1 : 1'b0;
  assign out[230] = (in == 9'd230) ? 1'b1 : 1'b0;
  assign out[231] = (in == 9'd231) ? 1'b1 : 1'b0;
  assign out[232] = (in == 9'd232) ? 1'b1 : 1'b0;
  assign out[233] = (in == 9'd233) ? 1'b1 : 1'b0;
  assign out[234] = (in == 9'd234) ? 1'b1 : 1'b0;
  assign out[235] = (in == 9'd235) ? 1'b1 : 1'b0;
  assign out[236] = (in == 9'd236) ? 1'b1 : 1'b0;
  assign out[237] = (in == 9'd237) ? 1'b1 : 1'b0;
  assign out[238] = (in == 9'd238) ? 1'b1 : 1'b0;
  assign out[239] = (in == 9'd239) ? 1'b1 : 1'b0;
  assign out[240] = (in == 9'd240) ? 1'b1 : 1'b0;
  assign out[241] = (in == 9'd241) ? 1'b1 : 1'b0;
  assign out[242] = (in == 9'd242) ? 1'b1 : 1'b0;
  assign out[243] = (in == 9'd243) ? 1'b1 : 1'b0;
  assign out[244] = (in == 9'd244) ? 1'b1 : 1'b0;
  assign out[245] = (in == 9'd245) ? 1'b1 : 1'b0;
  assign out[246] = (in == 9'd246) ? 1'b1 : 1'b0;
  assign out[247] = (in == 9'd247) ? 1'b1 : 1'b0;
  assign out[248] = (in == 9'd248) ? 1'b1 : 1'b0;
  assign out[249] = (in == 9'd249) ? 1'b1 : 1'b0;
  assign out[250] = (in == 9'd250) ? 1'b1 : 1'b0;
  assign out[251] = (in == 9'd251) ? 1'b1 : 1'b0;
  assign out[252] = (in == 9'd252) ? 1'b1 : 1'b0;
  assign out[253] = (in == 9'd253) ? 1'b1 : 1'b0;
  assign out[254] = (in == 9'd254) ? 1'b1 : 1'b0;
  assign out[255] = (in == 9'd255) ? 1'b1 : 1'b0;
  assign out[256] = (in == 9'd256) ? 1'b1 : 1'b0;
  assign out[257] = (in == 9'd257) ? 1'b1 : 1'b0;
  assign out[258] = (in == 9'd258) ? 1'b1 : 1'b0;
  assign out[259] = (in == 9'd259) ? 1'b1 : 1'b0;
  assign out[260] = (in == 9'd260) ? 1'b1 : 1'b0;
  assign out[261] = (in == 9'd261) ? 1'b1 : 1'b0;
  assign out[262] = (in == 9'd262) ? 1'b1 : 1'b0;
  assign out[263] = (in == 9'd263) ? 1'b1 : 1'b0;
  assign out[264] = (in == 9'd264) ? 1'b1 : 1'b0;
  assign out[265] = (in == 9'd265) ? 1'b1 : 1'b0;
  assign out[266] = (in == 9'd266) ? 1'b1 : 1'b0;
  assign out[267] = (in == 9'd267) ? 1'b1 : 1'b0;
  assign out[268] = (in == 9'd268) ? 1'b1 : 1'b0;
  assign out[269] = (in == 9'd269) ? 1'b1 : 1'b0;
  assign out[270] = (in == 9'd270) ? 1'b1 : 1'b0;
  assign out[271] = (in == 9'd271) ? 1'b1 : 1'b0;
  assign out[272] = (in == 9'd272) ? 1'b1 : 1'b0;
  assign out[273] = (in == 9'd273) ? 1'b1 : 1'b0;
  assign out[274] = (in == 9'd274) ? 1'b1 : 1'b0;
  assign out[275] = (in == 9'd275) ? 1'b1 : 1'b0;
  assign out[276] = (in == 9'd276) ? 1'b1 : 1'b0;
  assign out[277] = (in == 9'd277) ? 1'b1 : 1'b0;
  assign out[278] = (in == 9'd278) ? 1'b1 : 1'b0;
  assign out[279] = (in == 9'd279) ? 1'b1 : 1'b0;
  assign out[280] = (in == 9'd280) ? 1'b1 : 1'b0;
  assign out[281] = (in == 9'd281) ? 1'b1 : 1'b0;
  assign out[282] = (in == 9'd282) ? 1'b1 : 1'b0;
  assign out[283] = (in == 9'd283) ? 1'b1 : 1'b0;
  assign out[284] = (in == 9'd284) ? 1'b1 : 1'b0;
  assign out[285] = (in == 9'd285) ? 1'b1 : 1'b0;
  assign out[286] = (in == 9'd286) ? 1'b1 : 1'b0;
  assign out[287] = (in == 9'd287) ? 1'b1 : 1'b0;
  assign out[288] = (in == 9'd288) ? 1'b1 : 1'b0;
  assign out[289] = (in == 9'd289) ? 1'b1 : 1'b0;
  assign out[290] = (in == 9'd290) ? 1'b1 : 1'b0;
  assign out[291] = (in == 9'd291) ? 1'b1 : 1'b0;
  assign out[292] = (in == 9'd292) ? 1'b1 : 1'b0;
  assign out[293] = (in == 9'd293) ? 1'b1 : 1'b0;
  assign out[294] = (in == 9'd294) ? 1'b1 : 1'b0;
  assign out[295] = (in == 9'd295) ? 1'b1 : 1'b0;
  assign out[296] = (in == 9'd296) ? 1'b1 : 1'b0;
  assign out[297] = (in == 9'd297) ? 1'b1 : 1'b0;
  assign out[298] = (in == 9'd298) ? 1'b1 : 1'b0;
  assign out[299] = (in == 9'd299) ? 1'b1 : 1'b0;
  assign out[300] = (in == 9'd300) ? 1'b1 : 1'b0;
  assign out[301] = (in == 9'd301) ? 1'b1 : 1'b0;
  assign out[302] = (in == 9'd302) ? 1'b1 : 1'b0;
  assign out[303] = (in == 9'd303) ? 1'b1 : 1'b0;
  assign out[304] = (in == 9'd304) ? 1'b1 : 1'b0;
  assign out[305] = (in == 9'd305) ? 1'b1 : 1'b0;
  assign out[306] = (in == 9'd306) ? 1'b1 : 1'b0;
  assign out[307] = (in == 9'd307) ? 1'b1 : 1'b0;
  assign out[308] = (in == 9'd308) ? 1'b1 : 1'b0;
  assign out[309] = (in == 9'd309) ? 1'b1 : 1'b0;
  assign out[310] = (in == 9'd310) ? 1'b1 : 1'b0;
  assign out[311] = (in == 9'd311) ? 1'b1 : 1'b0;
  assign out[312] = (in == 9'd312) ? 1'b1 : 1'b0;
  assign out[313] = (in == 9'd313) ? 1'b1 : 1'b0;
  assign out[314] = (in == 9'd314) ? 1'b1 : 1'b0;
  assign out[315] = (in == 9'd315) ? 1'b1 : 1'b0;
  assign out[316] = (in == 9'd316) ? 1'b1 : 1'b0;
  assign out[317] = (in == 9'd317) ? 1'b1 : 1'b0;
  assign out[318] = (in == 9'd318) ? 1'b1 : 1'b0;
  assign out[319] = (in == 9'd319) ? 1'b1 : 1'b0;
  assign out[320] = (in == 9'd320) ? 1'b1 : 1'b0;
  assign out[321] = (in == 9'd321) ? 1'b1 : 1'b0;
  assign out[322] = (in == 9'd322) ? 1'b1 : 1'b0;
  assign out[323] = (in == 9'd323) ? 1'b1 : 1'b0;
  assign out[324] = (in == 9'd324) ? 1'b1 : 1'b0;
  assign out[325] = (in == 9'd325) ? 1'b1 : 1'b0;
  assign out[326] = (in == 9'd326) ? 1'b1 : 1'b0;
  assign out[327] = (in == 9'd327) ? 1'b1 : 1'b0;
  assign out[328] = (in == 9'd328) ? 1'b1 : 1'b0;
  assign out[329] = (in == 9'd329) ? 1'b1 : 1'b0;
  assign out[330] = (in == 9'd330) ? 1'b1 : 1'b0;
  assign out[331] = (in == 9'd331) ? 1'b1 : 1'b0;
  assign out[332] = (in == 9'd332) ? 1'b1 : 1'b0;
  assign out[333] = (in == 9'd333) ? 1'b1 : 1'b0;
  assign out[334] = (in == 9'd334) ? 1'b1 : 1'b0;
  assign out[335] = (in == 9'd335) ? 1'b1 : 1'b0;
  assign out[336] = (in == 9'd336) ? 1'b1 : 1'b0;
  assign out[337] = (in == 9'd337) ? 1'b1 : 1'b0;
  assign out[338] = (in == 9'd338) ? 1'b1 : 1'b0;
  assign out[339] = (in == 9'd339) ? 1'b1 : 1'b0;
  assign out[340] = (in == 9'd340) ? 1'b1 : 1'b0;
  assign out[341] = (in == 9'd341) ? 1'b1 : 1'b0;
  assign out[342] = (in == 9'd342) ? 1'b1 : 1'b0;
  assign out[343] = (in == 9'd343) ? 1'b1 : 1'b0;
  assign out[344] = (in == 9'd344) ? 1'b1 : 1'b0;
  assign out[345] = (in == 9'd345) ? 1'b1 : 1'b0;
  assign out[346] = (in == 9'd346) ? 1'b1 : 1'b0;
  assign out[347] = (in == 9'd347) ? 1'b1 : 1'b0;
  assign out[348] = (in == 9'd348) ? 1'b1 : 1'b0;
  assign out[349] = (in == 9'd349) ? 1'b1 : 1'b0;
  assign out[350] = (in == 9'd350) ? 1'b1 : 1'b0;
  assign out[351] = (in == 9'd351) ? 1'b1 : 1'b0;
  assign out[352] = (in == 9'd352) ? 1'b1 : 1'b0;
  assign out[353] = (in == 9'd353) ? 1'b1 : 1'b0;
  assign out[354] = (in == 9'd354) ? 1'b1 : 1'b0;
  assign out[355] = (in == 9'd355) ? 1'b1 : 1'b0;
  assign out[356] = (in == 9'd356) ? 1'b1 : 1'b0;
  assign out[357] = (in == 9'd357) ? 1'b1 : 1'b0;
  assign out[358] = (in == 9'd358) ? 1'b1 : 1'b0;
  assign out[359] = (in == 9'd359) ? 1'b1 : 1'b0;
  assign out[360] = (in == 9'd360) ? 1'b1 : 1'b0;
  assign out[361] = (in == 9'd361) ? 1'b1 : 1'b0;
  assign out[362] = (in == 9'd362) ? 1'b1 : 1'b0;
  assign out[363] = (in == 9'd363) ? 1'b1 : 1'b0;
  assign out[364] = (in == 9'd364) ? 1'b1 : 1'b0;
  assign out[365] = (in == 9'd365) ? 1'b1 : 1'b0;
  assign out[366] = (in == 9'd366) ? 1'b1 : 1'b0;
  assign out[367] = (in == 9'd367) ? 1'b1 : 1'b0;
  assign out[368] = (in == 9'd368) ? 1'b1 : 1'b0;
  assign out[369] = (in == 9'd369) ? 1'b1 : 1'b0;
  assign out[370] = (in == 9'd370) ? 1'b1 : 1'b0;
  assign out[371] = (in == 9'd371) ? 1'b1 : 1'b0;
  assign out[372] = (in == 9'd372) ? 1'b1 : 1'b0;
  assign out[373] = (in == 9'd373) ? 1'b1 : 1'b0;
  assign out[374] = (in == 9'd374) ? 1'b1 : 1'b0;
  assign out[375] = (in == 9'd375) ? 1'b1 : 1'b0;
  assign out[376] = (in == 9'd376) ? 1'b1 : 1'b0;
  assign out[377] = (in == 9'd377) ? 1'b1 : 1'b0;
  assign out[378] = (in == 9'd378) ? 1'b1 : 1'b0;
  assign out[379] = (in == 9'd379) ? 1'b1 : 1'b0;
  assign out[380] = (in == 9'd380) ? 1'b1 : 1'b0;
  assign out[381] = (in == 9'd381) ? 1'b1 : 1'b0;
  assign out[382] = (in == 9'd382) ? 1'b1 : 1'b0;
  assign out[383] = (in == 9'd383) ? 1'b1 : 1'b0;
  assign out[384] = (in == 9'd384) ? 1'b1 : 1'b0;
  assign out[385] = (in == 9'd385) ? 1'b1 : 1'b0;
  assign out[386] = (in == 9'd386) ? 1'b1 : 1'b0;
  assign out[387] = (in == 9'd387) ? 1'b1 : 1'b0;
  assign out[388] = (in == 9'd388) ? 1'b1 : 1'b0;
  assign out[389] = (in == 9'd389) ? 1'b1 : 1'b0;
  assign out[390] = (in == 9'd390) ? 1'b1 : 1'b0;
  assign out[391] = (in == 9'd391) ? 1'b1 : 1'b0;
  assign out[392] = (in == 9'd392) ? 1'b1 : 1'b0;
  assign out[393] = (in == 9'd393) ? 1'b1 : 1'b0;
  assign out[394] = (in == 9'd394) ? 1'b1 : 1'b0;
  assign out[395] = (in == 9'd395) ? 1'b1 : 1'b0;
  assign out[396] = (in == 9'd396) ? 1'b1 : 1'b0;
  assign out[397] = (in == 9'd397) ? 1'b1 : 1'b0;
  assign out[398] = (in == 9'd398) ? 1'b1 : 1'b0;
  assign out[399] = (in == 9'd399) ? 1'b1 : 1'b0;
  assign out[400] = (in == 9'd400) ? 1'b1 : 1'b0;
  assign out[401] = (in == 9'd401) ? 1'b1 : 1'b0;
  assign out[402] = (in == 9'd402) ? 1'b1 : 1'b0;
  assign out[403] = (in == 9'd403) ? 1'b1 : 1'b0;
  assign out[404] = (in == 9'd404) ? 1'b1 : 1'b0;
  assign out[405] = (in == 9'd405) ? 1'b1 : 1'b0;
  assign out[406] = (in == 9'd406) ? 1'b1 : 1'b0;
  assign out[407] = (in == 9'd407) ? 1'b1 : 1'b0;
  assign out[408] = (in == 9'd408) ? 1'b1 : 1'b0;
  assign out[409] = (in == 9'd409) ? 1'b1 : 1'b0;
  assign out[410] = (in == 9'd410) ? 1'b1 : 1'b0;
  assign out[411] = (in == 9'd411) ? 1'b1 : 1'b0;
  assign out[412] = (in == 9'd412) ? 1'b1 : 1'b0;
  assign out[413] = (in == 9'd413) ? 1'b1 : 1'b0;
  assign out[414] = (in == 9'd414) ? 1'b1 : 1'b0;
  assign out[415] = (in == 9'd415) ? 1'b1 : 1'b0;
  assign out[416] = (in == 9'd416) ? 1'b1 : 1'b0;
  assign out[417] = (in == 9'd417) ? 1'b1 : 1'b0;
  assign out[418] = (in == 9'd418) ? 1'b1 : 1'b0;
  assign out[419] = (in == 9'd419) ? 1'b1 : 1'b0;
  assign out[420] = (in == 9'd420) ? 1'b1 : 1'b0;
  assign out[421] = (in == 9'd421) ? 1'b1 : 1'b0;
  assign out[422] = (in == 9'd422) ? 1'b1 : 1'b0;
  assign out[423] = (in == 9'd423) ? 1'b1 : 1'b0;
  assign out[424] = (in == 9'd424) ? 1'b1 : 1'b0;
  assign out[425] = (in == 9'd425) ? 1'b1 : 1'b0;
  assign out[426] = (in == 9'd426) ? 1'b1 : 1'b0;
  assign out[427] = (in == 9'd427) ? 1'b1 : 1'b0;
  assign out[428] = (in == 9'd428) ? 1'b1 : 1'b0;
  assign out[429] = (in == 9'd429) ? 1'b1 : 1'b0;
  assign out[430] = (in == 9'd430) ? 1'b1 : 1'b0;
  assign out[431] = (in == 9'd431) ? 1'b1 : 1'b0;
  assign out[432] = (in == 9'd432) ? 1'b1 : 1'b0;
  assign out[433] = (in == 9'd433) ? 1'b1 : 1'b0;
  assign out[434] = (in == 9'd434) ? 1'b1 : 1'b0;
  assign out[435] = (in == 9'd435) ? 1'b1 : 1'b0;
  assign out[436] = (in == 9'd436) ? 1'b1 : 1'b0;
  assign out[437] = (in == 9'd437) ? 1'b1 : 1'b0;
  assign out[438] = (in == 9'd438) ? 1'b1 : 1'b0;
  assign out[439] = (in == 9'd439) ? 1'b1 : 1'b0;
  assign out[440] = (in == 9'd440) ? 1'b1 : 1'b0;
  assign out[441] = (in == 9'd441) ? 1'b1 : 1'b0;
  assign out[442] = (in == 9'd442) ? 1'b1 : 1'b0;
  assign out[443] = (in == 9'd443) ? 1'b1 : 1'b0;
  assign out[444] = (in == 9'd444) ? 1'b1 : 1'b0;
  assign out[445] = (in == 9'd445) ? 1'b1 : 1'b0;
  assign out[446] = (in == 9'd446) ? 1'b1 : 1'b0;
  assign out[447] = (in == 9'd447) ? 1'b1 : 1'b0;
  assign out[448] = (in == 9'd448) ? 1'b1 : 1'b0;
  assign out[449] = (in == 9'd449) ? 1'b1 : 1'b0;
  assign out[450] = (in == 9'd450) ? 1'b1 : 1'b0;
  assign out[451] = (in == 9'd451) ? 1'b1 : 1'b0;
  assign out[452] = (in == 9'd452) ? 1'b1 : 1'b0;
  assign out[453] = (in == 9'd453) ? 1'b1 : 1'b0;
  assign out[454] = (in == 9'd454) ? 1'b1 : 1'b0;
  assign out[455] = (in == 9'd455) ? 1'b1 : 1'b0;
  assign out[456] = (in == 9'd456) ? 1'b1 : 1'b0;
  assign out[457] = (in == 9'd457) ? 1'b1 : 1'b0;
  assign out[458] = (in == 9'd458) ? 1'b1 : 1'b0;
  assign out[459] = (in == 9'd459) ? 1'b1 : 1'b0;
  assign out[460] = (in == 9'd460) ? 1'b1 : 1'b0;
  assign out[461] = (in == 9'd461) ? 1'b1 : 1'b0;
  assign out[462] = (in == 9'd462) ? 1'b1 : 1'b0;
  assign out[463] = (in == 9'd463) ? 1'b1 : 1'b0;
  assign out[464] = (in == 9'd464) ? 1'b1 : 1'b0;
  assign out[465] = (in == 9'd465) ? 1'b1 : 1'b0;
  assign out[466] = (in == 9'd466) ? 1'b1 : 1'b0;
  assign out[467] = (in == 9'd467) ? 1'b1 : 1'b0;
  assign out[468] = (in == 9'd468) ? 1'b1 : 1'b0;
  assign out[469] = (in == 9'd469) ? 1'b1 : 1'b0;
  assign out[470] = (in == 9'd470) ? 1'b1 : 1'b0;
  assign out[471] = (in == 9'd471) ? 1'b1 : 1'b0;
  assign out[472] = (in == 9'd472) ? 1'b1 : 1'b0;
  assign out[473] = (in == 9'd473) ? 1'b1 : 1'b0;
  assign out[474] = (in == 9'd474) ? 1'b1 : 1'b0;
  assign out[475] = (in == 9'd475) ? 1'b1 : 1'b0;
  assign out[476] = (in == 9'd476) ? 1'b1 : 1'b0;
  assign out[477] = (in == 9'd477) ? 1'b1 : 1'b0;
  assign out[478] = (in == 9'd478) ? 1'b1 : 1'b0;
  assign out[479] = (in == 9'd479) ? 1'b1 : 1'b0;
  assign out[480] = (in == 9'd480) ? 1'b1 : 1'b0;
  assign out[481] = (in == 9'd481) ? 1'b1 : 1'b0;
  assign out[482] = (in == 9'd482) ? 1'b1 : 1'b0;
  assign out[483] = (in == 9'd483) ? 1'b1 : 1'b0;
  assign out[484] = (in == 9'd484) ? 1'b1 : 1'b0;
  assign out[485] = (in == 9'd485) ? 1'b1 : 1'b0;
  assign out[486] = (in == 9'd486) ? 1'b1 : 1'b0;
  assign out[487] = (in == 9'd487) ? 1'b1 : 1'b0;
  assign out[488] = (in == 9'd488) ? 1'b1 : 1'b0;
  assign out[489] = (in == 9'd489) ? 1'b1 : 1'b0;
  assign out[490] = (in == 9'd490) ? 1'b1 : 1'b0;
  assign out[491] = (in == 9'd491) ? 1'b1 : 1'b0;
  assign out[492] = (in == 9'd492) ? 1'b1 : 1'b0;
  assign out[493] = (in == 9'd493) ? 1'b1 : 1'b0;
  assign out[494] = (in == 9'd494) ? 1'b1 : 1'b0;
  assign out[495] = (in == 9'd495) ? 1'b1 : 1'b0;
  assign out[496] = (in == 9'd496) ? 1'b1 : 1'b0;
  assign out[497] = (in == 9'd497) ? 1'b1 : 1'b0;
  assign out[498] = (in == 9'd498) ? 1'b1 : 1'b0;
  assign out[499] = (in == 9'd499) ? 1'b1 : 1'b0;
  assign out[500] = (in == 9'd500) ? 1'b1 : 1'b0;
  assign out[501] = (in == 9'd501) ? 1'b1 : 1'b0;
  assign out[502] = (in == 9'd502) ? 1'b1 : 1'b0;
  assign out[503] = (in == 9'd503) ? 1'b1 : 1'b0;
  assign out[504] = (in == 9'd504) ? 1'b1 : 1'b0;
  assign out[505] = (in == 9'd505) ? 1'b1 : 1'b0;
  assign out[506] = (in == 9'd506) ? 1'b1 : 1'b0;
  assign out[507] = (in == 9'd507) ? 1'b1 : 1'b0;
  assign out[508] = (in == 9'd508) ? 1'b1 : 1'b0;
  assign out[509] = (in == 9'd509) ? 1'b1 : 1'b0;
  assign out[510] = (in == 9'd510) ? 1'b1 : 1'b0;
  assign out[511] = (in == 9'd511) ? 1'b1 : 1'b0;
endmodule
module decoder_param (out, in);

   parameter BITS = 2;
   parameter SIZE = 4;

   output [SIZE - 1:0] out;
   input [BITS - 1:0] in;

   reg [SIZE -1: 0] out;
   integer i;

   always @ (in)
      begin
         for(i = 0; i < SIZE; i = i + 1)
         begin
            out[i] = (in == i) ? 1'b1 : 1'b0;
         end
      end

endmodule
module decoder_param_en (out, in, en);

   parameter BITS = 2;
   parameter SIZE = 4;

   output [SIZE - 1:0] out;
   input [BITS - 1:0] in;
   input en;

   reg [SIZE -1: 0] out;
   integer i;

   always @ (in or en)
      begin
         for(i = 0; i < SIZE; i = i + 1)
         begin
            out[i] = en ? ((in == i) ? 1'b1 : 1'b0) : 1'b0;
         end
      end

endmodule
module dff (q, d, clk, rst);

   output         q;
   input          d;
   input          clk;
   input          rst;

   reg            state;

   assign q = state;

   always @(posedge clk)
   begin
      if (rst)
         state <= 1'b0;
      else
         state <= d;
   end










endmodule
module dff_en (q, d, en, clk, rst);

  output q;
  input d;
  input en;
  input clk;
  input rst;

  wire d_int, q1;

  assign d_int = en ? d : q1;
  assign q = q1;

  dff dff_0(.q(q1), .d(d_int), .clk(clk), .rst(rst));
  
endmodule
// D-flipflop
// Copied from http://pages.cs.wisc.edu/~karu/courses/cs552/spring2009/handouts/verilog_code/dff.v
module dff_set (q, d, clk, set);

   output         q;
   input          d;
   input          clk;
   input          set;

   reg            state;

   assign q = state;

   always @(posedge clk)
   begin
      state <= set? 1 : d;
   end










endmodule
module dff_set_en (q, d, en, clk, set);

  output q;
  input d;
  input en;
  input clk;
  input set;

  wire d_int, q1;

  assign d_int = en ? d : q1;
  assign q = q1;

  dff_set dff_0(.q(q1), .d(d_int), .clk(clk), .set(set));
  
endmodule
module dff_set_en_rst(
   d,
   q,
   en,
   clk,
   set,
   rst );


   output q;
   input d;
   input en;
   input clk;
   input set;
   input rst;

   wire d_int;
   reg state;

   assign d_int = en ? d : state;

   assign q = state;

   always @(posedge clk or posedge rst)
   begin
      if(rst)
      state <= 0;
      else
      state <= set? 1 : d_int;
   end










endmodule
module encoder(in,out);
input [39:0] in;
output [5:0] out;

assign out =  (in[0]==1'b1)?6'd0:
              (in[1]==1'b1)?6'd1:
			  (in[2]==1'b1)?6'd2:
			  (in[3]==1'b1)?6'd3:
			  (in[4]==1'b1)?6'd4:
			  (in[5]==1'b1)?6'd5:
			  (in[6]==1'b1)?6'd6:
			  (in[7]==1'b1)?6'd7:
			  (in[8]==1'b1)?6'd8:
			  (in[9]==1'b1)?6'd9:
			  (in[10]==1'b1)?6'd10:
			  (in[11]==1'b1)?6'd11:
			  (in[12]==1'b1)?6'd12:
			  (in[13]==1'b1)?6'd13:
			  (in[14]==1'b1)?6'd14:
			  (in[15]==1'b1)?6'd15:
			  (in[16]==1'b1)?6'd16:
			  (in[17]==1'b1)?6'd17:
			  (in[18]==1'b1)?6'd18:
			  (in[19]==1'b1)?6'd19:
			  (in[20]==1'b1)?6'd20:
			  (in[21]==1'b1)?6'd21:
			  (in[22]==1'b1)?6'd22:
			  (in[23]==1'b1)?6'd23:
			  (in[24]==1'b1)?6'd24:
			  (in[25]==1'b1)?6'd25:
			  (in[26]==1'b1)?6'd26:
			  (in[27]==1'b1)?6'd27:
			  (in[28]==1'b1)?6'd28:
			  (in[29]==1'b1)?6'd29:
			  (in[30]==1'b1)?6'd30:
			  (in[31]==1'b1)?6'd31:
			  (in[32]==1'b1)?6'd32:
			  (in[33]==1'b1)?6'd33:
			  (in[34]==1'b1)?6'd34:
			  (in[35]==1'b1)?6'd35:
			  (in[36]==1'b1)?6'd36:
			  (in[37]==1'b1)?6'd37:
			  (in[38]==1'b1)?6'd38:
			  (in[39]==1'b1)?6'd39:
			  6'b000000;
endmodule
module encoder_5b_3b(
    in,
    out
);

input[4:0] in;
output[2:0] out;

reg[2:0] out;

always @(in) begin
    out = 3'h0;
    
    case(in)
        5'b00001: out = 3'h0;
        5'b00010: out = 3'h1;
        5'b00100: out = 3'h2;
        5'b01000: out = 3'h3;
        5'b10000: out = 3'h4;
        default: out = 3'h0;
    endcase
end
endmodule
module flop (q, d, clk);

   output         q;
   input          d;
   input          clk;
   reg            state;

   assign q = state;

   always @(posedge clk)
   begin
      state <= d;
   end










endmodule
module flop_32b (out, in, wr_en, clk);

  output [31:0] out;
  input [31:0] in;
  input wr_en;
  input clk;

  flop_en bits[31:0] (.q(out), .d(in), .en(wr_en), .clk(clk));

endmodule
module flop_en (q, d, en, clk);

  output q;
  input d;
  input en;
  input clk;

  wire d_int, q1;

  assign d_int = en ? d : q1;
  assign q = q1;

  flop flop_0(.q(q1), .d(d_int), .clk(clk));
  
endmodule
module mux2_1(InA,InB,S,out);
input InA,InB,S;
output out;
wire a1,a2,n1;

not1 n5(S,n1);
nand2 n4(InA,n1,a1);
nand2 n2(InB,S,a2);
nand2 n3(a1,a2,out);

endmodule
module mux_40x64b_to_1x64b (out, in, select);

  output [63:0] out;
  input [2559:0] in;
  input [5:0] select;

  reg [63:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<40; $i=$i+1)
// {
//   $low_index = 64*$i;
//   $high_index = 64*$i+63;
//   print "      6'd$i : out <= in [$high_index:$low_index];\n";
// }
// %%stop_veriperl
      6'd0 : out <= in [63:0];
      6'd1 : out <= in [127:64];
      6'd2 : out <= in [191:128];
      6'd3 : out <= in [255:192];
      6'd4 : out <= in [319:256];
      6'd5 : out <= in [383:320];
      6'd6 : out <= in [447:384];
      6'd7 : out <= in [511:448];
      6'd8 : out <= in [575:512];
      6'd9 : out <= in [639:576];
      6'd10 : out <= in [703:640];
      6'd11 : out <= in [767:704];
      6'd12 : out <= in [831:768];
      6'd13 : out <= in [895:832];
      6'd14 : out <= in [959:896];
      6'd15 : out <= in [1023:960];
      6'd16 : out <= in [1087:1024];
      6'd17 : out <= in [1151:1088];
      6'd18 : out <= in [1215:1152];
      6'd19 : out <= in [1279:1216];
      6'd20 : out <= in [1343:1280];
      6'd21 : out <= in [1407:1344];
      6'd22 : out <= in [1471:1408];
      6'd23 : out <= in [1535:1472];
      6'd24 : out <= in [1599:1536];
      6'd25 : out <= in [1663:1600];
      6'd26 : out <= in [1727:1664];
      6'd27 : out <= in [1791:1728];
      6'd28 : out <= in [1855:1792];
      6'd29 : out <= in [1919:1856];
      6'd30 : out <= in [1983:1920];
      6'd31 : out <= in [2047:1984];
      6'd32 : out <= in [2111:2048];
      6'd33 : out <= in [2175:2112];
      6'd34 : out <= in [2239:2176];
      6'd35 : out <= in [2303:2240];
      6'd36 : out <= in [2367:2304];
      6'd37 : out <= in [2431:2368];
      6'd38 : out <= in [2495:2432];
      6'd39 : out <= in [2559:2496];
      default: out <= {64{1'bx}};
    endcase
  end
endmodule
module mux_40xX_to_1xX (out, in, select);

  parameter WIDTH = 1;
  output [WIDTH-1:0] out;
  input [(40*WIDTH)-1:0] in;
  input [5:0] select;

  reg [WIDTH-1:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $i_plus_one;
// for($i=0; $i<40; $i=$i+1)
// {
//   $i_plus_one = $i + 1;
//   print "      6'd$i : out <= in [(WIDTH*$i_plus_one)-1:WIDTH*$i];\n";
// }
// %%stop_veriperl
      6'd0 : out <= in [(WIDTH*1)-1:WIDTH*0];
      6'd1 : out <= in [(WIDTH*2)-1:WIDTH*1];
      6'd2 : out <= in [(WIDTH*3)-1:WIDTH*2];
      6'd3 : out <= in [(WIDTH*4)-1:WIDTH*3];
      6'd4 : out <= in [(WIDTH*5)-1:WIDTH*4];
      6'd5 : out <= in [(WIDTH*6)-1:WIDTH*5];
      6'd6 : out <= in [(WIDTH*7)-1:WIDTH*6];
      6'd7 : out <= in [(WIDTH*8)-1:WIDTH*7];
      6'd8 : out <= in [(WIDTH*9)-1:WIDTH*8];
      6'd9 : out <= in [(WIDTH*10)-1:WIDTH*9];
      6'd10 : out <= in [(WIDTH*11)-1:WIDTH*10];
      6'd11 : out <= in [(WIDTH*12)-1:WIDTH*11];
      6'd12 : out <= in [(WIDTH*13)-1:WIDTH*12];
      6'd13 : out <= in [(WIDTH*14)-1:WIDTH*13];
      6'd14 : out <= in [(WIDTH*15)-1:WIDTH*14];
      6'd15 : out <= in [(WIDTH*16)-1:WIDTH*15];
      6'd16 : out <= in [(WIDTH*17)-1:WIDTH*16];
      6'd17 : out <= in [(WIDTH*18)-1:WIDTH*17];
      6'd18 : out <= in [(WIDTH*19)-1:WIDTH*18];
      6'd19 : out <= in [(WIDTH*20)-1:WIDTH*19];
      6'd20 : out <= in [(WIDTH*21)-1:WIDTH*20];
      6'd21 : out <= in [(WIDTH*22)-1:WIDTH*21];
      6'd22 : out <= in [(WIDTH*23)-1:WIDTH*22];
      6'd23 : out <= in [(WIDTH*24)-1:WIDTH*23];
      6'd24 : out <= in [(WIDTH*25)-1:WIDTH*24];
      6'd25 : out <= in [(WIDTH*26)-1:WIDTH*25];
      6'd26 : out <= in [(WIDTH*27)-1:WIDTH*26];
      6'd27 : out <= in [(WIDTH*28)-1:WIDTH*27];
      6'd28 : out <= in [(WIDTH*29)-1:WIDTH*28];
      6'd29 : out <= in [(WIDTH*30)-1:WIDTH*29];
      6'd30 : out <= in [(WIDTH*31)-1:WIDTH*30];
      6'd31 : out <= in [(WIDTH*32)-1:WIDTH*31];
      6'd32 : out <= in [(WIDTH*33)-1:WIDTH*32];
      6'd33 : out <= in [(WIDTH*34)-1:WIDTH*33];
      6'd34 : out <= in [(WIDTH*35)-1:WIDTH*34];
      6'd35 : out <= in [(WIDTH*36)-1:WIDTH*35];
      6'd36 : out <= in [(WIDTH*37)-1:WIDTH*36];
      6'd37 : out <= in [(WIDTH*38)-1:WIDTH*37];
      6'd38 : out <= in [(WIDTH*39)-1:WIDTH*38];
      6'd39 : out <= in [(WIDTH*40)-1:WIDTH*39];
      default: out <= {WIDTH{1'bx}};
    endcase
  end
endmodule
module mux_param (out, in, select);

   parameter BITS = 2;
   parameter SIZE = 4;
   parameter WIDTH = 1;

   output [WIDTH - 1:0] out;
   input [(SIZE * WIDTH) - 1:0] in;
   input [BITS - 1:0] select;

   reg [WIDTH - 1:0] out;

   integer i;

   always @ (in or select)
      begin
         out = {WIDTH{1'bx}};
         for(i = 0; i < SIZE; i = i + 1)
         begin
            if (select == i)
            begin
               out = in[(WIDTH * (i+1)) - 1-:WIDTH];
            end
         end
      end
endmodule
module nand2 (in1,in2,out);
input in1,in2;
output out;
assign out = ~(in1 & in2);
endmodule
module not1 (in1,out);
input in1;
output out;
assign out = ~in1;
endmodule
module priority_encoder_40to6 (
	binary_out,
	valid,
	encoder_in,
	enable
);

output[5:0] binary_out;
output valid;

input[39:0] encoder_in;
input enable;

assign valid = (|encoder_in) & enable;

assign binary_out = (!enable) ? 6'd0 : (
		(encoder_in[0]) ? 6'd0 : 
		(encoder_in[1]) ? 6'd1 : 
		(encoder_in[2]) ? 6'd2 : 
		(encoder_in[3]) ? 6'd3 : 
		(encoder_in[4]) ? 6'd4 : 
		(encoder_in[5]) ? 6'd5 : 
		(encoder_in[6]) ? 6'd6 : 
		(encoder_in[7]) ? 6'd7 : 
		(encoder_in[8]) ? 6'd8 : 
		(encoder_in[9]) ? 6'd9 : 
		(encoder_in[10]) ? 6'd10 : 
		(encoder_in[11]) ? 6'd11 : 
		(encoder_in[12]) ? 6'd12 : 
		(encoder_in[13]) ? 6'd13 : 
		(encoder_in[14]) ? 6'd14 : 
		(encoder_in[15]) ? 6'd15 : 
		(encoder_in[16]) ? 6'd16 : 
		(encoder_in[17]) ? 6'd17 : 
		(encoder_in[18]) ? 6'd18 : 
		(encoder_in[19]) ? 6'd19 : 
		(encoder_in[20]) ? 6'd20 : 
		(encoder_in[21]) ? 6'd21 : 
		(encoder_in[22]) ? 6'd22 : 
		(encoder_in[23]) ? 6'd23 : 
		(encoder_in[24]) ? 6'd24 : 
		(encoder_in[25]) ? 6'd25 : 
		(encoder_in[26]) ? 6'd26 : 
		(encoder_in[27]) ? 6'd27 : 
		(encoder_in[28]) ? 6'd28 : 
		(encoder_in[29]) ? 6'd29 : 
		(encoder_in[30]) ? 6'd30 : 
		(encoder_in[31]) ? 6'd31 : 
		(encoder_in[32]) ? 6'd32 : 
		(encoder_in[33]) ? 6'd33 : 
		(encoder_in[34]) ? 6'd34 : 
		(encoder_in[35]) ? 6'd35 : 
		(encoder_in[36]) ? 6'd36 : 
		(encoder_in[37]) ? 6'd37 : 
		(encoder_in[38]) ? 6'd38 : 
		(encoder_in[39]) ? 6'd39 : {6{1'bx}}); 

endmodule
module queue_param_1r_1w(
                        in_wr_en,
                        in_wr_addr,
                        in_wr_data,
                        in_rd_addr,
                        out_rd_data,
                        clk,
                        rst
                        );

   parameter BITS = 2;
   parameter SIZE = 4;
   parameter WIDTH = 32;

   input in_wr_en;
   input [BITS - 1:0] in_wr_addr;
   input [WIDTH - 1:0] in_wr_data;
   input [BITS - 1:0] in_rd_addr;

   output [WIDTH - 1:0] out_rd_data;
   input clk;
   input rst;

   wire [(SIZE * WIDTH) - 1:0] word_out;
   wire [SIZE - 1:0] wr_word_select;
   wire [SIZE - 1:0] wr_en_word;

   mux_param #(.BITS(BITS), .SIZE(SIZE), .WIDTH(WIDTH)) mux_rd_port (.out(out_rd_data), .in(word_out), .select(in_rd_addr));
   decoder_param #(.BITS(BITS), .SIZE(SIZE)) decoder_wr_port (.out(wr_word_select), .in(in_wr_addr));
   assign wr_en_word = {SIZE{in_wr_en}} & wr_word_select;

   reg_param #(.WIDTH(WIDTH)) word[SIZE - 1:0] (.out(word_out), .in(in_wr_data), .wr_en(wr_en_word), .clk(clk), .rst(rst));

endmodule
module reg_32b (out, in, wr_en, clk, rst);

  output [31:0] out;
  input [31:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[31:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module reg_40b (out, in, wr_en, clk, rst);

  output [39:0] out;
  input [39:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[39:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module reg_40b_set (out, in, wr_en, clk, set);

  output [39:0] out;
  input [39:0] in;
  input wr_en;
  input clk;
  input set;

  dff_set_en bits[39:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .set(set));

endmodule
module reg_40xX_1r_1w (
  rd_addr,
  rd_data,

  wr_en,
  wr_addr,
  wr_data,

  clk,
  rst
);

  parameter WIDTH = 1;
  output [WIDTH-1:0] rd_data;
  input [5:0] rd_addr;

  input [5:0] wr_addr;
  input wr_en;
  input [WIDTH-1:0] wr_data;

  input clk;
  input rst;

  wire [(40*WIDTH)-1:0] word_out;
  wire [39:0] wr_word_select;
  wire [39:0] wr_en_word;

  mux_40xX_to_1xX #(WIDTH) mux_rd_port (.out(rd_data), .in(word_out), .select(rd_addr));
  decoder_6_to_40 decoder_wr_port (.out(wr_word_select), .in(wr_addr));
  assign wr_en_word = {40{wr_en}} & wr_word_select;

  register #(WIDTH) word[39:0](.out(word_out), .in(wr_data), .wr_en(wr_en_word), .clk(clk), .rst(rst));

endmodule
module reg_40xX_2r_1w (
  rd0_addr,
  rd0_data,

  rd1_addr,
  rd1_data,

  wr_en,
  wr_addr,
  wr_data,

  clk,
  rst
);

  parameter WIDTH = 1;
  output [WIDTH-1:0] rd0_data;
  output [WIDTH-1:0] rd1_data;
  input [5:0] rd0_addr;
  input [5:0] rd1_addr;

  input [5:0] wr_addr;
  input wr_en;
  input [WIDTH-1:0] wr_data;

  input clk;
  input rst;

  wire [(40*WIDTH)-1:0] word_out;
  wire [39:0] wr_word_select;
  wire [39:0] wr_en_word;

  mux_40xX_to_1xX #(WIDTH) mux_rd0_port (.out(rd0_data), .in(word_out), .select(rd0_addr));
  mux_40xX_to_1xX #(WIDTH) mux_rd1_port (.out(rd1_data), .in(word_out), .select(rd1_addr));

  decoder_6_to_40 decoder_wr_port (.out(wr_word_select), .in(wr_addr));
  assign wr_en_word = {40{wr_en}} & wr_word_select;

  register #(WIDTH) word[39:0](.out(word_out), .in(wr_data), .wr_en(wr_en_word), .clk(clk), .rst(rst));

endmodule
module reg_64b (out, in, wr_en, clk, rst);

  output [63:0] out;
  input [63:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[63:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module reg_param (out, in, wr_en, clk, rst);

parameter WIDTH = 2;

  output[WIDTH-1:0] out;
  input[WIDTH-1:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[WIDTH - 1:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module regfile(
	d_in, 
	wr_en, 
	d_out, 
	clk, 
	rst
);  
  
parameter BITWIDTH = 11;

input [BITWIDTH-1:0] d_in;
input wr_en, clk, rst;

output [BITWIDTH-1:0] d_out;

wire [BITWIDTH-1:0] out;

dff d1[BITWIDTH-1:0](.q(d_out), .d(out), .clk(clk), .rst(rst));

mux2_1 m1[BITWIDTH-1:0](.InA(d_out), .InB(d_in), .out(out), .S(wr_en));
  
endmodulemodule register(out, in, wr_en, clk, rst);

  parameter WIDTH = 1;
  output [WIDTH-1:0] out;
  input [WIDTH-1:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[WIDTH-1:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module compute_unit
  (
    /*AUTOARG*/
   // Outputs
   cu2dispatch_wf_done, cu2dispatch_wf_tag_done,
   fetch2buff_rd_en, fetch2buff_addr, fetch2buff_tag,
   lsu2mem_rd_en, lsu2mem_wr_en, lsu2mem_tag_req, lsu2mem_wr_mask,
   lsu2mem_addr, lsu2mem_wr_data, lsu2mem_gm_or_lds,

  sgpr2dispatch_rd_data,
  vgpr2dispatch_rd_data,









































































   // Inputs

  dispatch2sgpr_addr, dispatch2sgpr_wr_data, dispatch2sgpr_wr_en,
  dispatch2vgpr_addr, dispatch2vgpr_wr_data, dispatch2vgpr_wr_en, dispatch2vgpr_wr_mask,
  dispatch2cu_idle,

  dispatch2cu_wf_dispatch, dispatch2cu_wf_tag_dispatch, dispatch2cu_start_pc_dispatch,
  dispatch2cu_sgpr_base_dispatch, dispatch2cu_vgpr_base_dispatch, dispatch2cu_lds_base_dispatch,
  buff2fetchwave_ack, buff2wave_instr, buff2wave_tag,
  dispatch2cu_wg_wf_count, dispatch2cu_wf_size_dispatch,
  mem2lsu_ack, mem2lsu_tag_resp, mem2lsu_rd_data,
  clk, rst
);

  input clk;
  input rst;

  input dispatch2cu_wf_dispatch, mem2lsu_ack, buff2fetchwave_ack;
  input [3:0] dispatch2cu_wg_wf_count;
  input [5:0] dispatch2cu_wf_size_dispatch;
  input [6:0] mem2lsu_tag_resp;
  input [8:0] dispatch2cu_sgpr_base_dispatch;
  input [9:0] dispatch2cu_vgpr_base_dispatch;
  input [14:0] dispatch2cu_wf_tag_dispatch;
  input [15:0] dispatch2cu_lds_base_dispatch;
  input [31:0] dispatch2cu_start_pc_dispatch, buff2wave_instr;
  input [38:0] buff2wave_tag;
  input [31:0] mem2lsu_rd_data;


  input dispatch2cu_idle;
  input [8:0] dispatch2sgpr_addr;
  input [127:0] dispatch2sgpr_wr_data;
  input dispatch2sgpr_wr_en;

  input [9:0] dispatch2vgpr_addr;
  input [2047:0] dispatch2vgpr_wr_data;
  input dispatch2vgpr_wr_en;
  input [63:0] dispatch2vgpr_wr_mask;

  output [127:0] sgpr2dispatch_rd_data;
  output [2047:0] vgpr2dispatch_rd_data;


  output 	  cu2dispatch_wf_done, fetch2buff_rd_en, lsu2mem_rd_en, lsu2mem_wr_en, lsu2mem_gm_or_lds;

  output [6:0] lsu2mem_tag_req;
  output [63:0] lsu2mem_wr_mask;
  output [31:0] lsu2mem_wr_data, lsu2mem_addr;

  output [31:0] fetch2buff_addr;
  output [38:0]  fetch2buff_tag;

  output [14:0] cu2dispatch_wf_tag_done;
































































   ///////////////////////////////
		   //Signals for submodules
   ///////////////////////////////
   wire [2047:0] lsu2tracemon_addr;
   wire [2047:0] lsu2tracemon_store_data;
   wire 	   buff2fetchwave_ack, cu2dispatch_wf_done, decode2issue_barrier,
		   decode2issue_branch, decode2issue_exec_rd, decode2issue_exec_wr, decode2issue_m0_rd,
		   decode2issue_m0_wr, decode2issue_scc_rd, decode2issue_scc_wr, decode2issue_valid,
		   decode2issue_vcc_rd, decode2issue_vcc_wr, decode2issue_waitcnt, decode2issue_wf_halt,
		   decode2tracemon_colldone, decode2wave_ins_half_rqd, dispatch2cu_wf_dispatch,
		   exec2issue_salu_wr_exec_en, exec2issue_salu_wr_m0_en, exec2issue_salu_wr_scc_en,
		   exec2issue_salu_wr_vcc_en, exec2issue_valu_wr_vcc_en, exec2salu_rd_scc_value,
		   exec2simd_rd_scc_value, exec2simf_rd_scc_value, fetch2buff_rd_en, fetch2exec_init_wf_en,
		   fetch2tracemon_dispatch, fetch2wave_basereg_wr, fetch2wave_reserve_valid,
		   issue2fetchwave_wf_done_en, issue2lsu_lsu_select, issue2salu_alu_select,
		   issue2simd0_alu_select, issue2simd1_alu_select, issue2simd2_alu_select,
		   issue2simd3_alu_select, issue2simf0_alu_select, issue2simf1_alu_select,
		   issue2simf2_alu_select, issue2simf3_alu_select, issue2tracemon_barrier_retire_en,
		   issue2tracemon_waitcnt_retire_en, lsu2issue_ready, lsu2issue_done, lsu2mem_gm_or_lds,
		   lsu2sgpr_instr_done, lsu2sgpr_source1_rd_en, lsu2sgpr_source2_rd_en,
		   lsu2tracemon_gm_or_lds, lsu2vgpr_instr_done, lsu2vgpr_source1_rd_en,
		   lsu2vgpr_source2_rd_en, lsu2rfa_dest_wr_req, mem2lsu_ack, rfa2simd0_queue_entry_serviced,
		   rfa2simd1_queue_entry_serviced, rfa2simd2_queue_entry_serviced, rfa2simd3_queue_entry_serviced,
		   rfa2simf0_queue_entry_serviced, rfa2simf1_queue_entry_serviced, rfa2simf2_queue_entry_serviced,
		   rfa2simf3_queue_entry_serviced, salu2exec_rd_en, salu2exec_wr_exec_en,
		   salu2exec_wr_m0_en, salu2exec_wr_scc_en, salu2exec_wr_scc_value, salu2exec_wr_vcc_en,
		   salu2fetchwaveissue_branch_en, salu2fetchwaveissue_branch_taken, salu2issue_alu_ready,
		   salu2sgpr_instr_done, salu2sgpr_source1_rd_en, salu2sgpr_source2_rd_en,
		   sgpr2issue_alu_wr_done, sgpr2issue_lsu_instr_done, sgpr2issue_valu_dest_reg_valid,
		   simd0_2exec_rd_en, simd0_2exec_wr_vcc_en, simd0_2issue_alu_ready, simd0_2rfa_queue_entry_valid,
		   simd0_2sgpr_rd_en, simd0_2sgpr_wr_en, simd0_2vgpr_instr_done, simd0_2vgpr_source1_rd_en,
		   simd0_2vgpr_source2_rd_en, simd0_2vgpr_source3_rd_en, simd0_2vgpr_wr_en,
		   simd1_2exec_rd_en, simd1_2exec_wr_vcc_en, simd1_2issue_alu_ready, simd1_2rfa_queue_entry_valid,
		   simd1_2sgpr_rd_en, simd1_2sgpr_wr_en, simd1_2vgpr_instr_done, simd1_2vgpr_source1_rd_en,
		   simd1_2vgpr_source2_rd_en, simd1_2vgpr_source3_rd_en, simd1_2vgpr_wr_en,
		   simd2_2exec_rd_en, simd2_2exec_wr_vcc_en, simd2_2issue_alu_ready, simd2_2rfa_queue_entry_valid,
		   simd2_2sgpr_rd_en, simd2_2sgpr_wr_en, simd2_2vgpr_instr_done, simd2_2vgpr_source1_rd_en,
		   simd2_2vgpr_source2_rd_en, simd2_2vgpr_source3_rd_en, simd2_2vgpr_wr_en,
		   simd3_2exec_rd_en, simd3_2exec_wr_vcc_en, simd3_2issue_alu_ready, simd3_2rfa_queue_entry_valid,
		   simd3_2sgpr_rd_en, simd3_2sgpr_wr_en, simd3_2vgpr_instr_done, simd3_2vgpr_source1_rd_en,
		   simd3_2vgpr_source2_rd_en, simd3_2vgpr_source3_rd_en, simd3_2vgpr_wr_en,
		   simf0_2exec_rd_en, simf0_2exec_wr_vcc_en, simf0_2issue_alu_ready, simf0_2rfa_queue_entry_valid,
		   simf0_2sgpr_rd_en, simf0_2sgpr_wr_en, simf0_2vgpr_instr_done, simf0_2vgpr_source1_rd_en,
		   simf0_2vgpr_source2_rd_en, simf0_2vgpr_source3_rd_en, simf0_2vgpr_wr_en,
		   simf1_2exec_rd_en, simf1_2exec_wr_vcc_en, simf1_2issue_alu_ready, simf1_2rfa_queue_entry_valid,
		   simf1_2sgpr_rd_en, simf1_2sgpr_wr_en, simf1_2vgpr_instr_done, simf1_2vgpr_source1_rd_en,
		   simf1_2vgpr_source2_rd_en, simf1_2vgpr_source3_rd_en, simf1_2vgpr_wr_en,
		   simf2_2exec_rd_en, simf2_2exec_wr_vcc_en, simf2_2issue_alu_ready, simf2_2rfa_queue_entry_valid,
		   simf2_2sgpr_rd_en, simf2_2sgpr_wr_en, simf2_2vgpr_instr_done, simf2_2vgpr_source1_rd_en,
		   simf2_2vgpr_source2_rd_en, simf2_2vgpr_source3_rd_en, simf2_2vgpr_wr_en,
		   simf3_2exec_rd_en, simf3_2exec_wr_vcc_en, simf3_2issue_alu_ready, simf3_2rfa_queue_entry_valid,
		   simf3_2sgpr_rd_en, simf3_2sgpr_wr_en, simf3_2vgpr_instr_done, simf3_2vgpr_source1_rd_en,
		   simf3_2vgpr_source2_rd_en, simf3_2vgpr_source3_rd_en, simf3_2vgpr_wr_en,
		   vgpr2issue_alu_dest_reg_valid, vgpr2issue_alu_wr_done, vgpr2issue_lsu_wr_done,
		   wave2decode_instr_valid;
   wire [1:0] 	   decode2issue_fu, salu2sgpr_dest_wr_en, salu2tracemon_exec_word_sel,
		   salu2tracemon_vcc_word_sel, sgpr2issue_alu_dest_reg_valid;
   wire [3:0] 	   dispatch2cu_wg_wf_count, fetch2issue_wg_wf_count,
		   lsu2sgpr_dest_wr_en, sgpr2issue_lsu_dest_reg_valid,
		   vgpr2issue_lsu_dest_reg_valid;
   wire lsu2mem_rd_en, lsu2mem_wr_en, lsu2vgpr_dest_wr_en;
   wire [5:0] 	   decode2issue_wfid, decode2wave_ins_half_wfid, dispatch2cu_wf_size_dispatch,
		   exec2issue_salu_wr_wfid, exec2issue_valu_wr_vcc_wfid, fetch2exec_init_wf_id,
		   fetch2issue_wg_wgid, fetch2tracemon_new_wfid, fetch2wave_basereg_wfid,
		   fetch2wave_reserve_slotid, issue2alu_wfid, issue2fetch_wg_wfid, issue2fetchwave_wf_done_wf_id,
		   issue2lsu_wfid, issue2tracemon_waitcnt_retire_wfid, lsu2exec_rd_wfid,
		   lsu2sgpr_instr_done_wfid, lsu2vgpr_instr_done_wfid, lsu2issue_done_wfid, salu2exec_rd_wfid,
		   salu2exec_wr_wfid, salu2fetchwaveissue_branch_wfid, salu2sgpr_instr_done_wfid,
		   sgpr2issue_alu_wr_done_wfid, sgpr2issue_lsu_instr_done_wfid, simd0_2exec_rd_wfid,
		   simd0_2exec_wr_vcc_wfid, simd0_2vgpr_instr_done_wfid, simd1_2exec_rd_wfid,
		   simd1_2exec_wr_vcc_wfid, simd1_2vgpr_instr_done_wfid, simd2_2exec_rd_wfid,
		   simd2_2exec_wr_vcc_wfid, simd2_2vgpr_instr_done_wfid, simd3_2exec_rd_wfid,
		   simd3_2exec_wr_vcc_wfid, simd3_2vgpr_instr_done_wfid, simf0_2exec_rd_wfid,
		   simf0_2exec_wr_vcc_wfid, simf0_2vgpr_instr_done_wfid, simf1_2exec_rd_wfid,
		   simf1_2exec_wr_vcc_wfid, simf1_2vgpr_instr_done_wfid, simf2_2exec_rd_wfid,
		   simf2_2exec_wr_vcc_wfid, simf2_2vgpr_instr_done_wfid, simf3_2exec_rd_wfid,
		   simf3_2exec_wr_vcc_wfid, simf3_2vgpr_instr_done_wfid, vgpr2issue_alu_wr_done_wfid,
		   vgpr2issue_lsu_wr_done_wfid, wave2decode_wfid;
   wire [6:0] 	   lsu2mem_tag_req, mem2lsu_tag_resp;
   wire [8:0] 	   dispatch2cu_sgpr_base_dispatch, fetch2wave_sgpr_base, lsu2sgpr_dest_addr,
		   lsu2sgpr_source1_addr, lsu2sgpr_source2_addr, salu2sgpr_dest_addr, salu2sgpr_source1_addr,
		   salu2sgpr_source2_addr, sgpr2issue_alu_dest_reg_addr, sgpr2issue_lsu_dest_reg_addr,
		   sgpr2issue_valu_dest_addr, simd0_2sgpr_rd_addr, simd0_2sgpr_wr_addr,
		   simd1_2sgpr_rd_addr, simd1_2sgpr_wr_addr, simd2_2sgpr_rd_addr, simd2_2sgpr_wr_addr,
		   simd3_2sgpr_rd_addr, simd3_2sgpr_wr_addr, simf0_2sgpr_rd_addr, simf0_2sgpr_wr_addr,
		   simf1_2sgpr_rd_addr, simf1_2sgpr_wr_addr, simf2_2sgpr_rd_addr, simf2_2sgpr_wr_addr,
		   simf3_2sgpr_rd_addr, simf3_2sgpr_wr_addr, wave2decode_sgpr_base;
   wire [9:0] 	   dispatch2cu_vgpr_base_dispatch, fetch2wave_vgpr_base, lsu2vgpr_dest_addr,
		   lsu2vgpr_source1_addr, lsu2vgpr_source2_addr, simd0_2vgpr_dest_addr,
		   simd0_2vgpr_source1_addr, simd0_2vgpr_source2_addr, simd0_2vgpr_source3_addr,
		   simd1_2vgpr_dest_addr, simd1_2vgpr_source1_addr, simd1_2vgpr_source2_addr,
		   simd1_2vgpr_source3_addr, simd2_2vgpr_dest_addr, simd2_2vgpr_source1_addr,
		   simd2_2vgpr_source2_addr, simd2_2vgpr_source3_addr, simd3_2vgpr_dest_addr,
		   simd3_2vgpr_source1_addr, simd3_2vgpr_source2_addr, simd3_2vgpr_source3_addr,
		   simf0_2vgpr_dest_addr, simf0_2vgpr_source1_addr, simf0_2vgpr_source2_addr,
		   simf0_2vgpr_source3_addr, simf1_2vgpr_dest_addr, simf1_2vgpr_source1_addr,
		   simf1_2vgpr_source2_addr, simf1_2vgpr_source3_addr, simf2_2vgpr_dest_addr,
		   simf2_2vgpr_source1_addr, simf2_2vgpr_source2_addr, simf2_2vgpr_source3_addr,
		   simf3_2vgpr_dest_addr, simf3_2vgpr_source1_addr, simf3_2vgpr_source2_addr,
		   simf3_2vgpr_source3_addr, vgpr2issue_alu_dest_reg_addr, vgpr2issue_lsu_dest_reg_addr,
		   wave2decode_vgpr_base;
   wire [11:0] 	   issue2alu_dest_reg1, issue2alu_dest_reg2, issue2alu_source_reg1,
		   issue2alu_source_reg2, issue2alu_source_reg3, issue2lsu_dest_reg, issue2lsu_mem_sgpr,
		   issue2lsu_source_reg1, issue2lsu_source_reg2, issue2lsu_source_reg3;
   wire [12:0] 	   decode2issue_dest_reg2, decode2issue_source_reg2, decode2issue_source_reg3;
   wire [13:0] 	   decode2issue_dest_reg1, decode2issue_source_reg1, decode2issue_source_reg4;
   wire [14:0] 	   cu2dispatch_wf_tag_done, dispatch2cu_wf_tag_dispatch, fetch2tracemon_wf_tag;
   wire [15:0] 	   decode2issue_imm_value0, decode2issue_lds_base, dispatch2cu_lds_base_dispatch,
		   fetch2wave_lds_base, issue2alu_imm_value0, issue2lsu_imm_value0, issue2lsu_lds_base,
		   rfa2execvgprsgpr_select_fu, wave2decode_lds_base;
   wire [31:0] 	   buff2wave_instr, decode2issue_imm_value1, decode2issue_instr_pc,
		   decode2issue_opcode, dispatch2cu_start_pc_dispatch, exec2lsu_rd_m0_value,
		   exec2salu_rd_m0_value, exec2simd_rd_m0_value, exec2simf_rd_m0_value,
		   fetch2buff_addr, issue2alu_imm_value1, issue2alu_instr_pc, issue2alu_opcode,
		   issue2lsu_imm_value1, issue2lsu_instr_pc, issue2lsu_opcode, issue2tracemon_barrier_retire_pc,
		   issue2tracemon_waitcnt_retire_pc, lsu2tracemon_retire_pc, salu2exec_wr_m0_value,
		   salu2fetch_branch_pc_value, salu2tracemon_retire_pc, sgpr2lsu_source2_data,
		   sgpr2simd_rd_data, sgpr2simf_rd_data, simd0_2tracemon_retire_pc, simd1_2tracemon_retire_pc,
		   simd2_2tracemon_retire_pc, simd3_2tracemon_retire_pc, simf0_2tracemon_retire_pc,
		   simf1_2tracemon_retire_pc, simf2_2tracemon_retire_pc, simf3_2tracemon_retire_pc,
		   wave2decode_instr, wave2decode_instr_pc;
   wire [38:0] 	   buff2wave_tag, fetch2buff_tag;
   wire [39:0] 	   issue2tracemon_barrier_retire_wf_bitmap, issue2wave_valid_entries,
		   wave2fetch_stop_fetch;
   wire [63:0] 	   decode2tracemon_collinstr, exec2lsu_exec_value, exec2salu_rd_exec_value,
		   exec2salu_rd_vcc_value, exec2simd_rd_exec_value, exec2simd_rd_vcc_value,
		   exec2simf_rd_exec_value, exec2simf_rd_vcc_value, fetch2exec_init_value,
		   lsu2mem_wr_mask, lsu2vgpr_dest_wr_mask, salu2exec_wr_exec_value, salu2exec_wr_vcc_value,
		   salu2sgpr_dest_data, sgpr2salu_source1_data, sgpr2salu_source2_data,
		   simd0_2exec_wr_vcc_value, simd0_2sgpr_wr_data, simd0_2sgpr_wr_mask,
		   simd0_2vgpr_wr_mask, simd1_2exec_wr_vcc_value, simd1_2sgpr_wr_data,
		   simd1_2sgpr_wr_mask, simd1_2vgpr_wr_mask, simd2_2exec_wr_vcc_value,
		   simd2_2sgpr_wr_data, simd2_2sgpr_wr_mask, simd2_2vgpr_wr_mask, simd3_2exec_wr_vcc_value,
		   simd3_2sgpr_wr_data, simd3_2sgpr_wr_mask, simd3_2vgpr_wr_mask, simf0_2exec_wr_vcc_value,
		   simf0_2sgpr_wr_data, simf0_2sgpr_wr_mask, simf0_2vgpr_wr_mask, simf1_2exec_wr_vcc_value,
		   simf1_2sgpr_wr_data, simf1_2sgpr_wr_mask, simf1_2vgpr_wr_mask, simf2_2exec_wr_vcc_value,
		   simf2_2sgpr_wr_data, simf2_2sgpr_wr_mask, simf2_2vgpr_wr_mask, simf3_2exec_wr_vcc_value,
		   simf3_2sgpr_wr_data, simf3_2sgpr_wr_mask, simf3_2vgpr_wr_mask;
   wire [127:0]    lsu2sgpr_dest_data, sgpr2lsu_source1_data;
   wire [2047:0]   simd0_2vgpr_dest_data, simd1_2vgpr_dest_data,
		   simd2_2vgpr_dest_data, simd3_2vgpr_dest_data, simf0_2vgpr_dest_data,
		   simf1_2vgpr_dest_data, simf2_2vgpr_dest_data, simf3_2vgpr_dest_data,
		   vgpr2lsu_source2_data, vgpr2simd_source1_data, vgpr2simd_source2_data,
		   vgpr2simd_source3_data, vgpr2simf_source1_data, vgpr2simf_source2_data,
		   vgpr2simf_source3_data;

   //**CHANGE
   wire [2047:0]   lsu2vgpr_dest_data, vgpr2lsu_source1_data;
   wire [31:0]     lsu2mem_wr_data, mem2lsu_rd_data, lsu2mem_addr;


   wire salu_request, lsu_stall;


  wire [8:0] lsu2sgpr_dest_addr_muxed;
  wire [127:0] lsu2sgpr_dest_data_muxed;
  wire [3:0] lsu2sgpr_dest_wr_en_muxed;
  wire [8:0] lsu2sgpr_source1_addr_muxed;
  wire lsu2sgpr_source1_rd_en_muxed;

  wire [9:0] lsu2vgpr_dest_addr_muxed;
  wire [2047:0] lsu2vgpr_dest_data_muxed;
  wire [3:0] lsu2vgpr_dest_wr_en_muxed;
  wire [63:0] lsu2vgpr_dest_wr_mask_muxed;
  wire [9:0] lsu2vgpr_source1_addr_muxed;
  wire lsu2vgpr_source1_rd_en_muxed;

  wire [15:0] sgpr_select_fu;
  wire [15:0] vgpr_select_fu;

  assign sgpr2dispatch_rd_data = sgpr2lsu_source1_data;
  assign vgpr2dispatch_rd_data = vgpr2lsu_source1_data;

  assign sgpr_select_fu = dispatch2cu_idle ? {7'd0, dispatch2sgpr_wr_en, 8'd0} : rfa2execvgprsgpr_select_fu;
  assign lsu2sgpr_dest_addr_muxed = dispatch2cu_idle ? dispatch2sgpr_addr : lsu2sgpr_dest_addr;
  assign lsu2sgpr_dest_data_muxed = dispatch2cu_idle ? dispatch2sgpr_wr_data : lsu2sgpr_dest_data;
  assign lsu2sgpr_dest_wr_en_muxed = dispatch2cu_idle ? {4{dispatch2sgpr_wr_en}} : lsu2sgpr_dest_wr_en;
  assign lsu2sgpr_source1_addr_muxed = dispatch2cu_idle ? dispatch2sgpr_addr : lsu2sgpr_source1_addr;
  assign lsu2sgpr_source1_rd_en_muxed = dispatch2cu_idle | lsu2sgpr_source1_rd_en;

  assign vgpr_select_fu = dispatch2cu_idle ? {7'd0,  dispatch2vgpr_wr_en, 8'd0} : rfa2execvgprsgpr_select_fu;
  assign lsu2vgpr_dest_addr_muxed = dispatch2cu_idle ? dispatch2vgpr_addr : lsu2vgpr_dest_addr;
  assign lsu2vgpr_dest_data_muxed = dispatch2cu_idle ? dispatch2vgpr_wr_data : lsu2vgpr_dest_data;
  assign lsu2vgpr_dest_wr_en_muxed = dispatch2cu_idle ? {4{dispatch2vgpr_wr_en}} : lsu2vgpr_dest_wr_en;
  assign lsu2vgpr_dest_wr_mask_muxed = dispatch2cu_idle ? dispatch2vgpr_wr_mask : lsu2vgpr_dest_wr_mask;
  assign lsu2vgpr_source1_addr_muxed = dispatch2cu_idle ? dispatch2vgpr_addr : lsu2vgpr_source1_addr;
  assign lsu2vgpr_source1_rd_en_muxed = dispatch2cu_idle | lsu2vgpr_source1_rd_en;


   decode decode0 (
		   // Unit that decodes instructions and passes them to issue.
		   .clk(clk),
		   .rst(rst),
		   //  Inputs
		   .wave_instr_pc(wave2decode_instr_pc),
		   .wave_instr_valid(wave2decode_instr_valid),
		   .wave_instr(wave2decode_instr),
		   .wave_wfid(wave2decode_wfid),
		   .wave_vgpr_base(wave2decode_vgpr_base),
		   .wave_sgpr_base(wave2decode_sgpr_base),
		   .wave_lds_base(wave2decode_lds_base),
		   //  Outputs
		   .issue_wf_halt(decode2issue_wf_halt),
		   .issue_fu(decode2issue_fu),
		   .issue_wfid(decode2issue_wfid),
		   .issue_opcode(decode2issue_opcode),
		   .issue_source_reg1(decode2issue_source_reg1),
		   .issue_source_reg2(decode2issue_source_reg2),
		   .issue_source_reg3(decode2issue_source_reg3),
		   .issue_source_reg4(decode2issue_source_reg4),
		   .issue_dest_reg1(decode2issue_dest_reg1),
		   .issue_dest_reg2(decode2issue_dest_reg2),
		   .issue_imm_value0(decode2issue_imm_value0),
		   .issue_imm_value1(decode2issue_imm_value1),
		   .issue_valid(decode2issue_valid),
		   .issue_instr_pc(decode2issue_instr_pc),
		   .issue_vcc_wr(decode2issue_vcc_wr),
		   .issue_vcc_rd(decode2issue_vcc_rd),
		   .issue_scc_wr(decode2issue_scc_wr),
		   .issue_scc_rd(decode2issue_scc_rd),
		   .issue_exec_rd(decode2issue_exec_rd),
		   .issue_exec_wr(decode2issue_exec_wr),
		   .issue_m0_rd(decode2issue_m0_rd),
		   .issue_m0_wr(decode2issue_m0_wr),
		   .issue_barrier(decode2issue_barrier),
		   .issue_branch(decode2issue_branch),
		   .issue_lds_base(decode2issue_lds_base),
		   .issue_waitcnt(decode2issue_waitcnt),
		   .wave_ins_half_rqd(decode2wave_ins_half_rqd),
		   .wave_ins_half_wfid(decode2wave_ins_half_wfid),
		   .tracemon_collinstr(decode2tracemon_collinstr),
		   .tracemon_colldone(decode2tracemon_colldone)
		   );

   exec exec0 (
	       // Exec flag, used to choose which wave items inside a wavefront will retire and which will not.
	       .clk(clk),
	       .rst(rst),
	       //  Inputs
	       .lsu_rd_wfid(lsu2exec_rd_wfid),
	       .salu_wr_exec_en(salu2exec_wr_exec_en),
	       .salu_wr_vcc_en(salu2exec_wr_vcc_en),
	       .salu_wr_exec_value(salu2exec_wr_exec_value),
	       .salu_wr_vcc_value(salu2exec_wr_vcc_value),
	       .salu_wr_wfid(salu2exec_wr_wfid),
	       .salu_rd_en(salu2exec_rd_en),
	       .salu_rd_wfid(salu2exec_rd_wfid),
	       .salu_wr_m0_en(salu2exec_wr_m0_en),
	       .salu_wr_m0_value(salu2exec_wr_m0_value),
	       .salu_wr_scc_en(salu2exec_wr_scc_en),
	       .salu_wr_scc_value(salu2exec_wr_scc_value),
	       .simd0_rd_wfid(simd0_2exec_rd_wfid),
	       .simd1_rd_wfid(simd1_2exec_rd_wfid),
	       .simd2_rd_wfid(simd2_2exec_rd_wfid),
	       .simd3_rd_wfid(simd3_2exec_rd_wfid),
	       .simd0_rd_en(simd0_2exec_rd_en),
	       .simd1_rd_en(simd1_2exec_rd_en),
	       .simd2_rd_en(simd2_2exec_rd_en),
	       .simd3_rd_en(simd3_2exec_rd_en),
	       .simd0_vcc_wr_wfid(simd0_2exec_wr_vcc_wfid),
	       .simd1_vcc_wr_wfid(simd1_2exec_wr_vcc_wfid),
	       .simd2_vcc_wr_wfid(simd2_2exec_wr_vcc_wfid),
	       .simd3_vcc_wr_wfid(simd3_2exec_wr_vcc_wfid),
	       .simd0_vcc_wr_en(simd0_2exec_wr_vcc_en),
	       .simd1_vcc_wr_en(simd1_2exec_wr_vcc_en),
	       .simd2_vcc_wr_en(simd2_2exec_wr_vcc_en),
	       .simd3_vcc_wr_en(simd3_2exec_wr_vcc_en),
	       .simd0_vcc_value(simd0_2exec_wr_vcc_value),
	       .simd1_vcc_value(simd1_2exec_wr_vcc_value),
	       .simd2_vcc_value(simd2_2exec_wr_vcc_value),
	       .simd3_vcc_value(simd3_2exec_wr_vcc_value),
	       .simf0_rd_wfid(simf0_2exec_rd_wfid),
	       .simf1_rd_wfid(simf1_2exec_rd_wfid),
	       .simf2_rd_wfid(simf2_2exec_rd_wfid),
	       .simf3_rd_wfid(simf3_2exec_rd_wfid),
	       .simf0_rd_en(simf0_2exec_rd_en),
	       .simf1_rd_en(simf1_2exec_rd_en),
	       .simf2_rd_en(simf2_2exec_rd_en),
	       .simf3_rd_en(simf3_2exec_rd_en),
	       .simf0_vcc_wr_wfid(simf0_2exec_wr_vcc_wfid),
	       .simf1_vcc_wr_wfid(simf1_2exec_wr_vcc_wfid),
	       .simf2_vcc_wr_wfid(simf2_2exec_wr_vcc_wfid),
	       .simf3_vcc_wr_wfid(simf3_2exec_wr_vcc_wfid),
	       .simf0_vcc_wr_en(simf0_2exec_wr_vcc_en),
	       .simf1_vcc_wr_en(simf1_2exec_wr_vcc_en),
	       .simf2_vcc_wr_en(simf2_2exec_wr_vcc_en),
	       .simf3_vcc_wr_en(simf3_2exec_wr_vcc_en),
	       .simf0_vcc_value(simf0_2exec_wr_vcc_value),
	       .simf1_vcc_value(simf1_2exec_wr_vcc_value),
	       .simf2_vcc_value(simf2_2exec_wr_vcc_value),
	       .simf3_vcc_value(simf3_2exec_wr_vcc_value),
	       .fetch_init_wf_en(fetch2exec_init_wf_en),
	       .fetch_init_wf_id(fetch2exec_init_wf_id),
	       .fetch_init_value(fetch2exec_init_value),
	       .rfa_select_fu(rfa2execvgprsgpr_select_fu),
	       //  Outputs
	       .lsu_exec_value(exec2lsu_exec_value),
	       .lsu_rd_m0_value(exec2lsu_rd_m0_value),
	       .simd_rd_exec_value(exec2simd_rd_exec_value),
	       .simd_rd_vcc_value(exec2simd_rd_vcc_value),
	       .simd_rd_m0_value(exec2simd_rd_m0_value),
	       .simd_rd_scc_value(exec2simd_rd_scc_value),
	       .simf_rd_exec_value(exec2simf_rd_exec_value),
	       .simf_rd_vcc_value(exec2simf_rd_vcc_value),
	       .simf_rd_m0_value(exec2simf_rd_m0_value),
	       .simf_rd_scc_value(exec2simf_rd_scc_value),
	       .salu_rd_exec_value(exec2salu_rd_exec_value),
	       .salu_rd_vcc_value(exec2salu_rd_vcc_value),
	       .salu_rd_m0_value(exec2salu_rd_m0_value),
	       .salu_rd_scc_value(exec2salu_rd_scc_value),
	       .issue_salu_wr_vcc_wfid(exec2issue_salu_wr_wfid),
	       .issue_salu_wr_vcc_en(exec2issue_salu_wr_vcc_en),
	       .issue_salu_wr_exec_en(exec2issue_salu_wr_exec_en),
	       .issue_salu_wr_m0_en(exec2issue_salu_wr_m0_en),
	       .issue_salu_wr_scc_en(exec2issue_salu_wr_scc_en),
	       .issue_valu_wr_vcc_wfid(exec2issue_valu_wr_vcc_wfid),
	       .issue_valu_wr_vcc_en(exec2issue_valu_wr_vcc_en)
	       );

   fetch fetch0 (
		 // Unit that fetches instructions from a wavefront chosen by the wavepool
		 .clk(clk),
		 .rst(rst),
		 //  Inputs
		 .dispatch2cu_wf_dispatch(dispatch2cu_wf_dispatch),
		 .dispatch2cu_wf_tag_dispatch(dispatch2cu_wf_tag_dispatch),
		 .dispatch2cu_start_pc_dispatch(dispatch2cu_start_pc_dispatch),
		 .dispatch2cu_vgpr_base_dispatch(dispatch2cu_vgpr_base_dispatch),
		 .dispatch2cu_sgpr_base_dispatch(dispatch2cu_sgpr_base_dispatch),
		 .dispatch2cu_lds_base_dispatch(dispatch2cu_lds_base_dispatch),
		 .dispatch2cu_wf_size_dispatch(dispatch2cu_wf_size_dispatch),
		 .dispatch2cu_wg_wf_count(dispatch2cu_wg_wf_count),
		 .buff_ack(buff2fetchwave_ack),
		 .wave_stop_fetch(wave2fetch_stop_fetch),
		 .issue_wf_done_en(issue2fetchwave_wf_done_en),
		 .issue_wf_done_wf_id(issue2fetchwave_wf_done_wf_id),
		 .issue_wg_wfid(issue2fetch_wg_wfid),
		 .salu_branch_wfid(salu2fetchwaveissue_branch_wfid),
		 .salu_branch_en(salu2fetchwaveissue_branch_en),
		 .salu_branch_taken(salu2fetchwaveissue_branch_taken),
		 .salu_branch_pc_value(salu2fetch_branch_pc_value),
		 //  Outputs
		 .cu2dispatch_wf_tag_done(cu2dispatch_wf_tag_done),
		 .cu2dispatch_wf_done(cu2dispatch_wf_done),
		 .buff_addr(fetch2buff_addr),
		 .buff_tag(fetch2buff_tag),
		 .buff_rd_en(fetch2buff_rd_en),
		 .wave_reserve_slotid(fetch2wave_reserve_slotid),
		 .wave_reserve_valid(fetch2wave_reserve_valid),
		 .wave_basereg_wr(fetch2wave_basereg_wr),
		 .wave_basereg_wfid(fetch2wave_basereg_wfid),
		 .wave_vgpr_base(fetch2wave_vgpr_base),
		 .wave_sgpr_base(fetch2wave_sgpr_base),
		 .wave_lds_base(fetch2wave_lds_base),
		 .exec_init_wf_en(fetch2exec_init_wf_en),
		 .exec_init_wf_id(fetch2exec_init_wf_id),
		 .exec_init_value(fetch2exec_init_value),
		 .issue_wg_wgid(fetch2issue_wg_wgid),
		 .issue_wg_wf_count(fetch2issue_wg_wf_count),
		 .tracemon_dispatch(fetch2tracemon_dispatch),
		 .tracemon_wf_tag_dispatch(fetch2tracemon_wf_tag),
		 .tracemon_new_wfid(fetch2tracemon_new_wfid)
		 );

   issue issue0 (
		 // Unit that does scoreboarding and choses from which wavefront to issue at a cycle.
		 .clk(clk),
		 .rst(rst),
		 //  Inputs
		 .decode_branch(decode2issue_branch),
		 .decode_barrier(decode2issue_barrier),
		 .decode_vcc_wr(decode2issue_vcc_wr),
		 .decode_vcc_rd(decode2issue_vcc_rd),
		 .decode_scc_wr(decode2issue_scc_wr),
		 .decode_scc_rd(decode2issue_scc_rd),
		 .decode_exec_rd(decode2issue_exec_rd),
		 .decode_exec_wr(decode2issue_exec_wr),
		 .decode_m0_rd(decode2issue_m0_rd),
		 .decode_m0_wr(decode2issue_m0_wr),
		 .decode_instr_pc(decode2issue_instr_pc),
		 .decode_wf_halt(decode2issue_wf_halt),
		 .decode_fu(decode2issue_fu),
		 .decode_wfid(decode2issue_wfid),
		 .decode_opcode(decode2issue_opcode),
		 .decode_source_reg1(decode2issue_source_reg1),
		 .decode_source_reg2(decode2issue_source_reg2),
		 .decode_source_reg3(decode2issue_source_reg3),
		 .decode_source_reg4(decode2issue_source_reg4),
		 .decode_dest_reg1(decode2issue_dest_reg1),
		 .decode_dest_reg2(decode2issue_dest_reg2),
		 .decode_imm_value0(decode2issue_imm_value0),
		 .decode_imm_value1(decode2issue_imm_value1),
		 .decode_lds_base(decode2issue_lds_base),
		 .decode_waitcnt(decode2issue_waitcnt),
		 .decode_valid(decode2issue_valid),
		 .vgpr_alu_wr_done_wfid(vgpr2issue_alu_wr_done_wfid),
		 .vgpr_alu_wr_done(vgpr2issue_alu_wr_done),
		 .vgpr_alu_dest_reg_addr(vgpr2issue_alu_dest_reg_addr),
		 .vgpr_alu_dest_reg_valid(vgpr2issue_alu_dest_reg_valid),
		 .vgpr_lsu_wr_done_wfid(vgpr2issue_lsu_wr_done_wfid),
		 .vgpr_lsu_wr_done(vgpr2issue_lsu_wr_done),
		 .vgpr_lsu_dest_reg_addr(vgpr2issue_lsu_dest_reg_addr),
		 .vgpr_lsu_dest_reg_valid(vgpr2issue_lsu_dest_reg_valid),
		 .sgpr_alu_wr_done_wfid(sgpr2issue_alu_wr_done_wfid),
		 .sgpr_alu_wr_done(sgpr2issue_alu_wr_done),
		 .sgpr_alu_dest_reg_addr(sgpr2issue_alu_dest_reg_addr),
		 .sgpr_alu_dest_reg_valid(sgpr2issue_alu_dest_reg_valid),
		 .sgpr_lsu_instr_done_wfid(sgpr2issue_lsu_instr_done_wfid),
		 .sgpr_lsu_instr_done(sgpr2issue_lsu_instr_done),
		 .sgpr_lsu_dest_reg_addr(sgpr2issue_lsu_dest_reg_addr),
		 .sgpr_lsu_dest_reg_valid(sgpr2issue_lsu_dest_reg_valid),
		 .sgpr_valu_dest_reg_valid(sgpr2issue_valu_dest_reg_valid),
		 .sgpr_valu_dest_addr(sgpr2issue_valu_dest_addr),
		 .simd0_alu_ready(simd0_2issue_alu_ready),
		 .simd1_alu_ready(simd1_2issue_alu_ready),
		 .simd2_alu_ready(simd2_2issue_alu_ready),
		 .simd3_alu_ready(simd3_2issue_alu_ready),
		 .simf0_alu_ready(simf0_2issue_alu_ready),
		 .simf1_alu_ready(simf1_2issue_alu_ready),
		 .simf2_alu_ready(simf2_2issue_alu_ready),
		 .simf3_alu_ready(simf3_2issue_alu_ready),
		 .salu_alu_ready(salu2issue_alu_ready),
		 .lsu_ready(lsu2issue_ready),
         .lsu_done(lsu2issue_done),
         .lsu_done_wfid(lsu2issue_done_wfid),
		 .exec_salu_wr_wfid(exec2issue_salu_wr_wfid),
		 .exec_salu_wr_vcc_en(exec2issue_salu_wr_vcc_en),
		 .exec_salu_wr_exec_en(exec2issue_salu_wr_exec_en),
		 .exec_salu_wr_scc_en(exec2issue_salu_wr_scc_en),
		 .exec_salu_wr_m0_en(exec2issue_salu_wr_m0_en),
		 .exec_valu_wr_vcc_wfid(exec2issue_valu_wr_vcc_wfid),
		 .exec_valu_wr_vcc_en(exec2issue_valu_wr_vcc_en),
		 .fetch_wg_wgid(fetch2issue_wg_wgid),
		 .fetch_wg_wf_count(fetch2issue_wg_wf_count),
		 .salu_branch_wfid(salu2fetchwaveissue_branch_wfid),
		 .salu_branch_en(salu2fetchwaveissue_branch_en),
		 .salu_branch_taken(salu2fetchwaveissue_branch_taken),
		 //  Outputs
		 .wave_valid_entries(issue2wave_valid_entries),
		 .salu_alu_select(issue2salu_alu_select),
		 .simd0_alu_select(issue2simd0_alu_select),
		 .simd1_alu_select(issue2simd1_alu_select),
		 .simd2_alu_select(issue2simd2_alu_select),
		 .simd3_alu_select(issue2simd3_alu_select),
		 .simf0_alu_select(issue2simf0_alu_select),
		 .simf1_alu_select(issue2simf1_alu_select),
		 .simf2_alu_select(issue2simf2_alu_select),
		 .simf3_alu_select(issue2simf3_alu_select),
		 .lsu_lsu_select(issue2lsu_lsu_select),
		 .lsu_source_reg1(issue2lsu_source_reg1),
		 .lsu_source_reg2(issue2lsu_source_reg2),
		 .lsu_source_reg3(issue2lsu_source_reg3),
		 .lsu_dest_reg(issue2lsu_dest_reg),
		 .lsu_imm_value0(issue2lsu_imm_value0),
		 .lsu_imm_value1(issue2lsu_imm_value1),
		 .lsu_opcode(issue2lsu_opcode),
		 .lsu_mem_sgpr(issue2lsu_mem_sgpr),
		 .lsu_wfid(issue2lsu_wfid),
		 .lsu_lds_base(issue2lsu_lds_base),
		 .alu_source_reg1(issue2alu_source_reg1),
		 .alu_source_reg2(issue2alu_source_reg2),
		 .alu_source_reg3(issue2alu_source_reg3),
		 .alu_dest_reg1(issue2alu_dest_reg1),
		 .alu_dest_reg2(issue2alu_dest_reg2),
		 .alu_imm_value0(issue2alu_imm_value0),
		 .alu_imm_value1(issue2alu_imm_value1),
		 .alu_opcode(issue2alu_opcode),
		 .alu_wfid(issue2alu_wfid),
		 .alu_instr_pc(issue2alu_instr_pc),
		 .lsu_instr_pc(issue2lsu_instr_pc),
		 .fetchwave_wf_done_en(issue2fetchwave_wf_done_en),
		 .fetchwave_wf_done_wf_id(issue2fetchwave_wf_done_wf_id),
		 .fetch_wg_wfid(issue2fetch_wg_wfid),
		 .tracemon_barrier_retire_en(issue2tracemon_barrier_retire_en),
		 .tracemon_barrier_retire_wf_bitmap(issue2tracemon_barrier_retire_wf_bitmap),
		 .tracemon_barrier_retire_pc(issue2tracemon_barrier_retire_pc),
		 .tracemon_waitcnt_retire_en(issue2tracemon_waitcnt_retire_en),
		 .tracemon_waitcnt_retire_wfid(issue2tracemon_waitcnt_retire_wfid),
		 .tracemon_waitcnt_retire_pc(issue2tracemon_waitcnt_retire_pc)
		 );

// Because of how the LSU internally works it's the same buffer that feeds
// into the VGPR and the SGPR write buses so we can just use the VGPR output
// bus to capture store operations for both.
assign lsu2tracemon_store_data = lsu2vgpr_dest_data;

neko_lsu neko_lsu0 (
    // unit to handle loads and stores
    .clk(clk),//
    .rst(rst),//
    //  Inputs
    .issue_lsu_select(issue2lsu_lsu_select),//
    .issue_source_reg1(issue2lsu_source_reg1),//
    .issue_source_reg2(issue2lsu_source_reg2),//
    .issue_source_reg3(issue2lsu_source_reg3),//
    .issue_dest_reg(issue2lsu_dest_reg),//
    .issue_imm_value0(issue2lsu_imm_value0),//
    .issue_imm_value1(issue2lsu_imm_value1),//
    .issue_opcode(issue2lsu_opcode),//
    .issue_mem_sgpr(issue2lsu_mem_sgpr),//
    .issue_wfid(issue2lsu_wfid),//
    .issue_lds_base(issue2lsu_lds_base),//
    .vgpr_source1_data(vgpr2lsu_source1_data),//
    .vgpr_source2_data(vgpr2lsu_source2_data),//
    .mem_rd_data(mem2lsu_rd_data),//
    .mem_tag_resp(mem2lsu_tag_resp),//
    .mem_ack(mem2lsu_ack),//
    .sgpr_source1_data(sgpr2lsu_source1_data),//
    .sgpr_source2_data(sgpr2lsu_source2_data),//
    .exec_exec_value(exec2lsu_exec_value),//
    .exec_rd_m0_value(exec2lsu_rd_m0_value),//
    .issue_instr_pc(issue2lsu_instr_pc),//
     .lsu_stall(lsu_stall),//**CHANGE
    //  Outputs
    .issue_ready(lsu2issue_ready),
    .lsu_done(lsu2issue_done),
    .lsu_done_wfid(lsu2issue_done_wfid),
    .vgpr_source1_addr(lsu2vgpr_source1_addr),
    .vgpr_source2_addr(lsu2vgpr_source2_addr),
    .vgpr_dest_addr(lsu2vgpr_dest_addr),
    .vgpr_dest_data(lsu2vgpr_dest_data),
    .vgpr_dest_wr_en(lsu2vgpr_dest_wr_en),
    .vgpr_dest_wr_mask(lsu2vgpr_dest_wr_mask),
    .vgpr_instr_done_wfid(lsu2vgpr_instr_done_wfid),
    .vgpr_instr_done(lsu2vgpr_instr_done),
    .vgpr_source1_rd_en(lsu2vgpr_source1_rd_en),
    .vgpr_source2_rd_en(lsu2vgpr_source2_rd_en),
    .exec_rd_wfid(lsu2exec_rd_wfid),
    .mem_rd_en(lsu2mem_rd_en),
    .mem_wr_en(lsu2mem_wr_en),
    .mem_addr(lsu2mem_addr),
    .mem_wr_data(lsu2mem_wr_data),
    .mem_tag_req(lsu2mem_tag_req),
    .mem_wr_mask(lsu2mem_wr_mask),
    .sgpr_source1_addr(lsu2sgpr_source1_addr),
    .sgpr_source2_addr(lsu2sgpr_source2_addr),
    .sgpr_dest_addr(lsu2sgpr_dest_addr),
    .sgpr_dest_data(lsu2sgpr_dest_data),
    .sgpr_dest_wr_en(lsu2sgpr_dest_wr_en),
    .sgpr_instr_done_wfid(lsu2sgpr_instr_done_wfid),
    .sgpr_instr_done(lsu2sgpr_instr_done),
    .sgpr_source1_rd_en(lsu2sgpr_source1_rd_en),
    .sgpr_source2_rd_en(lsu2sgpr_source2_rd_en),
    .mem_gm_or_lds(lsu2mem_gm_or_lds),
    .rfa_dest_wr_req(lsu2rfa_dest_wr_req),
    .tracemon_retire_pc(lsu2tracemon_retire_pc),
    .tracemon_gm_or_lds(lsu2tracemon_gm_or_lds),
    .tracemon_mem_addr(lsu2tracemon_addr),
    .tracemon_idle(lsu2tracemon_idle)
);

   rfa rfa0 (
	     // Unit that controls access to register file
	     .clk(clk),
	     .rst(rst),
	     //  Inputs
	     .lsu_dest_wr_req(lsu2rfa_dest_wr_req),
	     .simd0_queue_entry_valid(simd0_2rfa_queue_entry_valid),
	     .simd1_queue_entry_valid(simd1_2rfa_queue_entry_valid),
	     .simd2_queue_entry_valid(simd2_2rfa_queue_entry_valid),
	     .simd3_queue_entry_valid(simd3_2rfa_queue_entry_valid),
	     .simf0_queue_entry_valid(simf0_2rfa_queue_entry_valid),
	     .simf1_queue_entry_valid(simf1_2rfa_queue_entry_valid),
	     .simf2_queue_entry_valid(simf2_2rfa_queue_entry_valid),
	     .simf3_queue_entry_valid(simf3_2rfa_queue_entry_valid),
	     //  Outputs
	     .simd0_queue_entry_serviced(rfa2simd0_queue_entry_serviced),
	     .simd1_queue_entry_serviced(rfa2simd1_queue_entry_serviced),
	     .simd2_queue_entry_serviced(rfa2simd2_queue_entry_serviced),
	     .simd3_queue_entry_serviced(rfa2simd3_queue_entry_serviced),
	     .simf0_queue_entry_serviced(rfa2simf0_queue_entry_serviced),
	     .simf1_queue_entry_serviced(rfa2simf1_queue_entry_serviced),
	     .simf2_queue_entry_serviced(rfa2simf2_queue_entry_serviced),
	     .simf3_queue_entry_serviced(rfa2simf3_queue_entry_serviced),
	     .execvgprsgpr_select_fu(rfa2execvgprsgpr_select_fu),
             .lsu_wait(lsu_stall), //**change,
             .salu_req(salu_request) //**change
	     );

   salu salu0 (
	       // The scalar alu for scalar operations
	       .clk(clk),
	       .rst(rst),
	       //  Inputs
	       .issue_source_reg1(issue2alu_source_reg1),
	       .issue_source_reg2(issue2alu_source_reg2),
	       .issue_dest_reg(issue2alu_dest_reg1),
	       .issue_imm_value0(issue2alu_imm_value0),
	       .issue_imm_value1(issue2alu_imm_value1),
	       .issue_opcode(issue2alu_opcode),
	       .issue_wfid(issue2alu_wfid),
	       .issue_alu_select(issue2salu_alu_select),
	       .exec_rd_exec_value(exec2salu_rd_exec_value),
	       .exec_rd_vcc_value(exec2salu_rd_vcc_value),
	       .exec_rd_m0_value(exec2salu_rd_m0_value),
	       .exec_rd_scc_value(exec2salu_rd_scc_value),
	       .sgpr_source2_data(sgpr2salu_source2_data),
	       .sgpr_source1_data(sgpr2salu_source1_data),
	       .issue_instr_pc(issue2alu_instr_pc),
	       //  Outputs
	       .exec_wr_exec_en(salu2exec_wr_exec_en),
	       .exec_wr_vcc_en(salu2exec_wr_vcc_en),
	       .exec_wr_m0_en(salu2exec_wr_m0_en),
	       .exec_wr_scc_en(salu2exec_wr_scc_en),
	       .exec_wr_exec_value(salu2exec_wr_exec_value),
	       .exec_wr_vcc_value(salu2exec_wr_vcc_value),
	       .exec_wr_m0_value(salu2exec_wr_m0_value),
	       .exec_wr_scc_value(salu2exec_wr_scc_value),
	       .exec_wr_wfid(salu2exec_wr_wfid),
	       .exec_rd_en(salu2exec_rd_en),
	       .exec_rd_wfid(salu2exec_rd_wfid),
	       .sgpr_dest_data(salu2sgpr_dest_data),
	       .sgpr_dest_addr(salu2sgpr_dest_addr),
	       .sgpr_dest_wr_en(salu2sgpr_dest_wr_en),
	       .sgpr_source2_addr(salu2sgpr_source2_addr),
	       .sgpr_source1_addr(salu2sgpr_source1_addr),
	       .sgpr_source1_rd_en(salu2sgpr_source1_rd_en),
	       .sgpr_source2_rd_en(salu2sgpr_source2_rd_en),
	       .issue_alu_ready(salu2issue_alu_ready),
	       .sgpr_instr_done_wfid(salu2sgpr_instr_done_wfid),
	       .sgpr_instr_done(salu2sgpr_instr_done),
	       .fetchwaveissue_branch_wfid(salu2fetchwaveissue_branch_wfid),
	       .fetchwaveissue_branch_en(salu2fetchwaveissue_branch_en),
	       .fetchwaveissue_branch_taken(salu2fetchwaveissue_branch_taken),
	       .fetch_branch_pc_value(salu2fetch_branch_pc_value),
	       .tracemon_retire_pc(salu2tracemon_retire_pc),
	       .tracemon_exec_word_sel(salu2tracemon_exec_word_sel),
	       .tracemon_vcc_word_sel(salu2tracemon_vcc_word_sel),
               .rfa2sgpr_request(salu_request)//**change
	       );

   sgpr sgpr0 (
	      // set of scalar general purpose registers
	      .clk(clk),
	      .rst(rst),
	      //  Inputs

        .rfa_select_fu(sgpr_select_fu),
	      .lsu_source1_addr(lsu2sgpr_source1_addr_muxed),
        .lsu_source1_rd_en(lsu2sgpr_source1_rd_en_muxed),
        .lsu_dest_addr(lsu2sgpr_dest_addr_muxed),
	      .lsu_dest_data(lsu2sgpr_dest_data_muxed),
	      .lsu_dest_wr_en(lsu2sgpr_dest_wr_en_muxed),








	       .lsu_source2_addr(lsu2sgpr_source2_addr),
	       .lsu_source2_rd_en(lsu2sgpr_source2_rd_en),
	       .lsu_instr_done_wfid(lsu2sgpr_instr_done_wfid),
	       .lsu_instr_done(lsu2sgpr_instr_done),
	       .simd0_rd_addr(simd0_2sgpr_rd_addr),
	       .simd0_rd_en(simd0_2sgpr_rd_en),
	       .simd1_rd_addr(simd1_2sgpr_rd_addr),
	       .simd1_rd_en(simd1_2sgpr_rd_en),
	       .simd2_rd_addr(simd2_2sgpr_rd_addr),
	       .simd2_rd_en(simd2_2sgpr_rd_en),
	       .simd3_rd_addr(simd3_2sgpr_rd_addr),
	       .simd3_rd_en(simd3_2sgpr_rd_en),
	       .simd0_wr_addr(simd0_2sgpr_wr_addr),
	       .simd0_wr_en(simd0_2sgpr_wr_en),
	       .simd0_wr_data(simd0_2sgpr_wr_data),
	       .simd1_wr_addr(simd1_2sgpr_wr_addr),
	       .simd1_wr_en(simd1_2sgpr_wr_en),
	       .simd1_wr_data(simd1_2sgpr_wr_data),
	       .simd2_wr_addr(simd2_2sgpr_wr_addr),
	       .simd2_wr_en(simd2_2sgpr_wr_en),
	       .simd2_wr_data(simd2_2sgpr_wr_data),
	       .simd3_wr_addr(simd3_2sgpr_wr_addr),
	       .simd3_wr_en(simd3_2sgpr_wr_en),
	       .simd3_wr_data(simd3_2sgpr_wr_data),
	       .simd0_wr_mask(simd0_2sgpr_wr_mask),
	       .simd1_wr_mask(simd1_2sgpr_wr_mask),
	       .simd2_wr_mask(simd2_2sgpr_wr_mask),
	       .simd3_wr_mask(simd3_2sgpr_wr_mask),
	       .simf0_rd_addr(simf0_2sgpr_rd_addr),
	       .simf0_rd_en(simf0_2sgpr_rd_en),
	       .simf1_rd_addr(simf1_2sgpr_rd_addr),
	       .simf1_rd_en(simf1_2sgpr_rd_en),
	       .simf2_rd_addr(simf2_2sgpr_rd_addr),
	       .simf2_rd_en(simf2_2sgpr_rd_en),
	       .simf3_rd_addr(simf3_2sgpr_rd_addr),
	       .simf3_rd_en(simf3_2sgpr_rd_en),
	       .simf0_wr_addr(simf0_2sgpr_wr_addr),
	       .simf0_wr_en(simf0_2sgpr_wr_en),
	       .simf0_wr_data(simf0_2sgpr_wr_data),
	       .simf1_wr_addr(simf1_2sgpr_wr_addr),
	       .simf1_wr_en(simf1_2sgpr_wr_en),
	       .simf1_wr_data(simf1_2sgpr_wr_data),
	       .simf2_wr_addr(simf2_2sgpr_wr_addr),
	       .simf2_wr_en(simf2_2sgpr_wr_en),
	       .simf2_wr_data(simf2_2sgpr_wr_data),
	       .simf3_wr_addr(simf3_2sgpr_wr_addr),
	       .simf3_wr_en(simf3_2sgpr_wr_en),
	       .simf3_wr_data(simf3_2sgpr_wr_data),
	       .simf0_wr_mask(simf0_2sgpr_wr_mask),
	       .simf1_wr_mask(simf1_2sgpr_wr_mask),
	       .simf2_wr_mask(simf2_2sgpr_wr_mask),
	       .simf3_wr_mask(simf3_2sgpr_wr_mask),
	       .salu_dest_data(salu2sgpr_dest_data),
	       .salu_dest_addr(salu2sgpr_dest_addr),
	       .salu_dest_wr_en(salu2sgpr_dest_wr_en),
	       .salu_source2_addr(salu2sgpr_source2_addr),
	       .salu_source1_addr(salu2sgpr_source1_addr),
	       .salu_instr_done_wfid(salu2sgpr_instr_done_wfid),
	       .salu_instr_done(salu2sgpr_instr_done),
	       .salu_source1_rd_en(salu2sgpr_source1_rd_en),
	       .salu_source2_rd_en(salu2sgpr_source2_rd_en),
	       //  Outputs
	       .lsu_source1_data(sgpr2lsu_source1_data),
	       .lsu_source2_data(sgpr2lsu_source2_data),
	       .simd_rd_data(sgpr2simd_rd_data),
	       .simf_rd_data(sgpr2simf_rd_data),
	       .salu_source2_data(sgpr2salu_source2_data),
	       .salu_source1_data(sgpr2salu_source1_data),
	       .issue_alu_wr_done_wfid(sgpr2issue_alu_wr_done_wfid),
	       .issue_alu_wr_done(sgpr2issue_alu_wr_done),
	       .issue_alu_dest_reg_addr(sgpr2issue_alu_dest_reg_addr),
	       .issue_alu_dest_reg_valid(sgpr2issue_alu_dest_reg_valid),
	       .issue_lsu_instr_done_wfid(sgpr2issue_lsu_instr_done_wfid),
	       .issue_lsu_instr_done(sgpr2issue_lsu_instr_done),
	       .issue_lsu_dest_reg_addr(sgpr2issue_lsu_dest_reg_addr),
	       .issue_lsu_dest_reg_valid(sgpr2issue_lsu_dest_reg_valid),
	       .issue_valu_dest_reg_valid(sgpr2issue_valu_dest_reg_valid),
	       .issue_valu_dest_addr(sgpr2issue_valu_dest_addr)
	       );

   simd simd0 (
	       // Contains a 16 wide vector alu for vector operations
	       .clk(clk),
	       .rst(rst),
	       //  Inputs
	       .issue_source_reg1(issue2alu_source_reg1),
	       .issue_source_reg2(issue2alu_source_reg2),
	       .issue_source_reg3(issue2alu_source_reg3),
	       .issue_dest_reg1(issue2alu_dest_reg1),
	       .issue_dest_reg2(issue2alu_dest_reg2),
	       .issue_imm_value0(issue2alu_imm_value0),
	       .issue_imm_value1(issue2alu_imm_value1),
	       .issue_opcode(issue2alu_opcode),
	       .issue_wfid(issue2alu_wfid),
	       .issue_alu_select(issue2simd0_alu_select),
	       .vgpr_source1_data(vgpr2simd_source1_data),
	       .vgpr_source2_data(vgpr2simd_source2_data),
	       .vgpr_source3_data(vgpr2simd_source3_data),
	       .sgpr_rd_data(sgpr2simd_rd_data),
	       .exec_rd_exec_value(exec2simd_rd_exec_value),
	       .exec_rd_vcc_value(exec2simd_rd_vcc_value),
	       .exec_rd_m0_value(exec2simd_rd_m0_value),
	       .exec_rd_scc_value(exec2simd_rd_scc_value),
	       .issue_instr_pc(issue2alu_instr_pc),
	       .rfa_queue_entry_serviced(rfa2simd0_queue_entry_serviced),
	       //  Outputs
	       .vgpr_source1_rd_en(simd0_2vgpr_source1_rd_en),
	       .vgpr_source2_rd_en(simd0_2vgpr_source2_rd_en),
	       .vgpr_source3_rd_en(simd0_2vgpr_source3_rd_en),
	       .vgpr_source1_addr(simd0_2vgpr_source1_addr),
	       .vgpr_source2_addr(simd0_2vgpr_source2_addr),
	       .vgpr_source3_addr(simd0_2vgpr_source3_addr),
	       .vgpr_dest_addr(simd0_2vgpr_dest_addr),
	       .vgpr_dest_data(simd0_2vgpr_dest_data),
	       .vgpr_wr_en(simd0_2vgpr_wr_en),
	       .vgpr_wr_mask(simd0_2vgpr_wr_mask),
	       .exec_rd_wfid(simd0_2exec_rd_wfid),
	       .exec_rd_en(simd0_2exec_rd_en),
	       .exec_wr_vcc_wfid(simd0_2exec_wr_vcc_wfid),
	       .exec_wr_vcc_en(simd0_2exec_wr_vcc_en),
	       .exec_wr_vcc_value(simd0_2exec_wr_vcc_value),
	       .sgpr_rd_en(simd0_2sgpr_rd_en),
	       .sgpr_rd_addr(simd0_2sgpr_rd_addr),
	       .sgpr_wr_addr(simd0_2sgpr_wr_addr),
	       .sgpr_wr_en(simd0_2sgpr_wr_en),
	       .sgpr_wr_data(simd0_2sgpr_wr_data),
	       .sgpr_wr_mask(simd0_2sgpr_wr_mask),
	       .issue_alu_ready(simd0_2issue_alu_ready),
	       .vgpr_instr_done_wfid(simd0_2vgpr_instr_done_wfid),
	       .vgpr_instr_done(simd0_2vgpr_instr_done),
	       .rfa_queue_entry_valid(simd0_2rfa_queue_entry_valid),
	       .tracemon_retire_pc(simd0_2tracemon_retire_pc)
	       );




































































































































































   simf simf0 (
	       // Contains a 16 wide floating point vector alu for vector operations
	       .clk(clk),
	       .rst(rst),
	       //  Inputs
	       .issue_source_reg1(issue2alu_source_reg1),
	       .issue_source_reg2(issue2alu_source_reg2),
	       .issue_source_reg3(issue2alu_source_reg3),
	       .issue_dest_reg1(issue2alu_dest_reg1),
	       .issue_dest_reg2(issue2alu_dest_reg2),
	       .issue_imm_value0(issue2alu_imm_value0),
	       .issue_imm_value1(issue2alu_imm_value1),
	       .issue_opcode(issue2alu_opcode),
	       .issue_wfid(issue2alu_wfid),
	       .issue_alu_select(issue2simf0_alu_select),
	       .vgpr_source1_data(vgpr2simf_source1_data),
	       .vgpr_source2_data(vgpr2simf_source2_data),
	       .vgpr_source3_data(vgpr2simf_source3_data),
	       .sgpr_rd_data(sgpr2simf_rd_data),
	       .exec_rd_exec_value(exec2simf_rd_exec_value),
	       .exec_rd_vcc_value(exec2simf_rd_vcc_value),
	       .exec_rd_m0_value(exec2simf_rd_m0_value),
	       .exec_rd_scc_value(exec2simf_rd_scc_value),
	       .issue_instr_pc(issue2alu_instr_pc),
	       .rfa_queue_entry_serviced(rfa2simf0_queue_entry_serviced),
	       //  Outputs
	       .vgpr_source1_rd_en(simf0_2vgpr_source1_rd_en),
	       .vgpr_source2_rd_en(simf0_2vgpr_source2_rd_en),
	       .vgpr_source3_rd_en(simf0_2vgpr_source3_rd_en),
	       .vgpr_source1_addr(simf0_2vgpr_source1_addr),
	       .vgpr_source2_addr(simf0_2vgpr_source2_addr),
	       .vgpr_source3_addr(simf0_2vgpr_source3_addr),
	       .vgpr_dest_addr(simf0_2vgpr_dest_addr),
	       .vgpr_dest_data(simf0_2vgpr_dest_data),
	       .vgpr_wr_en(simf0_2vgpr_wr_en),
	       .vgpr_wr_mask(simf0_2vgpr_wr_mask),
	       .exec_rd_wfid(simf0_2exec_rd_wfid),
	       .exec_rd_en(simf0_2exec_rd_en),
	       .exec_wr_vcc_wfid(simf0_2exec_wr_vcc_wfid),
	       .exec_wr_vcc_en(simf0_2exec_wr_vcc_en),
	       .exec_wr_vcc_value(simf0_2exec_wr_vcc_value),
	       .sgpr_rd_en(simf0_2sgpr_rd_en),
	       .sgpr_rd_addr(simf0_2sgpr_rd_addr),
	       .sgpr_wr_addr(simf0_2sgpr_wr_addr),
	       .sgpr_wr_en(simf0_2sgpr_wr_en),
	       .sgpr_wr_data(simf0_2sgpr_wr_data),
	       .sgpr_wr_mask(simf0_2sgpr_wr_mask),
	       .issue_alu_ready(simf0_2issue_alu_ready),
	       .vgpr_instr_done_wfid(simf0_2vgpr_instr_done_wfid),
	       .vgpr_instr_done(simf0_2vgpr_instr_done),
	       .rfa_queue_entry_valid(simf0_2rfa_queue_entry_valid),
	       .tracemon_retire_pc(simf0_2tracemon_retire_pc)
	       );





































































































































































   vgpr vgpr0 (
	      // A set of vector general purpose registers
	      .clk(clk),
	      .rst(rst),
	      //  Inputs

        .rfa_select_fu(vgpr_select_fu),
        .lsu_source1_addr(lsu2vgpr_source1_addr_muxed),
        .lsu_source1_rd_en(lsu2vgpr_source1_rd_en_muxed),
        .lsu_dest_addr(lsu2vgpr_dest_addr_muxed),
	      .lsu_dest_data(lsu2vgpr_dest_data_muxed),
	      .lsu_dest_wr_en(lsu2vgpr_dest_wr_en_muxed),
	      .lsu_dest_wr_mask(lsu2vgpr_dest_wr_mask_muxed),









	       .lsu_source2_addr(lsu2vgpr_source2_addr),
	       .lsu_source2_rd_en(lsu2vgpr_source2_rd_en),
	       .lsu_instr_done_wfid(lsu2vgpr_instr_done_wfid),
	       .lsu_instr_done(lsu2vgpr_instr_done),
	       .simd0_source1_rd_en(simd0_2vgpr_source1_rd_en),
	       .simd1_source1_rd_en(simd1_2vgpr_source1_rd_en),
	       .simd2_source1_rd_en(simd2_2vgpr_source1_rd_en),
	       .simd3_source1_rd_en(simd3_2vgpr_source1_rd_en),
	       .simd0_source2_rd_en(simd0_2vgpr_source2_rd_en),
	       .simd1_source2_rd_en(simd1_2vgpr_source2_rd_en),
	       .simd2_source2_rd_en(simd2_2vgpr_source2_rd_en),
	       .simd3_source2_rd_en(simd3_2vgpr_source2_rd_en),
	       .simd0_source3_rd_en(simd0_2vgpr_source3_rd_en),
	       .simd1_source3_rd_en(simd1_2vgpr_source3_rd_en),
	       .simd2_source3_rd_en(simd2_2vgpr_source3_rd_en),
	       .simd3_source3_rd_en(simd3_2vgpr_source3_rd_en),
	       .simd0_source1_addr(simd0_2vgpr_source1_addr),
	       .simd1_source1_addr(simd1_2vgpr_source1_addr),
	       .simd2_source1_addr(simd2_2vgpr_source1_addr),
	       .simd3_source1_addr(simd3_2vgpr_source1_addr),
	       .simd0_source2_addr(simd0_2vgpr_source2_addr),
	       .simd1_source2_addr(simd1_2vgpr_source2_addr),
	       .simd2_source2_addr(simd2_2vgpr_source2_addr),
	       .simd3_source2_addr(simd3_2vgpr_source2_addr),
	       .simd0_source3_addr(simd0_2vgpr_source3_addr),
	       .simd1_source3_addr(simd1_2vgpr_source3_addr),
	       .simd2_source3_addr(simd2_2vgpr_source3_addr),
	       .simd3_source3_addr(simd3_2vgpr_source3_addr),
	       .simd0_dest_addr(simd0_2vgpr_dest_addr),
	       .simd1_dest_addr(simd1_2vgpr_dest_addr),
	       .simd2_dest_addr(simd2_2vgpr_dest_addr),
	       .simd3_dest_addr(simd3_2vgpr_dest_addr),
	       .simd0_dest_data(simd0_2vgpr_dest_data),
	       .simd1_dest_data(simd1_2vgpr_dest_data),
	       .simd2_dest_data(simd2_2vgpr_dest_data),
	       .simd3_dest_data(simd3_2vgpr_dest_data),
	       .simd0_wr_en(simd0_2vgpr_wr_en),
	       .simd1_wr_en(simd1_2vgpr_wr_en),
	       .simd2_wr_en(simd2_2vgpr_wr_en),
	       .simd3_wr_en(simd3_2vgpr_wr_en),
	       .simd0_wr_mask(simd0_2vgpr_wr_mask),
	       .simd1_wr_mask(simd1_2vgpr_wr_mask),
	       .simd2_wr_mask(simd2_2vgpr_wr_mask),
	       .simd3_wr_mask(simd3_2vgpr_wr_mask),
	       .simf0_source1_rd_en(simf0_2vgpr_source1_rd_en),
	       .simf1_source1_rd_en(simf1_2vgpr_source1_rd_en),
	       .simf2_source1_rd_en(simf2_2vgpr_source1_rd_en),
	       .simf3_source1_rd_en(simf3_2vgpr_source1_rd_en),
	       .simf0_source2_rd_en(simf0_2vgpr_source2_rd_en),
	       .simf1_source2_rd_en(simf1_2vgpr_source2_rd_en),
	       .simf2_source2_rd_en(simf2_2vgpr_source2_rd_en),
	       .simf3_source2_rd_en(simf3_2vgpr_source2_rd_en),
	       .simf0_source3_rd_en(simf0_2vgpr_source3_rd_en),
	       .simf1_source3_rd_en(simf1_2vgpr_source3_rd_en),
	       .simf2_source3_rd_en(simf2_2vgpr_source3_rd_en),
	       .simf3_source3_rd_en(simf3_2vgpr_source3_rd_en),
	       .simf0_source1_addr(simf0_2vgpr_source1_addr),
	       .simf1_source1_addr(simf1_2vgpr_source1_addr),
	       .simf2_source1_addr(simf2_2vgpr_source1_addr),
	       .simf3_source1_addr(simf3_2vgpr_source1_addr),
	       .simf0_source2_addr(simf0_2vgpr_source2_addr),
	       .simf1_source2_addr(simf1_2vgpr_source2_addr),
	       .simf2_source2_addr(simf2_2vgpr_source2_addr),
	       .simf3_source2_addr(simf3_2vgpr_source2_addr),
	       .simf0_source3_addr(simf0_2vgpr_source3_addr),
	       .simf1_source3_addr(simf1_2vgpr_source3_addr),
	       .simf2_source3_addr(simf2_2vgpr_source3_addr),
	       .simf3_source3_addr(simf3_2vgpr_source3_addr),
	       .simf0_dest_addr(simf0_2vgpr_dest_addr),
	       .simf1_dest_addr(simf1_2vgpr_dest_addr),
	       .simf2_dest_addr(simf2_2vgpr_dest_addr),
	       .simf3_dest_addr(simf3_2vgpr_dest_addr),
	       .simf0_dest_data(simf0_2vgpr_dest_data),
	       .simf1_dest_data(simf1_2vgpr_dest_data),
	       .simf2_dest_data(simf2_2vgpr_dest_data),
	       .simf3_dest_data(simf3_2vgpr_dest_data),
	       .simf0_wr_en(simf0_2vgpr_wr_en),
	       .simf1_wr_en(simf1_2vgpr_wr_en),
	       .simf2_wr_en(simf2_2vgpr_wr_en),
	       .simf3_wr_en(simf3_2vgpr_wr_en),
	       .simf0_wr_mask(simf0_2vgpr_wr_mask),
	       .simf1_wr_mask(simf1_2vgpr_wr_mask),
	       .simf2_wr_mask(simf2_2vgpr_wr_mask),
	       .simf3_wr_mask(simf3_2vgpr_wr_mask),
	       .simd0_instr_done_wfid(simd0_2vgpr_instr_done_wfid),
	       .simd1_instr_done_wfid(simd1_2vgpr_instr_done_wfid),
	       .simd2_instr_done_wfid(simd2_2vgpr_instr_done_wfid),
	       .simd3_instr_done_wfid(simd3_2vgpr_instr_done_wfid),
	       .simd0_instr_done(simd0_2vgpr_instr_done),
	       .simd1_instr_done(simd1_2vgpr_instr_done),
	       .simd2_instr_done(simd2_2vgpr_instr_done),
	       .simd3_instr_done(simd3_2vgpr_instr_done),
	       .simf0_instr_done_wfid(simf0_2vgpr_instr_done_wfid),
	       .simf1_instr_done_wfid(simf1_2vgpr_instr_done_wfid),
	       .simf2_instr_done_wfid(simf2_2vgpr_instr_done_wfid),
	       .simf3_instr_done_wfid(simf3_2vgpr_instr_done_wfid),
	       .simf0_instr_done(simf0_2vgpr_instr_done),
	       .simf1_instr_done(simf1_2vgpr_instr_done),
	       .simf2_instr_done(simf2_2vgpr_instr_done),
	       .simf3_instr_done(simf3_2vgpr_instr_done),
	       //  Outputs
	       .simd_source1_data(vgpr2simd_source1_data),
	       .simd_source2_data(vgpr2simd_source2_data),
	       .simd_source3_data(vgpr2simd_source3_data),
	       .simf_source1_data(vgpr2simf_source1_data),
	       .simf_source2_data(vgpr2simf_source2_data),
	       .simf_source3_data(vgpr2simf_source3_data),
	       .lsu_source1_data(vgpr2lsu_source1_data),
	       .lsu_source2_data(vgpr2lsu_source2_data),
	       .issue_alu_wr_done_wfid(vgpr2issue_alu_wr_done_wfid),
	       .issue_alu_wr_done(vgpr2issue_alu_wr_done),
	       .issue_alu_dest_reg_addr(vgpr2issue_alu_dest_reg_addr),
	       .issue_alu_dest_reg_valid(vgpr2issue_alu_dest_reg_valid),
	       .issue_lsu_wr_done_wfid(vgpr2issue_lsu_wr_done_wfid),
	       .issue_lsu_wr_done(vgpr2issue_lsu_wr_done),
	       .issue_lsu_dest_reg_addr(vgpr2issue_lsu_dest_reg_addr),
	       .issue_lsu_dest_reg_valid(vgpr2issue_lsu_dest_reg_valid)
	       );

   wavepool wavepool0 (
		       // Unit that choses wavefronts fetched and keeps control of a instruction queue.
		       .clk(clk),
		       .rst(rst),
		       //  Inputs
		       .fetch_reserve_slotid(fetch2wave_reserve_slotid),
		       .fetch_reserve_valid(fetch2wave_reserve_valid),
		       .fetch_basereg_wr(fetch2wave_basereg_wr),
		       .fetch_basereg_wfid(fetch2wave_basereg_wfid),
		       .fetch_vgpr_base(fetch2wave_vgpr_base),
		       .fetch_sgpr_base(fetch2wave_sgpr_base),
		       .fetch_lds_base(fetch2wave_lds_base),
		       .issue_valid_entries(issue2wave_valid_entries),
		       .buff_tag(buff2wave_tag),
		       .buff_instr(buff2wave_instr),
		       .buff2fetchwave_ack(buff2fetchwave_ack),
		       .issue_wf_done_en(issue2fetchwave_wf_done_en),
		       .issue_wf_done_wf_id(issue2fetchwave_wf_done_wf_id),
		       .salu_branch_wfid(salu2fetchwaveissue_branch_wfid),
		       .salu_branch_en(salu2fetchwaveissue_branch_en),
		       .salu_branch_taken(salu2fetchwaveissue_branch_taken),
		       .decode_ins_half_rqd(decode2wave_ins_half_rqd),
		       .decode_ins_half_wfid(decode2wave_ins_half_wfid),
		       //  Outputs
		       .fetch_stop_fetch(wave2fetch_stop_fetch),
		       .decode_instr_valid(wave2decode_instr_valid),
		       .decode_instr(wave2decode_instr),
		       .decode_wfid(wave2decode_wfid),
		       .decode_vgpr_base(wave2decode_vgpr_base),
		       .decode_sgpr_base(wave2decode_sgpr_base),
		       .decode_lds_base(wave2decode_lds_base),
		       .decode_instr_pc(wave2decode_instr_pc)
		       );

endmodule
module PS_flops_wavepool_decode (
 wave_instr_pc,
 wave_instr_valid,
 wave_instr,
 wave_wfid,
 wave_vgpr_base,
 wave_sgpr_base,
 wave_lds_base,
 flopped_instr_pc,
 flopped_instr_valid,
 flopped_instr,
 flopped_wfid,
 flopped_vgpr_base,
 flopped_sgpr_base,
 flopped_lds_base,
 clk,
 rst
);

input clk;
input rst;

input [31:0] wave_instr_pc;
input wave_instr_valid;
input [31:0] wave_instr;
input [5:0] wave_wfid;
input [9:0] wave_vgpr_base;
input [8:0] wave_sgpr_base;
input [15:0] wave_lds_base;

output [31:0] flopped_instr_pc;
output flopped_instr_valid;
output [31:0] flopped_instr;
output [5:0] flopped_wfid;
output [9:0] flopped_vgpr_base;
output [8:0] flopped_sgpr_base;
output [15:0] flopped_lds_base;

dff flop_instr_pc [31:0] (.q(flopped_instr_pc), .d(wave_instr_pc), .clk(clk), .rst(rst));
dff flop_instr_valid (.q(flopped_instr_valid), .d(wave_instr_valid), .clk(clk), .rst(rst));
dff flop_instr [31:0] (.q(flopped_instr), .d(wave_instr), .clk(clk), .rst(rst));
dff flop_wfid [5:0] (.q(flopped_wfid), .d(wave_wfid), .clk(clk), .rst(rst));
dff flop_vgpr_base [9:0] (.q(flopped_vgpr_base), .d(wave_vgpr_base), .clk(clk), .rst(rst));
dff flop_sgpr_base [8:0] (.q(flopped_sgpr_base), .d(wave_sgpr_base), .clk(clk), .rst(rst));
dff flop_lds_base [15:0] (.q(flopped_lds_base), .d(wave_lds_base), .clk(clk), .rst(rst));

endmodule









//VIN


//`define EXT_LIT_128 10'b1010000000 // 128 - INT 0
//`define EXT_LIT_242 10'b1011110010 // 242 - FP 1.0

module decode( 
      wave_instr_pc,
      wave_instr_valid,
      wave_instr,
      wave_wfid,
      wave_vgpr_base,
      wave_sgpr_base,
      wave_lds_base,
      issue_wf_halt,
      issue_fu,
      issue_wfid,
      issue_opcode,
      issue_source_reg1,
      issue_source_reg2,
      issue_source_reg3,
      issue_source_reg4,
      issue_dest_reg1,
      issue_dest_reg2,
      issue_imm_value0,
      issue_imm_value1,
      issue_valid,
      issue_instr_pc,
      issue_vcc_wr,
      issue_vcc_rd,
      issue_scc_wr,
      issue_scc_rd,
      issue_exec_rd,
      issue_exec_wr,
      issue_m0_rd,
      issue_m0_wr,
      issue_barrier,
      issue_branch,
      issue_lds_base,
      issue_waitcnt,
      wave_ins_half_rqd,
      wave_ins_half_wfid,
      tracemon_collinstr,
      tracemon_colldone,
      clk,
      rst
 );

input clk;

input rst;

input wave_instr_valid;
input[5:0] wave_wfid;
input[8:0] wave_sgpr_base;
input[9:0] wave_vgpr_base;
input[15:0] wave_lds_base;
input[31:0] wave_instr_pc, wave_instr;

output issue_wf_halt, issue_valid, issue_vcc_wr, issue_vcc_rd, issue_scc_wr,
         issue_scc_rd, issue_exec_rd, issue_exec_wr, issue_m0_rd, issue_m0_wr,
         issue_barrier, issue_branch, issue_waitcnt, wave_ins_half_rqd, tracemon_colldone;
output[1:0] issue_fu;
output[5:0] issue_wfid, wave_ins_half_wfid;
output[15:0] issue_lds_base;
output[12:0] issue_source_reg2, issue_source_reg3, issue_dest_reg2;
output[13:0] issue_source_reg1, issue_source_reg4, issue_dest_reg1;
output[15:0] issue_imm_value0;
output[31:0] issue_opcode, issue_imm_value1, issue_instr_pc;
output[63:0] tracemon_collinstr;

///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////


wire [31:0] flopped_instr_pc;
wire flopped_instr_valid;
wire [31:0] flopped_instr;
wire [5:0] flopped_wfid;
wire [9:0] flopped_vgpr_base;
wire [8:0] flopped_sgpr_base;
wire [15:0] flopped_lds_base;

//////////////////////////////
wire [63:0] collated_instr;
wire collate_required;
wire collate_done;

wire [9:0] s1_field;
wire [9:0] s2_field;
wire [9:0] s3_field;
wire [9:0] s4_field;
wire [9:0] dest1_field;
wire [9:0] dest2_field;
wire [9:0] dest1_field_converted;
wire [9:0] s4_field_converted;
wire [9:0] s3_field_converted;
wire [9:0] s1_field_converted;

wire [1:0] raw_fu;

wire implicit_scc_write;
wire implicit_scc_read;
wire implicit_vcc_write;
wire implicit_vcc_read;
wire implicit_exec_write;
wire implicit_exec_read;
wire implicit_M0_write;
wire implicit_M0_read;

wire [2:0] s1_width;
wire [2:0] s2_width;
wire [2:0] s3_width;
wire [2:0] s4_width;
wire [2:0] dest1_width;
wire [2:0] dest2_width;
wire fp_instr;
wire copy_d1_to_s4;
wire copy_d1_to_s3;
wire copy_d1_to_s1;
wire d1_vdst_to_sdst;

wire [11:0] encoded_s1_reg;
wire [11:0] encoded_s2_reg;
wire [11:0] encoded_s3_reg;
wire [11:0] encoded_s4_reg;
wire [11:0] encoded_dest1_reg;
wire [11:0] encoded_dest2_reg;

assign issue_lds_base = flopped_lds_base;
assign issue_wfid = flopped_wfid;

wire s1_literal_req;
wire s2_literal_req;
wire s3_literal_req;
wire s4_literal_req;
//Following two wires are dummies
wire dest1_literal_req;
wire dest2_literal_req;

wire s1_explicit_vcc;
wire s2_explicit_vcc;
wire s3_explicit_vcc;
wire s4_explicit_vcc;
wire dest1_explicit_vcc;
wire dest2_explicit_vcc;

wire s1_explicit_exec;
wire s2_explicit_exec;
wire s3_explicit_exec;
wire s4_explicit_exec;
wire dest1_explicit_exec;
wire dest2_explicit_exec;

wire s1_explicit_scc;
wire s2_explicit_scc;
wire s3_explicit_scc;
wire s4_explicit_scc;
wire dest1_explicit_scc;
wire dest2_explicit_scc;

wire s1_explicit_M0;
wire s2_explicit_M0;
wire s3_explicit_M0;
wire s4_explicit_M0;
wire dest1_explicit_M0;
wire dest2_explicit_M0;

wire ext_literal_s3; //VIN

wire long_instr_or_literal_required;
wire [31:0] imm1_frominstr_fromliteral;
reg [31:0] issue_imm_value1;
wire [9:0] s3_field_const; //VIN


wire [32:0] s1_fp_constant;
wire [32:0] s2_fp_constant;
wire [32:0] s3_fp_constant;
wire [32:0] s4_fp_constant;
wire [32:0] dest1_fp_constant;
wire [32:0] dest2_fp_constant;

wire width_qualified_s1_valid;
wire width_qualified_s2_valid;
wire width_qualified_s3_valid;
wire width_qualified_s4_valid;
wire width_qualified_dest1_valid;
wire width_qualified_dest2_valid;

PS_flops_wavepool_decode stage_flops (
  .wave_instr_pc(wave_instr_pc),
  .wave_instr_valid(wave_instr_valid),
  .wave_instr(wave_instr),
  .wave_wfid(wave_wfid),
  .wave_vgpr_base(wave_vgpr_base),
  .wave_sgpr_base(wave_sgpr_base),
  .wave_lds_base(wave_lds_base),
  .flopped_instr_pc(flopped_instr_pc),
  .flopped_instr_valid(flopped_instr_valid),
  .flopped_instr(flopped_instr),
  .flopped_wfid(flopped_wfid),
  .flopped_vgpr_base(flopped_vgpr_base),
  .flopped_sgpr_base(flopped_sgpr_base),
  .flopped_lds_base(flopped_lds_base),
  .clk(clk),
  .rst(rst)
);

assign long_instr_or_literal_required = collate_required | ((~collate_done) & ( ext_literal_s3|s1_literal_req|s2_literal_req|s3_literal_req|s4_literal_req));

instr_collate collater(
  .in_wfid(flopped_wfid),
  .in_instr(flopped_instr),
  .in_valid(flopped_instr_valid),
  .in_pc(flopped_instr_pc),
  .out_instr(collated_instr),
  .out_valid(issue_valid),
  .out_pc(issue_instr_pc),
  .in_long(long_instr_or_literal_required),
  .out_long(collate_done),
  .clk(clk),
  .rst(rst)
);

decode_core core(
  .collated_instr(collated_instr),
  .collate_done(collate_done),
  .collate_required(collate_required),
  .fu(raw_fu),
  .opcode(issue_opcode),
  .imm_value0(issue_imm_value0),
  .imm_value1(imm1_frominstr_fromliteral),
  .s1_field(s1_field),
  .s2_field(s2_field),
  .s3_field(s3_field),
  .s4_field(s4_field),
  .dest1_field(dest1_field),
  .dest2_field(dest2_field)
);

flag_generator flaggen(
  .opcode(issue_opcode),
  .fu(raw_fu),
  .wf_halt(issue_wf_halt),
  .wf_barrier(issue_barrier),
  .wf_branch(issue_branch),
  .wf_waitcnt(issue_waitcnt),
  .scc_write(implicit_scc_write),
  .scc_read(implicit_scc_read),
  .vcc_write(implicit_vcc_write),
  .vcc_read(implicit_vcc_read),
  .exec_write(implicit_exec_write),
  .exec_read(implicit_exec_read),
  .M0_write(implicit_M0_write),
  .M0_read(implicit_M0_read),
  .s1_width(s1_width),
  .s2_width(s2_width),
  .s3_width(s3_width),
  .s4_width(s4_width),
  .dest1_width(dest1_width),
  .dest2_width(dest2_width),
  .fp_instr(fp_instr),
  .copy_d1_to_s4(copy_d1_to_s4),
	.copy_d1_to_s3(copy_d1_to_s3),
  .copy_d1_to_s1(copy_d1_to_s1),
	.ext_literal_s3(ext_literal_s3),
  .d1_vdst_to_sdst(d1_vdst_to_sdst)
);

reg_field_encoder s1_encoder (
  .in(s1_field_converted),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_s1_reg),
  .literal_required(s1_literal_req),
  .explicit_vcc(s1_explicit_vcc),
  .explicit_exec(s1_explicit_exec),
  .explicit_scc(s1_explicit_scc),
  .explicit_M0(s1_explicit_M0),
  .fp_constant(s1_fp_constant)
);
reg_field_encoder s2_encoder (
  .in(s2_field),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_s2_reg),
  .literal_required(s2_literal_req),
  .explicit_vcc(s2_explicit_vcc),
  .explicit_exec(s2_explicit_exec),
  .explicit_scc(s2_explicit_scc),
  .explicit_M0(s2_explicit_M0),
  .fp_constant(s2_fp_constant)
);
reg_field_encoder s3_encoder (
  .in(s3_field_converted),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_s3_reg),
  .literal_required(s3_literal_req),
  .explicit_vcc(s3_explicit_vcc),
  .explicit_exec(s3_explicit_exec),
  .explicit_scc(s3_explicit_scc),
  .explicit_M0(s3_explicit_M0),
  .fp_constant(s3_fp_constant)
);
reg_field_encoder s4_encoder (
  .in(s4_field_converted),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_s4_reg),
  .literal_required(s4_literal_req),
  .explicit_vcc(s4_explicit_vcc),
  .explicit_exec(s4_explicit_exec),
  .explicit_scc(s4_explicit_scc),
  .explicit_M0(s4_explicit_M0),
  .fp_constant(s4_fp_constant)
);
reg_field_encoder dest1_encoder (
  .in(dest1_field_converted),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_dest1_reg),
  .literal_required(dest1_literal_req),
  .explicit_vcc(dest1_explicit_vcc),
  .explicit_exec(dest1_explicit_exec),
  .explicit_scc(dest1_explicit_scc),
  .explicit_M0(dest1_explicit_M0),
  .fp_constant(dest1_fp_constant)
);
reg_field_encoder dest2_encoder (
  .in(dest2_field),
  .sgpr_base(flopped_sgpr_base),
  .vgpr_base(flopped_vgpr_base),
  .out(encoded_dest2_reg),
  .literal_required(dest2_literal_req),
  .explicit_vcc(dest2_explicit_vcc),
  .explicit_exec(dest2_explicit_exec),
  .explicit_scc(dest2_explicit_scc),
  .explicit_M0(dest2_explicit_M0),
  .fp_constant(dest2_fp_constant)
);

assign issue_vcc_wr = implicit_vcc_write | dest1_explicit_vcc | dest2_explicit_vcc;
assign issue_vcc_rd = implicit_vcc_read | s1_explicit_vcc | s2_explicit_vcc | s3_explicit_vcc | s4_explicit_vcc;
assign issue_scc_wr = implicit_scc_write | dest1_explicit_scc | dest2_explicit_scc;
assign issue_scc_rd = implicit_scc_read | s1_explicit_scc | s2_explicit_scc | s3_explicit_scc | s4_explicit_scc;
assign issue_exec_wr = implicit_exec_write | dest1_explicit_exec | dest2_explicit_exec;
assign issue_exec_rd = implicit_exec_read | s1_explicit_exec | s2_explicit_exec | s3_explicit_exec | s4_explicit_exec;
assign issue_m0_wr = implicit_M0_write | dest1_explicit_M0 | dest2_explicit_M0;
assign issue_m0_rd = implicit_M0_read | s1_explicit_M0 | s2_explicit_M0 | s3_explicit_M0 | s4_explicit_M0;

assign dest1_field_converted = d1_vdst_to_sdst ? {dest1_field[9],2'b0,dest1_field[6:0]} : dest1_field;
assign s4_field_converted = copy_d1_to_s4 ? dest1_field : s4_field;
assign s1_field_converted = copy_d1_to_s1 ? dest1_field : s1_field;

/* VIN */
assign s3_field_const = ext_literal_s3 ? 10'b1011111111 : s3_field;
/* VIN */

/*
always@(s3_field or ext_literal_s3)
begin
	casex(ext_literal_s3)
		2'b00 : s3_field_const <= s3_field;
		2'b01 : s3_field_const <= `EXT_LIT_128;
		2'b10 : s3_field_const <= `EXT_LIT_242;
		2'b11 : s3_field_const <= `EXT_LIT_255;
		default : s3_field_const <= s3_field;
	endcase
end
*/

assign s3_field_converted = copy_d1_to_s3 ? dest1_field : s3_field_const; // VIN
assign issue_fu = fp_instr ? 2'b0 : raw_fu;

assign width_qualified_s1_valid = (s1_width == 3'b111) ? 1'b0 : encoded_s1_reg[11];
assign width_qualified_s2_valid = (s2_width == 3'b111) ? 1'b0 : encoded_s2_reg[11];
assign width_qualified_s3_valid = (s3_width == 3'b111) ? 1'b0 : encoded_s3_reg[11];
assign width_qualified_s4_valid = (s4_width == 3'b111) ? 1'b0 : encoded_s4_reg[11];
assign width_qualified_dest1_valid = (dest1_width == 3'b111) ? 1'b0 : encoded_dest1_reg[11];
assign width_qualified_dest2_valid = (dest2_width == 3'b111) ? 1'b0 : encoded_dest2_reg[11];

assign issue_source_reg1 = {s1_width[1:0],width_qualified_s1_valid,encoded_s1_reg[10:0]};
assign issue_source_reg2 = {s2_width[0],width_qualified_s2_valid,encoded_s2_reg[10:0]};
assign issue_source_reg3 = {s3_width[0],width_qualified_s3_valid,encoded_s3_reg[10:0]};
assign issue_source_reg4 = {s4_width[1:0],width_qualified_s4_valid,encoded_s4_reg[10:0]};
assign issue_dest_reg1 = {dest1_width[1:0],width_qualified_dest1_valid,encoded_dest1_reg[10:0]};
assign issue_dest_reg2 = {dest2_width[0],width_qualified_dest2_valid,encoded_dest2_reg[10:0]};

//wire [2:0] qualified_width_s1;
//wire [2:0] qualified_width_s2;
//wire [2:0] qualified_width_s3;
//wire [2:0] qualified_width_s4;
//wire [2:0] qualified_width_dest1;
//wire [2:0] qualified_width_dest2;
//assign qualified_width_s1 = width_qualified_s1_valid ? s1_width : 3'b000;
//assign qualified_width_s2 = width_qualified_s2_valid ? s2_width : 3'b000;
//assign qualified_width_s3 = width_qualified_s3_valid ? s3_width : 3'b000;
//assign qualified_width_s4 = width_qualified_s4_valid ? s4_width : 3'b000;
//assign qualified_width_dest1 = width_qualified_dest1_valid ? dest1_width : 3'b000;
//assign qualified_width_dest2 = width_qualified_dest2_valid ? dest2_width : 3'b000;
//assign issue_source_reg1 = {qualified_width_s1[1:0],width_qualified_s1_valid,encoded_s1_reg[10:0]};
//assign issue_source_reg2 = {qualified_width_s2[0],width_qualified_s2_valid,encoded_s2_reg[10:0]};
//assign issue_source_reg3 = {qualified_width_s3[0],width_qualified_s3_valid,encoded_s3_reg[10:0]};
//assign issue_source_reg4 = {qualified_width_s4[1:0],width_qualified_s4_valid,encoded_s4_reg[10:0]};
//assign issue_dest_reg1 = {qualified_width_dest1[1:0],width_qualified_dest1_valid,encoded_dest1_reg[10:0]};
//assign issue_dest_reg2 = {qualified_width_dest2[0],width_qualified_dest2_valid,encoded_dest2_reg[10:0]};

assign wave_ins_half_wfid = flopped_wfid;
assign wave_ins_half_rqd = long_instr_or_literal_required & flopped_instr_valid;

assign tracemon_collinstr =  collated_instr;
assign tracemon_colldone = collate_done;

always @(s1_fp_constant or s2_fp_constant or s3_fp_constant or s4_fp_constant or imm1_frominstr_fromliteral)
begin
  casex({s1_fp_constant,s2_fp_constant,s3_fp_constant,s4_fp_constant})
    4'b0000:
      begin
        issue_imm_value1 <= imm1_frominstr_fromliteral;
      end
    4'b0001:
      begin
        issue_imm_value1 <= s4_fp_constant[31:0];
      end
    4'b0010:
      begin
        issue_imm_value1 <= s3_fp_constant[31:0];
      end
    4'b0100:
      begin
        issue_imm_value1 <= s2_fp_constant[31:0];
      end
    4'b1000:
      begin
        issue_imm_value1 <= s1_fp_constant[31:0];
      end
    default:
      begin
        issue_imm_value1 <= {32{1'bx}};
      end
  endcase
end

endmodule



module decode_core(
 collated_instr,
 collate_done,
 collate_required,
 fu,
 opcode,
 imm_value0,
 imm_value1,
 s1_field,
 s2_field,
 s3_field,
 s4_field,
 dest1_field,
 dest2_field
);

input [63:0] collated_instr;
input collate_done;

output collate_required;
output [1:0] fu;
output [31:0] opcode;
output [15:0] imm_value0;
output [31:0] imm_value1;
output [9:0] s1_field;
output [9:0] s2_field;
output [9:0] s3_field;
output [9:0] s4_field;
output [9:0] dest1_field;
output [9:0] dest2_field;

reg collate_required;
reg wf_halt;
reg wf_barrier;
reg wf_branch;
reg [1:0] fu;
reg [31:0] opcode;
reg [15:0] imm_value0;
reg [31:0] imm_value1;
reg scc_write;
reg scc_read;
reg vcc_write;
reg vcc_read;
reg exec_read;
reg [9:0] s1_field;
reg [9:0] s2_field;
reg [9:0] s3_field;
reg [9:0] s4_field;
reg [9:0] dest1_field;
reg [9:0] dest2_field;

always @(collated_instr or collate_done)
begin
  casex(collated_instr[31:0]) //for 64bit instructions lower word is decoded
    //SOPP
    32'b1011_1111_1???_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b10;
        opcode[31:24] <= 8'd1;
        opcode[23:0] <= {17'b0,collated_instr[22:16]};
        imm_value0 <= collated_instr[15:0];
        imm_value1 <= {32{1'bx}};
        s1_field <= {1'b0,{9{1'bx}}};
        s2_field <= {1'b0,{9{1'bx}}};
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b0,{9{1'bx}}};
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //SOP1
    32'b1011_1110_1???_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b10;
        opcode[31:24] <= 8'd2;
        opcode[23:0] <= {16'b0,collated_instr[15:8]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,1'b0,collated_instr[7:0]}; //SSRC8
        s2_field <= {1'b0,{9{1'bx}}};
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,2'b0,collated_instr[22:16]}; //SDST7
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //SOPC
    32'b1011_1111_0???_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b10;
        opcode[31:24] <= 8'd4;
        opcode[23:0] <= {17'b0,collated_instr[22:16]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,1'b0,collated_instr[7:0]}; //SSRC8
        s2_field <= {1'b1,1'b0,collated_instr[15:8]}; //SSRC8
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b0,{9{1'bx}}};
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //SOPK
    32'b1011_????_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b10;
        opcode[31:24] <= 8'd16;
        opcode[23:0] <= {19'b0,collated_instr[27:23]};
        imm_value0 <= collated_instr[15:0];
        imm_value1 <= {32{1'bx}};
        s1_field <= {1'b0,{9{1'bx}}};
        s2_field <= {1'b0,{9{1'bx}}};
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,2'b0,collated_instr[22:16]}; //SDST7
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //SOP2
    32'b10??_????_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b10;
        opcode[31:24] <= 8'd8;
        opcode[23:0] <= {17'b0,collated_instr[29:23]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,1'b0,collated_instr[7:0]}; //SSRC8
        s2_field <= {1'b1,1'b0,collated_instr[15:8]}; //SSRC8
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,2'b0,collated_instr[22:16]}; //SDST7
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //Vector formats
    //VOPC
    32'b0111_110?_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b01;
        opcode[31:24] <= 8'd1;
        opcode[23:0] <= {16'b0,collated_instr[24:17]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,collated_instr[8:0]}; //SRC9
        s2_field <= {1'b1,1'b1,collated_instr[16:9]}; //VSRC8
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b0,{9{1'bx}}};
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //VOP1
    32'b0111_111?_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b01;
        opcode[31:24] <= 8'd2;
        opcode[23:0] <= {16'b0,collated_instr[16:9]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,collated_instr[8:0]}; //SRC9
        s2_field <= {1'b0,{9{1'bx}}};
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,1'b1,collated_instr[24:17]}; //VDST8
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //VOP2
    32'b0???_????_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b01;
        opcode[31:24] <= 8'd4;
        opcode[23:0] <= {18'b0,collated_instr[30:25]};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= {1'b1,collated_instr[8:0]}; //SRC9
        s2_field <= {1'b1,1'b1,collated_instr[16:9]}; //VSRC8
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,1'b1,collated_instr[24:17]}; //VDST8
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //VOP3a and VOP3b
    32'b1101_00??_????_????_????_????_????_????:
      begin
        casex(collate_done)
          //Only first word available
          1'b0:
            begin
              collate_required <= 1'b1;
              fu <= 2'b0; //Unused fu
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {1'b0,{9{1'bx}}};
              s2_field <= {1'b0,{9{1'bx}}};
              s3_field <= {1'b0,{9{1'bx}}};
              s4_field <= {1'b0,{9{1'bx}}};
              dest1_field <= {1'b0,{9{1'bx}}};
              dest2_field <= {1'b0,{9{1'bx}}};
            end
           //Both words are available
           1'b1:
             begin
               //VOP3b
               if((collated_instr[25:17] >= 9'h125) && (collated_instr[25:17] <= 9'h12a))
                 begin
                   collate_required <= 1'b0;
                   fu <= 2'b01;
                   opcode[31:24] <= 8'd8;
                   opcode[23:0] <= {collated_instr[63:59],10'b0,collated_instr[25:17]};
                   imm_value0 <= {16{1'bx}};
                   imm_value1 <= {32{1'bx}};
                   s1_field <= {1'b1,collated_instr[40:32]}; //SRC9
                   s2_field <= {1'b1,collated_instr[49:41]}; //SRC9
                   s3_field <= {1'b1,collated_instr[58:50]}; //SRC9
                   s4_field <= {1'b0,{9{1'bx}}};
                   dest1_field <= {1'b1,1'b1,collated_instr[7:0]}; //VDST8
                   dest2_field <= {1'b1,2'b0,collated_instr[14:8]}; //SDST7
                 end
               //VOP3a
               else
                 begin
                   collate_required <= 1'b0;
                   fu <= 2'b01;
                   opcode[31:24] <= 8'd16;
                   opcode[23:0] <= {collated_instr[63:59],collated_instr[11:8],6'b0,collated_instr[25:17]};
                   imm_value0 <= {16{1'bx}};
                   imm_value1 <= {32{1'bx}};
                   s1_field <= {1'b1,collated_instr[40:32]}; //SRC9
                   s2_field <= {1'b1,collated_instr[49:41]}; //SRC9
                   s3_field <= {1'b1,collated_instr[58:50]}; //SRC9
                   s4_field <= {1'b0,{9{1'bx}}};
                   dest1_field <= {1'b1,1'b1,collated_instr[7:0]}; //VDST8
                   dest2_field <= {1'b0,{9{1'bx}}};
                 end
             end
           //Error Condition
           default:
             begin
              collate_required <= 1'bx;
              fu <= {2{1'bx}};
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {10{1'bx}};
              s2_field <= {10{1'bx}};
              s3_field <= {10{1'bx}};
              s4_field <= {10{1'bx}};
              dest1_field <= {10{1'bx}};
              dest2_field <= {10{1'bx}};
             end
        endcase
      end
    //SMRD
    32'b1100_0???_????_????_????_????_????_????:
      begin
        collate_required <= 1'b0;
        fu <= 2'b11;
        opcode[31:24] <= 8'd1;
        opcode[23:0] <= {collated_instr[8],18'b0,collated_instr[26:22]};
        imm_value0 <= collated_instr[8] ? {8'b0,collated_instr[7:0]} : {16{1'bx}}; //OFFSET8 if IMM=1
        imm_value1 <= collate_done ? collated_instr[63:32] : {32{1'bx}};
        s1_field <= collated_instr[8] ? {1'b0,{9{1'bx}}} : {1'b1,1'b0,collated_instr[7:0]}; //OFFSET8 if IMM=0
        s2_field <= {1'b1,2'b0,collated_instr[14:9],1'b0}; //SBASE6
        s3_field <= {1'b0,{9{1'bx}}};
        s4_field <= {1'b0,{9{1'bx}}};
        dest1_field <= {1'b1,2'b0,collated_instr[21:15]}; //SDST7
        dest2_field <= {1'b0,{9{1'bx}}};
      end
    //LDS/GDS
    32'b1101_10??_????_????_????_????_????_????:
      begin
        casex(collate_done)
          //Only first word available
          1'b0:
            begin
              collate_required <= 1'b1;
              fu <= 2'b0; //Unused fu
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {1'b0,{9{1'bx}}};
              s2_field <= {1'b0,{9{1'bx}}};
              s3_field <= {1'b0,{9{1'bx}}};
              s4_field <= {1'b0,{9{1'bx}}};
              dest1_field <= {1'b0,{9{1'bx}}};
              dest2_field <= {1'b0,{9{1'bx}}};
            end
           //Both words are available
           1'b1:
             begin
               collate_required <= 1'b0;
               fu <= 2'b11;
               opcode[31:24] <= 8'd2;
               opcode[23:0] <= {collated_instr[17],15'b0,collated_instr[25:18]};
               imm_value0 <= collated_instr[7:0];
               imm_value1 <= collated_instr[15:8];
               s1_field <= {1'b1,1'b1,collated_instr[39:32]}; //ADDR8 (only VGPR)
               s2_field <= {1'b1,1'b1,collated_instr[47:40]}; //DATA0 (only VGPR)
               s3_field <= {1'b1,1'b1,collated_instr[55:48]}; //DATA1 (only VGPR)
               s4_field <= {1'b0,{9{1'bx}}};
               dest1_field <= {1'b1,1'b1,collated_instr[63:56]}; //VDST8
               dest2_field <= {1'b0,{9{1'bx}}};
             end
           //Error Condition
           default:
             begin
              collate_required <= 1'bx;
              fu <= {2{1'bx}};
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {10{1'bx}};
              s2_field <= {10{1'bx}};
              s3_field <= {10{1'bx}};
              s4_field <= {10{1'bx}};
              dest1_field <= {10{1'bx}};
              dest2_field <= {10{1'bx}};
             end
        endcase
      end
    //MTBUF
    32'b1110_10??_????_????_????_????_????_????:
      begin
        casex(collate_done)
          //Only first word available
          1'b0:
            begin
              collate_required <= 1'b1;
              fu <= 2'b0; //Unused fu
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {1'b0,{9{1'bx}}};
              s2_field <= {1'b0,{9{1'bx}}};
              s3_field <= {1'b0,{9{1'bx}}};
              s4_field <= {1'b0,{9{1'bx}}};
              dest1_field <= {1'b0,{9{1'bx}}};
              dest2_field <= {1'b0,{9{1'bx}}};
            end
           //Both words are available
           1'b1:
             begin
               collate_required <= 1'b0;
               fu <= 2'b11;
               opcode[31:24] <= 8'd4;
               opcode[23:0] <= {collated_instr[55:54],collated_instr[25:19],collated_instr[15:12],8'b0,collated_instr[18:16]};
               imm_value0 <= {4'd0,collated_instr[11:0]}; //The ISA does not suggest this offset to be optional.
               imm_value1 <= {24'd0,collated_instr[63:56]};
               s1_field <= {1'b1,1'b0,collated_instr[63:56]}; //SOFFSET8
               s2_field <= {1'b1,1'b1,collated_instr[47:40]}; //VDATA8 if store
               s3_field <= {1'b1,1'b1,collated_instr[39:32]}; //VADDR8
               s4_field <= {1'b1,2'b0,collated_instr[52:48],2'b0}; //SRSRC5
               dest1_field <= {1'b1,1'b1,collated_instr[47:40]}; //VDATA8 if load
               dest2_field <= {1'b0,{9{1'bx}}};
             end
           //Error Condition
           default:
             begin
              collate_required <= 1'bx;
              fu <= {2{1'bx}};
              opcode[31:24] <= {8{1'bx}};
              opcode[23:0] <= {24{1'bx}};
              imm_value0 <= {16{1'bx}};
              imm_value1 <= {32{1'bx}};
              s1_field <= {10{1'bx}};
              s2_field <= {10{1'bx}};
              s3_field <= {10{1'bx}};
              s4_field <= {10{1'bx}};
              dest1_field <= {10{1'bx}};
              dest2_field <= {10{1'bx}};
             end
        endcase
      end
    //Error condition
    default:
      begin
        collate_required <= 1'bx;
        fu <= {2{1'bx}};
        opcode[31:24] <= {8{1'bx}};
        opcode[23:0] <= {24{1'bx}};
        imm_value0 <= {16{1'bx}};
        imm_value1 <= {32{1'bx}};
        s1_field <= {10{1'bx}};
        s2_field <= {10{1'bx}};
        s3_field <= {10{1'bx}};
        s4_field <= {10{1'bx}};
        dest1_field <= {10{1'bx}};
        dest2_field <= {10{1'bx}};
      end
  endcase
end

endmodule
module flag_generator(
  opcode,
  fu,
  wf_halt,
  wf_barrier,
  wf_branch,
  wf_waitcnt,
  scc_write,
  scc_read,
  vcc_write,
  vcc_read,
  exec_write,
  exec_read,
  M0_write,
  M0_read,
  s1_width,
  s2_width,
  s3_width,
  s4_width,
  dest1_width,
  dest2_width,
  fp_instr,
  copy_d1_to_s4,
  copy_d1_to_s3,
  copy_d1_to_s1,
  ext_literal_s3,
  d1_vdst_to_sdst
);

input [31:0] opcode;
input [1:0] fu;

output wf_halt;
output wf_barrier;
output wf_branch;
output wf_waitcnt;
output scc_write;
output scc_read;
output vcc_write;
output vcc_read;
output exec_write;
output exec_read;
output M0_write;
output M0_read;
output [2:0] s1_width;
output [2:0] s2_width;
output [2:0] s3_width;
output [2:0] s4_width;
output [2:0] dest1_width;
output [2:0] dest2_width;
output fp_instr;
output copy_d1_to_s4;
output copy_d1_to_s3;
output copy_d1_to_s1;
output ext_literal_s3;
output d1_vdst_to_sdst;

reg wf_halt;
reg wf_barrier;
reg wf_branch;
reg wf_waitcnt;
reg scc_write;
reg scc_read;
reg vcc_write;
reg vcc_read;
reg exec_write;
reg exec_read;
reg M0_write;
reg M0_read;
reg [2:0] s1_width;
reg [2:0] s2_width;
reg [2:0] s3_width;
reg [2:0] s4_width;
reg [2:0] dest1_width;
reg [2:0] dest2_width;
reg fp_instr;
reg copy_d1_to_s4;
reg copy_d1_to_s3;
reg copy_d1_to_s1;
reg ext_literal_s3;
reg d1_vdst_to_sdst;

wire [33:0] instruction_id;

//Opcode
//Bits 31:24 should be retained
//Out of 23:0, atleast 13 higher bits should be masked
//             (MTBUF with 13 flag bits)
//Out of 23:0, atleast 9 bits should be retained
//             (longest operand is 9 bits)
//Current choice: Retain only 9 bits!!
assign instruction_id = {fu,opcode} & {2'b11,8'hff,15'b0,{9{1'b1}}};

always @(instruction_id)
begin
  wf_halt <= 1'b0;
  wf_barrier <= 1'b0;
  wf_branch <= 1'b0;
  wf_waitcnt <= 1'b0;
  scc_write <= 1'b0;
  scc_read <= 1'b0;
  vcc_write <= 1'b0;
  vcc_read <= 1'b0;
  exec_write <= 1'b0;
  exec_read <= 1'b0;
  M0_write <= 1'b0;
  M0_read <= 1'b0;
  s1_width <= 3'b111;
  s2_width <= 3'b111;
  s3_width <= 3'b111;
  s4_width <= 3'b111;
  dest1_width <= 3'b111;
  dest2_width <= 3'b111;
  fp_instr <= 1'b0;
  copy_d1_to_s4 <= 1'b0;
  copy_d1_to_s3 <= 1'b0;
  copy_d1_to_s1 <= 1'b0;
  d1_vdst_to_sdst <= 1'b0;
  ext_literal_s3 <= 1'b0;
  casex(instruction_id)
    //SOPP --------------------------------------------
    //SOPP: S_NOP
    {2'b10,8'd1,24'h0}:
      begin
      end
    //SOPP: S_ENDPGM
    {2'b10,8'd1,24'h1}:
      begin
        wf_halt <= 1'b1;
      end
    //SOPP: S_BRANCH
    {2'b10,8'd1,24'h2}:
      begin
        wf_branch <= 1'b1;
      end
    //SOPP: S_CBRANCH_SCC0
    {2'b10,8'd1,24'h4}:
      begin
        wf_branch <= 1'b1;
        scc_read <= 1'b1;
      end
    //SOPP: S_CBRANCH_SCC1
    {2'b10,8'd1,24'h5}:
      begin
        wf_branch <= 1'b1;
        scc_read <= 1'b1;
      end
    //SOPP: S_CBRANCH_VCCZ
    {2'b10,8'd1,24'h6}:
      begin
        wf_branch <= 1'b1;
        vcc_read <= 1'b1;
      end
    //SOPP: S_CBRANCH_VCCNZ
    {2'b10,8'd1,24'h7}:
      begin
        wf_branch <= 1'b1;
        vcc_read <= 1'b1;
      end
    //SOPP: S_CBRANCH_EXECZ
    {2'b10,8'd1,24'h8}:
      begin
        wf_branch <= 1'b1;
        exec_read <= 1'b1;
      end
    //SOPP: S_CBRANCH_EXECNZ
    {2'b10,8'd1,24'h9}:
      begin
        wf_branch <= 1'b1;
        exec_read <= 1'b1;
      end
    //SOPP: S_BARRIER
    {2'b10,8'd1,24'ha}:
      begin
        wf_barrier <= 1'b1;
      end
    //SOPP: S_WAITCNT
    {2'b10,8'd1,24'hc}:
      begin
        wf_waitcnt <= 1'b1;
      end
    //SOP1 --------------------------------------------
    //SOP1: S_MOV_B32
    {2'b10,8'd2,24'h3}:
      begin
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP1: S_MOV_B64
    {2'b10,8'd2,24'h4}:
      begin
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_CMOV_B32
    {2'b10,8'd2,24'h5}:
      begin
       scc_read <= 1'b1;
       s1_width <= 3'b000;
       dest1_width <= 3'b000;
      end
    //SOP1: S_NOT_B32
    {2'b10,8'd2,24'h7}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP1: S_NOT_B64
    {2'b10,8'd2,24'h8}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_BREV_B32
    {2'b10,8'd2,24'hB}:
      begin
        scc_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP1: S_SEXT_I32_I8
    {2'b10,8'd2,24'h19}:
      begin
        scc_read <= 1'b1;
        s1_width <= 3'b000;
	dest1_width <= 3'b000;
      end
    //SOP1: S_AND_SAVEEXEC_B64
    {2'b10,8'd2,24'h24}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_OR_SAVEEXEC_B64
    {2'b10,8'd2,24'h25}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_XOR_SAVEEXEC_B64
    {2'b10,8'd2,24'h26}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_ANDN2_SAVEEXEC_B64
    {2'b10,8'd2,24'h27}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_ORN2_SAVEEXEC_B64
    {2'b10,8'd2,24'h28}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_NAND_SAVEEXEC_B64
    {2'b10,8'd2,24'h29}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_NOR_SAVEEXEC_B64
    {2'b10,8'd2,24'h2a}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP1: S_XNOR_SAVEEXEC_B64
    {2'b10,8'd2,24'h2b}:
      begin
        scc_write <= 1'b1;
        exec_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOPC --------------------------------------------
    //SOPC: S_CMP_EQ_I32
    {2'b10,8'd4,24'h0}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LG_I32
    {2'b10,8'd4,24'h1}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_GT_I32
    {2'b10,8'd4,24'h2}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_GE_I32
    {2'b10,8'd4,24'h3}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LT_I32
    {2'b10,8'd4,24'h4}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LE_I32
    {2'b10,8'd4,24'h5}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_EQ_U32
    {2'b10,8'd4,24'h6}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LG_U32
    {2'b10,8'd4,24'h7}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_GT_U32
    {2'b10,8'd4,24'h8}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_GE_U32
    {2'b10,8'd4,24'h9}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LT_U32
    {2'b10,8'd4,24'ha}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOPC: S_CMP_LE_U32
    {2'b10,8'd4,24'hb}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //SOP2 --------------------------------------------
    //SOP2: S_ADD_U32
    {2'b10,8'd8,24'h0}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_SUB_U32
    {2'b10,8'd8,24'h1}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_ADD_I32
    {2'b10,8'd8,24'h2}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_SUB_I32
    {2'b10,8'd8,24'h3}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_ADDC_U32
    {2'b10,8'd8,24'h4}:
      begin
        scc_write <= 1'b1;
        scc_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_SUBB_U32
    {2'b10,8'd8,24'h5}:
      begin
        scc_write <= 1'b1;
        scc_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_MIN_I32
    {2'b10,8'd8,24'h6}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_MIN_U32
    {2'b10,8'd8,24'h7}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_MAX_I32
    {2'b10,8'd8,24'h8}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_MAX_U32
    {2'b10,8'd8,24'h9}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_CSELECT_B32
    {2'b10,8'd8,24'hA}:
      begin
	scc_read <= 1'b1;
	s1_width <= 3'b000;
	s2_width <= 3'b000;
	dest1_width <= 3'b000;
      end
    //SOP2: S_AND_B32
    {2'b10,8'd8,24'he}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_AND_B64
    {2'b10,8'd8,24'hf}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_OR_B32
    {2'b10,8'd8,24'h10}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_OR_B64
    {2'b10,8'd8,24'h11}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_XOR_B32
    {2'b10,8'd8,24'h12}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_XOR_B64
    {2'b10,8'd8,24'h13}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_ANDN2_B32
    {2'b10,8'd8,24'h14}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_ANDN2_B64
    {2'b10,8'd8,24'h15}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_ORN2_B32
    {2'b10,8'd8,24'h16}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_ORN2_B64
    {2'b10,8'd8,24'h17}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_NAND_B32
    {2'b10,8'd8,24'h18}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_NAND_B64
    {2'b10,8'd8,24'h19}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_NOR_B32
    {2'b10,8'd8,24'h1a}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_NOR_B64
    {2'b10,8'd8,24'h1b}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_XNOR_B32
    {2'b10,8'd8,24'h1c}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_XNOR_B64
    {2'b10,8'd8,24'h1d}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_LSHL_B32
    {2'b10,8'd8,24'h1e}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_LSHL_B64
    {2'b10,8'd8,24'h1f}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_LSHR_B32
    {2'b10,8'd8,24'h20}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_LSHR_B64
    {2'b10,8'd8,24'h21}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_ASHR_I32
    {2'b10,8'd8,24'h22}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOP2: S_ASHR_I64
    {2'b10,8'd8,24'h23}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //SOP2: S_MUL_I32
    {2'b10,8'd8,24'h26}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SOPK --------------------------------------------
    //SOPK: S_MOVK_I32
    {2'b10,8'd16,24'h0}:
      begin
        dest1_width <= 3'b000;
      end
    //SOPK: S_ADDK_I32
    {2'b10,8'd16,24'hf}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        copy_d1_to_s1 <= 1'b1;
      end
    //SOPK: S_MULK_I32
    {2'b10,8'd16,24'h10}:
      begin
        scc_write <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        copy_d1_to_s1 <= 1'b1;
      end
    //VOPC --------------------------------------------
    //VOPC: V_CMP/CMPX/CMPS/CMPSX_{OP16}_F32/64 (128 instructions)
    //OP16: F,LT,EQ,LE,GT,LG,GE,O,U,NGE,NLG,NGT,NLE,NEQ,NLT,TRU
    {2'b01,8'd1,16'h0,8'b0???_????}:
      begin
        vcc_write <= 1'b1;
        exec_write <= opcode[4] ? 1'b1 : 1'b0;
        exec_read <= 1'b1;
        s1_width <= opcode[5] ? 3'b001 : 3'b000;
        s2_width <= opcode[5] ? 3'b001 : 3'b000;
        fp_instr <= 1'b1;
      end
    //VOPC: V_CMP/CMPX_{OP8}_I/U32/64 (64 instructions)
    //OP8: F,LT,EQ,LE,GT,LG,GE,TRU
    {2'b01,8'd1,16'h0,8'b1???_0???}:
      begin
        vcc_write <= 1'b1;
        exec_write <= opcode[4] ? 1'b1 : 1'b0;
        exec_read <= 1'b1;
        s1_width <= opcode[5] ? 3'b001 : 3'b000;
        s2_width <= opcode[5] ? 3'b001 : 3'b000;
      end
    //VOP1 --------------------------------------------
    //VOP1: V_NOP
    {2'b01,8'd2,24'h0}:
      begin
      end
    //VOP1: V_MOV_B32
    {2'b01,8'd2,24'h1}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_CVT_I32_F64
    {2'b01,8'd2,24'h3}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F64_I32
    {2'b01,8'd2,24'h4}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F32_I32
    {2'b01,8'd2,24'h5}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F32_U32
    {2'b01,8'd2,24'h6}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_U32_F32
    {2'b01,8'd2,24'h7}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_I32_F32
    {2'b01,8'd2,24'h8}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F16_F32
    {2'b01,8'd2,24'ha}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F32_F16
    {2'b01,8'd2,24'hb}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F32_F64
    {2'b01,8'd2,24'hf}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F64_F32
    {2'b01,8'd2,24'h10}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_U32_F64
    {2'b01,8'd2,24'h15}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CVT_F64_U32
    {2'b01,8'd2,24'h16}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_FRAC_F32
    {2'b01,8'd2,24'h20}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_TRUNC_F32
    {2'b01,8'd2,24'h21}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_CEIL_F32
    {2'b01,8'd2,24'h22}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RNDNE_F32
    {2'b01,8'd2,24'h23}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_FLOOR_F32
    {2'b01,8'd2,24'h24}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_EXP_F32
    {2'b01,8'd2,24'h25}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_LOG_CLAMP_F32
    {2'b01,8'd2,24'h26}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_LOG_F32
    {2'b01,8'd2,24'h27}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RCP_CLAMP_F32
    {2'b01,8'd2,24'h28}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RCP_F32
    {2'b01,8'd2,24'h2a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RSQ_CLAMP_F32
    {2'b01,8'd2,24'h2c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RSQ_F32
    {2'b01,8'd2,24'h2e}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RCP_F64
    {2'b01,8'd2,24'h2f}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RCP_CLAMP_F64
    {2'b01,8'd2,24'h30}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RSQ_F64
    {2'b01,8'd2,24'h31}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_RSQ_CLAMP_F64
    {2'b01,8'd2,24'h32}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_SQRT_F32
    {2'b01,8'd2,24'h33}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_SQRT_F64
    {2'b01,8'd2,24'h34}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP1: V_SIN_F32
    {2'b01,8'd2,24'h35}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_COS_F32
    {2'b01,8'd2,24'h36}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP1: V_NOT_B32
    {2'b01,8'd2,24'h37}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_BFREV_B32
    {2'b01,8'd2,24'h38}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_FFBH_U32
    {2'b01,8'd2,24'h39}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_FFBL_B32
    {2'b01,8'd2,24'h3a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_FFBH_I32
    {2'b01,8'd2,24'h3b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP1: V_FRACT_F64
    {2'b01,8'd2,24'h3e}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP2 --------------------------------------------
    //VOP2: V_CNDMASK_B32
    {2'b01,8'd4,24'h0}:
      begin
        vcc_read <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_READLINE_B32
    {2'b01,8'd4,24'h1}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_WRITELINE_B32
    {2'b01,8'd4,24'h2}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_ADD_F32
    {2'b01,8'd4,24'h3}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_SUB_F32
    {2'b01,8'd4,24'h4}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_SUBREV_F32
    {2'b01,8'd4,24'h5}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_MUL_F32
    {2'b01,8'd4,24'h8}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_MUL_I32_I24
    {2'b01,8'd4,24'h9}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MUL_HI_I32_I24
    {2'b01,8'd4,24'ha}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MUL_U32_U24
    {2'b01,8'd4,24'hb}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MUL_HI_U32_U24
    {2'b01,8'd4,24'hc}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MIN_F32
    {2'b01,8'd4,24'hf}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_MAX_F32
    {2'b01,8'd4,24'h10}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP2: V_MADMK_F32 - VIN
    {2'b01,8'd4,24'h20}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
				ext_literal_s3 <= 1'b1;
      end
    //VOP2: V_MIN_I32
    {2'b01,8'd4,24'h11}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MAX_I32
    {2'b01,8'd4,24'h12}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MIN_U32
    {2'b01,8'd4,24'h13}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MAX_U32
    {2'b01,8'd4,24'h14}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_LSHR_B32
    {2'b01,8'd4,24'h15}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_LSHRREV_B32
    {2'b01,8'd4,24'h16}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_ASHR_I32
    {2'b01,8'd4,24'h17}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_ASHRREV_I32
    {2'b01,8'd4,24'h18}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_LSHL_B32
    {2'b01,8'd4,24'h19}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_LSHLREV_B32
    {2'b01,8'd4,24'h1a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_AND_B32
    {2'b01,8'd4,24'h1b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_OR_B32
    {2'b01,8'd4,24'h1c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_XOR_B32
    {2'b01,8'd4,24'h1d}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_BFM_B32
    {2'b01,8'd4,24'h1e}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_MAC_F32  - VIN
    {2'b01,8'd4,24'h1f}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000; // `DECODE_BIT0
        s4_width <= 3'b000; 
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
        copy_d1_to_s4 <= 1'b1;
        copy_d1_to_s3 <= 1'b1;
      end
    //VOP2: V_ADD_I32
    {2'b01,8'd4,24'h25}:
      begin
        vcc_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_SUB_I32
    {2'b01,8'd4,24'h26}:
      begin
        vcc_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_SUBREV_I32
    {2'b01,8'd4,24'h27}:
      begin
        vcc_write <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_ADDC_U32
    {2'b01,8'd4,24'h28}:
      begin
        vcc_write <= 1'b1;
        vcc_read <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_SUBB_U32
    {2'b01,8'd4,24'h29}:
      begin
        vcc_write <= 1'b1;
        vcc_read <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP2: V_SUBBREV_U32
    {2'b01,8'd4,24'h2a}:
      begin
        vcc_write <= 1'b1;
        vcc_read <= 1'b1;
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3b --------------------------------------------
    //VOP3b (from VOP2): V_ADD_I32
    {2'b01,8'd8,24'h125}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3b (from VOP2): V_SUB_I32
    {2'b01,8'd8,24'h126}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3b (from VOP2): V_SUBREV_I32
    {2'b01,8'd8,24'h127}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3b (from VOP2): V_ADDC_U32
    {2'b01,8'd8,24'h128}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3b (from VOP2): V_SUBB_U32
    {2'b01,8'd8,24'h129}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3b (from VOP2): V_SUBBREV_U32
    {2'b01,8'd8,24'h12a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        dest2_width <= 3'b000;
      end
    //VOP3a --------------------------------------------
    //VOP3a (from VOPC): V_CMP/CMPX/CMPS/CMPSX_{OP16}_F32/64 (128 instructions)
    //OP16: F,LT,EQ,LE,GT,LG,GE,O,U,NGE,NLG,NGT,NLE,NEQ,NLT,TRU
    {2'b01,8'd16,16'h0,8'b0???_????}:
      begin
        exec_write <=opcode[4] ? 1'b1 : 1'b0;
        exec_read <= 1'b1;
        s1_width <= opcode[5] ? 3'b001 : 3'b000;
        s2_width <= opcode[5] ? 3'b001 : 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
        d1_vdst_to_sdst <= 1'b1;
      end
    //VOP3a (from VOPC): V_CMP/CMPX_{OP8}_I/U32/64 (64 instructions)
    //OP8: F,LT,EQ,LE,GT,LG,GE,TRU
    {2'b01,8'd16,16'h0,8'b1???_0???}:
      begin
        exec_write <=opcode[4] ? 1'b1 : 1'b0;
        exec_read <= 1'b1;
        s1_width <= opcode[5] ? 3'b001 : 3'b000;
        s2_width <= opcode[5] ? 3'b001 : 3'b000;
        dest1_width <= 3'b001;
        d1_vdst_to_sdst <= 1'b1;
      end
    //VOP3a (from VOP2): V_CNDMASK_B32
    {2'b01,8'd16,24'h100}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b001;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_READLINE_B32
    {2'b01,8'd16,24'h101}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_WRITELINE_B32
    {2'b01,8'd16,24'h102}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_ADD_F32
    {2'b01,8'd16,24'h103}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_SUB_F32
    {2'b01,8'd16,24'h104}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_SUBREV_F32
    {2'b01,8'd16,24'h105}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_MUL_F32
    {2'b01,8'd16,24'h108}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_MUL_I32_I24
    {2'b01,8'd16,24'h109}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MUL_HI_I32_I24
    {2'b01,8'd16,24'h10a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MUL_U32_U24
    {2'b01,8'd16,24'h10b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MUL_HI_U32_U24
    {2'b01,8'd16,24'h10c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MIN_F32
    {2'b01,8'd16,24'h10f}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_MAX_F32
    {2'b01,8'd16,24'h110}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP2): V_MIN_I32
    {2'b01,8'd16,24'h111}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MAX_I32
    {2'b01,8'd16,24'h112}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MIN_U32
    {2'b01,8'd16,24'h113}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MAX_U32
    {2'b01,8'd16,24'h114}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_LSHR_B32
    {2'b01,8'd16,24'h115}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_LSHRREV_B32
    {2'b01,8'd16,24'h116}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_ASHR_I32
    {2'b01,8'd16,24'h117}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_ASHRREV_I32
    {2'b01,8'd16,24'h118}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_LSHL_B32
    {2'b01,8'd16,24'h119}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_LSHLREV_B32
    {2'b01,8'd16,24'h11a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_AND_B32
    {2'b01,8'd16,24'h11b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_OR_B32
    {2'b01,8'd16,24'h11c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_XOR_B32
    {2'b01,8'd16,24'h11d}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_BFM_B32
    {2'b01,8'd16,24'h11e}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP2): V_MAC_F32
    {2'b01,8'd16,24'h11f}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s4_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
        copy_d1_to_s4 <= 1'b1;
      end
    //VOP3a: V_MAD_F32
    {2'b01,8'd16,24'h141}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MAD_I32_I24
    {2'b01,8'd16,24'h142}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MAD_U32_U24
    {2'b01,8'd16,24'h143}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_BFE_U32
    {2'b01,8'd16,24'h148}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_BFE_I32
    {2'b01,8'd16,24'h149}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_BFI_B32
  {2'b01,8'd16,24'h14a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_FMA_F32
    {2'b01,8'd16,24'h14b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_FMA_F64
    {2'b01,8'd16,24'h14c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        s3_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MIN3_F32
    {2'b01,8'd16,24'h151}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MIN3_I32
    {2'b01,8'd16,24'h152}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MIN3_U32
    {2'b01,8'd16,24'h153}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MAX3_F32
    {2'b01,8'd16,24'h154}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MAX3_I32
    {2'b01,8'd16,24'h155}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MAX3_U32
    {2'b01,8'd16,24'h156}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MED3_F32
    {2'b01,8'd16,24'h157}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MED3_I32
    {2'b01,8'd16,24'h158}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MED3_U32
    {2'b01,8'd16,24'h159}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_LSHL_B64
    {2'b01,8'd16,24'h161}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //VOP3a: V_LSHR_B64
    {2'b01,8'd16,24'h162}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //VOP3a: V_ASHR_I64
    {2'b01,8'd16,24'h163}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
      end
    //VOP3a (from VOP1): V_NOP
    {2'b01,8'd16,24'h180}:
      begin
      end
    //VOP3a (from VOP1): V_MOV_B32
    {2'b01,8'd16,24'h181}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_CVT_I32_F64
    {2'b01,8'd16,24'h183}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F64_I32
    {2'b01,8'd16,24'h184}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F32_I32
    {2'b01,8'd16,24'h185}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F32_U32
    {2'b01,8'd16,24'h186}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_U32_F32
    {2'b01,8'd16,24'h187}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_I32_F32
    {2'b01,8'd16,24'h188}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F16_F32
    {2'b01,8'd16,24'h18a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F32_F16
    {2'b01,8'd16,24'h18b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F32_F64
    {2'b01,8'd16,24'h18f}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F64_F32
    {2'b01,8'd16,24'h190}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_U32_F64
    {2'b01,8'd16,24'h195}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CVT_F64_U32
    {2'b01,8'd16,24'h196}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_FRAC_F32
    {2'b01,8'd16,24'h1a0}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_TRUNC_F32
    {2'b01,8'd16,24'h1a1}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_CEIL_F32
    {2'b01,8'd16,24'h1a2}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RNDNE_F32
    {2'b01,8'd16,24'h1a3}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_FLOOR_F32
    {2'b01,8'd16,24'h1a4}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_EXP_F32
    {2'b01,8'd16,24'h1a5}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_LOG_CLAMP_F32
    {2'b01,8'd16,24'h1a6}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_LOG_F32
    {2'b01,8'd16,24'h1a7}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RCP_CLAMP_F32
    {2'b01,8'd16,24'h1a8}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RCP_F32
    {2'b01,8'd16,24'h1aa}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RSQ_CLAMP_F32
    {2'b01,8'd16,24'h1ac}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RSQ_F32
    {2'b01,8'd16,24'h1ae}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RCP_F64
    {2'b01,8'd16,24'h1af}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RCP_CLAMP_F64
    {2'b01,8'd16,24'h1b0}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RSQ_F64
    {2'b01,8'd16,24'h1b1}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_RSQ_CLAMP_F64
    {2'b01,8'd16,24'h1b2}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_SQRT_F32
    {2'b01,8'd16,24'h1b3}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_SQRT_F64
    {2'b01,8'd16,24'h1b4}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_SIN_F32
    {2'b01,8'd16,24'h1b5}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_COS_F32
    {2'b01,8'd16,24'h1b6}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
        fp_instr <= 1'b1;
      end
    //VOP3a (from VOP1): V_NOT_B32
    {2'b01,8'd16,24'h1b7}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_BFREV_B32
    {2'b01,8'd16,24'h1b8}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_FFBH_U32
    {2'b01,8'd16,24'h1b9}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_FFBL_B32
    {2'b01,8'd16,24'h1ba}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_FFBH_I32
    {2'b01,8'd16,24'h1bb}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a (from VOP1): V_FRACT_F64
    {2'b01,8'd16,24'h1be}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_ADD_F64
    {2'b01,8'd16,24'h164}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MUL_F64
    {2'b01,8'd16,24'h165}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MIN_F64
    {2'b01,8'd16,24'h166}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MAX_F64
    {2'b01,8'd16,24'h167}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b001;
        s2_width <= 3'b001;
        dest1_width <= 3'b001;
        fp_instr <= 1'b1;
      end
    //VOP3a: V_MUL_LO_U32
    {2'b01,8'd16,24'h169}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MUL_HI_U32
    {2'b01,8'd16,24'h16a}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MUL_LO_I32
    {2'b01,8'd16,24'h16b}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //VOP3a: V_MUL_HI_I32
    {2'b01,8'd16,24'h16c}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SMRD --------------------------------------------
    //SMRD: S_LOAD_DWORD
    {2'b11,8'd1,24'h0}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //SMRD: S_LOAD_DWORDX2
    {2'b11,8'd1,24'h1}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b001;
      end
    //SMRD: S_LOAD_DWORDX4
    {2'b11,8'd1,24'h2}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b010;
      end
    //SMRD: S_LOAD_DWORDX8
    {2'b11,8'd1,24'h3}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b011;
      end
    //SMRD: S_LOAD_DWORDX16
    {2'b11,8'd1,24'h4}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        dest1_width <= 3'b100;
      end
    //SMRD: S_BUFFER_LOAD_DWORD
    {2'b11,8'd1,24'h8}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        dest1_width <= 3'b000;
      end
    //SMRD: S_BUFFER_LOAD_DWORDX2
    {2'b11,8'd1,24'h9}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        dest1_width <= 3'b001;
      end
    //SMRD: S_BUFFER_LOAD_DWORDX4
    {2'b11,8'd1,24'ha}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        dest1_width <= 3'b010;
      end
    //SMRD: S_BUFFER_LOAD_DWORDX8
    {2'b11,8'd1,24'hb}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        dest1_width <= 3'b011;
      end
    //SMRD: S_BUFFER_LOAD_DWORDX16
    {2'b11,8'd1,24'hc}:
      begin
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        dest1_width <= 3'b100;
      end
    //LDS/GDS --------------------------------------------
    //LDS/GDS: DS_WRITE_B32
    {2'b11,8'd2,24'hd}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
      end
    //LDS/GDS: DS_READ_B32
    {2'b11,8'd2,24'h36}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        dest1_width <= 3'b000;
      end
    //MTBUF --------------------------------------------
    //MTBUF: TBUFFER_LOAD_FORMAT_X
    {2'b11,8'd4,24'h0}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
        dest1_width <= 3'b000;
      end
    //MTBUF: TBUFFER_LOAD_FORMAT_XY
    {2'b11,8'd4,24'h1}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
        dest1_width <= 3'b001;
      end
    //MTBUF: TBUFFER_LOAD_FORMAT_XYZ
    {2'b11,8'd4,24'h2}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
        dest1_width <= 3'b101;
      end
    //MTBUF: TBUFFER_LOAD_FORMAT_XYZW
    {2'b11,8'd4,24'h3}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
        dest1_width <= 3'b010;
      end
    //MTBUF: TBUFFER_STORE_FORMAT_X
    {2'b11,8'd4,24'h4}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b000;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
      end
    //MTBUF: TBUFFER_STORE_FORMAT_XY
    {2'b11,8'd4,24'h5}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b001;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
      end
    //MTBUF: TBUFFER_STORE_FORMAT_XYZ
    {2'b11,8'd4,24'h6}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b101;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
      end
    //MTBUF: TBUFFER_STORE_FORMAT_XYZW
    {2'b11,8'd4,24'h7}:
      begin
        exec_read <= 1'b1;
        s1_width <= 3'b000;
        s2_width <= 3'b010;
        s3_width <= 3'b000;
        s4_width <= 3'b010;
      end
  endcase
end
endmodule
module instr_collate (
  in_wfid,
  in_instr,
  in_valid,
  in_pc,
  out_instr,
  out_valid,
  out_pc,
  in_long,
  out_long,
  clk,
  rst
);

input [5:0] in_wfid;
input [31:0] in_instr;
input in_valid;
input [31:0] in_pc;

output [63:0] out_instr;
output out_valid;
output [31:0] out_pc;

input in_long;
output out_long;

input clk;
input rst;

wire [31:0] stored_instr;
wire [31:0] stored_pc;

reg_40xX_1r_1w #(64) reg_instr_pc (
 .rd_addr(in_wfid),
 .rd_data({stored_instr,stored_pc}),
 .wr_en(in_long&in_valid),
 .wr_addr(in_wfid),
 .wr_data({in_instr,in_pc}),
 .clk(clk),
 .rst(rst)
);

reg_40xX_1r_1w #(1) reg_valid (
 .rd_addr(in_wfid),
 .rd_data(out_long),
 .wr_en(in_valid),
 .wr_addr(in_wfid),
 .wr_data(in_long),
 .clk(clk),
 .rst(rst)
);

assign out_instr = out_long ? {in_instr,stored_instr} : {32'b0,in_instr};
assign out_pc = out_long ? stored_pc : in_pc;
assign out_valid = in_valid & (~in_long);

endmodule
module reg_field_encoder (
 in,
 sgpr_base,
 vgpr_base,
 out,
 literal_required,
 explicit_vcc,
 explicit_exec,
 explicit_scc,
 explicit_M0,
 fp_constant
);

input [9:0] in;
input [8:0] sgpr_base;
input [9:0] vgpr_base;
output [11:0] out;
output literal_required;
output explicit_vcc;
output explicit_exec;
output explicit_scc;
output explicit_M0;
output [32:0] fp_constant;

reg [11:0] out;
reg literal_required;
reg explicit_vcc;
reg explicit_exec;
reg explicit_scc;
reg explicit_M0;
reg [32:0] fp_constant;

wire [8:0] sgpr_address;
wire [9:0] vgpr_address;
wire signed [9:0] negative_constant;

assign sgpr_address = sgpr_base + in[6:0];
assign vgpr_address = vgpr_base + in[7:0];
assign negative_constant = (~{4'b0,in[5:0]}) + 10'b1;

always @(in or sgpr_base or vgpr_base)
begin
  casex(in)
    //invalid operand
    10'b0?_????_????:
      begin
        out <= {1'b0,{11{1'bx}}};
        literal_required <= 1'b0;
        explicit_vcc <= 1'b0;
        explicit_exec <= 1'b0;
        explicit_scc <= 1'b0;
        explicit_M0 <= 1'b0;
        fp_constant <= {1'b0,{32{1'bx}}};
      end
    //vgpr
    10'b11_????_????:
      begin
        out <= {2'b10,vgpr_address};
	literal_required <= 1'b0;
        explicit_vcc <= 1'b0;
        explicit_exec <= 1'b0;
        explicit_scc <= 1'b0;
        explicit_M0 <= 1'b0;
        fp_constant <= {1'b0,{32{1'bx}}};
      end
    //Integer constants and reserved fields or literal constant
    10'b10_1???_????:
      begin
        //Zero and positive integer constants
        if(in[6:0] <= 7'd64) begin 
          out <= {5'd0,in[6:0]};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //negative integer constant
        else if(in[6:0] <= 7'd80) begin
          out <= {2'b00,negative_constant};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //reserved field
        else if(in[6:0] <= 7'd111) begin
          out <= {1'b0,{11{1'bx}}};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //floating point constant: 0.5
        else if(in[6:0] == 7'd112) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'h3f00_0000};
        end
        //floating point constant: -0.5
        else if(in[6:0] == 7'd113) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'hbf00_0000};
        end
        //floating point constant: 1.0
        else if(in[6:0] == 7'd114) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'h3f80_0000};
        end
        //floating point constant: -1.0
        else if(in[6:0] == 7'd115) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'hbf80_0000};
        end
        //floating point constant: 2.0
        else if(in[6:0] == 7'd116) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'h4000_0000};
        end
        //floating point constant: -2.0
        else if(in[6:0] == 7'd117) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'hc000_0000};
        end
        //floating point constant: 4.0
        else if(in[6:0] == 7'd118) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'h4080_0000};
        end
        //floating point constant: -4.0
        else if(in[6:0] == 7'd119) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b1,32'hc080_0000};
        end
        //reserved field
        else if(in[6:0] <= 7'd122) begin
          out <= {1'b0,{11{1'bx}}};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //VCCZ
	else if(in[6:0] == 7'd123) begin
          out <= {3'b111,9'd32};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b1;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //EXECZ
	else if(in[6:0] == 7'd124) begin
          out <= {3'b111,9'd64};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b1;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //SCC
	else if(in[6:0] == 7'd125) begin
          out <= {3'b111,9'd128};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b1;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
	//Literal constant in instruction stream!
	else if(in[6:0] == 7'd127) begin
          out <= {1'b0,11'b111_1111_1111};
	  literal_required <= 1'b1;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
	end
        //reserved
        else begin
          out <= {1'b0,{11{1'bx}}};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
      end
    //sgpr or exec or vcc or reserved field
    10'b10_0???_????:
      begin
        //sgpr
        if(in[6:0] <= 7'd103) begin
          out <= {3'b110,sgpr_address};
	  literal_required <= 1'b0;
          explicit_vcc <= 1'b0;
          explicit_exec <= 1'b0;
          explicit_scc <= 1'b0;
          explicit_M0 <= 1'b0;
          fp_constant <= {1'b0,{32{1'bx}}};
        end
        //special registers or reserved fields
        else begin
          casex(in[6:0])
            //VCC_LO
            7'd106:
              begin
                out <= {3'b111,9'd1};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b1;
                explicit_exec <= 1'b0;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b0;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
            //VCC_HI
            7'd107:
              begin
                out <= {3'b111,9'd2};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b1;
                explicit_exec <= 1'b0;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b0;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
            //M0
            7'd124:
              begin
                out <= {3'b111,9'd4};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b0;
                explicit_exec <= 1'b0;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b1;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
            //EXEC_LO
            7'd126:
              begin
                out <= {3'b111,9'd8};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b0;
                explicit_exec <= 1'b1;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b0;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
            //EXEC_HI
            7'd127:
              begin
                out <= {3'b111,9'd16};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b0;
                explicit_exec <= 1'b1;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b0;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
            //reserved field
            default:
              begin
                out <= {1'b0,{11{1'bx}}};
	        literal_required <= 1'b0;
                explicit_vcc <= 1'b0;
                explicit_exec <= 1'b0;
                explicit_scc <= 1'b0;
                explicit_M0 <= 1'b0;
                fp_constant <= {1'b0,{32{1'bx}}};
              end
          endcase
        end
      end
    //Error condition
    default:
      begin
        out <= {1'b0,{11{1'bx}}};
	literal_required <= 1'b0;
        explicit_vcc <= 1'b0;
        explicit_exec <= 1'b0;
        explicit_scc <= 1'b0;
        explicit_M0 <= 1'b0;
        fp_constant <= {1'b0,{32{1'bx}}};
      end
  endcase
end
endmodule
module exec(
      lsu_rd_wfid,
      salu_wr_exec_en,
      salu_wr_vcc_en,
      salu_wr_exec_value,
      salu_wr_vcc_value,
      salu_wr_wfid,
      salu_rd_en,
      salu_rd_wfid,
      salu_wr_m0_en,
      salu_wr_m0_value,
      salu_wr_scc_en,
      salu_wr_scc_value,
      simd0_rd_wfid,
      simd1_rd_wfid,
      simd2_rd_wfid,
      simd3_rd_wfid,
      simd0_rd_en,
      simd1_rd_en,
      simd2_rd_en,
      simd3_rd_en,
      simd0_vcc_wr_wfid,
      simd1_vcc_wr_wfid,
      simd2_vcc_wr_wfid,
      simd3_vcc_wr_wfid,
      simd0_vcc_wr_en,
      simd1_vcc_wr_en,
      simd2_vcc_wr_en,
      simd3_vcc_wr_en,
      simd0_vcc_value,
      simd1_vcc_value,
      simd2_vcc_value,
      simd3_vcc_value,
      simf0_rd_wfid,
      simf1_rd_wfid,
      simf2_rd_wfid,
      simf3_rd_wfid,
      simf0_rd_en,
      simf1_rd_en,
      simf2_rd_en,
      simf3_rd_en,
      simf0_vcc_wr_wfid,
      simf1_vcc_wr_wfid,
      simf2_vcc_wr_wfid,
      simf3_vcc_wr_wfid,
      simf0_vcc_wr_en,
      simf1_vcc_wr_en,
      simf2_vcc_wr_en,
      simf3_vcc_wr_en,
      simf0_vcc_value,
      simf1_vcc_value,
      simf2_vcc_value,
      simf3_vcc_value,
      fetch_init_wf_en,
      fetch_init_wf_id,
      fetch_init_value,
      rfa_select_fu,
      lsu_exec_value,
      lsu_rd_m0_value,
      simd_rd_exec_value,
      simd_rd_vcc_value,
      simd_rd_m0_value,
      simd_rd_scc_value,
      simf_rd_exec_value,
      simf_rd_vcc_value,
      simf_rd_m0_value,
      simf_rd_scc_value,
      salu_rd_exec_value,
      salu_rd_vcc_value,
      salu_rd_m0_value,
      salu_rd_scc_value,
      issue_salu_wr_vcc_wfid,
      issue_salu_wr_vcc_en,
      issue_salu_wr_exec_en,
      issue_salu_wr_m0_en,
      issue_salu_wr_scc_en,
      issue_valu_wr_vcc_wfid,
      issue_valu_wr_vcc_en,
      clk,
      rst
 );

input clk;

input rst;

input salu_wr_exec_en, salu_wr_vcc_en, salu_rd_en, salu_wr_m0_en, salu_wr_scc_en,
         salu_wr_scc_value, simd0_rd_en, simd1_rd_en, simd2_rd_en, simd3_rd_en,
         simd0_vcc_wr_en, simd1_vcc_wr_en, simd2_vcc_wr_en, simd3_vcc_wr_en,
         simf0_rd_en, simf1_rd_en, simf2_rd_en, simf3_rd_en, simf0_vcc_wr_en,
         simf1_vcc_wr_en, simf2_vcc_wr_en, simf3_vcc_wr_en, fetch_init_wf_en;
input[5:0] lsu_rd_wfid, salu_wr_wfid, salu_rd_wfid, simd0_rd_wfid, simd1_rd_wfid,
         simd2_rd_wfid, simd3_rd_wfid, simd0_vcc_wr_wfid, simd1_vcc_wr_wfid,
         simd2_vcc_wr_wfid, simd3_vcc_wr_wfid, simf0_rd_wfid, simf1_rd_wfid,
         simf2_rd_wfid, simf3_rd_wfid, simf0_vcc_wr_wfid, simf1_vcc_wr_wfid,
         simf2_vcc_wr_wfid, simf3_vcc_wr_wfid, fetch_init_wf_id;
input[15:0] rfa_select_fu;
input[31:0] salu_wr_m0_value;
input[63:0] salu_wr_exec_value, salu_wr_vcc_value, simd0_vcc_value,
         simd1_vcc_value, simd2_vcc_value, simd3_vcc_value, simf0_vcc_value,
         simf1_vcc_value, simf2_vcc_value, simf3_vcc_value, fetch_init_value;

output simd_rd_scc_value, simf_rd_scc_value, salu_rd_scc_value, issue_salu_wr_vcc_en,
         issue_salu_wr_exec_en, issue_salu_wr_m0_en, issue_salu_wr_scc_en, issue_valu_wr_vcc_en;
output[5:0] issue_salu_wr_vcc_wfid, issue_valu_wr_vcc_wfid;
output[31:0] lsu_rd_m0_value, simd_rd_m0_value, simf_rd_m0_value, salu_rd_m0_value;
output[63:0] lsu_exec_value, simd_rd_exec_value, simd_rd_vcc_value,
         simf_rd_exec_value, simf_rd_vcc_value, salu_rd_exec_value, salu_rd_vcc_value;

wire[5:0] alu_rd_wfid;

wire vcc_simd_wr_en;
wire[5:0] vcc_simd_wr_addr;
wire[63:0] vcc_simd_wr_data;

wire lsu_rd_scc_value; //if needed in future
wire[63:0] lsu_rd_vcc_value; //if needed in future

assign salu_rd_exec_value = simd_rd_exec_value;
assign salu_rd_vcc_value = simd_rd_vcc_value;
assign salu_rd_m0_value = simd_rd_m0_value;
assign salu_rd_scc_value = simd_rd_scc_value;

assign simf_rd_exec_value = simd_rd_exec_value;
assign simf_rd_vcc_value = simd_rd_vcc_value;
assign simf_rd_m0_value = simd_rd_m0_value;
assign simf_rd_scc_value = simd_rd_scc_value;

rd_port_9_to_1 #(6) alu_rd_port_mux(
  .port0_rd_en(simd0_rd_en),
  .port0_rd_addr(simd0_rd_wfid),
  .port1_rd_en(simd1_rd_en),
  .port1_rd_addr(simd1_rd_wfid),
  .port2_rd_en(simd2_rd_en),
  .port2_rd_addr(simd2_rd_wfid),
  .port3_rd_en(simd3_rd_en),
  .port3_rd_addr(simd3_rd_wfid),
  .port4_rd_en(simf0_rd_en),
  .port4_rd_addr(simf0_rd_wfid),
  .port5_rd_en(simf1_rd_en),
  .port5_rd_addr(simf1_rd_wfid),
  .port6_rd_en(simf2_rd_en),
  .port6_rd_addr(simf2_rd_wfid),
  .port7_rd_en(simf3_rd_en),
  .port7_rd_addr(simf3_rd_wfid),
  .port8_rd_en(salu_rd_en),
  .port8_rd_addr(salu_rd_wfid),
  .rd_addr(alu_rd_wfid)
);

wr_port_40x64b_8_to_1 vcc_wr_port_mux(
  .select(rfa_select_fu[7:0]),
  .port0_wr_en(simd0_vcc_wr_en),
  .port0_wr_addr(simd0_vcc_wr_wfid),
  .port0_wr_data(simd0_vcc_value),
  .port1_wr_en(simd1_vcc_wr_en),
  .port1_wr_addr(simd1_vcc_wr_wfid),
  .port1_wr_data(simd1_vcc_value),
  .port2_wr_en(simd2_vcc_wr_en),
  .port2_wr_addr(simd2_vcc_wr_wfid),
  .port2_wr_data(simd2_vcc_value),
  .port3_wr_en(simd3_vcc_wr_en),
  .port3_wr_addr(simd3_vcc_wr_wfid),
  .port3_wr_data(simd3_vcc_value),
  .port4_wr_en(simf0_vcc_wr_en),
  .port4_wr_addr(simf0_vcc_wr_wfid),
  .port4_wr_data(simf0_vcc_value),
  .port5_wr_en(simf1_vcc_wr_en),
  .port5_wr_addr(simf1_vcc_wr_wfid),
  .port5_wr_data(simf1_vcc_value),
  .port6_wr_en(simf2_vcc_wr_en),
  .port6_wr_addr(simf2_vcc_wr_wfid),
  .port6_wr_data(simf2_vcc_value),
  .port7_wr_en(simf3_vcc_wr_en),
  .port7_wr_addr(simf3_vcc_wr_wfid),
  .port7_wr_data(simf3_vcc_value),
  .muxed_port_wr_en(vcc_simd_wr_en),
  .muxed_port_wr_addr(vcc_simd_wr_addr),
  .muxed_port_wr_data(vcc_simd_wr_data)
);

// m0
reg_40xX_2r_2w #(32) m0_file(
  .rd0_addr(alu_rd_wfid),
  .rd0_data(simd_rd_m0_value),
  .rd1_addr(lsu_rd_wfid),
  .rd1_data(lsu_rd_m0_value),
  .wr0_en(fetch_init_wf_en),
  .wr0_addr(fetch_init_wf_id),
  .wr0_data(32'd0),
  .wr1_en(salu_wr_m0_en),
  .wr1_addr(salu_wr_wfid),
  .wr1_data(salu_wr_m0_value),
  .clk(clk),
  .rst(rst)
);

// scc
reg_40xX_2r_2w #(1) scc_file(
  .rd0_addr(alu_rd_wfid),
  .rd0_data(simd_rd_scc_value),
  .rd1_addr(lsu_rd_wfid),
  .rd1_data(lsu_rd_scc_value),
  .wr0_en(fetch_init_wf_en),
  .wr0_addr(fetch_init_wf_id),
  .wr0_data(1'b0),
  .wr1_en(salu_wr_scc_en),
  .wr1_addr(salu_wr_wfid),
  .wr1_data(salu_wr_scc_value),
  .clk(clk),
  .rst(rst)
);

// vcc
reg_40xX_2r_3w #(64) vcc_file(
  .rd0_addr(alu_rd_wfid),
  .rd0_data(simd_rd_vcc_value),
  .rd1_addr(lsu_rd_wfid),
  .rd1_data(lsu_rd_vcc_value),
  .wr0_en(fetch_init_wf_en),
  .wr0_addr(fetch_init_wf_id),
  .wr0_data(64'd0),
  .wr1_en(vcc_simd_wr_en),
  .wr1_addr(vcc_simd_wr_addr),
  .wr1_data(vcc_simd_wr_data),
  .wr2_en(salu_wr_vcc_en),
  .wr2_addr(salu_wr_wfid),
  .wr2_data(salu_wr_vcc_value),
  .clk(clk),
  .rst(rst)
);

// exec
reg_40xX_2r_2w #(64) exec_file(
  .rd0_addr(alu_rd_wfid),
  .rd0_data(simd_rd_exec_value),
  .rd1_addr(lsu_rd_wfid),
  .rd1_data(lsu_exec_value),
  .wr0_en(fetch_init_wf_en),
  .wr0_addr(fetch_init_wf_id),
  .wr0_data(fetch_init_value),
  .wr1_en(salu_wr_exec_en),
  .wr1_addr(salu_wr_wfid),
  .wr1_data(salu_wr_exec_value),
  .clk(clk),
  .rst(rst)
);

///////////////////////////////

assign issue_salu_wr_vcc_wfid = salu_wr_wfid;
assign issue_salu_wr_vcc_en = salu_wr_vcc_en;
assign issue_valu_wr_vcc_wfid = vcc_simd_wr_addr;
assign issue_valu_wr_vcc_en = vcc_simd_wr_en;
assign issue_salu_wr_exec_en = salu_wr_exec_en;
assign issue_salu_wr_m0_en = salu_wr_m0_en;
assign issue_salu_wr_scc_en = salu_wr_scc_en;
///////////////////////////////

endmodule
module rd_port_9_to_1 (
  port0_rd_en,
  port0_rd_addr,

  port1_rd_en,
  port1_rd_addr,

  port2_rd_en,
  port2_rd_addr,

  port3_rd_en,
  port3_rd_addr,

  port4_rd_en,
  port4_rd_addr,

  port5_rd_en,
  port5_rd_addr,

  port6_rd_en,
  port6_rd_addr,

  port7_rd_en,
  port7_rd_addr,

  port8_rd_en,
  port8_rd_addr,

  rd_addr
);

  parameter WIDTH = 1;

  input               port0_rd_en;
  input [WIDTH - 1:0] port0_rd_addr;
  input               port1_rd_en;
  input [WIDTH - 1:0] port1_rd_addr;
  input               port2_rd_en;
  input [WIDTH - 1:0] port2_rd_addr;
  input               port3_rd_en;
  input [WIDTH - 1:0] port3_rd_addr;
  input               port4_rd_en;
  input [WIDTH - 1:0] port4_rd_addr;
  input               port5_rd_en;
  input [WIDTH - 1:0] port5_rd_addr;
  input               port6_rd_en;
  input [WIDTH - 1:0] port6_rd_addr;
  input               port7_rd_en;
  input [WIDTH - 1:0] port7_rd_addr;
  input               port8_rd_en;
  input [WIDTH - 1:0] port8_rd_addr;

  output [WIDTH - 1:0]  rd_addr;

  reg [WIDTH - 1:0]     rd_addr;

   always @ (
      port0_rd_en or port1_rd_en or port2_rd_en or port3_rd_en or port4_rd_en or
      port5_rd_en or port6_rd_en or port7_rd_en or port8_rd_en or
      port0_rd_addr or port1_rd_addr or port2_rd_addr or port3_rd_addr or
      port4_rd_addr or port5_rd_addr or port6_rd_addr or port7_rd_addr or port8_rd_addr)
   begin
      casex({port8_rd_en, port7_rd_en, port6_rd_en, port5_rd_en, port4_rd_en,
            port3_rd_en, port2_rd_en, port1_rd_en, port0_rd_en})
         9'b000000001: rd_addr <= port0_rd_addr;
         9'b000000010: rd_addr <= port1_rd_addr;
         9'b000000100: rd_addr <= port2_rd_addr;
         9'b000001000: rd_addr <= port3_rd_addr;
         9'b000010000: rd_addr <= port4_rd_addr;
         9'b000100000: rd_addr <= port5_rd_addr;
         9'b001000000: rd_addr <= port6_rd_addr;
         9'b010000000: rd_addr <= port7_rd_addr;
         9'b100000000: rd_addr <= port8_rd_addr;
         default: rd_addr <= 6'bxxxxxx;
      endcase
   end

endmodule
module reg_40xX_1r_2w (
  rd_addr,
  rd_data,

  wr0_en,
  wr0_addr,
  wr0_data,

  wr1_en,
  wr1_addr,
  wr1_data,

  clk,
  rst
);

parameter WIDTH = 64;

output [WIDTH-1:0] rd_data;
input [5:0] rd_addr;

input wr0_en;
input [5:0] wr0_addr;
input [WIDTH-1:0] wr0_data;

input wr1_en;
input [5:0] wr1_addr;
input [WIDTH-1:0] wr1_data;

input clk;
input rst;

wire [(40*WIDTH)-1:0] word_out;
wire [(40*WIDTH)-1:0] word_in;
wire [39:0] wr_en_word;
wire [39:0] wr0_word_select;
wire [39:0] wr1_word_select;
wire [39:0] wr0_word_enable;
wire [39:0] wr1_word_enable;

mux_40xX_to_1xX #(64) mux_rd_port(
  .out(rd_data),
  .in(word_out),
  .select(rd_addr)
);

decoder_6_to_40 decoder_wr_port_0(
  .out(wr0_word_select),
  .in(wr0_addr)
);

decoder_6_to_40 decoder_wr_port_1(
  .out(wr1_word_select),
  .in(wr1_addr)
);

register #(64) word[39:0](
  .out(word_out),
  .in(word_in),
  .wr_en(wr_en_word),
  .clk(clk),
  .rst(rst)
);

assign wr0_word_enable = {40{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {40{wr1_en}} & wr1_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable;

// %%start_veriperl
// my $i;
// my $i_plus_one;
// for($i=0; $i<40; $i=$i+1)
// {
//   $i_plus_one = $i + 1;
//   print "  assign word_in[(WIDTH*$i_plus_one)-1:WIDTH*$i] = ({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b01) ? wr0_data : (({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});\n";
// }
// %%stop_veriperl
  assign word_in[(WIDTH*1)-1:WIDTH*0] = ({wr1_word_enable[0],wr0_word_enable[0]} == 2'b01) ? wr0_data : (({wr1_word_enable[0],wr0_word_enable[0]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*2)-1:WIDTH*1] = ({wr1_word_enable[1],wr0_word_enable[1]} == 2'b01) ? wr0_data : (({wr1_word_enable[1],wr0_word_enable[1]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*3)-1:WIDTH*2] = ({wr1_word_enable[2],wr0_word_enable[2]} == 2'b01) ? wr0_data : (({wr1_word_enable[2],wr0_word_enable[2]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*4)-1:WIDTH*3] = ({wr1_word_enable[3],wr0_word_enable[3]} == 2'b01) ? wr0_data : (({wr1_word_enable[3],wr0_word_enable[3]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*5)-1:WIDTH*4] = ({wr1_word_enable[4],wr0_word_enable[4]} == 2'b01) ? wr0_data : (({wr1_word_enable[4],wr0_word_enable[4]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*6)-1:WIDTH*5] = ({wr1_word_enable[5],wr0_word_enable[5]} == 2'b01) ? wr0_data : (({wr1_word_enable[5],wr0_word_enable[5]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*7)-1:WIDTH*6] = ({wr1_word_enable[6],wr0_word_enable[6]} == 2'b01) ? wr0_data : (({wr1_word_enable[6],wr0_word_enable[6]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*8)-1:WIDTH*7] = ({wr1_word_enable[7],wr0_word_enable[7]} == 2'b01) ? wr0_data : (({wr1_word_enable[7],wr0_word_enable[7]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*9)-1:WIDTH*8] = ({wr1_word_enable[8],wr0_word_enable[8]} == 2'b01) ? wr0_data : (({wr1_word_enable[8],wr0_word_enable[8]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*10)-1:WIDTH*9] = ({wr1_word_enable[9],wr0_word_enable[9]} == 2'b01) ? wr0_data : (({wr1_word_enable[9],wr0_word_enable[9]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*11)-1:WIDTH*10] = ({wr1_word_enable[10],wr0_word_enable[10]} == 2'b01) ? wr0_data : (({wr1_word_enable[10],wr0_word_enable[10]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*12)-1:WIDTH*11] = ({wr1_word_enable[11],wr0_word_enable[11]} == 2'b01) ? wr0_data : (({wr1_word_enable[11],wr0_word_enable[11]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*13)-1:WIDTH*12] = ({wr1_word_enable[12],wr0_word_enable[12]} == 2'b01) ? wr0_data : (({wr1_word_enable[12],wr0_word_enable[12]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*14)-1:WIDTH*13] = ({wr1_word_enable[13],wr0_word_enable[13]} == 2'b01) ? wr0_data : (({wr1_word_enable[13],wr0_word_enable[13]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*15)-1:WIDTH*14] = ({wr1_word_enable[14],wr0_word_enable[14]} == 2'b01) ? wr0_data : (({wr1_word_enable[14],wr0_word_enable[14]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*16)-1:WIDTH*15] = ({wr1_word_enable[15],wr0_word_enable[15]} == 2'b01) ? wr0_data : (({wr1_word_enable[15],wr0_word_enable[15]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*17)-1:WIDTH*16] = ({wr1_word_enable[16],wr0_word_enable[16]} == 2'b01) ? wr0_data : (({wr1_word_enable[16],wr0_word_enable[16]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*18)-1:WIDTH*17] = ({wr1_word_enable[17],wr0_word_enable[17]} == 2'b01) ? wr0_data : (({wr1_word_enable[17],wr0_word_enable[17]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*19)-1:WIDTH*18] = ({wr1_word_enable[18],wr0_word_enable[18]} == 2'b01) ? wr0_data : (({wr1_word_enable[18],wr0_word_enable[18]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*20)-1:WIDTH*19] = ({wr1_word_enable[19],wr0_word_enable[19]} == 2'b01) ? wr0_data : (({wr1_word_enable[19],wr0_word_enable[19]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*21)-1:WIDTH*20] = ({wr1_word_enable[20],wr0_word_enable[20]} == 2'b01) ? wr0_data : (({wr1_word_enable[20],wr0_word_enable[20]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*22)-1:WIDTH*21] = ({wr1_word_enable[21],wr0_word_enable[21]} == 2'b01) ? wr0_data : (({wr1_word_enable[21],wr0_word_enable[21]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*23)-1:WIDTH*22] = ({wr1_word_enable[22],wr0_word_enable[22]} == 2'b01) ? wr0_data : (({wr1_word_enable[22],wr0_word_enable[22]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*24)-1:WIDTH*23] = ({wr1_word_enable[23],wr0_word_enable[23]} == 2'b01) ? wr0_data : (({wr1_word_enable[23],wr0_word_enable[23]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*25)-1:WIDTH*24] = ({wr1_word_enable[24],wr0_word_enable[24]} == 2'b01) ? wr0_data : (({wr1_word_enable[24],wr0_word_enable[24]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*26)-1:WIDTH*25] = ({wr1_word_enable[25],wr0_word_enable[25]} == 2'b01) ? wr0_data : (({wr1_word_enable[25],wr0_word_enable[25]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*27)-1:WIDTH*26] = ({wr1_word_enable[26],wr0_word_enable[26]} == 2'b01) ? wr0_data : (({wr1_word_enable[26],wr0_word_enable[26]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*28)-1:WIDTH*27] = ({wr1_word_enable[27],wr0_word_enable[27]} == 2'b01) ? wr0_data : (({wr1_word_enable[27],wr0_word_enable[27]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*29)-1:WIDTH*28] = ({wr1_word_enable[28],wr0_word_enable[28]} == 2'b01) ? wr0_data : (({wr1_word_enable[28],wr0_word_enable[28]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*30)-1:WIDTH*29] = ({wr1_word_enable[29],wr0_word_enable[29]} == 2'b01) ? wr0_data : (({wr1_word_enable[29],wr0_word_enable[29]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*31)-1:WIDTH*30] = ({wr1_word_enable[30],wr0_word_enable[30]} == 2'b01) ? wr0_data : (({wr1_word_enable[30],wr0_word_enable[30]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*32)-1:WIDTH*31] = ({wr1_word_enable[31],wr0_word_enable[31]} == 2'b01) ? wr0_data : (({wr1_word_enable[31],wr0_word_enable[31]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*33)-1:WIDTH*32] = ({wr1_word_enable[32],wr0_word_enable[32]} == 2'b01) ? wr0_data : (({wr1_word_enable[32],wr0_word_enable[32]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*34)-1:WIDTH*33] = ({wr1_word_enable[33],wr0_word_enable[33]} == 2'b01) ? wr0_data : (({wr1_word_enable[33],wr0_word_enable[33]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*35)-1:WIDTH*34] = ({wr1_word_enable[34],wr0_word_enable[34]} == 2'b01) ? wr0_data : (({wr1_word_enable[34],wr0_word_enable[34]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*36)-1:WIDTH*35] = ({wr1_word_enable[35],wr0_word_enable[35]} == 2'b01) ? wr0_data : (({wr1_word_enable[35],wr0_word_enable[35]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*37)-1:WIDTH*36] = ({wr1_word_enable[36],wr0_word_enable[36]} == 2'b01) ? wr0_data : (({wr1_word_enable[36],wr0_word_enable[36]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*38)-1:WIDTH*37] = ({wr1_word_enable[37],wr0_word_enable[37]} == 2'b01) ? wr0_data : (({wr1_word_enable[37],wr0_word_enable[37]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*39)-1:WIDTH*38] = ({wr1_word_enable[38],wr0_word_enable[38]} == 2'b01) ? wr0_data : (({wr1_word_enable[38],wr0_word_enable[38]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*40)-1:WIDTH*39] = ({wr1_word_enable[39],wr0_word_enable[39]} == 2'b01) ? wr0_data : (({wr1_word_enable[39],wr0_word_enable[39]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});

endmodule
module reg_40xX_2r_2w (
  rd0_addr,
  rd0_data,

  rd1_addr,
  rd1_data,

  wr0_en,
  wr0_addr,
  wr0_data,

  wr1_en,
  wr1_addr,
  wr1_data,

  clk,
  rst
);

parameter WIDTH = 64;

output [WIDTH-1:0] rd0_data;
input [5:0] rd0_addr;

output [WIDTH-1:0] rd1_data;
input [5:0] rd1_addr;

input wr0_en;
input [5:0] wr0_addr;
input [WIDTH-1:0] wr0_data;

input wr1_en;
input [5:0] wr1_addr;
input [WIDTH-1:0] wr1_data;

input clk;
input rst;

wire [(40*WIDTH)-1:0] word_out;
wire [(40*WIDTH)-1:0] word_in;
wire [39:0] wr_en_word;
wire [39:0] wr0_word_select;
wire [39:0] wr1_word_select;
wire [39:0] wr0_word_enable;
wire [39:0] wr1_word_enable;

mux_40xX_to_1xX #(WIDTH) mux_rd_port_0(
  .out(rd0_data),
  .in(word_out),
  .select(rd0_addr)
);

mux_40xX_to_1xX #(WIDTH) mux_rd_port_1(
  .out(rd1_data),
  .in(word_out),
  .select(rd1_addr)
);

decoder_6_to_40 decoder_wr_port_0(
  .out(wr0_word_select),
  .in(wr0_addr)
);

decoder_6_to_40 decoder_wr_port_1(
  .out(wr1_word_select),
  .in(wr1_addr)
);

register #(WIDTH) word[39:0](
  .out(word_out),
  .in(word_in),
  .wr_en(wr_en_word),
  .clk(clk),
  .rst(rst)
);

assign wr0_word_enable = {40{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {40{wr1_en}} & wr1_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable;

// %%start_veriperl
// my $i;
// my $i_plus_one;
// for($i=0; $i<40; $i=$i+1)
// {
//   $i_plus_one = $i + 1;
//   print "  assign word_in[(WIDTH*$i_plus_one)-1:WIDTH*$i] = ({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b01) ? wr0_data : (({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});\n";
// }
// %%stop_veriperl
  assign word_in[(WIDTH*1)-1:WIDTH*0] = ({wr1_word_enable[0],wr0_word_enable[0]} == 2'b01) ? wr0_data : (({wr1_word_enable[0],wr0_word_enable[0]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*2)-1:WIDTH*1] = ({wr1_word_enable[1],wr0_word_enable[1]} == 2'b01) ? wr0_data : (({wr1_word_enable[1],wr0_word_enable[1]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*3)-1:WIDTH*2] = ({wr1_word_enable[2],wr0_word_enable[2]} == 2'b01) ? wr0_data : (({wr1_word_enable[2],wr0_word_enable[2]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*4)-1:WIDTH*3] = ({wr1_word_enable[3],wr0_word_enable[3]} == 2'b01) ? wr0_data : (({wr1_word_enable[3],wr0_word_enable[3]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*5)-1:WIDTH*4] = ({wr1_word_enable[4],wr0_word_enable[4]} == 2'b01) ? wr0_data : (({wr1_word_enable[4],wr0_word_enable[4]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*6)-1:WIDTH*5] = ({wr1_word_enable[5],wr0_word_enable[5]} == 2'b01) ? wr0_data : (({wr1_word_enable[5],wr0_word_enable[5]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*7)-1:WIDTH*6] = ({wr1_word_enable[6],wr0_word_enable[6]} == 2'b01) ? wr0_data : (({wr1_word_enable[6],wr0_word_enable[6]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*8)-1:WIDTH*7] = ({wr1_word_enable[7],wr0_word_enable[7]} == 2'b01) ? wr0_data : (({wr1_word_enable[7],wr0_word_enable[7]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*9)-1:WIDTH*8] = ({wr1_word_enable[8],wr0_word_enable[8]} == 2'b01) ? wr0_data : (({wr1_word_enable[8],wr0_word_enable[8]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*10)-1:WIDTH*9] = ({wr1_word_enable[9],wr0_word_enable[9]} == 2'b01) ? wr0_data : (({wr1_word_enable[9],wr0_word_enable[9]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*11)-1:WIDTH*10] = ({wr1_word_enable[10],wr0_word_enable[10]} == 2'b01) ? wr0_data : (({wr1_word_enable[10],wr0_word_enable[10]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*12)-1:WIDTH*11] = ({wr1_word_enable[11],wr0_word_enable[11]} == 2'b01) ? wr0_data : (({wr1_word_enable[11],wr0_word_enable[11]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*13)-1:WIDTH*12] = ({wr1_word_enable[12],wr0_word_enable[12]} == 2'b01) ? wr0_data : (({wr1_word_enable[12],wr0_word_enable[12]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*14)-1:WIDTH*13] = ({wr1_word_enable[13],wr0_word_enable[13]} == 2'b01) ? wr0_data : (({wr1_word_enable[13],wr0_word_enable[13]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*15)-1:WIDTH*14] = ({wr1_word_enable[14],wr0_word_enable[14]} == 2'b01) ? wr0_data : (({wr1_word_enable[14],wr0_word_enable[14]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*16)-1:WIDTH*15] = ({wr1_word_enable[15],wr0_word_enable[15]} == 2'b01) ? wr0_data : (({wr1_word_enable[15],wr0_word_enable[15]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*17)-1:WIDTH*16] = ({wr1_word_enable[16],wr0_word_enable[16]} == 2'b01) ? wr0_data : (({wr1_word_enable[16],wr0_word_enable[16]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*18)-1:WIDTH*17] = ({wr1_word_enable[17],wr0_word_enable[17]} == 2'b01) ? wr0_data : (({wr1_word_enable[17],wr0_word_enable[17]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*19)-1:WIDTH*18] = ({wr1_word_enable[18],wr0_word_enable[18]} == 2'b01) ? wr0_data : (({wr1_word_enable[18],wr0_word_enable[18]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*20)-1:WIDTH*19] = ({wr1_word_enable[19],wr0_word_enable[19]} == 2'b01) ? wr0_data : (({wr1_word_enable[19],wr0_word_enable[19]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*21)-1:WIDTH*20] = ({wr1_word_enable[20],wr0_word_enable[20]} == 2'b01) ? wr0_data : (({wr1_word_enable[20],wr0_word_enable[20]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*22)-1:WIDTH*21] = ({wr1_word_enable[21],wr0_word_enable[21]} == 2'b01) ? wr0_data : (({wr1_word_enable[21],wr0_word_enable[21]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*23)-1:WIDTH*22] = ({wr1_word_enable[22],wr0_word_enable[22]} == 2'b01) ? wr0_data : (({wr1_word_enable[22],wr0_word_enable[22]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*24)-1:WIDTH*23] = ({wr1_word_enable[23],wr0_word_enable[23]} == 2'b01) ? wr0_data : (({wr1_word_enable[23],wr0_word_enable[23]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*25)-1:WIDTH*24] = ({wr1_word_enable[24],wr0_word_enable[24]} == 2'b01) ? wr0_data : (({wr1_word_enable[24],wr0_word_enable[24]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*26)-1:WIDTH*25] = ({wr1_word_enable[25],wr0_word_enable[25]} == 2'b01) ? wr0_data : (({wr1_word_enable[25],wr0_word_enable[25]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*27)-1:WIDTH*26] = ({wr1_word_enable[26],wr0_word_enable[26]} == 2'b01) ? wr0_data : (({wr1_word_enable[26],wr0_word_enable[26]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*28)-1:WIDTH*27] = ({wr1_word_enable[27],wr0_word_enable[27]} == 2'b01) ? wr0_data : (({wr1_word_enable[27],wr0_word_enable[27]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*29)-1:WIDTH*28] = ({wr1_word_enable[28],wr0_word_enable[28]} == 2'b01) ? wr0_data : (({wr1_word_enable[28],wr0_word_enable[28]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*30)-1:WIDTH*29] = ({wr1_word_enable[29],wr0_word_enable[29]} == 2'b01) ? wr0_data : (({wr1_word_enable[29],wr0_word_enable[29]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*31)-1:WIDTH*30] = ({wr1_word_enable[30],wr0_word_enable[30]} == 2'b01) ? wr0_data : (({wr1_word_enable[30],wr0_word_enable[30]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*32)-1:WIDTH*31] = ({wr1_word_enable[31],wr0_word_enable[31]} == 2'b01) ? wr0_data : (({wr1_word_enable[31],wr0_word_enable[31]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*33)-1:WIDTH*32] = ({wr1_word_enable[32],wr0_word_enable[32]} == 2'b01) ? wr0_data : (({wr1_word_enable[32],wr0_word_enable[32]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*34)-1:WIDTH*33] = ({wr1_word_enable[33],wr0_word_enable[33]} == 2'b01) ? wr0_data : (({wr1_word_enable[33],wr0_word_enable[33]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*35)-1:WIDTH*34] = ({wr1_word_enable[34],wr0_word_enable[34]} == 2'b01) ? wr0_data : (({wr1_word_enable[34],wr0_word_enable[34]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*36)-1:WIDTH*35] = ({wr1_word_enable[35],wr0_word_enable[35]} == 2'b01) ? wr0_data : (({wr1_word_enable[35],wr0_word_enable[35]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*37)-1:WIDTH*36] = ({wr1_word_enable[36],wr0_word_enable[36]} == 2'b01) ? wr0_data : (({wr1_word_enable[36],wr0_word_enable[36]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*38)-1:WIDTH*37] = ({wr1_word_enable[37],wr0_word_enable[37]} == 2'b01) ? wr0_data : (({wr1_word_enable[37],wr0_word_enable[37]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*39)-1:WIDTH*38] = ({wr1_word_enable[38],wr0_word_enable[38]} == 2'b01) ? wr0_data : (({wr1_word_enable[38],wr0_word_enable[38]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});
  assign word_in[(WIDTH*40)-1:WIDTH*39] = ({wr1_word_enable[39],wr0_word_enable[39]} == 2'b01) ? wr0_data : (({wr1_word_enable[39],wr0_word_enable[39]} == 2'b10) ? wr1_data : {WIDTH{1'bx}});

endmodule

module reg_40xX_2r_3w (
  rd0_addr,
  rd0_data,

  rd1_addr,
  rd1_data,

  wr0_en,
  wr0_addr,
  wr0_data,

  wr1_en,
  wr1_addr,
  wr1_data,

  wr2_en,
  wr2_addr,
  wr2_data,

  clk,
  rst
);

parameter WIDTH = 64;

output [WIDTH-1:0] rd0_data;
input [5:0] rd0_addr;

output [WIDTH-1:0] rd1_data;
input [5:0] rd1_addr;

input wr0_en;
input [5:0] wr0_addr;
input [WIDTH-1:0] wr0_data;

input wr1_en;
input [5:0] wr1_addr;
input [WIDTH-1:0] wr1_data;

input wr2_en;
input [5:0] wr2_addr;
input [WIDTH-1:0] wr2_data;

input clk;
input rst;

wire [(40*WIDTH)-1:0] word_out;
wire [(40*WIDTH)-1:0] word_in;
wire [39:0] wr_en_word;
wire [39:0] wr0_word_select;
wire [39:0] wr1_word_select;
wire [39:0] wr2_word_select;
wire [39:0] wr0_word_enable;
wire [39:0] wr1_word_enable;
wire [39:0] wr2_word_enable;

mux_40xX_to_1xX #(WIDTH) mux_rd_port_0(
  .out(rd0_data),
  .in(word_out),
  .select(rd0_addr)
);

mux_40xX_to_1xX #(WIDTH) mux_rd_port_1(
  .out(rd1_data),
  .in(word_out),
  .select(rd1_addr)
);

decoder_6_to_40 decoder_wr_port_0(
  .out(wr0_word_select),
  .in(wr0_addr)
);

decoder_6_to_40 decoder_wr_port_1(
  .out(wr1_word_select),
  .in(wr1_addr)
);

decoder_6_to_40 decoder_wr_port_2(
  .out(wr2_word_select),
  .in(wr2_addr)
);

register #(WIDTH) word[39:0](
  .out(word_out),
  .in(word_in),
  .wr_en(wr_en_word),
  .clk(clk),
  .rst(rst)
);

assign wr0_word_enable = {40{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {40{wr1_en}} & wr1_word_select;
assign wr2_word_enable = {40{wr2_en}} & wr2_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable | wr2_word_enable;

// %%start_veriperl
// my $i;
// my $i_plus_one;
// for($i=0; $i<40; $i=$i+1)
// {
//   $i_plus_one = $i + 1;
//   print "  assign word_in[(WIDTH*$i_plus_one)-1:WIDTH*$i] = ({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b001) ? wr0_data : (({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b010) ? wr1_data : (({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));\n";
// }
// %%stop_veriperl
  assign word_in[(WIDTH*1)-1:WIDTH*0] = ({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b001) ? wr0_data : (({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b010) ? wr1_data : (({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*2)-1:WIDTH*1] = ({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b001) ? wr0_data : (({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b010) ? wr1_data : (({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*3)-1:WIDTH*2] = ({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b001) ? wr0_data : (({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b010) ? wr1_data : (({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*4)-1:WIDTH*3] = ({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b001) ? wr0_data : (({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b010) ? wr1_data : (({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*5)-1:WIDTH*4] = ({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b001) ? wr0_data : (({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b010) ? wr1_data : (({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*6)-1:WIDTH*5] = ({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b001) ? wr0_data : (({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b010) ? wr1_data : (({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*7)-1:WIDTH*6] = ({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b001) ? wr0_data : (({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b010) ? wr1_data : (({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*8)-1:WIDTH*7] = ({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b001) ? wr0_data : (({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b010) ? wr1_data : (({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*9)-1:WIDTH*8] = ({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b001) ? wr0_data : (({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b010) ? wr1_data : (({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*10)-1:WIDTH*9] = ({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b001) ? wr0_data : (({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b010) ? wr1_data : (({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*11)-1:WIDTH*10] = ({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b001) ? wr0_data : (({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b010) ? wr1_data : (({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*12)-1:WIDTH*11] = ({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b001) ? wr0_data : (({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b010) ? wr1_data : (({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*13)-1:WIDTH*12] = ({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b001) ? wr0_data : (({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b010) ? wr1_data : (({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*14)-1:WIDTH*13] = ({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b001) ? wr0_data : (({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b010) ? wr1_data : (({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*15)-1:WIDTH*14] = ({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b001) ? wr0_data : (({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b010) ? wr1_data : (({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*16)-1:WIDTH*15] = ({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b001) ? wr0_data : (({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b010) ? wr1_data : (({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*17)-1:WIDTH*16] = ({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b001) ? wr0_data : (({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b010) ? wr1_data : (({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*18)-1:WIDTH*17] = ({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b001) ? wr0_data : (({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b010) ? wr1_data : (({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*19)-1:WIDTH*18] = ({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b001) ? wr0_data : (({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b010) ? wr1_data : (({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*20)-1:WIDTH*19] = ({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b001) ? wr0_data : (({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b010) ? wr1_data : (({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*21)-1:WIDTH*20] = ({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b001) ? wr0_data : (({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b010) ? wr1_data : (({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*22)-1:WIDTH*21] = ({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b001) ? wr0_data : (({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b010) ? wr1_data : (({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*23)-1:WIDTH*22] = ({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b001) ? wr0_data : (({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b010) ? wr1_data : (({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*24)-1:WIDTH*23] = ({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b001) ? wr0_data : (({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b010) ? wr1_data : (({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*25)-1:WIDTH*24] = ({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b001) ? wr0_data : (({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b010) ? wr1_data : (({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*26)-1:WIDTH*25] = ({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b001) ? wr0_data : (({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b010) ? wr1_data : (({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*27)-1:WIDTH*26] = ({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b001) ? wr0_data : (({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b010) ? wr1_data : (({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*28)-1:WIDTH*27] = ({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b001) ? wr0_data : (({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b010) ? wr1_data : (({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*29)-1:WIDTH*28] = ({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b001) ? wr0_data : (({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b010) ? wr1_data : (({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*30)-1:WIDTH*29] = ({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b001) ? wr0_data : (({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b010) ? wr1_data : (({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*31)-1:WIDTH*30] = ({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b001) ? wr0_data : (({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b010) ? wr1_data : (({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*32)-1:WIDTH*31] = ({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b001) ? wr0_data : (({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b010) ? wr1_data : (({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*33)-1:WIDTH*32] = ({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b001) ? wr0_data : (({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b010) ? wr1_data : (({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*34)-1:WIDTH*33] = ({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b001) ? wr0_data : (({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b010) ? wr1_data : (({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*35)-1:WIDTH*34] = ({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b001) ? wr0_data : (({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b010) ? wr1_data : (({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*36)-1:WIDTH*35] = ({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b001) ? wr0_data : (({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b010) ? wr1_data : (({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*37)-1:WIDTH*36] = ({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b001) ? wr0_data : (({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b010) ? wr1_data : (({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*38)-1:WIDTH*37] = ({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b001) ? wr0_data : (({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b010) ? wr1_data : (({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*39)-1:WIDTH*38] = ({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b001) ? wr0_data : (({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b010) ? wr1_data : (({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));
  assign word_in[(WIDTH*40)-1:WIDTH*39] = ({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b001) ? wr0_data : (({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b010) ? wr1_data : (({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b100) ? wr2_data : {WIDTH{1'bx}}));

endmodule

module wr_port_40x64b_8_to_1 (
   select,

   port0_wr_en,
   port0_wr_addr,
   port0_wr_data,

   port1_wr_en,
   port1_wr_addr,
   port1_wr_data,

   port2_wr_en,
   port2_wr_addr,
   port2_wr_data,

   port3_wr_en,
   port3_wr_addr,
   port3_wr_data,

   port4_wr_en,
   port4_wr_addr,
   port4_wr_data,

   port5_wr_en,
   port5_wr_addr,
   port5_wr_data,

   port6_wr_en,
   port6_wr_addr,
   port6_wr_data,

   port7_wr_en,
   port7_wr_addr,
   port7_wr_data,

   muxed_port_wr_en,
   muxed_port_wr_addr,
   muxed_port_wr_data
);

   output muxed_port_wr_en;
   output [5:0] muxed_port_wr_addr;
   output [63:0] muxed_port_wr_data;

   input [7:0] select;

   input port0_wr_en;
   input [5:0] port0_wr_addr;
   input [63:0] port0_wr_data;

   input port1_wr_en;
   input [5:0] port1_wr_addr;
   input [63:0] port1_wr_data;

   input port2_wr_en;
   input [5:0] port2_wr_addr;
   input [63:0] port2_wr_data;

   input port3_wr_en;
   input [5:0] port3_wr_addr;
   input [63:0] port3_wr_data;

   input port4_wr_en;
   input [5:0] port4_wr_addr;
   input [63:0] port4_wr_data;

   input port5_wr_en;
   input [5:0] port5_wr_addr;
   input [63:0] port5_wr_data;

   input port6_wr_en;
   input [5:0] port6_wr_addr;
   input [63:0] port6_wr_data;

   input port7_wr_en;
   input [5:0] port7_wr_addr;
   input [63:0] port7_wr_data;

   reg muxed_port_wr_en;
   reg [5:0] muxed_port_wr_addr;
   reg [63:0] muxed_port_wr_data;

   always @ ( select or
      port0_wr_en or port1_wr_en or port2_wr_en or port3_wr_en or port4_wr_en or
      port5_wr_en or port6_wr_en or port7_wr_en or
      port0_wr_addr or port1_wr_addr or port2_wr_addr or port3_wr_addr or
      port4_wr_addr or port5_wr_addr or port6_wr_addr or port7_wr_addr or
      port0_wr_data or port1_wr_data or port2_wr_data or port3_wr_data or
      port4_wr_data or port5_wr_data or port6_wr_data or port7_wr_data)
    begin
       casex(select)
         8'b00000001:
           begin
             muxed_port_wr_en <= port0_wr_en;
             muxed_port_wr_addr <= port0_wr_addr;
             muxed_port_wr_data <= port0_wr_data;
           end
         8'b00000010:
           begin
             muxed_port_wr_en <= port1_wr_en;
             muxed_port_wr_addr <= port1_wr_addr;
             muxed_port_wr_data <= port1_wr_data;
           end
         8'b00000100:
           begin
             muxed_port_wr_en <= port2_wr_en;
             muxed_port_wr_addr <= port2_wr_addr;
             muxed_port_wr_data <= port2_wr_data;
           end
         8'b00001000:
           begin
             muxed_port_wr_en <= port3_wr_en;
             muxed_port_wr_addr <= port3_wr_addr;
             muxed_port_wr_data <= port3_wr_data;
           end
         8'b00010000:
           begin
             muxed_port_wr_en <= port4_wr_en;
             muxed_port_wr_addr <= port4_wr_addr;
             muxed_port_wr_data <= port4_wr_data;
           end
         8'b00100000:
           begin
             muxed_port_wr_en <= port5_wr_en;
             muxed_port_wr_addr <= port5_wr_addr;
             muxed_port_wr_data <= port5_wr_data;
           end
         8'b01000000:
           begin
             muxed_port_wr_en <= port6_wr_en;
             muxed_port_wr_addr <= port6_wr_addr;
             muxed_port_wr_data <= port6_wr_data;
           end
         8'b10000000:
           begin
             muxed_port_wr_en <= port7_wr_en;
             muxed_port_wr_addr <= port7_wr_addr;
             muxed_port_wr_data <= port7_wr_data;
           end
         8'b00000000:
           begin
             muxed_port_wr_en <= 1'b0;
             muxed_port_wr_addr <= {6{1'bx}};
             muxed_port_wr_data <= {64{1'bx}};
           end
         default:
           begin
             muxed_port_wr_en <= 1'b0;
             muxed_port_wr_addr <= {6{1'bx}};
             muxed_port_wr_data <= {64{1'bx}};
           end
       endcase
  end

endmodule
module add_wraparound_after40 (
	out_value,
	in_value_1,
	in_value_2
);

output[5:0] out_value;
input[5:0] in_value_1, in_value_2;

wire[5:0] inter_sum;
wire[6:0] inter_sub_40;
wire cout1, cout2, is_less_than_40;

adder6bit a6b(inter_sum, cout1, in_value_1, in_value_2); // adding two inputs
adder7bit a7b(inter_sub_40, cout2, {cout1, inter_sum}, 7'b1011000); // sum - 40 is output if sum is > 40

assign is_less_than_40 = inter_sub_40[6];
assign out_value = is_less_than_40 ? inter_sum : inter_sub_40[5:0];

endmodule
module adder(in,out);
input [31:0]in;
output [31:0]out;

//wire [31:0]carry;
wire carry;

//adder1bit b1 [31:0] (out, carry, in, 32'd4, {carry[30:0],1'b0});
assign {carry, out} = in + 4;

endmodule
module adder6bit (
	sum,
	cout,
	in1,
	in2
);

output[5:0] sum;
output cout;

input[5:0] in1, in2;

wire cout0, cout1, cout2, cout3, cout4;

adder1bit add0(sum[0], cout0, in1[0], in2[0], 1'b0);
adder1bit add1(sum[1], cout1, in1[1], in2[1], cout0);
adder1bit add2(sum[2], cout2, in1[2], in2[2], cout1);
adder1bit add3(sum[3], cout3, in1[3], in2[3], cout2);
adder1bit add4(sum[4], cout4, in1[4], in2[4], cout3);
adder1bit add5(sum[5], cout, in1[5], in2[5], cout4);

endmodule
module adder7bit (
	sum,
	cout,
	in1,
	in2
);

output[6:0] sum;
output cout;

input[6:0] in1, in2;

wire cout0, cout1, cout2, cout3, cout4, cout5;

adder1bit add0(sum[0], cout0, in1[0], in2[0], 1'b0);
adder1bit add1(sum[1], cout1, in1[1], in2[1], cout0);
adder1bit add2(sum[2], cout2, in1[2], in2[2], cout1);
adder1bit add3(sum[3], cout3, in1[3], in2[3], cout2);
adder1bit add4(sum[4], cout4, in1[4], in2[4], cout3);
adder1bit add5(sum[5], cout5, in1[5], in2[5], cout4);
adder1bit add6(sum[6], cout, in1[6], in2[6], cout5);

endmodule
module decoder(in,out);
input [5:0] in;
output [39:0] out;

reg [39:0]out;

always@(in)
begin
 out = 40'd0;
case (in)
0: out[0]=1'b1;
1: out[1]=1'b1;
2: out[2]=1'b1;
3: out[3]=1'b1;
4: out[4]=1'b1;
5: out[5]=1'b1;
6: out[6]=1'b1;
7: out[7]=1'b1;
8: out[8]=1'b1;
9: out[9]=1'b1;
10: out[10]=1'b1;
11: out[11]=1'b1;
12: out[12]=1'b1;
13: out[13]=1'b1;
14: out[14]=1'b1;
15: out[15]=1'b1;
16: out[16]=1'b1;
17: out[17]=1'b1;
18: out[18]=1'b1;
19: out[19]=1'b1;
20: out[20]=1'b1;
21: out[21]=1'b1;
22: out[22]=1'b1;
23: out[23]=1'b1;
24: out[24]=1'b1;
25: out[25]=1'b1;
26: out[26]=1'b1;
27: out[27]=1'b1;
28: out[28]=1'b1;
29: out[29]=1'b1;
30: out[30]=1'b1;
31: out[31]=1'b1;
32: out[32]=1'b1;
33: out[33]=1'b1;
34: out[34]=1'b1;
35: out[35]=1'b1;
36: out[36]=1'b1;
37: out[37]=1'b1;
38: out[38]=1'b1;
39: out[39]=1'b1;
endcase
end
endmodule
module dff_clr (q, d, clk, rst);

   output         q;
   input          d;
   input          clk;
   input          rst;

   reg            state;

   assign q = state;

   always @(posedge clk or posedge rst)
   begin
      state <= rst? 1 : d;
   end










endmodule

module dff_en_fixed_reset_value (
	out_value,
	in_value,
	reset_value,
	en,
	clk,
	rst
);

output[5:0] out_value;
input[5:0] reset_value, in_value;
input en, clk, rst;

wire[5:0] dff_in_value;

assign dff_in_value = rst ? reset_value : in_value;

dff_en ff[5:0](out_value, dff_in_value, en, clk, 1'b0);

endmodule
module fetch(
      dispatch2cu_wf_dispatch,
      dispatch2cu_wf_tag_dispatch,
      dispatch2cu_start_pc_dispatch,
      dispatch2cu_vgpr_base_dispatch,
      dispatch2cu_sgpr_base_dispatch,
      dispatch2cu_lds_base_dispatch,
      dispatch2cu_wf_size_dispatch,
      dispatch2cu_wg_wf_count,
      buff_ack,
      wave_stop_fetch,
      issue_wf_done_en,
      issue_wf_done_wf_id,
      issue_wg_wfid,
      salu_branch_wfid,
      salu_branch_en,
      salu_branch_taken,
      salu_branch_pc_value,
      cu2dispatch_wf_tag_done,
      cu2dispatch_wf_done,
      buff_addr,
      buff_tag,
      buff_rd_en,
      wave_reserve_slotid,
      wave_reserve_valid,
      wave_basereg_wr,
      wave_basereg_wfid,
      wave_vgpr_base,
      wave_sgpr_base,
      wave_lds_base,
      exec_init_wf_en,
      exec_init_wf_id,
      exec_init_value,
      issue_wg_wgid,
      issue_wg_wf_count,
      tracemon_dispatch,
      tracemon_wf_tag_dispatch,
      tracemon_new_wfid,
      clk,
      rst
 );

input clk;

input rst;

input dispatch2cu_wf_dispatch, buff_ack, issue_wf_done_en, salu_branch_en,
         salu_branch_taken;
input[3:0] dispatch2cu_wg_wf_count;
input[5:0] dispatch2cu_wf_size_dispatch, issue_wf_done_wf_id, issue_wg_wfid,
         salu_branch_wfid;
input[8:0] dispatch2cu_sgpr_base_dispatch;
input[9:0] dispatch2cu_vgpr_base_dispatch;
input[14:0] dispatch2cu_wf_tag_dispatch;
input[15:0] dispatch2cu_lds_base_dispatch;
input[31:0] dispatch2cu_start_pc_dispatch, salu_branch_pc_value;
input[39:0] wave_stop_fetch;

output cu2dispatch_wf_done, buff_rd_en, wave_reserve_valid, wave_basereg_wr,
         exec_init_wf_en, tracemon_dispatch;
output[3:0] issue_wg_wf_count;
output[5:0] wave_reserve_slotid, wave_basereg_wfid, exec_init_wf_id,
         issue_wg_wgid, tracemon_new_wfid;
output[8:0] wave_sgpr_base;
output[9:0] wave_vgpr_base;
output[14:0] cu2dispatch_wf_tag_done;
output[14:0] tracemon_wf_tag_dispatch;
output[15:0] wave_lds_base;
output[31:0] buff_addr;
output[38:0] buff_tag;
output[63:0] exec_init_value;

///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////

wire fetch_instr_en;
wire [39:0] vacant_next;
wire wf_dispatch;
wire wr;
wire [3:0]  wg_wf_count;
wire [14:0] wf_tag_dispatch;
wire fetch_valid;
wire [31:0] start_pc_dispatch;
wire [5:0] wf_size_dispatch;
wire [39:0] vacant;
wire vacant_reg_wr;
wire [5:0] buff_tag_sch;
wire [32:0] buff_addr_init;
wire [5:0] new_wfid;

wire branch_wr, pcblk_wr;
wire [31:0] pcblk_pc;
wire [5:0] pcblk_wfid;

assign buff_rd_en = fetch_instr_en;
assign wave_basereg_wfid = new_wfid;
assign exec_init_wf_en = wr;
assign exec_init_wf_id = wave_basereg_wfid;
assign buff_tag = {buff_addr_init[32], buff_tag_sch, buff_addr_init[31:0]};
assign wave_basereg_wr = wr;
assign cu2dispatch_wf_done = issue_wf_done_en;
assign wave_reserve_slotid = buff_tag_sch;
assign vacant_reg_wr = (wr | issue_wf_done_en);
assign buff_addr = buff_addr_init[31:0];

assign branch_wr = salu_branch_en & salu_branch_taken;
assign pcblk_pc = branch_wr ? salu_branch_pc_value : start_pc_dispatch;
assign pcblk_wfid = branch_wr ? salu_branch_wfid : new_wfid;
assign pcblk_wr = branch_wr | wr;

// tracemon signals
assign tracemon_dispatch = wf_dispatch;
assign tracemon_wf_tag_dispatch = wf_tag_dispatch;
assign tracemon_new_wfid = new_wfid;

regfile #(93) dispatch_info_latch (
      { dispatch2cu_wf_dispatch, dispatch2cu_wf_tag_dispatch,
        dispatch2cu_start_pc_dispatch, dispatch2cu_vgpr_base_dispatch,
        dispatch2cu_sgpr_base_dispatch, dispatch2cu_lds_base_dispatch,
        dispatch2cu_wf_size_dispatch, dispatch2cu_wg_wf_count },
      1'b1,
      { wf_dispatch, wf_tag_dispatch, start_pc_dispatch,
        wave_vgpr_base, wave_sgpr_base, wave_lds_base,
        wf_size_dispatch, wg_wf_count },
      clk, rst
);

wfid_generator wfgen (
      issue_wf_done_en, wf_tag_dispatch, issue_wf_done_wf_id,
      vacant, vacant_next, new_wfid,
      cu2dispatch_wf_tag_done, clk, wr, rst
);

wavegrp_info wginfo (
      wf_dispatch, wf_tag_dispatch,
      wg_wf_count, new_wfid,
      issue_wf_done_en, issue_wf_done_wf_id,
      issue_wg_wfid, issue_wg_wgid, issue_wg_wf_count,
      clk, rst
);

regfile_clr #(40) vacant_reg (
      vacant_next, vacant_reg_wr,
      vacant, clk, rst
);

fetch_controller fcontrol (
      wf_dispatch, fetch_valid,
      wr, fetch_instr_en, wave_reserve_valid
);

round_robin scheduler (
      fetch_valid, buff_tag_sch, wave_stop_fetch,
      buff_ack, vacant, clk, rst
);

pc_block pcb1 (
      pcblk_pc, pcblk_wfid, pcblk_wr,
      fetch_instr_en, buff_tag_sch,
      buff_addr_init, clk, rst
);

mask_gen execmaskgen (wf_size_dispatch, exec_init_value);

endmodule
module fetch_controller (
	WF_dispatch_i, 
	fetch_valid, 
	wr, 
	inst_buff_rd, 
	wave_reserve_valid
);

input WF_dispatch_i;
input fetch_valid;

output wr;
output inst_buff_rd;
output wave_reserve_valid;

assign wr = WF_dispatch_i;
assign wave_reserve_valid = fetch_valid;
assign inst_buff_rd = fetch_valid;

endmodule
module incr_wraparound_at40 (
	out_value,
	in_value
);

output[5:0] out_value;
input[5:0] in_value;

wire[5:0] inter_sum;
wire ign_cout;

adder6bit a6b(inter_sum, ign_cout, in_value, 6'b000001);

assign out_value = (inter_sum == 6'b101000) ? 6'b000000 : inter_sum;

endmodule
module mask_gen(in,out);

input [5:0]in;
output [63:0]out;

assign out = (in == 6'd0) ? 64'h0000000000000001:
             (in == 6'd1) ? 64'h0000000000000003:
			 (in == 6'd2) ? 64'h0000000000000007:
			 (in == 6'd3) ? 64'h000000000000000f:
			 (in == 6'd4) ? 64'h000000000000001f:
			 (in == 6'd5) ? 64'h000000000000003f:
			 (in == 6'd6) ? 64'h000000000000007f:
			 (in == 6'd7) ? 64'h00000000000000ff:
			 (in == 6'd8) ? 64'h00000000000001ff:
			 (in == 6'd9) ? 64'h00000000000003ff:
			 (in == 6'd10) ? 64'h00000000000007ff:
			 (in == 6'd11) ? 64'h0000000000000fff:
			 (in == 6'd12) ? 64'h0000000000001fff:
			 (in == 6'd13) ? 64'h0000000000003fff:
			 (in == 6'd14) ? 64'h0000000000007fff:
			 (in == 6'd15) ? 64'h000000000000ffff:
			 (in == 6'd16) ? 64'h000000000001ffff:
			 (in == 6'd17) ? 64'h000000000003ffff:
			 (in == 6'd18) ? 64'h000000000007ffff:
			 (in == 6'd19) ? 64'h00000000000fffff:
			 (in == 6'd20) ? 64'h00000000001fffff:
			 (in == 6'd21) ? 64'h00000000003fffff:
			 (in == 6'd22) ? 64'h00000000007fffff:
			 (in == 6'd23) ? 64'h0000000000ffffff:
			 (in == 6'd24) ? 64'h0000000001ffffff:
			 (in == 6'd25) ? 64'h0000000003ffffff:
			 (in == 6'd26) ? 64'h0000000007ffffff:
			 (in == 6'd27) ? 64'h000000000fffffff:
			 (in == 6'd28) ? 64'h000000001fffffff:
			 (in == 6'd29) ? 64'h000000003fffffff:
			 (in == 6'd30) ? 64'h000000007fffffff:
			 (in == 6'd31) ? 64'h00000000ffffffff:
			 (in == 6'd32) ? 64'h00000001ffffffff:
			 (in == 6'd33) ? 64'h00000003ffffffff:
			 (in == 6'd34) ? 64'h00000007ffffffff:
			 (in == 6'd35) ? 64'h0000000fffffffff:
			 (in == 6'd36) ? 64'h0000001fffffffff:
			 (in == 6'd37) ? 64'h0000003fffffffff:
			 (in == 6'd38) ? 64'h0000007fffffffff:
			 (in == 6'd39) ? 64'h000000ffffffffff:
			 (in == 6'd40) ? 64'h000001ffffffffff:
			 (in == 6'd41) ? 64'h000003ffffffffff:
			 (in == 6'd42) ? 64'h000007ffffffffff:
			 (in == 6'd43) ? 64'h00000fffffffffff:
			 (in == 6'd44) ? 64'h00001fffffffffff:
			 (in == 6'd45) ? 64'h00003fffffffffff:
			 (in == 6'd46) ? 64'h00007fffffffffff:
			 (in == 6'd47) ? 64'h0000ffffffffffff:
			 (in == 6'd48) ? 64'h0001ffffffffffff:
			 (in == 6'd49) ? 64'h0003ffffffffffff:
			 (in == 6'd50) ? 64'h0007ffffffffffff:
			 (in == 6'd51) ? 64'h000fffffffffffff:
			 (in == 6'd52) ? 64'h001fffffffffffff:
			 (in == 6'd53) ? 64'h003fffffffffffff:
			 (in == 6'd54) ? 64'h007fffffffffffff:
			 (in == 6'd55) ? 64'h00ffffffffffffff:
			 (in == 6'd56) ? 64'h01ffffffffffffff:
			 (in == 6'd57) ? 64'h03ffffffffffffff:
			 (in == 6'd58) ? 64'h07ffffffffffffff:
			 (in == 6'd59) ? 64'h0fffffffffffffff:
			 (in == 6'd60) ? 64'h1fffffffffffffff:
			 (in == 6'd61) ? 64'h3fffffffffffffff:
			 (in == 6'd62) ? 64'h7fffffffffffffff:
			 (in == 6'd63) ? 64'hffffffffffffffff:
			 64'd0;
			 
endmodulemodule mux4to1_6bit (
	out,
	input0,
	input1,
	input2,
	input3,
	select
);

output[5:0] out;

input[5:0] input0, input1, input2, input3;
input[1:0] select;

assign out = (input0 & {6{(select == 2'b00)}}) |
			 (input1 & {6{(select == 2'b01)}}) |
			 (input2 & {6{(select == 2'b10)}}) |
			 (input3 & {6{(select == 2'b11)}});

endmodule
module pc_block (
	new_pc_init, 
	wf_id, 
	wr, 
	rd_en, 
	wf_id_rd, 
	pc_read2ibuff, 
	clk, 
	rst
);

parameter BITWIDTH = 32;

input [31:0] new_pc_init;
input [5:0] wf_id;
input wr;
input clk, rst;
input rd_en;
input [5:0] wf_id_rd;

output [32:0]pc_read2ibuff;

wire write;
wire [31:0] pc_read;
wire [32:0] data0, data_flop0;
wire [32:0] data1, data_flop1;
wire [32:0] data2, data_flop2;
wire [32:0] data3, data_flop3;
wire [32:0] data4, data_flop4;
wire [32:0] data5, data_flop5;
wire [32:0] data6, data_flop6;
wire [32:0] data7, data_flop7;
wire [32:0] data8, data_flop8;
wire [32:0] data9, data_flop9;
wire [32:0] data10, data_flop10;
wire [32:0] data11, data_flop11;
wire [32:0] data12, data_flop12;
wire [32:0] data13, data_flop13;
wire [32:0] data14, data_flop14;
wire [32:0] data15, data_flop15;
wire [32:0] data16, data_flop16;
wire [32:0] data17, data_flop17;
wire [32:0] data18, data_flop18;
wire [32:0] data19, data_flop19;
wire [32:0] data20, data_flop20;
wire [32:0] data21, data_flop21;
wire [32:0] data22, data_flop22;
wire [32:0] data23, data_flop23;
wire [32:0] data24, data_flop24;
wire [32:0] data25, data_flop25;
wire [32:0] data26, data_flop26;
wire [32:0] data27, data_flop27;
wire [32:0] data28, data_flop28;
wire [32:0] data29, data_flop29;
wire [32:0] data30, data_flop30;
wire [32:0] data31, data_flop31;
wire [32:0] data32, data_flop32;
wire [32:0] data33, data_flop33;
wire [32:0] data34, data_flop34;
wire [32:0] data35, data_flop35;
wire [32:0] data36, data_flop36;
wire [32:0] data37, data_flop37;
wire [32:0] data38, data_flop38;
wire [32:0] data39, data_flop39;

   assign write = 1'b1;  

     regfile #(33) rfile0 (data0, write, data_flop0, clk, rst);
	 regfile #(33) rfile1 (data1, write, data_flop1, clk, rst);
	 regfile #(33) rfile2 (data2, write, data_flop2, clk, rst);
	 regfile #(33) rfile3 (data3, write, data_flop3, clk, rst);
	 regfile #(33) rfile4 (data4, write, data_flop4, clk, rst);
	 regfile #(33) rfile5 (data5, write, data_flop5, clk, rst);
	 regfile #(33) rfile6 (data6, write, data_flop6, clk, rst);
	 regfile #(33) rfile7 (data7, write, data_flop7, clk, rst);
	 regfile #(33) rfile8 (data8, write, data_flop8, clk, rst);
	 regfile #(33) rfile9 (data9, write, data_flop9, clk, rst);
	 regfile #(33) rfile10 (data10, write, data_flop10, clk, rst);
	 regfile #(33) rfile11 (data11, write, data_flop11, clk, rst);
	 regfile #(33) rfile12 (data12, write, data_flop12, clk, rst);
	 regfile #(33) rfile13 (data13, write, data_flop13, clk, rst);
	 regfile #(33) rfile14 (data14, write, data_flop14, clk, rst);
	 regfile #(33) rfile15 (data15, write, data_flop15, clk, rst);
	 regfile #(33) rfile16 (data16, write, data_flop16, clk, rst);
	 regfile #(33) rfile17 (data17, write, data_flop17, clk, rst);
	 regfile #(33) rfile18 (data18, write, data_flop18, clk, rst);
	 regfile #(33) rfile19 (data19, write, data_flop19, clk, rst);
	 regfile #(33) rfile20 (data20, write, data_flop20, clk, rst);
	 regfile #(33) rfile21 (data21, write, data_flop21, clk, rst);
	 regfile #(33) rfile22 (data22, write, data_flop22, clk, rst);
	 regfile #(33) rfile23 (data23, write, data_flop23, clk, rst);
	 regfile #(33) rfile24 (data24, write, data_flop24, clk, rst);
	 regfile #(33) rfile25 (data25, write, data_flop25, clk, rst);
	 regfile #(33) rfile26 (data26, write, data_flop26, clk, rst);
	 regfile #(33) rfile27 (data27, write, data_flop27, clk, rst);
	 regfile #(33) rfile28 (data28, write, data_flop28, clk, rst);
	 regfile #(33) rfile29 (data29, write, data_flop29, clk, rst);
	 regfile #(33) rfile30 (data30, write, data_flop30, clk, rst);
	 regfile #(33) rfile31 (data31, write, data_flop31, clk, rst);
	 regfile #(33) rfile32 (data32, write, data_flop32, clk, rst);
	 regfile #(33) rfile33 (data33, write, data_flop33, clk, rst);
	 regfile #(33) rfile34 (data34, write, data_flop34, clk, rst);
	 regfile #(33) rfile35 (data35, write, data_flop35, clk, rst);
	 regfile #(33) rfile36 (data36, write, data_flop36, clk, rst);
	 regfile #(33) rfile37 (data37, write, data_flop37, clk, rst);
	 regfile #(33) rfile38 (data38, write, data_flop38, clk, rst);
	 regfile #(33) rfile39 (data39, write, data_flop39, clk, rst);
	 
   adder a1(pc_read2ibuff[31:0],pc_read);
   assign pc_read2ibuff = (wf_id_rd==6'd0)?data_flop0:
                   (wf_id_rd==6'd1)?data_flop1:
				   (wf_id_rd==6'd2)?data_flop2:
				   (wf_id_rd==6'd3)?data_flop3:
				   (wf_id_rd==6'd4)?data_flop4:
				   (wf_id_rd==6'd5)?data_flop5:
				   (wf_id_rd==6'd6)?data_flop6:
				   (wf_id_rd==6'd7)?data_flop7:
				   (wf_id_rd==6'd8)?data_flop8:
				   (wf_id_rd==6'd9)?data_flop9:
				   (wf_id_rd==6'd10)?data_flop10:
				   (wf_id_rd==6'd11)?data_flop11:
				   (wf_id_rd==6'd12)?data_flop12:
				   (wf_id_rd==6'd13)?data_flop13:
				   (wf_id_rd==6'd14)?data_flop14:
				   (wf_id_rd==6'd15)?data_flop15:
				   (wf_id_rd==6'd16)?data_flop16:
				   (wf_id_rd==6'd17)?data_flop17:
				   (wf_id_rd==6'd18)?data_flop18:
				   (wf_id_rd==6'd19)?data_flop19:
				   (wf_id_rd==6'd20)?data_flop20:
				   (wf_id_rd==6'd21)?data_flop21:
				   (wf_id_rd==6'd22)?data_flop22:
				   (wf_id_rd==6'd23)?data_flop23:
				   (wf_id_rd==6'd24)?data_flop24:
				   (wf_id_rd==6'd25)?data_flop25:
				   (wf_id_rd==6'd26)?data_flop26:
				   (wf_id_rd==6'd27)?data_flop27:
				   (wf_id_rd==6'd28)?data_flop28:
				   (wf_id_rd==6'd29)?data_flop29:
				   (wf_id_rd==6'd30)?data_flop30:
				   (wf_id_rd==6'd31)?data_flop31:
				   (wf_id_rd==6'd32)?data_flop32:
				   (wf_id_rd==6'd33)?data_flop33:
				   (wf_id_rd==6'd34)?data_flop34:
				   (wf_id_rd==6'd35)?data_flop35:
				   (wf_id_rd==6'd36)?data_flop36:
				   (wf_id_rd==6'd37)?data_flop37:
				   (wf_id_rd==6'd38)?data_flop38:
				   (wf_id_rd==6'd39)?data_flop39:
                    33'd0;
  
   
   assign data0=(wr & (wf_id==6'd0))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd0))?{1'b0,pc_read}:data_flop0;
   assign data1=(wr & (wf_id==6'd1))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd1))?{1'b0,pc_read}:data_flop1;
   assign data2=(wr & (wf_id==6'd2))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd2))?{1'b0,pc_read}:data_flop2;
   assign data3=(wr & (wf_id==6'd3))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd3))?{1'b0,pc_read}:data_flop3;
   assign data4=(wr & (wf_id==6'd4))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd4))?{1'b0,pc_read}:data_flop4;
   assign data5=(wr & (wf_id==6'd5))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd5))?{1'b0,pc_read}:data_flop5;
   assign data6=(wr & (wf_id==6'd6))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd6))?{1'b0,pc_read}:data_flop6;
   assign data7=(wr & (wf_id==6'd7))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd7))?{1'b0,pc_read}:data_flop7;
   assign data8=(wr & (wf_id==6'd8))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd8))?{1'b0,pc_read}:data_flop8;
   assign data9=(wr & (wf_id==6'd9))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd9))?{1'b0,pc_read}:data_flop9;
   assign data10=(wr & (wf_id==6'd10))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd10))?{1'b0,pc_read}:data_flop10;
   assign data11=(wr & (wf_id==6'd11))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd11))?{1'b0,pc_read}:data_flop11;
   assign data12=(wr & (wf_id==6'd12))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd12))?{1'b0,pc_read}:data_flop12;
   assign data13=(wr & (wf_id==6'd13))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd13))?{1'b0,pc_read}:data_flop13;
   assign data14=(wr & (wf_id==6'd14))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd14))?{1'b0,pc_read}:data_flop14;
   assign data15=(wr & (wf_id==6'd15))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd15))?{1'b0,pc_read}:data_flop15;
   assign data16=(wr & (wf_id==6'd16))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd16))?{1'b0,pc_read}:data_flop16;
   assign data17=(wr & (wf_id==6'd17))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd17))?{1'b0,pc_read}:data_flop17;
   assign data18=(wr & (wf_id==6'd18))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd18))?{1'b0,pc_read}:data_flop18;
   assign data19=(wr & (wf_id==6'd19))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd19))?{1'b0,pc_read}:data_flop19;
   assign data20=(wr & (wf_id==6'd20))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd20))?{1'b0,pc_read}:data_flop20;
   assign data21=(wr & (wf_id==6'd21))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd21))?{1'b0,pc_read}:data_flop21;
   assign data22=(wr & (wf_id==6'd22))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd22))?{1'b0,pc_read}:data_flop22;
   assign data23=(wr & (wf_id==6'd23))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd23))?{1'b0,pc_read}:data_flop23;
   assign data24=(wr & (wf_id==6'd24))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd24))?{1'b0,pc_read}:data_flop24;
   assign data25=(wr & (wf_id==6'd25))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd25))?{1'b0,pc_read}:data_flop25;
   assign data26=(wr & (wf_id==6'd26))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd26))?{1'b0,pc_read}:data_flop26;
   assign data27=(wr & (wf_id==6'd27))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd27))?{1'b0,pc_read}:data_flop27;
   assign data28=(wr & (wf_id==6'd28))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd28))?{1'b0,pc_read}:data_flop28;
   assign data29=(wr & (wf_id==6'd29))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd29))?{1'b0,pc_read}:data_flop29;
   assign data30=(wr & (wf_id==6'd30))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd30))?{1'b0,pc_read}:data_flop30;
   assign data31=(wr & (wf_id==6'd31))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd31))?{1'b0,pc_read}:data_flop31;
   assign data32=(wr & (wf_id==6'd32))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd32))?{1'b0,pc_read}:data_flop32;
   assign data33=(wr & (wf_id==6'd33))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd33))?{1'b0,pc_read}:data_flop33;
   assign data34=(wr & (wf_id==6'd34))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd34))?{1'b0,pc_read}:data_flop34;
   assign data35=(wr & (wf_id==6'd35))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd35))?{1'b0,pc_read}:data_flop35;
   assign data36=(wr & (wf_id==6'd36))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd36))?{1'b0,pc_read}:data_flop36;
   assign data37=(wr & (wf_id==6'd37))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd37))?{1'b0,pc_read}:data_flop37;
   assign data38=(wr & (wf_id==6'd38))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd38))?{1'b0,pc_read}:data_flop38;
   assign data39=(wr & (wf_id==6'd39))? {1'b1,new_pc_init} :(rd_en & (wf_id_rd==6'd39))?{1'b0,pc_read}:data_flop39;
   

endmodule
module regblock(
	readdata, 
	clk, 
	rst, 
	readregsel, 
	writeregsel, 
	writedata, 
	write
);

parameter BITWIDTH = 11;

input clk, rst;
input [5:0] readregsel;
input [5:0] writeregsel;
input [(BITWIDTH-1):0] writedata;
input  write;

output [(BITWIDTH-1):0] readdata;

wire write_dff;

wire [(BITWIDTH-1):0] data0,data_flop0;
wire [(BITWIDTH-1):0] data1,data_flop1;
wire [(BITWIDTH-1):0] data2,data_flop2;
wire [(BITWIDTH-1):0] data3,data_flop3;
wire [(BITWIDTH-1):0] data4,data_flop4;
wire [(BITWIDTH-1):0] data5,data_flop5;
wire [(BITWIDTH-1):0] data6,data_flop6;
wire [(BITWIDTH-1):0] data7,data_flop7;
wire [(BITWIDTH-1):0] data8,data_flop8;
wire [(BITWIDTH-1):0] data9,data_flop9;
wire [(BITWIDTH-1):0] data10,data_flop10;
wire [(BITWIDTH-1):0] data11,data_flop11;
wire [(BITWIDTH-1):0] data12,data_flop12;
wire [(BITWIDTH-1):0] data13,data_flop13;
wire [(BITWIDTH-1):0] data14,data_flop14;
wire [(BITWIDTH-1):0] data15,data_flop15;
wire [(BITWIDTH-1):0] data16,data_flop16;
wire [(BITWIDTH-1):0] data17,data_flop17;
wire [(BITWIDTH-1):0] data18,data_flop18;
wire [(BITWIDTH-1):0] data19,data_flop19;
wire [(BITWIDTH-1):0] data20,data_flop20;
wire [(BITWIDTH-1):0] data21,data_flop21;
wire [(BITWIDTH-1):0] data22,data_flop22;
wire [(BITWIDTH-1):0] data23,data_flop23;
wire [(BITWIDTH-1):0] data24,data_flop24;
wire [(BITWIDTH-1):0] data25,data_flop25;
wire [(BITWIDTH-1):0] data26,data_flop26;
wire [(BITWIDTH-1):0] data27,data_flop27;
wire [(BITWIDTH-1):0] data28,data_flop28;
wire [(BITWIDTH-1):0] data29,data_flop29;
wire [(BITWIDTH-1):0] data30,data_flop30;
wire [(BITWIDTH-1):0] data31,data_flop31;
wire [(BITWIDTH-1):0] data32,data_flop32;
wire [(BITWIDTH-1):0] data33,data_flop33;
wire [(BITWIDTH-1):0] data34,data_flop34;
wire [(BITWIDTH-1):0] data35,data_flop35;
wire [(BITWIDTH-1):0] data36,data_flop36;
wire [(BITWIDTH-1):0] data37,data_flop37;
wire [(BITWIDTH-1):0] data38,data_flop38;
wire [(BITWIDTH-1):0] data39,data_flop39;
   
assign write_dff = 1'b1;

         regfile #(BITWIDTH) r_file0 (data0,write_dff,data_flop0,clk,rst);
	 regfile #(BITWIDTH) r_file1 (data1,write_dff,data_flop1,clk,rst);
	 regfile #(BITWIDTH) r_file2 (data2,write_dff,data_flop2,clk,rst);
	 regfile #(BITWIDTH) r_file3 (data3,write_dff,data_flop3,clk,rst);
	 regfile #(BITWIDTH) r_file4 (data4,write_dff,data_flop4,clk,rst);
	 regfile #(BITWIDTH) r_file5 (data5,write_dff,data_flop5,clk,rst);
	 regfile #(BITWIDTH) r_file6 (data6,write_dff,data_flop6,clk,rst);
	 regfile #(BITWIDTH) r_file7 (data7,write_dff,data_flop7,clk,rst);
	 regfile #(BITWIDTH) r_file8 (data8,write_dff,data_flop8,clk,rst);
	 regfile #(BITWIDTH) r_file9 (data9,write_dff,data_flop9,clk,rst);
	 regfile #(BITWIDTH) r_file10 (data10,write_dff,data_flop10,clk,rst);
	 regfile #(BITWIDTH) r_file11 (data11,write_dff,data_flop11,clk,rst);
	 regfile #(BITWIDTH) r_file12 (data12,write_dff,data_flop12,clk,rst);
	 regfile #(BITWIDTH) r_file13 (data13,write_dff,data_flop13,clk,rst);
	 regfile #(BITWIDTH) r_file14 (data14,write_dff,data_flop14,clk,rst);
	 regfile #(BITWIDTH) r_file15 (data15,write_dff,data_flop15,clk,rst);
	 regfile #(BITWIDTH) r_file16 (data16,write_dff,data_flop16,clk,rst);
	 regfile #(BITWIDTH) r_file17 (data17,write_dff,data_flop17,clk,rst);
	 regfile #(BITWIDTH) r_file18 (data18,write_dff,data_flop18,clk,rst);
	 regfile #(BITWIDTH) r_file19 (data19,write_dff,data_flop19,clk,rst);
	 regfile #(BITWIDTH) r_file20 (data20,write_dff,data_flop20,clk,rst);
	 regfile #(BITWIDTH) r_file21 (data21,write_dff,data_flop21,clk,rst);
	 regfile #(BITWIDTH) r_file22 (data22,write_dff,data_flop22,clk,rst);
	 regfile #(BITWIDTH) r_file23 (data23,write_dff,data_flop23,clk,rst);
	 regfile #(BITWIDTH) r_file24 (data24,write_dff,data_flop24,clk,rst);
	 regfile #(BITWIDTH) r_file25 (data25,write_dff,data_flop25,clk,rst);
	 regfile #(BITWIDTH) r_file26 (data26,write_dff,data_flop26,clk,rst);
	 regfile #(BITWIDTH) r_file27 (data27,write_dff,data_flop27,clk,rst);
	 regfile #(BITWIDTH) r_file28 (data28,write_dff,data_flop28,clk,rst);
	 regfile #(BITWIDTH) r_file29 (data29,write_dff,data_flop29,clk,rst);
	 regfile #(BITWIDTH) r_file30 (data30,write_dff,data_flop30,clk,rst);
	 regfile #(BITWIDTH) r_file31 (data31,write_dff,data_flop31,clk,rst);
	 regfile #(BITWIDTH) r_file32 (data32,write_dff,data_flop32,clk,rst);
	 regfile #(BITWIDTH) r_file33 (data33,write_dff,data_flop33,clk,rst);
	 regfile #(BITWIDTH) r_file34 (data34,write_dff,data_flop34,clk,rst);
	 regfile #(BITWIDTH) r_file35 (data35,write_dff,data_flop35,clk,rst);
	 regfile #(BITWIDTH) r_file36 (data36,write_dff,data_flop36,clk,rst);
	 regfile #(BITWIDTH) r_file37 (data37,write_dff,data_flop37,clk,rst);
	 regfile #(BITWIDTH) r_file38 (data38,write_dff,data_flop38,clk,rst);
	 regfile #(BITWIDTH) r_file39 (data39,write_dff,data_flop39,clk,rst);
	 
   
 assign readdata = (readregsel==6'd0)?data_flop0:
                   (readregsel==6'd1)?data_flop1:
				   (readregsel==6'd2)?data_flop2:
				   (readregsel==6'd3)?data_flop3:
				   (readregsel==6'd4)?data_flop4:
				   (readregsel==6'd5)?data_flop5:
				   (readregsel==6'd6)?data_flop6:
				   (readregsel==6'd7)?data_flop7:
				   (readregsel==6'd8)?data_flop8:
				   (readregsel==6'd9)?data_flop9:
				   (readregsel==6'd10)?data_flop10:
				   (readregsel==6'd11)?data_flop11:
				   (readregsel==6'd12)?data_flop12:
				   (readregsel==6'd13)?data_flop13:
				   (readregsel==6'd14)?data_flop14:
				   (readregsel==6'd15)?data_flop15:
				   (readregsel==6'd16)?data_flop16:
				   (readregsel==6'd17)?data_flop17:
				   (readregsel==6'd18)?data_flop18:
				   (readregsel==6'd19)?data_flop19:
				   (readregsel==6'd20)?data_flop20:
				   (readregsel==6'd21)?data_flop21:
				   (readregsel==6'd22)?data_flop22:
				   (readregsel==6'd23)?data_flop23:
				   (readregsel==6'd24)?data_flop24:
				   (readregsel==6'd25)?data_flop25:
				   (readregsel==6'd26)?data_flop26:
				   (readregsel==6'd27)?data_flop27:
				   (readregsel==6'd28)?data_flop28:
				   (readregsel==6'd29)?data_flop29:
				   (readregsel==6'd30)?data_flop30:
				   (readregsel==6'd31)?data_flop31:
				   (readregsel==6'd32)?data_flop32:
				   (readregsel==6'd33)?data_flop33:
				   (readregsel==6'd34)?data_flop34:
				   (readregsel==6'd35)?data_flop35:
				   (readregsel==6'd36)?data_flop36:
				   (readregsel==6'd37)?data_flop37:
				   (readregsel==6'd38)?data_flop38:
				   (readregsel==6'd39)?data_flop39:
                   11'd0;
   
   assign data0=(write & (writeregsel==6'd0))? writedata:data_flop0;
   assign data1=(write & (writeregsel==6'd1))? writedata:data_flop1;
   assign data2=(write & (writeregsel==6'd2))? writedata:data_flop2;
   assign data3=(write & (writeregsel==6'd3))? writedata:data_flop3;
   assign data4=(write & (writeregsel==6'd4))? writedata:data_flop4;
   assign data5=(write & (writeregsel==6'd5))? writedata:data_flop5;
   assign data6=(write & (writeregsel==6'd6))? writedata:data_flop6;
   assign data7=(write & (writeregsel==6'd7))? writedata:data_flop7;
   assign data8=(write & (writeregsel==6'd8))? writedata:data_flop8;
   assign data9=(write & (writeregsel==6'd9))? writedata:data_flop9;
   assign data10=(write & (writeregsel==6'd10))? writedata:data_flop10;
   assign data11=(write & (writeregsel==6'd11))? writedata:data_flop11;
   assign data12=(write & (writeregsel==6'd12))? writedata:data_flop12;
   assign data13=(write & (writeregsel==6'd13))? writedata:data_flop13;
   assign data14=(write & (writeregsel==6'd14))? writedata:data_flop14;
   assign data15=(write & (writeregsel==6'd15))? writedata:data_flop15;
   assign data16=(write & (writeregsel==6'd16))? writedata:data_flop16;
   assign data17=(write & (writeregsel==6'd17))? writedata:data_flop17;
   assign data18=(write & (writeregsel==6'd18))? writedata:data_flop18;
   assign data19=(write & (writeregsel==6'd19))? writedata:data_flop19;
   assign data20=(write & (writeregsel==6'd20))? writedata:data_flop20;
   assign data21=(write & (writeregsel==6'd21))? writedata:data_flop21;
   assign data22=(write & (writeregsel==6'd22))? writedata:data_flop22;
   assign data23=(write & (writeregsel==6'd23))? writedata:data_flop23;
   assign data24=(write & (writeregsel==6'd24))? writedata:data_flop24;
   assign data25=(write & (writeregsel==6'd25))? writedata:data_flop25;
   assign data26=(write & (writeregsel==6'd26))? writedata:data_flop26;
   assign data27=(write & (writeregsel==6'd27))? writedata:data_flop27;
   assign data28=(write & (writeregsel==6'd28))? writedata:data_flop28;
   assign data29=(write & (writeregsel==6'd29))? writedata:data_flop29;
   assign data30=(write & (writeregsel==6'd30))? writedata:data_flop30;
   assign data31=(write & (writeregsel==6'd31))? writedata:data_flop31;
   assign data32=(write & (writeregsel==6'd32))? writedata:data_flop32;
   assign data33=(write & (writeregsel==6'd33))? writedata:data_flop33;
   assign data34=(write & (writeregsel==6'd34))? writedata:data_flop34;
   assign data35=(write & (writeregsel==6'd35))? writedata:data_flop35;
   assign data36=(write & (writeregsel==6'd36))? writedata:data_flop36;
   assign data37=(write & (writeregsel==6'd37))? writedata:data_flop37;
   assign data38=(write & (writeregsel==6'd38))? writedata:data_flop38;
   assign data39=(write & (writeregsel==6'd39))? writedata:data_flop39;
   
endmodule

module regfile_clr(d_in,wr_en,d_out,clk,rst);
  
  
  parameter BITWIDTH=11;
  input [BITWIDTH-1:0]d_in;
  output [BITWIDTH-1:0]d_out;
  input wr_en,clk,rst;
  
  wire [BITWIDTH-1:0]out;
  
  dff_clr d1[BITWIDTH-1:0](.q(d_out), .d(out), .clk(clk), .rst(rst));
  
  mux2_1 m1[BITWIDTH-1:0](.InA(d_out),.InB(d_in),.out(out),.S(wr_en));
  
endmodulemodule round_robin (
	fetch_valid,
	pc_select,
	queue_vfull,
	icache_ack,
	vacant,
	clk,
	rst
);

output fetch_valid;
output[5:0] pc_select;

input[39:0] queue_vfull;
input icache_ack;
input[39:0] vacant;
input clk, rst;

wire[5:0] icache_req_out, icache_req_in;
wire[5:0] icache_req_plus1, icache_req_minus1;
wire ign_cout1, ign_cout2;

wire[39:0] valid_queues_not_full;
wire can_fetch, any_to_fetch;

wire[39:0] shifted_queue;
wire[5:0] highest_pr_in, highest_pr_out, prenc_out;

//adder6bit plus1(icache_req_plus1, ign_cout1, icache_req_out, 6'b000001);
//adder6bit minus1(icache_req_minus1, ign_cout2, icache_req_out, 6'b111111);

assign {ign_cout1, icache_req_plus1} = icache_req_out + 1;
assign {ign_cout2, icache_req_minus1} = icache_req_out - 1;

mux4to1_6bit m4to1_6b(icache_req_in, icache_req_out, icache_req_plus1, icache_req_minus1,
				icache_req_out, {fetch_valid, icache_ack});

dff_en_fixed_reset_value req_ff(icache_req_out, icache_req_in, 6'b011111, 1'b1, clk, rst);
dff_en high_pr_ff[5:0](highest_pr_out, highest_pr_in, fetch_valid, clk, rst);

assign valid_queues_not_full = ~(queue_vfull | vacant);
assign can_fetch = |icache_req_out;

circular_barrel_shift cbs(shifted_queue, valid_queues_not_full, highest_pr_out);
priority_encoder_40to6 penc(prenc_out, any_to_fetch, shifted_queue, 1'b1);

assign fetch_valid = can_fetch & any_to_fetch;

add_wraparound_after40 awa(pc_select, prenc_out, highest_pr_out);
incr_wraparound_at40 iwa(highest_pr_in, pc_select);

endmodule
module vacant_mask_gen(
	new_wfid, 
	new_vacant, 
	wf_id_done, 
	vacant, 
	halt, 
	wr
);

input [5:0] new_wfid;
input wr;
input [39:0] vacant;
input [5:0] wf_id_done;
input halt;

output [39:0] new_vacant;

wire [39:0] halt_reset_mask, masked_vacant;
wire [39:0] new_slot_mask_neg, new_slot_mask;

assign new_vacant = halt ? (masked_vacant | halt_reset_mask) : masked_vacant;
assign masked_vacant = wr ? (new_slot_mask & vacant) : vacant;
assign new_slot_mask = ~new_slot_mask_neg;

decoder_6b_40b_en halt_mask(
	.addr_in(wf_id_done), .en(1'b1), .out(halt_reset_mask)
);

decoder_6b_40b_en new_wfid_mask(
	.addr_in(new_wfid), .en(1'b1), .out(new_slot_mask_neg)
);

endmodule
module wavegrp_info (
	wf_wr_en,
	wr_wf_tag,
	wr_wg_wf_count,
	wr_wfid,
	halt,
	halt_wfid,
	rd_wfid,
	rd_wgid,
	rd_wf_count,
	clk,
	rst
);

input clk;
input rst;

input wf_wr_en;
input [14:0] wr_wf_tag;
input [3:0] wr_wg_wf_count;
input [5:0] wr_wfid;
input [5:0] rd_wfid;
input halt;
input [5:0] halt_wfid;

output [5:0] rd_wgid;
output [3:0] rd_wf_count;

reg [5:0] rd_wgid;
reg [3:0] rd_wf_count;

reg [879:0] write_data;
reg [39:0] write_en;
reg cam_hit;
reg [21:0] cam_data;

wire [879:0] regfile_out;

regfile #(22) wg_cnt_store[39:0] (
	write_data, write_en, regfile_out, clk, rst
);

//assign regfile_out = write_data;

integer i;

//always @(wf_wr_en or wr_wfid or wr_wf_tag /*or regfile_out*/)
always @(*)
begin
	cam_hit = 1'b0;
	cam_data = 22'b0;

	if (wf_wr_en) begin
		for(i = 0; i < 40; i=i+1) begin
			if(/*!cam_hit && */regfile_out[(i*22)+21] &&
					(regfile_out[((i*22)+20)-:11] == wr_wf_tag[14-:11]))
			begin
				cam_data = regfile_out[((i*22)+21)-:22];
				cam_hit = 1'b1;
			end
		end
	end
end

//always @(halt or halt_wfid or cam_hit /*or cam_data*/ or wf_wr_en or wr_wf_tag or wr_wfid or wr_wg_wf_count /*or regfile_out*/) begin
always @(*) begin
	write_en = 40'b0;
	write_data = regfile_out;

	if(halt) begin
		write_data[(halt_wfid*22)+21-:22] = 22'd0;
		write_en[halt_wfid] = 1'b1;
	end

	if (wf_wr_en) begin
   		if(cam_hit == 1'b1) begin
			write_data[(wr_wfid*22)+21-:22] = cam_data;
			write_en[wr_wfid] = 1'b1;
		end
		else begin
			write_data[(wr_wfid*22)+21-:22] = {
				1'b1, wr_wf_tag[14-:11], wr_wfid, wr_wg_wf_count
				};
			write_en[wr_wfid] = 1'b1;
		end
	end
end

always @(rd_wfid or regfile_out)
begin
	rd_wgid = regfile_out[(rd_wfid*22)+9-:6];
	rd_wf_count = regfile_out[(rd_wfid*22)+3-:4];
end

endmodule
module wfid_generator(
	halt, 
	WF_tag, 
	WF_id_done, 
	vacant, 
	vacant_next, 
	WF_id, 
	WF_tag_done, 
	clk, 
	wr, 
	rst
);

input clk;
input rst;
input halt;
input wr;
input [14:0] WF_tag;
input [5:0] WF_id_done; //rename
input [39:0] vacant;

output [39:0] vacant_next;
output [5:0] WF_id; //new id generated
output [14:0] WF_tag_done; //rename

encoder encoder1(vacant, WF_id);
vacant_mask_gen vmg(WF_id, vacant_next, WF_id_done, vacant, halt, wr);

regblock #(15) wf_tag_store (
	WF_tag_done, clk, rst, 
	WF_id_done, WF_id, WF_tag, wr
);

endmodule
// DO NOT USE THIS, THIS IS A PLACEHOLDER FOR A XILINX IP CORE BLOCK RAM

module block_ram
(
  clka,
  wea,
  addra,
  dina,
  douta,
  clkb,
  web,
  addrb,
  dinb,
  doutb
);

input clka, clkb;
input wea, web;
input [9:0] addra, addrb;
input [31:0] dina, dinb;
output [31:0] douta, doutb;

endmodule
`timescale 1 ns / 1 ps

module compute_unit_fpga #
(
  // Users to add parameters here

  // User parameters ends
  // Do not modify the parameters beyond this line

  // Width of S_AXI data bus
  parameter integer C_S_AXI_DATA_WIDTH	= 32,
  // Width of S_AXI address bus
  parameter integer C_S_AXI_ADDR_WIDTH	= 11
)
(
  input wire  S_AXI_ACLK,
  // Global Reset Signal. This Signal is Active LOW
  input wire  S_AXI_ARESETN,
  // Write address (issued by master, acceped by Slave)
  input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
  // Write channel Protection type. This signal indicates the
      // privilege and security level of the transaction, and whether
      // the transaction is a data access or an instruction access.
  input wire [2 : 0] S_AXI_AWPROT,
  // Write address valid. This signal indicates that the master signaling
      // valid write address and control information.
  input wire  S_AXI_AWVALID,
  // Write address ready. This signal indicates that the slave is ready
      // to accept an address and associated control signals.
  output wire  S_AXI_AWREADY,
  // Write data (issued by master, acceped by Slave) 
  input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
  // Write strobes. This signal indicates which byte lanes hold
      // valid data. There is one write strobe bit for each eight
      // bits of the write data bus.    
  input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
  // Write valid. This signal indicates that valid write
      // data and strobes are available.
  input wire  S_AXI_WVALID,
  // Write ready. This signal indicates that the slave
      // can accept the write data.
  output wire  S_AXI_WREADY,
  // Write response. This signal indicates the status
      // of the write transaction.
  output wire [1 : 0] S_AXI_BRESP,
  // Write response valid. This signal indicates that the channel
      // is signaling a valid write response.
  output wire  S_AXI_BVALID,
  // Response ready. This signal indicates that the master
      // can accept a write response.
  input wire  S_AXI_BREADY,
  // Read address (issued by master, acceped by Slave)
  input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
  // Protection type. This signal indicates the privilege
      // and security level of the transaction, and whether the
      // transaction is a data access or an instruction access.
  input wire [2 : 0] S_AXI_ARPROT,
  // Read address valid. This signal indicates that the channel
      // is signaling valid read address and control information.
  input wire  S_AXI_ARVALID,
  // Read address ready. This signal indicates that the slave is
      // ready to accept an address and associated control signals.
  output wire  S_AXI_ARREADY,
  // Read data (issued by slave)
  output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
  // Read response. This signal indicates the status of the
      // read transfer.
  output wire [1 : 0] S_AXI_RRESP,
  // Read valid. This signal indicates that the channel is
      // signaling the required read data.
  output wire  S_AXI_RVALID,
  // Read ready. This signal indicates that the master can
      // accept the read data and response information.
  input wire  S_AXI_RREADY











);

// Example-specific design signals
// local parameter for addressing 32 bit / 64 bit C_S_AXI_DATA_WIDTH
// ADDR_LSB is used for addressing 32/64 bit registers/memories
// ADDR_LSB = 2 for 32 bits (n downto 2)
// ADDR_LSB = 3 for 64 bits (n downto 3)
localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
localparam integer OPT_MEM_ADDR_BITS = 8;


// AXI4LITE signals
reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_awaddr;
reg  	axi_awready;
reg  	axi_wready;
reg [1 : 0] 	axi_bresp;
reg  	axi_bvalid;
reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
reg  	axi_arready;
reg [C_S_AXI_DATA_WIDTH-1 : 0] 	axi_rdata;
reg [1 : 0] 	axi_rresp;
reg  	axi_rvalid;

//----------------------------------------------
//-- Signals for user logic register space example
//------------------------------------------------

wire rst;
wire clk;

wire slv_reg_wren;
wire slv_reg_rden;
reg slv_reg_wren_buffer;
reg [C_S_AXI_DATA_WIDTH-1:0]	 reg_data_out;

assign clk = S_AXI_ACLK;

assign S_AXI_AWREADY	= axi_awready;
assign S_AXI_WREADY	= axi_wready;
assign S_AXI_BRESP	= axi_bresp;
assign S_AXI_BVALID	= axi_bvalid;
assign S_AXI_ARREADY	= axi_arready;
assign S_AXI_RDATA	= axi_rdata;
assign S_AXI_RRESP	= axi_rresp;
assign S_AXI_RVALID	= axi_rvalid;

wire fetch2buff_rd_en;
wire [31:0] fetch2buff_addr;
reg fetch2buff_rd_en_reg;
wire [38:0] fetch2buff_tag;
reg [38:0] fetch2buff_tag_reg;

wire cu2dispatch_wf_done;
wire [14:0] cu2dispatch_wf_tag_done;

wire [31:0] instruction_buff_out_a;
wire [31:0] instruction_buff_out_b;

// SGPR registers
reg [31:0] gprCommand;

wire mem2lsu_ack;
wire [6:0] mem2lsu_tag_resp;

wire lsu2mem_rd_en, lsu2mem_wr_en;
wire [6:0] lsu2mem_tag_req;

wire [31:0]   lsu2mem_wr_data, mem2lsu_rd_data, lsu2mem_addr;
wire [2047:0] lsu2vgpr_dest_data, vgpr2lsu_source1_data;

wire [3:0] fpgamem2mb_op;
wire [31:0] fpgamem2mb_data;
wire [31:0] fpgamem2mb_addr;

reg mb2fpgamem_data_we;
reg mb2fpgamem_ack_reg;
reg mb2fpgamem_done_reg;

reg [C_S_AXI_DATA_WIDTH-1:0] waveID;
reg [C_S_AXI_DATA_WIDTH-1:0] baseVGPR;
reg [C_S_AXI_DATA_WIDTH-1:0] baseSGPR;
reg [C_S_AXI_DATA_WIDTH-1:0] baseLDS;
reg [C_S_AXI_DATA_WIDTH-1:0] waveCount;
reg [C_S_AXI_DATA_WIDTH-1:0] pcStart;
reg [C_S_AXI_DATA_WIDTH-1:0] resultsReady;
reg [C_S_AXI_DATA_WIDTH-1:0] resultsReadyTag;

reg instrBuffWrEn;
reg [31:0] instrAddrReg;

reg [8:0] quadBaseAddress;
reg [31:0] quadData0;
reg [31:0] quadData1;
reg [31:0] quadData2;
reg [31:0] quadData3;
reg lsu2sgpr_dest_wr_en_reg;

wire [127:0] sgpr2lsu_source1_data;

reg [9:0]  singleVectorBaseAddress;

reg [63:0] singleVectorWrDataMask;
reg lsu2vgpr_dest_wr_en_reg;






reg [3:0] executeState;
reg [3:0] executeStateNext;

reg executeStart;
reg dispatch_idle;

reg mb_reset;

reg [31:0] singleVectorWrData0, singleVectorWrData1, singleVectorWrData2, singleVectorWrData3, singleVectorWrData4, singleVectorWrData5, singleVectorWrData6,
           singleVectorWrData7, singleVectorWrData8, singleVectorWrData9, singleVectorWrData10, singleVectorWrData11, singleVectorWrData12, singleVectorWrData13,
           singleVectorWrData14, singleVectorWrData15, singleVectorWrData16, singleVectorWrData17, singleVectorWrData18, singleVectorWrData19, singleVectorWrData20,
           singleVectorWrData21, singleVectorWrData22, singleVectorWrData23, singleVectorWrData24, singleVectorWrData25, singleVectorWrData26, singleVectorWrData27,
           singleVectorWrData28, singleVectorWrData29, singleVectorWrData30, singleVectorWrData31, singleVectorWrData32, singleVectorWrData33, singleVectorWrData34,
           singleVectorWrData35, singleVectorWrData36, singleVectorWrData37, singleVectorWrData38, singleVectorWrData39, singleVectorWrData40, singleVectorWrData41,
           singleVectorWrData42, singleVectorWrData43, singleVectorWrData44, singleVectorWrData45, singleVectorWrData46, singleVectorWrData47, singleVectorWrData48,
           singleVectorWrData49, singleVectorWrData50, singleVectorWrData51, singleVectorWrData52, singleVectorWrData53, singleVectorWrData54, singleVectorWrData55,
           singleVectorWrData56, singleVectorWrData57, singleVectorWrData58, singleVectorWrData59, singleVectorWrData60, singleVectorWrData61, singleVectorWrData62,
           singleVectorWrData63;


always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    executeState <= 4'd0;
    //cycle_counter <= 32'd0;
  end
  else begin
    executeState <= executeStateNext;
    //cycle_counter <= cycle_counter_next;
  end
end

always @(*) begin
  executeStateNext <= executeState;
  //cycle_counter_next <= cycle_counter;
  executeStart <= 1'b0;
  resultsReady <= 32'd0;
  dispatch_idle <= 1'b0;
  //cycle_counter_wr_reg <= 1'b0;
  case(executeState)
    4'd0: begin
      dispatch_idle <= 1'b1;
      if(slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h000) begin
        executeStart <= 1'b1;
        executeStateNext <= 4'd2;
        //cycle_counter_next <= 32'd0;
      end
    end
    4'd2: begin
      //cycle_counter_next <= cycle_counter + 32'd1;
      //cycle_counter_wr_reg <= 1'b1;
      if(cu2dispatch_wf_done) begin
        executeStateNext <= 4'd3;
      end
    end
    4'd3: begin
      resultsReady <= 32'd1;
      if(slv_reg_rden && axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h000) begin
        executeStateNext <= 4'd0;
      end
    end
  endcase
end

assign rst = ~S_AXI_ARESETN;

assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;
assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;

// Implement axi_awready generation
// axi_awready is asserted for one S_AXI_ACLK clock cycle when both
// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_awready is
// de-asserted when reset is low.

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_awready <= 1'b0;
  end
  else begin
    if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID) begin
      // slave is ready to accept write address when
      // there is a valid write address and write data
      // on the write address and data bus. This design
      // expects no outstanding transactions.
      axi_awready <= 1'b1;
    end
    else begin
      axi_awready <= 1'b0;
    end
  end
end

// Implement axi_awaddr latching
// This process is used to latch the address when both
// S_AXI_AWVALID and S_AXI_WVALID are valid.

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_awaddr <= 0;
  end
  else begin
    if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID) begin
      // Write Address latching
      axi_awaddr <= S_AXI_AWADDR;
    end
  end
end

// Implement axi_wready generation
// axi_wready is asserted for one S_AXI_ACLK clock cycle when both
// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_wready is
// de-asserted when reset is low.

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_wready <= 1'b0;
  end
  else begin
    if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID) begin
      // slave is ready to accept write data when
      // there is a valid write address and write data
      // on the write address and data bus. This design
      // expects no outstanding transactions.
      axi_wready <= 1'b1;
    end
    else begin
      axi_wready <= 1'b0;
    end
  end
end

// Implement write response logic generation
// The write response and response valid signals are asserted by the slave 
// when axi_wready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted.  
// This marks the acceptance of address and indicates the status of 
// write transaction.

always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_bvalid  <= 0;
    axi_bresp   <= 2'b0;
  end
  else begin
    if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID) begin
      // indicates a valid write response is available
      axi_bvalid <= 1'b1;
      axi_bresp  <= 2'b0; // 'OKAY' response 
    end                   // work error responses in future
    else begin
      if (S_AXI_BREADY && axi_bvalid) begin
        //check if bready is asserted while bvalid is high) 
        //(there is a possibility that bready is always asserted high)   
        axi_bvalid <= 1'b0; 
      end
    end
  end
end

// Implement axi_arready generation
// axi_arready is asserted for one S_AXI_ACLK clock cycle when
// S_AXI_ARVALID is asserted. axi_awready is 
// de-asserted when reset (active low) is asserted. 
// The read address is also latched when S_AXI_ARVALID is 
// asserted. axi_araddr is reset to zero on reset assertion.

always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_arready <= 1'b0;
    axi_araddr  <= 32'b0;
  end
  else begin
    if (~axi_arready && S_AXI_ARVALID) begin
      // indicates that the slave has accepted the valid read address
      axi_arready <= 1'b1;
      // Read address latching
      axi_araddr  <= S_AXI_ARADDR;
    end
    else begin
      axi_arready <= 1'b0;
    end
  end 
end

// Implement axi_arvalid generation
// axi_rvalid is asserted for one S_AXI_ACLK clock cycle when both 
// S_AXI_ARVALID and axi_arready are asserted. The slave registers 
// data are available on the axi_rdata bus at this instance. The 
// assertion of axi_rvalid marks the validity of read data on the 
// bus and axi_rresp indicates the status of read transaction.axi_rvalid 
// is deasserted on reset (active low). axi_rresp and axi_rdata are 
// cleared to zero on reset (active low).
always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_rvalid <= 0;
    axi_rresp  <= 0;
  end
  else begin    
    if (axi_arready && S_AXI_ARVALID && ~axi_rvalid) begin
      // Valid read data is available at the read data bus
      axi_rvalid <= 1'b1;
      axi_rresp  <= 2'b0; // 'OKAY' response
    end
    else if (axi_rvalid && S_AXI_RREADY) begin
      // Read data is accepted by the master
      axi_rvalid <= 1'b0;
    end
  end
end 

always @(*) begin
  lsu2sgpr_dest_wr_en_reg <= 1'b0;
  lsu2vgpr_dest_wr_en_reg <= 1'b0;
  instrBuffWrEn <= 1'b0;
  mb2fpgamem_data_we <= 1'b0;
  if(slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h0C0) begin
    case(S_AXI_WDATA)
      32'd0: lsu2sgpr_dest_wr_en_reg <= 1'b1;
      32'd1: lsu2vgpr_dest_wr_en_reg <= 1'b1;
    endcase
  end
  
  if(dispatch_idle && slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h008) begin
    instrBuffWrEn <= 1'b1;
  end
  
  if(slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h041) begin
    mb2fpgamem_data_we <= 1'b1;
  end
end

always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0) begin
    mb_reset <= 1'b1;
  end
  else begin
    mb_reset <= mb_reset;
    if (slv_reg_wren && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 9'h009) begin
      mb_reset <= ~S_AXI_WDATA[0];
    end
  end
end

always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 || mb_reset == 1'b0 ) begin
    waveID    <= 32'd0;
    baseVGPR  <= 32'd0;
    baseSGPR  <= 32'd0;
    baseLDS   <= 32'd0;
    waveCount <= 32'd0;

    resultsReadyTag <= 32'd0;

    slv_reg_wren_buffer <= 1'b0;
    
    mb2fpgamem_ack_reg <= 1'b0;
    mb2fpgamem_done_reg <= 1'b0;
    
    quadBaseAddress <= 9'd0;
    quadData0 <= 32'd0;
    quadData1 <= 32'd0;
    quadData2 <= 32'd0;
    quadData3 <= 32'd0;
    
    singleVectorBaseAddress <= 10'd0;

    singleVectorWrDataMask <= 64'd0;
    {
      singleVectorWrData63, singleVectorWrData62, singleVectorWrData61, singleVectorWrData60, singleVectorWrData59, singleVectorWrData58,
      singleVectorWrData57, singleVectorWrData56, singleVectorWrData55, singleVectorWrData54, singleVectorWrData53, singleVectorWrData52,
      singleVectorWrData51, singleVectorWrData50, singleVectorWrData49, singleVectorWrData48, singleVectorWrData47, singleVectorWrData46,
      singleVectorWrData45, singleVectorWrData44, singleVectorWrData43, singleVectorWrData42, singleVectorWrData41, singleVectorWrData40,
      singleVectorWrData39, singleVectorWrData38, singleVectorWrData37, singleVectorWrData36, singleVectorWrData35, singleVectorWrData34,
      singleVectorWrData33, singleVectorWrData32, singleVectorWrData31, singleVectorWrData30, singleVectorWrData29, singleVectorWrData28,
      singleVectorWrData27, singleVectorWrData26, singleVectorWrData25, singleVectorWrData24, singleVectorWrData23, singleVectorWrData22,
      singleVectorWrData21, singleVectorWrData20, singleVectorWrData19, singleVectorWrData18, singleVectorWrData17, singleVectorWrData16,
      singleVectorWrData15, singleVectorWrData14, singleVectorWrData13, singleVectorWrData12, singleVectorWrData11, singleVectorWrData10,
      singleVectorWrData9,  singleVectorWrData8,  singleVectorWrData7,  singleVectorWrData6,  singleVectorWrData5,  singleVectorWrData4,
      singleVectorWrData3,  singleVectorWrData2,  singleVectorWrData1,  singleVectorWrData0
    } <= 2048'd0;
  end
  else begin
    slv_reg_wren_buffer <= slv_reg_wren;
    if(cu2dispatch_wf_done) begin
      resultsReadyTag <= {17'd0, cu2dispatch_wf_tag_done};
    end
    if (slv_reg_wren) begin
      case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
        // 9'h00: Start command initiate program
        9'h001: waveID       <= S_AXI_WDATA;
        9'h002: baseVGPR     <= S_AXI_WDATA;
        9'h003: baseSGPR     <= S_AXI_WDATA;
        9'h004: baseLDS      <= S_AXI_WDATA;
        9'h005: waveCount    <= S_AXI_WDATA;
        9'h006: pcStart      <= S_AXI_WDATA;
        9'h007: instrAddrReg <= S_AXI_WDATA;
        // 9'h008: Instruction value
        // 9'h009: MB reset
        
        // 0x0100
        // Memory registers
        //9'h40: Writes to this address result in a write to the FPGA memory buffer
        9'h041: mb2fpgamem_ack_reg <= S_AXI_WDATA[0];
        9'h042: mb2fpgamem_done_reg <= S_AXI_WDATA[0];
        
        // 0x0300
        // 9'h0C0: GPR command register, used for both vector and scalar ops
        // Scalar register registers
        9'h0C1: quadBaseAddress <= S_AXI_WDATA[8:0];
        9'h0C2: quadData0 <= S_AXI_WDATA;
        9'h0C3: quadData1 <= S_AXI_WDATA;
        9'h0C4: quadData2 <= S_AXI_WDATA;
        9'h0C5: quadData3 <= S_AXI_WDATA;
        // Vector register configuration registers
        9'h0C6: singleVectorBaseAddress <= S_AXI_WDATA[9:0];
        //9'h75: Vector write command
        // Reset vector register inputs
        9'h0C8: begin
          {
            singleVectorWrData63, singleVectorWrData62, singleVectorWrData61, singleVectorWrData60, singleVectorWrData59, singleVectorWrData58,
            singleVectorWrData57, singleVectorWrData56, singleVectorWrData55, singleVectorWrData54, singleVectorWrData53, singleVectorWrData52,
            singleVectorWrData51, singleVectorWrData50, singleVectorWrData49, singleVectorWrData48, singleVectorWrData47, singleVectorWrData46,
            singleVectorWrData45, singleVectorWrData44, singleVectorWrData43, singleVectorWrData42, singleVectorWrData41, singleVectorWrData40,
            singleVectorWrData39, singleVectorWrData38, singleVectorWrData37, singleVectorWrData36, singleVectorWrData35, singleVectorWrData34,
            singleVectorWrData33, singleVectorWrData32, singleVectorWrData31, singleVectorWrData30, singleVectorWrData29, singleVectorWrData28,
            singleVectorWrData27, singleVectorWrData26, singleVectorWrData25, singleVectorWrData24, singleVectorWrData23, singleVectorWrData22,
            singleVectorWrData21, singleVectorWrData20, singleVectorWrData19, singleVectorWrData18, singleVectorWrData17, singleVectorWrData16,
            singleVectorWrData15, singleVectorWrData14, singleVectorWrData13, singleVectorWrData12, singleVectorWrData11, singleVectorWrData10,
            singleVectorWrData9,  singleVectorWrData8,  singleVectorWrData7,  singleVectorWrData6,  singleVectorWrData5,  singleVectorWrData4,
            singleVectorWrData3,  singleVectorWrData2,  singleVectorWrData1,  singleVectorWrData0
          } <= 2048'd0;
        end
        //DataMask_Lo
        9'h0C9: singleVectorWrDataMask[31:0] <= S_AXI_WDATA;
        //DataMask_Hi
        9'h0CA: singleVectorWrDataMask[63:32] <= S_AXI_WDATA;
        // 0x400
        // Vector register data registers
        9'h100: begin
          singleVectorWrData0 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000001;
        end
        9'h101: begin
          singleVectorWrData1 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000002;
        end
        9'h102: begin
          singleVectorWrData2 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000004;
        end
        9'h103: begin
          singleVectorWrData3 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000008;
        end
        9'h104: begin
          singleVectorWrData4 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000010;
        end
        9'h105: begin
          singleVectorWrData5 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000020;
        end
        9'h106: begin
          singleVectorWrData6 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000040;
        end
        9'h107: begin
          singleVectorWrData7 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000080;
        end
        9'h108: begin
          singleVectorWrData8 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000100;
        end
        9'h109: begin
          singleVectorWrData9 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000200;
        end
        9'h10A: begin
          singleVectorWrData10 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000400;
        end
        9'h10B: begin
          singleVectorWrData11 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000000800;
        end
        9'h10C: begin
          singleVectorWrData12 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000001000;
         end
        9'h10D: begin
          singleVectorWrData13 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000002000;
        end
        9'h10E: begin
          singleVectorWrData14 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000004000;
        end
        9'h10F: begin
          singleVectorWrData15 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000008000;
        end
        9'h110: begin
          singleVectorWrData16 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000010000;
        end
        9'h111: begin
          singleVectorWrData17 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000020000;
        end
        9'h112: begin
          singleVectorWrData18 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000040000;
        end
        9'h113: begin
          singleVectorWrData19 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000080000;
        end
        9'h114: begin
          singleVectorWrData20 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000100000;
        end
        9'h115: begin
          singleVectorWrData21 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000200000;
        end
        9'h116: begin
          singleVectorWrData22 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000400000;
        end
        9'h117: begin
          singleVectorWrData23 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000000800000;
        end
        9'h118: begin
          singleVectorWrData24 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000001000000;
        end
        9'h119: begin
          singleVectorWrData25 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000002000000;
        end
        9'h11A: begin
          singleVectorWrData26 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000004000000;
        end
        9'h11B: begin
          singleVectorWrData27 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000008000000;
        end
        9'h11C: begin
          singleVectorWrData28 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000010000000;
        end
        9'h11D: begin
          singleVectorWrData29 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000020000000;
        end
        9'h11E: begin
          singleVectorWrData30 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000040000000;
        end
        9'h11F: begin
          singleVectorWrData31 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000080000000;
        end
        9'h120: begin
          singleVectorWrData32 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000100000000;
        end
        9'h121: begin
          singleVectorWrData33 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000000200000000;
        end
        9'h122: begin
          singleVectorWrData34 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000000400000000;
        end
        9'h123: begin
          singleVectorWrData35 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000000800000000;
        end
        9'h124: begin
          singleVectorWrData36 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |   64'h0000001000000000;
        end
        9'h125: begin
          singleVectorWrData37 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000002000000000;
        end
        9'h126: begin
          singleVectorWrData38 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000004000000000;
        end
        9'h127: begin
          singleVectorWrData39 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000008000000000;
        end
        9'h128: begin
          singleVectorWrData40 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000010000000000;
        end
        9'h129: begin
          singleVectorWrData41 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000020000000000;
        end
        9'h12A: begin
          singleVectorWrData42 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000040000000000;
        end
        9'h12B: begin
          singleVectorWrData43 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000080000000000;
        end
        9'h12C: begin
          singleVectorWrData44 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000100000000000;
        end
        9'h12D: begin
          singleVectorWrData45 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000200000000000;
        end
        9'h12E: begin
          singleVectorWrData46 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000400000000000;
        end
        9'h12F: begin
          singleVectorWrData47 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0000800000000000;
        end
        9'h130: begin
          singleVectorWrData48 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0001000000000000;
        end
        9'h131: begin
          singleVectorWrData49 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0002000000000000;
        end
        9'h132: begin
          singleVectorWrData50 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0004000000000000;
        end
        9'h133: begin
          singleVectorWrData51 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0008000000000000;
        end
        9'h134: begin
          singleVectorWrData52 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0010000000000000;
        end
        9'h135: begin
          singleVectorWrData53 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0020000000000000;
        end
        9'h136: begin
          singleVectorWrData54 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0040000000000000;
        end
        9'h137: begin
          singleVectorWrData55 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0080000000000000;
        end
        9'h138: begin
          singleVectorWrData56 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0100000000000000;
        end
        9'h139: begin
          singleVectorWrData57 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0200000000000000;
        end
        9'h13A: begin
          singleVectorWrData58 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0400000000000000;
        end
        9'h13B: begin
          singleVectorWrData59 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h0800000000000000;
        end
        9'h13C: begin
          singleVectorWrData60 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h1000000000000000;
        end
        9'h13D: begin
          singleVectorWrData61 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h2000000000000000;
        end
        9'h13E: begin
          singleVectorWrData62 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h4000000000000000;
        end
        9'h13F: begin
          singleVectorWrData63 <= S_AXI_WDATA;
          singleVectorWrDataMask <= singleVectorWrDataMask |  64'h8000000000000000;
        end

        default: begin
          waveID    <= waveID;
          baseVGPR  <= baseVGPR;
          baseSGPR  <= baseSGPR;
          baseLDS   <= baseLDS;
          waveCount <= waveCount;
          pcStart   <= pcStart;
          instrAddrReg <= instrAddrReg;
          
          mb2fpgamem_ack_reg <= mb2fpgamem_ack_reg;
          mb2fpgamem_done_reg <= mb2fpgamem_done_reg;
          
          quadBaseAddress <= quadBaseAddress;
          quadData0 <= quadData0;
          quadData1 <= quadData1;
          quadData2 <= quadData2;
          quadData3 <= quadData3;
          
          singleVectorBaseAddress <= singleVectorBaseAddress;
          singleVectorWrDataMask <= singleVectorWrDataMask;
          
          singleVectorWrData63 <= singleVectorWrData63;
          singleVectorWrData62 <= singleVectorWrData62;
          singleVectorWrData61 <= singleVectorWrData61;
          singleVectorWrData60 <= singleVectorWrData60;
          singleVectorWrData59 <= singleVectorWrData59;
          singleVectorWrData58 <= singleVectorWrData58;
          singleVectorWrData57 <= singleVectorWrData57;
          singleVectorWrData56 <= singleVectorWrData56;
          singleVectorWrData55 <= singleVectorWrData55;
          singleVectorWrData54 <= singleVectorWrData54;
          singleVectorWrData53 <= singleVectorWrData53;
          singleVectorWrData52 <= singleVectorWrData52;
          singleVectorWrData51 <= singleVectorWrData51;
          singleVectorWrData50 <= singleVectorWrData50;
          singleVectorWrData49 <= singleVectorWrData49;
          singleVectorWrData48 <= singleVectorWrData48;
          singleVectorWrData47 <= singleVectorWrData47;
          singleVectorWrData46 <= singleVectorWrData46;
          singleVectorWrData45 <= singleVectorWrData45;
          singleVectorWrData44 <= singleVectorWrData44;
          singleVectorWrData43 <= singleVectorWrData43;
          singleVectorWrData42 <= singleVectorWrData42;
          singleVectorWrData41 <= singleVectorWrData41;
          singleVectorWrData40 <= singleVectorWrData40;
          singleVectorWrData39 <= singleVectorWrData39;
          singleVectorWrData38 <= singleVectorWrData38;
          singleVectorWrData37 <= singleVectorWrData37;
          singleVectorWrData36 <= singleVectorWrData36;
          singleVectorWrData35 <= singleVectorWrData35;
          singleVectorWrData34 <= singleVectorWrData34;
          singleVectorWrData33 <= singleVectorWrData33;
          singleVectorWrData32 <= singleVectorWrData32;
          singleVectorWrData31 <= singleVectorWrData31;
          singleVectorWrData30 <= singleVectorWrData30;
          singleVectorWrData29 <= singleVectorWrData29;
          singleVectorWrData28 <= singleVectorWrData28;
          singleVectorWrData27 <= singleVectorWrData27;
          singleVectorWrData26 <= singleVectorWrData26;
          singleVectorWrData25 <= singleVectorWrData25;
          singleVectorWrData24 <= singleVectorWrData24;
          singleVectorWrData23 <= singleVectorWrData23;
          singleVectorWrData22 <= singleVectorWrData22;
          singleVectorWrData21 <= singleVectorWrData21;
          singleVectorWrData20 <= singleVectorWrData20;
          singleVectorWrData19 <= singleVectorWrData19;
          singleVectorWrData18 <= singleVectorWrData18;
          singleVectorWrData17 <= singleVectorWrData17;
          singleVectorWrData16 <= singleVectorWrData16;
          singleVectorWrData15 <= singleVectorWrData15;
          singleVectorWrData14 <= singleVectorWrData14;
          singleVectorWrData13 <= singleVectorWrData13;
          singleVectorWrData12 <= singleVectorWrData12;
          singleVectorWrData11 <= singleVectorWrData11;
          singleVectorWrData10 <= singleVectorWrData10;
          singleVectorWrData9 <= singleVectorWrData9;
          singleVectorWrData8 <= singleVectorWrData8;
          singleVectorWrData7 <= singleVectorWrData7;
          singleVectorWrData6 <= singleVectorWrData6;
          singleVectorWrData5 <= singleVectorWrData5;
          singleVectorWrData4 <= singleVectorWrData4;
          singleVectorWrData3 <= singleVectorWrData3;
          singleVectorWrData2 <= singleVectorWrData2;
          singleVectorWrData1 <= singleVectorWrData1;
          singleVectorWrData0 <= singleVectorWrData0;
        end
      endcase
    end
  end
end

always @(*) begin
  // Address decoding for reading registers
  case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
    9'h000  : reg_data_out <= resultsReady;
    9'h001  : reg_data_out <= waveID;
    9'h002  : reg_data_out <= baseVGPR;
    9'h003  : reg_data_out <= baseSGPR;
    9'h004  : reg_data_out <= baseLDS;
    9'h005  : reg_data_out <= waveCount;
    9'h006  : reg_data_out <= pcStart;
    9'h007  : reg_data_out <= instrAddrReg;
    9'h008  : reg_data_out <= instruction_buff_out_a;
    9'h009  : reg_data_out <= resultsReadyTag;
    //9'h00A   : unused
    9'h0C1  : reg_data_out <= quadBaseAddress;
    9'h0C2  : reg_data_out <= sgpr2lsu_source1_data[31:0];
    9'h0C3  : reg_data_out <= sgpr2lsu_source1_data[63:32];
    9'h0C4  : reg_data_out <= sgpr2lsu_source1_data[95:64];
    9'h0C5  : reg_data_out <= sgpr2lsu_source1_data[127:96];
    
    9'h040  : reg_data_out <= {28'd0, fpgamem2mb_op};
    9'h041  : reg_data_out <= fpgamem2mb_data;
    9'h042  : reg_data_out <= fpgamem2mb_addr;
    
    //7'h30   : reg_data_out <= cycle_counter;
    //7'h31   : reg_data_out <= pc_value;
    
    9'h100  : reg_data_out <= vgpr2lsu_source1_data[31:0];
    9'h101  : reg_data_out <= vgpr2lsu_source1_data[63:32];
    9'h102  : reg_data_out <= vgpr2lsu_source1_data[95:64];
    9'h103  : reg_data_out <= vgpr2lsu_source1_data[127:96];
    9'h104  : reg_data_out <= vgpr2lsu_source1_data[159:128];
    9'h105  : reg_data_out <= vgpr2lsu_source1_data[191:160];
    9'h106  : reg_data_out <= vgpr2lsu_source1_data[223:192];
    9'h107  : reg_data_out <= vgpr2lsu_source1_data[255:224];
    9'h108  : reg_data_out <= vgpr2lsu_source1_data[287:256];
    9'h109  : reg_data_out <= vgpr2lsu_source1_data[319:288];
    9'h10A  : reg_data_out <= vgpr2lsu_source1_data[351:320];
    9'h10B  : reg_data_out <= vgpr2lsu_source1_data[383:352];
    9'h10C  : reg_data_out <= vgpr2lsu_source1_data[415:384];
    9'h10D  : reg_data_out <= vgpr2lsu_source1_data[447:416];
    9'h10E  : reg_data_out <= vgpr2lsu_source1_data[479:448];
    9'h10F  : reg_data_out <= vgpr2lsu_source1_data[511:480];
    
    9'h110  : reg_data_out <= vgpr2lsu_source1_data[543:512];
    9'h111  : reg_data_out <= vgpr2lsu_source1_data[575:544];
    9'h112  : reg_data_out <= vgpr2lsu_source1_data[607:576];
    9'h113  : reg_data_out <= vgpr2lsu_source1_data[639:608];
    9'h114  : reg_data_out <= vgpr2lsu_source1_data[671:640];
    9'h115  : reg_data_out <= vgpr2lsu_source1_data[703:672];
    9'h116  : reg_data_out <= vgpr2lsu_source1_data[735:704];
    9'h117  : reg_data_out <= vgpr2lsu_source1_data[767:736];
    9'h118  : reg_data_out <= vgpr2lsu_source1_data[799:768];
    9'h119  : reg_data_out <= vgpr2lsu_source1_data[831:800];
    9'h11A  : reg_data_out <= vgpr2lsu_source1_data[863:832];
    9'h11B  : reg_data_out <= vgpr2lsu_source1_data[895:864];
    9'h11C  : reg_data_out <= vgpr2lsu_source1_data[927:896];
    9'h11D  : reg_data_out <= vgpr2lsu_source1_data[959:928];
    9'h11E  : reg_data_out <= vgpr2lsu_source1_data[991:960];
    9'h11F  : reg_data_out <= vgpr2lsu_source1_data[1023:992];
    
    9'h120  : reg_data_out <= vgpr2lsu_source1_data[1055:1024];
    9'h121  : reg_data_out <= vgpr2lsu_source1_data[1087:1056];
    9'h122  : reg_data_out <= vgpr2lsu_source1_data[1119:1088];
    9'h123  : reg_data_out <= vgpr2lsu_source1_data[1151:1120];
    9'h124  : reg_data_out <= vgpr2lsu_source1_data[1183:1152];
    9'h125  : reg_data_out <= vgpr2lsu_source1_data[1215:1184];
    9'h126  : reg_data_out <= vgpr2lsu_source1_data[1247:1216];
    9'h127  : reg_data_out <= vgpr2lsu_source1_data[1279:1248];
    9'h128  : reg_data_out <= vgpr2lsu_source1_data[1311:1280];
    9'h129  : reg_data_out <= vgpr2lsu_source1_data[1343:1312];
    9'h12A  : reg_data_out <= vgpr2lsu_source1_data[1375:1344];
    9'h12B  : reg_data_out <= vgpr2lsu_source1_data[1407:1376];
    9'h12C  : reg_data_out <= vgpr2lsu_source1_data[1439:1408];
    9'h12D  : reg_data_out <= vgpr2lsu_source1_data[1471:1440];
    9'h12E  : reg_data_out <= vgpr2lsu_source1_data[1503:1472];
    9'h12F  : reg_data_out <= vgpr2lsu_source1_data[1535:1504];
            
    9'h130  : reg_data_out <= vgpr2lsu_source1_data[1567:1536];
    9'h131  : reg_data_out <= vgpr2lsu_source1_data[1599:1568];
    9'h132  : reg_data_out <= vgpr2lsu_source1_data[1631:1600];
    9'h133  : reg_data_out <= vgpr2lsu_source1_data[1663:1632];
    9'h134  : reg_data_out <= vgpr2lsu_source1_data[1695:1664];
    9'h135  : reg_data_out <= vgpr2lsu_source1_data[1727:1696];
    9'h136  : reg_data_out <= vgpr2lsu_source1_data[1759:1728];
    9'h137  : reg_data_out <= vgpr2lsu_source1_data[1791:1760];
    9'h138  : reg_data_out <= vgpr2lsu_source1_data[1823:1792];
    9'h139  : reg_data_out <= vgpr2lsu_source1_data[1855:1824];
    9'h13A  : reg_data_out <= vgpr2lsu_source1_data[1887:1856];
    9'h13B  : reg_data_out <= vgpr2lsu_source1_data[1919:1888];
    9'h13C  : reg_data_out <= vgpr2lsu_source1_data[1951:1920];
    9'h13D  : reg_data_out <= vgpr2lsu_source1_data[1983:1952];
    9'h13E  : reg_data_out <= vgpr2lsu_source1_data[2015:1984];
    9'h13F  : reg_data_out <= vgpr2lsu_source1_data[2047:2016];
    
    default : reg_data_out <= 0;
  endcase
end

always @( posedge S_AXI_ACLK ) begin
  if ( S_AXI_ARESETN == 1'b0 ) begin
    axi_rdata  <= 0;
  end
  else begin
    // When there is a valid read address (S_AXI_ARVALID) with
    // acceptance of read address by the slave (axi_arready),
    // output the read dada
    if (slv_reg_rden) begin
      axi_rdata <= reg_data_out;     // register read data
    end
  end
end

assign lsu2vgpr_dest_data = {
  singleVectorWrData63, singleVectorWrData62, singleVectorWrData61, singleVectorWrData60, singleVectorWrData59, singleVectorWrData58,
  singleVectorWrData57, singleVectorWrData56, singleVectorWrData55, singleVectorWrData54, singleVectorWrData53, singleVectorWrData52,
  singleVectorWrData51, singleVectorWrData50, singleVectorWrData49, singleVectorWrData48, singleVectorWrData47, singleVectorWrData46,
  singleVectorWrData45, singleVectorWrData44, singleVectorWrData43, singleVectorWrData42, singleVectorWrData41, singleVectorWrData40,
  singleVectorWrData39, singleVectorWrData38, singleVectorWrData37, singleVectorWrData36, singleVectorWrData35, singleVectorWrData34,
  singleVectorWrData33, singleVectorWrData32, singleVectorWrData31, singleVectorWrData30, singleVectorWrData29, singleVectorWrData28,
  singleVectorWrData27, singleVectorWrData26, singleVectorWrData25, singleVectorWrData24, singleVectorWrData23, singleVectorWrData22,
  singleVectorWrData21, singleVectorWrData20, singleVectorWrData19, singleVectorWrData18, singleVectorWrData17, singleVectorWrData16,
  singleVectorWrData15, singleVectorWrData14, singleVectorWrData13, singleVectorWrData12, singleVectorWrData11, singleVectorWrData10,
  singleVectorWrData9,  singleVectorWrData8,  singleVectorWrData7,  singleVectorWrData6,  singleVectorWrData5,  singleVectorWrData4,
  singleVectorWrData3,  singleVectorWrData2,  singleVectorWrData1,  singleVectorWrData0
};
// I/O Connections assignments

assign buff2wave_tag = fetch2buff_tag_reg;
assign buff2fetchwave_ack = fetch2buff_rd_en_reg;
assign buff2wave_instr = instruction_buff_out_b;

always @( posedge clk) begin
  fetch2buff_tag_reg <= fetch2buff_tag;
  fetch2buff_rd_en_reg <= fetch2buff_rd_en;
  //buff2wave_instr_reg <= instruction_buff_out_b;
end

//assign pc_value = fetch2buff_addr;

block_ram instruction_buffer
(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(instrBuffWrEn), // input [3 : 0] wea
  .addra(instrAddrReg[9:0]), // input [31 : 0] addra
  .dina(S_AXI_WDATA), // input [31 : 0] dina
  .douta(instruction_buff_out_a), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(fetch2buff_addr[11:2]), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(instruction_buff_out_b) // output [31 : 0] doutb
);

compute_unit compute_unit0
(
  // Outputs
  .cu2dispatch_wf_done(cu2dispatch_wf_done),
  .cu2dispatch_wf_tag_done(cu2dispatch_wf_tag_done),
  .fetch2buff_rd_en(fetch2buff_rd_en),
  .fetch2buff_addr(fetch2buff_addr),
  .fetch2buff_tag(fetch2buff_tag),
  .lsu2mem_rd_en(lsu2mem_rd_en),
  .lsu2mem_wr_en(lsu2mem_wr_en),
  .lsu2mem_tag_req(lsu2mem_tag_req),
  .lsu2mem_wr_mask(),
  .lsu2mem_addr(lsu2mem_addr),
  .lsu2mem_wr_data(lsu2mem_wr_data),
  .lsu2mem_gm_or_lds(),
  .sgpr2dispatch_rd_data(sgpr2lsu_source1_data),
  .vgpr2dispatch_rd_data(vgpr2lsu_source1_data),
  // Inputs
  .dispatch2cu_idle(dispatch_idle),
  .dispatch2sgpr_addr(quadBaseAddress),
  .dispatch2sgpr_wr_data({quadData3, quadData2, quadData1, quadData0}),
  .dispatch2sgpr_wr_en(lsu2sgpr_dest_wr_en_reg),
  .dispatch2vgpr_addr(singleVectorBaseAddress),
  .dispatch2vgpr_wr_data(lsu2vgpr_dest_data),
  .dispatch2vgpr_wr_en(lsu2vgpr_dest_wr_en_reg),
  .dispatch2vgpr_wr_mask(singleVectorWrDataMask),
  .dispatch2cu_wf_dispatch(executeStart),
  .dispatch2cu_wf_tag_dispatch(waveID[14:0]),
  .dispatch2cu_start_pc_dispatch(pcStart),
  .dispatch2cu_sgpr_base_dispatch(baseSGPR[8:0]),
  .dispatch2cu_vgpr_base_dispatch(baseVGPR[9:0]),
  .dispatch2cu_lds_base_dispatch(baseLDS[15:0]),
  // Instruction buffer
  .buff2fetchwave_ack(fetch2buff_rd_en_reg),
  .buff2wave_instr(instruction_buff_out_b),
  .buff2wave_tag(fetch2buff_tag_reg),
  .dispatch2cu_wg_wf_count(4'd1),
  .dispatch2cu_wf_size_dispatch(waveCount[5:0]),
  .mem2lsu_ack(mem2lsu_ack),
  .mem2lsu_tag_resp(mem2lsu_tag_resp),
  .mem2lsu_rd_data(mem2lsu_rd_data),
  
  .clk(clk),
  .rst(rst)
);


























  
fpga_memory fpga_memory0(
  .mem_wr_en(lsu2mem_wr_en),
  .mem_rd_en(lsu2mem_rd_en),
  .mem_addr(lsu2mem_addr),
  .mem_wr_data(lsu2mem_wr_data),
  .mem_tag_req(lsu2mem_tag_req),
  
  // MB
  //.mb_data_in(mb2fpgamem_data_in_reg),S_AXI_WDATA
  .mb_data_in(S_AXI_WDATA),
  .mb_data_we(mb2fpgamem_data_we),
  .mb_ack(mb2fpgamem_ack_reg),
  .mb_done(mb2fpgamem_done_reg),
  
  .clk(clk),
  .rst(rst),
  // output
  // LSU
  .mem_tag_resp(mem2lsu_tag_resp),
  .mem_rd_data(mem2lsu_rd_data),
  .mem_ack(mem2lsu_ack),
  
  // MB
  .mb_op(fpgamem2mb_op),
  .mb_data_out(fpgamem2mb_data),
  .mb_addr(fpgamem2mb_addr)
);

endmodule
module fpga_memory
(
  // input
  // LSU
  mem_wr_en, mem_rd_en,
  mem_addr, mem_wr_data, mem_tag_req,
  
  // MB
  mb_data_in, mb_data_we, mb_ack, mb_done,
  
  clk, rst,
  // output
  // LSU
  mem_tag_resp, mem_rd_data, mem_ack,
  
  // MB
  mb_op, mb_data_out, mb_addr
);

input clk;
input rst;

input mem_wr_en;
input mem_rd_en;
input [31:0] mem_addr;
input [31:0] mem_wr_data;
input [6:0] mem_tag_req;

input [31:0] mb_data_in;
input mb_data_we;
input mb_ack;
input mb_done;

output [31:0] mem_rd_data;
output [6:0] mem_tag_resp;
output mem_ack;

output [3:0] mb_op;
output [31:0] mb_data_out;
output [31:0] mb_addr;

reg [31:0] mem_addr_reg;
//reg [31:0] mem_wr_en;
reg [31:0] mb_data_out_reg;
reg[6:0] mem_tag_req_reg;

reg[3:0] mem_state;
reg[3:0] mem_state_next;

reg [31:0] mb_data_in_reg;
reg mem_ack_reg;
reg mb_ack_reg;
reg mb_done_reg;









assign mem_tag_resp = mem_tag_req_reg;
assign mem_rd_data = mb_data_in_reg;
assign mem_ack = mem_ack_reg;

assign mb_data_out = mb_data_out_reg;
assign mb_addr = mem_addr_reg;
assign mb_op = mem_state;

always@(posedge clk) begin
  if(rst) begin
    mem_state <= 4'b0000;
    mb_data_out_reg <= 32'd0;
    mem_addr_reg <= 32'd0;
    mem_tag_req_reg <= 7'd0;
    mb_data_in_reg <= 32'd0;
    mb_ack_reg <= 1'b0;
    mb_done_reg <= 1'b0;
  end
  else begin
    mb_ack_reg <= mb_ack;
    mb_done_reg <= mb_done;
    mem_state <= mem_state_next;
    
    mb_data_out_reg <= mb_data_out_reg;
    if(mem_wr_en) begin
      mb_data_out_reg <= mem_wr_data;
    end
    
    mem_addr_reg <= mem_addr_reg;
    mem_tag_req_reg <= mem_tag_req_reg;
    if(mem_wr_en | mem_rd_en) begin
      mem_addr_reg <= mem_addr;
      mem_tag_req_reg <= mem_tag_req;
    end
    
    mb_data_in_reg <= mb_data_in_reg;
    if(mb_data_we) begin
      mb_data_in_reg <= mb_data_in;
    end
  end
end

always@(*) begin
  mem_state_next <= mem_state;
  mem_ack_reg <= 1'b0;
  case(mem_state)
    4'b0000: begin
      if(mem_wr_en) begin
        mem_state_next <= 4'b0001;
      end
      else if(mem_rd_en) begin
        mem_state_next <= 4'b0100;
      end
    end
    4'b0001: begin
      if(~mb_ack_reg & mb_ack) begin
        mem_state_next <= 4'b0010;
      end
    end
    4'b0010: begin
      if(~mb_done_reg & mb_done) begin
        mem_state_next <= 4'b0011;
      end
    end
    4'b0011: begin
      mem_ack_reg <= 1'b1;
      mem_state_next <= 4'b0000;
    end
    4'b0100: begin
      if(~mb_ack_reg & mb_ack) begin
        mem_state_next <= 4'b0101;
      end
    end
    4'b0101: begin
      if(~mb_done_reg & mb_done) begin
        mem_state_next <= 4'b0110;
      end
    end
    4'b0110: begin
      mem_ack_reg <= 1'b1;
      mem_state_next <= 4'b0000;
    end
    default: mem_state_next <= mem_state;
  endcase
end

endmodule// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module fpga_memory_2 # (
    parameter LSU_MEM_DATA_WIDTH = 32,
    parameter VGPR_BUS_WIDTH = 2048,
    parameter VGPR_BUS_WIDTH_LOG = 11,
    parameter MAX_PKT_LEN = 35,
    parameter MSG_MSHRID_HI = 13,
    parameter MSG_MSHRID_LO = 6
)
(
    input wire clk,
    input wire rst,

    // output to noc2 (send requests to noc2 through packet filter)
    output reg                          noc2_filter_val,
    output wire [64 - 1:0] noc2_filter_data,
    input wire                          filter_noc2_rdy,

    // input from noc3 (receive responses from noc3 through packet filter)
    input wire                         filter_noc3_val,
    input wire [64 - 1:0] filter_noc3_data,
    output reg                         noc3_filter_rdy,

    // LSU inputs/outputs
    input wire                            lsu_wr_en,
    input wire                            lsu_rd_en,
    input wire [LSU_MEM_DATA_WIDTH - 1:0] lsu_addr,
    input wire [LSU_MEM_DATA_WIDTH - 1:0] lsu_wr_data,
    input wire [6:0]                      lsu_tag_req,

    output reg  [6:0]                      lsu_tag_resp,
    output wire [LSU_MEM_DATA_WIDTH - 1:0] lsu_rd_data,
    output reg                             lsu_ack
);

// STATES
localparam STATE_IDLE = 4'd0; // waiting for a mem request from LSU
localparam STATE_WR_SAVE_DATA = 4'd1; // get 32 bits from LSU
localparam STATE_WR_WAIT_DATA = 4'd2; // wait a cycle to get data from LSU
localparam STATE_WR_SLIDE_DATA = 4'd3; // shift data over in buffer
localparam STATE_WR_SEND_FLIT_ONE = 4'd4; // send first write header flit
localparam STATE_WR_SEND_FLIT_TWO = 4'd5; // send second write header flit
localparam STATE_WR_SEND_FLIT_THREE = 4'd6; // send third write header flit
localparam STATE_WR_SEND_FLIT_DATA = 4'd7; // send data to write
localparam STATE_WR_ACK_WAIT = 4'd8; // wait for ack from memory
localparam STATE_RD_SEND_FLIT_ONE = 4'd9; // send first read header flit
localparam STATE_RD_SEND_FLIT_TWO = 4'd10; // send second read header flit
localparam STATE_RD_SEND_FLIT_THREE = 4'd11; // send third read header flit
localparam STATE_RD_RESP_HEAD = 4'd12; // response header from memory
localparam STATE_RD_RESP_DATA = 4'd13; // response data from memory
localparam STATE_RD_SEND_DATA = 4'd14; // send data to LSU
localparam STATE_RD_WAIT_TO_SEND = 4'd15; // wait to send data to LSU

reg [4:0] state;
reg [4:0] state_next;

// amount of data seen so far (in either read rsp or write req)
reg [VGPR_BUS_WIDTH_LOG - 1:0] bits_seen;
reg [VGPR_BUS_WIDTH_LOG - 1:0] bits_seen_next;

reg [5:0] flit_count;
reg [5:0] flit_count_next;

reg [5:0] total_flits_to_send;
reg [5:0] total_flits_to_send_next;

reg [5:0] total_flits_to_see;
reg [5:0] total_flits_to_see_next;

reg [VGPR_BUS_WIDTH - 1:0] data_buffer;
reg [VGPR_BUS_WIDTH - 1:0] data_buffer_next;

reg [6:0] lsu_tag_resp_next;

reg [6:0] lsu_tag_req_reg;
reg [6:0] lsu_tag_req_reg_next;

reg [LSU_MEM_DATA_WIDTH - 1:0] lsu_addr_reg;
reg [LSU_MEM_DATA_WIDTH - 1:0] lsu_addr_reg_next;

reg [64 - 1:0] flit_to_send;

assign lsu_rd_data = data_buffer[LSU_MEM_DATA_WIDTH - 1:0];
assign noc2_filter_data = flit_to_send;

reg is_new_flit;
reg is_new_flit_next;

// update variables
always @( * ) begin
    noc2_filter_val = 1'b0;
    noc3_filter_rdy = 1'b0;
    lsu_ack = 1'b0;
    flit_to_send = 64'b0;

    lsu_tag_resp_next = lsu_tag_resp;
    bits_seen_next = bits_seen;
    flit_count_next = flit_count;
    total_flits_to_send_next = total_flits_to_send;
    total_flits_to_see_next = total_flits_to_see;
    data_buffer_next = data_buffer;
    lsu_addr_reg_next = lsu_addr_reg;
    lsu_tag_req_reg_next = lsu_tag_req;
    is_new_flit_next = is_new_flit;

    case (state)
        STATE_IDLE: begin
            bits_seen_next = 11'd0;
            flit_count_next = 6'd0;
            total_flits_to_send_next = 6'd0;
            total_flits_to_see_next = 6'd0;
            data_buffer_next = 2048'd0;

            if (lsu_wr_en) begin
                is_new_flit_next = 1'b1;
                total_flits_to_send_next = 4'd3;
            end
            else if (lsu_rd_en) begin
                total_flits_to_see_next = MAX_PKT_LEN - 2; // 2 fewer header packets
            end
        end
        STATE_WR_SAVE_DATA: begin
            lsu_ack = 1'b1;
            if (bits_seen == 0) begin
                lsu_tag_req_reg_next = lsu_tag_req;
                lsu_addr_reg_next = lsu_addr;
            end

            data_buffer_next[VGPR_BUS_WIDTH - LSU_MEM_DATA_WIDTH - 1: 0] = data_buffer[VGPR_BUS_WIDTH - 1:LSU_MEM_DATA_WIDTH];
            data_buffer_next[VGPR_BUS_WIDTH - 1:VGPR_BUS_WIDTH - LSU_MEM_DATA_WIDTH] = lsu_wr_data;

            bits_seen_next = bits_seen + 6'd32;
        end
        STATE_WR_WAIT_DATA: begin
            if (is_new_flit) begin
                total_flits_to_send_next = total_flits_to_send + 1;
            end

            is_new_flit_next = ~is_new_flit;
        end
        STATE_WR_SLIDE_DATA: begin
            data_buffer_next[VGPR_BUS_WIDTH - LSU_MEM_DATA_WIDTH - 1: 0] = data_buffer[VGPR_BUS_WIDTH - 1:LSU_MEM_DATA_WIDTH];
            
            bits_seen_next = bits_seen + 6'd32;
        end
        STATE_WR_SEND_FLIT_ONE: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = flit_count + 1'b1;
                flit_to_send[29:22] = total_flits_to_send - 1;
                flit_to_send[MSG_MSHRID_HI - 2:MSG_MSHRID_LO] = lsu_tag_req_reg;
            end
        end
        STATE_WR_SEND_FLIT_TWO: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = flit_count + 1'b1;
                flit_to_send[((16 + 40 - 1)):(16)] = {16'b0, lsu_addr_reg};
            end
        end
        STATE_WR_SEND_FLIT_THREE: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = flit_count + 1'b1;
             end
        end
        STATE_WR_SEND_FLIT_DATA: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = flit_count + 1'b1;
                flit_to_send = data_buffer[64:0];
                data_buffer_next[VGPR_BUS_WIDTH - 1 - 64:0] = data_buffer[VGPR_BUS_WIDTH - 1:64];
            end

            if (flit_count >= total_flits_to_send - 1 && filter_noc2_rdy) begin
                flit_count_next = 6'd0;
            end
        end
        STATE_WR_ACK_WAIT: begin
            noc3_filter_rdy = 1'b1;
            if (filter_noc3_val) begin
                lsu_tag_resp_next = filter_noc3_data[MSG_MSHRID_HI - 2:MSG_MSHRID_LO];
            end
        end
        STATE_RD_SEND_FLIT_ONE: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = flit_count + 1'b1;
                flit_to_send[29:22] = 8'd3;
                flit_to_send[MSG_MSHRID_HI - 2:MSG_MSHRID_LO] = lsu_tag_req;
                lsu_addr_reg_next = lsu_addr;
            end
        end
        STATE_RD_SEND_FLIT_TWO: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next=  flit_count + 1'b1;
                flit_to_send[((16 + 40 - 1)):(16)] = {16'b0, lsu_addr_reg};
            end
        end
        STATE_RD_SEND_FLIT_THREE: begin
            if (filter_noc2_rdy) begin
                noc2_filter_val = 1'b1;
                flit_count_next = 6'd0;
            end
        end
        STATE_RD_RESP_HEAD: begin
            noc3_filter_rdy = 1'b1;
            if (filter_noc3_val) begin
                lsu_tag_resp_next = filter_noc3_data[MSG_MSHRID_HI - 2:MSG_MSHRID_LO];
                flit_count_next = flit_count + 1'b1;
            end
        end
        STATE_RD_RESP_DATA: begin
            noc3_filter_rdy = 1'b1;
            if (filter_noc3_val) begin
                data_buffer_next[VGPR_BUS_WIDTH - 1 - 64:0] = data_buffer[VGPR_BUS_WIDTH - 1:64];
                data_buffer_next[VGPR_BUS_WIDTH - 1:VGPR_BUS_WIDTH - 64] = filter_noc3_data;
                flit_count_next = flit_count + 1'b1;
            end
        end
        STATE_RD_SEND_DATA: begin
            lsu_ack = 1'b1;
        end
        STATE_RD_WAIT_TO_SEND: begin
            data_buffer_next[VGPR_BUS_WIDTH - 1 - LSU_MEM_DATA_WIDTH:0] = data_buffer[VGPR_BUS_WIDTH - 1:LSU_MEM_DATA_WIDTH];
        end
        default: begin
        end
    endcase
end

// next state logic
always @( * ) begin
    state_next = state;

    case (state)
        STATE_IDLE: begin
            if (lsu_wr_en) begin
                state_next = STATE_WR_SAVE_DATA;
            end
            else if (lsu_rd_en) begin
                state_next = STATE_RD_SEND_FLIT_ONE;
            end
        end
        STATE_WR_SAVE_DATA: begin
            state_next = STATE_WR_WAIT_DATA;
        end
        STATE_WR_WAIT_DATA: begin
            if (lsu_wr_en) begin
                state_next = STATE_WR_SAVE_DATA;
            end
            else begin
                state_next = STATE_WR_SLIDE_DATA;
            end
        end
        STATE_WR_SLIDE_DATA: begin
            if (bits_seen >= VGPR_BUS_WIDTH - LSU_MEM_DATA_WIDTH) begin
                state_next = STATE_WR_SEND_FLIT_ONE;
            end
        end
        STATE_WR_SEND_FLIT_ONE: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_WR_SEND_FLIT_TWO;
            end
        end
        STATE_WR_SEND_FLIT_TWO: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_WR_SEND_FLIT_THREE;
            end
        end
        STATE_WR_SEND_FLIT_THREE: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_WR_SEND_FLIT_DATA;
            end
        end
        STATE_WR_SEND_FLIT_DATA: begin
            if (flit_count >= total_flits_to_send - 1 && filter_noc2_rdy) begin
                state_next = STATE_WR_ACK_WAIT;
            end
        end
        STATE_WR_ACK_WAIT: begin
            if (filter_noc3_val) begin
                state_next = STATE_IDLE;
            end
        end
        STATE_RD_SEND_FLIT_ONE: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_RD_SEND_FLIT_TWO;
            end
        end
        STATE_RD_SEND_FLIT_TWO: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_RD_SEND_FLIT_THREE;
            end
        end
        STATE_RD_SEND_FLIT_THREE: begin
            if (filter_noc2_rdy) begin
                state_next = STATE_RD_RESP_HEAD;
            end
        end
        STATE_RD_RESP_HEAD: begin
            if (filter_noc3_val) begin
                state_next = STATE_RD_RESP_DATA;
            end
        end
        STATE_RD_RESP_DATA: begin
            if (filter_noc3_val && flit_count >= total_flits_to_see - 1) begin
                state_next = STATE_RD_SEND_DATA;
            end
        end
        STATE_RD_SEND_DATA: begin
            state_next = STATE_RD_WAIT_TO_SEND;
        end
        STATE_RD_WAIT_TO_SEND: begin
            if (lsu_rd_en) begin
                state_next = STATE_RD_SEND_DATA;
            end
            else begin
                state_next = STATE_IDLE;
            end
        end
        default: begin
            state_next = state;
        end
    endcase
end

// update registers
always @(posedge clk) begin
    if (rst) begin
        state <= STATE_IDLE;
        bits_seen <= 11'd0;
        total_flits_to_send <= 6'd0;
        total_flits_to_see <= 6'd0;
        flit_count <= 6'd0;
        data_buffer <= 2048'd0;
        lsu_tag_resp <= 6'd0;
        lsu_addr_reg <= 32'd0;
        lsu_tag_req_reg <= 6'd0;
        is_new_flit <= 1'b0;
    end
    else begin
        state <= state_next;
        bits_seen <= bits_seen_next;
        total_flits_to_send <= total_flits_to_send_next;
        total_flits_to_see <= total_flits_to_see_next;
        flit_count <= flit_count_next;
        data_buffer <= data_buffer_next;
        lsu_tag_resp <= lsu_tag_resp_next;
        lsu_addr_reg <= lsu_addr_reg_next;
        lsu_tag_req_reg <= lsu_tag_req_reg_next;
        is_new_flit <= is_new_flit_next;
    end
end

endmodule
module neko #
(
	parameter integer NEKO_AXI_DATA_WIDTH	= 32,
	parameter integer NEKO_AXI_ADDR_WIDTH	= 11
)
(
    input                                   chipset_clk,
    input                                   rst_n,

    input                                   noc2_in_val,
    input       [64-1:0]       noc2_in_data,
    output                                  noc2_in_rdy,

    output                                  noc3_out_val,
    output      [64-1:0]       noc3_out_data,
    input                                   noc3_out_rdy











);


	wire  neko_axi_aclk;
	wire  neko_axi_aresetn;
	wire [NEKO_AXI_ADDR_WIDTH-1 : 0] neko_axi_awaddr;
	wire [2 : 0] neko_axi_awprot;
	wire  neko_axi_awvalid;
	wire  neko_axi_awready;
	wire [NEKO_AXI_DATA_WIDTH-1 : 0] neko_axi_wdata;
	wire [(NEKO_AXI_DATA_WIDTH/8)-1 : 0] neko_axi_wstrb;
	wire  neko_axi_wvalid;
	wire  neko_axi_wready;
	wire [1 : 0] neko_axi_bresp;
	wire  neko_axi_bvalid;
	wire  neko_axi_bready;
	wire [NEKO_AXI_ADDR_WIDTH-1 : 0] neko_axi_araddr;
	wire [2 : 0] neko_axi_arprot;
	wire  neko_axi_arvalid;
	wire  neko_axi_arready;
	wire [NEKO_AXI_DATA_WIDTH-1 : 0] neko_axi_rdata;
	wire [1 : 0] neko_axi_rresp;
	wire  neko_axi_rvalid;
	wire  neko_axi_rready;

    assign neko_axi_aclk = chipset_clk;
    assign neko_axi_aresetn = rst_n;

noc_axilite_bridge noc_neko_bridge   (
    .clk                    (chipset_clk        ),
    .rst                    (~rst_n             ),      // TODO: rewrite to positive ?
           
    .splitter_bridge_val    (noc2_in_val   ),
    .splitter_bridge_data   (noc2_in_data  ),
    .bridge_splitter_rdy    (noc2_in_rdy   ),   // CRAZY NAMING !

    .bridge_splitter_val    (noc3_out_val   ),
    .bridge_splitter_data   (noc3_out_data  ),
    .splitter_bridge_rdy    (noc3_out_rdy   ),   // CRAZY NAMING !
       
    //axi lite signals             
    //write address channel
    .m_axi_awaddr        (neko_axi_awaddr),
    .m_axi_awvalid       (neko_axi_awvalid),
    .m_axi_awready       (neko_axi_awready),

    //write data channel
    .m_axi_wdata         (neko_axi_wdata),
    .m_axi_wstrb         (neko_axi_wstrb),
    .m_axi_wvalid        (neko_axi_wvalid),
    .m_axi_wready        (neko_axi_wready),

    //read address channel
    .m_axi_araddr        (neko_axi_araddr),
    .m_axi_arvalid       (neko_axi_arvalid),
    .m_axi_arready       (neko_axi_arready),

    //read data channel
    .m_axi_rdata         (neko_axi_rdata),
    .m_axi_rresp         (neko_axi_rresp),
    .m_axi_rvalid        (neko_axi_rvalid),
    .m_axi_rready        (neko_axi_rready),

    //write response channel
    .m_axi_bresp         (neko_axi_bresp),
    .m_axi_bvalid        (neko_axi_bvalid),
    .m_axi_bready        (neko_axi_bready)
);

    compute_unit_fpga # (
        .C_S_AXI_DATA_WIDTH(NEKO_AXI_DATA_WIDTH),
        .C_S_AXI_ADDR_WIDTH(NEKO_AXI_ADDR_WIDTH)
    ) compute_unit_fpga (
        .S_AXI_ACLK(neko_axi_aclk),
		.S_AXI_ARESETN(neko_axi_aresetn),
		.S_AXI_AWADDR(neko_axi_awaddr),
		.S_AXI_AWPROT(neko_axi_awprot),
		.S_AXI_AWVALID(neko_axi_awvalid),
		.S_AXI_AWREADY(neko_axi_awready),
		.S_AXI_WDATA(neko_axi_wdata),
		.S_AXI_WSTRB(neko_axi_wstrb),
		.S_AXI_WVALID(neko_axi_wvalid),
		.S_AXI_WREADY(neko_axi_wready),
		.S_AXI_BRESP(neko_axi_bresp),
		.S_AXI_BVALID(neko_axi_bvalid),
		.S_AXI_BREADY(neko_axi_bready),
		.S_AXI_ARADDR(neko_axi_araddr),
		.S_AXI_ARPROT(neko_axi_arprot),
		.S_AXI_ARVALID(neko_axi_arvalid),
		.S_AXI_ARREADY(neko_axi_arready),
		.S_AXI_RDATA(neko_axi_rdata),
		.S_AXI_RRESP(neko_axi_rresp),
		.S_AXI_RVALID(neko_axi_rvalid),
		.S_AXI_RREADY(neko_axi_rready)









    );
endmodule
	module neko_axi_slave #
	(
		// Users to add parameters here

		// User parameters ends
		// Do not modify the parameters beyond this line

		// Width of S_AXI data bus
		parameter integer NEKO_AXI_DATA_WIDTH	= 32,
		// Width of S_AXI address bus
		parameter integer NEKO_AXI_ADDR_WIDTH	= 9
	)
	(
		// Users to add ports here

		output wire [NEKO_AXI_DATA_WIDTH-1:0] waveID_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] baseVGPR_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] baseSGPR_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] baseLDS_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] waveCount_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] pcStart_out,
        output wire [NEKO_AXI_DATA_WIDTH-1:0] instrAddrReg_out,
        input wire [NEKO_AXI_DATA_WIDTH-1:0] instruction_buff_out_a_in,
        input wire cu2dispatch_wf_done_in,
        input wire [NEKO_AXI_DATA_WIDTH-1:0] resultsReadyTag_in,

        output wire [3:0] lsu2sgpr_dest_wr_en_out,
        output wire [9:0] quadBaseAddress_out,
        output wire [31:0] quadData0_out,
        output wire [31:0] quadData1_out,
        output wire [31:0] quadData2_out,
        output wire [31:0] quadData3_out,
        input wire [127:0] quadData_in,

        output wire execute_out,
        output wire executeStart_out,

        output wire [3:0] instrBuffWrEn_out,

        output wire [31:0] axi_data_out,
        
        output wire [31:0] mb2fpgamem_data_in,
        output wire mb2fpgamem_data_we,
        output wire mb2fpgamem_ack,
        output wire mb2fpgamem_done,
        
        input wire [3:0] fpgamem2mb_op,
        input wire [31:0] fpgamem2mb_data,
        input wire [31:0] fpgamem2mb_addr,
        
        input wire [31:0] pc_value,

		// User ports ends
		// Do not modify the ports beyond this line

		// Global Clock Signal
		input wire  S_AXI_ACLK,
		// Global Reset Signal. This Signal is Active LOW
		input wire  S_AXI_ARESETN,
		// Write address (issued by master, acceped by Slave)
		input wire [NEKO_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
		// Write channel Protection type. This signal indicates the
    		// privilege and security level of the transaction, and whether
    		// the transaction is a data access or an instruction access.
		input wire [2 : 0] S_AXI_AWPROT,
		// Write address valid. This signal indicates that the master signaling
    		// valid write address and control information.
		input wire  S_AXI_AWVALID,
		// Write address ready. This signal indicates that the slave is ready
    		// to accept an address and associated control signals.
		output wire  S_AXI_AWREADY,
		// Write data (issued by master, acceped by Slave)
		input wire [NEKO_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
		// Write strobes. This signal indicates which byte lanes hold
    		// valid data. There is one write strobe bit for each eight
    		// bits of the write data bus.
		input wire [(NEKO_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
		// Write valid. This signal indicates that valid write
    		// data and strobes are available.
		input wire  S_AXI_WVALID,
		// Write ready. This signal indicates that the slave
    		// can accept the write data.
		output wire  S_AXI_WREADY,
		// Write response. This signal indicates the status
    		// of the write transaction.
		output wire [1 : 0] S_AXI_BRESP,
		// Write response valid. This signal indicates that the channel
    		// is signaling a valid write response.
		output wire  S_AXI_BVALID,
		// Response ready. This signal indicates that the master
    		// can accept a write response.
		input wire  S_AXI_BREADY,
		// Read address (issued by master, acceped by Slave)
		input wire [NEKO_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
		// Protection type. This signal indicates the privilege
    		// and security level of the transaction, and whether the
    		// transaction is a data access or an instruction access.
		input wire [2 : 0] S_AXI_ARPROT,
		// Read address valid. This signal indicates that the channel
    		// is signaling valid read address and control information.
		input wire  S_AXI_ARVALID,
		// Read address ready. This signal indicates that the slave is
    		// ready to accept an address and associated control signals.
		output wire  S_AXI_ARREADY,
		// Read data (issued by slave)
		output wire [NEKO_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
		// Read response. This signal indicates the status of the
    		// read transfer.
		output wire [1 : 0] S_AXI_RRESP,
		// Read valid. This signal indicates that the channel is
    		// signaling the required read data.
		output wire  S_AXI_RVALID,
		// Read ready. This signal indicates that the master can
    		// accept the read data and response information.
		input wire  S_AXI_RREADY
	);

	// AXI4LITE signals
	reg [NEKO_AXI_ADDR_WIDTH-1 : 0] 	axi_awaddr;
	reg  	axi_awready;
	reg  	axi_wready;
	reg [1 : 0] 	axi_bresp;
	reg  	axi_bvalid;
	reg [NEKO_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
	reg  	axi_arready;
	reg [NEKO_AXI_DATA_WIDTH-1 : 0] 	axi_rdata;
	reg [1 : 0] 	axi_rresp;
	reg  	axi_rvalid;

	// Example-specific design signals
	// local parameter for addressing 32 bit / 64 bit NEKO_AXI_DATA_WIDTH
	// ADDR_LSB is used for addressing 32/64 bit registers/memories
	// ADDR_LSB = 2 for 32 bits (n downto 2)
	// ADDR_LSB = 3 for 64 bits (n downto 3)
	localparam integer ADDR_LSB = (NEKO_AXI_DATA_WIDTH/32) + 1;
	localparam integer OPT_MEM_ADDR_BITS = 6;
	//----------------------------------------------
	//-- Signals for user logic register space example
	//------------------------------------------------
	//-- Number of Slave Registers 128
	wire	 slv_reg_rden;
	wire	 slv_reg_wren;
	reg [NEKO_AXI_DATA_WIDTH-1:0]	 reg_data_out;
	integer	 byte_index;

reg slv_reg_wren_buffer;
parameter IDLE_STATE = 4'd0;
parameter DISPATCH_STATE = 4'd1;
parameter EXECUTE_STATE = 4'd2;
parameter RESULT_STATE = 4'd3;

reg [3:0] executeState;
reg [3:0] executeStateNext;
reg execute;
reg executeStart;

reg [NEKO_AXI_DATA_WIDTH-1:0] waveID;
reg [NEKO_AXI_DATA_WIDTH-1:0] baseVGPR;
reg [NEKO_AXI_DATA_WIDTH-1:0] baseSGPR;
reg [NEKO_AXI_DATA_WIDTH-1:0] baseLDS;
reg [NEKO_AXI_DATA_WIDTH-1:0] waveCount;
reg [NEKO_AXI_DATA_WIDTH-1:0] pcStart;
reg [NEKO_AXI_DATA_WIDTH-1:0] resultsReady;
reg [NEKO_AXI_DATA_WIDTH-1:0] resultsReadyTag;

reg [3:0] instrBuffWrEn;
reg [31:0] instrAddrReg;

reg [9:0] quadBaseAddress;
reg [31:0] quadData0;
reg [31:0] quadData1;
reg [31:0] quadData2;
reg [31:0] quadData3;
reg [3:0] lsu2sgpr_dest_wr_en_reg;

reg [31:0] mb2fpgamem_data_in_reg;
reg mb2fpgamem_data_we_reg;
reg mb2fpgamem_ack_reg;
reg mb2fpgamem_done_reg;

reg [31:0] cycle_counter;
reg [31:0] cycle_counter_next;

wire [31:0] fpgamem2mb_op_net;

assign fpgamem2mb_op_net = {28'd0, fpgamem2mb_op}; 

assign mb2fpgamem_data_in = mb2fpgamem_data_in_reg;
assign mb2fpgamem_data_we = mb2fpgamem_data_we_reg;
assign mb2fpgamem_ack = mb2fpgamem_ack_reg;
assign mb2fpgamem_done = mb2fpgamem_done_reg;

assign waveID_out = waveID;
assign baseVGPR_out = baseVGPR;
assign baseSGPR_out = baseSGPR;
assign baseLDS_out = baseLDS;
assign waveCount_out = waveCount;
assign pcStart_out = pcStart;
assign instrAddrReg_out = instrAddrReg;

assign quadBaseAddress_out = quadBaseAddress;
assign lsu2sgpr_dest_wr_en_out = lsu2sgpr_dest_wr_en_reg;
assign quadData0_out = quadData0;
assign quadData1_out = quadData1;
assign quadData2_out = quadData2;
assign quadData3_out = quadData3;

assign execute_out = execute;
assign executeStart_out = executeStart;

assign instrBuffWrEn_out = instrBuffWrEn;

assign axi_data_out = S_AXI_WDATA;

	// I/O Connections assignments

	assign S_AXI_AWREADY	= axi_awready;
	assign S_AXI_WREADY	= axi_wready;
	assign S_AXI_BRESP	= axi_bresp;
	assign S_AXI_BVALID	= axi_bvalid;
	assign S_AXI_ARREADY	= axi_arready;
	assign S_AXI_RDATA	= axi_rdata;
	assign S_AXI_RRESP	= axi_rresp;
	assign S_AXI_RVALID	= axi_rvalid;
	// Implement axi_awready generation
	// axi_awready is asserted for one S_AXI_ACLK clock cycle when both
	// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_awready is
	// de-asserted when reset is low.

always @(*) begin
      instrBuffWrEn <= 4'd0;
      if(~execute && slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 7'h08) begin
        instrBuffWrEn <= 4'b1111;
      end
    end

    always @( posedge S_AXI_ACLK ) begin
      if ( S_AXI_ARESETN == 1'b0 ) begin
        executeState <= IDLE_STATE;
        cycle_counter <= 32'd0;
      end
      else begin
        executeState <= executeStateNext;
        cycle_counter <= cycle_counter_next;
      end
    end

    always @(*) begin
      executeStateNext <= executeState;
      cycle_counter_next <= cycle_counter;
      executeStart <= 1'b0;
      resultsReady <= 1'b0;
      execute <= 1'b1;
      case(executeState)
        IDLE_STATE: begin
          execute <= 1'b0;
          if(slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 7'h00) begin
            executeStart <= 1'b1;
            executeStateNext <= EXECUTE_STATE;
            cycle_counter_next <= 32'd0;
          end
        end
        EXECUTE_STATE: begin
          cycle_counter_next <= cycle_counter + 32'd1;
          if(cu2dispatch_wf_done_in) begin
            executeStateNext <= RESULT_STATE;
          end
        end
        RESULT_STATE: begin
          resultsReady <= 1'b1;
          if(slv_reg_rden && axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 7'h00) begin
            executeStateNext <= IDLE_STATE;
          end
        end
        default: executeStateNext <= IDLE_STATE;
      endcase
    end

    always @(*) begin
      lsu2sgpr_dest_wr_en_reg <= 4'd0;
      if(slv_reg_wren && ~slv_reg_wren_buffer && axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] == 7'h0A) begin
        lsu2sgpr_dest_wr_en_reg <= 4'b1111;
      end
    end

	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_awready <= 1'b0;
	    end
	  else
	    begin
	      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
	        begin
	          // slave is ready to accept write address when
	          // there is a valid write address and write data
	          // on the write address and data bus. This design
	          // expects no outstanding transactions.
	          axi_awready <= 1'b1;
	        end
	      else
	        begin
	          axi_awready <= 1'b0;
	        end
	    end
	end

	// Implement axi_awaddr latching
	// This process is used to latch the address when both
	// S_AXI_AWVALID and S_AXI_WVALID are valid.

	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_awaddr <= 0;
	    end
	  else
	    begin
	      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
	        begin
	          // Write Address latching
	          axi_awaddr <= S_AXI_AWADDR;
	        end
	    end
	end

	// Implement axi_wready generation
	// axi_wready is asserted for one S_AXI_ACLK clock cycle when both
	// S_AXI_AWVALID and S_AXI_WVALID are asserted. axi_wready is
	// de-asserted when reset is low.

	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_wready <= 1'b0;
	    end
	  else
	    begin
	      if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)
	        begin
	          // slave is ready to accept write data when
	          // there is a valid write address and write data
	          // on the write address and data bus. This design
	          // expects no outstanding transactions.
	          axi_wready <= 1'b1;
	        end
	      else
	        begin
	          axi_wready <= 1'b0;
	        end
	    end
	end

	// Implement memory mapped register select and write logic generation
	// The write data is accepted and written to memory mapped registers when
	// axi_awready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted. Write strobes are used to
	// select byte enables of slave registers while writing.
	// These registers are cleared when reset (active low) is applied.
	// Slave register write enable is asserted when valid address and data are available
	// and the slave is ready to accept the write address and write data.
	assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;

	always @( posedge S_AXI_ACLK )
    begin
      if ( S_AXI_ARESETN == 1'b0 )
      begin
        waveID    <= 32'd0;
        baseVGPR  <= 32'd0;
        baseSGPR  <= 32'd0;
        baseLDS   <= 32'd0;
        waveCount <= 32'd0;

        resultsReadyTag <= 32'd0;
        
        slv_reg_wren_buffer <= 1'b0;
      end
      else begin
        slv_reg_wren_buffer <= slv_reg_wren;
        if(cu2dispatch_wf_done_in) begin
          resultsReadyTag <= resultsReadyTag_in;
        end
        if (slv_reg_wren)
          begin
            case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
              // 7'h00: Start command initiate program
              7'h01: waveID       <= S_AXI_WDATA;
              7'h02: baseVGPR     <= S_AXI_WDATA;
              7'h03: baseSGPR     <= S_AXI_WDATA;
              7'h04: baseLDS      <= S_AXI_WDATA;
              7'h05: waveCount    <= S_AXI_WDATA;
              7'h06: pcStart      <= S_AXI_WDATA;
              7'h07: instrAddrReg <= S_AXI_WDATA;
              // 7'h08: Instruction value
              // 7'h09: Unused
              // 7'h0A: GPR command register
              7'h0B: quadBaseAddress <= S_AXI_WDATA[9:0];
              7'h0C: quadData0 <= S_AXI_WDATA;
              7'h0D: quadData1 <= S_AXI_WDATA;
              7'h0E: quadData2 <= S_AXI_WDATA;
              7'h0F: quadData3 <= S_AXI_WDATA;
              
              7'h30: mb2fpgamem_data_in_reg <= S_AXI_WDATA;
              7'h31: mb2fpgamem_data_we_reg <= S_AXI_WDATA[0];
              7'h32: mb2fpgamem_ack_reg <= S_AXI_WDATA[0];
              7'h33: mb2fpgamem_done_reg <= S_AXI_WDATA[0];
              default:
              begin
                waveID    <= waveID;
                baseVGPR  <= baseVGPR;
                baseSGPR  <= baseSGPR;
                baseLDS   <= baseLDS;
                waveCount <= waveCount;
              end
            endcase
          end
      end
    end

	// Implement write response logic generation
	// The write response and response valid signals are asserted by the slave
	// when axi_wready, S_AXI_WVALID, axi_wready and S_AXI_WVALID are asserted.
	// This marks the acceptance of address and indicates the status of
	// write transaction.

	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_bvalid  <= 0;
	      axi_bresp   <= 2'b0;
	    end
	  else
	    begin
	      if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
	        begin
	          // indicates a valid write response is available
	          axi_bvalid <= 1'b1;
	          axi_bresp  <= 2'b0; // 'OKAY' response
	        end                   // work error responses in future
	      else
	        begin
	          if (S_AXI_BREADY && axi_bvalid)
	            //check if bready is asserted while bvalid is high)
	            //(there is a possibility that bready is always asserted high)
	            begin
	              axi_bvalid <= 1'b0;
	            end
	        end
	    end
	end

	// Implement axi_arready generation
	// axi_arready is asserted for one S_AXI_ACLK clock cycle when
	// S_AXI_ARVALID is asserted. axi_awready is
	// de-asserted when reset (active low) is asserted.
	// The read address is also latched when S_AXI_ARVALID is
	// asserted. axi_araddr is reset to zero on reset assertion.

	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_arready <= 1'b0;
	      axi_araddr  <= 32'b0;
	    end
	  else
	    begin
	      if (~axi_arready && S_AXI_ARVALID)
	        begin
	          // indicates that the slave has acceped the valid read address
	          axi_arready <= 1'b1;
	          // Read address latching
	          axi_araddr  <= S_AXI_ARADDR;
	        end
	      else
	        begin
	          axi_arready <= 1'b0;
	        end
	    end
	end

	// Implement axi_arvalid generation
	// axi_rvalid is asserted for one S_AXI_ACLK clock cycle when both
	// S_AXI_ARVALID and axi_arready are asserted. The slave registers
	// data are available on the axi_rdata bus at this instance. The
	// assertion of axi_rvalid marks the validity of read data on the
	// bus and axi_rresp indicates the status of read transaction.axi_rvalid
	// is deasserted on reset (active low). axi_rresp and axi_rdata are
	// cleared to zero on reset (active low).
	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_rvalid <= 0;
	      axi_rresp  <= 0;
	    end
	  else
	    begin
	      if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
	        begin
	          // Valid read data is available at the read data bus
	          axi_rvalid <= 1'b1;
	          axi_rresp  <= 2'b0; // 'OKAY' response
	        end
	      else if (axi_rvalid && S_AXI_RREADY)
	        begin
	          // Read data is accepted by the master
	          axi_rvalid <= 1'b0;
	        end
	    end
	end

	// Implement memory mapped register select and read logic generation
	// Slave register read enable is asserted when valid address is available
	// and the slave is ready to accept the read address.
	assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;
	always @(*)
    begin
      // Address decoding for reading registers
      case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
        7'h00   : reg_data_out <= resultsReady;
        7'h01   : reg_data_out <= waveID;
        7'h02   : reg_data_out <= baseVGPR;
        7'h03   : reg_data_out <= baseSGPR;
        7'h04   : reg_data_out <= baseLDS;
        7'h05   : reg_data_out <= waveCount;
        7'h06   : reg_data_out <= pcStart;
        7'h07   : reg_data_out <= instrAddrReg;
        7'h08   : reg_data_out <= instruction_buff_out_a_in;
        7'h09   : reg_data_out <= resultsReadyTag;
        //7'h0A   : unused
        7'h0B   : reg_data_out <= quadBaseAddress;
        7'h0C   : reg_data_out <= quadData_in[31:0];
        7'h0D   : reg_data_out <= quadData_in[63:32];
        7'h0E   : reg_data_out <= quadData_in[95:64];
        7'h0F   : reg_data_out <= quadData_in[127:96];
        
        7'h20   : reg_data_out <= fpgamem2mb_op_net;
        7'h21   : reg_data_out <= fpgamem2mb_data;
        7'h22   : reg_data_out <= fpgamem2mb_addr;
        
        7'h30   : reg_data_out <= cycle_counter;
        7'h31   : reg_data_out <= pc_value;
        default : reg_data_out <= 0;
      endcase
    end

	// Output register or memory read data
	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_rdata  <= 0;
	    end
	  else
	    begin
	      // When there is a valid read address (S_AXI_ARVALID) with
	      // acceptance of read address by the slave (axi_arready),
	      // output the read dada
	      if (slv_reg_rden)
	        begin
	          axi_rdata <= reg_data_out;     // register read data
	        end
	    end
	end

	// Add user logic here

	// User logic ends

	endmodule
module neko_lsu
(/*AUTOARG*/
    // Outputs
    issue_ready,
    vgpr_source1_rd_en, vgpr_source2_rd_en,
    sgpr_source1_rd_en, sgpr_source2_rd_en,
    mem_gm_or_lds, tracemon_gm_or_lds,
    vgpr_dest_wr_en,
    mem_rd_en, mem_wr_en,
    sgpr_dest_wr_en,
    exec_rd_wfid,
    mem_tag_req,
    sgpr_source1_addr, sgpr_source2_addr, sgpr_dest_addr,
    vgpr_source1_addr, vgpr_source2_addr, vgpr_dest_addr,
    vgpr_dest_wr_mask, mem_wr_mask,
    sgpr_dest_data,
    mem_addr,
    vgpr_dest_data, mem_wr_data, rfa_dest_wr_req,
    lsu_done, lsu_done_wfid,
    sgpr_instr_done, sgpr_instr_done_wfid,
    vgpr_instr_done, vgpr_instr_done_wfid,
    tracemon_retire_pc, tracemon_mem_addr, tracemon_idle,
    // Inputs
    clk, rst, issue_lsu_select, mem_ack, issue_wfid, mem_tag_resp,
    issue_source_reg1, issue_source_reg2, issue_source_reg3,
    issue_dest_reg, issue_mem_sgpr, issue_imm_value0, issue_lds_base,
    issue_imm_value1, issue_opcode, sgpr_source2_data,
    exec_rd_m0_value, issue_instr_pc, exec_exec_value,
    sgpr_source1_data, vgpr_source2_data, vgpr_source1_data,
    mem_rd_data, lsu_stall
);

parameter MEMORY_BUS_WIDTH = 32;
parameter MEM_SLOTS = 1;

input clk;
input rst;

input issue_lsu_select, mem_ack;
input [5:0] issue_wfid;
input [6:0] mem_tag_resp;
input [11:0] issue_source_reg1, issue_source_reg2, issue_source_reg3,
    issue_dest_reg, issue_mem_sgpr;
input [15:0] issue_imm_value0, issue_lds_base;
input [31:0] issue_imm_value1, issue_opcode, sgpr_source2_data, exec_rd_m0_value,
    issue_instr_pc;
input [63:0] exec_exec_value;
input [127:0] sgpr_source1_data;
input [2047:0] vgpr_source1_data;
input [2047:0] vgpr_source2_data;
input [MEMORY_BUS_WIDTH-1:0] mem_rd_data;
input lsu_stall;

output    issue_ready, vgpr_source1_rd_en, vgpr_source2_rd_en,
      sgpr_source1_rd_en, sgpr_source2_rd_en, mem_gm_or_lds,
      tracemon_gm_or_lds;
output vgpr_dest_wr_en, mem_rd_en, mem_wr_en;
output [3:0] sgpr_dest_wr_en;
output [5:0]   exec_rd_wfid;
output [6:0]   mem_tag_req;
output [8:0]   sgpr_source1_addr, sgpr_source2_addr, sgpr_dest_addr;
output [9:0]   vgpr_source1_addr, vgpr_source2_addr, vgpr_dest_addr;
output [63:0]  vgpr_dest_wr_mask, mem_wr_mask;
output [127:0] sgpr_dest_data;
output [31:0] mem_addr;
output [2047:0] vgpr_dest_data;
output [MEMORY_BUS_WIDTH-1:0] mem_wr_data;

output rfa_dest_wr_req;

output lsu_done;
output sgpr_instr_done;
output vgpr_instr_done;

output [5:0] lsu_done_wfid;
output [5:0] sgpr_instr_done_wfid;
output [5:0] vgpr_instr_done_wfid;

output [31:0]  tracemon_retire_pc;
output [2047:0] tracemon_mem_addr;
output tracemon_idle;

assign exec_rd_wfid = issue_wfid;

reg [31:0] issue_opcode_flopped;
reg [15:0] issue_lds_base_flopped;
reg [15:0] issue_imm_value0_flopped;

wire [2047:0] calc_mem_addr;
wire gm_or_lds;

wire decoded_sgpr_source1_rd_en;
wire decoded_sgpr_source2_rd_en;
wire [8:0] decoded_sgpr_source1_addr;
wire [8:0] decoded_sgpr_source2_addr;

//wire decoded_vgpr_source1_rd_en;
wire decoded_vgpr_source2_rd_en;
wire [9:0] decoded_vgpr_source1_addr;
wire [9:0] decoded_vgpr_source2_addr;

wire [5:0] mem_op_cnt;
wire mem_op_rd;
wire mem_op_wr;
wire mem_gpr;
wire [3:0] sgpr_wr_mask;

wire [1:0] gpr_op_depth;

always@(posedge clk) begin

    if(rst) begin
        issue_opcode_flopped <= 32'd0;
        issue_lds_base_flopped <= 16'd0;
        issue_imm_value0_flopped <= 16'd0;
    end
    else begin
        issue_opcode_flopped <= issue_opcode;
        issue_lds_base_flopped <= issue_lds_base;
        issue_imm_value0_flopped <= issue_imm_value0;
    end

end

// The decoder requires two cycles to receive the entire opcode. On the second
// cycle it generates register read operations for getting addres values from
// the GPRs.
lsu_opcode_decoder lsu_opcode_decoder0(
    .lsu_selected(issue_lsu_select),
    .lsu_opcode(issue_opcode),
    
    .issue_source_reg1(issue_source_reg1),
    .issue_source_reg2(issue_source_reg2),
    .issue_source_reg3(issue_source_reg3),
    .issue_mem_sgpr(issue_mem_sgpr),
    //.issue_dest_reg(issue_dest_reg_flopped),

    .sgpr_source1_rd_en(decoded_sgpr_source1_rd_en),
    .sgpr_source2_rd_en(decoded_sgpr_source2_rd_en),
    .sgpr_source1_addr(decoded_sgpr_source1_addr),
    .sgpr_source2_addr(decoded_sgpr_source2_addr),
    
    .vgpr_source2_rd_en(decoded_vgpr_source2_rd_en),
    .vgpr_source1_addr(decoded_vgpr_source1_addr),
    .vgpr_source2_addr(decoded_vgpr_source2_addr),
    
    // Signals to indicate a new memory request
    .mem_op_cnt(mem_op_cnt),
    .mem_op_rd(mem_op_rd),
    .mem_op_wr(mem_op_wr),
    .mem_gpr(mem_gpr),
    
    .sgpr_wr_mask(sgpr_wr_mask),
    
    .gpr_op_depth(gpr_op_depth)
);

lsu_op_manager lsu_op_manager0(
    .lsu_wfid(issue_wfid),
    .instr_pc(issue_instr_pc),
    
    // Signals to indicate a new memory request
    .mem_op_cnt(mem_op_cnt),
    .mem_op_rd(mem_op_rd),
    .mem_op_wr(mem_op_wr),
    .mem_gpr(mem_gpr),
    .gm_or_lds(gm_or_lds),
    
    .sgpr_wr_mask(sgpr_wr_mask),
    .gpr_op_depth(gpr_op_depth),
    .exec_mask(exec_exec_value),
    
    .mem_in_addr(calc_mem_addr),
    
    .mem_ack(mem_ack),
    .mem_rd_data(mem_rd_data),
    
    .vgpr_source1_data(vgpr_source1_data),
    
    .free_mem_slots(1'b0),
    
    .decoded_sgpr_source1_rd_en(decoded_sgpr_source1_rd_en),
    .decoded_sgpr_source2_rd_en(decoded_sgpr_source2_rd_en),
    .decoded_sgpr_source1_addr(decoded_sgpr_source1_addr),
    .decoded_sgpr_source2_addr(decoded_sgpr_source2_addr),

    //decoded_vgpr_source1_rd_en,
    .decoded_vgpr_source2_rd_en(decoded_vgpr_source2_rd_en),
    .decoded_vgpr_source1_addr(decoded_vgpr_source1_addr),
    .decoded_vgpr_source2_addr(decoded_vgpr_source2_addr),
    
    .decoded_dest_addr(issue_dest_reg),
    
    .sgpr_dest_data(sgpr_dest_data),
    .sgpr_dest_wr_en(sgpr_dest_wr_en),
    .sgpr_dest_addr(sgpr_dest_addr),
    
    .vgpr_dest_data(vgpr_dest_data),
    .vgpr_dest_wr_en(vgpr_dest_wr_en),
    .vgpr_wr_mask(vgpr_dest_wr_mask),
    .vgpr_dest_addr(vgpr_dest_addr),
    
    .lsu_rdy(issue_ready),
    
    .lsu_done(lsu_done),
    .sgpr_instr_done(sgpr_instr_done),
    .vgpr_instr_done(vgpr_instr_done),
    .lsu_done_wfid(lsu_done_wfid),
    .sgpr_instr_done_wfid(sgpr_instr_done_wfid),
    .vgpr_instr_done_wfid(vgpr_instr_done_wfid),
    
    .retire_pc(tracemon_retire_pc),
    .retire_gm_or_lds(tracemon_gm_or_lds),
    .tracemon_mem_addr(tracemon_mem_addr),
    
    .mem_rd_en(mem_rd_en),
    .mem_wr_en(mem_wr_en),
    .mem_out_addr(mem_addr),
    .mem_wr_data(mem_wr_data),
    .mem_tag_req(mem_tag_req),
    .mem_gm_or_lds(mem_gm_or_lds),
    
    .sgpr_source1_rd_en(sgpr_source1_rd_en),
    .sgpr_source2_rd_en(sgpr_source2_rd_en),
    .sgpr_source1_addr(sgpr_source1_addr),
    .sgpr_source2_addr(sgpr_source2_addr),
    
    .vgpr_source1_rd_en(vgpr_source1_rd_en),
    .vgpr_source2_rd_en(vgpr_source2_rd_en),
    .vgpr_source1_addr(vgpr_source1_addr),
    .vgpr_source2_addr(vgpr_source2_addr),
    
    .clk(clk),
    .rst(rst)
);

// Because the register read operations for the address values will take one
// cycle to complete the opcode needs to be flopped so that the opcode being
// used by the address calculator is properly aligned.
lsu_addr_calculator addr_calc(
    .in_vector_source_b(vgpr_source2_data),
    .in_scalar_source_a(sgpr_source1_data),
    .in_scalar_source_b(sgpr_source2_data),
    .in_opcode(issue_opcode_flopped),
    .in_lds_base(issue_lds_base_flopped),
    .in_imm_value0(issue_imm_value0_flopped),
    .out_ld_st_addr(calc_mem_addr),
    .out_gm_or_lds(gm_or_lds)
);

assign rfa_dest_wr_req = (|sgpr_dest_wr_en) | vgpr_dest_wr_en;

// Something of a hack, at this point it's not actually needed
assign mem_wr_mask = vgpr_dest_wr_mask;

assign tracemon_idle = issue_ready;

endmodule
module reg_128x32b_3r_2w_fpga
(/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   clk, rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr1_addr, wr0_en,
   wr1_en, wr0_data, wr1_data
   );
input clk;

output [31:0] rd0_data;
output [31:0] rd1_data;
output [31:0] rd2_data;

input [6:0] rd0_addr;
input [6:0] rd1_addr;
input [6:0] rd2_addr;

input [6:0] wr0_addr;
input [6:0] wr1_addr;

input wr0_en;
input wr1_en;

input [31:0] wr0_data;
input [31:0] wr1_data;

wire [6:0] wr_addr;
wire [9:0] wr_addr_blk;
wire wr_en;
wire [31:0] wr_data;

wire [9:0] rd0_addr_blk;
wire [9:0] rd1_addr_blk;
wire [9:0] rd2_addr_blk;

assign rd0_addr_blk = {3'b000, rd0_addr};
assign rd1_addr_blk = {3'b000, rd1_addr};
assign rd2_addr_blk = {3'b000, rd2_addr};

assign wr_data = wr1_en ? wr1_data : wr0_data;
assign wr_addr = wr1_en ? wr1_addr : wr0_addr;
assign wr_addr_blk = {3'b000, wr_addr};
assign wr_en = wr0_en | wr1_en;

block_ram bank0(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr_en), // input [3 : 0] wea
  .addra(wr_addr_blk), // input [31 : 0] addra
  .dina(wr_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd0_addr_blk), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(rd0_data) // output [31 : 0] doutb
);

block_ram bank1(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr_en), // input [3 : 0] wea
  .addra(wr_addr_blk), // input [31 : 0] addra
  .dina(wr_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd1_addr_blk), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(rd1_data) // output [31 : 0] doutb
);

block_ram bank2(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr_en), // input [3 : 0] wea
  .addra(wr_addr_blk), // input [31 : 0] addra
  .dina(wr_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd2_addr_blk), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(rd2_data) // output [31 : 0] doutb
);

endmodule
module reg_256x32b_3r_1w_fpga
  (/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   clk, rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr0_en, wr0_data
   );
   input clk;

   output [31:0] rd0_data;
   output [31:0] rd1_data;
   output [31:0] rd2_data;

   input [9:0]   rd0_addr;
   input [9:0]   rd1_addr;
   input [9:0]   rd2_addr;

   input [9:0]   wr0_addr;

   input   wr0_en;

   input [31:0]  wr0_data;

wire [31:0] block_out_a;
wire [31:0] block_out_b;
wire [31:0] block_out_c;

reg wr_en_a;

assign rd0_data = block_out_a;
assign rd1_data = block_out_b;
assign rd2_data = block_out_c;

block_ram bank0(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr0_en), // input [3 : 0] wea
  .addra(wr0_addr), // input [31 : 0] addra
  .dina(wr0_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd0_addr), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(block_out_a) // output [31 : 0] doutb
);

block_ram bank1(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr0_en), // input [3 : 0] wea
  .addra(wr0_addr), // input [31 : 0] addra
  .dina(wr0_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd1_addr), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(block_out_b) // output [31 : 0] doutb
);

block_ram bank2(
  .clka(clk), // input clka
  //.rsta(rst), // input rsta
  .wea(wr0_en), // input [3 : 0] wea
  .addra(wr0_addr), // input [31 : 0] addra
  .dina(wr0_data), // input [31 : 0] dina
  .douta(), // output [31 : 0] douta
  .clkb(clk), // input clkb
  //.rstb(rst), // input rstb
  .web(1'b0), // input [3 : 0] web
  .addrb(rd2_addr), // input [31 : 0] addrb
  .dinb(32'd0), // input [31 : 0] dinb
  .doutb(block_out_c) // output [31 : 0] doutb
);
   
endmodule
/**
 * issue_definitions.v
 * File that contains all definitions used throughout issue
 * stage
 ***/




// PC + Opcode + IMM0 + IMM1 + SRC1 + SRC2 + SRC3 + SRC4 +
// DST1 + DST2





































































 // _issue_definitions_v_
/**
 * global_definitions.v
 * File with al global definitions of the miaow project.
 * This file does not need to be included within the modules but it needs to be
 * listed for compilation/syntesys.
 */


// Maximum number of wavefronts per compute unit

// Maximum number of workgroups per compute unit

// Maximum number of wavefronts per wavegroup

// Length of WF_ID in bits


// Length of operand field on instructions





// Single word length


// Number of VGPRS

// Number of SGPRs


  //_global_definitions_v_

module alu_issue_logic
(/*AUTOARG*/
    // Outputs
    c_issued_valid, c_simd0_alu_select, c_simd1_alu_select,
    c_simd2_alu_select, c_simd3_alu_select, c_simf0_alu_select,
    c_simf1_alu_select, c_simf2_alu_select, c_simf3_alu_select,
    c_lsu_lsu_select, c_salu_alu_select, c_issued_wfid,
    // Inputs
    clk, rst, f_lsu_ready, f_salu_alu_ready, f_simf3_alu_ready,
    f_simf2_alu_ready, f_simf1_alu_ready, f_simf0_alu_ready,
    f_simd3_alu_ready, f_simd2_alu_ready, f_simd1_alu_ready,
    f_simd0_alu_ready, lsu_wf_valid, simd_wf_valid, simf_wf_valid,
    salu_wf_valid, lsu_wf_chosen, simd_wf_choosen, simf_wf_choosen,
    salu_wf_choosen
);

input clk,rst;

input   f_lsu_ready, f_salu_alu_ready,
        f_simf3_alu_ready,f_simf2_alu_ready,
        f_simf1_alu_ready,f_simf0_alu_ready,
        f_simd3_alu_ready,f_simd2_alu_ready,
        f_simd1_alu_ready,f_simd0_alu_ready;


input lsu_wf_valid, simd_wf_valid, simf_wf_valid ,salu_wf_valid;
input [6-1:0] lsu_wf_chosen, simd_wf_choosen, simf_wf_choosen, salu_wf_choosen;

output  c_issued_valid;
output  c_simd0_alu_select, c_simd1_alu_select, 
        c_simd2_alu_select, c_simd3_alu_select, 
        c_simf0_alu_select, c_simf1_alu_select, 
        c_simf2_alu_select, c_simf3_alu_select, 
        c_lsu_lsu_select, c_salu_alu_select;

output [6-1:0] c_issued_wfid;

reg [6-1:0] c_issued_wfid;


wire [1:0] last_fu_selected;

reg [1:0] curr_fu_selected;

reg_param #(2) last_fu(.out(last_fu_selected), .in(curr_fu_selected), 
          .wr_en(c_issued_valid), .clk(clk), .rst(rst));


reg c_issued_valid;
reg c_simd0_alu_select, c_simd1_alu_select, 
    c_simd2_alu_select, c_simd3_alu_select, 
    c_simf0_alu_select, c_simf1_alu_select, 
    c_simf2_alu_select, c_simf3_alu_select, 
    c_lsu_lsu_select, c_salu_alu_select;
             
reg [3:0] fu_ready_shifted, fu_selected_shifted;
reg [3:0] fu_ready_arry, fu_selected_arry;
         
always @(*) begin

    fu_ready_arry <= { (f_simd0_alu_ready | f_simd1_alu_ready | f_simd2_alu_ready | 
    f_simd3_alu_ready) & simd_wf_valid,
    (f_simf0_alu_ready | f_simf1_alu_ready | f_simf2_alu_ready | 
    f_simf3_alu_ready) & simf_wf_valid,
    f_lsu_ready & lsu_wf_valid,
    f_salu_alu_ready & salu_wf_valid };

      // Select one fu based on round robin between fu classes
    case( last_fu_selected )
        2'b00 : fu_ready_shifted <= fu_ready_arry;
        2'b01 : fu_ready_shifted <= {fu_ready_arry[0], fu_ready_arry[3:1]};
        2'b10 : fu_ready_shifted <= {fu_ready_arry[1:0], fu_ready_arry[3:2]};
        2'b11 : fu_ready_shifted <= {fu_ready_arry[2:0], fu_ready_arry[3]};
    endcase

    casex( fu_ready_shifted )
        4'b1??? : begin
            fu_selected_shifted <= fu_ready_shifted & 4'b1000;
            curr_fu_selected <= 2'h3;
        end

        4'b01?? : begin
            fu_selected_shifted <= fu_ready_shifted & 4'b0100;
            curr_fu_selected <= 2'h2;
        end

        4'b001? : begin 
            fu_selected_shifted <= fu_ready_shifted & 4'b0010;
            curr_fu_selected <= 2'h1;
        end
                      
        4'b0001 : begin
            fu_selected_shifted <= fu_ready_shifted & 4'b0001;
            curr_fu_selected <= 2'h0;
        end
           
        default : begin
            fu_selected_shifted <= 4'b0000;
            curr_fu_selected <= last_fu_selected;
        end
    endcase // casex ( fu_ready_shifted )

    case( last_fu_selected )
        2'b00 : fu_selected_arry <= fu_selected_shifted;
        2'b01 : fu_selected_arry <= {fu_selected_shifted[2:0], fu_selected_shifted[3]};
        2'b10 : fu_selected_arry <= {fu_selected_shifted[1:0], fu_selected_shifted[3:2]};
        2'b11 : fu_selected_arry <= {fu_selected_shifted[0], fu_selected_shifted[3:1]};
    endcase // case ( last_fu_selected )

    // With the class selected, we select the correct alu
    casex( { f_simd0_alu_ready,f_simd1_alu_ready,f_simd2_alu_ready,f_simd3_alu_ready} )
        4'b1??? : begin
            c_simd0_alu_select <= fu_selected_arry[3];
            c_simd1_alu_select <= 1'b0;
            c_simd2_alu_select <= 1'b0;
            c_simd3_alu_select <= 1'b0;
        end

        4'b01?? : begin
            c_simd0_alu_select <= 1'b0;
            c_simd1_alu_select <= fu_selected_arry[3];
            c_simd2_alu_select <= 1'b0;
            c_simd3_alu_select <= 1'b0;
        end

        4'b001? : begin
            c_simd0_alu_select <= 1'b0;
            c_simd1_alu_select <= 1'b0;
            c_simd2_alu_select <= fu_selected_arry[3];
            c_simd3_alu_select <= 1'b0;
        end

        4'b0001 : begin
            c_simd0_alu_select <= 1'b0;
            c_simd1_alu_select <= 1'b0;
            c_simd2_alu_select <= 1'b0;
            c_simd3_alu_select <= fu_selected_arry[3];
        end

        default : begin
            c_simd0_alu_select <= 1'b0;
            c_simd1_alu_select <= 1'b0;
            c_simd2_alu_select <= 1'b0;
            c_simd3_alu_select <= 1'b0;
        end
    endcase

    casex( { f_simf0_alu_ready,f_simf1_alu_ready,f_simf2_alu_ready,f_simf3_alu_ready} )
        4'b1??? : begin
            c_simf0_alu_select <= fu_selected_arry[2];
            c_simf1_alu_select <= 1'b0;
            c_simf2_alu_select <= 1'b0;
            c_simf3_alu_select <= 1'b0;
        end

        4'b01?? : begin
            c_simf0_alu_select <= 1'b0;
            c_simf1_alu_select <= fu_selected_arry[2];
            c_simf2_alu_select <= 1'b0;
            c_simf3_alu_select <= 1'b0;
        end

        4'b001? : begin
            c_simf0_alu_select <= 1'b0;
            c_simf1_alu_select <= 1'b0;
            c_simf2_alu_select <= fu_selected_arry[2];
            c_simf3_alu_select <= 1'b0;
        end

        4'b0001 : begin
            c_simf0_alu_select <= 1'b0;
            c_simf1_alu_select <= 1'b0;
            c_simf2_alu_select <= 1'b0;
            c_simf3_alu_select <= fu_selected_arry[2];
        end

        default : begin
            c_simf0_alu_select <= 1'b0;
            c_simf1_alu_select <= 1'b0;
            c_simf2_alu_select <= 1'b0;
            c_simf3_alu_select <= 1'b0;
        end

    endcase

    c_lsu_lsu_select <= fu_selected_arry[1];
    c_salu_alu_select <= fu_selected_arry[0];
      
      // Select the correct wfid
    case( fu_selected_arry )
        4'b1000 : c_issued_wfid <= simd_wf_choosen;
        4'b0100 : c_issued_wfid <= simf_wf_choosen;
        4'b0010 : c_issued_wfid <= lsu_wf_chosen;
        4'b0001 : c_issued_wfid <= salu_wf_choosen;
        default : c_issued_wfid <= {6{1'bx}};
    endcase // case ( fu_selected_arry )

    c_issued_valid <= |fu_selected_arry;
end

endmodule
module arbiter(
    // Inputs
    input_arry,
    issued_en,
    issued_wf_id,
    
    // Outputs
    choosen_valid,
    choosen_wf_id,
    
    clk,
    rst
);

input clk,rst;
input issued_en;
input[5:0] issued_wf_id;
input[39:0] input_arry;

output choosen_valid;
output[5:0] choosen_wf_id;

wire[5:0] last_issued_wf_id, last_issued_wf_id_corr_output, priority_encoder_out;
wire[39:0] priority_encoder_in, decoded_priority_encoder_out, choosen_wf_id_encoded;

reg_param #(6) last_wf_id_issued_reg(
    .out(last_issued_wf_id),
    .in(issued_wf_id),
    .wr_en(issued_en),
    .clk(clk),
    .rst(rst)
);

circular_barrel_shift input_priority_shifter(
	.output_val(priority_encoder_in),
	.input_val(input_arry),
	.shift_amt(last_issued_wf_id)
);

circular_barrel_shift output_priority_shifter(
    .output_val(choosen_wf_id_encoded),
    .input_val(decoded_priority_encoder_out),
    .shift_amt(last_issued_wf_id_corr_output)
);

decoder_6b_40b_en decoder_6b_40b_en(
	.addr_in(priority_encoder_out),
	.out(decoded_priority_encoder_out),
	.en(choosen_valid)
);

priority_encoder_40to6 priority_encoder(
	.binary_out(priority_encoder_out),
	.valid(choosen_valid),
	.encoder_in(priority_encoder_in),
	.enable(|priority_encoder_in)
);

encoder encoder(
	.in(choosen_wf_id_encoded),
	.out(choosen_wf_id)
);

assign last_issued_wf_id_corr_output = 6'd40 - last_issued_wf_id;

endmodule
module barrier_wait
  (/*AUTOARG*/
   // Outputs
   tracemon_barrier_retire_en, fetch_wg_wfid, barrier_wait_arry,
   tracemon_barrier_retire_wf_bitmap, tracemon_barrier_retire_pc,
   // Inputs
   clk, rst, f_decode_valid, f_decode_barrier, f_decode_wfid,
   f_decode_instr_pc, fetch_wg_wgid, fetch_wg_wf_count
   );
   /**
    * Barrier wait has to recognize a barrier instruction
    * from decode and hold the wf that hits the barrier until
    * all wf from that wg are decoded.
    * for each workgroup:
    ** have a list (Bitmap) of wf that hit the barrier
    ** somehow keep track of the number of wf that hit the barrier
    * fore each wf
    ** 1 bit identifies wheather it hit or not the barrier
    ** clear bits from all wf when all wg hit the barrier
    **/

   input clk,rst;
   input f_decode_valid, f_decode_barrier;
   input [6-1:0] f_decode_wfid;
   input [31:0] 	     f_decode_instr_pc;
   
   
   input [6-1:0] fetch_wg_wgid;
   input [3:0] 		     fetch_wg_wf_count;

   wire 		     decode_barrier_valid;

   output 		     tracemon_barrier_retire_en;
   
   output [6-1:0] fetch_wg_wfid;
   output [40-1:0]    barrier_wait_arry;
   output [40-1:0]    tracemon_barrier_retire_wf_bitmap;

   output [31:0] 	      tracemon_barrier_retire_pc;
   
   wire [40-1:0]      curr_wg_wf_waiting, next_curr_wg_wf_waiting;
   
   wire [16-1:0]      curr_wg_wf_count, next_curr_wg_wf_count;

   wire [40-1:0]      barrier_wait_arry, next_barrier_wait_arry;

   wire 		      all_wf_hit_barrier, first_wf_barrier;

   
   reg [16-1:0]       wf_count_mask;

   wire [40-1:0]      decode_barrier_valid_decoded;

   assign fetch_wg_wfid = f_decode_wfid;

   // The pc of the retired instruction is always the pc of the currently decoded instruction
   assign tracemon_barrier_retire_pc = f_decode_instr_pc;
      
   reg_40xX_1r_1w #(40 + 16) wg_info_reg
     ( 
       .rd_addr(fetch_wg_wgid),
       .rd_data({curr_wg_wf_waiting,curr_wg_wf_count}),
       .wr_en(decode_barrier_valid),
       .wr_addr(fetch_wg_wgid),
       .wr_data({next_curr_wg_wf_waiting,
		 next_curr_wg_wf_count}),

       .clk(clk),
       .rst(rst)
       );

   dff_en  waiting_wf_reg[40-1:0]
     (
      .q(barrier_wait_arry),
      .d(next_barrier_wait_arry),
      .en(decode_barrier_valid),
      .clk(clk),
      .rst(rst)
      );
   
   // Calculate next mask for wg
   always @ ( fetch_wg_wf_count ) begin
      case(fetch_wg_wf_count)
	4'd0  : wf_count_mask <= 16'b0000_0000_0000_0001;
	4'd1  : wf_count_mask <= 16'b1111_1111_1111_1111;
	4'd2  : wf_count_mask <= 16'b0111_1111_1111_1111;
	4'd3  : wf_count_mask <= 16'b0011_1111_1111_1111;
	4'd4  : wf_count_mask <= 16'b0001_1111_1111_1111;
	4'd5  : wf_count_mask <= 16'b0000_1111_1111_1111;
	4'd6  : wf_count_mask <= 16'b0000_0111_1111_1111;
	4'd7  : wf_count_mask <= 16'b0000_0011_1111_1111;
	4'd8  : wf_count_mask <= 16'b0000_0001_1111_1111;
	4'd9  : wf_count_mask <= 16'b0000_0000_1111_1111;
	4'd10 : wf_count_mask <= 16'b0000_0000_0111_1111;
	4'd11 : wf_count_mask <= 16'b0000_0000_0011_1111;
	4'd12 : wf_count_mask <= 16'b0000_0000_0001_1111;
	4'd13 : wf_count_mask <= 16'b0000_0000_0000_1111;
	4'd14 : wf_count_mask <= 16'b0000_0000_0000_0111;
	4'd15 : wf_count_mask <= 16'b0000_0000_0000_0011;
      endcase
   end
   
   decoder_6b_40b_en barrier_valid_decoder
     (
      .addr_in(f_decode_wfid),
      .en(decode_barrier_valid),
      .out(decode_barrier_valid_decoded)
      );

   assign decode_barrier_valid = f_decode_valid && f_decode_barrier;

   // Signal when all_wf hit the barrier and when the first
   // wf hit the barrier
   assign all_wf_hit_barrier 
     = ((curr_wg_wf_count == 16'h7fff) | (fetch_wg_wf_count == 4'd1) ) & 
       decode_barrier_valid ? 1'b1 : 1'b0;
   assign first_wf_barrier = (curr_wg_wf_count == 16'h0000)? 1'b1 : 1'b0;
   
   // Reset wf_count if all wf hit the barrier,
   // write the mask if it is the first wf
   // and shift if is another wf
   assign next_curr_wg_wf_count
     = (all_wf_hit_barrier)? 16'h0 :
       (first_wf_barrier)? wf_count_mask :
       {curr_wg_wf_count[16-2:0],1'b1};
   
   // Mark all wf of the curr wg waiting
   assign next_curr_wg_wf_waiting
     = (all_wf_hit_barrier)? 40'b0 :
       curr_wg_wf_waiting | decode_barrier_valid_decoded;

   assign tracemon_barrier_retire_wf_bitmap = curr_wg_wf_waiting | decode_barrier_valid_decoded;
   
   // Mark all wf waiting globally
   assign next_barrier_wait_arry
     = (all_wf_hit_barrier)? barrier_wait_arry & (~curr_wg_wf_waiting) :
       barrier_wait_arry | decode_barrier_valid_decoded;
   
   // Assign signals for tracemon
   assign tracemon_barrier_retire_en = all_wf_hit_barrier;
   
endmodule
module branch_wait
  (/*AUTOARG*/
   // Outputs
   pending_branches_arry,
   // Inputs
   clk, rst, alu_valid, alu_branch, alu_wfid, f_salu_branch_en,
   f_salu_branch_wfid
   );
   input clk, rst;

   // Issued alu info
   input alu_valid, alu_branch;   
   input [6-1:0] alu_wfid;

   // Salu signals with outcome of branch
   input 		    f_salu_branch_en;
   input [6-1:0] f_salu_branch_wfid;

   // Output - list of pending branches
   output [40-1:0]   pending_branches_arry;
   
   /**
    * Branch wait is a reg that marks all wf with a pending branch.
    * Pending branches start when a branch instruction is issued
    * and end when salu signals the outcome of the branch
    **/

   wire 		    alu_branch_valid;
   wire [40-1:0]     alu_branch_decoded, 
			    salu_branch_decoded;

   wire [40-1:0]     pending_branch, next_pending_branch;

   assign pending_branches_arry = pending_branch;
   
   // Decoder for the issued branch
   decoder_6b_40b_en alu_brach_decoder
     (
      .addr_in(alu_wfid),
      .out(alu_branch_decoded),
      .en(alu_branch_valid)
      );

   // Decoder for the finished branch by fetch
   decoder_6b_40b_en issue_Value_decoder
     (
      .addr_in(f_salu_branch_wfid),
      .out(salu_branch_decoded),
      .en(f_salu_branch_en)
      );

   dff pending_branch_ff[40-1:0]
     (
      .q(pending_branch),
      .d(next_pending_branch),
      .clk(clk),
      .rst(rst)
      );
   
   assign alu_branch_valid = alu_valid && alu_branch; 
   assign next_pending_branch 
     = (  pending_branch | (alu_branch_decoded)  ) &
       ~(salu_branch_decoded);
   
endmodule
module busy_gpr_table
  (/*AUTOARG*/
   // Outputs
   decode_dest_reg1_busy_bits, decode_source_reg1_busy_bits,
   decode_source_reg4_busy_bits, decode_source_reg2_busy_bits,
   decode_source_reg3_busy_bits, decode_dest_reg2_busy_bits,
   // Inputs
   clk, rst, alu_valid, lsu_valid, f_decode_source_reg2,
   f_decode_source_reg3, f_decode_dest_reg2, f_decode_dest_reg1,
   f_decode_source_reg1, f_decode_source_reg4, alu_dest_reg1,
   lsu_dest_reg, lsu_dest_reg_size, alu_dest_reg1_size, alu_dest_reg2,
   alu_dest_reg2_size, f_vgpr_alu_dest_reg_addr, f_vgpr_lsu_dest_reg_addr,
   f_vgpr_lsu_dest_reg_valid, f_vgpr_alu_dest_reg_valid,
   f_sgpr_valu_dest_addr, f_sgpr_alu_dest_reg_addr,
   f_sgpr_lsu_dest_reg_addr, f_sgpr_lsu_dest_reg_valid,
   f_sgpr_alu_dest_reg_valid, f_sgpr_valu_dest_reg_valid
   );
   

   /**
    * Busy bit is set when dst1 and dst2 are issued, cleared when 
    * register retires
    ***/
   input clk,rst;
   
   input alu_valid, lsu_valid;

   input [13-1:0] f_decode_source_reg2, f_decode_source_reg3, f_decode_dest_reg2;
   
   input [14-1:0] f_decode_dest_reg1, f_decode_source_reg1, f_decode_source_reg4;
   
   input [11:0] alu_dest_reg1, lsu_dest_reg;
   input [1:0] 	lsu_dest_reg_size;
   input 	alu_dest_reg1_size;
   
   wire [3:0] 	lsu_dest_reg_sgpr_valid, lsu_dest_reg_vgpr_valid;

   wire [1:0] 	alu_dest_reg1_sgpr_valid, alu_dest_reg1_vgpr_valid;
   
   input [11:0] alu_dest_reg2;
   input 	alu_dest_reg2_size;
   
   wire [1:0] 			    alu_dest_reg2_sgpr_valid;
   
   input [10-1:0]    f_vgpr_alu_dest_reg_addr, f_vgpr_lsu_dest_reg_addr;
   input [3:0] 			    f_vgpr_lsu_dest_reg_valid;
   input 			    f_vgpr_alu_dest_reg_valid;
   
   input [9-1:0]    f_sgpr_valu_dest_addr, f_sgpr_alu_dest_reg_addr, 
				     f_sgpr_lsu_dest_reg_addr;
   input [3:0] 			     f_sgpr_lsu_dest_reg_valid;
   input [1:0] 			     f_sgpr_alu_dest_reg_valid;
   input 			     f_sgpr_valu_dest_reg_valid;
   
   output [3:0] 		    decode_dest_reg1_busy_bits, decode_source_reg1_busy_bits, decode_source_reg4_busy_bits;
		    
   output [1:0] 		    decode_source_reg2_busy_bits, decode_source_reg3_busy_bits, decode_dest_reg2_busy_bits;

   wire [3:0] 			    decode_dest_reg1_mask, decode_source_reg1_mask, decode_source_reg4_mask;
   wire [1:0] 			    decode_source_reg2_mask, decode_source_reg3_mask, decode_dest_reg2_mask;
 			    
   wire [3:0] 		    decode_dest_reg1_busy_bits_vgpr, decode_source_reg1_busy_bits_vgpr, decode_dest_reg1_busy_bits_sgpr, decode_source_reg1_busy_bits_sgpr, decode_source_reg4_busy_bits_sgpr;
		    
   wire [1:0] 		    decode_source_reg2_busy_bits_vgpr, decode_source_reg3_busy_bits_vgpr, decode_source_reg2_busy_bits_sgpr, decode_source_reg3_busy_bits_sgpr, decode_dest_reg2_busy_bits_sgpr;

   wire [512-1:0] 	    sgpr_busy_bits, next_sgpr_busy_bits;
   
   wire [512-1:0] 	    alu_dest_reg1_sgpr_set_decoded, alu_dest_reg2_sgpr_set_decoded, lsu_dest_reg_sgpr_set_decoded;
   wire [512-1:0] 	    sgpr_alu_dest_clear_decoded, sgpr_lsu_dest_clear_decoded, sgpr_valu_dest_clear_decoded;

   wire [1024-1:0] 	    vgpr_busy_bits, next_vgpr_busy_bits;
  	    
   wire [1024-1:0] 	    alu_dest_reg1_vgpr_set_decoded, lsu_dest_reg_vgpr_set_decoded;
   
   wire [1024-1:0] 	    vgpr_alu_dest_clear_decoded, vgpr_lsu_dest_clear_decoded;
   // Decoder for the dsts value to set the busy table
   // 1024 - dest1 alu - 2, dest1 lsu - 4
   // 512 - dest1 alu - 1(2wide), dest1 lsu - 1(4wide), dest2 alu 1(2wide)
   vgpr_busy_table_decoder #(2) alu_dst1_vgpr_set_decoder
     (
      .vgpr_addr(alu_dest_reg1[10-1:0]),
      .vgpr_valid(alu_dest_reg1_vgpr_valid),
      .output_decoded(alu_dest_reg1_vgpr_set_decoded)
      );
   
   vgpr_busy_table_decoder #(4) lsu_dst1_set_decoder
     (
      .vgpr_addr(lsu_dest_reg[10-1:0]),
      .vgpr_valid(lsu_dest_reg_vgpr_valid),
      .output_decoded(lsu_dest_reg_vgpr_set_decoded)
      );

   sgpr_busy_table_decoder #(4) lsu_dst1_sgpr_set_decoder
     (
      .sgpr_addr(lsu_dest_reg[9-1:0]),
      .sgpr_valid(lsu_dest_reg_sgpr_valid),
      .output_decoded(lsu_dest_reg_sgpr_set_decoded)
      );

   sgpr_busy_table_decoder #(2) alu_dst1_sgpr_set_decoder
     (
      .sgpr_addr(alu_dest_reg1[9-1:0]),
      .sgpr_valid(alu_dest_reg1_sgpr_valid),
      .output_decoded(alu_dest_reg1_sgpr_set_decoded)
      );

   sgpr_busy_table_decoder #(2) alu_dst2_sgpr_set_decoder
     (
      .sgpr_addr(alu_dest_reg2[9-1:0]),
      .sgpr_valid(alu_dest_reg2_sgpr_valid),
      .output_decoded(alu_dest_reg2_sgpr_set_decoded)
      );

   
   // Decoders for the retired values to clear the busy table
   // 1024 - vgpr_alu - 2, vgpr_lsu - 4
   // 512 -sgpr_alu - 1(2 wide), sgpr_lsu 1(4wide)
   vgpr_busy_table_decoder #(2) vgpr_alu_dst_clear_decoder
     (
      .vgpr_addr(f_vgpr_alu_dest_reg_addr),
      .vgpr_valid({1'b0,f_vgpr_alu_dest_reg_valid}),
      .output_decoded(vgpr_alu_dest_clear_decoded)
      );

   vgpr_busy_table_decoder #(4) vgpr_lsu_dst_clear_decoder
     (
      .vgpr_addr(f_vgpr_lsu_dest_reg_addr),
      .vgpr_valid(f_vgpr_lsu_dest_reg_valid),
      .output_decoded(vgpr_lsu_dest_clear_decoded)
      );

   sgpr_busy_table_decoder #(2) sgpr_alu_dst_clear_decoder
     (
      .sgpr_addr(f_sgpr_alu_dest_reg_addr),
      .sgpr_valid(f_sgpr_alu_dest_reg_valid),
      .output_decoded(sgpr_alu_dest_clear_decoded)
      );

   sgpr_busy_table_decoder #(2) sgpr_valu_dst_clear_decoder
     (
      .sgpr_addr(f_sgpr_valu_dest_addr),
      .sgpr_valid({f_sgpr_valu_dest_reg_valid, f_sgpr_valu_dest_reg_valid}),
      .output_decoded(sgpr_valu_dest_clear_decoded)
      );

   sgpr_busy_table_decoder #(4) sgpr_lsu_dst_clear_decoder
     (
      .sgpr_addr(f_sgpr_lsu_dest_reg_addr),
      .sgpr_valid(f_sgpr_lsu_dest_reg_valid),
      .output_decoded(sgpr_lsu_dest_clear_decoded)
      );

   
   // Muxes for the read ports
   // 1024- 4 to dst1 and src1  2 to src2 and src3
   // 1(4wide) dst1 src1 and src4, 1(2wide) dest2, src2 and src3
   vgpr_busy_table_mux #(4) decode_dest_reg1_rd_port_vgpr
     (
      .in(vgpr_busy_bits),
      .select(f_decode_dest_reg1[10-1:0]),
      .out(decode_dest_reg1_busy_bits_vgpr)
      );

    vgpr_busy_table_mux #(4) decode_source_reg1_rd_port_vgpr
     (
      .in(vgpr_busy_bits),
      .select(f_decode_source_reg1[10-1:0]),
      .out(decode_source_reg1_busy_bits_vgpr)
      );
   vgpr_busy_table_mux #(2) decode_source_reg2_rd_port_vgpr
     (
      .in(vgpr_busy_bits),
      .select(f_decode_source_reg2[10-1:0]),
      .out(decode_source_reg2_busy_bits_vgpr)
      );
   vgpr_busy_table_mux #(2) decode_source_reg3_rd_port_vgpr
     (
      .in(vgpr_busy_bits),
      .select(f_decode_source_reg3[10-1:0]),
      .out(decode_source_reg3_busy_bits_vgpr)
      );

   

   sgpr_busy_table_mux #(4) decode_dest_reg1_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_dest_reg1[9-1:0]),
      .out(decode_dest_reg1_busy_bits_sgpr)
      );

   sgpr_busy_table_mux #(2) decode_dest_reg2_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_dest_reg2[9-1:0]),
      .out(decode_dest_reg2_busy_bits_sgpr)
      );

    sgpr_busy_table_mux #(4) decode_source_reg1_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_source_reg1[9-1:0]),
      .out(decode_source_reg1_busy_bits_sgpr)
      );
   sgpr_busy_table_mux #(2) decode_source_reg2_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_source_reg2[9-1:0]),
      .out(decode_source_reg2_busy_bits_sgpr)
      );
   sgpr_busy_table_mux #(2) decode_source_reg3_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_source_reg3[9-1:0]),
      .out(decode_source_reg3_busy_bits_sgpr)
      );
   sgpr_busy_table_mux #(4) decode_source_reg4_rd_port_sgpr
     (
      .in(sgpr_busy_bits),
      .select(f_decode_source_reg4[9-1:0]),
      .out(decode_source_reg4_busy_bits_sgpr)
      );

   
   // 1024 reg for vgpr
   dff vgpr_busy_bit_reg[1024-1:0]
     (
      .q(vgpr_busy_bits),
      .d(next_vgpr_busy_bits),
      .clk(clk),
      .rst(rst)
      );


   // 512 reg for sgpr
   dff sgpr_busy_bit_reg[512-1:0]
     (
      .q(sgpr_busy_bits),
      .d(next_sgpr_busy_bits),
      .clk(clk),
      .rst(rst)
      );
   // Generate next inputs for the busy bits tables
   assign next_vgpr_busy_bits 
     = vgpr_busy_bits & 
       (~vgpr_alu_dest_clear_decoded & ~vgpr_lsu_dest_clear_decoded) |
       (alu_dest_reg1_vgpr_set_decoded | lsu_dest_reg_vgpr_set_decoded);
   
   assign next_sgpr_busy_bits
     = sgpr_busy_bits & 
       (~sgpr_valu_dest_clear_decoded & ~sgpr_alu_dest_clear_decoded & ~sgpr_lsu_dest_clear_decoded) |
       (   lsu_dest_reg_sgpr_set_decoded | 
	   alu_dest_reg1_sgpr_set_decoded | alu_dest_reg2_sgpr_set_decoded   );
   
   // Generate the valid bits for write ports
   assign alu_dest_reg1_vgpr_valid 
     = alu_valid && (alu_dest_reg1[11:11-1] == 2'b10)?
       ( (alu_dest_reg1_size)? 2'b11 : 2'b01  ) :
       2'b00;

   assign lsu_dest_reg_vgpr_valid 
     = lsu_valid && (lsu_dest_reg[11:11-1] == 2'b10)?
       (  (lsu_dest_reg_size[1])? 4'b1111 :
	  (lsu_dest_reg_size[0])? 4'b0011 : 4'b0001  ) :
       4'b0000;

   assign alu_dest_reg1_sgpr_valid 
     = alu_valid && (alu_dest_reg1[11:11-2] == 3'b110)?
       (  (alu_dest_reg1_size)? 2'b11 : 2'b01  ) :
       2'b00;

   assign alu_dest_reg2_sgpr_valid 
     = alu_valid && (alu_dest_reg2[11:11-2] == 3'b110)?
       (  (alu_dest_reg2_size)? 2'b11 : 2'b01  ) :
       2'b00;

   assign lsu_dest_reg_sgpr_valid 
     = lsu_valid && (lsu_dest_reg[11:11-2] == 3'b110)?
       (  (lsu_dest_reg_size[1])? 4'b1111 :
	  (lsu_dest_reg_size[0])? 4'b0011 : 4'b0001  ) :
       4'b0000;

   

   
				 
   // Select only valid values for read ports
   assign decode_dest_reg1_mask = (f_decode_dest_reg1[11+2])? 4'b1111 :
				  (f_decode_dest_reg1[11+1])? 4'b0011 :
				  4'b0001;
   
   assign decode_source_reg1_mask = (f_decode_source_reg1[11+2])? 4'b1111 :
				    (f_decode_source_reg1[11+1])? 4'b0011 :
				    4'b0001;
   assign decode_source_reg4_mask = (f_decode_source_reg4[11+2])? 4'b1111 :
				    (f_decode_source_reg4[11+1])? 4'b0011 :
				    4'b0001;
   assign decode_source_reg2_mask = (f_decode_source_reg2[11+1])? 2'b11 :
				    2'b01;
   assign decode_source_reg3_mask = (f_decode_source_reg3[11+1])? 2'b11 :
				    2'b01;
   assign decode_dest_reg2_mask = (f_decode_dest_reg2[11+1])? 2'b11 :
				  2'b01;

   assign decode_dest_reg1_busy_bits
     = (f_decode_dest_reg1[11:11-1] == 2'b10)? decode_dest_reg1_busy_bits_vgpr & decode_dest_reg1_mask :
       (f_decode_dest_reg1[11:11-2] == 3'b110)? decode_dest_reg1_busy_bits_sgpr & decode_dest_reg1_mask :
       4'b0000;

   assign decode_dest_reg2_busy_bits
     = (f_decode_dest_reg2[11:11-2] == 3'b110)? decode_dest_reg2_busy_bits_sgpr & decode_dest_reg2_mask:
       2'b00;

   assign decode_source_reg1_busy_bits
     = (f_decode_source_reg1[11:11-1] == 2'b10)? decode_source_reg1_busy_bits_vgpr & decode_source_reg1_mask :
       (f_decode_source_reg1[11:11-2] == 3'b110)? decode_source_reg1_busy_bits_sgpr & decode_source_reg1_mask:
       4'b0000;

   assign decode_source_reg2_busy_bits
     = (f_decode_source_reg2[11:11-1] == 2'b10)? decode_source_reg2_busy_bits_vgpr & decode_source_reg2_mask:
       (f_decode_source_reg2[11:11-2] == 3'b110)? decode_source_reg2_busy_bits_sgpr & decode_source_reg2_mask:
       2'b00;

   assign decode_source_reg3_busy_bits
     = (f_decode_source_reg3[11:11-1] == 2'b10)? decode_source_reg3_busy_bits_vgpr & decode_source_reg3_mask:
       (f_decode_source_reg3[11:11-2] == 3'b110)? decode_source_reg3_busy_bits_sgpr & decode_source_reg3_mask:
       2'b00;

   assign decode_source_reg4_busy_bits
     = (f_decode_source_reg4[11:11-2] == 3'b110)? decode_source_reg4_busy_bits_sgpr & decode_source_reg4_mask:
       4'b0000;

   
endmodule
module circular_barrel_shift_9b(
    output_val,
    input_val,
    shift_amt
);

output[8:0] output_val;

input[8:0] input_val;
input[3:0] shift_amt;

wire[8:0] shift_1, shift_2, shift_4, shift_8, shift_16; 

assign shift_1  = shift_amt[0] ? (input_val >> 1 | input_val << 8) : input_val;
assign shift_2  = shift_amt[1] ? (shift_1 >> 2 | shift_1 << 7) : shift_1;
assign shift_4  = shift_amt[2] ? (shift_2 >> 4 | shift_2 << 5) : shift_2;
assign output_val = shift_amt[3] ? (shift_4 >>  8 | shift_4 << 1) : shift_4;

endmodule
module finished_wf
  (/*AUTOARG*/
   // Outputs
   fetchwave_wf_done_en, fetchwave_wf_done_wf_id,
   max_instr_inflight_array,
   // Inputs
   clk, rst, f_decode_wfid, f_sgpr_alu_wr_done_wfid,
   f_vgpr_alu_wr_done_wfid, alu_wfid, f_salu_branch_wfid, f_decode_valid,
   f_decode_wf_halt, f_vgpr_alu_wr_done, f_sgpr_alu_wr_done, alu_valid,
   f_salu_branch_en, mem_wait_arry
   );

   input clk,rst;
   input [6-1:0] f_decode_wfid, f_sgpr_alu_wr_done_wfid, 
			     f_vgpr_alu_wr_done_wfid, alu_wfid,
			     f_salu_branch_wfid;
   input 		     f_decode_valid, f_decode_wf_halt, f_vgpr_alu_wr_done, 
			     f_sgpr_alu_wr_done, alu_valid, f_salu_branch_en;
   input [40-1:0]    mem_wait_arry;   
   
   output 		     fetchwave_wf_done_en;
   output [6-1:0] fetchwave_wf_done_wf_id;
   output [40-1:0]    max_instr_inflight_array;

   wire 		      decode_wf_halt_valid;
   wire [40-1:0]      decoded_retired_sgpr, decoded_retired_vgpr,
			      decoded_retired_branch;
   wire [40-1:0]      decoded_decode_wf_halt, decoded_decode_valid, 
			      decoded_wf_done, decoded_no_inflight_instr;
   wire [40-1:0]      done_wf_array;
   wire [40-1:0]      halted_reg_out, halted_reg_in, halted_reg_wr_en;

   wire [40-1:0]      decoded_alu_valid;


   // Decoder for the retired instructions
   decoder_6b_40b_en decoder_retired_sgpr
     (
      .addr_in(f_sgpr_alu_wr_done_wfid),
      .out(decoded_retired_sgpr),
      .en(f_sgpr_alu_wr_done)
      );

   decoder_6b_40b_en decoder_retired_vgpr
     (
      .addr_in(f_vgpr_alu_wr_done_wfid),
      .out(decoded_retired_vgpr),
      .en(f_vgpr_alu_wr_done)
      );

   decoder_6b_40b_en decoder_retired_branch
     (
      .addr_in(f_salu_branch_wfid),
      .out(decoded_retired_branch),
      .en(f_salu_branch_en)
      );

   // Decoder for the issued instructions
   decoder_6b_40b_en decoder_issued_inst
     (
      .addr_in(alu_wfid),
      .out(decoded_alu_valid),
      .en(alu_valid)
      );


   // Decoder for the halt signal
   decoder_6b_40b_en decode_wf_halt_decoder
     (
      .addr_in(f_decode_wfid),
      .out(decoded_decode_wf_halt),
      .en(decode_wf_halt_valid)
      );

   decoder_6b_40b_en decode_wf_halt_decoder_valid
     (
      .addr_in(f_decode_wfid),
      .out(decoded_decode_valid),
      .en(f_decode_valid)
      );

   // Decoder for the done wf signal
   decoder_6b_40b_en decode_finished_wf
     (
      .addr_in(fetchwave_wf_done_wf_id),
      .out(decoded_wf_done),
      .en(fetchwave_wf_done_en)
      );
   // Register to record witch registers had a halt signals
   dff_en halted_reg[40-1:0]
     (
      .q(halted_reg_out),
      .d(halted_reg_in),
      .en(halted_reg_wr_en),
      .clk(clk),
      .rst(rst)
      );

   // Arbiter to chose witch finished wf signal will be issued
   arbiter finished_arbiter
     (
      .issued_en(fetchwave_wf_done_en),
      .issued_wf_id(fetchwave_wf_done_wf_id),
      .input_arry(done_wf_array),
      .choosen_valid(fetchwave_wf_done_en),
      .choosen_wf_id(fetchwave_wf_done_wf_id),
      .clk(clk),
      .rst(rst)
      );

   // Counter for the inflight instructions
   inflight_instr_counter inflight_instr_counters[40-1:0]
     (
      .clk(clk),
      .rst(rst),
      // Input from retired instructions
      .retire_vgpr_1_en(decoded_retired_vgpr),
      .retire_branch_en(decoded_retired_branch),
      .retire_sgpr_en(decoded_retired_sgpr),
      // Input from issued instructions
      .issued_en(decoded_alu_valid),
      // Output
      .no_inflight_instr_flag(decoded_no_inflight_instr),
      .max_inflight_instr_flag(max_instr_inflight_array)
      );

   assign decode_wf_halt_valid = f_decode_valid && f_decode_wf_halt;

   assign done_wf_array = halted_reg_out & decoded_no_inflight_instr & ~mem_wait_arry;
   assign halted_reg_in = decoded_decode_wf_halt | (~decoded_wf_done & halted_reg_out);
   assign halted_reg_wr_en = decoded_decode_valid | decoded_wf_done;

endmodule
module functional_unit_reg
  (/*AUTOARG*/
   // Outputs
   rd_fu_simd, rd_fu_salu, rd_fu_lsu, rd_fu_simf,
   // Inputs
   clk, rst, wr_fu_en, wr_fu_value
   );

   input clk,rst;

   input wr_fu_en;
   input [1:0] wr_fu_value;

   output      rd_fu_simd, rd_fu_salu, rd_fu_lsu, rd_fu_simf;

   reg [3:0]   decoded_wr_fu_value;

   // Decoder for fu value
   always @(wr_fu_value) begin
      decoded_wr_fu_value = 4'b0;

      case(wr_fu_value)
	2'b01 : decoded_wr_fu_value = 4'b0001;
	2'b10 : decoded_wr_fu_value = 4'b0010;
	2'b11  : decoded_wr_fu_value = 4'b0100;
	2'b00 : decoded_wr_fu_value = 4'b1000;
	default: decoded_wr_fu_value = 4'b0;
      endcase
   end

   dff_en reg_ff[3:0](.q({rd_fu_simf,rd_fu_lsu,rd_fu_salu,rd_fu_simd}), 
		      .d(decoded_wr_fu_value), .en(wr_fu_en), .clk(clk), .rst(rst) );

endmodule
module functional_unit_reg_bank
  (/*AUTOARG*/
   // Outputs
   fu_simd, fu_salu, fu_lsu, fu_simf,
   // Inputs
   clk, rst, f_decode_valid, f_decode_fu, f_decode_wfid
   );

   input clk,rst;
   input f_decode_valid;
   input [1:0] f_decode_fu;
   input [6-1:0] f_decode_wfid;

   output [40-1:0]   fu_simd,fu_salu,fu_lsu,fu_simf;

   wire [40-1:0]     decoded_init_wr_en;
   wire [40*2-1:0]   fu_regs_in;

   decoder_6b_40b_en decoder_6b_40b_en
     (
      .addr_in(f_decode_wfid),
      .out(decoded_init_wr_en),
      .en(f_decode_valid)
      );


   functional_unit_reg functional_unit_regs[40-1:0]
     (
      .wr_fu_en(decoded_init_wr_en),
      .wr_fu_value(fu_regs_in),
      .rd_fu_simd(fu_simd),
      .rd_fu_simf(fu_simf),
      .rd_fu_salu(fu_salu),
      .rd_fu_lsu(fu_lsu),
      .clk(clk),
      .rst(rst)
      );

   assign fu_regs_in = {40{f_decode_fu}};

endmodule
module gpr_dependency_table
  (/*AUTOARG*/
   // Outputs
   ready_arry_gpr,
   // Inputs
   clk, rst, vgpr_alu_set_data, vgpr_lsu_set_data, sgpr_alu_set_data,
   sgpr_lsu_set_data, sgpr_valu_set_data, decode_instr_data,
   f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid,
   f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid, f_decode_wfid,
   f_decode_valid
   );

/**********************************************************************
 * The dependency table works this way:                               *
 * Ready bits are set whenever a operand that was not ready retires   *
 * or a operand that does not depends on a inflight instruction       *
 * destination is decoded                                             *
 * Ready bits are cleared whenever a operand that reads or writes to    *
 * the destination of a inflight instruction is decoded.              *
 **********************************************************************/
   input clk, rst;
   
   input [(4+2+2+4+4+2)-1:0] vgpr_alu_set_data, vgpr_lsu_set_data, 
					 sgpr_alu_set_data, sgpr_lsu_set_data,
					 sgpr_valu_set_data, decode_instr_data;
   input [6-1:0]   f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid, 
			      f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid, 
			      f_decode_wfid;
   
   input 		      f_decode_valid;
   

   output [40-1:0]     ready_arry_gpr;
   wire [40*(4+2+2+4+4+2)-1:0] reg_out, reg_in;
   wire [40*(4+2+2+4+4+2)-1:0] 
						   vgpr_alu_set_demuxed, vgpr_lsu_set_demuxed,
						   sgpr_alu_set_demuxed, sgpr_lsu_set_demuxed,
						   sgpr_valu_set_demuxed,
						   decoded_instr_set_demuxed, decoded_instr_clear_demuxed,
						   issue_clear_demuxed;
   
   wire [40-1:0] 			 reg_wr_en;
   
   ready_bits_demux vgpr_alu_set_demux
     (
      .in(vgpr_alu_set_data),
      .addr(f_vgpr_alu_wr_done_wfid),
      .out(vgpr_alu_set_demuxed),
      .en(|vgpr_alu_set_data)
      );

   ready_bits_demux vgpr_lsu_set_demux
     (
      .in(vgpr_lsu_set_data),
      .addr(f_vgpr_lsu_wr_done_wfid),
      .out(vgpr_lsu_set_demuxed),
      .en(|vgpr_lsu_set_data)
      );

   ready_bits_demux sgpr_alu_set_demux
     (
      .in(sgpr_alu_set_data),
      .addr(f_sgpr_alu_wr_done_wfid),
      .out(sgpr_alu_set_demuxed),
      .en(|sgpr_alu_set_data)
      );

   ready_bits_demux sgpr_valu_set_demux
     (
      .in(sgpr_valu_set_data),
      .addr(f_vgpr_alu_wr_done_wfid),
      .out(sgpr_valu_set_demuxed),
      .en(|sgpr_valu_set_data)
      );
   
   ready_bits_demux sgpr_lsu_set_demux
     (
      .in(sgpr_lsu_set_data),
      .addr(f_sgpr_lsu_instr_done_wfid),
      .out(sgpr_lsu_set_demuxed),
      .en(|sgpr_lsu_set_data)
      );

   ready_bits_demux decode_instr_set_demux
     (
      .in(~decode_instr_data),
      .addr(f_decode_wfid),
      .out(decoded_instr_set_demuxed),
      .en(f_decode_valid)
      );

   ready_bits_demux decode_instr_clear_demux
     (
      .in(decode_instr_data),
      .addr(f_decode_wfid),
      .out(decoded_instr_clear_demuxed),
      .en(f_decode_valid)
      );
   
		
   assign reg_wr_en = {40{1'b1}};			  
   reg_param #((4+2+2+4+4+2)) data_bank[40-1:0] 
     ( 
       .out(reg_out), 
       .in(reg_in), 
       .wr_en(reg_wr_en),
       .clk(clk), 
       .rst(rst) );

// Generate the ready bits, that are ready only when all depoendency bits are set 
// %%start_veriperl
// my $i;
// for($i=0; $i<40; $i=$i+1)
// {
//   print "assign ready_arry_gpr[$i] = &reg_out[`ISSUE_GPR_RD_BITS_LENGTH*($i+1)-1:`ISSUE_GPR_RD_BITS_LENGTH*$i];\n";
// }
// %%stop_veriperl
assign ready_arry_gpr[0] = &reg_out[(4+2+2+4+4+2)*(0+1)-1:(4+2+2+4+4+2)*0];
assign ready_arry_gpr[1] = &reg_out[(4+2+2+4+4+2)*(1+1)-1:(4+2+2+4+4+2)*1];
assign ready_arry_gpr[2] = &reg_out[(4+2+2+4+4+2)*(2+1)-1:(4+2+2+4+4+2)*2];
assign ready_arry_gpr[3] = &reg_out[(4+2+2+4+4+2)*(3+1)-1:(4+2+2+4+4+2)*3];
assign ready_arry_gpr[4] = &reg_out[(4+2+2+4+4+2)*(4+1)-1:(4+2+2+4+4+2)*4];
assign ready_arry_gpr[5] = &reg_out[(4+2+2+4+4+2)*(5+1)-1:(4+2+2+4+4+2)*5];
assign ready_arry_gpr[6] = &reg_out[(4+2+2+4+4+2)*(6+1)-1:(4+2+2+4+4+2)*6];
assign ready_arry_gpr[7] = &reg_out[(4+2+2+4+4+2)*(7+1)-1:(4+2+2+4+4+2)*7];
assign ready_arry_gpr[8] = &reg_out[(4+2+2+4+4+2)*(8+1)-1:(4+2+2+4+4+2)*8];
assign ready_arry_gpr[9] = &reg_out[(4+2+2+4+4+2)*(9+1)-1:(4+2+2+4+4+2)*9];
assign ready_arry_gpr[10] = &reg_out[(4+2+2+4+4+2)*(10+1)-1:(4+2+2+4+4+2)*10];
assign ready_arry_gpr[11] = &reg_out[(4+2+2+4+4+2)*(11+1)-1:(4+2+2+4+4+2)*11];
assign ready_arry_gpr[12] = &reg_out[(4+2+2+4+4+2)*(12+1)-1:(4+2+2+4+4+2)*12];
assign ready_arry_gpr[13] = &reg_out[(4+2+2+4+4+2)*(13+1)-1:(4+2+2+4+4+2)*13];
assign ready_arry_gpr[14] = &reg_out[(4+2+2+4+4+2)*(14+1)-1:(4+2+2+4+4+2)*14];
assign ready_arry_gpr[15] = &reg_out[(4+2+2+4+4+2)*(15+1)-1:(4+2+2+4+4+2)*15];
assign ready_arry_gpr[16] = &reg_out[(4+2+2+4+4+2)*(16+1)-1:(4+2+2+4+4+2)*16];
assign ready_arry_gpr[17] = &reg_out[(4+2+2+4+4+2)*(17+1)-1:(4+2+2+4+4+2)*17];
assign ready_arry_gpr[18] = &reg_out[(4+2+2+4+4+2)*(18+1)-1:(4+2+2+4+4+2)*18];
assign ready_arry_gpr[19] = &reg_out[(4+2+2+4+4+2)*(19+1)-1:(4+2+2+4+4+2)*19];
assign ready_arry_gpr[20] = &reg_out[(4+2+2+4+4+2)*(20+1)-1:(4+2+2+4+4+2)*20];
assign ready_arry_gpr[21] = &reg_out[(4+2+2+4+4+2)*(21+1)-1:(4+2+2+4+4+2)*21];
assign ready_arry_gpr[22] = &reg_out[(4+2+2+4+4+2)*(22+1)-1:(4+2+2+4+4+2)*22];
assign ready_arry_gpr[23] = &reg_out[(4+2+2+4+4+2)*(23+1)-1:(4+2+2+4+4+2)*23];
assign ready_arry_gpr[24] = &reg_out[(4+2+2+4+4+2)*(24+1)-1:(4+2+2+4+4+2)*24];
assign ready_arry_gpr[25] = &reg_out[(4+2+2+4+4+2)*(25+1)-1:(4+2+2+4+4+2)*25];
assign ready_arry_gpr[26] = &reg_out[(4+2+2+4+4+2)*(26+1)-1:(4+2+2+4+4+2)*26];
assign ready_arry_gpr[27] = &reg_out[(4+2+2+4+4+2)*(27+1)-1:(4+2+2+4+4+2)*27];
assign ready_arry_gpr[28] = &reg_out[(4+2+2+4+4+2)*(28+1)-1:(4+2+2+4+4+2)*28];
assign ready_arry_gpr[29] = &reg_out[(4+2+2+4+4+2)*(29+1)-1:(4+2+2+4+4+2)*29];
assign ready_arry_gpr[30] = &reg_out[(4+2+2+4+4+2)*(30+1)-1:(4+2+2+4+4+2)*30];
assign ready_arry_gpr[31] = &reg_out[(4+2+2+4+4+2)*(31+1)-1:(4+2+2+4+4+2)*31];
assign ready_arry_gpr[32] = &reg_out[(4+2+2+4+4+2)*(32+1)-1:(4+2+2+4+4+2)*32];
assign ready_arry_gpr[33] = &reg_out[(4+2+2+4+4+2)*(33+1)-1:(4+2+2+4+4+2)*33];
assign ready_arry_gpr[34] = &reg_out[(4+2+2+4+4+2)*(34+1)-1:(4+2+2+4+4+2)*34];
assign ready_arry_gpr[35] = &reg_out[(4+2+2+4+4+2)*(35+1)-1:(4+2+2+4+4+2)*35];
assign ready_arry_gpr[36] = &reg_out[(4+2+2+4+4+2)*(36+1)-1:(4+2+2+4+4+2)*36];
assign ready_arry_gpr[37] = &reg_out[(4+2+2+4+4+2)*(37+1)-1:(4+2+2+4+4+2)*37];
assign ready_arry_gpr[38] = &reg_out[(4+2+2+4+4+2)*(38+1)-1:(4+2+2+4+4+2)*38];
assign ready_arry_gpr[39] = &reg_out[(4+2+2+4+4+2)*(39+1)-1:(4+2+2+4+4+2)*39];

// Generate updated dependencies, giving priority to sets over clears
assign reg_in = (   reg_out &
		    // Clear ready bits of all issued and non-ready decoded instructions 
		    ( ~decoded_instr_clear_demuxed   ) |
		    // Set ready bits of all retired and ready decoded instructions
		    ( vgpr_alu_set_demuxed | vgpr_lsu_set_demuxed | 
		    sgpr_alu_set_demuxed | sgpr_lsu_set_demuxed | 
		    sgpr_valu_set_demuxed | decoded_instr_set_demuxed) );

endmodule
module inflight_instr_counter
  (/*AUTOARG*/
   // Outputs
   no_inflight_instr_flag, max_inflight_instr_flag,
   // Inputs
   clk, rst, retire_vgpr_1_en, retire_branch_en, retire_sgpr_en,
   issued_en
   );

   // Inputs and outputs
   input clk,rst, retire_vgpr_1_en, 
	 retire_branch_en, retire_sgpr_en,
	 issued_en;


   output no_inflight_instr_flag, max_inflight_instr_flag;

   wire   wr_en;

   // For now, allow only 16 inflight instructions
   wire [3:0] inflight_instr_counter;

   // This will be used to calculate the total number of retired instructions
   wire [1:0] total_retired_instr;
   wire [2:0] total_counter_summed_value;

   // Next counter value   
   wire [3:0] counter_value;
   wire [3:0] next_counter_value;

   // Find the number of retired instructions
   adder1bit adder_retired 
     (
      total_retired_instr[0],
      total_retired_instr[1],
      retire_vgpr_1_en,
      retire_branch_en,
      retire_sgpr_en
      );

   // Calculates:
   // total_counter_summed_value =  (issued_en? 1 : 0) - total_retired_instr  
   adder_param #(3) adder_issued 
     (
      .in1({{2{1'b0}},issued_en}),
      .in2({1'b1,~total_retired_instr}),
      .cin(1'b1),
      .sum(total_counter_summed_value),
      .cout()
      );

   // Calculates the next counter value
   adder_param #(4) adder_next_counter 
     (
      .in1({total_counter_summed_value[2],total_counter_summed_value}),
      .in2(counter_value),
      .cin(1'b0),
      .sum(next_counter_value),
      .cout()
      );

   // Register for the counter value
   register #(4) counter_reg
     (
      .out(counter_value), 
      .in(next_counter_value), 
      .wr_en(wr_en), 
      .clk(clk), 
      .rst(rst)
      );

   // Finds out when to write the counter
   assign wr_en = retire_vgpr_1_en | retire_branch_en |retire_sgpr_en | issued_en;

   // Calculate the no_inflight_instr bit or the max_inflight_instr_bit
   assign no_inflight_instr_flag = ~(|counter_value);
   assign max_inflight_instr_flag = &counter_value;


endmodule



module instr_info_table
  (/*AUTOARG*/
   // Outputs
   vgpr_alu_rd_data, vgpr_lsu_rd_data, sgpr_alu_rd_data,
   sgpr_lsu_rd_data, issued_rd_data,
   // Inputs
   f_decode_valid, clk, rst, f_decode_wfid, decode_wr_data,
   f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid,
   f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid, issued_wfid
   );

   input f_decode_valid;
   input clk, rst;
   
   input [6-1:0] f_decode_wfid;
   input [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] decode_wr_data;

   input [6-1:0] 	       f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid, 
				       f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid, 
				       issued_wfid;
   output [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] vgpr_alu_rd_data, vgpr_lsu_rd_data, 
					sgpr_alu_rd_data, sgpr_lsu_rd_data, 
					issued_rd_data;

   wire [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] vgpr_alu_rd_data_tbl, vgpr_lsu_rd_data_tbl, 
					 sgpr_alu_rd_data_tbl, sgpr_lsu_rd_data_tbl;

   wire [40-1:0] 		reg_wr_en;
   wire [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)*40-1:0] reg_in, reg_out;

   assign vgpr_alu_rd_data = (f_decode_valid && f_decode_wfid == f_vgpr_alu_wr_done_wfid)?
			     decode_wr_data : vgpr_alu_rd_data_tbl;

   assign vgpr_lsu_rd_data = (f_decode_valid && f_decode_wfid == f_vgpr_lsu_wr_done_wfid)?
			     decode_wr_data : vgpr_lsu_rd_data_tbl;

   assign sgpr_alu_rd_data = (f_decode_valid && f_decode_wfid == f_sgpr_alu_wr_done_wfid)?
			     decode_wr_data : sgpr_alu_rd_data_tbl;

   assign sgpr_lsu_rd_data = (f_decode_valid && f_decode_wfid == f_sgpr_lsu_instr_done_wfid)?
			     decode_wr_data : sgpr_lsu_rd_data_tbl;
   
   
   // Decoder for the write port. Does not enable any port if wr_en is 0
   decoder_6b_40b_en wr_port_decoder
     (.out(reg_wr_en), .addr_in(f_decode_wfid), .en(f_decode_valid) );

   // Muxes for the read ports
   mux_40xPARAMb_to_1xPARAMb #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) mux_rd0 
     (.out(vgpr_alu_rd_data_tbl), .in(reg_out), .select(f_vgpr_alu_wr_done_wfid));
   mux_40xPARAMb_to_1xPARAMb #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) mux_rd1 
     (.out(vgpr_lsu_rd_data_tbl), .in(reg_out), .select(f_vgpr_lsu_wr_done_wfid));
   mux_40xPARAMb_to_1xPARAMb #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) mux_rd2 
     (.out(sgpr_alu_rd_data_tbl), .in(reg_out), .select(f_sgpr_alu_wr_done_wfid));
   mux_40xPARAMb_to_1xPARAMb #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) mux_rd3 
     (.out(sgpr_lsu_rd_data_tbl), .in(reg_out), .select(f_sgpr_lsu_instr_done_wfid));
   mux_40xPARAMb_to_1xPARAMb #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) mux_rd5 
     (.out(issued_rd_data), .in(reg_out), .select(issued_wfid));

   // Bank of registerss
   reg_param #((16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)) data_bank[40-1:0] 
					  ( .out(reg_out), 
					    .in(reg_in), 
					    .wr_en(reg_wr_en),                               
					    .clk(clk), 
					    .rst(rst) );
   
   assign reg_in = {40{decode_wr_data}};

endmodule
module instruction_arbiter
  (/*AUTOARG*/
   // Outputs
   simd0_alu_select, simd1_alu_select, simd2_alu_select,
   simd3_alu_select, simf0_alu_select, simf1_alu_select,
   simf2_alu_select, simf3_alu_select, lsu_lsu_select,
   salu_alu_select, lsu_wfid, alu_wfid, issued_wfid, alu_valid,
   lsu_valid, issued_valid,
   // Inputs
   clk, rst, salu_ready_to_issue, simd_ready_to_issue,
   simf_ready_to_issue, lsu_ready_to_issue, simd0_alu_ready,
   simd1_alu_ready, simd2_alu_ready, simd3_alu_ready, simf0_alu_ready,
   simf1_alu_ready, simf2_alu_ready, simf3_alu_ready, salu_alu_ready,
   lsu_ready
   );
   input clk, rst;
   
   input [40-1:0] salu_ready_to_issue, simd_ready_to_issue,
			  simf_ready_to_issue, lsu_ready_to_issue;
   input 		  simd0_alu_ready, simd1_alu_ready, 
			  simd2_alu_ready, simd3_alu_ready, 
			  simf0_alu_ready, simf1_alu_ready, 
			  simf2_alu_ready, simf3_alu_ready, 
			  salu_alu_ready, lsu_ready;
   
   output 		  simd0_alu_select, simd1_alu_select, 
			  simd2_alu_select, simd3_alu_select, 
			  simf0_alu_select, simf1_alu_select, 
			  simf2_alu_select, simf3_alu_select, 
			  lsu_lsu_select, salu_alu_select;
   output [6-1:0] lsu_wfid, alu_wfid, issued_wfid;
   output 		      alu_valid, lsu_valid, issued_valid;

   wire [40-1:0]      c_issued_arry, issued_arry, inegible_wf_arry;
   
   wire [40-1:0]      f_salu_ready_to_issue, f_simd_ready_to_issue,
			      f_simf_ready_to_issue, f_lsu_ready_to_issue;
   
   wire 		      f_simd0_alu_ready, f_simd1_alu_ready, 
			      f_simd2_alu_ready, f_simd3_alu_ready, 
			      f_simf0_alu_ready, f_simf1_alu_ready, 
			      f_simf2_alu_ready, f_simf3_alu_ready, 
			      f_salu_alu_ready, f_lsu_ready;

   wire 		      c_simd0_alu_select, c_simd1_alu_select, 
			      c_simd2_alu_select, c_simd3_alu_select, 
			      c_simf0_alu_select, c_simf1_alu_select, 
			      c_simf2_alu_select, c_simf3_alu_select, 
			      c_lsu_lsu_select, c_salu_alu_select;
   wire 		      c_issued_valid;


   wire [6-1:0]   c_issued_wfid;   

   decoder_6b_40b_en c_issued_decoder
     (.addr_in(c_issued_wfid),
      .en(c_issued_valid),
      .out(c_issued_arry)
      );

   decoder_6b_40b_en issued_decoder
     (.addr_in(issued_wfid),
      .en(issued_valid),
      .out(issued_arry)
      );

   // Hack: make sure the wf that are being chosen right now and the one
   // that was chosen last cycle are not issued.
   assign inegible_wf_arry = c_issued_arry | issued_arry;
   
   
   dff input_flops[(40*4 + 10)-1:0]
     (.d({salu_ready_to_issue & ~inegible_wf_arry, simd_ready_to_issue & ~inegible_wf_arry,
	  simf_ready_to_issue & ~inegible_wf_arry, lsu_ready_to_issue & ~inegible_wf_arry,
	  simd0_alu_ready & ~simd0_alu_select & ~c_simd0_alu_select, 
	  simd1_alu_ready & ~simd1_alu_select & ~c_simd1_alu_select , 
	  simd2_alu_ready & ~simd2_alu_select & ~c_simd2_alu_select, 
	  simd3_alu_ready & ~simd3_alu_select & ~c_simd3_alu_select, 
	  simf0_alu_ready & ~simf0_alu_select & ~c_simf0_alu_select, 
	  simf1_alu_ready & ~simf1_alu_select & ~c_simf1_alu_select, 
	  simf2_alu_ready & ~simf2_alu_select & ~c_simf2_alu_select, 
	  simf3_alu_ready & ~simf3_alu_select & ~c_simf3_alu_select, 
	  salu_alu_ready & ~salu_alu_select & ~c_salu_alu_select, 
	  lsu_ready & ~lsu_lsu_select & ~c_lsu_lsu_select}),
      .q({f_salu_ready_to_issue, f_simd_ready_to_issue,
	  f_simf_ready_to_issue, f_lsu_ready_to_issue,
	  f_simd0_alu_ready, f_simd1_alu_ready, 
	  f_simd2_alu_ready, f_simd3_alu_ready, 
	  f_simf0_alu_ready, f_simf1_alu_ready, 
	  f_simf2_alu_ready, f_simf3_alu_ready, 
	  f_salu_alu_ready, f_lsu_ready}),
      .clk(clk),
      .rst(rst));

   dff output_flops[(6*1 + 11)-1:0]
     (.d({c_simd0_alu_select, c_simd1_alu_select, 
	  c_simd2_alu_select, c_simd3_alu_select, 
	  c_simf0_alu_select, c_simf1_alu_select, 
	  c_simf2_alu_select, c_simf3_alu_select, 
	  c_lsu_lsu_select, c_salu_alu_select,
	  c_issued_wfid,
	  c_issued_valid}),
      .q({simd0_alu_select, simd1_alu_select, 
	  simd2_alu_select, simd3_alu_select, 
	  simf0_alu_select, simf1_alu_select, 
	  simf2_alu_select, simf3_alu_select, 
	  lsu_lsu_select, salu_alu_select,
	  issued_wfid,
	  issued_valid}),
      .clk(clk),
      .rst(rst));

   wire 		      lsu_wf_valid, salu_wf_valid, simd_wf_valid, simf_wf_valid;
   wire [6-1:0]   lsu_wf_chosen, salu_wf_choosen, simd_wf_choosen, simf_wf_choosen;
   
   arbiter lsu_arbiter
     (
      .clk(clk),
      .rst(rst),
      
      .input_arry(f_lsu_ready_to_issue),
      
      .issued_en(c_issued_valid),
      .issued_wf_id(c_issued_wfid),
      
      .choosen_valid(lsu_wf_valid),
      .choosen_wf_id(lsu_wf_chosen)
      );

   arbiter salu_arbiter
     (
      .clk(clk),
      .rst(rst),
      .input_arry(f_salu_ready_to_issue),
      .issued_en(c_issued_valid),
      .issued_wf_id(c_issued_wfid),
      
      .choosen_valid(salu_wf_valid),
      .choosen_wf_id(salu_wf_choosen)
      );
   
   arbiter simd_arbiter
     (
      .clk(clk),
      .rst(rst),
      
      .input_arry(f_simd_ready_to_issue),
      
      .issued_en(c_issued_valid),
      .issued_wf_id(c_issued_wfid),
      
      .choosen_valid(simd_wf_valid),
      .choosen_wf_id(simd_wf_choosen)
      );

   arbiter simf_arbiter
     (
      .clk(clk),
      .rst(rst),
      
      .input_arry(f_simf_ready_to_issue),
      
      .issued_en(c_issued_valid),
      .issued_wf_id(c_issued_wfid),
      
      .choosen_valid(simf_wf_valid),
      .choosen_wf_id(simf_wf_choosen)
      );
   
   alu_issue_logic alu_issue_logic
     (/*AUTOINST*/
      // Outputs
      .c_issued_valid			(c_issued_valid),
      .c_simd0_alu_select		(c_simd0_alu_select),
      .c_simd1_alu_select		(c_simd1_alu_select),
      .c_simd2_alu_select		(c_simd2_alu_select),
      .c_simd3_alu_select		(c_simd3_alu_select),
      .c_simf0_alu_select		(c_simf0_alu_select),
      .c_simf1_alu_select		(c_simf1_alu_select),
      .c_simf2_alu_select		(c_simf2_alu_select),
      .c_simf3_alu_select		(c_simf3_alu_select),
      .c_lsu_lsu_select			(c_lsu_lsu_select),
      .c_salu_alu_select		(c_salu_alu_select),
      .c_issued_wfid			(c_issued_wfid[6-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_lsu_ready			(f_lsu_ready),
      .f_salu_alu_ready			(f_salu_alu_ready),
      .f_simf3_alu_ready		(f_simf3_alu_ready),
      .f_simf2_alu_ready		(f_simf2_alu_ready),
      .f_simf1_alu_ready		(f_simf1_alu_ready),
      .f_simf0_alu_ready		(f_simf0_alu_ready),
      .f_simd3_alu_ready		(f_simd3_alu_ready),
      .f_simd2_alu_ready		(f_simd2_alu_ready),
      .f_simd1_alu_ready		(f_simd1_alu_ready),
      .f_simd0_alu_ready		(f_simd0_alu_ready),
      .lsu_wf_valid			(lsu_wf_valid),
      .simd_wf_valid			(simd_wf_valid),
      .simf_wf_valid			(simf_wf_valid),
      .salu_wf_valid			(salu_wf_valid),
      .lsu_wf_chosen			(lsu_wf_chosen[6-1:0]),
      .simd_wf_choosen			(simd_wf_choosen[6-1:0]),
      .simf_wf_choosen			(simf_wf_choosen[6-1:0]),
      .salu_wf_choosen			(salu_wf_choosen[6-1:0]));

   assign alu_wfid = issued_wfid;
   assign lsu_wfid = issued_wfid;
   assign alu_valid = simd0_alu_select | simd1_alu_select | simd2_alu_select | 
			simd3_alu_select | simf0_alu_select | simf1_alu_select | 
			simf2_alu_select | simf3_alu_select | salu_alu_select;
   
   assign lsu_valid = lsu_lsu_select;
   
endmodule
module issue
(/*AUTOARG*/
    // Outputs
    salu_alu_select, simd0_alu_select, simd1_alu_select,
    simd2_alu_select, simd3_alu_select, simf0_alu_select,
    simf1_alu_select, simf2_alu_select, simf3_alu_select,
    lsu_lsu_select, fetchwave_wf_done_en, tracemon_barrier_retire_en,
    tracemon_waitcnt_retire_en, lsu_wfid, alu_wfid,
    fetchwave_wf_done_wf_id, fetch_wg_wfid,
    tracemon_waitcnt_retire_wfid, lsu_source_reg1, lsu_source_reg2,
    lsu_source_reg3, lsu_dest_reg, lsu_mem_sgpr, alu_source_reg1,
    alu_source_reg2, alu_source_reg3, alu_dest_reg1, alu_dest_reg2,
    lsu_imm_value0, alu_imm_value0, lsu_lds_base, lsu_imm_value1,
    lsu_opcode, alu_imm_value1, alu_opcode, alu_instr_pc, lsu_instr_pc,
    tracemon_waitcnt_retire_pc, tracemon_barrier_retire_pc,
    wave_valid_entries, tracemon_barrier_retire_wf_bitmap,
    // Inputs
    clk, rst, decode_branch, decode_barrier, decode_vcc_wr,
    decode_vcc_rd, decode_scc_wr, decode_scc_rd, decode_exec_rd,
    decode_exec_wr, decode_m0_rd, decode_m0_wr, decode_wf_halt,
    decode_valid, decode_waitcnt, vgpr_alu_wr_done,
    vgpr_alu_dest_reg_valid, vgpr_lsu_wr_done, sgpr_alu_wr_done,
    sgpr_lsu_instr_done, sgpr_valu_dest_reg_valid, simd0_alu_ready,
    simd1_alu_ready, simd2_alu_ready, simd3_alu_ready, simf0_alu_ready,
    simf1_alu_ready, simf2_alu_ready, simf3_alu_ready, salu_alu_ready,
    lsu_ready, exec_salu_wr_vcc_en, exec_salu_wr_exec_en,
    exec_salu_wr_scc_en, exec_salu_wr_m0_en, exec_valu_wr_vcc_en,
    salu_branch_en, salu_branch_taken, decode_fu,
    sgpr_alu_dest_reg_valid, vgpr_lsu_dest_reg_valid,
    sgpr_lsu_dest_reg_valid, fetch_wg_wf_count, decode_wfid,
    vgpr_alu_wr_done_wfid, vgpr_lsu_wr_done_wfid,
    sgpr_alu_wr_done_wfid, sgpr_lsu_instr_done_wfid, exec_salu_wr_wfid,
    exec_valu_wr_vcc_wfid, fetch_wg_wgid, salu_branch_wfid,
    sgpr_alu_dest_reg_addr, sgpr_lsu_dest_reg_addr,
    sgpr_valu_dest_addr, vgpr_alu_dest_reg_addr,
    vgpr_lsu_dest_reg_addr, decode_source_reg2, decode_source_reg3,
    lsu_done, lsu_done_wfid,
    decode_dest_reg2, decode_source_reg1, decode_source_reg4,
    decode_dest_reg1, decode_imm_value0, decode_lds_base,
    decode_instr_pc, decode_opcode, decode_imm_value1
);

input clk;

input rst;

input   decode_branch, decode_barrier, decode_vcc_wr, decode_vcc_rd, decode_scc_wr,
        decode_scc_rd, decode_exec_rd, decode_exec_wr, decode_m0_rd, decode_m0_wr,
        decode_wf_halt, decode_valid, decode_waitcnt, 
        vgpr_alu_wr_done, vgpr_alu_dest_reg_valid,
        vgpr_lsu_wr_done, sgpr_alu_wr_done, sgpr_lsu_instr_done, sgpr_valu_dest_reg_valid,
        simd0_alu_ready, simd1_alu_ready, simd2_alu_ready, simd3_alu_ready, 
        simf0_alu_ready, simf1_alu_ready, simf2_alu_ready, simf3_alu_ready, 
        salu_alu_ready, lsu_ready,
        exec_salu_wr_vcc_en, exec_salu_wr_exec_en, exec_salu_wr_scc_en, exec_salu_wr_m0_en,
        exec_valu_wr_vcc_en, salu_branch_en, salu_branch_taken,
        lsu_done;
input [1:0] decode_fu, sgpr_alu_dest_reg_valid;
input [3:0] vgpr_lsu_dest_reg_valid, sgpr_lsu_dest_reg_valid, fetch_wg_wf_count;
input [5:0] decode_wfid, vgpr_alu_wr_done_wfid, vgpr_lsu_wr_done_wfid,
            sgpr_alu_wr_done_wfid, sgpr_lsu_instr_done_wfid, exec_salu_wr_wfid,
            exec_valu_wr_vcc_wfid, fetch_wg_wgid, salu_branch_wfid,
            lsu_done_wfid;
input [8:0] sgpr_alu_dest_reg_addr, sgpr_lsu_dest_reg_addr, sgpr_valu_dest_addr;
input [9:0] vgpr_alu_dest_reg_addr, vgpr_lsu_dest_reg_addr;
input [12:0] decode_source_reg2, decode_source_reg3, decode_dest_reg2;
input [13:0] decode_source_reg1, decode_source_reg4, decode_dest_reg1;
input [15:0] decode_imm_value0, decode_lds_base;
input [31:0] decode_instr_pc, decode_opcode, decode_imm_value1;

output 	salu_alu_select, simd0_alu_select, simd1_alu_select, simd2_alu_select,
simd3_alu_select, simf0_alu_select, simf1_alu_select, simf2_alu_select,
simf3_alu_select, lsu_lsu_select, fetchwave_wf_done_en, tracemon_barrier_retire_en,
tracemon_waitcnt_retire_en;
output [5:0] lsu_wfid, alu_wfid, fetchwave_wf_done_wf_id, fetch_wg_wfid,
tracemon_waitcnt_retire_wfid;
output [11:0] lsu_source_reg1, lsu_source_reg2, lsu_source_reg3, lsu_dest_reg,
lsu_mem_sgpr, alu_source_reg1, alu_source_reg2, alu_source_reg3, alu_dest_reg1,
alu_dest_reg2;
output [15:0] lsu_imm_value0, alu_imm_value0, lsu_lds_base;
output [31:0] lsu_imm_value1, lsu_opcode, alu_imm_value1, alu_opcode,
alu_instr_pc, lsu_instr_pc, tracemon_waitcnt_retire_pc, tracemon_barrier_retire_pc;
output [39:0] wave_valid_entries;

output [39:0] tracemon_barrier_retire_wf_bitmap;

   // Flopped inputs
   wire 	 f_decode_branch, f_decode_barrier, f_decode_vcc_wr, 
		 f_decode_vcc_rd, f_decode_scc_wr, f_decode_scc_rd, 
		 f_decode_exec_rd, f_decode_exec_wr, f_decode_m0_rd, 
		 f_decode_m0_wr, f_decode_wf_halt, f_decode_valid, 
		 f_decode_waitcnt, f_vgpr_alu_wr_done, f_vgpr_alu_dest_reg_valid,
		 f_vgpr_lsu_wr_done, f_sgpr_alu_wr_done, f_sgpr_lsu_instr_done, 
		 f_sgpr_valu_dest_reg_valid,
		 f_exec_salu_wr_vcc_en, f_exec_salu_wr_exec_en, 
		 f_exec_salu_wr_scc_en, f_exec_salu_wr_m0_en,
		 f_exec_valu_wr_vcc_en, f_salu_branch_en, f_salu_branch_taken; //26
   
   wire [1:0] 	 f_decode_fu, f_sgpr_alu_dest_reg_valid; //2
   wire [3:0] 	 f_vgpr_lsu_dest_reg_valid, f_sgpr_lsu_dest_reg_valid; //2
   wire [5:0] 	 f_decode_wfid, f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid,
		 f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid, 
		 f_exec_salu_wr_wfid, f_exec_valu_wr_vcc_wfid, f_salu_branch_wfid; //8
   wire [8:0] 	 f_sgpr_alu_dest_reg_addr, f_sgpr_lsu_dest_reg_addr, 
		 f_sgpr_valu_dest_addr; //3

   wire [9:0] 	 f_vgpr_alu_dest_reg_addr, f_vgpr_lsu_dest_reg_addr; // 2
   wire [12:0] 	 f_decode_source_reg2, f_decode_source_reg3, f_decode_dest_reg2; //3
   wire [13:0] 	 f_decode_source_reg1, f_decode_source_reg4, f_decode_dest_reg1; //3
   wire [15:0] 	 f_decode_imm_value0, f_decode_lds_base; //2
   wire [31:0] 	 f_decode_instr_pc, f_decode_opcode, f_decode_imm_value1; //3

   
   // Other signals
   wire 	 alu_valid, lsu_valid;
   wire 	 issued_valid;
   wire [6-1:0] issued_wfid;
 
   wire [6-1:0] alu_wfid, lsu_wfid;
   wire [40-1:0]    ready_array_data_dependencies;
   wire [40-1:0]    fu_lsu, fu_salu, fu_simd, fu_simf;
   wire [40-1:0]    lsu_ready_to_issue, salu_ready_to_issue, 
			    simd_ready_to_issue, simf_ready_to_issue;
   
   wire [40-1:0]    mem_wait_arry, pending_branches_arry, 
			    barrier_wait_arry, max_instr_inflight_array;
   wire [40-1:0]    valid_entry_out;
   wire 		    alu_branch;

   dff input_flops[26 + 2*2 + 4*2 + 6*8 + 9*3 + 10*2 + 13*3 + 14*3 + 16*2 + 32*3 - 1 : 0]
     (
      .d({decode_barrier, decode_branch, decode_dest_reg1, decode_dest_reg2, 
	  decode_exec_rd, decode_exec_wr, decode_fu, decode_imm_value0, 
	  decode_imm_value1, decode_instr_pc, decode_lds_base, decode_m0_rd, 
	  decode_m0_wr, decode_opcode, decode_scc_rd, decode_scc_wr, 
	  decode_source_reg1, decode_source_reg2, decode_source_reg3, 
	  decode_source_reg4, decode_valid, decode_vcc_rd, decode_vcc_wr, 
	  decode_waitcnt, decode_wf_halt, decode_wfid, exec_salu_wr_exec_en, 
	  exec_salu_wr_m0_en, exec_salu_wr_scc_en, exec_salu_wr_vcc_en, 
	  exec_salu_wr_wfid, exec_valu_wr_vcc_en, exec_valu_wr_vcc_wfid, 
	  salu_branch_en, salu_branch_taken, salu_branch_wfid, 
	  sgpr_alu_dest_reg_addr, sgpr_alu_dest_reg_valid, sgpr_alu_wr_done, 
	  sgpr_alu_wr_done_wfid, sgpr_lsu_dest_reg_addr, sgpr_lsu_dest_reg_valid, 
	  sgpr_lsu_instr_done, sgpr_lsu_instr_done_wfid, sgpr_valu_dest_addr, 
	  sgpr_valu_dest_reg_valid, vgpr_alu_dest_reg_addr, vgpr_alu_dest_reg_valid, 
	  vgpr_alu_wr_done, vgpr_alu_wr_done_wfid, vgpr_lsu_dest_reg_addr, 
	  vgpr_lsu_dest_reg_valid, vgpr_lsu_wr_done, vgpr_lsu_wr_done_wfid}
	 ),
      .q({f_decode_barrier, f_decode_branch, f_decode_dest_reg1, 
	  f_decode_dest_reg2, f_decode_exec_rd, f_decode_exec_wr, 
	  f_decode_fu, f_decode_imm_value0, f_decode_imm_value1, 
	  f_decode_instr_pc, f_decode_lds_base, f_decode_m0_rd, 
	  f_decode_m0_wr, f_decode_opcode, f_decode_scc_rd, f_decode_scc_wr, 
	  f_decode_source_reg1, f_decode_source_reg2, f_decode_source_reg3, 
	  f_decode_source_reg4, f_decode_valid, f_decode_vcc_rd, f_decode_vcc_wr, 
	  f_decode_waitcnt, f_decode_wf_halt, f_decode_wfid, f_exec_salu_wr_exec_en,
	  f_exec_salu_wr_m0_en, f_exec_salu_wr_scc_en, f_exec_salu_wr_vcc_en, 
	  f_exec_salu_wr_wfid, f_exec_valu_wr_vcc_en, f_exec_valu_wr_vcc_wfid, 
	  f_salu_branch_en, f_salu_branch_taken, f_salu_branch_wfid, 
	  f_sgpr_alu_dest_reg_addr, f_sgpr_alu_dest_reg_valid, f_sgpr_alu_wr_done, 
	  f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_dest_reg_addr, 
	  f_sgpr_lsu_dest_reg_valid, f_sgpr_lsu_instr_done, 
	  f_sgpr_lsu_instr_done_wfid, f_sgpr_valu_dest_addr, 
	  f_sgpr_valu_dest_reg_valid, f_vgpr_alu_dest_reg_addr, 
	  f_vgpr_alu_dest_reg_valid, f_vgpr_alu_wr_done, f_vgpr_alu_wr_done_wfid, 
	  f_vgpr_lsu_dest_reg_addr, f_vgpr_lsu_dest_reg_valid, f_vgpr_lsu_wr_done, 
	  f_vgpr_lsu_wr_done_wfid}
	 ),
      .clk(clk),
      .rst(rst));
   
   // Assign wait cnt values
   assign tracemon_waitcnt_retire_en = f_decode_valid & f_decode_waitcnt;
   assign tracemon_waitcnt_retire_wfid = f_decode_wfid;
   assign tracemon_waitcnt_retire_pc = f_decode_instr_pc;
   

   valid_entry valid_entry
     (/*AUTOINST*/
      // Outputs
      .valid_entry_out			(valid_entry_out[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_decode_valid			(f_decode_valid),
      .f_decode_wf_halt			(f_decode_wf_halt),
      .f_decode_barrier			(f_decode_barrier),
      .f_salu_branch_en			(f_salu_branch_en),
      .f_salu_branch_taken		(f_salu_branch_taken),
      .issued_valid			(issued_valid),
      .f_decode_waitcnt			(f_decode_waitcnt),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .issued_wfid			(issued_wfid[6-1:0]),
      .f_salu_branch_wfid		(f_salu_branch_wfid[6-1:0]));


   functional_unit_reg_bank fu_table
     (/*AUTOINST*/
      // Outputs
      .fu_simd				(fu_simd[40-1:0]),
      .fu_salu				(fu_salu[40-1:0]),
      .fu_lsu				(fu_lsu[40-1:0]),
      .fu_simf				(fu_simf[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_decode_valid			(f_decode_valid),
      .f_decode_fu			(f_decode_fu[1:0]),
      .f_decode_wfid			(f_decode_wfid[6-1:0]));

   issue_flow_control issue_flow_control
     (/*AUTOINST*/
      // Outputs
      .wave_valid_entries		(wave_valid_entries[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .tracemon_barrier_retire_en	(tracemon_barrier_retire_en),
      .valid_entry_out			(valid_entry_out[40-1:0]),
      .tracemon_barrier_retire_wf_bitmap(tracemon_barrier_retire_wf_bitmap[40-1:0]),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_salu_branch_wfid		(f_salu_branch_wfid[6-1:0]),
      .alu_wfid				(alu_wfid[6-1:0]),
      .f_decode_valid			(f_decode_valid),
      .f_decode_waitcnt			(f_decode_waitcnt),
      .f_salu_branch_en			(f_salu_branch_en),
      .alu_valid			(alu_valid),
      .alu_branch			(alu_branch));
   
   scoreboard scoreboard
     (/*AUTOINST*/
      // Outputs
      .lsu_source_reg1			(lsu_source_reg1[11:0]),
      .lsu_source_reg2			(lsu_source_reg2[11:0]),
      .lsu_source_reg3			(lsu_source_reg3[11:0]),
      .lsu_dest_reg			(lsu_dest_reg[11:0]),
      .lsu_mem_sgpr			(lsu_mem_sgpr[11:0]),
      .alu_source_reg1			(alu_source_reg1[11:0]),
      .alu_source_reg2			(alu_source_reg2[11:0]),
      .alu_source_reg3			(alu_source_reg3[11:0]),
      .alu_dest_reg1			(alu_dest_reg1[11:0]),
      .alu_dest_reg2			(alu_dest_reg2[11:0]),
      .lsu_imm_value0			(lsu_imm_value0[15:0]),
      .alu_imm_value0			(alu_imm_value0[15:0]),
      .lsu_lds_base			(lsu_lds_base[15:0]),
      .lsu_imm_value1			(lsu_imm_value1[31:0]),
      .lsu_opcode			(lsu_opcode[31:0]),
      .alu_imm_value1			(alu_imm_value1[31:0]),
      .alu_opcode			(alu_opcode[31:0]),
      .alu_instr_pc			(alu_instr_pc[31:0]),
      .lsu_instr_pc			(lsu_instr_pc[31:0]),
      .ready_array_data_dependencies	(ready_array_data_dependencies[40-1:0]),
      .alu_branch			(alu_branch),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_decode_source_reg2		(f_decode_source_reg2[13-1:0]),
      .f_decode_source_reg3		(f_decode_source_reg3[13-1:0]),
      .f_decode_dest_reg2		(f_decode_dest_reg2[13-1:0]),
      .f_decode_source_reg1		(f_decode_source_reg1[14-1:0]),
      .f_decode_source_reg4		(f_decode_source_reg4[14-1:0]),
      .f_decode_dest_reg1		(f_decode_dest_reg1[14-1:0]),
      .f_decode_imm_value0		(f_decode_imm_value0[15:0]),
      .f_decode_lds_base		(f_decode_lds_base[15:0]),
      .f_decode_instr_pc		(f_decode_instr_pc[31:0]),
      .f_decode_opcode			(f_decode_opcode[31:0]),
      .f_decode_imm_value1		(f_decode_imm_value1[31:0]),
      .f_decode_vcc_wr			(f_decode_vcc_wr),
      .f_decode_vcc_rd			(f_decode_vcc_rd),
      .f_decode_scc_wr			(f_decode_scc_wr),
      .f_decode_scc_rd			(f_decode_scc_rd),
      .f_decode_exec_rd			(f_decode_exec_rd),
      .f_decode_exec_wr			(f_decode_exec_wr),
      .f_decode_m0_rd			(f_decode_m0_rd),
      .f_decode_m0_wr			(f_decode_m0_wr),
      .f_decode_branch			(f_decode_branch),
      .f_decode_valid			(f_decode_valid),
      .issued_wfid			(issued_wfid[6-1:0]),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_vgpr_alu_wr_done_wfid		(f_vgpr_alu_wr_done_wfid[6-1:0]),
      .f_vgpr_lsu_wr_done_wfid		(f_vgpr_lsu_wr_done_wfid[6-1:0]),
      .f_sgpr_alu_wr_done_wfid		(f_sgpr_alu_wr_done_wfid[6-1:0]),
      .f_sgpr_lsu_instr_done_wfid	(f_sgpr_lsu_instr_done_wfid[6-1:0]),
      .f_exec_salu_wr_wfid		(f_exec_salu_wr_wfid[6-1:0]),
      .f_exec_valu_wr_vcc_wfid		(f_exec_valu_wr_vcc_wfid[6-1:0]),
      .f_exec_salu_wr_vcc_en		(f_exec_salu_wr_vcc_en),
      .f_exec_salu_wr_exec_en		(f_exec_salu_wr_exec_en),
      .f_exec_salu_wr_scc_en		(f_exec_salu_wr_scc_en),
      .f_exec_salu_wr_m0_en		(f_exec_salu_wr_m0_en),
      .f_exec_valu_wr_vcc_en		(f_exec_valu_wr_vcc_en),
      .f_sgpr_alu_dest_reg_addr		(f_sgpr_alu_dest_reg_addr[9-1:0]),
      .f_sgpr_lsu_dest_reg_addr		(f_sgpr_lsu_dest_reg_addr[9-1:0]),
      .f_sgpr_valu_dest_addr		(f_sgpr_valu_dest_addr[9-1:0]),
      .f_vgpr_alu_dest_reg_addr		(f_vgpr_alu_dest_reg_addr[10-1:0]),
      .f_vgpr_lsu_dest_reg_addr		(f_vgpr_lsu_dest_reg_addr[10-1:0]),
      .f_vgpr_lsu_dest_reg_valid	(f_vgpr_lsu_dest_reg_valid[3:0]),
      .f_sgpr_lsu_dest_reg_valid	(f_sgpr_lsu_dest_reg_valid[3:0]),
      .f_sgpr_alu_dest_reg_valid	(f_sgpr_alu_dest_reg_valid[1:0]),
      .f_vgpr_alu_dest_reg_valid	(f_vgpr_alu_dest_reg_valid),
      .f_sgpr_valu_dest_reg_valid	(f_sgpr_valu_dest_reg_valid),
      .alu_valid			(alu_valid),
      .lsu_valid			(lsu_valid),
      .issued_valid			(issued_valid));

   assign salu_ready_to_issue = fu_salu & valid_entry_out &
				ready_array_data_dependencies &
				~max_instr_inflight_array & 
				~pending_branches_arry & ~barrier_wait_arry;
   
   assign simd_ready_to_issue = fu_simd & valid_entry_out &
				ready_array_data_dependencies &
				~max_instr_inflight_array &
				~pending_branches_arry & ~barrier_wait_arry;

   assign simf_ready_to_issue = fu_simf & valid_entry_out &
				ready_array_data_dependencies &
				~max_instr_inflight_array &
   				~pending_branches_arry & ~barrier_wait_arry;
   
   assign lsu_ready_to_issue = fu_lsu & valid_entry_out &
			       ready_array_data_dependencies & 
			       ~max_instr_inflight_array &
			       ~mem_wait_arry & 
			       ~pending_branches_arry & ~barrier_wait_arry;
   

   instruction_arbiter instruction_arbiter
     (/*AUTOINST*/
      // Outputs
      .simd0_alu_select			(simd0_alu_select),
      .simd1_alu_select			(simd1_alu_select),
      .simd2_alu_select			(simd2_alu_select),
      .simd3_alu_select			(simd3_alu_select),
      .simf0_alu_select			(simf0_alu_select),
      .simf1_alu_select			(simf1_alu_select),
      .simf2_alu_select			(simf2_alu_select),
      .simf3_alu_select			(simf3_alu_select),
      .lsu_lsu_select			(lsu_lsu_select),
      .salu_alu_select			(salu_alu_select),
      .lsu_wfid				(lsu_wfid[6-1:0]),
      .alu_wfid				(alu_wfid[6-1:0]),
      .issued_wfid			(issued_wfid[6-1:0]),
      .alu_valid			(alu_valid),
      .lsu_valid			(lsu_valid),
      .issued_valid			(issued_valid),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .salu_ready_to_issue		(salu_ready_to_issue[40-1:0]),
      .simd_ready_to_issue		(simd_ready_to_issue[40-1:0]),
      .simf_ready_to_issue		(simf_ready_to_issue[40-1:0]),
      .lsu_ready_to_issue		(lsu_ready_to_issue[40-1:0]),
      .simd0_alu_ready			(simd0_alu_ready),
      .simd1_alu_ready			(simd1_alu_ready),
      .simd2_alu_ready			(simd2_alu_ready),
      .simd3_alu_ready			(simd3_alu_ready),
      .simf0_alu_ready			(simf0_alu_ready),
      .simf1_alu_ready			(simf1_alu_ready),
      .simf2_alu_ready			(simf2_alu_ready),
      .simf3_alu_ready			(simf3_alu_ready),
      .salu_alu_ready			(salu_alu_ready),
      .lsu_ready			(lsu_ready));
   
    mem_wait mem_wait
    (/*AUTOINST*/
        // Outputs
        .mem_wait_arry			(mem_wait_arry[40-1:0]),
        // Inputs
        .clk        (clk),
        .rst        (rst),
        .lsu_valid  (lsu_valid),
        .lsu_wfid   (lsu_wfid[5:0]),
        .lsu_done(lsu_done),
        .lsu_done_wfid(lsu_done_wfid)
    );
   
   branch_wait branch_wait
     (/*AUTOINST*/
      // Outputs
      .pending_branches_arry		(pending_branches_arry[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .alu_valid			(alu_valid),
      .alu_branch			(alu_branch),
      .alu_wfid				(alu_wfid[6-1:0]),
      .f_salu_branch_en			(f_salu_branch_en),
      .f_salu_branch_wfid		(f_salu_branch_wfid[6-1:0]));

   barrier_wait barrier_wait
     (/*AUTOINST*/
      // Outputs
      .tracemon_barrier_retire_en	(tracemon_barrier_retire_en),
      .fetch_wg_wfid			(fetch_wg_wfid[6-1:0]),
      .barrier_wait_arry		(barrier_wait_arry[40-1:0]),
      .tracemon_barrier_retire_wf_bitmap(tracemon_barrier_retire_wf_bitmap[40-1:0]),
      .tracemon_barrier_retire_pc	(tracemon_barrier_retire_pc[31:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_decode_valid			(f_decode_valid),
      .f_decode_barrier			(f_decode_barrier),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_decode_instr_pc		(f_decode_instr_pc[31:0]),
      .fetch_wg_wgid			(fetch_wg_wgid[6-1:0]),
      .fetch_wg_wf_count		(fetch_wg_wf_count[3:0]));
   
   finished_wf finished_wf
     (/*AUTOINST*/
      // Outputs
      .fetchwave_wf_done_en		(fetchwave_wf_done_en),
      .fetchwave_wf_done_wf_id		(fetchwave_wf_done_wf_id[6-1:0]),
      .max_instr_inflight_array		(max_instr_inflight_array[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_sgpr_alu_wr_done_wfid		(f_sgpr_alu_wr_done_wfid[6-1:0]),
      .f_vgpr_alu_wr_done_wfid		(f_vgpr_alu_wr_done_wfid[6-1:0]),
      .alu_wfid				(alu_wfid[6-1:0]),
      .f_salu_branch_wfid		(f_salu_branch_wfid[6-1:0]),
      .f_decode_valid			(f_decode_valid),
      .f_decode_wf_halt			(f_decode_wf_halt),
      .f_vgpr_alu_wr_done		(f_vgpr_alu_wr_done),
      .f_sgpr_alu_wr_done		(f_sgpr_alu_wr_done),
      .alu_valid			(alu_valid),
      .f_salu_branch_en			(f_salu_branch_en),
      .mem_wait_arry			(mem_wait_arry[40-1:0]));

   
endmodule
module issue_flow_control
  (/*AUTOARG*/
   // Outputs
   wave_valid_entries,
   // Inputs
   clk, rst, tracemon_barrier_retire_en, valid_entry_out,
   tracemon_barrier_retire_wf_bitmap, f_decode_wfid,
   f_salu_branch_wfid, alu_wfid, f_decode_valid, f_decode_waitcnt,
   f_salu_branch_en, alu_valid, alu_branch
   );

   input clk,rst;
   input tracemon_barrier_retire_en;
   input [40-1:0] valid_entry_out;
   input [40-1:0] tracemon_barrier_retire_wf_bitmap;
   input [6-1:0] f_decode_wfid, f_salu_branch_wfid,
			     alu_wfid;
   input 		     f_decode_valid, f_decode_waitcnt,
			     f_salu_branch_en,
			     alu_valid, alu_branch;

   wire [40-1:0]     flopped_valid_entry_out;
   wire [40-1:0]     valid_barrier_retire_wf_bitmap;
   wire [40-1:0]     decoded_decode_waitcnt, decoded_branch_retired;
			     
   wire [40-1:0]     decoded_branch_issued, flopped_decoded_branch_issued;
   
			
   output [40-1:0]   wave_valid_entries;


   decoder_6b_40b_en branch_issue
     (
      .addr_in(alu_wfid),
      .out(decoded_branch_issued),
      .en(alu_valid & alu_branch)
      );
   
   decoder_6b_40b_en branch_retire
     (
      .addr_in(f_salu_branch_wfid),
      .out(decoded_branch_retired),
      .en(f_salu_branch_en)
      );
   
   decoder_6b_40b_en wait_cnt_decoder
     (
      .addr_in(f_decode_wfid),
      .out(decoded_decode_waitcnt),
      .en(f_decode_valid & f_decode_waitcnt)
      );

   dff valid_entry_out_flop[40-1:0]
     (
      .q(flopped_valid_entry_out),
      .d(valid_entry_out),
      .clk(clk),
      .rst(rst)
      );

   dff branch_issued_flop[40-1:0]
     (
      .q(flopped_decoded_branch_issued),
      .d(decoded_branch_issued),
      .clk(clk),
      .rst(rst)
      );

   assign valid_barrier_retire_wf_bitmap 
     = ( tracemon_barrier_retire_en )? tracemon_barrier_retire_wf_bitmap : 
       {40{1'b0}};

   // Ask for new instructions when valid goes down (instruction is issued) or when
   // a barrier or a branch of a waitcnt retire.
   // Do not ask for new instructions when a branch was issued last cycle
   assign wave_valid_entries 
     = (  ( (valid_entry_out ^ flopped_valid_entry_out) & flopped_valid_entry_out ) | 
	  valid_barrier_retire_wf_bitmap | decoded_decode_waitcnt | decoded_branch_retired  ) &
       ~flopped_decoded_branch_issued;   
endmodule
module mem_wait
(/*AUTOARG*/
    // Outputs
    mem_wait_arry,
    // Inputs
    clk, rst, lsu_valid, lsu_done,
    lsu_wfid, lsu_done_wfid
);

input clk,rst;
input lsu_valid, lsu_done;
input [5:0] lsu_wfid, lsu_done_wfid;

output [40-1:0] mem_wait_arry;

wire [40-1:0]   decoded_issue_value, decoded_lsu_retire_value,
                        mem_wait_reg_wr_en, mem_waiting_wf;

decoder_6b_40b_en issue_value_decoder
(
    .addr_in(lsu_wfid),
    .out(decoded_issue_value),
    .en(lsu_valid)
);


decoder_6b_40b_en retire_sgpr_value_decoder
(
    .addr_in(lsu_done_wfid),
    .out(decoded_lsu_retire_value),
    .en(lsu_done)
);

// decoder_6b_40b_en retire_vgpr_value_decoder
// (
//     .addr_in(f_vgpr_lsu_wr_done_wfid),
//     .out(decoded_vgpr_retire_value),
//     .en(f_vgpr_lsu_wr_done)
// );

dff_set_en_rst mem_wait[40-1:0]
(
    .q(mem_waiting_wf),
    .d(40'b0),
    .en(mem_wait_reg_wr_en),
    .clk(clk),
    .set(decoded_issue_value),
    .rst(rst)
);

assign mem_wait_reg_wr_en = decoded_lsu_retire_value | decoded_issue_value;

assign mem_wait_arry = mem_waiting_wf;
endmodule
module mux_40xPARAMb_to_1xPARAMb(
            out,
            in,
            select );

    parameter WORD_WIDTH = 12; 

    input[40*WORD_WIDTH-1:0] in;
    input[5:0] select;
    output[WORD_WIDTH-1:0] out;
    
    reg[WORD_WIDTH-1:0] out;
    always @(in or select) begin
        casex(select)
            6'h00: out = in[1*WORD_WIDTH-1:0*WORD_WIDTH];
            6'h01: out = in[2*WORD_WIDTH-1:1*WORD_WIDTH];
            6'h02: out = in[3*WORD_WIDTH-1:2*WORD_WIDTH];
            6'h03: out = in[4*WORD_WIDTH-1:3*WORD_WIDTH];
            6'h04: out = in[5*WORD_WIDTH-1:4*WORD_WIDTH];
            6'h05: out = in[6*WORD_WIDTH-1:5*WORD_WIDTH];
            6'h06: out = in[7*WORD_WIDTH-1:6*WORD_WIDTH];
            6'h07: out = in[8*WORD_WIDTH-1:7*WORD_WIDTH];
            6'h08: out = in[9*WORD_WIDTH-1:8*WORD_WIDTH];
            6'h09: out = in[10*WORD_WIDTH-1:9*WORD_WIDTH];
            6'h0a: out = in[11*WORD_WIDTH-1:10*WORD_WIDTH];
            6'h0b: out = in[12*WORD_WIDTH-1:11*WORD_WIDTH];
            6'h0c: out = in[13*WORD_WIDTH-1:12*WORD_WIDTH];
            6'h0d: out = in[14*WORD_WIDTH-1:13*WORD_WIDTH];
            6'h0e: out = in[15*WORD_WIDTH-1:14*WORD_WIDTH];
            6'h0f: out = in[16*WORD_WIDTH-1:15*WORD_WIDTH];
            6'h10: out = in[17*WORD_WIDTH-1:16*WORD_WIDTH];
            6'h11: out = in[18*WORD_WIDTH-1:17*WORD_WIDTH];
            6'h12: out = in[19*WORD_WIDTH-1:18*WORD_WIDTH];
            6'h13: out = in[20*WORD_WIDTH-1:19*WORD_WIDTH];
            6'h14: out = in[21*WORD_WIDTH-1:20*WORD_WIDTH];
            6'h15: out = in[22*WORD_WIDTH-1:21*WORD_WIDTH];
            6'h16: out = in[23*WORD_WIDTH-1:22*WORD_WIDTH];
            6'h17: out = in[24*WORD_WIDTH-1:23*WORD_WIDTH];
            6'h18: out = in[25*WORD_WIDTH-1:24*WORD_WIDTH];
            6'h19: out = in[26*WORD_WIDTH-1:25*WORD_WIDTH];
            6'h1a: out = in[27*WORD_WIDTH-1:26*WORD_WIDTH];
            6'h1b: out = in[28*WORD_WIDTH-1:27*WORD_WIDTH];
            6'h1c: out = in[29*WORD_WIDTH-1:28*WORD_WIDTH];
            6'h1d: out = in[30*WORD_WIDTH-1:29*WORD_WIDTH];
            6'h1e: out = in[31*WORD_WIDTH-1:30*WORD_WIDTH];
            6'h1f: out = in[32*WORD_WIDTH-1:31*WORD_WIDTH];
            6'h20: out = in[33*WORD_WIDTH-1:32*WORD_WIDTH];
            6'h21: out = in[34*WORD_WIDTH-1:33*WORD_WIDTH];
            6'h22: out = in[35*WORD_WIDTH-1:34*WORD_WIDTH];
            6'h23: out = in[36*WORD_WIDTH-1:35*WORD_WIDTH];
            6'h24: out = in[37*WORD_WIDTH-1:36*WORD_WIDTH];
            6'h25: out = in[38*WORD_WIDTH-1:37*WORD_WIDTH];
            6'h26: out = in[39*WORD_WIDTH-1:38*WORD_WIDTH];
            6'h27: out = in[40*WORD_WIDTH-1:39*WORD_WIDTH];
            default: out = {(WORD_WIDTH){1'bX}};
        endcase
    end
endmodule
/**
 * global_definitions.v
 * File with al global definitions of the miaow project.
 * This file does not need to be included within the modules but it needs to be
 * listed for compilation/syntesys.
 */

























  //_global_definitions_v_
/**
 * issue_definitions.v
 * File that contains all definitions used throughout issue
 * stage
 ***/











































































 // _issue_definitions_v_

module ready_bits_demux(
    in,
    addr,
    out,
    en
);

parameter TOTAL_INFO_LENGTH = (4+2+2+4+4+2);

input [TOTAL_INFO_LENGTH-1:0] in;
input [6-1:0] addr;
output [TOTAL_INFO_LENGTH*40-1:0] out;
reg [TOTAL_INFO_LENGTH*40-1:0] out;
input en;

always @(addr or in or en) begin
    out <= {(TOTAL_INFO_LENGTH*40-1){1'b0}};
    case(addr)
// %%start_veriperl
// my $i;
// for($i=0; $i<40; $i=$i+1)
// {
//   print "        6'd$i : out[TOTAL_INFO_LENGTH*$i+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*$i] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;\n";
// }
// %%stop_veriperl
        6'd0 : out[TOTAL_INFO_LENGTH*0+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*0] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd1 : out[TOTAL_INFO_LENGTH*1+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*1] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd2 : out[TOTAL_INFO_LENGTH*2+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*2] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd3 : out[TOTAL_INFO_LENGTH*3+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*3] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd4 : out[TOTAL_INFO_LENGTH*4+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*4] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd5 : out[TOTAL_INFO_LENGTH*5+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*5] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd6 : out[TOTAL_INFO_LENGTH*6+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*6] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd7 : out[TOTAL_INFO_LENGTH*7+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*7] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd8 : out[TOTAL_INFO_LENGTH*8+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*8] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd9 : out[TOTAL_INFO_LENGTH*9+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*9] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd10 : out[TOTAL_INFO_LENGTH*10+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*10] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd11 : out[TOTAL_INFO_LENGTH*11+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*11] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd12 : out[TOTAL_INFO_LENGTH*12+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*12] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd13 : out[TOTAL_INFO_LENGTH*13+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*13] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd14 : out[TOTAL_INFO_LENGTH*14+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*14] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd15 : out[TOTAL_INFO_LENGTH*15+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*15] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd16 : out[TOTAL_INFO_LENGTH*16+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*16] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd17 : out[TOTAL_INFO_LENGTH*17+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*17] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd18 : out[TOTAL_INFO_LENGTH*18+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*18] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd19 : out[TOTAL_INFO_LENGTH*19+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*19] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd20 : out[TOTAL_INFO_LENGTH*20+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*20] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd21 : out[TOTAL_INFO_LENGTH*21+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*21] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd22 : out[TOTAL_INFO_LENGTH*22+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*22] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd23 : out[TOTAL_INFO_LENGTH*23+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*23] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd24 : out[TOTAL_INFO_LENGTH*24+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*24] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd25 : out[TOTAL_INFO_LENGTH*25+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*25] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd26 : out[TOTAL_INFO_LENGTH*26+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*26] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd27 : out[TOTAL_INFO_LENGTH*27+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*27] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd28 : out[TOTAL_INFO_LENGTH*28+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*28] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd29 : out[TOTAL_INFO_LENGTH*29+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*29] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd30 : out[TOTAL_INFO_LENGTH*30+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*30] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd31 : out[TOTAL_INFO_LENGTH*31+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*31] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd32 : out[TOTAL_INFO_LENGTH*32+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*32] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd33 : out[TOTAL_INFO_LENGTH*33+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*33] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd34 : out[TOTAL_INFO_LENGTH*34+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*34] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd35 : out[TOTAL_INFO_LENGTH*35+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*35] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd36 : out[TOTAL_INFO_LENGTH*36+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*36] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd37 : out[TOTAL_INFO_LENGTH*37+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*37] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd38 : out[TOTAL_INFO_LENGTH*38+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*38] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
        6'd39 : out[TOTAL_INFO_LENGTH*39+(TOTAL_INFO_LENGTH-1):TOTAL_INFO_LENGTH*39] <= (en)? in: {TOTAL_INFO_LENGTH{1'b0}} ;
    endcase
end

endmodule
module scoreboard
  (/*AUTOARG*/
   // Outputs
   lsu_source_reg1, lsu_source_reg2, lsu_source_reg3, lsu_dest_reg,
   lsu_mem_sgpr, alu_source_reg1, alu_source_reg2, alu_source_reg3,
   alu_dest_reg1, alu_dest_reg2, lsu_imm_value0, alu_imm_value0,
   lsu_lds_base, lsu_imm_value1, lsu_opcode, alu_imm_value1,
   alu_opcode, alu_instr_pc, lsu_instr_pc,
   ready_array_data_dependencies, alu_branch,
   // Inputs
   clk, rst, f_decode_source_reg2, f_decode_source_reg3,
   f_decode_dest_reg2, f_decode_source_reg1, f_decode_source_reg4,
   f_decode_dest_reg1, f_decode_imm_value0, f_decode_lds_base,
   f_decode_instr_pc, f_decode_opcode, f_decode_imm_value1,
   f_decode_vcc_wr, f_decode_vcc_rd, f_decode_scc_wr, f_decode_scc_rd,
   f_decode_exec_rd, f_decode_exec_wr, f_decode_m0_rd, f_decode_m0_wr,
   f_decode_branch, f_decode_valid, issued_wfid, f_decode_wfid,
   f_vgpr_alu_wr_done_wfid, f_vgpr_lsu_wr_done_wfid,
   f_sgpr_alu_wr_done_wfid, f_sgpr_lsu_instr_done_wfid,
   f_exec_salu_wr_wfid, f_exec_valu_wr_vcc_wfid,
   f_exec_salu_wr_vcc_en, f_exec_salu_wr_exec_en,
   f_exec_salu_wr_scc_en, f_exec_salu_wr_m0_en, f_exec_valu_wr_vcc_en,
   f_sgpr_alu_dest_reg_addr, f_sgpr_lsu_dest_reg_addr,
   f_sgpr_valu_dest_addr, f_vgpr_alu_dest_reg_addr,
   f_vgpr_lsu_dest_reg_addr, f_vgpr_lsu_dest_reg_valid,
   f_sgpr_lsu_dest_reg_valid, f_sgpr_alu_dest_reg_valid,
   f_vgpr_alu_dest_reg_valid, f_sgpr_valu_dest_reg_valid, alu_valid,
   lsu_valid, issued_valid
   );

   input clk, rst;
   
   input[13-1:0] f_decode_source_reg2, f_decode_source_reg3, 
				   f_decode_dest_reg2;
   input [14-1:0] f_decode_source_reg1, f_decode_source_reg4, 
				    f_decode_dest_reg1;
   input [15:0] 		    f_decode_imm_value0, f_decode_lds_base;
   input [31:0] 		    f_decode_instr_pc, f_decode_opcode, f_decode_imm_value1;
   input 			    f_decode_vcc_wr, f_decode_vcc_rd, f_decode_scc_wr,
				    f_decode_scc_rd, f_decode_exec_rd, f_decode_exec_wr, 
				    f_decode_m0_rd, f_decode_m0_wr, 
				    f_decode_branch, f_decode_valid;
   input [6-1:0] 	    issued_wfid;	    

   input [6-1:0] 	    f_decode_wfid, f_vgpr_alu_wr_done_wfid, 
				    f_vgpr_lsu_wr_done_wfid, f_sgpr_alu_wr_done_wfid, 
				    f_sgpr_lsu_instr_done_wfid, f_exec_salu_wr_wfid, 
				    f_exec_valu_wr_vcc_wfid;

   input 			    f_exec_salu_wr_vcc_en, f_exec_salu_wr_exec_en, f_exec_salu_wr_scc_en, 
				    f_exec_salu_wr_m0_en, f_exec_valu_wr_vcc_en;
   
   input [9-1:0]     f_sgpr_alu_dest_reg_addr, f_sgpr_lsu_dest_reg_addr,
				     f_sgpr_valu_dest_addr;
   input [10-1:0]     f_vgpr_alu_dest_reg_addr, f_vgpr_lsu_dest_reg_addr;
   input [3:0] 			     f_vgpr_lsu_dest_reg_valid, f_sgpr_lsu_dest_reg_valid;
   input [1:0] 			     f_sgpr_alu_dest_reg_valid;
   input 			     f_vgpr_alu_dest_reg_valid, f_sgpr_valu_dest_reg_valid;
			     
   
   input 			    alu_valid, lsu_valid, issued_valid;
			    
   output [11:0] 		    lsu_source_reg1, lsu_source_reg2, lsu_source_reg3, 
				    lsu_dest_reg, lsu_mem_sgpr, 
				    alu_source_reg1, alu_source_reg2, alu_source_reg3, 
				    alu_dest_reg1, alu_dest_reg2;
   output [15:0] 		    lsu_imm_value0, alu_imm_value0, lsu_lds_base;
   output [31:0] 		    lsu_imm_value1, lsu_opcode, alu_imm_value1, alu_opcode,
				    alu_instr_pc, lsu_instr_pc;
   output [40-1:0] 	    ready_array_data_dependencies;  
   output 			    alu_branch;
   

   wire [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] sgpr_alu_rd_data, sgpr_lsu_rd_data,
				       vgpr_alu_rd_data, vgpr_lsu_rd_data;

   wire [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] issued_rd_data;
   wire [40-1:0] 	      ready_arry_gpr, ready_arry_spr;

   wire [3:0] 			      decode_dest_reg1_busy_bits, 
				      decode_source_reg1_busy_bits,
				      decode_source_reg4_busy_bits;
   
   wire [1:0] 			      decode_dest_reg2_busy_bits, 
				      decode_source_reg2_busy_bits,
				      decode_source_reg3_busy_bits;
  
   wire [(4+2+2+4+4+2)-1:0] sgpr_valu_set_data,
					sgpr_alu_set_data, sgpr_lsu_set_data,
					vgpr_alu_set_data, vgpr_lsu_set_data;

   wire 			      issue_alu_exec_wr, issue_alu_m0_wr, 
				      issue_alu_scc_wr, issue_alu_vcc_wr, 
				      issue_lsu_exec_wr, issue_lsu_m0_wr,
				      issue_lsu_scc_wr, issue_lsu_vcc_wr;
   
   wire [(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0] decode_wr_data;
   wire [(4+2+2+4+4+2)-1:0] decode_instr_data;
   wire [11:0] 			       lsu_source_reg1, lsu_source_reg2, lsu_source_reg3, 
				      lsu_dest_reg, lsu_mem_sgpr, 
				      alu_source_reg1, alu_source_reg2, alu_source_reg3, 
				      alu_dest_reg1, alu_dest_reg2;
   wire [15:0] 			      lsu_imm_value0, alu_imm_value0;
   wire [31:0] 			      lsu_imm_value1, lsu_opcode, alu_imm_value1, alu_opcode,
				      alu_instr_pc, lsu_instr_pc;
   wire [1:0] 			      lsu_dest_reg_size;
   wire 			      alu_dest_reg1_size, alu_dest_reg2_size;
   
   instr_info_table iit
     (/*AUTOINST*/
      // Outputs
      .vgpr_alu_rd_data			(vgpr_alu_rd_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      .vgpr_lsu_rd_data			(vgpr_lsu_rd_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      .sgpr_alu_rd_data			(sgpr_alu_rd_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      .sgpr_lsu_rd_data			(sgpr_lsu_rd_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      .issued_rd_data			(issued_rd_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      // Inputs
      .f_decode_valid			(f_decode_valid),
      .clk				(clk),
      .rst				(rst),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .decode_wr_data			(decode_wr_data[(16+1+1+1+1+1+32+32+16+32+14+13+13+14+14+13)-1:0]),
      .f_vgpr_alu_wr_done_wfid		(f_vgpr_alu_wr_done_wfid[6-1:0]),
      .f_vgpr_lsu_wr_done_wfid		(f_vgpr_lsu_wr_done_wfid[6-1:0]),
      .f_sgpr_alu_wr_done_wfid		(f_sgpr_alu_wr_done_wfid[6-1:0]),
      .f_sgpr_lsu_instr_done_wfid	(f_sgpr_lsu_instr_done_wfid[6-1:0]),
      .issued_wfid			(issued_wfid[6-1:0]));

   assign decode_wr_data
     = {f_decode_lds_base, f_decode_branch,
	f_decode_vcc_wr,f_decode_scc_wr,
	f_decode_exec_wr,f_decode_m0_wr,
	f_decode_instr_pc,f_decode_opcode,
	f_decode_imm_value0,f_decode_imm_value1,
	f_decode_source_reg1,f_decode_source_reg2,
	f_decode_source_reg3,f_decode_source_reg4,
	f_decode_dest_reg1,f_decode_dest_reg2};
	
   assign lsu_lds_base = issued_rd_data[((((((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)+1)+1) + 1) + 16-1):(((((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)+1)+1) + 1)];
   assign lsu_opcode = issued_rd_data[(((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1):((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)];
   assign lsu_instr_pc  = issued_rd_data[(((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1):((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)];
   assign lsu_imm_value0  = issued_rd_data[(((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1):((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)];
   assign lsu_imm_value1  = issued_rd_data[(((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1):((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)];
   assign lsu_source_reg1  = issued_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)-2:((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)];
   assign lsu_source_reg2  = issued_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)-1:((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)];
   assign lsu_source_reg3  = issued_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)-1:((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)];
   assign lsu_dest_reg_size = issued_rd_data[(((0+13-1)+1)+14-1):(((0+13-1)+1)+14-1)-1];
   assign lsu_dest_reg  = issued_rd_data[(((0+13-1)+1)+14-1)-2:((0+13-1)+1)];
   assign lsu_mem_sgpr  = issued_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1)-2:((((0+13-1)+1)+14-1) + 1)];
   assign issue_lsu_vcc_wr = issued_rd_data[(((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)+1)];
   assign issue_lsu_scc_wr = issued_rd_data[((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)];
   assign issue_lsu_m0_wr = issued_rd_data[((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)];
   assign issue_lsu_exec_wr = issued_rd_data[(((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)];
   
   assign alu_opcode  = issued_rd_data[(((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1):((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)];
   assign alu_instr_pc  = issued_rd_data[(((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1):((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)];
   assign alu_imm_value0  = issued_rd_data[(((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1):((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)];
   assign alu_imm_value1  = issued_rd_data[(((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1):((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)];
   assign alu_source_reg1  = issued_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)-2:((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)];
   assign alu_source_reg2  = issued_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)-1:((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)];
   assign alu_source_reg3  = issued_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)-1:((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)];
   assign alu_dest_reg1_size = issued_rd_data[(((0+13-1)+1)+14-1)-1];
   assign alu_dest_reg1  = issued_rd_data[(((0+13-1)+1)+14-1)-2:((0+13-1)+1)];
   assign alu_dest_reg2_size = issued_rd_data[(0+13-1)];
   assign alu_dest_reg2  = issued_rd_data[(0+13-1)-1:0];
   assign issue_alu_vcc_wr = issued_rd_data[(((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)+1)];
   assign issue_alu_scc_wr = issued_rd_data[((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)];
   assign issue_alu_m0_wr = issued_rd_data[((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)];
   assign issue_alu_exec_wr = issued_rd_data[(((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)];
   assign alu_branch = issued_rd_data[((((((((((((((((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1)+ 1)+ 32-1)+ 1)+ 16-1)+ 1)+ 32-1)+ 1)+ 32-1)+1)+1)+1)+1)+1)];
   

   busy_gpr_table bgt
     (/*AUTOINST*/
      // Outputs
      .decode_dest_reg1_busy_bits	(decode_dest_reg1_busy_bits[3:0]),
      .decode_source_reg1_busy_bits	(decode_source_reg1_busy_bits[3:0]),
      .decode_source_reg4_busy_bits	(decode_source_reg4_busy_bits[3:0]),
      .decode_source_reg2_busy_bits	(decode_source_reg2_busy_bits[1:0]),
      .decode_source_reg3_busy_bits	(decode_source_reg3_busy_bits[1:0]),
      .decode_dest_reg2_busy_bits	(decode_dest_reg2_busy_bits[1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .alu_valid			(alu_valid),
      .lsu_valid			(lsu_valid),
      .f_decode_source_reg2		(f_decode_source_reg2[13-1:0]),
      .f_decode_source_reg3		(f_decode_source_reg3[13-1:0]),
      .f_decode_dest_reg2		(f_decode_dest_reg2[13-1:0]),
      .f_decode_dest_reg1		(f_decode_dest_reg1[14-1:0]),
      .f_decode_source_reg1		(f_decode_source_reg1[14-1:0]),
      .f_decode_source_reg4		(f_decode_source_reg4[14-1:0]),
      .alu_dest_reg1			(alu_dest_reg1[11:0]),
      .lsu_dest_reg			(lsu_dest_reg[11:0]),
      .lsu_dest_reg_size		(lsu_dest_reg_size[1:0]),
      .alu_dest_reg1_size		(alu_dest_reg1_size),
      .alu_dest_reg2			(alu_dest_reg2[11:0]),
      .alu_dest_reg2_size		(alu_dest_reg2_size),
      .f_vgpr_alu_dest_reg_addr		(f_vgpr_alu_dest_reg_addr[10-1:0]),
      .f_vgpr_lsu_dest_reg_addr		(f_vgpr_lsu_dest_reg_addr[10-1:0]),
      .f_vgpr_lsu_dest_reg_valid	(f_vgpr_lsu_dest_reg_valid[3:0]),
      .f_vgpr_alu_dest_reg_valid	(f_vgpr_alu_dest_reg_valid),
      .f_sgpr_valu_dest_addr		(f_sgpr_valu_dest_addr[9-1:0]),
      .f_sgpr_alu_dest_reg_addr		(f_sgpr_alu_dest_reg_addr[9-1:0]),
      .f_sgpr_lsu_dest_reg_addr		(f_sgpr_lsu_dest_reg_addr[9-1:0]),
      .f_sgpr_lsu_dest_reg_valid	(f_sgpr_lsu_dest_reg_valid[3:0]),
      .f_sgpr_alu_dest_reg_valid	(f_sgpr_alu_dest_reg_valid[1:0]),
      .f_sgpr_valu_dest_reg_valid	(f_sgpr_valu_dest_reg_valid));
   
   

   
   /*******************************************************************
    * GPR comparators to fill the dependency table                    *
    *******************************************************************/
   
   vgpr_comparator vgpr_alu_cmp
     (
      // Outputs
      .result				(vgpr_alu_set_data),
      // Inputs
      .retired_operand_mask		({3'b0,f_vgpr_alu_dest_reg_valid}),
      .retired_operand_addr		(f_vgpr_alu_dest_reg_addr),
      .src1_gpr_info			(vgpr_alu_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1):((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)]),
      .src4_gpr_info			(vgpr_alu_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1):((((0+13-1)+1)+14-1) + 1)]),
      .dst1_gpr_info			(vgpr_alu_rd_data[(((0+13-1)+1)+14-1):((0+13-1)+1)]),
      .src2_gpr_info			(vgpr_alu_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1):((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)]),
      .src3_gpr_info			(vgpr_alu_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1):((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)]),
      .dst2_gpr_info			(vgpr_alu_rd_data[(0+13-1):0]));

   vgpr_comparator vgpr_lsu_cmp
     (
      // Outputs
      .result				(vgpr_lsu_set_data),
      // Inputs
      .retired_operand_mask		(f_vgpr_lsu_dest_reg_valid),
      .retired_operand_addr		(f_vgpr_lsu_dest_reg_addr),
      .src1_gpr_info			(vgpr_lsu_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1):((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)]),
      .src4_gpr_info			(vgpr_lsu_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1):((((0+13-1)+1)+14-1) + 1)]),
      .dst1_gpr_info			(vgpr_lsu_rd_data[(((0+13-1)+1)+14-1):((0+13-1)+1)]),
      .src2_gpr_info			(vgpr_lsu_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1):((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)]),
      .src3_gpr_info			(vgpr_lsu_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1):((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)]),
      .dst2_gpr_info			(vgpr_lsu_rd_data[(0+13-1):0]));

   sgpr_comparator sgpr_alu_cmp
     (
      // Outputs
      .result				(sgpr_alu_set_data),
      // Inputs
      .retired_operand_mask		({2'b0,f_sgpr_alu_dest_reg_valid}),
      .retired_operand_addr		(f_sgpr_alu_dest_reg_addr),
      .src1_gpr_info			(sgpr_alu_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1):((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)]),
      .src4_gpr_info			(sgpr_alu_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1):((((0+13-1)+1)+14-1) + 1)]),
      .dst1_gpr_info			(sgpr_alu_rd_data[(((0+13-1)+1)+14-1):((0+13-1)+1)]),
      .src2_gpr_info			(sgpr_alu_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1):((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)]),
      .src3_gpr_info			(sgpr_alu_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1):((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)]),
      .dst2_gpr_info			(sgpr_alu_rd_data[(0+13-1):0]));

   // This comparator uses the same WFID as the valu one, so it also uses the
   // same data read from the instruction info table
   sgpr_comparator sgpr_valu_cmp
     (
      // Outputs
      .result				(sgpr_valu_set_data),
      // Inputs
      .retired_operand_mask		({2'b0,f_sgpr_valu_dest_reg_valid, f_sgpr_valu_dest_reg_valid}),
      .retired_operand_addr		(f_sgpr_valu_dest_addr),
      .src1_gpr_info			(vgpr_alu_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1):((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)]),
      .src4_gpr_info			(vgpr_alu_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1):((((0+13-1)+1)+14-1) + 1)]),
      .dst1_gpr_info			(vgpr_alu_rd_data[(((0+13-1)+1)+14-1):((0+13-1)+1)]),
      .src2_gpr_info			(vgpr_alu_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1):((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)]),
      .src3_gpr_info			(vgpr_alu_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1):((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)]),
      .dst2_gpr_info			(vgpr_alu_rd_data[(0+13-1):0]));

   sgpr_comparator sgpr_lsu_cmp
     (
      // Outputs
      .result				(sgpr_lsu_set_data),
      // Inputs
      .retired_operand_mask		(f_sgpr_lsu_dest_reg_valid),
      .retired_operand_addr		(f_sgpr_lsu_dest_reg_addr),
      .src1_gpr_info			(sgpr_lsu_rd_data[(((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)+ 14-1):((((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1)+ 1)]),
      .src4_gpr_info			(sgpr_lsu_rd_data[(((((0+13-1)+1)+14-1) + 1) + 14-1):((((0+13-1)+1)+14-1) + 1)]),
      .dst1_gpr_info			(sgpr_lsu_rd_data[(((0+13-1)+1)+14-1):((0+13-1)+1)]),
      .src2_gpr_info			(sgpr_lsu_rd_data[(((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)+ 13-1):((((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1)+ 1)]),
      .src3_gpr_info			(sgpr_lsu_rd_data[(((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)+ 13-1):((((((0+13-1)+1)+14-1) + 1) + 14-1)+ 1)]),
      .dst2_gpr_info			(sgpr_lsu_rd_data[(0+13-1):0]));
   
   /**********************************************************************
    * GPR dependency table                                               *
    **********************************************************************/    
  gpr_dependency_table gdt
     (/*AUTOINST*/
      // Outputs
      .ready_arry_gpr			(ready_arry_gpr[40-1:0]),
      // Inputs
      .clk				(clk),
      .rst				(rst),
      .vgpr_alu_set_data		(vgpr_alu_set_data[(4+2+2+4+4+2)-1:0]),
      .vgpr_lsu_set_data		(vgpr_lsu_set_data[(4+2+2+4+4+2)-1:0]),
      .sgpr_alu_set_data		(sgpr_alu_set_data[(4+2+2+4+4+2)-1:0]),
      .sgpr_lsu_set_data		(sgpr_lsu_set_data[(4+2+2+4+4+2)-1:0]),
      .sgpr_valu_set_data		(sgpr_valu_set_data[(4+2+2+4+4+2)-1:0]),
      .decode_instr_data		(decode_instr_data[(4+2+2+4+4+2)-1:0]),
      .f_vgpr_alu_wr_done_wfid		(f_vgpr_alu_wr_done_wfid[6-1:0]),
      .f_vgpr_lsu_wr_done_wfid		(f_vgpr_lsu_wr_done_wfid[6-1:0]),
      .f_sgpr_alu_wr_done_wfid		(f_sgpr_alu_wr_done_wfid[6-1:0]),
      .f_sgpr_lsu_instr_done_wfid	(f_sgpr_lsu_instr_done_wfid[6-1:0]),
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_decode_valid			(f_decode_valid));
   
   assign decode_instr_data = {decode_source_reg1_busy_bits, decode_source_reg2_busy_bits[1:0], 
			decode_source_reg3_busy_bits[1:0], decode_source_reg4_busy_bits, 
			decode_dest_reg1_busy_bits, decode_dest_reg2_busy_bits[1:0]};
   

   /**********************************************************************
    * SPR dependency table                                               *
    **********************************************************************/
   spr_dependency_table sdt
     (/*AUTOINST*/
      // Outputs
      .ready_arry_spr			(ready_arry_spr[40-1:0]),
      // Inputs
      .f_decode_wfid			(f_decode_wfid[6-1:0]),
      .f_exec_salu_wr_wfid		(f_exec_salu_wr_wfid[6-1:0]),
      .f_exec_valu_wr_vcc_wfid		(f_exec_valu_wr_vcc_wfid[6-1:0]),
      .issued_wfid			(issued_wfid[6-1:0]),
      .f_decode_valid			(f_decode_valid),
      .f_decode_vcc_wr			(f_decode_vcc_wr),
      .f_decode_vcc_rd			(f_decode_vcc_rd),
      .f_decode_scc_wr			(f_decode_scc_wr),
      .f_decode_scc_rd			(f_decode_scc_rd),
      .f_decode_exec_rd			(f_decode_exec_rd),
      .f_decode_exec_wr			(f_decode_exec_wr),
      .f_decode_m0_rd			(f_decode_m0_rd),
      .f_decode_m0_wr			(f_decode_m0_wr),
      .f_exec_salu_wr_vcc_en		(f_exec_salu_wr_vcc_en),
      .f_exec_salu_wr_exec_en		(f_exec_salu_wr_exec_en),
      .f_exec_salu_wr_scc_en		(f_exec_salu_wr_scc_en),
      .f_exec_salu_wr_m0_en		(f_exec_salu_wr_m0_en),
      .f_exec_valu_wr_vcc_en		(f_exec_valu_wr_vcc_en),
      .alu_valid			(alu_valid),
      .lsu_valid			(lsu_valid),
      .issued_valid			(issued_valid),
      .issue_lsu_vcc_wr			(issue_lsu_vcc_wr),
      .issue_lsu_scc_wr			(issue_lsu_scc_wr),
      .issue_lsu_exec_wr		(issue_lsu_exec_wr),
      .issue_lsu_m0_wr			(issue_lsu_m0_wr),
      .issue_alu_vcc_wr			(issue_alu_vcc_wr),
      .issue_alu_scc_wr			(issue_alu_scc_wr),
      .issue_alu_exec_wr		(issue_alu_exec_wr),
      .issue_alu_m0_wr			(issue_alu_m0_wr),
      .clk				(clk),
      .rst				(rst));
   
   assign ready_array_data_dependencies = ready_arry_spr & ready_arry_gpr;
 
endmodule
   
module sgpr_busy_table_decoder
(
 sgpr_addr,
 sgpr_valid,

 output_decoded
);
   parameter MAX_NUMBER_WORDS = 4;
   
   input[9-1:0] sgpr_addr;
   input [MAX_NUMBER_WORDS-1:0] sgpr_valid;

   output [512-1:0] 	output_decoded;
   wire [512+4-1:0] 	output_decoded_2;

   assign output_decoded_2 = (|sgpr_valid) ? sgpr_valid << sgpr_addr : 516'd0;
   assign output_decoded = output_decoded_2[512-1:0] | { {(512-4){1'b0}},output_decoded_2[512+4-1:512]};
endmodule
module sgpr_busy_table_mux
  (
   in,
   select,
   out
   );
   parameter MAX_NUMBER_WORDS = 4;
   
   input[512-1:0] in;
   wire [512+4-1:0] in_rotated;
   input [9-1:0] select;

   output [MAX_NUMBER_WORDS-1:0] out;

   assign in_rotated = {in[3:0],in};
   assign out = in_rotated >> select;
endmodule
module sgpr_comparator
  (/*AUTOARG*/
   // Outputs
   result,
   // Inputs
   retired_operand_mask, retired_operand_addr, src1_gpr_info,
   src4_gpr_info, dst1_gpr_info, src2_gpr_info, src3_gpr_info,
   dst2_gpr_info
   );

   wire  src1_cmp_en, src2_cmp_en, src3_cmp_en, src4_cmp_en,
	 dst1_cmp_en, dst2_cmp_en;
   
   
   input [3:0] retired_operand_mask;
   wire [3:0]  src1_mask, src4_mask, dst1_mask;
   wire [2:0]  src2_mask, src3_mask, dst2_mask;
   
   
   input [9-1:0] retired_operand_addr;
   input [13:0] 		 src1_gpr_info, src4_gpr_info, dst1_gpr_info;
   input [12:0] 		 src2_gpr_info,	src3_gpr_info, dst2_gpr_info;
   

   output [(4+2+2+4+4+2)-1:0] result;
   
   wire [3:0] 				  src1_cmp_result, src4_cmp_result, dst1_cmp_result;
   
   wire [1:0] 				  src2_cmp_result, src3_cmp_result, dst2_cmp_result;

   // Compare only valid sgprs
   assign src1_cmp_en = get_valid_sgpr(src1_gpr_info[11:0]);
   assign src2_cmp_en = get_valid_sgpr(src2_gpr_info[11:0]);
   assign src3_cmp_en = get_valid_sgpr(src3_gpr_info[11:0]);
   assign src4_cmp_en = get_valid_sgpr(src4_gpr_info[11:0]);
   assign dst1_cmp_en = get_valid_sgpr(dst1_gpr_info[11:0]);
   assign dst2_cmp_en = get_valid_sgpr(dst2_gpr_info[11:0]);

   assign src1_mask = get_mask_4w(src1_gpr_info);
   assign src2_mask = get_mask_2w(src2_gpr_info);
   assign src3_mask = get_mask_2w(src3_gpr_info);
   assign src4_mask = get_mask_4w(src4_gpr_info);
   assign dst1_mask = get_mask_4w(dst1_gpr_info);
   assign dst2_mask = get_mask_2w(dst2_gpr_info);

   assign src1_cmp_result = sgpr_compare_operands_4w(src1_cmp_en, retired_operand_addr,
				 		      src1_gpr_info[9-1:0], 
						      retired_operand_mask,
						      src1_mask);
   assign src2_cmp_result = sgpr_compare_operands_2w(src2_cmp_en, retired_operand_addr,
				 		      src2_gpr_info[9-1:0], 
						      retired_operand_mask,
						      src2_mask);
   assign src3_cmp_result = sgpr_compare_operands_2w(src3_cmp_en, retired_operand_addr,
				 		      src3_gpr_info[9-1:0], 
						      retired_operand_mask,
						      src3_mask);
   assign src4_cmp_result = sgpr_compare_operands_4w(src4_cmp_en, retired_operand_addr,
				 		      src4_gpr_info[9-1:0], 
						      retired_operand_mask,
						      src4_mask);
   assign dst1_cmp_result = sgpr_compare_operands_4w(dst1_cmp_en, retired_operand_addr,
				 		      dst1_gpr_info[9-1:0],
						      retired_operand_mask,
						      dst1_mask);
   assign dst2_cmp_result = sgpr_compare_operands_2w(dst2_cmp_en, retired_operand_addr,
				 		      dst2_gpr_info[9-1:0],
						      retired_operand_mask,
						      dst2_mask);
	

   assign result = {src1_cmp_result, src2_cmp_result, src3_cmp_result,
		    src4_cmp_result, dst1_cmp_result, dst2_cmp_result};
   


   // Function to verify if the operand is indeed a valid sgpr
   function get_valid_sgpr;
      input[11:0] sgpr_info;
      begin
	 get_valid_sgpr 
	   = (sgpr_info[11:11-2] == 3'b110)?
	     1'b1 : 1'b0;
      end
   endfunction 
   
   // Functions to generate masks
   function [3:0] get_mask_4w;
      input[13:0] sgpr_info;
      begin
	 get_mask_4w
	   = (sgpr_info[11+2]) ? 4'b1111 :
	     (sgpr_info[11+1]) ? 4'b0011 :
	     4'b0001;
      end
   endfunction

   function [1:0] get_mask_2w;
      input[12:0] sgpr_info;
      begin
	 get_mask_2w
	   = (sgpr_info[11+1]) ? 4'b0011 :
	     4'b0001;
      end
   endfunction
   
   
   // Functions that compare two operands
   function [3:0] sgpr_compare_operands_4w;
      input sb_operand_en;
      input [9-1:0] r_operand_info, sb_operand_info;
      input [3:0] 		    r_operand_mask, sb_operand_mask;
      begin
	 sgpr_compare_operands_4w 
	   = ( sb_operand_en == 1'b0 ) ? 4'b0000 :
	     ( sb_operand_info+3 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<3 :
	     ( sb_operand_info+2 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<2 :
	     ( sb_operand_info+1 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<1 :
	     ( sb_operand_info == r_operand_info ) ? sb_operand_mask & r_operand_mask :
	     ( sb_operand_info == r_operand_info+1 ) ? sb_operand_mask & r_operand_mask>>1 :
	     ( sb_operand_info == r_operand_info+2 ) ? sb_operand_mask & r_operand_mask>>2 :
	     ( sb_operand_info == r_operand_info+3 ) ? sb_operand_mask & r_operand_mask>>3 :
	     4'b0000;
      end
   endfunction

   function [1:0] sgpr_compare_operands_2w;
      input sb_operand_en;
      input [9-1:0] r_operand_info, sb_operand_info;
      input [3:0] 		    r_operand_mask;
      input [1:0] 		    sb_operand_mask;
      begin
	 sgpr_compare_operands_2w 
	   = ( sb_operand_en  == 1'b0 )? 2'b00 :
	     ( sb_operand_info+1 == r_operand_info ) ? (sb_operand_mask & {r_operand_mask[0],1'b0}) : 
	     ( sb_operand_info == r_operand_info ) ? (sb_operand_mask & r_operand_mask[1:0]) :
	     ( sb_operand_info == r_operand_info+1 ) ? (sb_operand_mask & r_operand_mask[2:1]) :
	     ( sb_operand_info == r_operand_info+2 ) ? sb_operand_mask & r_operand_mask[3:2] :
	     ( sb_operand_info == r_operand_info+3 ) ? sb_operand_mask & {1'b0,r_operand_mask[3]} :
	     2'b00;
      end
   endfunction

endmodule
module spr_dependency_table
(/*AUTOARG*/
   // Outputs
   ready_arry_spr,
   // Inputs
   f_decode_wfid, f_exec_salu_wr_wfid, f_exec_valu_wr_vcc_wfid,
   issued_wfid, f_decode_valid, f_decode_vcc_wr, f_decode_vcc_rd,
   f_decode_scc_wr, f_decode_scc_rd, f_decode_exec_rd,
   f_decode_exec_wr, f_decode_m0_rd, f_decode_m0_wr,
   f_exec_salu_wr_vcc_en, f_exec_salu_wr_exec_en,
   f_exec_salu_wr_scc_en, f_exec_salu_wr_m0_en, f_exec_valu_wr_vcc_en,
   alu_valid, lsu_valid, issued_valid, issue_lsu_vcc_wr,
   issue_lsu_scc_wr, issue_lsu_exec_wr, issue_lsu_m0_wr,
   issue_alu_vcc_wr, issue_alu_scc_wr, issue_alu_exec_wr,
   issue_alu_m0_wr, clk, rst
   );

   input[6-1:0] f_decode_wfid, f_exec_salu_wr_wfid, f_exec_valu_wr_vcc_wfid,
			   issued_wfid;
   
   input 		   f_decode_valid,
			   f_decode_vcc_wr, f_decode_vcc_rd, f_decode_scc_wr, 
			   f_decode_scc_rd, f_decode_exec_rd, f_decode_exec_wr, 
			   f_decode_m0_rd, f_decode_m0_wr, 
			   f_exec_salu_wr_vcc_en, f_exec_salu_wr_exec_en, 
			   f_exec_salu_wr_scc_en, f_exec_salu_wr_m0_en, 
			   f_exec_valu_wr_vcc_en;
 
   input 		   alu_valid, lsu_valid,
			   issued_valid, issue_lsu_vcc_wr, issue_lsu_scc_wr, 
			   issue_lsu_exec_wr, issue_lsu_m0_wr, 
			   issue_alu_vcc_wr, issue_alu_scc_wr, 
			   issue_alu_exec_wr, issue_alu_m0_wr;
 
   input 		   clk, rst;

   output [40-1:0]  ready_arry_spr;
   
   
   /**
    * Ready bits:
    * Incomming instructions:
    * If reads or writes spr and spr is busy, then mark as not ready
    * When instructions retires, set ready bits
    * 
    * Busy bits:
    * Set when instruction issue, clear when retires.
    **/
   wire[40-1:0] decode_wfid_decoded;

   decoder_6b_40b_en decode_wfid_decoder(
					    .addr_in(f_decode_wfid),
					    .en(f_decode_valid),
					    .out(decode_wfid_decoded)
					    );
   
   
   /*********************************************************************
    * EXEC dependency table                                             *
    *********************************************************************/
   wire[40-1:0] exec_ready_bits, next_exec_ready_bits,
		       exec_busy_bits, next_exec_busy_bits;

   wire [40-1:0] exec_issued_decoded;

   wire 		exec_issued_decoder_en;
   wire [40-1:0] exec_retired_salu_decoded;

   wire 		exec_decoded_instr_depends;
   
   wire [40-1:0] exec_decoded_instr_depends_decoded;
   
   decoder_6b_40b_en exec_retired_salu_decoder(
						  .addr_in(f_exec_salu_wr_wfid),
						  .en(f_exec_salu_wr_exec_en),
						  .out(exec_retired_salu_decoded)
						  );
   
   // Busy bits logic  
   dff exec_busy_bits_reg[40-1:0](
					 .q(exec_busy_bits),
					 .d(next_exec_busy_bits),
					 .clk(clk),
					 .rst(rst)
					 );

   decoder_6b_40b_en exec_issued_decoder(
					     .addr_in(issued_wfid),
					     .en(exec_issued_decoder_en),
					     .out(exec_issued_decoded)
					     );

   assign exec_issued_decoder_en = (issue_alu_exec_wr && alu_valid) | 
				       (issue_lsu_exec_wr && lsu_valid);
   
   assign next_exec_busy_bits = (  exec_busy_bits | 
				   (exec_issued_decoded)  ) & ( ~exec_retired_salu_decoded );
   
   // Ready bits logic
   dff exec_ready_bits_reg[40-1:0](
					     .q(exec_ready_bits),
					     .d(next_exec_ready_bits),
					     .clk(clk),
					     .rst(rst)
					     );

   decoder_6b_40b_en exec_decoded_instr_depends_decoder(
				 .addr_in(f_decode_wfid),
				 .en(exec_decoded_instr_depends),
				 .out(exec_decoded_instr_depends_decoded)
					     );
   
   assign exec_decoded_instr_depends = f_decode_exec_rd | f_decode_exec_wr;
   assign next_exec_ready_bits = (   decode_wfid_decoded  & ~(exec_decoded_instr_depends_decoded & next_exec_busy_bits)   ) | 
				 (   ~decode_wfid_decoded & (exec_ready_bits | exec_retired_salu_decoded)    );

   /*********************************************************************
    * M0 dependency table                                             *
    *********************************************************************/
   wire[40-1:0] m0_ready_bits, next_m0_ready_bits,
		       m0_busy_bits, next_m0_busy_bits;

   wire [40-1:0] m0_issued_decoded;

   wire 		m0_issued_decoder_en;
   wire [40-1:0] m0_retired_salu_decoded;

   wire 		m0_decoded_instr_depends;
   
   wire [40-1:0] m0_decoded_instr_depends_decoded;
   
   decoder_6b_40b_en m0_retired_salu_decoder(
						  .addr_in(f_exec_salu_wr_wfid),
						  .en(f_exec_salu_wr_m0_en),
						  .out(m0_retired_salu_decoded)
						  );
   
   // Busy bits logic  
   dff m0_busy_bits_reg[40-1:0](
					 .q(m0_busy_bits),
					 .d(next_m0_busy_bits),
					 .clk(clk),
					 .rst(rst)
					 );

   decoder_6b_40b_en m0_issued_decoder(
					     .addr_in(issued_wfid),
					     .en(m0_issued_decoder_en),
					     .out(m0_issued_decoded)
					     );

   assign m0_issued_decoder_en = (issue_alu_m0_wr && alu_valid) |
				     (issue_lsu_m0_wr && lsu_valid);
   
   assign next_m0_busy_bits = (  m0_busy_bits | 
				 (m0_issued_decoded) ) & ( ~m0_retired_salu_decoded );
   
   // Ready bits logic
   dff m0_ready_bits_reg[40-1:0](
					     .q(m0_ready_bits),
					     .d(next_m0_ready_bits),
					     .clk(clk),
					     .rst(rst)
					     );

   decoder_6b_40b_en m0_decoded_instr_depends_decoder(
				 .addr_in(f_decode_wfid),
				 .en(m0_decoded_instr_depends),
				 .out(m0_decoded_instr_depends_decoded)
					     );
   
   assign m0_decoded_instr_depends = f_decode_m0_rd | f_decode_m0_wr;
   assign next_m0_ready_bits = (   decode_wfid_decoded  & ~(m0_decoded_instr_depends_decoded & next_m0_busy_bits)   ) | 
				 (   ~decode_wfid_decoded & (m0_ready_bits | m0_retired_salu_decoded)    );

   /*********************************************************************
    * SCC dependency table                                             *
    *********************************************************************/
   wire[40-1:0] scc_ready_bits, next_scc_ready_bits,
		       scc_busy_bits, next_scc_busy_bits;

   wire [40-1:0] scc_issued_decoded;

   wire 		scc_issued_decoder_en;
   wire [40-1:0] scc_retired_salu_decoded;

   wire 		scc_decoded_instr_depends;
   
   wire [40-1:0] scc_decoded_instr_depends_decoded;
   
   decoder_6b_40b_en scc_retired_salu_decoder(
						  .addr_in(f_exec_salu_wr_wfid),
						  .en(f_exec_salu_wr_scc_en),
						  .out(scc_retired_salu_decoded)
						  );
   
   // Busy bits logic  
   dff scc_busy_bits_reg[40-1:0](
					 .q(scc_busy_bits),
					 .d(next_scc_busy_bits),
					 .clk(clk),
					 .rst(rst)
					 );

   decoder_6b_40b_en scc_issued_decoder(
					     .addr_in(issued_wfid),
					     .en(scc_issued_decoder_en),
					     .out(scc_issued_decoded)
					     );

   assign scc_issued_decoder_en = (issue_alu_scc_wr && alu_valid) |
				      (issue_lsu_scc_wr && lsu_valid);
   
   assign next_scc_busy_bits = (  scc_busy_bits | 
				  (scc_issued_decoded) ) & ( ~scc_retired_salu_decoded );
   
   // Ready bits logic
   dff scc_ready_bits_reg[40-1:0](
					     .q(scc_ready_bits),
					     .d(next_scc_ready_bits),
					     .clk(clk),
					     .rst(rst)
					     );

   decoder_6b_40b_en scc_decoded_instr_depends_decoder(
				 .addr_in(f_decode_wfid),
				 .en(scc_decoded_instr_depends),
				 .out(scc_decoded_instr_depends_decoded)
					     );
   
   assign scc_decoded_instr_depends = f_decode_scc_rd | f_decode_scc_wr;
   assign next_scc_ready_bits = (   decode_wfid_decoded  & ~(scc_decoded_instr_depends_decoded & next_scc_busy_bits)   ) | 
				 (   ~decode_wfid_decoded & (scc_ready_bits | scc_retired_salu_decoded)    );

 
    /*********************************************************************
    * VCC dependency table                                             *
    *********************************************************************/
   wire[40-1:0] vcc_ready_bits, next_vcc_ready_bits,
		       vcc_busy_bits, next_vcc_busy_bits;

   wire [40-1:0] vcc_issued_decoded;

   wire 		vcc_issued_decoder_en;
   wire [40-1:0] vcc_retired_salu_decoded, vcc_retired_valu_decoded;

   wire 		vcc_decoded_instr_depends;
   
   wire [40-1:0] vcc_decoded_instr_depends_decoded;
   
   decoder_6b_40b_en vcc_retired_salu_decoder(
						  .addr_in(f_exec_salu_wr_wfid),
						  .en(f_exec_salu_wr_vcc_en),
						  .out(vcc_retired_salu_decoded)
						  );

   decoder_6b_40b_en vcc_retired_valu_decoder(
						  .addr_in(f_exec_valu_wr_vcc_wfid),
						  .en(f_exec_valu_wr_vcc_en),
						  .out(vcc_retired_valu_decoded)
						  );
   
   // Busy bits logic  
   dff vcc_busy_bits_reg[40-1:0](
					 .q(vcc_busy_bits),
					 .d(next_vcc_busy_bits),
					 .clk(clk),
					 .rst(rst)
					 );

   decoder_6b_40b_en vcc_issued_decoder(
					.addr_in(issued_wfid),
					.en(vcc_issued_decoder_en),
					.out(vcc_issued_decoded)
					     );

   assign vcc_issued_decoder_en = (issue_alu_vcc_wr && alu_valid) |
				  (issue_lsu_vcc_wr && lsu_valid);
   
   assign next_vcc_busy_bits = (  vcc_busy_bits | 
				  (vcc_issued_decoded) ) & ( ~vcc_retired_salu_decoded & ~vcc_retired_valu_decoded );
   
   // Ready bits logic
   dff vcc_ready_bits_reg[40-1:0](
					     .q(vcc_ready_bits),
					     .d(next_vcc_ready_bits),
					     .clk(clk),
					     .rst(rst)
					     );

   decoder_6b_40b_en vcc_decoded_instr_depends_decoder(
				 .addr_in(f_decode_wfid),
				 .en(vcc_decoded_instr_depends),
				 .out(vcc_decoded_instr_depends_decoded)
					     );
   
   assign vcc_decoded_instr_depends = f_decode_vcc_rd | f_decode_vcc_wr;
   assign next_vcc_ready_bits = (   decode_wfid_decoded  & ~(vcc_decoded_instr_depends_decoded & next_vcc_busy_bits)   ) | 
				 (   ~decode_wfid_decoded & (vcc_ready_bits | vcc_retired_salu_decoded | vcc_retired_valu_decoded)    );

   assign ready_arry_spr = vcc_ready_bits & scc_ready_bits & exec_ready_bits & m0_ready_bits;
   
endmodule
module valid_entry
  (/*AUTOARG*/
   // Outputs
   valid_entry_out,
   // Inputs
   clk, rst, f_decode_valid, f_decode_wf_halt, f_decode_barrier,
   f_salu_branch_en, f_salu_branch_taken, issued_valid,
   f_decode_waitcnt, f_decode_wfid, issued_wfid, f_salu_branch_wfid
   );

   // Valid entry is set at decode and cleared at issue

   input clk,rst;
   input f_decode_valid, f_decode_wf_halt, f_decode_barrier, 
	 f_salu_branch_en, f_salu_branch_taken, issued_valid,
	 f_decode_waitcnt;
   input [6-1:0] f_decode_wfid, issued_wfid, 
			     f_salu_branch_wfid;
   
   wire 		     decode_init_en;
   wire [40-1:0]     decoded_init_instr, decoded_issued,
			     decoded_branch_taken,
			     next_valid_entry;

   output [40-1:0]   valid_entry_out;

   decoder_6b_40b_en init_instr_decoder(
					.addr_in(f_decode_wfid),
					.out(decoded_init_instr),
					.en(decode_init_en)
					);

   decoder_6b_40b_en instr_issued_decoder(
				       .addr_in(issued_wfid),
				       .out(decoded_issued),
				       .en(issued_valid)
				       );

   decoder_6b_40b_en branch_taken_decoder(
				       .addr_in(f_salu_branch_wfid),
				       .out(decoded_branch_taken),
				       .en((f_salu_branch_en & f_salu_branch_taken))
				       );

   dff valid_reg[40-1:0] 
     (
      .q(valid_entry_out),
      .d(next_valid_entry),
      .clk(clk),
      .rst(rst)
      );

   assign decode_init_en = f_decode_valid & ~f_decode_wf_halt & ~f_decode_barrier & ~f_decode_waitcnt;
   
   assign next_valid_entry = (valid_entry_out | (decoded_init_instr)) & 
			     ~(decoded_issued | decoded_branch_taken);
   
   
endmodule
module vgpr_busy_table_decoder
  (
   vgpr_addr,
   vgpr_valid,
   
   output_decoded
   );
   parameter MAX_NUMBER_WORDS = 4;
   
   input[10-1:0] vgpr_addr;
   input [MAX_NUMBER_WORDS-1:0] vgpr_valid;

   output [1024-1:0] 	output_decoded;
   wire [1024+4-1:0] 	output_decoded_2;
   
   assign output_decoded_2 = (|vgpr_valid) ? vgpr_valid << vgpr_addr : 1028'd0;
   assign output_decoded = output_decoded_2[1024-1:0] | { {(1024-4){1'b0}},output_decoded_2[1024+4-1:1024]};
endmodule
module vgpr_busy_table_mux
  (
   in,
   select,
   out
   );
   parameter MAX_NUMBER_WORDS = 4;
   
   input[1024-1:0] in;
   wire[1024+4-1:0] in_rotated;
   input [10-1:0] select;

   output [MAX_NUMBER_WORDS-1:0] out;

   assign in_rotated = {in[3:0], in};
   assign out = in_rotated >> select;
endmodule
module vgpr_comparator
  (/*AUTOARG*/
   // Outputs
   result,
   // Inputs
   retired_operand_mask, retired_operand_addr, src1_gpr_info,
   src4_gpr_info, dst1_gpr_info, src2_gpr_info, src3_gpr_info,
   dst2_gpr_info
   );

   wire  src1_cmp_en, src2_cmp_en, src3_cmp_en, src4_cmp_en,
	 dst1_cmp_en, dst2_cmp_en;
   
   
   input [3:0] retired_operand_mask;
   wire [3:0]  src1_mask, src4_mask, dst1_mask;
   wire [2:0]  src2_mask, src3_mask, dst2_mask;
   
   
   input [10-1:0] retired_operand_addr;
   input [13:0] 		 src1_gpr_info, src4_gpr_info, dst1_gpr_info;
   input [12:0] 		 src2_gpr_info,	src3_gpr_info, dst2_gpr_info;
   

   output [(4+2+2+4+4+2)-1:0] result;
   
   wire [3:0] 				  src1_cmp_result, src4_cmp_result, dst1_cmp_result;
   
   wire [1:0] 				  src2_cmp_result, src3_cmp_result, dst2_cmp_result;

   // Compare only valid vgprs
   assign src1_cmp_en = get_valid_vgpr(src1_gpr_info[11:0]);
   assign src2_cmp_en = get_valid_vgpr(src2_gpr_info[11:0]);
   assign src3_cmp_en = get_valid_vgpr(src3_gpr_info[11:0]);
   assign src4_cmp_en = get_valid_vgpr(src4_gpr_info[11:0]);
   assign dst1_cmp_en = get_valid_vgpr(dst1_gpr_info[11:0]);
   assign dst2_cmp_en = get_valid_vgpr(dst2_gpr_info[11:0]);

   assign src1_mask = get_mask_4w(src1_gpr_info);
   assign src2_mask = get_mask_2w(src2_gpr_info);
   assign src3_mask = get_mask_2w(src3_gpr_info);
   assign src4_mask = get_mask_4w(src4_gpr_info);
   assign dst1_mask = get_mask_4w(dst1_gpr_info);
   assign dst2_mask = get_mask_2w(dst2_gpr_info);

   assign src1_cmp_result = vgpr_compare_operands_4w(src1_cmp_en, retired_operand_addr,
				 		   src1_gpr_info[10-1:0], 
						   retired_operand_mask,
						   src1_mask);
   assign src2_cmp_result = vgpr_compare_operands_2w(src2_cmp_en, retired_operand_addr,
				 		   src2_gpr_info[10-1:0], 
						   retired_operand_mask,
						   src2_mask);
   assign src3_cmp_result = vgpr_compare_operands_2w(src3_cmp_en, retired_operand_addr,
				 		   src3_gpr_info[10-1:0], 
						   retired_operand_mask,
						   src3_mask);
   assign src4_cmp_result = vgpr_compare_operands_4w(src4_cmp_en, retired_operand_addr,
				 		   src4_gpr_info[10-1:0], 
						   retired_operand_mask,
						   src4_mask);
   assign dst1_cmp_result = vgpr_compare_operands_4w(dst1_cmp_en, retired_operand_addr,
				 		   dst1_gpr_info[10-1:0],
						   retired_operand_mask,
						   dst1_mask);
   assign dst2_cmp_result = vgpr_compare_operands_2w(dst2_cmp_en, retired_operand_addr,
				 		   dst2_gpr_info[10-1:0],
						   retired_operand_mask,
						   dst2_mask);
	
   assign result = {src1_cmp_result, src2_cmp_result, src3_cmp_result,
		    src4_cmp_result, dst1_cmp_result, dst2_cmp_result};
   


   // Function to verify if the operand is indeed a valid vgpr
   function get_valid_vgpr;
      input[11:0] vgpr_info;
      begin
	 get_valid_vgpr 
	   = (vgpr_info[11:11-1] == 2'b10)?
	     1'b1 : 1'b0;
      end
   endfunction 
   
   // Functions to generate masks
   function [3:0] get_mask_4w;
      input[13:0] vgpr_info;
      begin
	 get_mask_4w
	   = (vgpr_info[11+2]) ? 4'b1111 :
	     (vgpr_info[11+1]) ? 4'b0011 :
	     4'b0001;
      end
   endfunction

   function [1:0] get_mask_2w;
      input[12:0] vgpr_info;
      begin
	 get_mask_2w
	   = (vgpr_info[11+1]) ? 4'b0011 :
	     4'b0001;
      end
   endfunction
   
   
   // Functions that compare two operands
   function [3:0] vgpr_compare_operands_4w;
      input sb_operand_en;
      input [10-1:0] r_operand_info, sb_operand_info;
      input [3:0] 		    r_operand_mask, sb_operand_mask;
      begin
	 vgpr_compare_operands_4w 
	   = ( sb_operand_en == 1'b0 ) ? 4'b0000 :
	     ( sb_operand_info+3 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<3 :
	     ( sb_operand_info+2 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<2 :
	     ( sb_operand_info+1 == r_operand_info ) ? sb_operand_mask & r_operand_mask<<1 :
	     ( sb_operand_info == r_operand_info ) ? sb_operand_mask & r_operand_mask :
	     ( sb_operand_info == r_operand_info+1 ) ? sb_operand_mask & r_operand_mask>>1 :
	     ( sb_operand_info == r_operand_info+2 ) ? sb_operand_mask & r_operand_mask>>2 :
	     ( sb_operand_info == r_operand_info+3 ) ? sb_operand_mask & r_operand_mask>>3 :
	     4'b0000;
      end
   endfunction

   function [1:0] vgpr_compare_operands_2w;
      input sb_operand_en;
      input [10-1:0] r_operand_info, sb_operand_info;
      input [3:0] 		    r_operand_mask;
      input [1:0] 		    sb_operand_mask;
      begin
	 vgpr_compare_operands_2w 
	   = ( sb_operand_en  == 1'b0 )? 2'b00 :
	     ( sb_operand_info+1 == r_operand_info ) ? (sb_operand_mask & {r_operand_mask[0],1'b0}) : 
	     ( sb_operand_info == r_operand_info ) ? (sb_operand_mask & r_operand_mask[1:0]) :
	     ( sb_operand_info == r_operand_info+1 ) ? (sb_operand_mask & r_operand_mask[2:1]) :
	     ( sb_operand_info == r_operand_info+2 ) ? sb_operand_mask & r_operand_mask[3:2] :
	     ( sb_operand_info == r_operand_info+3 ) ? sb_operand_mask & {1'b0,r_operand_mask[3]} :
	     2'b00;
      end
   endfunction

endmodule
module ds_addr_calc (
 lds_base,
 in_addr,
 out_addr
);

input [15:0] lds_base;
input [31:0] in_addr;
output [31:0] out_addr;

assign out_addr = {16'b0,lds_base} + in_addr;

endmodule 










module lsu_addr_calculator(
  in_vector_source_b,
  in_scalar_source_a,
  in_scalar_source_b,
  in_opcode,
  in_lds_base,
  in_imm_value0,
  out_ld_st_addr,
  out_gm_or_lds
);

input [2047:0] in_vector_source_b;
input [127:0] in_scalar_source_a;
input [31:0] in_scalar_source_b;
input [31:0] in_opcode;
input [15:0] in_lds_base;
input [15:0] in_imm_value0;

output [2047:0] out_ld_st_addr;
output out_gm_or_lds;



reg [63:0] out_exec_value;
reg [2047:0] out_ld_st_addr;
reg out_gm_or_lds;
wire [383:0] thread_id;
wire [2047:0] mtbuf_address;
wire [2047:0]ds_address;

always @(*)
begin
  casex(in_opcode[31:24])
    8'h01:
      begin
        //Only 32 bits of the result is the address
        //Other bits are ignored since exec mask is 64'd1
        out_ld_st_addr <= in_scalar_source_a[47:0] + (in_opcode[23] ? (in_imm_value0 * 4) : in_scalar_source_b);
        out_gm_or_lds <= 1'b0;
      end
    8'h02:
      begin
        out_ld_st_addr <= ds_address;
        out_gm_or_lds <= 1'b1;
      end
    8'h04:
      begin
        // We suffer a architectural limitation here wherein we cannot support
        // both an offset and index value as inputs into the address
        // calculation, as that would require two vector register reads
        // instead of the one that we currently do. Proposed future solution
        // is to have the LSU be able to utilize two read ports to the VGPR to
        // facilitate two reads in a cycle instead of just one.
        out_ld_st_addr <= ({in_opcode[12],in_opcode[11]} == 2'b11) ? {2048{1'bx}} : mtbuf_address;
        out_gm_or_lds <= 1'b0;
      end
    default:
      begin
        out_ld_st_addr <= {2048{1'bx}};
        out_gm_or_lds <= 1'b0;
      end
  endcase
end

mtbuf_addr_calc mtbuf_address_calc[63:0](
  .out_addr(mtbuf_address),
  .vector_source_b(in_vector_source_b),
  .scalar_source_a(in_scalar_source_a),
  .scalar_source_b(in_scalar_source_b),
  .imm_value0(in_imm_value0),
  .idx_en(in_opcode[12]),
  .off_en(in_opcode[11]),
  .tid(thread_id)
);

ds_addr_calc ds_address_calc[63:0](
  .lds_base(in_lds_base),
  .in_addr(in_vector_source_b),
  .out_addr(ds_address)
);


// %%start_veriperl
// my $i;
// my $high;
// my $low;
// for($i=0; $i<64; $i=$i+1)
// {
//   $high = (($i+1)*6) - 1;
//   $low = $i * 6;
//   print "assign thread_id[$high:$low] = `ADD_TID_ENABLE ? 6'd$i : 6'd0;\n";
// }
// %%stop_veriperl
assign thread_id[5:0] = in_scalar_source_a[119] ? 6'd0 : 6'd0;
assign thread_id[11:6] = in_scalar_source_a[119] ? 6'd1 : 6'd0;
assign thread_id[17:12] = in_scalar_source_a[119] ? 6'd2 : 6'd0;
assign thread_id[23:18] = in_scalar_source_a[119] ? 6'd3 : 6'd0;
assign thread_id[29:24] = in_scalar_source_a[119] ? 6'd4 : 6'd0;
assign thread_id[35:30] = in_scalar_source_a[119] ? 6'd5 : 6'd0;
assign thread_id[41:36] = in_scalar_source_a[119] ? 6'd6 : 6'd0;
assign thread_id[47:42] = in_scalar_source_a[119] ? 6'd7 : 6'd0;
assign thread_id[53:48] = in_scalar_source_a[119] ? 6'd8 : 6'd0;
assign thread_id[59:54] = in_scalar_source_a[119] ? 6'd9 : 6'd0;
assign thread_id[65:60] = in_scalar_source_a[119] ? 6'd10 : 6'd0;
assign thread_id[71:66] = in_scalar_source_a[119] ? 6'd11 : 6'd0;
assign thread_id[77:72] = in_scalar_source_a[119] ? 6'd12 : 6'd0;
assign thread_id[83:78] = in_scalar_source_a[119] ? 6'd13 : 6'd0;
assign thread_id[89:84] = in_scalar_source_a[119] ? 6'd14 : 6'd0;
assign thread_id[95:90] = in_scalar_source_a[119] ? 6'd15 : 6'd0;
assign thread_id[101:96] = in_scalar_source_a[119] ? 6'd16 : 6'd0;
assign thread_id[107:102] = in_scalar_source_a[119] ? 6'd17 : 6'd0;
assign thread_id[113:108] = in_scalar_source_a[119] ? 6'd18 : 6'd0;
assign thread_id[119:114] = in_scalar_source_a[119] ? 6'd19 : 6'd0;
assign thread_id[125:120] = in_scalar_source_a[119] ? 6'd20 : 6'd0;
assign thread_id[131:126] = in_scalar_source_a[119] ? 6'd21 : 6'd0;
assign thread_id[137:132] = in_scalar_source_a[119] ? 6'd22 : 6'd0;
assign thread_id[143:138] = in_scalar_source_a[119] ? 6'd23 : 6'd0;
assign thread_id[149:144] = in_scalar_source_a[119] ? 6'd24 : 6'd0;
assign thread_id[155:150] = in_scalar_source_a[119] ? 6'd25 : 6'd0;
assign thread_id[161:156] = in_scalar_source_a[119] ? 6'd26 : 6'd0;
assign thread_id[167:162] = in_scalar_source_a[119] ? 6'd27 : 6'd0;
assign thread_id[173:168] = in_scalar_source_a[119] ? 6'd28 : 6'd0;
assign thread_id[179:174] = in_scalar_source_a[119] ? 6'd29 : 6'd0;
assign thread_id[185:180] = in_scalar_source_a[119] ? 6'd30 : 6'd0;
assign thread_id[191:186] = in_scalar_source_a[119] ? 6'd31 : 6'd0;
assign thread_id[197:192] = in_scalar_source_a[119] ? 6'd32 : 6'd0;
assign thread_id[203:198] = in_scalar_source_a[119] ? 6'd33 : 6'd0;
assign thread_id[209:204] = in_scalar_source_a[119] ? 6'd34 : 6'd0;
assign thread_id[215:210] = in_scalar_source_a[119] ? 6'd35 : 6'd0;
assign thread_id[221:216] = in_scalar_source_a[119] ? 6'd36 : 6'd0;
assign thread_id[227:222] = in_scalar_source_a[119] ? 6'd37 : 6'd0;
assign thread_id[233:228] = in_scalar_source_a[119] ? 6'd38 : 6'd0;
assign thread_id[239:234] = in_scalar_source_a[119] ? 6'd39 : 6'd0;
assign thread_id[245:240] = in_scalar_source_a[119] ? 6'd40 : 6'd0;
assign thread_id[251:246] = in_scalar_source_a[119] ? 6'd41 : 6'd0;
assign thread_id[257:252] = in_scalar_source_a[119] ? 6'd42 : 6'd0;
assign thread_id[263:258] = in_scalar_source_a[119] ? 6'd43 : 6'd0;
assign thread_id[269:264] = in_scalar_source_a[119] ? 6'd44 : 6'd0;
assign thread_id[275:270] = in_scalar_source_a[119] ? 6'd45 : 6'd0;
assign thread_id[281:276] = in_scalar_source_a[119] ? 6'd46 : 6'd0;
assign thread_id[287:282] = in_scalar_source_a[119] ? 6'd47 : 6'd0;
assign thread_id[293:288] = in_scalar_source_a[119] ? 6'd48 : 6'd0;
assign thread_id[299:294] = in_scalar_source_a[119] ? 6'd49 : 6'd0;
assign thread_id[305:300] = in_scalar_source_a[119] ? 6'd50 : 6'd0;
assign thread_id[311:306] = in_scalar_source_a[119] ? 6'd51 : 6'd0;
assign thread_id[317:312] = in_scalar_source_a[119] ? 6'd52 : 6'd0;
assign thread_id[323:318] = in_scalar_source_a[119] ? 6'd53 : 6'd0;
assign thread_id[329:324] = in_scalar_source_a[119] ? 6'd54 : 6'd0;
assign thread_id[335:330] = in_scalar_source_a[119] ? 6'd55 : 6'd0;
assign thread_id[341:336] = in_scalar_source_a[119] ? 6'd56 : 6'd0;
assign thread_id[347:342] = in_scalar_source_a[119] ? 6'd57 : 6'd0;
assign thread_id[353:348] = in_scalar_source_a[119] ? 6'd58 : 6'd0;
assign thread_id[359:354] = in_scalar_source_a[119] ? 6'd59 : 6'd0;
assign thread_id[365:360] = in_scalar_source_a[119] ? 6'd60 : 6'd0;
assign thread_id[371:366] = in_scalar_source_a[119] ? 6'd61 : 6'd0;
assign thread_id[377:372] = in_scalar_source_a[119] ? 6'd62 : 6'd0;
assign thread_id[383:378] = in_scalar_source_a[119] ? 6'd63 : 6'd0;

endmodule
module lsu_op_manager
(
    lsu_wfid,
    instr_pc,
    
    mem_op_cnt,
    mem_op_rd,
    mem_op_wr,
    mem_gpr,
    gm_or_lds,
    
    sgpr_wr_mask,
    gpr_op_depth,
    exec_mask,
    
    mem_in_addr,
    
    mem_ack,
    mem_rd_data,
    
    vgpr_source1_data,
    
    free_mem_slots,
    
    decoded_sgpr_source1_rd_en,
    decoded_sgpr_source2_rd_en,
    decoded_sgpr_source1_addr,
    decoded_sgpr_source2_addr,
    
    decoded_vgpr_source2_rd_en,
    decoded_vgpr_source1_addr,
    decoded_vgpr_source2_addr,
    
    decoded_dest_addr,
    
    sgpr_dest_data, sgpr_dest_wr_en, sgpr_dest_addr,
    
    vgpr_dest_data,
    vgpr_dest_wr_en,
    vgpr_wr_mask,
    vgpr_dest_addr,
    
    lsu_rdy,
    lsu_done, lsu_done_wfid,
    sgpr_instr_done, sgpr_instr_done_wfid,
    vgpr_instr_done, vgpr_instr_done_wfid,
    retire_pc,
    retire_gm_or_lds,
    tracemon_mem_addr,
    
    mem_rd_en,
    mem_wr_en,
    mem_out_addr,
    mem_wr_data,
    mem_tag_req,
    mem_gm_or_lds,
    
    sgpr_source1_rd_en,
    sgpr_source2_rd_en,
    sgpr_source1_addr,
    sgpr_source2_addr,
    
    vgpr_source1_rd_en,
    vgpr_source2_rd_en,
    vgpr_source1_addr,
    vgpr_source2_addr,
    
    clk,
    rst
);

parameter MEMORY_BUS_WIDTH = 32;
parameter MEM_SLOTS = 1;

input [5:0] lsu_wfid;   // wavefront ID, need to figure out what I'm going to do with it
input [31:0] instr_pc;

input [5:0] mem_op_cnt; // Number of memory operations needed per register row
input mem_op_rd;    // Indicates this is a memory read operation
input mem_op_wr;    // Indicates this is a memory write operation
input mem_gpr; // Indicates whether to write to SGPR (0) or VGPR (1)
input gm_or_lds;

input [3:0] sgpr_wr_mask;   // Indicates how wide the write to the SGPR will be

input [1:0] gpr_op_depth;   // Indicates how many GPR rows need to be operated on

input [63:0] exec_mask; // Indicates whether to skip a particular address

input [2047:0] mem_in_addr;
input mem_ack;
input [MEMORY_BUS_WIDTH-1:0] mem_rd_data;

input [2047:0] vgpr_source1_data;

input [MEM_SLOTS-1:0] free_mem_slots;

input decoded_sgpr_source1_rd_en;
input decoded_sgpr_source2_rd_en;
input [8:0] decoded_sgpr_source1_addr;
input [8:0] decoded_sgpr_source2_addr;

//input decoded_vgpr_source1_rd_en;
input decoded_vgpr_source2_rd_en;
input [9:0] decoded_vgpr_source1_addr;
input [9:0] decoded_vgpr_source2_addr;

input [11:0] decoded_dest_addr;

input clk;
input rst;

output sgpr_source1_rd_en;
output sgpr_source2_rd_en;
output [8:0] sgpr_source1_addr;
output [8:0] sgpr_source2_addr;

output vgpr_source1_rd_en;
output vgpr_source2_rd_en;
output [9:0] vgpr_source1_addr;
output [9:0] vgpr_source2_addr;

output [127:0] sgpr_dest_data;
output [8:0] sgpr_dest_addr;
output [3:0] sgpr_dest_wr_en;

output [2047:0] vgpr_dest_data;
output [9:0] vgpr_dest_addr;
output vgpr_dest_wr_en;
output [63:0] vgpr_wr_mask;

output mem_rd_en;
output mem_wr_en;
output [31:0] mem_out_addr;
output [MEMORY_BUS_WIDTH-1:0] mem_wr_data;
output [6:0] mem_tag_req;
output mem_gm_or_lds;

output lsu_rdy;
output lsu_done;
output sgpr_instr_done;
output vgpr_instr_done;

output [5:0] lsu_done_wfid;
output [5:0] sgpr_instr_done_wfid;
output [5:0] vgpr_instr_done_wfid;

output [31:0] retire_pc;
output retire_gm_or_lds;
output [2047:0] tracemon_mem_addr;

localparam IDLE_STATE = 4'b0000;
localparam ADDR_CALC_STATE = 4'b0001;
localparam RD_STATE = 4'b0010;              // Read from memory, write to register
localparam RD_REG_WR_STATE = 4'b0011;       // Write the data we've read from memory to the registers
localparam WR_REG_INIT_RD_STATE = 4'b0100;  // Due to the cycle delay need to initiate a read first
localparam WR_REG_RD_STATE = 4'b0101;       // Before we can write to memory we need to read data in from the registers
localparam WR_STATE = 4'b0110;              // Read from register, write to memory
localparam WR_REG_INC_STATE = 4'b0111;      // Increment to next register row
localparam SIGNAL_DONE_STATE = 4'b1000;

reg [5:0] current_wfid;
reg [5:0] current_wfid_next;
reg [31:0] current_pc;
reg [31:0] current_pc_next;

reg [3:0] lsu_state;
reg [3:0] lsu_state_next;
reg lsu_rd_wr; // 0 for read, 1 for write
reg lsu_rd_wr_next;

reg [5:0] mem_op_cnt_reg;
reg [5:0] mem_op_cnt_reg_next;
reg [6:0] mem_op_cnter;
reg [6:0] mem_op_cnter_next;

reg [2047:0] mem_in_addr_reg;
reg [2047:0] mem_in_addr_reg_next;
reg [2047:0] mem_base_addr_reg;
reg [2047:0] mem_base_addr_reg_next;

reg [31:0] mem_addr_offset;
reg [31:0] mem_addr_offset_next;

reg [2047:0] tracemon_mem_addr_reg;
reg [2047:0] tracemon_mem_addr_reg_next;

reg gm_or_lds_reg;
reg gm_or_lds_reg_next;

reg [1:0] gpr_op_depth_reg;
reg [1:0] gpr_op_depth_next;
reg [1:0] gpr_op_depth_cntr;
reg [1:0] gpr_op_depth_cntr_next;

reg [2047:0] mem_data_buffer;
reg [2047:0] mem_data_buffer_next_flat;
reg [31:0] mem_data_buffer_next [0:63];

reg [5:0] mem_data_offset;
reg [5:0] mem_data_offset_next;

reg mem_rd_en_reg;
reg mem_wr_en_reg;

reg sgpr_op;
reg sgpr_op_next;
reg vgpr_op;
reg vgpr_op_next;
reg gpr_wr;

// This module also handles routing of read requests to the VGPR and SGPR
reg muxed_sgpr_source1_rd_en;
reg muxed_sgpr_source2_rd_en;
reg [8:0] muxed_sgpr_source1_addr;
reg [8:0] muxed_sgpr_source2_addr;

reg muxed_vgpr_source1_rd_en;
reg muxed_vgpr_source2_rd_en;
reg [9:0] muxed_vgpr_source1_addr;
reg [9:0] muxed_vgpr_source2_addr;

reg [9:0] vgpr_source1_addr_reg;
reg [9:0] vgpr_source1_addr_reg_next;

reg [11:0] gpr_dest_addr;
reg [11:0] gpr_dest_addr_next;
reg [3:0] sgpr_wr_mask_reg;
reg [3:0] sgpr_wr_mask_reg_next;

reg [63:0] exec_mask_reg;
reg [63:0] exec_mask_reg_next;
reg [63:0] exec_mask_base_reg;
reg [63:0] exec_mask_base_reg_next;

always@(posedge clk) begin
    if(rst) begin
        current_wfid <= 6'd0;
        current_pc <= 32'd0;
        lsu_state <= IDLE_STATE;
        lsu_rd_wr <= 1'b0;
        mem_op_cnt_reg <= 6'd0;
        mem_op_cnter <= 7'd0;
        mem_in_addr_reg <= 2048'd0;
        mem_base_addr_reg <= 2048'd0;
        mem_addr_offset <= 32'd0;
        mem_data_buffer <= 2048'd0;
        mem_data_offset <= 6'd0;
        tracemon_mem_addr_reg <= 2048'd0;
        sgpr_op <= 1'b0;
        vgpr_op <= 1'b0;
        gpr_dest_addr <= 12'd0;
        gpr_op_depth_reg <= 2'd0;
        gpr_op_depth_cntr <= 2'd0;
        sgpr_wr_mask_reg <= 4'd0;
        exec_mask_reg <= 64'd0;
        exec_mask_base_reg <= 64'd0;
        vgpr_source1_addr_reg <= 10'd0;
        gm_or_lds_reg <= 1'b0;
    end
    else begin
        current_wfid <= current_wfid_next;
        current_pc <= current_pc_next;
        lsu_state <= lsu_state_next;
        lsu_rd_wr <= lsu_rd_wr_next;
        mem_op_cnt_reg <= mem_op_cnt_reg_next;
        mem_op_cnter <= mem_op_cnter_next;
        mem_in_addr_reg <= mem_in_addr_reg_next;
        mem_base_addr_reg <= mem_base_addr_reg_next;
        mem_addr_offset <= mem_addr_offset_next;
        mem_data_buffer <= mem_data_buffer_next_flat;
        tracemon_mem_addr_reg <= tracemon_mem_addr_reg_next;
        sgpr_op <= sgpr_op_next;
        vgpr_op <= vgpr_op_next;
        gpr_dest_addr <= gpr_dest_addr_next;
        gpr_op_depth_reg <= gpr_op_depth_next;
        gpr_op_depth_cntr <= gpr_op_depth_cntr_next;
        sgpr_wr_mask_reg <= sgpr_wr_mask_reg_next;
        exec_mask_reg <= exec_mask_reg_next;
        exec_mask_base_reg <= exec_mask_base_reg_next;
        vgpr_source1_addr_reg <= vgpr_source1_addr_reg_next;
        gm_or_lds_reg <= gm_or_lds_reg_next;
    end
end

always@(*) begin
    // LSU state/operation signals
    lsu_state_next <= lsu_state;
    lsu_rd_wr_next <= lsu_rd_wr;
    
    mem_op_cnt_reg_next <= mem_op_cnt_reg;
    mem_op_cnter_next <= mem_op_cnter;
    
    // Memory interface signals
    mem_in_addr_reg_next <= mem_in_addr_reg;
    mem_base_addr_reg_next <= mem_base_addr_reg;
    mem_addr_offset_next <= mem_addr_offset;
    mem_rd_en_reg <= 1'b0;
    mem_wr_en_reg <= 1'b0;
    
    tracemon_mem_addr_reg_next <= tracemon_mem_addr_reg;
    
    begin : MEM_BUFFER_MAP
        integer i;
        for(i = 0; i < 64; i = i + 1) begin
            mem_data_buffer_next[i] <= mem_data_buffer[32 * i+:32];
            mem_data_buffer_next_flat[32 * i+:32] <= mem_data_buffer_next[i];
        end
    end
    
    // Register bank control signals
    sgpr_wr_mask_reg_next <= sgpr_wr_mask_reg;
    exec_mask_reg_next <= exec_mask_reg;
    exec_mask_base_reg_next <= exec_mask_base_reg;
    
    sgpr_op_next <= sgpr_op;
    vgpr_op_next <= vgpr_op;
    gpr_wr <= 1'b0;
    current_wfid_next <= current_wfid;
    current_pc_next <= current_pc;
    gpr_op_depth_next <= gpr_op_depth_reg;
    gpr_op_depth_cntr_next <= gpr_op_depth_cntr;
    
    vgpr_source1_addr_reg_next <= vgpr_source1_addr_reg;
    
    muxed_sgpr_source1_rd_en <= 1'b0;
    muxed_sgpr_source2_rd_en <= 1'b0;
    muxed_sgpr_source1_addr <= 9'bXXXXXXXXX;
    muxed_sgpr_source2_addr <= 9'bXXXXXXXXX;
    //muxed_sgpr_dest_addr <= 9'bXXXXXXXXX;

    muxed_vgpr_source1_rd_en <= 1'b0;
    muxed_vgpr_source2_rd_en <= 1'b0;
    muxed_vgpr_source1_addr <= 10'bXXXXXXXXXX;
    muxed_vgpr_source2_addr <= 10'bXXXXXXXXXX;
    
    gpr_dest_addr_next <= gpr_dest_addr;
    
    gm_or_lds_reg_next <= gm_or_lds_reg;
    
    case(lsu_state)
        IDLE_STATE: begin
            lsu_rd_wr_next <= 1'b0;
            if(mem_op_rd | mem_op_wr) begin
                current_wfid_next <= lsu_wfid;
                current_pc_next <= instr_pc;
                lsu_state_next <= ADDR_CALC_STATE;
                mem_op_cnt_reg_next <= mem_op_cnt;
                mem_op_cnter_next <= 6'd0;
                mem_addr_offset_next <= 32'd0;
                
                // Route SGPR read signals from opcode decoder
                muxed_sgpr_source1_rd_en <= decoded_sgpr_source1_rd_en;
                muxed_sgpr_source2_rd_en <= decoded_sgpr_source2_rd_en;
                muxed_sgpr_source1_addr <= decoded_sgpr_source1_addr;
                muxed_sgpr_source2_addr <= decoded_sgpr_source2_addr;
                
                // Route VGPR read signals from opcode decoder
                muxed_vgpr_source2_rd_en <= decoded_vgpr_source2_rd_en;
                muxed_vgpr_source2_addr <= decoded_vgpr_source2_addr;
                
                gpr_op_depth_next <= gpr_op_depth;
            end
            
            // There are no SGPR to memory instructions so don't need to check
            // where the data is coming from, it's always the VGPR for writes.
            if(mem_op_wr) begin
                lsu_rd_wr_next <= 1'b1;
                vgpr_source1_addr_reg_next <= decoded_vgpr_source1_addr;
            end
            
            // These signals technically could be only updated when we get a
            // memory operation, but there's no real point to conditionalize
            // them.
            exec_mask_reg_next <= exec_mask;
            exec_mask_base_reg_next <= exec_mask;
            sgpr_wr_mask_reg_next <= sgpr_wr_mask;
            
            if(mem_op_rd) begin
                sgpr_op_next <= ~mem_gpr;
                vgpr_op_next <= mem_gpr;
                gpr_dest_addr_next <= decoded_dest_addr;
            end
        end
        // Get calculated address values
        ADDR_CALC_STATE: begin
            lsu_state_next <= RD_STATE;
            mem_in_addr_reg_next <= mem_in_addr;
            mem_base_addr_reg_next <= mem_in_addr;
            tracemon_mem_addr_reg_next <= mem_in_addr;
            gpr_op_depth_cntr_next <= 2'd0;
            mem_op_cnter_next <= 6'd0;
            if(lsu_rd_wr) begin
                lsu_state_next <= WR_REG_INIT_RD_STATE;
            end
            gm_or_lds_reg_next <= gm_or_lds;
        end
        
        RD_STATE: begin
            mem_rd_en_reg <= 1'b1;
            if(vgpr_op & ~exec_mask_reg[0]) begin
                // Stop trying to load
                lsu_state_next <= RD_REG_WR_STATE;
                mem_rd_en_reg <= 1'b0;
            end
            else if(mem_ack) begin
                // Need to verify how SGPR addresses are generated, whether
                // I'm supposed to just increment by 4's or if the offsets
                // are part of the generated address bank.
                mem_rd_en_reg <= 1'b0;
                mem_op_cnter_next <= mem_op_cnter + 6'd1;
                if(sgpr_op) begin
                    mem_addr_offset_next <= mem_addr_offset + 32'd4;
                end
                if(vgpr_op) begin
                    mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];
                end
                mem_data_buffer_next[mem_op_cnter] <= mem_rd_data;
                exec_mask_reg_next[62:0] <= exec_mask_reg[63:1];
                if(mem_op_cnter == mem_op_cnt_reg) begin
                    lsu_state_next <= RD_REG_WR_STATE;
                end
            end
        end
        
        RD_REG_WR_STATE: begin
            gpr_wr <= 1'b1;
            gpr_op_depth_cntr_next <= gpr_op_depth_cntr + 2'd1;
            lsu_state_next <= RD_STATE;
            mem_op_cnter_next <= 6'd0;
            mem_in_addr_reg_next <= mem_base_addr_reg;
            exec_mask_reg_next <= exec_mask_base_reg;
            gpr_dest_addr_next <= gpr_dest_addr + 12'd1;
            if(vgpr_op) begin
                mem_addr_offset_next <= mem_addr_offset + 32'd4;
            end
            if(gpr_op_depth_cntr == gpr_op_depth_reg) begin
                // Signal done somehow
                lsu_state_next <= SIGNAL_DONE_STATE;
            end
        end
        
        WR_REG_INIT_RD_STATE: begin
            // There is literally no mechanism to actually write SGPR data
            // out to memory, so ignoring that case for now.
            muxed_vgpr_source1_rd_en <= 1'b1;
            muxed_vgpr_source1_addr <= vgpr_source1_addr_reg;
            lsu_state_next <= WR_REG_RD_STATE;
        end
        
        WR_REG_RD_STATE: begin
            mem_data_buffer_next_flat <= vgpr_source1_data;
            lsu_state_next <= WR_STATE;
        end
        
        WR_STATE: begin
            mem_wr_en_reg <= 1'b1;
            //pduarte: removed vgpr_op from the condition since only vector writes occur 
            if(~exec_mask_reg[0]) begin
                // Stop trying to load
                lsu_state_next <= WR_REG_INC_STATE;
                mem_wr_en_reg <= 1'b0;
            end
            else if(mem_ack) begin
                mem_wr_en_reg <= 1'b0;
                mem_op_cnter_next <= mem_op_cnter + 6'd1;
                mem_in_addr_reg_next[2015:0] <= mem_in_addr_reg[2047:32];
                mem_data_buffer_next_flat[2015:0] <= mem_data_buffer[2047:32];
                exec_mask_reg_next[62:0] <= exec_mask_reg[63:1];
                if(mem_op_cnter == mem_op_cnt_reg) begin
                    lsu_state_next <= WR_REG_INC_STATE;
                end
            end
        end
        
        WR_REG_INC_STATE: begin
            lsu_state_next <= WR_REG_INIT_RD_STATE;
            gpr_op_depth_cntr_next <= gpr_op_depth_cntr + 2'd1;
            vgpr_source1_addr_reg_next <= vgpr_source1_addr_reg + 10'd1;
            //pduarte: added reinitializations for the execute mask, the base address, and the counter
            mem_op_cnter_next <= 6'd0;
            mem_in_addr_reg_next <= mem_base_addr_reg;
            exec_mask_reg_next <= exec_mask_base_reg;
            //pduarte: updates offset when changing to the next vgpr
            mem_addr_offset_next <= mem_addr_offset + 32'd4;
                       
            if(gpr_op_depth_cntr == gpr_op_depth_reg) begin
                // Signal done somehow
                lsu_state_next <= SIGNAL_DONE_STATE;
            end
        end
        
        SIGNAL_DONE_STATE: begin
            lsu_state_next <= IDLE_STATE;
        end
    endcase
end

assign lsu_rdy = (lsu_state == IDLE_STATE) ? 1'b1 : 1'b0;
assign lsu_done = (lsu_state == SIGNAL_DONE_STATE) ? 1'b1 : 1'b0;
assign lsu_done_wfid = current_wfid;

assign retire_pc = (lsu_state == SIGNAL_DONE_STATE) ? current_pc : 32'd0;
assign retire_gm_or_lds = (lsu_state == SIGNAL_DONE_STATE) ? gm_or_lds_reg : 1'b0;

assign sgpr_instr_done = (lsu_state == SIGNAL_DONE_STATE) ? sgpr_op : 1'b0;
assign vgpr_instr_done = (lsu_state == SIGNAL_DONE_STATE) ? vgpr_op : 1'b0;

assign sgpr_instr_done_wfid = current_wfid;
assign vgpr_instr_done_wfid = current_wfid;

assign sgpr_dest_data = mem_data_buffer[127:0];
assign sgpr_dest_wr_en = {4{sgpr_op & gpr_wr}} & sgpr_wr_mask_reg;
assign sgpr_dest_addr = gpr_dest_addr[8:0];

assign vgpr_dest_data = mem_data_buffer;
assign vgpr_dest_wr_en = vgpr_op & gpr_wr;
assign vgpr_wr_mask = exec_mask_base_reg;
assign vgpr_dest_addr = gpr_dest_addr[9:0];

assign sgpr_source1_rd_en = muxed_sgpr_source1_rd_en;
assign sgpr_source2_rd_en = muxed_sgpr_source2_rd_en;
assign sgpr_source1_addr = muxed_sgpr_source1_addr;
assign sgpr_source2_addr = muxed_sgpr_source2_addr;

assign vgpr_source1_rd_en = muxed_vgpr_source1_rd_en;
assign vgpr_source2_rd_en = muxed_vgpr_source2_rd_en;
assign vgpr_source1_addr = muxed_vgpr_source1_addr;
assign vgpr_source2_addr = muxed_vgpr_source2_addr;

assign mem_rd_en = mem_rd_en_reg;
assign mem_wr_en = mem_wr_en_reg;
assign mem_out_addr = mem_in_addr_reg[31:0] + mem_addr_offset;
assign mem_wr_data = mem_data_buffer[31:0];
assign mem_tag_req = {current_wfid, mem_rd_en_reg};
assign mem_gm_or_lds = gm_or_lds_reg;

assign tracemon_mem_addr = tracemon_mem_addr_reg;

endmodule
module lsu_opcode_decoder(
    lsu_selected,
    lsu_opcode,
    
    issue_source_reg1,
    issue_source_reg2,
    issue_source_reg3,
    issue_mem_sgpr,

    sgpr_source1_rd_en,
    sgpr_source2_rd_en,
    sgpr_source1_addr,
    sgpr_source2_addr,
    
    vgpr_source2_rd_en,
    vgpr_source1_addr,
    vgpr_source2_addr,
    
    mem_op_cnt,
    mem_op_rd,
    mem_op_wr,
    mem_gpr,
    
    sgpr_wr_mask,
    
    gpr_op_depth
);

input lsu_selected;
input [31:0] lsu_opcode;

input [11:0] issue_source_reg1;
input [11:0] issue_source_reg2;
input [11:0] issue_source_reg3;
input [11:0] issue_mem_sgpr;

output sgpr_source1_rd_en;
output sgpr_source2_rd_en;
output [8:0] sgpr_source1_addr;
output [8:0] sgpr_source2_addr;

output vgpr_source2_rd_en;
output [9:0] vgpr_source1_addr;
output [9:0] vgpr_source2_addr;

output [5:0] mem_op_cnt;
output mem_op_rd;
output mem_op_wr;
output mem_gpr; // Indicates whether the operation is for SGPR (0) or VGPR (1)
output [3:0] sgpr_wr_mask;

output [1:0] gpr_op_depth;













reg sgpr_source1_rd_en_reg;
reg sgpr_source2_rd_en_reg;
reg [8:0] sgpr_source1_addr_reg;
reg [8:0] sgpr_source2_addr_reg;
reg [3:0] sgpr_wr_mask_reg;

reg [9:0] vgpr_source1_addr_reg;
reg vgpr_source2_rd_en_reg;
reg [9:0] vgpr_source2_addr_reg;

reg [5:0] mem_op_cnt_reg;
reg mem_op_rd_reg;
reg mem_op_wr_reg;
reg mem_gpr_reg;

reg [1:0] gpr_op_depth_reg;

// Notes
// SGPR_S2 is the base address, S1 is the offset address if there is an offset address
// Intermediary value has the actual intermediary value. Don't bother routing that through
// for now, it'd be just a pass through anyway

always@(*) begin
    
    sgpr_source1_rd_en_reg <= 1'b0;
    sgpr_source2_rd_en_reg <= 1'b0;
    sgpr_source1_addr_reg <= 9'bxxxxxxxxx;
    sgpr_source2_addr_reg <= 9'bxxxxxxxxx;
    sgpr_wr_mask_reg <= 4'bxxxx;
    
    vgpr_source2_rd_en_reg <= 1'b0;
    vgpr_source2_addr_reg <= 10'bxxxxxxxxxx;
    
    mem_op_cnt_reg <= 6'bxxxxxx;
    mem_op_rd_reg <= 1'b0;
    mem_op_wr_reg <= 1'b0;
    mem_gpr_reg <= 1'b0;

    gpr_op_depth_reg <= 2'd0;
    
    // There is an inconsistency here between the decode_core and how we use
    // the SGPR ports here. The decode unit has register 2 as the BASE value,
    //  which doesn't work as the second SGPR port to the LSU is only 32bits
    //  wide, so we have to flip the registers in here. Don't get confused by
    // the inconsistency.
    case({lsu_selected, lsu_opcode[31:24]})
        
        // The SMRD instructions are different as there no write data from the
        // SGPR to memory instructions.
        {1'b1, 8'h01}:
        begin
            sgpr_source1_addr_reg <= issue_source_reg2[8:0];
            sgpr_source2_addr_reg <= issue_source_reg1[8:0];
            sgpr_source1_rd_en_reg <= 1'b1;
            if(lsu_opcode[23] == 0) begin
                sgpr_source2_rd_en_reg <= 1'b1;
            end
            
            // NOTE: S_DCACHE_INV instruction not supported, that instruction
            // does NOT perform a memory read
            
        end
        {1'b1,8'h02}:
        begin
            vgpr_source1_addr_reg <= issue_source_reg2[9:0];
            vgpr_source2_addr_reg <= issue_source_reg1[9:0];
            vgpr_source2_rd_en_reg <= 1'b1;
            mem_gpr_reg <= 1'b1;
        end
        {1'b1, 8'h04}:
        begin
            vgpr_source1_addr_reg <= issue_source_reg2[9:0];
            vgpr_source2_addr_reg <= issue_source_reg3[9:0];
            sgpr_source1_addr_reg <= issue_mem_sgpr[8:0];
            sgpr_source2_addr_reg <= issue_source_reg1[8:0];
            vgpr_source2_rd_en_reg <= 1'b1;
            sgpr_source1_rd_en_reg <= 1'b1;
            sgpr_source2_rd_en_reg <= 1'b1;//issue_source_reg1[11];//1'b1;//pduarte: changed to allow immediates to be loaded from address
            mem_gpr_reg <= 1'b1;
        end
    endcase
    
    casex({lsu_selected, lsu_opcode[31:24], lsu_opcode[7:0]})
        {1'b1, 8'h01, 8'h00}: //s_load_dword
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd0;
            sgpr_wr_mask_reg <= 4'b0001;
        end
        {1'b1, 8'h01, 8'h01}: //s_load_dwordx2
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd1;
            sgpr_wr_mask_reg <= 4'b0011;
        end
        {1'b1, 8'h01, 8'h02}: //s_load_dwordx4
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 7'd3;
            sgpr_wr_mask_reg <= 4'b1111;
        end
        {1'b1, 8'h01, 8'h03}: //s_load_dwordx8
        begin
            gpr_op_depth_reg <= 2'b01;
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd3;
            sgpr_wr_mask_reg <= 4'b1111;
        end
        {1'b1, 8'h01, 8'h04}: //s_load_dwordx16
        begin
            gpr_op_depth_reg <= 2'b10;
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd3;
            sgpr_wr_mask_reg <= 4'b1111;
        end
        // Buffered loads aren't actually properly implemented, the necessary
        // infrastructure just isn't there in the rest of the LSU. Conversely
        // the documentation for the buffered instructions is extremely
        // confusing as it is not clear for SI at least how num_records or
        // stride is used in the memory operation beyond clamping.
        {1'b1, 8'h01, 8'h08}: //s_buffer_load_dword
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd0;
            sgpr_wr_mask_reg <= 4'b0001;
        end
        {1'b1, 8'h01, 8'h09}: //s_buffer_load_dwordx2
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd1;
            sgpr_wr_mask_reg <= 4'b0011;
        end
        {1'b1, 8'h02, 8'h36}: //ds_read_b32
        begin
            mem_op_rd_reg <= 1'b1;
        end
        {1'b1, 8'h02, 8'h0D}: //ds_write_b32
        begin
            mem_op_wr_reg <= 1'b1;
        end
        {1'b1, 8'h04, 8'h00}: //tbuffer_load_format_x
        begin
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 7'd63;
        end
        ///////// ADDED XY & XYZ support
        {1'b1, 8'h04, 8'h01}: //tbuffer_load_format_xy
        begin
            gpr_op_depth_reg <= 2'b01;
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        {1'b1, 8'h04, 8'h02}: //tbuffer_load_format_xyz
        begin
            gpr_op_depth_reg <= 2'b10;
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        //////////////////////////////////////
        {1'b1, 8'h04, 8'h03}: //tbuffer_load_format_xyzw
        begin
            gpr_op_depth_reg <= 2'b11;
            mem_op_rd_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        {1'b1, 8'h04, 8'h04}: //tbuffer_store_format_x
        begin
            mem_op_wr_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        ///////// ADDED XY & XYZ support
        {1'b1, 8'h04, 8'h05}: //tbuffer_store_format_xy
        begin
            gpr_op_depth_reg <= 2'b01;
            mem_op_wr_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        {1'b1, 8'h04, 8'h06}: //tbuffer_store_format_xyz
        begin
            gpr_op_depth_reg <= 2'b10;
            mem_op_wr_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
        ////////////////////////////////
        {1'b1, 8'h04, 8'h07}: //tbuffer_store_format_xyzw
        begin
            gpr_op_depth_reg <= 2'b11;
            mem_op_wr_reg <= 1'b1;
            mem_op_cnt_reg <= 6'd63;
        end
    endcase
end

assign sgpr_source1_rd_en = sgpr_source1_rd_en_reg;
assign sgpr_source2_rd_en = sgpr_source2_rd_en_reg;
assign sgpr_source1_addr = sgpr_source1_addr_reg;
assign sgpr_source2_addr = sgpr_source2_addr_reg;
assign sgpr_wr_mask = sgpr_wr_mask_reg;

assign vgpr_source2_rd_en = vgpr_source2_rd_en_reg;
assign vgpr_source1_addr = vgpr_source1_addr_reg;
assign vgpr_source2_addr = vgpr_source2_addr_reg;

assign mem_op_cnt = mem_op_cnt_reg;
assign mem_op_rd = mem_op_rd_reg;
assign mem_op_wr = mem_op_wr_reg;
assign mem_gpr = mem_gpr_reg;

assign gpr_op_depth = gpr_op_depth_reg;

endmodule
module mtbuf_addr_calc (
  out_addr,
  vector_source_b,
  scalar_source_a,
  scalar_source_b,
  imm_value0,
  idx_en,
  off_en,
  tid
);

output[31:0] out_addr;

input [31:0] vector_source_b;
input [127:0] scalar_source_a;
input [31:0] scalar_source_b;

input [15:0] imm_value0;

input idx_en;
input off_en;

input[5:0] tid;




wire[47:0] out_temp;

// Simplified equation is as follows:
// address = baseAddress + baseOffset + instrOffset + vectorOffset + stride * (vectorIndex + threadID)
assign out_temp = scalar_source_a[47:0] + scalar_source_b + imm_value0 + (off_en ? {12'b0, vector_source_b} : 48'd0) + (scalar_source_a[61:48] * (tid + (idx_en ? vector_source_b : 48'b0)));

assign out_addr = out_temp[31:0];

endmodule
module circular_shift (
   out,
   in,
   shift_amount
);

output[15:0] out;

input[15:0] in;
input[3:0] shift_amount;

wire[15:0] shift_1, shift_2, shift_4;

assign shift_1  = shift_amount[0] ? (in >> 1 | in << 15) : in;
assign shift_2  = shift_amount[1] ? (shift_1 >> 2 | shift_1 << 14) : shift_1;
assign shift_4  = shift_amount[2] ? (shift_2 >> 4 | shift_2 << 12) : shift_2;
assign out  = shift_amount[3] ? (shift_4 >> 8 | shift_4 << 8) : shift_4;

endmodule
module priority_encoder_16_to_4 (
   out,
   in,
   enable
);

output[3:0] out;
input[15:0] in;
input enable;

assign out =
      (!enable) ? 4'd0 : (
      (in[0]) ? 4'd0 :
      (in[1]) ? 4'd1 :
      (in[2]) ? 4'd2 :
      (in[3]) ? 4'd3 :
      (in[4]) ? 4'd4 :
      (in[5]) ? 4'd5 :
      (in[6]) ? 4'd6 :
      (in[7]) ? 4'd7 :
      (in[8]) ? 4'd8 :
      (in[9]) ? 4'd9 :
      (in[10]) ? 4'd10 :
      (in[11]) ? 4'd11 :
      (in[12]) ? 4'd12 :
      (in[13]) ? 4'd13 :
      (in[14]) ? 4'd14 :
      (in[15]) ? 4'd15 :  {4{1'bx}});

endmodule
module rfa(/*AUTOARG*/
   // Outputs
   simd0_queue_entry_serviced, simd1_queue_entry_serviced,
   simd2_queue_entry_serviced, simd3_queue_entry_serviced,
   simf0_queue_entry_serviced, simf1_queue_entry_serviced,
   simf2_queue_entry_serviced, simf3_queue_entry_serviced,
   execvgprsgpr_select_fu,
   //**CHANGE [PSP]
   //add req_sat_output and lsu_wait signal
   lsu_wait, //
   // Inputs
   clk, rst, simd0_queue_entry_valid, simd1_queue_entry_valid,
   simd2_queue_entry_valid, simd3_queue_entry_valid,
   simf0_queue_entry_valid, simf1_queue_entry_valid,
   simf2_queue_entry_valid, simf3_queue_entry_valid, lsu_dest_wr_req,
   //**CHANGE [PSP]
   //add salu_req input
   salu_req
   );

   input clk;

   input rst;

   //**CHANGE [PSP]
   input salu_req;

   output lsu_wait;
   //**

   input simd0_queue_entry_valid, simd1_queue_entry_valid, simd2_queue_entry_valid,
         simd3_queue_entry_valid, simf0_queue_entry_valid, simf1_queue_entry_valid,
         simf2_queue_entry_valid, simf3_queue_entry_valid, lsu_dest_wr_req;

   
   output simd0_queue_entry_serviced, simd1_queue_entry_serviced, simd2_queue_entry_serviced,
          simd3_queue_entry_serviced, simf0_queue_entry_serviced, simf1_queue_entry_serviced,
          simf2_queue_entry_serviced, simf3_queue_entry_serviced;
   output [15:0] execvgprsgpr_select_fu;


   wire [15:0] 	 entry_valid;
   wire [15:0] 	 entry_serviced;

   wire [15:0] 	 shifted_valid;
   wire [3:0] 	 highest_priority, next_highest_priority;
   wire [3:0] 	 cur_priority;
   wire [31:0] 	 dummy_entry_serviced;
   wire [31:0] 	 dummy_next_highest_priority;

   //**change [psp]
   wire lsu_wait;
   wire lsu_wr_req_lp;

   // If lsu requests writes, it bypasses the priority encoder
   // but if salu request writes, it bypasses both
   assign entry_valid = salu_req ? {8'b0, simf3_queue_entry_valid, simf2_queue_entry_valid,
                         simf1_queue_entry_valid, simf0_queue_entry_valid,
                         simd3_queue_entry_valid, simd2_queue_entry_valid,
                         simd1_queue_entry_valid, simd0_queue_entry_valid} &
			{16{~salu_req}}:{8'b0, simf3_queue_entry_valid, simf2_queue_entry_valid,
                         simf1_queue_entry_valid, simf0_queue_entry_valid,
                         simd3_queue_entry_valid, simd2_queue_entry_valid,
                         simd1_queue_entry_valid, simd0_queue_entry_valid} &
			{16{~lsu_dest_wr_req}}
                        ;

   
   assign lsu_wr_req_lp = salu_req ? 1'b0:lsu_dest_wr_req;
   assign lsu_wait = salu_req;
   //**

   assign {simf3_queue_entry_serviced, simf2_queue_entry_serviced,
           simf1_queue_entry_serviced, simf0_queue_entry_serviced,
           simd3_queue_entry_serviced, simd2_queue_entry_serviced,
           simd1_queue_entry_serviced, simd0_queue_entry_serviced} 
   = entry_serviced[7:0];


   //**CHANGE lsu_dest_wr_req to lsu_wr_req_lp
   //and add in the salu_req signal
   // If lsu requested, then entry_serviced will be 0 
   assign execvgprsgpr_select_fu = { {6{1'b0}}, salu_req, lsu_wr_req_lp, entry_serviced[7:0]};
   //**

   dff_en high_pr_flop[3:0] 
     (highest_priority, 
      next_highest_priority, 
      |entry_valid, 
      clk, rst);

   circular_shift circ_shift (
                              .out(shifted_valid),
                              .in(entry_valid),
                              .shift_amount(highest_priority)
                              );

   priority_encoder_16_to_4 priority_encoder (
					      .out(cur_priority),
					      .in(shifted_valid),
					      .enable(1'b1)
					      );

   assign dummy_entry_serviced = cur_priority + highest_priority;
   assign dummy_next_highest_priority = dummy_entry_serviced + 1;
   assign next_highest_priority = dummy_next_highest_priority[3:0];

   decoder_param_en 
     #(.BITS(4), .SIZE(16)) 
   entry_serviced_decoder 
     (.out(entry_serviced), .
      in(dummy_entry_serviced[3:0]), 
      .en(|entry_valid));

endmodule
module salu(
	    issue_source_reg1,
	    issue_source_reg2,
	    issue_dest_reg,
	    issue_imm_value0,
	    issue_imm_value1,
	    issue_opcode,
	    issue_wfid,
	    issue_alu_select,
	    exec_rd_exec_value,
	    exec_rd_vcc_value,
	    exec_rd_m0_value,
	    exec_rd_scc_value,
	    sgpr_source2_data,
	    sgpr_source1_data,
	    issue_instr_pc,
	    exec_wr_exec_en,
	    exec_wr_vcc_en,
	    exec_wr_m0_en,
	    exec_wr_scc_en,
	    exec_wr_exec_value,
	    exec_wr_vcc_value,
	    exec_wr_m0_value,
	    exec_wr_scc_value,
	    exec_wr_wfid,
	    exec_rd_en,
	    exec_rd_wfid,
	    sgpr_dest_data, //**
	    sgpr_dest_addr, //**
	    sgpr_dest_wr_en, //**
	    sgpr_source2_addr, //**
	    sgpr_source1_addr, //**
	    sgpr_source1_rd_en, //**
	    sgpr_source2_rd_en, //**
	    issue_alu_ready,
	    sgpr_instr_done_wfid, //**
	    sgpr_instr_done, //**
	    fetchwaveissue_branch_wfid,
	    fetchwaveissue_branch_en,
	    fetchwaveissue_branch_taken,
	    fetch_branch_pc_value,
	    tracemon_retire_pc,
	    tracemon_exec_word_sel,
	    tracemon_vcc_word_sel,
	    clk,
	    rst,

            //**CHANGE [PSP]
            rfa2sgpr_request
	    );

   input clk;

   input rst;

   input issue_alu_select, exec_rd_scc_value;
   input [5:0] issue_wfid;
   input [11:0] issue_source_reg1, issue_source_reg2, issue_dest_reg;
   input [15:0] issue_imm_value0;
   input [31:0] issue_imm_value1, exec_rd_m0_value, issue_instr_pc, issue_opcode;
   input [63:0] sgpr_source2_data, sgpr_source1_data,
		exec_rd_exec_value, exec_rd_vcc_value;

   //**CHANGE [PSP]
   output rfa2sgpr_request;

   output 	exec_wr_exec_en, exec_wr_vcc_en, exec_wr_m0_en, exec_wr_scc_en,
		exec_wr_scc_value, exec_rd_en, sgpr_source1_rd_en, sgpr_source2_rd_en, issue_alu_ready, sgpr_instr_done,
		fetchwaveissue_branch_en, fetchwaveissue_branch_taken;
   output [1:0] sgpr_dest_wr_en, tracemon_exec_word_sel, tracemon_vcc_word_sel;
   output [5:0] exec_wr_wfid, exec_rd_wfid, sgpr_instr_done_wfid, fetchwaveissue_branch_wfid;
   output [8:0] sgpr_dest_addr, sgpr_source2_addr, sgpr_source1_addr;
   output [31:0] exec_wr_m0_value, fetch_branch_pc_value, tracemon_retire_pc;
   output [63:0] exec_wr_exec_value, exec_wr_vcc_value, sgpr_dest_data;

   ///////////////////////////////
   //Your code goes here - beware: script does not recognize changes
   // into files. It ovewrites everithing without mercy. Save your work before running the script
   ///////////////////////////////

   wire 	 alu_select_i, alu_select_i_flopped, alu_select_ii, exec_en_i,
		 vcc_en_i, scc_en_i, m0_en_i, branch_en, branch_taken,
		 branch_taken_i, branch_en_i, branch_taken_ii, branch_en_ii,
		 bit64_op, bit64_op_i, scc_val_i;
   wire [1:0] 	 sgpr_en_i, vcc_wordsel, exec_wordsel, vcc_wordsel_i,
		 exec_wordsel_i, vcc_wordsel_ii, exec_wordsel_ii;
   wire [5:0] 	 wfid_i, wfid_ii;
   wire [5:0] 	 branch_on_cc;
   wire [11:0] 	 source_reg1_i, source_reg2_i, dest_reg_i,
		 dest_reg_ii, salu_dst_reg;
   wire [11:0] 	 source_reg1_i_flopped, source_reg2_i_flopped;
   wire [15:0] 	 imm_value0_i;
   wire [31:0] 	 exec_rd_val1, exec_rd_val2, instr_pc_i,
		 instr_pc_ii, opcode_i, imm_value1_i;
   wire [63:0] 	 source2_value, source1_value, source1_value_i,
		 source2_value_i, dest_data;
   wire [63:0] 	 exec_val_i, vcc_val_i, exec_val_ii, vcc_val_ii, alu_out;

   // from controller
   wire [31:0] 	 alu_control, alu_control_i; // no of bits
   wire 	 vccz, execz, exec_en, vcc_en, scc_en, m0_en, scc_data,
		 exec_sgpr_cpy, exec_sgpr_cpy_i, exec_sgpr_cpy_ii, snd_src_imm;
   wire [1:0] 	 sgpr_en;

   wire 	 exec_rd1, vcc_rd1, sgpr_rd1, exec_rd2, vcc_rd2, sgpr_rd2;

   //**CHANGE add wires for new controller ports
   wire          salu2sgpr_req, salu2sgpr_req_i, salu2sgpr_req_ii;
   //**

   ///////////////////////////////////////////////////////
   // SOURCE REGISTER SELECT LOGIC

   reg 	 exec_rd_scc_value_i;
   reg [31:0] 	 exec_rd_m0_value_i;
   reg [63:0] exec_rd_exec_value_i, exec_rd_vcc_value_i;
   wire [63:0] sgpr_source2_data_i, sgpr_source1_data_i;
   wire rfa2salu_req_hold;

   // Keep the delay on exec signals
   always @ ( posedge clk or posedge rst ) begin
      if(rst) begin
	 exec_rd_scc_value_i <= 0;
	 exec_rd_m0_value_i <= 0;
	 //sgpr_source2_data_i <= 0;
	 //sgpr_source1_data_i <= 0;
	 exec_rd_exec_value_i <= 0;
	 exec_rd_vcc_value_i <= 0;
      end
      else begin
	 exec_rd_scc_value_i <= exec_rd_scc_value;
	 exec_rd_m0_value_i <= exec_rd_m0_value;
	 //sgpr_source2_data_i <= sgpr_source2_data;
	 //sgpr_source1_data_i <= sgpr_source1_data;
	 exec_rd_exec_value_i <= exec_rd_exec_value;
	 exec_rd_vcc_value_i <= exec_rd_vcc_value;
      end
   end

   assign sgpr_source2_data_i = sgpr_source2_data;
   assign sgpr_source1_data_i = sgpr_source1_data;

   assign alu_select_i = issue_alu_select;
   assign source_reg1_i = issue_source_reg1;
   assign source_reg2_i = issue_source_reg2;

   assign sgpr_source1_addr = source_reg1_i[8:0];
   assign sgpr_source2_addr = source_reg2_i[8:0];

   assign sgpr_source1_rd_en = alu_select_i;
   assign sgpr_source2_rd_en = alu_select_i;

   assign exec_rd_wfid = issue_wfid;

   assign vccz  = ~(|exec_rd_vcc_value_i);
   assign execz = ~(|exec_rd_exec_value_i);

   assign branch_en = (|branch_on_cc);
   assign branch_taken = (branch_on_cc[0] & ~exec_rd_scc_value_i) |
			 (branch_on_cc[1] & exec_rd_scc_value_i) |
			 (branch_on_cc[2] & vccz) |
			 (branch_on_cc[3] & ~vccz) |
			 (branch_on_cc[4] & execz) |
			 (branch_on_cc[5] & ~execz);

   // Test - read exec all time
   assign exec_rd_en = alu_select_i;

   // Data mux selection signas will arrive with the data, therefore
   // use delayed addr signals
   assign sgpr_rd1 = ~source_reg1_i_flopped[9];
   assign vcc_rd1 = (source_reg1_i_flopped[7:0] == 8'h01);
   assign exec_rd1 = (source_reg1_i_flopped[7:0] == 8'h08);

   assign source1_value[63:32] = bit64_op ?
				 sgpr_rd1 ? sgpr_source1_data_i[63:32] :
				 ((exec_rd1 ? exec_rd_exec_value_i[63:32] :
				   (vcc_rd1 ? exec_rd_vcc_value_i[63:32] : 32'bx)))
				   : 32'bx;

   assign source1_value[31:0] =
			       branch_en ? instr_pc_i :
			       source_reg1_i_flopped[11] ?
			       (
				source_reg1_i_flopped[10] ?
				(source_reg1_i_flopped[9] ? exec_rd_val1 : sgpr_source1_data_i[31:0]) :
				32'bx
				) : (source_reg1_i_flopped[10:0]==11'h7FF) ?
			       imm_value1_i : { {22{source_reg1_i_flopped[9]}}, source_reg1_i_flopped[9:0] };

   assign sgpr_rd2 = ~source_reg2_i_flopped[9];
   assign vcc_rd2 = (source_reg2_i_flopped[7:0] == 8'h01);
   assign exec_rd2 = (source_reg2_i_flopped[7:0] == 8'h08);

   assign source2_value[63:32] = bit64_op ?
				 sgpr_rd2 ? sgpr_source2_data_i[63:32] :
				 ((exec_rd2 ? exec_rd_exec_value_i[63:32] :
				   (vcc_rd2 ? exec_rd_vcc_value_i[63:32] : 32'bx)))
				   : 32'bx;

   assign source2_value[31:0] =
			       snd_src_imm ? { {16{imm_value0_i[15]}}, imm_value0_i } :
			       source_reg2_i_flopped[11] ?
			       (
				source_reg2_i_flopped[10] ?
				(source_reg2_i_flopped[9] ? exec_rd_val2 : sgpr_source2_data_i[31:0]) :
				32'bx
				) : (source_reg2_i_flopped[10:0]==11'h7FF) ?
			       imm_value1_i : { {22{source_reg2_i_flopped[9]}}, source_reg2_i_flopped[9:0] };

   assign exec_rd_val1 =
			(source_reg1_i_flopped[7:0] == 8'h01) ? exec_rd_vcc_value_i[31:0]    :
			(source_reg1_i_flopped[7:0] == 8'h02) ? exec_rd_vcc_value_i[63:32]   :
			(source_reg1_i_flopped[7:0] == 8'h04) ? exec_rd_m0_value_i           :
			(source_reg1_i_flopped[7:0] == 8'h08) ? exec_rd_exec_value_i[31:0]   :
			(source_reg1_i_flopped[7:0] == 8'h10) ? exec_rd_exec_value_i[63:32]  :
			(source_reg1_i_flopped[7:0] == 8'h20) ? {31'b0, vccz}              :
			(source_reg1_i_flopped[7:0] == 8'h40) ? {31'b0, execz}             :
			(source_reg1_i_flopped[7:0] == 8'h80) ? {31'b0, exec_rd_scc_value_i} : 32'bx;

   assign exec_rd_val2 =
			(source_reg2_i_flopped[7:0] == 8'h01) ? exec_rd_vcc_value_i[31:0]    :
			(source_reg2_i_flopped[7:0] == 8'h02) ? exec_rd_vcc_value_i[63:32]   :
			(source_reg2_i_flopped[7:0] == 8'h04) ? exec_rd_m0_value_i           :
			(source_reg2_i_flopped[7:0] == 8'h08) ? exec_rd_exec_value_i[31:0]   :
			(source_reg2_i_flopped[7:0] == 8'h10) ? exec_rd_exec_value_i[63:32]  :
			(source_reg2_i_flopped[7:0] == 8'h20) ? {31'b0, vccz}              :
			(source_reg2_i_flopped[7:0] == 8'h40) ? {31'b0, execz}             :
			(source_reg2_i_flopped[7:0] == 8'h80) ? {31'b0, exec_rd_scc_value_i} : 32'bx;

   ///////////////////////////////////////////////////////
   // STAGE FLOPS

   // TODO : CHANGE ALL LATCH WIDTHS

   // Stage 1: Latching input from Issue
   regfile #(155) salu_instr(
			     { issue_alu_select, issue_wfid, issue_source_reg1,
			       issue_source_reg2, issue_dest_reg, issue_imm_value0,
			       issue_imm_value1, issue_opcode, issue_instr_pc },
			     1'b1,
			     { alu_select_i_flopped, wfid_i, source_reg1_i_flopped,
			       source_reg2_i_flopped, dest_reg_i, imm_value0_i,
			       imm_value1_i, opcode_i, instr_pc_i },
			     clk, rst
			     );

   // Stage 2: Latching control signals
   regfile #(98) salu_decode(
			     { alu_select_i_flopped, dest_reg_i, wfid_i,
			       instr_pc_i, alu_control, exec_en, vcc_en, scc_en,
			       m0_en, sgpr_en, vcc_wordsel, exec_wordsel,
			       branch_en, branch_taken, exec_sgpr_cpy, bit64_op, salu2sgpr_req },
			     1'b1,
			     { alu_select_ii, dest_reg_ii, wfid_ii,
			       instr_pc_ii, alu_control_i, exec_en_i, vcc_en_i, scc_en_i,
			       m0_en_i, sgpr_en_i, vcc_wordsel_i, exec_wordsel_i,
			       branch_en_i, branch_taken_i, exec_sgpr_cpy_i, bit64_op_i, salu2sgpr_req_i },
			     clk, rst
			     );

   // Stage 2: Latching source operands
   regfile #(257) source_input(
			       { source1_value, source2_value, exec_rd_exec_value_i, exec_rd_vcc_value_i, exec_rd_scc_value_i },
			       1'b1,
			       { source1_value_i, source2_value_i, exec_val_i, vcc_val_i, scc_val_i },
			       clk, rst
			       );

   // Stage 3: Latching writeback control signals and data
   regfile #(257) writeback(
			    { instr_pc_ii, exec_en_i, vcc_en_i, scc_en_i, m0_en_i,
			      sgpr_en_i, dest_reg_ii, wfid_ii, alu_out, scc_data,
			      vcc_wordsel_i, exec_wordsel_i, exec_val_i, vcc_val_i,
			      branch_en_i, branch_taken_i, exec_sgpr_cpy_i, salu2sgpr_req_i },
			    1'b1,
			    { tracemon_retire_pc, exec_wr_exec_en, exec_wr_vcc_en,
			      exec_wr_scc_en, exec_wr_m0_en, sgpr_dest_wr_en,
			      salu_dst_reg, sgpr_instr_done_wfid, dest_data,
			      exec_wr_scc_value, vcc_wordsel_ii, exec_wordsel_ii,
			      exec_val_ii, vcc_val_ii, fetchwaveissue_branch_en,
			      fetchwaveissue_branch_taken, exec_sgpr_cpy_ii, salu2sgpr_req_ii },
			    clk, rst
			    );

   //**CHANGE [PSP]
   //request line will be double flopped.
   assign rfa2sgpr_request = salu2sgpr_req_ii;
   ///////////////////////////////////////////////////////
   // MODULE INSTANTIATIONS


   //**CHANGE [psp]
   //**ADD two ports for salu2sgpr_request and rfa2salu_req_hold
   //controller

   assign rfa2salu_req_hold = (salu2sgpr_req_ii | salu2sgpr_req_i | salu2sgpr_req) ? 1'b1: 1'b0;
   salu_controller scontrol(
			    .control_en(alu_select_i_flopped), .dst_reg(dest_reg_i), .opcode(opcode_i),
                            .alu_control(alu_control), .branch_on_cc(branch_on_cc), .exec_en(exec_en),
                            .vcc_en(vcc_en), .scc_en(scc_en), .m0_en(m0_en), .sgpr_en(sgpr_en),
                            .vcc_wordsel(vcc_wordsel), .exec_wordsel(exec_wordsel), .exec_sgpr_cpy(exec_sgpr_cpy),
                            .snd_src_imm(snd_src_imm), .bit64_op(bit64_op), .rst(rst), .clk(clk),
                            .salu2sgpr_req(salu2sgpr_req), .rfa2salu_req_hold(rfa2salu_req_hold),
                            .control_en_fw(issue_alu_select), .dst_reg_fw(issue_dest_reg)
			    );
   //**

   //alu
   scalar_alu salu_gpu(
		       .s1(source1_value_i), .s2(source2_value_i), .exec(exec_val_i), .control(alu_control_i),
		       .scc(scc_val_i), .b64_op(bit64_op_i), .out(alu_out), .scc_val(scc_data)
		       );

   ///////////////////////////////////////////////////////
   // WRITEBACK DATA GENERATION

   // SGPR signals
   assign sgpr_dest_addr = salu_dst_reg[8:0];
   assign sgpr_dest_data = exec_sgpr_cpy_ii ? exec_val_ii : dest_data;

   // Exec signals
   assign exec_wr_exec_value = (exec_wordsel_ii == 2'b11) ?
			       dest_data : (exec_wordsel_ii == 2'b10) ?
			       {dest_data[31:0], exec_val_ii[31:0]} : (exec_wordsel_ii == 2'b01) ?
			       {exec_val_ii[63:32], dest_data[31:0]} : exec_val_ii;
   assign exec_wr_vcc_value = (vcc_wordsel_ii == 2'b11) ?
			      dest_data : (vcc_wordsel_ii == 2'b10) ?
			      {dest_data[31:0], vcc_val_ii[31:0]} : (vcc_wordsel_ii == 2'b01) ?
			      {vcc_val_ii[63:32], dest_data[31:0]} : vcc_val_ii;
   assign exec_wr_m0_value = dest_data[31:0];
   assign exec_wr_wfid = sgpr_instr_done_wfid;

   // Branch signals
   assign fetch_branch_pc_value = dest_data[31:0];
   assign fetchwaveissue_branch_wfid = sgpr_instr_done_wfid;

   assign sgpr_instr_done = exec_wr_exec_en | exec_wr_vcc_en | exec_wr_m0_en | exec_wr_scc_en | (|sgpr_dest_wr_en);

   // Tracemon signals
   assign tracemon_exec_word_sel = exec_wordsel_ii;
   assign tracemon_vcc_word_sel  = vcc_wordsel_ii;

   // SALU is currently always ready
   // can accept an instruction every cycle
   //assign issue_alu_ready = 1'b1;

   //**CHANGE [psp]
   // SALU not always ready
   // SALU will only accept instruction every cycle
   // if pending request line is not high
   // this is to prevent new instructions coming in while
   // salu has not been satisfied to write to SGPR

   assign issue_alu_ready = ~rfa2salu_req_hold;

   //**

endmodule






module salu_controller(
	control_en,
	dst_reg,
	opcode,
	alu_control,
	branch_on_cc,
	exec_en,
	vcc_en,
	scc_en,
	m0_en,
	sgpr_en,
	vcc_wordsel,
	exec_wordsel,
	exec_sgpr_cpy,
	snd_src_imm,
	bit64_op,
	rst,
        //**CHANGE
        //**add 2 signals
        //one is output which is 
        //a signal to flag a SGPR write request pending
        //one is input to flag request satisfied, unlock request
        clk,
        salu2sgpr_req,
        rfa2salu_req_hold,

        //**change for port forwarding
        control_en_fw,
        dst_reg_fw
        //**
);

//**change [psp]
input rfa2salu_req_hold;
input clk;

input control_en_fw;
input [11:0] dst_reg_fw;
//**

//**change [psp]
output salu2sgpr_req;
//**

input [11:0] dst_reg;
input [31:0] opcode;
input control_en, rst;

output exec_en, vcc_en, scc_en, m0_en, exec_sgpr_cpy,
		snd_src_imm, bit64_op;
output [1:0] vcc_wordsel, exec_wordsel, sgpr_en;
output [5:0] branch_on_cc;
output [31:0] alu_control;

reg exec_en_dreg, vcc_en, scc_en, m0_en, exec_sgpr_cpy,
	snd_src_imm, bit64_op;
reg [1:0] vcc_ws_dreg, exec_ws_dreg, vcc_ws_op, exec_ws_op, sgpr_en;
reg [5:0] branch_on_cc;
reg [31:0] alu_control;

//**change [psp]
reg salu2sgpr_req;
reg salu2sgpr_req_trig;

wire sgpr_fw_check;
assign sgpr_fw_check = {control_en_fw, dst_reg_fw[11:9]} && 4'b1110;
//**

//**change [psp]
//create a lock mechanism that locks the request line
//until rfa notifies its been satisfied

//this is simply the unlocker
//line is locked below where it determines destination registers
always@ (control_en or dst_reg or bit64_op or clk or rst) begin
        if(~control_en | rst ) begin
              salu2sgpr_req <= 1'b0; //satisfied   
           end
        else
        if(salu2sgpr_req_trig | sgpr_fw_check) begin
              salu2sgpr_req <= 1'b1; //not satisfied
        end
        else
        begin
              salu2sgpr_req <= salu2sgpr_req;
        end
   end
//**

// setting scc_en, alu_control, vcc_ws_op, exec_ws_op
always@ (control_en or opcode or rst) begin
	if(~control_en | rst) begin
		alu_control <= 'd0;
		scc_en <= 1'b0;
		vcc_ws_op <= 2'b00;
		exec_ws_op <= 2'b00;
		exec_sgpr_cpy <= 1'b0;
		branch_on_cc <= 6'b000000;
		snd_src_imm <= 1'b0;
		bit64_op <= 1'b0;
	end
	else if(control_en) begin
		scc_en <= 1'b0;
		alu_control <= opcode;
		bit64_op <= 1'b0;
		exec_sgpr_cpy <= 1'b0;
		snd_src_imm <= 1'b0;
		branch_on_cc <= 6'b000000;
		vcc_ws_op <= 2'b00;
		exec_ws_op <= 2'b00;
		// setting scc_en for instruction that write to scc
		casex(opcode[31:24])
			// SOPP
			{8'h01} : begin
				snd_src_imm <= 1'b1;
				casex(opcode[23:0])
					// s_branch	0x02
					24'h000002 : begin branch_on_cc <= 6'b111111; end
					// s_cbranch_scc0	0x04
					24'h000004 : begin branch_on_cc <= 6'b000001; end
					// s_cbranch_scc1	0x05
					24'h000005 : begin branch_on_cc <= 6'b000010; end
					// s_cbranch_vccz	0x06
					24'h000006 : begin branch_on_cc <= 6'b000100; end
					// s_cbranch_vccnz	0x07
					24'h000007 : begin branch_on_cc <= 6'b001000; end
					// s_cbranch_execz	0x08
					24'h000008 : begin branch_on_cc <= 6'b010000; end
					// s_cbranch_execnz	0x09
					24'h000009 : begin branch_on_cc <= 6'b100000; end
				endcase
			end

			// SOP1
			{8'h02} : begin
				casex(opcode[23:0])
					// s_mov_b32	0x03
					// No special signals
					// s_mov_b64	0x04
					24'h000004 : begin
						bit64_op <= 1'b1;
					end
					// s_not_b32	0x07
					24'h000007 : begin
						scc_en <= 1'b1;
					end
					// s_and_saveexec_b64	0x24
					24'h000024 : begin
						scc_en <= 1'b1;
						exec_ws_op <= 2'b11;
						exec_sgpr_cpy <= 1'b1;
						bit64_op <= 1'b1;
					end
				endcase
			end

			// SOP2
			{8'h08} : begin
				casex(opcode[23:0])
					// s_add_u32	0x00
					24'h000000 : begin
						scc_en <= 1'b1;
					end
					// s_sub_u32	0x01
					24'h000001 : begin
						scc_en <= 1'b1;
					end
					// s_add_i32	0x02
					24'h000002 : begin
						scc_en <= 1'b1;
					end
					// s_sub_i32	0x03
					24'h000003 : begin
						scc_en <= 1'b1;
					end
					// s_min_u32	0x07
					24'h000007 : begin
						scc_en <= 1'b1;
					end
					// s_max_u32	0x09
					24'h000009 : begin
						scc_en <= 1'b1;
					end
					// s_max_i32	0x08 - VIN
					24'h000008 : begin
						scc_en <= 1'b1;
					end
					// s_and_b32	0x0E
					24'h00000E : begin
						scc_en <= 1'b1;
					end
					// s_and_b64	0x0F
					24'h00000F : begin
						scc_en <= 1'b1;
						bit64_op <= 1'b1;
					end
					// s_or_b64	0x11
					24'h000011 : begin
						scc_en <= 1'b1;
						bit64_op <= 1'b1;
					end
					// s_or_b32	0x10
					24'h000010 : begin
						scc_en <= 1'b1;
					end
					// s_andn2_b64	0x15
					24'h000015 : begin
						scc_en <= 1'b1;
						bit64_op <= 1'b1;
					end
					// s_lshl_b32	0x1E
					24'h00001E : begin
						scc_en <= 1'b1;
					end
					// s_lshr_b32	0x20
					24'h000020 : begin
						scc_en <= 1'b1;
						
					end
					// s_ashr_i32	0x22
					24'h000022 : begin
						scc_en <= 1'b1;
						
					end
					// s_mul_i32	0x26
					// No special signals
				endcase
			end

			// SOPC
			{8'h04} : begin
				casex(opcode[23:0])
					// s_cmp_eq_i32	0x00
					24'h000000 : begin scc_en <= 1'b1; end
					// s_cmp_lg_i32	0x01 - VIN
					24'h000001 : begin scc_en <= 1'b1; end
					// s_cmp_gt_i32	0x02 - VIN
					24'h000002 : begin scc_en <= 1'b1; end
					// s_cmp_ge_i32	0x03 - VIN
					24'h000003 : begin scc_en <= 1'b1; end
					// s_cmp_lt_i32	0x04 - VIN
					24'h000004 : begin scc_en <= 1'b1; end
					// s_cmp_le_i32	0x05
					24'h000005 : begin scc_en <= 1'b1; end
					// s_cmp_eq_u32	0x06 - VIN
					24'h000006 : begin scc_en <= 1'b1; end
					// s_cmp_lg_u32	0x07 - VIN
					24'h000007 : begin scc_en <= 1'b1; end
					// s_cmp_gt_u32	0x08 - VIN
					24'h000008 : begin scc_en <= 1'b1; end
					// s_cmp_ge_u32	0x09 - VIN
					24'h000009 : begin scc_en <= 1'b1; end
					// s_cmp_lt_u32	0x0A - VIN
					24'h00000A : begin scc_en <= 1'b1; end
					// s_cmp_le_u32	0x0B
					24'h00000B : begin scc_en <= 1'b1; end
					// default
					default : begin  end
				endcase
			end

			// SOPK
			{8'h10} : begin
				snd_src_imm <= 1'b1;
				casex(opcode[23:0])
					// s_movk_i32	0x00
					// No special signals
					// s_addk_i32	0x0F
					24'h00000F : begin scc_en <= 1'b1; end
					// s_mulk_i32	0x10
					24'h000010 : begin scc_en <= 1'b1; end
				endcase
			end
		endcase
	end

end

always@(control_en or dst_reg or bit64_op) begin
	exec_en_dreg <= 1'b0;
	exec_ws_dreg <= 2'b00;
	vcc_en  <= 1'b0;
	vcc_ws_dreg  <= 2'b00;
	m0_en   <= 1'b0;
	sgpr_en <= 2'b00;
	casex({control_en, dst_reg})
		// SGPR
		{1'b1, 12'b110xxxxxxxxx} : begin
			sgpr_en <= bit64_op ? 2'b11 : 2'b01;
			//**change [psp]
			salu2sgpr_req_trig <= 1'b1; //request pending
			//**
		end
		// VCC_LO
		{1'b1, 12'b111000000001} : begin
			vcc_en  <= 1'b1;
			vcc_ws_dreg <= bit64_op ? 2'b11 : 2'b01;
		end
		// VCC_HI
		{1'b1, 12'b111000000010} : begin
			vcc_en  <= 1'b1;
			vcc_ws_dreg <= bit64_op ? 2'b11 : 2'b10;
			
		end
		// EXEC_LO
		{1'b1, 12'b111000001000} : begin
			exec_en_dreg <= 1'b1;
			exec_ws_dreg <= bit64_op ? 2'b11 : 2'b01;
		end
		// EXEC_HI
		{1'b1, 12'b111000010000} : begin
			exec_en_dreg <= 1'b1;
			exec_ws_dreg <= bit64_op ? 2'b11 : 2'b10;
		end
		// M0
		{1'b1, 12'b111000000100} : begin
			m0_en <= 1'b1;
		end
	endcase
end

assign exec_wordsel = exec_ws_dreg | exec_ws_op;
assign vcc_wordsel = vcc_ws_dreg | vcc_ws_op;
assign exec_en = |exec_wordsel;

endmodule






module scalar_alu(
    s1,
    s2,
    exec,
    control,
    scc,
    b64_op,
    out,
    scc_val
);

integer i;

input[63:0] s1, s2, exec;
input[31:0] control;
input b64_op, scc;

output[63:0] out;
output scc_val;

reg scc_val;

reg infogen;
reg [31:0] partial_sum, out_low, out_hi;

wire [31:0] s1_low, s2_low;

assign s1_low = s1[31:0];
assign s2_low = s2[31:0];

assign out = b64_op ? {out_hi, out_low} : {32'bx, out_low};

always@(s1 or s2 or control)
begin
    // setting out for instructions
    casex(control[31:24])
        // SOPP
        {8'h01} : begin
            infogen     = 1'bx;
            partial_sum = 32'bx;
            out_hi = 32'bx;

            casex(control[23:0])
                // s_branch    0x02
                24'h000002 : begin out_low = s1_low + s2_low*4 + 4; end
                // s_cbranch_scc0  0x04
                24'h000004 : begin out_low = s1_low + s2_low*4 + 4; end
                // s_cbranch_scc1  0x05
                24'h000005 : begin out_low = s1_low + s2_low*4 + 4; end
                // s_cbranch_vccz  0x06
                24'h000006 : begin out_low = s1_low + s2_low*4 + 4; end
                // s_cbranch_execz 0x08
                24'h000008 : begin out_low = s1_low + s2_low*4 + 4; end
                default : begin out_low = 32'bx; end
            endcase
        end

        // SOP1
        {8'h02} : begin
            infogen     = 1'bx;
            partial_sum = 32'bx;

            casex(control[23:0])
                // s_mov_b32    0x03
                24'h000003 : begin
                               out_low = s1_low;
                               out_hi = 32'bx;
                             end
                // s_mov_b64    0x04
                24'h000004 : begin {out_hi, out_low} = s1; end
		// s_cmov_b32	0x05
		24'h000005 : begin
			       if(scc) begin
				 out_low = s1_low;
			 	end
			     end
                // s_not_b32    0x07
                24'h000007 : begin
                               out_low = ~s1_low;
                               out_hi = 32'bx;
                             end
		// s_brev_b32	0x0B
		24'h00000B : begin
				for(i = 0; i < 32; i = i + 1)
				  out_low[i] = s1_low[31 - i];
			     end
		// s_sext_i32_i8    0x19
		24'h000019 : begin
				out_low = {{24{s1_low[7]}}, s1_low[7:0]};
			     end
                // s_and_saveexec_b64   0x24
                24'h000024 : begin {out_hi, out_low} = s1 & exec; end
                // default
                default : begin
                               out_low = 32'bx;
                               out_hi = 32'bx;
                          end
            endcase
        end

        // SOP2
        {8'h08} : begin
            casex(control[23:0])
                // s_add_u32    0x00
                24'h000000 : begin
                    {infogen, out_low} = s1_low + s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_sub_u32    0x01
                24'h000001 : begin
                    {infogen, out_low} = s1_low - s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_add_i32    0x02
                24'h000002 : begin
                    {infogen, out_low} = s1_low + s2_low;
                    partial_sum = s1_low[30:0] + s2_low[30:0];
                    out_hi = 32'bx;
                end
                // s_sub_i32    0x03
                24'h000003 : begin
                    {infogen, out_low} = s1_low - s2_low;
                    partial_sum = s1_low[30:0] + (~(s2_low[30:0])) + 31'b1;
                    out_hi = 32'bx;
                end
                // s_min_u32    0x07
                24'h000007 : begin
                    out_low     = (s1_low < s2_low) ? s1_low : s2_low;
                    infogen     = s1_low < s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_max_i32    0x08
                24'h000008 : begin
                    out_low     = (s1_low > s2_low) ? s1_low : s2_low;
                    infogen     = s1_low > s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_max_u32    0x09
                24'h000009 : begin
                    out_low     = (s1_low > s2_low) ? s1_low : s2_low;
                    infogen     = s1_low > s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
		// s_cselect_b32
		24'h00000A : begin
                    out_low = scc ? s1_low : s2_low;
                end
                // s_and_b32    0x0E
                24'h00000e : begin
                    out_low     = s1_low & s2_low;
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_and_b64    0x0F
                24'h00000f : begin
                    {out_hi, out_low} = s1 & s2;
                    infogen           = 1'bx;
                    partial_sum       = 32'bx;
                end
                // s_or_b64    0x11
                24'h000011 : begin
                    {out_hi, out_low} = s1 | s2;
                    infogen           = 1'bx;
                    partial_sum       = 32'bx;
                end
                // s_or_b32     0x10
                24'h000010 : begin
                    out_low     = s1_low | s2_low;
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_andn2_b64  0x15
                24'h000015 : begin
                    {out_hi, out_low} = s1 & ~s2;
                    infogen           = 1'bx;
                    partial_sum       = 32'bx;
                end
                // s_lshl_b32   0x1E
                24'h00001e : begin
                    out_low     = s1_low << s2_low[4:0];
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_lshr_b32   0x20
                24'h000020 : begin
                    out_low     = s1_low >> s2_low[4:0];
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_ashr_i32   0x22
                24'h000022 : begin
                    out_low     = s1_low >>> s2_low[4:0];
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_mul_i32    0x26
                24'h000026 : begin
                    out_low     = s1_low * s2_low;
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                default : begin
                    out_low     = 32'bx;
                    infogen     = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
            endcase
        end

        // SOPC
        {8'h04} : begin
            out_low     = 32'bx;
            partial_sum = 32'bx;

            casex(control[23:0])
                // s_cmp_eq_i32 0x00
                24'h000000 : begin infogen = s1_low == s2_low;
                                   out_hi = 32'bx;
                             end
                // s_cmp_lg_i32 0x01 - VIN
                24'h000001 : begin infogen = s1_low != s2_low;
                                   out_hi = 32'bx;
                             end
                // s_cmp_gt_i32 0x02 - VIN
                24'h000002 : begin
				   if(s1_low[31] == 1'b1 & s2_low[31] == 1'b1)
				     begin
				       infogen = s1_low < s2_low;
                        	       out_hi = 32'bx;
                      		     end
				   else if(s1_low[31] == 1'b1)
				     begin
				       infogen = 1'b0;
                                       out_hi = 32'bx;
				     end
				   else if(s2_low[31] == 1'b1)
				     begin
				       infogen = 1'b1;
                                       out_hi = 32'bx;
				     end
				   else
				     begin
				       infogen = s1_low > s2_low;
                        	       out_hi = 32'bx;
				     end
			     end
                // s_cmp_ge_i32 0x03 - VIN
                24'h000003 : begin
				if(s1_low[31] == 1'b1 & s2_low[31] == 1'b1)
											begin
												infogen = s1_low <= s2_low;
                        out_hi = 32'bx;
                      end
										else if(s1_low[31] == 1'b1)
											begin
												infogen = 1'b0;
                        out_hi = 32'bx;
										  end
										else if(s2_low[31] == 1'b1)
											begin
												infogen = 1'b1;
                        out_hi = 32'bx;
											end
										else
											begin
												infogen = s1_low >= s2_low;
                        out_hi = 32'bx;
											end
								end
                // s_cmp_lt_i32 0x04 - VIN
                24'h000004 : begin
                    if (s1_low[31] == 1'b1 & s2_low[31] == 1'b1)
                      begin
                        infogen = s1_low > s2_low;
                        out_hi = 32'bx;
                      end
                    else if (s1_low[31] == 1'b1)
                      begin
                        infogen = 1'b1;
                        out_hi = 32'bx;
                      end
                    else if (s2_low[31] == 1'b1)
                      begin
                        infogen = 1'b0;
                        out_hi = 32'bx;
                      end
                    else
                      begin
                        infogen = s1_low < s2_low;
                        out_hi = 32'bx;
                      end
                end
                // s_cmp_le_i32 0x05 - VIN
                24'h000005 : begin
                    if (s1_low[31] == 1'b1 & s2_low[31] == 1'b1)
                      begin
                        infogen = s1_low >= s2_low;
                        out_hi = 32'bx;
                      end
                    else if (s1_low[31] == 1'b1)
                      begin
                        infogen = 1'b1;
                        out_hi = 32'bx;
                      end
                    else if (s2_low[31] == 1'b1)
                      begin
                        infogen = 1'b0;
                        out_hi = 32'bx;
                      end
                    else
                      begin
                        infogen = s1_low <= s2_low;
                        out_hi = 32'bx;
                      end
                end
		// s_cmp_eq_u32 0x06 - VIN
                24'h000006 : begin infogen = s1_low == s2_low;
                                   out_hi = 32'bx;
			     end
		// s_cmp_lg_u32 0x07 - VIN
                24'h000007 : begin infogen = s1_low != s2_low;
                                   out_hi = 32'bx;
			     end
		// s_cmp_gt_u32 0x08 - VIN
                24'h000008 : begin infogen = s1_low > s2_low;
                                   out_hi = 32'bx;
		             end
		// s_cmp_ge_u32 0x09
                24'h000009 : begin infogen = s1_low >= s2_low;
                                   out_hi = 32'bx;
			     end
		// s_cmp_lt_u32 0x0A - VIN
                24'h00000A : begin infogen = s1_low < s2_low;
                                   out_hi = 32'bx;
                             end
                // s_cmp_le_u32 0x0B
                24'h00000B : begin infogen = s1_low <= s2_low;
                                   out_hi = 32'bx;
                             end
                // default
                default : begin infogen = 1'bx;
                                out_hi = 32'bx;
                          end
            endcase
        end

        // SOPK
        {8'h10} : begin
            casex(control[23:0])
                // s_movk_i32   0x00
                24'h000000 : begin
                    out_low = s2_low;
                    infogen = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // s_addk_i32   0x0F
                24'h00000F : begin
                    {infogen, out_low} = s1_low + s2_low;
                    partial_sum = s1_low[30:0] + s2_low[30:0];
                    out_hi = 32'bx;
                end
                // s_mulk_i32   0x10
                24'h000010 : begin
                    {infogen, out_low} = s1_low * s2_low;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
                // default
                default : begin
                    out_low = 32'bx;
                    infogen = 1'bx;
                    partial_sum = 32'bx;
                    out_hi = 32'bx;
                end
            endcase
        end
        default : begin
            out_low     = 32'bx;
            infogen     = 1'bx;
            partial_sum = 32'bx;
            out_hi = 32'bx;
        end
    endcase
end

always@(control or out_low or out or infogen or partial_sum)
begin
    scc_val = 1'bx;

    // setting scc_val for instruction that write to scc
    casex(control[31:24])
        // SOPP
        // no instruction set scc

        // SOP1
        {8'h02} : begin
            casex(control[23:0])
                // s_not_b32    0x07
                24'h000007 : begin scc_val = (|out_low); end
                // s_and_saveexec_b64   0x24
                24'h000024 : begin scc_val = (|out); end
                // default
                default : begin scc_val = 1'bx; end
            endcase
        end

        // SOP2
        {8'h08} : begin
            casex(control[23:0])
                // s_add_u32    0x00
                24'h000000 : begin scc_val = infogen; end
                // s_sub_u32    0x01
                24'h000001 : begin scc_val = infogen; end
                // s_add_i32    0x02
                24'h000002 : begin scc_val = partial_sum[31] ^ infogen; end
                // s_sub_i32    0x03
                24'h000003 : begin scc_val = partial_sum[31] ^ infogen; end
                // s_min_u32    0x07
                24'h000007 : begin scc_val = infogen; end
                // s_max_i32    0x08
                24'h000008 : begin scc_val = infogen; end
                // s_max_u32    0x09
                24'h000009 : begin scc_val = infogen; end
                // s_and_b32    0x0E
                24'h00000E : begin scc_val = |out_low; end
                // s_and_b64    0x0F
                24'h00000F : begin scc_val = |out; end
                // s_or_b32     0x10
                24'h000010 : begin scc_val = |out_low; end
                // s_or_b64     0x11
                24'h000011 : begin scc_val = |out; end
                // s_andn2_b64  0x15
                24'h000015 : begin scc_val = |out; end
                // s_lshl_b32   0x1E
                24'h00001E : begin scc_val = |out_low; end
                // s_lshr_b32   0x20
                24'h000020 : begin scc_val = |out_low; end
                // s_ashr_i32   0x22
                24'h000022 : begin scc_val = |out_low; end
                // default
                default : begin scc_val = 1'bx; end
            endcase
        end

        // SOPC
        {8'h04} : begin
            casex(control[23:0])
                // s_cmp_eq_i32 0x00
                24'h000000 : begin scc_val = infogen; end
                // s_cmp_lg_i32 0x01
                24'h000001 : begin scc_val = infogen; end
                // s_cmp_gt_i32 0x02
                24'h000002 : begin scc_val = infogen; end
                // s_cmp_ge_i32 0x03
                24'h000003 : begin scc_val = infogen; end
                // s_cmp_lt_i32 0x04
                24'h000004 : begin scc_val = infogen; end
                // s_cmp_le_i32 0x05
                24'h000005 : begin scc_val = infogen; end
                // s_cmp_eq_u32 0x06
                24'h000006 : begin scc_val = infogen; end
                // s_cmp_lg_u32 0x07
                24'h000007 : begin scc_val = infogen; end
								// s_cmp_gt_u32 0x08
                24'h000008 : begin scc_val = infogen; end
								// s_cmp_ge_u32 0x09
                24'h000009 : begin scc_val = infogen; end
                // s_cmp_lt_u32 0x0A
                24'h00000A : begin scc_val = infogen; end
                // s_cmp_le_u32 0x0B
                24'h00000B : begin scc_val = infogen; end
                // default
                default : begin scc_val = 1'bx; end
            endcase
        end

        // SOPK
        {8'h10} : begin
            casex(control[23:0])
                // s_addk_i32   0x0F
                24'h00000F : begin scc_val = partial_sum[31] ^ infogen; end
                // s_mulk_i32   0x10
                24'h000010 : begin scc_val = infogen; end
                // default
                default : begin scc_val = 1'bx; end
            endcase
        end
    endcase
end

endmodule
module mux_128x32b_to_1x32b (out, in, select);

  output [31:0] out;
  input [4095:0] in;
  input [6:0] select;

  reg [31:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<128; $i=$i+1)
// {
//   $low_index = 32*$i;
//   $high_index = 32*$i+31;
//   print "      7'd$i : out <= in [$high_index:$low_index];\n";
// }
// %%stop_veriperl
      7'd0 : out <= in [31:0];
      7'd1 : out <= in [63:32];
      7'd2 : out <= in [95:64];
      7'd3 : out <= in [127:96];
      7'd4 : out <= in [159:128];
      7'd5 : out <= in [191:160];
      7'd6 : out <= in [223:192];
      7'd7 : out <= in [255:224];
      7'd8 : out <= in [287:256];
      7'd9 : out <= in [319:288];
      7'd10 : out <= in [351:320];
      7'd11 : out <= in [383:352];
      7'd12 : out <= in [415:384];
      7'd13 : out <= in [447:416];
      7'd14 : out <= in [479:448];
      7'd15 : out <= in [511:480];
      7'd16 : out <= in [543:512];
      7'd17 : out <= in [575:544];
      7'd18 : out <= in [607:576];
      7'd19 : out <= in [639:608];
      7'd20 : out <= in [671:640];
      7'd21 : out <= in [703:672];
      7'd22 : out <= in [735:704];
      7'd23 : out <= in [767:736];
      7'd24 : out <= in [799:768];
      7'd25 : out <= in [831:800];
      7'd26 : out <= in [863:832];
      7'd27 : out <= in [895:864];
      7'd28 : out <= in [927:896];
      7'd29 : out <= in [959:928];
      7'd30 : out <= in [991:960];
      7'd31 : out <= in [1023:992];
      7'd32 : out <= in [1055:1024];
      7'd33 : out <= in [1087:1056];
      7'd34 : out <= in [1119:1088];
      7'd35 : out <= in [1151:1120];
      7'd36 : out <= in [1183:1152];
      7'd37 : out <= in [1215:1184];
      7'd38 : out <= in [1247:1216];
      7'd39 : out <= in [1279:1248];
      7'd40 : out <= in [1311:1280];
      7'd41 : out <= in [1343:1312];
      7'd42 : out <= in [1375:1344];
      7'd43 : out <= in [1407:1376];
      7'd44 : out <= in [1439:1408];
      7'd45 : out <= in [1471:1440];
      7'd46 : out <= in [1503:1472];
      7'd47 : out <= in [1535:1504];
      7'd48 : out <= in [1567:1536];
      7'd49 : out <= in [1599:1568];
      7'd50 : out <= in [1631:1600];
      7'd51 : out <= in [1663:1632];
      7'd52 : out <= in [1695:1664];
      7'd53 : out <= in [1727:1696];
      7'd54 : out <= in [1759:1728];
      7'd55 : out <= in [1791:1760];
      7'd56 : out <= in [1823:1792];
      7'd57 : out <= in [1855:1824];
      7'd58 : out <= in [1887:1856];
      7'd59 : out <= in [1919:1888];
      7'd60 : out <= in [1951:1920];
      7'd61 : out <= in [1983:1952];
      7'd62 : out <= in [2015:1984];
      7'd63 : out <= in [2047:2016];
      7'd64 : out <= in [2079:2048];
      7'd65 : out <= in [2111:2080];
      7'd66 : out <= in [2143:2112];
      7'd67 : out <= in [2175:2144];
      7'd68 : out <= in [2207:2176];
      7'd69 : out <= in [2239:2208];
      7'd70 : out <= in [2271:2240];
      7'd71 : out <= in [2303:2272];
      7'd72 : out <= in [2335:2304];
      7'd73 : out <= in [2367:2336];
      7'd74 : out <= in [2399:2368];
      7'd75 : out <= in [2431:2400];
      7'd76 : out <= in [2463:2432];
      7'd77 : out <= in [2495:2464];
      7'd78 : out <= in [2527:2496];
      7'd79 : out <= in [2559:2528];
      7'd80 : out <= in [2591:2560];
      7'd81 : out <= in [2623:2592];
      7'd82 : out <= in [2655:2624];
      7'd83 : out <= in [2687:2656];
      7'd84 : out <= in [2719:2688];
      7'd85 : out <= in [2751:2720];
      7'd86 : out <= in [2783:2752];
      7'd87 : out <= in [2815:2784];
      7'd88 : out <= in [2847:2816];
      7'd89 : out <= in [2879:2848];
      7'd90 : out <= in [2911:2880];
      7'd91 : out <= in [2943:2912];
      7'd92 : out <= in [2975:2944];
      7'd93 : out <= in [3007:2976];
      7'd94 : out <= in [3039:3008];
      7'd95 : out <= in [3071:3040];
      7'd96 : out <= in [3103:3072];
      7'd97 : out <= in [3135:3104];
      7'd98 : out <= in [3167:3136];
      7'd99 : out <= in [3199:3168];
      7'd100 : out <= in [3231:3200];
      7'd101 : out <= in [3263:3232];
      7'd102 : out <= in [3295:3264];
      7'd103 : out <= in [3327:3296];
      7'd104 : out <= in [3359:3328];
      7'd105 : out <= in [3391:3360];
      7'd106 : out <= in [3423:3392];
      7'd107 : out <= in [3455:3424];
      7'd108 : out <= in [3487:3456];
      7'd109 : out <= in [3519:3488];
      7'd110 : out <= in [3551:3520];
      7'd111 : out <= in [3583:3552];
      7'd112 : out <= in [3615:3584];
      7'd113 : out <= in [3647:3616];
      7'd114 : out <= in [3679:3648];
      7'd115 : out <= in [3711:3680];
      7'd116 : out <= in [3743:3712];
      7'd117 : out <= in [3775:3744];
      7'd118 : out <= in [3807:3776];
      7'd119 : out <= in [3839:3808];
      7'd120 : out <= in [3871:3840];
      7'd121 : out <= in [3903:3872];
      7'd122 : out <= in [3935:3904];
      7'd123 : out <= in [3967:3936];
      7'd124 : out <= in [3999:3968];
      7'd125 : out <= in [4031:4000];
      7'd126 : out <= in [4063:4032];
      7'd127 : out <= in [4095:4064];
      default: out <= {32{1'bx}};
    endcase
  end
endmodule
module reg_128x32b_3r_2w
(/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   clk, rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr1_addr, wr0_en,
   wr1_en, wr0_data, wr1_data
   );
input clk;

output [31:0] rd0_data;
output [31:0] rd1_data;
output [31:0] rd2_data;

input [6:0] rd0_addr;
input [6:0] rd1_addr;
input [6:0] rd2_addr;

input [6:0] wr0_addr;
input [6:0] wr1_addr;

input wr0_en;
input wr1_en;

input [31:0] wr0_data;
input [31:0] wr1_data;

wire [31:0] rd0_data_i;
wire [31:0] rd1_data_i;
wire [31:0] rd2_data_i;
   
wire [4095:0] word_out;
wire [4095:0] word_in;
wire [127:0] wr_en_word;

wire [127:0] wr0_word_select;
wire [127:0] wr1_word_select;
wire [127:0] wr0_word_enable;
wire [127:0] wr1_word_enable;

//Register file
flop_32b word[127:0](.out(word_out), .in(word_in), .wr_en(wr_en_word), .clk(clk));

//Muxes for read ports
mux_128x32b_to_1x32b mux_rd_port_0 
  (.out(rd0_data_i), .in(word_out), .select(rd0_addr));
mux_128x32b_to_1x32b mux_rd_port_1 
  (.out(rd1_data_i), .in(word_out), .select(rd1_addr));
mux_128x32b_to_1x32b mux_rd_port_2 
  (.out(rd2_data_i), .in(word_out), .select(rd2_addr));

//Write port logic
decoder_param #(7,128) decoder_wr_port_0 (.out(wr0_word_select), .in(wr0_addr));
decoder_param #(7,128) decoder_wr_port_1 (.out(wr1_word_select), .in(wr1_addr));
assign wr0_word_enable = {128{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {128{wr1_en}} & wr1_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable;

// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<128; $i=$i+1)
// {
//   $low_index = 32*$i;
//   $high_index = 32*$i+31;
//   print "assign word_in[$high_index:$low_index] = ({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b01) ? wr0_data : (({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b10) ? wr1_data : {32{1'bx}});\n";
// }
// %%stop_veriperl
assign word_in[31:0] = ({wr1_word_enable[0],wr0_word_enable[0]} == 2'b01) ? wr0_data : (({wr1_word_enable[0],wr0_word_enable[0]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[63:32] = ({wr1_word_enable[1],wr0_word_enable[1]} == 2'b01) ? wr0_data : (({wr1_word_enable[1],wr0_word_enable[1]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[95:64] = ({wr1_word_enable[2],wr0_word_enable[2]} == 2'b01) ? wr0_data : (({wr1_word_enable[2],wr0_word_enable[2]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[127:96] = ({wr1_word_enable[3],wr0_word_enable[3]} == 2'b01) ? wr0_data : (({wr1_word_enable[3],wr0_word_enable[3]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[159:128] = ({wr1_word_enable[4],wr0_word_enable[4]} == 2'b01) ? wr0_data : (({wr1_word_enable[4],wr0_word_enable[4]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[191:160] = ({wr1_word_enable[5],wr0_word_enable[5]} == 2'b01) ? wr0_data : (({wr1_word_enable[5],wr0_word_enable[5]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[223:192] = ({wr1_word_enable[6],wr0_word_enable[6]} == 2'b01) ? wr0_data : (({wr1_word_enable[6],wr0_word_enable[6]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[255:224] = ({wr1_word_enable[7],wr0_word_enable[7]} == 2'b01) ? wr0_data : (({wr1_word_enable[7],wr0_word_enable[7]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[287:256] = ({wr1_word_enable[8],wr0_word_enable[8]} == 2'b01) ? wr0_data : (({wr1_word_enable[8],wr0_word_enable[8]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[319:288] = ({wr1_word_enable[9],wr0_word_enable[9]} == 2'b01) ? wr0_data : (({wr1_word_enable[9],wr0_word_enable[9]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[351:320] = ({wr1_word_enable[10],wr0_word_enable[10]} == 2'b01) ? wr0_data : (({wr1_word_enable[10],wr0_word_enable[10]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[383:352] = ({wr1_word_enable[11],wr0_word_enable[11]} == 2'b01) ? wr0_data : (({wr1_word_enable[11],wr0_word_enable[11]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[415:384] = ({wr1_word_enable[12],wr0_word_enable[12]} == 2'b01) ? wr0_data : (({wr1_word_enable[12],wr0_word_enable[12]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[447:416] = ({wr1_word_enable[13],wr0_word_enable[13]} == 2'b01) ? wr0_data : (({wr1_word_enable[13],wr0_word_enable[13]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[479:448] = ({wr1_word_enable[14],wr0_word_enable[14]} == 2'b01) ? wr0_data : (({wr1_word_enable[14],wr0_word_enable[14]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[511:480] = ({wr1_word_enable[15],wr0_word_enable[15]} == 2'b01) ? wr0_data : (({wr1_word_enable[15],wr0_word_enable[15]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[543:512] = ({wr1_word_enable[16],wr0_word_enable[16]} == 2'b01) ? wr0_data : (({wr1_word_enable[16],wr0_word_enable[16]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[575:544] = ({wr1_word_enable[17],wr0_word_enable[17]} == 2'b01) ? wr0_data : (({wr1_word_enable[17],wr0_word_enable[17]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[607:576] = ({wr1_word_enable[18],wr0_word_enable[18]} == 2'b01) ? wr0_data : (({wr1_word_enable[18],wr0_word_enable[18]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[639:608] = ({wr1_word_enable[19],wr0_word_enable[19]} == 2'b01) ? wr0_data : (({wr1_word_enable[19],wr0_word_enable[19]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[671:640] = ({wr1_word_enable[20],wr0_word_enable[20]} == 2'b01) ? wr0_data : (({wr1_word_enable[20],wr0_word_enable[20]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[703:672] = ({wr1_word_enable[21],wr0_word_enable[21]} == 2'b01) ? wr0_data : (({wr1_word_enable[21],wr0_word_enable[21]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[735:704] = ({wr1_word_enable[22],wr0_word_enable[22]} == 2'b01) ? wr0_data : (({wr1_word_enable[22],wr0_word_enable[22]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[767:736] = ({wr1_word_enable[23],wr0_word_enable[23]} == 2'b01) ? wr0_data : (({wr1_word_enable[23],wr0_word_enable[23]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[799:768] = ({wr1_word_enable[24],wr0_word_enable[24]} == 2'b01) ? wr0_data : (({wr1_word_enable[24],wr0_word_enable[24]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[831:800] = ({wr1_word_enable[25],wr0_word_enable[25]} == 2'b01) ? wr0_data : (({wr1_word_enable[25],wr0_word_enable[25]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[863:832] = ({wr1_word_enable[26],wr0_word_enable[26]} == 2'b01) ? wr0_data : (({wr1_word_enable[26],wr0_word_enable[26]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[895:864] = ({wr1_word_enable[27],wr0_word_enable[27]} == 2'b01) ? wr0_data : (({wr1_word_enable[27],wr0_word_enable[27]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[927:896] = ({wr1_word_enable[28],wr0_word_enable[28]} == 2'b01) ? wr0_data : (({wr1_word_enable[28],wr0_word_enable[28]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[959:928] = ({wr1_word_enable[29],wr0_word_enable[29]} == 2'b01) ? wr0_data : (({wr1_word_enable[29],wr0_word_enable[29]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[991:960] = ({wr1_word_enable[30],wr0_word_enable[30]} == 2'b01) ? wr0_data : (({wr1_word_enable[30],wr0_word_enable[30]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1023:992] = ({wr1_word_enable[31],wr0_word_enable[31]} == 2'b01) ? wr0_data : (({wr1_word_enable[31],wr0_word_enable[31]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1055:1024] = ({wr1_word_enable[32],wr0_word_enable[32]} == 2'b01) ? wr0_data : (({wr1_word_enable[32],wr0_word_enable[32]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1087:1056] = ({wr1_word_enable[33],wr0_word_enable[33]} == 2'b01) ? wr0_data : (({wr1_word_enable[33],wr0_word_enable[33]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1119:1088] = ({wr1_word_enable[34],wr0_word_enable[34]} == 2'b01) ? wr0_data : (({wr1_word_enable[34],wr0_word_enable[34]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1151:1120] = ({wr1_word_enable[35],wr0_word_enable[35]} == 2'b01) ? wr0_data : (({wr1_word_enable[35],wr0_word_enable[35]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1183:1152] = ({wr1_word_enable[36],wr0_word_enable[36]} == 2'b01) ? wr0_data : (({wr1_word_enable[36],wr0_word_enable[36]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1215:1184] = ({wr1_word_enable[37],wr0_word_enable[37]} == 2'b01) ? wr0_data : (({wr1_word_enable[37],wr0_word_enable[37]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1247:1216] = ({wr1_word_enable[38],wr0_word_enable[38]} == 2'b01) ? wr0_data : (({wr1_word_enable[38],wr0_word_enable[38]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1279:1248] = ({wr1_word_enable[39],wr0_word_enable[39]} == 2'b01) ? wr0_data : (({wr1_word_enable[39],wr0_word_enable[39]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1311:1280] = ({wr1_word_enable[40],wr0_word_enable[40]} == 2'b01) ? wr0_data : (({wr1_word_enable[40],wr0_word_enable[40]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1343:1312] = ({wr1_word_enable[41],wr0_word_enable[41]} == 2'b01) ? wr0_data : (({wr1_word_enable[41],wr0_word_enable[41]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1375:1344] = ({wr1_word_enable[42],wr0_word_enable[42]} == 2'b01) ? wr0_data : (({wr1_word_enable[42],wr0_word_enable[42]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1407:1376] = ({wr1_word_enable[43],wr0_word_enable[43]} == 2'b01) ? wr0_data : (({wr1_word_enable[43],wr0_word_enable[43]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1439:1408] = ({wr1_word_enable[44],wr0_word_enable[44]} == 2'b01) ? wr0_data : (({wr1_word_enable[44],wr0_word_enable[44]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1471:1440] = ({wr1_word_enable[45],wr0_word_enable[45]} == 2'b01) ? wr0_data : (({wr1_word_enable[45],wr0_word_enable[45]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1503:1472] = ({wr1_word_enable[46],wr0_word_enable[46]} == 2'b01) ? wr0_data : (({wr1_word_enable[46],wr0_word_enable[46]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1535:1504] = ({wr1_word_enable[47],wr0_word_enable[47]} == 2'b01) ? wr0_data : (({wr1_word_enable[47],wr0_word_enable[47]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1567:1536] = ({wr1_word_enable[48],wr0_word_enable[48]} == 2'b01) ? wr0_data : (({wr1_word_enable[48],wr0_word_enable[48]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1599:1568] = ({wr1_word_enable[49],wr0_word_enable[49]} == 2'b01) ? wr0_data : (({wr1_word_enable[49],wr0_word_enable[49]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1631:1600] = ({wr1_word_enable[50],wr0_word_enable[50]} == 2'b01) ? wr0_data : (({wr1_word_enable[50],wr0_word_enable[50]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1663:1632] = ({wr1_word_enable[51],wr0_word_enable[51]} == 2'b01) ? wr0_data : (({wr1_word_enable[51],wr0_word_enable[51]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1695:1664] = ({wr1_word_enable[52],wr0_word_enable[52]} == 2'b01) ? wr0_data : (({wr1_word_enable[52],wr0_word_enable[52]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1727:1696] = ({wr1_word_enable[53],wr0_word_enable[53]} == 2'b01) ? wr0_data : (({wr1_word_enable[53],wr0_word_enable[53]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1759:1728] = ({wr1_word_enable[54],wr0_word_enable[54]} == 2'b01) ? wr0_data : (({wr1_word_enable[54],wr0_word_enable[54]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1791:1760] = ({wr1_word_enable[55],wr0_word_enable[55]} == 2'b01) ? wr0_data : (({wr1_word_enable[55],wr0_word_enable[55]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1823:1792] = ({wr1_word_enable[56],wr0_word_enable[56]} == 2'b01) ? wr0_data : (({wr1_word_enable[56],wr0_word_enable[56]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1855:1824] = ({wr1_word_enable[57],wr0_word_enable[57]} == 2'b01) ? wr0_data : (({wr1_word_enable[57],wr0_word_enable[57]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1887:1856] = ({wr1_word_enable[58],wr0_word_enable[58]} == 2'b01) ? wr0_data : (({wr1_word_enable[58],wr0_word_enable[58]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1919:1888] = ({wr1_word_enable[59],wr0_word_enable[59]} == 2'b01) ? wr0_data : (({wr1_word_enable[59],wr0_word_enable[59]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1951:1920] = ({wr1_word_enable[60],wr0_word_enable[60]} == 2'b01) ? wr0_data : (({wr1_word_enable[60],wr0_word_enable[60]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1983:1952] = ({wr1_word_enable[61],wr0_word_enable[61]} == 2'b01) ? wr0_data : (({wr1_word_enable[61],wr0_word_enable[61]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2015:1984] = ({wr1_word_enable[62],wr0_word_enable[62]} == 2'b01) ? wr0_data : (({wr1_word_enable[62],wr0_word_enable[62]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2047:2016] = ({wr1_word_enable[63],wr0_word_enable[63]} == 2'b01) ? wr0_data : (({wr1_word_enable[63],wr0_word_enable[63]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2079:2048] = ({wr1_word_enable[64],wr0_word_enable[64]} == 2'b01) ? wr0_data : (({wr1_word_enable[64],wr0_word_enable[64]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2111:2080] = ({wr1_word_enable[65],wr0_word_enable[65]} == 2'b01) ? wr0_data : (({wr1_word_enable[65],wr0_word_enable[65]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2143:2112] = ({wr1_word_enable[66],wr0_word_enable[66]} == 2'b01) ? wr0_data : (({wr1_word_enable[66],wr0_word_enable[66]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2175:2144] = ({wr1_word_enable[67],wr0_word_enable[67]} == 2'b01) ? wr0_data : (({wr1_word_enable[67],wr0_word_enable[67]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2207:2176] = ({wr1_word_enable[68],wr0_word_enable[68]} == 2'b01) ? wr0_data : (({wr1_word_enable[68],wr0_word_enable[68]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2239:2208] = ({wr1_word_enable[69],wr0_word_enable[69]} == 2'b01) ? wr0_data : (({wr1_word_enable[69],wr0_word_enable[69]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2271:2240] = ({wr1_word_enable[70],wr0_word_enable[70]} == 2'b01) ? wr0_data : (({wr1_word_enable[70],wr0_word_enable[70]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2303:2272] = ({wr1_word_enable[71],wr0_word_enable[71]} == 2'b01) ? wr0_data : (({wr1_word_enable[71],wr0_word_enable[71]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2335:2304] = ({wr1_word_enable[72],wr0_word_enable[72]} == 2'b01) ? wr0_data : (({wr1_word_enable[72],wr0_word_enable[72]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2367:2336] = ({wr1_word_enable[73],wr0_word_enable[73]} == 2'b01) ? wr0_data : (({wr1_word_enable[73],wr0_word_enable[73]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2399:2368] = ({wr1_word_enable[74],wr0_word_enable[74]} == 2'b01) ? wr0_data : (({wr1_word_enable[74],wr0_word_enable[74]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2431:2400] = ({wr1_word_enable[75],wr0_word_enable[75]} == 2'b01) ? wr0_data : (({wr1_word_enable[75],wr0_word_enable[75]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2463:2432] = ({wr1_word_enable[76],wr0_word_enable[76]} == 2'b01) ? wr0_data : (({wr1_word_enable[76],wr0_word_enable[76]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2495:2464] = ({wr1_word_enable[77],wr0_word_enable[77]} == 2'b01) ? wr0_data : (({wr1_word_enable[77],wr0_word_enable[77]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2527:2496] = ({wr1_word_enable[78],wr0_word_enable[78]} == 2'b01) ? wr0_data : (({wr1_word_enable[78],wr0_word_enable[78]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2559:2528] = ({wr1_word_enable[79],wr0_word_enable[79]} == 2'b01) ? wr0_data : (({wr1_word_enable[79],wr0_word_enable[79]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2591:2560] = ({wr1_word_enable[80],wr0_word_enable[80]} == 2'b01) ? wr0_data : (({wr1_word_enable[80],wr0_word_enable[80]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2623:2592] = ({wr1_word_enable[81],wr0_word_enable[81]} == 2'b01) ? wr0_data : (({wr1_word_enable[81],wr0_word_enable[81]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2655:2624] = ({wr1_word_enable[82],wr0_word_enable[82]} == 2'b01) ? wr0_data : (({wr1_word_enable[82],wr0_word_enable[82]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2687:2656] = ({wr1_word_enable[83],wr0_word_enable[83]} == 2'b01) ? wr0_data : (({wr1_word_enable[83],wr0_word_enable[83]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2719:2688] = ({wr1_word_enable[84],wr0_word_enable[84]} == 2'b01) ? wr0_data : (({wr1_word_enable[84],wr0_word_enable[84]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2751:2720] = ({wr1_word_enable[85],wr0_word_enable[85]} == 2'b01) ? wr0_data : (({wr1_word_enable[85],wr0_word_enable[85]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2783:2752] = ({wr1_word_enable[86],wr0_word_enable[86]} == 2'b01) ? wr0_data : (({wr1_word_enable[86],wr0_word_enable[86]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2815:2784] = ({wr1_word_enable[87],wr0_word_enable[87]} == 2'b01) ? wr0_data : (({wr1_word_enable[87],wr0_word_enable[87]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2847:2816] = ({wr1_word_enable[88],wr0_word_enable[88]} == 2'b01) ? wr0_data : (({wr1_word_enable[88],wr0_word_enable[88]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2879:2848] = ({wr1_word_enable[89],wr0_word_enable[89]} == 2'b01) ? wr0_data : (({wr1_word_enable[89],wr0_word_enable[89]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2911:2880] = ({wr1_word_enable[90],wr0_word_enable[90]} == 2'b01) ? wr0_data : (({wr1_word_enable[90],wr0_word_enable[90]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2943:2912] = ({wr1_word_enable[91],wr0_word_enable[91]} == 2'b01) ? wr0_data : (({wr1_word_enable[91],wr0_word_enable[91]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2975:2944] = ({wr1_word_enable[92],wr0_word_enable[92]} == 2'b01) ? wr0_data : (({wr1_word_enable[92],wr0_word_enable[92]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3007:2976] = ({wr1_word_enable[93],wr0_word_enable[93]} == 2'b01) ? wr0_data : (({wr1_word_enable[93],wr0_word_enable[93]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3039:3008] = ({wr1_word_enable[94],wr0_word_enable[94]} == 2'b01) ? wr0_data : (({wr1_word_enable[94],wr0_word_enable[94]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3071:3040] = ({wr1_word_enable[95],wr0_word_enable[95]} == 2'b01) ? wr0_data : (({wr1_word_enable[95],wr0_word_enable[95]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3103:3072] = ({wr1_word_enable[96],wr0_word_enable[96]} == 2'b01) ? wr0_data : (({wr1_word_enable[96],wr0_word_enable[96]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3135:3104] = ({wr1_word_enable[97],wr0_word_enable[97]} == 2'b01) ? wr0_data : (({wr1_word_enable[97],wr0_word_enable[97]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3167:3136] = ({wr1_word_enable[98],wr0_word_enable[98]} == 2'b01) ? wr0_data : (({wr1_word_enable[98],wr0_word_enable[98]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3199:3168] = ({wr1_word_enable[99],wr0_word_enable[99]} == 2'b01) ? wr0_data : (({wr1_word_enable[99],wr0_word_enable[99]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3231:3200] = ({wr1_word_enable[100],wr0_word_enable[100]} == 2'b01) ? wr0_data : (({wr1_word_enable[100],wr0_word_enable[100]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3263:3232] = ({wr1_word_enable[101],wr0_word_enable[101]} == 2'b01) ? wr0_data : (({wr1_word_enable[101],wr0_word_enable[101]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3295:3264] = ({wr1_word_enable[102],wr0_word_enable[102]} == 2'b01) ? wr0_data : (({wr1_word_enable[102],wr0_word_enable[102]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3327:3296] = ({wr1_word_enable[103],wr0_word_enable[103]} == 2'b01) ? wr0_data : (({wr1_word_enable[103],wr0_word_enable[103]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3359:3328] = ({wr1_word_enable[104],wr0_word_enable[104]} == 2'b01) ? wr0_data : (({wr1_word_enable[104],wr0_word_enable[104]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3391:3360] = ({wr1_word_enable[105],wr0_word_enable[105]} == 2'b01) ? wr0_data : (({wr1_word_enable[105],wr0_word_enable[105]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3423:3392] = ({wr1_word_enable[106],wr0_word_enable[106]} == 2'b01) ? wr0_data : (({wr1_word_enable[106],wr0_word_enable[106]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3455:3424] = ({wr1_word_enable[107],wr0_word_enable[107]} == 2'b01) ? wr0_data : (({wr1_word_enable[107],wr0_word_enable[107]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3487:3456] = ({wr1_word_enable[108],wr0_word_enable[108]} == 2'b01) ? wr0_data : (({wr1_word_enable[108],wr0_word_enable[108]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3519:3488] = ({wr1_word_enable[109],wr0_word_enable[109]} == 2'b01) ? wr0_data : (({wr1_word_enable[109],wr0_word_enable[109]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3551:3520] = ({wr1_word_enable[110],wr0_word_enable[110]} == 2'b01) ? wr0_data : (({wr1_word_enable[110],wr0_word_enable[110]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3583:3552] = ({wr1_word_enable[111],wr0_word_enable[111]} == 2'b01) ? wr0_data : (({wr1_word_enable[111],wr0_word_enable[111]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3615:3584] = ({wr1_word_enable[112],wr0_word_enable[112]} == 2'b01) ? wr0_data : (({wr1_word_enable[112],wr0_word_enable[112]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3647:3616] = ({wr1_word_enable[113],wr0_word_enable[113]} == 2'b01) ? wr0_data : (({wr1_word_enable[113],wr0_word_enable[113]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3679:3648] = ({wr1_word_enable[114],wr0_word_enable[114]} == 2'b01) ? wr0_data : (({wr1_word_enable[114],wr0_word_enable[114]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3711:3680] = ({wr1_word_enable[115],wr0_word_enable[115]} == 2'b01) ? wr0_data : (({wr1_word_enable[115],wr0_word_enable[115]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3743:3712] = ({wr1_word_enable[116],wr0_word_enable[116]} == 2'b01) ? wr0_data : (({wr1_word_enable[116],wr0_word_enable[116]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3775:3744] = ({wr1_word_enable[117],wr0_word_enable[117]} == 2'b01) ? wr0_data : (({wr1_word_enable[117],wr0_word_enable[117]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3807:3776] = ({wr1_word_enable[118],wr0_word_enable[118]} == 2'b01) ? wr0_data : (({wr1_word_enable[118],wr0_word_enable[118]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3839:3808] = ({wr1_word_enable[119],wr0_word_enable[119]} == 2'b01) ? wr0_data : (({wr1_word_enable[119],wr0_word_enable[119]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3871:3840] = ({wr1_word_enable[120],wr0_word_enable[120]} == 2'b01) ? wr0_data : (({wr1_word_enable[120],wr0_word_enable[120]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3903:3872] = ({wr1_word_enable[121],wr0_word_enable[121]} == 2'b01) ? wr0_data : (({wr1_word_enable[121],wr0_word_enable[121]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3935:3904] = ({wr1_word_enable[122],wr0_word_enable[122]} == 2'b01) ? wr0_data : (({wr1_word_enable[122],wr0_word_enable[122]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3967:3936] = ({wr1_word_enable[123],wr0_word_enable[123]} == 2'b01) ? wr0_data : (({wr1_word_enable[123],wr0_word_enable[123]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3999:3968] = ({wr1_word_enable[124],wr0_word_enable[124]} == 2'b01) ? wr0_data : (({wr1_word_enable[124],wr0_word_enable[124]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4031:4000] = ({wr1_word_enable[125],wr0_word_enable[125]} == 2'b01) ? wr0_data : (({wr1_word_enable[125],wr0_word_enable[125]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4063:4032] = ({wr1_word_enable[126],wr0_word_enable[126]} == 2'b01) ? wr0_data : (({wr1_word_enable[126],wr0_word_enable[126]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4095:4064] = ({wr1_word_enable[127],wr0_word_enable[127]} == 2'b01) ? wr0_data : (({wr1_word_enable[127],wr0_word_enable[127]} == 2'b10) ? wr1_data : {32{1'bx}});

  // Output flop on the read ports.
  dff_en rd_port_0_out_flop[31:0]
    (.q(rd0_data),
     .d(rd0_data_i),
     .en(1'b1),
     .clk(clk),
     .rst(1'b0));

  dff_en rd_port_1_out_flop[31:0]
    (.q(rd1_data),
     .d(rd1_data_i),
     .en(1'b1),
     .clk(clk),
     .rst(1'b0));

  dff_en rd_port_2_out_flop[31:0]
    (.q(rd2_data),
     .d(rd2_data_i),
     .en(1'b1),
     .clk(clk),
     .rst(1'b0));

/*   // For now disable this flop
   assign rd0_data = rd0_data_i;
   assign rd1_data = rd1_data_i;
   assign rd2_data = rd2_data_i;*/

endmodule
module reg_128x32b_3r_3w
(
  rd0_data, rd1_data, rd2_data,
  clk,
  rd0_addr, rd1_addr, rd2_addr,
  wr0_addr, wr1_addr, wr2_addr,
  wr0_en, wr1_en, wr2_en, wr0_data, wr1_data, wr2_data
);
input clk;

output [31:0] rd0_data;
output [31:0] rd1_data;
output [31:0] rd2_data;

input [6:0] rd0_addr;
input [6:0] rd1_addr;
input [6:0] rd2_addr;

input [6:0] wr0_addr;
input [6:0] wr1_addr;
input [6:0] wr2_addr;

input wr0_en;
input wr1_en;
input wr2_en;

input [31:0] wr0_data;
input [31:0] wr1_data;
input [31:0] wr2_data;

wire [4095:0] word_out;
wire [4095:0] word_in;
wire [127:0] wr_en_word;

wire [127:0] wr0_word_select;
wire [127:0] wr1_word_select;
wire [127:0] wr2_word_select;
wire [127:0] wr0_word_enable;
wire [127:0] wr1_word_enable;
wire [127:0] wr2_word_enable;

//Register file
flop_32b word[127:0](.out(word_out), .in(word_in), .wr_en(wr_en_word), .clk(clk));

//Muxes for read ports
mux_128x32b_to_1x32b mux_rd_port_0 (.out(rd0_data), .in(word_out), .select(rd0_addr));
mux_128x32b_to_1x32b mux_rd_port_1 (.out(rd1_data), .in(word_out), .select(rd1_addr));
mux_128x32b_to_1x32b mux_rd_port_2 (.out(rd2_data), .in(word_out), .select(rd2_addr));

//Write port logic
decoder_param #(7,128) decoder_wr_port_0 (.out(wr0_word_select), .in(wr0_addr));
decoder_param #(7,128) decoder_wr_port_1 (.out(wr1_word_select), .in(wr1_addr));
decoder_param #(7,128) decoder_wr_port_2 (.out(wr2_word_select), .in(wr2_addr));
assign wr0_word_enable = {128{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {128{wr1_en}} & wr1_word_select;
assign wr2_word_enable = {128{wr2_en}} & wr2_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable | wr2_word_enable;

// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<128; $i=$i+1)
// {
//   $low_index = 32*$i;
//   $high_index = 32*$i+31;
//   print "assign word_in[$high_index:$low_index] = ({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b001) ? wr0_data : (({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[$i],wr1_word_enable[$i],wr0_word_enable[$i]} == 3'b100)? wr2_data : {32{1'bx}}));\n";
// }
// %%stop_veriperl
assign word_in[31:0] = ({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b001) ? wr0_data : (({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[0],wr1_word_enable[0],wr0_word_enable[0]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[63:32] = ({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b001) ? wr0_data : (({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[1],wr1_word_enable[1],wr0_word_enable[1]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[95:64] = ({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b001) ? wr0_data : (({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[2],wr1_word_enable[2],wr0_word_enable[2]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[127:96] = ({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b001) ? wr0_data : (({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[3],wr1_word_enable[3],wr0_word_enable[3]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[159:128] = ({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b001) ? wr0_data : (({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[4],wr1_word_enable[4],wr0_word_enable[4]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[191:160] = ({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b001) ? wr0_data : (({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[5],wr1_word_enable[5],wr0_word_enable[5]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[223:192] = ({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b001) ? wr0_data : (({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[6],wr1_word_enable[6],wr0_word_enable[6]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[255:224] = ({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b001) ? wr0_data : (({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[7],wr1_word_enable[7],wr0_word_enable[7]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[287:256] = ({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b001) ? wr0_data : (({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[8],wr1_word_enable[8],wr0_word_enable[8]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[319:288] = ({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b001) ? wr0_data : (({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[9],wr1_word_enable[9],wr0_word_enable[9]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[351:320] = ({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b001) ? wr0_data : (({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[10],wr1_word_enable[10],wr0_word_enable[10]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[383:352] = ({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b001) ? wr0_data : (({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[11],wr1_word_enable[11],wr0_word_enable[11]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[415:384] = ({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b001) ? wr0_data : (({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[12],wr1_word_enable[12],wr0_word_enable[12]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[447:416] = ({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b001) ? wr0_data : (({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[13],wr1_word_enable[13],wr0_word_enable[13]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[479:448] = ({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b001) ? wr0_data : (({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[14],wr1_word_enable[14],wr0_word_enable[14]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[511:480] = ({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b001) ? wr0_data : (({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[15],wr1_word_enable[15],wr0_word_enable[15]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[543:512] = ({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b001) ? wr0_data : (({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[16],wr1_word_enable[16],wr0_word_enable[16]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[575:544] = ({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b001) ? wr0_data : (({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[17],wr1_word_enable[17],wr0_word_enable[17]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[607:576] = ({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b001) ? wr0_data : (({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[18],wr1_word_enable[18],wr0_word_enable[18]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[639:608] = ({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b001) ? wr0_data : (({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[19],wr1_word_enable[19],wr0_word_enable[19]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[671:640] = ({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b001) ? wr0_data : (({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[20],wr1_word_enable[20],wr0_word_enable[20]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[703:672] = ({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b001) ? wr0_data : (({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[21],wr1_word_enable[21],wr0_word_enable[21]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[735:704] = ({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b001) ? wr0_data : (({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[22],wr1_word_enable[22],wr0_word_enable[22]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[767:736] = ({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b001) ? wr0_data : (({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[23],wr1_word_enable[23],wr0_word_enable[23]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[799:768] = ({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b001) ? wr0_data : (({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[24],wr1_word_enable[24],wr0_word_enable[24]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[831:800] = ({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b001) ? wr0_data : (({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[25],wr1_word_enable[25],wr0_word_enable[25]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[863:832] = ({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b001) ? wr0_data : (({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[26],wr1_word_enable[26],wr0_word_enable[26]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[895:864] = ({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b001) ? wr0_data : (({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[27],wr1_word_enable[27],wr0_word_enable[27]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[927:896] = ({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b001) ? wr0_data : (({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[28],wr1_word_enable[28],wr0_word_enable[28]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[959:928] = ({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b001) ? wr0_data : (({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[29],wr1_word_enable[29],wr0_word_enable[29]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[991:960] = ({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b001) ? wr0_data : (({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[30],wr1_word_enable[30],wr0_word_enable[30]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1023:992] = ({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b001) ? wr0_data : (({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[31],wr1_word_enable[31],wr0_word_enable[31]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1055:1024] = ({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b001) ? wr0_data : (({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[32],wr1_word_enable[32],wr0_word_enable[32]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1087:1056] = ({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b001) ? wr0_data : (({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[33],wr1_word_enable[33],wr0_word_enable[33]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1119:1088] = ({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b001) ? wr0_data : (({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[34],wr1_word_enable[34],wr0_word_enable[34]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1151:1120] = ({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b001) ? wr0_data : (({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[35],wr1_word_enable[35],wr0_word_enable[35]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1183:1152] = ({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b001) ? wr0_data : (({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[36],wr1_word_enable[36],wr0_word_enable[36]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1215:1184] = ({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b001) ? wr0_data : (({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[37],wr1_word_enable[37],wr0_word_enable[37]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1247:1216] = ({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b001) ? wr0_data : (({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[38],wr1_word_enable[38],wr0_word_enable[38]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1279:1248] = ({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b001) ? wr0_data : (({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[39],wr1_word_enable[39],wr0_word_enable[39]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1311:1280] = ({wr2_word_enable[40],wr1_word_enable[40],wr0_word_enable[40]} == 3'b001) ? wr0_data : (({wr2_word_enable[40],wr1_word_enable[40],wr0_word_enable[40]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[40],wr1_word_enable[40],wr0_word_enable[40]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1343:1312] = ({wr2_word_enable[41],wr1_word_enable[41],wr0_word_enable[41]} == 3'b001) ? wr0_data : (({wr2_word_enable[41],wr1_word_enable[41],wr0_word_enable[41]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[41],wr1_word_enable[41],wr0_word_enable[41]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1375:1344] = ({wr2_word_enable[42],wr1_word_enable[42],wr0_word_enable[42]} == 3'b001) ? wr0_data : (({wr2_word_enable[42],wr1_word_enable[42],wr0_word_enable[42]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[42],wr1_word_enable[42],wr0_word_enable[42]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1407:1376] = ({wr2_word_enable[43],wr1_word_enable[43],wr0_word_enable[43]} == 3'b001) ? wr0_data : (({wr2_word_enable[43],wr1_word_enable[43],wr0_word_enable[43]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[43],wr1_word_enable[43],wr0_word_enable[43]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1439:1408] = ({wr2_word_enable[44],wr1_word_enable[44],wr0_word_enable[44]} == 3'b001) ? wr0_data : (({wr2_word_enable[44],wr1_word_enable[44],wr0_word_enable[44]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[44],wr1_word_enable[44],wr0_word_enable[44]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1471:1440] = ({wr2_word_enable[45],wr1_word_enable[45],wr0_word_enable[45]} == 3'b001) ? wr0_data : (({wr2_word_enable[45],wr1_word_enable[45],wr0_word_enable[45]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[45],wr1_word_enable[45],wr0_word_enable[45]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1503:1472] = ({wr2_word_enable[46],wr1_word_enable[46],wr0_word_enable[46]} == 3'b001) ? wr0_data : (({wr2_word_enable[46],wr1_word_enable[46],wr0_word_enable[46]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[46],wr1_word_enable[46],wr0_word_enable[46]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1535:1504] = ({wr2_word_enable[47],wr1_word_enable[47],wr0_word_enable[47]} == 3'b001) ? wr0_data : (({wr2_word_enable[47],wr1_word_enable[47],wr0_word_enable[47]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[47],wr1_word_enable[47],wr0_word_enable[47]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1567:1536] = ({wr2_word_enable[48],wr1_word_enable[48],wr0_word_enable[48]} == 3'b001) ? wr0_data : (({wr2_word_enable[48],wr1_word_enable[48],wr0_word_enable[48]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[48],wr1_word_enable[48],wr0_word_enable[48]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1599:1568] = ({wr2_word_enable[49],wr1_word_enable[49],wr0_word_enable[49]} == 3'b001) ? wr0_data : (({wr2_word_enable[49],wr1_word_enable[49],wr0_word_enable[49]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[49],wr1_word_enable[49],wr0_word_enable[49]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1631:1600] = ({wr2_word_enable[50],wr1_word_enable[50],wr0_word_enable[50]} == 3'b001) ? wr0_data : (({wr2_word_enable[50],wr1_word_enable[50],wr0_word_enable[50]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[50],wr1_word_enable[50],wr0_word_enable[50]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1663:1632] = ({wr2_word_enable[51],wr1_word_enable[51],wr0_word_enable[51]} == 3'b001) ? wr0_data : (({wr2_word_enable[51],wr1_word_enable[51],wr0_word_enable[51]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[51],wr1_word_enable[51],wr0_word_enable[51]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1695:1664] = ({wr2_word_enable[52],wr1_word_enable[52],wr0_word_enable[52]} == 3'b001) ? wr0_data : (({wr2_word_enable[52],wr1_word_enable[52],wr0_word_enable[52]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[52],wr1_word_enable[52],wr0_word_enable[52]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1727:1696] = ({wr2_word_enable[53],wr1_word_enable[53],wr0_word_enable[53]} == 3'b001) ? wr0_data : (({wr2_word_enable[53],wr1_word_enable[53],wr0_word_enable[53]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[53],wr1_word_enable[53],wr0_word_enable[53]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1759:1728] = ({wr2_word_enable[54],wr1_word_enable[54],wr0_word_enable[54]} == 3'b001) ? wr0_data : (({wr2_word_enable[54],wr1_word_enable[54],wr0_word_enable[54]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[54],wr1_word_enable[54],wr0_word_enable[54]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1791:1760] = ({wr2_word_enable[55],wr1_word_enable[55],wr0_word_enable[55]} == 3'b001) ? wr0_data : (({wr2_word_enable[55],wr1_word_enable[55],wr0_word_enable[55]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[55],wr1_word_enable[55],wr0_word_enable[55]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1823:1792] = ({wr2_word_enable[56],wr1_word_enable[56],wr0_word_enable[56]} == 3'b001) ? wr0_data : (({wr2_word_enable[56],wr1_word_enable[56],wr0_word_enable[56]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[56],wr1_word_enable[56],wr0_word_enable[56]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1855:1824] = ({wr2_word_enable[57],wr1_word_enable[57],wr0_word_enable[57]} == 3'b001) ? wr0_data : (({wr2_word_enable[57],wr1_word_enable[57],wr0_word_enable[57]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[57],wr1_word_enable[57],wr0_word_enable[57]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1887:1856] = ({wr2_word_enable[58],wr1_word_enable[58],wr0_word_enable[58]} == 3'b001) ? wr0_data : (({wr2_word_enable[58],wr1_word_enable[58],wr0_word_enable[58]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[58],wr1_word_enable[58],wr0_word_enable[58]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1919:1888] = ({wr2_word_enable[59],wr1_word_enable[59],wr0_word_enable[59]} == 3'b001) ? wr0_data : (({wr2_word_enable[59],wr1_word_enable[59],wr0_word_enable[59]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[59],wr1_word_enable[59],wr0_word_enable[59]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1951:1920] = ({wr2_word_enable[60],wr1_word_enable[60],wr0_word_enable[60]} == 3'b001) ? wr0_data : (({wr2_word_enable[60],wr1_word_enable[60],wr0_word_enable[60]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[60],wr1_word_enable[60],wr0_word_enable[60]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[1983:1952] = ({wr2_word_enable[61],wr1_word_enable[61],wr0_word_enable[61]} == 3'b001) ? wr0_data : (({wr2_word_enable[61],wr1_word_enable[61],wr0_word_enable[61]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[61],wr1_word_enable[61],wr0_word_enable[61]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2015:1984] = ({wr2_word_enable[62],wr1_word_enable[62],wr0_word_enable[62]} == 3'b001) ? wr0_data : (({wr2_word_enable[62],wr1_word_enable[62],wr0_word_enable[62]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[62],wr1_word_enable[62],wr0_word_enable[62]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2047:2016] = ({wr2_word_enable[63],wr1_word_enable[63],wr0_word_enable[63]} == 3'b001) ? wr0_data : (({wr2_word_enable[63],wr1_word_enable[63],wr0_word_enable[63]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[63],wr1_word_enable[63],wr0_word_enable[63]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2079:2048] = ({wr2_word_enable[64],wr1_word_enable[64],wr0_word_enable[64]} == 3'b001) ? wr0_data : (({wr2_word_enable[64],wr1_word_enable[64],wr0_word_enable[64]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[64],wr1_word_enable[64],wr0_word_enable[64]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2111:2080] = ({wr2_word_enable[65],wr1_word_enable[65],wr0_word_enable[65]} == 3'b001) ? wr0_data : (({wr2_word_enable[65],wr1_word_enable[65],wr0_word_enable[65]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[65],wr1_word_enable[65],wr0_word_enable[65]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2143:2112] = ({wr2_word_enable[66],wr1_word_enable[66],wr0_word_enable[66]} == 3'b001) ? wr0_data : (({wr2_word_enable[66],wr1_word_enable[66],wr0_word_enable[66]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[66],wr1_word_enable[66],wr0_word_enable[66]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2175:2144] = ({wr2_word_enable[67],wr1_word_enable[67],wr0_word_enable[67]} == 3'b001) ? wr0_data : (({wr2_word_enable[67],wr1_word_enable[67],wr0_word_enable[67]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[67],wr1_word_enable[67],wr0_word_enable[67]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2207:2176] = ({wr2_word_enable[68],wr1_word_enable[68],wr0_word_enable[68]} == 3'b001) ? wr0_data : (({wr2_word_enable[68],wr1_word_enable[68],wr0_word_enable[68]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[68],wr1_word_enable[68],wr0_word_enable[68]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2239:2208] = ({wr2_word_enable[69],wr1_word_enable[69],wr0_word_enable[69]} == 3'b001) ? wr0_data : (({wr2_word_enable[69],wr1_word_enable[69],wr0_word_enable[69]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[69],wr1_word_enable[69],wr0_word_enable[69]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2271:2240] = ({wr2_word_enable[70],wr1_word_enable[70],wr0_word_enable[70]} == 3'b001) ? wr0_data : (({wr2_word_enable[70],wr1_word_enable[70],wr0_word_enable[70]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[70],wr1_word_enable[70],wr0_word_enable[70]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2303:2272] = ({wr2_word_enable[71],wr1_word_enable[71],wr0_word_enable[71]} == 3'b001) ? wr0_data : (({wr2_word_enable[71],wr1_word_enable[71],wr0_word_enable[71]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[71],wr1_word_enable[71],wr0_word_enable[71]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2335:2304] = ({wr2_word_enable[72],wr1_word_enable[72],wr0_word_enable[72]} == 3'b001) ? wr0_data : (({wr2_word_enable[72],wr1_word_enable[72],wr0_word_enable[72]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[72],wr1_word_enable[72],wr0_word_enable[72]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2367:2336] = ({wr2_word_enable[73],wr1_word_enable[73],wr0_word_enable[73]} == 3'b001) ? wr0_data : (({wr2_word_enable[73],wr1_word_enable[73],wr0_word_enable[73]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[73],wr1_word_enable[73],wr0_word_enable[73]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2399:2368] = ({wr2_word_enable[74],wr1_word_enable[74],wr0_word_enable[74]} == 3'b001) ? wr0_data : (({wr2_word_enable[74],wr1_word_enable[74],wr0_word_enable[74]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[74],wr1_word_enable[74],wr0_word_enable[74]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2431:2400] = ({wr2_word_enable[75],wr1_word_enable[75],wr0_word_enable[75]} == 3'b001) ? wr0_data : (({wr2_word_enable[75],wr1_word_enable[75],wr0_word_enable[75]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[75],wr1_word_enable[75],wr0_word_enable[75]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2463:2432] = ({wr2_word_enable[76],wr1_word_enable[76],wr0_word_enable[76]} == 3'b001) ? wr0_data : (({wr2_word_enable[76],wr1_word_enable[76],wr0_word_enable[76]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[76],wr1_word_enable[76],wr0_word_enable[76]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2495:2464] = ({wr2_word_enable[77],wr1_word_enable[77],wr0_word_enable[77]} == 3'b001) ? wr0_data : (({wr2_word_enable[77],wr1_word_enable[77],wr0_word_enable[77]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[77],wr1_word_enable[77],wr0_word_enable[77]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2527:2496] = ({wr2_word_enable[78],wr1_word_enable[78],wr0_word_enable[78]} == 3'b001) ? wr0_data : (({wr2_word_enable[78],wr1_word_enable[78],wr0_word_enable[78]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[78],wr1_word_enable[78],wr0_word_enable[78]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2559:2528] = ({wr2_word_enable[79],wr1_word_enable[79],wr0_word_enable[79]} == 3'b001) ? wr0_data : (({wr2_word_enable[79],wr1_word_enable[79],wr0_word_enable[79]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[79],wr1_word_enable[79],wr0_word_enable[79]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2591:2560] = ({wr2_word_enable[80],wr1_word_enable[80],wr0_word_enable[80]} == 3'b001) ? wr0_data : (({wr2_word_enable[80],wr1_word_enable[80],wr0_word_enable[80]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[80],wr1_word_enable[80],wr0_word_enable[80]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2623:2592] = ({wr2_word_enable[81],wr1_word_enable[81],wr0_word_enable[81]} == 3'b001) ? wr0_data : (({wr2_word_enable[81],wr1_word_enable[81],wr0_word_enable[81]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[81],wr1_word_enable[81],wr0_word_enable[81]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2655:2624] = ({wr2_word_enable[82],wr1_word_enable[82],wr0_word_enable[82]} == 3'b001) ? wr0_data : (({wr2_word_enable[82],wr1_word_enable[82],wr0_word_enable[82]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[82],wr1_word_enable[82],wr0_word_enable[82]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2687:2656] = ({wr2_word_enable[83],wr1_word_enable[83],wr0_word_enable[83]} == 3'b001) ? wr0_data : (({wr2_word_enable[83],wr1_word_enable[83],wr0_word_enable[83]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[83],wr1_word_enable[83],wr0_word_enable[83]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2719:2688] = ({wr2_word_enable[84],wr1_word_enable[84],wr0_word_enable[84]} == 3'b001) ? wr0_data : (({wr2_word_enable[84],wr1_word_enable[84],wr0_word_enable[84]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[84],wr1_word_enable[84],wr0_word_enable[84]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2751:2720] = ({wr2_word_enable[85],wr1_word_enable[85],wr0_word_enable[85]} == 3'b001) ? wr0_data : (({wr2_word_enable[85],wr1_word_enable[85],wr0_word_enable[85]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[85],wr1_word_enable[85],wr0_word_enable[85]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2783:2752] = ({wr2_word_enable[86],wr1_word_enable[86],wr0_word_enable[86]} == 3'b001) ? wr0_data : (({wr2_word_enable[86],wr1_word_enable[86],wr0_word_enable[86]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[86],wr1_word_enable[86],wr0_word_enable[86]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2815:2784] = ({wr2_word_enable[87],wr1_word_enable[87],wr0_word_enable[87]} == 3'b001) ? wr0_data : (({wr2_word_enable[87],wr1_word_enable[87],wr0_word_enable[87]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[87],wr1_word_enable[87],wr0_word_enable[87]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2847:2816] = ({wr2_word_enable[88],wr1_word_enable[88],wr0_word_enable[88]} == 3'b001) ? wr0_data : (({wr2_word_enable[88],wr1_word_enable[88],wr0_word_enable[88]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[88],wr1_word_enable[88],wr0_word_enable[88]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2879:2848] = ({wr2_word_enable[89],wr1_word_enable[89],wr0_word_enable[89]} == 3'b001) ? wr0_data : (({wr2_word_enable[89],wr1_word_enable[89],wr0_word_enable[89]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[89],wr1_word_enable[89],wr0_word_enable[89]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2911:2880] = ({wr2_word_enable[90],wr1_word_enable[90],wr0_word_enable[90]} == 3'b001) ? wr0_data : (({wr2_word_enable[90],wr1_word_enable[90],wr0_word_enable[90]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[90],wr1_word_enable[90],wr0_word_enable[90]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2943:2912] = ({wr2_word_enable[91],wr1_word_enable[91],wr0_word_enable[91]} == 3'b001) ? wr0_data : (({wr2_word_enable[91],wr1_word_enable[91],wr0_word_enable[91]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[91],wr1_word_enable[91],wr0_word_enable[91]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[2975:2944] = ({wr2_word_enable[92],wr1_word_enable[92],wr0_word_enable[92]} == 3'b001) ? wr0_data : (({wr2_word_enable[92],wr1_word_enable[92],wr0_word_enable[92]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[92],wr1_word_enable[92],wr0_word_enable[92]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3007:2976] = ({wr2_word_enable[93],wr1_word_enable[93],wr0_word_enable[93]} == 3'b001) ? wr0_data : (({wr2_word_enable[93],wr1_word_enable[93],wr0_word_enable[93]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[93],wr1_word_enable[93],wr0_word_enable[93]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3039:3008] = ({wr2_word_enable[94],wr1_word_enable[94],wr0_word_enable[94]} == 3'b001) ? wr0_data : (({wr2_word_enable[94],wr1_word_enable[94],wr0_word_enable[94]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[94],wr1_word_enable[94],wr0_word_enable[94]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3071:3040] = ({wr2_word_enable[95],wr1_word_enable[95],wr0_word_enable[95]} == 3'b001) ? wr0_data : (({wr2_word_enable[95],wr1_word_enable[95],wr0_word_enable[95]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[95],wr1_word_enable[95],wr0_word_enable[95]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3103:3072] = ({wr2_word_enable[96],wr1_word_enable[96],wr0_word_enable[96]} == 3'b001) ? wr0_data : (({wr2_word_enable[96],wr1_word_enable[96],wr0_word_enable[96]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[96],wr1_word_enable[96],wr0_word_enable[96]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3135:3104] = ({wr2_word_enable[97],wr1_word_enable[97],wr0_word_enable[97]} == 3'b001) ? wr0_data : (({wr2_word_enable[97],wr1_word_enable[97],wr0_word_enable[97]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[97],wr1_word_enable[97],wr0_word_enable[97]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3167:3136] = ({wr2_word_enable[98],wr1_word_enable[98],wr0_word_enable[98]} == 3'b001) ? wr0_data : (({wr2_word_enable[98],wr1_word_enable[98],wr0_word_enable[98]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[98],wr1_word_enable[98],wr0_word_enable[98]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3199:3168] = ({wr2_word_enable[99],wr1_word_enable[99],wr0_word_enable[99]} == 3'b001) ? wr0_data : (({wr2_word_enable[99],wr1_word_enable[99],wr0_word_enable[99]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[99],wr1_word_enable[99],wr0_word_enable[99]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3231:3200] = ({wr2_word_enable[100],wr1_word_enable[100],wr0_word_enable[100]} == 3'b001) ? wr0_data : (({wr2_word_enable[100],wr1_word_enable[100],wr0_word_enable[100]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[100],wr1_word_enable[100],wr0_word_enable[100]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3263:3232] = ({wr2_word_enable[101],wr1_word_enable[101],wr0_word_enable[101]} == 3'b001) ? wr0_data : (({wr2_word_enable[101],wr1_word_enable[101],wr0_word_enable[101]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[101],wr1_word_enable[101],wr0_word_enable[101]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3295:3264] = ({wr2_word_enable[102],wr1_word_enable[102],wr0_word_enable[102]} == 3'b001) ? wr0_data : (({wr2_word_enable[102],wr1_word_enable[102],wr0_word_enable[102]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[102],wr1_word_enable[102],wr0_word_enable[102]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3327:3296] = ({wr2_word_enable[103],wr1_word_enable[103],wr0_word_enable[103]} == 3'b001) ? wr0_data : (({wr2_word_enable[103],wr1_word_enable[103],wr0_word_enable[103]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[103],wr1_word_enable[103],wr0_word_enable[103]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3359:3328] = ({wr2_word_enable[104],wr1_word_enable[104],wr0_word_enable[104]} == 3'b001) ? wr0_data : (({wr2_word_enable[104],wr1_word_enable[104],wr0_word_enable[104]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[104],wr1_word_enable[104],wr0_word_enable[104]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3391:3360] = ({wr2_word_enable[105],wr1_word_enable[105],wr0_word_enable[105]} == 3'b001) ? wr0_data : (({wr2_word_enable[105],wr1_word_enable[105],wr0_word_enable[105]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[105],wr1_word_enable[105],wr0_word_enable[105]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3423:3392] = ({wr2_word_enable[106],wr1_word_enable[106],wr0_word_enable[106]} == 3'b001) ? wr0_data : (({wr2_word_enable[106],wr1_word_enable[106],wr0_word_enable[106]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[106],wr1_word_enable[106],wr0_word_enable[106]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3455:3424] = ({wr2_word_enable[107],wr1_word_enable[107],wr0_word_enable[107]} == 3'b001) ? wr0_data : (({wr2_word_enable[107],wr1_word_enable[107],wr0_word_enable[107]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[107],wr1_word_enable[107],wr0_word_enable[107]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3487:3456] = ({wr2_word_enable[108],wr1_word_enable[108],wr0_word_enable[108]} == 3'b001) ? wr0_data : (({wr2_word_enable[108],wr1_word_enable[108],wr0_word_enable[108]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[108],wr1_word_enable[108],wr0_word_enable[108]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3519:3488] = ({wr2_word_enable[109],wr1_word_enable[109],wr0_word_enable[109]} == 3'b001) ? wr0_data : (({wr2_word_enable[109],wr1_word_enable[109],wr0_word_enable[109]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[109],wr1_word_enable[109],wr0_word_enable[109]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3551:3520] = ({wr2_word_enable[110],wr1_word_enable[110],wr0_word_enable[110]} == 3'b001) ? wr0_data : (({wr2_word_enable[110],wr1_word_enable[110],wr0_word_enable[110]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[110],wr1_word_enable[110],wr0_word_enable[110]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3583:3552] = ({wr2_word_enable[111],wr1_word_enable[111],wr0_word_enable[111]} == 3'b001) ? wr0_data : (({wr2_word_enable[111],wr1_word_enable[111],wr0_word_enable[111]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[111],wr1_word_enable[111],wr0_word_enable[111]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3615:3584] = ({wr2_word_enable[112],wr1_word_enable[112],wr0_word_enable[112]} == 3'b001) ? wr0_data : (({wr2_word_enable[112],wr1_word_enable[112],wr0_word_enable[112]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[112],wr1_word_enable[112],wr0_word_enable[112]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3647:3616] = ({wr2_word_enable[113],wr1_word_enable[113],wr0_word_enable[113]} == 3'b001) ? wr0_data : (({wr2_word_enable[113],wr1_word_enable[113],wr0_word_enable[113]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[113],wr1_word_enable[113],wr0_word_enable[113]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3679:3648] = ({wr2_word_enable[114],wr1_word_enable[114],wr0_word_enable[114]} == 3'b001) ? wr0_data : (({wr2_word_enable[114],wr1_word_enable[114],wr0_word_enable[114]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[114],wr1_word_enable[114],wr0_word_enable[114]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3711:3680] = ({wr2_word_enable[115],wr1_word_enable[115],wr0_word_enable[115]} == 3'b001) ? wr0_data : (({wr2_word_enable[115],wr1_word_enable[115],wr0_word_enable[115]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[115],wr1_word_enable[115],wr0_word_enable[115]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3743:3712] = ({wr2_word_enable[116],wr1_word_enable[116],wr0_word_enable[116]} == 3'b001) ? wr0_data : (({wr2_word_enable[116],wr1_word_enable[116],wr0_word_enable[116]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[116],wr1_word_enable[116],wr0_word_enable[116]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3775:3744] = ({wr2_word_enable[117],wr1_word_enable[117],wr0_word_enable[117]} == 3'b001) ? wr0_data : (({wr2_word_enable[117],wr1_word_enable[117],wr0_word_enable[117]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[117],wr1_word_enable[117],wr0_word_enable[117]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3807:3776] = ({wr2_word_enable[118],wr1_word_enable[118],wr0_word_enable[118]} == 3'b001) ? wr0_data : (({wr2_word_enable[118],wr1_word_enable[118],wr0_word_enable[118]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[118],wr1_word_enable[118],wr0_word_enable[118]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3839:3808] = ({wr2_word_enable[119],wr1_word_enable[119],wr0_word_enable[119]} == 3'b001) ? wr0_data : (({wr2_word_enable[119],wr1_word_enable[119],wr0_word_enable[119]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[119],wr1_word_enable[119],wr0_word_enable[119]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3871:3840] = ({wr2_word_enable[120],wr1_word_enable[120],wr0_word_enable[120]} == 3'b001) ? wr0_data : (({wr2_word_enable[120],wr1_word_enable[120],wr0_word_enable[120]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[120],wr1_word_enable[120],wr0_word_enable[120]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3903:3872] = ({wr2_word_enable[121],wr1_word_enable[121],wr0_word_enable[121]} == 3'b001) ? wr0_data : (({wr2_word_enable[121],wr1_word_enable[121],wr0_word_enable[121]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[121],wr1_word_enable[121],wr0_word_enable[121]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3935:3904] = ({wr2_word_enable[122],wr1_word_enable[122],wr0_word_enable[122]} == 3'b001) ? wr0_data : (({wr2_word_enable[122],wr1_word_enable[122],wr0_word_enable[122]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[122],wr1_word_enable[122],wr0_word_enable[122]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3967:3936] = ({wr2_word_enable[123],wr1_word_enable[123],wr0_word_enable[123]} == 3'b001) ? wr0_data : (({wr2_word_enable[123],wr1_word_enable[123],wr0_word_enable[123]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[123],wr1_word_enable[123],wr0_word_enable[123]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[3999:3968] = ({wr2_word_enable[124],wr1_word_enable[124],wr0_word_enable[124]} == 3'b001) ? wr0_data : (({wr2_word_enable[124],wr1_word_enable[124],wr0_word_enable[124]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[124],wr1_word_enable[124],wr0_word_enable[124]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[4031:4000] = ({wr2_word_enable[125],wr1_word_enable[125],wr0_word_enable[125]} == 3'b001) ? wr0_data : (({wr2_word_enable[125],wr1_word_enable[125],wr0_word_enable[125]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[125],wr1_word_enable[125],wr0_word_enable[125]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[4063:4032] = ({wr2_word_enable[126],wr1_word_enable[126],wr0_word_enable[126]} == 3'b001) ? wr0_data : (({wr2_word_enable[126],wr1_word_enable[126],wr0_word_enable[126]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[126],wr1_word_enable[126],wr0_word_enable[126]} == 3'b100)? wr2_data : {32{1'bx}}));
assign word_in[4095:4064] = ({wr2_word_enable[127],wr1_word_enable[127],wr0_word_enable[127]} == 3'b001) ? wr0_data : (({wr2_word_enable[127],wr1_word_enable[127],wr0_word_enable[127]} == 3'b010) ? wr1_data : ( ({wr2_word_enable[127],wr1_word_enable[127],wr0_word_enable[127]} == 3'b100)? wr2_data : {32{1'bx}}));

endmodule
//rd0 - 128bit, aligned (also supports unaligned)
//rd1 - 64bit, aligned (also supports unaligned)
//rd2 - 64bit, aligned (also supports unaligned)

//wr0 - 128/64/32bit (4 bit enable), aligned
//wr1 - 64/32bit (2 bit enable), aligned


module reg_512x32b_3r_2w 
  (/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   clk, rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr1_addr, wr0_en,
   wr1_en, wr0_data, wr1_data
   );
   input clk;

   output [127:0] rd0_data;
   output [63:0]  rd1_data;
   output [63:0]  rd2_data;

   input [8:0] 	  rd0_addr;
   input [8:0] 	  rd1_addr;
   input [8:0] 	  rd2_addr;

   input [8:0] 	  wr0_addr;
   input [8:0] 	  wr1_addr;

   input [3:0] 	  wr0_en;
   input [1:0] 	  wr1_en;

   input [127:0]  wr0_data;
   input [63:0]   wr1_data;

   /////////////

   wire [8:0] 	  rd0_addr_last;
   wire [8:0] 	  rd1_addr_last;
   wire [8:0] 	  rd2_addr_last;
   
   reg [127:0] 	  rd0_data;
   reg [63:0] 	  rd1_data;
   reg [63:0] 	  rd2_data;

   wire [8:0] 	  rd0_addr_plus1;
   wire [8:0] 	  rd0_addr_plus2;
   wire [8:0] 	  rd0_addr_plus3;
   assign rd0_addr_plus1 = rd0_addr + 1'b1;
   assign rd0_addr_plus2 = rd0_addr + 2'b10;
   assign rd0_addr_plus3 = rd0_addr + 2'b11;
   wire [31:0] 	  rd0_data_bank0;
   wire [31:0] 	  rd0_data_bank1;
   wire [31:0] 	  rd0_data_bank2;
   wire [31:0] 	  rd0_data_bank3;
   reg [6:0] 	  rd0_addr_bank0;
   reg [6:0] 	  rd0_addr_bank1;
   reg [6:0] 	  rd0_addr_bank2;
   reg [6:0] 	  rd0_addr_bank3;
   //see mux at end of module


   wire [8:0] 	  rd1_addr_plus1;
   assign rd1_addr_plus1 = rd1_addr + 1'b1;
   wire [31:0] 	  rd1_data_bank0;
   wire [31:0] 	  rd1_data_bank1;
   wire [31:0] 	  rd1_data_bank2;
   wire [31:0] 	  rd1_data_bank3;
   reg [6:0] 	  rd1_addr_bank0;
   reg [6:0] 	  rd1_addr_bank1;
   reg [6:0] 	  rd1_addr_bank2;
   reg [6:0] 	  rd1_addr_bank3;
   //see mux at end of module

   wire [8:0] 	  rd2_addr_plus1;
   assign rd2_addr_plus1 = rd2_addr + 1'b1;
   wire [31:0] 	  rd2_data_bank0;
   wire [31:0] 	  rd2_data_bank1;
   wire [31:0] 	  rd2_data_bank2;
   wire [31:0] 	  rd2_data_bank3;
   reg [6:0] 	  rd2_addr_bank0;
   reg [6:0] 	  rd2_addr_bank1;
   reg [6:0] 	  rd2_addr_bank2;
   reg [6:0] 	  rd2_addr_bank3;
   //see mux at end of module

   /////
   reg 		  wr0_en_bank0;
   reg 		  wr0_en_bank1;
   reg 		  wr0_en_bank2;
   reg 		  wr0_en_bank3;
   reg [31:0] 	  wr0_data_bank0;
   reg [31:0] 	  wr0_data_bank1;
   reg [31:0] 	  wr0_data_bank2;
   reg [31:0] 	  wr0_data_bank3;
   //see mux at end of module

   reg 		  wr1_en_bank0;
   reg 		  wr1_en_bank1;
   reg 		  wr1_en_bank2;
   reg 		  wr1_en_bank3;
   reg [31:0] 	  wr1_data_bank0;
   reg [31:0] 	  wr1_data_bank1;
   reg [31:0] 	  wr1_data_bank2;
   reg [31:0] 	  wr1_data_bank3;
   //see mux at end of module


  reg_128x32b_3r_2w_fpga



  bank0(
			   .rd0_addr(rd0_addr_bank0),
			   .rd0_data(rd0_data_bank0),
			   .rd1_addr(rd1_addr_bank0),
			   .rd1_data(rd1_data_bank0),
			   .rd2_addr(rd2_addr_bank0),
			   .rd2_data(rd2_data_bank0),
			   .wr0_addr(wr0_addr[8:2]),
			   .wr0_en(wr0_en_bank0),
			   .wr0_data(wr0_data_bank0),
			   .wr1_addr(wr1_addr[8:2]),
			   .wr1_en(wr1_en_bank0),
			   .wr1_data(wr1_data_bank0),
			   .clk(clk)
			   );


  reg_128x32b_3r_2w_fpga



  bank1(
			   .rd0_addr(rd0_addr_bank1),
			   .rd0_data(rd0_data_bank1),
			   .rd1_addr(rd1_addr_bank1),
			   .rd1_data(rd1_data_bank1),
			   .rd2_addr(rd2_addr_bank1),
			   .rd2_data(rd2_data_bank1),
			   .wr0_addr(wr0_addr[8:2]),
			   .wr0_en(wr0_en_bank1),
			   .wr0_data(wr0_data_bank1),
			   .wr1_addr(wr1_addr[8:2]),
			   .wr1_en(wr1_en_bank1),
			   .wr1_data(wr1_data_bank1),
			   .clk(clk)
			   );


  reg_128x32b_3r_2w_fpga



  bank2(
			   .rd0_addr(rd0_addr_bank2),
			   .rd0_data(rd0_data_bank2),
			   .rd1_addr(rd1_addr_bank2),
			   .rd1_data(rd1_data_bank2),
			   .rd2_addr(rd2_addr_bank2),
			   .rd2_data(rd2_data_bank2),
			   .wr0_addr(wr0_addr[8:2]),
			   .wr0_en(wr0_en_bank2),
			   .wr0_data(wr0_data_bank2),
			   .wr1_addr(wr1_addr[8:2]),
			   .wr1_en(wr1_en_bank2),
			   .wr1_data(wr1_data_bank2),
			   .clk(clk)
			   );


  reg_128x32b_3r_2w_fpga



  bank3(
			   .rd0_addr(rd0_addr_bank3),
			   .rd0_data(rd0_data_bank3),
			   .rd1_addr(rd1_addr_bank3),
			   .rd1_data(rd1_data_bank3),
			   .rd2_addr(rd2_addr_bank3),
			   .rd2_data(rd2_data_bank3),
			   .wr0_addr(wr0_addr[8:2]),
			   .wr0_en(wr0_en_bank3),
			   .wr0_data(wr0_data_bank3),
			   .wr1_addr(wr1_addr[8:2]),
			   .wr1_en(wr1_en_bank3),
			   .wr1_data(wr1_data_bank3),
			   .clk(clk)
			   );

   //Bank distribution for 128/64/32 write bit port
   always @(wr0_data or wr0_addr or wr0_en)
     begin
	casex({wr0_en,wr0_addr[1:0]})
	  6'b0001_00:
	    begin
               wr0_en_bank0 <= 1'b1;
               wr0_en_bank1 <= 1'b0;
               wr0_en_bank2 <= 1'b0;
               wr0_en_bank3 <= 1'b0;
               wr0_data_bank0 <= wr0_data[31:0];
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= {32{1'bx}};
	    end
	  6'b0001_01:
	    begin
               wr0_en_bank0 <= 1'b0;
               wr0_en_bank1 <= 1'b1;
               wr0_en_bank2 <= 1'b0;
               wr0_en_bank3 <= 1'b0;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= wr0_data[31:0];
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= {32{1'bx}};
	    end
	  6'b0001_10:
	    begin
               wr0_en_bank0 <= 1'b0;
               wr0_en_bank1 <= 1'b0;
               wr0_en_bank2 <= 1'b1;
               wr0_en_bank3 <= 1'b0;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= wr0_data[31:0];
               wr0_data_bank3 <= {32{1'bx}};
	    end
	  6'b0001_11:
	    begin
               wr0_en_bank0 <= 1'b0;
               wr0_en_bank1 <= 1'b0;
               wr0_en_bank2 <= 1'b0;
               wr0_en_bank3 <= 1'b1;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= wr0_data[31:0];
	    end
	  6'b0011_00:
	    begin
               wr0_en_bank0 <= 1'b1;
               wr0_en_bank1 <= 1'b1;
               wr0_en_bank2 <= 1'b0;
               wr0_en_bank3 <= 1'b0;
               wr0_data_bank0 <= wr0_data[31:0];
               wr0_data_bank1 <= wr0_data[63:32];
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= {32{1'bx}};
	    end
	  6'b0011_10:
	    begin
               wr0_en_bank0 <= 1'b0;
               wr0_en_bank1 <= 1'b0;
               wr0_en_bank2 <= 1'b1;
               wr0_en_bank3 <= 1'b1;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= wr0_data[31:0];
               wr0_data_bank3 <= wr0_data[63:32];
	    end
	  6'b1111_00:
	    begin
               wr0_en_bank0 <= 1'b1;
               wr0_en_bank1 <= 1'b1;
               wr0_en_bank2 <= 1'b1;
               wr0_en_bank3 <= 1'b1;
               wr0_data_bank0 <= wr0_data[31:0];
               wr0_data_bank1 <= wr0_data[63:32];
               wr0_data_bank2 <= wr0_data[95:64];
               wr0_data_bank3 <= wr0_data[127:96];
	    end
	  6'b0000_??:
	    begin
               wr0_en_bank0 <= 1'b0;
               wr0_en_bank1 <= 1'b0;
               wr0_en_bank2 <= 1'b0;
               wr0_en_bank3 <= 1'b0;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= {32{1'bx}};
	    end
	  default:
	    begin
               wr0_en_bank0 <= 1'bx;
               wr0_en_bank1 <= 1'bx;
               wr0_en_bank2 <= 1'bx;
               wr0_en_bank3 <= 1'bx;
               wr0_data_bank0 <= {32{1'bx}};
               wr0_data_bank1 <= {32{1'bx}};
               wr0_data_bank2 <= {32{1'bx}};
               wr0_data_bank3 <= {32{1'bx}};
	    end
	endcase
     end

   //Bank distribution for 64/32 bit write port
   always @(wr1_data or wr1_addr or wr1_en)
     begin
	casex({wr1_en,wr1_addr[1:0]})
	  4'b01_00:
	    begin
               wr1_en_bank0 <= 1'b1;
               wr1_en_bank1 <= 1'b0;
               wr1_en_bank2 <= 1'b0;
               wr1_en_bank3 <= 1'b0;
               wr1_data_bank0 <= wr1_data[31:0];
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= {32{1'bx}};
	    end
	  4'b01_01:
	    begin
               wr1_en_bank0 <= 1'b0;
               wr1_en_bank1 <= 1'b1;
               wr1_en_bank2 <= 1'b0;
               wr1_en_bank3 <= 1'b0;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= wr1_data[31:0];
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= {32{1'bx}};
	    end
	  4'b01_10:
	    begin
               wr1_en_bank0 <= 1'b0;
               wr1_en_bank1 <= 1'b0;
               wr1_en_bank2 <= 1'b1;
               wr1_en_bank3 <= 1'b0;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= wr1_data[31:0];
               wr1_data_bank3 <= {32{1'bx}};
	    end
	  4'b01_11:
	    begin
               wr1_en_bank0 <= 1'b0;
               wr1_en_bank1 <= 1'b0;
               wr1_en_bank2 <= 1'b0;
               wr1_en_bank3 <= 1'b1;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= wr1_data[31:0];
	    end
	  4'b11_00:
	    begin
               wr1_en_bank0 <= 1'b1;
               wr1_en_bank1 <= 1'b1;
               wr1_en_bank2 <= 1'b0;
               wr1_en_bank3 <= 1'b0;
               wr1_data_bank0 <= wr1_data[31:0];
               wr1_data_bank1 <= wr1_data[63:32];
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= {32{1'bx}};
	    end
	  4'b11_10:
	    begin
               wr1_en_bank0 <= 1'b0;
               wr1_en_bank1 <= 1'b0;
               wr1_en_bank2 <= 1'b1;
               wr1_en_bank3 <= 1'b1;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= wr1_data[31:0];
               wr1_data_bank3 <= wr1_data[63:32];
	    end
	  4'b00_??:
	    begin
               wr1_en_bank0 <= 1'b0;
               wr1_en_bank1 <= 1'b0;
               wr1_en_bank2 <= 1'b0;
               wr1_en_bank3 <= 1'b0;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= {32{1'bx}};
	    end
	  default:
	    begin
               wr1_en_bank0 <= 1'bx;
               wr1_en_bank1 <= 1'bx;
               wr1_en_bank2 <= 1'bx;
               wr1_en_bank3 <= 1'bx;
               wr1_data_bank0 <= {32{1'bx}};
               wr1_data_bank1 <= {32{1'bx}};
               wr1_data_bank2 <= {32{1'bx}};
               wr1_data_bank3 <= {32{1'bx}};
	    end
	endcase
     end





   dff rd_addr_delay[9+9+9-1:0]
     (.q({rd0_addr_last, rd1_addr_last, rd2_addr_last}),
      .d({rd0_addr, rd1_addr, rd2_addr}),
      .clk(clk),
      .rst(1'b0));
   
   //Bank distribution for 128/64/32 bit read port
   always @(rd0_addr or rd0_addr_plus1 or rd0_addr_plus2 or rd0_addr_plus3)
     begin
	casex(rd0_addr[1:0])
	  2'b00:
	    begin
               rd0_addr_bank0 <= rd0_addr[8:2];
               rd0_addr_bank1 <= rd0_addr_plus1[8:2];
               rd0_addr_bank2 <= rd0_addr_plus2[8:2];
               rd0_addr_bank3 <= rd0_addr_plus3[8:2];
	    end
	  2'b01:
	    begin
               rd0_addr_bank0 <= rd0_addr_plus3[8:2];
               rd0_addr_bank1 <= rd0_addr[8:2];
               rd0_addr_bank2 <= rd0_addr_plus1[8:2];
               rd0_addr_bank3 <= rd0_addr_plus2[8:2];
	    end
	  2'b10:
	    begin
               rd0_addr_bank0 <= rd0_addr_plus2[8:2];
               rd0_addr_bank1 <= rd0_addr_plus3[8:2];
               rd0_addr_bank2 <= rd0_addr[8:2];
               rd0_addr_bank3 <= rd0_addr_plus1[8:2];
	    end
	  2'b11:
	    begin
               rd0_addr_bank0 <= rd0_addr_plus1[8:2];
               rd0_addr_bank1 <= rd0_addr_plus2[8:2];
               rd0_addr_bank2 <= rd0_addr_plus3[8:2];
               rd0_addr_bank3 <= rd0_addr[8:2];
	    end
	  default:
	    begin
               rd0_addr_bank0 <= {7{1'bx}};
               rd0_addr_bank1 <= {7{1'bx}};
               rd0_addr_bank2 <= {7{1'bx}};
               rd0_addr_bank3 <= {7{1'bx}};
	    end
	endcase
     end

   always @(rd0_addr_last or rd0_data_bank0 or rd0_data_bank1 or 
	    rd0_data_bank2 or rd0_data_bank3)
     begin
	casex(rd0_addr_last[1:0])
	  2'b00:
	    begin
               rd0_data <= {rd0_data_bank3,rd0_data_bank2,
			    rd0_data_bank1,rd0_data_bank0};
	    end
	  2'b01:
	    begin
               rd0_data <= {rd0_data_bank0,rd0_data_bank3,
			    rd0_data_bank2,rd0_data_bank1};
	    end
	  2'b10:
	    begin
               rd0_data <= {rd0_data_bank1,rd0_data_bank0,
			    rd0_data_bank3,rd0_data_bank2};
	    end
	  2'b11:
	    begin
               rd0_data <= {rd0_data_bank2,rd0_data_bank1,
			    rd0_data_bank0,rd0_data_bank3};
	    end
	  default:
	    begin
               rd0_data <= {128{1'bx}};
	    end
	endcase
     end
   
   //Bank distribution for 64/32 bit read port
   always @(rd1_addr or rd1_addr_plus1)
     begin
	casex(rd1_addr[1:0])
	  2'b00:
	    begin
               rd1_addr_bank0 <= rd1_addr[8:2];
               rd1_addr_bank1 <= rd1_addr_plus1[8:2];
               rd1_addr_bank2 <= {7{1'bx}};
               rd1_addr_bank3 <= {7{1'bx}};
	    end
	  2'b01:
	    begin
               rd1_addr_bank0 <= {7{1'bx}};
               rd1_addr_bank1 <= rd1_addr[8:2];
               rd1_addr_bank2 <= rd1_addr_plus1[8:2];
               rd1_addr_bank3 <= {7{1'bx}};
	    end
	  2'b10:
	    begin
               rd1_addr_bank0 <= {7{1'bx}};
               rd1_addr_bank1 <= {7{1'bx}};
               rd1_addr_bank2 <= rd1_addr[8:2];
               rd1_addr_bank3 <= rd1_addr_plus1[8:2];
	    end
	  2'b11:
	    begin
               rd1_addr_bank0 <= rd1_addr_plus1[8:2];
               rd1_addr_bank1 <= {7{1'bx}};
               rd1_addr_bank2 <= {7{1'bx}};
               rd1_addr_bank3 <= rd1_addr[8:2];
	    end
	  default:
	    begin
               rd1_addr_bank0 <= {7{1'bx}};
               rd1_addr_bank1 <= {7{1'bx}};
               rd1_addr_bank2 <= {7{1'bx}};
               rd1_addr_bank3 <= {7{1'bx}};
	    end
	endcase
     end

   always @(rd1_addr_last or rd1_data_bank0 or rd1_data_bank1 or 
	    rd1_data_bank2 or rd1_data_bank3)
     begin
	casex(rd1_addr_last[1:0])
	  2'b00:
	    begin
               rd1_data <= {rd1_data_bank1,rd1_data_bank0};
	    end
	  2'b01:
	    begin
               rd1_data <= {rd1_data_bank2,rd1_data_bank1};
	    end
	  2'b10:
	    begin
               rd1_data <= {rd1_data_bank3,rd1_data_bank2};
	    end
	  2'b11:
	    begin
               rd1_data <= {rd1_data_bank0,rd1_data_bank3};
	    end
	  default:
	    begin
               rd1_data <= {128{1'bx}};
	    end
	endcase
     end

   
   //Bank distribution for 64/32 bit read port
   always @(rd2_addr or rd2_addr_plus1)
     begin
	casex(rd2_addr[1:0])
	  2'b00:
	    begin
               rd2_addr_bank0 <= rd2_addr[8:2];
               rd2_addr_bank1 <= rd2_addr_plus1[8:2];
               rd2_addr_bank2 <= {7{1'bx}};
               rd2_addr_bank3 <= {7{1'bx}};
	    end
	  2'b01:
	    begin
               rd2_addr_bank0 <= {7{1'bx}};
               rd2_addr_bank1 <= rd2_addr[8:2];
               rd2_addr_bank2 <= rd2_addr_plus1[8:2];
               rd2_addr_bank3 <= {7{1'bx}};
	    end
	  2'b10:
	    begin
               rd2_addr_bank0 <= {7{1'bx}};
               rd2_addr_bank1 <= {7{1'bx}};
               rd2_addr_bank2 <= rd2_addr[8:2];
               rd2_addr_bank3 <= rd2_addr_plus1[8:2];
	    end
	  2'b11:
	    begin
               rd2_addr_bank0 <= rd2_addr_plus1[8:2];
               rd2_addr_bank1 <= {7{1'bx}};
               rd2_addr_bank2 <= {7{1'bx}};
               rd2_addr_bank3 <= rd2_addr[8:2];
	    end
	  default:
	    begin
               rd2_addr_bank0 <= {7{1'bx}};
               rd2_addr_bank1 <= {7{1'bx}};
               rd2_addr_bank2 <= {7{1'bx}};
               rd2_addr_bank3 <= {7{1'bx}};
	    end
	endcase
     end

   always @(rd2_addr_last or rd2_data_bank0 or rd2_data_bank1 or 
	    rd2_data_bank2 or rd2_data_bank3)
     begin
	casex(rd2_addr_last[1:0])
	  2'b00:
	    begin
               rd2_data <= {rd2_data_bank1,rd2_data_bank0};
	    end
	  2'b01:
	    begin
               rd2_data <= {rd2_data_bank2,rd2_data_bank1};
	    end
	  2'b10:
	    begin
               rd2_data <= {rd2_data_bank3,rd2_data_bank2};
	    end
	  2'b11:
	    begin
               rd2_data <= {rd2_data_bank0,rd2_data_bank3};
	    end
	  default:
	    begin
               rd2_data <= {128{1'bx}};
	    end
	endcase
     end
   
endmodule
//rd0 - 128bit, aligned (also supports unaligned)
//rd1 - 64bit, aligned (also supports unaligned)
//rd2 - 64bit, aligned (also supports unaligned)

//wr0 - 128/64/32bit (4 bit enable), aligned
//wr1 - 64/32bit (2 bit enable), aligned
//wr2 - 64bit (1 bit enable, always 64bit), aligned

module reg_512x32b_3r_3w (
  rd0_data, rd1_data, rd2_data,
  clk,
  rd0_addr, rd1_addr, rd2_addr,
  wr0_addr, wr1_addr, wr2_addr,
  wr0_en, wr1_en, wr2_en, wr0_data, wr1_data, wr2_data
);
input clk;

output [127:0] rd0_data;
output [63:0] rd1_data;
output [63:0] rd2_data;

input [8:0] rd0_addr;
input [8:0] rd1_addr;
input [8:0] rd2_addr;

input [8:0] wr0_addr;
input [8:0] wr1_addr;
input [8:0] wr2_addr;

input [3:0] wr0_en;
input [1:0] wr1_en;
input wr2_en;

input [127:0] wr0_data;
input [63:0] wr1_data;
input [63:0] wr2_data;

/////////////

reg [127:0] rd0_data;
reg [63:0] rd1_data;
reg [63:0] rd2_data;

wire [8:0] rd0_addr_plus1;
wire [8:0] rd0_addr_plus2;
wire [8:0] rd0_addr_plus3;
assign rd0_addr_plus1 = rd0_addr + 1'b1;
assign rd0_addr_plus2 = rd0_addr + 2'b10;
assign rd0_addr_plus3 = rd0_addr + 2'b11;
wire [31:0] rd0_data_bank0;
wire [31:0] rd0_data_bank1;
wire [31:0] rd0_data_bank2;
wire [31:0] rd0_data_bank3;
reg [6:0] rd0_addr_bank0;
reg [6:0] rd0_addr_bank1;
reg [6:0] rd0_addr_bank2;
reg [6:0] rd0_addr_bank3;
//see mux at end of module


wire [8:0] rd1_addr_plus1;
assign rd1_addr_plus1 = rd1_addr + 1'b1;
wire [31:0] rd1_data_bank0;
wire [31:0] rd1_data_bank1;
wire [31:0] rd1_data_bank2;
wire [31:0] rd1_data_bank3;
reg [6:0] rd1_addr_bank0;
reg [6:0] rd1_addr_bank1;
reg [6:0] rd1_addr_bank2;
reg [6:0] rd1_addr_bank3;
//see mux at end of module

wire [8:0] rd2_addr_plus1;
assign rd2_addr_plus1 = rd2_addr + 1'b1;
wire [31:0] rd2_data_bank0;
wire [31:0] rd2_data_bank1;
wire [31:0] rd2_data_bank2;
wire [31:0] rd2_data_bank3;
reg [6:0] rd2_addr_bank0;
reg [6:0] rd2_addr_bank1;
reg [6:0] rd2_addr_bank2;
reg [6:0] rd2_addr_bank3;
//see mux at end of module

/////
reg wr0_en_bank0;
reg wr0_en_bank1;
reg wr0_en_bank2;
reg wr0_en_bank3;
reg [31:0] wr0_data_bank0;
reg [31:0] wr0_data_bank1;
reg [31:0] wr0_data_bank2;
reg [31:0] wr0_data_bank3;
//see mux at end of module

reg wr1_en_bank0;
reg wr1_en_bank1;
reg wr1_en_bank2;
reg wr1_en_bank3;
reg [31:0] wr1_data_bank0;
reg [31:0] wr1_data_bank1;
reg [31:0] wr1_data_bank2;
reg [31:0] wr1_data_bank3;
//see mux at end of module

reg_128x32b_3r_3w bank0(
  .rd0_addr(rd0_addr_bank0),
  .rd0_data(rd0_data_bank0),
  .rd1_addr(rd1_addr_bank0),
  .rd1_data(rd1_data_bank0),
  .rd2_addr(rd2_addr_bank0),
  .rd2_data(rd2_data_bank0),
  .wr0_addr(wr0_addr[8:2]),
  .wr0_en(wr0_en_bank0),
  .wr0_data(wr0_data_bank0),
  .wr1_addr(wr1_addr[8:2]),
  .wr1_en(wr1_en_bank0),
  .wr1_data(wr1_data_bank0),
  .wr2_addr(wr2_addr[8:2]),
  .wr2_en(wr2_en & ~wr2_addr[1]),
  .wr2_data(wr2_data[31:0]),
  .clk(clk)
);

reg_128x32b_3r_3w bank1(
  .rd0_addr(rd0_addr_bank1),
  .rd0_data(rd0_data_bank1),
  .rd1_addr(rd1_addr_bank1),
  .rd1_data(rd1_data_bank1),
  .rd2_addr(rd2_addr_bank1),
  .rd2_data(rd2_data_bank1),
  .wr0_addr(wr0_addr[8:2]),
  .wr0_en(wr0_en_bank1),
  .wr0_data(wr0_data_bank1),
  .wr1_addr(wr1_addr[8:2]),
  .wr1_en(wr1_en_bank1),
  .wr1_data(wr1_data_bank1),
  .wr2_addr(wr2_addr[8:2]),
  .wr2_en(wr2_en & ~wr2_addr[1]),
  .wr2_data(wr2_data[63:32]),
  .clk(clk)
);

reg_128x32b_3r_3w bank2(
  .rd0_addr(rd0_addr_bank2),
  .rd0_data(rd0_data_bank2),
  .rd1_addr(rd1_addr_bank2),
  .rd1_data(rd1_data_bank2),
  .rd2_addr(rd2_addr_bank2),
  .rd2_data(rd2_data_bank2),
  .wr0_addr(wr0_addr[8:2]),
  .wr0_en(wr0_en_bank2),
  .wr0_data(wr0_data_bank2),
  .wr1_addr(wr1_addr[8:2]),
  .wr1_en(wr1_en_bank2),
  .wr1_data(wr1_data_bank2),
  .wr2_addr(wr2_addr[8:2]),
  .wr2_en(wr2_en & wr2_addr[1]),
  .wr2_data(wr2_data[31:0]),
  .clk(clk)
);

reg_128x32b_3r_3w bank3(
  .rd0_addr(rd0_addr_bank3),
  .rd0_data(rd0_data_bank3),
  .rd1_addr(rd1_addr_bank3),
  .rd1_data(rd1_data_bank3),
  .rd2_addr(rd2_addr_bank3),
  .rd2_data(rd2_data_bank3),
  .wr0_addr(wr0_addr[8:2]),
  .wr0_en(wr0_en_bank3),
  .wr0_data(wr0_data_bank3),
  .wr1_addr(wr1_addr[8:2]),
  .wr1_en(wr1_en_bank3),
  .wr1_data(wr1_data_bank3),
  .wr2_addr(wr2_addr[8:2]),
  .wr2_en(wr2_en & wr2_addr[1]),
  .wr2_data(wr2_data[63:32]),
  .clk(clk)
);

//Bank distribution for 128/64/32 write bit port
always @(wr0_data or wr0_addr or wr0_en)
begin
  casex({wr0_en,wr0_addr[1:0]})
    6'b0001_00:
      begin
        wr0_en_bank0 <= 1'b1;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
        wr0_data_bank0 <= wr0_data[31:0];
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= {32{1'bx}};
      end
    6'b0001_01:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b1;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= wr0_data[31:0];
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= {32{1'bx}};
      end
    6'b0001_10:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b1;
        wr0_en_bank3 <= 1'b0;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= wr0_data[31:0];
        wr0_data_bank3 <= {32{1'bx}};
      end
    6'b0001_11:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b1;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= wr0_data[31:0];
      end
    6'b0011_00:
      begin
        wr0_en_bank0 <= 1'b1;
        wr0_en_bank1 <= 1'b1;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
        wr0_data_bank0 <= wr0_data[31:0];
        wr0_data_bank1 <= wr0_data[63:32];
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= {32{1'bx}};
      end
    6'b0011_10:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b1;
        wr0_en_bank3 <= 1'b1;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= wr0_data[31:0];
        wr0_data_bank3 <= wr0_data[63:32];
      end
    6'b1111_00:
      begin
        wr0_en_bank0 <= 1'b1;
        wr0_en_bank1 <= 1'b1;
        wr0_en_bank2 <= 1'b1;
        wr0_en_bank3 <= 1'b1;
        wr0_data_bank0 <= wr0_data[31:0];
        wr0_data_bank1 <= wr0_data[63:32];
        wr0_data_bank2 <= wr0_data[95:64];
        wr0_data_bank3 <= wr0_data[127:96];
      end
    6'b0000_??:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= {32{1'bx}};
      end
    default:
      begin
        wr0_en_bank0 <= 1'bx;
        wr0_en_bank1 <= 1'bx;
        wr0_en_bank2 <= 1'bx;
        wr0_en_bank3 <= 1'bx;
        wr0_data_bank0 <= {32{1'bx}};
        wr0_data_bank1 <= {32{1'bx}};
        wr0_data_bank2 <= {32{1'bx}};
        wr0_data_bank3 <= {32{1'bx}};
      end
  endcase
end

//Bank distribution for 64/32 bit write port
always @(wr1_data or wr1_addr or wr1_en)
begin
  casex({wr1_en,wr1_addr[1:0]})
    4'b01_00:
      begin
        wr1_en_bank0 <= 1'b1;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b0;
        wr1_data_bank0 <= wr1_data[31:0];
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= {32{1'bx}};
      end
    4'b01_01:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b1;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b0;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= wr1_data[31:0];
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= {32{1'bx}};
      end
    4'b01_10:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b1;
        wr1_en_bank3 <= 1'b0;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= wr1_data[31:0];
        wr1_data_bank3 <= {32{1'bx}};
      end
    4'b01_11:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b1;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= wr1_data[31:0];
      end
    4'b11_00:
      begin
        wr1_en_bank0 <= 1'b1;
        wr1_en_bank1 <= 1'b1;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b0;
        wr1_data_bank0 <= wr1_data[31:0];
        wr1_data_bank1 <= wr1_data[63:32];
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= {32{1'bx}};
      end
    4'b11_10:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b1;
        wr1_en_bank3 <= 1'b1;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= wr1_data[31:0];
        wr1_data_bank3 <= wr1_data[63:32];
      end
    4'b00_??:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b0;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= {32{1'bx}};
      end
    default:
      begin
        wr1_en_bank0 <= 1'bx;
        wr1_en_bank1 <= 1'bx;
        wr1_en_bank2 <= 1'bx;
        wr1_en_bank3 <= 1'bx;
        wr1_data_bank0 <= {32{1'bx}};
        wr1_data_bank1 <= {32{1'bx}};
        wr1_data_bank2 <= {32{1'bx}};
        wr1_data_bank3 <= {32{1'bx}};
      end
  endcase
end

//Bank distribution for 128/64/32 bit read port
always @(rd0_addr or rd0_addr_plus1 or rd0_addr_plus2 or rd0_addr_plus3
         or rd0_data_bank0 or rd0_data_bank1 or rd0_data_bank2 or rd0_data_bank3)
begin
  casex(rd0_addr[1:0])
    2'b00:
      begin
        rd0_addr_bank0 <= rd0_addr[8:2];
        rd0_addr_bank1 <= rd0_addr_plus1[8:2];
        rd0_addr_bank2 <= rd0_addr_plus2[8:2];
        rd0_addr_bank3 <= rd0_addr_plus3[8:2];
        rd0_data <= {rd0_data_bank3,rd0_data_bank2,rd0_data_bank1,rd0_data_bank0};
      end
    2'b01:
      begin
        rd0_addr_bank0 <= rd0_addr_plus3[8:2];
        rd0_addr_bank1 <= rd0_addr[8:2];
        rd0_addr_bank2 <= rd0_addr_plus1[8:2];
        rd0_addr_bank3 <= rd0_addr_plus2[8:2];
        rd0_data <= {rd0_data_bank0,rd0_data_bank3,rd0_data_bank2,rd0_data_bank1};
      end
    2'b10:
      begin
        rd0_addr_bank0 <= rd0_addr_plus2[8:2];
        rd0_addr_bank1 <= rd0_addr_plus3[8:2];
        rd0_addr_bank2 <= rd0_addr[8:2];
        rd0_addr_bank3 <= rd0_addr_plus1[8:2];
        rd0_data <= {rd0_data_bank1,rd0_data_bank0,rd0_data_bank3,rd0_data_bank2};
      end
    2'b11:
      begin
        rd0_addr_bank0 <= rd0_addr_plus1[8:2];
        rd0_addr_bank1 <= rd0_addr_plus2[8:2];
        rd0_addr_bank2 <= rd0_addr_plus3[8:2];
        rd0_addr_bank3 <= rd0_addr[8:2];
        rd0_data <= {rd0_data_bank2,rd0_data_bank1,rd0_data_bank0,rd0_data_bank3};
      end
    default:
      begin
        rd0_addr_bank0 <= {7{1'bx}};
        rd0_addr_bank1 <= {7{1'bx}};
        rd0_addr_bank2 <= {7{1'bx}};
        rd0_addr_bank3 <= {7{1'bx}};
        rd0_data <= {128{1'bx}};
      end
  endcase
end

//Bank distribution for 64/32 bit read port
always @(rd1_addr or rd1_addr_plus1
         or rd1_data_bank0 or rd1_data_bank1 or rd1_data_bank2 or rd1_data_bank3)
begin
  casex(rd1_addr[1:0])
    2'b00:
      begin
        rd1_addr_bank0 <= rd1_addr[8:2];
        rd1_addr_bank1 <= rd1_addr_plus1[8:2];
        rd1_addr_bank2 <= {7{1'bx}};
        rd1_addr_bank3 <= {7{1'bx}};
        rd1_data <= {rd1_data_bank1,rd1_data_bank0};
      end
    2'b01:
      begin
        rd1_addr_bank0 <= {7{1'bx}};
        rd1_addr_bank1 <= rd1_addr[8:2];
        rd1_addr_bank2 <= rd1_addr_plus1[8:2];
        rd1_addr_bank3 <= {7{1'bx}};
        rd1_data <= {rd1_data_bank2,rd1_data_bank1};
      end
    2'b10:
      begin
        rd1_addr_bank0 <= {7{1'bx}};
        rd1_addr_bank1 <= {7{1'bx}};
        rd1_addr_bank2 <= rd1_addr[8:2];
        rd1_addr_bank3 <= rd1_addr_plus1[8:2];
        rd1_data <= {rd1_data_bank3,rd1_data_bank2};
      end
    2'b11:
      begin
        rd1_addr_bank0 <= rd1_addr_plus1[8:2];
        rd1_addr_bank1 <= {7{1'bx}};
        rd1_addr_bank2 <= {7{1'bx}};
        rd1_addr_bank3 <= rd1_addr[8:2];
        rd1_data <= {rd1_data_bank0,rd1_data_bank3};
      end
    default:
      begin
        rd1_addr_bank0 <= {7{1'bx}};
        rd1_addr_bank1 <= {7{1'bx}};
        rd1_addr_bank2 <= {7{1'bx}};
        rd1_addr_bank3 <= {7{1'bx}};
        rd1_data <= {128{1'bx}};
      end
  endcase
end

//Bank distribution for 64/32 bit read port
always @(rd2_addr or rd2_addr_plus1
         or rd2_data_bank0 or rd2_data_bank1 or rd2_data_bank2 or rd2_data_bank3)
begin
  casex(rd2_addr[1:0])
    2'b00:
      begin
        rd2_addr_bank0 <= rd2_addr[8:2];
        rd2_addr_bank1 <= rd2_addr_plus1[8:2];
        rd2_addr_bank2 <= {7{1'bx}};
        rd2_addr_bank3 <= {7{1'bx}};
        rd2_data <= {rd2_data_bank1,rd2_data_bank0};
      end
    2'b01:
      begin
        rd2_addr_bank0 <= {7{1'bx}};
        rd2_addr_bank1 <= rd2_addr[8:2];
        rd2_addr_bank2 <= rd2_addr_plus1[8:2];
        rd2_addr_bank3 <= {7{1'bx}};
        rd2_data <= {rd2_data_bank2,rd2_data_bank1};
      end
    2'b10:
      begin
        rd2_addr_bank0 <= {7{1'bx}};
        rd2_addr_bank1 <= {7{1'bx}};
        rd2_addr_bank2 <= rd2_addr[8:2];
        rd2_addr_bank3 <= rd2_addr_plus1[8:2];
        rd2_data <= {rd2_data_bank3,rd2_data_bank2};
      end
    2'b11:
      begin
        rd2_addr_bank0 <= rd2_addr_plus1[8:2];
        rd2_addr_bank1 <= {7{1'bx}};
        rd2_addr_bank2 <= {7{1'bx}};
        rd2_addr_bank3 <= rd2_addr[8:2];
        rd2_data <= {rd2_data_bank0,rd2_data_bank3};
      end
    default:
      begin
        rd2_addr_bank0 <= {7{1'bx}};
        rd2_addr_bank1 <= {7{1'bx}};
        rd2_addr_bank2 <= {7{1'bx}};
        rd2_addr_bank3 <= {7{1'bx}};
        rd2_data <= {128{1'bx}};
      end
  endcase
end

endmodule
module sgpr(
	     lsu_source1_addr,
	     lsu_source2_addr,
	     lsu_dest_addr,
	     lsu_dest_data,
	     lsu_dest_wr_en,
	     lsu_instr_done_wfid,
	     lsu_instr_done,
	     lsu_source1_rd_en,
	     lsu_source2_rd_en,
	     simd0_rd_addr,
	     simd0_rd_en,
	     simd1_rd_addr,
	     simd1_rd_en,
	     simd2_rd_addr,
	     simd2_rd_en,
	     simd3_rd_addr,
	     simd3_rd_en,
	     simd0_wr_addr,
	     simd0_wr_en,
	     simd0_wr_data,
	     simd1_wr_addr,
	     simd1_wr_en,
	     simd1_wr_data,
	     simd2_wr_addr,
	     simd2_wr_en,
	     simd2_wr_data,
	     simd3_wr_addr,
	     simd3_wr_en,
	     simd3_wr_data,
	     simd0_wr_mask,
	     simd1_wr_mask,
	     simd2_wr_mask,
	     simd3_wr_mask,
	     simf0_rd_addr,
	     simf0_rd_en,
	     simf1_rd_addr,
	     simf1_rd_en,
	     simf2_rd_addr,
	     simf2_rd_en,
	     simf3_rd_addr,
	     simf3_rd_en,
	     simf0_wr_addr,
	     simf0_wr_en,
	     simf0_wr_data,
	     simf1_wr_addr,
	     simf1_wr_en,
	     simf1_wr_data,
	     simf2_wr_addr,
	     simf2_wr_en,
	     simf2_wr_data,
	     simf3_wr_addr,
	     simf3_wr_en,
	     simf3_wr_data,
	     simf0_wr_mask,
	     simf1_wr_mask,
	     simf2_wr_mask,
	     simf3_wr_mask,
	     salu_dest_data,
	     salu_dest_addr,
	     salu_dest_wr_en,
	     salu_source2_addr,
	     salu_source1_addr,
	     salu_instr_done_wfid,
	     salu_instr_done,
	     salu_source1_rd_en,
	     salu_source2_rd_en,
	     rfa_select_fu,
	     lsu_source1_data,
	     lsu_source2_data,
	     simd_rd_data,
	     simf_rd_data,
	     salu_source2_data,
	     salu_source1_data,
	     issue_alu_wr_done_wfid,
	     issue_alu_wr_done,
	     issue_alu_dest_reg_addr,
	     issue_alu_dest_reg_valid,
	     issue_lsu_instr_done_wfid,
	     issue_lsu_instr_done,
	     issue_lsu_dest_reg_addr,
	     issue_lsu_dest_reg_valid,
	     issue_valu_dest_reg_valid,
	     issue_valu_dest_addr,
	     clk,
	     rst
	     );

   input clk;

   input rst;
   input salu_source1_rd_en,
	 salu_source2_rd_en,
	 lsu_source1_rd_en,
	 lsu_source2_rd_en;

   input lsu_instr_done, simd0_rd_en, simd1_rd_en, simd2_rd_en,
         simd3_rd_en, simd0_wr_en, simd1_wr_en, simd2_wr_en, simd3_wr_en, simf0_rd_en,
         simf1_rd_en, simf2_rd_en, simf3_rd_en, simf0_wr_en, simf1_wr_en, simf2_wr_en,
         simf3_wr_en, salu_instr_done;
   input [1:0] salu_dest_wr_en;
   input [3:0] lsu_dest_wr_en;
   input [5:0] lsu_instr_done_wfid, salu_instr_done_wfid;
   input [8:0] lsu_source1_addr, lsu_source2_addr, lsu_dest_addr, simd0_rd_addr,
               simd1_rd_addr, simd2_rd_addr, simd3_rd_addr, simd0_wr_addr, simd1_wr_addr,
               simd2_wr_addr, simd3_wr_addr, simf0_rd_addr, simf1_rd_addr, simf2_rd_addr,
               simf3_rd_addr, simf0_wr_addr, simf1_wr_addr, simf2_wr_addr, simf3_wr_addr,
               salu_dest_addr, salu_source2_addr, salu_source1_addr;
   input [15:0] rfa_select_fu;
   input [127:0] lsu_dest_data;
   input [63:0]  simd0_wr_data, simd1_wr_data, simd2_wr_data, simd3_wr_data,
		 simf0_wr_data, simf1_wr_data, simf2_wr_data, simf3_wr_data,
		 salu_dest_data,
		 simd0_wr_mask, simd1_wr_mask, simd2_wr_mask, simd3_wr_mask,
		 simf0_wr_mask, simf1_wr_mask, simf2_wr_mask, simf3_wr_mask;

   output 	 issue_alu_wr_done, issue_lsu_instr_done, issue_valu_dest_reg_valid;
   output [3:0]  issue_lsu_dest_reg_valid;
   output [1:0]  issue_alu_dest_reg_valid;
   output [5:0]  issue_alu_wr_done_wfid, issue_lsu_instr_done_wfid;
   output [8:0]  issue_alu_dest_reg_addr, issue_lsu_dest_reg_addr, issue_valu_dest_addr;
   output [31:0] lsu_source2_data, simd_rd_data, simf_rd_data;
   output [63:0] salu_source2_data, salu_source1_data;
   output [127:0] lsu_source1_data;

   ///////////////////////////////
   //Your code goes here - beware: script does not recognize changes
   // into files. It ovewrites everithing without mercy. Save your work before running the script
   ///////////////////////////////
   wire 	  dummy;
   assign dummy = rst;

   wire [31:0] 	  simx_rd_data;

   wire [8:0] 	  simx_muxed_rd_addr;
   wire [31:0] 	  simx_muxed_rd_data;
   wire 	  simx_muxed_rd_en;

   wire [3:0] 	  simxlsu_muxed_wr_en;
   wire [8:0] 	  simxlsu_muxed_wr_addr;
   wire [127:0]   simxlsu_muxed_wr_data;
   wire [63:0] 	  simx_rd_old_data;
   wire [127:0]   simxlsu_wr_merged_data;
   wire [127:0] 	  simxlsu_muxed_wr_mask;

   wire [3:0] 	  simxlsu_muxed_wr_en_i;
   wire [8:0] 	  simxlsu_muxed_wr_addr_i;
   wire [127:0]   simxlsu_muxed_wr_data_i;
   wire [127:0] 	  simxlsu_muxed_wr_mask_i;

   wire [8:0] 	  final_port0_addr;
   wire [8:0] 	  final_port1_addr;

   wire [127:0]   final_port0_data;
   wire [63:0] 	  final_port1_data;
   wire [127:0]   port0_distribute_data;
   wire [127:0]   port1_distribute_data;

   wire [127:0]   simd0_wr_data_i, simd1_wr_data_i, simd2_wr_data_i, simd3_wr_data_i,
		  simf0_wr_data_i, simf1_wr_data_i, simf2_wr_data_i, simf3_wr_data_i;

   wire [127:0]   simd0_wr_mask_i, simd1_wr_mask_i, simd2_wr_mask_i, simd3_wr_mask_i,
		  simf0_wr_mask_i, simf1_wr_mask_i, simf2_wr_mask_i, simf3_wr_mask_i;

   wire [3:0]	  simd0_wr_en_i, simd1_wr_en_i, simd2_wr_en_i, simd3_wr_en_i,
		  simf0_wr_en_i, simf1_wr_en_i, simf2_wr_en_i, simf3_wr_en_i;


   assign simd0_wr_data_i = {simd0_wr_data, simd0_wr_data};
   assign simd1_wr_data_i = {simd1_wr_data, simd1_wr_data};
   assign simd2_wr_data_i = {simd2_wr_data, simd2_wr_data};
   assign simd3_wr_data_i = {simd3_wr_data, simd3_wr_data};

   assign simf0_wr_data_i = {simf0_wr_data, simf0_wr_data};
   assign simf1_wr_data_i = {simf1_wr_data, simf1_wr_data};
   assign simf2_wr_data_i = {simf2_wr_data, simf2_wr_data};
   assign simf3_wr_data_i = {simf3_wr_data, simf3_wr_data};

   assign simd0_wr_mask_i = {simd0_wr_mask, simd0_wr_mask};
   assign simd1_wr_mask_i = {simd1_wr_mask, simd1_wr_mask};
   assign simd2_wr_mask_i = {simd2_wr_mask, simd2_wr_mask};
   assign simd3_wr_mask_i = {simd3_wr_mask, simd3_wr_mask};

   assign simf0_wr_mask_i = {simf0_wr_mask, simf0_wr_mask};
   assign simf1_wr_mask_i = {simf1_wr_mask, simf1_wr_mask};
   assign simf2_wr_mask_i = {simf2_wr_mask, simf2_wr_mask};
   assign simf3_wr_mask_i = {simf3_wr_mask, simf3_wr_mask};

   assign simd0_wr_en_i = {4{simd0_wr_en}} & 4'b0011;

   assign simd1_wr_en_i = {4{simd1_wr_en}} & 4'b0011;

   assign simd2_wr_en_i = {4{simd2_wr_en}} & 4'b0011;

   assign simd3_wr_en_i = {4{simd3_wr_en}} & 4'b0011;

   assign simf0_wr_en_i = {4{simf0_wr_en}} & 4'b0011;

   assign simf1_wr_en_i = {4{simf1_wr_en}} & 4'b0011;

   assign simf2_wr_en_i = {4{simf2_wr_en}} & 4'b0011;

   assign simf3_wr_en_i = {4{simf3_wr_en}} & 4'b0011;

   assign issue_alu_wr_done_wfid = salu_instr_done_wfid;
   assign issue_alu_wr_done = salu_instr_done;
   assign issue_alu_dest_reg_addr = salu_dest_addr;
   assign issue_alu_dest_reg_valid = salu_dest_wr_en;

   assign issue_lsu_instr_done_wfid = lsu_instr_done_wfid;
   assign issue_lsu_instr_done = lsu_instr_done;
   assign issue_lsu_dest_reg_addr = lsu_dest_addr;
   assign issue_lsu_dest_reg_valid = lsu_dest_wr_en;

   //For writes from simx, read the old value using a ead port and modify only
   //the bits specified by the wr mask
   assign simxlsu_wr_merged_data = (simxlsu_muxed_wr_data_i &
				    simxlsu_muxed_wr_mask_i) |
				   ({2{simx_rd_old_data}} &
				    (~simxlsu_muxed_wr_mask_i));

   dff  wr0_delay_flop[4+9+128+128-1:0]
     (.q({simxlsu_muxed_wr_en_i, simxlsu_muxed_wr_addr_i,
	  simxlsu_muxed_wr_data_i,simxlsu_muxed_wr_mask_i}),
      .d({simxlsu_muxed_wr_en, simxlsu_muxed_wr_addr,
	  simxlsu_muxed_wr_data,simxlsu_muxed_wr_mask}),
      .clk(clk),
      .rst(rst));

   reg_512x32b_3r_2w sgpr_reg_file
     (
      .rd0_addr(final_port0_addr),
      .rd0_data(final_port0_data),
      .rd1_addr(final_port1_addr),
      .rd1_data(final_port1_data),
      .rd2_addr(simxlsu_muxed_wr_addr),
      .rd2_data(simx_rd_old_data),
      .wr0_en(simxlsu_muxed_wr_en_i),
      .wr0_addr(simxlsu_muxed_wr_addr_i),
      .wr0_data(simxlsu_wr_merged_data),
      //**CHANGE [PSP]
      //**pretend we have one single port only
      //so keep wr1_en low [disable wr1 port write]
      .wr1_en(2'b00),//salu_dest_wr_en),
      .wr1_addr(salu_dest_addr),
      .wr1_data(salu_dest_data),
      //**
      .clk(clk)
      );

   sgpr_simx_rd_port_mux simx_rd_port_mux
     (
      .port0_rd_en(simd0_rd_en),
      .port0_rd_addr(simd0_rd_addr),
      .port1_rd_en(simd1_rd_en),
      .port1_rd_addr(simd1_rd_addr),
      .port2_rd_en(simd2_rd_en),
      .port2_rd_addr(simd2_rd_addr),
      .port3_rd_en(simd3_rd_en),
      .port3_rd_addr(simd3_rd_addr),
      .port4_rd_en(simf0_rd_en),
      .port4_rd_addr(simf0_rd_addr),
      .port5_rd_en(simf1_rd_en),
      .port5_rd_addr(simf1_rd_addr),
      .port6_rd_en(simf2_rd_en),
      .port6_rd_addr(simf2_rd_addr),
      .port7_rd_en(simf3_rd_en),
      .port7_rd_addr(simf3_rd_addr),
      .port_rd_data(simx_rd_data),
      .rd_addr(simx_muxed_rd_addr),
      .rd_data(simx_muxed_rd_data),
      .rd_en(simx_muxed_rd_en)
      );
   assign simd_rd_data = simx_rd_data;
   assign simf_rd_data = simx_rd_data;

   sgpr_3to1_rd_port_mux rd_port0_mux
     (
      .port0_rd_en(lsu_source1_rd_en),
      .port0_rd_addr(lsu_source1_addr),
      .port1_rd_en(1'b0),
      .port1_rd_addr(9'b0),
      .port2_rd_en(salu_source1_rd_en),
      .port2_rd_addr(salu_source1_addr),
      .port_rd_data(port0_distribute_data),
      .rd_addr(final_port0_addr),
      .rd_data(final_port0_data)
      );
   assign lsu_source1_data = port0_distribute_data;
   assign salu_source1_data = port0_distribute_data[63:0];

   sgpr_3to1_rd_port_mux rd_port1_mux
     (
      .port0_rd_en(lsu_source2_rd_en),
      .port0_rd_addr(lsu_source2_addr),
      .port1_rd_en(simx_muxed_rd_en),
      .port1_rd_addr(simx_muxed_rd_addr),
      .port2_rd_en(salu_source2_rd_en),
      .port2_rd_addr(salu_source2_addr),
      .port_rd_data(port1_distribute_data),
      .rd_addr(final_port1_addr),
      .rd_data({64'b0,final_port1_data})
      );
   assign lsu_source2_data = port1_distribute_data[31:0];
   assign simx_muxed_rd_data = port1_distribute_data[31:0];
   assign salu_source2_data = port1_distribute_data[63:0];

   ///////////////////////////////////////////
   //**CHANGE [PSP]**
   //simxlsu will now also take in the salu ports
   sgpr_simxlsu_wr_port_mux simx_wr_port_mux
     (
      .wr_port_select(rfa_select_fu),
      .port0_wr_en(simd0_wr_en_i),
      .port0_wr_addr(simd0_wr_addr),
      .port0_wr_data(simd0_wr_data_i),
      .port0_wr_mask(simd0_wr_mask_i),
      .port1_wr_en(simd1_wr_en_i),
      .port1_wr_addr(simd1_wr_addr),
      .port1_wr_data(simd1_wr_data_i),
      .port1_wr_mask(simd1_wr_mask_i),
      .port2_wr_en(simd2_wr_en_i),
      .port2_wr_addr(simd2_wr_addr),
      .port2_wr_data(simd2_wr_data_i),
      .port2_wr_mask(simd2_wr_mask_i),
      .port3_wr_en(simd3_wr_en_i),
      .port3_wr_addr(simd3_wr_addr),
      .port3_wr_data(simd3_wr_data_i),
      .port3_wr_mask(simd3_wr_mask_i),
      .port4_wr_en(simf0_wr_en_i),
      .port4_wr_addr(simf0_wr_addr),
      .port4_wr_data(simf0_wr_data_i),
      .port4_wr_mask(simf0_wr_mask_i),
      .port5_wr_en(simf1_wr_en_i),
      .port5_wr_addr(simf1_wr_addr),
      .port5_wr_data(simf1_wr_data_i),
      .port5_wr_mask(simf1_wr_mask_i),
      .port6_wr_en(simf2_wr_en_i),
      .port6_wr_addr(simf2_wr_addr),
      .port6_wr_data(simf2_wr_data_i),
      .port6_wr_mask(simf2_wr_mask_i),
      .port7_wr_en(simf3_wr_en_i),
      .port7_wr_addr(simf3_wr_addr),
      .port7_wr_data(simf3_wr_data_i),
      .port7_wr_mask(simf3_wr_mask_i),
      .port8_wr_en(lsu_dest_wr_en),
      .port8_wr_addr(lsu_dest_addr),
      .port8_wr_data(lsu_dest_data),
      .port8_wr_mask({128{1'b1}}),

      //**
      .port9_wr_en({2'd0, salu_dest_wr_en}),
      .port9_wr_addr(salu_dest_addr),
      .port9_wr_data({64'd0, salu_dest_data}),
      .port9_wr_mask({128{1'b1}}),
      //**

      .muxed_port_wr_en(simxlsu_muxed_wr_en),
      .muxed_port_wr_addr(simxlsu_muxed_wr_addr),
      .muxed_port_wr_data(simxlsu_muxed_wr_data),
      .muxed_port_wr_mask(simxlsu_muxed_wr_mask)
      );

   assign issue_valu_dest_reg_valid = (|simxlsu_muxed_wr_en) & (~|lsu_dest_wr_en);
   assign issue_valu_dest_addr = simxlsu_muxed_wr_addr;

endmodule
module sgpr_3to1_rd_port_mux (
  port0_rd_en,
  port0_rd_addr,

  port1_rd_en,
  port1_rd_addr,

  port2_rd_en,
  port2_rd_addr,

  port_rd_data,

  rd_addr,
  rd_data
);

  input         port0_rd_en;
  input [8:0]   port0_rd_addr;

  input         port1_rd_en;
  input [8:0]   port1_rd_addr;

  input         port2_rd_en;
  input [8:0]   port2_rd_addr;

  input [127:0] rd_data;
  output [127:0] port_rd_data;
  output [8:0]  rd_addr;

  reg [8:0]     rd_addr;

  assign port_rd_data = rd_data;

  always @ (
    port0_rd_en or
    port1_rd_en or
    port2_rd_en or
    port0_rd_addr or
    port1_rd_addr or
    port2_rd_addr
  ) begin
      casex({port2_rd_en,port1_rd_en,port0_rd_en})
        3'b001:
          begin
            rd_addr <= port0_rd_addr;
          end
        3'b010:
          begin
            rd_addr <= port1_rd_addr;
          end
        3'b100:
          begin
            rd_addr <= port2_rd_addr;
          end
        default:
          begin
            rd_addr <= {9{1'bx}};
          end
      endcase
    end

endmodule
module sgpr_simx_rd_port_mux (
  port0_rd_en,
  port0_rd_addr,

  port1_rd_en,
  port1_rd_addr,

  port2_rd_en,
  port2_rd_addr,

  port3_rd_en,
  port3_rd_addr,
  
  port4_rd_en,
  port4_rd_addr,

  port5_rd_en,
  port5_rd_addr,

  port6_rd_en,
  port6_rd_addr,

  port7_rd_en,
  port7_rd_addr,
  
  port_rd_data,

  rd_addr,
  rd_en,
  rd_data
);

  input         port0_rd_en;
  input [8:0]   port0_rd_addr;
  input         port1_rd_en;
  input [8:0]   port1_rd_addr;
  input         port2_rd_en;
  input [8:0]   port2_rd_addr;
  input         port3_rd_en;
  input [8:0]   port3_rd_addr;
  input         port4_rd_en;
  input [8:0]   port4_rd_addr;
  input         port5_rd_en;
  input [8:0]   port5_rd_addr;
  input         port6_rd_en;
  input [8:0]   port6_rd_addr;
  input         port7_rd_en;
  input [8:0]   port7_rd_addr;
  
  input [31:0]  rd_data;
  
  output [31:0] port_rd_data;
  output [8:0]  rd_addr;
  output rd_en;

  reg [8:0]     rd_addr;
  reg rd_en;

  assign port_rd_data = rd_data;
  
  always @ (
    port0_rd_en or
    port1_rd_en or
    port2_rd_en or
    port3_rd_en or
    port4_rd_en or
    port5_rd_en or
    port6_rd_en or
    port7_rd_en or
    port0_rd_addr or
    port1_rd_addr or
    port2_rd_addr or
    port3_rd_addr or
    port4_rd_addr or
    port5_rd_addr or
    port6_rd_addr or
    port7_rd_addr
  ) begin
    casex({port7_rd_en,port6_rd_en,port5_rd_en,port4_rd_en,port3_rd_en,port2_rd_en,port1_rd_en,port0_rd_en})
      8'b0000_0001:
        begin
          rd_addr <= port0_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0000_0010:
        begin
          rd_addr <= port1_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0000_0100:
        begin
          rd_addr <= port2_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0000_1000:
        begin
          rd_addr <= port3_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0001_0000:
        begin
          rd_addr <= port4_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0010_0000:
        begin
          rd_addr <= port5_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0100_0000:
        begin
          rd_addr <= port6_rd_addr;
          rd_en <= 1'b1;
        end
      8'b1000_0000:
        begin
          rd_addr <= port7_rd_addr;
          rd_en <= 1'b1;
        end
      8'b0000_0000:
        begin
          rd_addr <= {9{1'bx}};
          rd_en <= 1'b0;
        end
      default:
        begin
          rd_addr <= {9{1'bx}};
          rd_en <= 1'bx;
        end
    endcase
  end

endmodule
module sgpr_simx_wr_port_mux (
  wr_port_select,

  port0_wr_en,
  port0_wr_addr,
  port0_wr_data,
  port0_wr_mask,

  port1_wr_en,
  port1_wr_addr,
  port1_wr_data,
  port1_wr_mask,

  port2_wr_en,
  port2_wr_addr,
  port2_wr_data,
  port2_wr_mask,

  port3_wr_en,
  port3_wr_addr,
  port3_wr_data,
  port3_wr_mask,

  port4_wr_en,
  port4_wr_addr,
  port4_wr_data,
  port4_wr_mask,

  port5_wr_en,
  port5_wr_addr,
  port5_wr_data,
  port5_wr_mask,

  port6_wr_en,
  port6_wr_addr,
  port6_wr_data,
  port6_wr_mask,

  port7_wr_en,
  port7_wr_addr,
  port7_wr_data,
  port7_wr_mask,

  muxed_port_wr_en,
  muxed_port_wr_addr,
  muxed_port_wr_data,
  muxed_port_wr_mask
);

  output muxed_port_wr_en;
  output [8:0] muxed_port_wr_addr;
  output [63:0] muxed_port_wr_data;
  output [63:0] muxed_port_wr_mask;

  input [15:0] wr_port_select;

  input port0_wr_en;
  input [8:0] port0_wr_addr;
  input [63:0] port0_wr_data;
  input [63:0] port0_wr_mask;
  
  input port1_wr_en;
  input [8:0] port1_wr_addr;
  input [63:0] port1_wr_data;
  input [63:0] port1_wr_mask;
  
  input port2_wr_en;
  input [8:0] port2_wr_addr;
  input [63:0] port2_wr_data;
  input [63:0] port2_wr_mask;
  
  input port3_wr_en;
  input [8:0] port3_wr_addr;
  input [63:0] port3_wr_data;
  input [63:0] port3_wr_mask;

  input port4_wr_en;
  input [8:0] port4_wr_addr;
  input [63:0] port4_wr_data;
  input [63:0] port4_wr_mask;
  
  input port5_wr_en;
  input [8:0] port5_wr_addr;
  input [63:0] port5_wr_data;
  input [63:0] port5_wr_mask;
  
  input port6_wr_en;
  input [8:0] port6_wr_addr;
  input [63:0] port6_wr_data;
  input [63:0] port6_wr_mask;
  
  input port7_wr_en;
  input [8:0] port7_wr_addr;
  input [63:0] port7_wr_data;
  input [63:0] port7_wr_mask;

  reg muxed_port_wr_en;
  reg [8:0] muxed_port_wr_addr;
  reg [63:0] muxed_port_wr_data;
  reg [63:0] muxed_port_wr_mask;

  always @ (
    wr_port_select or
    port0_wr_en or
    port0_wr_addr or
    port0_wr_data or
    port0_wr_mask or
    port1_wr_en or
    port1_wr_addr or
    port1_wr_data or
    port1_wr_mask or
    port2_wr_en or
    port2_wr_addr or
    port2_wr_data or
    port2_wr_mask or
    port3_wr_en or
    port3_wr_addr or
    port3_wr_data or
    port3_wr_mask or
    port4_wr_en or
    port4_wr_addr or
    port4_wr_data or
    port4_wr_mask or
    port5_wr_en or
    port5_wr_addr or
    port5_wr_data or
    port5_wr_mask or
    port6_wr_en or
    port6_wr_addr or
    port6_wr_data or
    port6_wr_mask or
    port7_wr_en or
    port7_wr_addr or
    port7_wr_data or
    port7_wr_mask
  ) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_port_wr_en <= port0_wr_en;
          muxed_port_wr_addr <= port0_wr_addr;
          muxed_port_wr_data <= port0_wr_data;
          muxed_port_wr_mask <= port0_wr_mask;
        end
      16'h0002:
        begin
          muxed_port_wr_en <= port1_wr_en;
          muxed_port_wr_addr <= port1_wr_addr;
          muxed_port_wr_data <= port1_wr_data;
          muxed_port_wr_mask <= port1_wr_mask;
        end
      16'h0004:
        begin
          muxed_port_wr_en <= port2_wr_en;
          muxed_port_wr_addr <= port2_wr_addr;
          muxed_port_wr_data <= port2_wr_data;
          muxed_port_wr_mask <= port2_wr_mask;
        end
      16'h0008:
        begin
          muxed_port_wr_en <= port3_wr_en;
          muxed_port_wr_addr <= port3_wr_addr;
          muxed_port_wr_data <= port3_wr_data;
          muxed_port_wr_mask <= port3_wr_mask;
        end
      16'h0010:
        begin
          muxed_port_wr_en <= port4_wr_en;
          muxed_port_wr_addr <= port4_wr_addr;
          muxed_port_wr_data <= port4_wr_data;
          muxed_port_wr_mask <= port4_wr_mask;
        end
      16'h0020:
        begin
          muxed_port_wr_en <= port5_wr_en;
          muxed_port_wr_addr <= port5_wr_addr;
          muxed_port_wr_data <= port5_wr_data;
          muxed_port_wr_mask <= port5_wr_mask;
        end
      16'h0040:
        begin
          muxed_port_wr_en <= port6_wr_en;
          muxed_port_wr_addr <= port6_wr_addr;
          muxed_port_wr_data <= port6_wr_data;
          muxed_port_wr_mask <= port6_wr_mask;
        end
      16'h0080:
        begin
          muxed_port_wr_en <= port7_wr_en;
          muxed_port_wr_addr <= port7_wr_addr;
          muxed_port_wr_data <= port7_wr_data;
          muxed_port_wr_mask <= port7_wr_mask;
        end
      16'b0000:
        begin
          muxed_port_wr_en <= 1'b0;
          muxed_port_wr_addr <= {9{1'bx}};
          muxed_port_wr_data <= {64{1'bx}};
          muxed_port_wr_mask <= {64{1'bx}};
        end
      default:
        begin
          muxed_port_wr_en <= 1'bx;
          muxed_port_wr_addr <= {9{1'bx}};
          muxed_port_wr_data <= {64{1'bx}};
          muxed_port_wr_mask <= {64{1'bx}};
        end
    endcase
  end

endmodule

module sgpr_simxlsu_wr_port_mux 
  (/*AUTOARG*/
   // Outputs
   muxed_port_wr_en, muxed_port_wr_addr, muxed_port_wr_data,
   muxed_port_wr_mask,
   // Inputs

   //**CHANGE [PSP]
   //**add ports 9 for SALU integration
   wr_port_select, port0_wr_en, port0_wr_addr, port0_wr_data,
   port0_wr_mask, port1_wr_en, port1_wr_addr, port1_wr_data,
   port1_wr_mask, port2_wr_en, port2_wr_addr, port2_wr_data,
   port2_wr_mask, port3_wr_en, port3_wr_addr, port3_wr_data,
   port3_wr_mask, port4_wr_en, port4_wr_addr, port4_wr_data,
   port4_wr_mask, port5_wr_en, port5_wr_addr, port5_wr_data,
   port5_wr_mask, port6_wr_en, port6_wr_addr, port6_wr_data,
   port6_wr_mask, port7_wr_en, port7_wr_addr, port7_wr_data,
   port7_wr_mask, port8_wr_en, port8_wr_addr, port8_wr_data,
   port8_wr_mask, port9_wr_en, port9_wr_addr, port9_wr_data,
   port9_wr_mask
   //**
   );

  output [3:0] muxed_port_wr_en;
  output [8:0] muxed_port_wr_addr;
  output [127:0] muxed_port_wr_data;
  output [127:0] muxed_port_wr_mask;

  input [15:0] wr_port_select;

  input[3:0] port0_wr_en;
  input [8:0] port0_wr_addr;
  input [127:0] port0_wr_data;
  input [127:0] port0_wr_mask;
  
  input [3:0] port1_wr_en;
  input [8:0] port1_wr_addr;
  input [127:0] port1_wr_data;
  input [127:0] port1_wr_mask;
  
  input [3:0] port2_wr_en;
  input [8:0] port2_wr_addr;
  input [127:0] port2_wr_data;
  input [127:0] port2_wr_mask;
  
  input [3:0] port3_wr_en;
  input [8:0] port3_wr_addr;
  input [127:0] port3_wr_data;
  input [127:0] port3_wr_mask;

  input [3:0] port4_wr_en;
  input [8:0] port4_wr_addr;
  input [127:0] port4_wr_data;
  input [127:0] port4_wr_mask;
  
  input [3:0] port5_wr_en;
  input [8:0] port5_wr_addr;
  input [127:0] port5_wr_data;
  input [127:0] port5_wr_mask;
  
  input [3:0] port6_wr_en;
  input [8:0] port6_wr_addr;
  input [127:0] port6_wr_data;
  input [127:0] port6_wr_mask;
  
  input [3:0] port7_wr_en;
  input [8:0] port7_wr_addr;
  input [127:0] port7_wr_data;
  input [127:0] port7_wr_mask;

  input [3:0] port8_wr_en;
  input [8:0] port8_wr_addr;
  input [127:0] port8_wr_data;
  input [127:0] port8_wr_mask;
   
  reg [3:0] muxed_port_wr_en;
  reg [8:0] muxed_port_wr_addr;
  reg [127:0] muxed_port_wr_data;
  reg [127:0] muxed_port_wr_mask;

  //**CHANGE [PSP]
  //** add extra SALU port
  input [3:0] port9_wr_en;
  input [8:0] port9_wr_addr;
  input [127:0] port9_wr_data;
  input [127:0] port9_wr_mask;
  //**

  always @ (
    wr_port_select or
    port0_wr_en or
    port0_wr_addr or
    port0_wr_data or
    port0_wr_mask or
    port1_wr_en or
    port1_wr_addr or
    port1_wr_data or
    port1_wr_mask or
    port2_wr_en or
    port2_wr_addr or
    port2_wr_data or
    port2_wr_mask or
    port3_wr_en or
    port3_wr_addr or
    port3_wr_data or
    port3_wr_mask or
    port4_wr_en or
    port4_wr_addr or
    port4_wr_data or
    port4_wr_mask or
    port5_wr_en or
    port5_wr_addr or
    port5_wr_data or
    port5_wr_mask or
    port6_wr_en or
    port6_wr_addr or
    port6_wr_data or
    port6_wr_mask or
    port7_wr_en or
    port7_wr_addr or
    port7_wr_data or
    port7_wr_mask or
    port8_wr_en or
    port8_wr_addr or
    port8_wr_data or
    port8_wr_mask or

    //**CHANGE
    port9_wr_en or
    port9_wr_addr or
    port9_wr_data or
    port9_wr_mask 
    //**
	    
  ) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_port_wr_en <= port0_wr_en;
          muxed_port_wr_addr <= port0_wr_addr;
          muxed_port_wr_data <= port0_wr_data;
          muxed_port_wr_mask <= port0_wr_mask;
        end
      16'h0002:
        begin
          muxed_port_wr_en <= port1_wr_en;
          muxed_port_wr_addr <= port1_wr_addr;
          muxed_port_wr_data <= port1_wr_data;
          muxed_port_wr_mask <= port1_wr_mask;
        end
      16'h0004:
        begin
          muxed_port_wr_en <= port2_wr_en;
          muxed_port_wr_addr <= port2_wr_addr;
          muxed_port_wr_data <= port2_wr_data;
          muxed_port_wr_mask <= port2_wr_mask;
        end
      16'h0008:
        begin
          muxed_port_wr_en <= port3_wr_en;
          muxed_port_wr_addr <= port3_wr_addr;
          muxed_port_wr_data <= port3_wr_data;
          muxed_port_wr_mask <= port3_wr_mask;
        end
      16'h0010:
        begin
          muxed_port_wr_en <= port4_wr_en;
          muxed_port_wr_addr <= port4_wr_addr;
          muxed_port_wr_data <= port4_wr_data;
          muxed_port_wr_mask <= port4_wr_mask;
        end
      16'h0020:
        begin
          muxed_port_wr_en <= port5_wr_en;
          muxed_port_wr_addr <= port5_wr_addr;
          muxed_port_wr_data <= port5_wr_data;
          muxed_port_wr_mask <= port5_wr_mask;
        end
      16'h0040:
        begin
          muxed_port_wr_en <= port6_wr_en;
          muxed_port_wr_addr <= port6_wr_addr;
          muxed_port_wr_data <= port6_wr_data;
          muxed_port_wr_mask <= port6_wr_mask;
        end
      16'h0080:
        begin
          muxed_port_wr_en <= port7_wr_en;
          muxed_port_wr_addr <= port7_wr_addr;
          muxed_port_wr_data <= port7_wr_data;
          muxed_port_wr_mask <= port7_wr_mask;
        end
      16'h0100:
        begin
          muxed_port_wr_en <= port8_wr_en;
          muxed_port_wr_addr <= port8_wr_addr;
          muxed_port_wr_data <= port8_wr_data;
          muxed_port_wr_mask <= port8_wr_mask;
        end


      //**CHANGE [PSP]
      //**actual port assigning for SALU
      16'h0200:
        begin
          muxed_port_wr_en <= port9_wr_en;
          muxed_port_wr_addr <= port9_wr_addr;
          muxed_port_wr_data <= port9_wr_data;
          muxed_port_wr_mask <= port9_wr_mask;
        end
      //**


      16'b0000:
        begin
          muxed_port_wr_en <= 1'b0;
          muxed_port_wr_addr <= {9{1'bx}};
          muxed_port_wr_data <= {64{1'bx}};
          muxed_port_wr_mask <= {64{1'bx}};
        end
      default:
        begin
          muxed_port_wr_en <= 1'bx;
          muxed_port_wr_addr <= {9{1'bx}};
          muxed_port_wr_data <= {64{1'bx}};
          muxed_port_wr_mask <= {64{1'bx}};
        end
    endcase
  end

endmodule

//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200's 32x32 multiply for ASIC                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://www.opencores.org/project,or1k                       ////
////                                                              ////
////  Description                                                 ////
////  32x32 multiply for ASIC                                     ////
////                                                              ////
////  To Do:                                                      ////
////   - make it smaller and faster                               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Damjan Lampret, lampret@opencores.org                 ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
////                                                              ////
//// Copyright (C) 2000 Authors and OPENCORES.ORG                 ////
////                                                              ////
//// This source file may be used and distributed without         ////
//// restriction provided that this copyright statement is not    ////
//// removed from the file and that any derivative work contains  ////
//// the original copyright notice and the associated disclaimer. ////
////                                                              ////
//// This source file is free software; you can redistribute it   ////
//// and/or modify it under the terms of the GNU Lesser General   ////
//// Public License as published by the Free Software Foundation; ////
//// either version 2.1 of the License, or (at your option) any   ////
//// later version.                                               ////
////                                                              ////
//// This source is distributed in the hope that it will be       ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
//// PURPOSE.  See the GNU Lesser General Public License for more ////
//// details.                                                     ////
////                                                              ////
//// You should have received a copy of the GNU Lesser General    ////
//// Public License along with this source; if not, download it   ////
//// from http://www.opencores.org/lgpl.shtml                     ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
// $Log: or1200_amultp2_32x32.v,v $
// Revision 2.0  2010/06/30 11:00:00  ORSoC
// No update 

module PP_LOW ( ONEPOS, ONENEG, TWONEG, INA, INB, PPBIT );
   input  ONEPOS;
   input  ONENEG;
   input  TWONEG;
   input  INA;
   input  INB;
   output PPBIT;
   assign PPBIT = (ONEPOS & INA) | (ONENEG & INB) | TWONEG;
endmodule


module PP_MIDDLE ( ONEPOS, ONENEG, TWOPOS, TWONEG, INA, INB, INC, IND, PPBIT );
   input  ONEPOS;
   input  ONENEG;
   input  TWOPOS;
   input  TWONEG;
   input  INA;
   input  INB;
   input  INC;
   input  IND;
   output PPBIT;
   assign PPBIT =  ~ (( ~ (INA & TWOPOS)) & ( ~ (INB & TWONEG)) & ( ~ (INC & ONEPOS)) & ( ~ (IND & ONENEG)));
endmodule


module PP_HIGH ( ONEPOS, ONENEG, TWOPOS, TWONEG, INA, INB, PPBIT );
   input  ONEPOS;
   input  ONENEG;
   input  TWOPOS;
   input  TWONEG;
   input  INA;
   input  INB;
   output PPBIT;
   assign PPBIT =  ~ ((INA & ONEPOS) | (INB & ONENEG) | (INA & TWOPOS) | (INB & TWONEG));
endmodule


module R_GATE ( INA, INB, INC, PPBIT );
   input  INA;
   input  INB;
   input  INC;
   output PPBIT;
   assign PPBIT = ( ~ (INA & INB)) & INC;
endmodule


module DECODER ( INA, INB, INC, TWOPOS, TWONEG, ONEPOS, ONENEG );
   input  INA;
   input  INB;
   input  INC;
   output TWOPOS;
   output TWONEG;
   output ONEPOS;
   output ONENEG;
   assign TWOPOS =  ~ ( ~ (INA & INB & ( ~ INC)));
   assign TWONEG =  ~ ( ~ (( ~ INA) & ( ~ INB) & INC));
   assign ONEPOS = (( ~ INA) & INB & ( ~ INC)) | (( ~ INC) & ( ~ INB) & INA);
   assign ONENEG = (INA & ( ~ INB) & INC) | (INC & INB & ( ~ INA));
endmodule


module BOOTHCODER_33_32 ( OPA, OPB, SUMMAND );
   input  [0:32] OPA;
   input [0:31]  OPB;
   output [0:575] SUMMAND;
   wire [0:32] 	  INV_MULTIPLICAND;
   wire [0:63] 	  INT_MULTIPLIER;
   wire 	  LOGIC_ONE, LOGIC_ZERO;
   assign LOGIC_ONE = 1;
   assign LOGIC_ZERO = 0;
   DECODER DEC_0 (.INA (LOGIC_ZERO) , .INB (OPB[0]) , .INC (OPB[1]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) );
   assign INV_MULTIPLICAND[0] =  ~ OPA[0];
   PP_LOW PPL_0 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[0]) );
   R_GATE RGATE_0 (.INA (LOGIC_ZERO) , .INB (OPB[0]) , .INC (OPB[1]) , .PPBIT (SUMMAND[1]) );
   assign INV_MULTIPLICAND[1] =  ~ OPA[1];
   PP_MIDDLE PPM_0 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[2]) );
   assign INV_MULTIPLICAND[2] =  ~ OPA[2];
   PP_MIDDLE PPM_1 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[3]) );
   assign INV_MULTIPLICAND[3] =  ~ OPA[3];
   PP_MIDDLE PPM_2 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[6]) );
   assign INV_MULTIPLICAND[4] =  ~ OPA[4];
   PP_MIDDLE PPM_3 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[8]) );
   assign INV_MULTIPLICAND[5] =  ~ OPA[5];
   PP_MIDDLE PPM_4 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[12]) );
   assign INV_MULTIPLICAND[6] =  ~ OPA[6];
   PP_MIDDLE PPM_5 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[15]) );
   assign INV_MULTIPLICAND[7] =  ~ OPA[7];
   PP_MIDDLE PPM_6 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[20]) );
   assign INV_MULTIPLICAND[8] =  ~ OPA[8];
   PP_MIDDLE PPM_7 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[24]) );
   assign INV_MULTIPLICAND[9] =  ~ OPA[9];
   PP_MIDDLE PPM_8 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[30]) );
   assign INV_MULTIPLICAND[10] =  ~ OPA[10];
   PP_MIDDLE PPM_9 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[35]) );
   assign INV_MULTIPLICAND[11] =  ~ OPA[11];
   PP_MIDDLE PPM_10 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[42]) );
   assign INV_MULTIPLICAND[12] =  ~ OPA[12];
   PP_MIDDLE PPM_11 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[48]) );
   assign INV_MULTIPLICAND[13] =  ~ OPA[13];
   PP_MIDDLE PPM_12 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[56]) );
   assign INV_MULTIPLICAND[14] =  ~ OPA[14];
   PP_MIDDLE PPM_13 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[63]) );
   assign INV_MULTIPLICAND[15] =  ~ OPA[15];
   PP_MIDDLE PPM_14 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[72]) );
   assign INV_MULTIPLICAND[16] =  ~ OPA[16];
   PP_MIDDLE PPM_15 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[80]) );
   assign INV_MULTIPLICAND[17] =  ~ OPA[17];
   PP_MIDDLE PPM_16 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[90]) );
   assign INV_MULTIPLICAND[18] =  ~ OPA[18];
   PP_MIDDLE PPM_17 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[99]) );
   assign INV_MULTIPLICAND[19] =  ~ OPA[19];
   PP_MIDDLE PPM_18 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[110]) );
   assign INV_MULTIPLICAND[20] =  ~ OPA[20];
   PP_MIDDLE PPM_19 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[120]) );
   assign INV_MULTIPLICAND[21] =  ~ OPA[21];
   PP_MIDDLE PPM_20 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[132]) );
   assign INV_MULTIPLICAND[22] =  ~ OPA[22];
   PP_MIDDLE PPM_21 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[143]) );
   assign INV_MULTIPLICAND[23] =  ~ OPA[23];
   PP_MIDDLE PPM_22 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[156]) );
   assign INV_MULTIPLICAND[24] =  ~ OPA[24];
   PP_MIDDLE PPM_23 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[168]) );
   assign INV_MULTIPLICAND[25] =  ~ OPA[25];
   PP_MIDDLE PPM_24 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[182]) );
   assign INV_MULTIPLICAND[26] =  ~ OPA[26];
   PP_MIDDLE PPM_25 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[195]) );
   assign INV_MULTIPLICAND[27] =  ~ OPA[27];
   PP_MIDDLE PPM_26 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[210]) );
   assign INV_MULTIPLICAND[28] =  ~ OPA[28];
   PP_MIDDLE PPM_27 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[224]) );
   assign INV_MULTIPLICAND[29] =  ~ OPA[29];
   PP_MIDDLE PPM_28 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[240]) );
   assign INV_MULTIPLICAND[30] =  ~ OPA[30];
   PP_MIDDLE PPM_29 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[255]) );
   assign INV_MULTIPLICAND[31] =  ~ OPA[31];
   PP_MIDDLE PPM_30 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[272]) );
   assign INV_MULTIPLICAND[32] =  ~ OPA[32];
   PP_MIDDLE PPM_31 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[288]) );
   PP_HIGH PPH_0 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[0]) , .TWONEG (INT_MULTIPLIER[1]) , .ONEPOS (INT_MULTIPLIER[2]) , .ONENEG (INT_MULTIPLIER[3]) , .PPBIT (SUMMAND[304]) );
   assign SUMMAND[305] = 1;
   DECODER DEC_1 (.INA (OPB[1]) , .INB (OPB[2]) , .INC (OPB[3]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) );
   PP_LOW PPL_1 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[4]) );
   R_GATE RGATE_1 (.INA (OPB[1]) , .INB (OPB[2]) , .INC (OPB[3]) , .PPBIT (SUMMAND[5]) );
   PP_MIDDLE PPM_32 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[7]) );
   PP_MIDDLE PPM_33 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[9]) );
   PP_MIDDLE PPM_34 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[13]) );
   PP_MIDDLE PPM_35 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[16]) );
   PP_MIDDLE PPM_36 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[21]) );
   PP_MIDDLE PPM_37 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[25]) );
   PP_MIDDLE PPM_38 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[31]) );
   PP_MIDDLE PPM_39 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[36]) );
   PP_MIDDLE PPM_40 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[43]) );
   PP_MIDDLE PPM_41 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[49]) );
   PP_MIDDLE PPM_42 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[57]) );
   PP_MIDDLE PPM_43 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[64]) );
   PP_MIDDLE PPM_44 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[73]) );
   PP_MIDDLE PPM_45 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[81]) );
   PP_MIDDLE PPM_46 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[91]) );
   PP_MIDDLE PPM_47 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[100]) );
   PP_MIDDLE PPM_48 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[111]) );
   PP_MIDDLE PPM_49 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[121]) );
   PP_MIDDLE PPM_50 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[133]) );
   PP_MIDDLE PPM_51 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[144]) );
   PP_MIDDLE PPM_52 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[157]) );
   PP_MIDDLE PPM_53 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[169]) );
   PP_MIDDLE PPM_54 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[183]) );
   PP_MIDDLE PPM_55 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[196]) );
   PP_MIDDLE PPM_56 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[211]) );
   PP_MIDDLE PPM_57 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[225]) );
   PP_MIDDLE PPM_58 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[241]) );
   PP_MIDDLE PPM_59 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[256]) );
   PP_MIDDLE PPM_60 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[273]) );
   PP_MIDDLE PPM_61 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[289]) );
   PP_MIDDLE PPM_62 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[306]) );
   PP_MIDDLE PPM_63 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[321]) );
   assign SUMMAND[322] = LOGIC_ONE;
   PP_HIGH PPH_1 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[4]) , .TWONEG (INT_MULTIPLIER[5]) , .ONEPOS (INT_MULTIPLIER[6]) , .ONENEG (INT_MULTIPLIER[7]) , .PPBIT (SUMMAND[337]) );
   DECODER DEC_2 (.INA (OPB[3]) , .INB (OPB[4]) , .INC (OPB[5]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) );
   PP_LOW PPL_2 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[10]) );
   R_GATE RGATE_2 (.INA (OPB[3]) , .INB (OPB[4]) , .INC (OPB[5]) , .PPBIT (SUMMAND[11]) );
   PP_MIDDLE PPM_64 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[14]) );
   PP_MIDDLE PPM_65 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[17]) );
   PP_MIDDLE PPM_66 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[22]) );
   PP_MIDDLE PPM_67 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[26]) );
   PP_MIDDLE PPM_68 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[32]) );
   PP_MIDDLE PPM_69 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[37]) );
   PP_MIDDLE PPM_70 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[44]) );
   PP_MIDDLE PPM_71 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[50]) );
   PP_MIDDLE PPM_72 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[58]) );
   PP_MIDDLE PPM_73 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[65]) );
   PP_MIDDLE PPM_74 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[74]) );
   PP_MIDDLE PPM_75 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[82]) );
   PP_MIDDLE PPM_76 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[92]) );
   PP_MIDDLE PPM_77 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[101]) );
   PP_MIDDLE PPM_78 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[112]) );
   PP_MIDDLE PPM_79 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[122]) );
   PP_MIDDLE PPM_80 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[134]) );
   PP_MIDDLE PPM_81 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[145]) );
   PP_MIDDLE PPM_82 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[158]) );
   PP_MIDDLE PPM_83 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[170]) );
   PP_MIDDLE PPM_84 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[184]) );
   PP_MIDDLE PPM_85 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[197]) );
   PP_MIDDLE PPM_86 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[212]) );
   PP_MIDDLE PPM_87 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[226]) );
   PP_MIDDLE PPM_88 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[242]) );
   PP_MIDDLE PPM_89 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[257]) );
   PP_MIDDLE PPM_90 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[274]) );
   PP_MIDDLE PPM_91 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[290]) );
   PP_MIDDLE PPM_92 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[307]) );
   PP_MIDDLE PPM_93 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[323]) );
   PP_MIDDLE PPM_94 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[338]) );
   PP_MIDDLE PPM_95 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[352]) );
   assign SUMMAND[353] = LOGIC_ONE;
   PP_HIGH PPH_2 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[8]) , .TWONEG (INT_MULTIPLIER[9]) , .ONEPOS (INT_MULTIPLIER[10]) , .ONENEG (INT_MULTIPLIER[11]) , .PPBIT (SUMMAND[367]) );
   DECODER DEC_3 (.INA (OPB[5]) , .INB (OPB[6]) , .INC (OPB[7]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) );
   PP_LOW PPL_3 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[18]) );
   R_GATE RGATE_3 (.INA (OPB[5]) , .INB (OPB[6]) , .INC (OPB[7]) , .PPBIT (SUMMAND[19]) );
   PP_MIDDLE PPM_96 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[23]) );
   PP_MIDDLE PPM_97 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[27]) );
   PP_MIDDLE PPM_98 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[33]) );
   PP_MIDDLE PPM_99 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[38]) );
   PP_MIDDLE PPM_100 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[45]) );
   PP_MIDDLE PPM_101 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[51]) );
   PP_MIDDLE PPM_102 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[59]) );
   PP_MIDDLE PPM_103 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[66]) );
   PP_MIDDLE PPM_104 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[75]) );
   PP_MIDDLE PPM_105 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[83]) );
   PP_MIDDLE PPM_106 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[93]) );
   PP_MIDDLE PPM_107 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[102]) );
   PP_MIDDLE PPM_108 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[113]) );
   PP_MIDDLE PPM_109 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[123]) );
   PP_MIDDLE PPM_110 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[135]) );
   PP_MIDDLE PPM_111 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[146]) );
   PP_MIDDLE PPM_112 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[159]) );
   PP_MIDDLE PPM_113 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[171]) );
   PP_MIDDLE PPM_114 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[185]) );
   PP_MIDDLE PPM_115 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[198]) );
   PP_MIDDLE PPM_116 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[213]) );
   PP_MIDDLE PPM_117 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[227]) );
   PP_MIDDLE PPM_118 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[243]) );
   PP_MIDDLE PPM_119 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[258]) );
   PP_MIDDLE PPM_120 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[275]) );
   PP_MIDDLE PPM_121 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[291]) );
   PP_MIDDLE PPM_122 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[308]) );
   PP_MIDDLE PPM_123 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[324]) );
   PP_MIDDLE PPM_124 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[339]) );
   PP_MIDDLE PPM_125 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[354]) );
   PP_MIDDLE PPM_126 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[368]) );
   PP_MIDDLE PPM_127 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[381]) );
   assign SUMMAND[382] = LOGIC_ONE;
   PP_HIGH PPH_3 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[12]) , .TWONEG (INT_MULTIPLIER[13]) , .ONEPOS (INT_MULTIPLIER[14]) , .ONENEG (INT_MULTIPLIER[15]) , .PPBIT (SUMMAND[395]) );
   DECODER DEC_4 (.INA (OPB[7]) , .INB (OPB[8]) , .INC (OPB[9]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) );
   PP_LOW PPL_4 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[28]) );
   R_GATE RGATE_4 (.INA (OPB[7]) , .INB (OPB[8]) , .INC (OPB[9]) , .PPBIT (SUMMAND[29]) );
   PP_MIDDLE PPM_128 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[34]) );
   PP_MIDDLE PPM_129 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[39]) );
   PP_MIDDLE PPM_130 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[46]) );
   PP_MIDDLE PPM_131 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[52]) );
   PP_MIDDLE PPM_132 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[60]) );
   PP_MIDDLE PPM_133 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[67]) );
   PP_MIDDLE PPM_134 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[76]) );
   PP_MIDDLE PPM_135 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[84]) );
   PP_MIDDLE PPM_136 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[94]) );
   PP_MIDDLE PPM_137 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[103]) );
   PP_MIDDLE PPM_138 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[114]) );
   PP_MIDDLE PPM_139 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[124]) );
   PP_MIDDLE PPM_140 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[136]) );
   PP_MIDDLE PPM_141 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[147]) );
   PP_MIDDLE PPM_142 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[160]) );
   PP_MIDDLE PPM_143 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[172]) );
   PP_MIDDLE PPM_144 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[186]) );
   PP_MIDDLE PPM_145 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[199]) );
   PP_MIDDLE PPM_146 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[214]) );
   PP_MIDDLE PPM_147 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[228]) );
   PP_MIDDLE PPM_148 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[244]) );
   PP_MIDDLE PPM_149 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[259]) );
   PP_MIDDLE PPM_150 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[276]) );
   PP_MIDDLE PPM_151 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[292]) );
   PP_MIDDLE PPM_152 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[309]) );
   PP_MIDDLE PPM_153 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[325]) );
   PP_MIDDLE PPM_154 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[340]) );
   PP_MIDDLE PPM_155 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[355]) );
   PP_MIDDLE PPM_156 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[369]) );
   PP_MIDDLE PPM_157 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[383]) );
   PP_MIDDLE PPM_158 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[396]) );
   PP_MIDDLE PPM_159 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[408]) );
   assign SUMMAND[409] = LOGIC_ONE;
   PP_HIGH PPH_4 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[16]) , .TWONEG (INT_MULTIPLIER[17]) , .ONEPOS (INT_MULTIPLIER[18]) , .ONENEG (INT_MULTIPLIER[19]) , .PPBIT (SUMMAND[421]) );
   DECODER DEC_5 (.INA (OPB[9]) , .INB (OPB[10]) , .INC (OPB[11]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) );
   PP_LOW PPL_5 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[40]) );
   R_GATE RGATE_5 (.INA (OPB[9]) , .INB (OPB[10]) , .INC (OPB[11]) , .PPBIT (SUMMAND[41]) );
   PP_MIDDLE PPM_160 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[47]) );
   PP_MIDDLE PPM_161 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[53]) );
   PP_MIDDLE PPM_162 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[61]) );
   PP_MIDDLE PPM_163 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[68]) );
   PP_MIDDLE PPM_164 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[77]) );
   PP_MIDDLE PPM_165 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[85]) );
   PP_MIDDLE PPM_166 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[95]) );
   PP_MIDDLE PPM_167 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[104]) );
   PP_MIDDLE PPM_168 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[115]) );
   PP_MIDDLE PPM_169 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[125]) );
   PP_MIDDLE PPM_170 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[137]) );
   PP_MIDDLE PPM_171 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[148]) );
   PP_MIDDLE PPM_172 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[161]) );
   PP_MIDDLE PPM_173 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[173]) );
   PP_MIDDLE PPM_174 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[187]) );
   PP_MIDDLE PPM_175 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[200]) );
   PP_MIDDLE PPM_176 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[215]) );
   PP_MIDDLE PPM_177 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[229]) );
   PP_MIDDLE PPM_178 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[245]) );
   PP_MIDDLE PPM_179 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[260]) );
   PP_MIDDLE PPM_180 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[277]) );
   PP_MIDDLE PPM_181 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[293]) );
   PP_MIDDLE PPM_182 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[310]) );
   PP_MIDDLE PPM_183 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[326]) );
   PP_MIDDLE PPM_184 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[341]) );
   PP_MIDDLE PPM_185 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[356]) );
   PP_MIDDLE PPM_186 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[370]) );
   PP_MIDDLE PPM_187 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[384]) );
   PP_MIDDLE PPM_188 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[397]) );
   PP_MIDDLE PPM_189 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[410]) );
   PP_MIDDLE PPM_190 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[422]) );
   PP_MIDDLE PPM_191 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[433]) );
   assign SUMMAND[434] = LOGIC_ONE;
   PP_HIGH PPH_5 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[20]) , .TWONEG (INT_MULTIPLIER[21]) , .ONEPOS (INT_MULTIPLIER[22]) , .ONENEG (INT_MULTIPLIER[23]) , .PPBIT (SUMMAND[445]) );
   DECODER DEC_6 (.INA (OPB[11]) , .INB (OPB[12]) , .INC (OPB[13]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) );
   PP_LOW PPL_6 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[54]) );
   R_GATE RGATE_6 (.INA (OPB[11]) , .INB (OPB[12]) , .INC (OPB[13]) , .PPBIT (SUMMAND[55]) );
   PP_MIDDLE PPM_192 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[62]) );
   PP_MIDDLE PPM_193 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[69]) );
   PP_MIDDLE PPM_194 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[78]) );
   PP_MIDDLE PPM_195 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[86]) );
   PP_MIDDLE PPM_196 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[96]) );
   PP_MIDDLE PPM_197 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[105]) );
   PP_MIDDLE PPM_198 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[116]) );
   PP_MIDDLE PPM_199 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[126]) );
   PP_MIDDLE PPM_200 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[138]) );
   PP_MIDDLE PPM_201 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[149]) );
   PP_MIDDLE PPM_202 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[162]) );
   PP_MIDDLE PPM_203 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[174]) );
   PP_MIDDLE PPM_204 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[188]) );
   PP_MIDDLE PPM_205 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[201]) );
   PP_MIDDLE PPM_206 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[216]) );
   PP_MIDDLE PPM_207 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[230]) );
   PP_MIDDLE PPM_208 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[246]) );
   PP_MIDDLE PPM_209 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[261]) );
   PP_MIDDLE PPM_210 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[278]) );
   PP_MIDDLE PPM_211 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[294]) );
   PP_MIDDLE PPM_212 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[311]) );
   PP_MIDDLE PPM_213 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[327]) );
   PP_MIDDLE PPM_214 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[342]) );
   PP_MIDDLE PPM_215 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[357]) );
   PP_MIDDLE PPM_216 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[371]) );
   PP_MIDDLE PPM_217 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[385]) );
   PP_MIDDLE PPM_218 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[398]) );
   PP_MIDDLE PPM_219 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[411]) );
   PP_MIDDLE PPM_220 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[423]) );
   PP_MIDDLE PPM_221 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[435]) );
   PP_MIDDLE PPM_222 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[446]) );
   PP_MIDDLE PPM_223 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[456]) );
   assign SUMMAND[457] = LOGIC_ONE;
   PP_HIGH PPH_6 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[24]) , .TWONEG (INT_MULTIPLIER[25]) , .ONEPOS (INT_MULTIPLIER[26]) , .ONENEG (INT_MULTIPLIER[27]) , .PPBIT (SUMMAND[467]) );
   DECODER DEC_7 (.INA (OPB[13]) , .INB (OPB[14]) , .INC (OPB[15]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) );
   PP_LOW PPL_7 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[70]) );
   R_GATE RGATE_7 (.INA (OPB[13]) , .INB (OPB[14]) , .INC (OPB[15]) , .PPBIT (SUMMAND[71]) );
   PP_MIDDLE PPM_224 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[79]) );
   PP_MIDDLE PPM_225 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[87]) );
   PP_MIDDLE PPM_226 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[97]) );
   PP_MIDDLE PPM_227 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[106]) );
   PP_MIDDLE PPM_228 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[117]) );
   PP_MIDDLE PPM_229 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[127]) );
   PP_MIDDLE PPM_230 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[139]) );
   PP_MIDDLE PPM_231 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[150]) );
   PP_MIDDLE PPM_232 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[163]) );
   PP_MIDDLE PPM_233 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[175]) );
   PP_MIDDLE PPM_234 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[189]) );
   PP_MIDDLE PPM_235 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[202]) );
   PP_MIDDLE PPM_236 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[217]) );
   PP_MIDDLE PPM_237 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[231]) );
   PP_MIDDLE PPM_238 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[247]) );
   PP_MIDDLE PPM_239 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[262]) );
   PP_MIDDLE PPM_240 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[279]) );
   PP_MIDDLE PPM_241 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[295]) );
   PP_MIDDLE PPM_242 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[312]) );
   PP_MIDDLE PPM_243 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[328]) );
   PP_MIDDLE PPM_244 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[343]) );
   PP_MIDDLE PPM_245 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[358]) );
   PP_MIDDLE PPM_246 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[372]) );
   PP_MIDDLE PPM_247 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[386]) );
   PP_MIDDLE PPM_248 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[399]) );
   PP_MIDDLE PPM_249 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[412]) );
   PP_MIDDLE PPM_250 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[424]) );
   PP_MIDDLE PPM_251 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[436]) );
   PP_MIDDLE PPM_252 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[447]) );
   PP_MIDDLE PPM_253 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[458]) );
   PP_MIDDLE PPM_254 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[468]) );
   PP_MIDDLE PPM_255 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[477]) );
   assign SUMMAND[478] = LOGIC_ONE;
   PP_HIGH PPH_7 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[28]) , .TWONEG (INT_MULTIPLIER[29]) , .ONEPOS (INT_MULTIPLIER[30]) , .ONENEG (INT_MULTIPLIER[31]) , .PPBIT (SUMMAND[487]) );
   DECODER DEC_8 (.INA (OPB[15]) , .INB (OPB[16]) , .INC (OPB[17]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) );
   PP_LOW PPL_8 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[88]) );
   R_GATE RGATE_8 (.INA (OPB[15]) , .INB (OPB[16]) , .INC (OPB[17]) , .PPBIT (SUMMAND[89]) );
   PP_MIDDLE PPM_256 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[98]) );
   PP_MIDDLE PPM_257 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[107]) );
   PP_MIDDLE PPM_258 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[118]) );
   PP_MIDDLE PPM_259 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[128]) );
   PP_MIDDLE PPM_260 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[140]) );
   PP_MIDDLE PPM_261 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[151]) );
   PP_MIDDLE PPM_262 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[164]) );
   PP_MIDDLE PPM_263 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[176]) );
   PP_MIDDLE PPM_264 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[190]) );
   PP_MIDDLE PPM_265 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[203]) );
   PP_MIDDLE PPM_266 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[218]) );
   PP_MIDDLE PPM_267 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[232]) );
   PP_MIDDLE PPM_268 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[248]) );
   PP_MIDDLE PPM_269 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[263]) );
   PP_MIDDLE PPM_270 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[280]) );
   PP_MIDDLE PPM_271 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[296]) );
   PP_MIDDLE PPM_272 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[313]) );
   PP_MIDDLE PPM_273 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[329]) );
   PP_MIDDLE PPM_274 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[344]) );
   PP_MIDDLE PPM_275 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[359]) );
   PP_MIDDLE PPM_276 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[373]) );
   PP_MIDDLE PPM_277 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[387]) );
   PP_MIDDLE PPM_278 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[400]) );
   PP_MIDDLE PPM_279 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[413]) );
   PP_MIDDLE PPM_280 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[425]) );
   PP_MIDDLE PPM_281 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[437]) );
   PP_MIDDLE PPM_282 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[448]) );
   PP_MIDDLE PPM_283 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[459]) );
   PP_MIDDLE PPM_284 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[469]) );
   PP_MIDDLE PPM_285 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[479]) );
   PP_MIDDLE PPM_286 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[488]) );
   PP_MIDDLE PPM_287 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[496]) );
   assign SUMMAND[497] = LOGIC_ONE;
   PP_HIGH PPH_8 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[32]) , .TWONEG (INT_MULTIPLIER[33]) , .ONEPOS (INT_MULTIPLIER[34]) , .ONENEG (INT_MULTIPLIER[35]) , .PPBIT (SUMMAND[505]) );
   DECODER DEC_9 (.INA (OPB[17]) , .INB (OPB[18]) , .INC (OPB[19]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) );
   PP_LOW PPL_9 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[108]) );
   R_GATE RGATE_9 (.INA (OPB[17]) , .INB (OPB[18]) , .INC (OPB[19]) , .PPBIT (SUMMAND[109]) );
   PP_MIDDLE PPM_288 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[119]) );
   PP_MIDDLE PPM_289 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[129]) );
   PP_MIDDLE PPM_290 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[141]) );
   PP_MIDDLE PPM_291 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[152]) );
   PP_MIDDLE PPM_292 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[165]) );
   PP_MIDDLE PPM_293 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[177]) );
   PP_MIDDLE PPM_294 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[191]) );
   PP_MIDDLE PPM_295 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[204]) );
   PP_MIDDLE PPM_296 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[219]) );
   PP_MIDDLE PPM_297 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[233]) );
   PP_MIDDLE PPM_298 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[249]) );
   PP_MIDDLE PPM_299 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[264]) );
   PP_MIDDLE PPM_300 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[281]) );
   PP_MIDDLE PPM_301 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[297]) );
   PP_MIDDLE PPM_302 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[314]) );
   PP_MIDDLE PPM_303 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[330]) );
   PP_MIDDLE PPM_304 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[345]) );
   PP_MIDDLE PPM_305 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[360]) );
   PP_MIDDLE PPM_306 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[374]) );
   PP_MIDDLE PPM_307 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[388]) );
   PP_MIDDLE PPM_308 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[401]) );
   PP_MIDDLE PPM_309 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[414]) );
   PP_MIDDLE PPM_310 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[426]) );
   PP_MIDDLE PPM_311 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[438]) );
   PP_MIDDLE PPM_312 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[449]) );
   PP_MIDDLE PPM_313 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[460]) );
   PP_MIDDLE PPM_314 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[470]) );
   PP_MIDDLE PPM_315 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[480]) );
   PP_MIDDLE PPM_316 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[489]) );
   PP_MIDDLE PPM_317 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[498]) );
   PP_MIDDLE PPM_318 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[506]) );
   PP_MIDDLE PPM_319 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[513]) );
   assign SUMMAND[514] = LOGIC_ONE;
   PP_HIGH PPH_9 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[36]) , .TWONEG (INT_MULTIPLIER[37]) , .ONEPOS (INT_MULTIPLIER[38]) , .ONENEG (INT_MULTIPLIER[39]) , .PPBIT (SUMMAND[521]) );
   DECODER DEC_10 (.INA (OPB[19]) , .INB (OPB[20]) , .INC (OPB[21]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) );
   PP_LOW PPL_10 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[130]) );
   R_GATE RGATE_10 (.INA (OPB[19]) , .INB (OPB[20]) , .INC (OPB[21]) , .PPBIT (SUMMAND[131]) );
   PP_MIDDLE PPM_320 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[142]) );
   PP_MIDDLE PPM_321 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[153]) );
   PP_MIDDLE PPM_322 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[166]) );
   PP_MIDDLE PPM_323 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[178]) );
   PP_MIDDLE PPM_324 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[192]) );
   PP_MIDDLE PPM_325 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[205]) );
   PP_MIDDLE PPM_326 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[220]) );
   PP_MIDDLE PPM_327 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[234]) );
   PP_MIDDLE PPM_328 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[250]) );
   PP_MIDDLE PPM_329 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[265]) );
   PP_MIDDLE PPM_330 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[282]) );
   PP_MIDDLE PPM_331 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[298]) );
   PP_MIDDLE PPM_332 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[315]) );
   PP_MIDDLE PPM_333 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[331]) );
   PP_MIDDLE PPM_334 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[346]) );
   PP_MIDDLE PPM_335 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[361]) );
   PP_MIDDLE PPM_336 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[375]) );
   PP_MIDDLE PPM_337 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[389]) );
   PP_MIDDLE PPM_338 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[402]) );
   PP_MIDDLE PPM_339 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[415]) );
   PP_MIDDLE PPM_340 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[427]) );
   PP_MIDDLE PPM_341 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[439]) );
   PP_MIDDLE PPM_342 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[450]) );
   PP_MIDDLE PPM_343 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[461]) );
   PP_MIDDLE PPM_344 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[471]) );
   PP_MIDDLE PPM_345 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[481]) );
   PP_MIDDLE PPM_346 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[490]) );
   PP_MIDDLE PPM_347 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[499]) );
   PP_MIDDLE PPM_348 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[507]) );
   PP_MIDDLE PPM_349 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[515]) );
   PP_MIDDLE PPM_350 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[522]) );
   PP_MIDDLE PPM_351 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[528]) );
   assign SUMMAND[529] = LOGIC_ONE;
   PP_HIGH PPH_10 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[40]) , .TWONEG (INT_MULTIPLIER[41]) , .ONEPOS (INT_MULTIPLIER[42]) , .ONENEG (INT_MULTIPLIER[43]) , .PPBIT (SUMMAND[535]) );
   DECODER DEC_11 (.INA (OPB[21]) , .INB (OPB[22]) , .INC (OPB[23]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) );
   PP_LOW PPL_11 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[154]) );
   R_GATE RGATE_11 (.INA (OPB[21]) , .INB (OPB[22]) , .INC (OPB[23]) , .PPBIT (SUMMAND[155]) );
   PP_MIDDLE PPM_352 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[167]) );
   PP_MIDDLE PPM_353 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[179]) );
   PP_MIDDLE PPM_354 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[193]) );
   PP_MIDDLE PPM_355 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[206]) );
   PP_MIDDLE PPM_356 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[221]) );
   PP_MIDDLE PPM_357 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[235]) );
   PP_MIDDLE PPM_358 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[251]) );
   PP_MIDDLE PPM_359 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[266]) );
   PP_MIDDLE PPM_360 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[283]) );
   PP_MIDDLE PPM_361 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[299]) );
   PP_MIDDLE PPM_362 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[316]) );
   PP_MIDDLE PPM_363 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[332]) );
   PP_MIDDLE PPM_364 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[347]) );
   PP_MIDDLE PPM_365 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[362]) );
   PP_MIDDLE PPM_366 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[376]) );
   PP_MIDDLE PPM_367 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[390]) );
   PP_MIDDLE PPM_368 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[403]) );
   PP_MIDDLE PPM_369 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[416]) );
   PP_MIDDLE PPM_370 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[428]) );
   PP_MIDDLE PPM_371 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[440]) );
   PP_MIDDLE PPM_372 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[451]) );
   PP_MIDDLE PPM_373 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[462]) );
   PP_MIDDLE PPM_374 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[472]) );
   PP_MIDDLE PPM_375 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[482]) );
   PP_MIDDLE PPM_376 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[491]) );
   PP_MIDDLE PPM_377 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[500]) );
   PP_MIDDLE PPM_378 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[508]) );
   PP_MIDDLE PPM_379 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[516]) );
   PP_MIDDLE PPM_380 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[523]) );
   PP_MIDDLE PPM_381 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[530]) );
   PP_MIDDLE PPM_382 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[536]) );
   PP_MIDDLE PPM_383 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[541]) );
   assign SUMMAND[542] = LOGIC_ONE;
   PP_HIGH PPH_11 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[44]) , .TWONEG (INT_MULTIPLIER[45]) , .ONEPOS (INT_MULTIPLIER[46]) , .ONENEG (INT_MULTIPLIER[47]) , .PPBIT (SUMMAND[547]) );
   DECODER DEC_12 (.INA (OPB[23]) , .INB (OPB[24]) , .INC (OPB[25]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) );
   PP_LOW PPL_12 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[180]) );
   R_GATE RGATE_12 (.INA (OPB[23]) , .INB (OPB[24]) , .INC (OPB[25]) , .PPBIT (SUMMAND[181]) );
   PP_MIDDLE PPM_384 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[194]) );
   PP_MIDDLE PPM_385 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[207]) );
   PP_MIDDLE PPM_386 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[222]) );
   PP_MIDDLE PPM_387 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[236]) );
   PP_MIDDLE PPM_388 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[252]) );
   PP_MIDDLE PPM_389 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[267]) );
   PP_MIDDLE PPM_390 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[284]) );
   PP_MIDDLE PPM_391 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[300]) );
   PP_MIDDLE PPM_392 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[317]) );
   PP_MIDDLE PPM_393 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[333]) );
   PP_MIDDLE PPM_394 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[348]) );
   PP_MIDDLE PPM_395 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[363]) );
   PP_MIDDLE PPM_396 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[377]) );
   PP_MIDDLE PPM_397 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[391]) );
   PP_MIDDLE PPM_398 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[404]) );
   PP_MIDDLE PPM_399 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[417]) );
   PP_MIDDLE PPM_400 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[429]) );
   PP_MIDDLE PPM_401 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[441]) );
   PP_MIDDLE PPM_402 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[452]) );
   PP_MIDDLE PPM_403 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[463]) );
   PP_MIDDLE PPM_404 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[473]) );
   PP_MIDDLE PPM_405 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[483]) );
   PP_MIDDLE PPM_406 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[492]) );
   PP_MIDDLE PPM_407 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[501]) );
   PP_MIDDLE PPM_408 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[509]) );
   PP_MIDDLE PPM_409 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[517]) );
   PP_MIDDLE PPM_410 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[524]) );
   PP_MIDDLE PPM_411 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[531]) );
   PP_MIDDLE PPM_412 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[537]) );
   PP_MIDDLE PPM_413 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[543]) );
   PP_MIDDLE PPM_414 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[548]) );
   PP_MIDDLE PPM_415 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[552]) );
   assign SUMMAND[553] = LOGIC_ONE;
   PP_HIGH PPH_12 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[48]) , .TWONEG (INT_MULTIPLIER[49]) , .ONEPOS (INT_MULTIPLIER[50]) , .ONENEG (INT_MULTIPLIER[51]) , .PPBIT (SUMMAND[557]) );
   DECODER DEC_13 (.INA (OPB[25]) , .INB (OPB[26]) , .INC (OPB[27]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) );
   PP_LOW PPL_13 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[208]) );
   R_GATE RGATE_13 (.INA (OPB[25]) , .INB (OPB[26]) , .INC (OPB[27]) , .PPBIT (SUMMAND[209]) );
   PP_MIDDLE PPM_416 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[223]) );
   PP_MIDDLE PPM_417 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[237]) );
   PP_MIDDLE PPM_418 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[253]) );
   PP_MIDDLE PPM_419 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[268]) );
   PP_MIDDLE PPM_420 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[285]) );
   PP_MIDDLE PPM_421 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[301]) );
   PP_MIDDLE PPM_422 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[318]) );
   PP_MIDDLE PPM_423 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[334]) );
   PP_MIDDLE PPM_424 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[349]) );
   PP_MIDDLE PPM_425 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[364]) );
   PP_MIDDLE PPM_426 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[378]) );
   PP_MIDDLE PPM_427 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[392]) );
   PP_MIDDLE PPM_428 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[405]) );
   PP_MIDDLE PPM_429 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[418]) );
   PP_MIDDLE PPM_430 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[430]) );
   PP_MIDDLE PPM_431 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[442]) );
   PP_MIDDLE PPM_432 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[453]) );
   PP_MIDDLE PPM_433 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[464]) );
   PP_MIDDLE PPM_434 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[474]) );
   PP_MIDDLE PPM_435 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[484]) );
   PP_MIDDLE PPM_436 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[493]) );
   PP_MIDDLE PPM_437 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[502]) );
   PP_MIDDLE PPM_438 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[510]) );
   PP_MIDDLE PPM_439 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[518]) );
   PP_MIDDLE PPM_440 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[525]) );
   PP_MIDDLE PPM_441 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[532]) );
   PP_MIDDLE PPM_442 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[538]) );
   PP_MIDDLE PPM_443 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[544]) );
   PP_MIDDLE PPM_444 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[549]) );
   PP_MIDDLE PPM_445 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[554]) );
   PP_MIDDLE PPM_446 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[558]) );
   PP_MIDDLE PPM_447 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[561]) );
   assign SUMMAND[562] = LOGIC_ONE;
   PP_HIGH PPH_13 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[52]) , .TWONEG (INT_MULTIPLIER[53]) , .ONEPOS (INT_MULTIPLIER[54]) , .ONENEG (INT_MULTIPLIER[55]) , .PPBIT (SUMMAND[565]) );
   DECODER DEC_14 (.INA (OPB[27]) , .INB (OPB[28]) , .INC (OPB[29]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) );
   PP_LOW PPL_14 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[238]) );
   R_GATE RGATE_14 (.INA (OPB[27]) , .INB (OPB[28]) , .INC (OPB[29]) , .PPBIT (SUMMAND[239]) );
   PP_MIDDLE PPM_448 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[254]) );
   PP_MIDDLE PPM_449 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[269]) );
   PP_MIDDLE PPM_450 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[286]) );
   PP_MIDDLE PPM_451 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[302]) );
   PP_MIDDLE PPM_452 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[319]) );
   PP_MIDDLE PPM_453 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[335]) );
   PP_MIDDLE PPM_454 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[350]) );
   PP_MIDDLE PPM_455 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[365]) );
   PP_MIDDLE PPM_456 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[379]) );
   PP_MIDDLE PPM_457 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[393]) );
   PP_MIDDLE PPM_458 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[406]) );
   PP_MIDDLE PPM_459 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[419]) );
   PP_MIDDLE PPM_460 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[431]) );
   PP_MIDDLE PPM_461 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[443]) );
   PP_MIDDLE PPM_462 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[454]) );
   PP_MIDDLE PPM_463 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[465]) );
   PP_MIDDLE PPM_464 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[475]) );
   PP_MIDDLE PPM_465 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[485]) );
   PP_MIDDLE PPM_466 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[494]) );
   PP_MIDDLE PPM_467 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[503]) );
   PP_MIDDLE PPM_468 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[511]) );
   PP_MIDDLE PPM_469 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[519]) );
   PP_MIDDLE PPM_470 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[526]) );
   PP_MIDDLE PPM_471 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[533]) );
   PP_MIDDLE PPM_472 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[539]) );
   PP_MIDDLE PPM_473 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[545]) );
   PP_MIDDLE PPM_474 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[550]) );
   PP_MIDDLE PPM_475 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[555]) );
   PP_MIDDLE PPM_476 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[559]) );
   PP_MIDDLE PPM_477 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[563]) );
   PP_MIDDLE PPM_478 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[566]) );
   PP_MIDDLE PPM_479 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[568]) );
   assign SUMMAND[569] = LOGIC_ONE;
   PP_HIGH PPH_14 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[56]) , .TWONEG (INT_MULTIPLIER[57]) , .ONEPOS (INT_MULTIPLIER[58]) , .ONENEG (INT_MULTIPLIER[59]) , .PPBIT (SUMMAND[571]) );
   DECODER DEC_15 (.INA (OPB[29]) , .INB (OPB[30]) , .INC (OPB[31]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) );
   PP_LOW PPL_15 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[270]) );
   R_GATE RGATE_15 (.INA (OPB[29]) , .INB (OPB[30]) , .INC (OPB[31]) , .PPBIT (SUMMAND[271]) );
   PP_MIDDLE PPM_480 (.INA (OPA[0]) , .INB (INV_MULTIPLICAND[0]) , .INC (OPA[1]) , .IND (INV_MULTIPLICAND[1]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[287]) );
   PP_MIDDLE PPM_481 (.INA (OPA[1]) , .INB (INV_MULTIPLICAND[1]) , .INC (OPA[2]) , .IND (INV_MULTIPLICAND[2]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[303]) );
   PP_MIDDLE PPM_482 (.INA (OPA[2]) , .INB (INV_MULTIPLICAND[2]) , .INC (OPA[3]) , .IND (INV_MULTIPLICAND[3]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[320]) );
   PP_MIDDLE PPM_483 (.INA (OPA[3]) , .INB (INV_MULTIPLICAND[3]) , .INC (OPA[4]) , .IND (INV_MULTIPLICAND[4]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[336]) );
   PP_MIDDLE PPM_484 (.INA (OPA[4]) , .INB (INV_MULTIPLICAND[4]) , .INC (OPA[5]) , .IND (INV_MULTIPLICAND[5]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[351]) );
   PP_MIDDLE PPM_485 (.INA (OPA[5]) , .INB (INV_MULTIPLICAND[5]) , .INC (OPA[6]) , .IND (INV_MULTIPLICAND[6]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[366]) );
   PP_MIDDLE PPM_486 (.INA (OPA[6]) , .INB (INV_MULTIPLICAND[6]) , .INC (OPA[7]) , .IND (INV_MULTIPLICAND[7]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[380]) );
   PP_MIDDLE PPM_487 (.INA (OPA[7]) , .INB (INV_MULTIPLICAND[7]) , .INC (OPA[8]) , .IND (INV_MULTIPLICAND[8]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[394]) );
   PP_MIDDLE PPM_488 (.INA (OPA[8]) , .INB (INV_MULTIPLICAND[8]) , .INC (OPA[9]) , .IND (INV_MULTIPLICAND[9]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[407]) );
   PP_MIDDLE PPM_489 (.INA (OPA[9]) , .INB (INV_MULTIPLICAND[9]) , .INC (OPA[10]) , .IND (INV_MULTIPLICAND[10]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[420]) );
   PP_MIDDLE PPM_490 (.INA (OPA[10]) , .INB (INV_MULTIPLICAND[10]) , .INC (OPA[11]) , .IND (INV_MULTIPLICAND[11]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[432]) );
   PP_MIDDLE PPM_491 (.INA (OPA[11]) , .INB (INV_MULTIPLICAND[11]) , .INC (OPA[12]) , .IND (INV_MULTIPLICAND[12]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[444]) );
   PP_MIDDLE PPM_492 (.INA (OPA[12]) , .INB (INV_MULTIPLICAND[12]) , .INC (OPA[13]) , .IND (INV_MULTIPLICAND[13]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[455]) );
   PP_MIDDLE PPM_493 (.INA (OPA[13]) , .INB (INV_MULTIPLICAND[13]) , .INC (OPA[14]) , .IND (INV_MULTIPLICAND[14]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[466]) );
   PP_MIDDLE PPM_494 (.INA (OPA[14]) , .INB (INV_MULTIPLICAND[14]) , .INC (OPA[15]) , .IND (INV_MULTIPLICAND[15]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[476]) );
   PP_MIDDLE PPM_495 (.INA (OPA[15]) , .INB (INV_MULTIPLICAND[15]) , .INC (OPA[16]) , .IND (INV_MULTIPLICAND[16]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[486]) );
   PP_MIDDLE PPM_496 (.INA (OPA[16]) , .INB (INV_MULTIPLICAND[16]) , .INC (OPA[17]) , .IND (INV_MULTIPLICAND[17]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[495]) );
   PP_MIDDLE PPM_497 (.INA (OPA[17]) , .INB (INV_MULTIPLICAND[17]) , .INC (OPA[18]) , .IND (INV_MULTIPLICAND[18]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[504]) );
   PP_MIDDLE PPM_498 (.INA (OPA[18]) , .INB (INV_MULTIPLICAND[18]) , .INC (OPA[19]) , .IND (INV_MULTIPLICAND[19]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[512]) );
   PP_MIDDLE PPM_499 (.INA (OPA[19]) , .INB (INV_MULTIPLICAND[19]) , .INC (OPA[20]) , .IND (INV_MULTIPLICAND[20]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[520]) );
   PP_MIDDLE PPM_500 (.INA (OPA[20]) , .INB (INV_MULTIPLICAND[20]) , .INC (OPA[21]) , .IND (INV_MULTIPLICAND[21]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[527]) );
   PP_MIDDLE PPM_501 (.INA (OPA[21]) , .INB (INV_MULTIPLICAND[21]) , .INC (OPA[22]) , .IND (INV_MULTIPLICAND[22]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[534]) );
   PP_MIDDLE PPM_502 (.INA (OPA[22]) , .INB (INV_MULTIPLICAND[22]) , .INC (OPA[23]) , .IND (INV_MULTIPLICAND[23]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[540]) );
   PP_MIDDLE PPM_503 (.INA (OPA[23]) , .INB (INV_MULTIPLICAND[23]) , .INC (OPA[24]) , .IND (INV_MULTIPLICAND[24]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[546]) );
   PP_MIDDLE PPM_504 (.INA (OPA[24]) , .INB (INV_MULTIPLICAND[24]) , .INC (OPA[25]) , .IND (INV_MULTIPLICAND[25]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[551]) );
   PP_MIDDLE PPM_505 (.INA (OPA[25]) , .INB (INV_MULTIPLICAND[25]) , .INC (OPA[26]) , .IND (INV_MULTIPLICAND[26]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[556]) );
   PP_MIDDLE PPM_506 (.INA (OPA[26]) , .INB (INV_MULTIPLICAND[26]) , .INC (OPA[27]) , .IND (INV_MULTIPLICAND[27]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[560]) );
   PP_MIDDLE PPM_507 (.INA (OPA[27]) , .INB (INV_MULTIPLICAND[27]) , .INC (OPA[28]) , .IND (INV_MULTIPLICAND[28]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[564]) );
   PP_MIDDLE PPM_508 (.INA (OPA[28]) , .INB (INV_MULTIPLICAND[28]) , .INC (OPA[29]) , .IND (INV_MULTIPLICAND[29]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[567]) );
   PP_MIDDLE PPM_509 (.INA (OPA[29]) , .INB (INV_MULTIPLICAND[29]) , .INC (OPA[30]) , .IND (INV_MULTIPLICAND[30]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[570]) );
   PP_MIDDLE PPM_510 (.INA (OPA[30]) , .INB (INV_MULTIPLICAND[30]) , .INC (OPA[31]) , .IND (INV_MULTIPLICAND[31]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[572]) );
   PP_MIDDLE PPM_511 (.INA (OPA[31]) , .INB (INV_MULTIPLICAND[31]) , .INC (OPA[32]) , .IND (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[573]) );
   assign SUMMAND[574] = LOGIC_ONE;
   PP_HIGH PPH_15 (.INA (OPA[32]) , .INB (INV_MULTIPLICAND[32]) , .TWOPOS (INT_MULTIPLIER[60]) , .TWONEG (INT_MULTIPLIER[61]) , .ONEPOS (INT_MULTIPLIER[62]) , .ONENEG (INT_MULTIPLIER[63]) , .PPBIT (SUMMAND[575]) );
endmodule


module FULL_ADDER ( DATA_A, DATA_B, DATA_C, SAVE, CARRY );
   input  DATA_A;
   input  DATA_B;
   input  DATA_C;
   output SAVE;
   output CARRY;
   wire   TMP;
   assign TMP = DATA_A ^ DATA_B;
   assign SAVE = TMP ^ DATA_C;
   assign CARRY =  ~ (( ~ (TMP & DATA_C)) & ( ~ (DATA_A & DATA_B)));
endmodule


module HALF_ADDER ( DATA_A, DATA_B, SAVE, CARRY );
   input  DATA_A;
   input  DATA_B;
   output SAVE;
   output CARRY;
   assign SAVE = DATA_A ^ DATA_B;
   assign CARRY = DATA_A & DATA_B;
endmodule


module FLIPFLOP ( DIN, RST, CLK, DOUT );
   input  DIN;
   input  RST;
   input  CLK;
   output DOUT;
   reg 	  DOUT_reg;
   always @ ( posedge RST or posedge CLK ) begin
      if (RST)
        DOUT_reg <= 1'b0;
      else
        DOUT_reg <=  DIN;
   end
   assign DOUT = DOUT_reg;
endmodule


module WALLACE_33_32 ( SUMMAND, RST, CLK, CARRY, SUM );
   input  [0:575] SUMMAND;
   input 	  RST;
   input 	  CLK;
   output [0:62]  CARRY;
   output [0:63]  SUM;
   wire [0:7] 	  LATCHED_PP;
   wire [0:523]   INT_CARRY;
   wire [0:669]   INT_SUM;
   HALF_ADDER HA_0 (.DATA_A (SUMMAND[0]) , .DATA_B (SUMMAND[1]) , .SAVE (INT_SUM[0]) , .CARRY (INT_CARRY[0]) );
   FLIPFLOP LA_0 (.DIN (INT_SUM[0]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[0]) );
   FLIPFLOP LA_1 (.DIN (INT_CARRY[0]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[0]) );
   assign INT_SUM[1] = SUMMAND[2];
   assign CARRY[1] = 0;
   FLIPFLOP LA_2 (.DIN (INT_SUM[1]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[1]) );
   FULL_ADDER FA_0 (.DATA_A (SUMMAND[3]) , .DATA_B (SUMMAND[4]) , .DATA_C (SUMMAND[5]) , .SAVE (INT_SUM[2]) , .CARRY (INT_CARRY[1]) );
   FLIPFLOP LA_3 (.DIN (INT_SUM[2]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[2]) );
   FLIPFLOP LA_4 (.DIN (INT_CARRY[1]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[2]) );
   HALF_ADDER HA_1 (.DATA_A (SUMMAND[6]) , .DATA_B (SUMMAND[7]) , .SAVE (INT_SUM[3]) , .CARRY (INT_CARRY[2]) );
   FLIPFLOP LA_5 (.DIN (INT_SUM[3]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[3]) );
   FLIPFLOP LA_6 (.DIN (INT_CARRY[2]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[3]) );
   FULL_ADDER FA_1 (.DATA_A (SUMMAND[8]) , .DATA_B (SUMMAND[9]) , .DATA_C (SUMMAND[10]) , .SAVE (INT_SUM[4]) , .CARRY (INT_CARRY[4]) );
   assign INT_SUM[5] = SUMMAND[11];
   HALF_ADDER HA_2 (.DATA_A (INT_SUM[4]) , .DATA_B (INT_SUM[5]) , .SAVE (INT_SUM[6]) , .CARRY (INT_CARRY[3]) );
   FLIPFLOP LA_7 (.DIN (INT_SUM[6]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[4]) );
   FLIPFLOP LA_8 (.DIN (INT_CARRY[3]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[4]) );
   FULL_ADDER FA_2 (.DATA_A (SUMMAND[12]) , .DATA_B (SUMMAND[13]) , .DATA_C (SUMMAND[14]) , .SAVE (INT_SUM[7]) , .CARRY (INT_CARRY[6]) );
   HALF_ADDER HA_3 (.DATA_A (INT_SUM[7]) , .DATA_B (INT_CARRY[4]) , .SAVE (INT_SUM[8]) , .CARRY (INT_CARRY[5]) );
   FLIPFLOP LA_9 (.DIN (INT_SUM[8]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[5]) );
   FLIPFLOP LA_10 (.DIN (INT_CARRY[5]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[5]) );
   FULL_ADDER FA_3 (.DATA_A (SUMMAND[15]) , .DATA_B (SUMMAND[16]) , .DATA_C (SUMMAND[17]) , .SAVE (INT_SUM[9]) , .CARRY (INT_CARRY[8]) );
   HALF_ADDER HA_4 (.DATA_A (SUMMAND[18]) , .DATA_B (SUMMAND[19]) , .SAVE (INT_SUM[10]) , .CARRY (INT_CARRY[9]) );
   FULL_ADDER FA_4 (.DATA_A (INT_SUM[9]) , .DATA_B (INT_SUM[10]) , .DATA_C (INT_CARRY[6]) , .SAVE (INT_SUM[11]) , .CARRY (INT_CARRY[7]) );
   FLIPFLOP LA_11 (.DIN (INT_SUM[11]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[6]) );
   FLIPFLOP LA_12 (.DIN (INT_CARRY[7]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[6]) );
   FULL_ADDER FA_5 (.DATA_A (SUMMAND[20]) , .DATA_B (SUMMAND[21]) , .DATA_C (SUMMAND[22]) , .SAVE (INT_SUM[12]) , .CARRY (INT_CARRY[11]) );
   assign INT_SUM[13] = SUMMAND[23];
   FULL_ADDER FA_6 (.DATA_A (INT_SUM[12]) , .DATA_B (INT_SUM[13]) , .DATA_C (INT_CARRY[8]) , .SAVE (INT_SUM[14]) , .CARRY (INT_CARRY[12]) );
   assign INT_SUM[15] = INT_CARRY[9];
   HALF_ADDER HA_5 (.DATA_A (INT_SUM[14]) , .DATA_B (INT_SUM[15]) , .SAVE (INT_SUM[16]) , .CARRY (INT_CARRY[10]) );
   FLIPFLOP LA_13 (.DIN (INT_SUM[16]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[7]) );
   FLIPFLOP LA_14 (.DIN (INT_CARRY[10]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[7]) );
   FULL_ADDER FA_7 (.DATA_A (SUMMAND[24]) , .DATA_B (SUMMAND[25]) , .DATA_C (SUMMAND[26]) , .SAVE (INT_SUM[17]) , .CARRY (INT_CARRY[14]) );
   FULL_ADDER FA_8 (.DATA_A (SUMMAND[27]) , .DATA_B (SUMMAND[28]) , .DATA_C (SUMMAND[29]) , .SAVE (INT_SUM[18]) , .CARRY (INT_CARRY[15]) );
   FULL_ADDER FA_9 (.DATA_A (INT_SUM[17]) , .DATA_B (INT_SUM[18]) , .DATA_C (INT_CARRY[11]) , .SAVE (INT_SUM[19]) , .CARRY (INT_CARRY[16]) );
   HALF_ADDER HA_6 (.DATA_A (INT_SUM[19]) , .DATA_B (INT_CARRY[12]) , .SAVE (INT_SUM[20]) , .CARRY (INT_CARRY[13]) );
   FLIPFLOP LA_15 (.DIN (INT_SUM[20]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[8]) );
   FLIPFLOP LA_16 (.DIN (INT_CARRY[13]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[8]) );
   FULL_ADDER FA_10 (.DATA_A (SUMMAND[30]) , .DATA_B (SUMMAND[31]) , .DATA_C (SUMMAND[32]) , .SAVE (INT_SUM[21]) , .CARRY (INT_CARRY[18]) );
   HALF_ADDER HA_7 (.DATA_A (SUMMAND[33]) , .DATA_B (SUMMAND[34]) , .SAVE (INT_SUM[22]) , .CARRY (INT_CARRY[19]) );
   FULL_ADDER FA_11 (.DATA_A (INT_SUM[21]) , .DATA_B (INT_SUM[22]) , .DATA_C (INT_CARRY[14]) , .SAVE (INT_SUM[23]) , .CARRY (INT_CARRY[20]) );
   assign INT_SUM[24] = INT_CARRY[15];
   FULL_ADDER FA_12 (.DATA_A (INT_SUM[23]) , .DATA_B (INT_SUM[24]) , .DATA_C (INT_CARRY[16]) , .SAVE (INT_SUM[25]) , .CARRY (INT_CARRY[17]) );
   FLIPFLOP LA_17 (.DIN (INT_SUM[25]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[9]) );
   FLIPFLOP LA_18 (.DIN (INT_CARRY[17]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[9]) );
   FULL_ADDER FA_13 (.DATA_A (SUMMAND[35]) , .DATA_B (SUMMAND[36]) , .DATA_C (SUMMAND[37]) , .SAVE (INT_SUM[26]) , .CARRY (INT_CARRY[22]) );
   FULL_ADDER FA_14 (.DATA_A (SUMMAND[38]) , .DATA_B (SUMMAND[39]) , .DATA_C (SUMMAND[40]) , .SAVE (INT_SUM[27]) , .CARRY (INT_CARRY[23]) );
   assign INT_SUM[28] = SUMMAND[41];
   FULL_ADDER FA_15 (.DATA_A (INT_SUM[26]) , .DATA_B (INT_SUM[27]) , .DATA_C (INT_SUM[28]) , .SAVE (INT_SUM[29]) , .CARRY (INT_CARRY[24]) );
   HALF_ADDER HA_8 (.DATA_A (INT_CARRY[18]) , .DATA_B (INT_CARRY[19]) , .SAVE (INT_SUM[30]) , .CARRY (INT_CARRY[25]) );
   FULL_ADDER FA_16 (.DATA_A (INT_SUM[29]) , .DATA_B (INT_SUM[30]) , .DATA_C (INT_CARRY[20]) , .SAVE (INT_SUM[31]) , .CARRY (INT_CARRY[21]) );
   FLIPFLOP LA_19 (.DIN (INT_SUM[31]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[10]) );
   FLIPFLOP LA_20 (.DIN (INT_CARRY[21]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[10]) );
   FULL_ADDER FA_17 (.DATA_A (SUMMAND[42]) , .DATA_B (SUMMAND[43]) , .DATA_C (SUMMAND[44]) , .SAVE (INT_SUM[32]) , .CARRY (INT_CARRY[27]) );
   FULL_ADDER FA_18 (.DATA_A (SUMMAND[45]) , .DATA_B (SUMMAND[46]) , .DATA_C (SUMMAND[47]) , .SAVE (INT_SUM[33]) , .CARRY (INT_CARRY[28]) );
   FULL_ADDER FA_19 (.DATA_A (INT_SUM[32]) , .DATA_B (INT_SUM[33]) , .DATA_C (INT_CARRY[22]) , .SAVE (INT_SUM[34]) , .CARRY (INT_CARRY[29]) );
   assign INT_SUM[35] = INT_CARRY[23];
   FULL_ADDER FA_20 (.DATA_A (INT_SUM[34]) , .DATA_B (INT_SUM[35]) , .DATA_C (INT_CARRY[24]) , .SAVE (INT_SUM[36]) , .CARRY (INT_CARRY[30]) );
   assign INT_SUM[37] = INT_CARRY[25];
   HALF_ADDER HA_9 (.DATA_A (INT_SUM[36]) , .DATA_B (INT_SUM[37]) , .SAVE (INT_SUM[38]) , .CARRY (INT_CARRY[26]) );
   FLIPFLOP LA_21 (.DIN (INT_SUM[38]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[11]) );
   FLIPFLOP LA_22 (.DIN (INT_CARRY[26]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[11]) );
   FULL_ADDER FA_21 (.DATA_A (SUMMAND[48]) , .DATA_B (SUMMAND[49]) , .DATA_C (SUMMAND[50]) , .SAVE (INT_SUM[39]) , .CARRY (INT_CARRY[32]) );
   FULL_ADDER FA_22 (.DATA_A (SUMMAND[51]) , .DATA_B (SUMMAND[52]) , .DATA_C (SUMMAND[53]) , .SAVE (INT_SUM[40]) , .CARRY (INT_CARRY[33]) );
   assign INT_SUM[41] = SUMMAND[54];
   assign INT_SUM[42] = SUMMAND[55];
   FULL_ADDER FA_23 (.DATA_A (INT_SUM[39]) , .DATA_B (INT_SUM[40]) , .DATA_C (INT_SUM[41]) , .SAVE (INT_SUM[43]) , .CARRY (INT_CARRY[34]) );
   FULL_ADDER FA_24 (.DATA_A (INT_SUM[42]) , .DATA_B (INT_CARRY[27]) , .DATA_C (INT_CARRY[28]) , .SAVE (INT_SUM[44]) , .CARRY (INT_CARRY[35]) );
   FULL_ADDER FA_25 (.DATA_A (INT_SUM[43]) , .DATA_B (INT_SUM[44]) , .DATA_C (INT_CARRY[29]) , .SAVE (INT_SUM[45]) , .CARRY (INT_CARRY[36]) );
   HALF_ADDER HA_10 (.DATA_A (INT_SUM[45]) , .DATA_B (INT_CARRY[30]) , .SAVE (INT_SUM[46]) , .CARRY (INT_CARRY[31]) );
   FLIPFLOP LA_23 (.DIN (INT_SUM[46]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[12]) );
   FLIPFLOP LA_24 (.DIN (INT_CARRY[31]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[12]) );
   FULL_ADDER FA_26 (.DATA_A (SUMMAND[56]) , .DATA_B (SUMMAND[57]) , .DATA_C (SUMMAND[58]) , .SAVE (INT_SUM[47]) , .CARRY (INT_CARRY[38]) );
   FULL_ADDER FA_27 (.DATA_A (SUMMAND[59]) , .DATA_B (SUMMAND[60]) , .DATA_C (SUMMAND[61]) , .SAVE (INT_SUM[48]) , .CARRY (INT_CARRY[39]) );
   assign INT_SUM[49] = SUMMAND[62];
   FULL_ADDER FA_28 (.DATA_A (INT_SUM[47]) , .DATA_B (INT_SUM[48]) , .DATA_C (INT_SUM[49]) , .SAVE (INT_SUM[50]) , .CARRY (INT_CARRY[40]) );
   HALF_ADDER HA_11 (.DATA_A (INT_CARRY[32]) , .DATA_B (INT_CARRY[33]) , .SAVE (INT_SUM[51]) , .CARRY (INT_CARRY[41]) );
   FULL_ADDER FA_29 (.DATA_A (INT_SUM[50]) , .DATA_B (INT_SUM[51]) , .DATA_C (INT_CARRY[34]) , .SAVE (INT_SUM[52]) , .CARRY (INT_CARRY[42]) );
   assign INT_SUM[53] = INT_CARRY[35];
   FULL_ADDER FA_30 (.DATA_A (INT_SUM[52]) , .DATA_B (INT_SUM[53]) , .DATA_C (INT_CARRY[36]) , .SAVE (INT_SUM[54]) , .CARRY (INT_CARRY[37]) );
   FLIPFLOP LA_25 (.DIN (INT_SUM[54]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[13]) );
   FLIPFLOP LA_26 (.DIN (INT_CARRY[37]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[13]) );
   FULL_ADDER FA_31 (.DATA_A (SUMMAND[63]) , .DATA_B (SUMMAND[64]) , .DATA_C (SUMMAND[65]) , .SAVE (INT_SUM[55]) , .CARRY (INT_CARRY[44]) );
   FULL_ADDER FA_32 (.DATA_A (SUMMAND[66]) , .DATA_B (SUMMAND[67]) , .DATA_C (SUMMAND[68]) , .SAVE (INT_SUM[56]) , .CARRY (INT_CARRY[45]) );
   FULL_ADDER FA_33 (.DATA_A (SUMMAND[69]) , .DATA_B (SUMMAND[70]) , .DATA_C (SUMMAND[71]) , .SAVE (INT_SUM[57]) , .CARRY (INT_CARRY[46]) );
   FULL_ADDER FA_34 (.DATA_A (INT_SUM[55]) , .DATA_B (INT_SUM[56]) , .DATA_C (INT_SUM[57]) , .SAVE (INT_SUM[58]) , .CARRY (INT_CARRY[47]) );
   HALF_ADDER HA_12 (.DATA_A (INT_CARRY[38]) , .DATA_B (INT_CARRY[39]) , .SAVE (INT_SUM[59]) , .CARRY (INT_CARRY[48]) );
   FULL_ADDER FA_35 (.DATA_A (INT_SUM[58]) , .DATA_B (INT_SUM[59]) , .DATA_C (INT_CARRY[40]) , .SAVE (INT_SUM[60]) , .CARRY (INT_CARRY[49]) );
   assign INT_SUM[61] = INT_CARRY[41];
   FULL_ADDER FA_36 (.DATA_A (INT_SUM[60]) , .DATA_B (INT_SUM[61]) , .DATA_C (INT_CARRY[42]) , .SAVE (INT_SUM[62]) , .CARRY (INT_CARRY[43]) );
   FLIPFLOP LA_27 (.DIN (INT_SUM[62]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[14]) );
   FLIPFLOP LA_28 (.DIN (INT_CARRY[43]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[14]) );
   FULL_ADDER FA_37 (.DATA_A (SUMMAND[72]) , .DATA_B (SUMMAND[73]) , .DATA_C (SUMMAND[74]) , .SAVE (INT_SUM[63]) , .CARRY (INT_CARRY[51]) );
   FULL_ADDER FA_38 (.DATA_A (SUMMAND[75]) , .DATA_B (SUMMAND[76]) , .DATA_C (SUMMAND[77]) , .SAVE (INT_SUM[64]) , .CARRY (INT_CARRY[52]) );
   HALF_ADDER HA_13 (.DATA_A (SUMMAND[78]) , .DATA_B (SUMMAND[79]) , .SAVE (INT_SUM[65]) , .CARRY (INT_CARRY[53]) );
   FULL_ADDER FA_39 (.DATA_A (INT_SUM[63]) , .DATA_B (INT_SUM[64]) , .DATA_C (INT_SUM[65]) , .SAVE (INT_SUM[66]) , .CARRY (INT_CARRY[54]) );
   FULL_ADDER FA_40 (.DATA_A (INT_CARRY[44]) , .DATA_B (INT_CARRY[45]) , .DATA_C (INT_CARRY[46]) , .SAVE (INT_SUM[67]) , .CARRY (INT_CARRY[55]) );
   FULL_ADDER FA_41 (.DATA_A (INT_SUM[66]) , .DATA_B (INT_SUM[67]) , .DATA_C (INT_CARRY[47]) , .SAVE (INT_SUM[68]) , .CARRY (INT_CARRY[56]) );
   assign INT_SUM[69] = INT_CARRY[48];
   FULL_ADDER FA_42 (.DATA_A (INT_SUM[68]) , .DATA_B (INT_SUM[69]) , .DATA_C (INT_CARRY[49]) , .SAVE (INT_SUM[70]) , .CARRY (INT_CARRY[50]) );
   FLIPFLOP LA_29 (.DIN (INT_SUM[70]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[15]) );
   FLIPFLOP LA_30 (.DIN (INT_CARRY[50]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[15]) );
   FULL_ADDER FA_43 (.DATA_A (SUMMAND[80]) , .DATA_B (SUMMAND[81]) , .DATA_C (SUMMAND[82]) , .SAVE (INT_SUM[71]) , .CARRY (INT_CARRY[58]) );
   FULL_ADDER FA_44 (.DATA_A (SUMMAND[83]) , .DATA_B (SUMMAND[84]) , .DATA_C (SUMMAND[85]) , .SAVE (INT_SUM[72]) , .CARRY (INT_CARRY[59]) );
   FULL_ADDER FA_45 (.DATA_A (SUMMAND[86]) , .DATA_B (SUMMAND[87]) , .DATA_C (SUMMAND[88]) , .SAVE (INT_SUM[73]) , .CARRY (INT_CARRY[60]) );
   assign INT_SUM[74] = SUMMAND[89];
   FULL_ADDER FA_46 (.DATA_A (INT_SUM[71]) , .DATA_B (INT_SUM[72]) , .DATA_C (INT_SUM[73]) , .SAVE (INT_SUM[75]) , .CARRY (INT_CARRY[61]) );
   FULL_ADDER FA_47 (.DATA_A (INT_SUM[74]) , .DATA_B (INT_CARRY[51]) , .DATA_C (INT_CARRY[52]) , .SAVE (INT_SUM[76]) , .CARRY (INT_CARRY[62]) );
   assign INT_SUM[77] = INT_CARRY[53];
   FULL_ADDER FA_48 (.DATA_A (INT_SUM[75]) , .DATA_B (INT_SUM[76]) , .DATA_C (INT_SUM[77]) , .SAVE (INT_SUM[78]) , .CARRY (INT_CARRY[63]) );
   HALF_ADDER HA_14 (.DATA_A (INT_CARRY[54]) , .DATA_B (INT_CARRY[55]) , .SAVE (INT_SUM[79]) , .CARRY (INT_CARRY[64]) );
   FULL_ADDER FA_49 (.DATA_A (INT_SUM[78]) , .DATA_B (INT_SUM[79]) , .DATA_C (INT_CARRY[56]) , .SAVE (INT_SUM[80]) , .CARRY (INT_CARRY[57]) );
   FLIPFLOP LA_31 (.DIN (INT_SUM[80]) , .RST(RST), .CLK (CLK) , .DOUT (SUM[16]) );
   FLIPFLOP LA_32 (.DIN (INT_CARRY[57]) , .RST(RST), .CLK (CLK) , .DOUT (CARRY[16]) );
   FULL_ADDER FA_50 (.DATA_A (SUMMAND[90]) , .DATA_B (SUMMAND[91]) , .DATA_C (SUMMAND[92]) , .SAVE (INT_SUM[81]) , .CARRY (INT_CARRY[65]) );
   FULL_ADDER FA_51 (.DATA_A (SUMMAND[93]) , .DATA_B (SUMMAND[94]) , .DATA_C (SUMMAND[95]) , .SAVE (INT_SUM[82]) , .CARRY (INT_CARRY[66]) );
   FULL_ADDER FA_52 (.DATA_A (SUMMAND[96]) , .DATA_B (SUMMAND[97]) , .DATA_C (SUMMAND[98]) , .SAVE (INT_SUM[83]) , .CARRY (INT_CARRY[67]) );
   FULL_ADDER FA_53 (.DATA_A (INT_SUM[81]) , .DATA_B (INT_SUM[82]) , .DATA_C (INT_SUM[83]) , .SAVE (INT_SUM[84]) , .CARRY (INT_CARRY[68]) );
   FULL_ADDER FA_54 (.DATA_A (INT_CARRY[58]) , .DATA_B (INT_CARRY[59]) , .DATA_C (INT_CARRY[60]) , .SAVE (INT_SUM[85]) , .CARRY (INT_CARRY[69]) );
   FULL_ADDER FA_55 (.DATA_A (INT_SUM[84]) , .DATA_B (INT_SUM[85]) , .DATA_C (INT_CARRY[61]) , .SAVE (INT_SUM[86]) , .CARRY (INT_CARRY[70]) );
   assign INT_SUM[87] = INT_CARRY[62];
   FULL_ADDER FA_56 (.DATA_A (INT_SUM[86]) , .DATA_B (INT_SUM[87]) , .DATA_C (INT_CARRY[63]) , .SAVE (INT_SUM[88]) , .CARRY (INT_CARRY[71]) );
   assign INT_SUM[90] = INT_CARRY[64];
   FLIPFLOP LA_33 (.DIN (INT_SUM[88]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[89]) );
   FLIPFLOP LA_34 (.DIN (INT_SUM[90]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[91]) );
   HALF_ADDER HA_15 (.DATA_A (INT_SUM[89]) , .DATA_B (INT_SUM[91]) , .SAVE (SUM[17]) , .CARRY (CARRY[17]) );
   FULL_ADDER FA_57 (.DATA_A (SUMMAND[99]) , .DATA_B (SUMMAND[100]) , .DATA_C (SUMMAND[101]) , .SAVE (INT_SUM[92]) , .CARRY (INT_CARRY[73]) );
   FULL_ADDER FA_58 (.DATA_A (SUMMAND[102]) , .DATA_B (SUMMAND[103]) , .DATA_C (SUMMAND[104]) , .SAVE (INT_SUM[93]) , .CARRY (INT_CARRY[74]) );
   FULL_ADDER FA_59 (.DATA_A (SUMMAND[105]) , .DATA_B (SUMMAND[106]) , .DATA_C (SUMMAND[107]) , .SAVE (INT_SUM[94]) , .CARRY (INT_CARRY[75]) );
   assign INT_SUM[95] = SUMMAND[108];
   assign INT_SUM[96] = SUMMAND[109];
   FULL_ADDER FA_60 (.DATA_A (INT_SUM[92]) , .DATA_B (INT_SUM[93]) , .DATA_C (INT_SUM[94]) , .SAVE (INT_SUM[97]) , .CARRY (INT_CARRY[76]) );
   FULL_ADDER FA_61 (.DATA_A (INT_SUM[95]) , .DATA_B (INT_SUM[96]) , .DATA_C (INT_CARRY[65]) , .SAVE (INT_SUM[98]) , .CARRY (INT_CARRY[77]) );
   assign INT_SUM[99] = INT_CARRY[66];
   assign INT_SUM[100] = INT_CARRY[67];
   FULL_ADDER FA_62 (.DATA_A (INT_SUM[97]) , .DATA_B (INT_SUM[98]) , .DATA_C (INT_SUM[99]) , .SAVE (INT_SUM[101]) , .CARRY (INT_CARRY[78]) );
   FULL_ADDER FA_63 (.DATA_A (INT_SUM[100]) , .DATA_B (INT_CARRY[68]) , .DATA_C (INT_CARRY[69]) , .SAVE (INT_SUM[102]) , .CARRY (INT_CARRY[79]) );
   FULL_ADDER FA_64 (.DATA_A (INT_SUM[101]) , .DATA_B (INT_SUM[102]) , .DATA_C (INT_CARRY[70]) , .SAVE (INT_SUM[103]) , .CARRY (INT_CARRY[80]) );
   FLIPFLOP LA_35 (.DIN (INT_SUM[103]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[104]) );
   FLIPFLOP LA_36 (.DIN (INT_CARRY[71]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[72]) );
   HALF_ADDER HA_16 (.DATA_A (INT_SUM[104]) , .DATA_B (INT_CARRY[72]) , .SAVE (SUM[18]) , .CARRY (CARRY[18]) );
   FULL_ADDER FA_65 (.DATA_A (SUMMAND[110]) , .DATA_B (SUMMAND[111]) , .DATA_C (SUMMAND[112]) , .SAVE (INT_SUM[105]) , .CARRY (INT_CARRY[82]) );
   FULL_ADDER FA_66 (.DATA_A (SUMMAND[113]) , .DATA_B (SUMMAND[114]) , .DATA_C (SUMMAND[115]) , .SAVE (INT_SUM[106]) , .CARRY (INT_CARRY[83]) );
   FULL_ADDER FA_67 (.DATA_A (SUMMAND[116]) , .DATA_B (SUMMAND[117]) , .DATA_C (SUMMAND[118]) , .SAVE (INT_SUM[107]) , .CARRY (INT_CARRY[84]) );
   assign INT_SUM[108] = SUMMAND[119];
   FULL_ADDER FA_68 (.DATA_A (INT_SUM[105]) , .DATA_B (INT_SUM[106]) , .DATA_C (INT_SUM[107]) , .SAVE (INT_SUM[109]) , .CARRY (INT_CARRY[85]) );
   FULL_ADDER FA_69 (.DATA_A (INT_SUM[108]) , .DATA_B (INT_CARRY[73]) , .DATA_C (INT_CARRY[74]) , .SAVE (INT_SUM[110]) , .CARRY (INT_CARRY[86]) );
   assign INT_SUM[111] = INT_CARRY[75];
   FULL_ADDER FA_70 (.DATA_A (INT_SUM[109]) , .DATA_B (INT_SUM[110]) , .DATA_C (INT_SUM[111]) , .SAVE (INT_SUM[112]) , .CARRY (INT_CARRY[87]) );
   HALF_ADDER HA_17 (.DATA_A (INT_CARRY[76]) , .DATA_B (INT_CARRY[77]) , .SAVE (INT_SUM[113]) , .CARRY (INT_CARRY[88]) );
   FULL_ADDER FA_71 (.DATA_A (INT_SUM[112]) , .DATA_B (INT_SUM[113]) , .DATA_C (INT_CARRY[78]) , .SAVE (INT_SUM[114]) , .CARRY (INT_CARRY[89]) );
   assign INT_SUM[116] = INT_CARRY[79];
   FLIPFLOP LA_37 (.DIN (INT_SUM[114]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[115]) );
   FLIPFLOP LA_38 (.DIN (INT_SUM[116]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[117]) );
   FLIPFLOP LA_39 (.DIN (INT_CARRY[80]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[81]) );
   FULL_ADDER FA_72 (.DATA_A (INT_SUM[115]) , .DATA_B (INT_SUM[117]) , .DATA_C (INT_CARRY[81]) , .SAVE (SUM[19]) , .CARRY (CARRY[19]) );
   FULL_ADDER FA_73 (.DATA_A (SUMMAND[120]) , .DATA_B (SUMMAND[121]) , .DATA_C (SUMMAND[122]) , .SAVE (INT_SUM[118]) , .CARRY (INT_CARRY[91]) );
   FULL_ADDER FA_74 (.DATA_A (SUMMAND[123]) , .DATA_B (SUMMAND[124]) , .DATA_C (SUMMAND[125]) , .SAVE (INT_SUM[119]) , .CARRY (INT_CARRY[92]) );
   FULL_ADDER FA_75 (.DATA_A (SUMMAND[126]) , .DATA_B (SUMMAND[127]) , .DATA_C (SUMMAND[128]) , .SAVE (INT_SUM[120]) , .CARRY (INT_CARRY[93]) );
   FULL_ADDER FA_76 (.DATA_A (SUMMAND[129]) , .DATA_B (SUMMAND[130]) , .DATA_C (SUMMAND[131]) , .SAVE (INT_SUM[121]) , .CARRY (INT_CARRY[94]) );
   FULL_ADDER FA_77 (.DATA_A (INT_SUM[118]) , .DATA_B (INT_SUM[119]) , .DATA_C (INT_SUM[120]) , .SAVE (INT_SUM[122]) , .CARRY (INT_CARRY[95]) );
   FULL_ADDER FA_78 (.DATA_A (INT_SUM[121]) , .DATA_B (INT_CARRY[82]) , .DATA_C (INT_CARRY[83]) , .SAVE (INT_SUM[123]) , .CARRY (INT_CARRY[96]) );
   assign INT_SUM[124] = INT_CARRY[84];
   FULL_ADDER FA_79 (.DATA_A (INT_SUM[122]) , .DATA_B (INT_SUM[123]) , .DATA_C (INT_SUM[124]) , .SAVE (INT_SUM[125]) , .CARRY (INT_CARRY[97]) );
   HALF_ADDER HA_18 (.DATA_A (INT_CARRY[85]) , .DATA_B (INT_CARRY[86]) , .SAVE (INT_SUM[126]) , .CARRY (INT_CARRY[98]) );
   FULL_ADDER FA_80 (.DATA_A (INT_SUM[125]) , .DATA_B (INT_SUM[126]) , .DATA_C (INT_CARRY[87]) , .SAVE (INT_SUM[127]) , .CARRY (INT_CARRY[99]) );
   assign INT_SUM[129] = INT_CARRY[88];
   FLIPFLOP LA_40 (.DIN (INT_SUM[127]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[128]) );
   FLIPFLOP LA_41 (.DIN (INT_SUM[129]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[130]) );
   FLIPFLOP LA_42 (.DIN (INT_CARRY[89]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[90]) );
   FULL_ADDER FA_81 (.DATA_A (INT_SUM[128]) , .DATA_B (INT_SUM[130]) , .DATA_C (INT_CARRY[90]) , .SAVE (SUM[20]) , .CARRY (CARRY[20]) );
   FULL_ADDER FA_82 (.DATA_A (SUMMAND[132]) , .DATA_B (SUMMAND[133]) , .DATA_C (SUMMAND[134]) , .SAVE (INT_SUM[131]) , .CARRY (INT_CARRY[101]) );
   FULL_ADDER FA_83 (.DATA_A (SUMMAND[135]) , .DATA_B (SUMMAND[136]) , .DATA_C (SUMMAND[137]) , .SAVE (INT_SUM[132]) , .CARRY (INT_CARRY[102]) );
   FULL_ADDER FA_84 (.DATA_A (SUMMAND[138]) , .DATA_B (SUMMAND[139]) , .DATA_C (SUMMAND[140]) , .SAVE (INT_SUM[133]) , .CARRY (INT_CARRY[103]) );
   assign INT_SUM[134] = SUMMAND[141];
   assign INT_SUM[135] = SUMMAND[142];
   FULL_ADDER FA_85 (.DATA_A (INT_SUM[131]) , .DATA_B (INT_SUM[132]) , .DATA_C (INT_SUM[133]) , .SAVE (INT_SUM[136]) , .CARRY (INT_CARRY[104]) );
   FULL_ADDER FA_86 (.DATA_A (INT_SUM[134]) , .DATA_B (INT_SUM[135]) , .DATA_C (INT_CARRY[91]) , .SAVE (INT_SUM[137]) , .CARRY (INT_CARRY[105]) );
   FULL_ADDER FA_87 (.DATA_A (INT_CARRY[92]) , .DATA_B (INT_CARRY[93]) , .DATA_C (INT_CARRY[94]) , .SAVE (INT_SUM[138]) , .CARRY (INT_CARRY[106]) );
   FULL_ADDER FA_88 (.DATA_A (INT_SUM[136]) , .DATA_B (INT_SUM[137]) , .DATA_C (INT_SUM[138]) , .SAVE (INT_SUM[139]) , .CARRY (INT_CARRY[107]) );
   HALF_ADDER HA_19 (.DATA_A (INT_CARRY[95]) , .DATA_B (INT_CARRY[96]) , .SAVE (INT_SUM[140]) , .CARRY (INT_CARRY[108]) );
   FULL_ADDER FA_89 (.DATA_A (INT_SUM[139]) , .DATA_B (INT_SUM[140]) , .DATA_C (INT_CARRY[97]) , .SAVE (INT_SUM[141]) , .CARRY (INT_CARRY[109]) );
   assign INT_SUM[143] = INT_CARRY[98];
   FLIPFLOP LA_43 (.DIN (INT_SUM[141]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[142]) );
   FLIPFLOP LA_44 (.DIN (INT_SUM[143]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[144]) );
   FLIPFLOP LA_45 (.DIN (INT_CARRY[99]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[100]) );
   FULL_ADDER FA_90 (.DATA_A (INT_SUM[142]) , .DATA_B (INT_SUM[144]) , .DATA_C (INT_CARRY[100]) , .SAVE (SUM[21]) , .CARRY (CARRY[21]) );
   FULL_ADDER FA_91 (.DATA_A (SUMMAND[143]) , .DATA_B (SUMMAND[144]) , .DATA_C (SUMMAND[145]) , .SAVE (INT_SUM[145]) , .CARRY (INT_CARRY[111]) );
   FULL_ADDER FA_92 (.DATA_A (SUMMAND[146]) , .DATA_B (SUMMAND[147]) , .DATA_C (SUMMAND[148]) , .SAVE (INT_SUM[146]) , .CARRY (INT_CARRY[112]) );
   FULL_ADDER FA_93 (.DATA_A (SUMMAND[149]) , .DATA_B (SUMMAND[150]) , .DATA_C (SUMMAND[151]) , .SAVE (INT_SUM[147]) , .CARRY (INT_CARRY[113]) );
   FULL_ADDER FA_94 (.DATA_A (SUMMAND[152]) , .DATA_B (SUMMAND[153]) , .DATA_C (SUMMAND[154]) , .SAVE (INT_SUM[148]) , .CARRY (INT_CARRY[114]) );
   assign INT_SUM[149] = SUMMAND[155];
   FULL_ADDER FA_95 (.DATA_A (INT_SUM[145]) , .DATA_B (INT_SUM[146]) , .DATA_C (INT_SUM[147]) , .SAVE (INT_SUM[150]) , .CARRY (INT_CARRY[115]) );
   FULL_ADDER FA_96 (.DATA_A (INT_SUM[148]) , .DATA_B (INT_SUM[149]) , .DATA_C (INT_CARRY[101]) , .SAVE (INT_SUM[151]) , .CARRY (INT_CARRY[116]) );
   HALF_ADDER HA_20 (.DATA_A (INT_CARRY[102]) , .DATA_B (INT_CARRY[103]) , .SAVE (INT_SUM[152]) , .CARRY (INT_CARRY[117]) );
   FULL_ADDER FA_97 (.DATA_A (INT_SUM[150]) , .DATA_B (INT_SUM[151]) , .DATA_C (INT_SUM[152]) , .SAVE (INT_SUM[153]) , .CARRY (INT_CARRY[118]) );
   FULL_ADDER FA_98 (.DATA_A (INT_CARRY[104]) , .DATA_B (INT_CARRY[105]) , .DATA_C (INT_CARRY[106]) , .SAVE (INT_SUM[154]) , .CARRY (INT_CARRY[119]) );
   FULL_ADDER FA_99 (.DATA_A (INT_SUM[153]) , .DATA_B (INT_SUM[154]) , .DATA_C (INT_CARRY[107]) , .SAVE (INT_SUM[155]) , .CARRY (INT_CARRY[120]) );
   assign INT_SUM[157] = INT_CARRY[108];
   FLIPFLOP LA_46 (.DIN (INT_SUM[155]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[156]) );
   FLIPFLOP LA_47 (.DIN (INT_SUM[157]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[158]) );
   FLIPFLOP LA_48 (.DIN (INT_CARRY[109]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[110]) );
   FULL_ADDER FA_100 (.DATA_A (INT_SUM[156]) , .DATA_B (INT_SUM[158]) , .DATA_C (INT_CARRY[110]) , .SAVE (SUM[22]) , .CARRY (CARRY[22]) );
   FULL_ADDER FA_101 (.DATA_A (SUMMAND[156]) , .DATA_B (SUMMAND[157]) , .DATA_C (SUMMAND[158]) , .SAVE (INT_SUM[159]) , .CARRY (INT_CARRY[122]) );
   FULL_ADDER FA_102 (.DATA_A (SUMMAND[159]) , .DATA_B (SUMMAND[160]) , .DATA_C (SUMMAND[161]) , .SAVE (INT_SUM[160]) , .CARRY (INT_CARRY[123]) );
   FULL_ADDER FA_103 (.DATA_A (SUMMAND[162]) , .DATA_B (SUMMAND[163]) , .DATA_C (SUMMAND[164]) , .SAVE (INT_SUM[161]) , .CARRY (INT_CARRY[124]) );
   FULL_ADDER FA_104 (.DATA_A (SUMMAND[165]) , .DATA_B (SUMMAND[166]) , .DATA_C (SUMMAND[167]) , .SAVE (INT_SUM[162]) , .CARRY (INT_CARRY[125]) );
   FULL_ADDER FA_105 (.DATA_A (INT_SUM[159]) , .DATA_B (INT_SUM[160]) , .DATA_C (INT_SUM[161]) , .SAVE (INT_SUM[163]) , .CARRY (INT_CARRY[126]) );
   FULL_ADDER FA_106 (.DATA_A (INT_SUM[162]) , .DATA_B (INT_CARRY[111]) , .DATA_C (INT_CARRY[112]) , .SAVE (INT_SUM[164]) , .CARRY (INT_CARRY[127]) );
   HALF_ADDER HA_21 (.DATA_A (INT_CARRY[113]) , .DATA_B (INT_CARRY[114]) , .SAVE (INT_SUM[165]) , .CARRY (INT_CARRY[128]) );
   FULL_ADDER FA_107 (.DATA_A (INT_SUM[163]) , .DATA_B (INT_SUM[164]) , .DATA_C (INT_SUM[165]) , .SAVE (INT_SUM[166]) , .CARRY (INT_CARRY[129]) );
   FULL_ADDER FA_108 (.DATA_A (INT_CARRY[115]) , .DATA_B (INT_CARRY[116]) , .DATA_C (INT_CARRY[117]) , .SAVE (INT_SUM[167]) , .CARRY (INT_CARRY[130]) );
   FULL_ADDER FA_109 (.DATA_A (INT_SUM[166]) , .DATA_B (INT_SUM[167]) , .DATA_C (INT_CARRY[118]) , .SAVE (INT_SUM[168]) , .CARRY (INT_CARRY[131]) );
   assign INT_SUM[170] = INT_CARRY[119];
   FLIPFLOP LA_49 (.DIN (INT_SUM[168]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[169]) );
   FLIPFLOP LA_50 (.DIN (INT_SUM[170]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[171]) );
   FLIPFLOP LA_51 (.DIN (INT_CARRY[120]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[121]) );
   FULL_ADDER FA_110 (.DATA_A (INT_SUM[169]) , .DATA_B (INT_SUM[171]) , .DATA_C (INT_CARRY[121]) , .SAVE (SUM[23]) , .CARRY (CARRY[23]) );
   FULL_ADDER FA_111 (.DATA_A (SUMMAND[168]) , .DATA_B (SUMMAND[169]) , .DATA_C (SUMMAND[170]) , .SAVE (INT_SUM[172]) , .CARRY (INT_CARRY[133]) );
   FULL_ADDER FA_112 (.DATA_A (SUMMAND[171]) , .DATA_B (SUMMAND[172]) , .DATA_C (SUMMAND[173]) , .SAVE (INT_SUM[173]) , .CARRY (INT_CARRY[134]) );
   FULL_ADDER FA_113 (.DATA_A (SUMMAND[174]) , .DATA_B (SUMMAND[175]) , .DATA_C (SUMMAND[176]) , .SAVE (INT_SUM[174]) , .CARRY (INT_CARRY[135]) );
   FULL_ADDER FA_114 (.DATA_A (SUMMAND[177]) , .DATA_B (SUMMAND[178]) , .DATA_C (SUMMAND[179]) , .SAVE (INT_SUM[175]) , .CARRY (INT_CARRY[136]) );
   HALF_ADDER HA_22 (.DATA_A (SUMMAND[180]) , .DATA_B (SUMMAND[181]) , .SAVE (INT_SUM[176]) , .CARRY (INT_CARRY[137]) );
   FULL_ADDER FA_115 (.DATA_A (INT_SUM[172]) , .DATA_B (INT_SUM[173]) , .DATA_C (INT_SUM[174]) , .SAVE (INT_SUM[177]) , .CARRY (INT_CARRY[138]) );
   FULL_ADDER FA_116 (.DATA_A (INT_SUM[175]) , .DATA_B (INT_SUM[176]) , .DATA_C (INT_CARRY[122]) , .SAVE (INT_SUM[178]) , .CARRY (INT_CARRY[139]) );
   FULL_ADDER FA_117 (.DATA_A (INT_CARRY[123]) , .DATA_B (INT_CARRY[124]) , .DATA_C (INT_CARRY[125]) , .SAVE (INT_SUM[179]) , .CARRY (INT_CARRY[140]) );
   FULL_ADDER FA_118 (.DATA_A (INT_SUM[177]) , .DATA_B (INT_SUM[178]) , .DATA_C (INT_SUM[179]) , .SAVE (INT_SUM[180]) , .CARRY (INT_CARRY[141]) );
   FULL_ADDER FA_119 (.DATA_A (INT_CARRY[126]) , .DATA_B (INT_CARRY[127]) , .DATA_C (INT_CARRY[128]) , .SAVE (INT_SUM[181]) , .CARRY (INT_CARRY[142]) );
   FULL_ADDER FA_120 (.DATA_A (INT_SUM[180]) , .DATA_B (INT_SUM[181]) , .DATA_C (INT_CARRY[129]) , .SAVE (INT_SUM[182]) , .CARRY (INT_CARRY[143]) );
   assign INT_SUM[184] = INT_CARRY[130];
   FLIPFLOP LA_52 (.DIN (INT_SUM[182]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[183]) );
   FLIPFLOP LA_53 (.DIN (INT_SUM[184]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[185]) );
   FLIPFLOP LA_54 (.DIN (INT_CARRY[131]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[132]) );
   FULL_ADDER FA_121 (.DATA_A (INT_SUM[183]) , .DATA_B (INT_SUM[185]) , .DATA_C (INT_CARRY[132]) , .SAVE (SUM[24]) , .CARRY (CARRY[24]) );
   FULL_ADDER FA_122 (.DATA_A (SUMMAND[182]) , .DATA_B (SUMMAND[183]) , .DATA_C (SUMMAND[184]) , .SAVE (INT_SUM[186]) , .CARRY (INT_CARRY[145]) );
   FULL_ADDER FA_123 (.DATA_A (SUMMAND[185]) , .DATA_B (SUMMAND[186]) , .DATA_C (SUMMAND[187]) , .SAVE (INT_SUM[187]) , .CARRY (INT_CARRY[146]) );
   FULL_ADDER FA_124 (.DATA_A (SUMMAND[188]) , .DATA_B (SUMMAND[189]) , .DATA_C (SUMMAND[190]) , .SAVE (INT_SUM[188]) , .CARRY (INT_CARRY[147]) );
   FULL_ADDER FA_125 (.DATA_A (SUMMAND[191]) , .DATA_B (SUMMAND[192]) , .DATA_C (SUMMAND[193]) , .SAVE (INT_SUM[189]) , .CARRY (INT_CARRY[148]) );
   assign INT_SUM[190] = SUMMAND[194];
   FULL_ADDER FA_126 (.DATA_A (INT_SUM[186]) , .DATA_B (INT_SUM[187]) , .DATA_C (INT_SUM[188]) , .SAVE (INT_SUM[191]) , .CARRY (INT_CARRY[149]) );
   FULL_ADDER FA_127 (.DATA_A (INT_SUM[189]) , .DATA_B (INT_SUM[190]) , .DATA_C (INT_CARRY[133]) , .SAVE (INT_SUM[192]) , .CARRY (INT_CARRY[150]) );
   FULL_ADDER FA_128 (.DATA_A (INT_CARRY[134]) , .DATA_B (INT_CARRY[135]) , .DATA_C (INT_CARRY[136]) , .SAVE (INT_SUM[193]) , .CARRY (INT_CARRY[151]) );
   assign INT_SUM[194] = INT_CARRY[137];
   FULL_ADDER FA_129 (.DATA_A (INT_SUM[191]) , .DATA_B (INT_SUM[192]) , .DATA_C (INT_SUM[193]) , .SAVE (INT_SUM[195]) , .CARRY (INT_CARRY[152]) );
   FULL_ADDER FA_130 (.DATA_A (INT_SUM[194]) , .DATA_B (INT_CARRY[138]) , .DATA_C (INT_CARRY[139]) , .SAVE (INT_SUM[196]) , .CARRY (INT_CARRY[153]) );
   assign INT_SUM[197] = INT_CARRY[140];
   FULL_ADDER FA_131 (.DATA_A (INT_SUM[195]) , .DATA_B (INT_SUM[196]) , .DATA_C (INT_SUM[197]) , .SAVE (INT_SUM[198]) , .CARRY (INT_CARRY[154]) );
   HALF_ADDER HA_23 (.DATA_A (INT_CARRY[141]) , .DATA_B (INT_CARRY[142]) , .SAVE (INT_SUM[200]) , .CARRY (INT_CARRY[156]) );
   FLIPFLOP LA_55 (.DIN (INT_SUM[198]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[199]) );
   FLIPFLOP LA_56 (.DIN (INT_SUM[200]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[201]) );
   FLIPFLOP LA_57 (.DIN (INT_CARRY[143]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[144]) );
   FULL_ADDER FA_132 (.DATA_A (INT_SUM[199]) , .DATA_B (INT_SUM[201]) , .DATA_C (INT_CARRY[144]) , .SAVE (SUM[25]) , .CARRY (CARRY[25]) );
   FULL_ADDER FA_133 (.DATA_A (SUMMAND[195]) , .DATA_B (SUMMAND[196]) , .DATA_C (SUMMAND[197]) , .SAVE (INT_SUM[202]) , .CARRY (INT_CARRY[158]) );
   FULL_ADDER FA_134 (.DATA_A (SUMMAND[198]) , .DATA_B (SUMMAND[199]) , .DATA_C (SUMMAND[200]) , .SAVE (INT_SUM[203]) , .CARRY (INT_CARRY[159]) );
   FULL_ADDER FA_135 (.DATA_A (SUMMAND[201]) , .DATA_B (SUMMAND[202]) , .DATA_C (SUMMAND[203]) , .SAVE (INT_SUM[204]) , .CARRY (INT_CARRY[160]) );
   FULL_ADDER FA_136 (.DATA_A (SUMMAND[204]) , .DATA_B (SUMMAND[205]) , .DATA_C (SUMMAND[206]) , .SAVE (INT_SUM[205]) , .CARRY (INT_CARRY[161]) );
   FULL_ADDER FA_137 (.DATA_A (SUMMAND[207]) , .DATA_B (SUMMAND[208]) , .DATA_C (SUMMAND[209]) , .SAVE (INT_SUM[206]) , .CARRY (INT_CARRY[162]) );
   FULL_ADDER FA_138 (.DATA_A (INT_SUM[202]) , .DATA_B (INT_SUM[203]) , .DATA_C (INT_SUM[204]) , .SAVE (INT_SUM[207]) , .CARRY (INT_CARRY[163]) );
   FULL_ADDER FA_139 (.DATA_A (INT_SUM[205]) , .DATA_B (INT_SUM[206]) , .DATA_C (INT_CARRY[145]) , .SAVE (INT_SUM[208]) , .CARRY (INT_CARRY[164]) );
   FULL_ADDER FA_140 (.DATA_A (INT_CARRY[146]) , .DATA_B (INT_CARRY[147]) , .DATA_C (INT_CARRY[148]) , .SAVE (INT_SUM[209]) , .CARRY (INT_CARRY[165]) );
   FULL_ADDER FA_141 (.DATA_A (INT_SUM[207]) , .DATA_B (INT_SUM[208]) , .DATA_C (INT_SUM[209]) , .SAVE (INT_SUM[210]) , .CARRY (INT_CARRY[166]) );
   FULL_ADDER FA_142 (.DATA_A (INT_CARRY[149]) , .DATA_B (INT_CARRY[150]) , .DATA_C (INT_CARRY[151]) , .SAVE (INT_SUM[211]) , .CARRY (INT_CARRY[167]) );
   FULL_ADDER FA_143 (.DATA_A (INT_SUM[210]) , .DATA_B (INT_SUM[211]) , .DATA_C (INT_CARRY[152]) , .SAVE (INT_SUM[212]) , .CARRY (INT_CARRY[168]) );
   assign INT_SUM[214] = INT_CARRY[153];
   FLIPFLOP LA_58 (.DIN (INT_SUM[212]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[213]) );
   FLIPFLOP LA_59 (.DIN (INT_SUM[214]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[215]) );
   FLIPFLOP LA_60 (.DIN (INT_CARRY[154]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[155]) );
   FULL_ADDER FA_144 (.DATA_A (INT_SUM[213]) , .DATA_B (INT_SUM[215]) , .DATA_C (INT_CARRY[155]) , .SAVE (INT_SUM[216]) , .CARRY (INT_CARRY[170]) );
   FLIPFLOP LA_61 (.DIN (INT_CARRY[156]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[157]) );
   assign INT_SUM[217] = INT_CARRY[157];
   HALF_ADDER HA_24 (.DATA_A (INT_SUM[216]) , .DATA_B (INT_SUM[217]) , .SAVE (SUM[26]) , .CARRY (CARRY[26]) );
   FULL_ADDER FA_145 (.DATA_A (SUMMAND[210]) , .DATA_B (SUMMAND[211]) , .DATA_C (SUMMAND[212]) , .SAVE (INT_SUM[218]) , .CARRY (INT_CARRY[171]) );
   FULL_ADDER FA_146 (.DATA_A (SUMMAND[213]) , .DATA_B (SUMMAND[214]) , .DATA_C (SUMMAND[215]) , .SAVE (INT_SUM[219]) , .CARRY (INT_CARRY[172]) );
   FULL_ADDER FA_147 (.DATA_A (SUMMAND[216]) , .DATA_B (SUMMAND[217]) , .DATA_C (SUMMAND[218]) , .SAVE (INT_SUM[220]) , .CARRY (INT_CARRY[173]) );
   FULL_ADDER FA_148 (.DATA_A (SUMMAND[219]) , .DATA_B (SUMMAND[220]) , .DATA_C (SUMMAND[221]) , .SAVE (INT_SUM[221]) , .CARRY (INT_CARRY[174]) );
   HALF_ADDER HA_25 (.DATA_A (SUMMAND[222]) , .DATA_B (SUMMAND[223]) , .SAVE (INT_SUM[222]) , .CARRY (INT_CARRY[175]) );
   FULL_ADDER FA_149 (.DATA_A (INT_SUM[218]) , .DATA_B (INT_SUM[219]) , .DATA_C (INT_SUM[220]) , .SAVE (INT_SUM[223]) , .CARRY (INT_CARRY[176]) );
   FULL_ADDER FA_150 (.DATA_A (INT_SUM[221]) , .DATA_B (INT_SUM[222]) , .DATA_C (INT_CARRY[158]) , .SAVE (INT_SUM[224]) , .CARRY (INT_CARRY[177]) );
   FULL_ADDER FA_151 (.DATA_A (INT_CARRY[159]) , .DATA_B (INT_CARRY[160]) , .DATA_C (INT_CARRY[161]) , .SAVE (INT_SUM[225]) , .CARRY (INT_CARRY[178]) );
   assign INT_SUM[226] = INT_CARRY[162];
   FULL_ADDER FA_152 (.DATA_A (INT_SUM[223]) , .DATA_B (INT_SUM[224]) , .DATA_C (INT_SUM[225]) , .SAVE (INT_SUM[227]) , .CARRY (INT_CARRY[179]) );
   FULL_ADDER FA_153 (.DATA_A (INT_SUM[226]) , .DATA_B (INT_CARRY[163]) , .DATA_C (INT_CARRY[164]) , .SAVE (INT_SUM[228]) , .CARRY (INT_CARRY[180]) );
   assign INT_SUM[229] = INT_CARRY[165];
   FULL_ADDER FA_154 (.DATA_A (INT_SUM[227]) , .DATA_B (INT_SUM[228]) , .DATA_C (INT_SUM[229]) , .SAVE (INT_SUM[230]) , .CARRY (INT_CARRY[181]) );
   assign INT_SUM[232] = INT_CARRY[166];
   assign INT_SUM[234] = INT_CARRY[167];
   FLIPFLOP LA_62 (.DIN (INT_SUM[230]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[231]) );
   FLIPFLOP LA_63 (.DIN (INT_SUM[232]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[233]) );
   FLIPFLOP LA_64 (.DIN (INT_SUM[234]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[235]) );
   FULL_ADDER FA_155 (.DATA_A (INT_SUM[231]) , .DATA_B (INT_SUM[233]) , .DATA_C (INT_SUM[235]) , .SAVE (INT_SUM[236]) , .CARRY (INT_CARRY[183]) );
   FLIPFLOP LA_65 (.DIN (INT_CARRY[168]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[169]) );
   assign INT_SUM[237] = INT_CARRY[169];
   FULL_ADDER FA_156 (.DATA_A (INT_SUM[236]) , .DATA_B (INT_SUM[237]) , .DATA_C (INT_CARRY[170]) , .SAVE (SUM[27]) , .CARRY (CARRY[27]) );
   FULL_ADDER FA_157 (.DATA_A (SUMMAND[224]) , .DATA_B (SUMMAND[225]) , .DATA_C (SUMMAND[226]) , .SAVE (INT_SUM[238]) , .CARRY (INT_CARRY[184]) );
   FULL_ADDER FA_158 (.DATA_A (SUMMAND[227]) , .DATA_B (SUMMAND[228]) , .DATA_C (SUMMAND[229]) , .SAVE (INT_SUM[239]) , .CARRY (INT_CARRY[185]) );
   FULL_ADDER FA_159 (.DATA_A (SUMMAND[230]) , .DATA_B (SUMMAND[231]) , .DATA_C (SUMMAND[232]) , .SAVE (INT_SUM[240]) , .CARRY (INT_CARRY[186]) );
   FULL_ADDER FA_160 (.DATA_A (SUMMAND[233]) , .DATA_B (SUMMAND[234]) , .DATA_C (SUMMAND[235]) , .SAVE (INT_SUM[241]) , .CARRY (INT_CARRY[187]) );
   FULL_ADDER FA_161 (.DATA_A (SUMMAND[236]) , .DATA_B (SUMMAND[237]) , .DATA_C (SUMMAND[238]) , .SAVE (INT_SUM[242]) , .CARRY (INT_CARRY[188]) );
   assign INT_SUM[243] = SUMMAND[239];
   FULL_ADDER FA_162 (.DATA_A (INT_SUM[238]) , .DATA_B (INT_SUM[239]) , .DATA_C (INT_SUM[240]) , .SAVE (INT_SUM[244]) , .CARRY (INT_CARRY[189]) );
   FULL_ADDER FA_163 (.DATA_A (INT_SUM[241]) , .DATA_B (INT_SUM[242]) , .DATA_C (INT_SUM[243]) , .SAVE (INT_SUM[245]) , .CARRY (INT_CARRY[190]) );
   FULL_ADDER FA_164 (.DATA_A (INT_CARRY[171]) , .DATA_B (INT_CARRY[172]) , .DATA_C (INT_CARRY[173]) , .SAVE (INT_SUM[246]) , .CARRY (INT_CARRY[191]) );
   assign INT_SUM[247] = INT_CARRY[174];
   assign INT_SUM[248] = INT_CARRY[175];
   FULL_ADDER FA_165 (.DATA_A (INT_SUM[244]) , .DATA_B (INT_SUM[245]) , .DATA_C (INT_SUM[246]) , .SAVE (INT_SUM[249]) , .CARRY (INT_CARRY[192]) );
   FULL_ADDER FA_166 (.DATA_A (INT_SUM[247]) , .DATA_B (INT_SUM[248]) , .DATA_C (INT_CARRY[176]) , .SAVE (INT_SUM[250]) , .CARRY (INT_CARRY[193]) );
   assign INT_SUM[251] = INT_CARRY[177];
   assign INT_SUM[252] = INT_CARRY[178];
   FULL_ADDER FA_167 (.DATA_A (INT_SUM[249]) , .DATA_B (INT_SUM[250]) , .DATA_C (INT_SUM[251]) , .SAVE (INT_SUM[253]) , .CARRY (INT_CARRY[194]) );
   FULL_ADDER FA_168 (.DATA_A (INT_SUM[252]) , .DATA_B (INT_CARRY[179]) , .DATA_C (INT_CARRY[180]) , .SAVE (INT_SUM[255]) , .CARRY (INT_CARRY[196]) );
   FLIPFLOP LA_66 (.DIN (INT_SUM[253]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[254]) );
   FLIPFLOP LA_67 (.DIN (INT_SUM[255]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[256]) );
   FLIPFLOP LA_68 (.DIN (INT_CARRY[181]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[182]) );
   FULL_ADDER FA_169 (.DATA_A (INT_SUM[254]) , .DATA_B (INT_SUM[256]) , .DATA_C (INT_CARRY[182]) , .SAVE (INT_SUM[257]) , .CARRY (INT_CARRY[198]) );
   HALF_ADDER HA_26 (.DATA_A (INT_SUM[257]) , .DATA_B (INT_CARRY[183]) , .SAVE (SUM[28]) , .CARRY (CARRY[28]) );
   FULL_ADDER FA_170 (.DATA_A (SUMMAND[240]) , .DATA_B (SUMMAND[241]) , .DATA_C (SUMMAND[242]) , .SAVE (INT_SUM[258]) , .CARRY (INT_CARRY[199]) );
   FULL_ADDER FA_171 (.DATA_A (SUMMAND[243]) , .DATA_B (SUMMAND[244]) , .DATA_C (SUMMAND[245]) , .SAVE (INT_SUM[259]) , .CARRY (INT_CARRY[200]) );
   FULL_ADDER FA_172 (.DATA_A (SUMMAND[246]) , .DATA_B (SUMMAND[247]) , .DATA_C (SUMMAND[248]) , .SAVE (INT_SUM[260]) , .CARRY (INT_CARRY[201]) );
   FULL_ADDER FA_173 (.DATA_A (SUMMAND[249]) , .DATA_B (SUMMAND[250]) , .DATA_C (SUMMAND[251]) , .SAVE (INT_SUM[261]) , .CARRY (INT_CARRY[202]) );
   FULL_ADDER FA_174 (.DATA_A (SUMMAND[252]) , .DATA_B (SUMMAND[253]) , .DATA_C (SUMMAND[254]) , .SAVE (INT_SUM[262]) , .CARRY (INT_CARRY[203]) );
   FULL_ADDER FA_175 (.DATA_A (INT_SUM[258]) , .DATA_B (INT_SUM[259]) , .DATA_C (INT_SUM[260]) , .SAVE (INT_SUM[263]) , .CARRY (INT_CARRY[204]) );
   FULL_ADDER FA_176 (.DATA_A (INT_SUM[261]) , .DATA_B (INT_SUM[262]) , .DATA_C (INT_CARRY[184]) , .SAVE (INT_SUM[264]) , .CARRY (INT_CARRY[205]) );
   FULL_ADDER FA_177 (.DATA_A (INT_CARRY[185]) , .DATA_B (INT_CARRY[186]) , .DATA_C (INT_CARRY[187]) , .SAVE (INT_SUM[265]) , .CARRY (INT_CARRY[206]) );
   assign INT_SUM[266] = INT_CARRY[188];
   FULL_ADDER FA_178 (.DATA_A (INT_SUM[263]) , .DATA_B (INT_SUM[264]) , .DATA_C (INT_SUM[265]) , .SAVE (INT_SUM[267]) , .CARRY (INT_CARRY[207]) );
   FULL_ADDER FA_179 (.DATA_A (INT_SUM[266]) , .DATA_B (INT_CARRY[189]) , .DATA_C (INT_CARRY[190]) , .SAVE (INT_SUM[268]) , .CARRY (INT_CARRY[208]) );
   assign INT_SUM[269] = INT_CARRY[191];
   FULL_ADDER FA_180 (.DATA_A (INT_SUM[267]) , .DATA_B (INT_SUM[268]) , .DATA_C (INT_SUM[269]) , .SAVE (INT_SUM[270]) , .CARRY (INT_CARRY[209]) );
   HALF_ADDER HA_27 (.DATA_A (INT_CARRY[192]) , .DATA_B (INT_CARRY[193]) , .SAVE (INT_SUM[272]) , .CARRY (INT_CARRY[211]) );
   FLIPFLOP LA_69 (.DIN (INT_SUM[270]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[271]) );
   FLIPFLOP LA_70 (.DIN (INT_SUM[272]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[273]) );
   FLIPFLOP LA_71 (.DIN (INT_CARRY[194]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[195]) );
   FULL_ADDER FA_181 (.DATA_A (INT_SUM[271]) , .DATA_B (INT_SUM[273]) , .DATA_C (INT_CARRY[195]) , .SAVE (INT_SUM[274]) , .CARRY (INT_CARRY[213]) );
   FLIPFLOP LA_72 (.DIN (INT_CARRY[196]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[197]) );
   assign INT_SUM[275] = INT_CARRY[197];
   FULL_ADDER FA_182 (.DATA_A (INT_SUM[274]) , .DATA_B (INT_SUM[275]) , .DATA_C (INT_CARRY[198]) , .SAVE (SUM[29]) , .CARRY (CARRY[29]) );
   FULL_ADDER FA_183 (.DATA_A (SUMMAND[255]) , .DATA_B (SUMMAND[256]) , .DATA_C (SUMMAND[257]) , .SAVE (INT_SUM[276]) , .CARRY (INT_CARRY[214]) );
   FULL_ADDER FA_184 (.DATA_A (SUMMAND[258]) , .DATA_B (SUMMAND[259]) , .DATA_C (SUMMAND[260]) , .SAVE (INT_SUM[277]) , .CARRY (INT_CARRY[215]) );
   FULL_ADDER FA_185 (.DATA_A (SUMMAND[261]) , .DATA_B (SUMMAND[262]) , .DATA_C (SUMMAND[263]) , .SAVE (INT_SUM[278]) , .CARRY (INT_CARRY[216]) );
   FULL_ADDER FA_186 (.DATA_A (SUMMAND[264]) , .DATA_B (SUMMAND[265]) , .DATA_C (SUMMAND[266]) , .SAVE (INT_SUM[279]) , .CARRY (INT_CARRY[217]) );
   FULL_ADDER FA_187 (.DATA_A (SUMMAND[267]) , .DATA_B (SUMMAND[268]) , .DATA_C (SUMMAND[269]) , .SAVE (INT_SUM[280]) , .CARRY (INT_CARRY[218]) );
   assign INT_SUM[281] = SUMMAND[270];
   assign INT_SUM[282] = SUMMAND[271];
   FULL_ADDER FA_188 (.DATA_A (INT_SUM[276]) , .DATA_B (INT_SUM[277]) , .DATA_C (INT_SUM[278]) , .SAVE (INT_SUM[283]) , .CARRY (INT_CARRY[219]) );
   FULL_ADDER FA_189 (.DATA_A (INT_SUM[279]) , .DATA_B (INT_SUM[280]) , .DATA_C (INT_SUM[281]) , .SAVE (INT_SUM[284]) , .CARRY (INT_CARRY[220]) );
   FULL_ADDER FA_190 (.DATA_A (INT_SUM[282]) , .DATA_B (INT_CARRY[199]) , .DATA_C (INT_CARRY[200]) , .SAVE (INT_SUM[285]) , .CARRY (INT_CARRY[221]) );
   FULL_ADDER FA_191 (.DATA_A (INT_CARRY[201]) , .DATA_B (INT_CARRY[202]) , .DATA_C (INT_CARRY[203]) , .SAVE (INT_SUM[286]) , .CARRY (INT_CARRY[222]) );
   FULL_ADDER FA_192 (.DATA_A (INT_SUM[283]) , .DATA_B (INT_SUM[284]) , .DATA_C (INT_SUM[285]) , .SAVE (INT_SUM[287]) , .CARRY (INT_CARRY[223]) );
   FULL_ADDER FA_193 (.DATA_A (INT_SUM[286]) , .DATA_B (INT_CARRY[204]) , .DATA_C (INT_CARRY[205]) , .SAVE (INT_SUM[288]) , .CARRY (INT_CARRY[224]) );
   assign INT_SUM[289] = INT_CARRY[206];
   FULL_ADDER FA_194 (.DATA_A (INT_SUM[287]) , .DATA_B (INT_SUM[288]) , .DATA_C (INT_SUM[289]) , .SAVE (INT_SUM[290]) , .CARRY (INT_CARRY[225]) );
   HALF_ADDER HA_28 (.DATA_A (INT_CARRY[207]) , .DATA_B (INT_CARRY[208]) , .SAVE (INT_SUM[292]) , .CARRY (INT_CARRY[227]) );
   FLIPFLOP LA_73 (.DIN (INT_SUM[290]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[291]) );
   FLIPFLOP LA_74 (.DIN (INT_SUM[292]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[293]) );
   FLIPFLOP LA_75 (.DIN (INT_CARRY[209]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[210]) );
   FULL_ADDER FA_195 (.DATA_A (INT_SUM[291]) , .DATA_B (INT_SUM[293]) , .DATA_C (INT_CARRY[210]) , .SAVE (INT_SUM[294]) , .CARRY (INT_CARRY[229]) );
   FLIPFLOP LA_76 (.DIN (INT_CARRY[211]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[212]) );
   assign INT_SUM[295] = INT_CARRY[212];
   FULL_ADDER FA_196 (.DATA_A (INT_SUM[294]) , .DATA_B (INT_SUM[295]) , .DATA_C (INT_CARRY[213]) , .SAVE (SUM[30]) , .CARRY (CARRY[30]) );
   FULL_ADDER FA_197 (.DATA_A (SUMMAND[272]) , .DATA_B (SUMMAND[273]) , .DATA_C (SUMMAND[274]) , .SAVE (INT_SUM[296]) , .CARRY (INT_CARRY[230]) );
   FULL_ADDER FA_198 (.DATA_A (SUMMAND[275]) , .DATA_B (SUMMAND[276]) , .DATA_C (SUMMAND[277]) , .SAVE (INT_SUM[297]) , .CARRY (INT_CARRY[231]) );
   FULL_ADDER FA_199 (.DATA_A (SUMMAND[278]) , .DATA_B (SUMMAND[279]) , .DATA_C (SUMMAND[280]) , .SAVE (INT_SUM[298]) , .CARRY (INT_CARRY[232]) );
   FULL_ADDER FA_200 (.DATA_A (SUMMAND[281]) , .DATA_B (SUMMAND[282]) , .DATA_C (SUMMAND[283]) , .SAVE (INT_SUM[299]) , .CARRY (INT_CARRY[233]) );
   FULL_ADDER FA_201 (.DATA_A (SUMMAND[284]) , .DATA_B (SUMMAND[285]) , .DATA_C (SUMMAND[286]) , .SAVE (INT_SUM[300]) , .CARRY (INT_CARRY[234]) );
   assign INT_SUM[301] = SUMMAND[287];
   FULL_ADDER FA_202 (.DATA_A (INT_SUM[296]) , .DATA_B (INT_SUM[297]) , .DATA_C (INT_SUM[298]) , .SAVE (INT_SUM[302]) , .CARRY (INT_CARRY[235]) );
   FULL_ADDER FA_203 (.DATA_A (INT_SUM[299]) , .DATA_B (INT_SUM[300]) , .DATA_C (INT_SUM[301]) , .SAVE (INT_SUM[303]) , .CARRY (INT_CARRY[236]) );
   FULL_ADDER FA_204 (.DATA_A (INT_CARRY[214]) , .DATA_B (INT_CARRY[215]) , .DATA_C (INT_CARRY[216]) , .SAVE (INT_SUM[304]) , .CARRY (INT_CARRY[237]) );
   assign INT_SUM[305] = INT_CARRY[217];
   assign INT_SUM[306] = INT_CARRY[218];
   FULL_ADDER FA_205 (.DATA_A (INT_SUM[302]) , .DATA_B (INT_SUM[303]) , .DATA_C (INT_SUM[304]) , .SAVE (INT_SUM[307]) , .CARRY (INT_CARRY[238]) );
   FULL_ADDER FA_206 (.DATA_A (INT_SUM[305]) , .DATA_B (INT_SUM[306]) , .DATA_C (INT_CARRY[219]) , .SAVE (INT_SUM[308]) , .CARRY (INT_CARRY[239]) );
   FULL_ADDER FA_207 (.DATA_A (INT_CARRY[220]) , .DATA_B (INT_CARRY[221]) , .DATA_C (INT_CARRY[222]) , .SAVE (INT_SUM[309]) , .CARRY (INT_CARRY[240]) );
   FULL_ADDER FA_208 (.DATA_A (INT_SUM[307]) , .DATA_B (INT_SUM[308]) , .DATA_C (INT_SUM[309]) , .SAVE (INT_SUM[310]) , .CARRY (INT_CARRY[241]) );
   HALF_ADDER HA_29 (.DATA_A (INT_CARRY[223]) , .DATA_B (INT_CARRY[224]) , .SAVE (INT_SUM[312]) , .CARRY (INT_CARRY[243]) );
   FLIPFLOP LA_77 (.DIN (INT_SUM[310]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[311]) );
   FLIPFLOP LA_78 (.DIN (INT_SUM[312]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[313]) );
   FLIPFLOP LA_79 (.DIN (INT_CARRY[225]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[226]) );
   FULL_ADDER FA_209 (.DATA_A (INT_SUM[311]) , .DATA_B (INT_SUM[313]) , .DATA_C (INT_CARRY[226]) , .SAVE (INT_SUM[314]) , .CARRY (INT_CARRY[245]) );
   FLIPFLOP LA_80 (.DIN (INT_CARRY[227]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[228]) );
   assign INT_SUM[315] = INT_CARRY[228];
   FULL_ADDER FA_210 (.DATA_A (INT_SUM[314]) , .DATA_B (INT_SUM[315]) , .DATA_C (INT_CARRY[229]) , .SAVE (SUM[31]) , .CARRY (CARRY[31]) );
   FULL_ADDER FA_211 (.DATA_A (SUMMAND[288]) , .DATA_B (SUMMAND[289]) , .DATA_C (SUMMAND[290]) , .SAVE (INT_SUM[316]) , .CARRY (INT_CARRY[246]) );
   FULL_ADDER FA_212 (.DATA_A (SUMMAND[291]) , .DATA_B (SUMMAND[292]) , .DATA_C (SUMMAND[293]) , .SAVE (INT_SUM[317]) , .CARRY (INT_CARRY[247]) );
   FULL_ADDER FA_213 (.DATA_A (SUMMAND[294]) , .DATA_B (SUMMAND[295]) , .DATA_C (SUMMAND[296]) , .SAVE (INT_SUM[318]) , .CARRY (INT_CARRY[248]) );
   FULL_ADDER FA_214 (.DATA_A (SUMMAND[297]) , .DATA_B (SUMMAND[298]) , .DATA_C (SUMMAND[299]) , .SAVE (INT_SUM[319]) , .CARRY (INT_CARRY[249]) );
   FULL_ADDER FA_215 (.DATA_A (SUMMAND[300]) , .DATA_B (SUMMAND[301]) , .DATA_C (SUMMAND[302]) , .SAVE (INT_SUM[320]) , .CARRY (INT_CARRY[250]) );
   assign INT_SUM[321] = SUMMAND[303];
   FULL_ADDER FA_216 (.DATA_A (INT_SUM[316]) , .DATA_B (INT_SUM[317]) , .DATA_C (INT_SUM[318]) , .SAVE (INT_SUM[322]) , .CARRY (INT_CARRY[251]) );
   FULL_ADDER FA_217 (.DATA_A (INT_SUM[319]) , .DATA_B (INT_SUM[320]) , .DATA_C (INT_SUM[321]) , .SAVE (INT_SUM[323]) , .CARRY (INT_CARRY[252]) );
   FULL_ADDER FA_218 (.DATA_A (INT_CARRY[230]) , .DATA_B (INT_CARRY[231]) , .DATA_C (INT_CARRY[232]) , .SAVE (INT_SUM[324]) , .CARRY (INT_CARRY[253]) );
   HALF_ADDER HA_30 (.DATA_A (INT_CARRY[233]) , .DATA_B (INT_CARRY[234]) , .SAVE (INT_SUM[325]) , .CARRY (INT_CARRY[254]) );
   FULL_ADDER FA_219 (.DATA_A (INT_SUM[322]) , .DATA_B (INT_SUM[323]) , .DATA_C (INT_SUM[324]) , .SAVE (INT_SUM[326]) , .CARRY (INT_CARRY[255]) );
   FULL_ADDER FA_220 (.DATA_A (INT_SUM[325]) , .DATA_B (INT_CARRY[235]) , .DATA_C (INT_CARRY[236]) , .SAVE (INT_SUM[327]) , .CARRY (INT_CARRY[256]) );
   assign INT_SUM[328] = INT_CARRY[237];
   FULL_ADDER FA_221 (.DATA_A (INT_SUM[326]) , .DATA_B (INT_SUM[327]) , .DATA_C (INT_SUM[328]) , .SAVE (INT_SUM[329]) , .CARRY (INT_CARRY[257]) );
   FULL_ADDER FA_222 (.DATA_A (INT_CARRY[238]) , .DATA_B (INT_CARRY[239]) , .DATA_C (INT_CARRY[240]) , .SAVE (INT_SUM[331]) , .CARRY (INT_CARRY[259]) );
   FLIPFLOP LA_81 (.DIN (INT_SUM[329]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[330]) );
   FLIPFLOP LA_82 (.DIN (INT_SUM[331]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[332]) );
   FLIPFLOP LA_83 (.DIN (INT_CARRY[241]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[242]) );
   FULL_ADDER FA_223 (.DATA_A (INT_SUM[330]) , .DATA_B (INT_SUM[332]) , .DATA_C (INT_CARRY[242]) , .SAVE (INT_SUM[333]) , .CARRY (INT_CARRY[261]) );
   FLIPFLOP LA_84 (.DIN (INT_CARRY[243]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[244]) );
   assign INT_SUM[334] = INT_CARRY[244];
   FULL_ADDER FA_224 (.DATA_A (INT_SUM[333]) , .DATA_B (INT_SUM[334]) , .DATA_C (INT_CARRY[245]) , .SAVE (SUM[32]) , .CARRY (CARRY[32]) );
   FULL_ADDER FA_225 (.DATA_A (SUMMAND[304]) , .DATA_B (SUMMAND[305]) , .DATA_C (SUMMAND[306]) , .SAVE (INT_SUM[335]) , .CARRY (INT_CARRY[262]) );
   FULL_ADDER FA_226 (.DATA_A (SUMMAND[307]) , .DATA_B (SUMMAND[308]) , .DATA_C (SUMMAND[309]) , .SAVE (INT_SUM[336]) , .CARRY (INT_CARRY[263]) );
   FULL_ADDER FA_227 (.DATA_A (SUMMAND[310]) , .DATA_B (SUMMAND[311]) , .DATA_C (SUMMAND[312]) , .SAVE (INT_SUM[337]) , .CARRY (INT_CARRY[264]) );
   FULL_ADDER FA_228 (.DATA_A (SUMMAND[313]) , .DATA_B (SUMMAND[314]) , .DATA_C (SUMMAND[315]) , .SAVE (INT_SUM[338]) , .CARRY (INT_CARRY[265]) );
   FULL_ADDER FA_229 (.DATA_A (SUMMAND[316]) , .DATA_B (SUMMAND[317]) , .DATA_C (SUMMAND[318]) , .SAVE (INT_SUM[339]) , .CARRY (INT_CARRY[266]) );
   assign INT_SUM[340] = SUMMAND[319];
   assign INT_SUM[341] = SUMMAND[320];
   FULL_ADDER FA_230 (.DATA_A (INT_SUM[335]) , .DATA_B (INT_SUM[336]) , .DATA_C (INT_SUM[337]) , .SAVE (INT_SUM[342]) , .CARRY (INT_CARRY[267]) );
   FULL_ADDER FA_231 (.DATA_A (INT_SUM[338]) , .DATA_B (INT_SUM[339]) , .DATA_C (INT_SUM[340]) , .SAVE (INT_SUM[343]) , .CARRY (INT_CARRY[268]) );
   FULL_ADDER FA_232 (.DATA_A (INT_SUM[341]) , .DATA_B (INT_CARRY[246]) , .DATA_C (INT_CARRY[247]) , .SAVE (INT_SUM[344]) , .CARRY (INT_CARRY[269]) );
   FULL_ADDER FA_233 (.DATA_A (INT_CARRY[248]) , .DATA_B (INT_CARRY[249]) , .DATA_C (INT_CARRY[250]) , .SAVE (INT_SUM[345]) , .CARRY (INT_CARRY[270]) );
   FULL_ADDER FA_234 (.DATA_A (INT_SUM[342]) , .DATA_B (INT_SUM[343]) , .DATA_C (INT_SUM[344]) , .SAVE (INT_SUM[346]) , .CARRY (INT_CARRY[271]) );
   FULL_ADDER FA_235 (.DATA_A (INT_SUM[345]) , .DATA_B (INT_CARRY[251]) , .DATA_C (INT_CARRY[252]) , .SAVE (INT_SUM[347]) , .CARRY (INT_CARRY[272]) );
   assign INT_SUM[348] = INT_CARRY[253];
   assign INT_SUM[349] = INT_CARRY[254];
   FULL_ADDER FA_236 (.DATA_A (INT_SUM[346]) , .DATA_B (INT_SUM[347]) , .DATA_C (INT_SUM[348]) , .SAVE (INT_SUM[350]) , .CARRY (INT_CARRY[273]) );
   FULL_ADDER FA_237 (.DATA_A (INT_SUM[349]) , .DATA_B (INT_CARRY[255]) , .DATA_C (INT_CARRY[256]) , .SAVE (INT_SUM[352]) , .CARRY (INT_CARRY[275]) );
   FLIPFLOP LA_85 (.DIN (INT_SUM[350]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[351]) );
   FLIPFLOP LA_86 (.DIN (INT_SUM[352]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[353]) );
   FLIPFLOP LA_87 (.DIN (INT_CARRY[257]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[258]) );
   FULL_ADDER FA_238 (.DATA_A (INT_SUM[351]) , .DATA_B (INT_SUM[353]) , .DATA_C (INT_CARRY[258]) , .SAVE (INT_SUM[354]) , .CARRY (INT_CARRY[277]) );
   FLIPFLOP LA_88 (.DIN (INT_CARRY[259]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[260]) );
   assign INT_SUM[355] = INT_CARRY[260];
   FULL_ADDER FA_239 (.DATA_A (INT_SUM[354]) , .DATA_B (INT_SUM[355]) , .DATA_C (INT_CARRY[261]) , .SAVE (SUM[33]) , .CARRY (CARRY[33]) );
   FULL_ADDER FA_240 (.DATA_A (SUMMAND[321]) , .DATA_B (SUMMAND[322]) , .DATA_C (SUMMAND[323]) , .SAVE (INT_SUM[356]) , .CARRY (INT_CARRY[278]) );
   FULL_ADDER FA_241 (.DATA_A (SUMMAND[324]) , .DATA_B (SUMMAND[325]) , .DATA_C (SUMMAND[326]) , .SAVE (INT_SUM[357]) , .CARRY (INT_CARRY[279]) );
   FULL_ADDER FA_242 (.DATA_A (SUMMAND[327]) , .DATA_B (SUMMAND[328]) , .DATA_C (SUMMAND[329]) , .SAVE (INT_SUM[358]) , .CARRY (INT_CARRY[280]) );
   FULL_ADDER FA_243 (.DATA_A (SUMMAND[330]) , .DATA_B (SUMMAND[331]) , .DATA_C (SUMMAND[332]) , .SAVE (INT_SUM[359]) , .CARRY (INT_CARRY[281]) );
   FULL_ADDER FA_244 (.DATA_A (SUMMAND[333]) , .DATA_B (SUMMAND[334]) , .DATA_C (SUMMAND[335]) , .SAVE (INT_SUM[360]) , .CARRY (INT_CARRY[282]) );
   assign INT_SUM[361] = SUMMAND[336];
   FULL_ADDER FA_245 (.DATA_A (INT_SUM[356]) , .DATA_B (INT_SUM[357]) , .DATA_C (INT_SUM[358]) , .SAVE (INT_SUM[362]) , .CARRY (INT_CARRY[283]) );
   FULL_ADDER FA_246 (.DATA_A (INT_SUM[359]) , .DATA_B (INT_SUM[360]) , .DATA_C (INT_SUM[361]) , .SAVE (INT_SUM[363]) , .CARRY (INT_CARRY[284]) );
   FULL_ADDER FA_247 (.DATA_A (INT_CARRY[262]) , .DATA_B (INT_CARRY[263]) , .DATA_C (INT_CARRY[264]) , .SAVE (INT_SUM[364]) , .CARRY (INT_CARRY[285]) );
   assign INT_SUM[365] = INT_CARRY[265];
   assign INT_SUM[366] = INT_CARRY[266];
   FULL_ADDER FA_248 (.DATA_A (INT_SUM[362]) , .DATA_B (INT_SUM[363]) , .DATA_C (INT_SUM[364]) , .SAVE (INT_SUM[367]) , .CARRY (INT_CARRY[286]) );
   FULL_ADDER FA_249 (.DATA_A (INT_SUM[365]) , .DATA_B (INT_SUM[366]) , .DATA_C (INT_CARRY[267]) , .SAVE (INT_SUM[368]) , .CARRY (INT_CARRY[287]) );
   FULL_ADDER FA_250 (.DATA_A (INT_CARRY[268]) , .DATA_B (INT_CARRY[269]) , .DATA_C (INT_CARRY[270]) , .SAVE (INT_SUM[369]) , .CARRY (INT_CARRY[288]) );
   FULL_ADDER FA_251 (.DATA_A (INT_SUM[367]) , .DATA_B (INT_SUM[368]) , .DATA_C (INT_SUM[369]) , .SAVE (INT_SUM[370]) , .CARRY (INT_CARRY[289]) );
   HALF_ADDER HA_31 (.DATA_A (INT_CARRY[271]) , .DATA_B (INT_CARRY[272]) , .SAVE (INT_SUM[372]) , .CARRY (INT_CARRY[291]) );
   FLIPFLOP LA_89 (.DIN (INT_SUM[370]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[371]) );
   FLIPFLOP LA_90 (.DIN (INT_SUM[372]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[373]) );
   FLIPFLOP LA_91 (.DIN (INT_CARRY[273]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[274]) );
   FULL_ADDER FA_252 (.DATA_A (INT_SUM[371]) , .DATA_B (INT_SUM[373]) , .DATA_C (INT_CARRY[274]) , .SAVE (INT_SUM[374]) , .CARRY (INT_CARRY[293]) );
   FLIPFLOP LA_92 (.DIN (INT_CARRY[275]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[276]) );
   assign INT_SUM[375] = INT_CARRY[276];
   FULL_ADDER FA_253 (.DATA_A (INT_SUM[374]) , .DATA_B (INT_SUM[375]) , .DATA_C (INT_CARRY[277]) , .SAVE (SUM[34]) , .CARRY (CARRY[34]) );
   FULL_ADDER FA_254 (.DATA_A (SUMMAND[337]) , .DATA_B (SUMMAND[338]) , .DATA_C (SUMMAND[339]) , .SAVE (INT_SUM[376]) , .CARRY (INT_CARRY[294]) );
   FULL_ADDER FA_255 (.DATA_A (SUMMAND[340]) , .DATA_B (SUMMAND[341]) , .DATA_C (SUMMAND[342]) , .SAVE (INT_SUM[377]) , .CARRY (INT_CARRY[295]) );
   FULL_ADDER FA_256 (.DATA_A (SUMMAND[343]) , .DATA_B (SUMMAND[344]) , .DATA_C (SUMMAND[345]) , .SAVE (INT_SUM[378]) , .CARRY (INT_CARRY[296]) );
   FULL_ADDER FA_257 (.DATA_A (SUMMAND[346]) , .DATA_B (SUMMAND[347]) , .DATA_C (SUMMAND[348]) , .SAVE (INT_SUM[379]) , .CARRY (INT_CARRY[297]) );
   FULL_ADDER FA_258 (.DATA_A (SUMMAND[349]) , .DATA_B (SUMMAND[350]) , .DATA_C (SUMMAND[351]) , .SAVE (INT_SUM[380]) , .CARRY (INT_CARRY[298]) );
   FULL_ADDER FA_259 (.DATA_A (INT_SUM[376]) , .DATA_B (INT_SUM[377]) , .DATA_C (INT_SUM[378]) , .SAVE (INT_SUM[381]) , .CARRY (INT_CARRY[299]) );
   FULL_ADDER FA_260 (.DATA_A (INT_SUM[379]) , .DATA_B (INT_SUM[380]) , .DATA_C (INT_CARRY[278]) , .SAVE (INT_SUM[382]) , .CARRY (INT_CARRY[300]) );
   FULL_ADDER FA_261 (.DATA_A (INT_CARRY[279]) , .DATA_B (INT_CARRY[280]) , .DATA_C (INT_CARRY[281]) , .SAVE (INT_SUM[383]) , .CARRY (INT_CARRY[301]) );
   assign INT_SUM[384] = INT_CARRY[282];
   FULL_ADDER FA_262 (.DATA_A (INT_SUM[381]) , .DATA_B (INT_SUM[382]) , .DATA_C (INT_SUM[383]) , .SAVE (INT_SUM[385]) , .CARRY (INT_CARRY[302]) );
   FULL_ADDER FA_263 (.DATA_A (INT_SUM[384]) , .DATA_B (INT_CARRY[283]) , .DATA_C (INT_CARRY[284]) , .SAVE (INT_SUM[386]) , .CARRY (INT_CARRY[303]) );
   assign INT_SUM[387] = INT_CARRY[285];
   FULL_ADDER FA_264 (.DATA_A (INT_SUM[385]) , .DATA_B (INT_SUM[386]) , .DATA_C (INT_SUM[387]) , .SAVE (INT_SUM[388]) , .CARRY (INT_CARRY[304]) );
   FULL_ADDER FA_265 (.DATA_A (INT_CARRY[286]) , .DATA_B (INT_CARRY[287]) , .DATA_C (INT_CARRY[288]) , .SAVE (INT_SUM[390]) , .CARRY (INT_CARRY[306]) );
   FLIPFLOP LA_93 (.DIN (INT_SUM[388]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[389]) );
   FLIPFLOP LA_94 (.DIN (INT_SUM[390]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[391]) );
   FLIPFLOP LA_95 (.DIN (INT_CARRY[289]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[290]) );
   FULL_ADDER FA_266 (.DATA_A (INT_SUM[389]) , .DATA_B (INT_SUM[391]) , .DATA_C (INT_CARRY[290]) , .SAVE (INT_SUM[392]) , .CARRY (INT_CARRY[308]) );
   FLIPFLOP LA_96 (.DIN (INT_CARRY[291]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[292]) );
   assign INT_SUM[393] = INT_CARRY[292];
   FULL_ADDER FA_267 (.DATA_A (INT_SUM[392]) , .DATA_B (INT_SUM[393]) , .DATA_C (INT_CARRY[293]) , .SAVE (SUM[35]) , .CARRY (CARRY[35]) );
   FULL_ADDER FA_268 (.DATA_A (SUMMAND[352]) , .DATA_B (SUMMAND[353]) , .DATA_C (SUMMAND[354]) , .SAVE (INT_SUM[394]) , .CARRY (INT_CARRY[309]) );
   FULL_ADDER FA_269 (.DATA_A (SUMMAND[355]) , .DATA_B (SUMMAND[356]) , .DATA_C (SUMMAND[357]) , .SAVE (INT_SUM[395]) , .CARRY (INT_CARRY[310]) );
   FULL_ADDER FA_270 (.DATA_A (SUMMAND[358]) , .DATA_B (SUMMAND[359]) , .DATA_C (SUMMAND[360]) , .SAVE (INT_SUM[396]) , .CARRY (INT_CARRY[311]) );
   FULL_ADDER FA_271 (.DATA_A (SUMMAND[361]) , .DATA_B (SUMMAND[362]) , .DATA_C (SUMMAND[363]) , .SAVE (INT_SUM[397]) , .CARRY (INT_CARRY[312]) );
   FULL_ADDER FA_272 (.DATA_A (SUMMAND[364]) , .DATA_B (SUMMAND[365]) , .DATA_C (SUMMAND[366]) , .SAVE (INT_SUM[398]) , .CARRY (INT_CARRY[313]) );
   FULL_ADDER FA_273 (.DATA_A (INT_SUM[394]) , .DATA_B (INT_SUM[395]) , .DATA_C (INT_SUM[396]) , .SAVE (INT_SUM[399]) , .CARRY (INT_CARRY[314]) );
   FULL_ADDER FA_274 (.DATA_A (INT_SUM[397]) , .DATA_B (INT_SUM[398]) , .DATA_C (INT_CARRY[294]) , .SAVE (INT_SUM[400]) , .CARRY (INT_CARRY[315]) );
   FULL_ADDER FA_275 (.DATA_A (INT_CARRY[295]) , .DATA_B (INT_CARRY[296]) , .DATA_C (INT_CARRY[297]) , .SAVE (INT_SUM[401]) , .CARRY (INT_CARRY[316]) );
   assign INT_SUM[402] = INT_CARRY[298];
   FULL_ADDER FA_276 (.DATA_A (INT_SUM[399]) , .DATA_B (INT_SUM[400]) , .DATA_C (INT_SUM[401]) , .SAVE (INT_SUM[403]) , .CARRY (INT_CARRY[317]) );
   FULL_ADDER FA_277 (.DATA_A (INT_SUM[402]) , .DATA_B (INT_CARRY[299]) , .DATA_C (INT_CARRY[300]) , .SAVE (INT_SUM[404]) , .CARRY (INT_CARRY[318]) );
   assign INT_SUM[405] = INT_CARRY[301];
   FULL_ADDER FA_278 (.DATA_A (INT_SUM[403]) , .DATA_B (INT_SUM[404]) , .DATA_C (INT_SUM[405]) , .SAVE (INT_SUM[406]) , .CARRY (INT_CARRY[319]) );
   HALF_ADDER HA_32 (.DATA_A (INT_CARRY[302]) , .DATA_B (INT_CARRY[303]) , .SAVE (INT_SUM[408]) , .CARRY (INT_CARRY[321]) );
   FLIPFLOP LA_97 (.DIN (INT_SUM[406]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[407]) );
   FLIPFLOP LA_98 (.DIN (INT_SUM[408]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[409]) );
   FLIPFLOP LA_99 (.DIN (INT_CARRY[304]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[305]) );
   FULL_ADDER FA_279 (.DATA_A (INT_SUM[407]) , .DATA_B (INT_SUM[409]) , .DATA_C (INT_CARRY[305]) , .SAVE (INT_SUM[410]) , .CARRY (INT_CARRY[323]) );
   FLIPFLOP LA_100 (.DIN (INT_CARRY[306]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[307]) );
   assign INT_SUM[411] = INT_CARRY[307];
   FULL_ADDER FA_280 (.DATA_A (INT_SUM[410]) , .DATA_B (INT_SUM[411]) , .DATA_C (INT_CARRY[308]) , .SAVE (SUM[36]) , .CARRY (CARRY[36]) );
   FULL_ADDER FA_281 (.DATA_A (SUMMAND[367]) , .DATA_B (SUMMAND[368]) , .DATA_C (SUMMAND[369]) , .SAVE (INT_SUM[412]) , .CARRY (INT_CARRY[324]) );
   FULL_ADDER FA_282 (.DATA_A (SUMMAND[370]) , .DATA_B (SUMMAND[371]) , .DATA_C (SUMMAND[372]) , .SAVE (INT_SUM[413]) , .CARRY (INT_CARRY[325]) );
   FULL_ADDER FA_283 (.DATA_A (SUMMAND[373]) , .DATA_B (SUMMAND[374]) , .DATA_C (SUMMAND[375]) , .SAVE (INT_SUM[414]) , .CARRY (INT_CARRY[326]) );
   FULL_ADDER FA_284 (.DATA_A (SUMMAND[376]) , .DATA_B (SUMMAND[377]) , .DATA_C (SUMMAND[378]) , .SAVE (INT_SUM[415]) , .CARRY (INT_CARRY[327]) );
   HALF_ADDER HA_33 (.DATA_A (SUMMAND[379]) , .DATA_B (SUMMAND[380]) , .SAVE (INT_SUM[416]) , .CARRY (INT_CARRY[328]) );
   FULL_ADDER FA_285 (.DATA_A (INT_SUM[412]) , .DATA_B (INT_SUM[413]) , .DATA_C (INT_SUM[414]) , .SAVE (INT_SUM[417]) , .CARRY (INT_CARRY[329]) );
   FULL_ADDER FA_286 (.DATA_A (INT_SUM[415]) , .DATA_B (INT_SUM[416]) , .DATA_C (INT_CARRY[309]) , .SAVE (INT_SUM[418]) , .CARRY (INT_CARRY[330]) );
   FULL_ADDER FA_287 (.DATA_A (INT_CARRY[310]) , .DATA_B (INT_CARRY[311]) , .DATA_C (INT_CARRY[312]) , .SAVE (INT_SUM[419]) , .CARRY (INT_CARRY[331]) );
   assign INT_SUM[420] = INT_CARRY[313];
   FULL_ADDER FA_288 (.DATA_A (INT_SUM[417]) , .DATA_B (INT_SUM[418]) , .DATA_C (INT_SUM[419]) , .SAVE (INT_SUM[421]) , .CARRY (INT_CARRY[332]) );
   FULL_ADDER FA_289 (.DATA_A (INT_SUM[420]) , .DATA_B (INT_CARRY[314]) , .DATA_C (INT_CARRY[315]) , .SAVE (INT_SUM[422]) , .CARRY (INT_CARRY[333]) );
   assign INT_SUM[423] = INT_CARRY[316];
   FULL_ADDER FA_290 (.DATA_A (INT_SUM[421]) , .DATA_B (INT_SUM[422]) , .DATA_C (INT_SUM[423]) , .SAVE (INT_SUM[424]) , .CARRY (INT_CARRY[334]) );
   HALF_ADDER HA_34 (.DATA_A (INT_CARRY[317]) , .DATA_B (INT_CARRY[318]) , .SAVE (INT_SUM[426]) , .CARRY (INT_CARRY[336]) );
   FLIPFLOP LA_101 (.DIN (INT_SUM[424]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[425]) );
   FLIPFLOP LA_102 (.DIN (INT_SUM[426]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[427]) );
   FLIPFLOP LA_103 (.DIN (INT_CARRY[319]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[320]) );
   FULL_ADDER FA_291 (.DATA_A (INT_SUM[425]) , .DATA_B (INT_SUM[427]) , .DATA_C (INT_CARRY[320]) , .SAVE (INT_SUM[428]) , .CARRY (INT_CARRY[338]) );
   FLIPFLOP LA_104 (.DIN (INT_CARRY[321]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[322]) );
   assign INT_SUM[429] = INT_CARRY[322];
   FULL_ADDER FA_292 (.DATA_A (INT_SUM[428]) , .DATA_B (INT_SUM[429]) , .DATA_C (INT_CARRY[323]) , .SAVE (SUM[37]) , .CARRY (CARRY[37]) );
   FULL_ADDER FA_293 (.DATA_A (SUMMAND[381]) , .DATA_B (SUMMAND[382]) , .DATA_C (SUMMAND[383]) , .SAVE (INT_SUM[430]) , .CARRY (INT_CARRY[339]) );
   FULL_ADDER FA_294 (.DATA_A (SUMMAND[384]) , .DATA_B (SUMMAND[385]) , .DATA_C (SUMMAND[386]) , .SAVE (INT_SUM[431]) , .CARRY (INT_CARRY[340]) );
   FULL_ADDER FA_295 (.DATA_A (SUMMAND[387]) , .DATA_B (SUMMAND[388]) , .DATA_C (SUMMAND[389]) , .SAVE (INT_SUM[432]) , .CARRY (INT_CARRY[341]) );
   FULL_ADDER FA_296 (.DATA_A (SUMMAND[390]) , .DATA_B (SUMMAND[391]) , .DATA_C (SUMMAND[392]) , .SAVE (INT_SUM[433]) , .CARRY (INT_CARRY[342]) );
   HALF_ADDER HA_35 (.DATA_A (SUMMAND[393]) , .DATA_B (SUMMAND[394]) , .SAVE (INT_SUM[434]) , .CARRY (INT_CARRY[343]) );
   FULL_ADDER FA_297 (.DATA_A (INT_SUM[430]) , .DATA_B (INT_SUM[431]) , .DATA_C (INT_SUM[432]) , .SAVE (INT_SUM[435]) , .CARRY (INT_CARRY[344]) );
   FULL_ADDER FA_298 (.DATA_A (INT_SUM[433]) , .DATA_B (INT_SUM[434]) , .DATA_C (INT_CARRY[324]) , .SAVE (INT_SUM[436]) , .CARRY (INT_CARRY[345]) );
   FULL_ADDER FA_299 (.DATA_A (INT_CARRY[325]) , .DATA_B (INT_CARRY[326]) , .DATA_C (INT_CARRY[327]) , .SAVE (INT_SUM[437]) , .CARRY (INT_CARRY[346]) );
   assign INT_SUM[438] = INT_CARRY[328];
   FULL_ADDER FA_300 (.DATA_A (INT_SUM[435]) , .DATA_B (INT_SUM[436]) , .DATA_C (INT_SUM[437]) , .SAVE (INT_SUM[439]) , .CARRY (INT_CARRY[347]) );
   FULL_ADDER FA_301 (.DATA_A (INT_SUM[438]) , .DATA_B (INT_CARRY[329]) , .DATA_C (INT_CARRY[330]) , .SAVE (INT_SUM[440]) , .CARRY (INT_CARRY[348]) );
   assign INT_SUM[441] = INT_CARRY[331];
   FULL_ADDER FA_302 (.DATA_A (INT_SUM[439]) , .DATA_B (INT_SUM[440]) , .DATA_C (INT_SUM[441]) , .SAVE (INT_SUM[442]) , .CARRY (INT_CARRY[349]) );
   HALF_ADDER HA_36 (.DATA_A (INT_CARRY[332]) , .DATA_B (INT_CARRY[333]) , .SAVE (INT_SUM[444]) , .CARRY (INT_CARRY[351]) );
   FLIPFLOP LA_105 (.DIN (INT_SUM[442]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[443]) );
   FLIPFLOP LA_106 (.DIN (INT_SUM[444]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[445]) );
   FLIPFLOP LA_107 (.DIN (INT_CARRY[334]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[335]) );
   FULL_ADDER FA_303 (.DATA_A (INT_SUM[443]) , .DATA_B (INT_SUM[445]) , .DATA_C (INT_CARRY[335]) , .SAVE (INT_SUM[446]) , .CARRY (INT_CARRY[353]) );
   FLIPFLOP LA_108 (.DIN (INT_CARRY[336]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[337]) );
   assign INT_SUM[447] = INT_CARRY[337];
   FULL_ADDER FA_304 (.DATA_A (INT_SUM[446]) , .DATA_B (INT_SUM[447]) , .DATA_C (INT_CARRY[338]) , .SAVE (SUM[38]) , .CARRY (CARRY[38]) );
   FULL_ADDER FA_305 (.DATA_A (SUMMAND[395]) , .DATA_B (SUMMAND[396]) , .DATA_C (SUMMAND[397]) , .SAVE (INT_SUM[448]) , .CARRY (INT_CARRY[354]) );
   FULL_ADDER FA_306 (.DATA_A (SUMMAND[398]) , .DATA_B (SUMMAND[399]) , .DATA_C (SUMMAND[400]) , .SAVE (INT_SUM[449]) , .CARRY (INT_CARRY[355]) );
   FULL_ADDER FA_307 (.DATA_A (SUMMAND[401]) , .DATA_B (SUMMAND[402]) , .DATA_C (SUMMAND[403]) , .SAVE (INT_SUM[450]) , .CARRY (INT_CARRY[356]) );
   FULL_ADDER FA_308 (.DATA_A (SUMMAND[404]) , .DATA_B (SUMMAND[405]) , .DATA_C (SUMMAND[406]) , .SAVE (INT_SUM[451]) , .CARRY (INT_CARRY[357]) );
   assign INT_SUM[452] = SUMMAND[407];
   FULL_ADDER FA_309 (.DATA_A (INT_SUM[448]) , .DATA_B (INT_SUM[449]) , .DATA_C (INT_SUM[450]) , .SAVE (INT_SUM[453]) , .CARRY (INT_CARRY[358]) );
   FULL_ADDER FA_310 (.DATA_A (INT_SUM[451]) , .DATA_B (INT_SUM[452]) , .DATA_C (INT_CARRY[339]) , .SAVE (INT_SUM[454]) , .CARRY (INT_CARRY[359]) );
   FULL_ADDER FA_311 (.DATA_A (INT_CARRY[340]) , .DATA_B (INT_CARRY[341]) , .DATA_C (INT_CARRY[342]) , .SAVE (INT_SUM[455]) , .CARRY (INT_CARRY[360]) );
   assign INT_SUM[456] = INT_CARRY[343];
   FULL_ADDER FA_312 (.DATA_A (INT_SUM[453]) , .DATA_B (INT_SUM[454]) , .DATA_C (INT_SUM[455]) , .SAVE (INT_SUM[457]) , .CARRY (INT_CARRY[361]) );
   FULL_ADDER FA_313 (.DATA_A (INT_SUM[456]) , .DATA_B (INT_CARRY[344]) , .DATA_C (INT_CARRY[345]) , .SAVE (INT_SUM[458]) , .CARRY (INT_CARRY[362]) );
   assign INT_SUM[459] = INT_CARRY[346];
   FULL_ADDER FA_314 (.DATA_A (INT_SUM[457]) , .DATA_B (INT_SUM[458]) , .DATA_C (INT_SUM[459]) , .SAVE (INT_SUM[460]) , .CARRY (INT_CARRY[363]) );
   HALF_ADDER HA_37 (.DATA_A (INT_CARRY[347]) , .DATA_B (INT_CARRY[348]) , .SAVE (INT_SUM[462]) , .CARRY (INT_CARRY[365]) );
   FLIPFLOP LA_109 (.DIN (INT_SUM[460]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[461]) );
   FLIPFLOP LA_110 (.DIN (INT_SUM[462]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[463]) );
   FLIPFLOP LA_111 (.DIN (INT_CARRY[349]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[350]) );
   FULL_ADDER FA_315 (.DATA_A (INT_SUM[461]) , .DATA_B (INT_SUM[463]) , .DATA_C (INT_CARRY[350]) , .SAVE (INT_SUM[464]) , .CARRY (INT_CARRY[367]) );
   FLIPFLOP LA_112 (.DIN (INT_CARRY[351]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[352]) );
   assign INT_SUM[465] = INT_CARRY[352];
   FULL_ADDER FA_316 (.DATA_A (INT_SUM[464]) , .DATA_B (INT_SUM[465]) , .DATA_C (INT_CARRY[353]) , .SAVE (SUM[39]) , .CARRY (CARRY[39]) );
   FULL_ADDER FA_317 (.DATA_A (SUMMAND[408]) , .DATA_B (SUMMAND[409]) , .DATA_C (SUMMAND[410]) , .SAVE (INT_SUM[466]) , .CARRY (INT_CARRY[368]) );
   FULL_ADDER FA_318 (.DATA_A (SUMMAND[411]) , .DATA_B (SUMMAND[412]) , .DATA_C (SUMMAND[413]) , .SAVE (INT_SUM[467]) , .CARRY (INT_CARRY[369]) );
   FULL_ADDER FA_319 (.DATA_A (SUMMAND[414]) , .DATA_B (SUMMAND[415]) , .DATA_C (SUMMAND[416]) , .SAVE (INT_SUM[468]) , .CARRY (INT_CARRY[370]) );
   FULL_ADDER FA_320 (.DATA_A (SUMMAND[417]) , .DATA_B (SUMMAND[418]) , .DATA_C (SUMMAND[419]) , .SAVE (INT_SUM[469]) , .CARRY (INT_CARRY[371]) );
   FULL_ADDER FA_321 (.DATA_A (SUMMAND[420]) , .DATA_B (INT_CARRY[354]) , .DATA_C (INT_CARRY[355]) , .SAVE (INT_SUM[470]) , .CARRY (INT_CARRY[372]) );
   assign INT_SUM[471] = INT_CARRY[356];
   assign INT_SUM[472] = INT_CARRY[357];
   FULL_ADDER FA_322 (.DATA_A (INT_SUM[466]) , .DATA_B (INT_SUM[467]) , .DATA_C (INT_SUM[468]) , .SAVE (INT_SUM[473]) , .CARRY (INT_CARRY[373]) );
   FULL_ADDER FA_323 (.DATA_A (INT_SUM[469]) , .DATA_B (INT_SUM[470]) , .DATA_C (INT_SUM[471]) , .SAVE (INT_SUM[474]) , .CARRY (INT_CARRY[374]) );
   FULL_ADDER FA_324 (.DATA_A (INT_SUM[472]) , .DATA_B (INT_CARRY[358]) , .DATA_C (INT_CARRY[359]) , .SAVE (INT_SUM[475]) , .CARRY (INT_CARRY[375]) );
   assign INT_SUM[476] = INT_CARRY[360];
   FULL_ADDER FA_325 (.DATA_A (INT_SUM[473]) , .DATA_B (INT_SUM[474]) , .DATA_C (INT_SUM[475]) , .SAVE (INT_SUM[477]) , .CARRY (INT_CARRY[376]) );
   FULL_ADDER FA_326 (.DATA_A (INT_SUM[476]) , .DATA_B (INT_CARRY[361]) , .DATA_C (INT_CARRY[362]) , .SAVE (INT_SUM[479]) , .CARRY (INT_CARRY[378]) );
   FLIPFLOP LA_113 (.DIN (INT_SUM[477]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[478]) );
   FLIPFLOP LA_114 (.DIN (INT_SUM[479]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[480]) );
   FLIPFLOP LA_115 (.DIN (INT_CARRY[363]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[364]) );
   FULL_ADDER FA_327 (.DATA_A (INT_SUM[478]) , .DATA_B (INT_SUM[480]) , .DATA_C (INT_CARRY[364]) , .SAVE (INT_SUM[481]) , .CARRY (INT_CARRY[380]) );
   FLIPFLOP LA_116 (.DIN (INT_CARRY[365]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[366]) );
   assign INT_SUM[482] = INT_CARRY[366];
   FULL_ADDER FA_328 (.DATA_A (INT_SUM[481]) , .DATA_B (INT_SUM[482]) , .DATA_C (INT_CARRY[367]) , .SAVE (SUM[40]) , .CARRY (CARRY[40]) );
   FULL_ADDER FA_329 (.DATA_A (SUMMAND[421]) , .DATA_B (SUMMAND[422]) , .DATA_C (SUMMAND[423]) , .SAVE (INT_SUM[483]) , .CARRY (INT_CARRY[381]) );
   FULL_ADDER FA_330 (.DATA_A (SUMMAND[424]) , .DATA_B (SUMMAND[425]) , .DATA_C (SUMMAND[426]) , .SAVE (INT_SUM[484]) , .CARRY (INT_CARRY[382]) );
   FULL_ADDER FA_331 (.DATA_A (SUMMAND[427]) , .DATA_B (SUMMAND[428]) , .DATA_C (SUMMAND[429]) , .SAVE (INT_SUM[485]) , .CARRY (INT_CARRY[383]) );
   FULL_ADDER FA_332 (.DATA_A (SUMMAND[430]) , .DATA_B (SUMMAND[431]) , .DATA_C (SUMMAND[432]) , .SAVE (INT_SUM[486]) , .CARRY (INT_CARRY[384]) );
   FULL_ADDER FA_333 (.DATA_A (INT_SUM[483]) , .DATA_B (INT_SUM[484]) , .DATA_C (INT_SUM[485]) , .SAVE (INT_SUM[487]) , .CARRY (INT_CARRY[385]) );
   FULL_ADDER FA_334 (.DATA_A (INT_SUM[486]) , .DATA_B (INT_CARRY[368]) , .DATA_C (INT_CARRY[369]) , .SAVE (INT_SUM[488]) , .CARRY (INT_CARRY[386]) );
   FULL_ADDER FA_335 (.DATA_A (INT_CARRY[370]) , .DATA_B (INT_CARRY[371]) , .DATA_C (INT_CARRY[372]) , .SAVE (INT_SUM[489]) , .CARRY (INT_CARRY[387]) );
   FULL_ADDER FA_336 (.DATA_A (INT_SUM[487]) , .DATA_B (INT_SUM[488]) , .DATA_C (INT_SUM[489]) , .SAVE (INT_SUM[490]) , .CARRY (INT_CARRY[388]) );
   FULL_ADDER FA_337 (.DATA_A (INT_CARRY[373]) , .DATA_B (INT_CARRY[374]) , .DATA_C (INT_CARRY[375]) , .SAVE (INT_SUM[492]) , .CARRY (INT_CARRY[390]) );
   FLIPFLOP LA_117 (.DIN (INT_SUM[490]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[491]) );
   FLIPFLOP LA_118 (.DIN (INT_SUM[492]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[493]) );
   FLIPFLOP LA_119 (.DIN (INT_CARRY[376]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[377]) );
   FULL_ADDER FA_338 (.DATA_A (INT_SUM[491]) , .DATA_B (INT_SUM[493]) , .DATA_C (INT_CARRY[377]) , .SAVE (INT_SUM[494]) , .CARRY (INT_CARRY[392]) );
   FLIPFLOP LA_120 (.DIN (INT_CARRY[378]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[379]) );
   assign INT_SUM[495] = INT_CARRY[379];
   FULL_ADDER FA_339 (.DATA_A (INT_SUM[494]) , .DATA_B (INT_SUM[495]) , .DATA_C (INT_CARRY[380]) , .SAVE (SUM[41]) , .CARRY (CARRY[41]) );
   FULL_ADDER FA_340 (.DATA_A (SUMMAND[433]) , .DATA_B (SUMMAND[434]) , .DATA_C (SUMMAND[435]) , .SAVE (INT_SUM[496]) , .CARRY (INT_CARRY[393]) );
   FULL_ADDER FA_341 (.DATA_A (SUMMAND[436]) , .DATA_B (SUMMAND[437]) , .DATA_C (SUMMAND[438]) , .SAVE (INT_SUM[497]) , .CARRY (INT_CARRY[394]) );
   FULL_ADDER FA_342 (.DATA_A (SUMMAND[439]) , .DATA_B (SUMMAND[440]) , .DATA_C (SUMMAND[441]) , .SAVE (INT_SUM[498]) , .CARRY (INT_CARRY[395]) );
   FULL_ADDER FA_343 (.DATA_A (SUMMAND[442]) , .DATA_B (SUMMAND[443]) , .DATA_C (SUMMAND[444]) , .SAVE (INT_SUM[499]) , .CARRY (INT_CARRY[396]) );
   FULL_ADDER FA_344 (.DATA_A (INT_SUM[496]) , .DATA_B (INT_SUM[497]) , .DATA_C (INT_SUM[498]) , .SAVE (INT_SUM[500]) , .CARRY (INT_CARRY[397]) );
   FULL_ADDER FA_345 (.DATA_A (INT_SUM[499]) , .DATA_B (INT_CARRY[381]) , .DATA_C (INT_CARRY[382]) , .SAVE (INT_SUM[501]) , .CARRY (INT_CARRY[398]) );
   HALF_ADDER HA_38 (.DATA_A (INT_CARRY[383]) , .DATA_B (INT_CARRY[384]) , .SAVE (INT_SUM[502]) , .CARRY (INT_CARRY[399]) );
   FULL_ADDER FA_346 (.DATA_A (INT_SUM[500]) , .DATA_B (INT_SUM[501]) , .DATA_C (INT_SUM[502]) , .SAVE (INT_SUM[503]) , .CARRY (INT_CARRY[400]) );
   FULL_ADDER FA_347 (.DATA_A (INT_CARRY[385]) , .DATA_B (INT_CARRY[386]) , .DATA_C (INT_CARRY[387]) , .SAVE (INT_SUM[505]) , .CARRY (INT_CARRY[402]) );
   FLIPFLOP LA_121 (.DIN (INT_SUM[503]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[504]) );
   FLIPFLOP LA_122 (.DIN (INT_SUM[505]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[506]) );
   FLIPFLOP LA_123 (.DIN (INT_CARRY[388]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[389]) );
   FULL_ADDER FA_348 (.DATA_A (INT_SUM[504]) , .DATA_B (INT_SUM[506]) , .DATA_C (INT_CARRY[389]) , .SAVE (INT_SUM[507]) , .CARRY (INT_CARRY[404]) );
   FLIPFLOP LA_124 (.DIN (INT_CARRY[390]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[391]) );
   assign INT_SUM[508] = INT_CARRY[391];
   FULL_ADDER FA_349 (.DATA_A (INT_SUM[507]) , .DATA_B (INT_SUM[508]) , .DATA_C (INT_CARRY[392]) , .SAVE (SUM[42]) , .CARRY (CARRY[42]) );
   FULL_ADDER FA_350 (.DATA_A (SUMMAND[445]) , .DATA_B (SUMMAND[446]) , .DATA_C (SUMMAND[447]) , .SAVE (INT_SUM[509]) , .CARRY (INT_CARRY[405]) );
   FULL_ADDER FA_351 (.DATA_A (SUMMAND[448]) , .DATA_B (SUMMAND[449]) , .DATA_C (SUMMAND[450]) , .SAVE (INT_SUM[510]) , .CARRY (INT_CARRY[406]) );
   FULL_ADDER FA_352 (.DATA_A (SUMMAND[451]) , .DATA_B (SUMMAND[452]) , .DATA_C (SUMMAND[453]) , .SAVE (INT_SUM[511]) , .CARRY (INT_CARRY[407]) );
   assign INT_SUM[512] = SUMMAND[454];
   assign INT_SUM[513] = SUMMAND[455];
   FULL_ADDER FA_353 (.DATA_A (INT_SUM[509]) , .DATA_B (INT_SUM[510]) , .DATA_C (INT_SUM[511]) , .SAVE (INT_SUM[514]) , .CARRY (INT_CARRY[408]) );
   FULL_ADDER FA_354 (.DATA_A (INT_SUM[512]) , .DATA_B (INT_SUM[513]) , .DATA_C (INT_CARRY[393]) , .SAVE (INT_SUM[515]) , .CARRY (INT_CARRY[409]) );
   FULL_ADDER FA_355 (.DATA_A (INT_CARRY[394]) , .DATA_B (INT_CARRY[395]) , .DATA_C (INT_CARRY[396]) , .SAVE (INT_SUM[516]) , .CARRY (INT_CARRY[410]) );
   FULL_ADDER FA_356 (.DATA_A (INT_SUM[514]) , .DATA_B (INT_SUM[515]) , .DATA_C (INT_SUM[516]) , .SAVE (INT_SUM[517]) , .CARRY (INT_CARRY[411]) );
   FULL_ADDER FA_357 (.DATA_A (INT_CARRY[397]) , .DATA_B (INT_CARRY[398]) , .DATA_C (INT_CARRY[399]) , .SAVE (INT_SUM[519]) , .CARRY (INT_CARRY[413]) );
   FLIPFLOP LA_125 (.DIN (INT_SUM[517]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[518]) );
   FLIPFLOP LA_126 (.DIN (INT_SUM[519]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[520]) );
   FLIPFLOP LA_127 (.DIN (INT_CARRY[400]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[401]) );
   FULL_ADDER FA_358 (.DATA_A (INT_SUM[518]) , .DATA_B (INT_SUM[520]) , .DATA_C (INT_CARRY[401]) , .SAVE (INT_SUM[521]) , .CARRY (INT_CARRY[415]) );
   FLIPFLOP LA_128 (.DIN (INT_CARRY[402]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[403]) );
   assign INT_SUM[522] = INT_CARRY[403];
   FULL_ADDER FA_359 (.DATA_A (INT_SUM[521]) , .DATA_B (INT_SUM[522]) , .DATA_C (INT_CARRY[404]) , .SAVE (SUM[43]) , .CARRY (CARRY[43]) );
   FULL_ADDER FA_360 (.DATA_A (SUMMAND[456]) , .DATA_B (SUMMAND[457]) , .DATA_C (SUMMAND[458]) , .SAVE (INT_SUM[523]) , .CARRY (INT_CARRY[416]) );
   FULL_ADDER FA_361 (.DATA_A (SUMMAND[459]) , .DATA_B (SUMMAND[460]) , .DATA_C (SUMMAND[461]) , .SAVE (INT_SUM[524]) , .CARRY (INT_CARRY[417]) );
   FULL_ADDER FA_362 (.DATA_A (SUMMAND[462]) , .DATA_B (SUMMAND[463]) , .DATA_C (SUMMAND[464]) , .SAVE (INT_SUM[525]) , .CARRY (INT_CARRY[418]) );
   HALF_ADDER HA_39 (.DATA_A (SUMMAND[465]) , .DATA_B (SUMMAND[466]) , .SAVE (INT_SUM[526]) , .CARRY (INT_CARRY[419]) );
   FULL_ADDER FA_363 (.DATA_A (INT_SUM[523]) , .DATA_B (INT_SUM[524]) , .DATA_C (INT_SUM[525]) , .SAVE (INT_SUM[527]) , .CARRY (INT_CARRY[420]) );
   FULL_ADDER FA_364 (.DATA_A (INT_SUM[526]) , .DATA_B (INT_CARRY[405]) , .DATA_C (INT_CARRY[406]) , .SAVE (INT_SUM[528]) , .CARRY (INT_CARRY[421]) );
   assign INT_SUM[529] = INT_CARRY[407];
   FULL_ADDER FA_365 (.DATA_A (INT_SUM[527]) , .DATA_B (INT_SUM[528]) , .DATA_C (INT_SUM[529]) , .SAVE (INT_SUM[530]) , .CARRY (INT_CARRY[422]) );
   FULL_ADDER FA_366 (.DATA_A (INT_CARRY[408]) , .DATA_B (INT_CARRY[409]) , .DATA_C (INT_CARRY[410]) , .SAVE (INT_SUM[532]) , .CARRY (INT_CARRY[424]) );
   FLIPFLOP LA_129 (.DIN (INT_SUM[530]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[531]) );
   FLIPFLOP LA_130 (.DIN (INT_SUM[532]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[533]) );
   FLIPFLOP LA_131 (.DIN (INT_CARRY[411]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[412]) );
   FULL_ADDER FA_367 (.DATA_A (INT_SUM[531]) , .DATA_B (INT_SUM[533]) , .DATA_C (INT_CARRY[412]) , .SAVE (INT_SUM[534]) , .CARRY (INT_CARRY[426]) );
   FLIPFLOP LA_132 (.DIN (INT_CARRY[413]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[414]) );
   assign INT_SUM[535] = INT_CARRY[414];
   FULL_ADDER FA_368 (.DATA_A (INT_SUM[534]) , .DATA_B (INT_SUM[535]) , .DATA_C (INT_CARRY[415]) , .SAVE (SUM[44]) , .CARRY (CARRY[44]) );
   FULL_ADDER FA_369 (.DATA_A (SUMMAND[467]) , .DATA_B (SUMMAND[468]) , .DATA_C (SUMMAND[469]) , .SAVE (INT_SUM[536]) , .CARRY (INT_CARRY[427]) );
   FULL_ADDER FA_370 (.DATA_A (SUMMAND[470]) , .DATA_B (SUMMAND[471]) , .DATA_C (SUMMAND[472]) , .SAVE (INT_SUM[537]) , .CARRY (INT_CARRY[428]) );
   FULL_ADDER FA_371 (.DATA_A (SUMMAND[473]) , .DATA_B (SUMMAND[474]) , .DATA_C (SUMMAND[475]) , .SAVE (INT_SUM[538]) , .CARRY (INT_CARRY[429]) );
   assign INT_SUM[539] = SUMMAND[476];
   FULL_ADDER FA_372 (.DATA_A (INT_SUM[536]) , .DATA_B (INT_SUM[537]) , .DATA_C (INT_SUM[538]) , .SAVE (INT_SUM[540]) , .CARRY (INT_CARRY[430]) );
   FULL_ADDER FA_373 (.DATA_A (INT_SUM[539]) , .DATA_B (INT_CARRY[416]) , .DATA_C (INT_CARRY[417]) , .SAVE (INT_SUM[541]) , .CARRY (INT_CARRY[431]) );
   assign INT_SUM[542] = INT_CARRY[418];
   assign INT_SUM[543] = INT_CARRY[419];
   FULL_ADDER FA_374 (.DATA_A (INT_SUM[540]) , .DATA_B (INT_SUM[541]) , .DATA_C (INT_SUM[542]) , .SAVE (INT_SUM[544]) , .CARRY (INT_CARRY[432]) );
   FULL_ADDER FA_375 (.DATA_A (INT_SUM[543]) , .DATA_B (INT_CARRY[420]) , .DATA_C (INT_CARRY[421]) , .SAVE (INT_SUM[546]) , .CARRY (INT_CARRY[434]) );
   FLIPFLOP LA_133 (.DIN (INT_SUM[544]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[545]) );
   FLIPFLOP LA_134 (.DIN (INT_SUM[546]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[547]) );
   FLIPFLOP LA_135 (.DIN (INT_CARRY[422]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[423]) );
   FULL_ADDER FA_376 (.DATA_A (INT_SUM[545]) , .DATA_B (INT_SUM[547]) , .DATA_C (INT_CARRY[423]) , .SAVE (INT_SUM[548]) , .CARRY (INT_CARRY[436]) );
   FLIPFLOP LA_136 (.DIN (INT_CARRY[424]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[425]) );
   assign INT_SUM[549] = INT_CARRY[425];
   FULL_ADDER FA_377 (.DATA_A (INT_SUM[548]) , .DATA_B (INT_SUM[549]) , .DATA_C (INT_CARRY[426]) , .SAVE (SUM[45]) , .CARRY (CARRY[45]) );
   FULL_ADDER FA_378 (.DATA_A (SUMMAND[477]) , .DATA_B (SUMMAND[478]) , .DATA_C (SUMMAND[479]) , .SAVE (INT_SUM[550]) , .CARRY (INT_CARRY[437]) );
   FULL_ADDER FA_379 (.DATA_A (SUMMAND[480]) , .DATA_B (SUMMAND[481]) , .DATA_C (SUMMAND[482]) , .SAVE (INT_SUM[551]) , .CARRY (INT_CARRY[438]) );
   FULL_ADDER FA_380 (.DATA_A (SUMMAND[483]) , .DATA_B (SUMMAND[484]) , .DATA_C (SUMMAND[485]) , .SAVE (INT_SUM[552]) , .CARRY (INT_CARRY[439]) );
   assign INT_SUM[553] = SUMMAND[486];
   FULL_ADDER FA_381 (.DATA_A (INT_SUM[550]) , .DATA_B (INT_SUM[551]) , .DATA_C (INT_SUM[552]) , .SAVE (INT_SUM[554]) , .CARRY (INT_CARRY[440]) );
   FULL_ADDER FA_382 (.DATA_A (INT_SUM[553]) , .DATA_B (INT_CARRY[427]) , .DATA_C (INT_CARRY[428]) , .SAVE (INT_SUM[555]) , .CARRY (INT_CARRY[441]) );
   assign INT_SUM[556] = INT_CARRY[429];
   FULL_ADDER FA_383 (.DATA_A (INT_SUM[554]) , .DATA_B (INT_SUM[555]) , .DATA_C (INT_SUM[556]) , .SAVE (INT_SUM[557]) , .CARRY (INT_CARRY[442]) );
   HALF_ADDER HA_40 (.DATA_A (INT_CARRY[430]) , .DATA_B (INT_CARRY[431]) , .SAVE (INT_SUM[559]) , .CARRY (INT_CARRY[444]) );
   FLIPFLOP LA_137 (.DIN (INT_SUM[557]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[558]) );
   FLIPFLOP LA_138 (.DIN (INT_SUM[559]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[560]) );
   FLIPFLOP LA_139 (.DIN (INT_CARRY[432]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[433]) );
   FULL_ADDER FA_384 (.DATA_A (INT_SUM[558]) , .DATA_B (INT_SUM[560]) , .DATA_C (INT_CARRY[433]) , .SAVE (INT_SUM[561]) , .CARRY (INT_CARRY[446]) );
   FLIPFLOP LA_140 (.DIN (INT_CARRY[434]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[435]) );
   assign INT_SUM[562] = INT_CARRY[435];
   FULL_ADDER FA_385 (.DATA_A (INT_SUM[561]) , .DATA_B (INT_SUM[562]) , .DATA_C (INT_CARRY[436]) , .SAVE (SUM[46]) , .CARRY (CARRY[46]) );
   FULL_ADDER FA_386 (.DATA_A (SUMMAND[487]) , .DATA_B (SUMMAND[488]) , .DATA_C (SUMMAND[489]) , .SAVE (INT_SUM[563]) , .CARRY (INT_CARRY[447]) );
   FULL_ADDER FA_387 (.DATA_A (SUMMAND[490]) , .DATA_B (SUMMAND[491]) , .DATA_C (SUMMAND[492]) , .SAVE (INT_SUM[564]) , .CARRY (INT_CARRY[448]) );
   FULL_ADDER FA_388 (.DATA_A (SUMMAND[493]) , .DATA_B (SUMMAND[494]) , .DATA_C (SUMMAND[495]) , .SAVE (INT_SUM[565]) , .CARRY (INT_CARRY[449]) );
   FULL_ADDER FA_389 (.DATA_A (INT_SUM[563]) , .DATA_B (INT_SUM[564]) , .DATA_C (INT_SUM[565]) , .SAVE (INT_SUM[566]) , .CARRY (INT_CARRY[450]) );
   FULL_ADDER FA_390 (.DATA_A (INT_CARRY[437]) , .DATA_B (INT_CARRY[438]) , .DATA_C (INT_CARRY[439]) , .SAVE (INT_SUM[567]) , .CARRY (INT_CARRY[451]) );
   FULL_ADDER FA_391 (.DATA_A (INT_SUM[566]) , .DATA_B (INT_SUM[567]) , .DATA_C (INT_CARRY[440]) , .SAVE (INT_SUM[568]) , .CARRY (INT_CARRY[452]) );
   assign INT_SUM[570] = INT_CARRY[441];
   FLIPFLOP LA_141 (.DIN (INT_SUM[568]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[569]) );
   FLIPFLOP LA_142 (.DIN (INT_SUM[570]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[571]) );
   FLIPFLOP LA_143 (.DIN (INT_CARRY[442]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[443]) );
   FULL_ADDER FA_392 (.DATA_A (INT_SUM[569]) , .DATA_B (INT_SUM[571]) , .DATA_C (INT_CARRY[443]) , .SAVE (INT_SUM[572]) , .CARRY (INT_CARRY[454]) );
   FLIPFLOP LA_144 (.DIN (INT_CARRY[444]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[445]) );
   assign INT_SUM[573] = INT_CARRY[445];
   FULL_ADDER FA_393 (.DATA_A (INT_SUM[572]) , .DATA_B (INT_SUM[573]) , .DATA_C (INT_CARRY[446]) , .SAVE (SUM[47]) , .CARRY (CARRY[47]) );
   FULL_ADDER FA_394 (.DATA_A (SUMMAND[496]) , .DATA_B (SUMMAND[497]) , .DATA_C (SUMMAND[498]) , .SAVE (INT_SUM[574]) , .CARRY (INT_CARRY[455]) );
   FULL_ADDER FA_395 (.DATA_A (SUMMAND[499]) , .DATA_B (SUMMAND[500]) , .DATA_C (SUMMAND[501]) , .SAVE (INT_SUM[575]) , .CARRY (INT_CARRY[456]) );
   FULL_ADDER FA_396 (.DATA_A (SUMMAND[502]) , .DATA_B (SUMMAND[503]) , .DATA_C (SUMMAND[504]) , .SAVE (INT_SUM[576]) , .CARRY (INT_CARRY[457]) );
   FULL_ADDER FA_397 (.DATA_A (INT_SUM[574]) , .DATA_B (INT_SUM[575]) , .DATA_C (INT_SUM[576]) , .SAVE (INT_SUM[577]) , .CARRY (INT_CARRY[458]) );
   FULL_ADDER FA_398 (.DATA_A (INT_CARRY[447]) , .DATA_B (INT_CARRY[448]) , .DATA_C (INT_CARRY[449]) , .SAVE (INT_SUM[578]) , .CARRY (INT_CARRY[459]) );
   FULL_ADDER FA_399 (.DATA_A (INT_SUM[577]) , .DATA_B (INT_SUM[578]) , .DATA_C (INT_CARRY[450]) , .SAVE (INT_SUM[579]) , .CARRY (INT_CARRY[460]) );
   assign INT_SUM[581] = INT_CARRY[451];
   FLIPFLOP LA_145 (.DIN (INT_SUM[579]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[580]) );
   FLIPFLOP LA_146 (.DIN (INT_SUM[581]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[582]) );
   FLIPFLOP LA_147 (.DIN (INT_CARRY[452]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[453]) );
   FULL_ADDER FA_400 (.DATA_A (INT_SUM[580]) , .DATA_B (INT_SUM[582]) , .DATA_C (INT_CARRY[453]) , .SAVE (INT_SUM[583]) , .CARRY (INT_CARRY[462]) );
   HALF_ADDER HA_41 (.DATA_A (INT_SUM[583]) , .DATA_B (INT_CARRY[454]) , .SAVE (SUM[48]) , .CARRY (CARRY[48]) );
   FULL_ADDER FA_401 (.DATA_A (SUMMAND[505]) , .DATA_B (SUMMAND[506]) , .DATA_C (SUMMAND[507]) , .SAVE (INT_SUM[584]) , .CARRY (INT_CARRY[463]) );
   FULL_ADDER FA_402 (.DATA_A (SUMMAND[508]) , .DATA_B (SUMMAND[509]) , .DATA_C (SUMMAND[510]) , .SAVE (INT_SUM[585]) , .CARRY (INT_CARRY[464]) );
   FULL_ADDER FA_403 (.DATA_A (SUMMAND[511]) , .DATA_B (SUMMAND[512]) , .DATA_C (INT_CARRY[455]) , .SAVE (INT_SUM[586]) , .CARRY (INT_CARRY[465]) );
   HALF_ADDER HA_42 (.DATA_A (INT_CARRY[456]) , .DATA_B (INT_CARRY[457]) , .SAVE (INT_SUM[587]) , .CARRY (INT_CARRY[466]) );
   FULL_ADDER FA_404 (.DATA_A (INT_SUM[584]) , .DATA_B (INT_SUM[585]) , .DATA_C (INT_SUM[586]) , .SAVE (INT_SUM[588]) , .CARRY (INT_CARRY[467]) );
   FULL_ADDER FA_405 (.DATA_A (INT_SUM[587]) , .DATA_B (INT_CARRY[458]) , .DATA_C (INT_CARRY[459]) , .SAVE (INT_SUM[590]) , .CARRY (INT_CARRY[469]) );
   FLIPFLOP LA_148 (.DIN (INT_SUM[588]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[589]) );
   FLIPFLOP LA_149 (.DIN (INT_SUM[590]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[591]) );
   FLIPFLOP LA_150 (.DIN (INT_CARRY[460]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[461]) );
   FULL_ADDER FA_406 (.DATA_A (INT_SUM[589]) , .DATA_B (INT_SUM[591]) , .DATA_C (INT_CARRY[461]) , .SAVE (INT_SUM[592]) , .CARRY (INT_CARRY[471]) );
   HALF_ADDER HA_43 (.DATA_A (INT_SUM[592]) , .DATA_B (INT_CARRY[462]) , .SAVE (SUM[49]) , .CARRY (CARRY[49]) );
   FULL_ADDER FA_407 (.DATA_A (SUMMAND[513]) , .DATA_B (SUMMAND[514]) , .DATA_C (SUMMAND[515]) , .SAVE (INT_SUM[593]) , .CARRY (INT_CARRY[472]) );
   FULL_ADDER FA_408 (.DATA_A (SUMMAND[516]) , .DATA_B (SUMMAND[517]) , .DATA_C (SUMMAND[518]) , .SAVE (INT_SUM[594]) , .CARRY (INT_CARRY[473]) );
   assign INT_SUM[595] = SUMMAND[519];
   assign INT_SUM[596] = SUMMAND[520];
   FULL_ADDER FA_409 (.DATA_A (INT_SUM[593]) , .DATA_B (INT_SUM[594]) , .DATA_C (INT_SUM[595]) , .SAVE (INT_SUM[597]) , .CARRY (INT_CARRY[474]) );
   assign INT_SUM[598] = INT_SUM[596];
   FULL_ADDER FA_410 (.DATA_A (INT_SUM[597]) , .DATA_B (INT_SUM[598]) , .DATA_C (INT_CARRY[463]) , .SAVE (INT_SUM[599]) , .CARRY (INT_CARRY[475]) );
   FULL_ADDER FA_411 (.DATA_A (INT_CARRY[464]) , .DATA_B (INT_CARRY[465]) , .DATA_C (INT_CARRY[466]) , .SAVE (INT_SUM[601]) , .CARRY (INT_CARRY[477]) );
   FLIPFLOP LA_151 (.DIN (INT_SUM[599]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[600]) );
   FLIPFLOP LA_152 (.DIN (INT_SUM[601]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[602]) );
   FLIPFLOP LA_153 (.DIN (INT_CARRY[467]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[468]) );
   FULL_ADDER FA_412 (.DATA_A (INT_SUM[600]) , .DATA_B (INT_SUM[602]) , .DATA_C (INT_CARRY[468]) , .SAVE (INT_SUM[603]) , .CARRY (INT_CARRY[479]) );
   FLIPFLOP LA_154 (.DIN (INT_CARRY[469]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[470]) );
   assign INT_SUM[604] = INT_CARRY[470];
   FULL_ADDER FA_413 (.DATA_A (INT_SUM[603]) , .DATA_B (INT_SUM[604]) , .DATA_C (INT_CARRY[471]) , .SAVE (SUM[50]) , .CARRY (CARRY[50]) );
   FULL_ADDER FA_414 (.DATA_A (SUMMAND[521]) , .DATA_B (SUMMAND[522]) , .DATA_C (SUMMAND[523]) , .SAVE (INT_SUM[605]) , .CARRY (INT_CARRY[480]) );
   FULL_ADDER FA_415 (.DATA_A (SUMMAND[524]) , .DATA_B (SUMMAND[525]) , .DATA_C (SUMMAND[526]) , .SAVE (INT_SUM[606]) , .CARRY (INT_CARRY[481]) );
   FULL_ADDER FA_416 (.DATA_A (SUMMAND[527]) , .DATA_B (INT_CARRY[472]) , .DATA_C (INT_CARRY[473]) , .SAVE (INT_SUM[607]) , .CARRY (INT_CARRY[482]) );
   FULL_ADDER FA_417 (.DATA_A (INT_SUM[605]) , .DATA_B (INT_SUM[606]) , .DATA_C (INT_SUM[607]) , .SAVE (INT_SUM[608]) , .CARRY (INT_CARRY[483]) );
   assign INT_SUM[610] = INT_CARRY[474];
   FLIPFLOP LA_155 (.DIN (INT_SUM[608]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[609]) );
   FLIPFLOP LA_156 (.DIN (INT_SUM[610]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[611]) );
   FLIPFLOP LA_157 (.DIN (INT_CARRY[475]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[476]) );
   FULL_ADDER FA_418 (.DATA_A (INT_SUM[609]) , .DATA_B (INT_SUM[611]) , .DATA_C (INT_CARRY[476]) , .SAVE (INT_SUM[612]) , .CARRY (INT_CARRY[485]) );
   FLIPFLOP LA_158 (.DIN (INT_CARRY[477]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[478]) );
   assign INT_SUM[613] = INT_CARRY[478];
   FULL_ADDER FA_419 (.DATA_A (INT_SUM[612]) , .DATA_B (INT_SUM[613]) , .DATA_C (INT_CARRY[479]) , .SAVE (SUM[51]) , .CARRY (CARRY[51]) );
   FULL_ADDER FA_420 (.DATA_A (SUMMAND[528]) , .DATA_B (SUMMAND[529]) , .DATA_C (SUMMAND[530]) , .SAVE (INT_SUM[614]) , .CARRY (INT_CARRY[486]) );
   FULL_ADDER FA_421 (.DATA_A (SUMMAND[531]) , .DATA_B (SUMMAND[532]) , .DATA_C (SUMMAND[533]) , .SAVE (INT_SUM[615]) , .CARRY (INT_CARRY[487]) );
   assign INT_SUM[616] = SUMMAND[534];
   FULL_ADDER FA_422 (.DATA_A (INT_SUM[614]) , .DATA_B (INT_SUM[615]) , .DATA_C (INT_SUM[616]) , .SAVE (INT_SUM[617]) , .CARRY (INT_CARRY[488]) );
   FULL_ADDER FA_423 (.DATA_A (INT_CARRY[480]) , .DATA_B (INT_CARRY[481]) , .DATA_C (INT_CARRY[482]) , .SAVE (INT_SUM[619]) , .CARRY (INT_CARRY[490]) );
   FLIPFLOP LA_159 (.DIN (INT_SUM[617]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[618]) );
   FLIPFLOP LA_160 (.DIN (INT_SUM[619]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[620]) );
   FLIPFLOP LA_161 (.DIN (INT_CARRY[483]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[484]) );
   FULL_ADDER FA_424 (.DATA_A (INT_SUM[618]) , .DATA_B (INT_SUM[620]) , .DATA_C (INT_CARRY[484]) , .SAVE (INT_SUM[621]) , .CARRY (INT_CARRY[492]) );
   HALF_ADDER HA_44 (.DATA_A (INT_SUM[621]) , .DATA_B (INT_CARRY[485]) , .SAVE (SUM[52]) , .CARRY (CARRY[52]) );
   FULL_ADDER FA_425 (.DATA_A (SUMMAND[535]) , .DATA_B (SUMMAND[536]) , .DATA_C (SUMMAND[537]) , .SAVE (INT_SUM[622]) , .CARRY (INT_CARRY[493]) );
   FULL_ADDER FA_426 (.DATA_A (SUMMAND[538]) , .DATA_B (SUMMAND[539]) , .DATA_C (SUMMAND[540]) , .SAVE (INT_SUM[623]) , .CARRY (INT_CARRY[494]) );
   FULL_ADDER FA_427 (.DATA_A (INT_SUM[622]) , .DATA_B (INT_SUM[623]) , .DATA_C (INT_CARRY[486]) , .SAVE (INT_SUM[624]) , .CARRY (INT_CARRY[495]) );
   assign INT_SUM[626] = INT_CARRY[487];
   FLIPFLOP LA_162 (.DIN (INT_SUM[624]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[625]) );
   FLIPFLOP LA_163 (.DIN (INT_SUM[626]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[627]) );
   FLIPFLOP LA_164 (.DIN (INT_CARRY[488]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[489]) );
   FULL_ADDER FA_428 (.DATA_A (INT_SUM[625]) , .DATA_B (INT_SUM[627]) , .DATA_C (INT_CARRY[489]) , .SAVE (INT_SUM[628]) , .CARRY (INT_CARRY[497]) );
   FLIPFLOP LA_165 (.DIN (INT_CARRY[490]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[491]) );
   assign INT_SUM[629] = INT_CARRY[491];
   FULL_ADDER FA_429 (.DATA_A (INT_SUM[628]) , .DATA_B (INT_SUM[629]) , .DATA_C (INT_CARRY[492]) , .SAVE (SUM[53]) , .CARRY (CARRY[53]) );
   FULL_ADDER FA_430 (.DATA_A (SUMMAND[541]) , .DATA_B (SUMMAND[542]) , .DATA_C (SUMMAND[543]) , .SAVE (INT_SUM[630]) , .CARRY (INT_CARRY[498]) );
   FULL_ADDER FA_431 (.DATA_A (SUMMAND[544]) , .DATA_B (SUMMAND[545]) , .DATA_C (SUMMAND[546]) , .SAVE (INT_SUM[631]) , .CARRY (INT_CARRY[499]) );
   FULL_ADDER FA_432 (.DATA_A (INT_SUM[630]) , .DATA_B (INT_SUM[631]) , .DATA_C (INT_CARRY[493]) , .SAVE (INT_SUM[632]) , .CARRY (INT_CARRY[500]) );
   assign INT_SUM[634] = INT_CARRY[494];
   FLIPFLOP LA_166 (.DIN (INT_SUM[632]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[633]) );
   FLIPFLOP LA_167 (.DIN (INT_SUM[634]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[635]) );
   FLIPFLOP LA_168 (.DIN (INT_CARRY[495]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[496]) );
   FULL_ADDER FA_433 (.DATA_A (INT_SUM[633]) , .DATA_B (INT_SUM[635]) , .DATA_C (INT_CARRY[496]) , .SAVE (INT_SUM[636]) , .CARRY (INT_CARRY[502]) );
   HALF_ADDER HA_45 (.DATA_A (INT_SUM[636]) , .DATA_B (INT_CARRY[497]) , .SAVE (SUM[54]) , .CARRY (CARRY[54]) );
   FULL_ADDER FA_434 (.DATA_A (SUMMAND[547]) , .DATA_B (SUMMAND[548]) , .DATA_C (SUMMAND[549]) , .SAVE (INT_SUM[637]) , .CARRY (INT_CARRY[503]) );
   HALF_ADDER HA_46 (.DATA_A (SUMMAND[550]) , .DATA_B (SUMMAND[551]) , .SAVE (INT_SUM[638]) , .CARRY (INT_CARRY[504]) );
   FULL_ADDER FA_435 (.DATA_A (INT_SUM[637]) , .DATA_B (INT_SUM[638]) , .DATA_C (INT_CARRY[498]) , .SAVE (INT_SUM[639]) , .CARRY (INT_CARRY[505]) );
   assign INT_SUM[641] = INT_CARRY[499];
   FLIPFLOP LA_169 (.DIN (INT_SUM[639]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[640]) );
   FLIPFLOP LA_170 (.DIN (INT_SUM[641]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[642]) );
   FLIPFLOP LA_171 (.DIN (INT_CARRY[500]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[501]) );
   FULL_ADDER FA_436 (.DATA_A (INT_SUM[640]) , .DATA_B (INT_SUM[642]) , .DATA_C (INT_CARRY[501]) , .SAVE (INT_SUM[643]) , .CARRY (INT_CARRY[507]) );
   HALF_ADDER HA_47 (.DATA_A (INT_SUM[643]) , .DATA_B (INT_CARRY[502]) , .SAVE (SUM[55]) , .CARRY (CARRY[55]) );
   FULL_ADDER FA_437 (.DATA_A (SUMMAND[552]) , .DATA_B (SUMMAND[553]) , .DATA_C (SUMMAND[554]) , .SAVE (INT_SUM[644]) , .CARRY (INT_CARRY[508]) );
   HALF_ADDER HA_48 (.DATA_A (SUMMAND[555]) , .DATA_B (SUMMAND[556]) , .SAVE (INT_SUM[645]) , .CARRY (INT_CARRY[509]) );
   FULL_ADDER FA_438 (.DATA_A (INT_SUM[644]) , .DATA_B (INT_SUM[645]) , .DATA_C (INT_CARRY[503]) , .SAVE (INT_SUM[646]) , .CARRY (INT_CARRY[510]) );
   assign INT_SUM[648] = INT_CARRY[504];
   FLIPFLOP LA_172 (.DIN (INT_SUM[646]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[647]) );
   FLIPFLOP LA_173 (.DIN (INT_SUM[648]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[649]) );
   FLIPFLOP LA_174 (.DIN (INT_CARRY[505]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[506]) );
   FULL_ADDER FA_439 (.DATA_A (INT_SUM[647]) , .DATA_B (INT_SUM[649]) , .DATA_C (INT_CARRY[506]) , .SAVE (INT_SUM[650]) , .CARRY (INT_CARRY[512]) );
   HALF_ADDER HA_49 (.DATA_A (INT_SUM[650]) , .DATA_B (INT_CARRY[507]) , .SAVE (SUM[56]) , .CARRY (CARRY[56]) );
   FULL_ADDER FA_440 (.DATA_A (SUMMAND[557]) , .DATA_B (SUMMAND[558]) , .DATA_C (SUMMAND[559]) , .SAVE (INT_SUM[651]) , .CARRY (INT_CARRY[513]) );
   FULL_ADDER FA_441 (.DATA_A (SUMMAND[560]) , .DATA_B (INT_CARRY[508]) , .DATA_C (INT_CARRY[509]) , .SAVE (INT_SUM[653]) , .CARRY (INT_CARRY[515]) );
   FLIPFLOP LA_175 (.DIN (INT_SUM[651]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[652]) );
   FLIPFLOP LA_176 (.DIN (INT_SUM[653]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[654]) );
   FLIPFLOP LA_177 (.DIN (INT_CARRY[510]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[511]) );
   FULL_ADDER FA_442 (.DATA_A (INT_SUM[652]) , .DATA_B (INT_SUM[654]) , .DATA_C (INT_CARRY[511]) , .SAVE (INT_SUM[655]) , .CARRY (INT_CARRY[517]) );
   HALF_ADDER HA_50 (.DATA_A (INT_SUM[655]) , .DATA_B (INT_CARRY[512]) , .SAVE (SUM[57]) , .CARRY (CARRY[57]) );
   FULL_ADDER FA_443 (.DATA_A (SUMMAND[561]) , .DATA_B (SUMMAND[562]) , .DATA_C (SUMMAND[563]) , .SAVE (INT_SUM[656]) , .CARRY (INT_CARRY[518]) );
   assign INT_SUM[658] = SUMMAND[564];
   FLIPFLOP LA_178 (.DIN (INT_SUM[656]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[657]) );
   FLIPFLOP LA_179 (.DIN (INT_SUM[658]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[659]) );
   FLIPFLOP LA_180 (.DIN (INT_CARRY[513]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[514]) );
   FULL_ADDER FA_444 (.DATA_A (INT_SUM[657]) , .DATA_B (INT_SUM[659]) , .DATA_C (INT_CARRY[514]) , .SAVE (INT_SUM[660]) , .CARRY (INT_CARRY[520]) );
   FLIPFLOP LA_181 (.DIN (INT_CARRY[515]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[516]) );
   assign INT_SUM[661] = INT_CARRY[516];
   FULL_ADDER FA_445 (.DATA_A (INT_SUM[660]) , .DATA_B (INT_SUM[661]) , .DATA_C (INT_CARRY[517]) , .SAVE (SUM[58]) , .CARRY (CARRY[58]) );
   FULL_ADDER FA_446 (.DATA_A (SUMMAND[565]) , .DATA_B (SUMMAND[566]) , .DATA_C (SUMMAND[567]) , .SAVE (INT_SUM[662]) , .CARRY (INT_CARRY[521]) );
   FLIPFLOP LA_182 (.DIN (INT_SUM[662]) , .RST(RST), .CLK (CLK) , .DOUT (INT_SUM[663]) );
   assign INT_SUM[664] = INT_SUM[663];
   FLIPFLOP LA_183 (.DIN (INT_CARRY[518]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[519]) );
   assign INT_SUM[665] = INT_CARRY[519];
   FULL_ADDER FA_447 (.DATA_A (INT_SUM[664]) , .DATA_B (INT_SUM[665]) , .DATA_C (INT_CARRY[520]) , .SAVE (SUM[59]) , .CARRY (CARRY[59]) );
   FLIPFLOP LA_184 (.DIN (SUMMAND[568]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[0]) );
   FLIPFLOP LA_185 (.DIN (SUMMAND[569]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[1]) );
   FLIPFLOP LA_186 (.DIN (SUMMAND[570]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[2]) );
   FULL_ADDER FA_448 (.DATA_A (LATCHED_PP[0]) , .DATA_B (LATCHED_PP[1]) , .DATA_C (LATCHED_PP[2]) , .SAVE (INT_SUM[666]) , .CARRY (INT_CARRY[523]) );
   FLIPFLOP LA_187 (.DIN (INT_CARRY[521]) , .RST(RST), .CLK (CLK) , .DOUT (INT_CARRY[522]) );
   assign INT_SUM[667] = INT_CARRY[522];
   HALF_ADDER HA_51 (.DATA_A (INT_SUM[666]) , .DATA_B (INT_SUM[667]) , .SAVE (SUM[60]) , .CARRY (CARRY[60]) );
   FLIPFLOP LA_188 (.DIN (SUMMAND[571]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[3]) );
   assign INT_SUM[668] = LATCHED_PP[3];
   FLIPFLOP LA_189 (.DIN (SUMMAND[572]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[4]) );
   assign INT_SUM[669] = LATCHED_PP[4];
   FULL_ADDER FA_449 (.DATA_A (INT_SUM[668]) , .DATA_B (INT_SUM[669]) , .DATA_C (INT_CARRY[523]) , .SAVE (SUM[61]) , .CARRY (CARRY[61]) );
   FLIPFLOP LA_190 (.DIN (SUMMAND[573]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[5]) );
   FLIPFLOP LA_191 (.DIN (SUMMAND[574]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[6]) );
   HALF_ADDER HA_52 (.DATA_A (LATCHED_PP[5]) , .DATA_B (LATCHED_PP[6]) , .SAVE (SUM[62]) , .CARRY (CARRY[62]) );
   FLIPFLOP LA_192 (.DIN (SUMMAND[575]) , .RST(RST), .CLK (CLK) , .DOUT (LATCHED_PP[7]) );
   assign SUM[63] = LATCHED_PP[7];
endmodule


module INVBLOCK ( GIN, PHI, GOUT );
   input  GIN;
   input  PHI;
   output GOUT;
   assign GOUT =  ~ GIN;
endmodule


module XXOR1 ( A, B, GIN, PHI, SUM );
   input  A;
   input  B;
   input  GIN;
   input  PHI;
   output SUM;
   assign SUM = ( ~ (A ^ B)) ^ GIN;
endmodule


module BLOCK0 ( A, B, PHI, POUT, GOUT );
   input  A;
   input  B;
   input  PHI;
   output POUT;
   output GOUT;
   assign POUT =  ~ (A | B);
   assign GOUT =  ~ (A & B);
endmodule


module BLOCK1 ( PIN1, PIN2, GIN1, GIN2, PHI, POUT, GOUT );
   input  PIN1;
   input  PIN2;
   input  GIN1;
   input  GIN2;
   input  PHI;
   output POUT;
   output GOUT;
   assign POUT =  ~ (PIN1 | PIN2);
   assign GOUT =  ~ (GIN2 & (PIN2 | GIN1));
endmodule


module BLOCK2 ( PIN1, PIN2, GIN1, GIN2, PHI, POUT, GOUT );
   input  PIN1;
   input  PIN2;
   input  GIN1;
   input  GIN2;
   input  PHI;
   output POUT;
   output GOUT;
   assign POUT =  ~ (PIN1 & PIN2);
   assign GOUT =  ~ (GIN2 | (PIN2 & GIN1));
endmodule


module BLOCK1A ( PIN2, GIN1, GIN2, PHI, GOUT );
   input  PIN2;
   input  GIN1;
   input  GIN2;
   input  PHI;
   output GOUT;
   assign GOUT =  ~ (GIN2 & (PIN2 | GIN1));
endmodule


module BLOCK2A ( PIN2, GIN1, GIN2, PHI, GOUT );
   input  PIN2;
   input  GIN1;
   input  GIN2;
   input  PHI;
   output GOUT;
   assign GOUT =  ~ (GIN2 | (PIN2 & GIN1));
endmodule


module PRESTAGE_64 ( A, B, CIN, PHI, POUT, GOUT );
   input  [0:63] A;
   input [0:63]  B;
   input 	 CIN;
   input 	 PHI;
   output [0:63] POUT;
   output [0:64] GOUT;
   BLOCK0 U10 (A[0] , B[0] , PHI , POUT[0] , GOUT[1] );
   BLOCK0 U11 (A[1] , B[1] , PHI , POUT[1] , GOUT[2] );
   BLOCK0 U12 (A[2] , B[2] , PHI , POUT[2] , GOUT[3] );
   BLOCK0 U13 (A[3] , B[3] , PHI , POUT[3] , GOUT[4] );
   BLOCK0 U14 (A[4] , B[4] , PHI , POUT[4] , GOUT[5] );
   BLOCK0 U15 (A[5] , B[5] , PHI , POUT[5] , GOUT[6] );
   BLOCK0 U16 (A[6] , B[6] , PHI , POUT[6] , GOUT[7] );
   BLOCK0 U17 (A[7] , B[7] , PHI , POUT[7] , GOUT[8] );
   BLOCK0 U18 (A[8] , B[8] , PHI , POUT[8] , GOUT[9] );
   BLOCK0 U19 (A[9] , B[9] , PHI , POUT[9] , GOUT[10] );
   BLOCK0 U110 (A[10] , B[10] , PHI , POUT[10] , GOUT[11] );
   BLOCK0 U111 (A[11] , B[11] , PHI , POUT[11] , GOUT[12] );
   BLOCK0 U112 (A[12] , B[12] , PHI , POUT[12] , GOUT[13] );
   BLOCK0 U113 (A[13] , B[13] , PHI , POUT[13] , GOUT[14] );
   BLOCK0 U114 (A[14] , B[14] , PHI , POUT[14] , GOUT[15] );
   BLOCK0 U115 (A[15] , B[15] , PHI , POUT[15] , GOUT[16] );
   BLOCK0 U116 (A[16] , B[16] , PHI , POUT[16] , GOUT[17] );
   BLOCK0 U117 (A[17] , B[17] , PHI , POUT[17] , GOUT[18] );
   BLOCK0 U118 (A[18] , B[18] , PHI , POUT[18] , GOUT[19] );
   BLOCK0 U119 (A[19] , B[19] , PHI , POUT[19] , GOUT[20] );
   BLOCK0 U120 (A[20] , B[20] , PHI , POUT[20] , GOUT[21] );
   BLOCK0 U121 (A[21] , B[21] , PHI , POUT[21] , GOUT[22] );
   BLOCK0 U122 (A[22] , B[22] , PHI , POUT[22] , GOUT[23] );
   BLOCK0 U123 (A[23] , B[23] , PHI , POUT[23] , GOUT[24] );
   BLOCK0 U124 (A[24] , B[24] , PHI , POUT[24] , GOUT[25] );
   BLOCK0 U125 (A[25] , B[25] , PHI , POUT[25] , GOUT[26] );
   BLOCK0 U126 (A[26] , B[26] , PHI , POUT[26] , GOUT[27] );
   BLOCK0 U127 (A[27] , B[27] , PHI , POUT[27] , GOUT[28] );
   BLOCK0 U128 (A[28] , B[28] , PHI , POUT[28] , GOUT[29] );
   BLOCK0 U129 (A[29] , B[29] , PHI , POUT[29] , GOUT[30] );
   BLOCK0 U130 (A[30] , B[30] , PHI , POUT[30] , GOUT[31] );
   BLOCK0 U131 (A[31] , B[31] , PHI , POUT[31] , GOUT[32] );
   BLOCK0 U132 (A[32] , B[32] , PHI , POUT[32] , GOUT[33] );
   BLOCK0 U133 (A[33] , B[33] , PHI , POUT[33] , GOUT[34] );
   BLOCK0 U134 (A[34] , B[34] , PHI , POUT[34] , GOUT[35] );
   BLOCK0 U135 (A[35] , B[35] , PHI , POUT[35] , GOUT[36] );
   BLOCK0 U136 (A[36] , B[36] , PHI , POUT[36] , GOUT[37] );
   BLOCK0 U137 (A[37] , B[37] , PHI , POUT[37] , GOUT[38] );
   BLOCK0 U138 (A[38] , B[38] , PHI , POUT[38] , GOUT[39] );
   BLOCK0 U139 (A[39] , B[39] , PHI , POUT[39] , GOUT[40] );
   BLOCK0 U140 (A[40] , B[40] , PHI , POUT[40] , GOUT[41] );
   BLOCK0 U141 (A[41] , B[41] , PHI , POUT[41] , GOUT[42] );
   BLOCK0 U142 (A[42] , B[42] , PHI , POUT[42] , GOUT[43] );
   BLOCK0 U143 (A[43] , B[43] , PHI , POUT[43] , GOUT[44] );
   BLOCK0 U144 (A[44] , B[44] , PHI , POUT[44] , GOUT[45] );
   BLOCK0 U145 (A[45] , B[45] , PHI , POUT[45] , GOUT[46] );
   BLOCK0 U146 (A[46] , B[46] , PHI , POUT[46] , GOUT[47] );
   BLOCK0 U147 (A[47] , B[47] , PHI , POUT[47] , GOUT[48] );
   BLOCK0 U148 (A[48] , B[48] , PHI , POUT[48] , GOUT[49] );
   BLOCK0 U149 (A[49] , B[49] , PHI , POUT[49] , GOUT[50] );
   BLOCK0 U150 (A[50] , B[50] , PHI , POUT[50] , GOUT[51] );
   BLOCK0 U151 (A[51] , B[51] , PHI , POUT[51] , GOUT[52] );
   BLOCK0 U152 (A[52] , B[52] , PHI , POUT[52] , GOUT[53] );
   BLOCK0 U153 (A[53] , B[53] , PHI , POUT[53] , GOUT[54] );
   BLOCK0 U154 (A[54] , B[54] , PHI , POUT[54] , GOUT[55] );
   BLOCK0 U155 (A[55] , B[55] , PHI , POUT[55] , GOUT[56] );
   BLOCK0 U156 (A[56] , B[56] , PHI , POUT[56] , GOUT[57] );
   BLOCK0 U157 (A[57] , B[57] , PHI , POUT[57] , GOUT[58] );
   BLOCK0 U158 (A[58] , B[58] , PHI , POUT[58] , GOUT[59] );
   BLOCK0 U159 (A[59] , B[59] , PHI , POUT[59] , GOUT[60] );
   BLOCK0 U160 (A[60] , B[60] , PHI , POUT[60] , GOUT[61] );
   BLOCK0 U161 (A[61] , B[61] , PHI , POUT[61] , GOUT[62] );
   BLOCK0 U162 (A[62] , B[62] , PHI , POUT[62] , GOUT[63] );
   BLOCK0 U163 (A[63] , B[63] , PHI , POUT[63] , GOUT[64] );
   INVBLOCK U2 (CIN , PHI , GOUT[0] );
endmodule


module DBLC_0_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:63] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:62] POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   BLOCK1A U21 (PIN[0] , GIN[0] , GIN[1] , PHI , GOUT[1] );
   BLOCK1 U32 (PIN[0] , PIN[1] , GIN[1] , GIN[2] , PHI , POUT[0] , GOUT[2] );
   BLOCK1 U33 (PIN[1] , PIN[2] , GIN[2] , GIN[3] , PHI , POUT[1] , GOUT[3] );
   BLOCK1 U34 (PIN[2] , PIN[3] , GIN[3] , GIN[4] , PHI , POUT[2] , GOUT[4] );
   BLOCK1 U35 (PIN[3] , PIN[4] , GIN[4] , GIN[5] , PHI , POUT[3] , GOUT[5] );
   BLOCK1 U36 (PIN[4] , PIN[5] , GIN[5] , GIN[6] , PHI , POUT[4] , GOUT[6] );
   BLOCK1 U37 (PIN[5] , PIN[6] , GIN[6] , GIN[7] , PHI , POUT[5] , GOUT[7] );
   BLOCK1 U38 (PIN[6] , PIN[7] , GIN[7] , GIN[8] , PHI , POUT[6] , GOUT[8] );
   BLOCK1 U39 (PIN[7] , PIN[8] , GIN[8] , GIN[9] , PHI , POUT[7] , GOUT[9] );
   BLOCK1 U310 (PIN[8] , PIN[9] , GIN[9] , GIN[10] , PHI , POUT[8] , GOUT[10] );
   BLOCK1 U311 (PIN[9] , PIN[10] , GIN[10] , GIN[11] , PHI , POUT[9] , GOUT[11] );
   BLOCK1 U312 (PIN[10] , PIN[11] , GIN[11] , GIN[12] , PHI , POUT[10] , GOUT[12] );
   BLOCK1 U313 (PIN[11] , PIN[12] , GIN[12] , GIN[13] , PHI , POUT[11] , GOUT[13] );
   BLOCK1 U314 (PIN[12] , PIN[13] , GIN[13] , GIN[14] , PHI , POUT[12] , GOUT[14] );
   BLOCK1 U315 (PIN[13] , PIN[14] , GIN[14] , GIN[15] , PHI , POUT[13] , GOUT[15] );
   BLOCK1 U316 (PIN[14] , PIN[15] , GIN[15] , GIN[16] , PHI , POUT[14] , GOUT[16] );
   BLOCK1 U317 (PIN[15] , PIN[16] , GIN[16] , GIN[17] , PHI , POUT[15] , GOUT[17] );
   BLOCK1 U318 (PIN[16] , PIN[17] , GIN[17] , GIN[18] , PHI , POUT[16] , GOUT[18] );
   BLOCK1 U319 (PIN[17] , PIN[18] , GIN[18] , GIN[19] , PHI , POUT[17] , GOUT[19] );
   BLOCK1 U320 (PIN[18] , PIN[19] , GIN[19] , GIN[20] , PHI , POUT[18] , GOUT[20] );
   BLOCK1 U321 (PIN[19] , PIN[20] , GIN[20] , GIN[21] , PHI , POUT[19] , GOUT[21] );
   BLOCK1 U322 (PIN[20] , PIN[21] , GIN[21] , GIN[22] , PHI , POUT[20] , GOUT[22] );
   BLOCK1 U323 (PIN[21] , PIN[22] , GIN[22] , GIN[23] , PHI , POUT[21] , GOUT[23] );
   BLOCK1 U324 (PIN[22] , PIN[23] , GIN[23] , GIN[24] , PHI , POUT[22] , GOUT[24] );
   BLOCK1 U325 (PIN[23] , PIN[24] , GIN[24] , GIN[25] , PHI , POUT[23] , GOUT[25] );
   BLOCK1 U326 (PIN[24] , PIN[25] , GIN[25] , GIN[26] , PHI , POUT[24] , GOUT[26] );
   BLOCK1 U327 (PIN[25] , PIN[26] , GIN[26] , GIN[27] , PHI , POUT[25] , GOUT[27] );
   BLOCK1 U328 (PIN[26] , PIN[27] , GIN[27] , GIN[28] , PHI , POUT[26] , GOUT[28] );
   BLOCK1 U329 (PIN[27] , PIN[28] , GIN[28] , GIN[29] , PHI , POUT[27] , GOUT[29] );
   BLOCK1 U330 (PIN[28] , PIN[29] , GIN[29] , GIN[30] , PHI , POUT[28] , GOUT[30] );
   BLOCK1 U331 (PIN[29] , PIN[30] , GIN[30] , GIN[31] , PHI , POUT[29] , GOUT[31] );
   BLOCK1 U332 (PIN[30] , PIN[31] , GIN[31] , GIN[32] , PHI , POUT[30] , GOUT[32] );
   BLOCK1 U333 (PIN[31] , PIN[32] , GIN[32] , GIN[33] , PHI , POUT[31] , GOUT[33] );
   BLOCK1 U334 (PIN[32] , PIN[33] , GIN[33] , GIN[34] , PHI , POUT[32] , GOUT[34] );
   BLOCK1 U335 (PIN[33] , PIN[34] , GIN[34] , GIN[35] , PHI , POUT[33] , GOUT[35] );
   BLOCK1 U336 (PIN[34] , PIN[35] , GIN[35] , GIN[36] , PHI , POUT[34] , GOUT[36] );
   BLOCK1 U337 (PIN[35] , PIN[36] , GIN[36] , GIN[37] , PHI , POUT[35] , GOUT[37] );
   BLOCK1 U338 (PIN[36] , PIN[37] , GIN[37] , GIN[38] , PHI , POUT[36] , GOUT[38] );
   BLOCK1 U339 (PIN[37] , PIN[38] , GIN[38] , GIN[39] , PHI , POUT[37] , GOUT[39] );
   BLOCK1 U340 (PIN[38] , PIN[39] , GIN[39] , GIN[40] , PHI , POUT[38] , GOUT[40] );
   BLOCK1 U341 (PIN[39] , PIN[40] , GIN[40] , GIN[41] , PHI , POUT[39] , GOUT[41] );
   BLOCK1 U342 (PIN[40] , PIN[41] , GIN[41] , GIN[42] , PHI , POUT[40] , GOUT[42] );
   BLOCK1 U343 (PIN[41] , PIN[42] , GIN[42] , GIN[43] , PHI , POUT[41] , GOUT[43] );
   BLOCK1 U344 (PIN[42] , PIN[43] , GIN[43] , GIN[44] , PHI , POUT[42] , GOUT[44] );
   BLOCK1 U345 (PIN[43] , PIN[44] , GIN[44] , GIN[45] , PHI , POUT[43] , GOUT[45] );
   BLOCK1 U346 (PIN[44] , PIN[45] , GIN[45] , GIN[46] , PHI , POUT[44] , GOUT[46] );
   BLOCK1 U347 (PIN[45] , PIN[46] , GIN[46] , GIN[47] , PHI , POUT[45] , GOUT[47] );
   BLOCK1 U348 (PIN[46] , PIN[47] , GIN[47] , GIN[48] , PHI , POUT[46] , GOUT[48] );
   BLOCK1 U349 (PIN[47] , PIN[48] , GIN[48] , GIN[49] , PHI , POUT[47] , GOUT[49] );
   BLOCK1 U350 (PIN[48] , PIN[49] , GIN[49] , GIN[50] , PHI , POUT[48] , GOUT[50] );
   BLOCK1 U351 (PIN[49] , PIN[50] , GIN[50] , GIN[51] , PHI , POUT[49] , GOUT[51] );
   BLOCK1 U352 (PIN[50] , PIN[51] , GIN[51] , GIN[52] , PHI , POUT[50] , GOUT[52] );
   BLOCK1 U353 (PIN[51] , PIN[52] , GIN[52] , GIN[53] , PHI , POUT[51] , GOUT[53] );
   BLOCK1 U354 (PIN[52] , PIN[53] , GIN[53] , GIN[54] , PHI , POUT[52] , GOUT[54] );
   BLOCK1 U355 (PIN[53] , PIN[54] , GIN[54] , GIN[55] , PHI , POUT[53] , GOUT[55] );
   BLOCK1 U356 (PIN[54] , PIN[55] , GIN[55] , GIN[56] , PHI , POUT[54] , GOUT[56] );
   BLOCK1 U357 (PIN[55] , PIN[56] , GIN[56] , GIN[57] , PHI , POUT[55] , GOUT[57] );
   BLOCK1 U358 (PIN[56] , PIN[57] , GIN[57] , GIN[58] , PHI , POUT[56] , GOUT[58] );
   BLOCK1 U359 (PIN[57] , PIN[58] , GIN[58] , GIN[59] , PHI , POUT[57] , GOUT[59] );
   BLOCK1 U360 (PIN[58] , PIN[59] , GIN[59] , GIN[60] , PHI , POUT[58] , GOUT[60] );
   BLOCK1 U361 (PIN[59] , PIN[60] , GIN[60] , GIN[61] , PHI , POUT[59] , GOUT[61] );
   BLOCK1 U362 (PIN[60] , PIN[61] , GIN[61] , GIN[62] , PHI , POUT[60] , GOUT[62] );
   BLOCK1 U363 (PIN[61] , PIN[62] , GIN[62] , GIN[63] , PHI , POUT[61] , GOUT[63] );
   BLOCK1 U364 (PIN[62] , PIN[63] , GIN[63] , GIN[64] , PHI , POUT[62] , GOUT[64] );
endmodule


module DBLC_1_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:62] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:60] POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   INVBLOCK U11 (GIN[1] , PHI , GOUT[1] );
   BLOCK2A U22 (PIN[0] , GIN[0] , GIN[2] , PHI , GOUT[2] );
   BLOCK2A U23 (PIN[1] , GIN[1] , GIN[3] , PHI , GOUT[3] );
   BLOCK2 U34 (PIN[0] , PIN[2] , GIN[2] , GIN[4] , PHI , POUT[0] , GOUT[4] );
   BLOCK2 U35 (PIN[1] , PIN[3] , GIN[3] , GIN[5] , PHI , POUT[1] , GOUT[5] );
   BLOCK2 U36 (PIN[2] , PIN[4] , GIN[4] , GIN[6] , PHI , POUT[2] , GOUT[6] );
   BLOCK2 U37 (PIN[3] , PIN[5] , GIN[5] , GIN[7] , PHI , POUT[3] , GOUT[7] );
   BLOCK2 U38 (PIN[4] , PIN[6] , GIN[6] , GIN[8] , PHI , POUT[4] , GOUT[8] );
   BLOCK2 U39 (PIN[5] , PIN[7] , GIN[7] , GIN[9] , PHI , POUT[5] , GOUT[9] );
   BLOCK2 U310 (PIN[6] , PIN[8] , GIN[8] , GIN[10] , PHI , POUT[6] , GOUT[10] );
   BLOCK2 U311 (PIN[7] , PIN[9] , GIN[9] , GIN[11] , PHI , POUT[7] , GOUT[11] );
   BLOCK2 U312 (PIN[8] , PIN[10] , GIN[10] , GIN[12] , PHI , POUT[8] , GOUT[12] );
   BLOCK2 U313 (PIN[9] , PIN[11] , GIN[11] , GIN[13] , PHI , POUT[9] , GOUT[13] );
   BLOCK2 U314 (PIN[10] , PIN[12] , GIN[12] , GIN[14] , PHI , POUT[10] , GOUT[14] );
   BLOCK2 U315 (PIN[11] , PIN[13] , GIN[13] , GIN[15] , PHI , POUT[11] , GOUT[15] );
   BLOCK2 U316 (PIN[12] , PIN[14] , GIN[14] , GIN[16] , PHI , POUT[12] , GOUT[16] );
   BLOCK2 U317 (PIN[13] , PIN[15] , GIN[15] , GIN[17] , PHI , POUT[13] , GOUT[17] );
   BLOCK2 U318 (PIN[14] , PIN[16] , GIN[16] , GIN[18] , PHI , POUT[14] , GOUT[18] );
   BLOCK2 U319 (PIN[15] , PIN[17] , GIN[17] , GIN[19] , PHI , POUT[15] , GOUT[19] );
   BLOCK2 U320 (PIN[16] , PIN[18] , GIN[18] , GIN[20] , PHI , POUT[16] , GOUT[20] );
   BLOCK2 U321 (PIN[17] , PIN[19] , GIN[19] , GIN[21] , PHI , POUT[17] , GOUT[21] );
   BLOCK2 U322 (PIN[18] , PIN[20] , GIN[20] , GIN[22] , PHI , POUT[18] , GOUT[22] );
   BLOCK2 U323 (PIN[19] , PIN[21] , GIN[21] , GIN[23] , PHI , POUT[19] , GOUT[23] );
   BLOCK2 U324 (PIN[20] , PIN[22] , GIN[22] , GIN[24] , PHI , POUT[20] , GOUT[24] );
   BLOCK2 U325 (PIN[21] , PIN[23] , GIN[23] , GIN[25] , PHI , POUT[21] , GOUT[25] );
   BLOCK2 U326 (PIN[22] , PIN[24] , GIN[24] , GIN[26] , PHI , POUT[22] , GOUT[26] );
   BLOCK2 U327 (PIN[23] , PIN[25] , GIN[25] , GIN[27] , PHI , POUT[23] , GOUT[27] );
   BLOCK2 U328 (PIN[24] , PIN[26] , GIN[26] , GIN[28] , PHI , POUT[24] , GOUT[28] );
   BLOCK2 U329 (PIN[25] , PIN[27] , GIN[27] , GIN[29] , PHI , POUT[25] , GOUT[29] );
   BLOCK2 U330 (PIN[26] , PIN[28] , GIN[28] , GIN[30] , PHI , POUT[26] , GOUT[30] );
   BLOCK2 U331 (PIN[27] , PIN[29] , GIN[29] , GIN[31] , PHI , POUT[27] , GOUT[31] );
   BLOCK2 U332 (PIN[28] , PIN[30] , GIN[30] , GIN[32] , PHI , POUT[28] , GOUT[32] );
   BLOCK2 U333 (PIN[29] , PIN[31] , GIN[31] , GIN[33] , PHI , POUT[29] , GOUT[33] );
   BLOCK2 U334 (PIN[30] , PIN[32] , GIN[32] , GIN[34] , PHI , POUT[30] , GOUT[34] );
   BLOCK2 U335 (PIN[31] , PIN[33] , GIN[33] , GIN[35] , PHI , POUT[31] , GOUT[35] );
   BLOCK2 U336 (PIN[32] , PIN[34] , GIN[34] , GIN[36] , PHI , POUT[32] , GOUT[36] );
   BLOCK2 U337 (PIN[33] , PIN[35] , GIN[35] , GIN[37] , PHI , POUT[33] , GOUT[37] );
   BLOCK2 U338 (PIN[34] , PIN[36] , GIN[36] , GIN[38] , PHI , POUT[34] , GOUT[38] );
   BLOCK2 U339 (PIN[35] , PIN[37] , GIN[37] , GIN[39] , PHI , POUT[35] , GOUT[39] );
   BLOCK2 U340 (PIN[36] , PIN[38] , GIN[38] , GIN[40] , PHI , POUT[36] , GOUT[40] );
   BLOCK2 U341 (PIN[37] , PIN[39] , GIN[39] , GIN[41] , PHI , POUT[37] , GOUT[41] );
   BLOCK2 U342 (PIN[38] , PIN[40] , GIN[40] , GIN[42] , PHI , POUT[38] , GOUT[42] );
   BLOCK2 U343 (PIN[39] , PIN[41] , GIN[41] , GIN[43] , PHI , POUT[39] , GOUT[43] );
   BLOCK2 U344 (PIN[40] , PIN[42] , GIN[42] , GIN[44] , PHI , POUT[40] , GOUT[44] );
   BLOCK2 U345 (PIN[41] , PIN[43] , GIN[43] , GIN[45] , PHI , POUT[41] , GOUT[45] );
   BLOCK2 U346 (PIN[42] , PIN[44] , GIN[44] , GIN[46] , PHI , POUT[42] , GOUT[46] );
   BLOCK2 U347 (PIN[43] , PIN[45] , GIN[45] , GIN[47] , PHI , POUT[43] , GOUT[47] );
   BLOCK2 U348 (PIN[44] , PIN[46] , GIN[46] , GIN[48] , PHI , POUT[44] , GOUT[48] );
   BLOCK2 U349 (PIN[45] , PIN[47] , GIN[47] , GIN[49] , PHI , POUT[45] , GOUT[49] );
   BLOCK2 U350 (PIN[46] , PIN[48] , GIN[48] , GIN[50] , PHI , POUT[46] , GOUT[50] );
   BLOCK2 U351 (PIN[47] , PIN[49] , GIN[49] , GIN[51] , PHI , POUT[47] , GOUT[51] );
   BLOCK2 U352 (PIN[48] , PIN[50] , GIN[50] , GIN[52] , PHI , POUT[48] , GOUT[52] );
   BLOCK2 U353 (PIN[49] , PIN[51] , GIN[51] , GIN[53] , PHI , POUT[49] , GOUT[53] );
   BLOCK2 U354 (PIN[50] , PIN[52] , GIN[52] , GIN[54] , PHI , POUT[50] , GOUT[54] );
   BLOCK2 U355 (PIN[51] , PIN[53] , GIN[53] , GIN[55] , PHI , POUT[51] , GOUT[55] );
   BLOCK2 U356 (PIN[52] , PIN[54] , GIN[54] , GIN[56] , PHI , POUT[52] , GOUT[56] );
   BLOCK2 U357 (PIN[53] , PIN[55] , GIN[55] , GIN[57] , PHI , POUT[53] , GOUT[57] );
   BLOCK2 U358 (PIN[54] , PIN[56] , GIN[56] , GIN[58] , PHI , POUT[54] , GOUT[58] );
   BLOCK2 U359 (PIN[55] , PIN[57] , GIN[57] , GIN[59] , PHI , POUT[55] , GOUT[59] );
   BLOCK2 U360 (PIN[56] , PIN[58] , GIN[58] , GIN[60] , PHI , POUT[56] , GOUT[60] );
   BLOCK2 U361 (PIN[57] , PIN[59] , GIN[59] , GIN[61] , PHI , POUT[57] , GOUT[61] );
   BLOCK2 U362 (PIN[58] , PIN[60] , GIN[60] , GIN[62] , PHI , POUT[58] , GOUT[62] );
   BLOCK2 U363 (PIN[59] , PIN[61] , GIN[61] , GIN[63] , PHI , POUT[59] , GOUT[63] );
   BLOCK2 U364 (PIN[60] , PIN[62] , GIN[62] , GIN[64] , PHI , POUT[60] , GOUT[64] );
endmodule


module DBLC_2_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:60] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:56] POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   INVBLOCK U11 (GIN[1] , PHI , GOUT[1] );
   INVBLOCK U12 (GIN[2] , PHI , GOUT[2] );
   INVBLOCK U13 (GIN[3] , PHI , GOUT[3] );
   BLOCK1A U24 (PIN[0] , GIN[0] , GIN[4] , PHI , GOUT[4] );
   BLOCK1A U25 (PIN[1] , GIN[1] , GIN[5] , PHI , GOUT[5] );
   BLOCK1A U26 (PIN[2] , GIN[2] , GIN[6] , PHI , GOUT[6] );
   BLOCK1A U27 (PIN[3] , GIN[3] , GIN[7] , PHI , GOUT[7] );
   BLOCK1 U38 (PIN[0] , PIN[4] , GIN[4] , GIN[8] , PHI , POUT[0] , GOUT[8] );
   BLOCK1 U39 (PIN[1] , PIN[5] , GIN[5] , GIN[9] , PHI , POUT[1] , GOUT[9] );
   BLOCK1 U310 (PIN[2] , PIN[6] , GIN[6] , GIN[10] , PHI , POUT[2] , GOUT[10] );
   BLOCK1 U311 (PIN[3] , PIN[7] , GIN[7] , GIN[11] , PHI , POUT[3] , GOUT[11] );
   BLOCK1 U312 (PIN[4] , PIN[8] , GIN[8] , GIN[12] , PHI , POUT[4] , GOUT[12] );
   BLOCK1 U313 (PIN[5] , PIN[9] , GIN[9] , GIN[13] , PHI , POUT[5] , GOUT[13] );
   BLOCK1 U314 (PIN[6] , PIN[10] , GIN[10] , GIN[14] , PHI , POUT[6] , GOUT[14] );
   BLOCK1 U315 (PIN[7] , PIN[11] , GIN[11] , GIN[15] , PHI , POUT[7] , GOUT[15] );
   BLOCK1 U316 (PIN[8] , PIN[12] , GIN[12] , GIN[16] , PHI , POUT[8] , GOUT[16] );
   BLOCK1 U317 (PIN[9] , PIN[13] , GIN[13] , GIN[17] , PHI , POUT[9] , GOUT[17] );
   BLOCK1 U318 (PIN[10] , PIN[14] , GIN[14] , GIN[18] , PHI , POUT[10] , GOUT[18] );
   BLOCK1 U319 (PIN[11] , PIN[15] , GIN[15] , GIN[19] , PHI , POUT[11] , GOUT[19] );
   BLOCK1 U320 (PIN[12] , PIN[16] , GIN[16] , GIN[20] , PHI , POUT[12] , GOUT[20] );
   BLOCK1 U321 (PIN[13] , PIN[17] , GIN[17] , GIN[21] , PHI , POUT[13] , GOUT[21] );
   BLOCK1 U322 (PIN[14] , PIN[18] , GIN[18] , GIN[22] , PHI , POUT[14] , GOUT[22] );
   BLOCK1 U323 (PIN[15] , PIN[19] , GIN[19] , GIN[23] , PHI , POUT[15] , GOUT[23] );
   BLOCK1 U324 (PIN[16] , PIN[20] , GIN[20] , GIN[24] , PHI , POUT[16] , GOUT[24] );
   BLOCK1 U325 (PIN[17] , PIN[21] , GIN[21] , GIN[25] , PHI , POUT[17] , GOUT[25] );
   BLOCK1 U326 (PIN[18] , PIN[22] , GIN[22] , GIN[26] , PHI , POUT[18] , GOUT[26] );
   BLOCK1 U327 (PIN[19] , PIN[23] , GIN[23] , GIN[27] , PHI , POUT[19] , GOUT[27] );
   BLOCK1 U328 (PIN[20] , PIN[24] , GIN[24] , GIN[28] , PHI , POUT[20] , GOUT[28] );
   BLOCK1 U329 (PIN[21] , PIN[25] , GIN[25] , GIN[29] , PHI , POUT[21] , GOUT[29] );
   BLOCK1 U330 (PIN[22] , PIN[26] , GIN[26] , GIN[30] , PHI , POUT[22] , GOUT[30] );
   BLOCK1 U331 (PIN[23] , PIN[27] , GIN[27] , GIN[31] , PHI , POUT[23] , GOUT[31] );
   BLOCK1 U332 (PIN[24] , PIN[28] , GIN[28] , GIN[32] , PHI , POUT[24] , GOUT[32] );
   BLOCK1 U333 (PIN[25] , PIN[29] , GIN[29] , GIN[33] , PHI , POUT[25] , GOUT[33] );
   BLOCK1 U334 (PIN[26] , PIN[30] , GIN[30] , GIN[34] , PHI , POUT[26] , GOUT[34] );
   BLOCK1 U335 (PIN[27] , PIN[31] , GIN[31] , GIN[35] , PHI , POUT[27] , GOUT[35] );
   BLOCK1 U336 (PIN[28] , PIN[32] , GIN[32] , GIN[36] , PHI , POUT[28] , GOUT[36] );
   BLOCK1 U337 (PIN[29] , PIN[33] , GIN[33] , GIN[37] , PHI , POUT[29] , GOUT[37] );
   BLOCK1 U338 (PIN[30] , PIN[34] , GIN[34] , GIN[38] , PHI , POUT[30] , GOUT[38] );
   BLOCK1 U339 (PIN[31] , PIN[35] , GIN[35] , GIN[39] , PHI , POUT[31] , GOUT[39] );
   BLOCK1 U340 (PIN[32] , PIN[36] , GIN[36] , GIN[40] , PHI , POUT[32] , GOUT[40] );
   BLOCK1 U341 (PIN[33] , PIN[37] , GIN[37] , GIN[41] , PHI , POUT[33] , GOUT[41] );
   BLOCK1 U342 (PIN[34] , PIN[38] , GIN[38] , GIN[42] , PHI , POUT[34] , GOUT[42] );
   BLOCK1 U343 (PIN[35] , PIN[39] , GIN[39] , GIN[43] , PHI , POUT[35] , GOUT[43] );
   BLOCK1 U344 (PIN[36] , PIN[40] , GIN[40] , GIN[44] , PHI , POUT[36] , GOUT[44] );
   BLOCK1 U345 (PIN[37] , PIN[41] , GIN[41] , GIN[45] , PHI , POUT[37] , GOUT[45] );
   BLOCK1 U346 (PIN[38] , PIN[42] , GIN[42] , GIN[46] , PHI , POUT[38] , GOUT[46] );
   BLOCK1 U347 (PIN[39] , PIN[43] , GIN[43] , GIN[47] , PHI , POUT[39] , GOUT[47] );
   BLOCK1 U348 (PIN[40] , PIN[44] , GIN[44] , GIN[48] , PHI , POUT[40] , GOUT[48] );
   BLOCK1 U349 (PIN[41] , PIN[45] , GIN[45] , GIN[49] , PHI , POUT[41] , GOUT[49] );
   BLOCK1 U350 (PIN[42] , PIN[46] , GIN[46] , GIN[50] , PHI , POUT[42] , GOUT[50] );
   BLOCK1 U351 (PIN[43] , PIN[47] , GIN[47] , GIN[51] , PHI , POUT[43] , GOUT[51] );
   BLOCK1 U352 (PIN[44] , PIN[48] , GIN[48] , GIN[52] , PHI , POUT[44] , GOUT[52] );
   BLOCK1 U353 (PIN[45] , PIN[49] , GIN[49] , GIN[53] , PHI , POUT[45] , GOUT[53] );
   BLOCK1 U354 (PIN[46] , PIN[50] , GIN[50] , GIN[54] , PHI , POUT[46] , GOUT[54] );
   BLOCK1 U355 (PIN[47] , PIN[51] , GIN[51] , GIN[55] , PHI , POUT[47] , GOUT[55] );
   BLOCK1 U356 (PIN[48] , PIN[52] , GIN[52] , GIN[56] , PHI , POUT[48] , GOUT[56] );
   BLOCK1 U357 (PIN[49] , PIN[53] , GIN[53] , GIN[57] , PHI , POUT[49] , GOUT[57] );
   BLOCK1 U358 (PIN[50] , PIN[54] , GIN[54] , GIN[58] , PHI , POUT[50] , GOUT[58] );
   BLOCK1 U359 (PIN[51] , PIN[55] , GIN[55] , GIN[59] , PHI , POUT[51] , GOUT[59] );
   BLOCK1 U360 (PIN[52] , PIN[56] , GIN[56] , GIN[60] , PHI , POUT[52] , GOUT[60] );
   BLOCK1 U361 (PIN[53] , PIN[57] , GIN[57] , GIN[61] , PHI , POUT[53] , GOUT[61] );
   BLOCK1 U362 (PIN[54] , PIN[58] , GIN[58] , GIN[62] , PHI , POUT[54] , GOUT[62] );
   BLOCK1 U363 (PIN[55] , PIN[59] , GIN[59] , GIN[63] , PHI , POUT[55] , GOUT[63] );
   BLOCK1 U364 (PIN[56] , PIN[60] , GIN[60] , GIN[64] , PHI , POUT[56] , GOUT[64] );
endmodule


module DBLC_3_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:56] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:48] POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   INVBLOCK U11 (GIN[1] , PHI , GOUT[1] );
   INVBLOCK U12 (GIN[2] , PHI , GOUT[2] );
   INVBLOCK U13 (GIN[3] , PHI , GOUT[3] );
   INVBLOCK U14 (GIN[4] , PHI , GOUT[4] );
   INVBLOCK U15 (GIN[5] , PHI , GOUT[5] );
   INVBLOCK U16 (GIN[6] , PHI , GOUT[6] );
   INVBLOCK U17 (GIN[7] , PHI , GOUT[7] );
   BLOCK2A U28 (PIN[0] , GIN[0] , GIN[8] , PHI , GOUT[8] );
   BLOCK2A U29 (PIN[1] , GIN[1] , GIN[9] , PHI , GOUT[9] );
   BLOCK2A U210 (PIN[2] , GIN[2] , GIN[10] , PHI , GOUT[10] );
   BLOCK2A U211 (PIN[3] , GIN[3] , GIN[11] , PHI , GOUT[11] );
   BLOCK2A U212 (PIN[4] , GIN[4] , GIN[12] , PHI , GOUT[12] );
   BLOCK2A U213 (PIN[5] , GIN[5] , GIN[13] , PHI , GOUT[13] );
   BLOCK2A U214 (PIN[6] , GIN[6] , GIN[14] , PHI , GOUT[14] );
   BLOCK2A U215 (PIN[7] , GIN[7] , GIN[15] , PHI , GOUT[15] );
   BLOCK2 U316 (PIN[0] , PIN[8] , GIN[8] , GIN[16] , PHI , POUT[0] , GOUT[16] );
   BLOCK2 U317 (PIN[1] , PIN[9] , GIN[9] , GIN[17] , PHI , POUT[1] , GOUT[17] );
   BLOCK2 U318 (PIN[2] , PIN[10] , GIN[10] , GIN[18] , PHI , POUT[2] , GOUT[18] );
   BLOCK2 U319 (PIN[3] , PIN[11] , GIN[11] , GIN[19] , PHI , POUT[3] , GOUT[19] );
   BLOCK2 U320 (PIN[4] , PIN[12] , GIN[12] , GIN[20] , PHI , POUT[4] , GOUT[20] );
   BLOCK2 U321 (PIN[5] , PIN[13] , GIN[13] , GIN[21] , PHI , POUT[5] , GOUT[21] );
   BLOCK2 U322 (PIN[6] , PIN[14] , GIN[14] , GIN[22] , PHI , POUT[6] , GOUT[22] );
   BLOCK2 U323 (PIN[7] , PIN[15] , GIN[15] , GIN[23] , PHI , POUT[7] , GOUT[23] );
   BLOCK2 U324 (PIN[8] , PIN[16] , GIN[16] , GIN[24] , PHI , POUT[8] , GOUT[24] );
   BLOCK2 U325 (PIN[9] , PIN[17] , GIN[17] , GIN[25] , PHI , POUT[9] , GOUT[25] );
   BLOCK2 U326 (PIN[10] , PIN[18] , GIN[18] , GIN[26] , PHI , POUT[10] , GOUT[26] );
   BLOCK2 U327 (PIN[11] , PIN[19] , GIN[19] , GIN[27] , PHI , POUT[11] , GOUT[27] );
   BLOCK2 U328 (PIN[12] , PIN[20] , GIN[20] , GIN[28] , PHI , POUT[12] , GOUT[28] );
   BLOCK2 U329 (PIN[13] , PIN[21] , GIN[21] , GIN[29] , PHI , POUT[13] , GOUT[29] );
   BLOCK2 U330 (PIN[14] , PIN[22] , GIN[22] , GIN[30] , PHI , POUT[14] , GOUT[30] );
   BLOCK2 U331 (PIN[15] , PIN[23] , GIN[23] , GIN[31] , PHI , POUT[15] , GOUT[31] );
   BLOCK2 U332 (PIN[16] , PIN[24] , GIN[24] , GIN[32] , PHI , POUT[16] , GOUT[32] );
   BLOCK2 U333 (PIN[17] , PIN[25] , GIN[25] , GIN[33] , PHI , POUT[17] , GOUT[33] );
   BLOCK2 U334 (PIN[18] , PIN[26] , GIN[26] , GIN[34] , PHI , POUT[18] , GOUT[34] );
   BLOCK2 U335 (PIN[19] , PIN[27] , GIN[27] , GIN[35] , PHI , POUT[19] , GOUT[35] );
   BLOCK2 U336 (PIN[20] , PIN[28] , GIN[28] , GIN[36] , PHI , POUT[20] , GOUT[36] );
   BLOCK2 U337 (PIN[21] , PIN[29] , GIN[29] , GIN[37] , PHI , POUT[21] , GOUT[37] );
   BLOCK2 U338 (PIN[22] , PIN[30] , GIN[30] , GIN[38] , PHI , POUT[22] , GOUT[38] );
   BLOCK2 U339 (PIN[23] , PIN[31] , GIN[31] , GIN[39] , PHI , POUT[23] , GOUT[39] );
   BLOCK2 U340 (PIN[24] , PIN[32] , GIN[32] , GIN[40] , PHI , POUT[24] , GOUT[40] );
   BLOCK2 U341 (PIN[25] , PIN[33] , GIN[33] , GIN[41] , PHI , POUT[25] , GOUT[41] );
   BLOCK2 U342 (PIN[26] , PIN[34] , GIN[34] , GIN[42] , PHI , POUT[26] , GOUT[42] );
   BLOCK2 U343 (PIN[27] , PIN[35] , GIN[35] , GIN[43] , PHI , POUT[27] , GOUT[43] );
   BLOCK2 U344 (PIN[28] , PIN[36] , GIN[36] , GIN[44] , PHI , POUT[28] , GOUT[44] );
   BLOCK2 U345 (PIN[29] , PIN[37] , GIN[37] , GIN[45] , PHI , POUT[29] , GOUT[45] );
   BLOCK2 U346 (PIN[30] , PIN[38] , GIN[38] , GIN[46] , PHI , POUT[30] , GOUT[46] );
   BLOCK2 U347 (PIN[31] , PIN[39] , GIN[39] , GIN[47] , PHI , POUT[31] , GOUT[47] );
   BLOCK2 U348 (PIN[32] , PIN[40] , GIN[40] , GIN[48] , PHI , POUT[32] , GOUT[48] );
   BLOCK2 U349 (PIN[33] , PIN[41] , GIN[41] , GIN[49] , PHI , POUT[33] , GOUT[49] );
   BLOCK2 U350 (PIN[34] , PIN[42] , GIN[42] , GIN[50] , PHI , POUT[34] , GOUT[50] );
   BLOCK2 U351 (PIN[35] , PIN[43] , GIN[43] , GIN[51] , PHI , POUT[35] , GOUT[51] );
   BLOCK2 U352 (PIN[36] , PIN[44] , GIN[44] , GIN[52] , PHI , POUT[36] , GOUT[52] );
   BLOCK2 U353 (PIN[37] , PIN[45] , GIN[45] , GIN[53] , PHI , POUT[37] , GOUT[53] );
   BLOCK2 U354 (PIN[38] , PIN[46] , GIN[46] , GIN[54] , PHI , POUT[38] , GOUT[54] );
   BLOCK2 U355 (PIN[39] , PIN[47] , GIN[47] , GIN[55] , PHI , POUT[39] , GOUT[55] );
   BLOCK2 U356 (PIN[40] , PIN[48] , GIN[48] , GIN[56] , PHI , POUT[40] , GOUT[56] );
   BLOCK2 U357 (PIN[41] , PIN[49] , GIN[49] , GIN[57] , PHI , POUT[41] , GOUT[57] );
   BLOCK2 U358 (PIN[42] , PIN[50] , GIN[50] , GIN[58] , PHI , POUT[42] , GOUT[58] );
   BLOCK2 U359 (PIN[43] , PIN[51] , GIN[51] , GIN[59] , PHI , POUT[43] , GOUT[59] );
   BLOCK2 U360 (PIN[44] , PIN[52] , GIN[52] , GIN[60] , PHI , POUT[44] , GOUT[60] );
   BLOCK2 U361 (PIN[45] , PIN[53] , GIN[53] , GIN[61] , PHI , POUT[45] , GOUT[61] );
   BLOCK2 U362 (PIN[46] , PIN[54] , GIN[54] , GIN[62] , PHI , POUT[46] , GOUT[62] );
   BLOCK2 U363 (PIN[47] , PIN[55] , GIN[55] , GIN[63] , PHI , POUT[47] , GOUT[63] );
   BLOCK2 U364 (PIN[48] , PIN[56] , GIN[56] , GIN[64] , PHI , POUT[48] , GOUT[64] );
endmodule


module DBLC_4_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:48] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:32] POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   INVBLOCK U11 (GIN[1] , PHI , GOUT[1] );
   INVBLOCK U12 (GIN[2] , PHI , GOUT[2] );
   INVBLOCK U13 (GIN[3] , PHI , GOUT[3] );
   INVBLOCK U14 (GIN[4] , PHI , GOUT[4] );
   INVBLOCK U15 (GIN[5] , PHI , GOUT[5] );
   INVBLOCK U16 (GIN[6] , PHI , GOUT[6] );
   INVBLOCK U17 (GIN[7] , PHI , GOUT[7] );
   INVBLOCK U18 (GIN[8] , PHI , GOUT[8] );
   INVBLOCK U19 (GIN[9] , PHI , GOUT[9] );
   INVBLOCK U110 (GIN[10] , PHI , GOUT[10] );
   INVBLOCK U111 (GIN[11] , PHI , GOUT[11] );
   INVBLOCK U112 (GIN[12] , PHI , GOUT[12] );
   INVBLOCK U113 (GIN[13] , PHI , GOUT[13] );
   INVBLOCK U114 (GIN[14] , PHI , GOUT[14] );
   INVBLOCK U115 (GIN[15] , PHI , GOUT[15] );
   BLOCK1A U216 (PIN[0] , GIN[0] , GIN[16] , PHI , GOUT[16] );
   BLOCK1A U217 (PIN[1] , GIN[1] , GIN[17] , PHI , GOUT[17] );
   BLOCK1A U218 (PIN[2] , GIN[2] , GIN[18] , PHI , GOUT[18] );
   BLOCK1A U219 (PIN[3] , GIN[3] , GIN[19] , PHI , GOUT[19] );
   BLOCK1A U220 (PIN[4] , GIN[4] , GIN[20] , PHI , GOUT[20] );
   BLOCK1A U221 (PIN[5] , GIN[5] , GIN[21] , PHI , GOUT[21] );
   BLOCK1A U222 (PIN[6] , GIN[6] , GIN[22] , PHI , GOUT[22] );
   BLOCK1A U223 (PIN[7] , GIN[7] , GIN[23] , PHI , GOUT[23] );
   BLOCK1A U224 (PIN[8] , GIN[8] , GIN[24] , PHI , GOUT[24] );
   BLOCK1A U225 (PIN[9] , GIN[9] , GIN[25] , PHI , GOUT[25] );
   BLOCK1A U226 (PIN[10] , GIN[10] , GIN[26] , PHI , GOUT[26] );
   BLOCK1A U227 (PIN[11] , GIN[11] , GIN[27] , PHI , GOUT[27] );
   BLOCK1A U228 (PIN[12] , GIN[12] , GIN[28] , PHI , GOUT[28] );
   BLOCK1A U229 (PIN[13] , GIN[13] , GIN[29] , PHI , GOUT[29] );
   BLOCK1A U230 (PIN[14] , GIN[14] , GIN[30] , PHI , GOUT[30] );
   BLOCK1A U231 (PIN[15] , GIN[15] , GIN[31] , PHI , GOUT[31] );
   BLOCK1 U332 (PIN[0] , PIN[16] , GIN[16] , GIN[32] , PHI , POUT[0] , GOUT[32] );
   BLOCK1 U333 (PIN[1] , PIN[17] , GIN[17] , GIN[33] , PHI , POUT[1] , GOUT[33] );
   BLOCK1 U334 (PIN[2] , PIN[18] , GIN[18] , GIN[34] , PHI , POUT[2] , GOUT[34] );
   BLOCK1 U335 (PIN[3] , PIN[19] , GIN[19] , GIN[35] , PHI , POUT[3] , GOUT[35] );
   BLOCK1 U336 (PIN[4] , PIN[20] , GIN[20] , GIN[36] , PHI , POUT[4] , GOUT[36] );
   BLOCK1 U337 (PIN[5] , PIN[21] , GIN[21] , GIN[37] , PHI , POUT[5] , GOUT[37] );
   BLOCK1 U338 (PIN[6] , PIN[22] , GIN[22] , GIN[38] , PHI , POUT[6] , GOUT[38] );
   BLOCK1 U339 (PIN[7] , PIN[23] , GIN[23] , GIN[39] , PHI , POUT[7] , GOUT[39] );
   BLOCK1 U340 (PIN[8] , PIN[24] , GIN[24] , GIN[40] , PHI , POUT[8] , GOUT[40] );
   BLOCK1 U341 (PIN[9] , PIN[25] , GIN[25] , GIN[41] , PHI , POUT[9] , GOUT[41] );
   BLOCK1 U342 (PIN[10] , PIN[26] , GIN[26] , GIN[42] , PHI , POUT[10] , GOUT[42] );
   BLOCK1 U343 (PIN[11] , PIN[27] , GIN[27] , GIN[43] , PHI , POUT[11] , GOUT[43] );
   BLOCK1 U344 (PIN[12] , PIN[28] , GIN[28] , GIN[44] , PHI , POUT[12] , GOUT[44] );
   BLOCK1 U345 (PIN[13] , PIN[29] , GIN[29] , GIN[45] , PHI , POUT[13] , GOUT[45] );
   BLOCK1 U346 (PIN[14] , PIN[30] , GIN[30] , GIN[46] , PHI , POUT[14] , GOUT[46] );
   BLOCK1 U347 (PIN[15] , PIN[31] , GIN[31] , GIN[47] , PHI , POUT[15] , GOUT[47] );
   BLOCK1 U348 (PIN[16] , PIN[32] , GIN[32] , GIN[48] , PHI , POUT[16] , GOUT[48] );
   BLOCK1 U349 (PIN[17] , PIN[33] , GIN[33] , GIN[49] , PHI , POUT[17] , GOUT[49] );
   BLOCK1 U350 (PIN[18] , PIN[34] , GIN[34] , GIN[50] , PHI , POUT[18] , GOUT[50] );
   BLOCK1 U351 (PIN[19] , PIN[35] , GIN[35] , GIN[51] , PHI , POUT[19] , GOUT[51] );
   BLOCK1 U352 (PIN[20] , PIN[36] , GIN[36] , GIN[52] , PHI , POUT[20] , GOUT[52] );
   BLOCK1 U353 (PIN[21] , PIN[37] , GIN[37] , GIN[53] , PHI , POUT[21] , GOUT[53] );
   BLOCK1 U354 (PIN[22] , PIN[38] , GIN[38] , GIN[54] , PHI , POUT[22] , GOUT[54] );
   BLOCK1 U355 (PIN[23] , PIN[39] , GIN[39] , GIN[55] , PHI , POUT[23] , GOUT[55] );
   BLOCK1 U356 (PIN[24] , PIN[40] , GIN[40] , GIN[56] , PHI , POUT[24] , GOUT[56] );
   BLOCK1 U357 (PIN[25] , PIN[41] , GIN[41] , GIN[57] , PHI , POUT[25] , GOUT[57] );
   BLOCK1 U358 (PIN[26] , PIN[42] , GIN[42] , GIN[58] , PHI , POUT[26] , GOUT[58] );
   BLOCK1 U359 (PIN[27] , PIN[43] , GIN[43] , GIN[59] , PHI , POUT[27] , GOUT[59] );
   BLOCK1 U360 (PIN[28] , PIN[44] , GIN[44] , GIN[60] , PHI , POUT[28] , GOUT[60] );
   BLOCK1 U361 (PIN[29] , PIN[45] , GIN[45] , GIN[61] , PHI , POUT[29] , GOUT[61] );
   BLOCK1 U362 (PIN[30] , PIN[46] , GIN[46] , GIN[62] , PHI , POUT[30] , GOUT[62] );
   BLOCK1 U363 (PIN[31] , PIN[47] , GIN[47] , GIN[63] , PHI , POUT[31] , GOUT[63] );
   BLOCK1 U364 (PIN[32] , PIN[48] , GIN[48] , GIN[64] , PHI , POUT[32] , GOUT[64] );
endmodule


module DBLC_5_64 ( PIN, GIN, PHI, POUT, GOUT );
   input  [0:32] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:0]  POUT;
   output [0:64] GOUT;
   INVBLOCK U10 (GIN[0] , PHI , GOUT[0] );
   INVBLOCK U11 (GIN[1] , PHI , GOUT[1] );
   INVBLOCK U12 (GIN[2] , PHI , GOUT[2] );
   INVBLOCK U13 (GIN[3] , PHI , GOUT[3] );
   INVBLOCK U14 (GIN[4] , PHI , GOUT[4] );
   INVBLOCK U15 (GIN[5] , PHI , GOUT[5] );
   INVBLOCK U16 (GIN[6] , PHI , GOUT[6] );
   INVBLOCK U17 (GIN[7] , PHI , GOUT[7] );
   INVBLOCK U18 (GIN[8] , PHI , GOUT[8] );
   INVBLOCK U19 (GIN[9] , PHI , GOUT[9] );
   INVBLOCK U110 (GIN[10] , PHI , GOUT[10] );
   INVBLOCK U111 (GIN[11] , PHI , GOUT[11] );
   INVBLOCK U112 (GIN[12] , PHI , GOUT[12] );
   INVBLOCK U113 (GIN[13] , PHI , GOUT[13] );
   INVBLOCK U114 (GIN[14] , PHI , GOUT[14] );
   INVBLOCK U115 (GIN[15] , PHI , GOUT[15] );
   INVBLOCK U116 (GIN[16] , PHI , GOUT[16] );
   INVBLOCK U117 (GIN[17] , PHI , GOUT[17] );
   INVBLOCK U118 (GIN[18] , PHI , GOUT[18] );
   INVBLOCK U119 (GIN[19] , PHI , GOUT[19] );
   INVBLOCK U120 (GIN[20] , PHI , GOUT[20] );
   INVBLOCK U121 (GIN[21] , PHI , GOUT[21] );
   INVBLOCK U122 (GIN[22] , PHI , GOUT[22] );
   INVBLOCK U123 (GIN[23] , PHI , GOUT[23] );
   INVBLOCK U124 (GIN[24] , PHI , GOUT[24] );
   INVBLOCK U125 (GIN[25] , PHI , GOUT[25] );
   INVBLOCK U126 (GIN[26] , PHI , GOUT[26] );
   INVBLOCK U127 (GIN[27] , PHI , GOUT[27] );
   INVBLOCK U128 (GIN[28] , PHI , GOUT[28] );
   INVBLOCK U129 (GIN[29] , PHI , GOUT[29] );
   INVBLOCK U130 (GIN[30] , PHI , GOUT[30] );
   INVBLOCK U131 (GIN[31] , PHI , GOUT[31] );
   BLOCK2A U232 (PIN[0] , GIN[0] , GIN[32] , PHI , GOUT[32] );
   BLOCK2A U233 (PIN[1] , GIN[1] , GIN[33] , PHI , GOUT[33] );
   BLOCK2A U234 (PIN[2] , GIN[2] , GIN[34] , PHI , GOUT[34] );
   BLOCK2A U235 (PIN[3] , GIN[3] , GIN[35] , PHI , GOUT[35] );
   BLOCK2A U236 (PIN[4] , GIN[4] , GIN[36] , PHI , GOUT[36] );
   BLOCK2A U237 (PIN[5] , GIN[5] , GIN[37] , PHI , GOUT[37] );
   BLOCK2A U238 (PIN[6] , GIN[6] , GIN[38] , PHI , GOUT[38] );
   BLOCK2A U239 (PIN[7] , GIN[7] , GIN[39] , PHI , GOUT[39] );
   BLOCK2A U240 (PIN[8] , GIN[8] , GIN[40] , PHI , GOUT[40] );
   BLOCK2A U241 (PIN[9] , GIN[9] , GIN[41] , PHI , GOUT[41] );
   BLOCK2A U242 (PIN[10] , GIN[10] , GIN[42] , PHI , GOUT[42] );
   BLOCK2A U243 (PIN[11] , GIN[11] , GIN[43] , PHI , GOUT[43] );
   BLOCK2A U244 (PIN[12] , GIN[12] , GIN[44] , PHI , GOUT[44] );
   BLOCK2A U245 (PIN[13] , GIN[13] , GIN[45] , PHI , GOUT[45] );
   BLOCK2A U246 (PIN[14] , GIN[14] , GIN[46] , PHI , GOUT[46] );
   BLOCK2A U247 (PIN[15] , GIN[15] , GIN[47] , PHI , GOUT[47] );
   BLOCK2A U248 (PIN[16] , GIN[16] , GIN[48] , PHI , GOUT[48] );
   BLOCK2A U249 (PIN[17] , GIN[17] , GIN[49] , PHI , GOUT[49] );
   BLOCK2A U250 (PIN[18] , GIN[18] , GIN[50] , PHI , GOUT[50] );
   BLOCK2A U251 (PIN[19] , GIN[19] , GIN[51] , PHI , GOUT[51] );
   BLOCK2A U252 (PIN[20] , GIN[20] , GIN[52] , PHI , GOUT[52] );
   BLOCK2A U253 (PIN[21] , GIN[21] , GIN[53] , PHI , GOUT[53] );
   BLOCK2A U254 (PIN[22] , GIN[22] , GIN[54] , PHI , GOUT[54] );
   BLOCK2A U255 (PIN[23] , GIN[23] , GIN[55] , PHI , GOUT[55] );
   BLOCK2A U256 (PIN[24] , GIN[24] , GIN[56] , PHI , GOUT[56] );
   BLOCK2A U257 (PIN[25] , GIN[25] , GIN[57] , PHI , GOUT[57] );
   BLOCK2A U258 (PIN[26] , GIN[26] , GIN[58] , PHI , GOUT[58] );
   BLOCK2A U259 (PIN[27] , GIN[27] , GIN[59] , PHI , GOUT[59] );
   BLOCK2A U260 (PIN[28] , GIN[28] , GIN[60] , PHI , GOUT[60] );
   BLOCK2A U261 (PIN[29] , GIN[29] , GIN[61] , PHI , GOUT[61] );
   BLOCK2A U262 (PIN[30] , GIN[30] , GIN[62] , PHI , GOUT[62] );
   BLOCK2A U263 (PIN[31] , GIN[31] , GIN[63] , PHI , GOUT[63] );
   BLOCK2 U364 (PIN[0] , PIN[32] , GIN[32] , GIN[64] , PHI , POUT[0] , GOUT[64] );
endmodule


module XORSTAGE_64 ( A, B, PBIT, PHI, CARRY, SUM, COUT );
   input  [0:63] A;
   input [0:63]  B;
   input 	 PBIT;
   input 	 PHI;
   input [0:64]  CARRY;
   output [0:63] SUM;
   output 	 COUT;
   XXOR1 U20 (A[0] , B[0] , CARRY[0] , PHI , SUM[0] );
   XXOR1 U21 (A[1] , B[1] , CARRY[1] , PHI , SUM[1] );
   XXOR1 U22 (A[2] , B[2] , CARRY[2] , PHI , SUM[2] );
   XXOR1 U23 (A[3] , B[3] , CARRY[3] , PHI , SUM[3] );
   XXOR1 U24 (A[4] , B[4] , CARRY[4] , PHI , SUM[4] );
   XXOR1 U25 (A[5] , B[5] , CARRY[5] , PHI , SUM[5] );
   XXOR1 U26 (A[6] , B[6] , CARRY[6] , PHI , SUM[6] );
   XXOR1 U27 (A[7] , B[7] , CARRY[7] , PHI , SUM[7] );
   XXOR1 U28 (A[8] , B[8] , CARRY[8] , PHI , SUM[8] );
   XXOR1 U29 (A[9] , B[9] , CARRY[9] , PHI , SUM[9] );
   XXOR1 U210 (A[10] , B[10] , CARRY[10] , PHI , SUM[10] );
   XXOR1 U211 (A[11] , B[11] , CARRY[11] , PHI , SUM[11] );
   XXOR1 U212 (A[12] , B[12] , CARRY[12] , PHI , SUM[12] );
   XXOR1 U213 (A[13] , B[13] , CARRY[13] , PHI , SUM[13] );
   XXOR1 U214 (A[14] , B[14] , CARRY[14] , PHI , SUM[14] );
   XXOR1 U215 (A[15] , B[15] , CARRY[15] , PHI , SUM[15] );
   XXOR1 U216 (A[16] , B[16] , CARRY[16] , PHI , SUM[16] );
   XXOR1 U217 (A[17] , B[17] , CARRY[17] , PHI , SUM[17] );
   XXOR1 U218 (A[18] , B[18] , CARRY[18] , PHI , SUM[18] );
   XXOR1 U219 (A[19] , B[19] , CARRY[19] , PHI , SUM[19] );
   XXOR1 U220 (A[20] , B[20] , CARRY[20] , PHI , SUM[20] );
   XXOR1 U221 (A[21] , B[21] , CARRY[21] , PHI , SUM[21] );
   XXOR1 U222 (A[22] , B[22] , CARRY[22] , PHI , SUM[22] );
   XXOR1 U223 (A[23] , B[23] , CARRY[23] , PHI , SUM[23] );
   XXOR1 U224 (A[24] , B[24] , CARRY[24] , PHI , SUM[24] );
   XXOR1 U225 (A[25] , B[25] , CARRY[25] , PHI , SUM[25] );
   XXOR1 U226 (A[26] , B[26] , CARRY[26] , PHI , SUM[26] );
   XXOR1 U227 (A[27] , B[27] , CARRY[27] , PHI , SUM[27] );
   XXOR1 U228 (A[28] , B[28] , CARRY[28] , PHI , SUM[28] );
   XXOR1 U229 (A[29] , B[29] , CARRY[29] , PHI , SUM[29] );
   XXOR1 U230 (A[30] , B[30] , CARRY[30] , PHI , SUM[30] );
   XXOR1 U231 (A[31] , B[31] , CARRY[31] , PHI , SUM[31] );
   XXOR1 U232 (A[32] , B[32] , CARRY[32] , PHI , SUM[32] );
   XXOR1 U233 (A[33] , B[33] , CARRY[33] , PHI , SUM[33] );
   XXOR1 U234 (A[34] , B[34] , CARRY[34] , PHI , SUM[34] );
   XXOR1 U235 (A[35] , B[35] , CARRY[35] , PHI , SUM[35] );
   XXOR1 U236 (A[36] , B[36] , CARRY[36] , PHI , SUM[36] );
   XXOR1 U237 (A[37] , B[37] , CARRY[37] , PHI , SUM[37] );
   XXOR1 U238 (A[38] , B[38] , CARRY[38] , PHI , SUM[38] );
   XXOR1 U239 (A[39] , B[39] , CARRY[39] , PHI , SUM[39] );
   XXOR1 U240 (A[40] , B[40] , CARRY[40] , PHI , SUM[40] );
   XXOR1 U241 (A[41] , B[41] , CARRY[41] , PHI , SUM[41] );
   XXOR1 U242 (A[42] , B[42] , CARRY[42] , PHI , SUM[42] );
   XXOR1 U243 (A[43] , B[43] , CARRY[43] , PHI , SUM[43] );
   XXOR1 U244 (A[44] , B[44] , CARRY[44] , PHI , SUM[44] );
   XXOR1 U245 (A[45] , B[45] , CARRY[45] , PHI , SUM[45] );
   XXOR1 U246 (A[46] , B[46] , CARRY[46] , PHI , SUM[46] );
   XXOR1 U247 (A[47] , B[47] , CARRY[47] , PHI , SUM[47] );
   XXOR1 U248 (A[48] , B[48] , CARRY[48] , PHI , SUM[48] );
   XXOR1 U249 (A[49] , B[49] , CARRY[49] , PHI , SUM[49] );
   XXOR1 U250 (A[50] , B[50] , CARRY[50] , PHI , SUM[50] );
   XXOR1 U251 (A[51] , B[51] , CARRY[51] , PHI , SUM[51] );
   XXOR1 U252 (A[52] , B[52] , CARRY[52] , PHI , SUM[52] );
   XXOR1 U253 (A[53] , B[53] , CARRY[53] , PHI , SUM[53] );
   XXOR1 U254 (A[54] , B[54] , CARRY[54] , PHI , SUM[54] );
   XXOR1 U255 (A[55] , B[55] , CARRY[55] , PHI , SUM[55] );
   XXOR1 U256 (A[56] , B[56] , CARRY[56] , PHI , SUM[56] );
   XXOR1 U257 (A[57] , B[57] , CARRY[57] , PHI , SUM[57] );
   XXOR1 U258 (A[58] , B[58] , CARRY[58] , PHI , SUM[58] );
   XXOR1 U259 (A[59] , B[59] , CARRY[59] , PHI , SUM[59] );
   XXOR1 U260 (A[60] , B[60] , CARRY[60] , PHI , SUM[60] );
   XXOR1 U261 (A[61] , B[61] , CARRY[61] , PHI , SUM[61] );
   XXOR1 U262 (A[62] , B[62] , CARRY[62] , PHI , SUM[62] );
   XXOR1 U263 (A[63] , B[63] , CARRY[63] , PHI , SUM[63] );
   BLOCK1A U1 (PBIT , CARRY[0] , CARRY[64] , PHI , COUT );
endmodule


module DBLCTREE_64 ( PIN, GIN, PHI, GOUT, POUT );
   input  [0:63] PIN;
   input [0:64]  GIN;
   input 	 PHI;
   output [0:64] GOUT;
   output [0:0]  POUT;
   wire [0:62] 	 INTPROP_0;
   wire [0:64] 	 INTGEN_0;
   wire [0:60] 	 INTPROP_1;
   wire [0:64] 	 INTGEN_1;
   wire [0:56] 	 INTPROP_2;
   wire [0:64] 	 INTGEN_2;
   wire [0:48] 	 INTPROP_3;
   wire [0:64] 	 INTGEN_3;
   wire [0:32] 	 INTPROP_4;
   wire [0:64] 	 INTGEN_4;
   DBLC_0_64 U_0 (.PIN(PIN) , .GIN(GIN) , .PHI(PHI) , .POUT(INTPROP_0) , .GOUT(INTGEN_0) );
   DBLC_1_64 U_1 (.PIN(INTPROP_0) , .GIN(INTGEN_0) , .PHI(PHI) , .POUT(INTPROP_1) , .GOUT(INTGEN_1) );
   DBLC_2_64 U_2 (.PIN(INTPROP_1) , .GIN(INTGEN_1) , .PHI(PHI) , .POUT(INTPROP_2) , .GOUT(INTGEN_2) );
   DBLC_3_64 U_3 (.PIN(INTPROP_2) , .GIN(INTGEN_2) , .PHI(PHI) , .POUT(INTPROP_3) , .GOUT(INTGEN_3) );
   DBLC_4_64 U_4 (.PIN(INTPROP_3) , .GIN(INTGEN_3) , .PHI(PHI) , .POUT(INTPROP_4) , .GOUT(INTGEN_4) );
   DBLC_5_64 U_5 (.PIN(INTPROP_4) , .GIN(INTGEN_4) , .PHI(PHI) , .POUT(POUT) , .GOUT(GOUT) );
endmodule


module DBLCADDER_64_64 ( OPA, OPB, CIN, PHI, SUM, COUT );
   input  [0:63] OPA;
   input [0:63]  OPB;
   input 	 CIN;
   input 	 PHI;
   output [0:63] SUM;
   output 	 COUT;
   wire [0:63] 	 INTPROP;
   wire [0:64] 	 INTGEN;
   wire [0:0] 	 PBIT;
   wire [0:64] 	 CARRY;
   PRESTAGE_64 U1 (OPA , OPB , CIN , PHI , INTPROP , INTGEN );
   DBLCTREE_64 U2 (INTPROP , INTGEN , PHI , CARRY , PBIT );
   XORSTAGE_64 U3 (OPA[0:63] , OPB[0:63] , PBIT[0] , PHI , CARRY[0:64] , SUM , COUT );
endmodule


module MULTIPLIER_33_32 ( MULTIPLICAND, MULTIPLIER, RST, CLK, PHI, RESULT );
   input  [0:32] MULTIPLICAND;
   input [0:31]  MULTIPLIER;
   input 	 RST;
   input 	 CLK;
   input 	 PHI;
   output [0:63] RESULT;
   wire [0:575]  PPBIT;
   wire [0:64] 	 INT_CARRY;
   wire [0:63] 	 INT_SUM;
   wire 	 LOGIC_ZERO;
   wire [0:63] 	 ARESULT;
   reg [0:63] 	 RESULT;
   assign LOGIC_ZERO = 0;
   BOOTHCODER_33_32 B (.OPA(MULTIPLICAND[0:32]) , .OPB(MULTIPLIER[0:31]) , .SUMMAND(PPBIT[0:575]) );
   WALLACE_33_32 W (.SUMMAND(PPBIT[0:575]) , .RST(RST), .CLK (CLK) , .CARRY(INT_CARRY[1:63]) , .SUM(INT_SUM[0:63]) );
   assign INT_CARRY[0] = LOGIC_ZERO;
   DBLCADDER_64_64 D (.OPA(INT_SUM[0:63]) , .OPB(INT_CARRY[0:63]) , .CIN (LOGIC_ZERO) , .PHI (PHI) , .SUM(ARESULT[0:63]), .COUT() );
   always @(posedge CLK or posedge RST)
     if (RST)
       RESULT <=  64'h0000_0000_0000_0000;
     else
       RESULT <= ARESULT;
endmodule


// 32x32 multiplier, no input/output registers
// Registers inside Wallace trees every 8 full adder levels,
// with first pipeline after level 4

module amultp2_32x32 ( X, Y, RST, CLK, P );
   input  [31:0] X;
   input [31:0]  Y;
   input 	 RST;
   input 	 CLK;
   output [63:0] P;
   wire [0:32] 	 A;
   wire [0:31] 	 B;
   wire [0:63] 	 Q;
   assign A[0] = X[0];
   assign A[1] = X[1];
   assign A[2] = X[2];
   assign A[3] = X[3];
   assign A[4] = X[4];
   assign A[5] = X[5];
   assign A[6] = X[6];
   assign A[7] = X[7];
   assign A[8] = X[8];
   assign A[9] = X[9];
   assign A[10] = X[10];
   assign A[11] = X[11];
   assign A[12] = X[12];
   assign A[13] = X[13];
   assign A[14] = X[14];
   assign A[15] = X[15];
   assign A[16] = X[16];
   assign A[17] = X[17];
   assign A[18] = X[18];
   assign A[19] = X[19];
   assign A[20] = X[20];
   assign A[21] = X[21];
   assign A[22] = X[22];
   assign A[23] = X[23];
   assign A[24] = X[24];
   assign A[25] = X[25];
   assign A[26] = X[26];
   assign A[27] = X[27];
   assign A[28] = X[28];
   assign A[29] = X[29];
   assign A[30] = X[30];
   assign A[31] = X[31];
   assign A[32] = X[31];
   assign B[0] = Y[0];
   assign B[1] = Y[1];
   assign B[2] = Y[2];
   assign B[3] = Y[3];
   assign B[4] = Y[4];
   assign B[5] = Y[5];
   assign B[6] = Y[6];
   assign B[7] = Y[7];
   assign B[8] = Y[8];
   assign B[9] = Y[9];
   assign B[10] = Y[10];
   assign B[11] = Y[11];
   assign B[12] = Y[12];
   assign B[13] = Y[13];
   assign B[14] = Y[14];
   assign B[15] = Y[15];
   assign B[16] = Y[16];
   assign B[17] = Y[17];
   assign B[18] = Y[18];
   assign B[19] = Y[19];
   assign B[20] = Y[20];
   assign B[21] = Y[21];
   assign B[22] = Y[22];
   assign B[23] = Y[23];
   assign B[24] = Y[24];
   assign B[25] = Y[25];
   assign B[26] = Y[26];
   assign B[27] = Y[27];
   assign B[28] = Y[28];
   assign B[29] = Y[29];
   assign B[30] = Y[30];
   assign B[31] = Y[31];
   assign P[0] = Q[0];
   assign P[1] = Q[1];
   assign P[2] = Q[2];
   assign P[3] = Q[3];
   assign P[4] = Q[4];
   assign P[5] = Q[5];
   assign P[6] = Q[6];
   assign P[7] = Q[7];
   assign P[8] = Q[8];
   assign P[9] = Q[9];
   assign P[10] = Q[10];
   assign P[11] = Q[11];
   assign P[12] = Q[12];
   assign P[13] = Q[13];
   assign P[14] = Q[14];
   assign P[15] = Q[15];
   assign P[16] = Q[16];
   assign P[17] = Q[17];
   assign P[18] = Q[18];
   assign P[19] = Q[19];
   assign P[20] = Q[20];
   assign P[21] = Q[21];
   assign P[22] = Q[22];
   assign P[23] = Q[23];
   assign P[24] = Q[24];
   assign P[25] = Q[25];
   assign P[26] = Q[26];
   assign P[27] = Q[27];
   assign P[28] = Q[28];
   assign P[29] = Q[29];
   assign P[30] = Q[30];
   assign P[31] = Q[31];
   assign P[32] = Q[32];
   assign P[33] = Q[33];
   assign P[34] = Q[34];
   assign P[35] = Q[35];
   assign P[36] = Q[36];
   assign P[37] = Q[37];
   assign P[38] = Q[38];
   assign P[39] = Q[39];
   assign P[40] = Q[40];
   assign P[41] = Q[41];
   assign P[42] = Q[42];
   assign P[43] = Q[43];
   assign P[44] = Q[44];
   assign P[45] = Q[45];
   assign P[46] = Q[46];
   assign P[47] = Q[47];
   assign P[48] = Q[48];
   assign P[49] = Q[49];
   assign P[50] = Q[50];
   assign P[51] = Q[51];
   assign P[52] = Q[52];
   assign P[53] = Q[53];
   assign P[54] = Q[54];
   assign P[55] = Q[55];
   assign P[56] = Q[56];
   assign P[57] = Q[57];
   assign P[58] = Q[58];
   assign P[59] = Q[59];
   assign P[60] = Q[60];
   assign P[61] = Q[61];
   assign P[62] = Q[62];
   assign P[63] = Q[63];
   MULTIPLIER_33_32 U1 (.MULTIPLICAND(A) , .MULTIPLIER(B) , .RST(RST), .CLK(CLK) , .PHI(1'b0) , .RESULT(Q) );
endmodule

/**
 * alu_definitions.v
 * File that contains all definitions used throughout alu
 * stage
 ***/





























 // _alu_definitions_v_

module simd(
      issue_source_reg1,
      issue_source_reg2,
      issue_source_reg3,
      issue_dest_reg1,
      issue_dest_reg2,
      issue_imm_value0,
      issue_imm_value1,
      issue_opcode,
      issue_wfid,
      issue_alu_select,
      vgpr_source1_data,
      vgpr_source2_data,
      vgpr_source3_data,
      sgpr_rd_data,
      exec_rd_exec_value,
      exec_rd_vcc_value,
      exec_rd_m0_value,
      exec_rd_scc_value,
      issue_instr_pc,
      rfa_queue_entry_serviced,
      vgpr_source1_rd_en,
      vgpr_source2_rd_en,
      vgpr_source3_rd_en,
      vgpr_source1_addr,
      vgpr_source2_addr,
      vgpr_source3_addr,
      vgpr_dest_addr,
      vgpr_dest_data,
      vgpr_wr_en,
      vgpr_wr_mask,
      exec_rd_wfid,
      exec_rd_en,
      exec_wr_vcc_wfid,
      exec_wr_vcc_en,
      exec_wr_vcc_value,
      sgpr_rd_en,
      sgpr_rd_addr,
      sgpr_wr_addr,
      sgpr_wr_en,
      sgpr_wr_data,
      sgpr_wr_mask,
      issue_alu_ready,
      vgpr_instr_done_wfid,
      vgpr_instr_done,
      rfa_queue_entry_valid,
      tracemon_retire_pc,
      clk,
      rst
 );

input clk;

input rst;

input issue_alu_select, exec_rd_scc_value, rfa_queue_entry_serviced;
input[5:0] issue_wfid;
input[11:0] issue_source_reg1, issue_source_reg2, issue_source_reg3,
         issue_dest_reg1, issue_dest_reg2;
input[15:0] issue_imm_value0;
input[31:0] issue_imm_value1, issue_opcode, sgpr_rd_data, exec_rd_m0_value,
         issue_instr_pc;
input[63:0] exec_rd_exec_value, exec_rd_vcc_value;
input[2047:0] vgpr_source1_data, vgpr_source2_data, vgpr_source3_data;

output vgpr_source1_rd_en, vgpr_source2_rd_en, vgpr_source3_rd_en, vgpr_wr_en,
         exec_rd_en, exec_wr_vcc_en, sgpr_rd_en, sgpr_wr_en, issue_alu_ready,
         vgpr_instr_done, rfa_queue_entry_valid;
output[5:0] exec_rd_wfid, exec_wr_vcc_wfid, vgpr_instr_done_wfid;
output[8:0] sgpr_rd_addr, sgpr_wr_addr;
output[9:0] vgpr_source1_addr, vgpr_source2_addr, vgpr_source3_addr,
         vgpr_dest_addr;
output[31:0] tracemon_retire_pc;
output[63:0] vgpr_wr_mask, exec_wr_vcc_value, sgpr_wr_data, sgpr_wr_mask;
output[2047:0] vgpr_dest_data;

alu #(.MODULE(0))
      alu(
      .issue_source_reg1(issue_source_reg1),
      .issue_source_reg2(issue_source_reg2),
      .issue_source_reg3(issue_source_reg3),
      .issue_dest_reg1(issue_dest_reg1),
      .issue_dest_reg2(issue_dest_reg2),
      .issue_imm_value0(issue_imm_value0),
      .issue_imm_value1(issue_imm_value1),
      .issue_opcode(issue_opcode),
      .issue_wfid(issue_wfid),
      .issue_alu_select(issue_alu_select),
      .vgpr_source1_data(vgpr_source1_data),
      .vgpr_source2_data(vgpr_source2_data),
      .vgpr_source3_data(vgpr_source3_data),
      .sgpr_rd_data(sgpr_rd_data),
      .exec_rd_exec_value(exec_rd_exec_value),
      .exec_rd_vcc_value(exec_rd_vcc_value),
      .exec_rd_m0_value(exec_rd_m0_value),
      .exec_rd_scc_value(exec_rd_scc_value),
      .issue_instr_pc(issue_instr_pc),
      .rfa_queue_entry_serviced(rfa_queue_entry_serviced),
      .vgpr_source1_rd_en(vgpr_source1_rd_en),
      .vgpr_source2_rd_en(vgpr_source2_rd_en),
      .vgpr_source3_rd_en(vgpr_source3_rd_en),
      .vgpr_source1_addr(vgpr_source1_addr),
      .vgpr_source2_addr(vgpr_source2_addr),
      .vgpr_source3_addr(vgpr_source3_addr),
      .vgpr_dest_addr(vgpr_dest_addr),
      .vgpr_dest_data(vgpr_dest_data),
      .vgpr_wr_en(vgpr_wr_en),
      .vgpr_wr_mask(vgpr_wr_mask),
      .exec_rd_wfid(exec_rd_wfid),
      .exec_rd_en(exec_rd_en),
      .exec_wr_vcc_wfid(exec_wr_vcc_wfid),
      .exec_wr_vcc_en(exec_wr_vcc_en),
      .exec_wr_vcc_value(exec_wr_vcc_value),
      .sgpr_rd_en(sgpr_rd_en),
      .sgpr_rd_addr(sgpr_rd_addr),
      .sgpr_wr_addr(sgpr_wr_addr),
      .sgpr_wr_en(sgpr_wr_en),
      .sgpr_wr_data(sgpr_wr_data),
      .sgpr_wr_mask(sgpr_wr_mask),
      .issue_alu_ready(issue_alu_ready),
      .vgpr_instr_done_wfid(vgpr_instr_done_wfid),
      .vgpr_instr_done(vgpr_instr_done),
      .rfa_queue_entry_valid(rfa_queue_entry_valid),
      .tracemon_retire_pc(tracemon_retire_pc),
      .clk(clk),
      .rst(rst)
 );
endmodule
module simd_alu
  (
   alu_source1_data,
   alu_source2_data,
   alu_source3_data, //TODO
   alu_source_vcc_value,
   alu_source_exec_value,
   alu_control,
   alu_start,
   alu_vgpr_dest_data,
   alu_sgpr_dest_data,
   alu_dest_vcc_value,
   alu_done,
   clk,
   rst
   );

   //TODO check overflow for signed and unsigned

   input clk;
   input rst;

   input [31:0]  alu_source1_data;
   input [31:0]  alu_source2_data;
   input [31:0]  alu_source3_data;
   input         alu_source_vcc_value;
   input         alu_source_exec_value;

   input [31:0]  alu_control;
   input         alu_start;

   output [31:0] alu_vgpr_dest_data;
   output        alu_sgpr_dest_data;
   output        alu_dest_vcc_value;
   output        alu_done;

   reg [31:0]    alu_vgpr_dest_data;
   reg           alu_dest_vcc_value;
   reg           alu_done;

   // Signals used by the multiplier
   reg [31:0]   mul_inp0_s;
   reg [31:0]   mul_inp1_s;
   wire [63:0]     mul_out_s;               // Combi output from multiplier
   reg [1:0]    mul_cycles_s;            // The current mult takes 4 cycles.
   wire   mul_busy_s;              // High 1 cycle after new mult, till done
   wire   mul_done_s;              // Pulse at end of computation
   reg       mul_op_s;                // Indicates multipler operation underway

   wire [31:0]     twos_complement_inp0_s;
   wire [31:0]     twos_complement_inp1_s;
	 wire [31:0]		 twos_complement_inp2_s; //VIN

   //TODO check logic

   reg [31:0] abs_signed_source1_data;
   reg [31:0] abs_signed_source2_data;
   reg [31:0] abs_signed_source3_data;
   reg [31:0] abs_unsigned_source1_data;
   reg [31:0] abs_unsigned_source2_data;
   reg [31:0] abs_unsigned_source3_data;
   reg [31:0] final_signed_source1_data;
   reg [31:0] final_signed_source2_data;
   reg [31:0] final_signed_source3_data;
   reg [31:0] final_unsigned_source1_data;
   reg [31:0] final_unsigned_source2_data;
   reg [31:0] final_unsigned_source3_data;
   
	 assign twos_complement_inp0_s = ~alu_source1_data + 32'd1;
   assign twos_complement_inp1_s = ~alu_source2_data + 32'd1;
   assign twos_complement_inp2_s = ~alu_source3_data + 32'd1;
   
	 assign alu_sgpr_dest_data = alu_dest_vcc_value;

   always @* begin
      casex(alu_control[31:24])
         {8'h10} :
            begin
               abs_signed_source1_data <= alu_control[17]
                                          ? (alu_source1_data[31] ? twos_complement_inp0_s : alu_source1_data)
                                          : alu_source1_data;
               abs_signed_source2_data <= alu_control[16]
                                          ? (alu_source2_data[31] ? twos_complement_inp1_s : alu_source2_data)
                                          : alu_source2_data;
               abs_signed_source3_data <= alu_control[15]
                                          ? (alu_source3_data[31] ? twos_complement_inp2_s : alu_source3_data)
                                          : alu_source3_data;
            end
         default : //VOP1, VOP2 and VOPC
            begin
              abs_signed_source1_data <= alu_source1_data;
              abs_signed_source2_data <= alu_source2_data;
              abs_signed_source3_data <= alu_source3_data;
            end
      endcase
   end // always @ (...

   always @* begin
      casex(alu_control[31:24])
         {8'h10} :
            begin
               final_signed_source1_data <= alu_control[23] ? (~abs_signed_source1_data + 32'd1) : abs_signed_source1_data;
               final_signed_source2_data <= alu_control[22] ? (~abs_signed_source2_data + 32'd1) : abs_signed_source2_data;
               final_signed_source3_data <= alu_control[21] ? (~abs_signed_source3_data + 32'd1) : abs_signed_source3_data;
							 final_unsigned_source1_data <= alu_control[23] ? twos_complement_inp0_s : alu_source1_data;
               final_unsigned_source2_data <= alu_control[22] ? twos_complement_inp1_s : alu_source2_data;
               final_unsigned_source3_data <= alu_control[21] ? twos_complement_inp2_s : alu_source3_data;
            end
         {8'h08} :
            begin
               final_signed_source1_data <= alu_control[23] ? (~abs_signed_source1_data + 32'd1) : abs_signed_source1_data;
               final_signed_source2_data <= alu_control[22] ? (~abs_signed_source2_data + 32'd1) : abs_signed_source2_data;
               final_signed_source3_data <= alu_control[21] ? (~abs_signed_source3_data + 32'd1) : abs_signed_source3_data;
               final_unsigned_source1_data <= alu_control[23] ? twos_complement_inp0_s : alu_source1_data;
               final_unsigned_source2_data <= alu_control[22] ? twos_complement_inp1_s : alu_source2_data;
               final_unsigned_source3_data <= alu_control[21] ? twos_complement_inp2_s : alu_source3_data;
            end
         default : //VOP1, VOP2 and VOPC
            begin
              final_signed_source1_data <= abs_signed_source1_data;
              final_signed_source2_data <= abs_signed_source2_data;
              final_signed_source3_data <= abs_signed_source3_data;
              final_unsigned_source1_data <= alu_source1_data;
              final_unsigned_source2_data <= alu_source2_data;
              final_unsigned_source3_data <= alu_source3_data;
            end
      endcase
   end // always @ (...

   always @* begin
      casex({alu_source_exec_value, alu_control[31:24], alu_control[11:0]})
         {1'b0, 8'h??, 12'h???} : //EXEC disabled
            begin
               alu_done <= 1'b0;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h02, 12'h001} : //VOP1: V_MOV_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source1_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h025} : //VOP2: V_ADD_I32
            begin
               alu_done <= 1'b1;
               {alu_dest_vcc_value, alu_vgpr_dest_data} <= final_signed_source1_data + final_signed_source2_data;
           end
         {1'b1, 8'h04, 12'h026} : //VOP2: V_SUB_I32
            begin
               alu_done <= 1'b1;
               {alu_dest_vcc_value, alu_vgpr_dest_data} <= final_signed_source1_data - final_signed_source2_data;
           end
         {1'b1, 8'h04, 12'h01B} : //VOP2: V_AND_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source1_data & alu_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h11B} : //VOP3A: V_AND_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source1_data & alu_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h01C} : //VOP2: V_OR_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source1_data | alu_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h01A} : //VOP2: V_LSHLREV_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source2_data << alu_source1_data[4:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h016} : //VOP2: V_LSHRREV_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source2_data >> alu_source1_data[4:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h018} : //VOP2: V_ASHRREV_I32 - VIN
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= final_signed_source2_data >> final_signed_source1_data[4:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h014} : //VOP2: V_MAX_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_unsigned_source1_data >= final_unsigned_source2_data) ? final_unsigned_source1_data : final_unsigned_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h012} : //VOP2: V_MAX_I32 - VIN
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_signed_source1_data >= final_signed_source2_data) ? final_signed_source1_data : final_signed_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
						end
         {1'b1, 8'h10, 12'h114} : //VOP3A: V_MAX_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_unsigned_source1_data >= final_unsigned_source2_data) ? final_unsigned_source1_data : final_unsigned_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h013} : //VOP2: V_MIN_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_unsigned_source1_data <= final_unsigned_source2_data) ? final_unsigned_source1_data : final_unsigned_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h113} : //VOP3A: V_MIN_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_unsigned_source1_data <= final_unsigned_source2_data) ? final_unsigned_source1_data : final_unsigned_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h000} : //VOP2: V_CNDMASK_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= alu_source_vcc_value ? alu_source2_data : alu_source1_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
            end
         {1'b1, 8'h01, 12'h080} : //VOPC: V_CMP_F_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
            end
         {1'b1, 8'h01, 12'h081} : //VOPC: V_CMP_LT_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data < final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h082} : //VOPC: V_CMP_EQ_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data == final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h083} : //VOPC: V_CMP_LE_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data <= final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h084} : //VOPC: V_CMP_GT_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data > final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h085} : //VOPC: V_CMP_LG_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data != final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h086} : //VOPC: V_CMP_GE_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data >= final_signed_source2_data);
            end
         {1'b1, 8'h01, 12'h087} : //VOPC: V_CMP_TRU_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
            end
         {1'b1, 8'h01, 12'h0C0} : //VOPC: V_CMP_F_U_32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
            end
         {1'b1, 8'h01, 12'h0C1} : //VOPC: V_CMP_LT_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} < {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C2} : //VOPC: V_CMP_EQ_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} == {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C3} : //VOPC: V_CMP_LE_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} <= {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C4} : //VOPC: V_CMP_GT_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} > {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C5} : //VOPC: V_CMP_LG_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} != {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C6} : //VOPC: V_CMP_GE_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} >= {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h01, 12'h0C7} : //VOPC: V_CMP_TRU_U_32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
            end
         {1'b1, 8'h10, 12'h080} : //VOP3a: V_CMP_F_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
            end
         {1'b1, 8'h10, 12'h081} : //VOP3a: V_CMP_LT_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data < final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h082} : //VOP3a: V_CMP_EQ_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data == final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h083} : //VOP3a: V_CMP_LE_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data <= final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h084} : //VOP3a: V_CMP_GT_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data > final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h085} : //VOP3a: V_CMP_LG_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data != final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h086} : //VOP3a: V_CMP_GE_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_signed_source1_data >= final_signed_source2_data);
            end
         {1'b1, 8'h10, 12'h087} : //VOP3a: V_CMP_TRU_I32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
            end
         {1'b1, 8'h10, 12'h0C0} : //VOP3a: V_CMP_F_U_32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
            end
         {1'b1, 8'h10, 12'h0C1} : //VOP3a: V_CMP_LT_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} < {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C2} : //VOP3a: V_CMP_EQ_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} == {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C3} : //VOP3a: V_CMP_LE_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} <= {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C4} : //VOP3a: V_CMP_GT_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} > {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C5} : //VOP3a: V_CMP_LG_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} != {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C6} : //VOP3a: V_CMP_GE_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= ({1'b0, final_unsigned_source1_data} >= {1'b0, final_unsigned_source2_data});
            end
         {1'b1, 8'h10, 12'h0C7} : //VOP3a: V_CMP_TRU_U_32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
            end
         {1'b1, 8'h10, 12'h16A} : //VOP3a: V_MUL_HI_U32 => /* D.u = (S0.u * S1.u)>>32 */ VCC not used
            begin
               alu_done <= mul_done_s;
               alu_vgpr_dest_data <= mul_out_s[63:32];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h009} : //VOP2: V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
            begin
               alu_done <= mul_done_s;
               alu_vgpr_dest_data <= mul_out_s[31:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h109} : //VOP3a: V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
            begin
               alu_done <= mul_done_s;
               alu_vgpr_dest_data <= mul_out_s[31:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h16B} : //VOP3a: V_MUL_LO_I32 => /* D.i = S0.i * S1.i. */ VCC not used
            begin
               // TODO-RAGHU-20130205 : When slicing, sign bit is missed.
               // FIXME
               alu_done <= mul_done_s;
               alu_vgpr_dest_data <= mul_out_s[31:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h169} : //VOP3a: V_MUL_LO_U32 => /* D.u = S0.u * S1.u. */ VCC not used
            begin
               alu_done <= mul_done_s;
               alu_vgpr_dest_data <= mul_out_s[31:0];
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h148} : //VOP3A: V_BFE_U32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_unsigned_source1_data >> final_unsigned_source2_data[4:0]) & ((1<<final_unsigned_source3_data[4:0])-1);
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h149} : //VOP3A: V_BFE_I32 - VIN //needs correct implmentation
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (final_signed_source1_data >>> final_signed_source2_data[4:0]) & ((1 <<< final_signed_source3_data[4:0])-1);
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h14A} : //VOP3A: V_BFI_B32
            begin
               alu_done <= 1'b1;
               alu_vgpr_dest_data <= (alu_source1_data & alu_source2_data) | (~alu_source1_data & alu_source3_data);
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h028} : //VOP2: V_ADDC_U32 - VIN
            begin
               alu_done <= 1'b1;
               {alu_dest_vcc_value, alu_vgpr_dest_data} <= final_unsigned_source1_data + final_unsigned_source2_data + alu_source_vcc_value;
						end
         {1'b1, 8'h04, 12'h027} : //VOP2: V_SUBREV_I32 - VIN
            begin
               alu_done <= 1'b1;
               {alu_dest_vcc_value, alu_vgpr_dest_data} <= final_signed_source2_data - final_signed_source1_data;
						end
         default :
            begin
               alu_done <= 1'b0;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'bx;
           end
      endcase
   end // always @ (...


   // Multiplier inputs
   always @* begin
      casex({alu_source_exec_value, alu_control[31:24], alu_control[11:0]})
         {1'b1, 8'h10, 12'h16A} : // V_MUL_HI_U32 => /* D.u = (S0.u * S1.u)>>32 */ VCC not used
            begin
               mul_op_s <= 1'b1;
               mul_inp0_s <= final_unsigned_source1_data;
               mul_inp1_s <= final_unsigned_source2_data;
            end
         {1'b1, 8'h04, 12'h009} : // V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
            begin
               mul_op_s <= 1'b1;
               // ISSUE-Ragh-20130205 : Assuming i24 => 31st bit is sign, [23:0] has data.
               if (alu_source1_data[31])
                  begin
                     mul_inp0_s[23:0] <= twos_complement_inp0_s[23:0];
                     mul_inp0_s[31:24] <= 'd0;
                  end
               else
                  begin
                     mul_inp0_s[23:0] <= alu_source1_data[23:0];
                     mul_inp0_s[31:24] <= 'd0;
                  end
               if (alu_source2_data[31])
                  begin
                     mul_inp1_s[23:0] <= twos_complement_inp1_s[23:0];
                     mul_inp1_s[31:24] <= 'd0;
                  end
               else
                  begin
                     mul_inp1_s[23:0] <= alu_source2_data[23:0];
                     mul_inp1_s[31:24] <= 'd0;
                  end
            end
         {1'b1, 8'h10, 12'h109} : // V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
            begin
               mul_op_s <= 1'b1;
               // ISSUE-Ragh-20130205 : Assuming i24 => 31st bit is sign, [23:0] has data.
               if (alu_source1_data[31])
                  begin
                     mul_inp0_s[23:0] <= twos_complement_inp0_s[23:0];
                     mul_inp0_s[31:24] <= 'd0;
                  end
               else
                  begin
                     mul_inp0_s[23:0] <= alu_source1_data[23:0];
                     mul_inp0_s[31:24] <= 'd0;
                  end
               if (alu_source2_data[31])
                  begin
                     mul_inp1_s[23:0] <= twos_complement_inp1_s[23:0];
                     mul_inp1_s[31:24] <= 'd0;
                  end
               else
                  begin
                     mul_inp1_s[23:0] <= alu_source1_data[23:0];
                     mul_inp1_s[31:24] <= 'd0;
                  end
            end
         {1'b1, 8'h10, 12'h16B} : // V_MUL_LO_I32 => /* D.i = S0.i * S1.i. */ VCC not used
            begin
               mul_op_s <= 1'b1;
               if (alu_source1_data[31])
                  mul_inp0_s <= twos_complement_inp0_s;
               else
                  mul_inp0_s <= alu_source1_data;
               if (alu_source2_data[31])
                  mul_inp1_s <= twos_complement_inp1_s;
               else
                  mul_inp1_s <= alu_source2_data;
            end
         {1'b1, 8'h10, 12'h169} : // V_MUL_LO_U32 => /* D.u = S0.u * S1.u. */ VCC not used
            begin
               mul_op_s <= 1'b1;
               mul_inp0_s <= alu_source1_data;
               mul_inp1_s <= alu_source2_data;
            end
         default :
            begin
               mul_op_s <= 1'b0;
               mul_inp0_s <= 'd0;
               mul_inp1_s <= 'd0;
            end
      endcase
   end // always @ (...




  // Booth multiplier from openrisc
  // amultp2_32x32 amultp2_32x32
  //   (
  //    .X(mul_inp0_s),
  //    .Y(mul_inp1_s),
  //    .RST(rst),
  //    .CLK(clk),
  //    .P(mul_out_s)
  //    );
  assign mul_out_s = mul_inp0_s * mul_inp1_s;

   assign mul_busy_s = |mul_cycles_s;
   assign mul_done_s = (mul_cycles_s == 2'd2);

   always @(posedge clk or posedge rst)
      if (rst)
         begin
            mul_cycles_s <= 'd0;
         end
      else
         begin
            if (~mul_op_s)
               begin
                  mul_cycles_s <= 'd0;
               end
            else
               begin
                  if (mul_cycles_s == 2'd2)
                     mul_cycles_s <= 'd0;
                  else
                     mul_cycles_s <= mul_cycles_s + 'd1;
               end
         end

endmodule
module simd_instr_decoder
  (/*AUTOARG*/
   // Outputs
   out_vcc_wr_en, out_vgpr_wr_en, out_sgpr_wr_en,
   // Inputs
   in_opcode, in_sgpr_dest_addr
   );

   input [31:0] in_opcode;
   input [11:0] in_sgpr_dest_addr;

   output 	out_vcc_wr_en;
   output 	out_vgpr_wr_en;
   output 	out_sgpr_wr_en;

   reg 		out_vcc_wr_en;
   reg 		out_vgpr_wr_en;
   reg 		out_sgpr_wr_en;

   reg 		temp_vcc_wr_en;
   reg 		temp_sgpr_wr_en;


   always @* begin
      casex({in_opcode[31:24], in_sgpr_dest_addr})
	{8'h10, 12'b1_1_1_0_0000_0001}:
          begin
             out_vcc_wr_en <= 1'b1;
             out_sgpr_wr_en <= 1'b0;
          end
	{8'h10, 12'b1_1_0_?????????}:
          begin
             out_vcc_wr_en <= 1'b0;
             out_sgpr_wr_en <= 1'b1;
          end
	default:
          begin
             out_vcc_wr_en <= temp_vcc_wr_en;
             out_sgpr_wr_en <= temp_sgpr_wr_en;
          end
      endcase
   end

 
always @ (in_opcode) begin
	casex(in_opcode)
		{8'h02, 12'h???, 12'h001} : //V_MOV_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h025} : //V_ADD_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h026} : //V_SUB_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h01B} : //V_AND_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h10, 12'h???, 12'h11B} : //V_AND_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h01C} : //V_OR_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h01A} : //V_LSHLREV_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h014} : //V_MAX_U32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h10, 12'h???, 12'h114} : //V_MAX_U32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h012} : //V_MAX_I32  - VIN
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h013} : //V_MIN_U32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h10, 12'h???, 12'h113} : //V_MIN_U32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h016} : //V_LSHRREV_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h018} : //V_ASHRREV_I32 - VIN
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h04, 12'h???, 12'h000} : //V_CNDMASK_B32
			begin
				temp_vcc_wr_en <= 1'b0;
				out_vgpr_wr_en <= 1'b1;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h080} : //V_CMP_F_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h081} : //V_CMP_LT_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h082} : //V_CMP_EQ_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h083} : //V_CMP_LE_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h084} : //V_CMP_GT_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h085} : //V_CMP_LG_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h086} : //V_CMP_GE_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h087} : //V_CMP_TRU_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C0} : //V_CMP_F_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C1} : //V_CMP_LT_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C2} : //V_CMP_EQ_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C3} : //V_CMP_LE_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C4} : //V_CMP_GT_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C5} : //V_CMP_LG_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C6} : //V_CMP_GE_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h01, 12'h???, 12'h0C7} : //V_CMP_TRU_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b0;
			end
		{8'h10, 12'h???, 12'h080} : //V_CMP_F_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h081} : //V_CMP_LT_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h082} : //V_CMP_EQ_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h083} : //V_CMP_LE_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h084} : //V_CMP_GT_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h085} : //V_CMP_LG_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h086} : //V_CMP_GE_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h087} : //V_CMP_TRU_I32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C0} : //V_CMP_F_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C1} : //V_CMP_LT_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C2} : //V_CMP_EQ_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C3} : //V_CMP_LE_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C4} : //V_CMP_GT_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C5} : //V_CMP_LG_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C6} : //V_CMP_GE_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
		{8'h10, 12'h???, 12'h0C7} : //V_CMP_TRU_U32
			begin
				temp_vcc_wr_en <= 1'b1;
				out_vgpr_wr_en <= 1'b0;
				temp_sgpr_wr_en <= 1'b1;
			end
      {8'h10, 12'h???, 12'h16A} : // V_MUL_HI_U32 => /* D.u = (S0.u * S1.u)>>32 */ VCC not used
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h04, 12'h???, 12'h009} : // V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h109} : // V_MUL_I32_I24 => /* D.i = S0.i[23:0] * S1.i[23:0]. */ VCC not used
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h16B} : // V_MUL_LO_I32 => /* D.i = S0.i * S1.i. */ VCC not used
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
       end
      {8'h10, 12'h???, 12'h169} : // V_MUL_LO_U32 => /* D.u = S0.u * S1.u. */ VCC not used
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h148} : // V_BFE_U32
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h149} : // V_BFE_I32 = VIN
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h14A} : // V_BFI_B32
         begin
         	temp_vcc_wr_en <= 1'b0;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
         end
      {8'h04, 12'h???, 12'h028} : // V_ADDC_U32 - VIN
         begin
         	temp_vcc_wr_en <= 1'b1;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
				 end
      {8'h04, 12'h???, 12'h027} : // V_SUBREV_I32 - VIN
         begin
         	temp_vcc_wr_en <= 1'b1;
         	out_vgpr_wr_en <= 1'b1;
         	temp_sgpr_wr_en <= 1'b0;
				 end
		default:
			begin
				temp_vcc_wr_en <= 1'bx;
				out_vgpr_wr_en <= 1'bx;
				temp_sgpr_wr_en <= 1'b0;
			end
	endcase
end

endmodule
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_addsub                                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  addition/subtraction entity for the addition/subtraction    ////
////  unit                                                        ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_addsub(
		  clk,
		  rst,
		  miaow_fpu_op_i,
		  fracta_i,
		  fractb_i,
		  signa_i,
		  signb_i,
		  fract_o,
		  sign_o);

   
   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;
   
   input clk;
   input rst;
   
   input miaow_fpu_op_i;   
   input [FRAC_WIDTH+4:0] fracta_i;
   input [FRAC_WIDTH+4:0] fractb_i;
   input 		  signa_i;
   input 		  signb_i;
   output reg [FRAC_WIDTH+4:0] fract_o;
   output reg 		       sign_o;
   
   wire [FRAC_WIDTH+4:0]       s_fracta_i;
   wire [FRAC_WIDTH+4:0]       s_fractb_i;
   wire [FRAC_WIDTH+4:0]       s_fract_o;
   wire 		       s_signa_i, s_signb_i, s_sign_o;   
   wire 		       s_miaow_fpu_op_i;
   
   wire 		       fracta_gt_fractb;
   wire 		       s_addop;
   
   assign s_fracta_i = fracta_i;
   assign s_fractb_i = fractb_i;
   assign s_signa_i  = signa_i;
   assign s_signb_i  = signb_i;
   assign s_miaow_fpu_op_i = miaow_fpu_op_i;
   
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  fract_o <= 'd0;
	  sign_o <= 1'b0;
       end
     else
       begin
	  fract_o <= s_fract_o;
	  sign_o <= s_sign_o;	
       end
   
   assign fracta_gt_fractb = s_fracta_i > s_fractb_i;
   
   // check if its a subtraction or an addition operation
   assign s_addop = ((s_signa_i ^ s_signb_i) & !s_miaow_fpu_op_i) |
		    ((s_signa_i ^~ s_signb_i) & s_miaow_fpu_op_i);
   
   // sign of result
   assign s_sign_o = ((s_fract_o == 28'd0) & !(s_signa_i & s_signb_i)) ? 1'b0 :
		     (!s_signa_i & (!fracta_gt_fractb & (miaow_fpu_op_i^s_signb_i)))|
		     (s_signa_i & (fracta_gt_fractb | (miaow_fpu_op_i^s_signb_i)));
   
   // add/substract
   assign s_fract_o = s_addop ?
		      (fracta_gt_fractb ? s_fracta_i - s_fractb_i :
		       s_fractb_i - s_fracta_i) :
		      s_fracta_i + s_fractb_i;
   
   
endmodule // miaow_fpu_addsub



//////////////////////////////////////////////////////////////////////
////                                                              ////
////  OR1200 FPU arith                                            ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Wrapper for floating point arithmetic units.                ////
////                                                              ////
////  To Do:                                                      ////
////   - lf.rem.s and lf.madd.s instruction support               ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_arith
  (
   clk,
   rst,
   opa_i,
   opb_i,
   miaow_fpu_op_i,
   rmode_i,
   output_o,
   start_i,
   ready_o,
   ine_o,
   overflow_o,
   underflow_o,
   div_zero_o,
   inf_o,
   zero_o,
   qnan_o,
   snan_o
   );

   parameter FP_WIDTH = 32;
   // C-RAGHU-20130205 : removed parallel mul form design. 
   parameter MUL_COUNT = 34; // Number of cycles taken 
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b11111111_10000000000000000000000;
   parameter SNAN = 31'b11111111_00000000000000000000001;

   // fpu operations (miaow_fpu_op_i):
   // ========================
   // 000 = add, 
   // 001 = substract, 
   // 010 = multiply, 
   // 011 = divide,
   // 100 = square root - DISABLED - JPB
   // 101 = unused
   // 110 = unused
   // 111 = unused

   // Rounding Mode: 
   // ==============
   // 00 = round to nearest even (default), 
   // 01 = round to zero, 
   // 10 = round up, 
   // 11 = round down
   
   input  clk;
   input  rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   input [2:0] 		miaow_fpu_op_i;
   input [1:0] 		rmode_i;
   input 		start_i;
   output reg 		ready_o;
   output reg [FP_WIDTH-1:0] output_o;
   output reg 		     ine_o;
   output reg 		     overflow_o;
   output reg 		     underflow_o;
   output reg 		     div_zero_o;
   output reg 		     inf_o;
   output reg 		     zero_o;
   output reg 		     qnan_o;
   output reg 		     snan_o;

   reg [FP_WIDTH-1:0] 	     s_opa_i;
   reg [FP_WIDTH-1:0] 	     s_opb_i;
   reg [2:0] 		     s_miaow_fpu_op_i;
   reg [1:0] 		     s_rmode_i;
   reg 			     s_start_i;
   reg [5:0] 		     s_count; // Max value of 64

   reg [FP_WIDTH-1:0] 	     s_output1;   
   reg [FP_WIDTH-1:0] 	     s_output_o; // Comb
   
   reg 			     s_ine_o;
   
   wire 		     s_overflow_o, 
			     s_underflow_o, 
			     s_div_zero_o, 
			     s_inf_o, s_zero_o, s_qnan_o, s_snan_o;

   wire 		     s_infa, s_infb;
   
   parameter t_state_waiting = 0,
	       t_state_busy = 1;
   
   reg 			     s_state;
   
   ////	***Add/Substract units signals***
   wire [27:0] 		     prenorm_addsub_fracta_28_o;
   wire [27:0] 		     prenorm_addsub_fractb_28_o;
   
   wire [7:0] 		     prenorm_addsub_exp_o; 
   
   wire [27:0] 		     addsub_fract_o; 
   wire 		     addsub_sign_o;
   
   wire [31:0] 		     postnorm_addsub_output_o; 
   wire 		     postnorm_addsub_ine_o;
   
   ////	***Multiply units signals***
   
   wire [9:0] 		     pre_norm_mul_exp_10;
   wire [23:0] 		     pre_norm_mul_fracta_24 ;
   wire [23:0] 		     pre_norm_mul_fractb_24 ;
   wire [47:0] 		     mul_fract_48;
   wire [47:0] 		     mul_24_fract_48;
   wire 		     mul_24_sign;   
   wire [47:0] 		     serial_mul_fract_48;
   wire 		     serial_mul_sign;   
   wire 		     mul_sign;
   wire [31:0] 		     post_norm_mul_output   ;
   wire 		     post_norm_mul_ine;
   
   
   ////	***Division units signals***
   
   wire [49:0] 		     pre_norm_div_dvdnd;
   wire [26:0] 		     pre_norm_div_dvsor;
   wire [EXP_WIDTH+1:0]      pre_norm_div_exp;   
   wire [26:0] 		     serial_div_qutnt;
   wire [26:0] 		     serial_div_rmndr;
   wire 		     serial_div_sign;   
   wire 		     serial_div_div_zero;
   wire [31:0] 		     post_norm_div_output;
   wire 		     post_norm_div_ine;
   
   
   ////	***Square units***
   
   wire [51:0] 		     pre_norm_sqrt_fracta_o;   
   wire [7:0] 		     pre_norm_sqrt_exp_o;   
   wire [25:0] 		     sqrt_sqr_o;
   wire 		     sqrt_ine_o;
   
   wire [31:0] 		     post_norm_sqrt_output  ;
   wire 		     post_norm_sqrt_ine_o;

   wire [31:0] 		     intfloat_conv_output_s;
   wire 		     intfloat_conv_ine_s;
   
   //***Add/Substract units***
   
   miaow_fpu_pre_norm_addsub miaow_fpu_prenorm_addsub
     (
      .clk(clk)  ,
      .rst(rst),
      .opa_i(s_opa_i)  ,
      .opb_i(s_opb_i)  ,
      .fracta_28_o(prenorm_addsub_fracta_28_o)  ,
      .fractb_28_o(prenorm_addsub_fractb_28_o)  ,
      .exp_o(prenorm_addsub_exp_o) );
   
   miaow_fpu_addsub miaow_fpu_addsub
     (      
	    .clk(clk)  ,
 	    .rst(rst), 
	    .miaow_fpu_op_i(s_miaow_fpu_op_i[0]),		 
	    .fracta_i(prenorm_addsub_fracta_28_o)	 ,	
	    .fractb_i(prenorm_addsub_fractb_28_o)	 ,		
	    .signa_i( s_opa_i[31]),			
	    .signb_i( s_opb_i[31]),				
	    .fract_o(addsub_fract_o)  ,			
	    .sign_o(addsub_sign_o)  );	
   
   miaow_fpu_post_norm_addsub miaow_fpu_postnorm_addsub
     (
      .clk(clk)  ,
      .rst(rst),
      
      .opa_i(s_opa_i)  ,
      .opb_i(s_opb_i)  ,	
      .fract_28_i(addsub_fract_o)  ,
      .exp_i(prenorm_addsub_exp_o)  ,
      .sign_i(addsub_sign_o)  ,
      .miaow_fpu_op_i(s_miaow_fpu_op_i[0]), 
      .rmode_i(s_rmode_i)  ,
      .output_o(postnorm_addsub_output_o)  ,
      .ine_o(postnorm_addsub_ine_o)  
      );
   
   //***Multiply units***
   
   miaow_fpu_pre_norm_mul miaow_fpu_pre_norm_mul
     (
      .clk(clk),
      .rst(rst),
      .opa_i(s_opa_i),
      .opb_i(s_opb_i),
      .exp_10_o(pre_norm_mul_exp_10),
      .fracta_24_o(pre_norm_mul_fracta_24),
      .fractb_24_o(pre_norm_mul_fractb_24));

   // Serial multiply is default and only one included here
   miaow_fpu_mul miaow_fpu_mul
     (
      .clk(clk)  ,
      .rst(rst),
      .fracta_i(pre_norm_mul_fracta_24)  ,
      .fractb_i(pre_norm_mul_fractb_24)  ,
      .signa_i(s_opa_i[31]),
      .signb_i(s_opb_i[31]),
      .start_i(s_start_i)  ,
      .fract_o(serial_mul_fract_48)  ,
      .sign_o(serial_mul_sign) 	,
      .ready_o()
      );
   
   miaow_fpu_post_norm_mul miaow_fpu_post_norm_mul
     (
      .clk(clk)  ,
      .rst(rst),
      .opa_i(s_opa_i)  ,
      .opb_i(s_opb_i)  ,
      .exp_10_i(pre_norm_mul_exp_10)  ,
      .fract_48_i(serial_mul_fract_48)	 , // Parallel multiplier input
      .sign_i(serial_mul_sign)	 , // Parallel multiplier input
      .rmode_i(s_rmode_i)  ,
      .output_o(post_norm_mul_output)  ,
      .ine_o(post_norm_mul_ine)  
      );
   
   ////***Division units***
      
   miaow_fpu_pre_norm_div miaow_fpu_pre_norm_div
     (
      .clk(clk)  ,
      .rst(rst),
      .opa_i(s_opa_i)  ,
      .opb_i(s_opb_i)  ,
      .exp_10_o(pre_norm_div_exp)  ,
      .dvdnd_50_o(pre_norm_div_dvdnd)	 ,
      .dvsor_27_o(pre_norm_div_dvsor)	 );
   
   miaow_fpu_div miaow_fpu_div
     (
      .clk(clk) ,
      .rst(rst),
      .dvdnd_i(pre_norm_div_dvdnd)  ,
      .dvsor_i(pre_norm_div_dvsor)  ,
      .sign_dvd_i(s_opa_i[31]),
      .sign_div_i(s_opb_i[31]),
      .start_i(s_start_i)  ,
      .ready_o()  ,
      .qutnt_o(serial_div_qutnt)  ,
      .rmndr_o(serial_div_rmndr)  ,
      .sign_o(serial_div_sign)  ,
      .div_zero_o(serial_div_div_zero)	 );
   
   miaow_fpu_post_norm_div miaow_fpu_post_norm_div
     (
      .clk(clk)  ,
      .rst(rst),
      .opa_i(s_opa_i)  ,
      .opb_i(s_opb_i)  ,
      .qutnt_i(serial_div_qutnt) 	,
      .rmndr_i(serial_div_rmndr)  ,
      .exp_10_i(pre_norm_div_exp)  ,
      .sign_i(serial_div_sign)	 ,
      .rmode_i(s_rmode_i) 	,
      .output_o(post_norm_div_output)  ,
      .ine_o(post_norm_div_ine)  );

   // This block 
   // TODO-RAGHU-20130205 : verify that the block has flops internally.   
   miaow_fpu_intfloat_conv miaow_fpu_intfloat_conv
     (
      .clk(clk),
      .rst(rst),
      .rmode(s_rmode_i),
      .miaow_fpu_op(miaow_fpu_op_i),
      .opa(opa_i),
      .out(intfloat_conv_output_s),
      .snan(),
      .ine(intfloat_conv_ine_s),
      .inv(),
      .overflow(),
      .underflow(),
      .zero()
      );
   
   //////////////////////////////////////////////////////////////////-

   // Input Registers
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_opa_i <= 'd0;
	  s_opb_i <= 'd0;
	  s_miaow_fpu_op_i <= 'd0;
	  s_rmode_i <= 'd0;
	  s_start_i <= 1'b0;
       end
     else
       begin
	  s_opa_i <= opa_i;
	  s_opb_i <= opb_i;
	  s_miaow_fpu_op_i <= miaow_fpu_op_i;
	  s_rmode_i <= rmode_i;
	  s_start_i <= start_i;
       end
   
   // Output registers
   always @(posedge clk or posedge rst)
     if (rst)
       begin
          output_o <= 'd0;
	  ine_o <= 1'b0;
	  overflow_o <= 1'b0;
	  underflow_o <= 1'b0;
	  div_zero_o <= 1'b0;
	  inf_o <= 1'b0;
	  zero_o <= 1'b0;
	  qnan_o <= 1'b0;
	  snan_o <= 1'b0;
       end
     else
       begin
	  output_o <= s_output_o;
	  ine_o <= s_ine_o;
	  overflow_o <= s_overflow_o;
	  underflow_o <= s_underflow_o;
	  div_zero_o <= s_div_zero_o & !s_infa;
	  inf_o <= s_inf_o;
	  zero_o <= s_zero_o;
	  qnan_o <= s_qnan_o;
	  snan_o <= s_snan_o;
       end

   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_state <= t_state_waiting;
	  s_count <= 0;
	  ready_o <= 1'b0;
       end
     else
       begin
	  if (s_start_i)  begin
	     s_state <= t_state_busy;
	     s_count <= 0;
	  end
	  else if (s_state == t_state_busy) begin
	     // Ready cases
	     if (((s_count == 6) & ((miaow_fpu_op_i==3'd0) | (miaow_fpu_op_i==3'd1))) |
		 ((s_count==MUL_COUNT) & (miaow_fpu_op_i==3'd2)) |
		 ((s_count==33) & (miaow_fpu_op_i==3'd3)) |
		 ((s_count==5) & (miaow_fpu_op_i == 3'd4)) |
		 ((s_count==5) & (miaow_fpu_op_i == 3'd5))) 
	       begin
		  s_state <= t_state_waiting;
		  ready_o <= 1;
		  s_count <= 0;
	       end
	     else
	       s_count <= s_count + 1;
	  end // if (s_state == t_state_busy)
	  else begin
	     s_state <= t_state_waiting;
	     ready_o <= 0;
	  end // else: !if(s_state == t_state_busy)
       end // else: !if(s_start_i)
   
   //// Output Multiplexer
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_output_o <= 'd0;
	  s_ine_o <= 1'b0;
       end
     else
       begin
	  case(miaow_fpu_op_i)
	    3'd0,
	      3'd1: begin
		 s_output_o <= postnorm_addsub_output_o;
		 s_ine_o <= postnorm_addsub_ine_o;
	      end
	    3'd2: begin
	       s_output_o <= post_norm_mul_output;
	       s_ine_o <= post_norm_mul_ine;
	    end
	    3'd3: begin
	       s_output_o <= post_norm_div_output;
	       s_ine_o <= post_norm_div_ine;
	    end
	    3'd4, 3'd5 : begin
	       s_output_o <= intfloat_conv_output_s;
	       s_ine_o <= intfloat_conv_ine_s;
	    end
	    //	  3'd4: begin
	    //	        s_output_o 	<= post_norm_sqrt_output;
	    //		s_ine_o 	<= post_norm_sqrt_ine_o;
	    //	end
	    default: begin
	       s_output_o <= 0;
	       s_ine_o <= 0;
	    end
	  endcase // case (miaow_fpu_op_i)
       end // always @ (posedge clk or posedge rst)
   
   // Infinte exponent
   assign s_infa = &s_opa_i[30:23];
   assign s_infb = &s_opb_i[30:23];

   /*always @*
     begin
	if (s_rmode_i==2'd0 | s_div_zero_o | s_infa | s_infb | s_qnan_o |
	    s_qnan_o) // Round to nearest even
	  s_output_o = s_output1;
	else if (s_rmode_i==2'd1 & (&s_output1[30:23]))
	  // In round-to-zero: the sum of two non-infinity operands is never 
	  // infinity,even if an overflow occures
	  s_output_o = {s_output1[31], 31'b1111111_01111111_11111111_11111111};
	else if (s_rmode_i==2'd2 & (&s_output1[31:23]))
	  // In round-up: the sum of two non-infinity operands is never 
	  // negative infinity,even if an overflow occures
	  s_output_o = {32'b11111111_01111111_11111111_11111111};
	else if (s_rmode_i==2'd3) begin
	   if (((s_miaow_fpu_op_i==3'd0) | (s_miaow_fpu_op_i==3'd1)) & s_zero_o & 
	       (s_opa_i[31] | (s_miaow_fpu_op_i[0] ^ s_opb_i[31])))
	     // In round-down: a-a= -0
	     s_output_o = {1'b1,s_output1[30:0]};
	   else if (s_output1[31:23]==9'b0_11111111)
	     s_output_o = 32'b01111111011111111111111111111111;
	   else
	     s_output_o = s_output1;
	end
	else
	  s_output_o = s_output1;
     end // always @ */

   // Exception generation
   assign s_underflow_o = (s_output1[30:23]==8'h00) & s_ine_o;
   assign s_overflow_o = (s_output1[30:23]==8'hff) & s_ine_o;
   assign s_div_zero_o = serial_div_div_zero & miaow_fpu_op_i==3'd3;
   assign s_inf_o = s_output1[30:23]==8'hff & !(s_qnan_o | s_snan_o);
   assign s_zero_o = !(|s_output1[30:0]);
   assign s_qnan_o = s_output1[30:0]==QNAN;
   assign s_snan_o = s_output1[30:0]==SNAN;

endmodule // miaow_fpu_arith


//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_div                                              ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  division entity for the division unit                       ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_div
  (
   clk,
   rst,
   dvdnd_i,
   dvsor_i,
   sign_dvd_i,
   sign_div_i,
   start_i,
   ready_o,
   qutnt_o,
   rmndr_o,
   sign_o,
   div_zero_o
   );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;


   input clk;
   input rst;
   input [2*(FRAC_WIDTH+2)-1:0] dvdnd_i;
   input [FRAC_WIDTH+3:0] 	dvsor_i;
   input 			sign_dvd_i;
   input 			sign_div_i;
   input 			start_i;
   output 			ready_o;
   output [FRAC_WIDTH+3:0] 	qutnt_o;
   output [FRAC_WIDTH+3:0] 	rmndr_o;
   output 			sign_o;
   output 			div_zero_o;
   
   parameter t_state_waiting = 1'b0,
	       t_state_busy = 1'b1;
   
   reg [FRAC_WIDTH+3:0] 	s_qutnt_o;
   reg [FRAC_WIDTH+3:0] 	s_rmndr_o;   
   reg [2*(FRAC_WIDTH+2)-1:0] 	s_dvdnd_i;   
   reg [FRAC_WIDTH+3:0] 	s_dvsor_i;
   reg 				s_sign_dvd_i, s_sign_div_i;
   wire 			s_sign_o;
   wire 			s_div_zero_o;
   reg 				s_start_i;
   reg 				s_ready_o;
   reg 				s_state;
   reg [4:0] 			s_count;
   reg [FRAC_WIDTH+3:0] 	s_dvd;

   // Input Register
   always @(posedge clk or posedge rst)
     if (rst)
       begin
          s_dvdnd_i <= 'd0;
	  s_dvsor_i <= 'd0;
	  s_sign_dvd_i<= 1'b0;
	  s_sign_div_i<= 1'b0;
	  s_start_i <= 1'b0;
       end
     else
       begin
	  s_dvdnd_i <= dvdnd_i;
	  s_dvsor_i <= dvsor_i;
	  s_sign_dvd_i<= sign_dvd_i;
	  s_sign_div_i<= sign_div_i;
	  s_start_i <= start_i;
       end
   
   assign qutnt_o = s_qutnt_o;
   assign rmndr_o = s_rmndr_o;
   assign sign_o = s_sign_o;	
   assign ready_o = s_ready_o;
   assign div_zero_o = s_div_zero_o;

   assign s_sign_o = sign_dvd_i ^ sign_div_i;
   assign s_div_zero_o = !(|s_dvsor_i) & (|s_dvdnd_i);
   

   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_state <= t_state_waiting;
	  s_count <= 0;
	  s_ready_o <= 0;
       end
     else
       if (s_start_i)
	 begin
	    s_state <= t_state_busy;
	    s_count <= 26;
	 end
       else if (!(|s_count) & s_state==t_state_busy)
	 begin
	    s_state <= t_state_waiting;
	    s_ready_o <= 1;
	    s_count <=26;
	 end
       else if (s_state==t_state_busy)
	 s_count <= s_count - 1;
       else
	 begin
	    s_state <= t_state_waiting;
	    s_ready_o <= 0;
	 end

   wire [26:0] v_div;
   assign v_div = (s_count==26) ? {3'd0,s_dvdnd_i[49:26]} : s_dvd;
   wire [26:0] v_div_minus_s_dvsor_i;
   assign v_div_minus_s_dvsor_i = v_div - s_dvsor_i;
   

   always @(posedge clk or posedge rst)
     begin
	if (rst)
	  begin
	     s_qutnt_o <= 0;
	     s_rmndr_o <= 0;
	  end
	else
	  if (s_start_i)
	    begin
	       s_qutnt_o <= 0;
	       s_rmndr_o <= 0;
	    end
	  else if (s_state==t_state_busy)
	    begin
	       
	       if (v_div < s_dvsor_i)
		 begin
		    s_qutnt_o[s_count] <= 1'b0;
		    s_dvd <= {v_div[25:0],1'b0};		  
		 end
	       else
		 begin
		    s_qutnt_o[s_count] <= 1'b1;
		    s_dvd <= {v_div_minus_s_dvsor_i[25:0],1'b0};		  
		 end
	       
	       s_rmndr_o <= v_div;
	       
	    end // if (s_state==t_state_busy)
     end // always @ (posedge clk or posedge rst)
   
endmodule // miaow_fpu_div

/////////////////////////////////////////////////////////////////////
////                                                             ////
////  miaow_fpu_intfloat_conv                                   ////
////  Only conversion between 32-bit integer and single          ////
////  precision floating point format                            ////
////                                                             ////
////  Author: Rudolf Usselmann                                   ////
////          rudi@asics.ws                                      ////
////                                                             ////
//// Modified by Julius Baxter, July, 2010                       ////
////             julius.baxter@orsoc.se                          ////
////                                                             ////
//// TODO: Fix bug where 1.0f in round up goes to integer 2      ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2000 Rudolf Usselmann                         ////
////                    rudi@asics.ws                            ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////
//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////
//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////
//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////
//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////
//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////
//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////
//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////
//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////
//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////
//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////
//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////
//// POSSIBILITY OF SUCH DAMAGE.                                 ////
////                                                             ////
/////////////////////////////////////////////////////////////////////

/*

 FPU Operations (miaow_fpu_op):
 ========================

 0 = 
 1 = 
 2 = 
 3 = 
 4 = int to float
 5 = float to int
 6 =
 7 =

 Rounding Modes (rmode):
 =======================

 0 = round_nearest_even
 1 = round_to_zero
 2 = round_up
 3 = round_down

 */


module miaow_fpu_intfloat_conv
  ( 
    clk, rst, rmode, miaow_fpu_op, opa, out, snan, ine, inv,
    overflow, underflow, zero
    );
   input		clk;
   input 		rst;
   
   input [1:0] 		rmode;
   input [2:0] 		miaow_fpu_op;
   input [31:0] 	opa;
   output [31:0] 	out;
   output		snan;   
   output		ine;
   output 		inv;   
   output 		overflow;
   output 		underflow;   
   output		zero;


   parameter	INF  = 31'h7f800000,
		  QNAN = 31'h7fc00001,
		  SNAN = 31'h7f800001;

   ////////////////////////////////////////////////////////////////////////
   //
   // Local Wires
   //
   reg 			zero;
   reg [31:0] 		opa_r;	// Input operand registers
   reg [31:0] 		out;		// Output register
   reg 			div_by_zero;	// Divide by zero output register
   wire [7:0] 		exp_fasu;	// Exponent output from EQU block
   reg [7:0] 		exp_r;		// Exponent output (registerd)
   wire 		co;		// carry output
   wire [30:0] 		out_d;		// Intermediate final result output
   wire 		overflow_d, underflow_d;// Overflow/Underflow
   reg 			inf, snan, qnan;// Output Registers for INF, S/QNAN
   reg 			ine;		// Output Registers for INE
   reg [1:0] 		rmode_r1, rmode_r2,// Pipeline registers for round mode
			rmode_r3;
   reg [2:0] 		miaow_fpu_op_r1, miaow_fpu_op_r2,// Pipeline registers for fp 
			// operation
			miaow_fpu_op_r3;

   ////////////////////////////////////////////////////////////////////////
     //
   // Input Registers
   //

   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_r <= 'd0; 
     else
       opa_r <=  opa;


   always @(posedge clk or posedge rst) 
     if (rst) 
       rmode_r1 <= 'd0; 
     else
       rmode_r1 <=  rmode;

   always @(posedge clk or posedge rst) 
     if (rst) 
       rmode_r2 <= 'd0; 
     else
       rmode_r2 <=  rmode_r1;

   always @(posedge clk or posedge rst) 
     if (rst) 
       rmode_r3 <= 'd0; 
     else
       rmode_r3 <=  rmode_r2;

   always @(posedge clk or posedge rst) 
     if (rst) 
       miaow_fpu_op_r1 <= 1'b0; 
     else
       miaow_fpu_op_r1 <=  miaow_fpu_op;

   always @(posedge clk or posedge rst) 
     if (rst) 
       miaow_fpu_op_r2 <= 1'b0; 
     else
       miaow_fpu_op_r2 <=  miaow_fpu_op_r1;

   always @(posedge clk or posedge rst) 
     if (rst) 
       miaow_fpu_op_r3 <= 1'b0; 
     else
       miaow_fpu_op_r3 <=  miaow_fpu_op_r2;

   ////////////////////////////////////////////////////////////////////////
   //
   // Exceptions block
   //
   wire 		inf_d, ind_d, qnan_d, snan_d, opa_nan;
   wire 		opa_00;   
   wire 		opa_inf;
   wire 		opa_dn;

   miaow_fpu_intfloat_conv_except u0
     (	.clk(clk),
	.rst(rst),
	.opa(opa_r), 
	.opb(),
	.inf(inf_d), 
	.ind(ind_d),
	.qnan(qnan_d), 
	.snan(snan_d),
	.opa_nan(opa_nan), 
	.opb_nan(),
	.opa_00(opa_00),   
	.opb_00(),
	.opa_inf(opa_inf), 
	.opb_inf(),
	.opa_dn(opa_dn), 
	.opb_dn()
	);

   ////////////////////////////////////////////////////////////////////////
   //
   // Pre-Normalize block
   // - Adjusts the numbers to equal exponents and sorts them
   // - determine result sign
   // - determine actual operation to perform (add or sub)
   //

   wire 		nan_sign_d, result_zero_sign_d;
   reg 			sign_fasu_r;
   wire [1:0] 		exp_ovf;
   reg [1:0] 		exp_ovf_r;
   
   // This is all we need from post-norm module for int-float conversion
   reg 			opa_sign_r;
   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_sign_r <= 1'b0;
     else
       opa_sign_r <= opa_r[31];
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       sign_fasu_r <= 1'b0; 
     else
       sign_fasu_r <=  opa_sign_r; //sign_fasu;


   ////////////////////////////////////////////////////////////////////////
   //
   // Normalize Result
   //
   wire 		ine_d;
   wire 		inv_d;   
   wire 		sign_d;
   reg 			sign;
   reg [30:0] 		opa_r1;
   reg [47:0] 		fract_i2f;
   reg 			opas_r1, opas_r2;
   wire 		f2i_out_sign;
   wire [47:0] 		fract_denorm;

   always @(posedge clk or posedge rst) 
     if (rst) 
       exp_r <= 'd0; 
     else  // Exponent must be once cycle delayed
       case(miaow_fpu_op_r2)
	 //4:	exp_r <=  0;
	 5:	exp_r <=  opa_r1[30:23];
	 default: exp_r <=  0;
       endcase

   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_r1 <= 'd0; 
     else
       opa_r1 <=  opa_r[30:0];
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       fract_i2f <= 'd0; 
     else
       fract_i2f <=  (miaow_fpu_op_r2==5) ?
		     (sign_d ?  1-{24'h00, (|opa_r1[30:23]), opa_r1[22:0]}-1 : 
		      {24'h0, (|opa_r1[30:23]), opa_r1[22:0]})
	 : (sign_d ? 1 - {opa_r1, 17'h01} : {opa_r1, 17'h0});

   assign fract_denorm = fract_i2f;
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       opas_r1 <= 1'b0;
     else
       opas_r1 <=  opa_r[31];

   always @(posedge clk or posedge rst) 
     if (rst) 
       opas_r2 <= 1'b0; 
     else
       opas_r2 <= opas_r1;

   assign sign_d = opa_sign_r; //sign_fasu;

   always @(posedge clk or posedge rst) 
     if (rst)
       sign <= 1'b0;
     else
       sign <=  (rmode_r2==2'h3) ? !sign_d : sign_d;


   // Special case of largest negative integer we can convert to - usually
   // gets picked up as invalid, but really it's not, so deal with it as a
   // special case.
   wire 		f2i_special_case_no_inv;
   assign f2i_special_case_no_inv = (opa == 32'hcf000000);
   

   miaow_fpu_post_norm_intfloat_conv u4
     (
      .clk(clk),			// System Clock
      .rst(rst),
      .miaow_fpu_op(miaow_fpu_op_r3),		// Floating Point Operation
      .opas(opas_r2),			// OPA Sign
      .sign(sign),			// Sign of the result
      .rmode(rmode_r3),		// Rounding mode
      .fract_in(fract_denorm),	// Fraction Input

      .exp_in(exp_r),			// Exponent Input
      .opa_dn(opa_dn),		// Operand A Denormalized
      .opa_nan(opa_nan),
      .opa_inf(opa_inf),
      
      .opb_dn(),		// Operand B Denormalized
      .out(out_d),		// Normalized output (un-registered)
      .ine(ine_d),		// Result Inexact output (un-registered)
      .inv(inv_d),            // Invalid input for f2i operation
      .overflow(overflow_d),	// Overflow output (un-registered)
      .underflow(underflow_d),// Underflow output (un-registered)
      .f2i_out_sign(f2i_out_sign)	// F2I Output Sign
      );

   ////////////////////////////////////////////////////////////////////////
     //
   // FPU Outputs
   //
   reg 			fasu_op_r1, fasu_op_r2;
   wire [30:0] 		out_fixed;
   wire 		output_zero_fasu;
   wire 		overflow_fasu;
   wire 		out_d_00;
   wire 		ine_fasu;
   wire 		underflow_fasu;   


   /*
    always @(posedge clk or posedge rst) if (rst) <= 1'b0; else
    fasu_op_r1 <=  fasu_op;

    always @(posedge clk or posedge rst) if (rst) <= 1'b0; else
    fasu_op_r2 <=  fasu_op_r1;
    */
   // Force pre-set values for non numerical output

   assign out_fixed = (	(qnan_d | snan_d) |
			(ind_d /*& !fasu_op_r2*/))  ? QNAN : INF;

   always @(posedge clk or posedge rst) 
     if (rst)
       out [30:0] <= 'd0; 
     else
       out[30:0] <=  /*((inf_d & (miaow_fpu_op_r3!=3'b101)) | snan_d | qnan_d) 
		      & miaow_fpu_op_r3!=3'b100 ? out_fixed :*/ out_d;

   assign out_d_00 = !(|out_d);


   always @(posedge clk or posedge rst) 
     if (rst) 
       out[31] <= 1'b0; 
     else
       out[31] <= (miaow_fpu_op_r3==3'b101) ? f2i_out_sign : sign_fasu_r; 
   
   
   
   // Exception Outputs
   assign ine_fasu = (ine_d | overflow_d | underflow_d) & 
		     !(snan_d | qnan_d | inf_d);

   always @(posedge clk or posedge rst)
     if (rst)
       ine <= 1'b0;
     else
       ine <= miaow_fpu_op_r3[2] ? ine_d : ine_fasu;

   assign overflow = overflow_d & !(snan_d | qnan_d | inf_d);
   assign underflow = underflow_d & !(inf_d | snan_d | qnan_d);

   always @(posedge clk or posedge rst) 
     if (rst) 
       snan <= 1'b0; 
     else
       snan <=  snan_d & (miaow_fpu_op_r3==3'b101);  // Only signal sNaN when ftoi

   // Status Outputs   
   assign output_zero_fasu = out_d_00 & !(inf_d | snan_d | qnan_d);

   always @(posedge clk or posedge rst) 
     if (rst) 
       zero <= 1'b0; 
     else
       zero <= 	miaow_fpu_op_r3==3'b101 ? out_d_00 & !(snan_d | qnan_d) :
	       output_zero_fasu ;
   
   assign inv = inv_d & !f2i_special_case_no_inv;
   
endmodule // miaow_fpu_intfloat_conv
/////////////////////////////////////////////////////////////////////
////                                                             ////
////  miaow_fpu_intfloat_conv_except                            ////
////                                                             ////
////  Author: Rudolf Usselmann                                   ////
////          rudi@asics.ws                                      ////
////                                                             ////
//// Modified by Julius Baxter, July, 2010                       ////
////             julius.baxter@orsoc.se                          ////
////                                                             ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2000 Rudolf Usselmann                         ////
////                    rudi@asics.ws                            ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////
//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////
//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////
//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////
//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////
//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////
//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////
//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////
//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////
//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////
//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////
//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////
//// POSSIBILITY OF SUCH DAMAGE.                                 ////
////                                                             ////
/////////////////////////////////////////////////////////////////////

module miaow_fpu_intfloat_conv_except
  (	
	clk, rst, opa, opb, inf, ind, qnan, snan, opa_nan, opb_nan,
	opa_00, opb_00, opa_inf, opb_inf, opa_dn, opb_dn
	);
   input		clk;
   input 		rst;
   input [31:0] 	opa, opb;
   output		inf, ind, qnan, snan, opa_nan, opb_nan;
   output		opa_00, opb_00;
   output		opa_inf, opb_inf;
   output		opa_dn;
   output		opb_dn;

   ////////////////////////////////////////////////////////////////////////
   //
   // Local Wires and registers
   //

   wire [7:0] 		expa, expb;		// alias to opX exponent
   wire [22:0] 		fracta, fractb;		// alias to opX fraction
   reg 			expa_ff, infa_f_r, qnan_r_a, snan_r_a;
   reg 			expb_ff, infb_f_r, qnan_r_b, snan_r_b;
   reg 			inf, ind, qnan, snan;	// Output registers
   reg 			opa_nan, opb_nan;
   reg 			expa_00, expb_00, fracta_00, fractb_00;
   reg 			opa_00, opb_00;
   reg 			opa_inf, opb_inf;
   reg 			opa_dn, opb_dn;

   ////////////////////////////////////////////////////////////////////////
   //
   // Aliases
   //

   assign   expa = opa[30:23];
   assign   expb = opb[30:23];
   assign fracta = opa[22:0];
   assign fractb = opb[22:0];

   ////////////////////////////////////////////////////////////////////////
   //
   // Determine if any of the input operators is a INF or NAN or any other 
   // special number
   //

   always @(posedge clk or posedge rst)
     if (rst)
       expa_ff <= 1'b0;
     else
       expa_ff <=  &expa;

   always @(posedge clk or posedge rst)
     if (rst)     
       expb_ff <= 1'b0;
     else
       expb_ff <=  &expb;
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       infa_f_r <= 1'b0; 
     else
       infa_f_r <=  !(|fracta);

   always @(posedge clk or posedge rst) 
     if (rst)
       infb_f_r <= 1'b0; 
     else
       infb_f_r <=  !(|fractb);

   always @(posedge clk or posedge rst) 
     if (rst) 
       qnan_r_a <= 1'b0; 
     else
       qnan_r_a <=   fracta[22];

   always @(posedge clk or posedge rst) 
     if (rst) 
       snan_r_a <= 1'b0; 
     else
       snan_r_a <=  !fracta[22] & |fracta[21:0];
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       qnan_r_b <= 1'b0; 
     else
       qnan_r_b <=   fractb[22];

   always @(posedge clk or posedge rst) 
     if (rst) 
       snan_r_b <= 1'b0; 
     else
       snan_r_b <=  !fractb[22]; // & |fractb[21:0];
   
   always @(posedge clk or posedge rst) 
     if (rst) 
       ind <= 1'b0; 
     else
       ind  <=  (expa_ff & infa_f_r); // & (expb_ff & infb_f_r);

   always @(posedge clk or posedge rst) 
     if (rst)
       inf <= 1'b0; 
     else
       inf  <=  (expa_ff & infa_f_r); // | (expb_ff & infb_f_r);

   always @(posedge clk or posedge rst) 
     if (rst) 
       qnan <= 1'b0; 
     else
       qnan <=  (expa_ff & qnan_r_a); // | (expb_ff & qnan_r_b);

   always @(posedge clk or posedge rst) 
     if (rst) 
       snan <= 1'b0; 
     else
       snan <=  (expa_ff & snan_r_a); // | (expb_ff & snan_r_b);

   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_nan <= 1'b0; 
     else
       opa_nan <=  &expa & (|fracta[22:0]);

   always @(posedge clk or posedge rst) 
     if (rst) 
       opb_nan <= 1'b0; 
     else
       opb_nan <=  &expb & (|fractb[22:0]);

   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_inf <= 1'b0; 
     else
       opa_inf <=  (expa_ff & infa_f_r);

   always @(posedge clk or posedge rst) 
     if (rst) 
       opb_inf <= 1'b0; 
     else
       opb_inf <=  (expb_ff & infb_f_r);

   always @(posedge clk or posedge rst) 
     if (rst)
       expa_00 <= 1'b0; 
     else
       expa_00 <=  !(|expa);

   always @(posedge clk or posedge rst) 
     if (rst)
       expb_00 <= 1'b0;
     else
       expb_00 <=  !(|expb);

   always @(posedge clk or posedge rst) 
     if (rst)
       fracta_00 <= 1'b0; 
     else
       fracta_00 <=  !(|fracta);

   always @(posedge clk or posedge rst) 
     if (rst) 
       fractb_00 <= 1'b0; 
     else
       fractb_00 <=  !(|fractb);

   always @(posedge clk or posedge rst) 
     if (rst) 
       opa_00 <= 1'b0; 
     else
       opa_00 <=  expa_00 & fracta_00;

   always @(posedge clk or posedge rst) 
     if (rst) 
       opb_00 <= 1'b0; 
     else
       opb_00 <=  expb_00 & fractb_00;

   always @(posedge clk or posedge rst) 
     if (rst)
       opa_dn <= 1'b0; 
     else
       opa_dn <=  expa_00;

   always @(posedge clk or posedge rst) 
     if (rst) 
       opb_dn <= 1'b0; 
     else
       opb_dn <=  expb_00;

endmodule // miaow_fpu_intfloat_conv_except
//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_mul                                              ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  Serial multiplication entity for the multiplication unit    ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_mul 
  (  
     clk,
     rst,
     fracta_i,
     fractb_i,
     signa_i,
     signb_i,
     start_i,
     fract_o,
     sign_o,
     ready_o
     );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;
   
   input clk;
   input rst;
   
   input [FRAC_WIDTH:0] fracta_i;   
   input [FRAC_WIDTH:0] fractb_i;   
   input 		signa_i;
   input 		signb_i;
   input 		start_i;
   output reg [2*FRAC_WIDTH+1:0] fract_o;
   output reg 			 sign_o;
   output reg 			 ready_o;
   
   parameter t_state_waiting = 1'b0,
	       t_state_busy = 1'b1;

   reg [47:0] 			 s_fract_o;
   reg [23:0] 			 s_fracta_i;
   reg [23:0] 			 s_fractb_i;
   reg 				 s_signa_i, s_signb_i;
   wire 			 s_sign_o;
   reg 				 s_start_i;
   reg 				 s_ready_o;
   reg 				 s_state;
   reg [4:0] 			 s_count;
   wire [23:0] 			 s_tem_prod;

   // Input Register
   always @(posedge clk or posedge rst) 
     if (rst)
       begin 
	  s_fracta_i <= 'd0;
	  s_fractb_i <= 'd0;
	  s_signa_i <= 1'b0;
	  s_signb_i <= 1'b0;
	  s_start_i <= 1'b0;
       end
     else 
       begin
	  s_fracta_i <= fracta_i;
	  s_fractb_i <= fractb_i;
	  s_signa_i<= signa_i;
	  s_signb_i<= signb_i;
	  s_start_i <= start_i;
       end
   
   // Output Register
   always @(posedge clk or posedge rst) 
     if (rst) 
       begin
	  fract_o <= 'd0;
	  sign_o <= 1'b0;
	  ready_o <= 1'b0;
       end
     else 
       begin
	  fract_o <= s_fract_o;
	  sign_o <= s_sign_o;	
	  ready_o <= s_ready_o;
       end

   assign s_sign_o = signa_i ^ signb_i;

   // FSM
   always @(posedge clk or posedge rst) 
     if (rst)
       begin
	  s_state <= t_state_waiting;
	  s_count <= 0;
       end
     else 
       if (s_start_i)
	 begin
	    s_state <= t_state_busy;
	    s_count <= 0;
	 end
       else if (s_count==23)
	 begin
	    s_state <= t_state_waiting;
	    s_ready_o <= 1;
	    s_count <=0;
	 end
       else if (s_state==t_state_busy)
	 s_count <= s_count + 1;
       else
	 begin
	    s_state <= t_state_waiting;
	    s_ready_o <= 0;
	 end
   
   assign s_tem_prod[0] = s_fracta_i[0] & s_fractb_i[s_count];
   assign s_tem_prod[1] = s_fracta_i[1] & s_fractb_i[s_count];
   assign s_tem_prod[2] = s_fracta_i[2] & s_fractb_i[s_count];
   assign s_tem_prod[3] = s_fracta_i[3] & s_fractb_i[s_count];
   assign s_tem_prod[4] = s_fracta_i[4] & s_fractb_i[s_count];
   assign s_tem_prod[5] = s_fracta_i[5] & s_fractb_i[s_count];
   assign s_tem_prod[6] = s_fracta_i[6] & s_fractb_i[s_count];
   assign s_tem_prod[7] = s_fracta_i[7] & s_fractb_i[s_count];
   assign s_tem_prod[8] = s_fracta_i[8] & s_fractb_i[s_count];
   assign s_tem_prod[9] = s_fracta_i[9] & s_fractb_i[s_count];
   assign s_tem_prod[10] = s_fracta_i[10] & s_fractb_i[s_count];
   assign s_tem_prod[11] = s_fracta_i[11] & s_fractb_i[s_count];
   assign s_tem_prod[12] = s_fracta_i[12] & s_fractb_i[s_count];
   assign s_tem_prod[13] = s_fracta_i[13] & s_fractb_i[s_count];
   assign s_tem_prod[14] = s_fracta_i[14] & s_fractb_i[s_count];
   assign s_tem_prod[15] = s_fracta_i[15] & s_fractb_i[s_count];
   assign s_tem_prod[16] = s_fracta_i[16] & s_fractb_i[s_count];
   assign s_tem_prod[17] = s_fracta_i[17] & s_fractb_i[s_count];
   assign s_tem_prod[18] = s_fracta_i[18] & s_fractb_i[s_count];
   assign s_tem_prod[19] = s_fracta_i[19] & s_fractb_i[s_count];
   assign s_tem_prod[20] = s_fracta_i[20] & s_fractb_i[s_count];
   assign s_tem_prod[21] = s_fracta_i[21] & s_fractb_i[s_count];
   assign s_tem_prod[22] = s_fracta_i[22] & s_fractb_i[s_count];
   assign s_tem_prod[23] = s_fracta_i[23] & s_fractb_i[s_count];
   
   wire [47:0] v_prod_shl;
   assign v_prod_shl = {24'd0,s_tem_prod} << s_count[4:0];

   always @(posedge clk or posedge rst) 
     if (rst)
       s_fract_o <= 'd0; 
     else
       if (s_state==t_state_busy)
	 begin
	    if (|s_count)
	      s_fract_o <= v_prod_shl + s_fract_o;
	    else
	      s_fract_o <= v_prod_shl;
	 end
   
endmodule // miaow_fpu_mul

//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_post_norm_addsub                                 ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  post-normalization entity for the addition/subtraction unit ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_post_norm_addsub
  (
   clk,
   rst,
   opa_i,
   opb_i,
   fract_28_i,
   exp_i,
   sign_i,
   miaow_fpu_op_i,
   rmode_i,
   output_o,
   ine_o
   );
   
   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;

   input     clk;
   input     rst;
   
   input [FP_WIDTH-1:0] opa_i;   
   input [FP_WIDTH-1:0] opb_i;
   input [FRAC_WIDTH+4:0] fract_28_i;   
   input [EXP_WIDTH-1:0]  exp_i;
   input 		  sign_i;
   input 		  miaow_fpu_op_i;
   input [1:0] 		  rmode_i;
   output reg [FP_WIDTH-1:0] output_o;
   output reg 		     ine_o;
   
   wire [FP_WIDTH-1:0] 	     s_opa_i;   
   wire [FP_WIDTH-1:0] 	     s_opb_i;
   wire [FRAC_WIDTH+4:0]     s_fract_28_i;	
   wire [EXP_WIDTH-1:0]      s_exp_i;
   wire 		     s_sign_i;
   wire 		     s_miaow_fpu_op_i;
   wire [1:0] 		     s_rmode_i;   
   wire [FP_WIDTH-1:0] 	     s_output_o;
   wire 		     s_ine_o;
   wire 		     s_overflow;
   
   wire [5:0] 		     s_zeros;
   reg [5:0] 		     s_shr1;
   reg [5:0] 		     s_shl1;
   wire 		     s_shr2, s_carry;

   wire [9:0] 		     s_exp10;
   reg [EXP_WIDTH:0] 	     s_expo9_1;
   wire [EXP_WIDTH:0] 	     s_expo9_2;
   wire [EXP_WIDTH:0] 	     s_expo9_3;
   
   reg [FRAC_WIDTH+4:0]      s_fracto28_1;
   wire [FRAC_WIDTH+4:0]     s_fracto28_2;
   wire [FRAC_WIDTH+4:0]     s_fracto28_rnd;

   wire 		     s_roundup;
   wire 		     s_sticky;
   
   wire 		     s_zero_fract;	
   wire 		     s_lost;
   wire 		     s_infa, s_infb;
   wire 		     s_nan_in, s_nan_op, s_nan_a, s_nan_b, s_nan_sign;
   
   assign s_opa_i = opa_i;
   assign s_opb_i = opb_i;
   assign s_fract_28_i = fract_28_i;
   assign s_exp_i = exp_i;
   assign s_sign_i = sign_i;
   assign s_miaow_fpu_op_i = miaow_fpu_op_i;
   assign s_rmode_i = rmode_i;
   
   // Output Register
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  output_o <= 'd0;
	  ine_o <= 1'b0;
       end
     else
       begin
	  output_o <= s_output_o;
	  ine_o <= s_ine_o;
       end
   //*** Stage 1 ****
   // figure out the output exponent and how much the fraction has to be 
   // shiftd right/left
   
   assign s_carry = s_fract_28_i[27];

   reg [5:0] lzeroes;
   
   always @(s_fract_28_i)
     casez(s_fract_28_i[26:0])	// synopsys full_case parallel_case
       27'b1??????????????????????????: lzeroes = 0;
       27'b01?????????????????????????: lzeroes = 1;
       27'b001????????????????????????: lzeroes = 2;
       27'b0001???????????????????????: lzeroes = 3;
       27'b00001??????????????????????: lzeroes = 4;
       27'b000001?????????????????????: lzeroes = 5;
       27'b0000001????????????????????: lzeroes = 6;
       27'b00000001???????????????????: lzeroes = 7;
       27'b000000001??????????????????: lzeroes = 8;
       27'b0000000001?????????????????: lzeroes = 9;
       27'b00000000001????????????????: lzeroes = 10;
       27'b000000000001???????????????: lzeroes = 11;
       27'b0000000000001??????????????: lzeroes = 12;
       27'b00000000000001?????????????: lzeroes = 13;
       27'b000000000000001????????????: lzeroes = 14;
       27'b0000000000000001???????????: lzeroes = 15;
       27'b00000000000000001??????????: lzeroes = 16;
       27'b000000000000000001?????????: lzeroes = 17;
       27'b0000000000000000001????????: lzeroes = 18;
       27'b00000000000000000001???????: lzeroes = 19;
       27'b000000000000000000001??????: lzeroes = 20;
       27'b0000000000000000000001?????: lzeroes = 21;
       27'b00000000000000000000001????: lzeroes = 22;
       27'b000000000000000000000001???: lzeroes = 23;
       27'b0000000000000000000000001??: lzeroes = 24;
       27'b00000000000000000000000001?: lzeroes = 25;
       27'b000000000000000000000000001: lzeroes = 26;
       27'b000000000000000000000000000: lzeroes = 27;
     endcase

   assign s_zeros = s_fract_28_i[27] ? 6'd0 : lzeroes;
   
   // negative flag & large flag & exp		
   assign s_exp10 = {2'd0,s_exp_i} + {9'd0,s_carry} - {4'd0,s_zeros}; 
   
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_shr1 <= 0;
	  s_shl1 <= 0;
	  s_expo9_1 <= 'd0;
       end
     else
       begin
	  if (s_exp10[9] | !(|s_exp10))
	    begin
	       s_shr1 <= 0;
	       s_expo9_1 <= 9'd1;
	       
	       if (|s_exp_i)
		 s_shl1 <= s_exp_i[5:0] - 6'd1;
	       else
		 s_shl1 <= 0;
	       
	    end
	  else if (s_exp10[8])
	    begin
	       s_shr1 <= 0;
	       s_shl1 <= 0;
	       s_expo9_1 <= 9'b011111111;
	    end
	  else
	    begin
	       s_shr1 <= {5'd0,s_carry};
	       s_shl1 <= s_zeros;
	       s_expo9_1 <= s_exp10[8:0];
	    end // else: !if(s_exp10[8])
       end // always @ (posedge clk or posedge rst)
   
   //-
   // *** Stage 2 ***
   // Shifting the fraction and rounding
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_fracto28_1 <= 'd0;
     else
       if (|s_shr1)
	 s_fracto28_1 <= s_fract_28_i >> s_shr1;
       else 
	 s_fracto28_1 <= s_fract_28_i << s_shl1; 
   
   assign s_expo9_2 = (s_fracto28_1[27:26]==2'b00) ? 
		      s_expo9_1 - 9'd1 : s_expo9_1;
   
   // round
   //check last bit, before and after right-shift
   assign s_sticky = s_fracto28_1[0] | (s_fract_28_i[0] & s_fract_28_i[27]); 
   
   assign s_roundup = s_rmode_i==2'b00 ?
		      // round to nearset even
		      s_fracto28_1[2] & ((s_fracto28_1[1] | s_sticky) | 
					 s_fracto28_1[3]) :
		      s_rmode_i==2'b10 ?
		      // round up
		      (s_fracto28_1[2] | s_fracto28_1[1] | s_sticky) & !s_sign_i:
		      s_rmode_i==2'b11 ?
		      // round down
		      (s_fracto28_1[2] | s_fracto28_1[1] | s_sticky) & s_sign_i :
		      // round to zero(truncate = no rounding)
		      1'b0;
   
   assign s_fracto28_rnd = s_roundup ? 
			   s_fracto28_1+28'b0000_0000_0000_0000_0000_0000_1000 :
			   s_fracto28_1;
   
   // ***Stage 3***
   // right-shift after rounding (if necessary)
   assign s_shr2 = s_fracto28_rnd[27]; 

   assign s_expo9_3 = (s_shr2 &  s_expo9_2!=9'b011111111) ?
		      s_expo9_2 + 9'b000000001 : s_expo9_2;

   assign s_fracto28_2 = s_shr2 ? {1'b0,s_fracto28_rnd[27:1]} : s_fracto28_rnd;

   ////-
   
   assign s_infa = &s_opa_i[30:23];
   assign s_infb = &s_opb_i[30:23];
   
   assign s_nan_a = s_infa &  (|s_opa_i[22:0]);
   assign s_nan_b = s_infb &  (|s_opb_i[22:0]);
   
   assign s_nan_in = s_nan_a | s_nan_b;

   // inf-inf=Nan
   assign s_nan_op = (s_infa & s_infb) & 
		     (s_opa_i[31] ^ (s_miaow_fpu_op_i ^ s_opb_i[31]));
   
   assign s_nan_sign = (s_nan_a & s_nan_b) ? s_sign_i :
		       s_nan_a ? 
		       s_opa_i[31] : s_opb_i[31];
   
   // check if result is inexact;
   assign s_lost = (s_shr1[0] & s_fract_28_i[0]) | 
		   (s_shr2 & s_fracto28_rnd[0]) | (|s_fracto28_2[2:0]);

   assign s_ine_o = (s_lost | s_overflow) & !(s_infa | s_infb);
   
   assign s_overflow = s_expo9_3==9'b011111111 & !(s_infa | s_infb);

   // '1' if fraction result is zero
   assign s_zero_fract = s_zeros==27 & !s_fract_28_i[27];
   

   // Generate result
   assign s_output_o = (s_nan_in | s_nan_op) ?
		       {s_nan_sign,QNAN} :
		       (s_infa | s_infb) | s_overflow ?
		       {s_sign_i,INF} :
		       s_zero_fract ?
		       {s_sign_i,ZERO_VECTOR} :
		       {s_sign_i,s_expo9_3[7:0],s_fracto28_2[25:3]};

endmodule // miaow_fpu_post_norm_addsub


//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_post_norm_div                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  post-normalization entity for the division unit             ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//


module miaow_fpu_post_norm_div
  (
   clk,
   rst,
   opa_i,
   opb_i,
   qutnt_i,
   rmndr_i,
   exp_10_i,
   sign_i,
   rmode_i,
   output_o,
   ine_o
   );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;
   
   input clk;
   input rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   input [FRAC_WIDTH+3:0] qutnt_i;
   input [FRAC_WIDTH+3:0] rmndr_i;
   input [EXP_WIDTH+1:0]  exp_10_i;
   input 		  sign_i;
   input [1:0] 		  rmode_i;
   output reg [FP_WIDTH-1:0] output_o;
   output reg 		     ine_o;
   
   // input&output register wires
   reg [FP_WIDTH-1:0] 	     s_opa_i;
   reg [FP_WIDTH-1:0] 	     s_opb_i;
   reg [EXP_WIDTH-1:0] 	     s_expa;
   reg [EXP_WIDTH-1:0] 	     s_expb;
   reg [FRAC_WIDTH+3:0]      s_qutnt_i;
   reg [FRAC_WIDTH+3:0]      s_rmndr_i;
   reg [5:0] 		     s_r_zeros;
   reg [EXP_WIDTH+1:0] 	     s_exp_10_i;
   reg 			     s_sign_i;
   reg [1:0] 		     s_rmode_i;
   wire [FP_WIDTH-1:0] 	     s_output_o;
   
   wire 		     s_ine_o, s_overflow;
   wire 		     s_opa_dn, s_opb_dn;
   wire 		     s_qutdn;
   wire [9:0] 		     s_exp_10b;
   reg [5:0] 		     s_shr1;
   reg [5:0] 		     s_shl1;
   wire 		     s_shr2;
   reg [8:0] 		     s_expo1;
   wire [8:0] 		     s_expo2;
   reg [8:0] 		     s_expo3;
   reg [26:0] 		     s_fraco1;
   wire [24:0] 		     s_frac_rnd;
   reg [24:0] 		     s_fraco2;
   wire 		     s_guard, s_round, s_sticky, s_roundup;
   wire 		     s_lost;
   wire 		     s_op_0, s_opab_0, s_opb_0;
   wire 		     s_infa, s_infb;
   wire 		     s_nan_in, s_nan_op, s_nan_a, s_nan_b;
   wire 		     s_inf_result;
   
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_opa_i <= 'd0;
	  s_opb_i <= 'd0;
	  s_expa <= 'd0;
	  s_expb <= 'd0;
	  s_qutnt_i <= 1'b0;
	  s_rmndr_i <= 1'b0;
	  s_exp_10_i <= 1'b0;
	  s_sign_i <= 1'b0;
	  s_rmode_i <= 1'b0;
       end
     else
       begin
	  s_opa_i <= opa_i;
	  s_opb_i <= opb_i;	
	  s_expa <= opa_i[30:23];
	  s_expb <= opb_i[30:23];
	  s_qutnt_i <= qutnt_i;
	  s_rmndr_i <= rmndr_i;
	  s_exp_10_i <= exp_10_i;			
	  s_sign_i <= sign_i;
	  s_rmode_i <= rmode_i;
       end

   // Output Register
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  output_o <= 'd0;
	  ine_o <= 1'b0;
       end
     else
       begin
	  output_o <= s_output_o;
	  ine_o	<= s_ine_o;
       end
   
   // qutnt_i
   // 26 25                    3
   // |  |                     | 
   // h  fffffffffffffffffffffff grs

   //*** Stage 1 ****
   // figure out the exponent and how far the fraction has to be shifted 
   // right or left
   
   assign s_opa_dn = !(|s_expa) & (|opa_i[22:0]);
   assign s_opb_dn = !(|s_expb) & (|opb_i[22:0]);
   
   assign s_qutdn =  !s_qutnt_i[26];

   assign s_exp_10b = s_exp_10_i - {9'd0,s_qutdn};
   
   wire [9:0] v_shr;
   wire [9:0] v_shl;
   
   assign v_shr = (s_exp_10b[9] | !(|s_exp_10b)) ?
		  (10'd1 - s_exp_10b) - {9'd0,s_qutdn} : 6'd0;
   
   assign v_shl = (s_exp_10b[9] | !(|s_exp_10b)) ?
		  10'd0 :
		  s_exp_10b[8] ?   
		  10'd0 : {9'd0,s_qutdn};

   always @(posedge clk or posedge rst)
     if (rst)
       s_expo1 <= 'd0;
     else
       if (s_exp_10b[9] | !(|s_exp_10b))
	 s_expo1 <= 9'd1;
       else
	 s_expo1 <= s_exp_10b[8:0];
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_shr1 <= 'd0;
     else
       s_shr1 <= v_shr[6] ? 6'b111111 : v_shr[5:0];

   always @(posedge clk or posedge rst)
     if (rst)
       s_shl1 <= 'd0;
     else
       s_shl1 <= v_shl[5:0];
   
   // *** Stage 2 ***
   // Shifting the fraction and rounding
   
   // shift the fraction
   always @(posedge clk or posedge rst)
     if (rst)
       s_fraco1 <= 'd0;
     else
       if (|s_shr1)
	 s_fraco1 <= s_qutnt_i >> s_shr1;
       else
	 s_fraco1 <= s_qutnt_i << s_shl1;
   
   assign s_expo2 = s_fraco1[26] ? s_expo1 : s_expo1 - 9'd1;
   
   //s_r_zeros <= count_r_zeros(s_qutnt_i);
   always @(s_qutnt_i)
     casez(s_qutnt_i) // synopsys full_case parallel_case
       27'b??????????????????????????1: s_r_zeros = 0;
       27'b?????????????????????????10: s_r_zeros = 1;
       27'b????????????????????????100: s_r_zeros = 2;
       27'b???????????????????????1000: s_r_zeros = 3;
       27'b??????????????????????10000: s_r_zeros = 4;
       27'b?????????????????????100000: s_r_zeros = 5;
       27'b????????????????????1000000: s_r_zeros = 6;
       27'b???????????????????10000000: s_r_zeros = 7;
       27'b??????????????????100000000: s_r_zeros = 8;
       27'b?????????????????1000000000: s_r_zeros = 9;
       27'b????????????????10000000000: s_r_zeros = 10;
       27'b???????????????100000000000: s_r_zeros = 11;
       27'b??????????????1000000000000: s_r_zeros = 12;
       27'b?????????????10000000000000: s_r_zeros = 13;
       27'b????????????100000000000000: s_r_zeros = 14;
       27'b???????????1000000000000000: s_r_zeros = 15;
       27'b??????????10000000000000000: s_r_zeros = 16;
       27'b?????????100000000000000000: s_r_zeros = 17;
       27'b????????1000000000000000000: s_r_zeros = 18;
       27'b???????10000000000000000000: s_r_zeros = 19;
       27'b??????100000000000000000000: s_r_zeros = 20;
       27'b?????1000000000000000000000: s_r_zeros = 21;
       27'b????10000000000000000000000: s_r_zeros = 22;
       27'b???100000000000000000000000: s_r_zeros = 23;
       27'b??1000000000000000000000000: s_r_zeros = 24;
       27'b?10000000000000000000000000: s_r_zeros = 25;
       27'b100000000000000000000000000: s_r_zeros = 26;
       27'b000000000000000000000000000: s_r_zeros = 27;
     endcase // casex (s_qutnt_i)
   
   assign s_lost = (s_shr1+{5'd0,s_shr2}) > s_r_zeros;
   
   // ***Stage 3***
   // Rounding
   
   assign s_guard = s_fraco1[2];
   assign s_round = s_fraco1[1];
   assign s_sticky = s_fraco1[0] | (|s_rmndr_i);

   assign s_roundup = s_rmode_i==2'b00 ? // round to nearest even
		      s_guard & ((s_round | s_sticky) | s_fraco1[3]) :
		      s_rmode_i==2'b10 ? // round up
		      (s_guard | s_round | s_sticky) & !s_sign_i :
		      s_rmode_i==2'b11 ? // round down
		      (s_guard | s_round | s_sticky) & s_sign_i : 
		      1'b0; // round to zero(truncate = no rounding)

   assign s_frac_rnd = s_roundup ?{1'b0,s_fraco1[26:3]} + 25'd1 : 
		       {1'b0,s_fraco1[26:3]};
   assign s_shr2 = s_frac_rnd[24];

   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_expo3 <= 1'b0;
	  s_fraco2 <= 'd0;
       end
     else
       begin
	  s_expo3 <= s_shr2 ? s_expo2 + "1" : s_expo2;
	  s_fraco2 <= s_shr2 ? {1'b0,s_frac_rnd[24:1]} : s_frac_rnd;
       end
   //
   // ***Stage 4****
   // Output
   
   assign s_op_0 = !((|s_opa_i[30:0]) & (|s_opb_i[30:0]));

   assign s_opab_0 = !((|s_opa_i[30:0]) | (|s_opb_i[30:0]));

   assign s_opb_0 = !(|s_opb_i[30:0]);
   
   assign s_infa = &s_expa;
   
   assign s_infb = &s_expb;
   
   assign s_nan_a = s_infa & (|s_opa_i[22:0]);
   
   assign s_nan_b = s_infb & (|s_opb_i[22:0]);
   
   assign s_nan_in = s_nan_a | s_nan_b;
   
   assign s_nan_op = (s_infa & s_infb) | s_opab_0; // 0 / 0, inf / inf

   assign s_inf_result = (&s_expo3[7:0]) | s_expo3[8] | s_opb_0;

   assign s_overflow =  s_inf_result & !(s_infa) & !s_opb_0;
   
   assign s_ine_o =  !s_op_0 & 
		     (s_lost | (|s_fraco1[2:0]) | s_overflow | (|s_rmndr_i));
   
   assign s_output_o = (s_nan_in | s_nan_op) ?
		       {s_sign_i,QNAN} :
		       s_infa  | s_overflow | s_inf_result ?
		       {s_sign_i,INF} :
		       s_op_0 | s_infb ?
		       {s_sign_i,ZERO_VECTOR} :
		       {s_sign_i,s_expo3[7:0],s_fraco2[22:0]};

endmodule // miaow_fpu_post_norm_div



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  miaow_fpu_post_norm_intfloat_conv                         ////
////  Floating Point Post Normalisation Unit                     ////
////                                                             ////
////  Author: Rudolf Usselmann                                   ////
////          rudi@asics.ws                                      ////
//// Modified by Julius Baxter, July, 2010                       ////
////             julius.baxter@orsoc.se                          ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2000 Rudolf Usselmann                         ////
////                    rudi@asics.ws                            ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////
//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////
//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////
//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////
//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////
//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////
//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////
//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////
//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////
//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////
//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////
//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////
//// POSSIBILITY OF SUCH DAMAGE.                                 ////
////                                                             ////
/////////////////////////////////////////////////////////////////////


module miaow_fpu_post_norm_intfloat_conv 
  ( 
    clk, rst, miaow_fpu_op, opas, sign, rmode, fract_in, 
    exp_in, opa_dn, opa_nan, opa_inf, opb_dn,  out,
    ine, inv, overflow, underflow, f2i_out_sign
    );
   input		clk;
   input 		rst;
   
   input [2:0] 		miaow_fpu_op;
   input		opas;
   input		sign;
   input [1:0] 		rmode;
   input [47:0] 	fract_in;
   input [7:0] 		exp_in;
   input		opa_dn, opb_dn;
   input 		opa_nan, opa_inf;
   
   output [30:0] 	out;
   output		ine, inv;
   output		overflow, underflow;
   output		f2i_out_sign;

   ////////////////////////////////////////////////////////////////////////
   //
   // Local Wires and registers
   //

   /*wire*/ reg [22:0] 		fract_out;
   /*wire*/reg [7:0] 		exp_out;
   wire [30:0] 		out;
   wire 		exp_out1_co, overflow, underflow;
   wire [22:0] 		fract_out_final;
   reg [22:0] 		fract_out_rnd;
   wire [8:0] 		exp_next_mi;
   wire 		dn;
   wire 		exp_rnd_adj;
   wire [7:0] 		exp_out_final;
   reg [7:0] 		exp_out_rnd;
   wire 		op_dn = opa_dn | opb_dn;
   wire 		op_mul = miaow_fpu_op[2:0]==3'b010;
   wire 		op_div = miaow_fpu_op[2:0]==3'b011;
   wire 		op_i2f = miaow_fpu_op[2:0]==3'b100;
   wire 		op_f2i = miaow_fpu_op[2:0]==3'b101;
   reg [5:0] 		fi_ldz;

   wire 		g, r, s;
   wire 		round, round2, round2a, round2_fasu, round2_fmul;
   wire [7:0] 		exp_out_rnd0, exp_out_rnd1, exp_out_rnd2, exp_out_rnd2a;
   wire [22:0] 		fract_out_rnd0, fract_out_rnd1, fract_out_rnd2, 
			fract_out_rnd2a;
   wire 		exp_rnd_adj0, exp_rnd_adj2a;
   wire 		r_sign;
   wire 		ovf0, ovf1;
   wire [23:0] 		fract_out_pl1;
   wire [7:0] 		exp_out_pl1, exp_out_mi1;
   wire 		exp_out_00, exp_out_fe, exp_out_ff, exp_in_00, 
			exp_in_ff;
   wire 		exp_out_final_ff, fract_out_7fffff;
   /*wire*/reg [24:0] 		fract_trunc;
   wire [7:0] 		exp_out1;
   wire 		grs_sel;
   wire 		fract_out_00;
   reg 			fract_in_00;
   wire 		shft_co;
   wire [8:0] 		exp_in_pl1, exp_in_mi1;
   wire [47:0] 		fract_in_shftr;
   wire [47:0] 		fract_in_shftl;

   wire [7:0] 		shft2;
   wire [7:0] 		exp_out1_mi1;

   wire [6:0] 		fi_ldz_2a;
   wire [7:0] 		fi_ldz_2;

   wire 		left_right;   
   wire [7:0] 		shift_right;
   wire [7:0] 		shift_left;   
   wire [7:0] 		fasu_shift;

   wire [5:0] 		fi_ldz_mi1;
   wire [5:0] 		fi_ldz_mi22;
   wire [6:0] 		ldz_all;

   wire [7:0] 		f2i_shft;
   wire [55:0] 		exp_f2i_1;
   wire 		f2i_zero, f2i_max;
   wire [7:0] 		f2i_emin;
   wire 		f2i_exp_gt_max ,f2i_exp_lt_min;
   wire [7:0] 		conv_shft;
   wire [7:0] 		exp_i2f, exp_f2i, conv_exp;
   wire 		round2_f2i;

   ////////////////////////////////////////////////////////////////////////
   //
   // Normalize and Round Logic
   //

   // ---------------------------------------------------------------------
   // Count Leading zeros in fraction

   always @(/*fract_in*/ posedge clk or posedge rst)
     if (rst)
       fi_ldz <= 0;
     else
       casez(fract_in)	// synopsys full_case parallel_case
	 48'b1???????????????????????????????????????????????: fi_ldz <=  1;
	 48'b01??????????????????????????????????????????????: fi_ldz <=  2;
	 48'b001?????????????????????????????????????????????: fi_ldz <=  3;
	 48'b0001????????????????????????????????????????????: fi_ldz <=  4;
	 48'b00001???????????????????????????????????????????: fi_ldz <=  5;
	 48'b000001??????????????????????????????????????????: fi_ldz <=  6;
	 48'b0000001?????????????????????????????????????????: fi_ldz <=  7;
	 48'b00000001????????????????????????????????????????: fi_ldz <=  8;
	 48'b000000001???????????????????????????????????????: fi_ldz <=  9;
	 48'b0000000001??????????????????????????????????????: fi_ldz <=  10;
	 48'b00000000001?????????????????????????????????????: fi_ldz <=  11;
	 48'b000000000001????????????????????????????????????: fi_ldz <=  12;
	 48'b0000000000001???????????????????????????????????: fi_ldz <=  13;
	 48'b00000000000001??????????????????????????????????: fi_ldz <=  14;
	 48'b000000000000001?????????????????????????????????: fi_ldz <=  15;
	 48'b0000000000000001????????????????????????????????: fi_ldz <=  16;
	 48'b00000000000000001???????????????????????????????: fi_ldz <=  17;
	 48'b000000000000000001??????????????????????????????: fi_ldz <=  18;
	 48'b0000000000000000001?????????????????????????????: fi_ldz <=  19;
	 48'b00000000000000000001????????????????????????????: fi_ldz <=  20;
	 48'b000000000000000000001???????????????????????????: fi_ldz <=  21;
	 48'b0000000000000000000001??????????????????????????: fi_ldz <=  22;
	 48'b00000000000000000000001?????????????????????????: fi_ldz <=  23;
	 48'b000000000000000000000001????????????????????????: fi_ldz <=  24;
	 48'b0000000000000000000000001???????????????????????: fi_ldz <=  25;
	 48'b00000000000000000000000001??????????????????????: fi_ldz <=  26;
	 48'b000000000000000000000000001?????????????????????: fi_ldz <=  27;
	 48'b0000000000000000000000000001????????????????????: fi_ldz <=  28;
	 48'b00000000000000000000000000001???????????????????: fi_ldz <=  29;
	 48'b000000000000000000000000000001??????????????????: fi_ldz <=  30;
	 48'b0000000000000000000000000000001?????????????????: fi_ldz <=  31;
	 48'b00000000000000000000000000000001????????????????: fi_ldz <=  32;
	 48'b000000000000000000000000000000001???????????????: fi_ldz <=  33;
	 48'b0000000000000000000000000000000001??????????????: fi_ldz <=  34;
	 48'b00000000000000000000000000000000001?????????????: fi_ldz <=  35;
	 48'b000000000000000000000000000000000001????????????: fi_ldz <=  36;
	 48'b0000000000000000000000000000000000001???????????: fi_ldz <=  37;
	 48'b00000000000000000000000000000000000001??????????: fi_ldz <=  38;
	 48'b000000000000000000000000000000000000001?????????: fi_ldz <=  39;
	 48'b0000000000000000000000000000000000000001????????: fi_ldz <=  40;
	 48'b00000000000000000000000000000000000000001???????: fi_ldz <=  41;
	 48'b000000000000000000000000000000000000000001??????: fi_ldz <=  42;
	 48'b0000000000000000000000000000000000000000001?????: fi_ldz <=  43;
	 48'b00000000000000000000000000000000000000000001????: fi_ldz <=  44;
	 48'b000000000000000000000000000000000000000000001???: fi_ldz <=  45;
	 48'b0000000000000000000000000000000000000000000001??: fi_ldz <=  46;
	 48'b00000000000000000000000000000000000000000000001?: fi_ldz <=  47;
	 48'b00000000000000000000000000000000000000000000000?: fi_ldz <=  48;
       endcase


   // ---------------------------------------------------------------------
   // Normalize

   wire 		exp_in_80;
   wire 		rmode_00, rmode_01, rmode_10, rmode_11;

   // Misc common signals
   assign exp_in_ff        = &exp_in;
   assign exp_in_00        = !(|exp_in);
   assign exp_in_80	= exp_in[7] & !(|exp_in[6:0]);
   assign exp_out_ff       = &exp_out;
   assign exp_out_00       = !(|exp_out);
   assign exp_out_fe       = &exp_out[7:1] & !exp_out[0];
   assign exp_out_final_ff = &exp_out_final;

   assign fract_out_7fffff = &fract_out;
   assign fract_out_00     = !(|fract_out);
   //assign fract_in_00      = !(|fract_in);
   always @(posedge clk or posedge rst)
     if (rst)
       fract_in_00 <= 1'b0;
     else
       fract_in_00  <= !(|fract_in);

   assign rmode_00 = (rmode==2'b00);
   assign rmode_01 = (rmode==2'b01);
   assign rmode_10 = (rmode==2'b10);
   assign rmode_11 = (rmode==2'b11);

   // Fasu Output will be denormalized ...
   assign dn = !op_mul & !op_div & 
	       (exp_in_00 | (exp_next_mi[8] & !fract_in[47]) );

   // ---------------------------------------------------------------------
   // Fraction Normalization
   parameter	f2i_emax = 8'h9d;

   // Special Signals for f2i
   assign f2i_emin = rmode_00 ? 8'h7e : 8'h7f;
   
   assign f2i_exp_gt_max = (exp_in > f2i_emax);
   assign f2i_exp_lt_min = (exp_in < f2i_emin);
   
   // Incremented fraction for rounding
   assign fract_out_pl1 = fract_out + 24'd1;

   /*
    assign f2i_zero = (!opas & (exp_in<f2i_emin)) | 
    (opas & (exp_in>f2i_emax)) | 
    (opas & (exp_in<f2i_emin) & (fract_in_00 | !rmode_11));

    assign f2i_max = (!opas & (exp_in>f2i_emax)) | 
    (opas & (exp_in<f2i_emin) & !fract_in_00 & rmode_11);
    */
   // Zero when :
   // a) too small exp. and positive sign - result will be 0
   // b) too big exp. and negative sign - result will be largest possible -int
   // c) -infinity: largest possible -int
   // d) -0.0: give positive 0
   assign f2i_zero = (
		      ( (f2i_exp_lt_min & (opas & (!rmode_11 | fract_in_00))) |
			(f2i_exp_lt_min & !opas) |
			(f2i_exp_gt_max & opas) )
		      & !(&exp_in)
		      ) |
		     // -inf case
		     (opa_inf & opas) |
		       // -0.0 case
		       (fract_in_00 & exp_in_00);

   // Maximum :
   // a) too big exp and positive sign - result will be maximum int.
   // b) rounding negative down and less than minimum expon. for int = -1
   // c) +/- NaN or +inf - result will be maximum int
   // d) disabled when the -0.0 case comes up
   assign f2i_max = (
		     ( ((!opas & f2i_exp_gt_max) | 
			(f2i_exp_lt_min & !fract_in_00 & rmode_11 & opas)) 
		       & !(&exp_in)) |
		     // Either +/- NaN, or +inf
		     (opa_nan | (opa_inf & !opas))) &
		    // .. and NOT -0.0( 0x80000000)
                    !(opas & fract_in_00 & exp_in_00);
   
   // Claculate various shifting options
   assign f2i_shft  = exp_in-8'h7d;

   assign conv_shft = op_f2i ? f2i_shft : {2'h0, fi_ldz};

   assign fract_in_shftl   = (|conv_shft[7:6] | (f2i_zero & op_f2i)) ? 
			     0 : fract_in<<conv_shft[5:0];

   // Final fraction output
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  fract_out <= 1'b0;
	  fract_trunc <= 'd0;
       end
     else
       {fract_out,fract_trunc} <= fract_in_shftl;
   

   // ---------------------------------------------------------------------
   // Exponent Normalization

   assign fi_ldz_mi1    = fi_ldz - 6'd1;
   assign fi_ldz_mi22   = fi_ldz - 6'd22;
   assign exp_out_pl1   = exp_out + 8'd1;
   assign exp_out_mi1   = exp_out - 8'd1;
   assign exp_in_pl1    = exp_in  + 9'd1;	// 9 bits - includes carry out
   assign exp_in_mi1    = exp_in  - 9'd1;	// 9 bits - includes carry out
   assign exp_out1_mi1  = exp_out1 - 8'd1;

   assign exp_next_mi  = exp_in_pl1 - 
			 {3'd0,fi_ldz_mi1}; // 9 bits - includes carry out

   assign {exp_out1_co, exp_out1} = fract_in[47] ? exp_in_pl1 : exp_next_mi;
   
   // Only ever force positive if:
   // i) It's a NaN
   // ii) It's zero and not -inf
   // iii) We've rounded to 0 (both fract and exp out are 0 and not forced)
   // Force to 1 (negative) when have negative sign with too big exponent
   assign f2i_out_sign = (opas & (exp_in>f2i_emax) & f2i_zero) ?
			 1'b1 : opa_nan | (f2i_zero & !f2i_max & !(opa_inf & opas))
			   | (!(|out) & !f2i_zero)
			     ? 
			 1'b0 :opas;

   assign exp_i2f   = fract_in_00 ? (opas ? 8'h9e : 1'b0) : (8'h9e-{2'd0,fi_ldz});
   assign exp_f2i_1 = {{8{fract_in[47]}}, fract_in }<<f2i_shft;
   assign exp_f2i   = f2i_zero ? 1'b0 : f2i_max ? 8'hff : exp_f2i_1[55:48];
   assign conv_exp  = op_f2i ? exp_f2i : exp_i2f;

   //assign exp_out = conv_exp;
   always @(posedge clk or posedge rst)
     if (rst)
       exp_out <= 'd0;
     else
       exp_out <= conv_exp;
   

   assign ldz_all   = {1'b0,fi_ldz};
   assign fi_ldz_2a = 6'd23 - fi_ldz;
   assign fi_ldz_2  = {fi_ldz_2a[6], fi_ldz_2a[6:0]};


   // ---------------------------------------------------------------------
   // Round

   // Extract rounding (GRS) bits
   assign g = fract_out[0];
   assign r = fract_trunc[24];
   assign s = |fract_trunc[23:0];

   // Round to nearest even
   assign round = (g & r) | (r & s) ;
   assign {exp_rnd_adj0, fract_out_rnd0} = round ? 
					   fract_out_pl1 : {1'b0, fract_out};
   
   assign exp_out_rnd0 =  exp_rnd_adj0 ? exp_out_pl1 : exp_out;
   
   assign ovf0 = exp_out_final_ff & !rmode_01 & !op_f2i;

   // round to zero
   // Added detection of sign and rounding up in case of negative ftoi! - JPB
   assign fract_out_rnd1 = (exp_out_ff  & !dn & !op_f2i) ? 
			   23'h7fffff : 
			   (op_f2i & (|fract_trunc) & opas) ? 
			   fract_out_pl1[22:0] : fract_out ;

   assign exp_out_rnd1 = (g & r & s & exp_in_ff) ? 
			 exp_next_mi[7:0] : (exp_out_ff & !op_f2i) ? 
			 exp_in : 
			 (op_f2i & opas & (|fract_trunc) & fract_out_pl1[23]) ? 
			 exp_out_pl1: exp_out;

   assign ovf1 = exp_out_ff & !dn;

   // round to +inf (UP) and -inf (DOWN)
   assign r_sign = sign;

   assign round2a = !exp_out_fe | !fract_out_7fffff | 
		    (exp_out_fe & fract_out_7fffff);

   assign round2_fasu = ((r | s) & !r_sign) & (!exp_out[7] | 
					       (exp_out[7] & round2a));

   assign round2_f2i = rmode_10 & 
		       (( |fract_in[23:0] & !opas & (exp_in<8'h80 )) | 
			(|fract_trunc));
   
   assign round2 = op_f2i ? round2_f2i : round2_fasu;

   assign {exp_rnd_adj2a, fract_out_rnd2a} = round2 ? fract_out_pl1 : 
					     {1'b0, fract_out};
   
   assign exp_out_rnd2a  = exp_rnd_adj2a ?  exp_out_pl1 : exp_out;

   assign fract_out_rnd2 = (r_sign & exp_out_ff & !op_div & !dn & !op_f2i) ? 
			   23'h7fffff : fract_out_rnd2a;
   
   assign exp_out_rnd2   = (r_sign & exp_out_ff & !op_f2i) ? 
			   8'hfe      : exp_out_rnd2a;


   // Choose rounding mode
   always @(rmode or exp_out_rnd0 or exp_out_rnd1 or exp_out_rnd2)
     case(rmode)	// synopsys full_case parallel_case
       0: exp_out_rnd = exp_out_rnd0;
       1: exp_out_rnd = exp_out_rnd1;
       2,3: exp_out_rnd = exp_out_rnd2;
     endcase

   always @(rmode or fract_out_rnd0 or fract_out_rnd1 or fract_out_rnd2)
     case(rmode)	// synopsys full_case parallel_case
       0: fract_out_rnd = fract_out_rnd0;
       1: fract_out_rnd = fract_out_rnd1;
       2,3: fract_out_rnd = fract_out_rnd2;
     endcase
   
   // ---------------------------------------------------------------------
   // Final Output Mux
   // Fix Output for denormalized and special numbers

   assign fract_out_final = ovf0 ? 23'h0 :
			    (f2i_max & op_f2i) ? 23'h7fffff :
			    fract_out_rnd;
   
   assign exp_out_final = (f2i_max & op_f2i) ? 8'hff :  exp_out_rnd;

   // ---------------------------------------------------------------------
   // Pack Result
   
   assign out = {exp_out_final, fract_out_final};
   
   // ---------------------------------------------------------------------
   // Exceptions
   
   
   assign underflow = (!fract_in[47] & exp_out1_co) & !dn;
   
   
   assign overflow  = ovf0 | ovf1;
   
   wire 		f2i_ine;
   wire 		exp_in_lt_half = (exp_in<8'h80);
   
   assign f2i_ine = (f2i_zero & !fract_in_00 & !opas) |
		    (|fract_trunc) |
		    (f2i_zero & exp_in_lt_half  & opas & !fract_in_00) |
		    (f2i_max & rmode_11 & (exp_in<8'h80));

   assign ine =	op_f2i ? f2i_ine :
	       op_i2f ? (|fract_trunc) :
	       ((r & !dn) | (s & !dn) );

   assign inv = op_f2i & (exp_in > f2i_emax);
   
   

endmodule // miaow_fpu_post_norm_intfloat_conv

//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_post_norm_mul                                    ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  post-normalization entity for the multiplication unit       ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_post_norm_mul(
			 clk,
			 rst,
			 opa_i,
			 opb_i,
			 exp_10_i,
			 fract_48_i,
			 sign_i,
			 rmode_i,
			 output_o,
			 ine_o
			 );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;

   input clk;
   input rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   input [EXP_WIDTH+1:0] exp_10_i;
   input [2*FRAC_WIDTH+1:0] fract_48_i;
   input 		    sign_i;
   input [1:0] 		    rmode_i;
   output reg [FP_WIDTH-1:0] output_o;
   output reg 		     ine_o;

   
   reg [EXP_WIDTH-1:0] 	     s_expa;
   reg [EXP_WIDTH-1:0] 	     s_expb;
   reg [EXP_WIDTH+1:0] 	     s_exp_10_i;
   reg [2*FRAC_WIDTH+1:0]    s_fract_48_i;
   reg 			     s_sign_i;   
   wire [FP_WIDTH-1:0] 	     s_output_o;
   wire 		     s_ine_o;
   wire 		     s_overflow;   
   reg [FP_WIDTH-1:0] 	     s_opa_i;
   reg [FP_WIDTH-1:0] 	     s_opb_i;
   reg [1:0] 		     s_rmode_i;

   reg [5:0] 		     s_zeros;
   wire 		     s_carry;   
   reg [5:0] 		     s_shr2;
   reg [5:0] 		     s_shl2;
   reg [8:0] 		     s_expo1;
   wire [8:0] 		     s_expo2b;
   wire [9:0] 		     s_exp_10a;
   wire [9:0] 		     s_exp_10b;
   reg [47:0] 		     s_frac2a;

   wire 		     s_sticky, s_guard, s_round;   
   wire 		     s_roundup;   
   reg [24:0] 		     s_frac_rnd;
   wire [24:0] 		     s_frac3;
   wire 		     s_shr3;   
   reg [5:0] 		     s_r_zeros;
   wire 		     s_lost;   
   wire 		     s_op_0;   
   wire [8:0] 		     s_expo3;

   wire 		     s_infa, s_infb;   
   wire 		     s_nan_in, s_nan_op, s_nan_a, s_nan_b;   

   
   // Input Register
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_opa_i <= 'd0;
	  s_opb_i <= 'd0;
	  s_expa <= 'd0;
	  s_expb <= 'd0;
	  s_exp_10_i <= 1'b0;
	  s_fract_48_i <= 1'b0;
	  s_sign_i <= 1'b0;
	  s_rmode_i <= 2'b0;
       end
     else
       begin
	  s_opa_i <= opa_i;
	  s_opb_i <= opb_i;	
	  s_expa <= opa_i[30:23];
	  s_expb <= opb_i[30:23];
	  s_exp_10_i <= exp_10_i;
	  s_fract_48_i <= fract_48_i;
	  s_sign_i <= sign_i;
	  s_rmode_i <= rmode_i;
       end
   
   // Output register
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  output_o <= 'd0;
	  ine_o <= 1'b0;
       end
     else
       begin
	  output_o <= s_output_o;
	  ine_o	<= s_ine_o;
       end

   //*** Stage 1 ****
   // figure out the exponent and howmuch the fraction has to be shiftd 
   // right/left
   
   assign s_carry = s_fract_48_i[47];
   
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_zeros <= 0;
     else
       if (!s_fract_48_i[47])
	 casez(s_fract_48_i[46:1])	// synopsys full_case parallel_case
	   46'b1?????????????????????????????????????????????: s_zeros <=  0;
	   46'b01????????????????????????????????????????????: s_zeros <=  1;
	   46'b001???????????????????????????????????????????: s_zeros <=  2;
	   46'b0001??????????????????????????????????????????: s_zeros <=  3;
	   46'b00001?????????????????????????????????????????: s_zeros <=  4;
	   46'b000001????????????????????????????????????????: s_zeros <=  5;
	   46'b0000001???????????????????????????????????????: s_zeros <=  6;
	   46'b00000001??????????????????????????????????????: s_zeros <=  7;
	   46'b000000001?????????????????????????????????????: s_zeros <=  8;
	   46'b0000000001????????????????????????????????????: s_zeros <=  9;
	   46'b00000000001???????????????????????????????????: s_zeros <=  10;
	   46'b000000000001??????????????????????????????????: s_zeros <=  11;
	   46'b0000000000001?????????????????????????????????: s_zeros <=  12;
	   46'b00000000000001????????????????????????????????: s_zeros <=  13;
	   46'b000000000000001???????????????????????????????: s_zeros <=  14;
	   46'b0000000000000001??????????????????????????????: s_zeros <=  15;
	   46'b00000000000000001?????????????????????????????: s_zeros <=  16;
	   46'b000000000000000001????????????????????????????: s_zeros <=  17;
	   46'b0000000000000000001???????????????????????????: s_zeros <=  18;
	   46'b00000000000000000001??????????????????????????: s_zeros <=  19;
	   46'b000000000000000000001?????????????????????????: s_zeros <=  20;
	   46'b0000000000000000000001????????????????????????: s_zeros <=  21;
	   46'b00000000000000000000001???????????????????????: s_zeros <=  22;
	   46'b000000000000000000000001??????????????????????: s_zeros <=  23;
	   46'b0000000000000000000000001?????????????????????: s_zeros <=  24;
	   46'b00000000000000000000000001????????????????????: s_zeros <=  25;
	   46'b000000000000000000000000001???????????????????: s_zeros <=  26;
	   46'b0000000000000000000000000001??????????????????: s_zeros <=  27;
	   46'b00000000000000000000000000001?????????????????: s_zeros <=  28;
	   46'b000000000000000000000000000001????????????????: s_zeros <=  29;
	   46'b0000000000000000000000000000001???????????????: s_zeros <=  30;
	   46'b00000000000000000000000000000001??????????????: s_zeros <=  31;
	   46'b000000000000000000000000000000001?????????????: s_zeros <=  32;
	   46'b0000000000000000000000000000000001????????????: s_zeros <=  33;
	   46'b00000000000000000000000000000000001???????????: s_zeros <=  34;
	   46'b000000000000000000000000000000000001??????????: s_zeros <=  35;
	   46'b0000000000000000000000000000000000001?????????: s_zeros <=  36;
	   46'b00000000000000000000000000000000000001????????: s_zeros <=  37;
	   46'b000000000000000000000000000000000000001???????: s_zeros <=  38;
	   46'b0000000000000000000000000000000000000001??????: s_zeros <=  39;
	   46'b00000000000000000000000000000000000000001?????: s_zeros <=  40;
	   46'b000000000000000000000000000000000000000001????: s_zeros <=  41;
	   46'b0000000000000000000000000000000000000000001???: s_zeros <=  42;
	   46'b00000000000000000000000000000000000000000001??: s_zeros <=  43;
	   46'b000000000000000000000000000000000000000000001?: s_zeros <=  44;
	   46'b0000000000000000000000000000000000000000000001: s_zeros <=  45;
	   46'b0000000000000000000000000000000000000000000000: s_zeros <=  46;
	 endcase // casex (s_fract_48_i[46:1])
       else
	 s_zeros <= 0;


   always @(posedge clk or posedge rst)
     if (rst)
       s_r_zeros <= 0;
     else
       casez(s_fract_48_i) // synopsys full_case parallel_case
	 48'b???????????????????????????????????????????????1: s_r_zeros <=  0;
	 48'b??????????????????????????????????????????????10: s_r_zeros <=  1;
	 48'b?????????????????????????????????????????????100: s_r_zeros <=  2;
	 48'b????????????????????????????????????????????1000: s_r_zeros <=  3;
	 48'b???????????????????????????????????????????10000: s_r_zeros <=  4;
	 48'b??????????????????????????????????????????100000: s_r_zeros <=  5;
	 48'b?????????????????????????????????????????1000000: s_r_zeros <=  6;
	 48'b????????????????????????????????????????10000000: s_r_zeros <=  7;
	 48'b???????????????????????????????????????100000000: s_r_zeros <=  8;
	 48'b??????????????????????????????????????1000000000: s_r_zeros <=  9;
	 48'b?????????????????????????????????????10000000000: s_r_zeros <=  10;
	 48'b????????????????????????????????????100000000000: s_r_zeros <=  11;
	 48'b???????????????????????????????????1000000000000: s_r_zeros <=  12;
	 48'b??????????????????????????????????10000000000000: s_r_zeros <=  13;
	 48'b?????????????????????????????????100000000000000: s_r_zeros <=  14;
	 48'b????????????????????????????????1000000000000000: s_r_zeros <=  15;
	 48'b???????????????????????????????10000000000000000: s_r_zeros <=  16;
	 48'b??????????????????????????????100000000000000000: s_r_zeros <=  17;
	 48'b?????????????????????????????1000000000000000000: s_r_zeros <=  18;
	 48'b????????????????????????????10000000000000000000: s_r_zeros <=  19;
	 48'b???????????????????????????100000000000000000000: s_r_zeros <=  20;
	 48'b??????????????????????????1000000000000000000000: s_r_zeros <=  21;
	 48'b?????????????????????????10000000000000000000000: s_r_zeros <=  22;
	 48'b????????????????????????100000000000000000000000: s_r_zeros <=  23;
	 48'b???????????????????????1000000000000000000000000: s_r_zeros <=  24;
	 48'b??????????????????????10000000000000000000000000: s_r_zeros <=  25;
	 48'b?????????????????????100000000000000000000000000: s_r_zeros <=  26;
	 48'b????????????????????1000000000000000000000000000: s_r_zeros <=  27;
	 48'b???????????????????10000000000000000000000000000: s_r_zeros <=  28;
	 48'b??????????????????100000000000000000000000000000: s_r_zeros <=  29;
	 48'b?????????????????1000000000000000000000000000000: s_r_zeros <=  30;
	 48'b????????????????10000000000000000000000000000000: s_r_zeros <=  31;
	 48'b???????????????100000000000000000000000000000000: s_r_zeros <=  32;
	 48'b??????????????1000000000000000000000000000000000: s_r_zeros <=  33;
	 48'b?????????????10000000000000000000000000000000000: s_r_zeros <=  34;
	 48'b????????????100000000000000000000000000000000000: s_r_zeros <=  35;
	 48'b???????????1000000000000000000000000000000000000: s_r_zeros <=  36;
	 48'b??????????10000000000000000000000000000000000000: s_r_zeros <=  37;
	 48'b?????????100000000000000000000000000000000000000: s_r_zeros <=  38;
	 48'b????????1000000000000000000000000000000000000000: s_r_zeros <=  39;
	 48'b???????10000000000000000000000000000000000000000: s_r_zeros <=  40;
	 48'b??????100000000000000000000000000000000000000000: s_r_zeros <=  41;
	 48'b?????1000000000000000000000000000000000000000000: s_r_zeros <=  42;
	 48'b????10000000000000000000000000000000000000000000: s_r_zeros <=  43;
	 48'b???100000000000000000000000000000000000000000000: s_r_zeros <=  44;
	 48'b??1000000000000000000000000000000000000000000000: s_r_zeros <=  45;
	 48'b?10000000000000000000000000000000000000000000000: s_r_zeros <=  46;
	 48'b100000000000000000000000000000000000000000000000: s_r_zeros <=  47;
	 48'b000000000000000000000000000000000000000000000000: s_r_zeros <=  48;
       endcase // casex (s_fract_48_i)

   assign s_exp_10a = s_exp_10_i + {9'd0,s_carry};		
   assign s_exp_10b = s_exp_10a - {4'd0,s_zeros};

   wire [9:0] v_shr1;
   wire [9:0] v_shl1;
   
   assign v_shr1 = (s_exp_10a[9] | !(|s_exp_10a)) ?
		   10'd1 - s_exp_10a + {9'd0,s_carry} :
		   (s_exp_10b[9] | !(|s_exp_10b)) ?
		   1'b0 :
		   s_exp_10b[8] ?
		   1'b0 : {9'd0,s_carry};
   
   assign v_shl1 = (s_exp_10a[9] | !(|s_exp_10a)) ?
		   1'b0 :
		   (s_exp_10b[9] | !(|s_exp_10b)) ?
		   {4'd0,s_zeros} - s_exp_10a :
		   s_exp_10b[8] ?
		   1'b0 : {4'd0,s_zeros};
   
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_expo1 <= 'd0;
     else
       begin
	  if ((s_exp_10a[9] | !(|s_exp_10a)))
	    s_expo1 <= 9'd1;
	  else if (s_exp_10b[9] | !(|s_exp_10b))
	    s_expo1 <= 9'd1;
	  else if (s_exp_10b[8])
	    s_expo1 <= 9'b011111111;
	  else
	    s_expo1 <= s_exp_10b[8:0];
	  
	  if (v_shr1[6])
	    s_shr2 <= {6{1'b1}};
	  else
	    s_shr2 <= v_shr1[5:0];

	  s_shl2 <= v_shl1[5:0];
       end // always @ (posedge clk or posedge rst)
   
   // *** Stage 2 ***
   // Shifting the fraction and rounding
   
   
   // shift the fraction
   always @(posedge clk or posedge rst)
     if (rst)
       s_frac2a <= 'd0;
     else
       if (|s_shr2)
	 s_frac2a <= s_fract_48_i >> s_shr2;
       else 
	 s_frac2a <= s_fract_48_i << s_shl2; 
   
   assign s_expo2b = s_frac2a[46] ? s_expo1 : s_expo1 - 9'd1;

   // signals if precision was last during the right-shift above
   assign s_lost = (s_shr2 + {5'd0,s_shr3}) > s_r_zeros;
   
   // ***Stage 3***
   // Rounding

   //								   23
   //									|	
   // 			xx00000000000000000000000grsxxxxxxxxxxxxxxxxxxxx
   // guard bit: s_frac2a[23] (LSB of output)
   // round bit: s_frac2a[22]
   assign s_guard = s_frac2a[22];
   assign s_round = s_frac2a[21];
   assign s_sticky = (|s_frac2a[20:0]) | s_lost;
   
   assign s_roundup = s_rmode_i==2'b00 ? // round to nearest even
		      s_guard & ((s_round | s_sticky) | s_frac2a[23]) :
		      s_rmode_i==2'b10 ? // round up
		      (s_guard | s_round | s_sticky) & !s_sign_i :
		      s_rmode_i==2'b11 ? // round down
		      (s_guard | s_round | s_sticky) & s_sign_i : 
		      1'b0; // round to zero(truncate = no rounding)
   
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_frac_rnd <= 'd0;
     else
       if (s_roundup)
	 s_frac_rnd <= s_frac2a[47:23] + 1; 
       else 
	 s_frac_rnd <= s_frac2a[47:23];
   
   assign s_shr3 = s_frac_rnd[24];


   assign s_expo3 = (s_shr3 & (s_expo2b!=9'b011111111)) ? 
		    s_expo2b + 1'b1 : s_expo2b;
   
   assign s_frac3 = (s_shr3 & (s_expo2b!=9'b011111111)) ? 
		    {1'b0,s_frac_rnd[24:1]} : s_frac_rnd; 
   
   //-***Stage 4****
   // Output
   
   assign s_op_0 = !((|s_opa_i[30:0]) & (|s_opb_i[30:0]));
   
   assign s_infa = &s_expa;
   
   assign s_infb = &s_expb;
   
   assign s_nan_a = s_infa & (|s_opa_i[22:0]);
   
   assign s_nan_b = s_infb & (|s_opb_i[22:0]);
   
   assign s_nan_in = s_nan_a | s_nan_b;
   
   assign s_nan_op = (s_infa | s_infb) & s_op_0; // 0 * inf = nan
   
   assign s_overflow = (s_expo3==9'b011111111) & !(s_infa | s_infb);
   
   assign s_ine_o = !s_op_0 & (s_lost | (|s_frac2a[22:0]) | s_overflow);
   
   assign s_output_o = (s_nan_in | s_nan_op) ?
		       {s_sign_i,QNAN} :
		       (s_infa | s_infb) | s_overflow ?
		       {s_sign_i,INF} :
		       s_r_zeros==48 ?
		       {s_sign_i,ZERO_VECTOR} :
		       {s_sign_i,s_expo3[7:0],s_frac3[22:0]};

endmodule // miaow_fpu_post_norm_mul

//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_pre_norm_addsub                                  ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  pre-normalization entity for the addition/subtraction unit  ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_pre_norm_addsub (

			    clk,
 			    rst,
			    opa_i,		
			    opb_i,		
			    fracta_28_o, 
			    fractb_28_o,
			    exp_o
			    );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;


   input clk;
   input rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   // carry(1) & hidden(1) & fraction(23) & guard(1) & round(1) & sticky(1)
   output reg [FRAC_WIDTH+4:0] fracta_28_o;
   output reg [FRAC_WIDTH+4:0] fractb_28_o;
   output reg [EXP_WIDTH-1:0]  exp_o;
   
   reg [EXP_WIDTH-1 : 0]       s_exp_o ;
   wire [FRAC_WIDTH+4 : 0]     s_fracta_28_o, s_fractb_28_o ;
   wire [EXP_WIDTH-1 : 0]      s_expa;
   wire [EXP_WIDTH-1 : 0]      s_expb ;
   wire [FRAC_WIDTH-1 : 0]     s_fracta;
   wire [FRAC_WIDTH-1 : 0]     s_fractb ;
   wire [FRAC_WIDTH+4 : 0]     s_fracta_28;

   wire [FRAC_WIDTH+4 : 0]     s_fractb_28 ;
   
   wire [FRAC_WIDTH+4 : 0]     s_fract_sm_28;
   wire [FRAC_WIDTH+4 : 0]     s_fract_shr_28 ;
   
   reg [EXP_WIDTH-1 : 0]       s_exp_diff ;
   reg [5 : 0] 		       s_rzeros ;
   wire 		       s_expa_eq_expb;
   wire 		       s_expa_gt_expb;
   wire 		       s_fracta_1;
   wire 		       s_fractb_1;
   wire 		       s_op_dn,s_opa_dn, s_opb_dn;
   wire [1 : 0] 	       s_mux_diff ;
   wire 		       s_mux_exp;
   wire 		       s_sticky;


   assign s_expa = opa_i[30:23];
   assign s_expb = opb_i[30:23];
   assign s_fracta = opa_i[22:0];
   assign s_fractb = opb_i[22:0];
   
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  exp_o <= 'd0;
	  fracta_28_o <= 'd0;
	  fractb_28_o <= 'd0;
       end
     else
       begin
	  exp_o <= s_exp_o;
	  fracta_28_o <= s_fracta_28_o;
	  fractb_28_o <= s_fractb_28_o;	
       end
   
   assign s_expa_eq_expb = (s_expa == s_expb);
   
   assign s_expa_gt_expb = (s_expa > s_expb);
   
   // '1' if fraction is not zero
   assign s_fracta_1 = |s_fracta;
   assign s_fractb_1 = |s_fractb; 
   
   // opa or Opb is denormalized
   assign s_opa_dn = !(|s_expa);
   assign s_opb_dn = !(|s_expb);
   assign s_op_dn = s_opa_dn | s_opb_dn; 

   // Output larger exponent
   assign s_mux_exp = s_expa_gt_expb;
   
   always @(posedge clk or posedge rst)
     if (rst)
       s_exp_o <= 'd0;
     else
       s_exp_o <= s_mux_exp ? s_expa : s_expb;
   
   // convert to an easy to handle floating-point format
   assign s_fracta_28 = s_opa_dn ? 
			{2'b00, s_fracta, 3'b000} : {2'b01, s_fracta, 3'b000};
   assign s_fractb_28 = s_opb_dn ? 
			{2'b00, s_fractb, 3'b000} : {2'b01, s_fractb, 3'b000};
   
   assign s_mux_diff = {s_expa_gt_expb, s_opa_dn ^ s_opb_dn};
   
   // calculate howmany postions the fraction will be shifted
   always @(posedge clk or posedge rst)
     if (rst)
       s_exp_diff <= 'd0;
     else
       begin
	  case(s_mux_diff)
	    2'b00: s_exp_diff <= s_expb - s_expa;
	    2'b01: s_exp_diff <= s_expb - (s_expa + 8'd1);
	    2'b10: s_exp_diff <= s_expa - s_expb;
	    2'b11: s_exp_diff <= s_expa - (s_expb + 8'd1);
	  endcase
       end
   
   assign s_fract_sm_28 =  s_expa_gt_expb ? s_fractb_28 : s_fracta_28;
   
   // shift-right the fraction if necessary
   assign s_fract_shr_28 = s_fract_sm_28 >> s_exp_diff;

   // count the zeros from right to check if result is inexact
   always @(s_fract_sm_28)
     casez(s_fract_sm_28) // synopsys full_case parallel_case
       28'b???????????????????????????1: s_rzeros = 0;
       28'b??????????????????????????10: s_rzeros = 1;
       28'b?????????????????????????100: s_rzeros = 2;
       28'b????????????????????????1000: s_rzeros = 3;
       28'b???????????????????????10000: s_rzeros = 4;
       28'b??????????????????????100000: s_rzeros = 5;
       28'b?????????????????????1000000: s_rzeros = 6;
       28'b????????????????????10000000: s_rzeros = 7;
       28'b???????????????????100000000: s_rzeros = 8;
       28'b??????????????????1000000000: s_rzeros = 9;
       28'b?????????????????10000000000: s_rzeros = 10;
       28'b????????????????100000000000: s_rzeros = 11;
       28'b???????????????1000000000000: s_rzeros = 12;
       28'b??????????????10000000000000: s_rzeros = 13;
       28'b?????????????100000000000000: s_rzeros = 14;
       28'b????????????1000000000000000: s_rzeros = 15;
       28'b???????????10000000000000000: s_rzeros = 16;
       28'b??????????100000000000000000: s_rzeros = 17;
       28'b?????????1000000000000000000: s_rzeros = 18;
       28'b????????10000000000000000000: s_rzeros = 19;
       28'b???????100000000000000000000: s_rzeros = 20;
       28'b??????1000000000000000000000: s_rzeros = 21;
       28'b?????10000000000000000000000: s_rzeros = 22;
       28'b????100000000000000000000000: s_rzeros = 23;
       28'b???1000000000000000000000000: s_rzeros = 24;
       28'b??10000000000000000000000000: s_rzeros = 25;
       28'b?100000000000000000000000000: s_rzeros = 26;
       28'b1000000000000000000000000000: s_rzeros = 27;
       28'b0000000000000000000000000000: s_rzeros = 28;
     endcase // casex (s_fract_sm_28)
   
   assign s_sticky = (s_exp_diff > {2'b00,s_rzeros}) & (|s_fract_sm_28);
   
   assign s_fracta_28_o = s_expa_gt_expb ?
			  s_fracta_28 :
			  {s_fract_shr_28[27:1],(s_sticky|s_fract_shr_28[0])};
   
   assign s_fractb_28_o =  s_expa_gt_expb ? 
			   {s_fract_shr_28[27:1],(s_sticky|s_fract_shr_28[0])} :
			   s_fractb_28;

endmodule // miaow_fpu_pre_norm_addsub


//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_pre_norm_div                                     ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  pre-normalization entity for the division unit              ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_pre_norm_div
  (
   clk,
   rst,
   opa_i,
   opb_i,
   exp_10_o,
   dvdnd_50_o,
   dvsor_27_o
   );

   
   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;

   input clk;
   input rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   output reg [EXP_WIDTH+1:0] exp_10_o;
   output [2*(FRAC_WIDTH+2)-1:0] dvdnd_50_o;
   output [FRAC_WIDTH+3:0] 	 dvsor_27_o;

   
   wire [EXP_WIDTH-1:0] 	 s_expa;
   wire [EXP_WIDTH-1:0] 	 s_expb;
   wire [FRAC_WIDTH-1:0] 	 s_fracta;
   wire [FRAC_WIDTH-1:0] 	 s_fractb;
   wire [2*(FRAC_WIDTH+2)-1:0] 	 s_dvdnd_50_o;
   wire [FRAC_WIDTH+3:0] 	 s_dvsor_27_o;
   reg [5:0] 			 s_dvd_zeros;
   reg [5:0] 			 s_div_zeros;
   reg [EXP_WIDTH+1:0] 		 s_exp_10_o;
   
   reg [EXP_WIDTH+1:0] 		 s_expa_in;
   reg [EXP_WIDTH+1:0] 		 s_expb_in;
   wire 			 s_opa_dn, s_opb_dn;
   
   wire [FRAC_WIDTH:0] 		 s_fracta_24;
   wire [FRAC_WIDTH:0] 		 s_fractb_24;

   
   assign s_expa = opa_i[30:23];
   assign s_expb = opb_i[30:23];
   assign s_fracta = opa_i[22:0];
   assign s_fractb = opb_i[22:0];
   assign dvdnd_50_o = s_dvdnd_50_o;
   assign dvsor_27_o	= s_dvsor_27_o;
   
   // Output Register
   always @(posedge clk or posedge rst)
     if (rst)
       exp_10_o <= 'd0;
     else
       exp_10_o <= s_exp_10_o;

   assign s_opa_dn = !(|s_expa);
   assign s_opb_dn = !(|s_expb);
   
   assign s_fracta_24 = {!s_opa_dn,s_fracta};
   assign s_fractb_24 = {!s_opb_dn,s_fractb};
   
   
   // count leading zeros
   //s_dvd_zeros <= count_l_zeros( s_fracta_24 );
   always @(s_fracta_24)
     casez(s_fracta_24)	// synopsys full_case parallel_case
       24'b1???????????????????????: s_dvd_zeros = 0;
       24'b01??????????????????????: s_dvd_zeros = 1;
       24'b001?????????????????????: s_dvd_zeros = 2;
       24'b0001????????????????????: s_dvd_zeros = 3;
       24'b00001???????????????????: s_dvd_zeros = 4;
       24'b000001??????????????????: s_dvd_zeros = 5;
       24'b0000001?????????????????: s_dvd_zeros = 6;
       24'b00000001????????????????: s_dvd_zeros = 7;
       24'b000000001???????????????: s_dvd_zeros = 8;
       24'b0000000001??????????????: s_dvd_zeros = 9;
       24'b00000000001?????????????: s_dvd_zeros = 10;
       24'b000000000001????????????: s_dvd_zeros = 11;
       24'b0000000000001???????????: s_dvd_zeros = 12;
       24'b00000000000001??????????: s_dvd_zeros = 13;
       24'b000000000000001?????????: s_dvd_zeros = 14;
       24'b0000000000000001????????: s_dvd_zeros = 15;
       24'b00000000000000001???????: s_dvd_zeros = 16;
       24'b000000000000000001??????: s_dvd_zeros = 17;
       24'b0000000000000000001?????: s_dvd_zeros = 18;
       24'b00000000000000000001????: s_dvd_zeros = 19;
       24'b000000000000000000001???: s_dvd_zeros = 20;
       24'b0000000000000000000001??: s_dvd_zeros = 21;
       24'b00000000000000000000001?: s_dvd_zeros = 22;
       24'b000000000000000000000001: s_dvd_zeros = 23;
       24'b000000000000000000000000: s_dvd_zeros = 24;
     endcase

   //s_div_zeros <= count_l_zeros( s_fractb_24 );
   always @(s_fractb_24)
     casez(s_fractb_24)	// synopsys full_case parallel_case
       24'b1???????????????????????: s_div_zeros = 0;
       24'b01??????????????????????: s_div_zeros = 1;
       24'b001?????????????????????: s_div_zeros = 2;
       24'b0001????????????????????: s_div_zeros = 3;
       24'b00001???????????????????: s_div_zeros = 4;
       24'b000001??????????????????: s_div_zeros = 5;
       24'b0000001?????????????????: s_div_zeros = 6;
       24'b00000001????????????????: s_div_zeros = 7;
       24'b000000001???????????????: s_div_zeros = 8;
       24'b0000000001??????????????: s_div_zeros = 9;
       24'b00000000001?????????????: s_div_zeros = 10;
       24'b000000000001????????????: s_div_zeros = 11;
       24'b0000000000001???????????: s_div_zeros = 12;
       24'b00000000000001??????????: s_div_zeros = 13;
       24'b000000000000001?????????: s_div_zeros = 14;
       24'b0000000000000001????????: s_div_zeros = 15;
       24'b00000000000000001???????: s_div_zeros = 16;
       24'b000000000000000001??????: s_div_zeros = 17;
       24'b0000000000000000001?????: s_div_zeros = 18;
       24'b00000000000000000001????: s_div_zeros = 19;
       24'b000000000000000000001???: s_div_zeros = 20;
       24'b0000000000000000000001??: s_div_zeros = 21;
       24'b00000000000000000000001?: s_div_zeros = 22;
       24'b000000000000000000000001: s_div_zeros = 23;
       24'b000000000000000000000000: s_div_zeros = 24;
     endcase

   // left-shift the dividend and divisor
   wire [FRAC_WIDTH:0] 		 fracta_lshift_intermediate;
   wire [FRAC_WIDTH:0] 		 fractb_lshift_intermediate;
   assign fracta_lshift_intermediate = s_fracta_24 << s_dvd_zeros;
   assign fractb_lshift_intermediate = s_fractb_24 << s_div_zeros;
   
   assign s_dvdnd_50_o = {fracta_lshift_intermediate,26'd0};
   
   assign s_dvsor_27_o = {3'd0,fractb_lshift_intermediate};
   
   always @(posedge clk or posedge rst)
     if (rst)
       begin
	  s_expa_in <= 'd0;
	  s_expb_in <= 'd0;
	  s_exp_10_o <= 'd0;
       end
     else
       begin
	  // pre-calculate exponent
	  s_expa_in <= {2'd0,s_expa} + {9'd0,s_opa_dn};
	  s_expb_in <= {2'd0,s_expb} + {9'd0,s_opb_dn};	
	  s_exp_10_o <= s_expa_in - s_expb_in + 10'b0001111111 - 
			{4'd0,s_dvd_zeros} + {4'd0,s_div_zeros};
       end

   
endmodule // miaow_fpu_pre_norm_div

//////////////////////////////////////////////////////////////////////
////                                                              ////
////  miaow_fpu_pre_norm_mul                                     ////
////                                                              ////
////  This file is part of the OpenRISC 1200 project              ////
////  http://opencores.org/project,or1k                           ////
////                                                              ////
////  Description                                                 ////
////  pre-normalization entity for the multiplication unit        ////
////                                                              ////
////  To Do:                                                      ////
////                                                              ////
////                                                              ////
////  Author(s):                                                  ////
////      - Original design (FPU100) -                            ////
////        Jidan Al-eryani, jidan@gmx.net                        ////
////      - Conv. to Verilog and inclusion in OR1200 -            ////
////        Julius Baxter, julius@opencores.org                   ////
////                                                              ////
//////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2006, 2010
//
//	This source file may be used and distributed without        
//	restriction provided that this copyright statement is not   
//	removed from the file and that any derivative work contains 
//	the original copyright notice and the associated disclaimer.
//                                                           
//		THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     
//	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   
//	TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   
//	FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      
//	OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         
//	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    
//	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        
//	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  
//	LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  
//	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  
//	OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         
//	POSSIBILITY OF SUCH DAMAGE. 
//

module miaow_fpu_pre_norm_mul (
			 clk,
			 rst,
			 opa_i,
			 opb_i,
			 exp_10_o,
			 fracta_24_o,
			 fractb_24_o
			 );

   parameter FP_WIDTH = 32;
   parameter MUL_SERIAL = 0; // 0 for parallel multiplier, 1 for serial
   parameter MUL_COUNT = 11; //11 for parallel multiplier, 34 for serial
   parameter FRAC_WIDTH = 23;
   parameter EXP_WIDTH = 8;
   parameter ZERO_VECTOR = 31'd0;
   parameter INF = 31'b1111111100000000000000000000000;
   parameter QNAN = 31'b1111111110000000000000000000000;
   parameter SNAN = 31'b1111111100000000000000000000001;


   input clk;
   input rst;
   
   input [FP_WIDTH-1:0] opa_i;
   input [FP_WIDTH-1:0] opb_i;
   output reg [EXP_WIDTH+1:0] exp_10_o;
   output [FRAC_WIDTH:0]      fracta_24_o;
   output [FRAC_WIDTH:0]      fractb_24_o; 

   
   wire [EXP_WIDTH-1:0]       s_expa;
   wire [EXP_WIDTH-1:0]       s_expb;
   
   wire [FRAC_WIDTH-1:0]      s_fracta;
   wire [FRAC_WIDTH-1:0]      s_fractb;

   wire [EXP_WIDTH+1:0]       s_exp_10_o;
   wire [EXP_WIDTH+1:0]       s_expa_in;
   wire [EXP_WIDTH+1:0]       s_expb_in;
   
   wire 		      s_opa_dn, s_opb_dn;

   assign s_expa = opa_i[30:23];
   assign s_expb = opb_i[30:23];
   assign s_fracta = opa_i[22:0];
   assign s_fractb = opb_i[22:0];
   
   // Output Register
   always @(posedge clk or posedge rst)
     if (rst)
       exp_10_o <= 'd0;
     else
       exp_10_o <= s_exp_10_o;
   
   // opa or opb is denormalized
   assign s_opa_dn = !(|s_expa);
   assign s_opb_dn = !(|s_expb);
   
   assign fracta_24_o = {!s_opa_dn, s_fracta};
   assign fractb_24_o = {!s_opb_dn, s_fractb};
   
   assign s_expa_in = {2'd0, s_expa} + {9'd0, s_opa_dn};
   assign s_expb_in = {2'd0, s_expb} + {9'd0, s_opb_dn};
   
   assign s_exp_10_o = s_expa_in + s_expb_in - 10'b0001111111;		

endmodule // miaow_fpu_pre_norm_mul


module simf(
      issue_source_reg1,
      issue_source_reg2,
      issue_source_reg3,
      issue_dest_reg1,
      issue_dest_reg2,
      issue_imm_value0,
      issue_imm_value1,
      issue_opcode,
      issue_wfid,
      issue_alu_select,
      vgpr_source1_data,
      vgpr_source2_data,
      vgpr_source3_data,
      sgpr_rd_data,
      exec_rd_exec_value,
      exec_rd_vcc_value,
      exec_rd_m0_value,
      exec_rd_scc_value,
      issue_instr_pc,
      rfa_queue_entry_serviced,
      vgpr_source1_rd_en,
      vgpr_source2_rd_en,
      vgpr_source3_rd_en,
      vgpr_source1_addr,
      vgpr_source2_addr,
      vgpr_source3_addr,
      vgpr_dest_addr,
      vgpr_dest_data,
      vgpr_wr_en,
      vgpr_wr_mask,
      exec_rd_wfid,
      exec_rd_en,
      exec_wr_vcc_wfid,
      exec_wr_vcc_en,
      exec_wr_vcc_value,
      sgpr_rd_en,
      sgpr_rd_addr,
      sgpr_wr_addr,
      sgpr_wr_en,
      sgpr_wr_data,
      sgpr_wr_mask,
      issue_alu_ready,
      vgpr_instr_done_wfid,
      vgpr_instr_done,
      rfa_queue_entry_valid,
      tracemon_retire_pc,
      clk,
      rst
 );

input clk;

input rst;

input issue_alu_select, exec_rd_scc_value, rfa_queue_entry_serviced;
input[5:0] issue_wfid;
input[11:0] issue_source_reg1, issue_source_reg2, issue_source_reg3,
         issue_dest_reg1, issue_dest_reg2;
input[15:0] issue_imm_value0;
input[31:0] issue_imm_value1, issue_opcode, sgpr_rd_data, exec_rd_m0_value,
         issue_instr_pc;
input[63:0] exec_rd_exec_value, exec_rd_vcc_value;
input[2047:0] vgpr_source1_data, vgpr_source2_data, vgpr_source3_data;

output vgpr_source1_rd_en, vgpr_source2_rd_en, vgpr_source3_rd_en, vgpr_wr_en,
         exec_rd_en, exec_wr_vcc_en, sgpr_rd_en, sgpr_wr_en, issue_alu_ready,
         vgpr_instr_done, rfa_queue_entry_valid;
output[5:0] exec_rd_wfid, exec_wr_vcc_wfid, vgpr_instr_done_wfid;
output[8:0] sgpr_rd_addr, sgpr_wr_addr;
output[9:0] vgpr_source1_addr, vgpr_source2_addr, vgpr_source3_addr,
         vgpr_dest_addr;
output[31:0] tracemon_retire_pc;
output[63:0] vgpr_wr_mask, exec_wr_vcc_value, sgpr_wr_data, sgpr_wr_mask;
output[2047:0] vgpr_dest_data;

alu #(.MODULE(1))
      alu(
      .issue_source_reg1(issue_source_reg1),
      .issue_source_reg2(issue_source_reg2),
      .issue_source_reg3(issue_source_reg3),
      .issue_dest_reg1(issue_dest_reg1),
      .issue_dest_reg2(issue_dest_reg2),
      .issue_imm_value0(issue_imm_value0),
      .issue_imm_value1(issue_imm_value1),
      .issue_opcode(issue_opcode),
      .issue_wfid(issue_wfid),
      .issue_alu_select(issue_alu_select),
      .vgpr_source1_data(vgpr_source1_data),
      .vgpr_source2_data(vgpr_source2_data),
      .vgpr_source3_data(vgpr_source3_data),
      .sgpr_rd_data(sgpr_rd_data),
      .exec_rd_exec_value(exec_rd_exec_value),
      .exec_rd_vcc_value(exec_rd_vcc_value),
      .exec_rd_m0_value(exec_rd_m0_value),
      .exec_rd_scc_value(exec_rd_scc_value),
      .issue_instr_pc(issue_instr_pc),
      .rfa_queue_entry_serviced(rfa_queue_entry_serviced),
      .vgpr_source1_rd_en(vgpr_source1_rd_en),
      .vgpr_source2_rd_en(vgpr_source2_rd_en),
      .vgpr_source3_rd_en(vgpr_source3_rd_en),
      .vgpr_source1_addr(vgpr_source1_addr),
      .vgpr_source2_addr(vgpr_source2_addr),
      .vgpr_source3_addr(vgpr_source3_addr),
      .vgpr_dest_addr(vgpr_dest_addr),
      .vgpr_dest_data(vgpr_dest_data),
      .vgpr_wr_en(vgpr_wr_en),
      .vgpr_wr_mask(vgpr_wr_mask),
      .exec_rd_wfid(exec_rd_wfid),
      .exec_rd_en(exec_rd_en),
      .exec_wr_vcc_wfid(exec_wr_vcc_wfid),
      .exec_wr_vcc_en(exec_wr_vcc_en),
      .exec_wr_vcc_value(exec_wr_vcc_value),
      .sgpr_rd_en(sgpr_rd_en),
      .sgpr_rd_addr(sgpr_rd_addr),
      .sgpr_wr_addr(sgpr_wr_addr),
      .sgpr_wr_en(sgpr_wr_en),
      .sgpr_wr_data(sgpr_wr_data),
      .sgpr_wr_mask(sgpr_wr_mask),
      .issue_alu_ready(issue_alu_ready),
      .vgpr_instr_done_wfid(vgpr_instr_done_wfid),
      .vgpr_instr_done(vgpr_instr_done),
      .rfa_queue_entry_valid(rfa_queue_entry_valid),
      .tracemon_retire_pc(tracemon_retire_pc),
      .clk(clk),
      .rst(rst)
 );

endmodule
module simf_alu
  (
   alu_source1_data,
   alu_source2_data,
   alu_source3_data, //TODO
   alu_source_vcc_value,
   alu_source_exec_value,
   alu_control,
   alu_start,
   alu_vgpr_dest_data,
   alu_sgpr_dest_data,
   alu_dest_vcc_value,
   alu_done,
   clk,
   rst
   );

   //TODO check overflow for signed and unsigned

   input clk;
   input rst;

   input [31:0]  alu_source1_data;
   input [31:0]  alu_source2_data;
   input [31:0]  alu_source3_data;
   input         alu_source_vcc_value;
   input         alu_source_exec_value;

   input [31:0]  alu_control;
   input         alu_start;

   output [31:0] alu_vgpr_dest_data;
   output        alu_sgpr_dest_data;
   output        alu_dest_vcc_value;
   output        alu_done;

   reg [31:0]    alu_vgpr_dest_data;
   reg           alu_done;
   reg           alu_dest_vcc_value;

   reg [31:0] final_source1_data;
   reg [31:0] final_source2_data;
	 reg [31:0] final_source3_data; // VIN
	 reg [31:0] temp_dest_data; 		//VIN


	 //Signals used by the fpu
   reg [31:0] miaow_fpu_opa_i;
   reg [31:0] miaow_fpu_opb_i;
   reg [2:0] miaow_fpu_op_i;
   wire [1:0] miaow_fpu_rmode_i;
   wire [31:0] miaow_fpu_output_o;
   reg miaow_fpu_start_i;
   wire miaow_fpu_ready_o;

   assign miaow_fpu_rmode_i = 2'b00;

   miaow_fpu_arith fpu(
               .clk(clk),
               .rst(rst),
               .opa_i(miaow_fpu_opa_i),
               .opb_i(miaow_fpu_opb_i),
               .miaow_fpu_op_i(miaow_fpu_op_i),
               .rmode_i(miaow_fpu_rmode_i),
               .output_o(miaow_fpu_output_o),
               .start_i(miaow_fpu_start_i),
               .ready_o(miaow_fpu_ready_o),
               .ine_o(),
               .overflow_o(),
               .underflow_o(),
               .div_zero_o(),
               .inf_o(),
               .zero_o(),
               .qnan_o(),
               .snan_o()
               );

   assign alu_sgpr_dest_data = alu_dest_vcc_value;
   
   
   always @* begin
      casex(alu_control[31:24])
         {8'h10} :
            begin
               final_source1_data <= alu_source1_data;
               final_source2_data <= alu_source2_data;
							 final_source3_data <= alu_source3_data; //VIN
            end
         {8'h08} :
            begin
               final_source1_data <= alu_source1_data;
               final_source2_data <= alu_source2_data;
							 final_source3_data <= alu_source3_data; //VIN
            end
         default : //VOP1, VOP2 and VOPC
            begin
               final_source1_data <= alu_source1_data;
               final_source2_data <= alu_source2_data;
							 final_source3_data <= alu_source3_data; //VIN
            end
      endcase
   end // always @ (...

	
   always @* begin
      casex({alu_source_exec_value, alu_control[31:24], alu_control[11:0]})
         {1'b0, 8'h??, 12'h???} : //EXEC disabled
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'b000;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h003} : //V_ADD_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b000;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h004} : //V_SUB_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b001;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h005} : //V_SUBREV_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b001;
               miaow_fpu_opa_i <= final_source2_data;
               miaow_fpu_opb_i <= final_source1_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h010} : //V_MAX_F32  - VIN
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= (final_source1_data >= final_source2_data) ? final_source1_data : final_source2_data;
               alu_dest_vcc_value <= alu_source_vcc_value;
						end
         {1'b1, 8'h02, 12'h02A} : //V_RCP_F32  - VIN
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b011;
               miaow_fpu_opa_i <= 32'h3f80_0000;
               miaow_fpu_opb_i <= final_source1_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
			end
         {1'b1, 8'h02, 12'h006} : //V_CVT_F32_U32 
            begin
                alu_done <=miaow_fpu_ready_o;// 1'b1;
                miaow_fpu_start_i <= alu_start;
                miaow_fpu_op_i <= 3'b100;
                miaow_fpu_opa_i <= final_source1_data;
                miaow_fpu_opb_i <= 32'h3f80_0000;
                alu_vgpr_dest_data <= miaow_fpu_output_o[31] ? 32'h7f800000 : miaow_fpu_output_o;
                alu_dest_vcc_value <= alu_source_vcc_value;
            end
          {1'b1, 8'h02, 12'h007} : //V_CVT_F32_U32 
            begin
                alu_done <=miaow_fpu_ready_o;// 1'b1;
                miaow_fpu_start_i <= alu_start;
                miaow_fpu_op_i <= 3'b101;
                miaow_fpu_opa_i <= final_source1_data[31] ? {1'b0,final_source1_data[30:0]} : final_source1_data;
                miaow_fpu_opb_i <= 32'h3f80_0000;
                alu_vgpr_dest_data <= miaow_fpu_output_o;
                alu_dest_vcc_value <= alu_source_vcc_value;
            end
         {1'b1, 8'h04, 12'h008} : //V_MUL_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b010;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h04, 12'h01F} : //V_MAC_F32 - VIN
            begin
               alu_dest_vcc_value <= alu_source_vcc_value;
							 alu_vgpr_dest_data <= temp_dest_data + alu_source3_data;
					
							 miaow_fpu_start_i <= alu_start;
							 miaow_fpu_op_i <= 3'b010;
							 miaow_fpu_opa_i <= final_source1_data;
							 miaow_fpu_opb_i <= final_source2_data;
							 temp_dest_data <= miaow_fpu_output_o;
							 alu_done <= miaow_fpu_ready_o;

							/*
								 casex(miaow_fpu_ready_o)
								1'b0 :
									begin
										miaow_fpu_start_i <= alu_start;
										miaow_fpu_op_i <= 3'b010;
										miaow_fpu_opa_i <= final_source1_data;
										miaow_fpu_opb_i <= final_source2_data;
										temp_dest_data <= miaow_fpu_output_o;
										alu_done <= 1'b0;
									end
								1'b1 :
									begin
										miaow_fpu_start_i <= 1'b1;
										miaow_fpu_op_i <= 3'b000;
										miaow_fpu_opa_i <= temp_dest_data;
										miaow_fpu_opb_i <= final_source3_data;
									  temp_dest_data <= miaow_fpu_output_o;	
										alu_done <= miaow_fpu_ready_o;
									end
								default :
									begin
               			miaow_fpu_start_i <= 1'b0;
               			miaow_fpu_op_i <= 3'b000;
               			miaow_fpu_opa_i <= 32'b0;
               			miaow_fpu_opb_i <= 32'b0;
               			temp_dest_data <= {32{1'bx}};
										alu_done <= 1'b1;
           				end
							endcase
							*/
						 	
						end
         {1'b1, 8'h04, 12'h020} : //V_MADMK_F32 - VIN
            begin
               alu_dest_vcc_value <= alu_source_vcc_value;
							 alu_vgpr_dest_data <= temp_dest_data + alu_source2_data;
						
							 miaow_fpu_start_i <= alu_start;
							 miaow_fpu_op_i <= 3'b010;
							 miaow_fpu_opa_i <= final_source1_data;
							 miaow_fpu_opb_i <= final_source3_data;
							 temp_dest_data <= miaow_fpu_output_o;
							 alu_done <= miaow_fpu_ready_o;

							 /*
							 casex(miaow_fpu_ready_o)
								1'b0 :
									begin
										miaow_fpu_start_i <= alu_start;
										miaow_fpu_op_i <= 3'b010;
										miaow_fpu_opa_i <= final_source1_data;
										miaow_fpu_opb_i <= final_source3_data;
										temp_dest_data <= miaow_fpu_output_o;
										alu_done <= 1'b0;
									end
								1'b1 :
									begin
										miaow_fpu_start_i <= 1'b1;
										miaow_fpu_op_i <= 3'b000;
										miaow_fpu_opa_i <= temp_dest_data;
										miaow_fpu_opb_i <= final_source2_data;
									  temp_dest_data <= miaow_fpu_output_o;	
										alu_done <= 1'b1;
									end
								default :
									begin
               			miaow_fpu_start_i <= 1'b0;
               			miaow_fpu_op_i <= 3'b000;
               			miaow_fpu_opa_i <= 32'b0;
               			miaow_fpu_opb_i <= 32'b0;
               			temp_dest_data <= {32{1'bx}};
										alu_done <= 1'b1;
           				end
							endcase
							*/
						end
         {1'b1, 8'h10, 12'h141} : //V_MAD_F32 - VIN
            begin
               alu_dest_vcc_value <= alu_source_vcc_value;
							 alu_vgpr_dest_data <= temp_dest_data;
							 
							 casex(miaow_fpu_ready_o)
								1'b0 :
									begin
										miaow_fpu_start_i <= alu_start;
										miaow_fpu_op_i <= 3'b010;
										miaow_fpu_opa_i <= final_source1_data;
										miaow_fpu_opb_i <= final_source2_data;
										temp_dest_data <= miaow_fpu_output_o;
										alu_done <= 1'b0;
									end
								1'b1 :
									begin
										miaow_fpu_start_i <= 1'b1;
										miaow_fpu_op_i <= 3'b000;
										miaow_fpu_opa_i <= temp_dest_data;
										miaow_fpu_opb_i <= final_source3_data;
									  temp_dest_data <= miaow_fpu_output_o;	
										alu_done <= 1'b1;
									end
								default :
									begin
               			miaow_fpu_start_i <= 1'b0;
               			miaow_fpu_op_i <= 3'b000;
               			miaow_fpu_opa_i <= 32'b0;
               			miaow_fpu_opb_i <= 32'b0;
               			temp_dest_data <= {32{1'bx}};
										alu_done <= 1'b1;
           				end
							endcase
						end
         {1'b1, 8'h01, 12'h000} : //V_CMP_F_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
           end
         {1'b1, 8'h01, 12'h001} : //V_CMP_LT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data < final_source2_data);
           end
         {1'b1, 8'h01, 12'h002} : //V_CMP_EQ_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data == final_source2_data);
           end
         {1'b1, 8'h01, 12'h003} : //V_CMP_LE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data <= final_source2_data);
           end
         {1'b1, 8'h01, 12'h004} : //V_CMP_GT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data > final_source2_data);
           end
         {1'b1, 8'h01, 12'h005} : //V_CMP_LG_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data != final_source2_data);
           end
         {1'b1, 8'h01, 12'h006} : //V_CMP_GE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data >= final_source2_data);
           end
         {1'b1, 8'h01, 12'h009} : //V_CMP_NGE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data >= final_source2_data);
           end
         {1'b1, 8'h01, 12'h00A} : //V_CMP_NLG_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data == final_source2_data);
           end
         {1'b1, 8'h01, 12'h00B} : //V_CMP_NGT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data > final_source2_data);
           end
         {1'b1, 8'h01, 12'h00C} : //V_CMP_NLE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data <= final_source2_data);
           end
         {1'b1, 8'h01, 12'h00D} : //V_CMP_NEQ_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data != final_source2_data);
           end
         {1'b1, 8'h01, 12'h00E} : //V_CMP_NLT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data < final_source2_data);
           end
         {1'b1, 8'h01, 12'h00F} : //V_CMP_TRU_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
           end
         {1'b1, 8'h10, 12'h000} : //V_CMP_F_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b0;
           end
         {1'b1, 8'h10, 12'h001} : //V_CMP_LT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data < final_source2_data);
           end
         {1'b1, 8'h10, 12'h002} : //V_CMP_EQ_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data == final_source2_data);
           end
         {1'b1, 8'h10, 12'h003} : //V_CMP_LE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data <= final_source2_data);
           end
         {1'b1, 8'h10, 12'h004} : //V_CMP_GT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data > final_source2_data);
           end
         {1'b1, 8'h10, 12'h005} : //V_CMP_LG_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data != final_source2_data);
           end
         {1'b1, 8'h10, 12'h006} : //V_CMP_GE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data >= final_source2_data);
           end
         {1'b1, 8'h10, 12'h009} : //V_CMP_NGE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data >= final_source2_data);
           end
         {1'b1, 8'h10, 12'h00A} : //V_CMP_NLG_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data == final_source2_data);
           end
         {1'b1, 8'h10, 12'h00B} : //V_CMP_NGT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data > final_source2_data);
           end
         {1'b1, 8'h10, 12'h00C} : //V_CMP_NLE_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data <= final_source2_data);
           end
         {1'b1, 8'h10, 12'h00D} : //V_CMP_NEQ_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= (final_source1_data != final_source2_data);
           end
         {1'b1, 8'h10, 12'h00E} : //V_CMP_NLT_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= !(final_source1_data < final_source2_data);
           end
         {1'b1, 8'h10, 12'h00F} : //V_CMP_TRU_F32
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'bxxx;
               miaow_fpu_opa_i <= {32{1'bx}};
               miaow_fpu_opb_i <= {32{1'bx}};
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= 1'b1;
           end
         {1'b1, 8'h10, 12'h103} : //V_ADD_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b000;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h104} : //V_SUB_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b001;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h105} : //V_SUBREV_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b001;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         {1'b1, 8'h10, 12'h108} : //V_MUL_F32
            begin
               alu_done <= miaow_fpu_ready_o;
               miaow_fpu_start_i <= alu_start;
               miaow_fpu_op_i <= 3'b010;
               miaow_fpu_opa_i <= final_source1_data;
               miaow_fpu_opb_i <= final_source2_data;
               alu_vgpr_dest_data <= miaow_fpu_output_o;
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
         default :
            begin
               alu_done <= 1'b1;
               miaow_fpu_start_i <= 1'b0;
               miaow_fpu_op_i <= 3'b000;
               miaow_fpu_opa_i <= 32'b0;
               miaow_fpu_opb_i <= 32'b0;
               alu_vgpr_dest_data <= {32{1'bx}};
               alu_dest_vcc_value <= alu_source_vcc_value;
           end
      endcase
   end // always @ (...
endmodule
module simf_instr_decoder 
  (/*AUTOARG*/
   // Outputs
   out_vcc_wr_en, out_vgpr_wr_en, out_sgpr_wr_en,
   // Inputs
   in_opcode, in_sgpr_dest_addr
   );

input [31:0] in_opcode;
input [11:0] in_sgpr_dest_addr;

output out_vcc_wr_en;
output out_vgpr_wr_en;
output out_sgpr_wr_en;

reg out_vcc_wr_en;
reg out_vgpr_wr_en;
reg out_sgpr_wr_en;

reg temp_vcc_wr_en;
reg temp_sgpr_wr_en;


always @* begin
   casex({in_opcode[31:24], in_sgpr_dest_addr})
      {8'h10, 12'b1_1_1_0_0000_0001}:
         begin
            out_vcc_wr_en <= 1'b1;
            out_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'b1_1_0_?????????}:
         begin
            out_vcc_wr_en <= 1'b0;
            out_sgpr_wr_en <= 1'b1;
         end
      default:
         begin
            out_vcc_wr_en <= temp_vcc_wr_en;
            out_sgpr_wr_en <= temp_sgpr_wr_en;
         end
      endcase
end

always @ (in_opcode) begin
	casex(in_opcode)
      {8'h04, 12'h???, 12'h003} : //V_ADD_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h04, 12'h???, 12'h004} : //V_SUB_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h04, 12'h???, 12'h005} : //V_SUBREV_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h04, 12'h???, 12'h008} : //V_MUL_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h01, 12'h???, 12'h000} : //V_CMP_F_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h001} : //V_CMP_LT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h002} : //V_CMP_EQ_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h003} : //V_CMP_LE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h004} : //V_CMP_GT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h005} : //V_CMP_LG_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h006} : //V_CMP_GE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h009} : //V_CMP_NGE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00A} : //V_CMP_NLG_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00B} : //V_CMP_NGT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00C} : //V_CMP_NLE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00D} : //V_CMP_NEQ_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00E} : //V_CMP_NLT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h01, 12'h???, 12'h00F} : //V_CMP_TRU_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h10, 12'h???, 12'h000} : //V_CMP_F_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h001} : //V_CMP_LT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h002} : //V_CMP_EQ_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h003} : //V_CMP_LE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h004} : //V_CMP_GT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h005} : //V_CMP_LG_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h006} : //V_CMP_GE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h009} : //V_CMP_NGE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00A} : //V_CMP_NLG_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00B} : //V_CMP_NGT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00C} : //V_CMP_NLE_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00D} : //V_CMP_NEQ_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00E} : //V_CMP_NLT_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h00F} : //V_CMP_TRU_F32
         begin
            temp_vcc_wr_en <= 1'b1;
            out_vgpr_wr_en <= 1'b0;
            temp_sgpr_wr_en <= 1'b1;
         end
      {8'h10, 12'h???, 12'h103} : //V_ADD_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h10, 12'h???, 12'h104} : //V_SUB_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h10, 12'h???, 12'h105} : //V_SUBREV_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h10, 12'h???, 12'h108} : //V_MUL_F32
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h04, 12'h???, 12'h01F} : //V_MAC_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
      {8'h04, 12'h???, 12'h020} : //V_MADMK_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
				 end
      {8'h04, 12'h???, 12'h010} : //V_MAX_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
				 end
      {8'h10, 12'h???, 12'h141} : //V_MAD_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
				 end
      {8'h02, 12'h???, 12'h033} : //V_SQRT_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
				 end
      {8'h02, 12'h???, 12'h02A} : //V_RCP_F32  - VIN
         begin
      		temp_vcc_wr_en <= 1'b0;
      		out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
				 end
	  {8'h02, 12'h???, 12'h006} : //V_CVT_F32_U32
         begin
            temp_vcc_wr_en <= 1'b0;
            out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
         end
      {8'h02, 12'h???, 12'h007} : //V_CVT_F32_U32 
        begin
            temp_vcc_wr_en <= 1'b0;
            out_vgpr_wr_en <= 1'b1;
            temp_sgpr_wr_en <= 1'b0;
        end
                 
		default:
			begin
				temp_vcc_wr_en <= 1'bx;
				out_vgpr_wr_en <= 1'bx;
            temp_sgpr_wr_en <= 1'b0;
			end
	endcase
end

endmodule
module mux_256x32b_to_1x32b (out, in, select);

  output [31:0] out;
  input [32767:0] in;
  input [9:0] select; //read address now 10 bits long for 1024 locations

  reg [31:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<1024; $i=$i+1)
// {
//   $low_index = 32*$i;
//   $high_index = 32*$i+31;
//   print "      10'd$i : out <= in [$high_index:$low_index];\n";
// }
// %%stop_veriperl
      10'd0 : out <= in [31:0];
      10'd1 : out <= in [63:32];
      10'd2 : out <= in [95:64];
      10'd3 : out <= in [127:96];
      10'd4 : out <= in [159:128];
      10'd5 : out <= in [191:160];
      10'd6 : out <= in [223:192];
      10'd7 : out <= in [255:224];
      10'd8 : out <= in [287:256];
      10'd9 : out <= in [319:288];
      10'd10 : out <= in [351:320];
      10'd11 : out <= in [383:352];
      10'd12 : out <= in [415:384];
      10'd13 : out <= in [447:416];
      10'd14 : out <= in [479:448];
      10'd15 : out <= in [511:480];
      10'd16 : out <= in [543:512];
      10'd17 : out <= in [575:544];
      10'd18 : out <= in [607:576];
      10'd19 : out <= in [639:608];
      10'd20 : out <= in [671:640];
      10'd21 : out <= in [703:672];
      10'd22 : out <= in [735:704];
      10'd23 : out <= in [767:736];
      10'd24 : out <= in [799:768];
      10'd25 : out <= in [831:800];
      10'd26 : out <= in [863:832];
      10'd27 : out <= in [895:864];
      10'd28 : out <= in [927:896];
      10'd29 : out <= in [959:928];
      10'd30 : out <= in [991:960];
      10'd31 : out <= in [1023:992];
      10'd32 : out <= in [1055:1024];
      10'd33 : out <= in [1087:1056];
      10'd34 : out <= in [1119:1088];
      10'd35 : out <= in [1151:1120];
      10'd36 : out <= in [1183:1152];
      10'd37 : out <= in [1215:1184];
      10'd38 : out <= in [1247:1216];
      10'd39 : out <= in [1279:1248];
      10'd40 : out <= in [1311:1280];
      10'd41 : out <= in [1343:1312];
      10'd42 : out <= in [1375:1344];
      10'd43 : out <= in [1407:1376];
      10'd44 : out <= in [1439:1408];
      10'd45 : out <= in [1471:1440];
      10'd46 : out <= in [1503:1472];
      10'd47 : out <= in [1535:1504];
      10'd48 : out <= in [1567:1536];
      10'd49 : out <= in [1599:1568];
      10'd50 : out <= in [1631:1600];
      10'd51 : out <= in [1663:1632];
      10'd52 : out <= in [1695:1664];
      10'd53 : out <= in [1727:1696];
      10'd54 : out <= in [1759:1728];
      10'd55 : out <= in [1791:1760];
      10'd56 : out <= in [1823:1792];
      10'd57 : out <= in [1855:1824];
      10'd58 : out <= in [1887:1856];
      10'd59 : out <= in [1919:1888];
      10'd60 : out <= in [1951:1920];
      10'd61 : out <= in [1983:1952];
      10'd62 : out <= in [2015:1984];
      10'd63 : out <= in [2047:2016];
      10'd64 : out <= in [2079:2048];
      10'd65 : out <= in [2111:2080];
      10'd66 : out <= in [2143:2112];
      10'd67 : out <= in [2175:2144];
      10'd68 : out <= in [2207:2176];
      10'd69 : out <= in [2239:2208];
      10'd70 : out <= in [2271:2240];
      10'd71 : out <= in [2303:2272];
      10'd72 : out <= in [2335:2304];
      10'd73 : out <= in [2367:2336];
      10'd74 : out <= in [2399:2368];
      10'd75 : out <= in [2431:2400];
      10'd76 : out <= in [2463:2432];
      10'd77 : out <= in [2495:2464];
      10'd78 : out <= in [2527:2496];
      10'd79 : out <= in [2559:2528];
      10'd80 : out <= in [2591:2560];
      10'd81 : out <= in [2623:2592];
      10'd82 : out <= in [2655:2624];
      10'd83 : out <= in [2687:2656];
      10'd84 : out <= in [2719:2688];
      10'd85 : out <= in [2751:2720];
      10'd86 : out <= in [2783:2752];
      10'd87 : out <= in [2815:2784];
      10'd88 : out <= in [2847:2816];
      10'd89 : out <= in [2879:2848];
      10'd90 : out <= in [2911:2880];
      10'd91 : out <= in [2943:2912];
      10'd92 : out <= in [2975:2944];
      10'd93 : out <= in [3007:2976];
      10'd94 : out <= in [3039:3008];
      10'd95 : out <= in [3071:3040];
      10'd96 : out <= in [3103:3072];
      10'd97 : out <= in [3135:3104];
      10'd98 : out <= in [3167:3136];
      10'd99 : out <= in [3199:3168];
      10'd100 : out <= in [3231:3200];
      10'd101 : out <= in [3263:3232];
      10'd102 : out <= in [3295:3264];
      10'd103 : out <= in [3327:3296];
      10'd104 : out <= in [3359:3328];
      10'd105 : out <= in [3391:3360];
      10'd106 : out <= in [3423:3392];
      10'd107 : out <= in [3455:3424];
      10'd108 : out <= in [3487:3456];
      10'd109 : out <= in [3519:3488];
      10'd110 : out <= in [3551:3520];
      10'd111 : out <= in [3583:3552];
      10'd112 : out <= in [3615:3584];
      10'd113 : out <= in [3647:3616];
      10'd114 : out <= in [3679:3648];
      10'd115 : out <= in [3711:3680];
      10'd116 : out <= in [3743:3712];
      10'd117 : out <= in [3775:3744];
      10'd118 : out <= in [3807:3776];
      10'd119 : out <= in [3839:3808];
      10'd120 : out <= in [3871:3840];
      10'd121 : out <= in [3903:3872];
      10'd122 : out <= in [3935:3904];
      10'd123 : out <= in [3967:3936];
      10'd124 : out <= in [3999:3968];
      10'd125 : out <= in [4031:4000];
      10'd126 : out <= in [4063:4032];
      10'd127 : out <= in [4095:4064];
      10'd128 : out <= in [4127:4096];
      10'd129 : out <= in [4159:4128];
      10'd130 : out <= in [4191:4160];
      10'd131 : out <= in [4223:4192];
      10'd132 : out <= in [4255:4224];
      10'd133 : out <= in [4287:4256];
      10'd134 : out <= in [4319:4288];
      10'd135 : out <= in [4351:4320];
      10'd136 : out <= in [4383:4352];
      10'd137 : out <= in [4415:4384];
      10'd138 : out <= in [4447:4416];
      10'd139 : out <= in [4479:4448];
      10'd140 : out <= in [4511:4480];
      10'd141 : out <= in [4543:4512];
      10'd142 : out <= in [4575:4544];
      10'd143 : out <= in [4607:4576];
      10'd144 : out <= in [4639:4608];
      10'd145 : out <= in [4671:4640];
      10'd146 : out <= in [4703:4672];
      10'd147 : out <= in [4735:4704];
      10'd148 : out <= in [4767:4736];
      10'd149 : out <= in [4799:4768];
      10'd150 : out <= in [4831:4800];
      10'd151 : out <= in [4863:4832];
      10'd152 : out <= in [4895:4864];
      10'd153 : out <= in [4927:4896];
      10'd154 : out <= in [4959:4928];
      10'd155 : out <= in [4991:4960];
      10'd156 : out <= in [5023:4992];
      10'd157 : out <= in [5055:5024];
      10'd158 : out <= in [5087:5056];
      10'd159 : out <= in [5119:5088];
      10'd160 : out <= in [5151:5120];
      10'd161 : out <= in [5183:5152];
      10'd162 : out <= in [5215:5184];
      10'd163 : out <= in [5247:5216];
      10'd164 : out <= in [5279:5248];
      10'd165 : out <= in [5311:5280];
      10'd166 : out <= in [5343:5312];
      10'd167 : out <= in [5375:5344];
      10'd168 : out <= in [5407:5376];
      10'd169 : out <= in [5439:5408];
      10'd170 : out <= in [5471:5440];
      10'd171 : out <= in [5503:5472];
      10'd172 : out <= in [5535:5504];
      10'd173 : out <= in [5567:5536];
      10'd174 : out <= in [5599:5568];
      10'd175 : out <= in [5631:5600];
      10'd176 : out <= in [5663:5632];
      10'd177 : out <= in [5695:5664];
      10'd178 : out <= in [5727:5696];
      10'd179 : out <= in [5759:5728];
      10'd180 : out <= in [5791:5760];
      10'd181 : out <= in [5823:5792];
      10'd182 : out <= in [5855:5824];
      10'd183 : out <= in [5887:5856];
      10'd184 : out <= in [5919:5888];
      10'd185 : out <= in [5951:5920];
      10'd186 : out <= in [5983:5952];
      10'd187 : out <= in [6015:5984];
      10'd188 : out <= in [6047:6016];
      10'd189 : out <= in [6079:6048];
      10'd190 : out <= in [6111:6080];
      10'd191 : out <= in [6143:6112];
      10'd192 : out <= in [6175:6144];
      10'd193 : out <= in [6207:6176];
      10'd194 : out <= in [6239:6208];
      10'd195 : out <= in [6271:6240];
      10'd196 : out <= in [6303:6272];
      10'd197 : out <= in [6335:6304];
      10'd198 : out <= in [6367:6336];
      10'd199 : out <= in [6399:6368];
      10'd200 : out <= in [6431:6400];
      10'd201 : out <= in [6463:6432];
      10'd202 : out <= in [6495:6464];
      10'd203 : out <= in [6527:6496];
      10'd204 : out <= in [6559:6528];
      10'd205 : out <= in [6591:6560];
      10'd206 : out <= in [6623:6592];
      10'd207 : out <= in [6655:6624];
      10'd208 : out <= in [6687:6656];
      10'd209 : out <= in [6719:6688];
      10'd210 : out <= in [6751:6720];
      10'd211 : out <= in [6783:6752];
      10'd212 : out <= in [6815:6784];
      10'd213 : out <= in [6847:6816];
      10'd214 : out <= in [6879:6848];
      10'd215 : out <= in [6911:6880];
      10'd216 : out <= in [6943:6912];
      10'd217 : out <= in [6975:6944];
      10'd218 : out <= in [7007:6976];
      10'd219 : out <= in [7039:7008];
      10'd220 : out <= in [7071:7040];
      10'd221 : out <= in [7103:7072];
      10'd222 : out <= in [7135:7104];
      10'd223 : out <= in [7167:7136];
      10'd224 : out <= in [7199:7168];
      10'd225 : out <= in [7231:7200];
      10'd226 : out <= in [7263:7232];
      10'd227 : out <= in [7295:7264];
      10'd228 : out <= in [7327:7296];
      10'd229 : out <= in [7359:7328];
      10'd230 : out <= in [7391:7360];
      10'd231 : out <= in [7423:7392];
      10'd232 : out <= in [7455:7424];
      10'd233 : out <= in [7487:7456];
      10'd234 : out <= in [7519:7488];
      10'd235 : out <= in [7551:7520];
      10'd236 : out <= in [7583:7552];
      10'd237 : out <= in [7615:7584];
      10'd238 : out <= in [7647:7616];
      10'd239 : out <= in [7679:7648];
      10'd240 : out <= in [7711:7680];
      10'd241 : out <= in [7743:7712];
      10'd242 : out <= in [7775:7744];
      10'd243 : out <= in [7807:7776];
      10'd244 : out <= in [7839:7808];
      10'd245 : out <= in [7871:7840];
      10'd246 : out <= in [7903:7872];
      10'd247 : out <= in [7935:7904];
      10'd248 : out <= in [7967:7936];
      10'd249 : out <= in [7999:7968];
      10'd250 : out <= in [8031:8000];
      10'd251 : out <= in [8063:8032];
      10'd252 : out <= in [8095:8064];
      10'd253 : out <= in [8127:8096];
      10'd254 : out <= in [8159:8128];
      10'd255 : out <= in [8191:8160];
      10'd256 : out <= in [8223:8192];
      10'd257 : out <= in [8255:8224];
      10'd258 : out <= in [8287:8256];
      10'd259 : out <= in [8319:8288];
      10'd260 : out <= in [8351:8320];
      10'd261 : out <= in [8383:8352];
      10'd262 : out <= in [8415:8384];
      10'd263 : out <= in [8447:8416];
      10'd264 : out <= in [8479:8448];
      10'd265 : out <= in [8511:8480];
      10'd266 : out <= in [8543:8512];
      10'd267 : out <= in [8575:8544];
      10'd268 : out <= in [8607:8576];
      10'd269 : out <= in [8639:8608];
      10'd270 : out <= in [8671:8640];
      10'd271 : out <= in [8703:8672];
      10'd272 : out <= in [8735:8704];
      10'd273 : out <= in [8767:8736];
      10'd274 : out <= in [8799:8768];
      10'd275 : out <= in [8831:8800];
      10'd276 : out <= in [8863:8832];
      10'd277 : out <= in [8895:8864];
      10'd278 : out <= in [8927:8896];
      10'd279 : out <= in [8959:8928];
      10'd280 : out <= in [8991:8960];
      10'd281 : out <= in [9023:8992];
      10'd282 : out <= in [9055:9024];
      10'd283 : out <= in [9087:9056];
      10'd284 : out <= in [9119:9088];
      10'd285 : out <= in [9151:9120];
      10'd286 : out <= in [9183:9152];
      10'd287 : out <= in [9215:9184];
      10'd288 : out <= in [9247:9216];
      10'd289 : out <= in [9279:9248];
      10'd290 : out <= in [9311:9280];
      10'd291 : out <= in [9343:9312];
      10'd292 : out <= in [9375:9344];
      10'd293 : out <= in [9407:9376];
      10'd294 : out <= in [9439:9408];
      10'd295 : out <= in [9471:9440];
      10'd296 : out <= in [9503:9472];
      10'd297 : out <= in [9535:9504];
      10'd298 : out <= in [9567:9536];
      10'd299 : out <= in [9599:9568];
      10'd300 : out <= in [9631:9600];
      10'd301 : out <= in [9663:9632];
      10'd302 : out <= in [9695:9664];
      10'd303 : out <= in [9727:9696];
      10'd304 : out <= in [9759:9728];
      10'd305 : out <= in [9791:9760];
      10'd306 : out <= in [9823:9792];
      10'd307 : out <= in [9855:9824];
      10'd308 : out <= in [9887:9856];
      10'd309 : out <= in [9919:9888];
      10'd310 : out <= in [9951:9920];
      10'd311 : out <= in [9983:9952];
      10'd312 : out <= in [10015:9984];
      10'd313 : out <= in [10047:10016];
      10'd314 : out <= in [10079:10048];
      10'd315 : out <= in [10111:10080];
      10'd316 : out <= in [10143:10112];
      10'd317 : out <= in [10175:10144];
      10'd318 : out <= in [10207:10176];
      10'd319 : out <= in [10239:10208];
      10'd320 : out <= in [10271:10240];
      10'd321 : out <= in [10303:10272];
      10'd322 : out <= in [10335:10304];
      10'd323 : out <= in [10367:10336];
      10'd324 : out <= in [10399:10368];
      10'd325 : out <= in [10431:10400];
      10'd326 : out <= in [10463:10432];
      10'd327 : out <= in [10495:10464];
      10'd328 : out <= in [10527:10496];
      10'd329 : out <= in [10559:10528];
      10'd330 : out <= in [10591:10560];
      10'd331 : out <= in [10623:10592];
      10'd332 : out <= in [10655:10624];
      10'd333 : out <= in [10687:10656];
      10'd334 : out <= in [10719:10688];
      10'd335 : out <= in [10751:10720];
      10'd336 : out <= in [10783:10752];
      10'd337 : out <= in [10815:10784];
      10'd338 : out <= in [10847:10816];
      10'd339 : out <= in [10879:10848];
      10'd340 : out <= in [10911:10880];
      10'd341 : out <= in [10943:10912];
      10'd342 : out <= in [10975:10944];
      10'd343 : out <= in [11007:10976];
      10'd344 : out <= in [11039:11008];
      10'd345 : out <= in [11071:11040];
      10'd346 : out <= in [11103:11072];
      10'd347 : out <= in [11135:11104];
      10'd348 : out <= in [11167:11136];
      10'd349 : out <= in [11199:11168];
      10'd350 : out <= in [11231:11200];
      10'd351 : out <= in [11263:11232];
      10'd352 : out <= in [11295:11264];
      10'd353 : out <= in [11327:11296];
      10'd354 : out <= in [11359:11328];
      10'd355 : out <= in [11391:11360];
      10'd356 : out <= in [11423:11392];
      10'd357 : out <= in [11455:11424];
      10'd358 : out <= in [11487:11456];
      10'd359 : out <= in [11519:11488];
      10'd360 : out <= in [11551:11520];
      10'd361 : out <= in [11583:11552];
      10'd362 : out <= in [11615:11584];
      10'd363 : out <= in [11647:11616];
      10'd364 : out <= in [11679:11648];
      10'd365 : out <= in [11711:11680];
      10'd366 : out <= in [11743:11712];
      10'd367 : out <= in [11775:11744];
      10'd368 : out <= in [11807:11776];
      10'd369 : out <= in [11839:11808];
      10'd370 : out <= in [11871:11840];
      10'd371 : out <= in [11903:11872];
      10'd372 : out <= in [11935:11904];
      10'd373 : out <= in [11967:11936];
      10'd374 : out <= in [11999:11968];
      10'd375 : out <= in [12031:12000];
      10'd376 : out <= in [12063:12032];
      10'd377 : out <= in [12095:12064];
      10'd378 : out <= in [12127:12096];
      10'd379 : out <= in [12159:12128];
      10'd380 : out <= in [12191:12160];
      10'd381 : out <= in [12223:12192];
      10'd382 : out <= in [12255:12224];
      10'd383 : out <= in [12287:12256];
      10'd384 : out <= in [12319:12288];
      10'd385 : out <= in [12351:12320];
      10'd386 : out <= in [12383:12352];
      10'd387 : out <= in [12415:12384];
      10'd388 : out <= in [12447:12416];
      10'd389 : out <= in [12479:12448];
      10'd390 : out <= in [12511:12480];
      10'd391 : out <= in [12543:12512];
      10'd392 : out <= in [12575:12544];
      10'd393 : out <= in [12607:12576];
      10'd394 : out <= in [12639:12608];
      10'd395 : out <= in [12671:12640];
      10'd396 : out <= in [12703:12672];
      10'd397 : out <= in [12735:12704];
      10'd398 : out <= in [12767:12736];
      10'd399 : out <= in [12799:12768];
      10'd400 : out <= in [12831:12800];
      10'd401 : out <= in [12863:12832];
      10'd402 : out <= in [12895:12864];
      10'd403 : out <= in [12927:12896];
      10'd404 : out <= in [12959:12928];
      10'd405 : out <= in [12991:12960];
      10'd406 : out <= in [13023:12992];
      10'd407 : out <= in [13055:13024];
      10'd408 : out <= in [13087:13056];
      10'd409 : out <= in [13119:13088];
      10'd410 : out <= in [13151:13120];
      10'd411 : out <= in [13183:13152];
      10'd412 : out <= in [13215:13184];
      10'd413 : out <= in [13247:13216];
      10'd414 : out <= in [13279:13248];
      10'd415 : out <= in [13311:13280];
      10'd416 : out <= in [13343:13312];
      10'd417 : out <= in [13375:13344];
      10'd418 : out <= in [13407:13376];
      10'd419 : out <= in [13439:13408];
      10'd420 : out <= in [13471:13440];
      10'd421 : out <= in [13503:13472];
      10'd422 : out <= in [13535:13504];
      10'd423 : out <= in [13567:13536];
      10'd424 : out <= in [13599:13568];
      10'd425 : out <= in [13631:13600];
      10'd426 : out <= in [13663:13632];
      10'd427 : out <= in [13695:13664];
      10'd428 : out <= in [13727:13696];
      10'd429 : out <= in [13759:13728];
      10'd430 : out <= in [13791:13760];
      10'd431 : out <= in [13823:13792];
      10'd432 : out <= in [13855:13824];
      10'd433 : out <= in [13887:13856];
      10'd434 : out <= in [13919:13888];
      10'd435 : out <= in [13951:13920];
      10'd436 : out <= in [13983:13952];
      10'd437 : out <= in [14015:13984];
      10'd438 : out <= in [14047:14016];
      10'd439 : out <= in [14079:14048];
      10'd440 : out <= in [14111:14080];
      10'd441 : out <= in [14143:14112];
      10'd442 : out <= in [14175:14144];
      10'd443 : out <= in [14207:14176];
      10'd444 : out <= in [14239:14208];
      10'd445 : out <= in [14271:14240];
      10'd446 : out <= in [14303:14272];
      10'd447 : out <= in [14335:14304];
      10'd448 : out <= in [14367:14336];
      10'd449 : out <= in [14399:14368];
      10'd450 : out <= in [14431:14400];
      10'd451 : out <= in [14463:14432];
      10'd452 : out <= in [14495:14464];
      10'd453 : out <= in [14527:14496];
      10'd454 : out <= in [14559:14528];
      10'd455 : out <= in [14591:14560];
      10'd456 : out <= in [14623:14592];
      10'd457 : out <= in [14655:14624];
      10'd458 : out <= in [14687:14656];
      10'd459 : out <= in [14719:14688];
      10'd460 : out <= in [14751:14720];
      10'd461 : out <= in [14783:14752];
      10'd462 : out <= in [14815:14784];
      10'd463 : out <= in [14847:14816];
      10'd464 : out <= in [14879:14848];
      10'd465 : out <= in [14911:14880];
      10'd466 : out <= in [14943:14912];
      10'd467 : out <= in [14975:14944];
      10'd468 : out <= in [15007:14976];
      10'd469 : out <= in [15039:15008];
      10'd470 : out <= in [15071:15040];
      10'd471 : out <= in [15103:15072];
      10'd472 : out <= in [15135:15104];
      10'd473 : out <= in [15167:15136];
      10'd474 : out <= in [15199:15168];
      10'd475 : out <= in [15231:15200];
      10'd476 : out <= in [15263:15232];
      10'd477 : out <= in [15295:15264];
      10'd478 : out <= in [15327:15296];
      10'd479 : out <= in [15359:15328];
      10'd480 : out <= in [15391:15360];
      10'd481 : out <= in [15423:15392];
      10'd482 : out <= in [15455:15424];
      10'd483 : out <= in [15487:15456];
      10'd484 : out <= in [15519:15488];
      10'd485 : out <= in [15551:15520];
      10'd486 : out <= in [15583:15552];
      10'd487 : out <= in [15615:15584];
      10'd488 : out <= in [15647:15616];
      10'd489 : out <= in [15679:15648];
      10'd490 : out <= in [15711:15680];
      10'd491 : out <= in [15743:15712];
      10'd492 : out <= in [15775:15744];
      10'd493 : out <= in [15807:15776];
      10'd494 : out <= in [15839:15808];
      10'd495 : out <= in [15871:15840];
      10'd496 : out <= in [15903:15872];
      10'd497 : out <= in [15935:15904];
      10'd498 : out <= in [15967:15936];
      10'd499 : out <= in [15999:15968];
      10'd500 : out <= in [16031:16000];
      10'd501 : out <= in [16063:16032];
      10'd502 : out <= in [16095:16064];
      10'd503 : out <= in [16127:16096];
      10'd504 : out <= in [16159:16128];
      10'd505 : out <= in [16191:16160];
      10'd506 : out <= in [16223:16192];
      10'd507 : out <= in [16255:16224];
      10'd508 : out <= in [16287:16256];
      10'd509 : out <= in [16319:16288];
      10'd510 : out <= in [16351:16320];
      10'd511 : out <= in [16383:16352];
      10'd512 : out <= in [16415:16384];
      10'd513 : out <= in [16447:16416];
      10'd514 : out <= in [16479:16448];
      10'd515 : out <= in [16511:16480];
      10'd516 : out <= in [16543:16512];
      10'd517 : out <= in [16575:16544];
      10'd518 : out <= in [16607:16576];
      10'd519 : out <= in [16639:16608];
      10'd520 : out <= in [16671:16640];
      10'd521 : out <= in [16703:16672];
      10'd522 : out <= in [16735:16704];
      10'd523 : out <= in [16767:16736];
      10'd524 : out <= in [16799:16768];
      10'd525 : out <= in [16831:16800];
      10'd526 : out <= in [16863:16832];
      10'd527 : out <= in [16895:16864];
      10'd528 : out <= in [16927:16896];
      10'd529 : out <= in [16959:16928];
      10'd530 : out <= in [16991:16960];
      10'd531 : out <= in [17023:16992];
      10'd532 : out <= in [17055:17024];
      10'd533 : out <= in [17087:17056];
      10'd534 : out <= in [17119:17088];
      10'd535 : out <= in [17151:17120];
      10'd536 : out <= in [17183:17152];
      10'd537 : out <= in [17215:17184];
      10'd538 : out <= in [17247:17216];
      10'd539 : out <= in [17279:17248];
      10'd540 : out <= in [17311:17280];
      10'd541 : out <= in [17343:17312];
      10'd542 : out <= in [17375:17344];
      10'd543 : out <= in [17407:17376];
      10'd544 : out <= in [17439:17408];
      10'd545 : out <= in [17471:17440];
      10'd546 : out <= in [17503:17472];
      10'd547 : out <= in [17535:17504];
      10'd548 : out <= in [17567:17536];
      10'd549 : out <= in [17599:17568];
      10'd550 : out <= in [17631:17600];
      10'd551 : out <= in [17663:17632];
      10'd552 : out <= in [17695:17664];
      10'd553 : out <= in [17727:17696];
      10'd554 : out <= in [17759:17728];
      10'd555 : out <= in [17791:17760];
      10'd556 : out <= in [17823:17792];
      10'd557 : out <= in [17855:17824];
      10'd558 : out <= in [17887:17856];
      10'd559 : out <= in [17919:17888];
      10'd560 : out <= in [17951:17920];
      10'd561 : out <= in [17983:17952];
      10'd562 : out <= in [18015:17984];
      10'd563 : out <= in [18047:18016];
      10'd564 : out <= in [18079:18048];
      10'd565 : out <= in [18111:18080];
      10'd566 : out <= in [18143:18112];
      10'd567 : out <= in [18175:18144];
      10'd568 : out <= in [18207:18176];
      10'd569 : out <= in [18239:18208];
      10'd570 : out <= in [18271:18240];
      10'd571 : out <= in [18303:18272];
      10'd572 : out <= in [18335:18304];
      10'd573 : out <= in [18367:18336];
      10'd574 : out <= in [18399:18368];
      10'd575 : out <= in [18431:18400];
      10'd576 : out <= in [18463:18432];
      10'd577 : out <= in [18495:18464];
      10'd578 : out <= in [18527:18496];
      10'd579 : out <= in [18559:18528];
      10'd580 : out <= in [18591:18560];
      10'd581 : out <= in [18623:18592];
      10'd582 : out <= in [18655:18624];
      10'd583 : out <= in [18687:18656];
      10'd584 : out <= in [18719:18688];
      10'd585 : out <= in [18751:18720];
      10'd586 : out <= in [18783:18752];
      10'd587 : out <= in [18815:18784];
      10'd588 : out <= in [18847:18816];
      10'd589 : out <= in [18879:18848];
      10'd590 : out <= in [18911:18880];
      10'd591 : out <= in [18943:18912];
      10'd592 : out <= in [18975:18944];
      10'd593 : out <= in [19007:18976];
      10'd594 : out <= in [19039:19008];
      10'd595 : out <= in [19071:19040];
      10'd596 : out <= in [19103:19072];
      10'd597 : out <= in [19135:19104];
      10'd598 : out <= in [19167:19136];
      10'd599 : out <= in [19199:19168];
      10'd600 : out <= in [19231:19200];
      10'd601 : out <= in [19263:19232];
      10'd602 : out <= in [19295:19264];
      10'd603 : out <= in [19327:19296];
      10'd604 : out <= in [19359:19328];
      10'd605 : out <= in [19391:19360];
      10'd606 : out <= in [19423:19392];
      10'd607 : out <= in [19455:19424];
      10'd608 : out <= in [19487:19456];
      10'd609 : out <= in [19519:19488];
      10'd610 : out <= in [19551:19520];
      10'd611 : out <= in [19583:19552];
      10'd612 : out <= in [19615:19584];
      10'd613 : out <= in [19647:19616];
      10'd614 : out <= in [19679:19648];
      10'd615 : out <= in [19711:19680];
      10'd616 : out <= in [19743:19712];
      10'd617 : out <= in [19775:19744];
      10'd618 : out <= in [19807:19776];
      10'd619 : out <= in [19839:19808];
      10'd620 : out <= in [19871:19840];
      10'd621 : out <= in [19903:19872];
      10'd622 : out <= in [19935:19904];
      10'd623 : out <= in [19967:19936];
      10'd624 : out <= in [19999:19968];
      10'd625 : out <= in [20031:20000];
      10'd626 : out <= in [20063:20032];
      10'd627 : out <= in [20095:20064];
      10'd628 : out <= in [20127:20096];
      10'd629 : out <= in [20159:20128];
      10'd630 : out <= in [20191:20160];
      10'd631 : out <= in [20223:20192];
      10'd632 : out <= in [20255:20224];
      10'd633 : out <= in [20287:20256];
      10'd634 : out <= in [20319:20288];
      10'd635 : out <= in [20351:20320];
      10'd636 : out <= in [20383:20352];
      10'd637 : out <= in [20415:20384];
      10'd638 : out <= in [20447:20416];
      10'd639 : out <= in [20479:20448];
      10'd640 : out <= in [20511:20480];
      10'd641 : out <= in [20543:20512];
      10'd642 : out <= in [20575:20544];
      10'd643 : out <= in [20607:20576];
      10'd644 : out <= in [20639:20608];
      10'd645 : out <= in [20671:20640];
      10'd646 : out <= in [20703:20672];
      10'd647 : out <= in [20735:20704];
      10'd648 : out <= in [20767:20736];
      10'd649 : out <= in [20799:20768];
      10'd650 : out <= in [20831:20800];
      10'd651 : out <= in [20863:20832];
      10'd652 : out <= in [20895:20864];
      10'd653 : out <= in [20927:20896];
      10'd654 : out <= in [20959:20928];
      10'd655 : out <= in [20991:20960];
      10'd656 : out <= in [21023:20992];
      10'd657 : out <= in [21055:21024];
      10'd658 : out <= in [21087:21056];
      10'd659 : out <= in [21119:21088];
      10'd660 : out <= in [21151:21120];
      10'd661 : out <= in [21183:21152];
      10'd662 : out <= in [21215:21184];
      10'd663 : out <= in [21247:21216];
      10'd664 : out <= in [21279:21248];
      10'd665 : out <= in [21311:21280];
      10'd666 : out <= in [21343:21312];
      10'd667 : out <= in [21375:21344];
      10'd668 : out <= in [21407:21376];
      10'd669 : out <= in [21439:21408];
      10'd670 : out <= in [21471:21440];
      10'd671 : out <= in [21503:21472];
      10'd672 : out <= in [21535:21504];
      10'd673 : out <= in [21567:21536];
      10'd674 : out <= in [21599:21568];
      10'd675 : out <= in [21631:21600];
      10'd676 : out <= in [21663:21632];
      10'd677 : out <= in [21695:21664];
      10'd678 : out <= in [21727:21696];
      10'd679 : out <= in [21759:21728];
      10'd680 : out <= in [21791:21760];
      10'd681 : out <= in [21823:21792];
      10'd682 : out <= in [21855:21824];
      10'd683 : out <= in [21887:21856];
      10'd684 : out <= in [21919:21888];
      10'd685 : out <= in [21951:21920];
      10'd686 : out <= in [21983:21952];
      10'd687 : out <= in [22015:21984];
      10'd688 : out <= in [22047:22016];
      10'd689 : out <= in [22079:22048];
      10'd690 : out <= in [22111:22080];
      10'd691 : out <= in [22143:22112];
      10'd692 : out <= in [22175:22144];
      10'd693 : out <= in [22207:22176];
      10'd694 : out <= in [22239:22208];
      10'd695 : out <= in [22271:22240];
      10'd696 : out <= in [22303:22272];
      10'd697 : out <= in [22335:22304];
      10'd698 : out <= in [22367:22336];
      10'd699 : out <= in [22399:22368];
      10'd700 : out <= in [22431:22400];
      10'd701 : out <= in [22463:22432];
      10'd702 : out <= in [22495:22464];
      10'd703 : out <= in [22527:22496];
      10'd704 : out <= in [22559:22528];
      10'd705 : out <= in [22591:22560];
      10'd706 : out <= in [22623:22592];
      10'd707 : out <= in [22655:22624];
      10'd708 : out <= in [22687:22656];
      10'd709 : out <= in [22719:22688];
      10'd710 : out <= in [22751:22720];
      10'd711 : out <= in [22783:22752];
      10'd712 : out <= in [22815:22784];
      10'd713 : out <= in [22847:22816];
      10'd714 : out <= in [22879:22848];
      10'd715 : out <= in [22911:22880];
      10'd716 : out <= in [22943:22912];
      10'd717 : out <= in [22975:22944];
      10'd718 : out <= in [23007:22976];
      10'd719 : out <= in [23039:23008];
      10'd720 : out <= in [23071:23040];
      10'd721 : out <= in [23103:23072];
      10'd722 : out <= in [23135:23104];
      10'd723 : out <= in [23167:23136];
      10'd724 : out <= in [23199:23168];
      10'd725 : out <= in [23231:23200];
      10'd726 : out <= in [23263:23232];
      10'd727 : out <= in [23295:23264];
      10'd728 : out <= in [23327:23296];
      10'd729 : out <= in [23359:23328];
      10'd730 : out <= in [23391:23360];
      10'd731 : out <= in [23423:23392];
      10'd732 : out <= in [23455:23424];
      10'd733 : out <= in [23487:23456];
      10'd734 : out <= in [23519:23488];
      10'd735 : out <= in [23551:23520];
      10'd736 : out <= in [23583:23552];
      10'd737 : out <= in [23615:23584];
      10'd738 : out <= in [23647:23616];
      10'd739 : out <= in [23679:23648];
      10'd740 : out <= in [23711:23680];
      10'd741 : out <= in [23743:23712];
      10'd742 : out <= in [23775:23744];
      10'd743 : out <= in [23807:23776];
      10'd744 : out <= in [23839:23808];
      10'd745 : out <= in [23871:23840];
      10'd746 : out <= in [23903:23872];
      10'd747 : out <= in [23935:23904];
      10'd748 : out <= in [23967:23936];
      10'd749 : out <= in [23999:23968];
      10'd750 : out <= in [24031:24000];
      10'd751 : out <= in [24063:24032];
      10'd752 : out <= in [24095:24064];
      10'd753 : out <= in [24127:24096];
      10'd754 : out <= in [24159:24128];
      10'd755 : out <= in [24191:24160];
      10'd756 : out <= in [24223:24192];
      10'd757 : out <= in [24255:24224];
      10'd758 : out <= in [24287:24256];
      10'd759 : out <= in [24319:24288];
      10'd760 : out <= in [24351:24320];
      10'd761 : out <= in [24383:24352];
      10'd762 : out <= in [24415:24384];
      10'd763 : out <= in [24447:24416];
      10'd764 : out <= in [24479:24448];
      10'd765 : out <= in [24511:24480];
      10'd766 : out <= in [24543:24512];
      10'd767 : out <= in [24575:24544];
      10'd768 : out <= in [24607:24576];
      10'd769 : out <= in [24639:24608];
      10'd770 : out <= in [24671:24640];
      10'd771 : out <= in [24703:24672];
      10'd772 : out <= in [24735:24704];
      10'd773 : out <= in [24767:24736];
      10'd774 : out <= in [24799:24768];
      10'd775 : out <= in [24831:24800];
      10'd776 : out <= in [24863:24832];
      10'd777 : out <= in [24895:24864];
      10'd778 : out <= in [24927:24896];
      10'd779 : out <= in [24959:24928];
      10'd780 : out <= in [24991:24960];
      10'd781 : out <= in [25023:24992];
      10'd782 : out <= in [25055:25024];
      10'd783 : out <= in [25087:25056];
      10'd784 : out <= in [25119:25088];
      10'd785 : out <= in [25151:25120];
      10'd786 : out <= in [25183:25152];
      10'd787 : out <= in [25215:25184];
      10'd788 : out <= in [25247:25216];
      10'd789 : out <= in [25279:25248];
      10'd790 : out <= in [25311:25280];
      10'd791 : out <= in [25343:25312];
      10'd792 : out <= in [25375:25344];
      10'd793 : out <= in [25407:25376];
      10'd794 : out <= in [25439:25408];
      10'd795 : out <= in [25471:25440];
      10'd796 : out <= in [25503:25472];
      10'd797 : out <= in [25535:25504];
      10'd798 : out <= in [25567:25536];
      10'd799 : out <= in [25599:25568];
      10'd800 : out <= in [25631:25600];
      10'd801 : out <= in [25663:25632];
      10'd802 : out <= in [25695:25664];
      10'd803 : out <= in [25727:25696];
      10'd804 : out <= in [25759:25728];
      10'd805 : out <= in [25791:25760];
      10'd806 : out <= in [25823:25792];
      10'd807 : out <= in [25855:25824];
      10'd808 : out <= in [25887:25856];
      10'd809 : out <= in [25919:25888];
      10'd810 : out <= in [25951:25920];
      10'd811 : out <= in [25983:25952];
      10'd812 : out <= in [26015:25984];
      10'd813 : out <= in [26047:26016];
      10'd814 : out <= in [26079:26048];
      10'd815 : out <= in [26111:26080];
      10'd816 : out <= in [26143:26112];
      10'd817 : out <= in [26175:26144];
      10'd818 : out <= in [26207:26176];
      10'd819 : out <= in [26239:26208];
      10'd820 : out <= in [26271:26240];
      10'd821 : out <= in [26303:26272];
      10'd822 : out <= in [26335:26304];
      10'd823 : out <= in [26367:26336];
      10'd824 : out <= in [26399:26368];
      10'd825 : out <= in [26431:26400];
      10'd826 : out <= in [26463:26432];
      10'd827 : out <= in [26495:26464];
      10'd828 : out <= in [26527:26496];
      10'd829 : out <= in [26559:26528];
      10'd830 : out <= in [26591:26560];
      10'd831 : out <= in [26623:26592];
      10'd832 : out <= in [26655:26624];
      10'd833 : out <= in [26687:26656];
      10'd834 : out <= in [26719:26688];
      10'd835 : out <= in [26751:26720];
      10'd836 : out <= in [26783:26752];
      10'd837 : out <= in [26815:26784];
      10'd838 : out <= in [26847:26816];
      10'd839 : out <= in [26879:26848];
      10'd840 : out <= in [26911:26880];
      10'd841 : out <= in [26943:26912];
      10'd842 : out <= in [26975:26944];
      10'd843 : out <= in [27007:26976];
      10'd844 : out <= in [27039:27008];
      10'd845 : out <= in [27071:27040];
      10'd846 : out <= in [27103:27072];
      10'd847 : out <= in [27135:27104];
      10'd848 : out <= in [27167:27136];
      10'd849 : out <= in [27199:27168];
      10'd850 : out <= in [27231:27200];
      10'd851 : out <= in [27263:27232];
      10'd852 : out <= in [27295:27264];
      10'd853 : out <= in [27327:27296];
      10'd854 : out <= in [27359:27328];
      10'd855 : out <= in [27391:27360];
      10'd856 : out <= in [27423:27392];
      10'd857 : out <= in [27455:27424];
      10'd858 : out <= in [27487:27456];
      10'd859 : out <= in [27519:27488];
      10'd860 : out <= in [27551:27520];
      10'd861 : out <= in [27583:27552];
      10'd862 : out <= in [27615:27584];
      10'd863 : out <= in [27647:27616];
      10'd864 : out <= in [27679:27648];
      10'd865 : out <= in [27711:27680];
      10'd866 : out <= in [27743:27712];
      10'd867 : out <= in [27775:27744];
      10'd868 : out <= in [27807:27776];
      10'd869 : out <= in [27839:27808];
      10'd870 : out <= in [27871:27840];
      10'd871 : out <= in [27903:27872];
      10'd872 : out <= in [27935:27904];
      10'd873 : out <= in [27967:27936];
      10'd874 : out <= in [27999:27968];
      10'd875 : out <= in [28031:28000];
      10'd876 : out <= in [28063:28032];
      10'd877 : out <= in [28095:28064];
      10'd878 : out <= in [28127:28096];
      10'd879 : out <= in [28159:28128];
      10'd880 : out <= in [28191:28160];
      10'd881 : out <= in [28223:28192];
      10'd882 : out <= in [28255:28224];
      10'd883 : out <= in [28287:28256];
      10'd884 : out <= in [28319:28288];
      10'd885 : out <= in [28351:28320];
      10'd886 : out <= in [28383:28352];
      10'd887 : out <= in [28415:28384];
      10'd888 : out <= in [28447:28416];
      10'd889 : out <= in [28479:28448];
      10'd890 : out <= in [28511:28480];
      10'd891 : out <= in [28543:28512];
      10'd892 : out <= in [28575:28544];
      10'd893 : out <= in [28607:28576];
      10'd894 : out <= in [28639:28608];
      10'd895 : out <= in [28671:28640];
      10'd896 : out <= in [28703:28672];
      10'd897 : out <= in [28735:28704];
      10'd898 : out <= in [28767:28736];
      10'd899 : out <= in [28799:28768];
      10'd900 : out <= in [28831:28800];
      10'd901 : out <= in [28863:28832];
      10'd902 : out <= in [28895:28864];
      10'd903 : out <= in [28927:28896];
      10'd904 : out <= in [28959:28928];
      10'd905 : out <= in [28991:28960];
      10'd906 : out <= in [29023:28992];
      10'd907 : out <= in [29055:29024];
      10'd908 : out <= in [29087:29056];
      10'd909 : out <= in [29119:29088];
      10'd910 : out <= in [29151:29120];
      10'd911 : out <= in [29183:29152];
      10'd912 : out <= in [29215:29184];
      10'd913 : out <= in [29247:29216];
      10'd914 : out <= in [29279:29248];
      10'd915 : out <= in [29311:29280];
      10'd916 : out <= in [29343:29312];
      10'd917 : out <= in [29375:29344];
      10'd918 : out <= in [29407:29376];
      10'd919 : out <= in [29439:29408];
      10'd920 : out <= in [29471:29440];
      10'd921 : out <= in [29503:29472];
      10'd922 : out <= in [29535:29504];
      10'd923 : out <= in [29567:29536];
      10'd924 : out <= in [29599:29568];
      10'd925 : out <= in [29631:29600];
      10'd926 : out <= in [29663:29632];
      10'd927 : out <= in [29695:29664];
      10'd928 : out <= in [29727:29696];
      10'd929 : out <= in [29759:29728];
      10'd930 : out <= in [29791:29760];
      10'd931 : out <= in [29823:29792];
      10'd932 : out <= in [29855:29824];
      10'd933 : out <= in [29887:29856];
      10'd934 : out <= in [29919:29888];
      10'd935 : out <= in [29951:29920];
      10'd936 : out <= in [29983:29952];
      10'd937 : out <= in [30015:29984];
      10'd938 : out <= in [30047:30016];
      10'd939 : out <= in [30079:30048];
      10'd940 : out <= in [30111:30080];
      10'd941 : out <= in [30143:30112];
      10'd942 : out <= in [30175:30144];
      10'd943 : out <= in [30207:30176];
      10'd944 : out <= in [30239:30208];
      10'd945 : out <= in [30271:30240];
      10'd946 : out <= in [30303:30272];
      10'd947 : out <= in [30335:30304];
      10'd948 : out <= in [30367:30336];
      10'd949 : out <= in [30399:30368];
      10'd950 : out <= in [30431:30400];
      10'd951 : out <= in [30463:30432];
      10'd952 : out <= in [30495:30464];
      10'd953 : out <= in [30527:30496];
      10'd954 : out <= in [30559:30528];
      10'd955 : out <= in [30591:30560];
      10'd956 : out <= in [30623:30592];
      10'd957 : out <= in [30655:30624];
      10'd958 : out <= in [30687:30656];
      10'd959 : out <= in [30719:30688];
      10'd960 : out <= in [30751:30720];
      10'd961 : out <= in [30783:30752];
      10'd962 : out <= in [30815:30784];
      10'd963 : out <= in [30847:30816];
      10'd964 : out <= in [30879:30848];
      10'd965 : out <= in [30911:30880];
      10'd966 : out <= in [30943:30912];
      10'd967 : out <= in [30975:30944];
      10'd968 : out <= in [31007:30976];
      10'd969 : out <= in [31039:31008];
      10'd970 : out <= in [31071:31040];
      10'd971 : out <= in [31103:31072];
      10'd972 : out <= in [31135:31104];
      10'd973 : out <= in [31167:31136];
      10'd974 : out <= in [31199:31168];
      10'd975 : out <= in [31231:31200];
      10'd976 : out <= in [31263:31232];
      10'd977 : out <= in [31295:31264];
      10'd978 : out <= in [31327:31296];
      10'd979 : out <= in [31359:31328];
      10'd980 : out <= in [31391:31360];
      10'd981 : out <= in [31423:31392];
      10'd982 : out <= in [31455:31424];
      10'd983 : out <= in [31487:31456];
      10'd984 : out <= in [31519:31488];
      10'd985 : out <= in [31551:31520];
      10'd986 : out <= in [31583:31552];
      10'd987 : out <= in [31615:31584];
      10'd988 : out <= in [31647:31616];
      10'd989 : out <= in [31679:31648];
      10'd990 : out <= in [31711:31680];
      10'd991 : out <= in [31743:31712];
      10'd992 : out <= in [31775:31744];
      10'd993 : out <= in [31807:31776];
      10'd994 : out <= in [31839:31808];
      10'd995 : out <= in [31871:31840];
      10'd996 : out <= in [31903:31872];
      10'd997 : out <= in [31935:31904];
      10'd998 : out <= in [31967:31936];
      10'd999 : out <= in [31999:31968];
      10'd1000 : out <= in [32031:32000];
      10'd1001 : out <= in [32063:32032];
      10'd1002 : out <= in [32095:32064];
      10'd1003 : out <= in [32127:32096];
      10'd1004 : out <= in [32159:32128];
      10'd1005 : out <= in [32191:32160];
      10'd1006 : out <= in [32223:32192];
      10'd1007 : out <= in [32255:32224];
      10'd1008 : out <= in [32287:32256];
      10'd1009 : out <= in [32319:32288];
      10'd1010 : out <= in [32351:32320];
      10'd1011 : out <= in [32383:32352];
      10'd1012 : out <= in [32415:32384];
      10'd1013 : out <= in [32447:32416];
      10'd1014 : out <= in [32479:32448];
      10'd1015 : out <= in [32511:32480];
      10'd1016 : out <= in [32543:32512];
      10'd1017 : out <= in [32575:32544];
      10'd1018 : out <= in [32607:32576];
      10'd1019 : out <= in [32639:32608];
      10'd1020 : out <= in [32671:32640];
      10'd1021 : out <= in [32703:32672];
      10'd1022 : out <= in [32735:32704];
      10'd1023 : out <= in [32767:32736];
      default: out <= 32'hxxxxxxxx;
    endcase
  end
endmodule

module rd_port_mux_8to1 (
  port0_rd_en,
  port0_rd_addr,

  port1_rd_en,
  port1_rd_addr,

  port2_rd_en,
  port2_rd_addr,

  port3_rd_en,
  port3_rd_addr,

  port4_rd_en,
  port4_rd_addr,

  port5_rd_en,
  port5_rd_addr,

  port6_rd_en,
  port6_rd_addr,

  port7_rd_en,
  port7_rd_addr,

  rd_data,

  muxed_port_rd_addr,
  muxed_port_rd_en,
  muxed_port_rd_data
);

  output [2047:0] rd_data;

  output [9:0] muxed_port_rd_addr;
  output muxed_port_rd_en;

  input port0_rd_en;
  input port1_rd_en;
  input port2_rd_en;
  input port3_rd_en;
  input port4_rd_en;
  input port5_rd_en;
  input port6_rd_en;
  input port7_rd_en;

  input [9:0] port0_rd_addr;
  input [9:0] port1_rd_addr;
  input [9:0] port2_rd_addr;
  input [9:0] port3_rd_addr;
  input [9:0] port4_rd_addr;
  input [9:0] port5_rd_addr;
  input [9:0] port6_rd_addr;
  input [9:0] port7_rd_addr;

  input [2047:0] muxed_port_rd_data;

  reg [2047:0] port0_rd_data;
  reg [2047:0] port1_rd_data;
  reg [2047:0] port2_rd_data;
  reg [2047:0] port3_rd_data;
  reg [2047:0] port4_rd_data;
  reg [2047:0] port5_rd_data;
  reg [2047:0] port6_rd_data;
  reg [2047:0] port7_rd_data;
  reg [9:0] muxed_port_rd_addr;
  reg muxed_port_rd_en;

  always @ (
    port0_rd_en or
    port1_rd_en or
    port2_rd_en or
    port3_rd_en or
    port4_rd_en or
    port5_rd_en or
    port6_rd_en or
    port7_rd_en or
    port0_rd_addr or
    port1_rd_addr or
    port2_rd_addr or
    port3_rd_addr or
    port4_rd_addr or
    port5_rd_addr or
    port6_rd_addr or
    port7_rd_addr
  ) begin
    casex({port7_rd_en,port6_rd_en,port5_rd_en,port4_rd_en,port3_rd_en,port2_rd_en,port1_rd_en,port0_rd_en})
      8'b0000_0001:
        begin
          muxed_port_rd_addr <= port0_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0000_0010:
        begin
          muxed_port_rd_addr <= port1_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0000_0100:
        begin
          muxed_port_rd_addr <= port2_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0000_1000:
        begin
          muxed_port_rd_addr <= port3_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0001_0000:
        begin
          muxed_port_rd_addr <= port4_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0010_0000:
        begin
          muxed_port_rd_addr <= port5_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0100_0000:
        begin
          muxed_port_rd_addr <= port6_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b1000_0000:
        begin
          muxed_port_rd_addr <= port7_rd_addr;
          muxed_port_rd_en <= 1'b1;
        end
      8'b0000_0000:
        begin
          muxed_port_rd_addr <= {10{1'bx}};
          muxed_port_rd_en <= 1'b0;
        end
      default:
        begin
          muxed_port_rd_addr <= {10{1'bx}};
          muxed_port_rd_en <= 1'bx;
        end
    endcase
  end

  assign rd_data = muxed_port_rd_data;

endmodule
//rd0 - 128/64/32 bits wide (can be unaligned)
//rd1 - 32 bits wide
//rd2 - 32 bits wide

//wr0 - 128/64/32 bits wide (4 bit enable) (can be unaligned)

module reg_1024x32b_3r_1w (/*AUTOARG*/
			   // Outputs
			   rd0_data, rd1_data, rd2_data,
			   // Inputs
			   rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr0_en, wr0_data, clk
			   );

   //innitial test will only include all 32b ops
   //keep 128 bit bus for future
   output [31:0]  rd0_data;
   output [31:0]  rd1_data;
   output [31:0]  rd2_data;

   //10 bit addr -> 1024 locations
   input [9:0] 	  rd0_addr;
   input [9:0] 	  rd1_addr;
   input [9:0] 	  rd2_addr;

   input [9:0] 	  wr0_addr;
   input [3:0] 	  wr0_en; //extern 4 bit enable [legacy--4 bits determined vector length]
   input [31:0]   wr0_data;

   input 	  clk;

   reg [31:0] 		      rd0_data;
   reg [31:0] 		      rd1_data;
   reg [31:0] 		      rd2_data;
   wire [31:0] 		      rd0_data_bank0;

   wire [9:0] 	  rd0_addr_last;
   wire [9:0] 	  rd1_addr_last;
   wire [9:0] 	  rd2_addr_last;

   dff rd_addr_data_path_delay[10+10+10-1:0]
     (.q({rd0_addr_last, rd1_addr_last, rd2_addr_last}),
      .d({rd0_addr, rd1_addr, rd2_addr}),
      .clk(clk),
      .rst(1'b0));

   // Rd data path
   always @(rd0_addr_last or rd0_data_bank0)//or rd0_data_bank1 or rd0_data_bank2 or rd0_data_bank3)
     begin
	//rd0_data <= {{96{1'b0}},rd0_data_bank0};
	// S: change to 32b line
	rd0_data <= rd0_data_bank0;
     end

   wire [31:0] rd1_data_bank0;
   always @(rd1_addr_last or rd1_data_bank0)// or rd1_data_bank1 or rd1_data_bank2 or rd1_data_bank3)
     begin
	rd1_data <= rd1_data_bank0;
     end

   wire [31:0] rd2_data_bank0;

   always @(rd2_addr_last or rd2_data_bank0)// or rd2_data_bank1 or rd2_data_bank2 or rd2_data_bank3)
     begin

	rd2_data <= rd2_data_bank0;

     end

  reg_256x32b_3r_1w_fpga



   bank0(
    .rd0_addr(rd0_addr),
    .rd0_data(rd0_data_bank0),
    .rd1_addr(rd1_addr),
    .rd1_data(rd1_data_bank0),
    .rd2_addr(rd2_addr),
    .rd2_data(rd2_data_bank0),
    .wr0_addr(wr0_addr), //connect write address straight in
    .wr0_en(wr0_en[0]|wr0_en[1]|wr0_en[2]|wr0_en[3]),  //only focus on 32b, so only enable if bottom bit active high
    .wr0_data(wr0_data[31:0]),
    .clk(clk)
  );

endmodule
//rd0 - 128/64/32 bits wide (can be unaligned)
//rd1 - 32 bits wide
//rd2 - 32 bits wide

//wr0 - 32 bits wide
//wr1 - 128/64/32 bits wide (4 bit enable) (can be unaligned)

module reg_1024x32b_3r_2w (
  rd0_addr,
  rd0_data,

  rd1_addr,
  rd1_data,

  rd2_addr,
  rd2_data,

  wr0_en,
  wr0_addr,
  wr0_data,

  wr1_en,
  wr1_addr,
  wr1_data,

  clk
);

output [127:0] rd0_data;
output [31:0] rd1_data;
output [31:0] rd2_data;

input [9:0] rd0_addr;
input [9:0] rd1_addr;
input [9:0] rd2_addr;

input [9:0] wr0_addr;
input [9:0] wr1_addr;

input wr0_en;
input [3:0] wr1_en;

input [31:0] wr0_data;
input [127:0] wr1_data;

input clk;

/////////////////////////////////////////
reg [127:0] rd0_data;
reg [31:0] rd1_data;
reg [31:0] rd2_data;

/////////////////////////////////////////
//Muxing for rd0

wire [9:0] rd0_addr_plus1;
wire [9:0] rd0_addr_plus2;
wire [9:0] rd0_addr_plus3;
assign rd0_addr_plus1 = rd0_addr + 1'b1;
assign rd0_addr_plus2 = rd0_addr + 2'b10;
assign rd0_addr_plus3 = rd0_addr + 2'b11;
wire [31:0] rd0_data_bank0;
wire [31:0] rd0_data_bank1;
wire [31:0] rd0_data_bank2;
wire [31:0] rd0_data_bank3;
reg [7:0] rd0_addr_bank0;
reg [7:0] rd0_addr_bank1;
reg [7:0] rd0_addr_bank2;
reg [7:0] rd0_addr_bank3;

//Bank distribution for 128/64/32 bit read port
always @(rd0_addr or rd0_addr_plus1 or rd0_addr_plus2 or rd0_addr_plus3
         or rd0_data_bank0 or rd0_data_bank1 or rd0_data_bank2 or rd0_data_bank3)
begin
  casex(rd0_addr[1:0])
    2'b00:
      begin
        rd0_addr_bank0 <= rd0_addr[9:2];
        rd0_addr_bank1 <= rd0_addr_plus1[9:2];
        rd0_addr_bank2 <= rd0_addr_plus2[9:2];
        rd0_addr_bank3 <= rd0_addr_plus3[9:2];
        rd0_data <= {rd0_data_bank3,rd0_data_bank2,rd0_data_bank1,rd0_data_bank0};
      end
    2'b01:
      begin
        rd0_addr_bank0 <= rd0_addr_plus3[9:2];
        rd0_addr_bank1 <= rd0_addr[9:2];
        rd0_addr_bank2 <= rd0_addr_plus1[9:2];
        rd0_addr_bank3 <= rd0_addr_plus2[9:2];
        rd0_data <= {rd0_data_bank0,rd0_data_bank3,rd0_data_bank2,rd0_data_bank1};
      end
    2'b10:
      begin
        rd0_addr_bank0 <= rd0_addr_plus2[9:2];
        rd0_addr_bank1 <= rd0_addr_plus3[9:2];
        rd0_addr_bank2 <= rd0_addr[9:2];
        rd0_addr_bank3 <= rd0_addr_plus1[9:2];
        rd0_data <= {rd0_data_bank1,rd0_data_bank0,rd0_data_bank3,rd0_data_bank2};
      end
    2'b11:
      begin
        rd0_addr_bank0 <= rd0_addr_plus1[9:2];
        rd0_addr_bank1 <= rd0_addr_plus2[9:2];
        rd0_addr_bank2 <= rd0_addr_plus3[9:2];
        rd0_addr_bank3 <= rd0_addr[9:2];
        rd0_data <= {rd0_data_bank2,rd0_data_bank1,rd0_data_bank0,rd0_data_bank3};
      end
    default:
      begin
        rd0_addr_bank0 <= {8{1'bx}};
        rd0_addr_bank1 <= {8{1'bx}};
        rd0_addr_bank2 <= {8{1'bx}};
        rd0_addr_bank3 <= {8{1'bx}};
        rd0_data <= {128{1'bx}};
      end
  endcase
end
/////////////////////////////////////////
//Muxing for rd1
wire [31:0] rd1_data_bank0;
wire [31:0] rd1_data_bank1;
wire [31:0] rd1_data_bank2;
wire [31:0] rd1_data_bank3;
always @(rd1_addr or rd1_data_bank0 or rd1_data_bank1 or rd1_data_bank2 or rd1_data_bank3)
begin
  casex(rd1_addr[1:0])
    2'b00:
      begin
        rd1_data <= rd1_data_bank0;
      end
    2'b01:
      begin
        rd1_data <= rd1_data_bank1;
      end
    2'b10:
      begin
        rd1_data <= rd1_data_bank2;
      end
    2'b11:
      begin
        rd1_data <= rd1_data_bank3;
      end
    default:
      begin
        rd1_data <= {32{1'bx}};
      end
  endcase
end
/////////////////////////////////////////
//Muxing for rd2

wire [31:0] rd2_data_bank0;
wire [31:0] rd2_data_bank1;
wire [31:0] rd2_data_bank2;
wire [31:0] rd2_data_bank3;
always @(rd2_addr or rd2_data_bank0 or rd2_data_bank1 or rd2_data_bank2 or rd2_data_bank3)
begin
  casex(rd2_addr[1:0])
    2'b00:
      begin
        rd2_data <= rd2_data_bank0;
      end
    2'b01:
      begin
        rd2_data <= rd2_data_bank1;
      end
    2'b10:
      begin
        rd2_data <= rd2_data_bank2;
      end
    2'b11:
      begin
        rd2_data <= rd2_data_bank3;
      end
    default:
      begin
        rd2_data <= {32{1'bx}};
      end
  endcase
end
/////////////////////////////////////////
//Muxing for wr0

reg wr0_en_bank0;
reg wr0_en_bank1;
reg wr0_en_bank2;
reg wr0_en_bank3;
always @(wr0_addr or wr0_en)
begin
  casex(wr0_addr[1:0])
    2'b00:
      begin
        wr0_en_bank0 <= wr0_en;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
      end
    2'b01:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= wr0_en;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= 1'b0;
      end
    2'b10:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= wr0_en;
        wr0_en_bank3 <= 1'b0;
      end
    2'b11:
      begin
        wr0_en_bank0 <= 1'b0;
        wr0_en_bank1 <= 1'b0;
        wr0_en_bank2 <= 1'b0;
        wr0_en_bank3 <= wr0_en;
      end
    default:
      begin
        wr0_en_bank0 <= wr0_en;
        wr0_en_bank1 <= wr0_en;
        wr0_en_bank2 <= wr0_en;
        wr0_en_bank3 <= wr0_en;
      end
  endcase
end
/////////////////////////////////////////
//Muxing for wr1

reg [3:0] wr1_en_internal;
reg wr1_en_bank0;
reg wr1_en_bank1;
reg wr1_en_bank2;
reg wr1_en_bank3;
reg [7:0] wr1_addr_bank0;
reg [7:0] wr1_addr_bank1;
reg [7:0] wr1_addr_bank2;
reg [7:0] wr1_addr_bank3;
reg [31:0] wr1_data_bank0;
reg [31:0] wr1_data_bank1;
reg [31:0] wr1_data_bank2;
reg [31:0] wr1_data_bank3;
wire [9:0] wr1_addr_plus1;
wire [9:0] wr1_addr_plus2;
wire [9:0] wr1_addr_plus3;
assign wr1_addr_plus1 = wr1_addr + 1'b1;
assign wr1_addr_plus2 = wr1_addr + 2'b10;
assign wr1_addr_plus3 = wr1_addr + 2'b11;

always @(wr1_addr or wr1_addr_plus1 or wr1_addr_plus2 or wr1_addr_plus3 or wr1_data)
begin
  casex(wr1_addr[1:0])
  2'b00:
    begin
      wr1_addr_bank0 <= wr1_addr[9:2];
      wr1_addr_bank1 <= wr1_addr_plus1[9:2];
      wr1_addr_bank2 <= wr1_addr_plus2[9:2];
      wr1_addr_bank3 <= wr1_addr_plus3[9:2];
      wr1_data_bank0 <= wr1_data[31:0];
      wr1_data_bank1 <= wr1_data[63:32];
      wr1_data_bank2 <= wr1_data[95:64];
      wr1_data_bank3 <= wr1_data[127:96];
      wr1_en_internal <= 4'b0001;
    end
  2'b01:
    begin
      wr1_addr_bank0 <= wr1_addr_plus3[9:2];
      wr1_addr_bank1 <= wr1_addr[9:2];
      wr1_addr_bank2 <= wr1_addr_plus1[9:2];
      wr1_addr_bank3 <= wr1_addr_plus2[9:2];
      wr1_data_bank0 <= wr1_data[127:96];
      wr1_data_bank1 <= wr1_data[31:0];
      wr1_data_bank2 <= wr1_data[63:32];
      wr1_data_bank3 <= wr1_data[95:64];
      wr1_en_internal <= 4'b0010;
    end
  2'b10:
    begin
      wr1_addr_bank0 <= wr1_addr_plus2[9:2];
      wr1_addr_bank1 <= wr1_addr_plus3[9:2];
      wr1_addr_bank2 <= wr1_addr[9:2];
      wr1_addr_bank3 <= wr1_addr_plus1[9:2];
      wr1_data_bank0 <= wr1_data[95:64];
      wr1_data_bank1 <= wr1_data[127:96];
      wr1_data_bank2 <= wr1_data[31:0];
      wr1_data_bank3 <= wr1_data[63:32];
      wr1_en_internal <= 4'b0100;
    end
  2'b11:
    begin
      wr1_addr_bank0 <= wr1_addr_plus1[9:2];
      wr1_addr_bank1 <= wr1_addr_plus2[9:2];
      wr1_addr_bank2 <= wr1_addr_plus3[9:2];
      wr1_addr_bank3 <= wr1_addr[9:2];
      wr1_data_bank0 <= wr1_data[63:32];
      wr1_data_bank1 <= wr1_data[95:64];
      wr1_data_bank2 <= wr1_data[127:96];
      wr1_data_bank3 <= wr1_data[31:0];
      wr1_en_internal <= 4'b1000;
    end
  default:
    begin
      wr1_addr_bank0 <= {8{1'bx}};
      wr1_addr_bank1 <= {8{1'bx}};
      wr1_addr_bank2 <= {8{1'bx}};
      wr1_addr_bank3 <= {8{1'bx}};
      wr1_data_bank0 <= {32{1'bx}};
      wr1_data_bank1 <= {32{1'bx}};
      wr1_data_bank2 <= {32{1'bx}};
      wr1_data_bank3 <= {32{1'bx}};
      wr1_en_internal <= {4{1'bx}};
    end
  endcase
end

always @(wr1_en_internal or wr1_en)
begin
  casex(wr1_en)
    4'b0000:
      begin
        wr1_en_bank0 <= 1'b0;
        wr1_en_bank1 <= 1'b0;
        wr1_en_bank2 <= 1'b0;
        wr1_en_bank3 <= 1'b0;
      end
    4'b0001:
      begin
        wr1_en_bank0 <= wr1_en_internal[0];
        wr1_en_bank1 <= wr1_en_internal[1];
        wr1_en_bank2 <= wr1_en_internal[2];
        wr1_en_bank3 <= wr1_en_internal[3];
      end
    4'b0011:
      begin
        wr1_en_bank0 <= wr1_en_internal[0] | wr1_en_internal[3];
        wr1_en_bank1 <= wr1_en_internal[1] | wr1_en_internal[0];
        wr1_en_bank2 <= wr1_en_internal[2] | wr1_en_internal[1];
        wr1_en_bank3 <= wr1_en_internal[3] | wr1_en_internal[2];
      end
    4'b1111:
      begin
        wr1_en_bank0 <= 1'b1;
        wr1_en_bank1 <= 1'b1;
        wr1_en_bank2 <= 1'b1;
        wr1_en_bank3 <= 1'b1;
      end
    default:
      begin
        wr1_en_bank0 <= 1'bx;
        wr1_en_bank1 <= 1'bx;
        wr1_en_bank2 <= 1'bx;
        wr1_en_bank3 <= 1'bx;
      end
  endcase
end
/////////////////////////////////////////
reg_256x32b_3r_2w bank0(
  .rd0_addr(rd0_addr_bank0),
  .rd0_data(rd0_data_bank0),
  .rd1_addr(rd1_addr[9:2]),
  .rd1_data(rd1_data_bank0),
  .rd2_addr(rd2_addr[9:2]),
  .rd2_data(rd2_data_bank0),
  .wr0_addr(wr0_addr[9:2]),
  .wr0_en(wr0_en_bank0),
  .wr0_data(wr0_data),
  .wr1_addr(wr1_addr_bank0),
  .wr1_en(wr1_en_bank0),
  .wr1_data(wr1_data_bank0),
  .clk(clk)
);

reg_256x32b_3r_2w bank1(
  .rd0_addr(rd0_addr_bank1),
  .rd0_data(rd0_data_bank1),
  .rd1_addr(rd1_addr[9:2]),
  .rd1_data(rd1_data_bank1),
  .rd2_addr(rd2_addr[9:2]),
  .rd2_data(rd2_data_bank1),
  .wr0_addr(wr0_addr[9:2]),
  .wr0_en(wr0_en_bank1),
  .wr0_data(wr0_data),
  .wr1_addr(wr1_addr_bank1),
  .wr1_en(wr1_en_bank1),
  .wr1_data(wr1_data_bank1),
  .clk(clk)
);

reg_256x32b_3r_2w bank2(
  .rd0_addr(rd0_addr_bank2),
  .rd0_data(rd0_data_bank2),
  .rd1_addr(rd1_addr[9:2]),
  .rd1_data(rd1_data_bank2),
  .rd2_addr(rd2_addr[9:2]),
  .rd2_data(rd2_data_bank2),
  .wr0_addr(wr0_addr[9:2]),
  .wr0_en(wr0_en_bank2),
  .wr0_data(wr0_data),
  .wr1_addr(wr1_addr_bank2),
  .wr1_en(wr1_en_bank2),
  .wr1_data(wr1_data_bank2),
  .clk(clk)
);

reg_256x32b_3r_2w bank3(
  .rd0_addr(rd0_addr_bank3),
  .rd0_data(rd0_data_bank3),
  .rd1_addr(rd1_addr[9:2]),
  .rd1_data(rd1_data_bank3),
  .rd2_addr(rd2_addr[9:2]),
  .rd2_data(rd2_data_bank3),
  .wr0_addr(wr0_addr[9:2]),
  .wr0_en(wr0_en_bank3),
  .wr0_data(wr0_data),
  .wr1_addr(wr1_addr_bank3),
  .wr1_en(wr1_en_bank3),
  .wr1_data(wr1_data_bank3),
  .clk(clk)
);
/////////////////////////////////////////

endmodule
//rd0 - 128/64/32 bits wide (can be unaligned)
//rd1 - 32 bits wide
//rd2 - 32 bits wide

//wr0 - 32 bits wide
//wr1 - 128/64/32 bits wide (4 bit enable) (can be unaligned)

module reg_1024x32b_3r_2w_banked 
  (/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr1_addr, wr0_en, wr1_en,
   wr0_data, wr1_data, clk
   );

   output [127:0] rd0_data;
   output [31:0]  rd1_data;
   output [31:0]  rd2_data;

   input [9:0] 	  rd0_addr;
   input [9:0] 	  rd1_addr;
   input [9:0] 	  rd2_addr;

   input [9:0] 	  wr0_addr;
   input [9:0] 	  wr1_addr;

   input 	  wr0_en;
   input [3:0] 	  wr1_en;

   input [31:0]   wr0_data;
   input [127:0]  wr1_data;

   input 	  clk;

   localparam NUMBER_BANKS = 16;

   localparam BANK_ADDR_SIZE = 4;
   
   wire [NUMBER_BANKS*(10-BANK_ADDR_SIZE)-1:0] bank_addr;
   wire [NUMBER_BANKS*32-1:0] 		       bank_data_in;
   wire [NUMBER_BANKS*32-1:0] 		       bank_data_out;
   wire [NUMBER_BANKS-1:0] 		       bank_wr_en_n;

   genvar 				       curr_bank;

   generate 
      for(curr_bank=0; curr_bank<NUMBER_BANKS; curr_bank = curr_bank+1) begin : gen_bank_signals   
	 assign bank_addr[curr_bank*(10-BANK_ADDR_SIZE)+:(10-BANK_ADDR_SIZE)] 
		  = (wr0_en && (wr0_addr[BANK_ADDR_SIZE-1:0] == curr_bank))?  wr0_addr[9:BANK_ADDR_SIZE] :
		    (wr1_en[0] && (wr1_addr[BANK_ADDR_SIZE-1:0] == curr_bank))? wr1_addr[9:BANK_ADDR_SIZE] :
		    (wr1_en[1] && (wr1_addr[BANK_ADDR_SIZE-1:0]+1 == curr_bank))? wr1_addr[9:BANK_ADDR_SIZE] :
		    (wr1_en[2] && (wr1_addr[BANK_ADDR_SIZE-1:0]+2 == curr_bank))? wr1_addr[9:BANK_ADDR_SIZE] :
		    (wr1_en[3] && (wr1_addr[BANK_ADDR_SIZE-1:0]+3 == curr_bank))? wr1_addr[9:BANK_ADDR_SIZE] :
		    (rd0_addr[BANK_ADDR_SIZE-1:0] == curr_bank)? rd0_addr[9:BANK_ADDR_SIZE] :		
		    (rd1_addr[BANK_ADDR_SIZE-1:0] == curr_bank)? rd1_addr[9:BANK_ADDR_SIZE] :		
		    (rd2_addr[BANK_ADDR_SIZE-1:0] == curr_bank)? rd2_addr[9:BANK_ADDR_SIZE] :		
		    (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == curr_bank)? rd0_addr[9:BANK_ADDR_SIZE] :		
		    (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == curr_bank)? rd0_addr[9:BANK_ADDR_SIZE] :		
		    rd0_addr[9:BANK_ADDR_SIZE];

	 assign bank_data_in[curr_bank*32+:32] 
		  = (wr0_en && (wr0_addr[BANK_ADDR_SIZE-1:0] == curr_bank))?  wr0_data[31:0] :
		    (wr1_en[0] && (wr1_addr[BANK_ADDR_SIZE-1:0] == curr_bank))? wr1_data[31:0] :
		    (wr1_en[1] && (wr1_addr[BANK_ADDR_SIZE-1:0]+1 == curr_bank))? wr1_data[63:32] :
		    (wr1_en[2] && (wr1_addr[BANK_ADDR_SIZE-1:0]+2 == curr_bank))? wr1_data[95:64] :
		    wr1_data[127:96];
	 assign bank_wr_en_n[curr_bank]
		  = (wr0_en && (wr0_addr[BANK_ADDR_SIZE-1:0] == curr_bank))?  1'b0 :
		    (wr1_en[0] && (wr1_addr[BANK_ADDR_SIZE-1:0] == curr_bank))? 1'b0 :
		    (wr1_en[1] && (wr1_addr[BANK_ADDR_SIZE-1:0]+1 == curr_bank))? 1'b0 :
		    (wr1_en[2] && (wr1_addr[BANK_ADDR_SIZE-1:0]+2 == curr_bank))? 1'b0 :
		    (wr1_en[3] && (wr1_addr[BANK_ADDR_SIZE-1:0]+3 == curr_bank))? 1'b0 : 1'b1;
      end // block: gen_bank_signals
   endgenerate
   
   assign rd0_data[31:0] 
	    =  (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0] == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];

   assign rd0_data[63:32] 
	    =  (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+1 == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];
   assign rd0_data[95:64] 
	    =  (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+2 == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];
   assign rd0_data[127:96] 
	    =  (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd0_addr[BANK_ADDR_SIZE-1:0]+3 == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];
   
   assign rd1_data[31:0] 
	    =  (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd1_addr[BANK_ADDR_SIZE-1:0] == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];
   assign rd2_data[31:0] 
	    =  (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h0)?  bank_data_out[0*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h1)?  bank_data_out[1*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h2)?  bank_data_out[2*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h3)?  bank_data_out[3*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h4)?  bank_data_out[4*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h5)?  bank_data_out[5*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h6)?  bank_data_out[6*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h7)?  bank_data_out[7*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h8)?  bank_data_out[8*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'h9)?  bank_data_out[9*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'ha)?  bank_data_out[10*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'hb)?  bank_data_out[11*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'hc)?  bank_data_out[12*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'hd)?  bank_data_out[13*32+:32] :
	       (rd2_addr[BANK_ADDR_SIZE-1:0] == 4'he)?  bank_data_out[14*32+:32] :
	       bank_data_out[15*32+:32];

   
   

   SRAMLP1RW64x32 sram_banks[NUMBER_BANKS-1:0] 
     (
      .A(bank_addr),
      // So it works like our current reg file, where we put the
      // addr in the bus and get the data on the same cycle
      .CE(~clk),
      .WEB(bank_wr_en_n),
      .OEB(~bank_wr_en_n),
      .CSB(1'b0),
      .I(bank_data_in),
      .O(bank_data_out),
      .SD(1'b0),
      .LS(1'b0),
      .DS(1'b0),
      .VDD(1'b1),
      .VDDL(1'b1),
      .VSS(1'b0)
      );
   
   

endmodule

/*********************************************************************                                                                                        
 *  SAED_EDK32nm_SRAMLP : SRAMLP1RW64x32 Verilog description             *                                                                                     
 *  ---------------------------------------------------------------   *                                                                                        
 *  Filename      : SRAMLP1RW64x32.v                                   *                                                                                       
 *  SRAMLP name     : SRAMLP1RW64x32                                     *                                                                                     
 *  Word width    : 32    bits                                        *                                                                                        
 *  Word number   : 64                                                *                                                                                        
 *  Adress width  : 6     bits                                        *                                                                                        
 **********************************************************************/

//`timescale 1ns/100fs





module SRAMLP1RW64x32 (A,CE,WEB,OEB,CSB,I,O,SD,LS,DS,VDD,VDDL,VSS);
   input                       SD;
   input                       LS;
   input                       DS;
   (* pg_type="primary_power" *)    input           VDD;
   (* pg_type="secondary_power" *)  input           VDDL;
   (* pg_type="primary_ground" *)   input           VSS;

   input 		       CE;
   input 		       WEB;
   input 		       OEB;
   input 		       CSB;

   input [6-1:0]        A;
   input [32-1:0]     I;
   output [32-1:0]    O;

   /*reg   [`wordLength-1:0]       memory[`numWords-1:0];*/
   /*reg   [`wordLength-1:0]       data_out;*/
   wire [32-1:0]      O;

   wire 		       RE;
   wire 		       WE;

   SRAMLP1RW64x32_1bit sram_IO0 ( CE, WEB,  A, OEB, CSB, I[0], O[0],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO1 ( CE, WEB,  A, OEB, CSB, I[1], O[1],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO2 ( CE, WEB,  A, OEB, CSB, I[2], O[2],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO3 ( CE, WEB,  A, OEB, CSB, I[3], O[3],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO4 ( CE, WEB,  A, OEB, CSB, I[4], O[4],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO5 ( CE, WEB,  A, OEB, CSB, I[5], O[5],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO6 ( CE, WEB,  A, OEB, CSB, I[6], O[6],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO7 ( CE, WEB,  A, OEB, CSB, I[7], O[7],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO8 ( CE, WEB,  A, OEB, CSB, I[8], O[8],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO9 ( CE, WEB,  A, OEB, CSB, I[9], O[9],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO10 ( CE, WEB,  A, OEB, CSB, I[10], O[10],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO11 ( CE, WEB,  A, OEB, CSB, I[11], O[11],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO12 ( CE, WEB,  A, OEB, CSB, I[12], O[12],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO13 ( CE, WEB,  A, OEB, CSB, I[13], O[13],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO14 ( CE, WEB,  A, OEB, CSB, I[14], O[14],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO15 ( CE, WEB,  A, OEB, CSB, I[15], O[15],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO16 ( CE, WEB,  A, OEB, CSB, I[16], O[16],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO17 ( CE, WEB,  A, OEB, CSB, I[17], O[17],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO18 ( CE, WEB,  A, OEB, CSB, I[18], O[18],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO19 ( CE, WEB,  A, OEB, CSB, I[19], O[19],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO20 ( CE, WEB,  A, OEB, CSB, I[20], O[20],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO21 ( CE, WEB,  A, OEB, CSB, I[21], O[21],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO22 ( CE, WEB,  A, OEB, CSB, I[22], O[22],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO23 ( CE, WEB,  A, OEB, CSB, I[23], O[23],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO24 ( CE, WEB,  A, OEB, CSB, I[24], O[24],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO25 ( CE, WEB,  A, OEB, CSB, I[25], O[25],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO26 ( CE, WEB,  A, OEB, CSB, I[26], O[26],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO27 ( CE, WEB,  A, OEB, CSB, I[27], O[27],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO28 ( CE, WEB,  A, OEB, CSB, I[28], O[28],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO29 ( CE, WEB,  A, OEB, CSB, I[29], O[29],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO30 ( CE, WEB,  A, OEB, CSB, I[30], O[30],SD,LS,DS);
   SRAMLP1RW64x32_1bit sram_IO31 ( CE, WEB,  A, OEB, CSB, I[31], O[31],SD,LS,DS);


endmodule


module SRAMLP1RW64x32_1bit (CE_i, WEB_i,  A_i, OEB_i, CSB_i, I_i, O_i,SD,LS,DS);
   input                       SD;
   input                       LS;
   input                       DS;
   integer 		       index;

   input 		       CSB_i;
   input 		       OEB_i;
   input 		       CE_i;
   input 		       WEB_i;

   input [6-1:0]        A_i;
   input [0:0] 		       I_i;

   output [0:0] 	       O_i;

   reg [0:0] 		       O_i;
   reg [0:0] 		       memory[64-1:0];
   reg [0:0] 		       data_out;


   // Write Mode                                                                                                                                                 
   and u1 (RE, ~CSB_i,  WEB_i);
   and u2 (WE, ~CSB_i, ~WEB_i);

   always @ (posedge CE_i)
     if(~CSB_i)
       begin
          if (RE)
            begin
               data_out = memory[A_i];
               if (!OEB_i)
                 O_i = data_out;
	       else
                 O_i = 1'bz;
	    end
          else
            if (WE)
              begin
                 memory[A_i] = I_i;
		 if (!OEB_i)
                   O_i = data_out;
                 else
                   O_i = 1'bz;
	      end
       end
   always @ (SD or LS or DS)
     if(CSB_i)
       begin
          casez ({SD,DS,LS})
            3'b1??:
              begin
                 for(index=0;index<64;index=index+1)
		   memory[index]=1'bx;
                 O_i=1'b0;
	      end
            3'b01?:
              begin
                 O_i=1'b0;
              end
	    3'b001:
              begin
                 if (!OEB_i)
                   O_i = data_out;
		 else
                   O_i = 1'bz;
              end
          endcase
       end



endmodule

module reg_256x32b_3r_1w
  (/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   clk, rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr0_en, wr0_data
   );
   input clk;

   output [31:0] rd0_data;
   output [31:0] rd1_data;
   output [31:0] rd2_data;

   input [9:0]   rd0_addr;
   input [9:0]   rd1_addr;
   input [9:0]   rd2_addr;

   input [9:0]   wr0_addr;

   input   wr0_en;

   input [31:0]  wr0_data;

   wire [32767:0] word_out; //32 x 1024 depth is 32768 - 1
   wire [32767:0] word_in;
   wire [1023:0]  wr_en_word;

   wire [1023:0]  wr0_word_select; //changed from 255 to 1023 (1024 select)

   wire [31:0]   rd0_data_i;
   wire [31:0]   rd1_data_i;
   wire [31:0]   rd2_data_i;
   
   //Register file
   flop_32b word[1023:0](.out(word_out), .in(word_in), .wr_en(wr_en_word), .clk(clk)); //actually 1024 flops

   //Muxes for read ports ***ALL 1024 x 32b MUX
   mux_256x32b_to_1x32b mux_rd_port_0 
     (.out(rd0_data_i), 
      .in(word_out), 
      .select(rd0_addr));

   mux_256x32b_to_1x32b mux_rd_port_1 
     (.out(rd1_data_i), 
      .in(word_out), 
      .select(rd1_addr));

   mux_256x32b_to_1x32b mux_rd_port_2 
     (.out(rd2_data_i), 
      .in(word_out), 
      .select(rd2_addr));

   //Write port logic
   decoder_param #(10,1024) decoder_wr_port_0 
     (.out(wr0_word_select), 
      .in(wr0_addr));

   assign wr_en_word = {1024{wr0_en}} & wr0_word_select;
   assign word_in = {1024{wr0_data}};
   
   // Output flop on the read ports.
   dff_en rd_port_0_out_flop[31:0]
     (.q(rd0_data),
      .d(rd0_data_i),
      .en(1'b1),
      .clk(clk),
      .rst(1'b0));

   dff_en rd_port_1_out_flop[31:0]
     (.q(rd1_data),
      .d(rd1_data_i),
      .en(1'b1),
      .clk(clk),
      .rst(1'b0));

   dff_en rd_port_2_out_flop[31:0]
     (.q(rd2_data),
      .d(rd2_data_i),
      .en(1'b1),
      .clk(clk),
      .rst(1'b0));
  
/*   // For now disable this flop
   assign rd0_data = rd0_data_i;
   assign rd1_data = rd1_data_i;
   assign rd2_data = rd2_data_i;*/
   
endmodule
module reg_256x32b_3r_2w
(
  rd0_data, rd1_data, rd2_data,
  clk,
  rd0_addr, rd1_addr, rd2_addr,
  wr0_addr, wr1_addr,
  wr0_en, wr1_en, wr0_data, wr1_data
);
input clk;

output [31:0] rd0_data;
output [31:0] rd1_data;
output [31:0] rd2_data;

input [7:0] 	  rd0_addr;
input [7:0] 	  rd1_addr;
input [7:0] 	  rd2_addr;

input [7:0] 	  wr0_addr;
input [7:0] 	  wr1_addr;

input 	  wr0_en;
input 	  wr1_en;

input [31:0]   wr0_data;
input [31:0]   wr1_data;

wire [8191:0] word_out;
wire [8191:0] word_in;
wire [255:0] wr_en_word;

wire [255:0] wr0_word_select;
wire [255:0] wr1_word_select;
wire [255:0] wr0_word_enable;
wire [255:0] wr1_word_enable;

//Register file
flop_32b word[255:0](.out(word_out), .in(word_in), .wr_en(wr_en_word), .clk(clk));

//Muxes for read ports
mux_256x32b_to_1x32b mux_rd_port_0 (.out(rd0_data), .in(word_out), .select(rd0_addr));
mux_256x32b_to_1x32b mux_rd_port_1 (.out(rd1_data), .in(word_out), .select(rd1_addr));
mux_256x32b_to_1x32b mux_rd_port_2 (.out(rd2_data), .in(word_out), .select(rd2_addr));

//Write port logic
decoder_param #(8,256) decoder_wr_port_0 (.out(wr0_word_select), .in(wr0_addr));
decoder_param #(8,256) decoder_wr_port_1 (.out(wr1_word_select), .in(wr1_addr));
assign wr0_word_enable = {256{wr0_en}} & wr0_word_select;
assign wr1_word_enable = {256{wr1_en}} & wr1_word_select;
assign wr_en_word = wr0_word_enable | wr1_word_enable;

// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<256; $i=$i+1)
// {
//   $low_index = 32*$i;
//   $high_index = 32*$i+31;
//   print "assign word_in[$high_index:$low_index] = ({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b01) ? wr0_data : (({wr1_word_enable[$i],wr0_word_enable[$i]} == 2'b10) ? wr1_data : {32{1'bx}});\n";
// }
// %%stop_veriperl
assign word_in[31:0] = ({wr1_word_enable[0],wr0_word_enable[0]} == 2'b01) ? wr0_data : (({wr1_word_enable[0],wr0_word_enable[0]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[63:32] = ({wr1_word_enable[1],wr0_word_enable[1]} == 2'b01) ? wr0_data : (({wr1_word_enable[1],wr0_word_enable[1]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[95:64] = ({wr1_word_enable[2],wr0_word_enable[2]} == 2'b01) ? wr0_data : (({wr1_word_enable[2],wr0_word_enable[2]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[127:96] = ({wr1_word_enable[3],wr0_word_enable[3]} == 2'b01) ? wr0_data : (({wr1_word_enable[3],wr0_word_enable[3]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[159:128] = ({wr1_word_enable[4],wr0_word_enable[4]} == 2'b01) ? wr0_data : (({wr1_word_enable[4],wr0_word_enable[4]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[191:160] = ({wr1_word_enable[5],wr0_word_enable[5]} == 2'b01) ? wr0_data : (({wr1_word_enable[5],wr0_word_enable[5]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[223:192] = ({wr1_word_enable[6],wr0_word_enable[6]} == 2'b01) ? wr0_data : (({wr1_word_enable[6],wr0_word_enable[6]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[255:224] = ({wr1_word_enable[7],wr0_word_enable[7]} == 2'b01) ? wr0_data : (({wr1_word_enable[7],wr0_word_enable[7]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[287:256] = ({wr1_word_enable[8],wr0_word_enable[8]} == 2'b01) ? wr0_data : (({wr1_word_enable[8],wr0_word_enable[8]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[319:288] = ({wr1_word_enable[9],wr0_word_enable[9]} == 2'b01) ? wr0_data : (({wr1_word_enable[9],wr0_word_enable[9]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[351:320] = ({wr1_word_enable[10],wr0_word_enable[10]} == 2'b01) ? wr0_data : (({wr1_word_enable[10],wr0_word_enable[10]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[383:352] = ({wr1_word_enable[11],wr0_word_enable[11]} == 2'b01) ? wr0_data : (({wr1_word_enable[11],wr0_word_enable[11]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[415:384] = ({wr1_word_enable[12],wr0_word_enable[12]} == 2'b01) ? wr0_data : (({wr1_word_enable[12],wr0_word_enable[12]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[447:416] = ({wr1_word_enable[13],wr0_word_enable[13]} == 2'b01) ? wr0_data : (({wr1_word_enable[13],wr0_word_enable[13]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[479:448] = ({wr1_word_enable[14],wr0_word_enable[14]} == 2'b01) ? wr0_data : (({wr1_word_enable[14],wr0_word_enable[14]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[511:480] = ({wr1_word_enable[15],wr0_word_enable[15]} == 2'b01) ? wr0_data : (({wr1_word_enable[15],wr0_word_enable[15]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[543:512] = ({wr1_word_enable[16],wr0_word_enable[16]} == 2'b01) ? wr0_data : (({wr1_word_enable[16],wr0_word_enable[16]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[575:544] = ({wr1_word_enable[17],wr0_word_enable[17]} == 2'b01) ? wr0_data : (({wr1_word_enable[17],wr0_word_enable[17]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[607:576] = ({wr1_word_enable[18],wr0_word_enable[18]} == 2'b01) ? wr0_data : (({wr1_word_enable[18],wr0_word_enable[18]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[639:608] = ({wr1_word_enable[19],wr0_word_enable[19]} == 2'b01) ? wr0_data : (({wr1_word_enable[19],wr0_word_enable[19]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[671:640] = ({wr1_word_enable[20],wr0_word_enable[20]} == 2'b01) ? wr0_data : (({wr1_word_enable[20],wr0_word_enable[20]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[703:672] = ({wr1_word_enable[21],wr0_word_enable[21]} == 2'b01) ? wr0_data : (({wr1_word_enable[21],wr0_word_enable[21]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[735:704] = ({wr1_word_enable[22],wr0_word_enable[22]} == 2'b01) ? wr0_data : (({wr1_word_enable[22],wr0_word_enable[22]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[767:736] = ({wr1_word_enable[23],wr0_word_enable[23]} == 2'b01) ? wr0_data : (({wr1_word_enable[23],wr0_word_enable[23]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[799:768] = ({wr1_word_enable[24],wr0_word_enable[24]} == 2'b01) ? wr0_data : (({wr1_word_enable[24],wr0_word_enable[24]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[831:800] = ({wr1_word_enable[25],wr0_word_enable[25]} == 2'b01) ? wr0_data : (({wr1_word_enable[25],wr0_word_enable[25]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[863:832] = ({wr1_word_enable[26],wr0_word_enable[26]} == 2'b01) ? wr0_data : (({wr1_word_enable[26],wr0_word_enable[26]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[895:864] = ({wr1_word_enable[27],wr0_word_enable[27]} == 2'b01) ? wr0_data : (({wr1_word_enable[27],wr0_word_enable[27]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[927:896] = ({wr1_word_enable[28],wr0_word_enable[28]} == 2'b01) ? wr0_data : (({wr1_word_enable[28],wr0_word_enable[28]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[959:928] = ({wr1_word_enable[29],wr0_word_enable[29]} == 2'b01) ? wr0_data : (({wr1_word_enable[29],wr0_word_enable[29]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[991:960] = ({wr1_word_enable[30],wr0_word_enable[30]} == 2'b01) ? wr0_data : (({wr1_word_enable[30],wr0_word_enable[30]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1023:992] = ({wr1_word_enable[31],wr0_word_enable[31]} == 2'b01) ? wr0_data : (({wr1_word_enable[31],wr0_word_enable[31]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1055:1024] = ({wr1_word_enable[32],wr0_word_enable[32]} == 2'b01) ? wr0_data : (({wr1_word_enable[32],wr0_word_enable[32]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1087:1056] = ({wr1_word_enable[33],wr0_word_enable[33]} == 2'b01) ? wr0_data : (({wr1_word_enable[33],wr0_word_enable[33]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1119:1088] = ({wr1_word_enable[34],wr0_word_enable[34]} == 2'b01) ? wr0_data : (({wr1_word_enable[34],wr0_word_enable[34]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1151:1120] = ({wr1_word_enable[35],wr0_word_enable[35]} == 2'b01) ? wr0_data : (({wr1_word_enable[35],wr0_word_enable[35]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1183:1152] = ({wr1_word_enable[36],wr0_word_enable[36]} == 2'b01) ? wr0_data : (({wr1_word_enable[36],wr0_word_enable[36]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1215:1184] = ({wr1_word_enable[37],wr0_word_enable[37]} == 2'b01) ? wr0_data : (({wr1_word_enable[37],wr0_word_enable[37]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1247:1216] = ({wr1_word_enable[38],wr0_word_enable[38]} == 2'b01) ? wr0_data : (({wr1_word_enable[38],wr0_word_enable[38]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1279:1248] = ({wr1_word_enable[39],wr0_word_enable[39]} == 2'b01) ? wr0_data : (({wr1_word_enable[39],wr0_word_enable[39]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1311:1280] = ({wr1_word_enable[40],wr0_word_enable[40]} == 2'b01) ? wr0_data : (({wr1_word_enable[40],wr0_word_enable[40]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1343:1312] = ({wr1_word_enable[41],wr0_word_enable[41]} == 2'b01) ? wr0_data : (({wr1_word_enable[41],wr0_word_enable[41]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1375:1344] = ({wr1_word_enable[42],wr0_word_enable[42]} == 2'b01) ? wr0_data : (({wr1_word_enable[42],wr0_word_enable[42]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1407:1376] = ({wr1_word_enable[43],wr0_word_enable[43]} == 2'b01) ? wr0_data : (({wr1_word_enable[43],wr0_word_enable[43]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1439:1408] = ({wr1_word_enable[44],wr0_word_enable[44]} == 2'b01) ? wr0_data : (({wr1_word_enable[44],wr0_word_enable[44]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1471:1440] = ({wr1_word_enable[45],wr0_word_enable[45]} == 2'b01) ? wr0_data : (({wr1_word_enable[45],wr0_word_enable[45]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1503:1472] = ({wr1_word_enable[46],wr0_word_enable[46]} == 2'b01) ? wr0_data : (({wr1_word_enable[46],wr0_word_enable[46]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1535:1504] = ({wr1_word_enable[47],wr0_word_enable[47]} == 2'b01) ? wr0_data : (({wr1_word_enable[47],wr0_word_enable[47]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1567:1536] = ({wr1_word_enable[48],wr0_word_enable[48]} == 2'b01) ? wr0_data : (({wr1_word_enable[48],wr0_word_enable[48]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1599:1568] = ({wr1_word_enable[49],wr0_word_enable[49]} == 2'b01) ? wr0_data : (({wr1_word_enable[49],wr0_word_enable[49]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1631:1600] = ({wr1_word_enable[50],wr0_word_enable[50]} == 2'b01) ? wr0_data : (({wr1_word_enable[50],wr0_word_enable[50]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1663:1632] = ({wr1_word_enable[51],wr0_word_enable[51]} == 2'b01) ? wr0_data : (({wr1_word_enable[51],wr0_word_enable[51]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1695:1664] = ({wr1_word_enable[52],wr0_word_enable[52]} == 2'b01) ? wr0_data : (({wr1_word_enable[52],wr0_word_enable[52]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1727:1696] = ({wr1_word_enable[53],wr0_word_enable[53]} == 2'b01) ? wr0_data : (({wr1_word_enable[53],wr0_word_enable[53]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1759:1728] = ({wr1_word_enable[54],wr0_word_enable[54]} == 2'b01) ? wr0_data : (({wr1_word_enable[54],wr0_word_enable[54]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1791:1760] = ({wr1_word_enable[55],wr0_word_enable[55]} == 2'b01) ? wr0_data : (({wr1_word_enable[55],wr0_word_enable[55]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1823:1792] = ({wr1_word_enable[56],wr0_word_enable[56]} == 2'b01) ? wr0_data : (({wr1_word_enable[56],wr0_word_enable[56]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1855:1824] = ({wr1_word_enable[57],wr0_word_enable[57]} == 2'b01) ? wr0_data : (({wr1_word_enable[57],wr0_word_enable[57]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1887:1856] = ({wr1_word_enable[58],wr0_word_enable[58]} == 2'b01) ? wr0_data : (({wr1_word_enable[58],wr0_word_enable[58]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1919:1888] = ({wr1_word_enable[59],wr0_word_enable[59]} == 2'b01) ? wr0_data : (({wr1_word_enable[59],wr0_word_enable[59]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1951:1920] = ({wr1_word_enable[60],wr0_word_enable[60]} == 2'b01) ? wr0_data : (({wr1_word_enable[60],wr0_word_enable[60]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[1983:1952] = ({wr1_word_enable[61],wr0_word_enable[61]} == 2'b01) ? wr0_data : (({wr1_word_enable[61],wr0_word_enable[61]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2015:1984] = ({wr1_word_enable[62],wr0_word_enable[62]} == 2'b01) ? wr0_data : (({wr1_word_enable[62],wr0_word_enable[62]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2047:2016] = ({wr1_word_enable[63],wr0_word_enable[63]} == 2'b01) ? wr0_data : (({wr1_word_enable[63],wr0_word_enable[63]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2079:2048] = ({wr1_word_enable[64],wr0_word_enable[64]} == 2'b01) ? wr0_data : (({wr1_word_enable[64],wr0_word_enable[64]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2111:2080] = ({wr1_word_enable[65],wr0_word_enable[65]} == 2'b01) ? wr0_data : (({wr1_word_enable[65],wr0_word_enable[65]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2143:2112] = ({wr1_word_enable[66],wr0_word_enable[66]} == 2'b01) ? wr0_data : (({wr1_word_enable[66],wr0_word_enable[66]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2175:2144] = ({wr1_word_enable[67],wr0_word_enable[67]} == 2'b01) ? wr0_data : (({wr1_word_enable[67],wr0_word_enable[67]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2207:2176] = ({wr1_word_enable[68],wr0_word_enable[68]} == 2'b01) ? wr0_data : (({wr1_word_enable[68],wr0_word_enable[68]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2239:2208] = ({wr1_word_enable[69],wr0_word_enable[69]} == 2'b01) ? wr0_data : (({wr1_word_enable[69],wr0_word_enable[69]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2271:2240] = ({wr1_word_enable[70],wr0_word_enable[70]} == 2'b01) ? wr0_data : (({wr1_word_enable[70],wr0_word_enable[70]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2303:2272] = ({wr1_word_enable[71],wr0_word_enable[71]} == 2'b01) ? wr0_data : (({wr1_word_enable[71],wr0_word_enable[71]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2335:2304] = ({wr1_word_enable[72],wr0_word_enable[72]} == 2'b01) ? wr0_data : (({wr1_word_enable[72],wr0_word_enable[72]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2367:2336] = ({wr1_word_enable[73],wr0_word_enable[73]} == 2'b01) ? wr0_data : (({wr1_word_enable[73],wr0_word_enable[73]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2399:2368] = ({wr1_word_enable[74],wr0_word_enable[74]} == 2'b01) ? wr0_data : (({wr1_word_enable[74],wr0_word_enable[74]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2431:2400] = ({wr1_word_enable[75],wr0_word_enable[75]} == 2'b01) ? wr0_data : (({wr1_word_enable[75],wr0_word_enable[75]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2463:2432] = ({wr1_word_enable[76],wr0_word_enable[76]} == 2'b01) ? wr0_data : (({wr1_word_enable[76],wr0_word_enable[76]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2495:2464] = ({wr1_word_enable[77],wr0_word_enable[77]} == 2'b01) ? wr0_data : (({wr1_word_enable[77],wr0_word_enable[77]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2527:2496] = ({wr1_word_enable[78],wr0_word_enable[78]} == 2'b01) ? wr0_data : (({wr1_word_enable[78],wr0_word_enable[78]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2559:2528] = ({wr1_word_enable[79],wr0_word_enable[79]} == 2'b01) ? wr0_data : (({wr1_word_enable[79],wr0_word_enable[79]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2591:2560] = ({wr1_word_enable[80],wr0_word_enable[80]} == 2'b01) ? wr0_data : (({wr1_word_enable[80],wr0_word_enable[80]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2623:2592] = ({wr1_word_enable[81],wr0_word_enable[81]} == 2'b01) ? wr0_data : (({wr1_word_enable[81],wr0_word_enable[81]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2655:2624] = ({wr1_word_enable[82],wr0_word_enable[82]} == 2'b01) ? wr0_data : (({wr1_word_enable[82],wr0_word_enable[82]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2687:2656] = ({wr1_word_enable[83],wr0_word_enable[83]} == 2'b01) ? wr0_data : (({wr1_word_enable[83],wr0_word_enable[83]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2719:2688] = ({wr1_word_enable[84],wr0_word_enable[84]} == 2'b01) ? wr0_data : (({wr1_word_enable[84],wr0_word_enable[84]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2751:2720] = ({wr1_word_enable[85],wr0_word_enable[85]} == 2'b01) ? wr0_data : (({wr1_word_enable[85],wr0_word_enable[85]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2783:2752] = ({wr1_word_enable[86],wr0_word_enable[86]} == 2'b01) ? wr0_data : (({wr1_word_enable[86],wr0_word_enable[86]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2815:2784] = ({wr1_word_enable[87],wr0_word_enable[87]} == 2'b01) ? wr0_data : (({wr1_word_enable[87],wr0_word_enable[87]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2847:2816] = ({wr1_word_enable[88],wr0_word_enable[88]} == 2'b01) ? wr0_data : (({wr1_word_enable[88],wr0_word_enable[88]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2879:2848] = ({wr1_word_enable[89],wr0_word_enable[89]} == 2'b01) ? wr0_data : (({wr1_word_enable[89],wr0_word_enable[89]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2911:2880] = ({wr1_word_enable[90],wr0_word_enable[90]} == 2'b01) ? wr0_data : (({wr1_word_enable[90],wr0_word_enable[90]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2943:2912] = ({wr1_word_enable[91],wr0_word_enable[91]} == 2'b01) ? wr0_data : (({wr1_word_enable[91],wr0_word_enable[91]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[2975:2944] = ({wr1_word_enable[92],wr0_word_enable[92]} == 2'b01) ? wr0_data : (({wr1_word_enable[92],wr0_word_enable[92]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3007:2976] = ({wr1_word_enable[93],wr0_word_enable[93]} == 2'b01) ? wr0_data : (({wr1_word_enable[93],wr0_word_enable[93]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3039:3008] = ({wr1_word_enable[94],wr0_word_enable[94]} == 2'b01) ? wr0_data : (({wr1_word_enable[94],wr0_word_enable[94]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3071:3040] = ({wr1_word_enable[95],wr0_word_enable[95]} == 2'b01) ? wr0_data : (({wr1_word_enable[95],wr0_word_enable[95]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3103:3072] = ({wr1_word_enable[96],wr0_word_enable[96]} == 2'b01) ? wr0_data : (({wr1_word_enable[96],wr0_word_enable[96]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3135:3104] = ({wr1_word_enable[97],wr0_word_enable[97]} == 2'b01) ? wr0_data : (({wr1_word_enable[97],wr0_word_enable[97]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3167:3136] = ({wr1_word_enable[98],wr0_word_enable[98]} == 2'b01) ? wr0_data : (({wr1_word_enable[98],wr0_word_enable[98]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3199:3168] = ({wr1_word_enable[99],wr0_word_enable[99]} == 2'b01) ? wr0_data : (({wr1_word_enable[99],wr0_word_enable[99]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3231:3200] = ({wr1_word_enable[100],wr0_word_enable[100]} == 2'b01) ? wr0_data : (({wr1_word_enable[100],wr0_word_enable[100]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3263:3232] = ({wr1_word_enable[101],wr0_word_enable[101]} == 2'b01) ? wr0_data : (({wr1_word_enable[101],wr0_word_enable[101]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3295:3264] = ({wr1_word_enable[102],wr0_word_enable[102]} == 2'b01) ? wr0_data : (({wr1_word_enable[102],wr0_word_enable[102]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3327:3296] = ({wr1_word_enable[103],wr0_word_enable[103]} == 2'b01) ? wr0_data : (({wr1_word_enable[103],wr0_word_enable[103]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3359:3328] = ({wr1_word_enable[104],wr0_word_enable[104]} == 2'b01) ? wr0_data : (({wr1_word_enable[104],wr0_word_enable[104]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3391:3360] = ({wr1_word_enable[105],wr0_word_enable[105]} == 2'b01) ? wr0_data : (({wr1_word_enable[105],wr0_word_enable[105]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3423:3392] = ({wr1_word_enable[106],wr0_word_enable[106]} == 2'b01) ? wr0_data : (({wr1_word_enable[106],wr0_word_enable[106]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3455:3424] = ({wr1_word_enable[107],wr0_word_enable[107]} == 2'b01) ? wr0_data : (({wr1_word_enable[107],wr0_word_enable[107]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3487:3456] = ({wr1_word_enable[108],wr0_word_enable[108]} == 2'b01) ? wr0_data : (({wr1_word_enable[108],wr0_word_enable[108]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3519:3488] = ({wr1_word_enable[109],wr0_word_enable[109]} == 2'b01) ? wr0_data : (({wr1_word_enable[109],wr0_word_enable[109]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3551:3520] = ({wr1_word_enable[110],wr0_word_enable[110]} == 2'b01) ? wr0_data : (({wr1_word_enable[110],wr0_word_enable[110]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3583:3552] = ({wr1_word_enable[111],wr0_word_enable[111]} == 2'b01) ? wr0_data : (({wr1_word_enable[111],wr0_word_enable[111]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3615:3584] = ({wr1_word_enable[112],wr0_word_enable[112]} == 2'b01) ? wr0_data : (({wr1_word_enable[112],wr0_word_enable[112]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3647:3616] = ({wr1_word_enable[113],wr0_word_enable[113]} == 2'b01) ? wr0_data : (({wr1_word_enable[113],wr0_word_enable[113]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3679:3648] = ({wr1_word_enable[114],wr0_word_enable[114]} == 2'b01) ? wr0_data : (({wr1_word_enable[114],wr0_word_enable[114]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3711:3680] = ({wr1_word_enable[115],wr0_word_enable[115]} == 2'b01) ? wr0_data : (({wr1_word_enable[115],wr0_word_enable[115]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3743:3712] = ({wr1_word_enable[116],wr0_word_enable[116]} == 2'b01) ? wr0_data : (({wr1_word_enable[116],wr0_word_enable[116]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3775:3744] = ({wr1_word_enable[117],wr0_word_enable[117]} == 2'b01) ? wr0_data : (({wr1_word_enable[117],wr0_word_enable[117]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3807:3776] = ({wr1_word_enable[118],wr0_word_enable[118]} == 2'b01) ? wr0_data : (({wr1_word_enable[118],wr0_word_enable[118]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3839:3808] = ({wr1_word_enable[119],wr0_word_enable[119]} == 2'b01) ? wr0_data : (({wr1_word_enable[119],wr0_word_enable[119]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3871:3840] = ({wr1_word_enable[120],wr0_word_enable[120]} == 2'b01) ? wr0_data : (({wr1_word_enable[120],wr0_word_enable[120]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3903:3872] = ({wr1_word_enable[121],wr0_word_enable[121]} == 2'b01) ? wr0_data : (({wr1_word_enable[121],wr0_word_enable[121]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3935:3904] = ({wr1_word_enable[122],wr0_word_enable[122]} == 2'b01) ? wr0_data : (({wr1_word_enable[122],wr0_word_enable[122]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3967:3936] = ({wr1_word_enable[123],wr0_word_enable[123]} == 2'b01) ? wr0_data : (({wr1_word_enable[123],wr0_word_enable[123]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[3999:3968] = ({wr1_word_enable[124],wr0_word_enable[124]} == 2'b01) ? wr0_data : (({wr1_word_enable[124],wr0_word_enable[124]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4031:4000] = ({wr1_word_enable[125],wr0_word_enable[125]} == 2'b01) ? wr0_data : (({wr1_word_enable[125],wr0_word_enable[125]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4063:4032] = ({wr1_word_enable[126],wr0_word_enable[126]} == 2'b01) ? wr0_data : (({wr1_word_enable[126],wr0_word_enable[126]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4095:4064] = ({wr1_word_enable[127],wr0_word_enable[127]} == 2'b01) ? wr0_data : (({wr1_word_enable[127],wr0_word_enable[127]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4127:4096] = ({wr1_word_enable[128],wr0_word_enable[128]} == 2'b01) ? wr0_data : (({wr1_word_enable[128],wr0_word_enable[128]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4159:4128] = ({wr1_word_enable[129],wr0_word_enable[129]} == 2'b01) ? wr0_data : (({wr1_word_enable[129],wr0_word_enable[129]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4191:4160] = ({wr1_word_enable[130],wr0_word_enable[130]} == 2'b01) ? wr0_data : (({wr1_word_enable[130],wr0_word_enable[130]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4223:4192] = ({wr1_word_enable[131],wr0_word_enable[131]} == 2'b01) ? wr0_data : (({wr1_word_enable[131],wr0_word_enable[131]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4255:4224] = ({wr1_word_enable[132],wr0_word_enable[132]} == 2'b01) ? wr0_data : (({wr1_word_enable[132],wr0_word_enable[132]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4287:4256] = ({wr1_word_enable[133],wr0_word_enable[133]} == 2'b01) ? wr0_data : (({wr1_word_enable[133],wr0_word_enable[133]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4319:4288] = ({wr1_word_enable[134],wr0_word_enable[134]} == 2'b01) ? wr0_data : (({wr1_word_enable[134],wr0_word_enable[134]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4351:4320] = ({wr1_word_enable[135],wr0_word_enable[135]} == 2'b01) ? wr0_data : (({wr1_word_enable[135],wr0_word_enable[135]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4383:4352] = ({wr1_word_enable[136],wr0_word_enable[136]} == 2'b01) ? wr0_data : (({wr1_word_enable[136],wr0_word_enable[136]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4415:4384] = ({wr1_word_enable[137],wr0_word_enable[137]} == 2'b01) ? wr0_data : (({wr1_word_enable[137],wr0_word_enable[137]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4447:4416] = ({wr1_word_enable[138],wr0_word_enable[138]} == 2'b01) ? wr0_data : (({wr1_word_enable[138],wr0_word_enable[138]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4479:4448] = ({wr1_word_enable[139],wr0_word_enable[139]} == 2'b01) ? wr0_data : (({wr1_word_enable[139],wr0_word_enable[139]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4511:4480] = ({wr1_word_enable[140],wr0_word_enable[140]} == 2'b01) ? wr0_data : (({wr1_word_enable[140],wr0_word_enable[140]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4543:4512] = ({wr1_word_enable[141],wr0_word_enable[141]} == 2'b01) ? wr0_data : (({wr1_word_enable[141],wr0_word_enable[141]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4575:4544] = ({wr1_word_enable[142],wr0_word_enable[142]} == 2'b01) ? wr0_data : (({wr1_word_enable[142],wr0_word_enable[142]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4607:4576] = ({wr1_word_enable[143],wr0_word_enable[143]} == 2'b01) ? wr0_data : (({wr1_word_enable[143],wr0_word_enable[143]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4639:4608] = ({wr1_word_enable[144],wr0_word_enable[144]} == 2'b01) ? wr0_data : (({wr1_word_enable[144],wr0_word_enable[144]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4671:4640] = ({wr1_word_enable[145],wr0_word_enable[145]} == 2'b01) ? wr0_data : (({wr1_word_enable[145],wr0_word_enable[145]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4703:4672] = ({wr1_word_enable[146],wr0_word_enable[146]} == 2'b01) ? wr0_data : (({wr1_word_enable[146],wr0_word_enable[146]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4735:4704] = ({wr1_word_enable[147],wr0_word_enable[147]} == 2'b01) ? wr0_data : (({wr1_word_enable[147],wr0_word_enable[147]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4767:4736] = ({wr1_word_enable[148],wr0_word_enable[148]} == 2'b01) ? wr0_data : (({wr1_word_enable[148],wr0_word_enable[148]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4799:4768] = ({wr1_word_enable[149],wr0_word_enable[149]} == 2'b01) ? wr0_data : (({wr1_word_enable[149],wr0_word_enable[149]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4831:4800] = ({wr1_word_enable[150],wr0_word_enable[150]} == 2'b01) ? wr0_data : (({wr1_word_enable[150],wr0_word_enable[150]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4863:4832] = ({wr1_word_enable[151],wr0_word_enable[151]} == 2'b01) ? wr0_data : (({wr1_word_enable[151],wr0_word_enable[151]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4895:4864] = ({wr1_word_enable[152],wr0_word_enable[152]} == 2'b01) ? wr0_data : (({wr1_word_enable[152],wr0_word_enable[152]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4927:4896] = ({wr1_word_enable[153],wr0_word_enable[153]} == 2'b01) ? wr0_data : (({wr1_word_enable[153],wr0_word_enable[153]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4959:4928] = ({wr1_word_enable[154],wr0_word_enable[154]} == 2'b01) ? wr0_data : (({wr1_word_enable[154],wr0_word_enable[154]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[4991:4960] = ({wr1_word_enable[155],wr0_word_enable[155]} == 2'b01) ? wr0_data : (({wr1_word_enable[155],wr0_word_enable[155]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5023:4992] = ({wr1_word_enable[156],wr0_word_enable[156]} == 2'b01) ? wr0_data : (({wr1_word_enable[156],wr0_word_enable[156]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5055:5024] = ({wr1_word_enable[157],wr0_word_enable[157]} == 2'b01) ? wr0_data : (({wr1_word_enable[157],wr0_word_enable[157]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5087:5056] = ({wr1_word_enable[158],wr0_word_enable[158]} == 2'b01) ? wr0_data : (({wr1_word_enable[158],wr0_word_enable[158]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5119:5088] = ({wr1_word_enable[159],wr0_word_enable[159]} == 2'b01) ? wr0_data : (({wr1_word_enable[159],wr0_word_enable[159]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5151:5120] = ({wr1_word_enable[160],wr0_word_enable[160]} == 2'b01) ? wr0_data : (({wr1_word_enable[160],wr0_word_enable[160]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5183:5152] = ({wr1_word_enable[161],wr0_word_enable[161]} == 2'b01) ? wr0_data : (({wr1_word_enable[161],wr0_word_enable[161]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5215:5184] = ({wr1_word_enable[162],wr0_word_enable[162]} == 2'b01) ? wr0_data : (({wr1_word_enable[162],wr0_word_enable[162]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5247:5216] = ({wr1_word_enable[163],wr0_word_enable[163]} == 2'b01) ? wr0_data : (({wr1_word_enable[163],wr0_word_enable[163]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5279:5248] = ({wr1_word_enable[164],wr0_word_enable[164]} == 2'b01) ? wr0_data : (({wr1_word_enable[164],wr0_word_enable[164]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5311:5280] = ({wr1_word_enable[165],wr0_word_enable[165]} == 2'b01) ? wr0_data : (({wr1_word_enable[165],wr0_word_enable[165]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5343:5312] = ({wr1_word_enable[166],wr0_word_enable[166]} == 2'b01) ? wr0_data : (({wr1_word_enable[166],wr0_word_enable[166]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5375:5344] = ({wr1_word_enable[167],wr0_word_enable[167]} == 2'b01) ? wr0_data : (({wr1_word_enable[167],wr0_word_enable[167]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5407:5376] = ({wr1_word_enable[168],wr0_word_enable[168]} == 2'b01) ? wr0_data : (({wr1_word_enable[168],wr0_word_enable[168]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5439:5408] = ({wr1_word_enable[169],wr0_word_enable[169]} == 2'b01) ? wr0_data : (({wr1_word_enable[169],wr0_word_enable[169]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5471:5440] = ({wr1_word_enable[170],wr0_word_enable[170]} == 2'b01) ? wr0_data : (({wr1_word_enable[170],wr0_word_enable[170]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5503:5472] = ({wr1_word_enable[171],wr0_word_enable[171]} == 2'b01) ? wr0_data : (({wr1_word_enable[171],wr0_word_enable[171]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5535:5504] = ({wr1_word_enable[172],wr0_word_enable[172]} == 2'b01) ? wr0_data : (({wr1_word_enable[172],wr0_word_enable[172]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5567:5536] = ({wr1_word_enable[173],wr0_word_enable[173]} == 2'b01) ? wr0_data : (({wr1_word_enable[173],wr0_word_enable[173]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5599:5568] = ({wr1_word_enable[174],wr0_word_enable[174]} == 2'b01) ? wr0_data : (({wr1_word_enable[174],wr0_word_enable[174]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5631:5600] = ({wr1_word_enable[175],wr0_word_enable[175]} == 2'b01) ? wr0_data : (({wr1_word_enable[175],wr0_word_enable[175]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5663:5632] = ({wr1_word_enable[176],wr0_word_enable[176]} == 2'b01) ? wr0_data : (({wr1_word_enable[176],wr0_word_enable[176]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5695:5664] = ({wr1_word_enable[177],wr0_word_enable[177]} == 2'b01) ? wr0_data : (({wr1_word_enable[177],wr0_word_enable[177]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5727:5696] = ({wr1_word_enable[178],wr0_word_enable[178]} == 2'b01) ? wr0_data : (({wr1_word_enable[178],wr0_word_enable[178]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5759:5728] = ({wr1_word_enable[179],wr0_word_enable[179]} == 2'b01) ? wr0_data : (({wr1_word_enable[179],wr0_word_enable[179]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5791:5760] = ({wr1_word_enable[180],wr0_word_enable[180]} == 2'b01) ? wr0_data : (({wr1_word_enable[180],wr0_word_enable[180]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5823:5792] = ({wr1_word_enable[181],wr0_word_enable[181]} == 2'b01) ? wr0_data : (({wr1_word_enable[181],wr0_word_enable[181]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5855:5824] = ({wr1_word_enable[182],wr0_word_enable[182]} == 2'b01) ? wr0_data : (({wr1_word_enable[182],wr0_word_enable[182]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5887:5856] = ({wr1_word_enable[183],wr0_word_enable[183]} == 2'b01) ? wr0_data : (({wr1_word_enable[183],wr0_word_enable[183]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5919:5888] = ({wr1_word_enable[184],wr0_word_enable[184]} == 2'b01) ? wr0_data : (({wr1_word_enable[184],wr0_word_enable[184]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5951:5920] = ({wr1_word_enable[185],wr0_word_enable[185]} == 2'b01) ? wr0_data : (({wr1_word_enable[185],wr0_word_enable[185]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[5983:5952] = ({wr1_word_enable[186],wr0_word_enable[186]} == 2'b01) ? wr0_data : (({wr1_word_enable[186],wr0_word_enable[186]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6015:5984] = ({wr1_word_enable[187],wr0_word_enable[187]} == 2'b01) ? wr0_data : (({wr1_word_enable[187],wr0_word_enable[187]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6047:6016] = ({wr1_word_enable[188],wr0_word_enable[188]} == 2'b01) ? wr0_data : (({wr1_word_enable[188],wr0_word_enable[188]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6079:6048] = ({wr1_word_enable[189],wr0_word_enable[189]} == 2'b01) ? wr0_data : (({wr1_word_enable[189],wr0_word_enable[189]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6111:6080] = ({wr1_word_enable[190],wr0_word_enable[190]} == 2'b01) ? wr0_data : (({wr1_word_enable[190],wr0_word_enable[190]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6143:6112] = ({wr1_word_enable[191],wr0_word_enable[191]} == 2'b01) ? wr0_data : (({wr1_word_enable[191],wr0_word_enable[191]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6175:6144] = ({wr1_word_enable[192],wr0_word_enable[192]} == 2'b01) ? wr0_data : (({wr1_word_enable[192],wr0_word_enable[192]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6207:6176] = ({wr1_word_enable[193],wr0_word_enable[193]} == 2'b01) ? wr0_data : (({wr1_word_enable[193],wr0_word_enable[193]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6239:6208] = ({wr1_word_enable[194],wr0_word_enable[194]} == 2'b01) ? wr0_data : (({wr1_word_enable[194],wr0_word_enable[194]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6271:6240] = ({wr1_word_enable[195],wr0_word_enable[195]} == 2'b01) ? wr0_data : (({wr1_word_enable[195],wr0_word_enable[195]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6303:6272] = ({wr1_word_enable[196],wr0_word_enable[196]} == 2'b01) ? wr0_data : (({wr1_word_enable[196],wr0_word_enable[196]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6335:6304] = ({wr1_word_enable[197],wr0_word_enable[197]} == 2'b01) ? wr0_data : (({wr1_word_enable[197],wr0_word_enable[197]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6367:6336] = ({wr1_word_enable[198],wr0_word_enable[198]} == 2'b01) ? wr0_data : (({wr1_word_enable[198],wr0_word_enable[198]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6399:6368] = ({wr1_word_enable[199],wr0_word_enable[199]} == 2'b01) ? wr0_data : (({wr1_word_enable[199],wr0_word_enable[199]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6431:6400] = ({wr1_word_enable[200],wr0_word_enable[200]} == 2'b01) ? wr0_data : (({wr1_word_enable[200],wr0_word_enable[200]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6463:6432] = ({wr1_word_enable[201],wr0_word_enable[201]} == 2'b01) ? wr0_data : (({wr1_word_enable[201],wr0_word_enable[201]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6495:6464] = ({wr1_word_enable[202],wr0_word_enable[202]} == 2'b01) ? wr0_data : (({wr1_word_enable[202],wr0_word_enable[202]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6527:6496] = ({wr1_word_enable[203],wr0_word_enable[203]} == 2'b01) ? wr0_data : (({wr1_word_enable[203],wr0_word_enable[203]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6559:6528] = ({wr1_word_enable[204],wr0_word_enable[204]} == 2'b01) ? wr0_data : (({wr1_word_enable[204],wr0_word_enable[204]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6591:6560] = ({wr1_word_enable[205],wr0_word_enable[205]} == 2'b01) ? wr0_data : (({wr1_word_enable[205],wr0_word_enable[205]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6623:6592] = ({wr1_word_enable[206],wr0_word_enable[206]} == 2'b01) ? wr0_data : (({wr1_word_enable[206],wr0_word_enable[206]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6655:6624] = ({wr1_word_enable[207],wr0_word_enable[207]} == 2'b01) ? wr0_data : (({wr1_word_enable[207],wr0_word_enable[207]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6687:6656] = ({wr1_word_enable[208],wr0_word_enable[208]} == 2'b01) ? wr0_data : (({wr1_word_enable[208],wr0_word_enable[208]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6719:6688] = ({wr1_word_enable[209],wr0_word_enable[209]} == 2'b01) ? wr0_data : (({wr1_word_enable[209],wr0_word_enable[209]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6751:6720] = ({wr1_word_enable[210],wr0_word_enable[210]} == 2'b01) ? wr0_data : (({wr1_word_enable[210],wr0_word_enable[210]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6783:6752] = ({wr1_word_enable[211],wr0_word_enable[211]} == 2'b01) ? wr0_data : (({wr1_word_enable[211],wr0_word_enable[211]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6815:6784] = ({wr1_word_enable[212],wr0_word_enable[212]} == 2'b01) ? wr0_data : (({wr1_word_enable[212],wr0_word_enable[212]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6847:6816] = ({wr1_word_enable[213],wr0_word_enable[213]} == 2'b01) ? wr0_data : (({wr1_word_enable[213],wr0_word_enable[213]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6879:6848] = ({wr1_word_enable[214],wr0_word_enable[214]} == 2'b01) ? wr0_data : (({wr1_word_enable[214],wr0_word_enable[214]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6911:6880] = ({wr1_word_enable[215],wr0_word_enable[215]} == 2'b01) ? wr0_data : (({wr1_word_enable[215],wr0_word_enable[215]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6943:6912] = ({wr1_word_enable[216],wr0_word_enable[216]} == 2'b01) ? wr0_data : (({wr1_word_enable[216],wr0_word_enable[216]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[6975:6944] = ({wr1_word_enable[217],wr0_word_enable[217]} == 2'b01) ? wr0_data : (({wr1_word_enable[217],wr0_word_enable[217]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7007:6976] = ({wr1_word_enable[218],wr0_word_enable[218]} == 2'b01) ? wr0_data : (({wr1_word_enable[218],wr0_word_enable[218]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7039:7008] = ({wr1_word_enable[219],wr0_word_enable[219]} == 2'b01) ? wr0_data : (({wr1_word_enable[219],wr0_word_enable[219]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7071:7040] = ({wr1_word_enable[220],wr0_word_enable[220]} == 2'b01) ? wr0_data : (({wr1_word_enable[220],wr0_word_enable[220]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7103:7072] = ({wr1_word_enable[221],wr0_word_enable[221]} == 2'b01) ? wr0_data : (({wr1_word_enable[221],wr0_word_enable[221]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7135:7104] = ({wr1_word_enable[222],wr0_word_enable[222]} == 2'b01) ? wr0_data : (({wr1_word_enable[222],wr0_word_enable[222]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7167:7136] = ({wr1_word_enable[223],wr0_word_enable[223]} == 2'b01) ? wr0_data : (({wr1_word_enable[223],wr0_word_enable[223]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7199:7168] = ({wr1_word_enable[224],wr0_word_enable[224]} == 2'b01) ? wr0_data : (({wr1_word_enable[224],wr0_word_enable[224]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7231:7200] = ({wr1_word_enable[225],wr0_word_enable[225]} == 2'b01) ? wr0_data : (({wr1_word_enable[225],wr0_word_enable[225]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7263:7232] = ({wr1_word_enable[226],wr0_word_enable[226]} == 2'b01) ? wr0_data : (({wr1_word_enable[226],wr0_word_enable[226]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7295:7264] = ({wr1_word_enable[227],wr0_word_enable[227]} == 2'b01) ? wr0_data : (({wr1_word_enable[227],wr0_word_enable[227]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7327:7296] = ({wr1_word_enable[228],wr0_word_enable[228]} == 2'b01) ? wr0_data : (({wr1_word_enable[228],wr0_word_enable[228]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7359:7328] = ({wr1_word_enable[229],wr0_word_enable[229]} == 2'b01) ? wr0_data : (({wr1_word_enable[229],wr0_word_enable[229]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7391:7360] = ({wr1_word_enable[230],wr0_word_enable[230]} == 2'b01) ? wr0_data : (({wr1_word_enable[230],wr0_word_enable[230]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7423:7392] = ({wr1_word_enable[231],wr0_word_enable[231]} == 2'b01) ? wr0_data : (({wr1_word_enable[231],wr0_word_enable[231]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7455:7424] = ({wr1_word_enable[232],wr0_word_enable[232]} == 2'b01) ? wr0_data : (({wr1_word_enable[232],wr0_word_enable[232]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7487:7456] = ({wr1_word_enable[233],wr0_word_enable[233]} == 2'b01) ? wr0_data : (({wr1_word_enable[233],wr0_word_enable[233]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7519:7488] = ({wr1_word_enable[234],wr0_word_enable[234]} == 2'b01) ? wr0_data : (({wr1_word_enable[234],wr0_word_enable[234]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7551:7520] = ({wr1_word_enable[235],wr0_word_enable[235]} == 2'b01) ? wr0_data : (({wr1_word_enable[235],wr0_word_enable[235]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7583:7552] = ({wr1_word_enable[236],wr0_word_enable[236]} == 2'b01) ? wr0_data : (({wr1_word_enable[236],wr0_word_enable[236]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7615:7584] = ({wr1_word_enable[237],wr0_word_enable[237]} == 2'b01) ? wr0_data : (({wr1_word_enable[237],wr0_word_enable[237]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7647:7616] = ({wr1_word_enable[238],wr0_word_enable[238]} == 2'b01) ? wr0_data : (({wr1_word_enable[238],wr0_word_enable[238]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7679:7648] = ({wr1_word_enable[239],wr0_word_enable[239]} == 2'b01) ? wr0_data : (({wr1_word_enable[239],wr0_word_enable[239]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7711:7680] = ({wr1_word_enable[240],wr0_word_enable[240]} == 2'b01) ? wr0_data : (({wr1_word_enable[240],wr0_word_enable[240]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7743:7712] = ({wr1_word_enable[241],wr0_word_enable[241]} == 2'b01) ? wr0_data : (({wr1_word_enable[241],wr0_word_enable[241]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7775:7744] = ({wr1_word_enable[242],wr0_word_enable[242]} == 2'b01) ? wr0_data : (({wr1_word_enable[242],wr0_word_enable[242]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7807:7776] = ({wr1_word_enable[243],wr0_word_enable[243]} == 2'b01) ? wr0_data : (({wr1_word_enable[243],wr0_word_enable[243]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7839:7808] = ({wr1_word_enable[244],wr0_word_enable[244]} == 2'b01) ? wr0_data : (({wr1_word_enable[244],wr0_word_enable[244]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7871:7840] = ({wr1_word_enable[245],wr0_word_enable[245]} == 2'b01) ? wr0_data : (({wr1_word_enable[245],wr0_word_enable[245]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7903:7872] = ({wr1_word_enable[246],wr0_word_enable[246]} == 2'b01) ? wr0_data : (({wr1_word_enable[246],wr0_word_enable[246]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7935:7904] = ({wr1_word_enable[247],wr0_word_enable[247]} == 2'b01) ? wr0_data : (({wr1_word_enable[247],wr0_word_enable[247]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7967:7936] = ({wr1_word_enable[248],wr0_word_enable[248]} == 2'b01) ? wr0_data : (({wr1_word_enable[248],wr0_word_enable[248]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[7999:7968] = ({wr1_word_enable[249],wr0_word_enable[249]} == 2'b01) ? wr0_data : (({wr1_word_enable[249],wr0_word_enable[249]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8031:8000] = ({wr1_word_enable[250],wr0_word_enable[250]} == 2'b01) ? wr0_data : (({wr1_word_enable[250],wr0_word_enable[250]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8063:8032] = ({wr1_word_enable[251],wr0_word_enable[251]} == 2'b01) ? wr0_data : (({wr1_word_enable[251],wr0_word_enable[251]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8095:8064] = ({wr1_word_enable[252],wr0_word_enable[252]} == 2'b01) ? wr0_data : (({wr1_word_enable[252],wr0_word_enable[252]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8127:8096] = ({wr1_word_enable[253],wr0_word_enable[253]} == 2'b01) ? wr0_data : (({wr1_word_enable[253],wr0_word_enable[253]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8159:8128] = ({wr1_word_enable[254],wr0_word_enable[254]} == 2'b01) ? wr0_data : (({wr1_word_enable[254],wr0_word_enable[254]} == 2'b10) ? wr1_data : {32{1'bx}});
assign word_in[8191:8160] = ({wr1_word_enable[255],wr0_word_enable[255]} == 2'b01) ? wr0_data : (({wr1_word_enable[255],wr0_word_enable[255]} == 2'b10) ? wr1_data : {32{1'bx}});

endmodule
module reg_64page_1024x32b_3r_1w 
  (/*AUTOARG*/
   // Outputs
   rd0_data, rd1_data, rd2_data,
   // Inputs
   rd0_addr, rd1_addr, rd2_addr, wr0_addr, wr0_en, wr0_en_xoutof4,
   wr0_data, clk
   );

   output [2047:0] rd0_data;
   output [2047:0] rd1_data;
   output [2047:0] rd2_data;

   input [9:0] 	   rd0_addr;
   input [9:0] 	   rd1_addr;
   input [9:0] 	   rd2_addr;

   input [9:0] 	   wr0_addr;

   input [63:0]    wr0_en;
   input [3:0] 	   wr0_en_xoutof4;


   input [2047:0]  wr0_data;

   input 	   clk;

   wire [255:0]    effective_wr0_en;

   reg_1024x32b_3r_1w page[63:0] 
     (
      .rd0_addr(rd0_addr),
      .rd0_data(rd0_data),
      .rd1_addr(rd1_addr),
      .rd1_data(rd1_data),
      .rd2_addr(rd2_addr),
      .rd2_data(rd2_data),
      .wr0_en(effective_wr0_en),
      .wr0_addr(wr0_addr),
      .wr0_data(wr0_data),
      .clk(clk)
      );

// %%start_veriperl
//    my $i;
//    my $low_index;
//    my $high_index;
//    for($i=0; $i<64; $i=$i+1)
//      {
//       $low_index = 4*$i;
//       $high_index = 4*$i+3;
//       print "assign effective_wr0_en[$high_index:$low_index] = {4{wr0_en[$i]}} & wr0_en_xoutof4;\n";
//       }
// %%stop_veriperl
assign effective_wr0_en[3:0] = {4{wr0_en[0]}} & wr0_en_xoutof4;
assign effective_wr0_en[7:4] = {4{wr0_en[1]}} & wr0_en_xoutof4;
assign effective_wr0_en[11:8] = {4{wr0_en[2]}} & wr0_en_xoutof4;
assign effective_wr0_en[15:12] = {4{wr0_en[3]}} & wr0_en_xoutof4;
assign effective_wr0_en[19:16] = {4{wr0_en[4]}} & wr0_en_xoutof4;
assign effective_wr0_en[23:20] = {4{wr0_en[5]}} & wr0_en_xoutof4;
assign effective_wr0_en[27:24] = {4{wr0_en[6]}} & wr0_en_xoutof4;
assign effective_wr0_en[31:28] = {4{wr0_en[7]}} & wr0_en_xoutof4;
assign effective_wr0_en[35:32] = {4{wr0_en[8]}} & wr0_en_xoutof4;
assign effective_wr0_en[39:36] = {4{wr0_en[9]}} & wr0_en_xoutof4;
assign effective_wr0_en[43:40] = {4{wr0_en[10]}} & wr0_en_xoutof4;
assign effective_wr0_en[47:44] = {4{wr0_en[11]}} & wr0_en_xoutof4;
assign effective_wr0_en[51:48] = {4{wr0_en[12]}} & wr0_en_xoutof4;
assign effective_wr0_en[55:52] = {4{wr0_en[13]}} & wr0_en_xoutof4;
assign effective_wr0_en[59:56] = {4{wr0_en[14]}} & wr0_en_xoutof4;
assign effective_wr0_en[63:60] = {4{wr0_en[15]}} & wr0_en_xoutof4;
assign effective_wr0_en[67:64] = {4{wr0_en[16]}} & wr0_en_xoutof4;
assign effective_wr0_en[71:68] = {4{wr0_en[17]}} & wr0_en_xoutof4;
assign effective_wr0_en[75:72] = {4{wr0_en[18]}} & wr0_en_xoutof4;
assign effective_wr0_en[79:76] = {4{wr0_en[19]}} & wr0_en_xoutof4;
assign effective_wr0_en[83:80] = {4{wr0_en[20]}} & wr0_en_xoutof4;
assign effective_wr0_en[87:84] = {4{wr0_en[21]}} & wr0_en_xoutof4;
assign effective_wr0_en[91:88] = {4{wr0_en[22]}} & wr0_en_xoutof4;
assign effective_wr0_en[95:92] = {4{wr0_en[23]}} & wr0_en_xoutof4;
assign effective_wr0_en[99:96] = {4{wr0_en[24]}} & wr0_en_xoutof4;
assign effective_wr0_en[103:100] = {4{wr0_en[25]}} & wr0_en_xoutof4;
assign effective_wr0_en[107:104] = {4{wr0_en[26]}} & wr0_en_xoutof4;
assign effective_wr0_en[111:108] = {4{wr0_en[27]}} & wr0_en_xoutof4;
assign effective_wr0_en[115:112] = {4{wr0_en[28]}} & wr0_en_xoutof4;
assign effective_wr0_en[119:116] = {4{wr0_en[29]}} & wr0_en_xoutof4;
assign effective_wr0_en[123:120] = {4{wr0_en[30]}} & wr0_en_xoutof4;
assign effective_wr0_en[127:124] = {4{wr0_en[31]}} & wr0_en_xoutof4;
assign effective_wr0_en[131:128] = {4{wr0_en[32]}} & wr0_en_xoutof4;
assign effective_wr0_en[135:132] = {4{wr0_en[33]}} & wr0_en_xoutof4;
assign effective_wr0_en[139:136] = {4{wr0_en[34]}} & wr0_en_xoutof4;
assign effective_wr0_en[143:140] = {4{wr0_en[35]}} & wr0_en_xoutof4;
assign effective_wr0_en[147:144] = {4{wr0_en[36]}} & wr0_en_xoutof4;
assign effective_wr0_en[151:148] = {4{wr0_en[37]}} & wr0_en_xoutof4;
assign effective_wr0_en[155:152] = {4{wr0_en[38]}} & wr0_en_xoutof4;
assign effective_wr0_en[159:156] = {4{wr0_en[39]}} & wr0_en_xoutof4;
assign effective_wr0_en[163:160] = {4{wr0_en[40]}} & wr0_en_xoutof4;
assign effective_wr0_en[167:164] = {4{wr0_en[41]}} & wr0_en_xoutof4;
assign effective_wr0_en[171:168] = {4{wr0_en[42]}} & wr0_en_xoutof4;
assign effective_wr0_en[175:172] = {4{wr0_en[43]}} & wr0_en_xoutof4;
assign effective_wr0_en[179:176] = {4{wr0_en[44]}} & wr0_en_xoutof4;
assign effective_wr0_en[183:180] = {4{wr0_en[45]}} & wr0_en_xoutof4;
assign effective_wr0_en[187:184] = {4{wr0_en[46]}} & wr0_en_xoutof4;
assign effective_wr0_en[191:188] = {4{wr0_en[47]}} & wr0_en_xoutof4;
assign effective_wr0_en[195:192] = {4{wr0_en[48]}} & wr0_en_xoutof4;
assign effective_wr0_en[199:196] = {4{wr0_en[49]}} & wr0_en_xoutof4;
assign effective_wr0_en[203:200] = {4{wr0_en[50]}} & wr0_en_xoutof4;
assign effective_wr0_en[207:204] = {4{wr0_en[51]}} & wr0_en_xoutof4;
assign effective_wr0_en[211:208] = {4{wr0_en[52]}} & wr0_en_xoutof4;
assign effective_wr0_en[215:212] = {4{wr0_en[53]}} & wr0_en_xoutof4;
assign effective_wr0_en[219:216] = {4{wr0_en[54]}} & wr0_en_xoutof4;
assign effective_wr0_en[223:220] = {4{wr0_en[55]}} & wr0_en_xoutof4;
assign effective_wr0_en[227:224] = {4{wr0_en[56]}} & wr0_en_xoutof4;
assign effective_wr0_en[231:228] = {4{wr0_en[57]}} & wr0_en_xoutof4;
assign effective_wr0_en[235:232] = {4{wr0_en[58]}} & wr0_en_xoutof4;
assign effective_wr0_en[239:236] = {4{wr0_en[59]}} & wr0_en_xoutof4;
assign effective_wr0_en[243:240] = {4{wr0_en[60]}} & wr0_en_xoutof4;
assign effective_wr0_en[247:244] = {4{wr0_en[61]}} & wr0_en_xoutof4;
assign effective_wr0_en[251:248] = {4{wr0_en[62]}} & wr0_en_xoutof4;
assign effective_wr0_en[255:252] = {4{wr0_en[63]}} & wr0_en_xoutof4;
	 
	 endmodule
module reg_64page_1024x32b_3r_2w (
  rd0_addr,
  rd0_data,

  rd1_addr,
  rd1_data,

  rd2_addr,
  rd2_data,

  wr0_en,
  wr0_addr,
  wr0_data,

  wr1_en,
  wr1_en_xoutof4,
  wr1_addr,
  wr1_data,

  clk
);

  output [8191:0] rd0_data;
  output [2047:0] rd1_data;
  output [2047:0] rd2_data;

  input [9:0] rd0_addr;
  input [9:0] rd1_addr;
  input [9:0] rd2_addr;

  input [9:0] wr0_addr;
  input [9:0] wr1_addr;

  input [63:0] wr0_en;
  input [63:0] wr1_en;
  input [3:0] wr1_en_xoutof4;

  input [2047:0] wr0_data;
  input [8191:0] wr1_data;

  input clk;

  wire [255:0] effective_wr1_en;

  reg_1024x32b_3r_2w page[63:0] (
    .rd0_addr(rd0_addr),
    .rd0_data(rd0_data),
    .rd1_addr(rd1_addr),
    .rd1_data(rd1_data),
    .rd2_addr(rd2_addr),
    .rd2_data(rd2_data),
    .wr0_en(wr0_en),
    .wr0_addr(wr0_addr),
    .wr0_data(wr0_data),
    .wr1_en(effective_wr1_en),
    .wr1_addr(wr1_addr),
    .wr1_data(wr1_data),
    .clk(clk)
  );

// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<64; $i=$i+1)
// {
//   $low_index = 4*$i;
//   $high_index = 4*$i+3;
//   print "assign effective_wr1_en[$high_index:$low_index] = {4{wr1_en[$i]}} & wr1_en_xoutof4;\n";
// }
// %%stop_veriperl
assign effective_wr1_en[3:0] = {4{wr1_en[0]}} & wr1_en_xoutof4;
assign effective_wr1_en[7:4] = {4{wr1_en[1]}} & wr1_en_xoutof4;
assign effective_wr1_en[11:8] = {4{wr1_en[2]}} & wr1_en_xoutof4;
assign effective_wr1_en[15:12] = {4{wr1_en[3]}} & wr1_en_xoutof4;
assign effective_wr1_en[19:16] = {4{wr1_en[4]}} & wr1_en_xoutof4;
assign effective_wr1_en[23:20] = {4{wr1_en[5]}} & wr1_en_xoutof4;
assign effective_wr1_en[27:24] = {4{wr1_en[6]}} & wr1_en_xoutof4;
assign effective_wr1_en[31:28] = {4{wr1_en[7]}} & wr1_en_xoutof4;
assign effective_wr1_en[35:32] = {4{wr1_en[8]}} & wr1_en_xoutof4;
assign effective_wr1_en[39:36] = {4{wr1_en[9]}} & wr1_en_xoutof4;
assign effective_wr1_en[43:40] = {4{wr1_en[10]}} & wr1_en_xoutof4;
assign effective_wr1_en[47:44] = {4{wr1_en[11]}} & wr1_en_xoutof4;
assign effective_wr1_en[51:48] = {4{wr1_en[12]}} & wr1_en_xoutof4;
assign effective_wr1_en[55:52] = {4{wr1_en[13]}} & wr1_en_xoutof4;
assign effective_wr1_en[59:56] = {4{wr1_en[14]}} & wr1_en_xoutof4;
assign effective_wr1_en[63:60] = {4{wr1_en[15]}} & wr1_en_xoutof4;
assign effective_wr1_en[67:64] = {4{wr1_en[16]}} & wr1_en_xoutof4;
assign effective_wr1_en[71:68] = {4{wr1_en[17]}} & wr1_en_xoutof4;
assign effective_wr1_en[75:72] = {4{wr1_en[18]}} & wr1_en_xoutof4;
assign effective_wr1_en[79:76] = {4{wr1_en[19]}} & wr1_en_xoutof4;
assign effective_wr1_en[83:80] = {4{wr1_en[20]}} & wr1_en_xoutof4;
assign effective_wr1_en[87:84] = {4{wr1_en[21]}} & wr1_en_xoutof4;
assign effective_wr1_en[91:88] = {4{wr1_en[22]}} & wr1_en_xoutof4;
assign effective_wr1_en[95:92] = {4{wr1_en[23]}} & wr1_en_xoutof4;
assign effective_wr1_en[99:96] = {4{wr1_en[24]}} & wr1_en_xoutof4;
assign effective_wr1_en[103:100] = {4{wr1_en[25]}} & wr1_en_xoutof4;
assign effective_wr1_en[107:104] = {4{wr1_en[26]}} & wr1_en_xoutof4;
assign effective_wr1_en[111:108] = {4{wr1_en[27]}} & wr1_en_xoutof4;
assign effective_wr1_en[115:112] = {4{wr1_en[28]}} & wr1_en_xoutof4;
assign effective_wr1_en[119:116] = {4{wr1_en[29]}} & wr1_en_xoutof4;
assign effective_wr1_en[123:120] = {4{wr1_en[30]}} & wr1_en_xoutof4;
assign effective_wr1_en[127:124] = {4{wr1_en[31]}} & wr1_en_xoutof4;
assign effective_wr1_en[131:128] = {4{wr1_en[32]}} & wr1_en_xoutof4;
assign effective_wr1_en[135:132] = {4{wr1_en[33]}} & wr1_en_xoutof4;
assign effective_wr1_en[139:136] = {4{wr1_en[34]}} & wr1_en_xoutof4;
assign effective_wr1_en[143:140] = {4{wr1_en[35]}} & wr1_en_xoutof4;
assign effective_wr1_en[147:144] = {4{wr1_en[36]}} & wr1_en_xoutof4;
assign effective_wr1_en[151:148] = {4{wr1_en[37]}} & wr1_en_xoutof4;
assign effective_wr1_en[155:152] = {4{wr1_en[38]}} & wr1_en_xoutof4;
assign effective_wr1_en[159:156] = {4{wr1_en[39]}} & wr1_en_xoutof4;
assign effective_wr1_en[163:160] = {4{wr1_en[40]}} & wr1_en_xoutof4;
assign effective_wr1_en[167:164] = {4{wr1_en[41]}} & wr1_en_xoutof4;
assign effective_wr1_en[171:168] = {4{wr1_en[42]}} & wr1_en_xoutof4;
assign effective_wr1_en[175:172] = {4{wr1_en[43]}} & wr1_en_xoutof4;
assign effective_wr1_en[179:176] = {4{wr1_en[44]}} & wr1_en_xoutof4;
assign effective_wr1_en[183:180] = {4{wr1_en[45]}} & wr1_en_xoutof4;
assign effective_wr1_en[187:184] = {4{wr1_en[46]}} & wr1_en_xoutof4;
assign effective_wr1_en[191:188] = {4{wr1_en[47]}} & wr1_en_xoutof4;
assign effective_wr1_en[195:192] = {4{wr1_en[48]}} & wr1_en_xoutof4;
assign effective_wr1_en[199:196] = {4{wr1_en[49]}} & wr1_en_xoutof4;
assign effective_wr1_en[203:200] = {4{wr1_en[50]}} & wr1_en_xoutof4;
assign effective_wr1_en[207:204] = {4{wr1_en[51]}} & wr1_en_xoutof4;
assign effective_wr1_en[211:208] = {4{wr1_en[52]}} & wr1_en_xoutof4;
assign effective_wr1_en[215:212] = {4{wr1_en[53]}} & wr1_en_xoutof4;
assign effective_wr1_en[219:216] = {4{wr1_en[54]}} & wr1_en_xoutof4;
assign effective_wr1_en[223:220] = {4{wr1_en[55]}} & wr1_en_xoutof4;
assign effective_wr1_en[227:224] = {4{wr1_en[56]}} & wr1_en_xoutof4;
assign effective_wr1_en[231:228] = {4{wr1_en[57]}} & wr1_en_xoutof4;
assign effective_wr1_en[235:232] = {4{wr1_en[58]}} & wr1_en_xoutof4;
assign effective_wr1_en[239:236] = {4{wr1_en[59]}} & wr1_en_xoutof4;
assign effective_wr1_en[243:240] = {4{wr1_en[60]}} & wr1_en_xoutof4;
assign effective_wr1_en[247:244] = {4{wr1_en[61]}} & wr1_en_xoutof4;
assign effective_wr1_en[251:248] = {4{wr1_en[62]}} & wr1_en_xoutof4;
assign effective_wr1_en[255:252] = {4{wr1_en[63]}} & wr1_en_xoutof4;

endmodule
module vgpr( 
      simd0_source1_rd_en,
      simd1_source1_rd_en,
      simd2_source1_rd_en,
      simd3_source1_rd_en,
      simd0_source2_rd_en,
      simd1_source2_rd_en,
      simd2_source2_rd_en,
      simd3_source2_rd_en,
      simd0_source3_rd_en,
      simd1_source3_rd_en,
      simd2_source3_rd_en,
      simd3_source3_rd_en,
      simd0_source1_addr,
      simd1_source1_addr,
      simd2_source1_addr,
      simd3_source1_addr,
      simd0_source2_addr,
      simd1_source2_addr,
      simd2_source2_addr,
      simd3_source2_addr,
      simd0_source3_addr,
      simd1_source3_addr,
      simd2_source3_addr,
      simd3_source3_addr,
      simd0_dest_addr,
      simd1_dest_addr,
      simd2_dest_addr,
      simd3_dest_addr,
      simd0_dest_data,
      simd1_dest_data,
      simd2_dest_data,
      simd3_dest_data,
      simd0_wr_en,
      simd1_wr_en,
      simd2_wr_en,
      simd3_wr_en,
      simd0_wr_mask,
      simd1_wr_mask,
      simd2_wr_mask,
      simd3_wr_mask,
      simf0_source1_rd_en,
      simf1_source1_rd_en,
      simf2_source1_rd_en,
      simf3_source1_rd_en,
      simf0_source2_rd_en,
      simf1_source2_rd_en,
      simf2_source2_rd_en,
      simf3_source2_rd_en,
      simf0_source3_rd_en,
      simf1_source3_rd_en,
      simf2_source3_rd_en,
      simf3_source3_rd_en,
      simf0_source1_addr,
      simf1_source1_addr,
      simf2_source1_addr,
      simf3_source1_addr,
      simf0_source2_addr,
      simf1_source2_addr,
      simf2_source2_addr,
      simf3_source2_addr,
      simf0_source3_addr,
      simf1_source3_addr,
      simf2_source3_addr,
      simf3_source3_addr,
      simf0_dest_addr,
      simf1_dest_addr,
      simf2_dest_addr,
      simf3_dest_addr,
      simf0_dest_data,
      simf1_dest_data,
      simf2_dest_data,
      simf3_dest_data,
      simf0_wr_en,
      simf1_wr_en,
      simf2_wr_en,
      simf3_wr_en,
      simf0_wr_mask,
      simf1_wr_mask,
      simf2_wr_mask,
      simf3_wr_mask,
      lsu_source1_addr,
      lsu_source2_addr,
      lsu_dest_addr,
      lsu_dest_data,
      lsu_dest_wr_mask,
      lsu_dest_wr_en,
      lsu_instr_done_wfid,
      lsu_instr_done,
      lsu_source1_rd_en,
      lsu_source2_rd_en,
      simd0_instr_done_wfid,
      simd1_instr_done_wfid,
      simd2_instr_done_wfid,
      simd3_instr_done_wfid,
      simd0_instr_done,
      simd1_instr_done,
      simd2_instr_done,
      simd3_instr_done,
      simf0_instr_done_wfid,
      simf1_instr_done_wfid,
      simf2_instr_done_wfid,
      simf3_instr_done_wfid,
      simf0_instr_done,
      simf1_instr_done,
      simf2_instr_done,
      simf3_instr_done,
      rfa_select_fu,
      simd_source1_data,
      simd_source2_data,
      simd_source3_data,
      simf_source1_data,
      simf_source2_data,
      simf_source3_data,
      lsu_source1_data,
      lsu_source2_data,
      issue_alu_wr_done_wfid,
      issue_alu_wr_done,
      issue_alu_dest_reg_addr,
      issue_alu_dest_reg_valid,
      issue_lsu_wr_done_wfid,
      issue_lsu_wr_done,
      issue_lsu_dest_reg_addr,
      issue_lsu_dest_reg_valid,
      clk,



      rst
 );

input clk;




input rst;

input lsu_source1_rd_en, lsu_source2_rd_en;
input simd0_source1_rd_en, simd1_source1_rd_en, simd2_source1_rd_en,
         simd3_source1_rd_en, simd0_source2_rd_en, simd1_source2_rd_en, simd2_source2_rd_en,
         simd3_source2_rd_en, simd0_source3_rd_en, simd1_source3_rd_en, simd2_source3_rd_en,
         simd3_source3_rd_en, simd0_wr_en, simd1_wr_en, simd2_wr_en, simd3_wr_en,
         simf0_source1_rd_en, simf1_source1_rd_en, simf2_source1_rd_en, simf3_source1_rd_en,
         simf0_source2_rd_en, simf1_source2_rd_en, simf2_source2_rd_en, simf3_source2_rd_en,
         simf0_source3_rd_en, simf1_source3_rd_en, simf2_source3_rd_en, simf3_source3_rd_en,
         simf0_wr_en, simf1_wr_en, simf2_wr_en, simf3_wr_en, lsu_instr_done,
         simd0_instr_done, simd1_instr_done, simd2_instr_done, simd3_instr_done,
         simf0_instr_done, simf1_instr_done, simf2_instr_done, simf3_instr_done;
input[3:0] lsu_dest_wr_en;
input[5:0] lsu_instr_done_wfid, simd0_instr_done_wfid, simd1_instr_done_wfid,
         simd2_instr_done_wfid, simd3_instr_done_wfid, simf0_instr_done_wfid,
         simf1_instr_done_wfid, simf2_instr_done_wfid, simf3_instr_done_wfid;
input[9:0] simd0_source1_addr, simd1_source1_addr, simd2_source1_addr,
         simd3_source1_addr, simd0_source2_addr, simd1_source2_addr, simd2_source2_addr,
         simd3_source2_addr, simd0_source3_addr, simd1_source3_addr, simd2_source3_addr,
         simd3_source3_addr, simd0_dest_addr, simd1_dest_addr, simd2_dest_addr,
         simd3_dest_addr, simf0_source1_addr, simf1_source1_addr, simf2_source1_addr,
         simf3_source1_addr, simf0_source2_addr, simf1_source2_addr, simf2_source2_addr,
         simf3_source2_addr, simf0_source3_addr, simf1_source3_addr, simf2_source3_addr,
         simf3_source3_addr, simf0_dest_addr, simf1_dest_addr, simf2_dest_addr,
         simf3_dest_addr, lsu_source1_addr, lsu_source2_addr, lsu_dest_addr;
input[15:0] rfa_select_fu;
input[63:0] simd0_wr_mask, simd1_wr_mask, simd2_wr_mask, simd3_wr_mask,
         simf0_wr_mask, simf1_wr_mask, simf2_wr_mask, simf3_wr_mask, lsu_dest_wr_mask;
input[2047:0] simd0_dest_data, simd1_dest_data, simd2_dest_data, simd3_dest_data,
         simf0_dest_data, simf1_dest_data, simf2_dest_data, simf3_dest_data;
// S: changed from 8k to 2k for lsu bus
input[2047:0] lsu_dest_data;
output issue_alu_wr_done, issue_alu_dest_reg_valid, issue_lsu_wr_done;
output[3:0] issue_lsu_dest_reg_valid;
output[5:0] issue_alu_wr_done_wfid, issue_lsu_wr_done_wfid;
output[9:0] issue_alu_dest_reg_addr, issue_lsu_dest_reg_addr;
output[2047:0] simd_source1_data, simd_source2_data, simd_source3_data,
         simf_source1_data, simf_source2_data, simf_source3_data,lsu_source2_data;
// S: changed from 8k to 2k for lsu bus
output[2047:0] lsu_source1_data;
///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////
wire dummy;
assign dummy = rst;

wire [9:0] muxed_simx_source1_rd_addr;
wire muxed_simx_source1_rd_en;
wire [2047:0] muxed_simx_source1_rd_data;
wire [9:0] muxed_simx_source2_rd_addr;
wire muxed_simx_source2_rd_en;
wire [2047:0] muxed_simx_source2_rd_data;
wire [9:0] muxed_simx_source3_rd_addr;
wire muxed_simx_source3_rd_en;
wire [2047:0] muxed_simx_source3_rd_data;

// simd/simf rdport 0 mux level 1
rd_port_mux_8to1 port_mux_simx_source1 (
  .port0_rd_en(simd0_source1_rd_en),
  .port0_rd_addr(simd0_source1_addr),
  .port1_rd_en(simd1_source1_rd_en),
  .port1_rd_addr(simd1_source1_addr),
  .port2_rd_en(simd2_source1_rd_en),
  .port2_rd_addr(simd2_source1_addr),
  .port3_rd_en(simd3_source1_rd_en),
  .port3_rd_addr(simd3_source1_addr),
  .port4_rd_en(simf0_source1_rd_en),
  .port4_rd_addr(simf0_source1_addr),
  .port5_rd_en(simf1_source1_rd_en),
  .port5_rd_addr(simf1_source1_addr),
  .port6_rd_en(simf2_source1_rd_en),
  .port6_rd_addr(simf2_source1_addr),
  .port7_rd_en(simf3_source1_rd_en),
  .port7_rd_addr(simf3_source1_addr),
  .rd_data(simd_source1_data),
  .muxed_port_rd_addr(muxed_simx_source1_rd_addr),
  .muxed_port_rd_data(muxed_simx_source1_rd_data),
  .muxed_port_rd_en(muxed_simx_source1_rd_en)
);
assign simf_source1_data = simd_source1_data;

// simd/simf rdport 1 mux
rd_port_mux_8to1 port_mux_simx_source2 (
  .port0_rd_en(simd0_source2_rd_en),
  .port0_rd_addr(simd0_source2_addr),
  .port1_rd_en(simd1_source2_rd_en),
  .port1_rd_addr(simd1_source2_addr),
  .port2_rd_en(simd2_source2_rd_en),
  .port2_rd_addr(simd2_source2_addr),
  .port3_rd_en(simd3_source2_rd_en),
  .port3_rd_addr(simd3_source2_addr),
  .port4_rd_en(simf0_source2_rd_en),
  .port4_rd_addr(simf0_source2_addr),
  .port5_rd_en(simf1_source2_rd_en),
  .port5_rd_addr(simf1_source2_addr),
  .port6_rd_en(simf2_source2_rd_en),
  .port6_rd_addr(simf2_source2_addr),
  .port7_rd_en(simf3_source2_rd_en),
  .port7_rd_addr(simf3_source2_addr),
  .rd_data(simd_source2_data),
  .muxed_port_rd_addr(muxed_simx_source2_rd_addr),
  .muxed_port_rd_data(muxed_simx_source2_rd_data),
  .muxed_port_rd_en(muxed_simx_source2_rd_en)
);
assign simf_source2_data = simd_source2_data;

// simd/simf rdport 2 mux
rd_port_mux_8to1 port_mux_simx_source3 (
  .port0_rd_en(simd0_source3_rd_en),
  .port0_rd_addr(simd0_source3_addr),
  .port1_rd_en(simd1_source3_rd_en),
  .port1_rd_addr(simd1_source3_addr),
  .port2_rd_en(simd2_source3_rd_en),
  .port2_rd_addr(simd2_source3_addr),
  .port3_rd_en(simd3_source3_rd_en),
  .port3_rd_addr(simd3_source3_addr),
  .port4_rd_en(simf0_source3_rd_en),
  .port4_rd_addr(simf0_source3_addr),
  .port5_rd_en(simf1_source3_rd_en),
  .port5_rd_addr(simf1_source3_addr),
  .port6_rd_en(simf2_source3_rd_en),
  .port6_rd_addr(simf2_source3_addr),
  .port7_rd_en(simf3_source3_rd_en),
  .port7_rd_addr(simf3_source3_addr),
  .rd_data(simd_source3_data),
  .muxed_port_rd_addr(muxed_simx_source3_rd_addr),
  .muxed_port_rd_data(muxed_simx_source3_rd_data),
  .muxed_port_rd_en(muxed_simx_source3_rd_en)
);
assign simf_source3_data = simd_source3_data;

wire [2047:0] distribute_source1_data;
wire [2047:0] final_source1_data;
wire [9:0] final_source1_addr;
// change mux width to 2048
// LSU changes pending
vgpr_2to1_rd_port_mux #(2048) source1_mux ( /// override the param
  .port0_rd_en(muxed_simx_source1_rd_en),
  .port0_rd_addr(muxed_simx_source1_rd_addr),
  .port1_rd_en(lsu_source1_rd_en),
  .port1_rd_addr(lsu_source1_addr),
  .port_rd_data(distribute_source1_data),
  .rd_addr(final_source1_addr),
  .rd_data(final_source1_data)
);
assign lsu_source1_data = distribute_source1_data;

// S: shrink 8k to 2k, so no need for veriperl assignment
assign muxed_simx_source1_rd_data = distribute_source1_data;

wire [2047:0] distribute_source2_data;
wire [2047:0] final_source2_data;
wire [9:0] final_source2_addr;
vgpr_2to1_rd_port_mux #(2048) source2_mux (
  .port0_rd_en(muxed_simx_source2_rd_en),
  .port0_rd_addr(muxed_simx_source2_rd_addr),
  .port1_rd_en(lsu_source2_rd_en),
  .port1_rd_addr(lsu_source2_addr),
  .port_rd_data(distribute_source2_data),
  .rd_addr(final_source2_addr),
  .rd_data(final_source2_data)
);
assign lsu_source2_data = distribute_source2_data;
assign muxed_simx_source2_rd_data = distribute_source2_data;

//////////////////////////////////
wire [3:0] muxed_simx_dest_wr_en;
wire [63:0] muxed_simx_dest_wr_mask;
wire [9:0] muxed_simx_dest_addr;

// S: shrink to 2k
wire [2047:0] muxed_simx_dest_data;

wr_port_mux_9to1 port_mux_simx_dest (
  .wr_port_select(rfa_select_fu),
  .port0_wr_en({ {3{1'b0}}, simd0_wr_en}),
  .port0_wr_mask(simd0_wr_mask),
  .port0_wr_addr(simd0_dest_addr),
  .port0_wr_data(simd0_dest_data),
  .port1_wr_en({ {3{1'b0}}, simd1_wr_en}),
  .port1_wr_mask(simd1_wr_mask),
  .port1_wr_addr(simd1_dest_addr),
  .port1_wr_data(simd1_dest_data),
  .port2_wr_en({ {3{1'b0}}, simd2_wr_en}),
  .port2_wr_mask(simd2_wr_mask),
  .port2_wr_addr(simd2_dest_addr),
  .port2_wr_data(simd2_dest_data),
  .port3_wr_en({ {3{1'b0}}, simd3_wr_en}),
  .port3_wr_mask(simd3_wr_mask),
  .port3_wr_addr(simd3_dest_addr),
  .port3_wr_data(simd3_dest_data),
  .port4_wr_en({ {3{1'b0}}, simf0_wr_en}),
  .port4_wr_mask(simf0_wr_mask),
  .port4_wr_addr(simf0_dest_addr),
  .port4_wr_data(simf0_dest_data),
  .port5_wr_en({ {3{1'b0}}, simf1_wr_en}),
  .port5_wr_mask(simf1_wr_mask),
  .port5_wr_addr(simf1_dest_addr),
  .port5_wr_data(simf1_dest_data),
  .port6_wr_en({ {3{1'b0}}, simf2_wr_en}),
  .port6_wr_mask(simf2_wr_mask),
  .port6_wr_addr(simf2_dest_addr),
  .port6_wr_data(simf2_dest_data),
  .port7_wr_en({ {3{1'b0}}, simf3_wr_en}),
  .port7_wr_mask(simf3_wr_mask),
  .port7_wr_addr(simf3_dest_addr),
  .port7_wr_data(simf3_dest_data),
  .port8_wr_en(lsu_dest_wr_en),
  .port8_wr_mask(lsu_dest_wr_mask),
  .port8_wr_addr(lsu_dest_addr),
  .port8_wr_data(lsu_dest_data),
  .muxed_port_wr_en(muxed_simx_dest_wr_en),
  .muxed_port_wr_mask(muxed_simx_dest_wr_mask),
  .muxed_port_wr_addr(muxed_simx_dest_addr),
  .muxed_port_wr_data(muxed_simx_dest_data)
);

assign issue_alu_dest_reg_addr = muxed_simx_dest_addr;
assign issue_alu_dest_reg_valid = (|muxed_simx_dest_wr_en) & (~|lsu_dest_wr_en);





reg_64page_1024x32b_3r_1w reg_file (

  .rd0_addr(final_source1_addr),
  .rd0_data(final_source1_data),
  .rd1_addr(final_source2_addr),
  .rd1_data(final_source2_data),
  .rd2_addr(muxed_simx_source3_rd_addr),
  .rd2_data(muxed_simx_source3_rd_data),
  .wr0_en(muxed_simx_dest_wr_mask),
  .wr0_en_xoutof4(muxed_simx_dest_wr_en),
  .wr0_addr(muxed_simx_dest_addr),
  .wr0_data(muxed_simx_dest_data),
  .clk(clk)
);

// wfid_mux was hacked to output valid data in case
// rfa selects lsu.
wfid_mux_8to1 wfid_mux (
  .wr_port_select(rfa_select_fu),
  .wfid_done_0(simd0_instr_done),
  .wfid_0(simd0_instr_done_wfid),
  .wfid_done_1(simd1_instr_done),
  .wfid_1(simd1_instr_done_wfid),
  .wfid_done_2(simd2_instr_done),
  .wfid_2(simd2_instr_done_wfid),
  .wfid_done_3(simd3_instr_done),
  .wfid_3(simd3_instr_done_wfid),
  .wfid_done_4(simf0_instr_done),
  .wfid_4(simf0_instr_done_wfid),
  .wfid_done_5(simf1_instr_done),
  .wfid_5(simf1_instr_done_wfid),
  .wfid_done_6(simf2_instr_done),
  .wfid_6(simf2_instr_done_wfid),
  .wfid_done_7(simf3_instr_done),
  .wfid_7(simf3_instr_done_wfid),
  .muxed_wfid(issue_alu_wr_done_wfid),
  .muxed_wfid_done(issue_alu_wr_done)
);

assign issue_lsu_wr_done_wfid = lsu_instr_done_wfid;
assign issue_lsu_wr_done = lsu_instr_done;
assign issue_lsu_dest_reg_addr = lsu_dest_addr;
assign issue_lsu_dest_reg_valid = lsu_dest_wr_en;

///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////
endmodule
module vgpr_2to1_rd_port_mux (
  port0_rd_en,
  port0_rd_addr,

  port1_rd_en,
  port1_rd_addr,

  port_rd_data,

  rd_addr,
  rd_data
);
// S: changed to 2k (parameter passed)
  parameter DATAWIDTH = 2048;

  input         port0_rd_en;
  input [9:0]   port0_rd_addr;

  input         port1_rd_en;
  input [9:0]   port1_rd_addr;

  input [DATAWIDTH-1:0] rd_data;
  output [DATAWIDTH-1:0] port_rd_data;
  output [9:0]  rd_addr;

  reg [9:0]     rd_addr;

  assign port_rd_data = rd_data;

  always @ (
    port0_rd_en or
    port1_rd_en or
    port0_rd_addr or
    port1_rd_addr
  ) begin
      casex({port1_rd_en,port0_rd_en})
        2'b01:
          begin
            rd_addr <= port0_rd_addr;
          end
        2'b10:
          begin
            rd_addr <= port1_rd_addr;
          end
        default:
          begin
            rd_addr <= {10{1'bx}};
          end
      endcase
    end

endmodule
module wfid_mux_8to1 (
  wr_port_select,

  wfid_done_0,
  wfid_0,
  wfid_done_1,
  wfid_1,
  wfid_done_2,
  wfid_2,
  wfid_done_3,
  wfid_3,
  wfid_done_4,
  wfid_4,
  wfid_done_5,
  wfid_5,
  wfid_done_6,
  wfid_6,
  wfid_done_7,
  wfid_7,
  muxed_wfid,
  muxed_wfid_done
);

  output [5:0] muxed_wfid;
  output muxed_wfid_done;

  input [15:0] wr_port_select;

  input wfid_done_0;
  input [5:0] wfid_0;
  input wfid_done_1;
  input [5:0] wfid_1;
  input wfid_done_2;
  input [5:0] wfid_2;
  input wfid_done_3;
  input [5:0] wfid_3;
  input wfid_done_4;
  input [5:0] wfid_4;
  input wfid_done_5;
  input [5:0] wfid_5;
  input wfid_done_6;
  input [5:0] wfid_6;
  input wfid_done_7;
  input [5:0] wfid_7;

  reg [5:0] muxed_wfid;
  reg muxed_wfid_done;

  always @ (
    wr_port_select or
    wfid_done_0 or
    wfid_0 or
    wfid_done_1 or
    wfid_1 or
    wfid_done_2 or
    wfid_2 or
    wfid_done_3 or
    wfid_3 or
    wfid_done_4 or
    wfid_4 or
    wfid_done_5 or
    wfid_5 or
    wfid_done_6 or
    wfid_6 or
    wfid_done_7 or
    wfid_7
  ) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_wfid_done <= wfid_done_0;
          muxed_wfid <= wfid_0;
        end
      16'h0002:
        begin
          muxed_wfid_done <= wfid_done_1;
          muxed_wfid <= wfid_1;
        end
      16'h0004:
        begin
          muxed_wfid_done <= wfid_done_2;
          muxed_wfid <= wfid_2;
        end
      16'h0008:
        begin
          muxed_wfid_done <= wfid_done_3;
          muxed_wfid <= wfid_3;
        end
      16'h0010:
        begin
          muxed_wfid_done <= wfid_done_4;
          muxed_wfid <= wfid_4;
        end
      16'h0020:
        begin
          muxed_wfid_done <= wfid_done_5;
          muxed_wfid <= wfid_5;
        end
      16'h0040:
        begin
          muxed_wfid_done <= wfid_done_6;
          muxed_wfid <= wfid_6;
        end
      16'h0080:
        begin
          muxed_wfid_done <= wfid_done_7;
          muxed_wfid <= wfid_7;
        end
      16'h0100:
        begin
          muxed_wfid_done <= 1'b0;
          muxed_wfid <= {6{1'bx}};
        end
      16'h0000:
        begin
          muxed_wfid_done <= 1'b0;
          muxed_wfid <= {6{1'bx}};
        end
      default:
        begin
          muxed_wfid_done <= 1'bx;
          muxed_wfid <= {6{1'bx}};
        end
    endcase
  end

endmodule
module wfid_mux_9to1 (
  wr_port_select,

  wfid_done_0,
  wfid_0,
  wfid_done_1,
  wfid_1,
  wfid_done_2,
  wfid_2,
  wfid_done_3,
  wfid_3,
  wfid_done_4,
  wfid_4,
  wfid_done_5,
  wfid_5,
  wfid_done_6,
  wfid_6,
  wfid_done_7,
  wfid_7,
  muxed_wfid,
  muxed_wfid_done
);

  output [5:0] muxed_wfid;
  output muxed_wfid_done;

  input [15:0] wr_port_select;

  input wfid_done_0;
  input [5:0] wfid_0;
  input wfid_done_1;
  input [5:0] wfid_1;
  input wfid_done_2;
  input [5:0] wfid_2;
  input wfid_done_3;
  input [5:0] wfid_3;
  input wfid_done_4;
  input [5:0] wfid_4;
  input wfid_done_5;
  input [5:0] wfid_5;
  input wfid_done_6;
  input [5:0] wfid_6;
  input wfid_done_7;
  input [5:0] wfid_7;

  reg [5:0] muxed_wfid;
  reg muxed_wfid_done;

  always @ (
    wr_port_select or
    wfid_done_0 or
    wfid_0 or
    wfid_done_1 or
    wfid_1 or
    wfid_done_2 or
    wfid_2 or
    wfid_done_3 or
    wfid_3 or
    wfid_done_4 or
    wfid_4 or
    wfid_done_5 or
    wfid_5 or
    wfid_done_6 or
    wfid_6 or
    wfid_done_7 or
    wfid_7
  ) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_wfid_done <= wfid_done_0;
          muxed_wfid <= wfid_0;
        end
      16'h0002:
        begin
          muxed_wfid_done <= wfid_done_1;
          muxed_wfid <= wfid_1;
        end
      16'h0004:
        begin
          muxed_wfid_done <= wfid_done_2;
          muxed_wfid <= wfid_2;
        end
      16'h0008:
        begin
          muxed_wfid_done <= wfid_done_3;
          muxed_wfid <= wfid_3;
        end
      16'h0010:
        begin
          muxed_wfid_done <= wfid_done_4;
          muxed_wfid <= wfid_4;
        end
      16'h0020:
        begin
          muxed_wfid_done <= wfid_done_5;
          muxed_wfid <= wfid_5;
        end
      16'h0040:
        begin
          muxed_wfid_done <= wfid_done_6;
          muxed_wfid <= wfid_6;
        end
      16'h0080:
        begin
          muxed_wfid_done <= wfid_done_7;
          muxed_wfid <= wfid_7;
        end
      16'h0000:
        begin
          muxed_wfid_done <= 1'b0;
          muxed_wfid <= {6{1'bx}};
        end
      default:
        begin
          muxed_wfid_done <= 1'bx;
          muxed_wfid <= {6{1'bx}};
        end
    endcase
  end

endmodule
module wr_port_mux_8to1 (
  wr_port_select,

  port0_wr_en,
  port0_wr_mask,
  port0_wr_addr,
  port0_wr_data,

  port1_wr_en,
  port1_wr_mask,
  port1_wr_addr,
  port1_wr_data,

  port2_wr_en,
  port2_wr_mask,
  port2_wr_addr,
  port2_wr_data,

  port3_wr_en,
  port3_wr_mask,
  port3_wr_addr,
  port3_wr_data,

  port4_wr_en,
  port4_wr_mask,
  port4_wr_addr,
  port4_wr_data,

  port5_wr_en,
  port5_wr_mask,
  port5_wr_addr,
  port5_wr_data,

  port6_wr_en,
  port6_wr_mask,
  port6_wr_addr,
  port6_wr_data,

  port7_wr_en,
  port7_wr_mask,
  port7_wr_addr,
  port7_wr_data,

  muxed_port_wr_en,
  muxed_port_wr_mask,
  muxed_port_wr_addr,
  muxed_port_wr_data
);

  output muxed_port_wr_en;
  output [63:0] muxed_port_wr_mask;
  output [9:0] muxed_port_wr_addr;
  output [2047:0] muxed_port_wr_data;

  input [15:0] wr_port_select;

  input port0_wr_en;
  input [63:0] port0_wr_mask;
  input [9:0] port0_wr_addr;
  input [2047:0] port0_wr_data;

  input port1_wr_en;
  input [63:0] port1_wr_mask;
  input [9:0] port1_wr_addr;
  input [2047:0] port1_wr_data;

  input port2_wr_en;
  input [63:0] port2_wr_mask;
  input [9:0] port2_wr_addr;
  input [2047:0] port2_wr_data;

  input port3_wr_en;
  input [63:0] port3_wr_mask;
  input [9:0] port3_wr_addr;
  input [2047:0] port3_wr_data;

  input port4_wr_en;
  input [63:0] port4_wr_mask;
  input [9:0] port4_wr_addr;
  input [2047:0] port4_wr_data;

  input port5_wr_en;
  input [63:0] port5_wr_mask;
  input [9:0] port5_wr_addr;
  input [2047:0] port5_wr_data;

  input port6_wr_en;
  input [63:0] port6_wr_mask;
  input [9:0] port6_wr_addr;
  input [2047:0] port6_wr_data;

  input port7_wr_en;
  input [63:0] port7_wr_mask;
  input [9:0] port7_wr_addr;
  input [2047:0] port7_wr_data;

  reg muxed_port_wr_en;
  reg [63:0] muxed_port_wr_mask;
  reg [9:0] muxed_port_wr_addr;
  reg [2047:0] muxed_port_wr_data;

  always @ (
    wr_port_select or
    port0_wr_en or
    port0_wr_mask or
    port0_wr_addr or
    port0_wr_data or
    port1_wr_en or
    port1_wr_mask or
    port1_wr_addr or
    port1_wr_data or
    port2_wr_en or
    port2_wr_mask or
    port2_wr_addr or
    port2_wr_data or
    port3_wr_en or
    port3_wr_mask or
    port3_wr_addr or
    port3_wr_data or
    port4_wr_en or
    port4_wr_mask or
    port4_wr_addr or
    port4_wr_data or
    port5_wr_en or
    port5_wr_mask or
    port5_wr_addr or
    port5_wr_data or
    port6_wr_en or
    port6_wr_mask or
    port6_wr_addr or
    port6_wr_data or
    port7_wr_en or
    port7_wr_mask or
    port7_wr_addr or
    port7_wr_data
  ) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_port_wr_en <= port0_wr_en;
          muxed_port_wr_mask <= port0_wr_mask & {64{port0_wr_en}};
          muxed_port_wr_addr <= port0_wr_addr;
          muxed_port_wr_data <= port0_wr_data;
        end
      16'h0002:
        begin
          muxed_port_wr_en <= port1_wr_en;
          muxed_port_wr_mask <= port1_wr_mask & {64{port1_wr_en}};
          muxed_port_wr_addr <= port1_wr_addr;
          muxed_port_wr_data <= port1_wr_data;
        end
      16'h0004:
        begin
          muxed_port_wr_en <= port2_wr_en;
          muxed_port_wr_mask <= port2_wr_mask & {64{port2_wr_en}};
          muxed_port_wr_addr <= port2_wr_addr;
          muxed_port_wr_data <= port2_wr_data;
        end
      16'h0008:
        begin
          muxed_port_wr_en <= port3_wr_en;
          muxed_port_wr_mask <= port3_wr_mask & {64{port3_wr_en}};
          muxed_port_wr_addr <= port3_wr_addr;
          muxed_port_wr_data <= port3_wr_data;
        end
      16'h0010:
        begin
          muxed_port_wr_en <= port4_wr_en;
          muxed_port_wr_mask <= port4_wr_mask & {64{port4_wr_en}};
          muxed_port_wr_addr <= port4_wr_addr;
          muxed_port_wr_data <= port4_wr_data;
        end
      16'h0020:
        begin
          muxed_port_wr_en <= port5_wr_en;
          muxed_port_wr_mask <= port5_wr_mask & {64{port5_wr_en}};
          muxed_port_wr_addr <= port5_wr_addr;
          muxed_port_wr_data <= port5_wr_data;
        end
      16'h0040:
        begin
          muxed_port_wr_en <= port6_wr_en;
          muxed_port_wr_mask <= port6_wr_mask & {64{port6_wr_en}};
          muxed_port_wr_addr <= port6_wr_addr;
          muxed_port_wr_data <= port6_wr_data;
        end
      16'h0080:
        begin
          muxed_port_wr_en <= port7_wr_en;
          muxed_port_wr_mask <= port7_wr_mask & {64{port7_wr_en}};
          muxed_port_wr_addr <= port7_wr_addr;
          muxed_port_wr_data <= port7_wr_data;
        end
      16'b0000:
        begin
          muxed_port_wr_en <= 1'b0;
          muxed_port_wr_mask <= 64'b0;
          muxed_port_wr_addr <= {10{1'bx}};
          muxed_port_wr_data <= {2048{1'bx}};
        end
      default:
        begin
          muxed_port_wr_en <= 1'bx;
          muxed_port_wr_mask <= {64{1'bx}};
          muxed_port_wr_addr <= {10{1'bx}};
          muxed_port_wr_data <= {2048{1'bx}};
        end
    endcase
  end

endmodule
module wr_port_mux_9to1 
  (/*AUTOARG*/
   // Outputs
   muxed_port_wr_en, muxed_port_wr_mask, muxed_port_wr_addr,
   muxed_port_wr_data,
   // Inputs
   wr_port_select, port0_wr_en, port0_wr_mask, port0_wr_addr,
   port0_wr_data, port1_wr_en, port1_wr_mask, port1_wr_addr,
   port1_wr_data, port2_wr_en, port2_wr_mask, port2_wr_addr,
   port2_wr_data, port3_wr_en, port3_wr_mask, port3_wr_addr,
   port3_wr_data, port4_wr_en, port4_wr_mask, port4_wr_addr,
   port4_wr_data, port5_wr_en, port5_wr_mask, port5_wr_addr,
   port5_wr_data, port6_wr_en, port6_wr_mask, port6_wr_addr,
   port6_wr_data, port7_wr_en, port7_wr_mask, port7_wr_addr,
   port7_wr_data, port8_wr_en, port8_wr_mask, port8_wr_addr,
   port8_wr_data
   );

  output[3:0] muxed_port_wr_en;
  output [63:0] muxed_port_wr_mask;
  output [9:0] muxed_port_wr_addr;

  // change output port width
  output [2047:0] muxed_port_wr_data;

  input [15:0] wr_port_select;

  input[3:0] port0_wr_en;
  input [63:0] port0_wr_mask;
  input [9:0] port0_wr_addr;
  input [2047:0] port0_wr_data;

  input[3:0] port1_wr_en;
  input [63:0] port1_wr_mask;
  input [9:0] port1_wr_addr;
  input [2047:0] port1_wr_data;

  input[3:0] port2_wr_en;
  input [63:0] port2_wr_mask;
  input [9:0] port2_wr_addr;
  input [2047:0] port2_wr_data;

  input[3:0] port3_wr_en;
  input [63:0] port3_wr_mask;
  input [9:0] port3_wr_addr;
  input [2047:0] port3_wr_data;

  input[3:0] port4_wr_en;
  input [63:0] port4_wr_mask;
  input [9:0] port4_wr_addr;
  input [2047:0] port4_wr_data;

  input[3:0] port5_wr_en;
  input [63:0] port5_wr_mask;
  input [9:0] port5_wr_addr;
  input [2047:0] port5_wr_data;

  input[3:0] port6_wr_en;
  input [63:0] port6_wr_mask;
  input [9:0] port6_wr_addr;
  input [2047:0] port6_wr_data;

  input[3:0] port7_wr_en;
  input [63:0] port7_wr_mask;
  input [9:0] port7_wr_addr;
  input [2047:0] port7_wr_data;

  input[3:0] port8_wr_en;
  input [63:0] port8_wr_mask;
  input [9:0] port8_wr_addr;

  // S: change output width
  input [2047:0] port8_wr_data;
  /* 
  wire [2047:0] port0_wr_data_i, port1_wr_data_i, port2_wr_data_i,
		port3_wr_data_i, port4_wr_data_i, port5_wr_data_i,
		port6_wr_data_i, port7_wr_data_i;
   
   assign port0_wr_data_i =
   */
   /*
   genvar 	i;
   generate
      for (i = 0; i<64; i=i+1) begin
	 assign port0_wr_data_i[i*32+:32] = {port0_wr_data[i*32+:32]};
	 assign port1_wr_data_i[i*32+:32] = {port1_wr_data[i*32+:32]};
	 assign port2_wr_data_i[i*32+:32] = {port2_wr_data[i*32+:32]};
	 assign port3_wr_data_i[i*32+:32] = {port3_wr_data[i*32+:32]};
	 assign port4_wr_data_i[i*128+:128] = {port4_wr_data[i*32+:32]};
	 assign port5_wr_data_i[i*128+:128] = {port5_wr_data[i*32+:32]};
	 assign port6_wr_data_i[i*128+:128] = {port6_wr_data[i*32+:32]};
	 assign port7_wr_data_i[i*128+:128] = {port7_wr_data[i*32+:32]};
      end
      
   endgenerate
   */

  reg [3:0] muxed_port_wr_en;
  reg [63:0] muxed_port_wr_mask;
  reg [9:0] muxed_port_wr_addr;
  reg [2047:0] muxed_port_wr_data;

  always @ (*) begin
    casex(wr_port_select)
      16'h0001:
        begin
          muxed_port_wr_en <= port0_wr_en;
          muxed_port_wr_mask <= port0_wr_mask;
          muxed_port_wr_addr <= port0_wr_addr;
          muxed_port_wr_data <= port0_wr_data;
        end
      16'h0002:
        begin
          muxed_port_wr_en <= port1_wr_en;
          muxed_port_wr_mask <= port1_wr_mask;
          muxed_port_wr_addr <= port1_wr_addr;
          muxed_port_wr_data <= port1_wr_data;
        end
      16'h0004:
        begin
          muxed_port_wr_en <= port2_wr_en;
          muxed_port_wr_mask <= port2_wr_mask;
          muxed_port_wr_addr <= port2_wr_addr;
          muxed_port_wr_data <= port2_wr_data;
        end
      16'h0008:
        begin
          muxed_port_wr_en <= port3_wr_en;
          muxed_port_wr_mask <= port3_wr_mask;
          muxed_port_wr_addr <= port3_wr_addr;
          muxed_port_wr_data <= port3_wr_data;
        end
      16'h0010:
        begin
          muxed_port_wr_en <= port4_wr_en;
          muxed_port_wr_mask <= port4_wr_mask;
          muxed_port_wr_addr <= port4_wr_addr;
          muxed_port_wr_data <= port4_wr_data;
        end
      16'h0020:
        begin
          muxed_port_wr_en <= port5_wr_en;
          muxed_port_wr_mask <= port5_wr_mask;
          muxed_port_wr_addr <= port5_wr_addr;
          muxed_port_wr_data <= port5_wr_data;
        end
      16'h0040:
        begin
          muxed_port_wr_en <= port6_wr_en;
          muxed_port_wr_mask <= port6_wr_mask;
          muxed_port_wr_addr <= port6_wr_addr;
          muxed_port_wr_data <= port6_wr_data;
        end
      16'h0080:
        begin
          muxed_port_wr_en <= port7_wr_en;
          muxed_port_wr_mask <= port7_wr_mask;
          muxed_port_wr_addr <= port7_wr_addr;
          muxed_port_wr_data <= port7_wr_data;
        end
      16'h0100:
        begin
          muxed_port_wr_en <= port8_wr_en;
          muxed_port_wr_mask <= port8_wr_mask;
          muxed_port_wr_addr <= port8_wr_addr;
          muxed_port_wr_data <= port8_wr_data;
        end
      16'b0000:
        begin
          muxed_port_wr_en <= 4'd0;
          muxed_port_wr_mask <= 64'b0;
          muxed_port_wr_addr <= {10{1'bx}};
          // S: change from 8k to 2k
          muxed_port_wr_data <= {2048{1'bx}};
        end
      default:
        begin
          muxed_port_wr_en <= 4'd0;
          muxed_port_wr_mask <= {64{1'b0}};
          muxed_port_wr_addr <= {10{1'bx}};
          // S: change from 8k to 2k
          muxed_port_wr_data <= {2048{1'bx}};
        end
    endcase
  end

endmodule
module PS_flops_fetch_wavepool (
 buff_tag,
 buff_instr,
 buff_ack,
 flopped_buff_wfid,
 flopped_buff_instr_pc,
 flopped_buff_first,
 flopped_buff_ack,
 clk,
 rst
);

input [38:0] buff_tag;
input [31:0] buff_instr;
input buff_ack;
output [5:0] flopped_buff_wfid;
output [63:0] flopped_buff_instr_pc;
output flopped_buff_first;
output flopped_buff_ack;
input clk;
input rst;

dff flop_wfid[5:0] (.q(flopped_buff_wfid), .d(buff_tag[37:32]), .clk(clk), .rst(rst));
dff flop_instr_pc[63:0] (.q(flopped_buff_instr_pc), .d({buff_instr,buff_tag[31:0]}), .clk(clk), .rst(rst));
dff flop_first (.q(flopped_buff_first), .d(buff_tag[38]), .clk(clk), .rst(rst));
dff flop_ack (.q(flopped_buff_ack), .d(buff_ack), .clk(clk), .rst(rst));

endmodule
module adder3bit (
	sum,
	cout,
	in1,
	in2
);

output[2:0] sum;
output cout;

input[2:0] in1, in2;

wire cout0, cout1;

adder1bit add0(sum[0], cout0, in1[0], in2[0], 1'b0);
adder1bit add1(sum[1], cout1, in1[1], in2[1], cout0);
adder1bit add2(sum[2], cout, in1[2], in2[2], cout1);

endmodule
module decoder_3_to_8 (out,in);
  output [7:0] out;
  input [2:0] in;
// %%start_veriperl
// my $i;
// for($i=0; $i<8; $i=$i+1)
// {
//   print "  assign out[$i] = (in == 3'd$i) ? 1'b1 : 1'b0;\n";
// }
// %%stop_veriperl
  assign out[0] = (in == 3'd0) ? 1'b1 : 1'b0;
  assign out[1] = (in == 3'd1) ? 1'b1 : 1'b0;
  assign out[2] = (in == 3'd2) ? 1'b1 : 1'b0;
  assign out[3] = (in == 3'd3) ? 1'b1 : 1'b0;
  assign out[4] = (in == 3'd4) ? 1'b1 : 1'b0;
  assign out[5] = (in == 3'd5) ? 1'b1 : 1'b0;
  assign out[6] = (in == 3'd6) ? 1'b1 : 1'b0;
  assign out[7] = (in == 3'd7) ? 1'b1 : 1'b0;
endmodule
module mux_40x35b_to_1x35b (out, in, select);

  output [34:0] out;
  input [1399:0] in;
  input [5:0] select;

  reg [34:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<40; $i=$i+1)
// {
//   $low_index = 35*$i;
//   $high_index = 35*$i+34;
//   print "      6'd$i : out <= in [$high_index:$low_index];\n";
// }
// %%stop_veriperl
      6'd0 : out <= in [34:0];
      6'd1 : out <= in [69:35];
      6'd2 : out <= in [104:70];
      6'd3 : out <= in [139:105];
      6'd4 : out <= in [174:140];
      6'd5 : out <= in [209:175];
      6'd6 : out <= in [244:210];
      6'd7 : out <= in [279:245];
      6'd8 : out <= in [314:280];
      6'd9 : out <= in [349:315];
      6'd10 : out <= in [384:350];
      6'd11 : out <= in [419:385];
      6'd12 : out <= in [454:420];
      6'd13 : out <= in [489:455];
      6'd14 : out <= in [524:490];
      6'd15 : out <= in [559:525];
      6'd16 : out <= in [594:560];
      6'd17 : out <= in [629:595];
      6'd18 : out <= in [664:630];
      6'd19 : out <= in [699:665];
      6'd20 : out <= in [734:700];
      6'd21 : out <= in [769:735];
      6'd22 : out <= in [804:770];
      6'd23 : out <= in [839:805];
      6'd24 : out <= in [874:840];
      6'd25 : out <= in [909:875];
      6'd26 : out <= in [944:910];
      6'd27 : out <= in [979:945];
      6'd28 : out <= in [1014:980];
      6'd29 : out <= in [1049:1015];
      6'd30 : out <= in [1084:1050];
      6'd31 : out <= in [1119:1085];
      6'd32 : out <= in [1154:1120];
      6'd33 : out <= in [1189:1155];
      6'd34 : out <= in [1224:1190];
      6'd35 : out <= in [1259:1225];
      6'd36 : out <= in [1294:1260];
      6'd37 : out <= in [1329:1295];
      6'd38 : out <= in [1364:1330];
      6'd39 : out <= in [1399:1365];
      default: out <= 32'hxxxxxxxx;
    endcase
  end
endmodule
module mux_8x64b_to_1x64b (out, in, select);

  output [63:0] out;
  input [511:0] in;
  input [2:0] select;

  reg [63:0] out;

  always @ (in or select) begin
    casex(select)
// %%start_veriperl
// my $i;
// my $low_index;
// my $high_index;
// for($i=0; $i<8; $i=$i+1)
// {
//   $low_index = 64*$i;
//   $high_index = 64*$i+63;
//   print "      3'd$i : out <= in [$high_index:$low_index];\n";
// }
// %%stop_veriperl
      3'd0 : out <= in [63:0];
      3'd1 : out <= in [127:64];
      3'd2 : out <= in [191:128];
      3'd3 : out <= in [255:192];
      3'd4 : out <= in [319:256];
      3'd5 : out <= in [383:320];
      3'd6 : out <= in [447:384];
      3'd7 : out <= in [511:448];
      default: out <= {64{1'bx}};
    endcase
  end
endmodule
module queue_controller (
  q_vtail_incr,
  q_rd,
  q_wr,
  q_reset,
  q_empty,
  stop_fetch,
  buff_rd_addr,
  buff_wr_addr,
  buff_wr_en,
  clk,
  rst
);

input q_vtail_incr;
input q_rd;
input q_wr;
input q_reset;

output q_empty;
output stop_fetch;
output [2:0] buff_rd_addr;
output [2:0] buff_wr_addr;
output buff_wr_en;
input clk;
input rst;

wire [2:0] vtail;
wire [2:0] tail;
wire [2:0] head;

wire [2:0] next_vtail;
wire [2:0] next_tail;
wire [2:0] next_head;
wire [2:0] next_vtail_qualified;
wire [2:0] next_tail_qualified;
wire [2:0] next_head_qualified;

wire [2:0] vtail_plus2;

assign next_vtail_qualified = next_vtail & ~{3{q_reset}};
assign next_tail_qualified = next_tail & ~{3{q_reset}};
assign next_head_qualified = next_head & ~{3{q_reset}};

reg_3b Vtail(.out(vtail), .in(next_vtail_qualified), .wr_en(q_vtail_incr|q_reset), .clk(clk), .rst(rst));
reg_3b Tail(.out(tail), .in(next_tail_qualified), .wr_en(q_wr|q_reset), .clk(clk), .rst(rst));
reg_3b Head(.out(head), .in(next_head_qualified), .wr_en(q_rd|q_reset), .clk(clk), .rst(rst));

adder3bit Vtail_Incr(.sum(next_vtail), .cout(), .in1(vtail), .in2(3'b1));
adder3bit Tail_Incr(.sum(next_tail), .cout(), .in1(tail), .in2(3'b1));
adder3bit Head_Incr(.sum(next_head), .cout(), .in1(head), .in2(3'b1));

adder3bit Vtail_Plus2(.sum(vtail_plus2), .cout(), .in1(vtail), .in2(3'd2));

assign q_empty = (head == tail);
assign stop_fetch = (head == next_vtail) | (head == vtail_plus2);

assign buff_rd_addr = head;
assign buff_wr_addr = tail;
assign buff_wr_en = q_wr;

endmodule
module reg_35b (out, in, wr_en, clk, rst);

  output [34:0] out;
  input [34:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[34:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module reg_3b (out, in, wr_en, clk, rst);

  output [2:0] out;
  input [2:0] in;
  input wr_en;
  input clk;
  input rst;

  dff_en bits[2:0] (.q(out), .d(in), .en(wr_en), .clk(clk), .rst(rst));

endmodule
module reg_40x35b_1r_1w (
  rd_addr,
  rd_data,

  wr_en,
  wr_addr,
  wr_data,

  clk,
  rst
);

  output [34:0] rd_data;
  input [5:0] rd_addr;

  input [5:0] wr_addr;
  input wr_en;
  input [34:0] wr_data;

  input clk;
  input rst;

  wire [1399:0] word_out;
  wire [39:0] wr_word_select;
  wire [39:0] wr_en_word;

  mux_40x35b_to_1x35b mux_rd_port (.out(rd_data), .in(word_out), .select(rd_addr));
  decoder_6_to_40 decoder_wr_port (.out(wr_word_select), .in(wr_addr));
  assign wr_en_word = {40{wr_en}} & wr_word_select;

  reg_35b word[39:0](.out(word_out), .in(wr_data), .wr_en(wr_en_word), .clk(clk), .rst(rst));

endmodule
module reg_8x64b_1r_1w (
  rd_addr,
  rd_data,

  wr_en,
  wr_addr,
  wr_data,

  clk,
  rst
);

  output [63:0] rd_data;
  input [2:0] rd_addr;

  input [2:0] wr_addr;
  input wr_en;
  input [63:0] wr_data;

  input clk;
  input rst;

  wire [511:0] word_out;
  wire [7:0] wr_word_select;
  wire [7:0] wr_en_word;

  mux_8x64b_to_1x64b mux_rd_port (.out(rd_data), .in(word_out), .select(rd_addr));
  decoder_3_to_8 decoder_wr_port (.out(wr_word_select), .in(wr_addr));
  assign wr_en_word = {8{wr_en}} & wr_word_select;

  reg_64b word[7:0] (.out(word_out), .in(wr_data), .wr_en(wr_en_word), .clk(clk), .rst(rst));

endmodule
module scbd_feeder(
  valid_wf,
  ins_half_reqd,
  ins_half_wfid,
  issue_vacant,
  q_empty,
  q_reset,
  feed_valid,
  feed_wfid,
  clk,
  rst
);

input [39:0] valid_wf;

input ins_half_reqd;
input [5:0] ins_half_wfid;
input [39:0] issue_vacant;
input [39:0] q_empty;
input [39:0] q_reset;

output feed_valid;
output [5:0] feed_wfid;


input clk;
input rst;

wire [39:0] ins_half_reqd_bitwise;
wire [39:0] selected_instr_bitwise;
wire [39:0] hungry;
wire [39:0] next_hungry;
wire [39:0] sb_candidates;

decoder_6_to_40 ins_half_dec(.out(ins_half_reqd_bitwise), .in(ins_half_wfid));

assign next_hungry = (issue_vacant | (ins_half_reqd_bitwise & {40{ins_half_reqd}}) | q_reset | hungry) & (~ ({40{feed_valid}} & selected_instr_bitwise));

reg_40b_set scbd_hungry(.out(hungry), .in(next_hungry), .wr_en(1'b1), .clk(clk), .set(rst));

assign sb_candidates = hungry & (~ q_empty) & valid_wf;

priority_encoder_40to6 select_enc(.binary_out(feed_wfid), .valid(feed_valid), .encoder_in(sb_candidates), .enable(1'b1));

decoder_6_to_40 update_dec(.out(selected_instr_bitwise), .in(feed_wfid));

endmodule
module wave_queue (
  q_vtail_incr,
  q_rd,
  q_wr,
  q_reset,
  q_empty,
  stop_fetch,
  instr_pc_in,
  instr_pc_out,
  clk,
  rst
);

input q_vtail_incr;
input q_rd;
input q_wr;
input q_reset;

output q_empty;
output stop_fetch;

input [63:0] instr_pc_in;
output [63:0] instr_pc_out;

input clk;
input rst;

wire [2:0] buff_rd_addr;
wire [2:0] buff_wr_addr;
wire  buff_wr_en;

queue_controller q_cntrl (
  .q_vtail_incr(q_vtail_incr),
  .q_rd(q_rd),
  .q_wr(q_wr),
  .q_reset(q_reset),
  .q_empty(q_empty),
  .stop_fetch(stop_fetch),
  .buff_rd_addr(buff_rd_addr),
  .buff_wr_addr(buff_wr_addr),
  .buff_wr_en(buff_wr_en),
  .clk(clk),
  .rst(rst)
);

reg_8x64b_1r_1w q_buff(
  .rd_addr(buff_rd_addr),
  .rd_data(instr_pc_out),
  .wr_en(buff_wr_en),
  .wr_addr(buff_wr_addr),
  .wr_data(instr_pc_in),
  .clk(clk),
  .rst(rst)
);

endmodule  
module wavepool( 
      fetch_reserve_slotid,
      fetch_reserve_valid,
      fetch_basereg_wr,
      fetch_basereg_wfid,
      fetch_vgpr_base,
      fetch_sgpr_base,
      fetch_lds_base,
      issue_valid_entries,
      buff_tag,
      buff_instr,
      buff2fetchwave_ack,
      issue_wf_done_en,
      issue_wf_done_wf_id,
      salu_branch_wfid,
      salu_branch_en,
      salu_branch_taken,
      decode_ins_half_rqd,
      decode_ins_half_wfid,
      fetch_stop_fetch,
      decode_instr_valid,
      decode_instr,
      decode_wfid,
      decode_vgpr_base,
      decode_sgpr_base,
      decode_lds_base,
      decode_instr_pc,
      clk,
      rst
 );

input clk;

input rst;

input fetch_reserve_valid, fetch_basereg_wr, buff2fetchwave_ack, issue_wf_done_en,
         salu_branch_en, salu_branch_taken, decode_ins_half_rqd;
input[5:0] fetch_reserve_slotid, fetch_basereg_wfid, issue_wf_done_wf_id,
         salu_branch_wfid, decode_ins_half_wfid;
input[8:0] fetch_sgpr_base;
input[9:0] fetch_vgpr_base;
input[15:0] fetch_lds_base;
input[31:0] buff_instr;
input[38:0] buff_tag;
input[39:0] issue_valid_entries;

output decode_instr_valid;
output[5:0] decode_wfid;
output[8:0] decode_sgpr_base;
output[9:0] decode_vgpr_base;
output[15:0] decode_lds_base;
output[31:0] decode_instr, decode_instr_pc;
output[39:0] fetch_stop_fetch;

///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////

wire [5:0] flopped_buff_wfid;
wire [63:0] flopped_buff_instr_pc;
wire flopped_buff_first;
wire flopped_buff_ack;

wire [5:0] feed_wfid;
wire feed_valid;

wire [39:0] valid_wf;

wire [39:0] q_wr;
wire [39:0] q_vtail_incr;
wire [39:0] q_reset;
wire [39:0] q_rd;
wire [39:0] q_empty;

PS_flops_fetch_wavepool PS_flops(
  .buff_tag(buff_tag),
  .buff_instr(buff_instr),
  .buff_ack(buff2fetchwave_ack),
  .flopped_buff_wfid(flopped_buff_wfid),
  .flopped_buff_instr_pc(flopped_buff_instr_pc),
  .flopped_buff_first(flopped_buff_first),
  .flopped_buff_ack(flopped_buff_ack),
  .clk(clk),
  .rst(rst)
);

wavepool_controller cntrl(
  .buff_wfid(flopped_buff_wfid),
  .buff_first(flopped_buff_first),
  .buff_ack(flopped_buff_ack),
  .q_wr(q_wr),
  .reserve_slotid(fetch_reserve_slotid),
  .reserve_valid(fetch_reserve_valid),
  .q_vtail_incr(q_vtail_incr),
  .halt_wfid(issue_wf_done_wf_id),
  .wf_halt(issue_wf_done_en),
  .branch_wfid(salu_branch_wfid),
  .branch_en(salu_branch_en),
  .branch_taken(salu_branch_taken),
  .q_reset(q_reset),
  .feed_wfid(feed_wfid),
  .feed_valid(feed_valid),
  .q_rd(q_rd),
  .valid_wf(valid_wf),
  .decode_wfid(decode_wfid),
  .decode_instr_valid(decode_instr_valid),
  .clk(clk),
  .rst(rst)
);

scbd_feeder feeder(
  .valid_wf(valid_wf),
  .ins_half_reqd(decode_ins_half_rqd),
  .ins_half_wfid(decode_ins_half_wfid),
  .issue_vacant(issue_valid_entries),
  .q_empty(q_empty),
  .q_reset(q_reset),
  .feed_valid(feed_valid),
  .feed_wfid(feed_wfid),
  .clk(clk),
  .rst(rst)
);

wq_pool pool(
  .q_vtail_incr(q_vtail_incr),
  .q_rd(q_rd),
  .q_wr(q_wr),
  .q_reset(q_reset),
  .q_empty(q_empty),
  .stop_fetch(fetch_stop_fetch),
  .instr_pc_in(flopped_buff_instr_pc),
  .instr_pc_out({decode_instr,decode_instr_pc}),
  .wf_select(decode_wfid),
  .clk(clk),
  .rst(rst)
);

reg_40x35b_1r_1w base_regs(
  .rd_addr(decode_wfid),
  .rd_data({decode_vgpr_base,decode_sgpr_base,decode_lds_base}),
  .wr_en(fetch_basereg_wr),
  .wr_addr(fetch_basereg_wfid),
  .wr_data({fetch_vgpr_base,fetch_sgpr_base,fetch_lds_base}),
  .clk(clk),
  .rst(rst)
);

///////////////////////////////
//Your code goes here - beware: script does not recognize changes
// into files. It ovewrites everithing without mercy. Save your work before running the script
///////////////////////////////
endmodule
module wavepool_controller (
  buff_wfid,
  buff_first,
  buff_ack,
  q_wr,
  reserve_slotid,
  reserve_valid,
  q_vtail_incr,
  halt_wfid,
  wf_halt,
  branch_wfid,
  branch_en,
  branch_taken,
  q_reset,
  feed_wfid,
  feed_valid,
  q_rd,
  valid_wf,
  decode_wfid,
  decode_instr_valid,
  clk,
  rst
);

input [5:0] buff_wfid;
input buff_first;
input buff_ack;
output [39:0] q_wr;

input [5:0] reserve_slotid;
input reserve_valid;
output [39:0] q_vtail_incr;

input [5:0] halt_wfid;
input wf_halt;
input [5:0] branch_wfid;
input branch_en;
input branch_taken;
output [39:0] q_reset;

input [5:0] feed_wfid;
input feed_valid;
output [39:0] q_rd;

output [39:0] valid_wf;

output [5:0] decode_wfid;
output decode_instr_valid;

input clk;
input rst;

wire [39:0] next_valid_wf;
wire [39:0] valid_wf;
wire [39:0] temp_q_wr;
wire [39:0] temp_q_vtail_incr;
wire [39:0] halt_temp_q_reset;
wire [39:0] branch_temp_q_reset;
wire [39:0] temp_q_rd;
wire branch_taken_en;

reg_40b valid_wavefront(.out(valid_wf), .in(next_valid_wf), .wr_en(1'b1), .clk(clk), .rst(rst));
assign next_valid_wf = (valid_wf | ((temp_q_wr & {40{buff_ack}}) & {40{buff_first}})) & (~q_reset);

decoder_6_to_40 dec_q_wr(.out(temp_q_wr), .in(buff_wfid));
assign q_wr = (temp_q_wr & {40{buff_ack}}) & ({40{buff_first}} | valid_wf);

decoder_6_to_40 dec_q_vtail_incr(.out(temp_q_vtail_incr), .in(reserve_slotid));
assign q_vtail_incr = temp_q_vtail_incr & {40{reserve_valid}};

decoder_6_to_40 dec_q_reset_halt(.out(halt_temp_q_reset), .in(halt_wfid));
decoder_6_to_40 dec_q_reset_branch(.out(branch_temp_q_reset), .in(branch_wfid));
assign branch_taken_en = branch_taken & branch_en;
assign q_reset = (halt_temp_q_reset & {40{wf_halt}}) | (branch_temp_q_reset & {40{branch_taken_en}});

decoder_6_to_40 dec_q_rd(.out(temp_q_rd), .in(feed_wfid));
assign q_rd = temp_q_rd & {40{feed_valid}};

assign decode_wfid = feed_wfid;
assign decode_instr_valid = feed_valid;

endmodule
module wq_pool (
  q_vtail_incr,
  q_rd,
  q_wr,
  q_reset,
  q_empty,
  stop_fetch,
  instr_pc_in,
  instr_pc_out,
  wf_select,
  clk,
  rst
);

input [39:0] q_vtail_incr;
input [39:0] q_rd;
input [39:0] q_wr;
input [39:0] q_reset;

output [39:0] q_empty;
output [39:0] stop_fetch;

input [63:0] instr_pc_in;
output [63:0] instr_pc_out;

input [5:0] wf_select;
input clk;
input rst;

wire [2559:0] instr_pc_premux;

  wave_queue wf_queue[39:0] (
    .q_vtail_incr(q_vtail_incr),
    .q_rd(q_rd),
    .q_wr(q_wr),
    .q_reset(q_reset),
    .q_empty(q_empty),
    .stop_fetch(stop_fetch),
    .instr_pc_in(instr_pc_in),
    .instr_pc_out(instr_pc_premux),
    .clk(clk),
    .rst(rst)
  );

  mux_40x64b_to_1x64b mux_rd_port (.out(instr_pc_out), .in(instr_pc_premux), .select(wf_select));

endmodule
