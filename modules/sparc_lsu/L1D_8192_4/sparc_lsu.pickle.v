/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/********************************************************************
 * Author: Sam Payne
 * 
 * Module encapsulates an asynchronus FIFO used for bridging signals
 * across clock domains, parameters allow for different sized modules
 * compatible with wide range of frequencies.
 *
 * * *******************************************************************/



module async_fifo 
#(
	parameter DSIZE = 64,
	parameter ASIZE = 5,
	parameter MEMSIZE = 16 // should be 2 ^ (ASIZE-1)
)
(
	rdata, 
	rempty,
	rclk,
	ren,
	wdata,
	wfull,
	wclk,
	wval,
	wreset,
	rreset
	);

//Inputs and Outputs
output  [DSIZE-1:0] 	rdata;
output			rempty;
output 			wfull;
input	[DSIZE-1:0]	wdata;
input			wval;
input			ren;
input			rclk;
input			wclk;
input 			wreset;
input			rreset;

//Internal Registers
reg	[ASIZE-1:0]	g_wptr;
reg	[ASIZE-1:0]	g_rptr;

reg	[ASIZE-1:0]	g_rsync1, g_rsync2;
reg	[ASIZE-1:0]	g_wsync1, g_wsync2;

//Memory
reg	[DSIZE-1:0] 	fifo[MEMSIZE-1:0];

wire [ASIZE-1:0] b_wptr;
wire [ASIZE-1:0] b_wptr_next;
wire [ASIZE-1:0] g_wptr_next;
wire [ASIZE-1:0] b_rptr;
wire [ASIZE-1:0] b_rptr_next;
wire [ASIZE-1:0] g_rptr_next;

/********************************************************************
COMBINATIONAL LOGIC
********************************************************************/

//convert gray to binary
assign b_wptr[ASIZE-1:0] = ({1'b0, b_wptr[ASIZE-1:1]} ^ g_wptr[ASIZE-1:0]);
assign b_rptr[ASIZE-1:0] = ({1'b0, b_rptr[ASIZE-1:1]} ^ g_rptr[ASIZE-1:0]);

//increment
assign b_wptr_next = b_wptr + 1;
assign b_rptr_next = b_rptr + 1;

//convert binary to gray
assign g_wptr_next[ASIZE-1:0] = {1'b0, b_wptr_next[ASIZE-1:1]} ^ b_wptr_next[ASIZE-1:0];
assign g_rptr_next[ASIZE-1:0] = {1'b0, b_rptr_next[ASIZE-1:1]} ^ b_rptr_next[ASIZE-1:0];

//full and empty signals
assign wfull =  (g_wptr[ASIZE-1]   != g_rsync2[ASIZE-1]  ) && 
		(g_wptr[ASIZE-2]   != g_rsync2[ASIZE-2]  ) &&
		(g_wptr[ASIZE-3:0] == g_rsync2[ASIZE-3:0]) ||
		(wreset || rreset);

assign rempty =  (g_wsync2[ASIZE-1:0] == g_rptr[ASIZE-1:0]) ||
	         (wreset || rreset);

//output values
assign rdata = fifo[b_rptr[ASIZE-2:0]];

/********************************************************************
SEQUENTIAL LOGIC
********************************************************************/

//transfer register values
always @(posedge rclk) begin
	if (rreset) begin
		g_rptr <= 0;
	end
	else if (ren && !rempty) begin
		g_rptr <= g_rptr_next;
	end

	g_wsync1 <= g_wptr;
	g_wsync2 <= g_wsync1;
end

always @(posedge wclk) begin
	if (wreset) begin
		g_wptr <= 0;
	end
	else if (wval && !wfull) begin
		fifo[b_wptr[ASIZE-2:0]] <= wdata;
		g_wptr <= g_wptr_next;
	end

	g_rsync1 <= g_rptr;
	g_rsync2 <= g_rsync1;

	
end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs, modified to be synthesizable

module bram_1r1w_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
  input wire MEMCLK,
  input wire RESET_N,
  input wire CEA,
  input wire [ADDR_WIDTH-1:0] AA,
  input wire [ADDR_WIDTH-1:0] AB,

  input wire RDWENA,
  input wire CEB,
  input wire RDWENB,
  input wire [DATA_WIDTH-1:0] BWA,
  input wire [DATA_WIDTH-1:0] DINA,
  output reg [DATA_WIDTH-1:0] DOUTA,
  input wire [DATA_WIDTH-1:0] BWB,
  input wire [DATA_WIDTH-1:0] DINB,
  output wire [DATA_WIDTH-1:0] DOUTB
  // input wire [`BIST_OP_WIDTH-1:0] BIST_COMMAND,
  // input wire [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DIN,
  // output reg [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DOUT,
  // input wire [`BIST_ID_WIDTH-1:0] SRAMID
);

wire                            write_enable_in;
wire                            read_enable_in;

// Temporary storage for write data
reg                             write_enable_in_reg;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg   [BITMASK_WIDTH-1:0 ]      WRITE_BIT_MASK_REG;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
// reg   [DATA_WIDTH-1:0    ]      DOUTB_r;

reg                             read_enable_in_reg;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_write_en;
reg                            bram_write_en_muxed;
wire                            bram_read_en;
wire                            bram_write_read_en;
reg  [DATA_WIDTH-1:0    ]      bram_data_write_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_in;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;
wire  [DATA_WIDTH-1:0    ]      last_wrote_data;
wire                            rw_conflict;
reg                             rw_conflict_r;
wire                            ww_conflict;
reg                             ww_conflict_r;

/* renaming signals */
assign read_enable_in    = CEA & (RDWENA == 1'b1);
assign write_enable_in   = CEB & (RDWENB == 1'b0);
wire [ADDR_WIDTH-1:0    ] READ_ADDRESS = AA;
wire [ADDR_WIDTH-1:0    ] WRITE_ADDRESS = AB;
wire [BITMASK_WIDTH-1:0    ] WRITE_BIT_MASK = BWB;

// Intermediate logic for write processing
always @(posedge MEMCLK) begin
  write_enable_in_reg <= write_enable_in;
  WRITE_ADDRESS_REG   <= WRITE_ADDRESS;
  WRITE_BIT_MASK_REG  <= WRITE_BIT_MASK;
  DIN_r <= DINB;
  read_enable_in_reg  <= read_enable_in;
  bram_data_in_r <= bram_data_in;
  rw_conflict_r  <= rw_conflict;
  ww_conflict_r  <= ww_conflict;
  // DOUTB_r  <= DOUTB;
end

// determining read-write and write-write conflict for data bypassing
assign rw_conflict      = write_enable_in_reg & read_enable_in & (WRITE_ADDRESS_REG == READ_ADDRESS);
assign ww_conflict      = write_enable_in_reg & write_enable_in & (WRITE_ADDRESS_REG == WRITE_ADDRESS);
assign DOUTB = {DATA_WIDTH{1'bx}}; // port B is always used for write

// calculate the correct read and write data after accoutning for conflicts
always @ * begin
  bram_data_in = (DIN_r & WRITE_BIT_MASK_REG);
  if (ww_conflict_r)
    bram_data_in = bram_data_in | (bram_data_in_r & ~WRITE_BIT_MASK_REG);
  else
    bram_data_in = bram_data_in | (bram_data_write_read_out_reg & ~WRITE_BIT_MASK_REG);
  

  // note: DOUT retains value if read enable is not asserted
  // which is why default value is not set for DOUT
  if (read_enable_in_reg) begin
    DOUTA = bram_data_read_out_reg; 
    if (rw_conflict_r) begin
      DOUTA = bram_data_in_r;
    end
  end
end

// synthesizable BRAM
assign bram_write_en      = write_enable_in_reg;
assign bram_read_en         = (read_enable_in) & ~rw_conflict;             // do not read in case of a conflict
assign bram_write_read_en         = (write_enable_in) & ~ww_conflict;             // do not read in case of a conflict

reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_write_read_out_reg;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
    ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_read_en) begin
    bram_data_read_out_reg <= ram[READ_ADDRESS];
  end
  if (bram_write_read_en) begin
    bram_data_write_read_out_reg <= ram[WRITE_ADDRESS];
  end
end
// END BRAM


/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = WRITE_ADDRESS_REG;
      bram_write_en_muxed = bram_write_en;
      bram_data_in_muxed = bram_data_in;
   end
end


endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs

module bram_1rw_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
    input                         MEMCLK,
    input wire RESET_N,
    input                         CE,
    input   [ADDR_WIDTH-1:0]      A,
    input                         RDWEN,
    input   [BITMASK_WIDTH-1:0]   BW,
    input   [DATA_WIDTH-1:0]      DIN,
    output  [DATA_WIDTH-1:0]      DOUT
);

wire                            write_en;
wire                            read_en;

// Temporary storage for write data
reg                             wen_r;
reg   [ADDR_WIDTH-1:0    ]      A_r;
reg   [BITMASK_WIDTH-1:0 ]      BW_r;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
reg   [DATA_WIDTH-1:0    ]      DOUT_r;

reg                             ren_r;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_wen;
wire                            bram_ren;
reg  [DATA_WIDTH-1:0    ]      bram_data_out;
wire  [DATA_WIDTH-1:0    ]      bram_data_in;
wire  [DATA_WIDTH-1:0    ]      up_to_date_data;
wire                            rw_conflict;
reg                             rw_conflict_r;



reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg                            bram_write_en_muxed;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;

assign write_en   = CE & (RDWEN == 1'b0);
assign read_en    = CE & (RDWEN == 1'b1);


// Intermediate logic for write processing
always @(posedge MEMCLK) begin
   wen_r <= write_en;
   A_r   <= A;
   BW_r  <= BW;
   DIN_r <= DIN;
end

always @(posedge MEMCLK) begin
  ren_r  <= read_en;
end

always @(posedge MEMCLK)
   bram_data_in_r <= bram_data_in;

always @(posedge MEMCLK)
   rw_conflict_r  <= rw_conflict;

always @(posedge MEMCLK)
  DOUT_r  <= DOUT;

assign bram_data_in = (up_to_date_data & ~BW_r) | (DIN_r & BW_r);

// processing of read in case if it just in the next cycle after read to the same address
assign rw_conflict      = wen_r & CE & (A_r == A);                         // read or write to the same address
assign up_to_date_data  = rw_conflict_r ? bram_data_in_r : bram_data_out;  // delay of mem is 1 cycle
assign bram_ren         = (read_en | write_en) & ~rw_conflict;             // do not read in case of a conflict
                                                                        // to make behaviour of a memory robust
assign bram_wen      = wen_r;

assign DOUT          = ren_r ? up_to_date_data : DOUT_r;

// BRAM
reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_out;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
      ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_ren) begin
    bram_data_out <= ram[A];
  end
end
// END BRAM

 // undefined by default

/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = A_r;
      bram_write_en_muxed = bram_wen;
      bram_data_in_muxed = bram_data_in;
   end
end













endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : synchronizer.v
//  Created On    : 2014-01-31 12:52:57
//  Last Modified : 2018-11-29 17:02:47
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   :
//==================================================================================================





module synchronizer (
    clk,
    presyncdata,
    syncdata
    );

// synopsys template
parameter SIZE = 1;

input wire clk;
input wire [SIZE-1:0] presyncdata;
output reg [SIZE-1:0] syncdata;













  reg [SIZE-1:0] presyncdata_tmp;



    // bw_u1_syncff_4x u_synchronizer_syncff [SIZE-1:0](.q(presyncdata_tmp),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

    // bw_u1_soff_2x u_synchronizer_ff[SIZE-1:0] (.q(syncdata),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata_tmp),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

always @ (posedge clk)
begin
    presyncdata_tmp <= presyncdata;
    syncdata        <= presyncdata_tmp;
end

endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : clk_gating_latch.v
//  Created On    : 2015-01-26 14:10:43
//  Last Modified : 2019-04-17 11:56:55
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   : Latch for glitchless clock gating
//==================================================================================================

module clk_gating_latch (
    input wire clk,
    input wire clk_en,
    output wire clk_out
);

// use clock buffer on FPGA
// note that not all FPGAs have enough of these available
// so we use the latch as a fallback on certain boards (e.g., vc707)




 // PITON_FPGA_SYNTH

  wire clk_en_sync;
  reg clk_en_sync_latch;

  assign clk_out = clk & clk_en_sync_latch;

  synchronizer sync(
      .clk            (clk),
      .presyncdata    (clk_en),
      .syncdata       (clk_en_sync)
  );

  // if possible, replace this with a native clock gate from the std cell lib
  // clk_en_sync_latch changes only on the negative duty of the cycle
  always @ (clk or clk_en_sync)
      if (~clk) clk_en_sync_latch = clk_en_sync;



endmodule // clk_gating_latch
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/****************************************************************************
 *
 *   FILE: credit_to_valrdy.v
 *
 *   Modified: Yaosheng Fu
 *   Date: May 2 2014

 ***************************************************************************/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

module credit_to_valrdy (
   clk,
   reset,
   //credit based interface	
   data_in,
   valid_in,
   yummy_in,
            
   //val/rdy interface
   data_out,
   valid_out,
   ready_out
);

   input	 clk;
   input	 reset;
   input [64-1:0]	 data_in;
   input	 valid_in;
   input     ready_out;
    
   output	 yummy_in;
   output	 valid_out;
   output [64-1:0] data_out;
   
   wire	 thanksIn;

   wire valid_out_temp;

   assign valid_out = valid_out_temp;

   network_input_blk_multi_out #(.LOG2_NUMBER_FIFO_ELEMENTS(2)) data(
      .clk(clk),
      .reset(reset),
      .data_in(data_in),
      .valid_in(valid_in),

      .thanks_in(valid_out & ready_out),

      .yummy_out(yummy_in),
      .data_val(data_out),
      .data_val1(/*not used*/),
      .data_avail(valid_out_temp));

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: m1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
// 64 bit nor gate with first 32 bits out

module zznor64_32 ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32



////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate

module zzor36 ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
	     | a[32] | a[33] | a[34] | a[35]); 
   
endmodule // zzor36



////////////////////////////////////////////////////////////////////////////////
// 32 bit or gate

module zzor32 ( z, a );
  input  [31:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

endmodule // zzor32



////////////////////////////////////////////////////////////////////////////////
// 24 bit nor gate

module zznor24 ( z, a );
  input  [23:0] a;
  output        z;

  assign z =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	      | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]); 

endmodule // zznor24



////////////////////////////////////////////////////////////////////////////////
// 16 bit nor gate

module zznor16 ( z, a );
  input  [15:0] a;
  output        z;

  assign z =  ~(a[0] | a[1] | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]); 

endmodule // zznor16



////////////////////////////////////////////////////////////////////////////////
// 8 bit or gate

module zzor8 ( z, a );
  input  [7:0] a;
  output       z;

  assign z =  (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7]); 
   
endmodule // zzor8




////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd13 ( rs1_data, rs2_data, cin, adder_out );

  input  [12:0] rs1_data;   // 1st input operand
  input  [12:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [12:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd13



////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd56 ( rs1_data, rs2_data, cin, adder_out );

  input  [55:0] rs1_data;   // 1st input operand
  input  [55:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [55:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd56



////////////////////////////////////////////////////////////////////////////////

module zzadd48 ( rs1_data, rs2_data, cin, adder_out );

  input  [47:0] rs1_data;   // 1st input operand
  input  [47:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [47:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd48



////////////////////////////////////////////////////////////////////////////////
//  This adder is primarily used in the multiplier.
//  The cin to out path is optimized.

module zzadd34c ( rs1_data, rs2_data, cin, adder_out );

  input  [33:0] rs1_data;
  input  [33:0] rs2_data;
  input         cin;

  output [33:0] adder_out;

  assign adder_out = rs1_data + rs2_data + cin;


endmodule // zzadd34c



////////////////////////////////////////////////////////////////////////////////

module zzadd32 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [31:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd32



////////////////////////////////////////////////////////////////////////////////

module zzadd18 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [17:0] rs1_data;   // 1st input operand
  input  [17:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [17:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd18



////////////////////////////////////////////////////////////////////////////////

module zzadd8 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [7:0] rs1_data;   // 1st input operand
  input  [7:0] rs2_data;   // 2nd input operand
  input        cin;        // carry in

  output [7:0] adder_out;  // result of add & decrement
  output       cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd8



////////////////////////////////////////////////////////////////////////////////
// Special 4-operand 32b adder used in spu_shamd5
//  Description:        This block implements the 4-operand 32-bit adder for SPU
//			It takes four 32-bit operands. It add them together and
//			output the 32-bit results to adder_out. The overflow of
//			32th bit and higher will be ignored.

module zzadd32op4 ( rs1_data, rs2_data, rs3_data, rs4_data, adder_out );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input  [31:0] rs3_data;   // 3rd input operand
  input  [31:0] rs4_data;   // 4th input operand

  output [31:0] adder_out;  // result of add

  assign adder_out = rs1_data + rs2_data + rs3_data + rs4_data;

endmodule // zzadd32op4


////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc alu.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out.  It outputs the overflow
//			and carry condition codes for both 64 bit and 32 bit operations.

module zzadd64 ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64



///////////////////////////////////////////////////////////////////////
/*
//      Description: This is the ffu VIS adder.  It can do either
//                              2 16 bit adds or 1 32 bit add.
*/

module zzadd32v (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
   a, b, cin, add32
   ) ;
   input [31:0] a;
   input [31:0] b;
   input        cin;
   input        add32;

   output [31:0] z;

   wire          cout15; // carry out from lower 16 bit add
   wire          cin16; // carry in to the upper 16 bit add
   wire          cout31; // carry out from the upper 16 bit add

   assign        cin16 = (add32)? cout15: cin;

   assign      {cout15, z[15:0]} = a[15:0]+b[15:0]+ cin;
   assign      {cout31, z[31:16]} = a[31:16]+b[31:16]+ cin16;

endmodule // zzadd32v




////////////////////////////////////////////////////////////////////////////////
// 64-bit incrementer

module zzinc64 ( in, out );

  input  [63:0] in;

  output [63:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc64


////////////////////////////////////////////////////////////////////////////////
// 48-bit incrementer

module zzinc48 ( in, out, overflow );

  input  [47:0] in;

  output [47:0] out;      // result of increment
  output        overflow; // overflow

  assign out      = in + 1'b1;
  assign overflow = ~in[47] & out[47];

endmodule // zzinc48


////////////////////////////////////////////////////////////////////////////////
// 32-bit incrementer

module zzinc32 ( in, out );

  input  [31:0] in;

  output [31:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc32


////////////////////////////////////////////////////////////////////////////////

module zzecc_exu_chkecc2 ( q,ce, ue, ne, d, p, vld );
   input [63:0] d;
   input [7:0]  p;
   input        vld;
   output [6:0] q;
   output       ce,
                ue,
                ne;

   wire       parity;

   assign     ce = vld & parity;

   assign ue = vld & ~parity & (q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);

   assign ne = ~vld | ~(parity | q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);


   assign q[0] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10]
               ^ d[11] ^ d[13] ^ d[15] ^ d[17] ^ d[19] ^ d[21] ^ d[23]
               ^ d[25] ^ d[26] ^ d[28] ^ d[30] ^ d[32] ^ d[34] ^ d[36]
               ^ d[38] ^ d[40] ^ d[42] ^ d[44] ^ d[46] ^ d[48] ^ d[50]
               ^ d[52] ^ d[54] ^ d[56] ^ d[57] ^ d[59] ^ d[61] ^ d[63]
               ^ p[0]  ;

   assign q[1] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[10]
               ^ d[12] ^ d[13] ^ d[16] ^ d[17] ^ d[20] ^ d[21] ^ d[24]
               ^ d[25] ^ d[27] ^ d[28] ^ d[31] ^ d[32] ^ d[35] ^ d[36]
               ^ d[39] ^ d[40] ^ d[43] ^ d[44] ^ d[47] ^ d[48] ^ d[51]
               ^ d[52] ^ d[55] ^ d[56] ^ d[58] ^ d[59] ^ d[62] ^ d[63]
               ^ p[1]  ;

   assign q[2] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[29] ^ d[30] ^ d[31] ^ d[32] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[45] ^ d[46] ^ d[47] ^ d[48] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
               ^ p[2]  ;

   assign q[3] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[3]  ;

   assign q[4] = d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[4]  ;

   assign q[5] = d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31] ^ d[32]
               ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
               ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[5]  ;

   assign q[6] = d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63] ^ p[6] ;

   assign parity = d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
                 ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
                 ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
                 ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
                 ^ d[32] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
                 ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46] ^ d[47]
                 ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53] ^ d[54] ^ d[55]
                 ^ d[56] ^ d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
                 ^ p[0]  ^ p[1]  ^ p[2]  ^ p[3]  ^ p[4]  ^ p[5]  ^ p[6]  ^ p[7];

endmodule // zzecc_exu_chkecc2



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_24b_gen ( din, dout, parity ) ;

// Input Ports
input  [23:0] din ;

// Output Ports
output [23:0] dout ;
output [5:0]  parity ;

wire   [23:0] dout ;
wire   [5:0]  parity ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire          p30 ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |  |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |  |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |  |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |  |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |  |  |* |  |* |* |  |  |* |* |  |* |  |  | * |   | * | * |   | * |   |   | * | * |   |   | * |   | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p30 = din[0]  ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5]  ^
             din[7]  ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^
             din[17] ^ din[18] ^ din[21] ^ din[23] ;

assign dout   = din ;
assign parity = {p30, p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_30b_cor ( din, parity, dout, corrected_bit ) ;

// Input Ports
input  [23:0] din ;
input  [4:0]  parity ;

// Output Ports
output [23:0] dout ;
output [4:0]  corrected_bit ;

wire   [23:0] dout ;
wire   [4:0]  corrected_bit ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire [23:0]   error_bit ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |* |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |* |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |* |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |* |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   | * | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |* |* |* |* |* |* |* |* |* |* |* |* |* |* | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = parity[0] ^
             din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = parity[1] ^
             din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = parity[2] ^
             din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = parity[3] ^
             din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = parity[4] ^
             din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign  error_bit[0]  = !p16 & !p8 & !p4 &  p2 &  p1 ; // 3
assign  error_bit[1]  = !p16 & !p8 &  p4 & !p2 &  p1 ; // 5
assign  error_bit[2]  = !p16 & !p8 &  p4 &  p2 & !p1 ; // 6
assign  error_bit[3]  = !p16 & !p8 &  p4 &  p2 &  p1 ; // 7
assign  error_bit[4]  = !p16 &  p8 & !p4 & !p2 &  p1 ; // 9
assign  error_bit[5]  = !p16 &  p8 & !p4 &  p2 & !p1 ; // 10
assign  error_bit[6]  = !p16 &  p8 & !p4 &  p2 &  p1 ; // 11
assign  error_bit[7]  = !p16 &  p8 &  p4 & !p2 & !p1 ; // 12
assign  error_bit[8]  = !p16 &  p8 &  p4 & !p2 &  p1 ; // 13
assign  error_bit[9]  = !p16 &  p8 &  p4 &  p2 & !p1 ; // 14
assign  error_bit[10] = !p16 &  p8 &  p4 &  p2 &  p1 ; // 15
assign  error_bit[11] =  p16 & !p8 & !p4 & !p2 &  p1 ; // 17
assign  error_bit[12] =  p16 & !p8 & !p4 &  p2 & !p1 ; // 18
assign  error_bit[13] =  p16 & !p8 & !p4 &  p2 &  p1 ; // 19
assign  error_bit[14] =  p16 & !p8 &  p4 & !p2 & !p1 ; // 20
assign  error_bit[15] =  p16 & !p8 &  p4 & !p2 &  p1 ; // 21
assign  error_bit[16] =  p16 & !p8 &  p4 &  p2 & !p1 ; // 22
assign  error_bit[17] =  p16 & !p8 &  p4 &  p2 &  p1 ; // 23
assign  error_bit[18] =  p16 &  p8 & !p4 & !p2 & !p1 ; // 24
assign  error_bit[19] =  p16 &  p8 & !p4 & !p2 &  p1 ; // 25
assign  error_bit[20] =  p16 &  p8 & !p4 &  p2 & !p1 ; // 26
assign  error_bit[21] =  p16 &  p8 & !p4 &  p2 &  p1 ; // 27
assign  error_bit[22] =  p16 &  p8 &  p4 & !p2 & !p1 ; // 28
assign  error_bit[23] =  p16 &  p8 &  p4 & !p2 &  p1 ; // 29

assign  dout          = din ^ error_bit ;
assign  corrected_bit = {p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_ecc39
//Function: Error Detection and Correction
//
//

module zzecc_sctag_ecc39 ( dout, cflag, pflag, parity, din);

   //Output: 32bit corrected data
   output[31:0] dout;
   output [5:0] cflag;
   output 	pflag;
   
   //Input: 32bit data din
   input [31:0] din;
   input [6:0]	parity;

   wire 	c0,c1,c2,c3,c4,c5;
   wire [31:0] 	err_bit_pos;

   //refer to the comments in parity_gen_32b.v for the position description
   
   assign c0= parity[0]^(din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   
   assign c1= parity[1]^(din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   
   assign c2= parity[2]^(din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   
   assign c3= parity[3]^(din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   
   assign c4= parity[4]^(din[11]^din[12])^(din[13]^din[14])^
                    (din[15]^din[16])^(din[17]^din[18])^(din[19]^din[20])^
                    (din[21]^din[22])^(din[23]^din[24])^din[25];

   assign c5= parity[5]^(din[26]^din[27])^(din[28]^din[29])^
		    (din[30]^din[31]);

   //generate total parity flag
   assign pflag= c0 ^
		(( (((parity[1]^parity[2])^(parity[3]^parity[4])) ^
		 ((parity[5]^parity[6])^(din[2]^din[5]))) ^		 
		 (((din[7]^din[9])^(din[12]^din[14])) ^
		 ((din[16]^din[18])^(din[20]^din[22]))) ) ^
		 ((din[24]^din[27])^(din[29]^din[31])) );
   
   assign cflag= {c5,c4,c3,c2,c1,c0};
   
   //6 to 32 decoder
   assign err_bit_pos[0] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[1] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[2] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[3] = (c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[4] = (c0)&(~c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[5] = (~c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[6] = (c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[7] = (~c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[8] = (c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[9] = (~c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[10] = (c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[11] = (c0)&(~c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[12] = (~c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[13] = (c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[14] = (~c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[15] = (c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[16] = (~c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[17] = (c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[18] = (~c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[19] = (c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[20] = (~c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[21] = (c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[22] = (~c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[23] = (c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[24] = (~c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[25] = (c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[26] = (c0)&(~c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[27] = (~c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[28] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[29] = (~c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[30] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[31] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(c5);

   //correct the error bit, it can only correct one error bit.
   
   assign dout = din ^ err_bit_pos;

endmodule // zzecc_sctag_ecc39


////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_pgen_32b
//Function: Generate 7 parity bits for 32bits input data
//

module zzecc_sctag_pgen_32b ( dout, parity, din);

   //Output: 32bit dout and 7bit parity bit
   output[31:0] dout;
   output [6:0] parity;

   //Input: 32bit data din
   input [31:0] din;

   //input data passing through this module
   assign dout = din ;

   //generate parity bits based on the hamming codes
   //the method to generate parity bit is shown as follows
   //1   2  3  4  5  6  7  8  9 10 11 12 13 14  15  16  17  18  19
   //P1 P2 d0 P4 d1 d2 d3 P8 d4 d5 d6 d7 d8 d9 d10 P16 d11 d12 d13 
   //
   // 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 
   //d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 P32 d26 d27 d28
   //
   // 36  37  38       
   //d29 d30 d31
   //For binary numbers B1-B2-B3-B4-B5-B6:
   //B1=1 for (1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,...)
   //B2=1 for (2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39...)
   //B3=1 for (4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,39....)
   //B4=1 for (8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,....)
   //B5=1 for (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,...)
   //B6=1 for (32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49...)
   //Parity bit P1,P2,P4,P8,P16,P32 can be generated from the above group of
   //bits B1=1,B2=1,B3=1,B4=1,B5=1,B6=1 respectively.

   //use parity[5:0] to stand for P1,P2,P4,P8,P16,P32
   assign parity[0] = (din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   //
   assign parity[1] = (din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   //
   assign parity[2] = (din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   //
   assign parity[3] = (din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[4] = (din[11]^din[12])^(din[13]^din[14])^(din[15]^din[16])
                     ^(din[17]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[5] = (din[26]^din[27])^(din[28]^din[29])^(din[30]^din[31]);

   //the last parity bit is the xor of all 38bits
   //assign parity[6] = (^din)^(^parity[5:0]);
   //it can be further simplified as:
   //din= d0  d1  d2  d3  d4  d5  d6  d7  d8  d9 d10 d11 d12 d13 d14 d15 
   //p0 =  x   x       x   x       x       x       x   x       x       x
   //p1 =  x       x   x       x   x           x   x       x   x
   //p2 =      x   x   x               x   x   x   x               x   x
   //p3 =                  x   x   x   x   x   x   x  
   //p4 =                                              x   x   x   x   x
   //p5 =
   //-------------------------------------------------------------------
   //Total 3   3   3   4   3   3   4   3   4   4   5   3   3   4   3   4 
   //
   //din=d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 
   //p0=       x       x       x       x       x   x       x       x    
   //p1=   x   x           x   x           x   x       x   x           x
   //p2=   x   x                   x   x   x   x               x   x   x
   //p3=           x   x   x   x   x   x   x   x
   //p4=   x   x   x   x   x   x   x   x   x   x
   //p5=                                           x   x   x   x   x   x
   //-------------------------------------------------------------------
   //total 4   5   3   4   4   5   4   5   5   6   3   3   4   3   4   4

   //so total=even number, the corresponding bit will not show up in the
   //final xor tree.
   assign parity[6] =  din[0] ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5] ^ din[7]
		    ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^ din[17]
		    ^ din[18] ^ din[21] ^ din[23] ^ din[24] ^ din[26]
		    ^ din[27] ^ din[29];
   
endmodule // zzecc_sctag_pgen_32b

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree

module zzpar34 ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
	      ^ d[32] ^ d[33]; 

endmodule // zzpar34



////////////////////////////////////////////////////////////////////////////////
// 32 bit parity tree

module zzpar32 ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]; 

endmodule // zzpar32



////////////////////////////////////////////////////////////////////////////////
// 28 bit parity tree

module zzpar28 ( z, d );
   input  [27:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27]; 

endmodule // zzpar28



////////////////////////////////////////////////////////////////////////////////
// 16 bit parity tree

module zzpar16 ( z, d );
   input  [15:0] d;
   output        z;

   assign z = d[0] ^ d[1] ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	    ^ d[8] ^ d[9] ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]; 
   
endmodule // zzpar16



////////////////////////////////////////////////////////////////////////////////
// 8 bit parity tree

module zzpar8 ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8



////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority

module zzpenc64 (/*AUTOARG*/
   // Outputs
   z, 
   // Inputs
  a 
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64

////////////////////////////////////////////////////////////////////////////////
//    4-bit 60x buffers

module zzbufh_60x4 (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [3:0] a;
   output [3:0] z;

   assign z = a;

endmodule //zzbufh_60x4

// LVT modules added below

module zzadd64_lv ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64_lv

module zzpar8_lv ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8_lv


module zzpar32_lv ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31];

endmodule // zzpar32_lv



module zznor64_32_lv ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32_lv

////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority
//    LVT version

module zzpenc64_lv (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64_lv

////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate
// LVT version

module zzor36_lv ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
             | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
             | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
             | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
             | a[32] | a[33] | a[34] | a[35]);

endmodule // zzor36_lv

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree
// LVT version

module zzpar34_lv ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
              ^ d[32] ^ d[33];

endmodule // zzpar34_lv


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: mul64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/*//////////////////////////////////////////////////////////////////////
//
//  Module Name: mul64
//  Description:        *This block implements the multiplier used in the modular multiplier
//                       unit (MUL) and be shared by sparc EXU and the streaming unit (SPU).
//                       It is also used as the 54x54 multiplier in the FPU.
//                      *It takes two 64-bit unsign data and accumulated operand and do the
//                       64x64 MAC operation at two cycle thruput and 5 cycle latency.
//                      *The mul_valid signal indicate the beginning of a new operation.
//                       It MUST be dis-asserted at the next cycle to have the proper 2-cycle
//                       latency operation in the csa array. If there are two back-to-back
//                       cycle operation, the first operation result will be incorrect.
//                      *Results are avaliable on the 5th cycle of the mul_valid as shows
//
//			*Following inputs should tie to "0" when used as a 64x64 multiplier
//			 - areg 
//			 - accreg 
//			 - x2
//
//                         Cycle-0  | Cycle-1 | Cycle-2 | Cycle-3 | Cycle-4 | Cycle-5
//                       1st        *         |         |         |         |
//                       rs1, rs2   ^         |         |         |         | 1st results
//                       valid=1    | valid=0 |         *         |         | avaliable
//                                1st         | 2nd OP  ^         |         |
//                                setup       | valid=1 |         |         |
//                                            |        2nd        |         |
//                                            |       setup       |         |
//
*/

//PITON_PROTO enables all FPGA related modifications



























































module mul64 (rs1_l, rs2, valid, areg, accreg, x2, out, rclk, si, so, se, mul_rst_l, mul_step);

input  [63:0]  	rs1_l;			// op1
input  [63:0]  	rs2;			// op2
input	       	valid;			// begin of the MUL operation
input  [96:0]  	areg;			// accumulated input for ACCUM
input  [135:129] accreg;		// direct input from ACCUM [135:129]
input	       	x2;			// for op1*op2*2
input	       	rclk, si, se, mul_rst_l, mul_step;
output  	so;
output [135:0] 	out;

wire	       	cyc1, cyc2, cyc3;	// cycle stage of MUL
wire [2:0]	b0, b1, b2,  b3,  b4,  b5,  b6,  b7;
wire [2:0]	b8, b9, b10, b11, b12, b13, b14, b15;
wire	    	b16;
wire [63:0]	op1_l, op1;
wire [81:0]	a0sum, a1sum, a0s, a1s; 
wire [81:4]	a0cout, a1cout, a0c, a1c;
wire		pcoutx2, psumx2;
wire 		x2_c1, x2_c2, x2_c3, x2_c2c3;

wire [98:0]	psum, pcout;
wire [98:30]	pcout_in, pc;
wire [98:31]	psum_in, ps;
wire [96:0]	ary2_cout, addin_cout;
wire [97:0]	ary2_sum,  addin_sum ;
wire		add_cin, addin_cin, add_co31, add_co96;
wire [103:0]	addout;
wire		clk_enb0, clk_enb1;
wire 		rst;
wire		clk;
wire		tm_l;

  assign clk = rclk;
  assign rst = ~mul_rst_l; 
  assign tm_l = ~se;

  clken_buf	ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));

  /////////////////////////////////////////////////////////////////////
  // 	States count
  /////////////////////////////////////////////////////////////////////
  dffr_s  cyc1_dff(.din(valid), .clk(clk_enb0), .q(cyc1), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc2_dff(.din(cyc1),  .clk(clk_enb0), .q(cyc2), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc3_dff(.din(cyc2),  .clk(clk_enb0), .q(cyc3), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c1_dff(.din(x2),    .clk(clk_enb0), .q(x2_c1), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c2_dff(.din(x2_c1), .clk(clk_enb0), .q(x2_c2), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c3_dff(.din(x2_c2), .clk(clk_enb0), .q(x2_c3), .rst(rst), .se(se), .si(), .so());

  assign x2_c2c3 =  x2_c2 | x2_c3 ;
	
  /////////////////////////////////////////////////////////////////////
  // 	Enable flops for op1
  /////////////////////////////////////////////////////////////////////
  clken_buf	ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(valid & mul_step)), .tmb_l(tm_l));
  dff_s #(64)  	ffrs1  (.din(rs1_l[63:0]), .clk(clk_enb1), .q(op1_l[63:0]),
			.se(se), .si(), .so());




  assign op1[63:0] = ~op1_l[63:0];

  mul_booth	 booth (.head (valid),
			.b_in (rs2),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (b8),
			.b9   (b9),
			.b10  (b10),
			.b11  (b11),
			.b12  (b12),
			.b13  (b13),
			.b14  (b14),
			.b15  (b15),
			.b16  (b16),
			.clk  (clk), .se(se), .si(), .so(), .mul_step(mul_step), .tm_l(tm_l));
			
  /////////////////////////////////////////////////////////////////////
  // 	Two Array1 inst ary1_a0 & ary1_a1 with the ouput flops 
  /////////////////////////////////////////////////////////////////////
  mul_array1	ary1_a0(.cout (a0cout[81:4]),
			.sum  (a0sum[81:0]),
			.a    (op1),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (3'b000),
			.head (cyc1),
			.bot  (1'b0)); //array a is never at the bottom of 33-pp rows
 
  dff_s #(78)  a0cot_dff (.din(a0cout[81:4]), .clk(clk_enb0), .q(a0c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a0sum_dff (.din(a0sum[81:0]), .clk(clk_enb0), .q(a0s[81:0]),
			.se(se), .si(), .so());

  mul_array1	ary1_a1(.cout (a1cout[81:4]),
			.sum  (a1sum[81:0]),
			.a    (op1),
			.b0   (b8),
			.b1   (b9),
			.b2   (b10),
			.b3   (b11),
			.b4   (b12),
			.b5   (b13),
			.b6   (b14),
			.b7   (b15),
			.b8   ({1'b0,b16,1'b0}),
			.head (1'b0),	//array b is never at the head of 33-pp rows
			.bot  (cyc2)); 

  dff_s #(78)  a1cot_dff (.din(a1cout[81:4]), .clk(clk_enb0), .q(a1c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a1sum_dff (.din(a1sum[81:0]), .clk(clk_enb0), .q(a1s[81:0]),
			.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Array2 with the reorder output mux-flops
  /////////////////////////////////////////////////////////////////////
  mul_array2 	 array2(.pcoutx2 (pcoutx2),
			.psumx2  (psumx2),
			.pcout 	 (pcout[98:0]),
			.psum    (psum[98:0]), 
			.a0c     (a0c[81:4]),
			.a0s     (a0s[81:0]),
			.a1c     (a1c[81:4]),
			.a1s     (a1s[81:0]),
			.pc	 (pc[98:30]),
			.ps	 (ps[98:31]),
			.areg    (areg[96:0]),
			.bot     (cyc3),
			.x2      (x2_c2c3));
 
  //// Outpput re-order muxes and flops	////
  dp_mux2es #(97)  ary2_cmux (.dout(ary2_cout[96:0]),
                              .in0(pcout[96:0]),
                              .in1({pcout[95:0],pcoutx2}),
                              .sel(x2_c2c3));
  dff_s #(97)  a2cot_dff (.din(ary2_cout[96:0]), .clk(clk_enb0), .q(addin_cout[96:0]), 
              		.se(se), .si(), .so());

  dp_mux2es #(98) ary2_smux (.dout(ary2_sum[97:0]),
                             .in0(psum[97:0]),
                             .in1({psum[96:0],psumx2}),
                             .sel(x2_c2c3));
  dff_s #(98)  a2sum_dff (.din(ary2_sum[97:0]), .clk(clk_enb0), .q(addin_sum[97:0]), 
			.se(se), .si(), .so());

  //// Pseudo sum & cout logic and flops ////
  assign psum_in[98:32]  = psum[98:32] & {67{cyc2}} ;
  assign psum_in[31]     = psum[31] & x2_c2 ;

  assign pcout_in[98:31] = pcout[98:31] & {68{cyc2}} ;
  assign pcout_in[30]    = pcout[30] & x2_c2 ;
  
  dff_s #(68)  psum_dff  (.din(psum_in[98:31]), .clk(clk_enb0), .q(ps[98:31]),
                	.se(se), .si(), .so());
  dff_s #(69)  pcout_dff (.din(pcout_in[98:30]), .clk(clk_enb0), .q(pc[98:30]),
            		.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Adder (104-bit) 
  /////////////////////////////////////////////////////////////////////

  assign 	add_cin = add_co31 & cyc3 ;

  assign {add_co31,addout[31:0]} =   {{1'b0},addin_sum[31:0]} 
		     		   + {{1'b0},addin_cout[30:0],addin_cin} ;


  assign {add_co96,addout[96:32]} =  addin_sum[97:32]	
				  + addin_cout[96:31]
				  + {{65'b0},add_co31} ;

  assign 	addout[103:97] =  accreg[135:129] + {{6'b0},add_co96} ;

  /////////////////////////////////////////////////////////////////////
  // 	Pipe adder outputs  
  /////////////////////////////////////////////////////////////////////

  dff_s  	      co31_dff (.din(add_cin), .clk(clk_enb0), .q(addin_cin),
       			.se(se), .si(), .so());

  dff_s #(104)   out_dff (.din(addout[103:0]), .clk(clk_enb0), .q(out[135:32]),
              		.se(se), .si(), .so());

  dff_s #(32)    pip_dff (.din(out[63:32]), .clk(clk_enb0), .q(out[31:0]),
               		.se(se), .si(), .so());

endmodule // mul64




////////////////////////////////////////////////////////////////////////
//	Sub-moudle for mul64
////////////////////////////////////////////////////////////////////////

module mul_array1 ( cout, sum, a, b0, b1, b2, b3, b4, b5, b6, b7, b8,
     bot, head );

input  bot, head;
output [81:4]  cout;
output [81:0]  sum;
input [2:0]  b6;
input [2:0]  b3;
input [2:0]  b8;
input [2:0]  b2;
input [2:0]  b1;
input [2:0]  b7;
input [63:0]  a;
input [2:0]  b0;
input [2:0]  b4;
input [2:0]  b5;

// Buses in the design

wire  [1:0]  b5n;
wire  [1:0]  b2n;
wire  [68:1]  c0;
wire  [69:0]  s1;
wire  [68:1]  c1;
wire  [69:0]  s2;
wire  [68:1]  c2;
wire  [70:4]  s_1;
wire  [69:2]  s0;
wire  [76:10]  s_2;
wire  [70:2]  c_1;
wire  [76:10]  c_2;
wire  [75:11]  co;

mul_negen p1n ( .b(b5[2:0]), .n1(b5n[1]), .n0(b5n[0]));
mul_negen p0n ( .b(b2[2:0]), .n1(b2n[1]), .n0(b2n[0]));
mul_csa42  sc3_71_ ( .c(s_2[71]), .cin(co[70]), .a(c_1[70]),
     .b(c_2[70]), .cout(co[71]), .sum(sum[71]), .d(s1[65]),
     .carry(cout[71]));
mul_csa42  sc3_75_ ( .c(s_2[75]), .cin(co[74]), .a(1'b0),
     .b(c_2[74]), .cout(co[75]), .sum(sum[75]), .d(s1[69]),
     .carry(cout[75]));
mul_csa42  sc3_74_ ( .c(s_2[74]), .cin(co[73]), .a(1'b0),
     .b(c_2[73]), .cout(co[74]), .sum(sum[74]), .d(s1[68]),
     .carry(cout[74]));
mul_csa42  sc3_73_ ( .c(s_2[73]), .cin(co[72]), .a(1'b0),
     .b(c_2[72]), .cout(co[73]), .sum(sum[73]), .d(s1[67]),
     .carry(cout[73]));
mul_csa42  sc3_72_ ( .c(s_2[72]), .cin(co[71]), .a(1'b0),
     .b(c_2[71]), .cout(co[72]), .sum(sum[72]), .d(s1[66]),
     .carry(cout[72]));
mul_csa42  sc3_76_ ( .c(s_2[76]), .cin(co[75]), .a(1'b0),
     .b(c_2[75]), .cout(), .sum(sum[76]), .d(1'b0),
     .carry(cout[76]));
mul_csa42  sc3_70_ ( .c(s_2[70]), .cin(co[69]), .a(c_1[69]),
     .b(c_2[69]), .cout(co[70]), .sum(sum[70]), .d(s_1[70]),
     .carry(cout[70]));
mul_csa42  sc3_69_ ( .c(s_2[69]), .cin(co[68]), .a(c_1[68]),
     .b(c_2[68]), .cout(co[69]), .sum(sum[69]), .d(s_1[69]),
     .carry(cout[69]));
mul_csa42  sc3_68_ ( .c(s_2[68]), .cin(co[67]), .a(c_1[67]),
     .b(c_2[67]), .cout(co[68]), .sum(sum[68]), .d(s_1[68]),
     .carry(cout[68]));
mul_csa42  sc3_67_ ( .c(s_2[67]), .cin(co[66]), .a(c_1[66]),
     .b(c_2[66]), .cout(co[67]), .sum(sum[67]), .d(s_1[67]),
     .carry(cout[67]));
mul_csa42  sc3_66_ ( .c(s_2[66]), .cin(co[65]), .a(c_1[65]),
     .b(c_2[65]), .cout(co[66]), .sum(sum[66]), .d(s_1[66]),
     .carry(cout[66]));
mul_csa42  sc3_65_ ( .c(s_2[65]), .cin(co[64]), .a(c_1[64]),
     .b(c_2[64]), .cout(co[65]), .sum(sum[65]), .d(s_1[65]),
     .carry(cout[65]));
mul_csa42  sc3_64_ ( .c(s_2[64]), .cin(co[63]), .a(c_1[63]),
     .b(c_2[63]), .cout(co[64]), .sum(sum[64]), .d(s_1[64]),
     .carry(cout[64]));
mul_csa42  sc3_63_ ( .c(s_2[63]), .cin(co[62]), .a(c_1[62]),
     .b(c_2[62]), .cout(co[63]), .sum(sum[63]), .d(s_1[63]),
     .carry(cout[63]));
mul_csa42  sc3_62_ ( .c(s_2[62]), .cin(co[61]), .a(c_1[61]),
     .b(c_2[61]), .cout(co[62]), .sum(sum[62]), .d(s_1[62]),
     .carry(cout[62]));
mul_csa42  sc3_61_ ( .c(s_2[61]), .cin(co[60]), .a(c_1[60]),
     .b(c_2[60]), .cout(co[61]), .sum(sum[61]), .d(s_1[61]),
     .carry(cout[61]));
mul_csa42  sc3_60_ ( .c(s_2[60]), .cin(co[59]), .a(c_1[59]),
     .b(c_2[59]), .cout(co[60]), .sum(sum[60]), .d(s_1[60]),
     .carry(cout[60]));
mul_csa42  sc3_59_ ( .c(s_2[59]), .cin(co[58]), .a(c_1[58]),
     .b(c_2[58]), .cout(co[59]), .sum(sum[59]), .d(s_1[59]),
     .carry(cout[59]));
mul_csa42  sc3_58_ ( .c(s_2[58]), .cin(co[57]), .a(c_1[57]),
     .b(c_2[57]), .cout(co[58]), .sum(sum[58]), .d(s_1[58]),
     .carry(cout[58]));
mul_csa42  sc3_57_ ( .c(s_2[57]), .cin(co[56]), .a(c_1[56]),
     .b(c_2[56]), .cout(co[57]), .sum(sum[57]), .d(s_1[57]),
     .carry(cout[57]));
mul_csa42  sc3_56_ ( .c(s_2[56]), .cin(co[55]), .a(c_1[55]),
     .b(c_2[55]), .cout(co[56]), .sum(sum[56]), .d(s_1[56]),
     .carry(cout[56]));
mul_csa42  sc3_55_ ( .c(s_2[55]), .cin(co[54]), .a(c_1[54]),
     .b(c_2[54]), .cout(co[55]), .sum(sum[55]), .d(s_1[55]),
     .carry(cout[55]));
mul_csa42  sc3_54_ ( .c(s_2[54]), .cin(co[53]), .a(c_1[53]),
     .b(c_2[53]), .cout(co[54]), .sum(sum[54]), .d(s_1[54]),
     .carry(cout[54]));
mul_csa42  sc3_53_ ( .c(s_2[53]), .cin(co[52]), .a(c_1[52]),
     .b(c_2[52]), .cout(co[53]), .sum(sum[53]), .d(s_1[53]),
     .carry(cout[53]));
mul_csa42  sc3_52_ ( .c(s_2[52]), .cin(co[51]), .a(c_1[51]),
     .b(c_2[51]), .cout(co[52]), .sum(sum[52]), .d(s_1[52]),
     .carry(cout[52]));
mul_csa42  sc3_51_ ( .c(s_2[51]), .cin(co[50]), .a(c_1[50]),
     .b(c_2[50]), .cout(co[51]), .sum(sum[51]), .d(s_1[51]),
     .carry(cout[51]));
mul_csa42  sc3_50_ ( .c(s_2[50]), .cin(co[49]), .a(c_1[49]),
     .b(c_2[49]), .cout(co[50]), .sum(sum[50]), .d(s_1[50]),
     .carry(cout[50]));
mul_csa42  sc3_49_ ( .c(s_2[49]), .cin(co[48]), .a(c_1[48]),
     .b(c_2[48]), .cout(co[49]), .sum(sum[49]), .d(s_1[49]),
     .carry(cout[49]));
mul_csa42  sc3_48_ ( .c(s_2[48]), .cin(co[47]), .a(c_1[47]),
     .b(c_2[47]), .cout(co[48]), .sum(sum[48]), .d(s_1[48]),
     .carry(cout[48]));
mul_csa42  sc3_47_ ( .c(s_2[47]), .cin(co[46]), .a(c_1[46]),
     .b(c_2[46]), .cout(co[47]), .sum(sum[47]), .d(s_1[47]),
     .carry(cout[47]));
mul_csa42  sc3_46_ ( .c(s_2[46]), .cin(co[45]), .a(c_1[45]),
     .b(c_2[45]), .cout(co[46]), .sum(sum[46]), .d(s_1[46]),
     .carry(cout[46]));
mul_csa42  sc3_45_ ( .c(s_2[45]), .cin(co[44]), .a(c_1[44]),
     .b(c_2[44]), .cout(co[45]), .sum(sum[45]), .d(s_1[45]),
     .carry(cout[45]));
mul_csa42  sc3_44_ ( .c(s_2[44]), .cin(co[43]), .a(c_1[43]),
     .b(c_2[43]), .cout(co[44]), .sum(sum[44]), .d(s_1[44]),
     .carry(cout[44]));
mul_csa42  sc3_43_ ( .c(s_2[43]), .cin(co[42]), .a(c_1[42]),
     .b(c_2[42]), .cout(co[43]), .sum(sum[43]), .d(s_1[43]),
     .carry(cout[43]));
mul_csa42  sc3_42_ ( .c(s_2[42]), .cin(co[41]), .a(c_1[41]),
     .b(c_2[41]), .cout(co[42]), .sum(sum[42]), .d(s_1[42]),
     .carry(cout[42]));
mul_csa42  sc3_41_ ( .c(s_2[41]), .cin(co[40]), .a(c_1[40]),
     .b(c_2[40]), .cout(co[41]), .sum(sum[41]), .d(s_1[41]),
     .carry(cout[41]));
mul_csa42  sc3_40_ ( .c(s_2[40]), .cin(co[39]), .a(c_1[39]),
     .b(c_2[39]), .cout(co[40]), .sum(sum[40]), .d(s_1[40]),
     .carry(cout[40]));
mul_csa42  sc3_39_ ( .c(s_2[39]), .cin(co[38]), .a(c_1[38]),
     .b(c_2[38]), .cout(co[39]), .sum(sum[39]), .d(s_1[39]),
     .carry(cout[39]));
mul_csa42  sc3_38_ ( .c(s_2[38]), .cin(co[37]), .a(c_1[37]),
     .b(c_2[37]), .cout(co[38]), .sum(sum[38]), .d(s_1[38]),
     .carry(cout[38]));
mul_csa42  sc3_37_ ( .c(s_2[37]), .cin(co[36]), .a(c_1[36]),
     .b(c_2[36]), .cout(co[37]), .sum(sum[37]), .d(s_1[37]),
     .carry(cout[37]));
mul_csa42  sc3_36_ ( .c(s_2[36]), .cin(co[35]), .a(c_1[35]),
     .b(c_2[35]), .cout(co[36]), .sum(sum[36]), .d(s_1[36]),
     .carry(cout[36]));
mul_csa42  sc3_35_ ( .c(s_2[35]), .cin(co[34]), .a(c_1[34]),
     .b(c_2[34]), .cout(co[35]), .sum(sum[35]), .d(s_1[35]),
     .carry(cout[35]));
mul_csa42  sc3_34_ ( .c(s_2[34]), .cin(co[33]), .a(c_1[33]),
     .b(c_2[33]), .cout(co[34]), .sum(sum[34]), .d(s_1[34]),
     .carry(cout[34]));
mul_csa42  sc3_33_ ( .c(s_2[33]), .cin(co[32]), .a(c_1[32]),
     .b(c_2[32]), .cout(co[33]), .sum(sum[33]), .d(s_1[33]),
     .carry(cout[33]));
mul_csa42  sc3_32_ ( .c(s_2[32]), .cin(co[31]), .a(c_1[31]),
     .b(c_2[31]), .cout(co[32]), .sum(sum[32]), .d(s_1[32]),
     .carry(cout[32]));
mul_csa42  sc3_31_ ( .c(s_2[31]), .cin(co[30]), .a(c_1[30]),
     .b(c_2[30]), .cout(co[31]), .sum(sum[31]), .d(s_1[31]),
     .carry(cout[31]));
mul_csa42  sc3_30_ ( .c(s_2[30]), .cin(co[29]), .a(c_1[29]),
     .b(c_2[29]), .cout(co[30]), .sum(sum[30]), .d(s_1[30]),
     .carry(cout[30]));
mul_csa42  sc3_29_ ( .c(s_2[29]), .cin(co[28]), .a(c_1[28]),
     .b(c_2[28]), .cout(co[29]), .sum(sum[29]), .d(s_1[29]),
     .carry(cout[29]));
mul_csa42  sc3_28_ ( .c(s_2[28]), .cin(co[27]), .a(c_1[27]),
     .b(c_2[27]), .cout(co[28]), .sum(sum[28]), .d(s_1[28]),
     .carry(cout[28]));
mul_csa42  sc3_27_ ( .c(s_2[27]), .cin(co[26]), .a(c_1[26]),
     .b(c_2[26]), .cout(co[27]), .sum(sum[27]), .d(s_1[27]),
     .carry(cout[27]));
mul_csa42  sc3_26_ ( .c(s_2[26]), .cin(co[25]), .a(c_1[25]),
     .b(c_2[25]), .cout(co[26]), .sum(sum[26]), .d(s_1[26]),
     .carry(cout[26]));
mul_csa42  sc3_25_ ( .c(s_2[25]), .cin(co[24]), .a(c_1[24]),
     .b(c_2[24]), .cout(co[25]), .sum(sum[25]), .d(s_1[25]),
     .carry(cout[25]));
mul_csa42  sc3_24_ ( .c(s_2[24]), .cin(co[23]), .a(c_1[23]),
     .b(c_2[23]), .cout(co[24]), .sum(sum[24]), .d(s_1[24]),
     .carry(cout[24]));
mul_csa42  sc3_23_ ( .c(s_2[23]), .cin(co[22]), .a(c_1[22]),
     .b(c_2[22]), .cout(co[23]), .sum(sum[23]), .d(s_1[23]),
     .carry(cout[23]));
mul_csa42  sc3_22_ ( .c(s_2[22]), .cin(co[21]), .a(c_1[21]),
     .b(c_2[21]), .cout(co[22]), .sum(sum[22]), .d(s_1[22]),
     .carry(cout[22]));
mul_csa42  sc3_21_ ( .c(s_2[21]), .cin(co[20]), .a(c_1[20]),
     .b(c_2[20]), .cout(co[21]), .sum(sum[21]), .d(s_1[21]),
     .carry(cout[21]));
mul_csa42  sc3_20_ ( .c(s_2[20]), .cin(co[19]), .a(c_1[19]),
     .b(c_2[19]), .cout(co[20]), .sum(sum[20]), .d(s_1[20]),
     .carry(cout[20]));
mul_csa42  sc3_19_ ( .c(s_2[19]), .cin(co[18]), .a(c_1[18]),
     .b(c_2[18]), .cout(co[19]), .sum(sum[19]), .d(s_1[19]),
     .carry(cout[19]));
mul_csa42  sc3_18_ ( .c(s_2[18]), .cin(co[17]), .a(c_1[17]),
     .b(c_2[17]), .cout(co[18]), .sum(sum[18]), .d(s_1[18]),
     .carry(cout[18]));
mul_csa42  sc3_17_ ( .c(s_2[17]), .cin(co[16]), .a(c_1[16]),
     .b(c_2[16]), .cout(co[17]), .sum(sum[17]), .d(s_1[17]),
     .carry(cout[17]));
mul_csa42  sc3_16_ ( .c(s_2[16]), .cin(co[15]), .a(c_1[15]),
     .b(c_2[15]), .cout(co[16]), .sum(sum[16]), .d(s_1[16]),
     .carry(cout[16]));
mul_csa42  sc3_15_ ( .c(s_2[15]), .cin(co[14]), .a(c_1[14]),
     .b(c_2[14]), .cout(co[15]), .sum(sum[15]), .d(s_1[15]),
     .carry(cout[15]));
mul_csa42  sc3_14_ ( .c(s_2[14]), .cin(co[13]), .a(c_1[13]),
     .b(c_2[13]), .cout(co[14]), .sum(sum[14]), .d(s_1[14]),
     .carry(cout[14]));
mul_csa42  sc3_13_ ( .c(s_2[13]), .cin(co[12]), .a(c_1[12]),
     .b(c_2[12]), .cout(co[13]), .sum(sum[13]), .d(s_1[13]),
     .carry(cout[13]));
mul_csa42  sc3_12_ ( .c(s_2[12]), .cin(co[11]), .a(c_1[11]),
     .b(c_2[11]), .cout(co[12]), .sum(sum[12]), .d(s_1[12]),
     .carry(cout[12]));
mul_csa42  sc3_11_ ( .c(s_2[11]), .cin(1'b0),
     .a(c_1[10]), .b(c_2[10]), .cout(co[11]), .sum(sum[11]),
     .d(s_1[11]), .carry(cout[11]));
mul_csa32  sc2_2_70_ ( .c(c1[63]), .b(c2[57]), .a(s2[58]),
     .cout(c_2[70]), .sum(s_2[70]));
mul_csa32  sc2_2_69_ ( .c(c1[62]), .b(c2[56]), .a(s2[57]),
     .cout(c_2[69]), .sum(s_2[69]));
mul_csa32  sc2_2_68_ ( .c(c1[61]), .b(c2[55]), .a(s2[56]),
     .cout(c_2[68]), .sum(s_2[68]));
mul_csa32  sc2_2_67_ ( .c(c1[60]), .b(c2[54]), .a(s2[55]),
     .cout(c_2[67]), .sum(s_2[67]));
mul_csa32  sc2_2_66_ ( .c(c1[59]), .b(c2[53]), .a(s2[54]),
     .cout(c_2[66]), .sum(s_2[66]));
mul_csa32  sc2_2_65_ ( .c(c1[58]), .b(c2[52]), .a(s2[53]),
     .cout(c_2[65]), .sum(s_2[65]));
mul_csa32  sc2_2_64_ ( .c(c1[57]), .b(c2[51]), .a(s2[52]),
     .cout(c_2[64]), .sum(s_2[64]));
mul_csa32  sc2_2_63_ ( .c(c1[56]), .b(c2[50]), .a(s2[51]),
     .cout(c_2[63]), .sum(s_2[63]));
mul_csa32  sc2_2_62_ ( .c(c1[55]), .b(c2[49]), .a(s2[50]),
     .cout(c_2[62]), .sum(s_2[62]));
mul_csa32  sc2_2_61_ ( .c(c1[54]), .b(c2[48]), .a(s2[49]),
     .cout(c_2[61]), .sum(s_2[61]));
mul_csa32  sc2_2_60_ ( .c(c1[53]), .b(c2[47]), .a(s2[48]),
     .cout(c_2[60]), .sum(s_2[60]));
mul_csa32  sc2_2_59_ ( .c(c1[52]), .b(c2[46]), .a(s2[47]),
     .cout(c_2[59]), .sum(s_2[59]));
mul_csa32  sc2_2_58_ ( .c(c1[51]), .b(c2[45]), .a(s2[46]),
     .cout(c_2[58]), .sum(s_2[58]));
mul_csa32  sc2_2_57_ ( .c(c1[50]), .b(c2[44]), .a(s2[45]),
     .cout(c_2[57]), .sum(s_2[57]));
mul_csa32  sc2_2_56_ ( .c(c1[49]), .b(c2[43]), .a(s2[44]),
     .cout(c_2[56]), .sum(s_2[56]));
mul_csa32  sc2_2_55_ ( .c(c1[48]), .b(c2[42]), .a(s2[43]),
     .cout(c_2[55]), .sum(s_2[55]));
mul_csa32  sc2_2_54_ ( .c(c1[47]), .b(c2[41]), .a(s2[42]),
     .cout(c_2[54]), .sum(s_2[54]));
mul_csa32  sc2_2_53_ ( .c(c1[46]), .b(c2[40]), .a(s2[41]),
     .cout(c_2[53]), .sum(s_2[53]));
mul_csa32  sc2_2_52_ ( .c(c1[45]), .b(c2[39]), .a(s2[40]),
     .cout(c_2[52]), .sum(s_2[52]));
mul_csa32  sc2_2_51_ ( .c(c1[44]), .b(c2[38]), .a(s2[39]),
     .cout(c_2[51]), .sum(s_2[51]));
mul_csa32  sc2_2_50_ ( .c(c1[43]), .b(c2[37]), .a(s2[38]),
     .cout(c_2[50]), .sum(s_2[50]));
mul_csa32  sc2_2_49_ ( .c(c1[42]), .b(c2[36]), .a(s2[37]),
     .cout(c_2[49]), .sum(s_2[49]));
mul_csa32  sc2_2_48_ ( .c(c1[41]), .b(c2[35]), .a(s2[36]),
     .cout(c_2[48]), .sum(s_2[48]));
mul_csa32  sc2_2_47_ ( .c(c1[40]), .b(c2[34]), .a(s2[35]),
     .cout(c_2[47]), .sum(s_2[47]));
mul_csa32  sc2_2_46_ ( .c(c1[39]), .b(c2[33]), .a(s2[34]),
     .cout(c_2[46]), .sum(s_2[46]));
mul_csa32  sc2_2_45_ ( .c(c1[38]), .b(c2[32]), .a(s2[33]),
     .cout(c_2[45]), .sum(s_2[45]));
mul_csa32  sc2_2_44_ ( .c(c1[37]), .b(c2[31]), .a(s2[32]),
     .cout(c_2[44]), .sum(s_2[44]));
mul_csa32  sc2_2_43_ ( .c(c1[36]), .b(c2[30]), .a(s2[31]),
     .cout(c_2[43]), .sum(s_2[43]));
mul_csa32  sc2_2_42_ ( .c(c1[35]), .b(c2[29]), .a(s2[30]),
     .cout(c_2[42]), .sum(s_2[42]));
mul_csa32  sc2_2_41_ ( .c(c1[34]), .b(c2[28]), .a(s2[29]),
     .cout(c_2[41]), .sum(s_2[41]));
mul_csa32  sc2_2_40_ ( .c(c1[33]), .b(c2[27]), .a(s2[28]),
     .cout(c_2[40]), .sum(s_2[40]));
mul_csa32  sc2_2_39_ ( .c(c1[32]), .b(c2[26]), .a(s2[27]),
     .cout(c_2[39]), .sum(s_2[39]));
mul_csa32  sc2_2_38_ ( .c(c1[31]), .b(c2[25]), .a(s2[26]),
     .cout(c_2[38]), .sum(s_2[38]));
mul_csa32  sc2_2_37_ ( .c(c1[30]), .b(c2[24]), .a(s2[25]),
     .cout(c_2[37]), .sum(s_2[37]));
mul_csa32  sc2_2_36_ ( .c(c1[29]), .b(c2[23]), .a(s2[24]),
     .cout(c_2[36]), .sum(s_2[36]));
mul_csa32  sc2_2_35_ ( .c(c1[28]), .b(c2[22]), .a(s2[23]),
     .cout(c_2[35]), .sum(s_2[35]));
mul_csa32  sc2_2_34_ ( .c(c1[27]), .b(c2[21]), .a(s2[22]),
     .cout(c_2[34]), .sum(s_2[34]));
mul_csa32  sc2_2_33_ ( .c(c1[26]), .b(c2[20]), .a(s2[21]),
     .cout(c_2[33]), .sum(s_2[33]));
mul_csa32  sc2_2_32_ ( .c(c1[25]), .b(c2[19]), .a(s2[20]),
     .cout(c_2[32]), .sum(s_2[32]));
mul_csa32  sc2_2_31_ ( .c(c1[24]), .b(c2[18]), .a(s2[19]),
     .cout(c_2[31]), .sum(s_2[31]));
mul_csa32  sc2_2_30_ ( .c(c1[23]), .b(c2[17]), .a(s2[18]),
     .cout(c_2[30]), .sum(s_2[30]));
mul_csa32  sc2_2_29_ ( .c(c1[22]), .b(c2[16]), .a(s2[17]),
     .cout(c_2[29]), .sum(s_2[29]));
mul_csa32  sc2_2_28_ ( .c(c1[21]), .b(c2[15]), .a(s2[16]),
     .cout(c_2[28]), .sum(s_2[28]));
mul_csa32  sc2_2_27_ ( .c(c1[20]), .b(c2[14]), .a(s2[15]),
     .cout(c_2[27]), .sum(s_2[27]));
mul_csa32  sc2_2_26_ ( .c(c1[19]), .b(c2[13]), .a(s2[14]),
     .cout(c_2[26]), .sum(s_2[26]));
mul_csa32  sc2_2_25_ ( .c(c1[18]), .b(c2[12]), .a(s2[13]),
     .cout(c_2[25]), .sum(s_2[25]));
mul_csa32  sc2_2_24_ ( .c(c1[17]), .b(c2[11]), .a(s2[12]),
     .cout(c_2[24]), .sum(s_2[24]));
mul_csa32  sc2_2_23_ ( .c(c1[16]), .b(c2[10]), .a(s2[11]),
     .cout(c_2[23]), .sum(s_2[23]));
mul_csa32  sc2_2_22_ ( .c(c1[15]), .b(c2[9]), .a(s2[10]),
     .cout(c_2[22]), .sum(s_2[22]));
mul_csa32  sc2_2_21_ ( .c(c1[14]), .b(c2[8]), .a(s2[9]),
     .cout(c_2[21]), .sum(s_2[21]));
mul_csa32  sc2_2_20_ ( .c(c1[13]), .b(c2[7]), .a(s2[8]),
     .cout(c_2[20]), .sum(s_2[20]));
mul_csa32  sc2_2_19_ ( .c(c1[12]), .b(c2[6]), .a(s2[7]),
     .cout(c_2[19]), .sum(s_2[19]));
mul_csa32  sc2_2_18_ ( .c(c1[11]), .b(c2[5]), .a(s2[6]),
     .cout(c_2[18]), .sum(s_2[18]));
mul_csa32  sc2_2_17_ ( .c(c1[10]), .b(c2[4]), .a(s2[5]),
     .cout(c_2[17]), .sum(s_2[17]));
mul_csa32  sc2_2_16_ ( .c(c1[9]), .b(c2[3]), .a(s2[4]),
     .cout(c_2[16]), .sum(s_2[16]));
mul_csa32  sc2_2_15_ ( .c(c1[8]), .b(c2[2]), .a(s2[3]),
     .cout(c_2[15]), .sum(s_2[15]));
mul_csa32  sc2_2_14_ ( .c(c1[7]), .b(c2[1]), .a(s2[2]),
     .cout(c_2[14]), .sum(s_2[14]));
mul_csa32  sc2_2_13_ ( .c(c1[6]), .b(s1[7]), .a(s2[1]),
     .cout(c_2[13]), .sum(s_2[13]));
mul_csa32  sc2_2_12_ ( .c(c1[5]), .b(s1[6]), .a(s2[0]),
     .cout(c_2[12]), .sum(s_2[12]));
mul_csa32  sc2_2_11_ ( .c(c1[4]), .b(s1[5]), .a(b5n[1]),
     .cout(c_2[11]), .sum(s_2[11]));
mul_csa32  sc2_2_10_ ( .c(c1[3]), .b(s1[4]), .a(b5n[0]),
     .cout(c_2[10]), .sum(s_2[10]));
mul_csa32  sc2_2_76_ ( .c(1'b1), .b(c2[63]), .a(s2[64]),
     .cout(c_2[76]), .sum(s_2[76]));
mul_csa32  sc2_2_77_ ( .c(c_2[76]), .b(c2[64]), .a(s2[65]),
     .cout(cout[77]), .sum(sum[77]));
mul_csa32  sc2_1_9_ ( .c(s1[3]), .b(c0[8]), .a(s0[9]), .cout(c_1[9]),
     .sum(s_1[9]));
mul_csa32  sc2_1_8_ ( .c(s1[2]), .b(c0[7]), .a(s0[8]), .cout(c_1[8]),
     .sum(s_1[8]));
mul_csa32  sc2_1_3_ ( .c(c_1[2]), .b(c0[2]), .a(s0[3]),
     .cout(c_1[3]), .sum(sum[3]));
mul_csa32  sc3_10_ ( .c(s_2[10]), .b(s_1[10]), .a(c_1[9]),
     .cout(cout[10]), .sum(sum[10]));
mul_csa32  sc3_9_ ( .c(c1[2]), .sum(sum[9]), .cout(cout[9]),
     .a(c_1[8]), .b(s_1[9]));
mul_csa32  sc3_8_ ( .c(c1[1]), .sum(sum[8]), .cout(cout[8]),
     .a(c_1[7]), .b(s_1[8]));
mul_csa32  sc2_2_71_ ( .c(c1[64]), .b(c2[58]), .a(s2[59]),
     .cout(c_2[71]), .sum(s_2[71]));
mul_csa32  sc2_2_75_ ( .c(c1[68]), .b(c2[62]), .a(s2[63]),
     .cout(c_2[75]), .sum(s_2[75]));
mul_csa32  sc2_2_74_ ( .c(c1[67]), .b(c2[61]), .a(s2[62]),
     .cout(c_2[74]), .sum(s_2[74]));
mul_csa32  sc2_2_73_ ( .c(c1[66]), .b(c2[60]), .a(s2[61]),
     .cout(c_2[73]), .sum(s_2[73]));
mul_csa32  sc2_2_72_ ( .c(c1[65]), .b(c2[59]), .a(s2[60]),
     .cout(c_2[72]), .sum(s_2[72]));
mul_csa32  sc2_1_69_ ( .c(s1[63]), .sum(s_1[69]), .cout(c_1[69]),
     .a(s0[69]), .b(c0[68]));
mul_csa32  sc2_1_68_ ( .c(s1[62]), .sum(s_1[68]), .cout(c_1[68]),
     .a(s0[68]), .b(c0[67]));
mul_csa32  sc2_1_67_ ( .c(s1[61]), .sum(s_1[67]), .cout(c_1[67]),
     .a(s0[67]), .b(c0[66]));
mul_csa32  sc2_1_66_ ( .c(s1[60]), .sum(s_1[66]), .cout(c_1[66]),
     .a(s0[66]), .b(c0[65]));
mul_csa32  sc2_1_65_ ( .c(s1[59]), .sum(s_1[65]), .cout(c_1[65]),
     .a(s0[65]), .b(c0[64]));
mul_csa32  sc2_1_64_ ( .c(s1[58]), .sum(s_1[64]), .cout(c_1[64]),
     .a(s0[64]), .b(c0[63]));
mul_csa32  sc2_1_63_ ( .c(s1[57]), .sum(s_1[63]), .cout(c_1[63]),
     .a(s0[63]), .b(c0[62]));
mul_csa32  sc2_1_62_ ( .c(s1[56]), .sum(s_1[62]), .cout(c_1[62]),
     .a(s0[62]), .b(c0[61]));
mul_csa32  sc2_1_61_ ( .c(s1[55]), .sum(s_1[61]), .cout(c_1[61]),
     .a(s0[61]), .b(c0[60]));
mul_csa32  sc2_1_60_ ( .c(s1[54]), .sum(s_1[60]), .cout(c_1[60]),
     .a(s0[60]), .b(c0[59]));
mul_csa32  sc2_1_59_ ( .c(s1[53]), .sum(s_1[59]), .cout(c_1[59]),
     .a(s0[59]), .b(c0[58]));
mul_csa32  sc2_1_58_ ( .c(s1[52]), .sum(s_1[58]), .cout(c_1[58]),
     .a(s0[58]), .b(c0[57]));
mul_csa32  sc2_1_57_ ( .c(s1[51]), .sum(s_1[57]), .cout(c_1[57]),
     .a(s0[57]), .b(c0[56]));
mul_csa32  sc2_1_56_ ( .c(s1[50]), .sum(s_1[56]), .cout(c_1[56]),
     .a(s0[56]), .b(c0[55]));
mul_csa32  sc2_1_55_ ( .c(s1[49]), .sum(s_1[55]), .cout(c_1[55]),
     .a(s0[55]), .b(c0[54]));
mul_csa32  sc2_1_54_ ( .c(s1[48]), .sum(s_1[54]), .cout(c_1[54]),
     .a(s0[54]), .b(c0[53]));
mul_csa32  sc2_1_53_ ( .c(s1[47]), .sum(s_1[53]), .cout(c_1[53]),
     .a(s0[53]), .b(c0[52]));
mul_csa32  sc2_1_52_ ( .c(s1[46]), .sum(s_1[52]), .cout(c_1[52]),
     .a(s0[52]), .b(c0[51]));
mul_csa32  sc2_1_51_ ( .c(s1[45]), .sum(s_1[51]), .cout(c_1[51]),
     .a(s0[51]), .b(c0[50]));
mul_csa32  sc2_1_50_ ( .c(s1[44]), .sum(s_1[50]), .cout(c_1[50]),
     .a(s0[50]), .b(c0[49]));
mul_csa32  sc2_1_49_ ( .c(s1[43]), .sum(s_1[49]), .cout(c_1[49]),
     .a(s0[49]), .b(c0[48]));
mul_csa32  sc2_1_48_ ( .c(s1[42]), .sum(s_1[48]), .cout(c_1[48]),
     .a(s0[48]), .b(c0[47]));
mul_csa32  sc2_1_47_ ( .c(s1[41]), .sum(s_1[47]), .cout(c_1[47]),
     .a(s0[47]), .b(c0[46]));
mul_csa32  sc2_1_46_ ( .c(s1[40]), .sum(s_1[46]), .cout(c_1[46]),
     .a(s0[46]), .b(c0[45]));
mul_csa32  sc2_1_45_ ( .c(s1[39]), .sum(s_1[45]), .cout(c_1[45]),
     .a(s0[45]), .b(c0[44]));
mul_csa32  sc2_1_44_ ( .c(s1[38]), .sum(s_1[44]), .cout(c_1[44]),
     .a(s0[44]), .b(c0[43]));
mul_csa32  sc2_1_43_ ( .c(s1[37]), .sum(s_1[43]), .cout(c_1[43]),
     .a(s0[43]), .b(c0[42]));
mul_csa32  sc2_1_42_ ( .c(s1[36]), .sum(s_1[42]), .cout(c_1[42]),
     .a(s0[42]), .b(c0[41]));
mul_csa32  sc2_1_41_ ( .c(s1[35]), .sum(s_1[41]), .cout(c_1[41]),
     .a(s0[41]), .b(c0[40]));
mul_csa32  sc2_1_40_ ( .c(s1[34]), .sum(s_1[40]), .cout(c_1[40]),
     .a(s0[40]), .b(c0[39]));
mul_csa32  sc2_1_39_ ( .c(s1[33]), .sum(s_1[39]), .cout(c_1[39]),
     .a(s0[39]), .b(c0[38]));
mul_csa32  sc2_1_38_ ( .c(s1[32]), .sum(s_1[38]), .cout(c_1[38]),
     .a(s0[38]), .b(c0[37]));
mul_csa32  sc2_1_37_ ( .c(s1[31]), .sum(s_1[37]), .cout(c_1[37]),
     .a(s0[37]), .b(c0[36]));
mul_csa32  sc2_1_36_ ( .c(s1[30]), .sum(s_1[36]), .cout(c_1[36]),
     .a(s0[36]), .b(c0[35]));
mul_csa32  sc2_1_35_ ( .c(s1[29]), .sum(s_1[35]), .cout(c_1[35]),
     .a(s0[35]), .b(c0[34]));
mul_csa32  sc2_1_34_ ( .c(s1[28]), .sum(s_1[34]), .cout(c_1[34]),
     .a(s0[34]), .b(c0[33]));
mul_csa32  sc2_1_33_ ( .c(s1[27]), .sum(s_1[33]), .cout(c_1[33]),
     .a(s0[33]), .b(c0[32]));
mul_csa32  sc2_1_32_ ( .c(s1[26]), .sum(s_1[32]), .cout(c_1[32]),
     .a(s0[32]), .b(c0[31]));
mul_csa32  sc2_1_31_ ( .c(s1[25]), .sum(s_1[31]), .cout(c_1[31]),
     .a(s0[31]), .b(c0[30]));
mul_csa32  sc2_1_30_ ( .c(s1[24]), .sum(s_1[30]), .cout(c_1[30]),
     .a(s0[30]), .b(c0[29]));
mul_csa32  sc2_1_29_ ( .c(s1[23]), .sum(s_1[29]), .cout(c_1[29]),
     .a(s0[29]), .b(c0[28]));
mul_csa32  sc2_1_28_ ( .c(s1[22]), .sum(s_1[28]), .cout(c_1[28]),
     .a(s0[28]), .b(c0[27]));
mul_csa32  sc2_1_27_ ( .c(s1[21]), .sum(s_1[27]), .cout(c_1[27]),
     .a(s0[27]), .b(c0[26]));
mul_csa32  sc2_1_26_ ( .c(s1[20]), .sum(s_1[26]), .cout(c_1[26]),
     .a(s0[26]), .b(c0[25]));
mul_csa32  sc2_1_25_ ( .c(s1[19]), .sum(s_1[25]), .cout(c_1[25]),
     .a(s0[25]), .b(c0[24]));
mul_csa32  sc2_1_24_ ( .c(s1[18]), .sum(s_1[24]), .cout(c_1[24]),
     .a(s0[24]), .b(c0[23]));
mul_csa32  sc2_1_23_ ( .c(s1[17]), .sum(s_1[23]), .cout(c_1[23]),
     .a(s0[23]), .b(c0[22]));
mul_csa32  sc2_1_22_ ( .c(s1[16]), .sum(s_1[22]), .cout(c_1[22]),
     .a(s0[22]), .b(c0[21]));
mul_csa32  sc2_1_21_ ( .c(s1[15]), .sum(s_1[21]), .cout(c_1[21]),
     .a(s0[21]), .b(c0[20]));
mul_csa32  sc2_1_20_ ( .c(s1[14]), .sum(s_1[20]), .cout(c_1[20]),
     .a(s0[20]), .b(c0[19]));
mul_csa32  sc2_1_19_ ( .c(s1[13]), .sum(s_1[19]), .cout(c_1[19]),
     .a(s0[19]), .b(c0[18]));
mul_csa32  sc2_1_18_ ( .c(s1[12]), .sum(s_1[18]), .cout(c_1[18]),
     .a(s0[18]), .b(c0[17]));
mul_csa32  sc2_1_17_ ( .c(s1[11]), .sum(s_1[17]), .cout(c_1[17]),
     .a(s0[17]), .b(c0[16]));
mul_csa32  sc2_1_16_ ( .c(s1[10]), .sum(s_1[16]), .cout(c_1[16]),
     .a(s0[16]), .b(c0[15]));
mul_csa32  sc2_1_15_ ( .c(s1[9]), .sum(s_1[15]), .cout(c_1[15]),
     .a(s0[15]), .b(c0[14]));
mul_csa32  sc2_1_14_ ( .c(s1[8]), .sum(s_1[14]), .cout(c_1[14]),
     .a(s0[14]), .b(c0[13]));
mul_csa32  sc2_1_7_ ( .c(s1[1]), .b(c0[6]), .a(s0[7]), .cout(c_1[7]),
     .sum(s_1[7]));
mul_csa32  sc2_1_6_ ( .c(s1[0]), .b(c0[5]), .a(s0[6]), .cout(c_1[6]),
     .sum(s_1[6]));
mul_csa32  sc2_1_5_ ( .c(b2n[1]), .b(c0[4]), .a(s0[5]),
     .cout(c_1[5]), .sum(s_1[5]));
mul_csa32  sc2_1_4_ ( .c(b2n[0]), .b(c0[3]), .a(s0[4]),
     .cout(c_1[4]), .sum(s_1[4]));
mul_ha sc2_1_10_ ( .sum(s_1[10]), .cout(c_1[10]), .a(s0[10]),
     .b(c0[9]));
mul_ha sc3_7_ ( .sum(sum[7]), .cout(cout[7]), .a(c_1[6]),
     .b(s_1[7]));
mul_ha sc3_6_ ( .sum(sum[6]), .cout(cout[6]), .a(c_1[5]),
     .b(s_1[6]));
mul_ha sc3_5_ ( .sum(sum[5]), .cout(cout[5]), .a(c_1[4]),
     .b(s_1[5]));
mul_ha sc3_4_ ( .sum(sum[4]), .cout(cout[4]), .a(c_1[3]),
     .b(s_1[4]));
mul_ha sc2_2_81_ ( .sum(sum[81]), .cout(cout[81]), .a(s2[69]),
     .b(c2[68]));
mul_ha sc2_2_80_ ( .sum(sum[80]), .cout(cout[80]), .a(s2[68]),
     .b(c2[67]));
mul_ha sc2_2_79_ ( .sum(sum[79]), .cout(cout[79]), .a(s2[67]),
     .b(c2[66]));
mul_ha sc2_2_78_ ( .sum(sum[78]), .cout(cout[78]), .a(s2[66]),
     .b(c2[65]));
mul_ha sc2_1_70_ ( .sum(s_1[70]), .cout(c_1[70]),
     .a(1'b1), .b(s1[64]));
mul_ha sc2_1_2_ ( .sum(sum[2]), .cout(c_1[2]), .a(s0[2]), .b(c0[1]));
mul_ha sc2_1_13_ ( .sum(s_1[13]), .cout(c_1[13]), .a(s0[13]),
     .b(c0[12]));
mul_ha sc2_1_12_ ( .sum(s_1[12]), .cout(c_1[12]), .a(s0[12]),
     .b(c0[11]));
mul_ha sc2_1_11_ ( .sum(s_1[11]), .cout(c_1[11]), .a(s0[11]),
     .b(c0[10]));
mul_ppgenrow3 I2 ( .head(1'b0), .bot(bot), .b2(b8[2:0]),
     .b1(b7[2:0]), .b0(b6[2:0]), .a(a[63:0]), .sum(s2[69:0]),
     .cout(c2[68:1]));
mul_ppgenrow3 I1 ( .head(1'b0), .bot(1'b1),
     .b2(b5[2:0]), .b1(b4[2:0]), .b0(b3[2:0]), .a(a[63:0]),
     .sum(s1[69:0]), .cout(c1[68:1]));
mul_ppgenrow3 I0 ( .head(head), .bot(1'b1), .b2(b2[2:0]),
     .b1(b1[2:0]), .b0(b0[2:0]), .a(a[63:0]), .sum({s0[69:2],
     sum[1:0]}), .cout(c0[68:1]));

endmodule // mul_array1

module mul_array2 ( pcout, pcoutx2, psum, psumx2, a0c, a0s, a1c, a1s,
     areg, bot, pc, ps, x2 );

output  pcoutx2, psumx2;
input  bot, x2;
output [98:0]  psum;
output [98:0]  pcout;
input [81:4]  a1c;
input [98:30]  pc;
input [98:31]  ps;
input [81:0]  a0s;
input [96:0]  areg;
input [81:0]  a1s;
input [81:4]  a0c;

// Buses in the design
wire  [81:15]  s3;
wire  [81:15]  c3;
wire  [96:0]  ain;
wire  [67:20]  co;
wire  [82:0]  s1;
wire  [96:0]  c2;
wire  [82:0]  c1;
wire  [96:0]  s2;
wire	      ainx2, s1x2, c1x2;

mul_mux2 sh_82_ ( .d1(areg[83]), .z(ain[82]), .d0(areg[82]), .s(x2));
mul_mux2 sh_68_ ( .d1(areg[69]), .z(ain[68]), .d0(areg[68]), .s(x2));
mul_mux2 sh_67_ ( .d1(areg[68]), .z(ain[67]), .d0(areg[67]), .s(x2));
mul_mux2 sh_66_ ( .d1(areg[67]), .z(ain[66]), .d0(areg[66]), .s(x2));
mul_mux2 sh_65_ ( .d1(areg[66]), .z(ain[65]), .d0(areg[65]), .s(x2));
mul_mux2 sh_64_ ( .d1(areg[65]), .z(ain[64]), .d0(areg[64]), .s(x2));
mul_mux2 sh_63_ ( .d1(areg[64]), .z(ain[63]), .d0(areg[63]), .s(x2));
mul_mux2 sh_62_ ( .d1(areg[63]), .z(ain[62]), .d0(areg[62]), .s(x2));
mul_mux2 sh_61_ ( .d1(areg[62]), .z(ain[61]), .d0(areg[61]), .s(x2));
mul_mux2 sh_60_ ( .d1(areg[61]), .z(ain[60]), .d0(areg[60]), .s(x2));
mul_mux2 sh_59_ ( .d1(areg[60]), .z(ain[59]), .d0(areg[59]), .s(x2));
mul_mux2 sh_58_ ( .d1(areg[59]), .z(ain[58]), .d0(areg[58]), .s(x2));
mul_mux2 sh_57_ ( .d1(areg[58]), .z(ain[57]), .d0(areg[57]), .s(x2));
mul_mux2 sh_56_ ( .d1(areg[57]), .z(ain[56]), .d0(areg[56]), .s(x2));
mul_mux2 sh_55_ ( .d1(areg[56]), .z(ain[55]), .d0(areg[55]), .s(x2));
mul_mux2 sh_54_ ( .d1(areg[55]), .z(ain[54]), .d0(areg[54]), .s(x2));
mul_mux2 sh_53_ ( .d1(areg[54]), .z(ain[53]), .d0(areg[53]), .s(x2));
mul_mux2 sh_52_ ( .d1(areg[53]), .z(ain[52]), .d0(areg[52]), .s(x2));
mul_mux2 sh_51_ ( .d1(areg[52]), .z(ain[51]), .d0(areg[51]), .s(x2));
mul_mux2 sh_50_ ( .d1(areg[51]), .z(ain[50]), .d0(areg[50]), .s(x2));
mul_mux2 sh_49_ ( .d1(areg[50]), .z(ain[49]), .d0(areg[49]), .s(x2));
mul_mux2 sh_48_ ( .d1(areg[49]), .z(ain[48]), .d0(areg[48]), .s(x2));
mul_mux2 sh_47_ ( .d1(areg[48]), .z(ain[47]), .d0(areg[47]), .s(x2));
mul_mux2 sh_46_ ( .d1(areg[47]), .z(ain[46]), .d0(areg[46]), .s(x2));
mul_mux2 sh_45_ ( .d1(areg[46]), .z(ain[45]), .d0(areg[45]), .s(x2));
mul_mux2 sh_44_ ( .d1(areg[45]), .z(ain[44]), .d0(areg[44]), .s(x2));
mul_mux2 sh_43_ ( .d1(areg[44]), .z(ain[43]), .d0(areg[43]), .s(x2));
mul_mux2 sh_42_ ( .d1(areg[43]), .z(ain[42]), .d0(areg[42]), .s(x2));
mul_mux2 sh_41_ ( .d1(areg[42]), .z(ain[41]), .d0(areg[41]), .s(x2));
mul_mux2 sh_40_ ( .d1(areg[41]), .z(ain[40]), .d0(areg[40]), .s(x2));
mul_mux2 sh_39_ ( .d1(areg[40]), .z(ain[39]), .d0(areg[39]), .s(x2));
mul_mux2 sh_38_ ( .d1(areg[39]), .z(ain[38]), .d0(areg[38]), .s(x2));
mul_mux2 sh_37_ ( .d1(areg[38]), .z(ain[37]), .d0(areg[37]), .s(x2));
mul_mux2 sh_36_ ( .d1(areg[37]), .z(ain[36]), .d0(areg[36]), .s(x2));
mul_mux2 sh_35_ ( .d1(areg[36]), .z(ain[35]), .d0(areg[35]), .s(x2));
mul_mux2 sh_34_ ( .d1(areg[35]), .z(ain[34]), .d0(areg[34]), .s(x2));
mul_mux2 sh_33_ ( .d1(areg[34]), .z(ain[33]), .d0(areg[33]), .s(x2));
mul_mux2 sh_32_ ( .d1(areg[33]), .z(ain[32]), .d0(areg[32]), .s(x2));
mul_mux2 sh_31_ ( .d1(areg[32]), .z(ain[31]), .d0(areg[31]), .s(x2));
mul_mux2 sh_30_ ( .d1(areg[31]), .z(ain[30]), .d0(areg[30]), .s(x2));
mul_mux2 sh_29_ ( .d1(areg[30]), .z(ain[29]), .d0(areg[29]), .s(x2));
mul_mux2 sh_28_ ( .d1(areg[29]), .z(ain[28]), .d0(areg[28]), .s(x2));
mul_mux2 sh_27_ ( .d1(areg[28]), .z(ain[27]), .d0(areg[27]), .s(x2));
mul_mux2 sh_26_ ( .d1(areg[27]), .z(ain[26]), .d0(areg[26]), .s(x2));
mul_mux2 sh_25_ ( .d1(areg[26]), .z(ain[25]), .d0(areg[25]), .s(x2));
mul_mux2 sh_24_ ( .d1(areg[25]), .z(ain[24]), .d0(areg[24]), .s(x2));
mul_mux2 sh_23_ ( .d1(areg[24]), .z(ain[23]), .d0(areg[23]), .s(x2));
mul_mux2 sh_22_ ( .d1(areg[23]), .z(ain[22]), .d0(areg[22]), .s(x2));
mul_mux2 sh_21_ ( .d1(areg[22]), .z(ain[21]), .d0(areg[21]), .s(x2));
mul_mux2 sh_20_ ( .d1(areg[21]), .z(ain[20]), .d0(areg[20]), .s(x2));
mul_mux2 sh_96_ ( .d1(1'b0), .z(ain[96]), .d0(areg[96]),
     .s(x2));
mul_mux2 sh_95_ ( .d1(areg[96]), .z(ain[95]), .d0(areg[95]), .s(x2));
mul_mux2 sh_94_ ( .d1(areg[95]), .z(ain[94]), .d0(areg[94]), .s(x2));
mul_mux2 sh_93_ ( .d1(areg[94]), .z(ain[93]), .d0(areg[93]), .s(x2));
mul_mux2 sh_92_ ( .d1(areg[93]), .z(ain[92]), .d0(areg[92]), .s(x2));
mul_mux2 sh_91_ ( .d1(areg[92]), .z(ain[91]), .d0(areg[91]), .s(x2));
mul_mux2 sh_90_ ( .d1(areg[91]), .z(ain[90]), .d0(areg[90]), .s(x2));
mul_mux2 sh_89_ ( .d1(areg[90]), .z(ain[89]), .d0(areg[89]), .s(x2));
mul_mux2 sh_88_ ( .d1(areg[89]), .z(ain[88]), .d0(areg[88]), .s(x2));
mul_mux2 sh_87_ ( .d1(areg[88]), .z(ain[87]), .d0(areg[87]), .s(x2));
mul_mux2 sh_86_ ( .d1(areg[87]), .z(ain[86]), .d0(areg[86]), .s(x2));
mul_mux2 sh_85_ ( .d1(areg[86]), .z(ain[85]), .d0(areg[85]), .s(x2));
mul_mux2 sh_84_ ( .d1(areg[85]), .z(ain[84]), .d0(areg[84]), .s(x2));
mul_mux2 sh_0_ ( .d1(areg[1]), .z(ain[0]), .d0(areg[0]), .s(x2));
mul_mux2 sh_81_ ( .d1(areg[82]), .z(ain[81]), .d0(areg[81]), .s(x2));
mul_mux2 sh_80_ ( .d1(areg[81]), .z(ain[80]), .d0(areg[80]), .s(x2));
mul_mux2 sh_79_ ( .d1(areg[80]), .z(ain[79]), .d0(areg[79]), .s(x2));
mul_mux2 sh_78_ ( .d1(areg[79]), .z(ain[78]), .d0(areg[78]), .s(x2));
mul_mux2 sh_77_ ( .d1(areg[78]), .z(ain[77]), .d0(areg[77]), .s(x2));
mul_mux2 sh_76_ ( .d1(areg[77]), .z(ain[76]), .d0(areg[76]), .s(x2));
mul_mux2 sh_75_ ( .d1(areg[76]), .z(ain[75]), .d0(areg[75]), .s(x2));
mul_mux2 sh_74_ ( .d1(areg[75]), .z(ain[74]), .d0(areg[74]), .s(x2));
mul_mux2 sh_73_ ( .d1(areg[74]), .z(ain[73]), .d0(areg[73]), .s(x2));
mul_mux2 sh_72_ ( .d1(areg[73]), .z(ain[72]), .d0(areg[72]), .s(x2));
mul_mux2 sh_71_ ( .d1(areg[72]), .z(ain[71]), .d0(areg[71]), .s(x2));
mul_mux2 sh_70_ ( .d1(areg[71]), .z(ain[70]), .d0(areg[70]), .s(x2));
mul_mux2 sh_69_ ( .d1(areg[70]), .z(ain[69]), .d0(areg[69]), .s(x2));
mul_mux2 sh_19_ ( .d1(areg[20]), .z(ain[19]), .d0(areg[19]), .s(x2));
mul_mux2 sh_18_ ( .d1(areg[19]), .z(ain[18]), .d0(areg[18]), .s(x2));
mul_mux2 sh_17_ ( .d1(areg[18]), .z(ain[17]), .d0(areg[17]), .s(x2));
mul_mux2 sh_16_ ( .d1(areg[17]), .z(ain[16]), .d0(areg[16]), .s(x2));
mul_mux2 sh_15_ ( .d1(areg[16]), .z(ain[15]), .d0(areg[15]), .s(x2));
mul_mux2 sh_4_ ( .d1(areg[5]), .z(ain[4]), .d0(areg[4]), .s(x2));
mul_mux2 sh_3_ ( .d1(areg[4]), .z(ain[3]), .d0(areg[3]), .s(x2));
mul_mux2 sh_2_ ( .d1(areg[3]), .z(ain[2]), .d0(areg[2]), .s(x2));
mul_mux2 sh_1_ ( .d1(areg[2]), .z(ain[1]), .d0(areg[1]), .s(x2));
mul_mux2 shx2 ( .d1(areg[0]), .z(ainx2), .d0(1'b0),
     .s(x2));
mul_mux2 sh_83_ ( .d1(areg[84]), .z(ain[83]), .d0(areg[83]), .s(x2));
mul_mux2 sh_14_ ( .d1(areg[15]), .z(ain[14]), .d0(areg[14]), .s(x2));
mul_mux2 sh_13_ ( .d1(areg[14]), .z(ain[13]), .d0(areg[13]), .s(x2));
mul_mux2 sh_12_ ( .d1(areg[13]), .z(ain[12]), .d0(areg[12]), .s(x2));
mul_mux2 sh_11_ ( .d1(areg[12]), .z(ain[11]), .d0(areg[11]), .s(x2));
mul_mux2 sh_10_ ( .d1(areg[11]), .z(ain[10]), .d0(areg[10]), .s(x2));
mul_mux2 sh_9_ ( .d1(areg[10]), .z(ain[9]), .d0(areg[9]), .s(x2));
mul_mux2 sh_8_ ( .d1(areg[9]), .z(ain[8]), .d0(areg[8]), .s(x2));
mul_mux2 sh_7_ ( .d1(areg[8]), .z(ain[7]), .d0(areg[7]), .s(x2));
mul_mux2 sh_6_ ( .d1(areg[7]), .z(ain[6]), .d0(areg[6]), .s(x2));
mul_mux2 sh_5_ ( .d1(areg[6]), .z(ain[5]), .d0(areg[5]), .s(x2));
mul_csa42  sc3_68_ ( .cin(co[67]), .d(1'b0),
     .carry(c3[68]), .c(c2[67]), .b(s2[68]), .a(1'b0),
     .cout(), .sum(s3[68]));
mul_csa42  sc3_67_ ( .cin(co[66]), .d(1'b0),
     .carry(c3[67]), .c(c2[66]), .b(s2[67]), .a(s1[67]), .cout(co[67]),
     .sum(s3[67]));
mul_csa42  sc3_66_ ( .cin(co[65]), .d(c1[65]), .carry(c3[66]),
     .c(c2[65]), .b(s2[66]), .a(s1[66]), .cout(co[66]), .sum(s3[66]));
mul_csa42  sc3_65_ ( .cin(co[64]), .d(c1[64]), .carry(c3[65]),
     .c(c2[64]), .b(s2[65]), .a(s1[65]), .cout(co[65]), .sum(s3[65]));
mul_csa42  sc3_64_ ( .cin(co[63]), .d(c1[63]), .carry(c3[64]),
     .c(c2[63]), .b(s2[64]), .a(s1[64]), .cout(co[64]), .sum(s3[64]));
mul_csa42  sc3_63_ ( .cin(co[62]), .d(c1[62]), .carry(c3[63]),
     .c(c2[62]), .b(s2[63]), .a(s1[63]), .cout(co[63]), .sum(s3[63]));
mul_csa42  sc3_62_ ( .cin(co[61]), .d(c1[61]), .carry(c3[62]),
     .c(c2[61]), .b(s2[62]), .a(s1[62]), .cout(co[62]), .sum(s3[62]));
mul_csa42  sc3_61_ ( .cin(co[60]), .d(c1[60]), .carry(c3[61]),
     .c(c2[60]), .b(s2[61]), .a(s1[61]), .cout(co[61]), .sum(s3[61]));
mul_csa42  sc3_60_ ( .cin(co[59]), .d(c1[59]), .carry(c3[60]),
     .c(c2[59]), .b(s2[60]), .a(s1[60]), .cout(co[60]), .sum(s3[60]));
mul_csa42  sc3_59_ ( .cin(co[58]), .d(c1[58]), .carry(c3[59]),
     .c(c2[58]), .b(s2[59]), .a(s1[59]), .cout(co[59]), .sum(s3[59]));
mul_csa42  sc3_58_ ( .cin(co[57]), .d(c1[57]), .carry(c3[58]),
     .c(c2[57]), .b(s2[58]), .a(s1[58]), .cout(co[58]), .sum(s3[58]));
mul_csa42  sc3_57_ ( .cin(co[56]), .d(c1[56]), .carry(c3[57]),
     .c(c2[56]), .b(s2[57]), .a(s1[57]), .cout(co[57]), .sum(s3[57]));
mul_csa42  sc3_56_ ( .cin(co[55]), .d(c1[55]), .carry(c3[56]),
     .c(c2[55]), .b(s2[56]), .a(s1[56]), .cout(co[56]), .sum(s3[56]));
mul_csa42  sc3_55_ ( .cin(co[54]), .d(c1[54]), .carry(c3[55]),
     .c(c2[54]), .b(s2[55]), .a(s1[55]), .cout(co[55]), .sum(s3[55]));
mul_csa42  sc3_54_ ( .cin(co[53]), .d(c1[53]), .carry(c3[54]),
     .c(c2[53]), .b(s2[54]), .a(s1[54]), .cout(co[54]), .sum(s3[54]));
mul_csa42  sc3_53_ ( .cin(co[52]), .d(c1[52]), .carry(c3[53]),
     .c(c2[52]), .b(s2[53]), .a(s1[53]), .cout(co[53]), .sum(s3[53]));
mul_csa42  sc3_52_ ( .cin(co[51]), .d(c1[51]), .carry(c3[52]),
     .c(c2[51]), .b(s2[52]), .a(s1[52]), .cout(co[52]), .sum(s3[52]));
mul_csa42  sc3_51_ ( .cin(co[50]), .d(c1[50]), .carry(c3[51]),
     .c(c2[50]), .b(s2[51]), .a(s1[51]), .cout(co[51]), .sum(s3[51]));
mul_csa42  sc3_50_ ( .cin(co[49]), .d(c1[49]), .carry(c3[50]),
     .c(c2[49]), .b(s2[50]), .a(s1[50]), .cout(co[50]), .sum(s3[50]));
mul_csa42  sc3_49_ ( .cin(co[48]), .d(c1[48]), .carry(c3[49]),
     .c(c2[48]), .b(s2[49]), .a(s1[49]), .cout(co[49]), .sum(s3[49]));
mul_csa42  sc3_48_ ( .cin(co[47]), .d(c1[47]), .carry(c3[48]),
     .c(c2[47]), .b(s2[48]), .a(s1[48]), .cout(co[48]), .sum(s3[48]));
mul_csa42  sc3_47_ ( .cin(co[46]), .d(c1[46]), .carry(c3[47]),
     .c(c2[46]), .b(s2[47]), .a(s1[47]), .cout(co[47]), .sum(s3[47]));
mul_csa42  sc3_46_ ( .cin(co[45]), .d(c1[45]), .carry(c3[46]),
     .c(c2[45]), .b(s2[46]), .a(s1[46]), .cout(co[46]), .sum(s3[46]));
mul_csa42  sc3_45_ ( .cin(co[44]), .d(c1[44]), .carry(c3[45]),
     .c(c2[44]), .b(s2[45]), .a(s1[45]), .cout(co[45]), .sum(s3[45]));
mul_csa42  sc3_44_ ( .cin(co[43]), .d(c1[43]), .carry(c3[44]),
     .c(c2[43]), .b(s2[44]), .a(s1[44]), .cout(co[44]), .sum(s3[44]));
mul_csa42  sc3_43_ ( .cin(co[42]), .d(c1[42]), .carry(c3[43]),
     .c(c2[42]), .b(s2[43]), .a(s1[43]), .cout(co[43]), .sum(s3[43]));
mul_csa42  sc3_42_ ( .cin(co[41]), .d(c1[41]), .carry(c3[42]),
     .c(c2[41]), .b(s2[42]), .a(s1[42]), .cout(co[42]), .sum(s3[42]));
mul_csa42  sc3_41_ ( .cin(co[40]), .d(c1[40]), .carry(c3[41]),
     .c(c2[40]), .b(s2[41]), .a(s1[41]), .cout(co[41]), .sum(s3[41]));
mul_csa42  sc3_40_ ( .cin(co[39]), .d(c1[39]), .carry(c3[40]),
     .c(c2[39]), .b(s2[40]), .a(s1[40]), .cout(co[40]), .sum(s3[40]));
mul_csa42  sc3_39_ ( .cin(co[38]), .d(c1[38]), .carry(c3[39]),
     .c(c2[38]), .b(s2[39]), .a(s1[39]), .cout(co[39]), .sum(s3[39]));
mul_csa42  sc3_38_ ( .cin(co[37]), .d(c1[37]), .carry(c3[38]),
     .c(c2[37]), .b(s2[38]), .a(s1[38]), .cout(co[38]), .sum(s3[38]));
mul_csa42  sc3_37_ ( .cin(co[36]), .d(c1[36]), .carry(c3[37]),
     .c(c2[36]), .b(s2[37]), .a(s1[37]), .cout(co[37]), .sum(s3[37]));
mul_csa42  sc3_36_ ( .cin(co[35]), .d(c1[35]), .carry(c3[36]),
     .c(c2[35]), .b(s2[36]), .a(s1[36]), .cout(co[36]), .sum(s3[36]));
mul_csa42  sc3_35_ ( .cin(co[34]), .d(c1[34]), .carry(c3[35]),
     .c(c2[34]), .b(s2[35]), .a(s1[35]), .cout(co[35]), .sum(s3[35]));
mul_csa42  sc3_34_ ( .cin(co[33]), .d(c1[33]), .carry(c3[34]),
     .c(c2[33]), .b(s2[34]), .a(s1[34]), .cout(co[34]), .sum(s3[34]));
mul_csa42  sc3_33_ ( .cin(co[32]), .d(c1[32]), .carry(c3[33]),
     .c(c2[32]), .b(s2[33]), .a(s1[33]), .cout(co[33]), .sum(s3[33]));
mul_csa42  sc3_32_ ( .cin(co[31]), .d(c1[31]), .carry(c3[32]),
     .c(c2[31]), .b(s2[32]), .a(s1[32]), .cout(co[32]), .sum(s3[32]));
mul_csa42  sc3_31_ ( .cin(co[30]), .d(c1[30]), .carry(c3[31]),
     .c(c2[30]), .b(s2[31]), .a(s1[31]), .cout(co[31]), .sum(s3[31]));
mul_csa42  sc3_30_ ( .cin(co[29]), .d(c1[29]), .carry(c3[30]),
     .c(c2[29]), .b(s2[30]), .a(s1[30]), .cout(co[30]), .sum(s3[30]));
mul_csa42  sc3_29_ ( .cin(co[28]), .d(c1[28]), .carry(c3[29]),
     .c(c2[28]), .b(s2[29]), .a(s1[29]), .cout(co[29]), .sum(s3[29]));
mul_csa42  sc3_28_ ( .cin(co[27]), .d(c1[27]), .carry(c3[28]),
     .c(c2[27]), .b(s2[28]), .a(s1[28]), .cout(co[28]), .sum(s3[28]));
mul_csa42  sc3_27_ ( .cin(co[26]), .d(c1[26]), .carry(c3[27]),
     .c(c2[26]), .b(s2[27]), .a(s1[27]), .cout(co[27]), .sum(s3[27]));
mul_csa42  sc3_26_ ( .cin(co[25]), .d(c1[25]), .carry(c3[26]),
     .c(c2[25]), .b(s2[26]), .a(s1[26]), .cout(co[26]), .sum(s3[26]));
mul_csa42  sc3_25_ ( .cin(co[24]), .d(c1[24]), .carry(c3[25]),
     .c(c2[24]), .b(s2[25]), .a(s1[25]), .cout(co[25]), .sum(s3[25]));
mul_csa42  sc3_24_ ( .cin(co[23]), .d(c1[23]), .carry(c3[24]),
     .c(c2[23]), .b(s2[24]), .a(s1[24]), .cout(co[24]), .sum(s3[24]));
mul_csa42  sc3_23_ ( .cin(co[22]), .d(c1[22]), .carry(c3[23]),
     .c(c2[22]), .b(s2[23]), .a(s1[23]), .cout(co[23]), .sum(s3[23]));
mul_csa42  sc3_22_ ( .cin(co[21]), .d(c1[21]), .carry(c3[22]),
     .c(c2[21]), .b(s2[22]), .a(s1[22]), .cout(co[22]), .sum(s3[22]));
mul_csa42  sc3_21_ ( .cin(co[20]), .d(c1[20]), .carry(c3[21]),
     .c(c2[20]), .b(s2[21]), .a(s1[21]), .cout(co[21]), .sum(s3[21]));
mul_csa42  sc3_20_ ( .cin(1'b0), .d(c1[19]),
     .carry(c3[20]), .c(c2[19]), .b(s2[20]), .a(s1[20]), .cout(co[20]),
     .sum(s3[20]));
mul_csa32  sc4_82_ ( .c(c3[81]), .b(s2[82]), .a(ain[82]),
     .cout(pcout[82]), .sum(psum[82]));
mul_csa32  sc4_68_ ( .c(c3[67]), .b(s3[68]), .a(ain[68]),
     .cout(pcout[68]), .sum(psum[68]));
mul_csa32  sc4_67_ ( .c(c3[66]), .b(s3[67]), .a(ain[67]),
     .cout(pcout[67]), .sum(psum[67]));
mul_csa32  sc4_66_ ( .c(c3[65]), .b(s3[66]), .a(ain[66]),
     .cout(pcout[66]), .sum(psum[66]));
mul_csa32  sc4_65_ ( .c(c3[64]), .b(s3[65]), .a(ain[65]),
     .cout(pcout[65]), .sum(psum[65]));
mul_csa32  sc4_64_ ( .c(c3[63]), .b(s3[64]), .a(ain[64]),
     .cout(pcout[64]), .sum(psum[64]));
mul_csa32  sc4_63_ ( .c(c3[62]), .b(s3[63]), .a(ain[63]),
     .cout(pcout[63]), .sum(psum[63]));
mul_csa32  sc4_62_ ( .c(c3[61]), .b(s3[62]), .a(ain[62]),
     .cout(pcout[62]), .sum(psum[62]));
mul_csa32  sc4_61_ ( .c(c3[60]), .b(s3[61]), .a(ain[61]),
     .cout(pcout[61]), .sum(psum[61]));
mul_csa32  sc4_60_ ( .c(c3[59]), .b(s3[60]), .a(ain[60]),
     .cout(pcout[60]), .sum(psum[60]));
mul_csa32  sc4_59_ ( .c(c3[58]), .b(s3[59]), .a(ain[59]),
     .cout(pcout[59]), .sum(psum[59]));
mul_csa32  sc4_58_ ( .c(c3[57]), .b(s3[58]), .a(ain[58]),
     .cout(pcout[58]), .sum(psum[58]));
mul_csa32  sc4_57_ ( .c(c3[56]), .b(s3[57]), .a(ain[57]),
     .cout(pcout[57]), .sum(psum[57]));
mul_csa32  sc4_56_ ( .c(c3[55]), .b(s3[56]), .a(ain[56]),
     .cout(pcout[56]), .sum(psum[56]));
mul_csa32  sc4_55_ ( .c(c3[54]), .b(s3[55]), .a(ain[55]),
     .cout(pcout[55]), .sum(psum[55]));
mul_csa32  sc4_54_ ( .c(c3[53]), .b(s3[54]), .a(ain[54]),
     .cout(pcout[54]), .sum(psum[54]));
mul_csa32  sc4_53_ ( .c(c3[52]), .b(s3[53]), .a(ain[53]),
     .cout(pcout[53]), .sum(psum[53]));
mul_csa32  sc4_52_ ( .c(c3[51]), .b(s3[52]), .a(ain[52]),
     .cout(pcout[52]), .sum(psum[52]));
mul_csa32  sc4_51_ ( .c(c3[50]), .b(s3[51]), .a(ain[51]),
     .cout(pcout[51]), .sum(psum[51]));
mul_csa32  sc4_50_ ( .c(c3[49]), .b(s3[50]), .a(ain[50]),
     .cout(pcout[50]), .sum(psum[50]));
mul_csa32  sc4_49_ ( .c(c3[48]), .b(s3[49]), .a(ain[49]),
     .cout(pcout[49]), .sum(psum[49]));
mul_csa32  sc4_48_ ( .c(c3[47]), .b(s3[48]), .a(ain[48]),
     .cout(pcout[48]), .sum(psum[48]));
mul_csa32  sc4_47_ ( .c(c3[46]), .b(s3[47]), .a(ain[47]),
     .cout(pcout[47]), .sum(psum[47]));
mul_csa32  sc4_46_ ( .c(c3[45]), .b(s3[46]), .a(ain[46]),
     .cout(pcout[46]), .sum(psum[46]));
mul_csa32  sc4_45_ ( .c(c3[44]), .b(s3[45]), .a(ain[45]),
     .cout(pcout[45]), .sum(psum[45]));
mul_csa32  sc4_44_ ( .c(c3[43]), .b(s3[44]), .a(ain[44]),
     .cout(pcout[44]), .sum(psum[44]));
mul_csa32  sc4_43_ ( .c(c3[42]), .b(s3[43]), .a(ain[43]),
     .cout(pcout[43]), .sum(psum[43]));
mul_csa32  sc4_42_ ( .c(c3[41]), .b(s3[42]), .a(ain[42]),
     .cout(pcout[42]), .sum(psum[42]));
mul_csa32  sc4_41_ ( .c(c3[40]), .b(s3[41]), .a(ain[41]),
     .cout(pcout[41]), .sum(psum[41]));
mul_csa32  sc4_40_ ( .c(c3[39]), .b(s3[40]), .a(ain[40]),
     .cout(pcout[40]), .sum(psum[40]));
mul_csa32  sc4_39_ ( .c(c3[38]), .b(s3[39]), .a(ain[39]),
     .cout(pcout[39]), .sum(psum[39]));
mul_csa32  sc4_38_ ( .c(c3[37]), .b(s3[38]), .a(ain[38]),
     .cout(pcout[38]), .sum(psum[38]));
mul_csa32  sc4_37_ ( .c(c3[36]), .b(s3[37]), .a(ain[37]),
     .cout(pcout[37]), .sum(psum[37]));
mul_csa32  sc4_36_ ( .c(c3[35]), .b(s3[36]), .a(ain[36]),
     .cout(pcout[36]), .sum(psum[36]));
mul_csa32  sc4_35_ ( .c(c3[34]), .b(s3[35]), .a(ain[35]),
     .cout(pcout[35]), .sum(psum[35]));
mul_csa32  sc4_34_ ( .c(c3[33]), .b(s3[34]), .a(ain[34]),
     .cout(pcout[34]), .sum(psum[34]));
mul_csa32  sc4_33_ ( .c(c3[32]), .b(s3[33]), .a(ain[33]),
     .cout(pcout[33]), .sum(psum[33]));
mul_csa32  sc4_32_ ( .c(c3[31]), .b(s3[32]), .a(ain[32]),
     .cout(pcout[32]), .sum(psum[32]));
mul_csa32  sc4_31_ ( .c(c3[30]), .b(s3[31]), .a(ain[31]),
     .cout(pcout[31]), .sum(psum[31]));
mul_csa32  sc4_30_ ( .c(c3[29]), .b(s3[30]), .a(ain[30]),
     .cout(pcout[30]), .sum(psum[30]));
mul_csa32  sc4_29_ ( .c(c3[28]), .b(s3[29]), .a(ain[29]),
     .cout(pcout[29]), .sum(psum[29]));
mul_csa32  sc4_28_ ( .c(c3[27]), .b(s3[28]), .a(ain[28]),
     .cout(pcout[28]), .sum(psum[28]));
mul_csa32  sc4_27_ ( .c(c3[26]), .b(s3[27]), .a(ain[27]),
     .cout(pcout[27]), .sum(psum[27]));
mul_csa32  sc4_26_ ( .c(c3[25]), .b(s3[26]), .a(ain[26]),
     .cout(pcout[26]), .sum(psum[26]));
mul_csa32  sc4_25_ ( .c(c3[24]), .b(s3[25]), .a(ain[25]),
     .cout(pcout[25]), .sum(psum[25]));
mul_csa32  sc4_24_ ( .c(c3[23]), .b(s3[24]), .a(ain[24]),
     .cout(pcout[24]), .sum(psum[24]));
mul_csa32  sc4_23_ ( .c(c3[22]), .b(s3[23]), .a(ain[23]),
     .cout(pcout[23]), .sum(psum[23]));
mul_csa32  sc4_22_ ( .c(c3[21]), .b(s3[22]), .a(ain[22]),
     .cout(pcout[22]), .sum(psum[22]));
mul_csa32  sc4_21_ ( .c(c3[20]), .b(s3[21]), .a(ain[21]),
     .cout(pcout[21]), .sum(psum[21]));
mul_csa32  sc4_20_ ( .c(c3[19]), .b(s3[20]), .a(ain[20]),
     .cout(pcout[20]), .sum(psum[20]));
mul_csa32  sc4_96_ ( .c(c2[95]), .b(s2[96]), .a(ain[96]),
     .cout(pcout[96]), .sum(psum[96]));
mul_csa32  sc4_95_ ( .c(c2[94]), .b(s2[95]), .a(ain[95]),
     .cout(pcout[95]), .sum(psum[95]));
mul_csa32  sc4_94_ ( .c(c2[93]), .b(s2[94]), .a(ain[94]),
     .cout(pcout[94]), .sum(psum[94]));
mul_csa32  sc4_93_ ( .c(c2[92]), .b(s2[93]), .a(ain[93]),
     .cout(pcout[93]), .sum(psum[93]));
mul_csa32  sc4_92_ ( .c(c2[91]), .b(s2[92]), .a(ain[92]),
     .cout(pcout[92]), .sum(psum[92]));
mul_csa32  sc4_91_ ( .c(c2[90]), .b(s2[91]), .a(ain[91]),
     .cout(pcout[91]), .sum(psum[91]));
mul_csa32  sc4_90_ ( .c(c2[89]), .b(s2[90]), .a(ain[90]),
     .cout(pcout[90]), .sum(psum[90]));
mul_csa32  sc4_89_ ( .c(c2[88]), .b(s2[89]), .a(ain[89]),
     .cout(pcout[89]), .sum(psum[89]));
mul_csa32  sc4_88_ ( .c(c2[87]), .b(s2[88]), .a(ain[88]),
     .cout(pcout[88]), .sum(psum[88]));
mul_csa32  sc4_87_ ( .c(c2[86]), .b(s2[87]), .a(ain[87]),
     .cout(pcout[87]), .sum(psum[87]));
mul_csa32  sc4_86_ ( .c(c2[85]), .b(s2[86]), .a(ain[86]),
     .cout(pcout[86]), .sum(psum[86]));
mul_csa32  sc4_85_ ( .c(c2[84]), .b(s2[85]), .a(ain[85]),
     .cout(pcout[85]), .sum(psum[85]));
mul_csa32  sc4_84_ ( .c(c2[83]), .b(s2[84]), .a(ain[84]),
     .cout(pcout[84]), .sum(psum[84]));
mul_csa32  sc4_81_ ( .c(c3[80]), .b(s3[81]), .a(ain[81]),
     .cout(pcout[81]), .sum(psum[81]));
mul_csa32  sc4_80_ ( .c(c3[79]), .b(s3[80]), .a(ain[80]),
     .cout(pcout[80]), .sum(psum[80]));
mul_csa32  sc4_79_ ( .c(c3[78]), .b(s3[79]), .a(ain[79]),
     .cout(pcout[79]), .sum(psum[79]));
mul_csa32  sc4_78_ ( .c(c3[77]), .b(s3[78]), .a(ain[78]),
     .cout(pcout[78]), .sum(psum[78]));
mul_csa32  sc4_77_ ( .c(c3[76]), .b(s3[77]), .a(ain[77]),
     .cout(pcout[77]), .sum(psum[77]));
mul_csa32  sc4_76_ ( .c(c3[75]), .b(s3[76]), .a(ain[76]),
     .cout(pcout[76]), .sum(psum[76]));
mul_csa32  sc4_75_ ( .c(c3[74]), .b(s3[75]), .a(ain[75]),
     .cout(pcout[75]), .sum(psum[75]));
mul_csa32  sc4_74_ ( .c(c3[73]), .b(s3[74]), .a(ain[74]),
     .cout(pcout[74]), .sum(psum[74]));
mul_csa32  sc4_73_ ( .c(c3[72]), .b(s3[73]), .a(ain[73]),
     .cout(pcout[73]), .sum(psum[73]));
mul_csa32  sc4_72_ ( .c(c3[71]), .b(s3[72]), .a(ain[72]),
     .cout(pcout[72]), .sum(psum[72]));
mul_csa32  sc4_71_ ( .c(c3[70]), .b(s3[71]), .a(ain[71]),
     .cout(pcout[71]), .sum(psum[71]));
mul_csa32  sc4_70_ ( .c(c3[69]), .b(s3[70]), .a(ain[70]),
     .cout(pcout[70]), .sum(psum[70]));
mul_csa32  sc4_69_ ( .c(c3[68]), .b(s3[69]), .a(ain[69]),
     .cout(pcout[69]), .sum(psum[69]));
mul_csa32  acc_4_ ( .c(c2[3]), .sum(psum[4]), .cout(pcout[4]),
     .a(ain[4]), .b(s2[4]));
mul_csa32  acc_3_ ( .c(c2[2]), .sum(psum[3]), .cout(pcout[3]),
     .a(ain[3]), .b(s2[3]));
mul_csa32  acc_2_ ( .c(c2[1]), .sum(psum[2]), .cout(pcout[2]),
     .a(ain[2]), .b(s2[2]));
mul_csa32  acc_1_ ( .c(c2[0]), .sum(psum[1]), .cout(pcout[1]),
     .a(ain[1]), .b(s2[1]));
mul_csa32  sc3_97_ ( .c(c2[96]), .sum(psum[97]), .cout(pcout[97]),
     .a(a1s[81]), .b(a1c[80]));
mul_csa32  sc1_19_ ( .c(a1s[3]), .b(pc[50]), .a(ps[51]),
     .cout(c1[19]), .sum(s1[19]));
mul_csa32  sc1_18_ ( .c(a1s[2]), .b(pc[49]), .a(ps[50]),
     .cout(c1[18]), .sum(s1[18]));
mul_csa32  sc1_17_ ( .c(a1s[1]), .b(pc[48]), .a(ps[49]),
     .cout(c1[17]), .sum(s1[17]));
mul_csa32  sc1_16_ ( .c(a1s[0]), .b(pc[47]), .a(ps[48]),
     .cout(c1[16]), .sum(s1[16]));
mul_csa32  sc1_15_ ( .c(1'b0), .b(pc[46]), .a(ps[47]),
     .cout(c1[15]), .sum(s1[15]));
mul_csa32  sc4_83_ ( .c(c2[82]), .b(s2[83]), .a(ain[83]),
     .cout(pcout[83]), .sum(psum[83]));
mul_csa32  sc2_83_ ( .c(c1[82]), .b(a1c[66]), .a(a1s[67]),
     .cout(c2[83]), .sum(s2[83]));
mul_csa32  sc2_19_ ( .c(a0c[18]), .b(a0s[19]), .a(s1[19]),
     .cout(c2[19]), .sum(s2[19]));
mul_csa32  sc2_18_ ( .c(a0c[17]), .b(a0s[18]), .a(s1[18]),
     .cout(c2[18]), .sum(s2[18]));
mul_csa32  sc2_17_ ( .c(a0c[16]), .b(a0s[17]), .a(s1[17]),
     .cout(c2[17]), .sum(s2[17]));
mul_csa32  sc2_16_ ( .c(a0c[15]), .b(a0s[16]), .a(s1[16]),
     .cout(c2[16]), .sum(s2[16]));
mul_csa32  sc2_15_ ( .c(a0c[14]), .b(a0s[15]), .a(s1[15]),
     .cout(c2[15]), .sum(s2[15]));
mul_csa32  sc1_81_ ( .c(a0s[81]), .b(a1c[64]), .a(a1s[65]),
     .cout(c1[81]), .sum(s1[81]));
mul_csa32  sc1_80_ ( .c(a0s[80]), .b(a1c[63]), .a(a1s[64]),
     .cout(c1[80]), .sum(s1[80]));
mul_csa32  sc1_79_ ( .c(a0s[79]), .b(a1c[62]), .a(a1s[63]),
     .cout(c1[79]), .sum(s1[79]));
mul_csa32  sc1_78_ ( .c(a0s[78]), .b(a1c[61]), .a(a1s[62]),
     .cout(c1[78]), .sum(s1[78]));
mul_csa32  sc1_77_ ( .c(a0s[77]), .b(a1c[60]), .a(a1s[61]),
     .cout(c1[77]), .sum(s1[77]));
mul_csa32  sc1_76_ ( .c(a0s[76]), .b(a1c[59]), .a(a1s[60]),
     .cout(c1[76]), .sum(s1[76]));
mul_csa32  sc1_75_ ( .c(a0s[75]), .b(a1c[58]), .a(a1s[59]),
     .cout(c1[75]), .sum(s1[75]));
mul_csa32  sc1_74_ ( .c(a0s[74]), .b(a1c[57]), .a(a1s[58]),
     .cout(c1[74]), .sum(s1[74]));
mul_csa32  sc1_73_ ( .c(a0s[73]), .b(a1c[56]), .a(a1s[57]),
     .cout(c1[73]), .sum(s1[73]));
mul_csa32  sc1_72_ ( .c(a0s[72]), .b(a1c[55]), .a(a1s[56]),
     .cout(c1[72]), .sum(s1[72]));
mul_csa32  sc1_71_ ( .c(a0s[71]), .b(a1c[54]), .a(a1s[55]),
     .cout(c1[71]), .sum(s1[71]));
mul_csa32  sc1_70_ ( .c(a0s[70]), .b(a1c[53]), .a(a1s[54]),
     .cout(c1[70]), .sum(s1[70]));
mul_csa32  sc1_69_ ( .c(a0s[69]), .b(a1c[52]), .a(a1s[53]),
     .cout(c1[69]), .sum(s1[69]));
mul_csa32  sc1_68_ ( .c(a0s[68]), .b(a1c[51]), .a(a1s[52]),
     .cout(c1[68]), .sum(s1[68]));
mul_csa32  sc3_19_ ( .c(c2[18]), .b(c1[18]), .a(s2[19]),
     .cout(c3[19]), .sum(s3[19]));
mul_csa32  sc3_18_ ( .c(c2[17]), .b(c1[17]), .a(s2[18]),
     .cout(c3[18]), .sum(s3[18]));
mul_csa32  sc3_17_ ( .c(c2[16]), .b(c1[16]), .a(s2[17]),
     .cout(c3[17]), .sum(s3[17]));
mul_csa32  sc3_16_ ( .c(c2[15]), .b(c1[15]), .a(s2[16]),
     .cout(c3[16]), .sum(s3[16]));
mul_csa32  sc3_15_ ( .c(c2[14]), .b(c1[14]), .a(s2[15]),
     .cout(c3[15]), .sum(s3[15]));
mul_csa32  sc1_82_ ( .c(a0c[81]), .b(a1c[65]), .a(a1s[66]),
     .cout(c1[82]), .sum(s1[82]));
mul_csa32  acc_14_ ( .c(c2[13]), .sum(psum[14]), .cout(pcout[14]),
     .a(ain[14]), .b(s2[14]));
mul_csa32  acc_13_ ( .c(c2[12]), .sum(psum[13]), .cout(pcout[13]),
     .a(ain[13]), .b(s2[13]));
mul_csa32  acc_12_ ( .c(c2[11]), .sum(psum[12]), .cout(pcout[12]),
     .a(ain[12]), .b(s2[12]));
mul_csa32  acc_11_ ( .c(c2[10]), .sum(psum[11]), .cout(pcout[11]),
     .a(ain[11]), .b(s2[11]));
mul_csa32  acc_10_ ( .c(c2[9]), .sum(psum[10]), .cout(pcout[10]),
     .a(ain[10]), .b(s2[10]));
mul_csa32  acc_9_ ( .c(c2[8]), .sum(psum[9]), .cout(pcout[9]),
     .a(ain[9]), .b(s2[9]));
mul_csa32  acc_8_ ( .c(c2[7]), .sum(psum[8]), .cout(pcout[8]),
     .a(ain[8]), .b(s2[8]));
mul_csa32  acc_7_ ( .c(c2[6]), .sum(psum[7]), .cout(pcout[7]),
     .a(ain[7]), .b(s2[7]));
mul_csa32  acc_6_ ( .c(c2[5]), .sum(psum[6]), .cout(pcout[6]),
     .a(ain[6]), .b(s2[6]));
mul_csa32  acc_5_ ( .c(c2[4]), .sum(psum[5]), .cout(pcout[5]),
     .a(ain[5]), .b(s2[5]));
mul_csa32  sc2_67_ ( .c(a0c[66]), .b(c1[66]), .a(a0s[67]),
     .cout(c2[67]), .sum(s2[67]));
mul_csa32  sc1_14_ ( .c(a0s[14]), .b(pc[45]), .a(ps[46]),
     .cout(c1[14]), .sum(s1[14]));
mul_csa32  sc1_13_ ( .c(a0s[13]), .b(pc[44]), .a(ps[45]),
     .cout(c1[13]), .sum(s1[13]));
mul_csa32  sc1_12_ ( .c(a0s[12]), .b(pc[43]), .a(ps[44]),
     .cout(c1[12]), .sum(s1[12]));
mul_csa32  sc1_11_ ( .c(a0s[11]), .b(pc[42]), .a(ps[43]),
     .cout(c1[11]), .sum(s1[11]));
mul_csa32  sc1_10_ ( .c(a0s[10]), .b(pc[41]), .a(ps[42]),
     .cout(c1[10]), .sum(s1[10]));
mul_csa32  sc1_9_ ( .c(a0s[9]), .b(pc[40]), .a(ps[41]), .cout(c1[9]),
     .sum(s1[9]));
mul_csa32  sc1_8_ ( .c(a0s[8]), .b(pc[39]), .a(ps[40]), .cout(c1[8]),
     .sum(s1[8]));
mul_csa32  sc1_7_ ( .c(a0s[7]), .b(pc[38]), .a(ps[39]), .cout(c1[7]),
     .sum(s1[7]));
mul_csa32  sc1_6_ ( .c(a0s[6]), .b(pc[37]), .a(ps[38]), .cout(c1[6]),
     .sum(s1[6]));
mul_csa32  sc1_5_ ( .c(a0s[5]), .b(pc[36]), .a(ps[37]), .cout(c1[5]),
     .sum(s1[5]));
mul_csa32  sc2_14_ ( .c(a0c[13]), .b(c1[13]), .a(s1[14]),
     .cout(c2[14]), .sum(s2[14]));
mul_csa32  sc2_13_ ( .c(a0c[12]), .b(c1[12]), .a(s1[13]),
     .cout(c2[13]), .sum(s2[13]));
mul_csa32  sc2_12_ ( .c(a0c[11]), .b(c1[11]), .a(s1[12]),
     .cout(c2[12]), .sum(s2[12]));
mul_csa32  sc2_11_ ( .c(a0c[10]), .b(c1[10]), .a(s1[11]),
     .cout(c2[11]), .sum(s2[11]));
mul_csa32  sc2_10_ ( .c(a0c[9]), .b(c1[9]), .a(s1[10]),
     .cout(c2[10]), .sum(s2[10]));
mul_csa32  sc2_9_ ( .c(a0c[8]), .b(c1[8]), .a(s1[9]), .cout(c2[9]),
     .sum(s2[9]));
mul_csa32  sc2_8_ ( .c(a0c[7]), .b(c1[7]), .a(s1[8]), .cout(c2[8]),
     .sum(s2[8]));
mul_csa32  sc2_7_ ( .c(a0c[6]), .b(c1[6]), .a(s1[7]), .cout(c2[7]),
     .sum(s2[7]));
mul_csa32  sc2_6_ ( .c(a0c[5]), .b(c1[5]), .a(s1[6]), .cout(c2[6]),
     .sum(s2[6]));
mul_csa32  sc2_5_ ( .c(a0c[4]), .b(c1[4]), .a(s1[5]), .cout(c2[5]),
     .sum(s2[5]));
mul_csa32  sc2_82_ ( .c(c2[81]), .b(c1[81]), .a(s1[82]),
     .cout(c2[82]), .sum(s2[82]));
mul_csa32  sc1_4_ ( .c(a0s[4]), .b(pc[35]), .a(ps[36]), .cout(c1[4]),
     .sum(s1[4]));
mul_csa32  sc1_3_ ( .c(a0s[3]), .b(pc[34]), .a(ps[35]), .cout(c1[3]),
     .sum(s1[3]));
mul_csa32  sc1_2_ ( .c(a0s[2]), .b(pc[33]), .a(ps[34]), .cout(c1[2]),
     .sum(s1[2]));
mul_csa32  sc1_1_ ( .c(a0s[1]), .b(pc[32]), .a(ps[33]), .cout(c1[1]),
     .sum(s1[1]));
mul_csa32  sc2_66_ ( .c(a0c[65]), .b(a0s[66]), .a(a1c[49]),
     .cout(c2[66]), .sum(s2[66]));
mul_csa32  sc2_65_ ( .c(a0c[64]), .b(a0s[65]), .a(a1c[48]),
     .cout(c2[65]), .sum(s2[65]));
mul_csa32  sc2_64_ ( .c(a0c[63]), .b(a0s[64]), .a(a1c[47]),
     .cout(c2[64]), .sum(s2[64]));
mul_csa32  sc2_63_ ( .c(a0c[62]), .b(a0s[63]), .a(a1c[46]),
     .cout(c2[63]), .sum(s2[63]));
mul_csa32  sc2_62_ ( .c(a0c[61]), .b(a0s[62]), .a(a1c[45]),
     .cout(c2[62]), .sum(s2[62]));
mul_csa32  sc2_61_ ( .c(a0c[60]), .b(a0s[61]), .a(a1c[44]),
     .cout(c2[61]), .sum(s2[61]));
mul_csa32  sc2_60_ ( .c(a0c[59]), .b(a0s[60]), .a(a1c[43]),
     .cout(c2[60]), .sum(s2[60]));
mul_csa32  sc2_59_ ( .c(a0c[58]), .b(a0s[59]), .a(a1c[42]),
     .cout(c2[59]), .sum(s2[59]));
mul_csa32  sc2_58_ ( .c(a0c[57]), .b(a0s[58]), .a(a1c[41]),
     .cout(c2[58]), .sum(s2[58]));
mul_csa32  sc2_57_ ( .c(a0c[56]), .b(a0s[57]), .a(a1c[40]),
     .cout(c2[57]), .sum(s2[57]));
mul_csa32  sc2_56_ ( .c(a0c[55]), .b(a0s[56]), .a(a1c[39]),
     .cout(c2[56]), .sum(s2[56]));
mul_csa32  sc2_55_ ( .c(a0c[54]), .b(a0s[55]), .a(a1c[38]),
     .cout(c2[55]), .sum(s2[55]));
mul_csa32  sc2_54_ ( .c(a0c[53]), .b(a0s[54]), .a(a1c[37]),
     .cout(c2[54]), .sum(s2[54]));
mul_csa32  sc2_53_ ( .c(a0c[52]), .b(a0s[53]), .a(a1c[36]),
     .cout(c2[53]), .sum(s2[53]));
mul_csa32  sc2_52_ ( .c(a0c[51]), .b(a0s[52]), .a(a1c[35]),
     .cout(c2[52]), .sum(s2[52]));
mul_csa32  sc2_51_ ( .c(a0c[50]), .b(a0s[51]), .a(a1c[34]),
     .cout(c2[51]), .sum(s2[51]));
mul_csa32  sc2_50_ ( .c(a0c[49]), .b(a0s[50]), .a(a1c[33]),
     .cout(c2[50]), .sum(s2[50]));
mul_csa32  sc2_49_ ( .c(a0c[48]), .b(a0s[49]), .a(a1c[32]),
     .cout(c2[49]), .sum(s2[49]));
mul_csa32  sc2_48_ ( .c(a0c[47]), .b(a0s[48]), .a(a1c[31]),
     .cout(c2[48]), .sum(s2[48]));
mul_csa32  sc2_47_ ( .c(a0c[46]), .b(a0s[47]), .a(a1c[30]),
     .cout(c2[47]), .sum(s2[47]));
mul_csa32  sc2_46_ ( .c(a0c[45]), .b(a0s[46]), .a(a1c[29]),
     .cout(c2[46]), .sum(s2[46]));
mul_csa32  sc2_45_ ( .c(a0c[44]), .b(a0s[45]), .a(a1c[28]),
     .cout(c2[45]), .sum(s2[45]));
mul_csa32  sc2_44_ ( .c(a0c[43]), .b(a0s[44]), .a(a1c[27]),
     .cout(c2[44]), .sum(s2[44]));
mul_csa32  sc2_43_ ( .c(a0c[42]), .b(a0s[43]), .a(a1c[26]),
     .cout(c2[43]), .sum(s2[43]));
mul_csa32  sc2_42_ ( .c(a0c[41]), .b(a0s[42]), .a(a1c[25]),
     .cout(c2[42]), .sum(s2[42]));
mul_csa32  sc2_41_ ( .c(a0c[40]), .b(a0s[41]), .a(a1c[24]),
     .cout(c2[41]), .sum(s2[41]));
mul_csa32  sc2_40_ ( .c(a0c[39]), .b(a0s[40]), .a(a1c[23]),
     .cout(c2[40]), .sum(s2[40]));
mul_csa32  sc2_39_ ( .c(a0c[38]), .b(a0s[39]), .a(a1c[22]),
     .cout(c2[39]), .sum(s2[39]));
mul_csa32  sc2_38_ ( .c(a0c[37]), .b(a0s[38]), .a(a1c[21]),
     .cout(c2[38]), .sum(s2[38]));
mul_csa32  sc2_37_ ( .c(a0c[36]), .b(a0s[37]), .a(a1c[20]),
     .cout(c2[37]), .sum(s2[37]));
mul_csa32  sc2_36_ ( .c(a0c[35]), .b(a0s[36]), .a(a1c[19]),
     .cout(c2[36]), .sum(s2[36]));
mul_csa32  sc2_35_ ( .c(a0c[34]), .b(a0s[35]), .a(a1c[18]),
     .cout(c2[35]), .sum(s2[35]));
mul_csa32  sc2_34_ ( .c(a0c[33]), .b(a0s[34]), .a(a1c[17]),
     .cout(c2[34]), .sum(s2[34]));
mul_csa32  sc2_33_ ( .c(a0c[32]), .b(a0s[33]), .a(a1c[16]),
     .cout(c2[33]), .sum(s2[33]));
mul_csa32  sc2_32_ ( .c(a0c[31]), .b(a0s[32]), .a(a1c[15]),
     .cout(c2[32]), .sum(s2[32]));
mul_csa32  sc2_31_ ( .c(a0c[30]), .b(a0s[31]), .a(a1c[14]),
     .cout(c2[31]), .sum(s2[31]));
mul_csa32  sc2_30_ ( .c(a0c[29]), .b(a0s[30]), .a(a1c[13]),
     .cout(c2[30]), .sum(s2[30]));
mul_csa32  sc2_29_ ( .c(a0c[28]), .b(a0s[29]), .a(a1c[12]),
     .cout(c2[29]), .sum(s2[29]));
mul_csa32  sc2_28_ ( .c(a0c[27]), .b(a0s[28]), .a(a1c[11]),
     .cout(c2[28]), .sum(s2[28]));
mul_csa32  sc2_27_ ( .c(a0c[26]), .b(a0s[27]), .a(a1c[10]),
     .cout(c2[27]), .sum(s2[27]));
mul_csa32  sc2_26_ ( .c(a0c[25]), .b(a0s[26]), .a(a1c[9]),
     .cout(c2[26]), .sum(s2[26]));
mul_csa32  sc2_25_ ( .c(a0c[24]), .b(a0s[25]), .a(a1c[8]),
     .cout(c2[25]), .sum(s2[25]));
mul_csa32  sc2_24_ ( .c(a0c[23]), .b(a0s[24]), .a(a1c[7]),
     .cout(c2[24]), .sum(s2[24]));
mul_csa32  sc2_23_ ( .c(a0c[22]), .b(a0s[23]), .a(a1c[6]),
     .cout(c2[23]), .sum(s2[23]));
mul_csa32  sc2_22_ ( .c(a0c[21]), .b(a0s[22]), .a(a1c[5]),
     .cout(c2[22]), .sum(s2[22]));
mul_csa32  sc2_21_ ( .c(a0c[20]), .b(a0s[21]), .a(a1c[4]),
     .cout(c2[21]), .sum(s2[21]));
mul_csa32  sc2_20_ ( .c(a0c[19]), .b(a0s[20]), .a(1'b0),
     .cout(c2[20]), .sum(s2[20]));
mul_csa32  sc1_66_ ( .c(a1s[50]), .b(pc[97]), .a(ps[98]),
     .cout(c1[66]), .sum(s1[66]));
mul_csa32  sc1_65_ ( .c(a1s[49]), .b(pc[96]), .a(ps[97]),
     .cout(c1[65]), .sum(s1[65]));
mul_csa32  sc1_64_ ( .c(a1s[48]), .b(pc[95]), .a(ps[96]),
     .cout(c1[64]), .sum(s1[64]));
mul_csa32  sc1_63_ ( .c(a1s[47]), .b(pc[94]), .a(ps[95]),
     .cout(c1[63]), .sum(s1[63]));
mul_csa32  sc1_62_ ( .c(a1s[46]), .b(pc[93]), .a(ps[94]),
     .cout(c1[62]), .sum(s1[62]));
mul_csa32  sc1_61_ ( .c(a1s[45]), .b(pc[92]), .a(ps[93]),
     .cout(c1[61]), .sum(s1[61]));
mul_csa32  sc1_60_ ( .c(a1s[44]), .b(pc[91]), .a(ps[92]),
     .cout(c1[60]), .sum(s1[60]));
mul_csa32  sc1_59_ ( .c(a1s[43]), .b(pc[90]), .a(ps[91]),
     .cout(c1[59]), .sum(s1[59]));
mul_csa32  sc1_58_ ( .c(a1s[42]), .b(pc[89]), .a(ps[90]),
     .cout(c1[58]), .sum(s1[58]));
mul_csa32  sc1_57_ ( .c(a1s[41]), .b(pc[88]), .a(ps[89]),
     .cout(c1[57]), .sum(s1[57]));
mul_csa32  sc1_56_ ( .c(a1s[40]), .b(pc[87]), .a(ps[88]),
     .cout(c1[56]), .sum(s1[56]));
mul_csa32  sc1_55_ ( .c(a1s[39]), .b(pc[86]), .a(ps[87]),
     .cout(c1[55]), .sum(s1[55]));
mul_csa32  sc1_54_ ( .c(a1s[38]), .b(pc[85]), .a(ps[86]),
     .cout(c1[54]), .sum(s1[54]));
mul_csa32  sc1_53_ ( .c(a1s[37]), .b(pc[84]), .a(ps[85]),
     .cout(c1[53]), .sum(s1[53]));
mul_csa32  sc1_52_ ( .c(a1s[36]), .b(pc[83]), .a(ps[84]),
     .cout(c1[52]), .sum(s1[52]));
mul_csa32  sc1_51_ ( .c(a1s[35]), .b(pc[82]), .a(ps[83]),
     .cout(c1[51]), .sum(s1[51]));
mul_csa32  sc1_50_ ( .c(a1s[34]), .b(pc[81]), .a(ps[82]),
     .cout(c1[50]), .sum(s1[50]));
mul_csa32  sc1_49_ ( .c(a1s[33]), .b(pc[80]), .a(ps[81]),
     .cout(c1[49]), .sum(s1[49]));
mul_csa32  sc1_48_ ( .c(a1s[32]), .b(pc[79]), .a(ps[80]),
     .cout(c1[48]), .sum(s1[48]));
mul_csa32  sc1_47_ ( .c(a1s[31]), .b(pc[78]), .a(ps[79]),
     .cout(c1[47]), .sum(s1[47]));
mul_csa32  sc1_46_ ( .c(a1s[30]), .b(pc[77]), .a(ps[78]),
     .cout(c1[46]), .sum(s1[46]));
mul_csa32  sc1_45_ ( .c(a1s[29]), .b(pc[76]), .a(ps[77]),
     .cout(c1[45]), .sum(s1[45]));
mul_csa32  sc1_44_ ( .c(a1s[28]), .b(pc[75]), .a(ps[76]),
     .cout(c1[44]), .sum(s1[44]));
mul_csa32  sc1_43_ ( .c(a1s[27]), .b(pc[74]), .a(ps[75]),
     .cout(c1[43]), .sum(s1[43]));
mul_csa32  sc1_42_ ( .c(a1s[26]), .b(pc[73]), .a(ps[74]),
     .cout(c1[42]), .sum(s1[42]));
mul_csa32  sc1_41_ ( .c(a1s[25]), .b(pc[72]), .a(ps[73]),
     .cout(c1[41]), .sum(s1[41]));
mul_csa32  sc1_40_ ( .c(a1s[24]), .b(pc[71]), .a(ps[72]),
     .cout(c1[40]), .sum(s1[40]));
mul_csa32  sc1_39_ ( .c(a1s[23]), .b(pc[70]), .a(ps[71]),
     .cout(c1[39]), .sum(s1[39]));
mul_csa32  sc1_38_ ( .c(a1s[22]), .b(pc[69]), .a(ps[70]),
     .cout(c1[38]), .sum(s1[38]));
mul_csa32  sc1_37_ ( .c(a1s[21]), .b(pc[68]), .a(ps[69]),
     .cout(c1[37]), .sum(s1[37]));
mul_csa32  sc1_36_ ( .c(a1s[20]), .b(pc[67]), .a(ps[68]),
     .cout(c1[36]), .sum(s1[36]));
mul_csa32  sc1_35_ ( .c(a1s[19]), .b(pc[66]), .a(ps[67]),
     .cout(c1[35]), .sum(s1[35]));
mul_csa32  sc1_34_ ( .c(a1s[18]), .b(pc[65]), .a(ps[66]),
     .cout(c1[34]), .sum(s1[34]));
mul_csa32  sc1_33_ ( .c(a1s[17]), .b(pc[64]), .a(ps[65]),
     .cout(c1[33]), .sum(s1[33]));
mul_csa32  sc1_32_ ( .c(a1s[16]), .b(pc[63]), .a(ps[64]),
     .cout(c1[32]), .sum(s1[32]));
mul_csa32  sc1_31_ ( .c(a1s[15]), .b(pc[62]), .a(ps[63]),
     .cout(c1[31]), .sum(s1[31]));
mul_csa32  sc1_30_ ( .c(a1s[14]), .b(pc[61]), .a(ps[62]),
     .cout(c1[30]), .sum(s1[30]));
mul_csa32  sc1_29_ ( .c(a1s[13]), .b(pc[60]), .a(ps[61]),
     .cout(c1[29]), .sum(s1[29]));
mul_csa32  sc1_28_ ( .c(a1s[12]), .b(pc[59]), .a(ps[60]),
     .cout(c1[28]), .sum(s1[28]));
mul_csa32  sc1_27_ ( .c(a1s[11]), .b(pc[58]), .a(ps[59]),
     .cout(c1[27]), .sum(s1[27]));
mul_csa32  sc1_26_ ( .c(a1s[10]), .b(pc[57]), .a(ps[58]),
     .cout(c1[26]), .sum(s1[26]));
mul_csa32  sc1_25_ ( .c(a1s[9]), .b(pc[56]), .a(ps[57]),
     .cout(c1[25]), .sum(s1[25]));
mul_csa32  sc1_24_ ( .c(a1s[8]), .b(pc[55]), .a(ps[56]),
     .cout(c1[24]), .sum(s1[24]));
mul_csa32  sc1_23_ ( .c(a1s[7]), .b(pc[54]), .a(ps[55]),
     .cout(c1[23]), .sum(s1[23]));
mul_csa32  sc1_22_ ( .c(a1s[6]), .b(pc[53]), .a(ps[54]),
     .cout(c1[22]), .sum(s1[22]));
mul_csa32  sc1_21_ ( .c(a1s[5]), .b(pc[52]), .a(ps[53]),
     .cout(c1[21]), .sum(s1[21]));
mul_csa32  sc1_20_ ( .c(a1s[4]), .b(pc[51]), .a(ps[52]),
     .cout(c1[20]), .sum(s1[20]));
mul_csa32  sc2_81_ ( .c(a0c[80]), .b(c1[80]), .a(s1[81]),
     .cout(c2[81]), .sum(s2[81]));
mul_csa32  sc2_80_ ( .c(a0c[79]), .b(c1[79]), .a(s1[80]),
     .cout(c2[80]), .sum(s2[80]));
mul_csa32  sc2_79_ ( .c(a0c[78]), .b(c1[78]), .a(s1[79]),
     .cout(c2[79]), .sum(s2[79]));
mul_csa32  sc2_78_ ( .c(a0c[77]), .b(c1[77]), .a(s1[78]),
     .cout(c2[78]), .sum(s2[78]));
mul_csa32  sc2_77_ ( .c(a0c[76]), .b(c1[76]), .a(s1[77]),
     .cout(c2[77]), .sum(s2[77]));
mul_csa32  sc2_76_ ( .c(a0c[75]), .b(c1[75]), .a(s1[76]),
     .cout(c2[76]), .sum(s2[76]));
mul_csa32  sc2_75_ ( .c(a0c[74]), .b(c1[74]), .a(s1[75]),
     .cout(c2[75]), .sum(s2[75]));
mul_csa32  sc2_74_ ( .c(a0c[73]), .b(c1[73]), .a(s1[74]),
     .cout(c2[74]), .sum(s2[74]));
mul_csa32  sc2_73_ ( .c(a0c[72]), .b(c1[72]), .a(s1[73]),
     .cout(c2[73]), .sum(s2[73]));
mul_csa32  sc2_72_ ( .c(a0c[71]), .b(c1[71]), .a(s1[72]),
     .cout(c2[72]), .sum(s2[72]));
mul_csa32  sc2_71_ ( .c(a0c[70]), .b(c1[70]), .a(s1[71]),
     .cout(c2[71]), .sum(s2[71]));
mul_csa32  sc2_70_ ( .c(a0c[69]), .b(c1[69]), .a(s1[70]),
     .cout(c2[70]), .sum(s2[70]));
mul_csa32  sc2_69_ ( .c(a0c[68]), .b(c1[68]), .a(s1[69]),
     .cout(c2[69]), .sum(s2[69]));
mul_csa32  sc2_68_ ( .c(a0c[67]), .b(c1[67]), .a(s1[68]),
     .cout(c2[68]), .sum(s2[68]));
mul_csa32  acc_19_ ( .c(c3[18]), .b(s3[19]), .a(ain[19]),
     .cout(pcout[19]), .sum(psum[19]));
mul_csa32  acc_18_ ( .c(c3[17]), .b(s3[18]), .a(ain[18]),
     .cout(pcout[18]), .sum(psum[18]));
mul_csa32  acc_17_ ( .c(c3[16]), .b(s3[17]), .a(ain[17]),
     .cout(pcout[17]), .sum(psum[17]));
mul_csa32  acc_16_ ( .c(c3[15]), .b(s3[16]), .a(ain[16]),
     .cout(pcout[16]), .sum(psum[16]));
mul_csa32  acc_15_ ( .c(1'b0), .b(s3[15]), .a(ain[15]),
     .cout(pcout[15]), .sum(psum[15]));
mul_csa32  sc1_0_ ( .c(a0s[0]), .sum(s1[0]), .cout(c1[0]),
     .a(ps[32]), .b(pc[31]));
mul_csa32  sc1_67_ ( .c(a1c[50]), .b(pc[98]), .a(a1s[51]),
     .cout(c1[67]), .sum(s1[67]));
mul_ha acc_0_ ( .sum(psum[0]), .cout(pcout[0]), .a(ain[0]),
     .b(s2[0]));
mul_ha sc3_98_ ( .sum(psum[98]), .cout(pcout[98]), .a(bot),
     .b(a1c[81]));
mul_ha sc2_96_ ( .b(a1c[79]), .a(a1s[80]), .cout(c2[96]),
     .sum(s2[96]));
mul_ha sc2_95_ ( .b(a1c[78]), .a(a1s[79]), .cout(c2[95]),
     .sum(s2[95]));
mul_ha sc2_94_ ( .b(a1c[77]), .a(a1s[78]), .cout(c2[94]),
     .sum(s2[94]));
mul_ha sc2_93_ ( .b(a1c[76]), .a(a1s[77]), .cout(c2[93]),
     .sum(s2[93]));
mul_ha sc2_92_ ( .b(a1c[75]), .a(a1s[76]), .cout(c2[92]),
     .sum(s2[92]));
mul_ha sc2_91_ ( .b(a1c[74]), .a(a1s[75]), .cout(c2[91]),
     .sum(s2[91]));
mul_ha sc2_90_ ( .b(a1c[73]), .a(a1s[74]), .cout(c2[90]),
     .sum(s2[90]));
mul_ha sc2_89_ ( .b(a1c[72]), .a(a1s[73]), .cout(c2[89]),
     .sum(s2[89]));
mul_ha sc2_88_ ( .b(a1c[71]), .a(a1s[72]), .cout(c2[88]),
     .sum(s2[88]));
mul_ha sc2_87_ ( .b(a1c[70]), .a(a1s[71]), .cout(c2[87]),
     .sum(s2[87]));
mul_ha sc2_86_ ( .b(a1c[69]), .a(a1s[70]), .cout(c2[86]),
     .sum(s2[86]));
mul_ha sc2_85_ ( .b(a1c[68]), .a(a1s[69]), .cout(c2[85]),
     .sum(s2[85]));
mul_ha sc2_84_ ( .b(a1c[67]), .a(a1s[68]), .cout(c2[84]),
     .sum(s2[84]));
mul_ha sc3_81_ ( .b(c2[80]), .a(s2[81]), .cout(c3[81]),
     .sum(s3[81]));
mul_ha sc3_80_ ( .b(c2[79]), .a(s2[80]), .cout(c3[80]),
     .sum(s3[80]));
mul_ha sc3_79_ ( .b(c2[78]), .a(s2[79]), .cout(c3[79]),
     .sum(s3[79]));
mul_ha sc3_78_ ( .b(c2[77]), .a(s2[78]), .cout(c3[78]),
     .sum(s3[78]));
mul_ha sc3_77_ ( .b(c2[76]), .a(s2[77]), .cout(c3[77]),
     .sum(s3[77]));
mul_ha sc3_76_ ( .b(c2[75]), .a(s2[76]), .cout(c3[76]),
     .sum(s3[76]));
mul_ha sc3_75_ ( .b(c2[74]), .a(s2[75]), .cout(c3[75]),
     .sum(s3[75]));
mul_ha sc3_74_ ( .b(c2[73]), .a(s2[74]), .cout(c3[74]),
     .sum(s3[74]));
mul_ha sc3_73_ ( .b(c2[72]), .a(s2[73]), .cout(c3[73]),
     .sum(s3[73]));
mul_ha sc3_72_ ( .b(c2[71]), .a(s2[72]), .cout(c3[72]),
     .sum(s3[72]));
mul_ha sc3_71_ ( .b(c2[70]), .a(s2[71]), .cout(c3[71]),
     .sum(s3[71]));
mul_ha sc3_70_ ( .b(c2[69]), .a(s2[70]), .cout(c3[70]),
     .sum(s3[70]));
mul_ha sc3_69_ ( .b(c2[68]), .a(s2[69]), .cout(c3[69]),
     .sum(s3[69]));
mul_ha accx2 ( .sum(psumx2), .cout(pcoutx2), .a(ainx2), .b(s1x2));
mul_ha sc2_4_ ( .sum(s2[4]), .cout(c2[4]), .a(s1[4]), .b(c1[3]));
mul_ha sc2_3_ ( .sum(s2[3]), .cout(c2[3]), .a(s1[3]), .b(c1[2]));
mul_ha sc2_2_ ( .sum(s2[2]), .cout(c2[2]), .a(s1[2]), .b(c1[1]));
mul_ha sc2_1_ ( .sum(s2[1]), .cout(c2[1]), .a(s1[1]), .b(c1[0]));
mul_ha sc2_0_ ( .sum(s2[0]), .cout(c2[0]), .a(s1[0]), .b(c1x2));
mul_ha sc1x2 ( .sum(s1x2), .cout(c1x2), .a(ps[31]), .b(pc[30]));

endmodule //mul_array2

module mul_csa32 (sum, cout, a, b, c);

output sum, cout;
input a, b, c;

wire x, y0, y1, y2;

assign x = a ^ b;
assign sum = c ^ x;

assign y0 = a & b ;
assign y1 = a & c ;
assign y2 = b & c ;

assign cout = y0 | y1 | y2 ;

endmodule //mul_csa32

module mul_csa42 (sum, carry, cout, a, b, c, d, cin);

output sum, carry, cout;
input a, b, c, d, cin;

wire x, y, z;

assign x = a ^ b;
assign y = c ^ d;
assign z = x ^ y;

assign sum = z ^ cin ;

assign carry = (b & ~z) | (cin & z);

assign cout = (d & ~y) | (a & y);

endmodule // mul_csa42

module mul_ha ( cout, sum, a, b );
output  cout, sum;
input  a, b;

assign sum = a ^ b;
assign cout = a & b ;

endmodule //mul_ha

module mul_negen ( n0, n1, b );
output  n0, n1;
input [2:0]  b;

assign n0 = b[2] & b[1] & ~b[0] ;
assign n1 = b[2] & b[1] & b[0] ;

endmodule //mul_negen

module mul_ppgen3lsb4 (cout, p0_l, p1_l, sum, a, b0, b1 );

output  p0_l, p1_l;
output [3:0]  sum;
output [3:1]  cout;
input [3:0]  a;
input [2:0]  b0;
input [2:0]  b1;

wire b0n, b0n_0, b0n_1, b1n_0, b1n_1;
wire p0_0, p0_1, p0_2, p0_3, p1_2, p1_3;
wire p0_l_0, p0_l_1, p0_l_2, p1_l_2;

assign b0n = b0n_1 | (b0n_0 & p0_0) ;
assign sum[0] = b0n_0 ^ p0_0 ;

mul_negen p0n ( .b(b0[2:0]), .n1(b0n_1), .n0(b0n_0));
mul_negen p1n ( .b(b1[2:0]), .n1(b1n_1), .n0(b1n_0));
mul_csa32  sc1_2_ ( .c(b1n_0), .sum(sum[2]), .cout(cout[2]),
     .a(p0_2), .b(p1_2));
mul_csa32  sc1_3_ ( .c(b1n_1), .sum(sum[3]), .cout(cout[3]),
     .a(p0_3), .b(p1_3));
mul_ha sc1_1_ ( .sum(sum[1]), .cout(cout[1]), .a(p0_1),
     .b(b0n));
mul_ppgen p0_3_ ( .pm1_l(p0_l_2), .p_l(p0_l), .b(b0[2:0]), .a(a[3]),
     .z(p0_3));
mul_ppgen p1_3_ ( .pm1_l(p1_l_2), .p_l(p1_l), .b(b1[2:0]), .a(a[1]),
     .z(p1_3));
mul_ppgen p0_2_ ( .pm1_l(p0_l_1), .p_l(p0_l_2), .b(b0[2:0]),
     .a(a[2]), .z(p0_2));
mul_ppgen p0_1_ ( .pm1_l(p0_l_0), .p_l(p0_l_1), .b(b0[2:0]),
     .a(a[1]), .z(p0_1));
mul_ppgen p0_0_ ( .pm1_l(1'b1), .p_l(p0_l_0),
     .b(b0[2:0]), .a(a[0]), .z(p0_0));
mul_ppgen p1_2_ ( .pm1_l(1'b1), .p_l(p1_l_2),
     .b(b1[2:0]), .a(a[0]), .z(p1_2));

endmodule // mul_ppgen3lsb4

module mul_ppgen3sign ( cout, sum, am1, am2, am3, am4, b0, b1, b2,
     bot, head, p0m1_l, p1m1_l, p2m1_l );
input  am1, am2, am3, am4;
input  bot, head, p0m1_l, p1m1_l, p2m1_l;
output [5:0]  sum;
output [4:0]  cout;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net37, net42, net075, net088, net0117; 
wire net47, net073, net38, net0118, net078, net8, net15, net43, net48, net35;
wire p2_l_67, p2_l_66, p2_l_65, p2_l_64; 
wire p1_l_65, p1_l_64; 

assign sum[5] = bot & net075 ;
assign net0117 = head & net088 ; 
assign net37 = ~net0117 ;
assign net42 = head ^ net088 ;

mul_ppgensign p0_64_ ( .b(b0[2:0]), .z(net47), .p_l(net088),
     .pm1_l(p0m1_l));
mul_ppgensign p2_68_ ( .pm1_l(p2_l_67), .b(b2[2:0]), .z(net073),
     .p_l(net075));
mul_ppgensign p1_66_ ( .pm1_l(p1_l_65), .b(b1[2:0]), .z(net38),
     .p_l(net0118));
mul_ha sc1_68_ ( .b(net073), .a(1'b1), .cout(cout[4]),
     .sum(sum[4]));
mul_ppgen p2_67_ ( .pm1_l(p2_l_66), .b(b2[2:0]), .a(am1), .z(net078),
     .p_l(p2_l_67));
mul_ppgen p2_66_ ( .pm1_l(p2_l_65), .b(b2[2:0]), .a(am2), .z(net8),
     .p_l(p2_l_66));
mul_ppgen p2_65_ ( .pm1_l(p2_l_64), .p_l(p2_l_65), .b(b2[2:0]),
     .a(am3), .z(net15));
mul_ppgen p1_65_ ( .pm1_l(p1_l_64), .p_l(p1_l_65), .b(b1[2:0]),
     .a(am1), .z(net43));
mul_ppgen p1_64_ ( .pm1_l(p1m1_l), .p_l(p1_l_64), .b(b1[2:0]),
     .a(am2), .z(net48));
mul_ppgen p2_64_ ( .pm1_l(p2m1_l), .p_l(p2_l_64), .b(b2[2:0]),
     .a(am4), .z(net35));
mul_csa32  sc1_67_ ( .c(net078), .b(net0117), .a(net0118),
     .cout(cout[3]), .sum(sum[3]));
mul_csa32  sc1_66_ ( .c(net8), .b(net37), .a(net38), .cout(cout[2]),
     .sum(sum[2]));
mul_csa32  sc1_65_ ( .c(net15), .b(net42), .a(net43), .cout(cout[1]),
     .sum(sum[1]));
mul_csa32  sc1_64_ ( .c(net35), .b(net47), .a(net48), .cout(cout[0]),
     .sum(sum[0]));

endmodule //mul_ppgen3sign

module mul_ppgen3 ( cout, p0_l, p1_l, p2_l, sum, am2, am4,
     a, b0, b1, b2, p0m1_l, p1m1_l, p2m1_l );
output  cout, p0_l, p1_l, p2_l, sum;
input  am2, am4;
input  a, p0m1_l, p1m1_l, p2m1_l;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net046, net32, net043;

mul_csa32  sc1 ( .a(net046), .b(net32), .cout(cout), .sum(sum),
     .c(net043));
mul_ppgen p2 ( .pm1_l(p2m1_l), .p_l(p2_l), .b(b2[2:0]), .a(am4),
     .z(net043));
mul_ppgen p1 ( .pm1_l(p1m1_l), .p_l(p1_l), .b(b1[2:0]), .a(am2),
     .z(net046));
mul_ppgen p0 ( .pm1_l(p0m1_l), .p_l(p0_l), .b(b0[2:0]), .a(a),
     .z(net32));

endmodule // mul_ppgen3

module mul_ppgenrow3 ( cout, sum, a, b0, b1, b2, bot, head );

output [68:1]  cout;
output [69:0]  sum;
input [63:0]  a;
input [2:0]  b2;
input [2:0]  b0;
input [2:0]  b1;
input  bot, head;

// Buses in the design
wire  [63:4]  p2_l;
wire  [63:3]  p1_l;
wire  [63:3]  p0_l;

mul_ppgen3sign I2 ( .am4(a[60]), .am3(a[61]), .am2(a[62]),
     .am1(a[63]), .p2m1_l(p2_l[63]), .p1m1_l(p1_l[63]),
     .p0m1_l(p0_l[63]), .b2(b2[2:0]), .head(head), .bot(bot),
     .sum(sum[69:64]), .cout(cout[68:64]), .b1(b1[2:0]), .b0(b0[2:0]));
mul_ppgen3 I1_63_ ( .p2_l(p2_l[63]), .b2(b2[2:0]),
     .am2(a[61]), .a(a[63]), .p2m1_l(p2_l[62]),
     .p1m1_l(p1_l[62]), .p0m1_l(p0_l[62]), .am4(a[59]), .sum(sum[63]),
     .cout(cout[63]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[63]),
     .p0_l(p0_l[63]));
mul_ppgen3 I1_62_ ( .p2_l(p2_l[62]), .b2(b2[2:0]), 
     .am2(a[60]), .a(a[62]), .p2m1_l(p2_l[61]),
     .p1m1_l(p1_l[61]), .p0m1_l(p0_l[61]), .am4(a[58]), .sum(sum[62]),
     .cout(cout[62]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[62]),
     .p0_l(p0_l[62]));
mul_ppgen3 I1_61_ ( .p2_l(p2_l[61]), .b2(b2[2:0]), 
     .am2(a[59]), .a(a[61]), .p2m1_l(p2_l[60]),
     .p1m1_l(p1_l[60]), .p0m1_l(p0_l[60]), .am4(a[57]), .sum(sum[61]),
     .cout(cout[61]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[61]),
     .p0_l(p0_l[61]));
mul_ppgen3 I1_60_ ( .p2_l(p2_l[60]), .b2(b2[2:0]), 
     .am2(a[58]), .a(a[60]), .p2m1_l(p2_l[59]),
     .p1m1_l(p1_l[59]), .p0m1_l(p0_l[59]), .am4(a[56]), .sum(sum[60]),
     .cout(cout[60]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[60]),
     .p0_l(p0_l[60]));
mul_ppgen3 I1_59_ ( .p2_l(p2_l[59]), .b2(b2[2:0]), 
     .am2(a[57]), .a(a[59]), .p2m1_l(p2_l[58]),
     .p1m1_l(p1_l[58]), .p0m1_l(p0_l[58]), .am4(a[55]), .sum(sum[59]),
     .cout(cout[59]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[59]),
     .p0_l(p0_l[59]));
mul_ppgen3 I1_58_ ( .p2_l(p2_l[58]), .b2(b2[2:0]), 
     .am2(a[56]), .a(a[58]), .p2m1_l(p2_l[57]),
     .p1m1_l(p1_l[57]), .p0m1_l(p0_l[57]), .am4(a[54]), .sum(sum[58]),
     .cout(cout[58]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[58]),
     .p0_l(p0_l[58]));
mul_ppgen3 I1_57_ ( .p2_l(p2_l[57]), .b2(b2[2:0]), 
     .am2(a[55]), .a(a[57]), .p2m1_l(p2_l[56]),
     .p1m1_l(p1_l[56]), .p0m1_l(p0_l[56]), .am4(a[53]), .sum(sum[57]),
     .cout(cout[57]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[57]),
     .p0_l(p0_l[57]));
mul_ppgen3 I1_56_ ( .p2_l(p2_l[56]), .b2(b2[2:0]), 
     .am2(a[54]), .a(a[56]), .p2m1_l(p2_l[55]),
     .p1m1_l(p1_l[55]), .p0m1_l(p0_l[55]), .am4(a[52]), .sum(sum[56]),
     .cout(cout[56]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[56]),
     .p0_l(p0_l[56]));
mul_ppgen3 I1_55_ ( .p2_l(p2_l[55]), .b2(b2[2:0]), 
     .am2(a[53]), .a(a[55]), .p2m1_l(p2_l[54]),
     .p1m1_l(p1_l[54]), .p0m1_l(p0_l[54]), .am4(a[51]), .sum(sum[55]),
     .cout(cout[55]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[55]),
     .p0_l(p0_l[55]));
mul_ppgen3 I1_54_ ( .p2_l(p2_l[54]), .b2(b2[2:0]), 
     .am2(a[52]), .a(a[54]), .p2m1_l(p2_l[53]),
     .p1m1_l(p1_l[53]), .p0m1_l(p0_l[53]), .am4(a[50]), .sum(sum[54]),
     .cout(cout[54]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[54]),
     .p0_l(p0_l[54]));
mul_ppgen3 I1_53_ ( .p2_l(p2_l[53]), .b2(b2[2:0]), 
     .am2(a[51]), .a(a[53]), .p2m1_l(p2_l[52]),
     .p1m1_l(p1_l[52]), .p0m1_l(p0_l[52]), .am4(a[49]), .sum(sum[53]),
     .cout(cout[53]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[53]),
     .p0_l(p0_l[53]));
mul_ppgen3 I1_52_ ( .p2_l(p2_l[52]), .b2(b2[2:0]), 
     .am2(a[50]), .a(a[52]), .p2m1_l(p2_l[51]),
     .p1m1_l(p1_l[51]), .p0m1_l(p0_l[51]), .am4(a[48]), .sum(sum[52]),
     .cout(cout[52]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[52]),
     .p0_l(p0_l[52]));
mul_ppgen3 I1_51_ ( .p2_l(p2_l[51]), .b2(b2[2:0]), 
     .am2(a[49]), .a(a[51]), .p2m1_l(p2_l[50]),
     .p1m1_l(p1_l[50]), .p0m1_l(p0_l[50]), .am4(a[47]), .sum(sum[51]),
     .cout(cout[51]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[51]),
     .p0_l(p0_l[51]));
mul_ppgen3 I1_50_ ( .p2_l(p2_l[50]), .b2(b2[2:0]), 
     .am2(a[48]), .a(a[50]), .p2m1_l(p2_l[49]),
     .p1m1_l(p1_l[49]), .p0m1_l(p0_l[49]), .am4(a[46]), .sum(sum[50]),
     .cout(cout[50]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[50]),
     .p0_l(p0_l[50]));
mul_ppgen3 I1_49_ ( .p2_l(p2_l[49]), .b2(b2[2:0]), 
     .am2(a[47]), .a(a[49]), .p2m1_l(p2_l[48]),
     .p1m1_l(p1_l[48]), .p0m1_l(p0_l[48]), .am4(a[45]), .sum(sum[49]),
     .cout(cout[49]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[49]),
     .p0_l(p0_l[49]));
mul_ppgen3 I1_48_ ( .p2_l(p2_l[48]), .b2(b2[2:0]), 
     .am2(a[46]), .a(a[48]), .p2m1_l(p2_l[47]),
     .p1m1_l(p1_l[47]), .p0m1_l(p0_l[47]), .am4(a[44]), .sum(sum[48]),
     .cout(cout[48]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[48]),
     .p0_l(p0_l[48]));
mul_ppgen3 I1_47_ ( .p2_l(p2_l[47]), .b2(b2[2:0]), 
     .am2(a[45]), .a(a[47]), .p2m1_l(p2_l[46]),
     .p1m1_l(p1_l[46]), .p0m1_l(p0_l[46]), .am4(a[43]), .sum(sum[47]),
     .cout(cout[47]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[47]),
     .p0_l(p0_l[47]));
mul_ppgen3 I1_46_ ( .p2_l(p2_l[46]), .b2(b2[2:0]), 
     .am2(a[44]), .a(a[46]), .p2m1_l(p2_l[45]),
     .p1m1_l(p1_l[45]), .p0m1_l(p0_l[45]), .am4(a[42]), .sum(sum[46]),
     .cout(cout[46]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[46]),
     .p0_l(p0_l[46]));
mul_ppgen3 I1_45_ ( .p2_l(p2_l[45]), .b2(b2[2:0]), 
     .am2(a[43]), .a(a[45]), .p2m1_l(p2_l[44]),
     .p1m1_l(p1_l[44]), .p0m1_l(p0_l[44]), .am4(a[41]), .sum(sum[45]),
     .cout(cout[45]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[45]),
     .p0_l(p0_l[45]));
mul_ppgen3 I1_44_ ( .p2_l(p2_l[44]), .b2(b2[2:0]), 
     .am2(a[42]), .a(a[44]), .p2m1_l(p2_l[43]),
     .p1m1_l(p1_l[43]), .p0m1_l(p0_l[43]), .am4(a[40]), .sum(sum[44]),
     .cout(cout[44]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[44]),
     .p0_l(p0_l[44]));
mul_ppgen3 I1_43_ ( .p2_l(p2_l[43]), .b2(b2[2:0]), 
     .am2(a[41]), .a(a[43]), .p2m1_l(p2_l[42]),
     .p1m1_l(p1_l[42]), .p0m1_l(p0_l[42]), .am4(a[39]), .sum(sum[43]),
     .cout(cout[43]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[43]),
     .p0_l(p0_l[43]));
mul_ppgen3 I1_42_ ( .p2_l(p2_l[42]), .b2(b2[2:0]), 
     .am2(a[40]), .a(a[42]), .p2m1_l(p2_l[41]),
     .p1m1_l(p1_l[41]), .p0m1_l(p0_l[41]), .am4(a[38]), .sum(sum[42]),
     .cout(cout[42]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[42]),
     .p0_l(p0_l[42]));
mul_ppgen3 I1_41_ ( .p2_l(p2_l[41]), .b2(b2[2:0]), 
     .am2(a[39]), .a(a[41]), .p2m1_l(p2_l[40]),
     .p1m1_l(p1_l[40]), .p0m1_l(p0_l[40]), .am4(a[37]), .sum(sum[41]),
     .cout(cout[41]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[41]),
     .p0_l(p0_l[41]));
mul_ppgen3 I1_40_ ( .p2_l(p2_l[40]), .b2(b2[2:0]), 
     .am2(a[38]), .a(a[40]), .p2m1_l(p2_l[39]),
     .p1m1_l(p1_l[39]), .p0m1_l(p0_l[39]), .am4(a[36]), .sum(sum[40]),
     .cout(cout[40]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[40]),
     .p0_l(p0_l[40]));
mul_ppgen3 I1_39_ ( .p2_l(p2_l[39]), .b2(b2[2:0]), 
     .am2(a[37]), .a(a[39]), .p2m1_l(p2_l[38]),
     .p1m1_l(p1_l[38]), .p0m1_l(p0_l[38]), .am4(a[35]), .sum(sum[39]),
     .cout(cout[39]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[39]),
     .p0_l(p0_l[39]));
mul_ppgen3 I1_38_ ( .p2_l(p2_l[38]), .b2(b2[2:0]), 
     .am2(a[36]), .a(a[38]), .p2m1_l(p2_l[37]),
     .p1m1_l(p1_l[37]), .p0m1_l(p0_l[37]), .am4(a[34]), .sum(sum[38]),
     .cout(cout[38]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[38]),
     .p0_l(p0_l[38]));
mul_ppgen3 I1_37_ ( .p2_l(p2_l[37]), .b2(b2[2:0]), 
     .am2(a[35]), .a(a[37]), .p2m1_l(p2_l[36]),
     .p1m1_l(p1_l[36]), .p0m1_l(p0_l[36]), .am4(a[33]), .sum(sum[37]),
     .cout(cout[37]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[37]),
     .p0_l(p0_l[37]));
mul_ppgen3 I1_36_ ( .p2_l(p2_l[36]), .b2(b2[2:0]), 
     .am2(a[34]), .a(a[36]), .p2m1_l(p2_l[35]),
     .p1m1_l(p1_l[35]), .p0m1_l(p0_l[35]), .am4(a[32]), .sum(sum[36]),
     .cout(cout[36]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[36]),
     .p0_l(p0_l[36]));
mul_ppgen3 I1_35_ ( .p2_l(p2_l[35]), .b2(b2[2:0]), 
     .am2(a[33]), .a(a[35]), .p2m1_l(p2_l[34]),
     .p1m1_l(p1_l[34]), .p0m1_l(p0_l[34]), .am4(a[31]), .sum(sum[35]),
     .cout(cout[35]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[35]),
     .p0_l(p0_l[35]));
mul_ppgen3 I1_34_ ( .p2_l(p2_l[34]), .b2(b2[2:0]), 
     .am2(a[32]), .a(a[34]), .p2m1_l(p2_l[33]),
     .p1m1_l(p1_l[33]), .p0m1_l(p0_l[33]), .am4(a[30]), .sum(sum[34]),
     .cout(cout[34]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[34]),
     .p0_l(p0_l[34]));
mul_ppgen3 I1_33_ ( .p2_l(p2_l[33]), .b2(b2[2:0]), 
     .am2(a[31]), .a(a[33]), .p2m1_l(p2_l[32]),
     .p1m1_l(p1_l[32]), .p0m1_l(p0_l[32]), .am4(a[29]), .sum(sum[33]),
     .cout(cout[33]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[33]),
     .p0_l(p0_l[33]));
mul_ppgen3 I1_32_ ( .p2_l(p2_l[32]), .b2(b2[2:0]), 
     .am2(a[30]), .a(a[32]), .p2m1_l(p2_l[31]),
     .p1m1_l(p1_l[31]), .p0m1_l(p0_l[31]), .am4(a[28]), .sum(sum[32]),
     .cout(cout[32]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[32]),
     .p0_l(p0_l[32]));
mul_ppgen3 I1_31_ ( .p2_l(p2_l[31]), .b2(b2[2:0]), 
     .am2(a[29]), .a(a[31]), .p2m1_l(p2_l[30]),
     .p1m1_l(p1_l[30]), .p0m1_l(p0_l[30]), .am4(a[27]), .sum(sum[31]),
     .cout(cout[31]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[31]),
     .p0_l(p0_l[31]));
mul_ppgen3 I1_30_ ( .p2_l(p2_l[30]), .b2(b2[2:0]), 
     .am2(a[28]), .a(a[30]), .p2m1_l(p2_l[29]),
     .p1m1_l(p1_l[29]), .p0m1_l(p0_l[29]), .am4(a[26]), .sum(sum[30]),
     .cout(cout[30]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[30]),
     .p0_l(p0_l[30]));
mul_ppgen3 I1_29_ ( .p2_l(p2_l[29]), .b2(b2[2:0]), 
     .am2(a[27]), .a(a[29]), .p2m1_l(p2_l[28]),
     .p1m1_l(p1_l[28]), .p0m1_l(p0_l[28]), .am4(a[25]), .sum(sum[29]),
     .cout(cout[29]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[29]),
     .p0_l(p0_l[29]));
mul_ppgen3 I1_28_ ( .p2_l(p2_l[28]), .b2(b2[2:0]), 
     .am2(a[26]), .a(a[28]), .p2m1_l(p2_l[27]),
     .p1m1_l(p1_l[27]), .p0m1_l(p0_l[27]), .am4(a[24]), .sum(sum[28]),
     .cout(cout[28]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[28]),
     .p0_l(p0_l[28]));
mul_ppgen3 I1_27_ ( .p2_l(p2_l[27]), .b2(b2[2:0]), 
     .am2(a[25]), .a(a[27]), .p2m1_l(p2_l[26]),
     .p1m1_l(p1_l[26]), .p0m1_l(p0_l[26]), .am4(a[23]), .sum(sum[27]),
     .cout(cout[27]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[27]),
     .p0_l(p0_l[27]));
mul_ppgen3 I1_26_ ( .p2_l(p2_l[26]), .b2(b2[2:0]), 
     .am2(a[24]), .a(a[26]), .p2m1_l(p2_l[25]),
     .p1m1_l(p1_l[25]), .p0m1_l(p0_l[25]), .am4(a[22]), .sum(sum[26]),
     .cout(cout[26]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[26]),
     .p0_l(p0_l[26]));
mul_ppgen3 I1_25_ ( .p2_l(p2_l[25]), .b2(b2[2:0]), 
     .am2(a[23]), .a(a[25]), .p2m1_l(p2_l[24]),
     .p1m1_l(p1_l[24]), .p0m1_l(p0_l[24]), .am4(a[21]), .sum(sum[25]),
     .cout(cout[25]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[25]),
     .p0_l(p0_l[25]));
mul_ppgen3 I1_24_ ( .p2_l(p2_l[24]), .b2(b2[2:0]), 
     .am2(a[22]), .a(a[24]), .p2m1_l(p2_l[23]),
     .p1m1_l(p1_l[23]), .p0m1_l(p0_l[23]), .am4(a[20]), .sum(sum[24]),
     .cout(cout[24]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[24]),
     .p0_l(p0_l[24]));
mul_ppgen3 I1_23_ ( .p2_l(p2_l[23]), .b2(b2[2:0]), 
     .am2(a[21]), .a(a[23]), .p2m1_l(p2_l[22]),
     .p1m1_l(p1_l[22]), .p0m1_l(p0_l[22]), .am4(a[19]), .sum(sum[23]),
     .cout(cout[23]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[23]),
     .p0_l(p0_l[23]));
mul_ppgen3 I1_22_ ( .p2_l(p2_l[22]), .b2(b2[2:0]), 
     .am2(a[20]), .a(a[22]), .p2m1_l(p2_l[21]),
     .p1m1_l(p1_l[21]), .p0m1_l(p0_l[21]), .am4(a[18]), .sum(sum[22]),
     .cout(cout[22]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[22]),
     .p0_l(p0_l[22]));
mul_ppgen3 I1_21_ ( .p2_l(p2_l[21]), .b2(b2[2:0]), 
     .am2(a[19]), .a(a[21]), .p2m1_l(p2_l[20]),
     .p1m1_l(p1_l[20]), .p0m1_l(p0_l[20]), .am4(a[17]), .sum(sum[21]),
     .cout(cout[21]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[21]),
     .p0_l(p0_l[21]));
mul_ppgen3 I1_20_ ( .p2_l(p2_l[20]), .b2(b2[2:0]), 
     .am2(a[18]), .a(a[20]), .p2m1_l(p2_l[19]),
     .p1m1_l(p1_l[19]), .p0m1_l(p0_l[19]), .am4(a[16]), .sum(sum[20]),
     .cout(cout[20]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[20]),
     .p0_l(p0_l[20]));
mul_ppgen3 I1_19_ ( .p2_l(p2_l[19]), .b2(b2[2:0]), 
     .am2(a[17]), .a(a[19]), .p2m1_l(p2_l[18]),
     .p1m1_l(p1_l[18]), .p0m1_l(p0_l[18]), .am4(a[15]), .sum(sum[19]),
     .cout(cout[19]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[19]),
     .p0_l(p0_l[19]));
mul_ppgen3 I1_18_ ( .p2_l(p2_l[18]), .b2(b2[2:0]), 
     .am2(a[16]), .a(a[18]), .p2m1_l(p2_l[17]),
     .p1m1_l(p1_l[17]), .p0m1_l(p0_l[17]), .am4(a[14]), .sum(sum[18]),
     .cout(cout[18]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[18]),
     .p0_l(p0_l[18]));
mul_ppgen3 I1_17_ ( .p2_l(p2_l[17]), .b2(b2[2:0]), 
     .am2(a[15]), .a(a[17]), .p2m1_l(p2_l[16]),
     .p1m1_l(p1_l[16]), .p0m1_l(p0_l[16]), .am4(a[13]), .sum(sum[17]),
     .cout(cout[17]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[17]),
     .p0_l(p0_l[17]));
mul_ppgen3 I1_16_ ( .p2_l(p2_l[16]), .b2(b2[2:0]), 
     .am2(a[14]), .a(a[16]), .p2m1_l(p2_l[15]),
     .p1m1_l(p1_l[15]), .p0m1_l(p0_l[15]), .am4(a[12]), .sum(sum[16]),
     .cout(cout[16]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[16]),
     .p0_l(p0_l[16]));
mul_ppgen3 I1_15_ ( .p2_l(p2_l[15]), .b2(b2[2:0]), 
     .am2(a[13]), .a(a[15]), .p2m1_l(p2_l[14]),
     .p1m1_l(p1_l[14]), .p0m1_l(p0_l[14]), .am4(a[11]), .sum(sum[15]),
     .cout(cout[15]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[15]),
     .p0_l(p0_l[15]));
mul_ppgen3 I1_14_ ( .p2_l(p2_l[14]), .b2(b2[2:0]), 
     .am2(a[12]), .a(a[14]), .p2m1_l(p2_l[13]),
     .p1m1_l(p1_l[13]), .p0m1_l(p0_l[13]), .am4(a[10]), .sum(sum[14]),
     .cout(cout[14]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[14]),
     .p0_l(p0_l[14]));
mul_ppgen3 I1_13_ ( .p2_l(p2_l[13]), .b2(b2[2:0]), 
     .am2(a[11]), .a(a[13]), .p2m1_l(p2_l[12]),
     .p1m1_l(p1_l[12]), .p0m1_l(p0_l[12]), .am4(a[9]), .sum(sum[13]),
     .cout(cout[13]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[13]),
     .p0_l(p0_l[13]));
mul_ppgen3 I1_12_ ( .p2_l(p2_l[12]), .b2(b2[2:0]), 
     .am2(a[10]), .a(a[12]), .p2m1_l(p2_l[11]),
     .p1m1_l(p1_l[11]), .p0m1_l(p0_l[11]), .am4(a[8]), .sum(sum[12]),
     .cout(cout[12]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[12]),
     .p0_l(p0_l[12]));
mul_ppgen3 I1_11_ ( .p2_l(p2_l[11]), .b2(b2[2:0]), 
     .am2(a[9]), .a(a[11]), .p2m1_l(p2_l[10]),
     .p1m1_l(p1_l[10]), .p0m1_l(p0_l[10]), .am4(a[7]), .sum(sum[11]),
     .cout(cout[11]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[11]),
     .p0_l(p0_l[11]));
mul_ppgen3 I1_10_ ( .p2_l(p2_l[10]), .b2(b2[2:0]), 
     .am2(a[8]), .a(a[10]), .p2m1_l(p2_l[9]),
     .p1m1_l(p1_l[9]), .p0m1_l(p0_l[9]), .am4(a[6]), .sum(sum[10]),
     .cout(cout[10]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[10]),
     .p0_l(p0_l[10]));
mul_ppgen3 I1_9_ ( .p2_l(p2_l[9]), .b2(b2[2:0]), 
     .am2(a[7]), .a(a[9]), .p2m1_l(p2_l[8]),
     .p1m1_l(p1_l[8]), .p0m1_l(p0_l[8]), .am4(a[5]), .sum(sum[9]),
     .cout(cout[9]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[9]),
     .p0_l(p0_l[9]));
mul_ppgen3 I1_8_ ( .p2_l(p2_l[8]), .b2(b2[2:0]), 
     .am2(a[6]), .a(a[8]), .p2m1_l(p2_l[7]),
     .p1m1_l(p1_l[7]), .p0m1_l(p0_l[7]), .am4(a[4]), .sum(sum[8]),
     .cout(cout[8]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[8]),
     .p0_l(p0_l[8]));
mul_ppgen3 I1_7_ ( .p2_l(p2_l[7]), .b2(b2[2:0]), 
     .am2(a[5]), .a(a[7]), .p2m1_l(p2_l[6]),
     .p1m1_l(p1_l[6]), .p0m1_l(p0_l[6]), .am4(a[3]), .sum(sum[7]),
     .cout(cout[7]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[7]),
     .p0_l(p0_l[7]));
mul_ppgen3 I1_6_ ( .p2_l(p2_l[6]), .b2(b2[2:0]), 
     .am2(a[4]), .a(a[6]), .p2m1_l(p2_l[5]),
     .p1m1_l(p1_l[5]), .p0m1_l(p0_l[5]), .am4(a[2]), .sum(sum[6]),
     .cout(cout[6]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[6]),
     .p0_l(p0_l[6]));
mul_ppgen3 I1_5_ ( .p2_l(p2_l[5]), .b2(b2[2:0]), 
     .am2(a[3]), .a(a[5]), .p2m1_l(p2_l[4]),
     .p1m1_l(p1_l[4]), .p0m1_l(p0_l[4]), .am4(a[1]), .sum(sum[5]),
     .cout(cout[5]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[5]),
     .p0_l(p0_l[5]));
mul_ppgen3 I1_4_ ( .p2_l(p2_l[4]), .b2(b2[2:0]), 
     .am2(a[2]), .a(a[4]), .p2m1_l(1'b1),
     .p1m1_l(p1_l[3]), .p0m1_l(p0_l[3]), .am4(a[0]), .sum(sum[4]),
     .cout(cout[4]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[4]),
     .p0_l(p0_l[4]));
mul_ppgen3lsb4 I0 ( .cout(cout[3:1]), .a(a[3:0]), .sum(sum[3:0]),
     .p1_l(p1_l[3]), .p0_l(p0_l[3]), .b1(b1[2:0]), .b0(b0[2:0]));

endmodule //mul_ppgenrow3

module mul_ppgensign ( p_l, z, b, pm1_l );
output  p_l, z;
input  pm1_l;
input [2:0]  b;

assign p_l = ~(b[1] & b[2]);
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgensign

module mul_ppgen ( p_l, z, a, b, pm1_l );
output  p_l, z;
input  a, pm1_l;
input [2:0]  b;

assign p_l = ~((a ^ b[2]) & b[1]) ;
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgen

module mul_mux2 ( z, d0, d1, s );
output  z;
input  d0, d1, s;

assign z = s ? d1 : d0 ;

endmodule // mul_mux2 

module mul_booth(
	head,
        b_in,
        b0, b1, b2, b3, b4, b5, b6, b7,
	b8, b9, b10, b11, b12, b13, b14, b15, b16,
	clk, se, si, so, mul_step, tm_l
	);
input		head;		// begin of the MUL operation
input   [63:0] 	b_in;
input		clk, se, si, mul_step, tm_l;
output  [2:0]  	b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
output 		b16;
output 		so;

wire  [63:31] 	b;
wire [2:0] 	b0_in0, b1_in0,  b2_in0,  b3_in0,  b4_in0,  b5_in0,  b6_in0,  b7_in0 ;
wire [2:0] 	b8_in0, b9_in0, b10_in0, b11_in0, b12_in0, b13_in0, b14_in0, b15_in0 ;
wire [2:0] 	b0_in1, b1_in1,  b2_in1,  b3_in1,  b4_in1,  b5_in1,  b6_in1,  b7_in1 ;
wire [2:0] 	b8_in1, b9_in1, b10_in1, b11_in1, b12_in1, b13_in1, b14_in1, b15_in1 ;
wire 	   	b16_in1;

wire [2:0] 	b0_outmx, b1_outmx, b2_outmx, b3_outmx, b4_outmx, b5_outmx, b6_outmx;
wire [2:0] 	b7_outmx, b8_outmx, b9_outmx, b10_outmx, b11_outmx, b12_outmx, b13_outmx;
wire [2:0] 	b14_outmx, b15_outmx;
wire 	   	b16_outmx;
wire		clk_enb0, clk_enb1;


  mul_bodec 		encode0_a(
				.x  (1'b0),
				.b  (b_in[15:0]),
				.b0 (b0_in0),
				.b1 (b1_in0),
				.b2 (b2_in0),
				.b3 (b3_in0),
				.b4 (b4_in0),
				.b5 (b5_in0),
				.b6 (b6_in0),
				.b7 (b7_in0)
				);
				//remove 16th row since it's never the last row
				//b8_in0 = 3'b010; 
  mul_bodec		encode0_b(
				.x  (b_in[15]),
				.b  (b_in[31:16]),
				.b0 (b8_in0),
				.b1 (b9_in0),
				.b2 (b10_in0),
				.b3 (b11_in0),
				.b4 (b12_in0),
				.b5 (b13_in0),
				.b6 (b14_in0),
				.b7 (b15_in0)
				);
				// remove 32th row since it's never the last row 
				// b16_in0 = 3'b010 ;

  // Pipe picked address [63:31] and hold flop

  clken_buf     ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));
  clken_buf     ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(head & mul_step)), .tmb_l(tm_l));

  dff_s 			hld_dff0(.din(b_in[31]), .clk(clk_enb1), .q(b[31]),
                        	.se(se), .si(), .so());
  dff_s #(32) 		hld_dff(.din(b_in[63:32]), .clk(clk_enb1), .q(b[63:32]),
				.se(se), .si(), .so());

  mul_bodec     	encode1_a(
                        	.x  (b[31]),
                        	.b  (b[47:32]),
                        	.b0 (b0_in1),
                        	.b1 (b1_in1),
                        	.b2 (b2_in1),
                        	.b3 (b3_in1),
                        	.b4 (b4_in1),
                        	.b5 (b5_in1),
                        	.b6 (b6_in1),
                        	.b7 (b7_in1)
                        	);
                        	//remove 16th row since it's never the last row
                        	//b8_in1 = 3'b010;
  mul_bodec     	encode1_b(
                        	.x  (b[47]),
                        	.b  (b[63:48]),
                        	.b0 (b8_in1),
                        	.b1 (b9_in1),
                        	.b2 (b10_in1),
                        	.b3 (b11_in1),
                        	.b4 (b12_in1),
                        	.b5 (b13_in1),
                        	.b6 (b14_in1),
                        	.b7 (b15_in1)
                        	);
				assign b16_in1 = b[63] ;

// Select booth encoded b outputs and flop based on the cycle0 and cycle1 

  dp_mux2es #(3)    out_mux0(.dout(b0_outmx[2:0]),
                        .in0(b0_in0[2:0]),
                        .in1(b0_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux1(.dout(b1_outmx[2:0]),
                        .in0(b1_in0[2:0]),
                        .in1(b1_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux2(.dout(b2_outmx[2:0]),
                        .in0(b2_in0[2:0]),
                        .in1(b2_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux3(.dout(b3_outmx[2:0]),
                        .in0(b3_in0[2:0]),
                        .in1(b3_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux4(.dout(b4_outmx[2:0]),
                        .in0(b4_in0[2:0]),
                        .in1(b4_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux5(.dout(b5_outmx[2:0]),
                        .in0(b5_in0[2:0]),
                        .in1(b5_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux6(.dout(b6_outmx[2:0]),
                        .in0(b6_in0[2:0]),
                        .in1(b6_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux7(.dout(b7_outmx[2:0]),
                        .in0(b7_in0[2:0]),
                        .in1(b7_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux8(.dout(b8_outmx[2:0]),
                        .in0(b8_in0[2:0]),
                        .in1(b8_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux9(.dout(b9_outmx[2:0]),
                        .in0(b9_in0[2:0]),
                        .in1(b9_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux10(.dout(b10_outmx[2:0]),
                        .in0(b10_in0[2:0]),
                        .in1(b10_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux11(.dout(b11_outmx[2:0]),
                        .in0(b11_in0[2:0]),
                        .in1(b11_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux12(.dout(b12_outmx[2:0]),
                        .in0(b12_in0[2:0]),
                        .in1(b12_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux13(.dout(b13_outmx[2:0]),
                        .in0(b13_in0[2:0]),
                        .in1(b13_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux14(.dout(b14_outmx[2:0]),
                        .in0(b14_in0[2:0]),
                        .in1(b14_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux15(.dout(b15_outmx[2:0]),
                        .in0(b15_in0[2:0]),
                        .in1(b15_in1[2:0]),
                        .sel(~head));
  dp_mux2es         out_mux16(.dout(b16_outmx),
                        .in0(1'b0),
                        .in1(b16_in1),
                        .sel(~head));

  dff_s #(3)    out_dff0 (.din(b0_outmx[2:0]), .clk(clk_enb0), .q(b0[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff1 (.din(b1_outmx[2:0]), .clk(clk_enb0), .q(b1[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff2 (.din(b2_outmx[2:0]), .clk(clk_enb0), .q(b2[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff3 (.din(b3_outmx[2:0]), .clk(clk_enb0), .q(b3[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff4 (.din(b4_outmx[2:0]), .clk(clk_enb0), .q(b4[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff5 (.din(b5_outmx[2:0]), .clk(clk_enb0), .q(b5[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff6 (.din(b6_outmx[2:0]), .clk(clk_enb0), .q(b6[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff7 (.din(b7_outmx[2:0]), .clk(clk_enb0), .q(b7[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff8 (.din(b8_outmx[2:0]), .clk(clk_enb0), .q(b8[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff9 (.din(b9_outmx[2:0]), .clk(clk_enb0), .q(b9[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff10 (.din(b10_outmx[2:0]), .clk(clk_enb0), .q(b10[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff11 (.din(b11_outmx[2:0]), .clk(clk_enb0), .q(b11[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff12 (.din(b12_outmx[2:0]), .clk(clk_enb0), .q(b12[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff13 (.din(b13_outmx[2:0]), .clk(clk_enb0), .q(b13[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff14 (.din(b14_outmx[2:0]), .clk(clk_enb0), .q(b14[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff15 (.din(b15_outmx[2:0]), .clk(clk_enb0), .q(b15[2:0]),
			.se(se), .si(), .so());
  dff_s 	      out_dff16 (.din(b16_outmx), .clk(clk_enb0), .q(b16),
			.se(se), .si(), .so());
endmodule //mul_booth

module mul_bodec (x, b,  
        b0, b1, b2, b3, b4, b5, b6, b7);

input	x;
input   [15:0] 	b;
output  [2:0] 	b0, b1, b2, b3, b4, b5, b6, b7; 

assign b0[2] = b[1];
assign b0[1] = ~((b[1] & b[0] & x) | (~b[1] & ~b[0] & ~x)) ;
assign b0[0] = (~b[1] & b[0] & x) | (b[1] & ~b[0] & ~x) ;

assign b1[2] = b[3]; 
assign b1[1] = ~((b[3] & b[2] & b[1]) | (~b[3] & ~b[2] & ~b[1])) ;
assign b1[0] = (~b[3] & b[2] & b[1]) | (b[3] & ~b[2] & ~b[1]) ;

assign b2[2] = b[5]; 
assign b2[1] = ~((b[5] & b[4] & b[3]) | (~b[5] & ~b[4] & ~b[3])) ;
assign b2[0] = (~b[5] & b[4] & b[3]) | (b[5] & ~b[4] & ~b[3]) ;

assign b3[2] = b[7] ;
assign b3[1] = ~((b[7] & b[6] & b[5]) | (~b[7] & ~b[6] & ~b[5])) ;
assign b3[0] = (~b[7] & b[6] & b[5]) | (b[7] & ~b[6] & ~b[5]) ;

assign b4[2] = b[9] ;
assign b4[1] = ~((b[9] & b[8] & b[7]) | (~b[9] & ~b[8] & ~b[7])) ;
assign b4[0] = (~b[9] & b[8] & b[7]) | (b[9] & ~b[8] & ~b[7]) ;

assign b5[2] = b[11] ;
assign b5[1] = ~((b[11] & b[10] & b[9]) | (~b[11] & ~b[10] & ~b[9])) ;
assign b5[0] = (~b[11] & b[10] & b[9]) | (b[11] & ~b[10] & ~b[9]) ;

assign b6[2] = b[13] ;
assign b6[1] = ~((b[13] & b[12] & b[11]) | (~b[13] & ~b[12] & ~b[11])) ;
assign b6[0] = (~b[13] & b[12] & b[11]) | (b[13] & ~b[12] & ~b[11]) ;

assign b7[2] = b[15] ;
assign b7[1] = ~((b[15] & b[14] & b[13]) | (~b[15] & ~b[14] & ~b[13])) ;
assign b7[0] = (~b[15] & b[14] & b[13]) | (b[15] & ~b[14] & ~b[13]) ;

endmodule // mul_bodec

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_clib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: swrvr_clib.v
//      Description: Design control behavioural library
*/                 





// POSITVE-EDGE TRIGGERED FLOP with SCAN
module dff_s (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;










endmodule // dff_s

// POSITVE-EDGE TRIGGERED FLOP with SCAN for Shadow-scan
module dff_sscan (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;










always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;

assign so={SIZE{1'b0}};


endmodule // dff_sscan

// POSITVE-EDGE TRIGGERED FLOP without SCAN
module dff_ns (din, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)

	q[SIZE-1:0]  <= din[SIZE-1:0] ;

endmodule // dff_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET
module dffr_s (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= ((rst) ? {SIZE{1'b0}}  : din[SIZE-1:0] );










endmodule // dffr_s

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET_L
module dffrl_s (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;


always @ (posedge clk)
	q[SIZE-1:0]  <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};










endmodule // dffrl_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, without SCAN
module dffr_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];
   
endmodule // dffr_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, without SCAN
module dffrl_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};

endmodule // dffrl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN and FUNCTIONAL ENABLE
module dffe_s (din, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// en	se	out
//------------------
// x	1	sin ; scan dominates
// 1  	0	din
// 0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) ;









endmodule // dffe_s

// POSITIVE-EDGE TRIGGERED FLOP with enable, without SCAN
module dffe_ns (din, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)
  q[SIZE-1:0] <= en ? din[SIZE-1:0] : q[SIZE-1:0];

endmodule // dffe_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET, FUNCTIONAL ENABLE, SCAN.
module dffre_s (din, rst, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 1	x	x	0   ; reset dominates
// 0	x	1	sin ; scan dominates
// 0	1  	0	din
// 0 	0 	0	q
//


always @ (posedge clk)
	q[SIZE-1:0]  <= (rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) ;











endmodule // dffre_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, FUNCTIONAL ENABLE, SCAN.
module dffrle_s (din, rst_l, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 0	x	x	0   ; reset dominates
// 1	x	1	sin ; scan dominates
// 1	1  	0	din
// 1 	0 	0	q
//


always @ (posedge clk)
	 q[SIZE-1:0]  <= (rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}}) ;










endmodule // dffrle_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, ENABLE, without SCAN.
module dffre_ns (din, rst, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 1	x	0   ; reset dominates
// 0	1  	din
// 0 	0 	q
//

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0]);

endmodule // dffre_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, ENABLE, without SCAN.
module dffrle_ns (din, rst_l, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 0	x	0   ; reset dominates
// 1	1  	din
// 1 	0 	q
//

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}} ;

endmodule // dffrle_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET
module dffr_async (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or posedge rst)
	q[SIZE-1:0]  <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];










endmodule // dffr_async

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET_L
module dffrl_async (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;


always @ (posedge clk or negedge rst_l)
	q[SIZE-1:0]  <= (!rst_l) ? {SIZE{1'b0}} : din[SIZE-1:0];










endmodule // dffrl_async

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET, without SCAN
//module dffr_async_ns (din, clk, rst, q);
//// synopsys template
//parameter SIZE = 1;
//input   [SIZE-1:0]      din ;   // data in
//input                   clk ;   // clk or scan clk
//input                   rst ;   // reset
//output  [SIZE-1:0]      q ;     // output
//reg     [SIZE-1:0]      q ;
// Reset dominates
//// synopsys async_set_reset "rst"
//always @ (posedge clk or posedge rst)
//        if(rst) q[SIZE-1:0]  <= {SIZE{1'b0}};
//        else if(clk) q[SIZE-1:0]  <= din[SIZE-1:0];
//endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET_L, without SCAN
module dffrl_async_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

// Reset dominates
// synopsys async_set_reset "rst_l"
 reg [SIZE-1:0] q;   
always @ (posedge clk or negedge rst_l)
  q[SIZE-1:0] <= ~rst_l ?  {SIZE{1'b0}} : ({SIZE{rst_l}} & din[SIZE-1:0]);

//   reg  [SIZE-1:0]   qm, qs, qm_l, qs_l, qm_f, qs_f;
//   wire              s_l;
//   assign            s_l = 1'b1;
//
//   always @ (rst_l or qm)   qm_l = ~(qm & {SIZE{rst_l}});
//   always @ (s_l or qs)   qs_l = ~(qs & {SIZE{s_l}});
//   always @ (s_l or qm_l) qm_f = ~(qm_l & {SIZE{s_l}});
//   always @ (rst_l or qs_l) qs_f = ~(qs_l & {SIZE{rst_l}});
//
//   always @ (clk or din or qm_f)
//      qm <= clk ? qm_f : din;
//
//   always @ (clk or qm_l or qs_f)
//      qs <= clk ? qm_l : qs_f;
//
//   assign q  = ~qs;

endmodule // dffrl_async_ns

// 2:1 MUX WITH DECODED SELECTS
module mux2ds (dout, in0, in1, sel0, sel1) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel0;
input			sel1;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;

// priority encoding takes care of mutex'ing selects.




wire [1:0] sel = {sel1, sel0}; // 0in one_hot
   
always @ (sel0 or sel1 or in0 or in1)

	case ({sel1,sel0}) // synopsys infer_mux
		2'b01 :	dout = in0 ;
		2'b10 : dout = in1 ;
		2'b11 : dout = {SIZE{1'bx}} ;
		2'b00 : dout = {SIZE{1'bx}} ;
			// 2'b00 : // E.g. 4state vs. 2state modelling.
			// begin
			//	`ifdef FOUR_STATE
			//		dout = {SIZE{1'bx}};
			//	`else
			//		begin
			//		dout = {SIZE{1'b0}};
			//		$error();
			//		end
			//	`endif
			// end
		default : dout = {SIZE{1'bx}};
	endcase

endmodule // mux2ds

// 3:1 MUX WITH DECODED SELECTS
module mux3ds (dout, in0, in1, in2, sel0, sel1, sel2) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0;
input			sel1;
input			sel2;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or in0 or in1 or in2)

	case ({sel2,sel1,sel0}) 
		3'b001 : dout = in0 ;
		3'b010 : dout = in1 ;
		3'b100 : dout = in2 ;
		3'b000 : dout = {SIZE{1'bx}} ;
		3'b011 : dout = {SIZE{1'bx}} ;
		3'b101 : dout = {SIZE{1'bx}} ;
		3'b110 : dout = {SIZE{1'bx}} ;
		3'b111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux3ds

// 4:1 MUX WITH DECODED SELECTS
module mux4ds (dout, in0, in1, in2, in3, sel0, sel1, sel2, sel3) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0;
input			sel1;
input			sel2;
input			sel3;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [3:0] sel = {sel3,sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or sel3 or in0 or in1 or in2 or in3)

	case ({sel3,sel2,sel1,sel0}) 
		4'b0001 : dout = in0 ;
		4'b0010 : dout = in1 ;
		4'b0100 : dout = in2 ;
		4'b1000 : dout = in3 ;
		4'b0000 : dout = {SIZE{1'bx}} ;
		4'b0011 : dout = {SIZE{1'bx}} ;
		4'b0101 : dout = {SIZE{1'bx}} ;
		4'b0110 : dout = {SIZE{1'bx}} ;
		4'b0111 : dout = {SIZE{1'bx}} ;
		4'b1001 : dout = {SIZE{1'bx}} ;
		4'b1010 : dout = {SIZE{1'bx}} ;
		4'b1011 : dout = {SIZE{1'bx}} ;
		4'b1100 : dout = {SIZE{1'bx}} ;
		4'b1101 : dout = {SIZE{1'bx}} ;
		4'b1110 : dout = {SIZE{1'bx}} ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux4ds

// SINK FOR UNLOADED INPUT PORTS
module sink (in);
// synopsys template

parameter SIZE = 1;

input [SIZE-1:0] in;

// Alexey
// `ifdef PITON_PROTO
   // As of version 8.2 XST does not remove this module without the
   // following additional dead code

   wire    a;

   assign		a = | in;

// `endif

endmodule //sink

// SOURCE FOR UNDRIVEN OUTPUT PORTS
module source (out) ;
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0] out;
// 
// Once 4state/2state model established
// then enable check.
// `ifdef FOUR_STATE
// leda check for x_or_z_in rhs_of assign turned off
// assign  out = {SIZE{1'bx}};
//`else
assign  out = {SIZE{1'b0}};
//`endif

endmodule //source

// 2:1 MUX WITH PRIORITY ENCODED SELECTS
//module mux2es (dout, in0, in1, sel0, sel1) ;
//
//parameter SIZE = 1;
//
//output 	[SIZE-1:0] 	dout;
//input	[SIZE-1:0]	in0;
//input	[SIZE-1:0]	in1;
//input			sel0;
//input			sel1;
//
//// reg declaration does not imply state being maintained
//// across cycles. Used to construct case statement and
//// always updated by inputs every cycle.
//reg	[SIZE-1:0]	dout ;
//
//// must take into account lack of mutex selects.
//// there is no reason for handling of x and z conditions.
//// This will be dictated by design.
//always @ (sel0 or sel1 or in0 or in1)
//
//	case ({sel1,sel0})
//		2'b1x : dout = in1 ; // 10(in1),11(z) 
//		2'b0x :	dout = in0 ; // 01(in0),00(x)
//	endcase
//
//endmodule // mux2es

// CLK Header for gating off the clock of
// a FF.
// clk - output of the clk header
// rclk - input clk
// enb_l - Active low clock enable
// tmb_l  - Active low clock enable ( in scan mode, this input is !se )

module clken_buf (clk, rclk, enb_l, tmb_l);
output clk;
input  rclk, enb_l, tmb_l;
reg    clken;

  always @ (rclk or enb_l or tmb_l)
    if (!rclk)  //latch opens on rclk low phase
      clken = !enb_l | !tmb_l;
  assign clk = clken & rclk;

endmodule



// The following flops are maintained and used in ENET , MAC IP  ONLY
// -- Mimi X61467

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys sync_set_reset "set_l"
always @ (posedge clk)
  q[SIZE-1:0] <= set_l ? din[SIZE-1:0] : {SIZE{1'b1}};

endmodule // dffsl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_async_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys async_set_reset "set_l"
always @ (posedge clk or negedge set_l)
  q[SIZE-1:0] <= ~set_l ? {SIZE{1'b1}} : ({SIZE{~set_l}} | din[SIZE-1:0]);

endmodule // dffsl_async_ns

// POSITIVE-EDGE TRIGGERED FLOP WITH SET_H , without SCAN.

module dffr_ns_r1 (din, clk, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_ns_r1

// POSITIVE-EDGE TRIGGERED ASYNC RESET_H FLOP , without SCAN.

module dffr_async_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset dominates
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];

endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_r1 (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset to 1
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_r1


// NEGATIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_cl_r1 (din, clkl, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clkl ;  // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (negedge clkl or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_cl_r1

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_dlib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// DP library

// 2:1 MUX WITH ENCODED SELECT
module dp_mux2es (dout, in0, in1, sel) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel;

reg	[SIZE-1:0]	dout ;

always @ (sel or in0 or in1)

 begin
	   case (sel)
	     1'b1: dout = in1 ; 
	     1'b0: dout = in0;
	     default: 
         begin
            if (in0 == in1) begin
               dout = in0;
            end
            else
              dout = {SIZE{1'bx}};
         end
	   endcase // case(sel)
 end

endmodule // dp_mux2es

// ----------------------------------------------------------------------


// 4:1 MUX WITH DECODED SELECTS
module dp_mux4ds (dout, in0, in1, in2, in3, 
		     sel0_l, sel1_l, sel2_l, sel3_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [3:0] sel = {sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3)

	case ({sel3_l,sel2_l,sel1_l,sel0_l})
		4'b1110 : dout = in0 ;
		4'b1101 : dout = in1 ;
		4'b1011 : dout = in2 ;
		4'b0111 : dout = in3 ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux4ds

// ----------------------------------------------------------------------


// 5:1 MUX WITH DECODED SELECTS
module dp_mux5ds (dout, in0, in1, in2, in3,  in4,
		     sel0_l, sel1_l, sel2_l, sel3_l, sel4_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [4:0] sel = {sel4_l,sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or sel4_l or
		in0 or in1 or in2 or in3 or in4)

	case ({sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		5'b11110 : dout = in0 ;
		5'b11101 : dout = in1 ;
		5'b11011 : dout = in2 ;
		5'b10111 : dout = in3 ;
		5'b01111 : dout = in4 ;
		5'b11111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux5ds

// --------------------------------------------------------------------

// 8:1 MUX WITH DECODED SELECTS
module dp_mux8ds (dout, in0, in1, in2, in3, 
			in4, in5, in6, in7,
		     sel0_l, sel1_l, sel2_l, sel3_l,
		     sel4_l, sel5_l, sel6_l, sel7_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input	[SIZE-1:0]	in5;
input	[SIZE-1:0]	in6;
input	[SIZE-1:0]	in7;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;
input			sel5_l;
input			sel6_l;
input			sel7_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;






wire [7:0] sel = {sel7_l,sel6_l,sel5_l,sel4_l,
                  sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3 or
	  sel4_l or sel5_l or sel6_l or sel7_l or in4 or in5 or in6 or in7)

	case ({sel7_l,sel6_l,sel5_l,sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		8'b11111110 : dout = in0 ;
		8'b11111101 : dout = in1 ;
		8'b11111011 : dout = in2 ;
		8'b11110111 : dout = in3 ;
		8'b11101111 : dout = in4 ;
		8'b11011111 : dout = in5 ;
		8'b10111111 : dout = in6 ;
		8'b01111111 : dout = in7 ;
		8'b11111111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux8ds


// ----------------------------------------------------------------------


// 3:1 MUX WITH DECODED SELECTS
module dp_mux3ds (dout, in0, in1, in2, 
		     sel0_l, sel1_l, sel2_l);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0_l;
input			sel1_l;
input			sel2_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or in0 or in1 or in2)

	case ({sel2_l,sel1_l,sel0_l})
		3'b110 : dout = in0 ;
		3'b101 : dout = in1 ;
		3'b011 : dout = in2 ;
	        default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux3ds

// ----------------------------------------------------------------------


// 2:1 MUX WITH DECODED SELECTS
module dp_mux2ds (dout, in0, in1,
             sel0_l, sel1_l);
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0]  dout;
input   [SIZE-1:0]  in0;
input   [SIZE-1:0]  in1;
input           sel0_l;
input           sel1_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg [SIZE-1:0]  dout ;





wire [1:0] sel = {sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or in0 or in1)

    case ({sel1_l,sel0_l})
        3'b10 : dout = in0 ;
        3'b01 : dout = in1 ;
            default : dout = {SIZE{1'bx}} ;
    endcase

endmodule // dp_mux3ds

// ---------------------------------------------------------------------


module dp_buffer(dout, in);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in;

assign dout = in;

endmodule // dp_buffer









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: test_stub_scan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// ____________________________________________________________________________
//
//  test_stub_bist - Test Stub with Scan Support
// ____________________________________________________________________________
//
// Description: DBB interface for test signal generation
// ____________________________________________________________________________

module test_stub_scan (/*AUTOARG*/
// Outputs
mux_drive_disable, mem_write_disable, sehold, se, testmode_l, 
mem_bypass, so_0, so_1, so_2, 
// Inputs
ctu_tst_pre_grst_l, arst_l, global_shift_enable, 
ctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, 
ctu_tst_short_chain, long_chain_so_0, short_chain_so_0, 
long_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2
);

   input        ctu_tst_pre_grst_l;
   input        arst_l;                // no longer used
   input        global_shift_enable;
   input        ctu_tst_scan_disable;  // redefined as pin_based_scan
   input        ctu_tst_scanmode;
   input 	ctu_tst_macrotest;
   input 	ctu_tst_short_chain;
   input 	long_chain_so_0;
   input 	short_chain_so_0;
   input 	long_chain_so_1;
   input 	short_chain_so_1;
   input 	long_chain_so_2;
   input 	short_chain_so_2;
   
   output 	mux_drive_disable;
   output 	mem_write_disable;
   output 	sehold;
   output 	se;
   output 	testmode_l;
   output 	mem_bypass;
   output 	so_0;
   output 	so_1;
   output 	so_2;

   wire         pin_based_scan;
   wire         short_chain_en;
   wire         short_chain_select;

   // INTERNAL CLUSTER CONNECTIONS
   //
   // Scan Chain Hookup
   // =================
   //
   // Scan chains have two configurations: long and short.
   // The short chain is typically the first tenth of the
   // long chain. The short chain should contain memory
   // collar flops for deep arrays. The CTU determines
   // which configuration is selected. Up to three chains
   // are supported.
   //
   // The scanout connections from the long and short
   // chains connect to the following inputs:
   //
   // long_chain_so_0, short_chain_so_0 (mandatory)
   // long_chain_so_1, short_chain_so_1 (optional)
   // long_chain_so_2, short_chain_so_2 (optional)
   //
   // The test stub outputs should connect directly to the
   // scanout port(s) of the cluster:
   //
   // so_0 (mandatory), so_1 (optional), so_2 (optional)
   //
   //
   // Static Output Signals
   // =====================
   //
   // testmode_l
   //
   // Local testmode control for overriding gated
   // clocks, asynchronous resets, etc. Asserted
   // for all shift-based test modes.
   //
   // mem_bypass
   //
   // Memory bypass control for arrays without output
   // flops. Allows testing of shadow logic. Asserted
   // for scan test; de-asserted for macrotest.
   //
   //
   // Dynamic Output Signals
   // ======================
   //
   // sehold
   //
   // The sehold signal needs to be set for macrotest
   // to allow holding flops in the array collars
   // to retain their shifted data during capture.
   // Inverted version of scan enable during macrotest.
   //
   // mux_drive_disable (for mux/long chain protection)
   //
   // Activate one-hot mux protection circuitry during
   // scan shift and reset. Formerly known as rst_tri_en.
   // Also used by long chain memories with embedded
   // control.
   //
   // mem_write_disable (for short chain protection)
   //
   // Protects contents of short chain memories during
   // shift and POR.
   //
   // se

   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;
   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;
   assign  sehold             = ctu_tst_macrotest & ~se;
   assign  se                 = global_shift_enable;
   assign  testmode_l         = ~ctu_tst_scanmode;
   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;
   assign  pin_based_scan     = ctu_tst_scan_disable;
   assign  short_chain_en     = ~(pin_based_scan & se);
   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;
   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;
   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;
   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;
   
endmodule // test_stub_scan
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: u1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
//
// basic gates {
//
////////////////////////////////////////////////////////////////////////


//bw_u1_inv_0p6x
//
//

module bw_u1_inv_0p6x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1x
//
//

module bw_u1_inv_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1p4x
//
//

module bw_u1_inv_1p4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_2x
//
//

module bw_u1_inv_2x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_3x
//
//

module bw_u1_inv_3x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_4x
//
//

module bw_u1_inv_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule



//bw_u1_inv_5x
//
//

module bw_u1_inv_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_8x
//
//

module bw_u1_inv_8x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_10x
//
//

module bw_u1_inv_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_15x
//
//

module bw_u1_inv_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_20x
//
//

module bw_u1_inv_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_30x
//
//

module bw_u1_inv_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_40x
//
//

module bw_u1_inv_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_15x
//
//

module bw_u1_invh_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_25x
//
//

module bw_u1_invh_25x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_30x
//
//

module bw_u1_invh_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_50x
//
//

module bw_u1_invh_50x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_60x
//
//

module bw_u1_invh_60x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule




//bw_u1_nand2_0p4x
//
//
module bw_u1_nand2_0p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_0p6x
//
//
module bw_u1_nand2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1x
//
//
module bw_u1_nand2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1p4x
//
//
module bw_u1_nand2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_2x
//
//
module bw_u1_nand2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_3x
//
//
module bw_u1_nand2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_4x
//
//
module bw_u1_nand2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_5x
//
//
module bw_u1_nand2_5x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_7x
//
//
module bw_u1_nand2_7x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_10x
//
//
module bw_u1_nand2_10x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_15x
//
//
module bw_u1_nand2_15x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand3_0p4x
//
//
module bw_u1_nand3_0p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule




//bw_u1_nand3_0p6x
//
//
module bw_u1_nand3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule



//bw_u1_nand3_1x

//
//
module bw_u1_nand3_1x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_1p4x

//
//
module bw_u1_nand3_1p4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_2x

//
//
module bw_u1_nand3_2x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_3x

//
//
module bw_u1_nand3_3x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_4x

//
//
module bw_u1_nand3_4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_5x

//
//
module bw_u1_nand3_5x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_7x

//
//
module bw_u1_nand3_7x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_10x

//
//
module bw_u1_nand3_10x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand4_0p6x

//
//
module bw_u1_nand4_0p6x (
    z,
    a,  
    b,  
    c,  
    d );
    
    output z;
    input  a;
    input  b;
    input  c;
    input  d;
    
    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1x
//
//
module bw_u1_nand4_1x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1p4x
//
//
module bw_u1_nand4_1p4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_2x
//
//
module bw_u1_nand4_2x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_3x
//
//
module bw_u1_nand4_3x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_4x
//
//
module bw_u1_nand4_4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_6x
//
//

module bw_u1_nand4_6x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nand4_8x
//
//

module bw_u1_nand4_8x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nor2_0p6x
//
//

module bw_u1_nor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1x
//
//

module bw_u1_nor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1p4x
//
//

module bw_u1_nor2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_2x
//
//

module bw_u1_nor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_3x
//
//

module bw_u1_nor2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_4x
//
//

module bw_u1_nor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_6x
//
//

module bw_u1_nor2_6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_8x
//
//

module bw_u1_nor2_8x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_12x
//
//

module bw_u1_nor2_12x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule




//bw_u1_nor3_0p6x
//
//

module bw_u1_nor3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1x
//
//

module bw_u1_nor3_1x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1p4x
//
//

module bw_u1_nor3_1p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_2x
//
//

module bw_u1_nor3_2x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_3x
//
//

module bw_u1_nor3_3x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_4x
//
//

module bw_u1_nor3_4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_6x
//
//

module bw_u1_nor3_6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_8x
//
//

module bw_u1_nor3_8x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_aoi21_0p4x
//
// 
module bw_u1_aoi21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_1x
//
// 
module bw_u1_aoi21_1x (

    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a  ));

endmodule
//bw_u1_aoi21_2x
//
// 
module bw_u1_aoi21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_4x
//
// 
module bw_u1_aoi21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_8x
//
// 
module bw_u1_aoi21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_12x
//
// 
module bw_u1_aoi21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi22_0p4x
//
// 
module bw_u1_aoi22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_1x
//
// 
module bw_u1_aoi22_1x (
    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;


    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_2x
//
// 
module bw_u1_aoi22_2x (


    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;
 
    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_4x
//
// 
module bw_u1_aoi22_4x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_8x
//
// 
module bw_u1_aoi22_8x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi211_0p3x
//
// 
module bw_u1_aoi211_0p3x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_1x
//
// 
module bw_u1_aoi211_1x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_2x
//
// 
module bw_u1_aoi211_2x (



    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_4x
//
// 
module bw_u1_aoi211_4x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_8x
//
// 
module bw_u1_aoi211_8x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_oai21_0p4x
//
//
module bw_u1_oai21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_1x
//
//
module bw_u1_oai21_1x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_2x
//
//
module bw_u1_oai21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_4x
//
//
module bw_u1_oai21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_8x
//
//
module bw_u1_oai21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_12x
//
//
module bw_u1_oai21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai22_0p4x
// 
module bw_u1_oai22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_1x
// 
module bw_u1_oai22_1x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_2x
// 
module bw_u1_oai22_2x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_4x
// 
module bw_u1_oai22_4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_8x
// 
module bw_u1_oai22_8x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai211_0p3x
//
//
module bw_u1_oai211_0p3x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_1x
//
//
module bw_u1_oai211_1x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_2x
//
//
module bw_u1_oai211_2x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_4x
//
//
module bw_u1_oai211_4x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_8x
//
//
module bw_u1_oai211_8x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_aoi31_1x
//
// 
module bw_u1_aoi31_1x (


    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_2x
//
// 
module bw_u1_aoi31_2x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_4x
//
// 
module bw_u1_aoi31_4x (
    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_8x
//
// 
module bw_u1_aoi31_8x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi32_1x
//
// 
module bw_u1_aoi32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_2x
//
// 
module bw_u1_aoi32_2x (
    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_4x
//
// 
module bw_u1_aoi32_4x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_8x
//
// 
module bw_u1_aoi32_8x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 
    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi33_1x
//
//
module bw_u1_aoi33_1x (




    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_2x
//
//
module bw_u1_aoi33_2x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_4x
//
//
module bw_u1_aoi33_4x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_8x
//
//
module bw_u1_aoi33_8x (
       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi221_1x
//
// 
module bw_u1_aoi221_1x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_2x
//
// 
module bw_u1_aoi221_2x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_4x
//
// 
module bw_u1_aoi221_4x (



    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_8x
//
// 
module bw_u1_aoi221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi222_1x
//
//
module bw_u1_aoi222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_aoi222_2x
//
//
module bw_u1_aoi222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi222_4x
//
//
module bw_u1_aoi222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi311_1x
//
//
module bw_u1_aoi311_1x (

    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_2x
//
//
module bw_u1_aoi311_2x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_4x
//
//
module bw_u1_aoi311_4x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;


    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_8x
//
//
module bw_u1_aoi311_8x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_oai31_1x
//
//
module bw_u1_oai31_1x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_2x
//
//
module bw_u1_oai31_2x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_4x
//
//
module bw_u1_oai31_4x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_8x
//
//
module bw_u1_oai31_8x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai32_1x
//
//
module bw_u1_oai32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_2x
//
//
module bw_u1_oai32_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_4x
//
//
module bw_u1_oai32_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_8x
//
//
module bw_u1_oai32_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai33_1x
//
//
module bw_u1_oai33_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_2x
//
//
module bw_u1_oai33_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_4x
//
//
module bw_u1_oai33_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_8x
//
//
module bw_u1_oai33_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai221_1x
//
//
module bw_u1_oai221_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_2x
//
//
module bw_u1_oai221_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_4x
//
//
module bw_u1_oai221_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_8x
//
//
module bw_u1_oai221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai222_1x
//
//
module bw_u1_oai222_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_2x
//
//
module bw_u1_oai222_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_4x
//
//
module bw_u1_oai222_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai311_1x
//
//
module bw_u1_oai311_1x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_2x
//
//
module bw_u1_oai311_2x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_4x
//
//
module bw_u1_oai311_4x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 | c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_8x
//
//
module bw_u1_oai311_8x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_muxi21_0p6x



module bw_u1_muxi21_0p6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_1x



module bw_u1_muxi21_1x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule







//bw_u1_muxi21_2x



module bw_u1_muxi21_2x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_4x



module bw_u1_muxi21_4x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule




//bw_u1_muxi21_6x


module bw_u1_muxi21_6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule

//bw_u1_muxi31d_4x
//

module bw_u1_muxi31d_4x (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
        zmuxi31d_prim i0 ( z, d0, d1, d2, s0, s1, s2 );
endmodule

//bw_u1_muxi41d_4x
//

module bw_u1_muxi41d_4x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule

//bw_u1_muxi41d_6x
//

module bw_u1_muxi41d_6x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule
 

//bw_u1_xor2_0p6x
//
// 
module bw_u1_xor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_1x
//
// 
module bw_u1_xor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_2x
//
// 
module bw_u1_xor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_4x
//
// 
module bw_u1_xor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xnor2_0p6x
//
// 
module bw_u1_xnor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_1x
//
// 
module bw_u1_xnor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_2x
//
// 
module bw_u1_xnor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_4x
//
// 
module bw_u1_xnor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule

//bw_u1_buf_1x
//

module bw_u1_buf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_buf_5x
//

module bw_u1_buf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_10x
//

module bw_u1_buf_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_15x
//

module bw_u1_buf_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_20x
//

module bw_u1_buf_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_30x
//

module bw_u1_buf_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_40x
//

module bw_u1_buf_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_ao2222_1x
//
//
module bw_u1_ao2222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_ao2222_2x
//
//
module bw_u1_ao2222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_ao2222_4x
//
//
module bw_u1_ao2222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

////////////////////////////////////////////////////////////////////////
//
// flipflops {
//
////////////////////////////////////////////////////////////////////////

//      scanable D-flipflop with scanout

module bw_u1_soff_1x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_2x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_8x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

//      fast scanable D-flipflop with scanout with inverted Q output

module bw_u1_soffi_4x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule
  
module bw_u1_soffi_8x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule

//      scanable D-flipflop with scanout with 2-to-1 input mux

module bw_u1_soffm2_4x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

module bw_u1_soffm2_8x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

//      scanable D-flipflop with scanout with sync reset-bar

module bw_u1_soffr_2x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule
  
module bw_u1_soffr_4x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

module bw_u1_soffr_8x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

//bw_u1_soffasr_2x

module bw_u1_soffasr_2x (q, so, ck, d, r_l, s_l, se, sd);
output q, so;
input  ck, d, r_l, s_l, se, sd;
        zsoffasr_prim i0 (q, so, ck, d, r_l, s_l, se, sd);
endmodule


//bw_u1_ckbuf_1p5x


module bw_u1_ckbuf_1p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_3x


module bw_u1_ckbuf_3x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_4p5x


module bw_u1_ckbuf_4p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_6x


module bw_u1_ckbuf_6x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_7x
//

module bw_u1_ckbuf_7x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_8x
//
module bw_u1_ckbuf_8x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_11x
//

module bw_u1_ckbuf_11x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_14x
//

module bw_u1_ckbuf_14x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_17x
//

module bw_u1_ckbuf_17x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_19x
//

module bw_u1_ckbuf_19x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_22x
//

module bw_u1_ckbuf_22x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_25x
//

module bw_u1_ckbuf_25x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_28x
//

module bw_u1_ckbuf_28x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_30x
//

module bw_u1_ckbuf_30x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_33x
//

module bw_u1_ckbuf_33x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_40x
//

module bw_u1_ckbuf_40x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


// gated clock buffers


module bw_u1_ckenbuf_6x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

module bw_u1_ckenbuf_14x (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule   

////////////////////////////////////////////////////////////////////////
//
// half cells
//
////////////////////////////////////////////////////////////////////////



module bw_u1_zhinv_0p6x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_1x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_1p4x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_2x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_3x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_4x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhnand2_0p4x (z, a, b);
output z;
input  a, b;
        nand (z, a, b);
endmodule


module bw_u1_zhnand2_0p6x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1p4x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_2x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_3x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_1x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_2x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule


module bw_u1_zhnand4_0p6x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_1x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_2x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule


        
module bw_u1_zhnor2_0p6x (z, a, b);
output z;
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_1x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_2x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule



module bw_u1_zhnor3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nor (z, a, b, c);
endmodule


module bw_u1_zhaoi21_0p4x (z,b1,b2,a);

    output z;   
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));
    
endmodule



module bw_u1_zhaoi21_1x (z, a, b1, b2);

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule



module bw_u1_zhoai21_1x (z,b1,b2,a );
    
    output z;
    input  b1;
    input  b2;  
    input  a;
  
    assign z = ~(( b1 | b2 ) & ( a ));
      
endmodule




module bw_u1_zhoai211_0p3x (z, a, b, c1, c2);
    output z; 
    input  c1;  
    input  c2;
    input  b;
    input  a;
      
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





module bw_u1_zhoai211_1x (z, a, b, c1, c2);
output z;
input  a, b, c1, c2;
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





/////////////// Scan data lock up latch ///////////////

module bw_u1_scanlg_2x (so, sd, ck, se);
output so;
input sd, ck, se;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd or se )
       if (~ck) so_l <= ~(sd & se) ;

endmodule

module bw_u1_scanl_2x (so, sd, ck);
output so;
input sd, ck;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd )
       if (~ck) so_l <= ~sd ;

endmodule



////////////////// Synchronizer ////////////////

module bw_u1_syncff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;

reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r;

endmodule




////////////////////////////////////////////////////////////////////////
//
// non library cells
// 
////////////////////////////////////////////////////////////////////////

// These cells are used only in custom DP macros
// Do not use in any block design without prior permission


module bw_u1_zzeccxor2_5x (z, a, b); 
 output z; 
 input a, b;
    assign z = ( a ^ b );

endmodule



module bw_u1_zzmulcsa42_5x (sum, carry, cout, a, b, c, d, cin);
output sum, carry, cout;
input  a, b, c, d, cin;
wire and_cin_b, or_cin_b, xor_a_c_d, and_or_cin_b_xor_a_c_d;
wire and_a_c, and_a_d, and_c_d;
        assign sum   = cin ^ a ^ b ^ c ^ d;
        assign carry = cin & b | (cin | b) & (a ^ c ^ d);
        assign cout  = a & c | a & d | c & d;
endmodule



module bw_u1_zzmulcsa32_5x (sum, cout, a, b, c);
output sum, cout;
input  a, b, c;
wire and_a_b, and_a_c, and_b_c;
        assign sum  = a ^ b ^ c ;
        assign cout = a & b | a & c | b & c ;
endmodule



module bw_u1_zzmulppmuxi21_2x ( z, d0, d1, s );
output  z;
input  d0, d1, s;
    assign z = s ? ~d1 : ~d0;
endmodule



module bw_u1_zzmulnand2_2x ( z, a, b );
output z;
input  a;
input  b;
    assign z = ~( a & b );
endmodule



// Primitives




module zmuxi31d_prim (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
// for Blacktie



wire [2:0] sel = {s0,s1,s2}; // 0in one_hot
reg z;
    always @ (s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s2,d2,s1,d1,s0,d0})
            6'b0?0?10: z = 1'b1;  
            6'b0?0?11: z = 1'b0;  
            6'b0?100?: z = 1'b1;  
            6'b0?110?: z = 1'b0;  
            6'b0?1010: z = 1'b1;  
            6'b0?1111: z = 1'b0;  
            6'b100?0?: z = 1'b1;  
            6'b110?0?: z = 1'b0;  
            6'b100?10: z = 1'b1;  
            6'b110?11: z = 1'b0;  
            6'b10100?: z = 1'b1;  
            6'b11110?: z = 1'b0;  
            6'b101010: z = 1'b1;  
            6'b111111: z = 1'b0;  
            default: z = 1'bx;
        endcase
endmodule







module zmuxi41d_prim (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
// for Blacktie



wire [3:0] sel = {s0,s1,s2,s3}; // 0in one_hot
reg z;
    always @ (s3 or d3 or s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s3,d3,s2,d2,s1,d1,s0,d0})
            8'b0?0?0?10: z = 1'b1;
            8'b0?0?0?11: z = 1'b0;
            8'b0?0?100?: z = 1'b1;
            8'b0?0?110?: z = 1'b0;
            8'b0?0?1010: z = 1'b1;
            8'b0?0?1111: z = 1'b0;
            8'b0?100?0?: z = 1'b1;
            8'b0?110?0?: z = 1'b0;
            8'b0?100?10: z = 1'b1;
            8'b0?110?11: z = 1'b0;
            8'b0?10100?: z = 1'b1;
            8'b0?11110?: z = 1'b0;
            8'b0?101010: z = 1'b1;
            8'b0?111111: z = 1'b0;
            8'b100?0?0?: z = 1'b1;
            8'b110?0?0?: z = 1'b0;
            8'b100?0?10: z = 1'b1;
            8'b110?0?11: z = 1'b0;
            8'b100?100?: z = 1'b1;
            8'b110?110?: z = 1'b0;
            8'b100?1010: z = 1'b1;
            8'b110?1111: z = 1'b0;
            8'b10100?0?: z = 1'b1;
            8'b11110?0?: z = 1'b0;
            8'b10100?10: z = 1'b1;
            8'b11110?11: z = 1'b0;
            8'b1010100?: z = 1'b1;
            8'b1111110?: z = 1'b0;
            8'b10101010: z = 1'b1;
            8'b11111111: z = 1'b0;
            default: z = 1'bx;
        endcase   
endmodule



module zsoff_prim (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r ;
endmodule


module zsoffr_prim (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (d & r_l) ;
  assign q  = q_r;
  assign so = q_r;
endmodule


module zsoffi_prim (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q_l = ~q_r;
  assign so  = q_r;
endmodule



module zsoffm2_prim (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (s ? d1 : d0) ;
  assign q  = q_r;
  assign so = q_r;
endmodule

module zsoffasr_prim (q, so, ck, d, r_l, s_l, se, sd);
  output q, so;
  input ck, d, r_l, s_l, se, sd;

  // asynchronous reset and asynchronous set
  // (priority: r_l > s_l > se > d)
  reg q;
  wire so;

  always @ (posedge ck or negedge r_l or negedge s_l) begin
		if(~r_l) q <= 1'b0;
		else if (~s_l) q <= r_l;
		else if (se) q <= r_l & s_l & sd;
		else q <= r_l & s_l & (~se) & d;
  end

  assign so = q | ~se;

endmodule



module zckenbuf_prim (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
reg    clken;

  always @ (rclk or en_l or tm_l)
    if (!rclk)  //latch opens on rclk low phase
      clken <= ~en_l | ~tm_l;
  assign clk = clken & rclk;

endmodule

module bw_mckbuf_40x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_33x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_30x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_28x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_25x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_22x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_19x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_17x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_14x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_11x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_8x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_7x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_6x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_4p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_3x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_1p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

//bw_u1_minbuf_1x
//

module bw_u1_minbuf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_4x
//

module bw_u1_minbuf_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_5x
//

module bw_u1_minbuf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

module bw_u1_ckenbuf_4p5x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

// dummy fill modules to get rid of DFT "CAP" property errors (bug 5487)

module bw_u1_fill_1x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_2x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_3x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_4x(\vdd! );
input \vdd! ;
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_in.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:	ucb_bus_in (ucb bus inbound interface block)
//  Description:	This interface block is instaniated by the
//                      UCB modules and IO Bridge to receive packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
			// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Interface signal list declarations
////////////////////////////////////////////////////////////////////////
module ucb_bus_in (/*AUTOARG*/
   // Outputs
   stall, indata_buf_vld, indata_buf,
   // Inputs
   rst_l, clk, vld, data, stall_a1
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;


////////////////////////////////////////////////////////////////////////
// Signal declarations
////////////////////////////////////////////////////////////////////////
   // Global interface
   input                     rst_l;
   input 		     clk;


   // UCB bus interface
   input 		     vld;
   input [UCB_BUS_WIDTH-1:0] data;
   output 		     stall;


   // Local interface
   output 		     indata_buf_vld;
   output [REG_WIDTH+63:0]   indata_buf;
   input 		     stall_a1; // would this prevent indata_buf to change?


   // Internal signals
   wire 		     vld_d1;
   wire 		     stall_d1;
   wire [UCB_BUS_WIDTH-1:0]  data_d1;
   wire 		     skid_buf0_en;
   wire 		     vld_buf0;
   wire [UCB_BUS_WIDTH-1:0]  data_buf0;
   wire 		     skid_buf1_en;
   wire 		     vld_buf1;
   wire [UCB_BUS_WIDTH-1:0]  data_buf1;
   wire 		     skid_buf0_sel;
   wire 		     skid_buf1_sel;
   wire 		     vld_mux;
   wire [UCB_BUS_WIDTH-1:0]  data_mux;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec_next;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec;
   wire [REG_WIDTH+63:0]     indata_buf_next;
   wire 		     indata_vec0_d1;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    * This is to make signals going between IOB and UCB flop-to-flop
    * to improve timing.
    ************************************************************/
   dffrle_ns #(1) vld_d1_ff (.din(vld),
			     .rst_l(rst_l),
			     .en(~stall_d1),
			     .clk(clk),
			     .q(vld_d1));

   dffe_ns #(UCB_BUS_WIDTH) data_d1_ff (.din(data),
					.en(~stall_d1),
					.clk(clk),
					.q(data_d1));

   dffrl_ns #(1) stall_ff (.din(stall_a1),
			   .clk(clk),
			   .rst_l(rst_l),
			   .q(stall));

   dffrl_ns #(1) stall_d1_ff (.din(stall),
			      .clk(clk),
			      .rst_l(rst_l),
			      .q(stall_d1));


   /************************************************************
    * Skid buffer
    * We need a two deep skid buffer to handle stalling.
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   // Buffer 0
   assign 	 skid_buf0_en = stall_a1 & ~stall;

   dffrle_ns #(1) vld_buf0_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf0_en),
			       .clk(clk),
			       .q(vld_buf0));

   dffe_ns #(UCB_BUS_WIDTH) data_buf0_ff (.din(data_d1),
					  .en(skid_buf0_en),
					  .clk(clk),
					  .q(data_buf0));

   // Buffer 1
   dffrl_ns #(1) skid_buf1_en_ff (.din(skid_buf0_en),
				  .clk(clk),
				  .rst_l(rst_l),
				  .q(skid_buf1_en));

   dffrle_ns #(1) vld_buf1_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf1_en),
			       .clk(clk),
			       .q(vld_buf1));

   dffe_ns #(UCB_BUS_WIDTH) data_buf1_ff (.din(data_d1),
					  .en(skid_buf1_en),
					  .clk(clk),
					  .q(data_buf1));


   /************************************************************
    * Mux between skid buffer and interface flop
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   assign 	 skid_buf0_sel = ~stall_a1 & stall;

   dffrl_ns #(1) skid_buf1_sel_ff (.din(skid_buf0_sel),
				   .clk(clk),
				   .rst_l(rst_l),
				   .q(skid_buf1_sel));

   assign 	 vld_mux = skid_buf0_sel ? vld_buf0 :
		           skid_buf1_sel ? vld_buf1 :
		                           vld_d1;

   assign 	 data_mux = skid_buf0_sel ? data_buf0 :
		            skid_buf1_sel ? data_buf1 :
		                            data_d1;


   /************************************************************
    * Assemble inbound data
    ************************************************************/
   // valid vector
   assign 	 indata_vec_next = {vld_mux,
				    indata_vec[(REG_WIDTH+64)/UCB_BUS_WIDTH-1:1]};
   dffrle_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) indata_vec_ff (.din(indata_vec_next),
							    .en(~stall_a1),
							    .rst_l(rst_l),
							    .clk(clk),
							    .q(indata_vec));

   // data buffer
   assign 	 indata_buf_next = {data_mux,
				    indata_buf[REG_WIDTH+63:UCB_BUS_WIDTH]};
   dffe_ns #(REG_WIDTH+64) indata_buf_ff (.din(indata_buf_next),
					  .en(~stall_a1),
					  .clk(clk),
					  .q(indata_buf));

   // detect a new packet
   dffrle_ns #(1) indata_vec0_d1_ff (.din(indata_vec[0]),
				     .rst_l(rst_l),
				     .en(~stall_a1),
				     .clk(clk),
				     .q(indata_vec0_d1));

   assign        indata_buf_vld = indata_vec[0] & ~indata_vec0_d1;


endmodule // ucb_bus_in
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_out.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:        ucb_bus_out (ucb bus outbound interface block)
//	Description:	This interface block is instantiated by the
//                      UCB modules and IO Bridge to transmit packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which
                        // contains the time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module ucb_bus_out (/*AUTOARG*/
   // Outputs
   vld, data, outdata_buf_busy,
   // Inputs
   clk, rst_l, stall, outdata_buf_in, outdata_vec_in, outdata_buf_wr
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;            // maximum data bits that needs to
                                        // be sent.  Set to 64 or 128

   // Globals
   input                                clk;
   input 				rst_l;


   // UCB bus interface
   output 				vld;
   output [UCB_BUS_WIDTH-1:0] 		data;
   input 				stall;


   // Local interface
   output 				outdata_buf_busy;  // busy outputting, can't accept data into buffer
   input [REG_WIDTH+63:0] 		outdata_buf_in;
   input [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] outdata_vec_in; // indicating how much data to send
   input 				outdata_buf_wr;


   // Local signals
   wire 				stall_d1;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec_next;
   wire [REG_WIDTH+63:0] 		outdata_buf;
   reg [REG_WIDTH+63:0] 		outdata_buf_next;
   wire 				load_outdata;
   wire 				shift_outdata;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    ************************************************************/
   assign 	 vld = outdata_vec[0];
   // assign 	 data = vld ? outdata_buf[UCB_BUS_WIDTH-1:0] : `UCB_BUS_WIDTH'b0;
   assign    data = outdata_buf[UCB_BUS_WIDTH-1:0];

   dffrl_ns #(1) stall_d1_ff (.din(stall),
                              .clk(clk),
                              .rst_l(rst_l),
                              .q(stall_d1));


   /************************************************************
    * Outbound Data
    ************************************************************/
   // accept new data only if there is none being processed
   assign 	 load_outdata = outdata_buf_wr & ~outdata_buf_busy;

   assign 	 outdata_buf_busy = outdata_vec[0] | stall_d1;

   // only shifts when then input vector is a straight valids
   assign 	 shift_outdata = outdata_vec[0] & ~stall_d1;

   assign 	 outdata_vec_next =
		 load_outdata  ? outdata_vec_in:
		 shift_outdata ? outdata_vec >> 1:
	                         outdata_vec;
   dffrl_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) outdata_vec_ff (.din(outdata_vec_next),
							    .clk(clk),
							    .rst_l(rst_l),
							    .q(outdata_vec));

   // assign 	 outdata_buf_next =
		 // load_outdata  ? outdata_buf_in:
		 // shift_outdata ? (outdata_buf >> UCB_BUS_WIDTH):
	  //                        outdata_buf;
   always @ *
   begin
      if (load_outdata)
         outdata_buf_next = outdata_buf_in;
      else if (shift_outdata)
      begin
         outdata_buf_next = outdata_buf >> UCB_BUS_WIDTH;
         if (outdata_vec[1] == 1'b0)
            outdata_buf_next[UCB_BUS_WIDTH-1:0] = 0;
      end
      else
         outdata_buf_next = outdata_buf; // no shifting
   end

   dff_ns #(REG_WIDTH+64) outdata_buf_ff (.din(outdata_buf_next),
					  .clk(clk),
					  .q(outdata_buf));


endmodule // ucb_bus_out






// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//File: valrdy_to_credit.v (modified from space_avail_top.v)
//
//Modified: Yaosheng Fu
//May 2, 2014
//
//Function: This module keeps track of how many spots are free in the NIB that
//	we are sending to
//
//State: count_f, yummy_out_f, valid_in_f
//
//Instantiates: 
//

module valrdy_to_credit (
            clk,
            reset,
                
            //val/rdy interface
            data_in,
            valid_in,
            ready_in,

			//credit based interface	
            data_out,
            valid_out,
		    yummy_out);

parameter BUFFER_SIZE = 4;
parameter BUFFER_BITS = 3;
   
input clk;
input reset;

 
input [64-1:0]	 data_in;
 input valid_in;			// sending data to the output
 input yummy_out;			// output consumed data

output [64-1:0]  data_out;
 output valid_out;
 output ready_in;		// is there space available?


//This is the state
 reg yummy_out_f;
 reg valid_temp_f;
 reg [BUFFER_BITS-1:0] count_f;

reg is_one_f;
 reg is_two_or_more_f;

//wires
 wire [BUFFER_BITS-1:0] count_plus_1;
 wire [BUFFER_BITS-1:0] count_minus_1;
 wire up;
 wire down;

 wire valid_temp;

//wire regs
  reg [BUFFER_BITS-1:0] count_temp;


//assigns
assign data_out = data_in;
assign valid_temp = valid_in & ready_in;
assign valid_out = valid_temp;

assign count_plus_1 = count_f + 1'b1;
assign count_minus_1 = count_f - 1'b1;
assign ready_in = is_two_or_more_f;
assign up = yummy_out_f & ~valid_temp_f;
assign down = ~yummy_out_f & valid_temp_f;

always @ (count_f or count_plus_1 or count_minus_1 or up or down)
begin
	case (count_f)
	0:
		begin
			if(up)
			begin
				count_temp <= count_plus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	BUFFER_SIZE:
		begin
			if(down)
			begin
				count_temp <= count_minus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	default:
		begin
			case ({up, down})
				2'b10:	count_temp <= count_plus_1;
				2'b01:	count_temp <= count_minus_1;
				default:	count_temp <= count_f;
			endcase
		end
	endcase
end

//wire top_bits_zero_temp = ~| count_temp[BUFFER_BITS-1:1];
 wire top_bits_zero_temp = count_temp < 3 ? 1 : 0;

always @ (posedge clk)
begin
	if(reset)
	begin
	   count_f <= BUFFER_SIZE;
	   yummy_out_f <= 1'b0;
	   valid_temp_f <= 1'b0;
	   is_one_f <= (BUFFER_SIZE == 1);
	   is_two_or_more_f <= (BUFFER_SIZE >= 2);
	end
	else
	begin
	   count_f <= count_temp;
	   yummy_out_f <= yummy_out;
	   valid_temp_f <= valid_temp;
	   is_one_f         <= top_bits_zero_temp & count_temp[0];
   	   is_two_or_more_f <= ~top_bits_zero_temp;
	end
end

endmodule
      
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




// Uncomment to define USE_GENERIC_SRAM_IMPLEMENTATION to use the old unsynthesizable BRAM
// `define USE_GENERIC_SRAM_IMPLEMENTATION




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

// Tile config

// devices.xml





// NoC interface





















// NodeID decomposition








//========================
//Packet format
//=========================

//Header decomposition































// these shifted fields are added for convienience
// HEADER 2








// HEADER 3








//NoC header information










// Width of MSG_ADDR field - you're probably looking for PHY_ADDR_WIDTH


//Coherence information





//Requests from L15 to L2
// Should always make #0 an error








//condition satisfied

//condition not satisfied

//Both SWAP and LDSTUB are the same for L2









//RISC-V AMO requests









//RISC-V AMO L2-internal phase 1









//RISC-V AMO L2-internal phase 2












//Forward requests from L2 to L15







//Memory requests from L2 to DRAM






//Forward acks from L15 to L2







//Memory acks from memory to L2









//Acks from L2 to L15


//TODO



//Only exist within L2





//`define MSG_TYPE_LOAD_REQ           8'd31 if this is enabled, don't use 31





// These should be defined in l2.vh, not the global defines











//Physical address










//Transition data size












//`define HOME_ID_MASK_X          10:10
//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only


// Tri: dynamically adjust these parameters based on how many tiles are available
//  Assumption: 8x8 topology























































//`define DMBR_TAG_WIDTH 4

//Clumpy Shared Memory






////////////////////////////////////////////
// SOME CONFIGURATION REGISTERS DEFINES
////////////////////////////////////////////
// example: read/write to csm_en would be 0xba_0000_0100

// `define ASI_ADDRESS_MASK    `L15_ADDR_TYPE
// `define CONFIG_ASI_ADDRESS  `L15_ADDR_TYPE_WIDTH'hba










// DMBR Config register 1 fields















// DMBR Config register 2 fields



//Home allocation method






//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only

































//`define TTE_CSM_WIDTH           64
//`define TTE_CSM                 63:0
//`define TTE_CSM_VALID           63
//`define TTE_CSM_SZL             62:61
//`define TTE_CSM_NFO             60
//`define TTE_CSM_IE              59
//`define TTE_CSM_SOFT2           58:49
//`define TTE_CSM_SZH             48
//`define TTE_CSM_DIAG            47:40
//`define TTE_CSM_RES1            39
//`define TTE_CSM_SDID            38:29
//`define TTE_CSM_HDID            28:19
//`define TTE_CSM_LSID            18:13
//`define TTE_CSM_SOFT            12:8
//`define TTE_CSM_RES2            7
//`define TTE_CSM_LOCK            6
//`define TTE_CSM_CP              5
//`define TTE_CSM_CV              4
//`define TTE_CSM_E               3
//`define TTE_CSM_P               2
//`define TTE_CSM_W               1
//`define TTE_CSM_RES3            0












// Packet format for home id





/////////////////////////////////////
// BIST
/////////////////////////////////////

// the data width from tap to individual sram wrappers



//deprecated































/////////////////////////////////////
// IDs for JTAG-Core interface
/////////////////////////////////////

// 48b for writing the PC reset vector

// 94b for reading the sscan data











// Execution Drafting Synchronization Method Values





// Execution Drafting timeout counter bit width


// Configuration registers












// Execution Drafting configuration register bit positions








// Execution Drafting configuration register default values
// ED disabled, STSM sync method, LFSR seed = 16'b0, LFSR load = 1'b0,
// Counter Timeout = 16'd32



//Clumpy sharer memory configuration registers
























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]






// `define L15_CACHELINE_WIDTH 128

















// devices.xml
// this is used in the ariane SV packages to derive the parameterization



















































// 7

// 7




// 16B cache lines

// 10




// 40 - 4 (16B line) - 7 (index width) = 29

// 11

// 39


// this need to be defined when L1.5 has more sets than L1D
// for correct operations
// `define L15_WMT_EXTENDED_ALIAS


// `define L15_WMT_ALIAS_WIDTH 4
// `define L15_WMT_ALIAS_LOW `L1D_SET_IDX_HI+1

// `define L15_WMT_ALIAS_HI `L15_WMT_ALIAS_LOW + `L15_WMT_ALIAS_WIDTH - 1












// `define L15_WMT_ENTRY_0_MASK 1*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_1_MASK 2*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_2_MASK 3*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_3_MASK 4*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_0_VALID_MASK 1*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_1_VALID_MASK 2*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_2_VALID_MASK 3*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_3_VALID_MASK 4*`L15_WMT_ENTRY_WIDTH-1


  
  


  
  


  
  


  
  







// LRU array storage
// keeps 6 bits per cache set: 4 "used" bits, 1 each cache line, and 2 bits for wayid round robin (4w)





// source





// MSHR






// controls how many mshr there are
// `define L15_MSHR_COUNT 10
// should be more than the count above when 2^n











// pipeline OPs




// `define L15_MSHR_ALLOCATE_TYPE_WIDTH 2
// `define L15_MSHR_ALLOCATE_TYPE_LD 2'd1
// `define L15_MSHR_ALLOCATE_TYPE_ST 2'd2
// `define L15_MSHR_ALLOCATE_TYPE_IFILL 2'd3









































































































// `define PCX_REQ_SIZE_WIDTH 4


























// define the width of the flattened, native L15 interface, used for ARIANE_RV64 option



























// [L15_DTAG_OP_WIDTH-1:0]































//`define L15_S3_MESI_WRITE_TAGCHECK_WAY_M_IF_LRSC_SET 3'd7






























































// `define L15_NOC1_DUMMY_GEN_NOC1_CREDIT 5'd11










































// L2 shared states


// `define L15_NOC2_ACK_STATE_WIDTH 2
// `define L15_NOC2_ACK_STATE_S 2'd1
// `define L15_NOC2_ACK_STATE_E 2'd2
// `define L15_NOC2_ACK_STATE_M 2'd3

// `define L15_NOC1_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC1_REQTYPE_WRITEBACK_GUARD `MSG_TYPE_WBGUARD_REQ
// `define L15_NOC1_REQTYPE_LD_REQUEST `MSG_TYPE_LOAD_REQ
// `define L15_NOC1_REQTYPE_LD_PREFETCH_REQUEST `MSG_TYPE_PREFETCH_REQ
// `define L15_NOC1_REQTYPE_LD_NC_REQUEST `MSG_TYPE_NC_LOAD_REQ
// `define L15_NOC1_REQTYPE_IFILL_REQUEST `MSG_TYPE_LOAD_REQ
// // `define L15_NOC1_REQTYPE_WRITETHROUGH_REQUEST 6'd4
// `define L15_NOC1_REQTYPE_ST_REQUEST `MSG_TYPE_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_REQUEST `MSG_TYPE_BLK_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_INIT_REQUEST `MSG_TYPE_BLKINIT_STORE_REQ
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE_ST_UPGRADE_REQUEST 6
// // `define L15_NOC1_REQTYPE_ST_FILL_REQUEST 6'd6
// `define L15_NOC1_REQTYPE_CAS_REQUEST `MSG_TYPE_CAS_REQ
// `define L15_NOC1_REQTYPE_SWAP_REQUEST `MSG_TYPE_SWAP_REQ

// `define L15_NOC3_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC3_REQTYPE_WRITEBACK `MSG_TYPE_WB_REQ
// `define L15_NOC3_REQTYPE_NO_DATA_FWD_ACK `MSG_TYPE_NODATA_ACK
// `define L15_NOC3_REQTYPE_DATA_FWD_ACK `MSG_TYPE_DATA_ACK

// `define L2_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L2_REQTYPE_INVALIDATE 6'd1
// `define L2_REQTYPE_DOWNGRADE 6'd2
// `define L2_REQTYPE_ACKDT_LD_NC 6'd3
// `define L2_REQTYPE_ACKDT_IFILL 6'd4
// `define L2_REQTYPE_ACKDT_LD 6'd5
// `define L2_REQTYPE_ACKDT_ST_IM 6'd6
// `define L2_REQTYPE_ACKDT_ST_SM 6'd7
// `define L2_REQTYPE_ACK_WRITETHROUGH 6'd8
// `define L2_REQTYPE_ACK_ATOMIC 6'd9






































// NOC1 ENCODER











// NOC3 ENCODER










// NOC2 BUFFER





// DMBR
// put this here for now, should be moved to a more appropriate location


// NOC1 CREDIT MANAGEMENT
// becareful, the noc1buffer module assumes these are power of two
// also, please change the corresponding pyv value in noc1buffer.v.pyv























// `define L15_NOC1BUFFER_BLKSTORE_LO  `L15_NOC1BUFFER_PREFETCH_HI + 1
// `define L15_NOC1BUFFER_BLKSTORE_HI  `L15_NOC1BUFFER_BLKSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_BLKINITSTORE_LO  `L15_NOC1BUFFER_BLKSTORE_HI + 1
// `define L15_NOC1BUFFER_BLKINITSTORE_HI  `L15_NOC1BUFFER_BLKINITSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_DATA_INDEX_LO  `L15_NOC1BUFFER_BLKINITSTORE_HI + 1
































// `define L15_CPUID_ADDRESS 40'h9800000900






////////////////
// CSM
////////////////



// Tri: save space on l15 sram






















//HMC array
































//Special addresses for HMC


//`define L15_ADDR_TYPE_TAG_ACCESS     8'hb4 // later
//`define L15_ADDR_TYPE_STATE_ACCESS   8'hb6 // later
//`define L15_ADDR_TYPE_DIR_ACCESS     8'hb1 // later
//`define L15_ADDR_TYPE_CTRL_REG       8'hb9
//`define L15_ADDR_TYPE_DIS_FLUSH      8'hbc, 8'hbd, 8'hbe, 8'hbf
// `define L15_ADDR_TYPE_HMT_BASE_REG      8'hb7


















// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































// devices.xml



module flat_id_to_xy(
    input  [(6-1):0] flat_id,
    output reg [(8-1):0] x_coord,
    output reg [(8-1):0] y_coord
);

    always @*
    begin
        case (flat_id)
        
//(`NOC_Y_WIDTH+`NOC_X_WIDTH)'d0: 
6'd0: 
begin
    x_coord = 3'd0;
    y_coord = 3'd0;
end

        default:
        begin
            x_coord = 3'dX;
            y_coord = 3'dX;
        end
        endcase
    end
endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_1rw_128x78
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [7-1:0] A,
input wire RDWEN,
input wire [78-1:0] BW,
input wire [78-1:0] DIN,
output wire [78-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [78-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (128),
   .ADDR_WIDTH    (7),
   .BITMASK_WIDTH (78),
   .DATA_WIDTH    (78)
)   sram_1rw_128x78 (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// Author: Tri Nguyen

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE







module sram_l1d_data_piton
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6:0] A,
input wire RDWEN,
input wire [287:0] BW,
input wire [287:0] DIN,
output wire [287:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);
reg [287:0] cache [(512/4)-1:0];

integer i;
initial
begin
   for (i = 0; i < (512/4); i = i + 1)
   begin
      cache[i] = 0;
   end
end



   reg [287:0] dout_f;

   assign DOUT = dout_f;

   always @ (posedge MEMCLK)
   begin
      if (CE)
      begin
         if (RDWEN == 1'b0)
            cache[A] <= (DIN & BW) | (cache[A] & ~BW);
         else
            dout_f <= cache[A];
      end
   end

endmodule



















































































/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1d_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [(6+1)-1:0] A,
input wire RDWEN,
input wire [(33*4)-1:0] BW,
input wire [(33*4)-1:0] DIN,
output wire [(33*4)-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [(33*4)-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         ((512/4)),
   .ADDR_WIDTH    ((6+1)),
   .BITMASK_WIDTH ((33*4)),
   .DATA_WIDTH    ((33*4))
)   sram_l1d_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1i_data
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+2-1:0] A,
input wire RDWEN,
input wire [272-1:0] BW,
input wire [272-1:0] DIN,
output wire [272-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [272-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((8192/32/2))*2),
   .ADDR_WIDTH    (6+2),
   .BITMASK_WIDTH (272),
   .DATA_WIDTH    (272)
)   sram_l1i_data (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































module sram_l1i_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+1-1:0] A,
input wire RDWEN,
input wire [132-1:0] BW,
input wire [132-1:0] DIN,
output wire [132-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [132-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((8192/32/2))),
   .ADDR_WIDTH    (6+1),
   .BITMASK_WIDTH (132),
   .DATA_WIDTH    (132)
)   sram_l1i_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_frf.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: bw_r_frf
// Description: This is the floating point register file.  It has one R/W port that is
//     78 bits (64 bits data, 14 bits ecc) wide.
*/


// trin 4/18/16: always use nowrapper implementation
//  all others will fail floating point tests



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module bw_r_frf (/*AUTOARG*/
   // Outputs
   so, frf_dp_data,
   // Inputs
   rclk, si, se, sehold, rst_tri_en, ctl_frf_wen, ctl_frf_ren,
   dp_frf_data, ctl_frf_addr,


   // sram wrapper interface
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data

   ) ;
   input rclk;
   input si;
   input se;
   input sehold;
   input rst_tri_en;
   input [1:0] ctl_frf_wen;
   input ctl_frf_ren;
   input [77:0] dp_frf_data;
   input [6:0]   ctl_frf_addr;

   output so;
   output [77:0] frf_dp_data;

   wire [7:0]    regfile_index;
  //  wire [7:0]   regfile_index_low;
    // wire [7:0] regfile_index_high;
   //
   reg [77:0] frf_dp_data_f;

   assign frf_dp_data = frf_dp_data_f;

  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;

   // reg            rst_tri_en_negedge;
   // wire           ren_d1;
   // wire [6:0]     addr_d1;
   // wire [1:0]     wen_d1;
   // wire [77:0]    write_data_d1;
   // wire [77:0]    sehold_write_data;
   // wire [9:0]     sehold_cntl_data;

   // wire [9:0]     cntl_scan_data;
   // wire [38:0]    write_scan_data_hi;
   // wire [38:0]    write_scan_data_lo;
   // wire [38:0]    read_scan_data_hi;
   // wire [38:0]    read_scan_data_lo;

   // wire           real_se;
   // assign         real_se = se & ~sehold;

   // This is for sas comparisons
   assign        regfile_index[7:0] = {ctl_frf_addr[6:0], 1'b0};

   // assign        regfile_index_low[7:0] = {addr_d1[6:0], 1'b0};
   // assign        regfile_index_high[7:0] = {addr_d1[6:0], 1'b1};

   // assign         sehold_write_data[77:0] = (sehold)? write_data_d1[77:0]: dp_frf_data[77:0];
   // assign sehold_cntl_data[9:0] = (sehold)? {addr_d1[6:0],wen_d1[1:0], ren_d1}:
   //                                          {ctl_frf_addr[6:0],ctl_frf_wen[1:0],ctl_frf_ren};
   // All inputs go through flop
   // dff_s #(39) datain_dff1(.din(sehold_write_data[77:39]), .clk(rclk), .q(write_data_d1[77:39]),
   //                       .se(real_se), .si({cntl_scan_data[0],write_scan_data_lo[38:1]}),
   //                       .so(write_scan_data_hi[38:0]));
   // dff_s #(39) datain_dff2(.din(sehold_write_data[38:0]), .clk(rclk), .q(write_data_d1[38:0]),
   //                       .se(real_se), .si(write_scan_data_hi[38:0]), .so(write_scan_data_lo[38:0]));
   // dff_s #(10) controlin_dff(.din(sehold_cntl_data[9:0]),
   //                         .q({addr_d1[6:0],wen_d1[1:0],ren_d1}),
   //                         .clk(rclk), .se(real_se), .si({si,cntl_scan_data[9:1]}), .so(cntl_scan_data[9:0]));


   wire [77:0] write_mask = {{39{ctl_frf_wen[1]}},{39{ctl_frf_wen[0]}}};
   wire ctl_frf_wens = ctl_frf_wen[1] | ctl_frf_wen[0];

   wire [77:0] read_data;
sram_1rw_128x78 regfile
//sram_configurable_frf regfile
(
  .MEMCLK(rclk),
  .RESET_N(!rst_tri_en),
  .CE(ctl_frf_wens | ctl_frf_ren),
  .A(ctl_frf_addr),
  .DIN(dp_frf_data),
  .BW(write_mask),
  .RDWEN(~ctl_frf_wens),
  .DOUT(read_data),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(8'd5)
);

   always @ (posedge rclk)
   begin
      frf_dp_data_f <= read_data;
   end

   // dff_s #(39) dataout_dff1(.din(read_data[77:39]), .clk(rclk), .q(frf_dp_data[77:39]),
   //                        .se(real_se), .si(read_scan_data_lo[38:0]), .so(read_scan_data_hi[38:0]));
   // dff_s #(39) dataout_dff2(.din(read_data[38:0]), .clk(rclk), .q(frf_dp_data[38:0]),
   //                        .se(real_se), .si({read_scan_data_hi[37:0],write_scan_data_lo[0]}),
   //                        .so(read_scan_data_lo[38:0]));
   // assign so = read_scan_data_hi[38];


   // always @ (negedge rclk) begin
   //    // latch rst_tri_en
   //    rst_tri_en_negedge <= rst_tri_en;
   // end

endmodule // sparc_ffu_frf


































































































































// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_icd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_icd
 //  Description:
 //    The ICD contains the icache data.
 //    32B line size.
 //    Write BW: 16B
 //    Read BW: 16Bx2 (fetdata and topdata), collapsed to 4Bx2
 //    Associativity: 4
 //    Write boundary: 34b (32b inst + parity + predec bit)
 //    NOTES:
 //    1. No clock enable.  Rd/Wr enable is used to trigger the
 //    operation.
 //    2. 2:1 mux on address input.  Selects provided externally.
 //    3. 3:1 mux on data input.   Selects provided and guaranteed
 //    exclusive, externally.
 //
 */


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting






















//PITON_PROTO enables all FPGA related modifications






















































































































































































































































































































































































module bw_r_icd(

    // sram wrapper interface
    sram_icache_w10_rtap_data,
    sram_icache_w32_rtap_data,
    rtap_srams_bist_command,
    rtap_srams_bist_data,


    icd_wsel_fetdata_s1, icd_wsel_topdata_s1, icd_fuse_repair_value,
    icd_fuse_repair_en, so, rclk, se, si, reset_l, sehold, fdp_icd_index_bf,
    ifq_icd_index_bf, fcl_icd_index_sel_ifq_bf, ifq_icd_wrway_bf,
    ifq_icd_worden_bf, ifq_icd_wrdata_i2, fcl_icd_rdreq_bf,
    fcl_icd_wrreq_bf, bist_ic_data, rst_tri_en, ifq_icd_data_sel_old_i2,
    ifq_icd_data_sel_fill_i2, ifq_icd_data_sel_bist_i2, fuse_icd_wren,
    fuse_icd_rid, fuse_icd_repair_value, fuse_icd_repair_en,
    efc_spc_fuse_clk1);

    // sram wrapper interface
    output [4-1:0] sram_icache_w10_rtap_data;
    output [4-1:0] sram_icache_w32_rtap_data;
    input  [4-1:0] rtap_srams_bist_command;
    input  [4-1:0] rtap_srams_bist_data;

    input           rclk;
    input           se;
    input           si;
    input           reset_l;
    input           sehold;
    input   [(6 + 5):2]      fdp_icd_index_bf;
    input   [(6 + 5):2]      ifq_icd_index_bf;
    input           fcl_icd_index_sel_ifq_bf;
    input   [1:0]       ifq_icd_wrway_bf;
    input   [3:0]       ifq_icd_worden_bf;
    input   [135:0]     ifq_icd_wrdata_i2;
    input           fcl_icd_rdreq_bf;
    input           fcl_icd_wrreq_bf;
    input   [7:0]       bist_ic_data;
    input           rst_tri_en;
    input           ifq_icd_data_sel_old_i2;
    input           ifq_icd_data_sel_fill_i2;
    input           ifq_icd_data_sel_bist_i2;
    input           fuse_icd_wren;
    input   [3:0]       fuse_icd_rid;
    input   [7:0]       fuse_icd_repair_value;
    input   [1:0]       fuse_icd_repair_en;
    input           efc_spc_fuse_clk1;
    output  [135:0]     icd_wsel_fetdata_s1;
    output  [135:0]     icd_wsel_topdata_s1;
    output  [7:0]       icd_fuse_repair_value;
    output  [1:0]       icd_fuse_repair_en;
    output          so;

    reg [7:0]       icd_fuse_repair_value;
    reg [1:0]       icd_fuse_repair_en;
    reg [135:0]     fetdata_f;
    reg [135:0]     topdata_f;
    // reg [135:0]     fetdata_sa;
    // reg [135:0]     topdata_sa;
    reg [135:0]     fetdata_s1;
    reg [135:0]     topdata_s1;
    wire            clk;
    wire    [135:0]     next_wrdata_bf;
    reg    [135:0]     wrdata_f;
    wire    [135:0]     bist_data_expand;
    wire [(6 + 5):2]     index_bf;
    reg [(6 + 5):2]      index_f;
    reg [(6 + 5):2]      index_s1;
    // reg [`IC_IDX_HI:0]      wr_index0;
    // reg [`IC_IDX_HI:0]      wr_index1;
    // reg [`IC_IDX_HI:0]      wr_index2;
    // reg [`IC_IDX_HI:0]      wr_index3;
    // reg         rdreq_f;
    // reg         wrreq_f;
    // reg [3:0]       worden_f;
    reg [1:0]       wrway_f;


    assign clk = rclk;
    assign index_bf = (fcl_icd_index_sel_ifq_bf ? ifq_icd_index_bf :
        fdp_icd_index_bf);

    // wire [`IC_IDX_HI:2] top_index = {index_f[`IC_IDX_HI:3] , 1'b1};

    always @ (posedge clk)
    begin
        wrway_f <= ifq_icd_wrway_bf;
        index_f <= index_bf;
        index_s1 <= index_f;
    end

    assign bist_data_expand = 136'b0;
    assign icd_wsel_fetdata_s1 = fetdata_s1;
    assign icd_wsel_topdata_s1 = topdata_s1;

    // mux3ds #(136) icden_mux(
    //     .dout               (next_wrdata_bf),
    //     .in0                (wrdata_f),
    //     .in1                (ifq_icd_wrdata_i2),
    //     .in2                (bist_data_expand),
    //     .sel0               (ifq_icd_data_sel_old_i2),
    //     .sel1               (ifq_icd_data_sel_fill_i2),
    //     .sel2               (ifq_icd_data_sel_bist_i2));
    // dffe_s #(136) wrdata_reg(
    //     .din                (next_wrdata_bf),
    //     .clk                (clk),
    //     .q              (wrdata_f),
    //     .en             ((~sehold)),
    //     .se             (se));

    assign next_wrdata_bf = ifq_icd_data_sel_old_i2 ? wrdata_f :
                            ifq_icd_data_sel_fill_i2 ? ifq_icd_wrdata_i2 : bist_data_expand;

    always @ (posedge clk)
    begin
        wrdata_f <= next_wrdata_bf;
    end

    wire  [543:0] read_data_f;
    wire [543:0] wrdata_expanded_bf;
    reg  [543:0] wrmask_expanded_bf;
    wire [135:0] wrmask_bf;

sram_l1i_data icache_way_10
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[271:0]),
    .BW(wrmask_expanded_bf[271:0]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[271:0]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w10_rtap_data),
    .SRAMID(8'd1)
);


sram_l1i_data icache_way_32
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[543:272]),
    .BW(wrmask_expanded_bf[543:272]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[543:272]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w32_rtap_data),
    .SRAMID(8'd2)
);


    // reg  [543:0] read_data_s1;
    wire [33:0]     icdata_ary_00_00;
    wire [33:0]     icdata_ary_00_01;
    wire [33:0]     icdata_ary_00_10;
    wire [33:0]     icdata_ary_00_11;
    wire [33:0]     icdata_ary_01_00;
    wire [33:0]     icdata_ary_01_01;
    wire [33:0]     icdata_ary_01_10;
    wire [33:0]     icdata_ary_01_11;
    wire [33:0]     icdata_ary_10_00;
    wire [33:0]     icdata_ary_10_01;
    wire [33:0]     icdata_ary_10_10;
    wire [33:0]     icdata_ary_10_11;
    wire [33:0]     icdata_ary_11_00;
    wire [33:0]     icdata_ary_11_01;
    wire [33:0]     icdata_ary_11_10;
    wire [33:0]     icdata_ary_11_11;
    // reg [135:0]     fetdata_s1;
    // reg [135:0]     topdata_s1;

    assign {icdata_ary_11_00,icdata_ary_11_01,icdata_ary_11_10,icdata_ary_11_11,
            icdata_ary_10_00,icdata_ary_10_01,icdata_ary_10_10,icdata_ary_10_11,
            icdata_ary_01_00,icdata_ary_01_01,icdata_ary_01_10,icdata_ary_01_11,
            icdata_ary_00_00,icdata_ary_00_01,icdata_ary_00_10,icdata_ary_00_11} = read_data_f;

    // way, word

    always @ *
    begin
      case (index_f[3:2])
        2'b00:
        begin
          fetdata_f = {icdata_ary_11_00, icdata_ary_10_00, icdata_ary_01_00, icdata_ary_00_00};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b01:
        begin
          fetdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b10:
        begin
          fetdata_f = {icdata_ary_11_10, icdata_ary_10_10, icdata_ary_01_10, icdata_ary_00_10};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
        2'b11:
        begin
          fetdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
      endcase
    end

    // always @ (posedge clk)
    // begin
    // end

    ///WRITE

    assign wrdata_expanded_bf = {4{next_wrdata_bf}};
    assign wrmask_bf = {{34{ifq_icd_worden_bf[0]}},{34{ifq_icd_worden_bf[1]}},{34{ifq_icd_worden_bf[2]}},{34{ifq_icd_worden_bf[3]}}};

    always @ *
    begin
        case (ifq_icd_wrway_bf)
          2'b11:
          begin
            wrmask_expanded_bf = {wrmask_bf, 136'b0, 136'b0, 136'b0};
          end
          2'b10:
          begin
            wrmask_expanded_bf = {136'b0, wrmask_bf, 136'b0, 136'b0};
          end
          2'b01:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, wrmask_bf, 136'b0};
          end
          2'b00:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, 136'b0, wrmask_bf};
          end
        endcase
    end

    always @ (posedge clk)
    begin
        fetdata_s1 <= fetdata_f;
        topdata_s1 <= topdata_f;
    end


endmodule


 // IBM









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1i_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1i_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

//`include "iop.h"
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1i_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [15:0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [3:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [15:0] debug_data_bmask;
reg [15:0] debug_data_in;
reg [15:0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [15:0] mem [0:((8192/32/2/4))-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [15:0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [15:0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[6-2:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[6-2:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
integer memidx;
reg [15:0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      // mem[0] <= 16'b0;
      // mem[1] <= 16'b0;
      // mem[2] <= 16'b0;
      // mem[3] <= 16'b0;
      // mem[4] <= 16'b0;
      // mem[5] <= 16'b0;
      // mem[6] <= 16'b0;
      // mem[7] <= 16'b0;
      // mem[8] <= 16'b0;
      // mem[9] <= 16'b0;
      // mem[10] <= 16'b0;
      // mem[11] <= 16'b0;
      // mem[12] <= 16'b0;
      // mem[13] <= 16'b0;
      // mem[14] <= 16'b0;
      // mem[15] <= 16'b0;
      // mem[16] <= 16'b0;
      // mem[17] <= 16'b0;
      // mem[18] <= 16'b0;
      // mem[19] <= 16'b0;
      // mem[20] <= 16'b0;
      // mem[21] <= 16'b0;
      // mem[22] <= 16'b0;
      // mem[23] <= 16'b0;
      // mem[24] <= 16'b0;
      // mem[25] <= 16'b0;
      // mem[26] <= 16'b0;
      // mem[27] <= 16'b0;
      // mem[28] <= 16'b0;
      // mem[29] <= 16'b0;
      // mem[30] <= 16'b0;
      // mem[31] <= 16'b0;
      
      // genvar memidx;
      // generate
      // for (memidx = 0; memidx < `IC_VAL_SET_COUNT; memidx = memidx + 1) begin
      //   mem[memidx] <= 16b'0;
      // end
      
      for (memidx = 0; memidx < ((8192/32/2/4)); memidx = memidx + 1) begin
        mem[memidx] <= 16'b0;
      end
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [15:0] read1;
reg [15:0] read2;
reg [15:0] read3;
reg [15:0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[3:0];
      2'b01:
         read3 = read2[7:4];
      2'b10:
         read3 = read2[11:8];
      2'b11:
         read3 = read2[15:12];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0];
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[15:0] = bist_data_reg[15:0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1i_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_scm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Store Buffer of Load/Store Unit (CAM Side)
//		 - Physically divided into CAM and DATA RAMs.
//                              - CAM RAM has a single cam port and a single
//                              port for read/writes. The cam port is for loads,
//                              write for stores, read for test/diagnostic purposes.
//                              rd or write can be simultaneous with cam. can rd and cam
//                              a single entry simultaneously. cannot write and cam
//                              the same entry.
//                              - DATA RAM read occurs for a load raw match in the
//                              stb CAM RAM. DATA RAM write occurs a store. Both
//                              actions are architecturally guaranteed to be
//                              mutex.
//                              - Write occurs simultaneously to both arrays.
//                              - Reads are not necessarily simultaneous and are
//                              controlled by individual read signals.
//                              - Certain bits are maintained outside the array
//                              in the stb's control section, such as the valid
//                              bits.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications






module bw_r_scm (/*AUTOARG*/
   // Outputs

    stb_rcsm_ramc,

   stb_rdata_ramc, stb_ld_full_raw, stb_ld_partial_raw,
   stb_cam_hit_ptr, stb_cam_hit, stb_cam_mhit,
   // Inputs

   stb_cam_csm,stb_alt_wr_csm,

   stb_cam_data, stb_alt_wr_data, stb_camwr_data, stb_alt_wsel,
   stb_cam_vld, stb_cam_cm_tid, stb_cam_sqsh_msk, stb_cam_rw_ptr,
   stb_cam_wptr_vld, stb_cam_rptr_vld, stb_cam_rw_tid,
   stb_quad_ld_cam, rclk, rst_tri_en
   ) ;

parameter NUMENTRIES = 32 ;				// number of entries in stb

input	[44:15]		stb_cam_data ;	  // data for compare; disjoint msb
input	[44:15]		stb_alt_wr_data ;	  // data for compare; disjoint msb
input	[14:0]		stb_camwr_data ;  // data for compare/write; common lsb
input			stb_alt_wsel ;
input			stb_cam_vld ;	  // cam is required.
input	[1:0]		stb_cam_cm_tid ;  // thread id for cam operation.
input	[7:0]		stb_cam_sqsh_msk; // mask for squashing cam results.

input 	[2:0]		stb_cam_rw_ptr ;  // wr pointer for single port.
input 	     		stb_cam_wptr_vld ;// write pointer vld
input 	     		stb_cam_rptr_vld ;// write pointer vld
input	[1:0]		stb_cam_rw_tid ;  // thread id for rw.
input 			stb_quad_ld_cam ; // quad-ld cam.

input			rclk ;		  // clock

//input			scan_ena ;	  // no longer required !
//input	[7:0]		adj ;

input			rst_tri_en ;


input   [32:0] stb_cam_csm;
input   [32:0] stb_alt_wr_csm;

output  [32:0] stb_rcsm_ramc;


output	[44:0]		stb_rdata_ramc ;  // rd data from CAM RAM.
// raw output is muxed on a thread basis.
output	[7:0]		stb_ld_full_raw ; // ld with full raw.
output	[7:0]		stb_ld_partial_raw ; // ld with partial raw.
output	[2:0]		stb_cam_hit_ptr ;
output			stb_cam_hit ;	  // any hit in stb
output			stb_cam_mhit ;	  // multiple hits in stb


/*UTOREG*/
// Beginning of automatic regs (for this module's undeclared outputs)
// End of automatics
reg [44:0]		stb_rdata_ramc ;
reg [31:0]		rw_wdline ;
reg [44:0]		stb_ramc [NUMENTRIES-1:0] /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */;
reg [44:0]		ramc_entry ;
reg [36:0]		cam_tag ;
reg [31:0]		ptag_hit ;
reg [7:0]		cam_bmask ;
reg [31:0]		byte_match ;
reg [31:0]		byte_overlap ;
reg [31:0]		ld_full_raw ;
reg [31:0]		ld_partial_raw ;
reg [44:15]		alt_wr_data ;
reg [44:15]		pipe_wr_data ;
reg [14:0]		camwr_data ;
reg			wptr_vld ;
reg			rptr_vld_tmp ;
reg [1:0]	  	cam_tid ;
reg [1:0]	  	cam_vld ;
reg			alt_wsel ;

wire		rptr_vld ;
wire 		ldq ;
wire	[7:0]	sqsh_msk ;
wire 	[7:0]	ld_full_raw_mx ;
wire    [7:0]	ld_partial_raw_mx ;
wire	[7:0]	ptag_hit_mx ;
wire	[7:0]	byte_overlap_mx ;
wire	[7:0]	byte_match_mx ;
wire	[7:0]	cam_hit ;
wire	[44:0]	wdata_ramc ;
wire	[44:0]	cam_data ;
wire	[44:15] wr_data ;

reg	[4:0]	stb_addr;



reg [32:0] stb_rcsm_ramc;
reg [32:0] stb_csm_ramc [NUMENTRIES-1:0];
reg [32:0] pipe_wr_csm;
wire [32:0] wcsm_ramc;
reg [32:0] alt_wr_csm;


integer	i,j,k,l ;


wire	scan_ena ;
assign	scan_ena = 1'b0 ;

//=========================================================================================
//	generate wordlines
//=========================================================================================

assign	sqsh_msk[7:0]	= stb_cam_sqsh_msk[7:0];

// cam_vld and cam_tid_tmp are set-up a phase earlier.
// Comment out - Now setup to posedge.
/*always @(negedge clk)
	begin
		cam_tid_tmp[1:0]	<= stb_cam_cm_tid[1:0] ;
		cam_vld_tmp		<= stb_cam_vld ;
	end */
















always @(posedge rclk)
	begin
		pipe_wr_data[44:15] <= stb_cam_data[44:15];
		alt_wr_data[44:15] <= stb_alt_wr_data[44:15];
		camwr_data[14:0] <= stb_camwr_data[14:0];
		wptr_vld 	<= stb_cam_wptr_vld ;
		rptr_vld_tmp 	<= stb_cam_rptr_vld ;
		cam_tid[1:0]	<= stb_cam_cm_tid[1:0] ;
		//cam_tid[1:0]	<= cam_tid_tmp[1:0] ;
 		//ldq 		<=  stb_quad_ld_cam ; Bug 2870
		alt_wsel 	<= stb_alt_wsel ;


		pipe_wr_csm <= stb_cam_csm;
        alt_wr_csm  <= stb_alt_wr_csm;


                stb_addr	<= {stb_cam_rw_tid[1:0],stb_cam_rw_ptr[2:0]};

	end

assign 	ldq =  stb_quad_ld_cam ;
assign  rptr_vld = rptr_vld_tmp | rst_tri_en ;

//=========================================================================================
//	write or read to/from memory
//=========================================================================================

// For blk-st, select out-of-pipe.
assign	wr_data[44:15] = alt_wsel ?
                alt_wr_data[44:15] : pipe_wr_data[44:15] ;

assign	wdata_ramc[44:0] = {wr_data[44:15],camwr_data[14:0]};

assign wcsm_ramc = alt_wsel ? alt_wr_csm : pipe_wr_csm;




// Write
always @ (negedge rclk)
	begin

	if(wptr_vld) begin
		if(~rst_tri_en) begin
			stb_ramc[stb_addr] <= wdata_ramc[44:0];
            stb_csm_ramc[stb_addr] <= wcsm_ramc;
			stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
            stb_rcsm_ramc <= wcsm_ramc;
                end else begin
			stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
            stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
		end
	end






















// Read

		if(rptr_vld & ~scan_ena) begin
			if (rptr_vld & wptr_vld & ~rst_tri_en) begin
				stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
                stb_rcsm_ramc <= wcsm_ramc;
			end
			else begin
				stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
                stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
			end
		end


















	end

























































//=========================================================================================
//	CAM contents of CAM RAM
//=========================================================================================

// - Generate full/partial raw for incoming load.
// - Output signals need to be qualified with per entry
// vlds before causing any subsequent event, the read of
// the DATA RAM specifically.
// - full_raw & vld will cause rd of DATA RAM.
// - partial_raw & vld will cause ld to follow corresponding
// st on way out to xbar.
// - logic to generate partial and full raws may be done outside
// but that would require an additional signal per entry to
// be output.

// Mapping of cam/write data
//
//	| 	40-3=37b(pa)	| 1b(stquad) 	|	8b(bytemask)	| <- use
//	|	45:9		| 8		|	7:0		| <- input port
//				**^ stquad rm'ed

assign	cam_data[44:0] = {stb_cam_data[44:15],stb_camwr_data[14:0]};

always @ (posedge rclk)
	begin

		for (l=0;l<NUMENTRIES;l=l+1)
				begin
				ramc_entry[44:0] = stb_ramc[l] ;

				cam_tag[36:0] = ramc_entry[44:8] ;
				cam_bmask[7:0] = ramc_entry[7:0] ;
				//stq =	ramc_entry[8] ;			// additional bit -stq

				// Prior to adding stb_quad_ld_cam port.
				/*ptag_hit[l] =
					((cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~stq) | stq)) & stcam_vld_tmp & ~scan_ena ;*/
				// Modification.
				// * remove ramc_entry[8]. Or keep it but it won't be used.
				// * Instead we'll control this from outside.
				ptag_hit[l] =
					(cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~ldq) | ldq) & stb_cam_vld & ~scan_ena ;
				byte_match[l] = |(cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;
				// Simplification :
				byte_overlap[l] = |(~cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;

				end
	end

// Mux the raw signals down to 8b quantities. Squash mask comes mid-way thru cycle.


assign	byte_overlap_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_overlap[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_overlap[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_overlap[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_overlap[31:24] : 8'bxxxx_xxxx ;

assign	byte_match_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_match[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_match[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_match[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_match[31:24] : 8'bxxxx_xxxx ;

assign	ptag_hit_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? ptag_hit[7:0] :
		(cam_tid[1:0] == 2'b01) ? ptag_hit[15:8] :
			(cam_tid[1:0] == 2'b10) ? ptag_hit[23:16] :
				(cam_tid[1:0] == 2'b11) ? ptag_hit[31:24] : 8'bxxxx_xxxx ;

assign	stb_ld_full_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_ld_partial_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] &  byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;

assign	cam_hit[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_cam_hit = |(cam_hit[7:0]);

// The stb data is meant to be read for single hit full raw case. It may actually be read
// for full raw, partial raw or multiple hit case but the read output will be ignored for
// partial and multiple hit case. Multiple hits will not cause a hazard as the ptr is first
// encoded and then decoded to form the wdline for the stb-data
// Use cam_hit result to void false hits.
assign	stb_cam_hit_ptr[0] 	=  cam_hit[1] | cam_hit[3] | cam_hit[5] | cam_hit[7] ;
assign	stb_cam_hit_ptr[1] 	=  cam_hit[2] | cam_hit[3] | cam_hit[6] | cam_hit[7] ;
assign	stb_cam_hit_ptr[2] 	=  cam_hit[4] | cam_hit[5] | cam_hit[6] | cam_hit[7] ;

//Generating multiple hits
assign  stb_cam_mhit            =  (cam_hit[0]  & cam_hit[1]) | (cam_hit[2] & cam_hit[3])  |
                                   (cam_hit[4]  & cam_hit[5]) | (cam_hit[6] & cam_hit[7])  |
                                   ((cam_hit[0] | cam_hit[1]) & (cam_hit[2] | cam_hit[3])) |
                                   ((cam_hit[4] | cam_hit[5]) & (cam_hit[6] | cam_hit[7])) |
                                   ((|cam_hit[3:0]) & (|cam_hit[7:4]));

//--------------------------------------------------------------
// Error Checking.
//--------------------------------------------------------------

// 1. simultaneous rd/wr on single port - terminate
// 2. simultaneous cam and wr - terminate
// * PUT OUTSIDE OF SRAM RTL, AS RST NOT AVAILABLE. *

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x152b.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    DCache Fill Queue of Load Store Unit.
//                      - Contains invalidates and loads.
//                      - loads will bypass and/or fill dcache.
//                      - Entry at head of queue may have to
//                      be held for multiple passes.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_rf32x152b(dout, so, rd_en, rd_adr, wr_en, wr_adr, din, si, se,
  sehold, rclk, rst_tri_en, reset_l);

  parameter   NUMENTRIES  = 32;

  input [4:0]   rd_adr;
  input     rd_en;
  input     wr_en;
  input [4:0]   wr_adr;
  input [151:0]   din;
  input     rclk;
  input     reset_l;
  input     rst_tri_en;
  input     sehold;
  input     si;
  input     se;
  output  [151:0]   dout;
  // reg [151:0]   dout;
  output      so;

  wire      clk;
  wire      wr_vld;

  reg [151:0]   mem[(NUMENTRIES - 1):0];  /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */
  // reg rd_en_d1;
  reg [4:0]   rd_adr_d1;

  assign clk = rclk;
  assign wr_vld = ((wr_en & (~rst_tri_en)) & reset_l);

  always @(posedge clk) begin
    if (wr_vld) begin
      mem[wr_adr] = din;
    end
    // rd_en_d1 <= rd_en;
    rd_adr_d1 <= rd_adr;
  end

  assign dout = mem[rd_adr_d1];

endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1d_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1d_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

//`include "iop.h"

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1d_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [(4*4-1):0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [4-1:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [(4*4-1):0] debug_data_bmask;
reg [(4*4-1):0] debug_data_in;
reg [(4*4-1):0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [(4*4-1):0] mem [0:((512/4)/4)-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [(4*4-1):0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [(4*4-1):0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[4:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[4:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
reg [(4*4-1):0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      mem[0] <= 16'b0;
      mem[1] <= 16'b0;
      mem[2] <= 16'b0;
      mem[3] <= 16'b0;
      mem[4] <= 16'b0;
      mem[5] <= 16'b0;
      mem[6] <= 16'b0;
      mem[7] <= 16'b0;
      mem[8] <= 16'b0;
      mem[9] <= 16'b0;
      mem[10] <= 16'b0;
      mem[11] <= 16'b0;
      mem[12] <= 16'b0;
      mem[13] <= 16'b0;
      mem[14] <= 16'b0;
      mem[15] <= 16'b0;
      mem[16] <= 16'b0;
      mem[17] <= 16'b0;
      mem[18] <= 16'b0;
      mem[19] <= 16'b0;
      mem[20] <= 16'b0;
      mem[21] <= 16'b0;
      mem[22] <= 16'b0;
      mem[23] <= 16'b0;
      mem[24] <= 16'b0;
      mem[25] <= 16'b0;
      mem[26] <= 16'b0;
      mem[27] <= 16'b0;
      mem[28] <= 16'b0;
      mem[29] <= 16'b0;
      mem[30] <= 16'b0;
      mem[31] <= 16'b0;
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [(4*4-1):0] read1;
reg [(4*4-1):0] read2;
reg [(4*4-1):0] read3;
reg [(4*4-1):0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[`L1D_SET_IDX_HI:2] == write_address_y[`L1D_SET_IDX_HI:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[4*1-1 -: 4];
      2'b01:
         read3 = read2[4*2-1 -: 4];
      2'b10:
         read3 = read2[4*3-1 -: 4];
      2'b11:
         read3 = read2[4*4-1 -: 4];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0]; // trin reconfig
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[(4*4-1):0] = bist_data_reg[(4*4-1):0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1d_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x80.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Trap Stack Array
//			- Dual-Ported.
//			- Port1 - Write Port; Used by wrpr, trap insertion.
//			Write occurs in W Stage. (M1:M2:W).
//			- Port2 - Read Port; Used by rdpr, done/retry.
//			Read occurs in E Stage.
//			- Arranged as 6(trap-levels/thread) x 4 threads = 24 entries.
//			Trap-level and thread id used to index array.
*/
////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications



















































































































































































































































module bw_r_rf32x80(/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rd_en, rd_adr, wr_en, nib_wr_en, wr_adr, din,
   si, se, sehold, rclk, rst_tri_en, reset_l);

parameter NUM_TPL = 6 ;         // 6 supported trap levels.
parameter NUM_ENTRIES = 32 ;    // 8 entries per thread

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
input [4:0]   rd_adr;     // read adr.
input         rd_en;      // read pointer
input         wr_en;      // write pointer vld
input [19:0]  nib_wr_en;  // enable write of a byte in tsa.
input [4:0]   wr_adr;     // write adr.
input [79:0] din;         // wr data for tsa.
input         rclk;       // clock
input         reset_l;    // active low reset
input         rst_tri_en; // reset and scan
input         sehold;     // scan hold
input         si;         // scan in
input         se;         // scan enable

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics
output  [79:0] dout ; // rd data for tsa.
output          so ;   // scan out write

   wire [159:0] write_mask; // write-mask
   reg [3:0] rd_adr_d1;
   reg [3:0] rd_adr_d2;
   reg read_en_d1;
   reg read_en_d2;

// for sastasks?
// reg [79:0]      temp_tlvl = 0;

   // memory
   reg [79:0] inq_ary [NUM_ENTRIES-1:0];

   // read
   assign dout = inq_ary[rd_adr_d1];

   // write
   always @ (posedge rclk)
   begin
      if (!reset_l)
      begin
         // assume flops
         inq_ary[00] <= 80'b0;
         inq_ary[01] <= 80'b0;
         inq_ary[02] <= 80'b0;
         inq_ary[03] <= 80'b0;
         inq_ary[04] <= 80'b0;
         inq_ary[05] <= 80'b0;
         inq_ary[06] <= 80'b0;
         inq_ary[07] <= 80'b0;
         inq_ary[08] <= 80'b0;
         inq_ary[09] <= 80'b0;
         inq_ary[10] <= 80'b0;
         inq_ary[11] <= 80'b0;
         inq_ary[12] <= 80'b0;
         inq_ary[13] <= 80'b0;
         inq_ary[14] <= 80'b0;
         inq_ary[15] <= 80'b0;
         inq_ary[16] <= 80'b0;
         inq_ary[17] <= 80'b0;
         inq_ary[18] <= 80'b0;
         inq_ary[19] <= 80'b0;
         inq_ary[20] <= 80'b0;
         inq_ary[21] <= 80'b0;
         inq_ary[22] <= 80'b0;
         inq_ary[23] <= 80'b0;
         inq_ary[24] <= 80'b0;
         inq_ary[25] <= 80'b0;
         inq_ary[26] <= 80'b0;
         inq_ary[27] <= 80'b0;
         inq_ary[28] <= 80'b0;
         inq_ary[29] <= 80'b0;
         inq_ary[30] <= 80'b0;
         inq_ary[31] <= 80'b0;
      end
      else
      begin
         if (wr_en)
         begin
            inq_ary[wr_adr] <= (din & write_mask) | (inq_ary[wr_adr] & ~write_mask);
         end
      end
   end

   // pipeline crap
   always @ (posedge rclk)
   begin
      // din_d1 <= din;
      rd_adr_d1 <= rd_adr;
      rd_adr_d2 <= rd_adr_d1;
      // wr_adr_d1 <= wr_adr;
      // wr_en_d1 <= wr_en;
      // word_wen_d1 <= word_wen;
      // byte_wen_d1 <= byte_wen;
      read_en_d1 <= rd_en;
      read_en_d2 <= read_en_d1;
   end

assign  write_mask[79:0] =
    {{4{nib_wr_en[19]}},
     {4{nib_wr_en[18]}},
     {4{nib_wr_en[17]}},
     {4{nib_wr_en[16]}},
     {4{nib_wr_en[15]}},
     {4{nib_wr_en[14]}},
     {4{nib_wr_en[13]}},
     {4{nib_wr_en[12]}},
     {4{nib_wr_en[11]}},
     {4{nib_wr_en[10]}},
     {4{nib_wr_en[9]}},
     {4{nib_wr_en[8]}},
     {4{nib_wr_en[7]}},
     {4{nib_wr_en[6]}},
     {4{nib_wr_en[5]}},
     {4{nib_wr_en[4]}},
     {4{nib_wr_en[3]}},
     {4{nib_wr_en[2]}},
     {4{nib_wr_en[1]}},
     {4{nib_wr_en[0]}}
    };

endmodule











// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dcd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================


// devices.xml


////////////////////////////////////////////////////////////////////////
/*
//  Module Name:
//  Description:  LSU Data Cache.
//      - Physically-Indexed Physically Tagged (PIPT)
//      - 8KB
//      - 4 way set-associative.
//      - 16B lines
//      - 2:1 column select by choosing either lower
//      or upper half of 16B line.
//      - Parity protected on a byte basis.
//      - Byte enables for byte-wide stores.
//
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include  "sys.h" // system level definition file which contains the
                  // time scale definition

//`include "iop.h"
//`include "fabric.h"











//PITON_PROTO enables all FPGA related modifications






////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_dcd ( /*AUTOARG*/
   // Outputs
   so, dcache_rdata_wb, dcache_rparity_wb, dcache_rparity_err_wb,
   dcache_rdata_msb_m,
   // dcache_rdata_msb_w0_m, dcache_rdata_msb_w1_m,
   // dcache_rdata_msb_w2_m, dcache_rdata_msb_w3_m,
   dcd_fuse_repair_value, dcd_fuse_repair_en,
   // Inputs
   dcache_rd_addr_e, dcache_alt_addr_e, dcache_rvld_e, dcache_wvld_e,
   dcache_wdata_e, dcache_wr_rway_e, dcache_byte_wr_en_e,
   dcache_alt_rsel_way_e, dcache_rsel_way_wb, dcache_alt_mx_sel_e,
   si, se, sehold, rst_tri_en, arst_l, rclk, dcache_alt_data_w0_m,
   dcache_arry_data_sel_m, efc_spc_fuse_clk1, fuse_dcd_wren,
   fuse_dcd_rid, fuse_dcd_repair_value, fuse_dcd_repair_en,


   // sram wrapper interface
   sram_dcache_w01_rtap_data,
   sram_dcache_w23_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   ) ;


output [4-1:0] sram_dcache_w01_rtap_data;
output [4-1:0] sram_dcache_w23_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;

input [(6 + 4):3]    dcache_rd_addr_e;     // read cache index [`L1D_ADDRESS_HI:4] + bit [3] offset
input [(6 + 4):3]    dcache_alt_addr_e;    // write/bist/diagnostic read cache index + offset

input           dcache_rvld_e;        // read accesses d$.
input           dcache_wvld_e;        // valid write setup to m-stage.

input [144-1:0]   dcache_wdata_e;       // write data - 16Bx8 + 8b parity.
input [4-1:0]     dcache_wr_rway_e;     // replacement way for load miss/store.
input [15:0]    dcache_byte_wr_en_e;  // 16b byte wr enable for stores.

input [4-1:0]     dcache_alt_rsel_way_e ; // bist/diagnostic read way select
input [4-1:0]     dcache_rsel_way_wb;     // load way select, connect to cache_way_hit
input           dcache_alt_mx_sel_e;

input           si;
input           se;
input           sehold;

output          so;

input   rst_tri_en ;

input           arst_l; // used for redundancy flops - do not reset on wrm reset.

input           rclk;

output reg [63:0]  dcache_rdata_wb;
output reg [7:0]   dcache_rparity_wb;
output reg         dcache_rparity_err_wb;

//=================================
//    dc_fill critical path
//=================================
   input [63:0] dcache_alt_data_w0_m; //from qdp1
   input        dcache_arry_data_sel_m;            //from dctl

   // output [7:0] dcache_rdata_msb_w0_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w1_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w2_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w3_m;    //to dcdp
  
  wire [7:0] dcache_rdata_msb_w0_m;    //to dcdp


  wire [7:0] dcache_rdata_msb_w1_m;    //to dcdp


  wire [7:0] dcache_rdata_msb_w2_m;    //to dcdp


  wire [7:0] dcache_rdata_msb_w3_m;    //to dcdp



   output [8*4-1:0] dcache_rdata_msb_m;    //to dcdp

//-----------------------------------------------------------------------------
// 32KB block fuse inputs
//-----------------------------------------------------------------------------
// efuse non ovl clks
input           efc_spc_fuse_clk1;

input           fuse_dcd_wren;          //redundancy register write enable, qualified
input [2:0]     fuse_dcd_rid;           //redundancy register id
input [7:0]     fuse_dcd_repair_value;  //data in for redundancy register
input [1:0]     fuse_dcd_repair_en;     //enable bits to turn on redundancy
output [7:0]    dcd_fuse_repair_value;  //data out for redundancy register
output [1:0]    dcd_fuse_repair_en;     //enable bits out

// Memory declaration.
wire  [(6 + 4):3]    dcache_rwaddr_e ;
wire  [(6 + 4):3]    dcache_raddr_e ;



// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a;


  wire [144-1:0]   temp_w0a;


  wire [144-1:0]   temp_w1a;


  wire [144-1:0]   temp_w2a;


  wire [144-1:0]   temp_w3a;



// this particular macro contains 2 ways
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way_mask_e = { {8{dcache_byte_wr_en_e[0]}},
//                             {8{dcache_byte_wr_en_e[1]}},
//                             {8{dcache_byte_wr_en_e[2]}},
//                             {8{dcache_byte_wr_en_e[3]}},
//                             {8{dcache_byte_wr_en_e[4]}},
//                             {8{dcache_byte_wr_en_e[5]}},
//                             {8{dcache_byte_wr_en_e[6]}},
//                             {8{dcache_byte_wr_en_e[7]}},
//                             {8{dcache_byte_wr_en_e[8]}},
//                             {8{dcache_byte_wr_en_e[9]}},
//                             {8{dcache_byte_wr_en_e[10]}},
//                             {8{dcache_byte_wr_en_e[11]}},
//                             {8{dcache_byte_wr_en_e[12]}},
//                             {8{dcache_byte_wr_en_e[13]}},
//                             {8{dcache_byte_wr_en_e[14]}},
//                             {8{dcache_byte_wr_en_e[15]}}
//                           };

// Includes data(128b)+parity(16b).
wire [144-1:0] way_mask_e =
    {{8{dcache_byte_wr_en_e[15]}},{8{dcache_byte_wr_en_e[14]}},{8{dcache_byte_wr_en_e[13]}},
     {8{dcache_byte_wr_en_e[12]}},{8{dcache_byte_wr_en_e[11]}},{8{dcache_byte_wr_en_e[10]}},
     {8{dcache_byte_wr_en_e[9]}}, {8{dcache_byte_wr_en_e[8]}}, {8{dcache_byte_wr_en_e[7]}},
     {8{dcache_byte_wr_en_e[6]}}, {8{dcache_byte_wr_en_e[5]}}, {8{dcache_byte_wr_en_e[4]}},
     {8{dcache_byte_wr_en_e[3]}}, {8{dcache_byte_wr_en_e[2]}}, {8{dcache_byte_wr_en_e[1]}},
     {8{dcache_byte_wr_en_e[0]}}, dcache_byte_wr_en_e[15:0]} ;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way2_write_mask = {144{dcache_wr_rway_e[2]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way3_write_mask = {144{dcache_wr_rway_e[3]}} & way_mask_e;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a_reg;

  wire [144-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
  wire [144-1:0]   temp_w0a_reg;


  wire [144-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
  wire [144-1:0]   temp_w1a_reg;


  wire [144-1:0] way2_write_mask = {144{dcache_wr_rway_e[2]}} & way_mask_e;
  wire [144-1:0]   temp_w2a_reg;


  wire [144-1:0] way3_write_mask = {144{dcache_wr_rway_e[3]}} & way_mask_e;
  wire [144-1:0]   temp_w3a_reg;





// !MERGE_L1_DCACHE && SRAM_LSU_DCACHE


sram_l1d_data_piton dcache_way_01
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way1_write_mask, way0_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w1a_reg, temp_w0a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w01_rtap_data),
  .SRAMID(8'd3)
);

sram_l1d_data_piton dcache_way_23
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way3_write_mask, way2_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w3a_reg, temp_w2a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w23_rtap_data),
  .SRAMID(8'd4)
);
























































 // MERGE_L1_DCACHE
























































 // SRAM_LSU_DCACHE

reg [(6 + 4):3]    dcache_rwaddr_m ;
reg [(6 + 4):3]    dcache_raddr_m ;
reg           dcache_rvld_m ;
reg           wvld_m ;
reg [144-1:0]   dcache_wdata_m ;
reg [127:0]   rw_wdline ;
reg [4-1:0]     dcache_wr_rway_m ;

// reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.
// reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.
// reg [63:0]    dcache_rdata_w2_wb;   // way2 64b data.
// reg [63:0]    dcache_rdata_w3_wb;   // way3 64b data.
reg [15:0]    byte_wr_enable ;

reg           dcache_alt_mx_sel_m, dcache_alt_mx_sel_wb;
reg [4-1:0]     dcache_alt_rsel_way_m, dcache_alt_rsel_way_wb;


wire            dcache_wvld_m ;
// wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
// wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
// wire  [63:0]    dcache_rdata_w2_m;    // way2 64b data.
// wire  [63:0]    dcache_rdata_w3_m;    // way3 64b data.
// wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
// wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
// wire  [7:0]     dcache_rparity_w2_m;  // way2 8b parity.
// wire  [7:0]     dcache_rparity_w3_m;  // way3 8b parity.

   // wire [7:0]   rd_parity_err_w0_m;
   // wire [7:0]   rd_parity_err_w1_m;
   // wire [7:0]   rd_parity_err_w2_m;
   // wire [7:0]   rd_parity_err_w3_m;


wire  [144-1:0]   way_mask ;
wire  [144-1:0]   way_mask_inv ;

//calculated parity based on read-out data
// wire [7:0]  gen_dcache_parity_w0_m;
// wire [7:0]  gen_dcache_parity_w1_m;
// wire [7:0]  gen_dcache_parity_w2_m;
// wire [7:0]  gen_dcache_parity_w3_m;

   wire     clk;
   assign   clk = rclk;


    wire [7:0]  gen_dcache_parity_w0_m;
    wire [7:0]   rd_parity_err_w0_m;
    wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
    wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
    reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.


    wire [7:0]  gen_dcache_parity_w1_m;
    wire [7:0]   rd_parity_err_w1_m;
    wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
    wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
    reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.


    wire [7:0]  gen_dcache_parity_w2_m;
    wire [7:0]   rd_parity_err_w2_m;
    wire  [7:0]     dcache_rparity_w2_m;  // way2 8b parity.
    wire  [63:0]    dcache_rdata_w2_m;    // way2 64b data.
    reg [63:0]    dcache_rdata_w2_wb;   // way2 64b data.


    wire [7:0]  gen_dcache_parity_w3_m;
    wire [7:0]   rd_parity_err_w3_m;
    wire  [7:0]     dcache_rparity_w3_m;  // way3 8b parity.
    wire  [63:0]    dcache_rdata_w3_m;    // way3 64b data.
    reg [63:0]    dcache_rdata_w3_wb;   // way3 64b data.



//=========================================================================================
//  Staging
//=========================================================================================

// BIST Rd used fill address port.
assign  dcache_rwaddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

assign  dcache_raddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

always @(posedge clk)
  begin
    dcache_alt_mx_sel_m   <= sehold ? dcache_alt_mx_sel_m : dcache_alt_mx_sel_e;

    dcache_alt_rsel_way_m <= sehold ? dcache_alt_rsel_way_m : dcache_alt_rsel_way_e;

    dcache_rwaddr_m[(6 + 4):3] <= sehold ? dcache_rwaddr_m[(6 + 4):3] : dcache_rwaddr_e[(6 + 4):3] ;

    dcache_raddr_m[(6 + 4):3] <= sehold ? dcache_raddr_m[(6 + 4):3] : dcache_raddr_e[(6 + 4):3] ;

    dcache_rvld_m         <= sehold ? dcache_rvld_m  : dcache_rvld_e ;

    wvld_m                <= sehold ?  wvld_m : dcache_wvld_e ;

    dcache_wdata_m[144-1:0] <= sehold ?  dcache_wdata_m[144-1:0] : dcache_wdata_e[144-1:0] ;

    dcache_wr_rway_m[4-1:0] <= sehold ?  dcache_wr_rway_m[4-1:0] : dcache_wr_rway_e[4-1:0] ;

    byte_wr_enable[15:0]  <= sehold ? byte_wr_enable[15:0] : dcache_byte_wr_en_e[15:0] ;

  end

always @ (posedge clk)
  begin
// JC modified begin
//    dcache_alt_mx_sel_wb <= dcache_alt_mx_sel_m;
//    dcache_alt_rsel_way_wb  <= dcache_alt_rsel_way_m;
    dcache_alt_mx_sel_wb <= sehold ? dcache_alt_mx_sel_wb :dcache_alt_mx_sel_m;
    dcache_alt_rsel_way_wb  <= sehold ? dcache_alt_rsel_way_wb :dcache_alt_rsel_way_m;
// JC modified end
  end

assign  dcache_wvld_m = wvld_m & ~rst_tri_en ;




















 // `ifndef SRAM_LSU_DCACHE

//removed stablizer, zero out without read (for IBM sram too)
// assign  temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w0a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w1a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w2a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w3a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;


  assign  temp_w0a[144-1:0] = dcache_rvld_m? temp_w0a_reg[144-1:0]: 144'b0;


  assign  temp_w1a[144-1:0] = dcache_rvld_m? temp_w1a_reg[144-1:0]: 144'b0;


  assign  temp_w2a[144-1:0] = dcache_rvld_m? temp_w2a_reg[144-1:0]: 144'b0;


  assign  temp_w3a[144-1:0] = dcache_rvld_m? temp_w3a_reg[144-1:0]: 144'b0;



 // `ifndef SRAM_LSU_DCACHE

// Prior to SA, column mux (64(D)+8(P))x4 bits. Assume parity is
// at the end of the 144b line. Entry is wX||Parity

// // Select either upper or lower 64b from each of the 4 ways.
// assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w0a[79:16] ;
// assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w1a[79:16] ;
// assign  dcache_rdata_w2_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w2a[79:16] ;
// assign  dcache_rdata_w3_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w3a[79:16] ;


  assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[144-1:80] : temp_w0a[79:16] ;


  assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[144-1:80] : temp_w1a[79:16] ;


  assign  dcache_rdata_w2_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w2a[144-1:80] : temp_w2a[79:16] ;


  assign  dcache_rdata_w3_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w3a[144-1:80] : temp_w3a[79:16] ;



   wire [7:0] dcache_msb_w0_m;
   wire [7:0] dcache_alt_data_w0_msb_m;

//MSB sent out to dcdp in M stage
assign dcache_msb_w0_m[7:0]=
    {dcache_rdata_w0_m[63],
     dcache_rdata_w0_m[55],
     dcache_rdata_w0_m[47],
     dcache_rdata_w0_m[39],
     dcache_rdata_w0_m[31],
     dcache_rdata_w0_m[23],
     dcache_rdata_w0_m[15],
     dcache_rdata_w0_m[07]} ;

assign dcache_alt_data_w0_msb_m [7:0]=
    {dcache_alt_data_w0_m[63],
     dcache_alt_data_w0_m[55],
     dcache_alt_data_w0_m[47],
     dcache_alt_data_w0_m[39],
     dcache_alt_data_w0_m[31],
     dcache_alt_data_w0_m[23],
     dcache_alt_data_w0_m[15],
     dcache_alt_data_w0_m[07]} ;

//2-to-1 mux
assign dcache_rdata_msb_w0_m[7:0] = dcache_arry_data_sel_m ?
                                    dcache_msb_w0_m[7:0] :
                                    dcache_alt_data_w0_msb_m[7:0];

// assign dcache_rdata_msb_w1_m[7:0]=
//     {dcache_rdata_w1_m[63],
//      dcache_rdata_w1_m[55],
//      dcache_rdata_w1_m[47],
//      dcache_rdata_w1_m[39],
//      dcache_rdata_w1_m[31],
//      dcache_rdata_w1_m[23],
//      dcache_rdata_w1_m[15],
//      dcache_rdata_w1_m[07]} ;

// assign dcache_rdata_msb_w2_m[7:0]=
//     {dcache_rdata_w2_m[63],
//      dcache_rdata_w2_m[55],
//      dcache_rdata_w2_m[47],
//      dcache_rdata_w2_m[39],
//      dcache_rdata_w2_m[31],
//      dcache_rdata_w2_m[23],
//      dcache_rdata_w2_m[15],
//      dcache_rdata_w2_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;


  assign dcache_rdata_msb_w1_m[7:0]=
    {dcache_rdata_w1_m[63],
     dcache_rdata_w1_m[55],
     dcache_rdata_w1_m[47],
     dcache_rdata_w1_m[39],
     dcache_rdata_w1_m[31],
     dcache_rdata_w1_m[23],
     dcache_rdata_w1_m[15],
     dcache_rdata_w1_m[07]} ;


  assign dcache_rdata_msb_w2_m[7:0]=
    {dcache_rdata_w2_m[63],
     dcache_rdata_w2_m[55],
     dcache_rdata_w2_m[47],
     dcache_rdata_w2_m[39],
     dcache_rdata_w2_m[31],
     dcache_rdata_w2_m[23],
     dcache_rdata_w2_m[15],
     dcache_rdata_w2_m[07]} ;


  assign dcache_rdata_msb_w3_m[7:0]=
    {dcache_rdata_w3_m[63],
     dcache_rdata_w3_m[55],
     dcache_rdata_w3_m[47],
     dcache_rdata_w3_m[39],
     dcache_rdata_w3_m[31],
     dcache_rdata_w3_m[23],
     dcache_rdata_w3_m[15],
     dcache_rdata_w3_m[07]} ;



assign dcache_rdata_msb_m[(8*(0+1))-1 -: 8] = dcache_rdata_msb_w0_m;
assign dcache_rdata_msb_m[(8*(1+1))-1 -: 8] = dcache_rdata_msb_w1_m;
assign dcache_rdata_msb_m[(8*(2+1))-1 -: 8] = dcache_rdata_msb_w2_m;
assign dcache_rdata_msb_m[(8*(3+1))-1 -: 8] = dcache_rdata_msb_w3_m;


   // wire [63:0] rdata_w0_m;
   // wire [63:0] rdata_w1_m;
   // wire [63:0] rdata_w2_m;
   // wire [63:0] rdata_w3_m;
wire [63:0] rdata_w0_m;
wire [63:0] rdata_w1_m;
wire [63:0] rdata_w2_m;
wire [63:0] rdata_w3_m;


//2-to-1 mux
//dcache_alt_mx_sel default 0001 (way 0) when not in MBIST mode (logic in qdp2)
assign rdata_w0_m[63:0] = dcache_arry_data_sel_m ?
                          dcache_rdata_w0_m[63:0] : dcache_alt_data_w0_m[63:0];

// //assign rdata_w0_m[63:0] = dcache_rdata_w0_m[63:0];
// assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];
// assign rdata_w2_m[63:0] = dcache_rdata_w2_m[63:0];
// assign rdata_w3_m[63:0] = dcache_rdata_w3_m[63:0];
   

  assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];


  assign rdata_w2_m[63:0] = dcache_rdata_w2_m[63:0];


  assign rdata_w3_m[63:0] = dcache_rdata_w3_m[63:0];



// // Select upper half or lower half of parity.
// assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
// assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
// assign  dcache_rparity_w2_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w2a[15:8] : temp_w2a[7:0] ;
// assign  dcache_rparity_w3_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w3a[15:8] : temp_w3a[7:0] ;

//    reg [7:0] dcache_rparity_w0_wb;
//    reg [7:0] dcache_rparity_w1_wb;
//    reg [7:0] dcache_rparity_w2_wb;
//    reg [7:0] dcache_rparity_w3_wb;

//    reg [7:0] rd_parity_err_w0_wb;
//    reg [7:0] rd_parity_err_w1_wb;
//    reg [7:0] rd_parity_err_w2_wb;
//    reg [7:0] rd_parity_err_w3_wb;


  assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
  reg [7:0] dcache_rparity_w0_wb;
  reg [7:0] rd_parity_err_w0_wb;


  assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
  reg [7:0] dcache_rparity_w1_wb;
  reg [7:0] rd_parity_err_w1_wb;


  assign  dcache_rparity_w2_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w2a[15:8] : temp_w2a[7:0] ;
  reg [7:0] dcache_rparity_w2_wb;
  reg [7:0] rd_parity_err_w2_wb;


  assign  dcache_rparity_w3_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w3a[15:8] : temp_w3a[7:0] ;
  reg [7:0] dcache_rparity_w3_wb;
  reg [7:0] rd_parity_err_w3_wb;




// Stage to WB
always  @(posedge clk)
  begin
    // dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
    // dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
    // dcache_rdata_w2_wb[63:0] <= rdata_w2_m[63:0] ;
    // dcache_rdata_w3_wb[63:0] <= rdata_w3_m[63:0] ;

    // dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
    // dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
    // dcache_rparity_w2_wb[7:0] <=  dcache_rparity_w2_m[7:0];
    // dcache_rparity_w3_wb[7:0] <=  dcache_rparity_w3_m[7:0];

    // rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];
    // rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];
    // rd_parity_err_w2_wb [7:0] <= rd_parity_err_w2_m[7:0];
    // rd_parity_err_w3_wb [7:0] <= rd_parity_err_w3_m[7:0];


  dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
  dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
  rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];


  dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
  dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
  rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];


  dcache_rdata_w2_wb[63:0] <= rdata_w2_m[63:0] ;
  dcache_rparity_w2_wb[7:0] <=  dcache_rparity_w2_m[7:0];
  rd_parity_err_w2_wb [7:0] <= rd_parity_err_w2_m[7:0];


  dcache_rdata_w3_wb[63:0] <= rdata_w3_m[63:0] ;
  dcache_rparity_w3_wb[7:0] <=  dcache_rparity_w3_m[7:0];
  rd_parity_err_w3_wb [7:0] <= rd_parity_err_w3_m[7:0];



  end

//parity calculation and check are done in M stage for 4 way data
   // wire rd_parity_err_w0;
   // wire rd_parity_err_w1;
   // wire rd_parity_err_w2;
   // wire rd_parity_err_w3;

// lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
//                 .data_in        (dcache_rdata_w0_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w0_m[7:0])
//         );

// assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0]) :
//                                                   8'hff;


// lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
//                 .data_in        (dcache_rdata_w1_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w1_m[7:0])
//         );

// assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0]) :
//                                                  8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w2 (
//                 .data_in        (dcache_rdata_w2_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w2_m[7:0])
//         );
// assign rd_parity_err_w2_m[7:0] = dcache_rvld_m ? (dcache_rparity_w2_m[7:0] ^ gen_dcache_parity_w2_m[7:0])  :
//                                                    8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w3 (
//                 .data_in        (dcache_rdata_w3_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w3_m[7:0])
//         );
// assign rd_parity_err_w3_m[7:0] =  dcache_rvld_m ? (dcache_rparity_w3_m[7:0] ^ gen_dcache_parity_w3_m[7:0]) :
//                                                   8'hff;


  wire rd_parity_err_w0;
  lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
                  .data_in        (dcache_rdata_w0_m[63:0]),
                  .parity_out     (gen_dcache_parity_w0_m[7:0])
          );
  assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0])  :
                                                     8'hff;


  wire rd_parity_err_w1;
  lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
                  .data_in        (dcache_rdata_w1_m[63:0]),
                  .parity_out     (gen_dcache_parity_w1_m[7:0])
          );
  assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0])  :
                                                     8'hff;


  wire rd_parity_err_w2;
  lsu_dc_parity_gen #(8,8)  parity_gen_w2 (
                  .data_in        (dcache_rdata_w2_m[63:0]),
                  .parity_out     (gen_dcache_parity_w2_m[7:0])
          );
  assign rd_parity_err_w2_m[7:0] = dcache_rvld_m ? (dcache_rparity_w2_m[7:0] ^ gen_dcache_parity_w2_m[7:0])  :
                                                     8'hff;


  wire rd_parity_err_w3;
  lsu_dc_parity_gen #(8,8)  parity_gen_w3 (
                  .data_in        (dcache_rdata_w3_m[63:0]),
                  .parity_out     (gen_dcache_parity_w3_m[7:0])
          );
  assign rd_parity_err_w3_m[7:0] = dcache_rvld_m ? (dcache_rparity_w3_m[7:0] ^ gen_dcache_parity_w3_m[7:0])  :
                                                     8'hff;



// way select mux on READ
// Select one of four ways from indexed cache set.

wire [4-1:0] dcache_rd_sel_way_wb;
assign dcache_rd_sel_way_wb[4-1:0] = dcache_alt_mx_sel_wb ? dcache_alt_rsel_way_wb[4-1:0] :
                                                          dcache_rsel_way_wb[4-1:0];

// assign  dcache_rdata_wb[63:0]  =
//  (dcache_rd_sel_way_wb[0] ? dcache_rdata_w0_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[1] ? dcache_rdata_w1_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[2] ? dcache_rdata_w2_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[3] ? dcache_rdata_w3_wb[63:0] : 64'b0);


always @ *
begin
dcache_rdata_wb[63:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w0_wb[63:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w1_wb[63:0];
if (dcache_rd_sel_way_wb[2])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w2_wb[63:0];
if (dcache_rd_sel_way_wb[3])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w3_wb[63:0];
end


//parity err in W-stage, cache_way_hit may not be one-hot
// assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);
// assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);
// assign rd_parity_err_w2 =   |(rd_parity_err_w2_wb[7:0]);
// assign rd_parity_err_w3 =   |(rd_parity_err_w3_wb[7:0]);


  assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);


  assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);


  assign rd_parity_err_w2 =   |(rd_parity_err_w2_wb[7:0]);


  assign rd_parity_err_w3 =   |(rd_parity_err_w3_wb[7:0]);



// assign dcache_rparity_err_wb = rd_parity_err_w3 & dcache_rd_sel_way_wb[3] |
//                                rd_parity_err_w2 & dcache_rd_sel_way_wb[2] |
//                                rd_parity_err_w1 & dcache_rd_sel_way_wb[1] |
//                                rd_parity_err_w0 & dcache_rd_sel_way_wb[0] ;

always @ *
begin
dcache_rparity_err_wb = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w0;
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w1;
if (dcache_rd_sel_way_wb[2])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w2;
if (dcache_rd_sel_way_wb[3])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w3;
end


//mux4ds #(64) dcache_rdata_wb_mx (
//  .in0  (dcache_rdata_w0_wb[63:0]),
//  .in1  (dcache_rdata_w1_wb[63:0]),
//  .in2  (dcache_rdata_w2_wb[63:0]),
//  .in3  (dcache_rdata_w3_wb[63:0]),
//  .sel0 (dcache_rd_sel_way_wb[0]),
//  .sel1 (dcache_rd_sel_way_wb[1]),
//  .sel2 (dcache_rd_sel_way_wb[2]),
//  .sel3 (dcache_rd_sel_way_wb[3]),
//  .dout (dcache_rdata_wb[63:0])
//);

// dcache_rparity_wb only used by MBIST
//mux4ds #(8) dcache_rparity_wb_mx (
//  .in0 (dcache_rparity_w0_wb[7:0]),
//  .in1 (dcache_rparity_w1_wb[7:0]),
//  .in2 (dcache_rparity_w2_wb[7:0]),
//  .in3 (dcache_rparity_w3_wb[7:0]),
//  .sel0(dcache_alt_rsel_way_wb[0]),
//  .sel1(dcache_alt_rsel_way_wb[1]),
//  .sel2(dcache_alt_rsel_way_wb[2]),
//  .sel3(dcache_alt_rsel_way_wb[3]),
//  .dout(dcache_rparity_wb[7:0])
//);

// assign  dcache_rparity_wb[7:0] =
// ( dcache_rd_sel_way_wb[0] ? dcache_rparity_w0_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[1] ? dcache_rparity_w1_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[2] ? dcache_rparity_w2_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[3] ? dcache_rparity_w3_wb[7:0] : 8'b0 ) ;
always @ *
begin
dcache_rparity_wb[7:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w0_wb[7:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w1_wb[7:0];
if (dcache_rd_sel_way_wb[2])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w2_wb[7:0];
if (dcache_rd_sel_way_wb[3])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w3_wb[7:0];
end













































 // `ifndef SRAM_LSU_DCACHE // FPGA

endmodule









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dct.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_dct.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */

// devices.xml



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications






































































































































































module bw_r_dct(
  // rdtag_w0_y, rdtag_w1_y, rdtag_w2_y, 
  rdtag_y, 
  // rdtag_w3_y, 
  so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, 

  wrtag_x, wrtag_y,
  // wrtag_w0_y, wrtag_w1_y, wrtag_w2_y,
  // wrtag_w3_y, wrtag_w0_x, wrtag_w1_x, wrtag_w2_x,
  // wrtag_w3_x, 
  adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [4-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;

  input [33-1:0]    wrtag_y;
  input [33-1:0]    wrtag_x;
  input [4-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [(33*4)-1:0]    rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [4-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [131:0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({4 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // wire [131:0] write_bus_x = {wrtag_x,wrtag_x,wrtag_x,wrtag_x};
  // wire [131:0] write_bus_mask_x = {{33{we[3]}}, {33{we[2]}}, {33{we[1]}}, {33{we[0]}}};

  wire [33*4-1:0] write_bus_x = {4{wrtag_x}};
  wire [33*4-1:0] write_bus_mask_x;
  
  assign write_bus_mask_x[33*(0+1)-1 -: 33] = {33{we[0]}};


  assign write_bus_mask_x[33*(1+1)-1 -: 33] = {33{we[1]}};


  assign write_bus_mask_x[33*(2+1)-1 -: 33] = {33{we[2]}};


  assign write_bus_mask_x[33*(3+1)-1 -: 33] = {33{we[3]}};




  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

  wire  [(33*4)-1:0]    rdtag_y;

sram_l1d_tag cache
(
  .MEMCLK(rclk),
    .RESET_N(reset_l),
  .CE(wrreq_x | rdreq_x),
  .A(index_x),
  .DIN(write_bus_x),
  .BW(write_bus_mask_x),
  .RDWEN(~wrreq_x),
  .DOUT(rdtag_y),

  // .BIST_COMMAND(rtap_srams_bist_command),
  // .BIST_DIN(rtap_srams_bist_data),
  // .BIST_DOUT(sram_dcache_w01_rtap_data),
  // .SRAMID(`BIST_ID_L1_DCACHE_W01)
  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(sramid)
);

  // assign rdtag_y = {rdtag_w3_y, rdtag_w2_y, rdtag_w1_y, rdtag_w0_y};




endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_dtlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/

// devices.xml


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used




















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































module bw_r_dtlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   // cache_ptag_w0, cache_ptag_w1, 
   // cache_ptag_w2, cache_ptag_w3, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input    [(33*4)+1-1:0]      cache_ptag;          // way3 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w0;       	// way1 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w1;       	// way2 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w2;       	// way0 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w3;       	// way3 30b(D)/29b(I) tag.
input	[4-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;

// input    [29:0]      cache_ptag_w0;          // way1 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w1;          // way2 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w2;          // way0 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w3;          // way3 30b(D)/29b(I) tag.

wire cache_ptag_va_10 = cache_ptag[(33*4)];


wire [33-1:0] cache_ptag_w0_tmp = cache_ptag[33*(0+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w0 = {cache_ptag_w0_tmp[(29+1)-2:0],cache_ptag_va_10};


wire [33-1:0] cache_ptag_w1_tmp = cache_ptag[33*(1+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w1 = {cache_ptag_w1_tmp[(29+1)-2:0],cache_ptag_va_10};


wire [33-1:0] cache_ptag_w2_tmp = cache_ptag[33*(2+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w2 = {cache_ptag_w2_tmp[(29+1)-2:0],cache_ptag_va_10};


wire [33-1:0] cache_ptag_w3_tmp = cache_ptag[33*(3+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w3 = {cache_ptag_w3_tmp[(29+1)-2:0],cache_ptag_va_10};




input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[4-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[4-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [4-1:0]		cache_set_vld_g;
// reg	[29:0]		cache_ptag_w0_g,cache_ptag_w1_g;
// reg	[29:0]		cache_ptag_w2_g,cache_ptag_w3_g;
reg [29:0]      cache_ptag_w0_g;
reg [29:0]      cache_ptag_w1_g;
reg [29:0]      cache_ptag_w2_g;
reg [29:0]      cache_ptag_w3_g;

reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.


 

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[4-1:0]  	<= cache_set_vld[4-1:0] ;
			// cache_ptag_w0_g[29:0] 	<= cache_ptag_w0[29:0] ;
			// cache_ptag_w1_g[29:0] 	<= cache_ptag_w1[29:0] ;
			// cache_ptag_w2_g[29:0] 	<= cache_ptag_w2[29:0] ;
			// cache_ptag_w3_g[29:0] 	<= cache_ptag_w3[29:0] ;
         
 cache_ptag_w0_g[(29+1)-1:0]   <= cache_ptag_w0[(29+1)-1:0];


 cache_ptag_w1_g[(29+1)-1:0]   <= cache_ptag_w1[(29+1)-1:0];


 cache_ptag_w2_g[(29+1)-1:0]   <= cache_ptag_w2[(29+1)-1:0];


 cache_ptag_w3_g[(29+1)-1:0]   <= cache_ptag_w3[(29+1)-1:0];

 
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


// assign	cache_way_hit[0] = 
// 	(cache_ptag_w0_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[0];
// assign	cache_way_hit[1] = 
// 	(cache_ptag_w1_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[1];
// assign	cache_way_hit[2] = 
// 	(cache_ptag_w2_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[2];
// assign	cache_way_hit[3] = 
// 	(cache_ptag_w3_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[3];


    assign  cache_way_hit[0] = 
       (cache_ptag_w0_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[0];


    assign  cache_way_hit[1] = 
       (cache_ptag_w1_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[1];


    assign  cache_way_hit[2] = 
       (cache_ptag_w2_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[2];


    assign  cache_way_hit[3] = 
       (cache_ptag_w3_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[3];



assign	cache_hit = |cache_way_hit[4-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)
	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end



//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_ict.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_ict.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


// devices.xml












//PITON_PROTO enables all FPGA related modifications














































































































































module bw_r_ict(rdtag_y, so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, wrtag_y,
  wrtag_x, adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [2-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_y;
  input [2-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [((((39 - (6 + 5))+1) * 2)-1):0] rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [2-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [((((39 - (6 + 5))+1) * 2)-1):0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({2 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // assign write_bus_x[`IC_PHYS_TAG_WAY0_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY1_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY2_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY3_MASK] = wrtag_x;

  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

// real SRAM instance
wire [33*2-1 : 0] write_bus_mask_x = {
{33{we[1]}},
{33{we[0]}}

};

  wire [32:0] wrtag_x_phys = wrtag_x;
  wire [33*2-1 : 0] write_bus_x_phys = {2{wrtag_x_phys}};
  // wire [`IC_PHYS_TAG_MASK_ALL] write_bus_x_phys = {wrtag_x_phys, wrtag_x_phys, wrtag_x_phys, wrtag_x_phys};
  wire [33*2-1 : 0] rdtag_y_phys;

  // assign rdtag_y[`IC_TLB_TAG_WAY0_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY0_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY1_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY1_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY2_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY2_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY3_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY3_MASK];

  // truncate tags from 33 bits to appropriate size
  
  wire [32:0] rdtag_y_phys_WAY0 = rdtag_y_phys[33*1-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*1-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY0[(((39 - (6 + 5))+1)-1):0];
  

  wire [32:0] rdtag_y_phys_WAY1 = rdtag_y_phys[33*2-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*2-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY1[(((39 - (6 + 5))+1)-1):0];
  


  sram_l1i_tag cache
  (
    .MEMCLK(rclk),
      .RESET_N(reset_l),
    .CE(wrreq_x | rdreq_x),
    .A(index_x),
    .DIN(write_bus_x_phys),
    .BW(write_bus_mask_x),
    .RDWEN(~wrreq_x),
    .DOUT(rdtag_y_phys),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(sramid)
  );

endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_itlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// devices.xml


///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================








































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used
































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // is default implementation in openpiton







module bw_r_itlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input  	[((((39 - (6 + 5))+1) * 2)-1):0]    	cache_ptag;       	// way1 30b(D)/29b(I) tag.
input	[2-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;



input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[2-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[2-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [2-1:0]		cache_set_vld_g;
reg	[((((39 - (6 + 5))+1) * 2)-1):0]		cache_ptag_g;
reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.

 



always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[2-1:0]  	<= cache_set_vld[2-1:0] ;
			cache_ptag_g[((((39 - (6 + 5))+1) * 2)-1):0] 	<= cache_ptag[((((39 - (6 + 5))+1) * 2)-1):0] ;
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


   assign   cache_way_hit[0] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*1-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[0];


   assign   cache_way_hit[1] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*2-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[1];



assign	cache_hit = |cache_way_hit[2-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)

	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end

//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_dc_parity_gen.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
//
//  Module Name: lsu_dc_parity_gen.v
//  Description: Parity Generator based on odd parity

module lsu_dc_parity_gen (parity_out, data_in);

// Changed the default to match that of dcache width
parameter WIDTH = 8 ;
parameter NUM = 16 ;

input	[WIDTH * NUM - 1 : 0]	data_in ; // data in

output	[NUM - 1 : 0]		parity_out ; // parity output
reg	[NUM - 1 : 0]		parity ; // parity output

integer i ;
integer j ;

always @(data_in)
    for (i = 0; i <= NUM - 1 ; i = i + 1) begin
	    parity[i] = 1'b0 ;
        for (j = WIDTH * i; j <= WIDTH * (i + 1) - 1 ; j = j + 1) begin
            parity[i] = parity[i] ^ data_in[j] ;
        end
    end

assign parity_out[NUM - 1 : 0] = parity[NUM - 1 : 0];

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Wraps the LSU to tie unused signals

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting












// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































module lsu_nospu_wrap
(
    input                   arst_l,
    input [(6 + 4):0]            bist_ctl_reg_out,
    input                   clk,
    input [2:0]             const_cpuid,
    input [63:0]            exu_lsu_rs2_data_e,
    input [63:0]            exu_lsu_rs3_data_e,
    input                   exu_tlu_misalign_addr_jmpl_rtn_m,
    input                   exu_tlu_va_oor_m,
    input                   ffu_lsu_blk_st_e,
    input [5:3]             ffu_lsu_blk_st_va_e,
    input                   ffu_lsu_fpop_rq_vld,
    input                   ffu_lsu_kill_fst_w,
    input                   gdbginit_l,
    input                   grst_l,
    input                   ifu_lsu_alt_space_d,
    input                   ifu_lsu_alt_space_e,
    input                   ifu_lsu_asi_ack,
    input                   ifu_lsu_asi_rd_unc,
    input                   ifu_lsu_casa_e,
    input [2:0]             ifu_lsu_destid_s,
    input                   ifu_lsu_fwd_data_vld,
    input                   ifu_lsu_fwd_wr_ack,
    input                   ifu_lsu_ibuf_busy,
    input [7:0]             ifu_lsu_imm_asi_d,
    input                   ifu_lsu_imm_asi_vld_d,
    input                   ifu_lsu_inv_clear,
    input                   ifu_lsu_ld_inst_e,
    input                   ifu_lsu_ldst_dbl_e,
    input                   ifu_lsu_ldst_fp_e,
    input [1:0]             ifu_lsu_ldst_size_e,
    input                   ifu_lsu_ldstub_e,
    input                   ifu_lsu_ldxa_data_vld_w2,
    input [63:0]            ifu_lsu_ldxa_data_w2,
    input                   ifu_lsu_ldxa_illgl_va_w2,
    input [1:0]             ifu_lsu_ldxa_tid_w2,
    input                   ifu_lsu_memref_d,
    input [3:0]             ifu_lsu_nceen,
    input [51:0]            ifu_lsu_pcxpkt_e,
    input                   ifu_lsu_pcxreq_d,
    input                   ifu_lsu_pref_inst_e,
    input [4:0]             ifu_lsu_rd_e,
    input                   ifu_lsu_sign_ext_e,
    input                   ifu_lsu_st_inst_e,
    input                   ifu_lsu_swap_e,
    input [1:0]             ifu_lsu_thrid_s,
    input                   ifu_tlu_flsh_inst_e,
    input                   ifu_tlu_flush_m,
    input                   ifu_tlu_inst_vld_m,
    input                   ifu_tlu_mb_inst_e,
    input [6:0]             ifu_tlu_sraddr_d,
    input [1:0]             ifu_tlu_thrid_e,
    input                   ifu_tlu_wsr_inst_d,
    input                   pcx_spc_grant_px0,
    input [3:0]             tlu_dsfsr_flt_vld,
    input                   tlu_dtlb_data_rd_g,
    input                   tlu_dtlb_dmp_actxt_g,
    input                   tlu_dtlb_dmp_all_g,
    input                   tlu_dtlb_dmp_nctxt_g,
    input                   tlu_dtlb_dmp_pctxt_g,
    input                   tlu_dtlb_dmp_sctxt_g,
    input                   tlu_dtlb_dmp_vld_g,
    input                   tlu_dtlb_invalidate_all_g,
    input [5:0]             tlu_dtlb_rw_index_g,
    input                   tlu_dtlb_rw_index_vld_g,
    input                   tlu_dtlb_tag_rd_g,
    input [42:0]            tlu_dtlb_tte_data_w2,
    input [58:0]            tlu_dtlb_tte_tag_w2,
    input                   tlu_early_flush_pipe2_w,
    input                   tlu_early_flush_pipe_w,
    input                   tlu_exu_early_flush_pipe_w,
    input [40:0]            tlu_idtlb_dmp_key_g,
    input [1:0]             tlu_idtlb_dmp_thrid_g,
    input [7:0]             tlu_lsu_asi_m,
    input                   tlu_lsu_asi_update_m,
    input [3:0]             tlu_lsu_hpstate_en,
    input [3:0]             tlu_lsu_hpv_priv,
    input                   tlu_lsu_int_ld_ill_va_w2,
    input [63:0]            tlu_lsu_int_ldxa_data_w2,
    input                   tlu_lsu_int_ldxa_vld_w2,
    input                   tlu_lsu_ldxa_async_data_vld,
    input [1:0]             tlu_lsu_ldxa_tid_w2,
    input [25:0]            tlu_lsu_pcxpkt,
    input                   tlu_lsu_priv_trap_m,
    input [3:0]             tlu_lsu_pstate_am,
    input [3:0]             tlu_lsu_pstate_cle,
    input [3:0]             tlu_lsu_pstate_priv,
    input [1:0]             tlu_lsu_redmode,
    input [3:0]             tlu_lsu_redmode_rst_d1,
    input                   tlu_lsu_stxa_ack,
    input [1:0]             tlu_lsu_stxa_ack_tid,
    input [1:0]             tlu_lsu_tid_m,
    input [3:0]             tlu_lsu_tl_zero,
    
    input                   tlu_dtlb_csm_rd_g,
    input [31:0]  tlu_dtlb_tte_csm_w2,
    input [32:0]        ifu_lsu_pcxcsm_e,
    input                   tlu_dtlb_wr_csm_sel_g,
    
    input [2-1:0]   cfg_lsu_csm_dtlb_state,
    input [14-1:0]      cfg_lsu_csm_dtlb_chipid,
    input [8-1:0]           cfg_lsu_csm_dtlb_x,
    input [8-1:0]           cfg_lsu_csm_dtlb_y,
    input [10-1:0]        cfg_lsu_csm_dtlb_hdid,
    input [6-1:0]        cfg_lsu_csm_dtlb_hd_size,
    input [10-1:0]        cfg_lsu_csm_dtlb_sdid,
    input [6-1:0]        cfg_lsu_csm_dtlb_lsid,
    
    input                   cfg_asi_lsu_ldxa_vld_w2,
    input [1:0]             cfg_asi_lsu_ldxa_tid_w2,
    input [63:0]            cfg_asi_lsu_ldxa_data_w2,
   
    // jtag debug
    // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [13:0] rtap_core_data_13_0, 
    // sram wrapper interface
    output [4-1:0] srams_rtap_data,
    input  [4-1:0] rtap_srams_bist_command,
    input  [4-1:0] rtap_srams_bist_data,
    
    output                  ifu_tlu_flush_fd2_w,
    output                  ifu_tlu_flush_fd3_w,
    output                  ifu_tlu_flush_fd_w,
    output [7:0]            lsu_asi_reg0,
    output [7:0]            lsu_asi_reg1,
    output [7:0]            lsu_asi_reg2,
    output [7:0]            lsu_asi_reg3,
    output [3:0]            lsu_dmmu_sfsr_trp_wr,
    output [23:0]           lsu_dsfsr_din_g,
    output [63:0]           lsu_exu_dfill_data_w2,
    output                  lsu_exu_dfill_vld_w2,
    output                  lsu_exu_flush_pipe_w,
    output                  lsu_exu_ldst_miss_w2,
    output [4:0]            lsu_exu_rd_m,
    output                  lsu_exu_st_dtlb_perr_g,
    output [1:0]            lsu_exu_thr_m,
    output                  lsu_ffu_ack,
    output                  lsu_ffu_blk_asi_e,
    output                  lsu_ffu_flush_pipe_w,
    output [63:0]           lsu_ffu_ld_data,
    output                  lsu_ffu_ld_vld,
    output                  lsu_ffu_st_dtlb_perr_g,
    output                  lsu_ffu_stb_full0,
    output                  lsu_ffu_stb_full1,
    output                  lsu_ffu_stb_full2,
    output                  lsu_ffu_stb_full3,
    output [3:0]            lsu_ictag_mrgn,
    output [17:0]           lsu_ifu_asi_addr,
    output                  lsu_ifu_asi_load,
    output [7:0]            lsu_ifu_asi_state,
    output [1:0]            lsu_ifu_asi_thrid,
    output                  lsu_ifu_asi_vld,
    output [144-1:0]   lsu_ifu_cpxpkt_i1,
    output                  lsu_ifu_cpxpkt_vld_i1,
    output                  lsu_ifu_dc_parity_error_w2,
    output                  lsu_ifu_dcache_data_perror,
    output                  lsu_ifu_dcache_tag_perror,
    output                  lsu_ifu_direct_map_l1,
    output [1:0]            lsu_ifu_error_tid,
    output                  lsu_ifu_flush_pipe_w,
    output [3:0]            lsu_ifu_icache_en,
    output                  lsu_ifu_io_error,
    output [3:0]            lsu_ifu_itlb_en,
    output                  lsu_ifu_l2_corr_error,
    output                  lsu_ifu_l2_unc_error,
    output [(6 + 5):5]           lsu_ifu_ld_icache_index,
    output [1:0]            lsu_ifu_ld_pcxpkt_tid,
    output                  lsu_ifu_ld_pcxpkt_vld,
    output [3:0]            lsu_ifu_ldst_cmplt,
    output                  lsu_ifu_ldst_miss_w,
    output                  lsu_ifu_ldsta_internal_e,
    output                  lsu_ifu_pcxpkt_ack_d,
    output                  lsu_ifu_stallreq,
    output [3:0]            lsu_ifu_stbcnt0,
    output [3:0]            lsu_ifu_stbcnt1,
    output [3:0]            lsu_ifu_stbcnt2,
    output [3:0]            lsu_ifu_stbcnt3,
    output [47:0]           lsu_ifu_stxa_data,
    output                  lsu_ifu_tlb_data_su,
    output                  lsu_ifu_tlb_data_ue,
    output                  lsu_ifu_tlb_tag_ue,
    output [7:0]            lsu_itlb_mrgn,
    output                  lsu_mmu_defr_trp_taken_g,
    output                  lsu_mmu_flush_pipe_w,
    output [63:0]           lsu_mmu_rs3_data_g,
    output [2:0]            lsu_pid_state0,
    output [2:0]            lsu_pid_state1,
    output [2:0]            lsu_pid_state2,
    output [2:0]            lsu_pid_state3,
    output [7:0]            lsu_spu_asi_state_e,
    output [12:0]           lsu_t0_pctxt_state,
    output [12:0]           lsu_t1_pctxt_state,
    output [12:0]           lsu_t2_pctxt_state,
    output [12:0]           lsu_t3_pctxt_state,
    output [1:0]            lsu_tlu_async_tid_w2,
    output                  lsu_tlu_async_ttype_vld_w2,
    output [6:0]            lsu_tlu_async_ttype_w2,
    output [3:0]            lsu_tlu_cpx_req,
    output                  lsu_tlu_cpx_vld,
    output                  lsu_tlu_daccess_excptn_g,
    output [3:0]            lsu_tlu_dcache_miss_w2,
    output                  lsu_tlu_defr_trp_taken_g,
    output                  lsu_tlu_dmmu_miss_g,
    output [12:0]           lsu_tlu_dside_ctxt_m,
    output                  lsu_tlu_dtlb_done,
    output                  lsu_tlu_early_flush2_w,
    output                  lsu_tlu_early_flush_w,
    output [17:0]           lsu_tlu_intpkt,
    output [3:0]            lsu_tlu_l2_dmiss,
    output [9:0]            lsu_tlu_ldst_va_m,
    output                  lsu_tlu_misalign_addr_ldst_atm_m,
    output [12:0]           lsu_tlu_pctxt_m,
    output                  lsu_tlu_pcxpkt_ack,
    output [63:0]           lsu_tlu_rs3_data_g,
    output [7:0]            lsu_tlu_rsr_data_e,
    output [3:0]            lsu_tlu_stb_full_w2,
    output [1:0]            lsu_tlu_thrid_d,
    output [1:0]            lsu_tlu_tlb_access_tid_m,
    output [7:0]            lsu_tlu_tlb_asi_state_m,
    output [47:13]          lsu_tlu_tlb_dmp_va_m,
    output                  lsu_tlu_tlb_ld_inst_m,
    output [(6 + 4):0]           lsu_tlu_tlb_ldst_va_m,
    output                  lsu_tlu_tlb_st_inst_m,
    output [8:0]            lsu_tlu_ttype_m2,
    output                  lsu_tlu_ttype_vld_m2,
    output                  lsu_tlu_wsr_inst_e,
    output                  spc_pcx_atom_pq,
    output [124-1:0] spc_pcx_data_pa,
    output [4:0]            spc_pcx_req_pq,
    
    output [32:0]       spc_pcx_csm_pa,
    

    input [145-1:0]  cpx_spc_data_cx,
    input [47:0]            exu_lsu_ldst_va_e,
    input [(6 + 4):3]            exu_lsu_early_va_e,
    input   [80:0]          ffu_lsu_data ,


    output [7:0]            lsu_asi_state,
    output [47:4]           lsu_ifu_err_addr,
    output [15:0]           lsu_sscan_data ,
    // output                  ifu_tlu_inst_vld_m_bf1,
    output [2:0]            lsu_ffu_bld_cnt_w,

    input [7:0]             exu_tlu_wsr_data_m,
    output                  lsu_tlu_nucleus_ctxt_m ,
    output  [2:0]           lsu_tlu_tte_pg_sz_g ,
    output                  lsu_tlu_squash_va_oor_m,
    output                  lsu_tlu_wtchpt_trp_g,
    output                  lsu_tlu_daccess_prot_g,
    output                  lsu_tlu_priv_action_g
);
wire [94-1:0] core_rtap_data;
wire                  ifu_tlu_inst_vld_m_bf1; // trin: not needed

    lsu lsu(
       .ifu_tlu_wsr_inst_d          (ifu_tlu_wsr_inst_d),
       .lsu_ffu_st_dtlb_perr_g      (lsu_ffu_st_dtlb_perr_g),
       .tlu_lsu_priv_trap_m         (tlu_lsu_priv_trap_m),
       .short_si0                   (1'bx),
       .short_si1                   (1'bx),
       .short_so0                   (),
       .short_so1                   (),
       .si0                         (1'bx),
       .si1                         (1'bx),
       .so0                         (),
       .so1                         (),
       // reset stuff
       .grst_l                      (grst_l),
       .arst_l                      (arst_l),
       .clk                         (clk),
       .lsu_exu_dfill_data_w2       (lsu_exu_dfill_data_w2),
       .lsu_exu_dfill_vld_w2        (lsu_exu_dfill_vld_w2),
       .lsu_exu_ldst_miss_w2        (lsu_exu_ldst_miss_w2),
       .cpx_spc_data_cx             (cpx_spc_data_cx),
       .exu_tlu_wsr_data_m          (exu_tlu_wsr_data_m),
       .tlu_lsu_hpv_priv            (tlu_lsu_hpv_priv),
       .tlu_lsu_hpstate_en          (tlu_lsu_hpstate_en),

       .spu_lsu_int_w2              (1'b0),
       .gdbginit_l                  (gdbginit_l),
       
       .spc_pcx_csm_pa              (spc_pcx_csm_pa),
       
       .ifu_tlu_flush_fd2_w         (ifu_tlu_flush_fd2_w),
       .ifu_tlu_flush_fd3_w         (ifu_tlu_flush_fd3_w),
       .ifu_tlu_flush_fd_w          (ifu_tlu_flush_fd_w),
       .lsu_asi_reg0                (lsu_asi_reg0),
       .lsu_asi_reg1                (lsu_asi_reg1),
       .lsu_asi_reg2                (lsu_asi_reg2),
       .lsu_asi_reg3                (lsu_asi_reg3),
       .lsu_dmmu_sfsr_trp_wr        (lsu_dmmu_sfsr_trp_wr),
       .lsu_dsfsr_din_g             (lsu_dsfsr_din_g),
       .lsu_exu_flush_pipe_w        (lsu_exu_flush_pipe_w),
       .lsu_exu_rd_m                (lsu_exu_rd_m),
       .lsu_exu_st_dtlb_perr_g      (lsu_exu_st_dtlb_perr_g),
       .lsu_exu_thr_m               (lsu_exu_thr_m),
       .lsu_ffu_ack                 (lsu_ffu_ack),
       .lsu_ffu_blk_asi_e           (lsu_ffu_blk_asi_e),
       .lsu_ffu_flush_pipe_w        (lsu_ffu_flush_pipe_w),
       .lsu_ffu_ld_data             (lsu_ffu_ld_data),
       .lsu_ffu_ld_vld              (lsu_ffu_ld_vld),
       .lsu_ffu_stb_full0           (lsu_ffu_stb_full0),
       .lsu_ffu_stb_full1           (lsu_ffu_stb_full1),
       .lsu_ffu_stb_full2           (lsu_ffu_stb_full2),
       .lsu_ffu_stb_full3           (lsu_ffu_stb_full3),
       .lsu_ictag_mrgn              (lsu_ictag_mrgn),
       .lsu_ifu_asi_addr            (lsu_ifu_asi_addr),
       .lsu_ifu_asi_load            (lsu_ifu_asi_load),
       .lsu_ifu_asi_state           (lsu_ifu_asi_state),
       .lsu_ifu_asi_thrid           (lsu_ifu_asi_thrid),
       .lsu_ifu_asi_vld             (lsu_ifu_asi_vld),
       .lsu_ifu_cpxpkt_i1           (lsu_ifu_cpxpkt_i1),
       .lsu_ifu_cpxpkt_vld_i1       (lsu_ifu_cpxpkt_vld_i1),
       .lsu_ifu_dc_parity_error_w2  (lsu_ifu_dc_parity_error_w2),
       .lsu_ifu_dcache_data_perror  (lsu_ifu_dcache_data_perror),
       .lsu_ifu_dcache_tag_perror   (lsu_ifu_dcache_tag_perror),
       .lsu_ifu_direct_map_l1       (lsu_ifu_direct_map_l1),
       .lsu_ifu_error_tid           (lsu_ifu_error_tid),
       .lsu_ifu_flush_pipe_w        (lsu_ifu_flush_pipe_w),
       .lsu_ifu_icache_en           (lsu_ifu_icache_en),
       .lsu_ifu_io_error            (lsu_ifu_io_error),
       .lsu_ifu_itlb_en             (lsu_ifu_itlb_en),
       .lsu_ifu_l2_corr_error       (lsu_ifu_l2_corr_error),
       .lsu_ifu_l2_unc_error        (lsu_ifu_l2_unc_error),
       .lsu_ifu_ld_icache_index     (lsu_ifu_ld_icache_index),
       .lsu_ifu_ld_pcxpkt_tid       (lsu_ifu_ld_pcxpkt_tid),
       .lsu_ifu_ld_pcxpkt_vld       (lsu_ifu_ld_pcxpkt_vld),
       .lsu_ifu_ldst_cmplt          (lsu_ifu_ldst_cmplt),
       .lsu_ifu_ldst_miss_w         (lsu_ifu_ldst_miss_w),
       .lsu_ifu_ldsta_internal_e    (lsu_ifu_ldsta_internal_e),
       .lsu_ifu_pcxpkt_ack_d        (lsu_ifu_pcxpkt_ack_d),
       .lsu_ifu_stallreq            (lsu_ifu_stallreq),
       .lsu_ifu_stbcnt0             (lsu_ifu_stbcnt0),
       .lsu_ifu_stbcnt1             (lsu_ifu_stbcnt1),
       .lsu_ifu_stbcnt2             (lsu_ifu_stbcnt2),
       .lsu_ifu_stbcnt3             (lsu_ifu_stbcnt3),
       .lsu_ifu_stxa_data           (lsu_ifu_stxa_data),
       .lsu_ifu_tlb_data_su         (lsu_ifu_tlb_data_su),
       .lsu_ifu_tlb_data_ue         (lsu_ifu_tlb_data_ue),
       .lsu_ifu_tlb_tag_ue          (lsu_ifu_tlb_tag_ue),
       .lsu_itlb_mrgn               (lsu_itlb_mrgn),
       .lsu_mamem_mrgn              (),
       .lsu_mmu_defr_trp_taken_g    (lsu_mmu_defr_trp_taken_g),
       .lsu_mmu_flush_pipe_w        (lsu_mmu_flush_pipe_w),
       .lsu_mmu_rs3_data_g          (lsu_mmu_rs3_data_g),
       .lsu_pid_state0              (lsu_pid_state0),
       .lsu_pid_state1              (lsu_pid_state1),
       .lsu_pid_state2              (lsu_pid_state2),
       .lsu_pid_state3              (lsu_pid_state3),
       .lsu_spu_asi_state_e         (lsu_spu_asi_state_e),
       .lsu_spu_early_flush_g       (),
       .lsu_spu_ldst_ack            (),
       .lsu_spu_stb_empty           (),
       .lsu_spu_strm_ack_cmplt      (),
       .lsu_t0_pctxt_state          (lsu_t0_pctxt_state),
       .lsu_t1_pctxt_state          (lsu_t1_pctxt_state),
       .lsu_t2_pctxt_state          (lsu_t2_pctxt_state),
       .lsu_t3_pctxt_state          (lsu_t3_pctxt_state),
       .lsu_tlu_async_tid_w2        (lsu_tlu_async_tid_w2),
       .lsu_tlu_async_ttype_vld_w2  (lsu_tlu_async_ttype_vld_w2),
       .lsu_tlu_async_ttype_w2      (lsu_tlu_async_ttype_w2),
       .lsu_tlu_cpx_req             (lsu_tlu_cpx_req),
       .lsu_tlu_cpx_vld             (lsu_tlu_cpx_vld),
       .lsu_tlu_daccess_excptn_g    (lsu_tlu_daccess_excptn_g),
       .lsu_tlu_dcache_miss_w2      (lsu_tlu_dcache_miss_w2),
       .lsu_tlu_defr_trp_taken_g    (lsu_tlu_defr_trp_taken_g),
       .lsu_tlu_dmmu_miss_g         (lsu_tlu_dmmu_miss_g),
       .lsu_tlu_dside_ctxt_m        (lsu_tlu_dside_ctxt_m),
       .lsu_tlu_dtlb_done           (lsu_tlu_dtlb_done),
       .lsu_tlu_early_flush2_w      (lsu_tlu_early_flush2_w),
       .lsu_tlu_early_flush_w       (lsu_tlu_early_flush_w),
       .lsu_tlu_intpkt              (lsu_tlu_intpkt),
       .lsu_tlu_l2_dmiss            (lsu_tlu_l2_dmiss),
       .lsu_tlu_ldst_va_m           (lsu_tlu_ldst_va_m),
       .lsu_tlu_misalign_addr_ldst_atm_m(lsu_tlu_misalign_addr_ldst_atm_m),
       .lsu_tlu_pctxt_m             (lsu_tlu_pctxt_m),
       .lsu_tlu_pcxpkt_ack          (lsu_tlu_pcxpkt_ack),
       .lsu_tlu_rs3_data_g          (lsu_tlu_rs3_data_g),
       .lsu_tlu_rsr_data_e          (lsu_tlu_rsr_data_e),
       .lsu_tlu_stb_full_w2         (lsu_tlu_stb_full_w2),
       .lsu_tlu_thrid_d             (lsu_tlu_thrid_d),
       .lsu_tlu_tlb_access_tid_m    (lsu_tlu_tlb_access_tid_m),
       .lsu_tlu_tlb_asi_state_m     (lsu_tlu_tlb_asi_state_m),
       .lsu_tlu_tlb_dmp_va_m        (lsu_tlu_tlb_dmp_va_m),
       .lsu_tlu_tlb_ld_inst_m       (lsu_tlu_tlb_ld_inst_m),
       .lsu_tlu_tlb_ldst_va_m       (lsu_tlu_tlb_ldst_va_m),
       .lsu_tlu_tlb_st_inst_m       (lsu_tlu_tlb_st_inst_m),
       .lsu_tlu_ttype_m2            (lsu_tlu_ttype_m2),
       .lsu_tlu_ttype_vld_m2        (lsu_tlu_ttype_vld_m2),
       .lsu_tlu_wsr_inst_e          (lsu_tlu_wsr_inst_e),
       .spc_pcx_atom_pq             (spc_pcx_atom_pq),
       .spc_pcx_data_pa             (spc_pcx_data_pa),
       .spc_pcx_req_pq              (spc_pcx_req_pq),
       .lsu_asi_state               (lsu_asi_state),
       .lsu_ifu_err_addr            (lsu_ifu_err_addr),
       .lsu_sscan_data              (lsu_sscan_data),
       .ifu_tlu_inst_vld_m_bf1      (ifu_tlu_inst_vld_m_bf1),
       .lsu_ffu_bld_cnt_w           (lsu_ffu_bld_cnt_w),
       .lsu_tlu_nucleus_ctxt_m      (lsu_tlu_nucleus_ctxt_m),
       .lsu_tlu_tte_pg_sz_g         (lsu_tlu_tte_pg_sz_g),
       .lsu_tlu_squash_va_oor_m     (lsu_tlu_squash_va_oor_m),
       .lsu_tlu_wtchpt_trp_g        (lsu_tlu_wtchpt_trp_g),
       .lsu_tlu_daccess_prot_g      (lsu_tlu_daccess_prot_g),
       .lsu_tlu_priv_action_g       (lsu_tlu_priv_action_g),
       
       .tlu_dtlb_csm_rd_g           (tlu_dtlb_csm_rd_g), 
       .tlu_dtlb_tte_csm_w2         ({1'bx, tlu_dtlb_tte_csm_w2}), 
       .ifu_lsu_pcxcsm_e            (ifu_lsu_pcxcsm_e), 
       .tlu_dtlb_wr_csm_sel_g       (tlu_dtlb_wr_csm_sel_g),

       .cfg_lsu_csm_dtlb_state      (cfg_lsu_csm_dtlb_state),
       .cfg_lsu_csm_dtlb_chipid     (cfg_lsu_csm_dtlb_chipid),
       .cfg_lsu_csm_dtlb_x          (cfg_lsu_csm_dtlb_x),
       .cfg_lsu_csm_dtlb_y          (cfg_lsu_csm_dtlb_y),
       .cfg_lsu_csm_dtlb_hdid       (cfg_lsu_csm_dtlb_hdid),
       .cfg_lsu_csm_dtlb_hd_size    (cfg_lsu_csm_dtlb_hd_size),
       .cfg_lsu_csm_dtlb_sdid       (cfg_lsu_csm_dtlb_sdid),
       .cfg_lsu_csm_dtlb_lsid       (cfg_lsu_csm_dtlb_lsid),

       
       .bist_ctl_reg_out            (bist_ctl_reg_out),
       .const_cpuid                 (const_cpuid),
       .exu_lsu_rs2_data_e          (exu_lsu_rs2_data_e),
       .exu_lsu_rs3_data_e          (exu_lsu_rs3_data_e),
       .exu_tlu_misalign_addr_jmpl_rtn_m(exu_tlu_misalign_addr_jmpl_rtn_m),
       .exu_tlu_va_oor_m            (exu_tlu_va_oor_m),
       .ffu_lsu_blk_st_e            (ffu_lsu_blk_st_e),
       .ffu_lsu_blk_st_va_e         (ffu_lsu_blk_st_va_e),
       .ffu_lsu_fpop_rq_vld         (ffu_lsu_fpop_rq_vld),
       .ffu_lsu_kill_fst_w          (ffu_lsu_kill_fst_w),
       .ifu_lsu_alt_space_d         (ifu_lsu_alt_space_d),
       .ifu_lsu_alt_space_e         (ifu_lsu_alt_space_e),
       .ifu_lsu_asi_ack             (ifu_lsu_asi_ack),
       .ifu_lsu_asi_rd_unc          (ifu_lsu_asi_rd_unc),
       .ifu_lsu_casa_e              (ifu_lsu_casa_e),
       .ifu_lsu_destid_s            (ifu_lsu_destid_s),
       .ifu_lsu_fwd_data_vld        (ifu_lsu_fwd_data_vld),
       .ifu_lsu_fwd_wr_ack          (ifu_lsu_fwd_wr_ack),
       .ifu_lsu_ibuf_busy           (ifu_lsu_ibuf_busy),
       .ifu_lsu_imm_asi_d           (ifu_lsu_imm_asi_d),
       .ifu_lsu_imm_asi_vld_d       (ifu_lsu_imm_asi_vld_d),
       .ifu_lsu_inv_clear           (ifu_lsu_inv_clear),
       .ifu_lsu_ld_inst_e           (ifu_lsu_ld_inst_e),
       .ifu_lsu_ldst_dbl_e          (ifu_lsu_ldst_dbl_e),
       .ifu_lsu_ldst_fp_e           (ifu_lsu_ldst_fp_e),
       .ifu_lsu_ldst_size_e         (ifu_lsu_ldst_size_e),
       .ifu_lsu_ldstub_e            (ifu_lsu_ldstub_e),
       .ifu_lsu_ldxa_data_vld_w2    (ifu_lsu_ldxa_data_vld_w2),
       .ifu_lsu_ldxa_data_w2        (ifu_lsu_ldxa_data_w2),
       .ifu_lsu_ldxa_illgl_va_w2    (ifu_lsu_ldxa_illgl_va_w2),
       .ifu_lsu_ldxa_tid_w2         (ifu_lsu_ldxa_tid_w2),
       .ifu_lsu_memref_d            (ifu_lsu_memref_d),
       .ifu_lsu_nceen               (ifu_lsu_nceen),
       .ifu_lsu_pcxpkt_e            (ifu_lsu_pcxpkt_e),
       .ifu_lsu_pcxreq_d            (ifu_lsu_pcxreq_d),
       .ifu_lsu_pref_inst_e         (ifu_lsu_pref_inst_e),
       .ifu_lsu_rd_e                (ifu_lsu_rd_e),
       .ifu_lsu_sign_ext_e          (ifu_lsu_sign_ext_e),
       .ifu_lsu_st_inst_e           (ifu_lsu_st_inst_e),
       .ifu_lsu_swap_e              (ifu_lsu_swap_e),
       .ifu_lsu_thrid_s             (ifu_lsu_thrid_s),
       .ifu_tlu_flsh_inst_e         (ifu_tlu_flsh_inst_e),
       .ifu_tlu_flush_m             (ifu_tlu_flush_m),
       .ifu_tlu_inst_vld_m          (ifu_tlu_inst_vld_m),
       .ifu_tlu_mb_inst_e           (ifu_tlu_mb_inst_e),
       .ifu_tlu_sraddr_d            (ifu_tlu_sraddr_d),
       .ifu_tlu_thrid_e             (ifu_tlu_thrid_e),
       .pcx_spc_grant_px            ({4'bx, pcx_spc_grant_px0}),
       .se                          (1'b0),
       .sehold                      (1'b0),
       .spu_lsu_ldxa_data_vld_w2    (1'b0),
       .spu_lsu_ldxa_data_w2        (64'h0000000000000000),
       .spu_lsu_ldxa_illgl_va_w2    (1'b0),
       .spu_lsu_ldxa_tid_w2         (2'b00),
       .spu_lsu_stxa_ack            (1'b0),
       .spu_lsu_stxa_ack_tid        (2'b00),
       .spu_lsu_unc_error_w2        (1'b0),
       // .testmode_l                  (1'bx),
       .tlu_dsfsr_flt_vld           (tlu_dsfsr_flt_vld),
       .tlu_dtlb_data_rd_g          (tlu_dtlb_data_rd_g),
       .tlu_dtlb_dmp_actxt_g        (tlu_dtlb_dmp_actxt_g),
       .tlu_dtlb_dmp_all_g          (tlu_dtlb_dmp_all_g),
       .tlu_dtlb_dmp_nctxt_g        (tlu_dtlb_dmp_nctxt_g),
       .tlu_dtlb_dmp_pctxt_g        (tlu_dtlb_dmp_pctxt_g),
       .tlu_dtlb_dmp_sctxt_g        (tlu_dtlb_dmp_sctxt_g),
       .tlu_dtlb_dmp_vld_g          (tlu_dtlb_dmp_vld_g),
       .tlu_dtlb_invalidate_all_g   (tlu_dtlb_invalidate_all_g),
       .tlu_dtlb_rw_index_g         (tlu_dtlb_rw_index_g),
       .tlu_dtlb_rw_index_vld_g     (tlu_dtlb_rw_index_vld_g),
       .tlu_dtlb_tag_rd_g           (tlu_dtlb_tag_rd_g),
       .tlu_dtlb_tte_data_w2        (tlu_dtlb_tte_data_w2),
       .tlu_dtlb_tte_tag_w2         (tlu_dtlb_tte_tag_w2),
       .tlu_early_flush_pipe2_w     (tlu_early_flush_pipe2_w),
       .tlu_early_flush_pipe_w      (tlu_early_flush_pipe_w),
       .tlu_exu_early_flush_pipe_w  (tlu_exu_early_flush_pipe_w),
       .tlu_idtlb_dmp_key_g         (tlu_idtlb_dmp_key_g),
       .tlu_idtlb_dmp_thrid_g       (tlu_idtlb_dmp_thrid_g),
       .tlu_lsu_asi_m               (tlu_lsu_asi_m),
       .tlu_lsu_asi_update_m        (tlu_lsu_asi_update_m),
       .tlu_lsu_int_ld_ill_va_w2    (tlu_lsu_int_ld_ill_va_w2),
       .tlu_lsu_int_ldxa_data_w2    (tlu_lsu_int_ldxa_data_w2),
       .tlu_lsu_int_ldxa_vld_w2     (tlu_lsu_int_ldxa_vld_w2),
       .tlu_lsu_ldxa_async_data_vld (tlu_lsu_ldxa_async_data_vld),
       .tlu_lsu_ldxa_tid_w2         (tlu_lsu_ldxa_tid_w2),
       .tlu_lsu_pcxpkt              (tlu_lsu_pcxpkt),
       .tlu_lsu_pstate_am           (tlu_lsu_pstate_am),
       .tlu_lsu_pstate_cle          (tlu_lsu_pstate_cle),
       .tlu_lsu_pstate_priv         (tlu_lsu_pstate_priv),
       .tlu_lsu_redmode             ({2'bx, tlu_lsu_redmode}),
       .tlu_lsu_redmode_rst_d1      (tlu_lsu_redmode_rst_d1),
       .tlu_lsu_stxa_ack            (tlu_lsu_stxa_ack),
       .tlu_lsu_stxa_ack_tid        (tlu_lsu_stxa_ack_tid),
       .tlu_lsu_tid_m               (tlu_lsu_tid_m),
       .tlu_lsu_tl_zero             (tlu_lsu_tl_zero),
       .spu_lsu_ldst_pckt           (124'h0000000000000000000000000000000),
       .exu_lsu_ldst_va_e           (exu_lsu_ldst_va_e),
       .exu_lsu_early_va_e          (exu_lsu_early_va_e),
       .ffu_lsu_data                (ffu_lsu_data),
       .cfg_asi_lsu_ldxa_vld_w2     (cfg_asi_lsu_ldxa_vld_w2),
       .cfg_asi_lsu_ldxa_tid_w2     (cfg_asi_lsu_ldxa_tid_w2),
       .cfg_asi_lsu_ldxa_data_w2    (cfg_asi_lsu_ldxa_data_w2),
       // interface to srams
       .srams_rtap_data (srams_rtap_data),
       .rtap_srams_bist_command (rtap_srams_bist_command),
       .rtap_srams_bist_data (rtap_srams_bist_data),
    .core_rtap_data          (core_rtap_data),
    .rtap_core_val         (rtap_core_val),
    .rtap_core_threadid         (rtap_core_threadid),
    .rtap_core_id         (rtap_core_id),
    .rtap_core_data         ({{(94-14){1'bx}}, rtap_core_data_13_0})
    );
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: lsu.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Description:  Load/Store Unit for Sparc Core
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
          // time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu ( /*AUTOARG*/
   // Outputs
  
  spc_pcx_csm_pa,
  
   spc_pcx_req_pq, spc_pcx_data_pa, spc_pcx_atom_pq,
   // spc_efc_dfuse_data, 
   lsu_tlu_wsr_inst_e,
   lsu_tlu_ttype_vld_m2, lsu_tlu_ttype_m2, lsu_tlu_tlb_st_inst_m,
   lsu_tlu_tlb_ldst_va_m, lsu_tlu_tlb_ld_inst_m,
   lsu_tlu_tlb_dmp_va_m, lsu_tlu_tlb_asi_state_m,
   lsu_tlu_tlb_access_tid_m, lsu_tlu_thrid_d, lsu_tlu_stb_full_w2,
   lsu_tlu_rsr_data_e, lsu_tlu_rs3_data_g, lsu_tlu_pcxpkt_ack,
   lsu_tlu_pctxt_m, lsu_tlu_misalign_addr_ldst_atm_m,
   lsu_tlu_ldst_va_m, lsu_tlu_l2_dmiss, lsu_tlu_intpkt,
   lsu_tlu_early_flush_w, lsu_tlu_early_flush2_w, lsu_tlu_dtlb_done,
   lsu_tlu_dside_ctxt_m, lsu_tlu_dmmu_miss_g,
   lsu_tlu_defr_trp_taken_g, lsu_tlu_dcache_miss_w2,
   lsu_tlu_daccess_excptn_g, lsu_tlu_cpx_vld, lsu_tlu_cpx_req,
   lsu_tlu_async_ttype_w2, lsu_tlu_async_ttype_vld_w2,
   lsu_tlu_async_tid_w2, lsu_t3_pctxt_state, lsu_t2_pctxt_state,
   lsu_t1_pctxt_state, lsu_t0_pctxt_state, lsu_spu_strm_ack_cmplt,
   lsu_spu_stb_empty, lsu_spu_ldst_ack, lsu_spu_early_flush_g,
   lsu_spu_asi_state_e, lsu_pid_state3, lsu_pid_state2,
   lsu_pid_state1, lsu_pid_state0, lsu_mmu_rs3_data_g,
   lsu_mmu_flush_pipe_w, lsu_mmu_defr_trp_taken_g, lsu_mamem_mrgn,
   lsu_itlb_mrgn, lsu_ifu_tlb_tag_ue, lsu_ifu_tlb_data_ue,
   lsu_ifu_tlb_data_su, lsu_ifu_stxa_data, lsu_ifu_stbcnt3,
   lsu_ifu_stbcnt2, lsu_ifu_stbcnt1, lsu_ifu_stbcnt0,
   lsu_ifu_stallreq, lsu_ifu_pcxpkt_ack_d, lsu_ifu_ldsta_internal_e,
   lsu_ifu_ldst_miss_w, lsu_ifu_ldst_cmplt, lsu_ifu_ld_pcxpkt_vld,
   lsu_ifu_ld_pcxpkt_tid, lsu_ifu_ld_icache_index,
   lsu_ifu_l2_unc_error, lsu_ifu_l2_corr_error, lsu_ifu_itlb_en,
   lsu_ifu_io_error, lsu_ifu_icache_en, lsu_ifu_flush_pipe_w,
   lsu_ifu_error_tid, lsu_ifu_direct_map_l1,
   lsu_ifu_dcache_tag_perror, lsu_ifu_dcache_data_perror,
   lsu_ifu_dc_parity_error_w2, lsu_ifu_cpxpkt_vld_i1,
   lsu_ifu_cpxpkt_i1, lsu_ifu_asi_vld, lsu_ifu_asi_thrid,
   lsu_ifu_asi_state, lsu_ifu_asi_load, lsu_ifu_asi_addr,
   lsu_ictag_mrgn, lsu_ffu_stb_full3, lsu_ffu_stb_full2,
   lsu_ffu_stb_full1, lsu_ffu_stb_full0, lsu_ffu_st_dtlb_perr_g,
   lsu_ffu_ld_vld, lsu_ffu_ld_data, lsu_ffu_flush_pipe_w,
   lsu_ffu_blk_asi_e, lsu_ffu_ack, lsu_exu_thr_m,
   lsu_exu_st_dtlb_perr_g, lsu_exu_rd_m, lsu_exu_ldst_miss_w2,
   lsu_exu_flush_pipe_w, lsu_exu_dfill_vld_w2, lsu_exu_dfill_data_w2,
   lsu_dsfsr_din_g, lsu_dmmu_sfsr_trp_wr, lsu_asi_reg3, lsu_asi_reg2,
   lsu_asi_reg1, lsu_asi_reg0, ifu_tlu_flush_fd_w,
   ifu_tlu_flush_fd3_w, ifu_tlu_flush_fd2_w, 
   // bist_ctl_reg_wr_en,
   // bist_ctl_reg_in, 
   lsu_asi_state, lsu_ifu_err_addr, lsu_sscan_data,
   ifu_tlu_inst_vld_m_bf1,
   lsu_ffu_bld_cnt_w, so0, so1, short_so0,
   short_so1, lsu_tlu_nucleus_ctxt_m, lsu_tlu_tte_pg_sz_g,
   lsu_tlu_squash_va_oor_m, lsu_tlu_wtchpt_trp_g,
   lsu_tlu_daccess_prot_g, lsu_tlu_priv_action_g,
   // Inputs
   
   tlu_dtlb_csm_rd_g, tlu_dtlb_tte_csm_w2, ifu_lsu_pcxcsm_e,
   tlu_dtlb_wr_csm_sel_g,

   cfg_lsu_csm_dtlb_state, cfg_lsu_csm_dtlb_chipid,cfg_lsu_csm_dtlb_x,
   cfg_lsu_csm_dtlb_y, cfg_lsu_csm_dtlb_hdid,cfg_lsu_csm_dtlb_hd_size,
   cfg_lsu_csm_dtlb_sdid,cfg_lsu_csm_dtlb_lsid,

   

   tlu_lsu_tl_zero, tlu_lsu_tid_m, tlu_lsu_stxa_ack_tid,
   tlu_lsu_stxa_ack, tlu_lsu_redmode_rst_d1, tlu_lsu_redmode,
   tlu_lsu_pstate_priv, tlu_lsu_pstate_cle, tlu_lsu_pstate_am,
   tlu_lsu_priv_trap_m, tlu_lsu_pcxpkt, tlu_lsu_ldxa_tid_w2,
   tlu_lsu_ldxa_async_data_vld, tlu_lsu_int_ldxa_vld_w2,
   tlu_lsu_int_ldxa_data_w2, tlu_lsu_int_ld_ill_va_w2,
   tlu_lsu_hpv_priv, tlu_lsu_hpstate_en, tlu_lsu_asi_update_m,
   tlu_lsu_asi_m, tlu_idtlb_dmp_thrid_g, tlu_idtlb_dmp_key_g,
   tlu_exu_early_flush_pipe_w, tlu_early_flush_pipe_w,
   tlu_early_flush_pipe2_w, tlu_dtlb_tte_tag_w2,
   tlu_dtlb_tte_data_w2, tlu_dtlb_tag_rd_g, tlu_dtlb_rw_index_vld_g,
   tlu_dtlb_rw_index_g, tlu_dtlb_invalidate_all_g,
   tlu_dtlb_dmp_vld_g, tlu_dtlb_dmp_sctxt_g, tlu_dtlb_dmp_pctxt_g,
   tlu_dtlb_dmp_nctxt_g, tlu_dtlb_dmp_all_g, tlu_dtlb_dmp_actxt_g,
   tlu_dtlb_data_rd_g, tlu_dsfsr_flt_vld, 
   // testmode_l,
   spu_lsu_unc_error_w2, spu_lsu_stxa_ack_tid, spu_lsu_stxa_ack,
   spu_lsu_ldxa_tid_w2, spu_lsu_ldxa_illgl_va_w2,
   spu_lsu_ldxa_data_w2, spu_lsu_ldxa_data_vld_w2, spu_lsu_int_w2,
   sehold, se, pcx_spc_grant_px, 
   // mux_drive_disable,
   // mem_write_disable, 

   // mbist_write_data, mbist_dcache_write,
   // mbist_dcache_word, mbist_dcache_way, mbist_dcache_read,
   // mbist_dcache_index, 

   ifu_tlu_wsr_inst_d, ifu_tlu_thrid_e,
   ifu_tlu_sraddr_d, ifu_tlu_mb_inst_e, ifu_tlu_inst_vld_m,
   ifu_tlu_flush_m, ifu_tlu_flsh_inst_e, ifu_lsu_thrid_s,
   ifu_lsu_swap_e, ifu_lsu_st_inst_e, ifu_lsu_sign_ext_e,
   ifu_lsu_rd_e, ifu_lsu_pref_inst_e, ifu_lsu_pcxreq_d,
   ifu_lsu_pcxpkt_e, ifu_lsu_nceen, ifu_lsu_memref_d,
   ifu_lsu_ldxa_tid_w2, ifu_lsu_ldxa_illgl_va_w2,
   ifu_lsu_ldxa_data_w2, ifu_lsu_ldxa_data_vld_w2, ifu_lsu_ldstub_e,
   ifu_lsu_ldst_size_e, ifu_lsu_ldst_fp_e, ifu_lsu_ldst_dbl_e,
   ifu_lsu_ld_inst_e, ifu_lsu_inv_clear, ifu_lsu_imm_asi_vld_d,
   ifu_lsu_imm_asi_d, ifu_lsu_ibuf_busy, ifu_lsu_fwd_wr_ack,
   ifu_lsu_fwd_data_vld, ifu_lsu_destid_s, ifu_lsu_casa_e,
   ifu_lsu_asi_rd_unc, ifu_lsu_asi_ack, ifu_lsu_alt_space_e,
   ifu_lsu_alt_space_d, grst_l, gdbginit_l, ffu_lsu_kill_fst_w,
   ffu_lsu_fpop_rq_vld, ffu_lsu_blk_st_va_e, ffu_lsu_blk_st_e,
   exu_tlu_va_oor_m, exu_tlu_misalign_addr_jmpl_rtn_m,
   exu_lsu_rs3_data_e, exu_lsu_rs2_data_e, 

   // efc_spc_fuse_clk2,
   // efc_spc_fuse_clk1, efc_spc_dfuse_dshift, efc_spc_dfuse_data,
   // efc_spc_dfuse_ashift, 
   const_cpuid, clk,
   bist_ctl_reg_out, arst_l, cpx_spc_data_cx, spu_lsu_ldst_pckt,
   exu_lsu_ldst_va_e, exu_lsu_early_va_e, ffu_lsu_data, si0, si1,
   short_si1, short_si0, exu_tlu_wsr_data_m,
   cfg_asi_lsu_ldxa_vld_w2, cfg_asi_lsu_ldxa_tid_w2, cfg_asi_lsu_ldxa_data_w2,

   // sram wrapper interface
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data,

   core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data

   );

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
input                   arst_l;                 // To qctl1 of lsu_qctl1.v, ...
input [(6 + 4):0]            bist_ctl_reg_out;       // To dctldp of lsu_dctldp.v
input                   clk;                    // To qctl1 of lsu_qctl1.v, ...
input [2:0]             const_cpuid;            // To qctl2 of lsu_qctl2.v, ...
input [63:0]            exu_lsu_rs2_data_e;     // To stb_rwdp of lsu_stb_rwdp.v
input [63:0]            exu_lsu_rs3_data_e;     // To excpctl of lsu_excpctl.v, ...
input                   exu_tlu_misalign_addr_jmpl_rtn_m;// To excpctl of lsu_excpctl.v
input                   exu_tlu_va_oor_m;       // To excpctl of lsu_excpctl.v
input                   ffu_lsu_blk_st_e;       // To dctl of lsu_dctl.v, ...
input [5:3]             ffu_lsu_blk_st_va_e;    // To stb_rwctl of lsu_stb_rwctl.v
input                   ffu_lsu_fpop_rq_vld;    // To qctl1 of lsu_qctl1.v
input                   ffu_lsu_kill_fst_w;     // To stb_rwctl of lsu_stb_rwctl.v
input                   gdbginit_l;             // To qctl1 of lsu_qctl1.v, ...
input                   grst_l;                 // To qctl2 of lsu_qctl2.v, ...
input                   ifu_lsu_alt_space_d;    // To dctl of lsu_dctl.v
input                   ifu_lsu_alt_space_e;    // To qctl1 of lsu_qctl1.v, ...
input                   ifu_lsu_asi_ack;        // To dctl of lsu_dctl.v
input                   ifu_lsu_asi_rd_unc;     // To dctl of lsu_dctl.v
input                   ifu_lsu_casa_e;         // To qctl1 of lsu_qctl1.v, ...
input [2:0]             ifu_lsu_destid_s;       // To qctl1 of lsu_qctl1.v
input                   ifu_lsu_fwd_data_vld;   // To qctl1 of lsu_qctl1.v, ...
input                   ifu_lsu_fwd_wr_ack;     // To qctl2 of lsu_qctl2.v
input                   ifu_lsu_ibuf_busy;      // To qctl2 of lsu_qctl2.v
input [7:0]             ifu_lsu_imm_asi_d;      // To dctldp of lsu_dctldp.v
input                   ifu_lsu_imm_asi_vld_d;  // To dctldp of lsu_dctldp.v
input                   ifu_lsu_inv_clear;      // To qctl2 of lsu_qctl2.v
input                   ifu_lsu_ld_inst_e;      // To qctl1 of lsu_qctl1.v, ...
input                   ifu_lsu_ldst_dbl_e;     // To qctl1 of lsu_qctl1.v, ...
input                   ifu_lsu_ldst_fp_e;      // To qctl1 of lsu_qctl1.v, ...
input [1:0]             ifu_lsu_ldst_size_e;    // To dctl of lsu_dctl.v, ...
input                   ifu_lsu_ldstub_e;       // To dctl of lsu_dctl.v, ...
input                   ifu_lsu_ldxa_data_vld_w2;// To dctl of lsu_dctl.v
input [63:0]            ifu_lsu_ldxa_data_w2;   // To qdp1 of lsu_qdp1.v
input                   ifu_lsu_ldxa_illgl_va_w2;// To dctl of lsu_dctl.v
input [1:0]             ifu_lsu_ldxa_tid_w2;    // To dctl of lsu_dctl.v
input                   ifu_lsu_memref_d;       // To qctl2 of lsu_qctl2.v, ...
input [3:0]             ifu_lsu_nceen;          // To excpctl of lsu_excpctl.v, ...
input [51:0]            ifu_lsu_pcxpkt_e;       // To qctl1 of lsu_qctl1.v, ...
input                   ifu_lsu_pcxreq_d;       // To qctl1 of lsu_qctl1.v
input                   ifu_lsu_pref_inst_e;    // To qctl1 of lsu_qctl1.v, ...
input [4:0]             ifu_lsu_rd_e;           // To qctl2 of lsu_qctl2.v, ...
input                   ifu_lsu_sign_ext_e;     // To dctl of lsu_dctl.v
input                   ifu_lsu_st_inst_e;      // To excpctl of lsu_excpctl.v, ...
input                   ifu_lsu_swap_e;         // To dctl of lsu_dctl.v, ...
input [1:0]             ifu_lsu_thrid_s;        // To dctl of lsu_dctl.v
input                   ifu_tlu_flsh_inst_e;    // To dctl of lsu_dctl.v, ...
input                   ifu_tlu_flush_m;        // To dctl of lsu_dctl.v
input                   ifu_tlu_inst_vld_m;     // To qctl1 of lsu_qctl1.v, ...
input                   ifu_tlu_mb_inst_e;      // To dctl of lsu_dctl.v
input [6:0]             ifu_tlu_sraddr_d;       // To dctl of lsu_dctl.v
input [1:0]             ifu_tlu_thrid_e;        // To qctl1 of lsu_qctl1.v, ...
input                   ifu_tlu_wsr_inst_d;     // To dctl of lsu_dctl.v
// input [6:0]             mbist_dcache_index;     // To dctl of lsu_dctl.v
// input                   mbist_dcache_read;      // To dctl of lsu_dctl.v
// input [1:0]             mbist_dcache_way;       // To dctl of lsu_dctl.v
// input                   mbist_dcache_word;      // To dctl of lsu_dctl.v
// input                   mbist_dcache_write;     // To dctl of lsu_dctl.v
// input [7:0]             mbist_write_data;       // To qdp2 of lsu_qdp2.v
input [4:0]             pcx_spc_grant_px;       // To qctl1 of lsu_qctl1.v
input                   se;                     // To qctl1 of lsu_qctl1.v, ...
input                   sehold;                 // To qctl1 of lsu_qctl1.v, ...
input                   spu_lsu_int_w2;         // To dctl of lsu_dctl.v
input                   spu_lsu_ldxa_data_vld_w2;// To dctl of lsu_dctl.v
input [63:0]            spu_lsu_ldxa_data_w2;   // To qdp1 of lsu_qdp1.v
input                   spu_lsu_ldxa_illgl_va_w2;// To dctl of lsu_dctl.v
input [1:0]             spu_lsu_ldxa_tid_w2;    // To dctl of lsu_dctl.v
input                   spu_lsu_stxa_ack;       // To dctl of lsu_dctl.v
input [1:0]             spu_lsu_stxa_ack_tid;   // To dctl of lsu_dctl.v
input                   spu_lsu_unc_error_w2;   // To dctl of lsu_dctl.v
// input                   testmode_l;             // To dcdhdr of cmp_sram_redhdr.v
input [3:0]             tlu_dsfsr_flt_vld;      // To excpctl of lsu_excpctl.v
input                   tlu_dtlb_data_rd_g;     // To dctl of lsu_dctl.v
input                   tlu_dtlb_dmp_actxt_g;   // To dctl of lsu_dctl.v, ...
input                   tlu_dtlb_dmp_all_g;     // To dctl of lsu_dctl.v
input                   tlu_dtlb_dmp_nctxt_g;   // To dctl of lsu_dctl.v
input                   tlu_dtlb_dmp_pctxt_g;   // To dctl of lsu_dctl.v
input                   tlu_dtlb_dmp_sctxt_g;   // To dctl of lsu_dctl.v
input                   tlu_dtlb_dmp_vld_g;     // To dctl of lsu_dctl.v
input                   tlu_dtlb_invalidate_all_g;// To dctl of lsu_dctl.v
input [5:0]             tlu_dtlb_rw_index_g;    // To dctl of lsu_dctl.v, ...
input                   tlu_dtlb_rw_index_vld_g;// To dctl of lsu_dctl.v
input                   tlu_dtlb_tag_rd_g;      // To dctl of lsu_dctl.v
input [42:0]            tlu_dtlb_tte_data_w2;   // To dtlb of bw_r_tlb.v
input [58:0]            tlu_dtlb_tte_tag_w2;    // To dctldp of lsu_dctldp.v, ...
input                   tlu_early_flush_pipe2_w;// To qctl1 of lsu_qctl1.v, ...
input                   tlu_early_flush_pipe_w; // To excpctl of lsu_excpctl.v
input                   tlu_exu_early_flush_pipe_w;// To stb_rwctl of lsu_stb_rwctl.v
input [40:0]            tlu_idtlb_dmp_key_g;    // To dtlb of bw_r_tlb.v
input [1:0]             tlu_idtlb_dmp_thrid_g;  // To dctl of lsu_dctl.v
input [7:0]             tlu_lsu_asi_m;          // To dctldp of lsu_dctldp.v
input                   tlu_lsu_asi_update_m;   // To dctl of lsu_dctl.v
input [3:0]             tlu_lsu_hpstate_en;     // To dctl of lsu_dctl.v
input [3:0]             tlu_lsu_hpv_priv;       // To dctl of lsu_dctl.v
input                   tlu_lsu_int_ld_ill_va_w2;// To dctl of lsu_dctl.v
input [63:0]            tlu_lsu_int_ldxa_data_w2;// To qdp1 of lsu_qdp1.v
input                   tlu_lsu_int_ldxa_vld_w2;// To dctl of lsu_dctl.v
input                   tlu_lsu_ldxa_async_data_vld;// To dctl of lsu_dctl.v
input [1:0]             tlu_lsu_ldxa_tid_w2;    // To dctl of lsu_dctl.v
input [25:0]            tlu_lsu_pcxpkt;         // To qctl1 of lsu_qctl1.v, ...
input                   tlu_lsu_priv_trap_m;    // To excpctl of lsu_excpctl.v
input [3:0]             tlu_lsu_pstate_am;      // To excpctl of lsu_excpctl.v, ...
input [3:0]             tlu_lsu_pstate_cle;     // To excpctl of lsu_excpctl.v, ...
input [3:0]             tlu_lsu_pstate_priv;    // To excpctl of lsu_excpctl.v
input [3:0]             tlu_lsu_redmode;        // To dctl of lsu_dctl.v
input [3:0]             tlu_lsu_redmode_rst_d1; // To dctl of lsu_dctl.v
input                   tlu_lsu_stxa_ack;       // To dctl of lsu_dctl.v
input [1:0]             tlu_lsu_stxa_ack_tid;   // To dctl of lsu_dctl.v
input [1:0]             tlu_lsu_tid_m;          // To dctl of lsu_dctl.v
input [3:0]             tlu_lsu_tl_zero;        // To dctl of lsu_dctl.v

input                   tlu_dtlb_csm_rd_g;
input [32:0]        tlu_dtlb_tte_csm_w2;
input [32:0]        ifu_lsu_pcxcsm_e;       // To qctl1 of lsu_qctl1.v, ...
input                   tlu_dtlb_wr_csm_sel_g;

input [2-1:0]   cfg_lsu_csm_dtlb_state;
input [14-1:0]      cfg_lsu_csm_dtlb_chipid;
input [8-1:0]           cfg_lsu_csm_dtlb_x;
input [8-1:0]           cfg_lsu_csm_dtlb_y;
input [10-1:0]        cfg_lsu_csm_dtlb_hdid;
input [6-1:0]        cfg_lsu_csm_dtlb_hd_size;
input [10-1:0]        cfg_lsu_csm_dtlb_sdid;
input [6-1:0]        cfg_lsu_csm_dtlb_lsid;


// End of automatics
input                   cfg_asi_lsu_ldxa_vld_w2;
input [1:0]             cfg_asi_lsu_ldxa_tid_w2;
input [63:0]            cfg_asi_lsu_ldxa_data_w2;


// sram wrapper interface
// output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_dcache_w01_rtap_data;
// output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_dcache_w23_rtap_data;
// output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_dtag_rtap_data;
wire [4-1:0] sram_dcache_w01_rtap_data;
wire [4-1:0] sram_dcache_w23_rtap_data;
wire [4-1:0] sram_dtag_rtap_data;
wire [4-1:0] dcv_rtap_data;
output [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;

assign srams_rtap_data = sram_dcache_w01_rtap_data
                        | sram_dcache_w23_rtap_data
                        // | dcv_rtap_data
                        | sram_dtag_rtap_data;

output wire [94-1:0] core_rtap_data;
input wire rtap_core_val;
input wire [1:0] rtap_core_threadid;
input wire [4-1:0]  rtap_core_id;
input wire [94-1:0] rtap_core_data;
assign core_rtap_data = 94'd0;

reg [3:0] ctu_sscan_tid;
always @ *
begin
   if (rtap_core_threadid == 2'd0)
      ctu_sscan_tid = 4'b0001;
   else if (rtap_core_threadid == 2'd1)
      ctu_sscan_tid = 4'b0010;
   else if (rtap_core_threadid == 2'd2)
      ctu_sscan_tid = 4'b0100;
   else if (rtap_core_threadid == 2'd3)
      ctu_sscan_tid = 4'b1000;
end



/*AUTOOUTPUT*/
// trin: removing useless output
// Beginning of automatic outputs (from unused autoinst outputs)
// output [6:0]            bist_ctl_reg_in;        // From dctldp of lsu_dctldp.v
// output                  bist_ctl_reg_wr_en;     // From dctl of lsu_dctl.v
wire   [6:0]            bist_ctl_reg_in;        // From dctldp of lsu_dctldp.v
wire                    bist_ctl_reg_wr_en;     // From dctl of lsu_dctl.v
output                  ifu_tlu_flush_fd2_w;    // From dctl of lsu_dctl.v
output                  ifu_tlu_flush_fd3_w;    // From dctl of lsu_dctl.v
output                  ifu_tlu_flush_fd_w;     // From dctl of lsu_dctl.v
output [7:0]            lsu_asi_reg0;           // From dctldp of lsu_dctldp.v
output [7:0]            lsu_asi_reg1;           // From dctldp of lsu_dctldp.v
output [7:0]            lsu_asi_reg2;           // From dctldp of lsu_dctldp.v
output [7:0]            lsu_asi_reg3;           // From dctldp of lsu_dctldp.v
output [3:0]            lsu_dmmu_sfsr_trp_wr;   // From excpctl of lsu_excpctl.v
output [23:0]           lsu_dsfsr_din_g;        // From excpctl of lsu_excpctl.v
output [63:0]           lsu_exu_dfill_data_w2;  // From dcdp of lsu_dcdp.v
output                  lsu_exu_dfill_vld_w2;   // From dctl of lsu_dctl.v
output                  lsu_exu_flush_pipe_w;   // From excpctl of lsu_excpctl.v
output                  lsu_exu_ldst_miss_w2;   // From dctl of lsu_dctl.v
output [4:0]            lsu_exu_rd_m;           // From qctl2 of lsu_qctl2.v
output                  lsu_exu_st_dtlb_perr_g; // From excpctl of lsu_excpctl.v
output [1:0]            lsu_exu_thr_m;          // From dctl of lsu_dctl.v
output                  lsu_ffu_ack;            // From qctl1 of lsu_qctl1.v
output                  lsu_ffu_blk_asi_e;      // From dctl of lsu_dctl.v
output                  lsu_ffu_flush_pipe_w;   // From excpctl of lsu_excpctl.v
output [63:0]           lsu_ffu_ld_data;        // From dcdp of lsu_dcdp.v
output                  lsu_ffu_ld_vld;         // From dctl of lsu_dctl.v
output                  lsu_ffu_st_dtlb_perr_g; // From excpctl of lsu_excpctl.v
output                  lsu_ffu_stb_full0;      // From stb_rwctl of lsu_stb_rwctl.v
output                  lsu_ffu_stb_full1;      // From stb_rwctl of lsu_stb_rwctl.v
output                  lsu_ffu_stb_full2;      // From stb_rwctl of lsu_stb_rwctl.v
output                  lsu_ffu_stb_full3;      // From stb_rwctl of lsu_stb_rwctl.v
output [3:0]            lsu_ictag_mrgn;         // From dctldp of lsu_dctldp.v
output [17:0]           lsu_ifu_asi_addr;       // From dctldp of lsu_dctldp.v
output                  lsu_ifu_asi_load;       // From dctl of lsu_dctl.v
output [7:0]            lsu_ifu_asi_state;      // From dctldp of lsu_dctldp.v
output [1:0]            lsu_ifu_asi_thrid;      // From dctl of lsu_dctl.v
output                  lsu_ifu_asi_vld;        // From dctl of lsu_dctl.v
output [144-1:0]   lsu_ifu_cpxpkt_i1;      // From qdp2 of lsu_qdp2.v
output                  lsu_ifu_cpxpkt_vld_i1;  // From qctl2 of lsu_qctl2.v
output                  lsu_ifu_dc_parity_error_w2;// From dctl of lsu_dctl.v
output                  lsu_ifu_dcache_data_perror;// From dctl of lsu_dctl.v
output                  lsu_ifu_dcache_tag_perror;// From dctl of lsu_dctl.v
output                  lsu_ifu_direct_map_l1;  // From dctldp of lsu_dctldp.v
output [1:0]            lsu_ifu_error_tid;      // From dctl of lsu_dctl.v
output                  lsu_ifu_flush_pipe_w;   // From excpctl of lsu_excpctl.v
output [3:0]            lsu_ifu_icache_en;      // From dctl of lsu_dctl.v
output                  lsu_ifu_io_error;       // From dctl of lsu_dctl.v
output [3:0]            lsu_ifu_itlb_en;        // From dctl of lsu_dctl.v
output                  lsu_ifu_l2_corr_error;  // From dctl of lsu_dctl.v
output                  lsu_ifu_l2_unc_error;   // From dctl of lsu_dctl.v
output [(6 + 5):5]           lsu_ifu_ld_icache_index;// From qdp1 of lsu_qdp1.v
output [1:0]            lsu_ifu_ld_pcxpkt_tid;  // From qdp1 of lsu_qdp1.v
output                  lsu_ifu_ld_pcxpkt_vld;  // From qctl1 of lsu_qctl1.v
output [3:0]            lsu_ifu_ldst_cmplt;     // From dctl of lsu_dctl.v
output                  lsu_ifu_ldst_miss_w;    // From dctl of lsu_dctl.v
output                  lsu_ifu_ldsta_internal_e;// From dctl of lsu_dctl.v
output                  lsu_ifu_pcxpkt_ack_d;   // From qctl1 of lsu_qctl1.v
output                  lsu_ifu_stallreq;       // From qctl2 of lsu_qctl2.v
output [3:0]            lsu_ifu_stbcnt0;        // From stb_rwctl of lsu_stb_rwctl.v
output [3:0]            lsu_ifu_stbcnt1;        // From stb_rwctl of lsu_stb_rwctl.v
output [3:0]            lsu_ifu_stbcnt2;        // From stb_rwctl of lsu_stb_rwctl.v
output [3:0]            lsu_ifu_stbcnt3;        // From stb_rwctl of lsu_stb_rwctl.v
output [47:0]           lsu_ifu_stxa_data;      // From qdp1 of lsu_qdp1.v
output                  lsu_ifu_tlb_data_su;    // From excpctl of lsu_excpctl.v
output                  lsu_ifu_tlb_data_ue;    // From excpctl of lsu_excpctl.v
output                  lsu_ifu_tlb_tag_ue;     // From excpctl of lsu_excpctl.v
output [7:0]            lsu_itlb_mrgn;          // From dctldp of lsu_dctldp.v
output [3:0]            lsu_mamem_mrgn;         // From dctldp of lsu_dctldp.v
output                  lsu_mmu_defr_trp_taken_g;// From excpctl of lsu_excpctl.v
output                  lsu_mmu_flush_pipe_w;   // From excpctl of lsu_excpctl.v
output [63:0]           lsu_mmu_rs3_data_g;     // From qdp1 of lsu_qdp1.v
output [2:0]            lsu_pid_state0;         // From dctldp of lsu_dctldp.v
output [2:0]            lsu_pid_state1;         // From dctldp of lsu_dctldp.v
output [2:0]            lsu_pid_state2;         // From dctldp of lsu_dctldp.v
output [2:0]            lsu_pid_state3;         // From dctldp of lsu_dctldp.v
output [7:0]            lsu_spu_asi_state_e;    // From dctldp of lsu_dctldp.v
output                  lsu_spu_early_flush_g;  // From excpctl of lsu_excpctl.v
output                  lsu_spu_ldst_ack;       // From qctl1 of lsu_qctl1.v
output [3:0]            lsu_spu_stb_empty;      // From stb_rwctl of lsu_stb_rwctl.v
output [1:0]            lsu_spu_strm_ack_cmplt; // From qctl2 of lsu_qctl2.v
output [12:0]           lsu_t0_pctxt_state;     // From dctldp of lsu_dctldp.v
output [12:0]           lsu_t1_pctxt_state;     // From dctldp of lsu_dctldp.v
output [12:0]           lsu_t2_pctxt_state;     // From dctldp of lsu_dctldp.v
output [12:0]           lsu_t3_pctxt_state;     // From dctldp of lsu_dctldp.v
output [1:0]            lsu_tlu_async_tid_w2;   // From dctl of lsu_dctl.v
output                  lsu_tlu_async_ttype_vld_w2;// From dctl of lsu_dctl.v
output [6:0]            lsu_tlu_async_ttype_w2; // From dctl of lsu_dctl.v
output [3:0]            lsu_tlu_cpx_req;        // From qctl2 of lsu_qctl2.v
output                  lsu_tlu_cpx_vld;        // From qctl2 of lsu_qctl2.v
output                  lsu_tlu_daccess_excptn_g;// From excpctl of lsu_excpctl.v
output [3:0]            lsu_tlu_dcache_miss_w2; // From qctl1 of lsu_qctl1.v
output                  lsu_tlu_defr_trp_taken_g;// From excpctl of lsu_excpctl.v
output                  lsu_tlu_dmmu_miss_g;    // From excpctl of lsu_excpctl.v
output [12:0]           lsu_tlu_dside_ctxt_m;   // From dctldp of lsu_dctldp.v
output                  lsu_tlu_dtlb_done;      // From dctl of lsu_dctl.v
output                  lsu_tlu_early_flush2_w; // From excpctl of lsu_excpctl.v
output                  lsu_tlu_early_flush_w;  // From excpctl of lsu_excpctl.v
output [17:0]           lsu_tlu_intpkt;         // From qctl2 of lsu_qctl2.v
output [3:0]            lsu_tlu_l2_dmiss;       // From qctl2 of lsu_qctl2.v
output [9:0]            lsu_tlu_ldst_va_m;      // From dctldp of lsu_dctldp.v
output                  lsu_tlu_misalign_addr_ldst_atm_m;// From excpctl of lsu_excpctl.v
output [12:0]           lsu_tlu_pctxt_m;        // From dctldp of lsu_dctldp.v
output                  lsu_tlu_pcxpkt_ack;     // From qctl1 of lsu_qctl1.v
output [63:0]           lsu_tlu_rs3_data_g;     // From qdp1 of lsu_qdp1.v
output [7:0]            lsu_tlu_rsr_data_e;     // From dctldp of lsu_dctldp.v
output [3:0]            lsu_tlu_stb_full_w2;    // From stb_ctl0 of lsu_stb_ctl.v, ...
output [1:0]            lsu_tlu_thrid_d;        // From dctl of lsu_dctl.v
output [1:0]            lsu_tlu_tlb_access_tid_m;// From dctl of lsu_dctl.v
output [7:0]            lsu_tlu_tlb_asi_state_m;// From dctldp of lsu_dctldp.v
output [47:13]          lsu_tlu_tlb_dmp_va_m;   // From dctldp of lsu_dctldp.v
output                  lsu_tlu_tlb_ld_inst_m;  // From dctl of lsu_dctl.v
output [(6 + 4):0]           lsu_tlu_tlb_ldst_va_m;  // From dctldp of lsu_dctldp.v
output                  lsu_tlu_tlb_st_inst_m;  // From,tl of lsu_dctl.v
output [8:0]            lsu_tlu_ttype_m2;       // From excpctl of lsu_excpctl.v
output                  lsu_tlu_ttype_vld_m2;   // From excpctl of lsu_excpctl.v
output                  lsu_tlu_wsr_inst_e;     // From dctl of lsu_dctl.v
// output [71:0]           mbist_dcache_data_in;   // From dcdp of lsu_dcdp.v
output                  spc_pcx_atom_pq;        // From qctl1 of lsu_qctl1.v
output [124-1:0] spc_pcx_data_pa;        // From qdp1 of lsu_qdp1.v
output [4:0]            spc_pcx_req_pq;         // From qctl1 of lsu_qctl1.v
// End of automatics


output [32:0]       spc_pcx_csm_pa;


// trin: disabling useless in/outs
wire [(6 + 4)-4:0]              mbist_dcache_index = 1'b0;     // To dctl of lsu_dctl.v
wire                    mbist_dcache_read = 1'b0;      // To dctl of lsu_dctl.v
wire [1:0]              mbist_dcache_way = 2'b0;       // To dctl of lsu_dctl.v
wire                    mbist_dcache_word = 1'b0;      // To dctl of lsu_dctl.v
wire                    mbist_dcache_write = 1'b0;     // To dctl of lsu_dctl.v
wire [7:0]              mbist_write_data = 8'b0;       // To qdp2 of lsu_qdp2.v

wire [71:0]             mbist_dcache_data_in;   // From dcdp of lsu_dcdp.v
// wire                    spc_efc_dfuse_data;     // From dcdhdr of cmp_sram_redhdr.v
// wire                   mem_write_disable = 0;      // To dcache of bw_r_dcd.v, ...
// wire                   mux_drive_disable = 0;      // To qctl1 of lsu_qctl1.v, ...
// wire mux_drive_disable = ~grst_l;
// wire mem_write_disable = ~grst_l;
wire mux_drive_disable = 1'b0;
wire mem_write_disable = 1'b0;
wire efc_spc_dfuse_ashift = 1'b0;
wire efc_spc_dfuse_data = 1'b0;
wire efc_spc_dfuse_dshift = 1'b0;
wire efc_spc_fuse_clk1 = 1'b0;
wire efc_spc_fuse_clk2 = 1'b0;




/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)

wire                    as_if_user_asi_m;       // From dctl of lsu_dctl.v
wire [7:0]              asi_d;                  // From dctldp of lsu_dctldp.v
wire                    asi_internal_m;         // From dctl of lsu_dctl.v
wire [3:0]              asi_state_wr_thrd;      // From dctl of lsu_dctl.v
wire                    asi_tte_data_perror;    // From excpctl of lsu_excpctl.v
wire                    asi_tte_tag_perror;     // From excpctl of lsu_excpctl.v
wire [5:0]              async_tlb_index;        // From dctl of lsu_dctl.v
wire                    atomic_asi_m;           // From dctl of lsu_dctl.v
wire                    atomic_m;               // From dctl of lsu_dctl.v
wire                    binit_quad_asi_m;       // From dctl of lsu_dctl.v
wire                    bist_tap_wr_en;         // From dctl of lsu_dctl.v
wire                    blk_asi_m;              // From dctl of lsu_dctl.v
wire                    cache_hit;              // From dtlb of bw_r_tlb.v
wire [4-1:0]              cache_way_hit;          // From dtlb of bw_r_tlb.v
wire [4-1:0]              cache_way_hit_buf1;     // From tlbdp of lsu_tlbdp.v
wire [4-1:0]              cache_way_hit_buf2;     // From tlbdp of lsu_tlbdp.v
wire                    cam_real_m;             // From dctl of lsu_dctl.v
wire                    cpx_fwd_pkt_en_cx;      // From qctl2 of lsu_qctl2.v
wire                    cpx_st_ack_tid0;        // From qctl2 of lsu_qctl2.v
wire                    cpx_st_ack_tid1;        // From qctl2 of lsu_qctl2.v
wire                    cpx_st_ack_tid2;        // From qctl2 of lsu_qctl2.v
wire                    cpx_st_ack_tid3;        // From qctl2 of lsu_qctl2.v
wire                    data_rd_vld_g;          // From dctl of lsu_dctl.v
wire                    dc_direct_map;          // From dctldp of lsu_dctldp.v
wire [63:0]             dcache_alt_data_w0_m;   // From qdp1 of lsu_qdp1.v
wire                    dcache_alt_mx_sel_e;    // From dctl of lsu_dctl.v
wire                    dcache_alt_mx_sel_e_bf; // From dctl of lsu_dctl.v
wire                    dcache_arry_data_sel_m; // From dctl of lsu_dctl.v
wire [15:0]             dcache_byte_wr_en_e;    // From dctl of lsu_dctl.v
wire [(6 + 4)-3:0]              dcache_iob_addr_e;      // From qdp2 of lsu_qdp2.v
// wire [7:0]              dcache_rdata_msb_w0_m;  // From dcache of bw_r_dcd.v
// wire [7:0]              dcache_rdata_msb_w1_m;  // From dcache of bw_r_dcd.v
// wire [7:0]              dcache_rdata_msb_w2_m;  // From dcache of bw_r_dcd.v
// wire [7:0]              dcache_rdata_msb_w3_m;  // From dcache of bw_r_dcd.v
wire [4*8-1:0]              dcache_rdata_msb_m;  // From dcache of bw_r_dcd.v
wire [63:0]             dcache_rdata_wb;        // From dcache of bw_r_dcd.v
wire [63:0]             dcache_rdata_wb_buf;    // From dcdp of lsu_dcdp.v
wire                    dcache_rparity_err_wb;  // From dcache of bw_r_dcd.v
wire [7:0]              dcache_rparity_wb;      // From dcache of bw_r_dcd.v
wire                    dcache_rvld_e;          // From dctl of lsu_dctl.v

// trin
wire [1:0]              dcd_fuse_repair_en;     // From dcache of bw_r_dcd.v
wire [7:0]              dcd_fuse_repair_value;  // From dcache of bw_r_dcd.v
assign dcd_fuse_repair_en = 2'b0;
assign dcd_fuse_repair_value = 2'b0;

wire                    dctl_rst_l;             // From dctl of lsu_dctl.v
wire                    dfill_tlb_asi_e;        // From dctl of lsu_dctl.v
wire                    dfq_byp_ff_en;          // From qctl2 of lsu_qctl2.v
wire [3:0]              dfq_byp_sel;            // From qctl2 of lsu_qctl2.v
wire [4:0]              dfq_rptr;               // From qctl2 of lsu_qctl2.v
wire                    dfq_rptr_vld;           // From qctl2 of lsu_qctl2.v
wire [1:0]              dfq_tid;                // From qdp2 of lsu_qdp2.v
wire [4:0]              dfq_wptr;               // From qctl2 of lsu_qctl2.v
wire                    dfq_wptr_vld;           // From qctl2 of lsu_qctl2.v
wire [3:0]              dfture_tap_rd_en;       // From dctl of lsu_dctl.v
wire                    dfture_tap_wr_mx_sel;   // From dctl of lsu_dctl.v
// wire [32:0]             dtag_rdata_w0_m;        // From dtag of bw_r_dct.v
// wire [32:0]             dtag_rdata_w1_m;        // From dtag of bw_r_dct.v
// wire [32:0]             dtag_rdata_w2_m;        // From dtag of bw_r_dct.v
// wire [32:0]             dtag_rdata_w3_m;        // From dtag of bw_r_dct.v
wire [(33*4)-1:0]             dtag_rdata_m;        // From dtag of bw_r_dct.v
wire                    dtlb_bypass_m;          // From dctl of lsu_dctl.v
wire [(4*4-1):0]             dva_bit_wr_en_e;        // From dctl of lsu_dctl.v
wire                    dva_din_e;              // From dctl of lsu_dctl.v
wire [(6 + 4)-6:0]              dva_snp_addr_e;         // From qctl2 of lsu_qctl2.v
wire [(4*4-1):0]             dva_snp_bit_wr_en_e;    // From qctl2 of lsu_qctl2.v
wire                    dva_svld_e;             // From qctl2 of lsu_qctl2.v
wire [4-1:0]              dva_vld_m;              // From dva of sram_l1d_val.v
wire [4-1:0]              dva_vld_m_bf;           // From dctl of lsu_dctl.v
wire [(6 + 4):6]             dva_wr_adr_e;           // From dctl of lsu_dctl.v
wire                    flsh_inst_m;            // From stb_rwctl of lsu_stb_rwctl.v
wire                    fp_ldst_m;              // From dctl of lsu_dctl.v

// trin
wire [1:0]              fuse_dcd_repair_en;     // From dcdhdr of cmp_sram_redhdr.v
wire [7:0]              fuse_dcd_repair_value;  // From dcdhdr of cmp_sram_redhdr.v
wire [5:0]              fuse_dcd_rid;           // From dcdhdr of cmp_sram_redhdr.v
wire                    fuse_dcd_wren;          // From dcdhdr of cmp_sram_redhdr.v
assign fuse_dcd_wren = 1'b0;
assign fuse_dcd_repair_en = 2'b0;
assign fuse_dcd_repair_value = 8'b0;
assign fuse_dcd_rid = 6'b0;

wire [2:0]              fwd_int_fp_pcx_mx_sel;  // From qctl1 of lsu_qctl1.v
wire                    hpstate_en_m;           // From dctl of lsu_dctl.v
wire                    hpv_priv_m;             // From dctl of lsu_dctl.v
wire                    ifill_tlb_asi_e;        // From dctl of lsu_dctl.v
wire                    ifu_lsu_flush_w;        // From dctl of lsu_dctl.v
wire                    ifu_tlu_inst_vld_m_bf2; // From stb_rwctl of lsu_stb_rwctl.v
wire                    imiss_pcx_mx_sel;       // From qctl1 of lsu_qctl1.v
wire                    l2fill_vld_m;           // From dctl of lsu_dctl.v
wire [3:0]              lctl_rst;               // From dctl of lsu_dctl.v
wire [65-1:40]  ld_pcx_pkt_g;           // From dctl of lsu_dctl.v
wire [1:0]              ld_pcx_thrd;            // From qctl1 of lsu_qctl1.v
wire [2:0]              ld_rawp_st_ackid_w2;    // From stb_rwctl of lsu_stb_rwctl.v
wire                    ld_rawp_st_ced_w2;      // From stb_rwctl of lsu_stb_rwctl.v
wire                    ld_sec_active;          // From qctl2 of lsu_qctl2.v
wire                    ld_sec_hit_thrd0;       // From qdp1 of lsu_qdp1.v
wire                    ld_sec_hit_thrd1;       // From qdp1 of lsu_qdp1.v
wire                    ld_sec_hit_thrd2;       // From qdp1 of lsu_qdp1.v
wire                    ld_sec_hit_thrd3;       // From qdp1 of lsu_qdp1.v
wire                    ld_stb_full_raw_w2;     // From qctl1 of lsu_qctl1.v
wire [3:0]              ld_thrd_byp_mxsel_m;    // From dctl of lsu_dctl.v
wire                    lda_internal_m;         // From dctl of lsu_dctl.v
wire                    ldd_in_dfq_out;         // From qctl2 of lsu_qctl2.v
wire                    ldiagctl_wr_en;         // From dctl of lsu_dctl.v
wire                    ldst_dbl_m;             // From dctl of lsu_dctl.v
wire [1:0]              ldst_sz_m;              // From dctl of lsu_dctl.v
wire                    ldxa_internal;          // From dctl of lsu_dctl.v

wire [1:0]              lmq0_byp_misc_sz;       // From qdp1 of lsu_qdp1.v
wire                    lmq0_l2fill_fpld;       // From qdp1 of lsu_qdp1.v
wire [2:0]              lmq0_ld_rq_type;        // From qdp1 of lsu_qdp1.v
wire                    lmq0_ldd_vld;           // From qdp1 of lsu_qdp1.v
wire                    lmq0_ncache_ld;         // From qdp1 of lsu_qdp1.v
wire [(6 + 4):0]             lmq0_pcx_pkt_addr;      // From qdp1 of lsu_qdp1.v
wire [2-1:0]              lmq0_pcx_pkt_way;       // From qctl1 of lsu_qctl1.v

wire [1:0]              lmq1_byp_misc_sz;       // From qdp1 of lsu_qdp1.v
wire                    lmq1_l2fill_fpld;       // From qdp1 of lsu_qdp1.v
wire [2:0]              lmq1_ld_rq_type;        // From qdp1 of lsu_qdp1.v
wire                    lmq1_ldd_vld;           // From qdp1 of lsu_qdp1.v
wire                    lmq1_ncache_ld;         // From qdp1 of lsu_qdp1.v
wire [(6 + 4):0]             lmq1_pcx_pkt_addr;      // From qdp1 of lsu_qdp1.v
wire [2-1:0]              lmq1_pcx_pkt_way;       // From qctl1 of lsu_qctl1.v
wire [1:0]              lmq2_byp_misc_sz;       // From qdp1 of lsu_qdp1.v
wire                    lmq2_l2fill_fpld;       // From qdp1 of lsu_qdp1.v
wire [2:0]              lmq2_ld_rq_type;        // From qdp1 of lsu_qdp1.v
wire                    lmq2_ldd_vld;           // From qdp1 of lsu_qdp1.v
wire                    lmq2_ncache_ld;         // From qdp1 of lsu_qdp1.v
wire [(6 + 4):0]             lmq2_pcx_pkt_addr;      // From qdp1 of lsu_qdp1.v
wire [2-1:0]              lmq2_pcx_pkt_way;       // From qctl1 of lsu_qctl1.v
wire [1:0]              lmq3_byp_misc_sz;       // From qdp1 of lsu_qdp1.v
wire                    lmq3_l2fill_fpld;       // From qdp1 of lsu_qdp1.v
wire [2:0]              lmq3_ld_rq_type;        // From qdp1 of lsu_qdp1.v
wire                    lmq3_ldd_vld;           // From qdp1 of lsu_qdp1.v
wire                    lmq3_ncache_ld;         // From qdp1 of lsu_qdp1.v
wire [(6 + 4):0]             lmq3_pcx_pkt_addr;      // From qdp1 of lsu_qdp1.v
wire [2-1:0]              lmq3_pcx_pkt_way;       // From qctl1 of lsu_qctl1.v

wire [3:0]              lmq_byp_data_en_w2;     // From dctl of lsu_dctl.v
wire [3:0]              lmq_byp_data_fmx_sel;   // From dctl of lsu_dctl.v
wire [3:0]              lmq_byp_data_mxsel0;    // From dctl of lsu_dctl.v
wire [3:0]              lmq_byp_data_mxsel1;    // From dctl of lsu_dctl.v
wire [3:0]              lmq_byp_data_mxsel2;    // From dctl of lsu_dctl.v
wire [3:0]              lmq_byp_data_mxsel3;    // From dctl of lsu_dctl.v
wire [2:0]              lmq_byp_ldxa_mxsel0;    // From dctl of lsu_dctl.v
wire [2:0]              lmq_byp_ldxa_mxsel1;    // From dctl of lsu_dctl.v
wire [2:0]              lmq_byp_ldxa_mxsel2;    // From dctl of lsu_dctl.v
wire [2:0]              lmq_byp_ldxa_mxsel3;    // From dctl of lsu_dctl.v
wire [3:0]              lmq_enable;             // From qctl1 of lsu_qctl1.v
wire                    lmq_ld_addr_b3;         // From dctl of lsu_dctl.v
wire [4:0]              lmq_ld_rd1;             // From qdp1 of lsu_qdp1.v
wire                    lmq_ldd_vld;            // From dctl of lsu_dctl.v
wire                    lsu_alt_space_m;        // From dctl of lsu_dctl.v
wire [2:0]              lsu_asi_sel_fmx1;       // From dctl of lsu_dctl.v
wire [2:0]              lsu_asi_sel_fmx2;       // From dctl of lsu_dctl.v
wire                    lsu_atm_st_cmplt_e;     // From qctl2 of lsu_qctl2.v
wire [2:0]              lsu_atomic_pkt2_bsel_g; // From dctl of lsu_dctl.v
wire [4-1:0]              lsu_bist_rsel_way_e;    // From dctl of lsu_dctl.v
wire [2:0]              lsu_bld_cnt_m;          // From qctl1 of lsu_qctl1.v
wire                    lsu_bld_helper_cmplt_m; // From qctl1 of lsu_qctl1.v
wire                    lsu_bld_pcx_rq;         // From qctl1 of lsu_qctl1.v
wire                    lsu_bld_reset;          // From qctl1 of lsu_qctl1.v
wire [1:0]              lsu_bld_rq_addr;        // From qctl1 of lsu_qctl1.v
wire                    lsu_blk_asi_m;          // From dctl of lsu_dctl.v
wire                    lsu_blk_st_m;           // From dctl of lsu_dctl.v
wire [39:10]            lsu_blkst_pgnum_m;      // From dctl of lsu_dctl.v
wire                    lsu_bst_in_pipe_m;      // From dctl of lsu_dctl.v
wire                    lsu_byp_ldd_oddrd_m;    // From qctl2 of lsu_qctl2.v
wire [1:0]              lsu_byp_misc_sz_e;      // From qdp1 of lsu_qdp1.v
wire [7:0]              lsu_cpu_dcd_sel;        // From qctl2 of lsu_qctl2.v
// wire                    lsu_cpu_inv_data_b0;    // From qdp2 of lsu_qdp2.v
// wire [13:9]             lsu_cpu_inv_data_b13to9;// From qdp2 of lsu_qdp2.v
// wire [7:2]              lsu_cpu_inv_data_b7to2; // From qdp2 of lsu_qdp2.v
wire                        lsu_cpu_inv_data_val ;
wire  [2-1:0]  lsu_cpu_inv_data_way ;
wire                    lsu_cpu_uhlf_sel;       // From qctl2 of lsu_qctl2.v
wire                    lsu_cpx_ld_dcache_perror_e;// From qctl2 of lsu_qctl2.v
wire                    lsu_cpx_ld_dtag_perror_e;// From qctl2 of lsu_qctl2.v
wire                    lsu_cpx_pkt_atm_st_cmplt;// From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_atomic;     // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_binit_st;   // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_ifill_type; // From qdp2 of lsu_qdp2.v
wire [(6 + 4)-6:0]              lsu_cpx_pkt_inv_pa;     // From qdp2 of lsu_qdp2.v
wire [2-1:0]              lsu_cpx_pkt_invwy;      // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_l2miss;     // From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_cpx_pkt_ld_err;     // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_perror_dinv;// From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_perror_iinv;// From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_cpx_pkt_perror_set; // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_prefetch;   // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_prefetch2;  // From qdp2 of lsu_qdp2.v
wire                    lsu_cpx_pkt_strm_ack;   // From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_cpx_pkt_tid;        // From qdp2 of lsu_qdp2.v
wire [3:0]              lsu_cpx_rmo_st_ack;     // From qctl2 of lsu_qctl2.v
wire                    lsu_cpx_spc_inv_vld;    // From qctl2 of lsu_qctl2.v
wire                    lsu_cpx_stack_dcfill_vld;// From qctl2 of lsu_qctl2.v
wire [3:0]              lsu_cpx_thrdid;         // From qctl2 of lsu_qctl2.v
wire [5:0]              lsu_cpxpkt_type_dcd_cx; // From qctl2 of lsu_qctl2.v
wire [3:0]              lsu_ctl_state_wr_en;    // From dctl of lsu_dctl.v
wire                    lsu_dc_iob_access_e;    // From dctl of lsu_dctl.v
wire                    lsu_dcache_data_perror_g;// From dctl of lsu_dctl.v
wire [(6 + 4):3]             lsu_dcache_fill_addr_e; // From dctl of lsu_dctl.v
wire [(6 + 4):4]             lsu_dcache_fill_addr_e_err;// From dctl of lsu_dctl.v
wire [143:0]            lsu_dcache_fill_data_e; // From qdp2 of lsu_qdp2.v
wire [4-1:0]              lsu_dcache_fill_way_e;  // From dctl of lsu_dctl.v
wire                    lsu_dcache_iob_rd_w;    // From qctl2 of lsu_qctl2.v
wire [2-1:0]              lsu_dcache_iob_way_e;   // From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_dcache_rand;        // From dctl of lsu_dctl.v
wire                    lsu_dcache_tag_perror_g;// From dctl of lsu_dctl.v
wire                    lsu_dcache_wr_vld_e;    // From dctl of lsu_dctl.v
wire                    lsu_dcfill_active_e;    // From qctl2 of lsu_qctl2.v
wire                    lsu_dcfill_data_mx_sel_e;// From dctl of lsu_dctl.v
wire [4-1:0]              lsu_dctag_mrgn;         // From dctldp of lsu_dctldp.v
wire [7:0]              lsu_dctl_asi_state_m;   // From dctldp of lsu_dctldp.v
wire                    lsu_dctldp_thread0_m;   // From dctl of lsu_dctl.v
wire                    lsu_dctldp_thread1_m;   // From dctl of lsu_dctl.v
wire                    lsu_dctldp_thread2_m;   // From dctl of lsu_dctl.v
wire                    lsu_dctldp_thread3_m;   // From dctl of lsu_dctl.v
wire                    lsu_defr_trp_taken_g;   // From excpctl of lsu_excpctl.v
wire                    lsu_dfill_data_sel_hi;  // From qctl2 of lsu_qctl2.v
wire [3:0]              lsu_dfill_dcd_thrd;     // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_byp_atm;        // From qdp2 of lsu_qdp2.v
wire                    lsu_dfq_byp_binit_st;   // From qdp2 of lsu_qdp2.v
wire                    lsu_dfq_byp_cpx_inv;    // From qdp2 of lsu_qdp2.v
wire                    lsu_dfq_byp_ff_en;      // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_byp_flush;      // From qdp2 of lsu_qdp2.v
wire                    lsu_dfq_byp_invwy_vld;  // From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_dfq_byp_stack_adr_b54;// From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_dfq_byp_stack_wrway;// From qdp2 of lsu_qdp2.v
wire [1:0]              lsu_dfq_byp_tid;        // From qdp2 of lsu_qdp2.v
wire [3:0]              lsu_dfq_byp_tid_d1_sel; // From qctl1 of lsu_qctl1.v
wire [5:0]              lsu_dfq_byp_type;       // From qdp2 of lsu_qdp2.v
wire [3:0]              lsu_dfq_flsh_cmplt;     // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_ld_vld;         // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_ldst_vld;       // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_rd_vld_d1;      // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_st_vld;         // From qctl2 of lsu_qctl2.v
wire                    lsu_dfq_vld;            // From qctl2 of lsu_qctl2.v
wire                    lsu_diag_va_prty_invrt; // From dctldp of lsu_dctldp.v
wire [3:0]              lsu_diagnstc_data_sel;  // From dctl of lsu_dctl.v
wire [7:0]              lsu_diagnstc_dc_prty_invrt_e;// From dctldp of lsu_dctldp.v
wire                    lsu_diagnstc_dtagv_prty_invrt_e;// From dctl of lsu_dctl.v
wire [3:0]              lsu_diagnstc_va_sel;    // From dctl of lsu_dctl.v
wire [(6 + 4):0]             lsu_diagnstc_wr_addr_e; // From dctldp of lsu_dctldp.v
wire                    lsu_diagnstc_wr_data_b0;// From qdp1 of lsu_qdp1.v
wire [63:0]             lsu_diagnstc_wr_data_e; // From qdp1 of lsu_qdp1.v
wire [2-1:0]              lsu_diagnstc_wr_way_e;  // From dctldp of lsu_dctldp.v
wire [5:0]              lsu_dp_ctl_reg0;        // From dctldp of lsu_dctldp.v
wire [5:0]              lsu_dp_ctl_reg1;        // From dctldp of lsu_dctldp.v
wire [5:0]              lsu_dp_ctl_reg2;        // From dctldp of lsu_dctldp.v
wire [5:0]              lsu_dp_ctl_reg3;        // From dctldp of lsu_dctldp.v
wire                    lsu_dtag_index_sel_x_e; // From dctl of lsu_dctl.v
wire [3:0]              lsu_dtag_rsel_m;        // From dctl of lsu_dctl.v
wire                    lsu_dtag_wrreq_x_e;     // From dctl of lsu_dctl.v
wire                    lsu_dtagv_wr_vld_e;     // From dctl of lsu_dctl.v
wire                    lsu_dtlb_addr_mask_l_e; // From dctl of lsu_dctl.v
wire                    lsu_dtlb_bypass_e;      // From dctl of lsu_dctl.v
wire [2:0]              lsu_dtlb_cam_pid_e;     // From dctldp of lsu_dctldp.v
wire                    lsu_dtlb_data_rd_e;     // From dctl of lsu_dctl.v
wire                    lsu_dtlb_dmp_all_e;     // From dctl of lsu_dctl.v
wire                    lsu_dtlb_dmp_vld_e;     // From dctl of lsu_dctl.v
wire                    lsu_dtlb_invalid_all_l_m;// From dctl of lsu_dctl.v
wire [7:0]              lsu_dtlb_mrgn;          // From dctldp of lsu_dctldp.v
wire                    lsu_dtlb_rwindex_vld_e; // From dctl of lsu_dctl.v
wire                    lsu_dtlb_tag_rd_e;      // From dctl of lsu_dctl.v
wire                    lsu_dtlb_wr_vld_e;      // From dctl of lsu_dctl.v
wire                    lsu_dtlb_cam_real_e;
wire [1:0]              lsu_encd_way_hit;       // From dctl of lsu_dctl.v
wire [2:0]              lsu_err_addr_sel;       // From dctl of lsu_dctl.v
wire [28:0]             lsu_error_pa_m;         // From qdp1 of lsu_qdp1.v
wire [7:0]              lsu_excpctl_asi_state_m;// From dctldp of lsu_dctldp.v
wire                    lsu_fldd_vld_en;        // From qctl2 of lsu_qctl2.v
wire                    lsu_flsh_inst_m;        // From dctl of lsu_dctl.v
wire                    lsu_fwd_rply_sz1_unc;   // From qctl2 of lsu_qctl2.v
wire [4:0]              lsu_fwdpkt_dest;        // From qctl2 of lsu_qctl2.v
wire                    lsu_fwdpkt_pcx_rq_sel;  // From qctl1 of lsu_qctl1.v
wire                    lsu_fwdpkt_vld;         // From qctl2 of lsu_qctl2.v
wire                    lsu_ifu_asi_data_en_l;  // From dctl of lsu_dctl.v
wire                    lsu_imiss_pcx_rq_sel_d1;// From qctl1 of lsu_qctl1.v
wire [3:0]              lsu_intrpt_cmplt;       // From qctl1 of lsu_qctl1.v
wire                    lsu_iobrdge_fwd_pkt_vld;// From qctl2 of lsu_qctl2.v
wire [2:0]              lsu_iobrdge_rply_data_sel;// From qctl2 of lsu_qctl2.v
wire [8:0]              lsu_iobrdge_tap_rq_type;// From qdp2 of lsu_qdp2.v
wire [43:0]             lsu_iobrdge_wr_data;    // From qdp2 of lsu_qdp2.v
wire                    lsu_l2fill_bendian_m;   // From qdp1 of lsu_qdp1.v
wire [63:0]             lsu_l2fill_data;        // From qdp2 of lsu_qdp2.v
wire                    lsu_l2fill_fpld_e;      // From dctl of lsu_dctl.v
wire                    lsu_l2fill_sign_extend_m;// From qdp1 of lsu_qdp1.v
wire                    lsu_l2fill_vld;         // From qctl2 of lsu_qctl2.v
wire                    lsu_ld0_spec_vld_kill_w2;// From qctl1 of lsu_qctl1.v
wire                    lsu_ld1_spec_vld_kill_w2;// From qctl1 of lsu_qctl1.v
wire                    lsu_ld2_spec_vld_kill_w2;// From qctl1 of lsu_qctl1.v
wire                    lsu_ld3_spec_vld_kill_w2;// From qctl1 of lsu_qctl1.v
wire [3:0]              lsu_ld_inst_vld_g;      // From dctl of lsu_dctl.v
wire                    lsu_ld_miss_wb;         // From dctl of lsu_dctl.v
wire [3:0]              lsu_ld_pcx_rq_mxsel;    // From qctl1 of lsu_qctl1.v
wire [3:0]              lsu_ld_pcx_rq_sel_d2;   // From qctl1 of lsu_qctl1.v
wire [2:0]              lsu_ld_thrd_byp_sel_e;  // From dctl of lsu_dctl.v
wire                    lsu_ldquad_inst_m;      // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_ldst_inst_vld_e;    // From dctl of lsu_dctl.v
wire [7:0]              lsu_ldst_va_g;          // From dctldp of lsu_dctldp.v
wire [12:0]             lsu_ldst_va_m;          // From dctldp of lsu_dctldp.v
wire [47:0]             lsu_ldst_va_m_buf;      // From dctldp of lsu_dctldp.v
wire [1:0]              lsu_ldst_va_way_g;      // From qdp1 of lsu_qdp1.v
wire                    lsu_ldstub_g;           // From dctl of lsu_dctl.v
wire [3:0]              lsu_lmq_byp_misc_sel;   // From qctl1 of lsu_qctl1.v
wire                    lsu_local_diagnstc_tagrd_sel_g;// From dctl of lsu_dctl.v
wire                    lsu_local_early_flush_g;// From excpctl of lsu_excpctl.v
wire                    lsu_local_ldxa_sel_g;   // From dctl of lsu_dctl.v
wire                    lsu_local_ldxa_tlbrd_sel_g;// From dctl of lsu_dctl.v
wire                    lsu_memref_m;           // From dctl of lsu_dctl.v
wire [63:0]             lsu_misc_rdata_w2;      // From tagdp of lsu_tagdp.v
wire [3:0]              lsu_no_spc_pref;        // From dctl of lsu_dctl.v
wire                    lsu_nonalt_nucl_access_m;// From dctl of lsu_dctl.v
wire [3:0]              lsu_outstanding_rmo_st_max;// From dctl of lsu_dctl.v
wire [107:0]            lsu_pcx_fwd_pkt;        // From qdp2 of lsu_qdp2.v
wire                    lsu_pcx_fwd_reply;      // From qctl2 of lsu_qctl2.v
wire                    lsu_pcx_ld_dtag_perror_w2;// From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_req_squash0;    // From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_req_squash1;    // From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_req_squash2;    // From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_req_squash3;    // From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_req_squash_d1;  // From qctl1 of lsu_qctl1.v
wire                    lsu_pcx_rq_sz_b3;       // From qctl1 of lsu_qctl1.v
wire                    lsu_pref_pcx_req;       // From qdp1 of lsu_qdp1.v
wire                    lsu_qdp2_dfq_ld_vld;    // From qctl2 of lsu_qctl2.v
wire                    lsu_qdp2_dfq_st_vld;    // From qctl2 of lsu_qctl2.v
wire                    lsu_quad_asi_e;         // From dctl of lsu_dctl.v
wire                    lsu_quad_word_access_g; // From dctl of lsu_dctl.v
wire                    lsu_ramtest_rd_w;       // From qctl1 of lsu_qctl1.v
wire [4-1:0]              lsu_rd_dtag_parity_g;   // From tagdp of lsu_tagdp.v
wire                    lsu_snap_blk_st_m;      // From dctl of lsu_dctl.v
wire                    lsu_squash_va_oor_m;    // From dctl of lsu_dctl.v
wire [3:0]              lsu_st_ack_dq_stb;      // From qctl2 of lsu_qctl2.v
wire [1:0]              lsu_st_dcfill_size_e;   // From qdp2 of lsu_qdp2.v
wire [3:0]              lsu_st_dtlb_perr_g;     // From excpctl of lsu_excpctl.v
wire                    lsu_st_hw_le_g;         // From dctl of lsu_dctl.v
wire [3:0]              lsu_st_pcx_rq_kill_w2;  // From stb_ctl0 of lsu_stb_ctl.v, ...
wire [3:0]              lsu_st_pcx_rq_pick;     // From qctl1 of lsu_qctl1.v
wire                    lsu_st_pcx_rq_vld;      // From qctl1 of lsu_qctl1.v
wire                    lsu_st_rmo_m;           // From dctl of lsu_dctl.v
wire [2:1]              lsu_st_rq_type_m;       // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_b_m;          // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_bhw_m;        // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_bhww_m;       // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_dw_m;         // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_hw_m;         // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_hww_m;        // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_w_m;          // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_sz_wdw_m;        // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_st_w_or_dbl_le_g;   // From dctl of lsu_dctl.v
wire [2-1:0]              lsu_st_way_e;           // From qdp2 of lsu_qdp2.v
wire                    lsu_st_wr_dcache;       // From qctl2 of lsu_qctl2.v
wire                    lsu_st_x_le_g;          // From dctl of lsu_dctl.v
wire [3:0]              lsu_stb_data_early_sel_e;// From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_stb_data_final_sel_m;// From stb_rwctl of lsu_stb_rwctl.v
wire [3:0]              lsu_stb_empty;          // From stb_ctl0 of lsu_stb_ctl.v, ...
wire [3:0]              lsu_stb_empty_buf;      // From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_stb_pcx_rvld_d1;    // From qctl1 of lsu_qctl1.v
wire [1:0]              lsu_stb_rd_tid;         // From qctl1 of lsu_qctl1.v
wire [3:0]              lsu_stb_rmo_st_issue;   // From stb_ctl0 of lsu_stb_ctl.v, ...
wire [9:3]              lsu_stb_va_m;           // From stb_rwctl of lsu_stb_rwctl.v
wire [3:0]              lsu_stbcnt0;            // From stb_ctl0 of lsu_stb_ctl.v
wire [3:0]              lsu_stbcnt1;            // From stb_ctl1 of lsu_stb_ctl.v
wire [3:0]              lsu_stbcnt2;            // From stb_ctl2 of lsu_stb_ctl.v
wire [3:0]              lsu_stbcnt3;            // From stb_ctl3 of lsu_stb_ctl.v
wire                    lsu_stbctl_flush_pipe_w;// From stb_rwctl of lsu_stb_rwctl.v
wire                    lsu_swap_g;             // From dctl of lsu_dctl.v
wire                    lsu_swap_sel_default_byte_7_2_g;// From dctl of lsu_dctl.v
wire                    lsu_swap_sel_default_g; // From dctl of lsu_dctl.v
wire [3:0]              lsu_thread_g;           // From dctl of lsu_dctl.v
wire                    lsu_tlb_asi_data_perr_g;// From dctl of lsu_dctl.v
wire                    lsu_tlb_asi_tag_perr_g; // From dctl of lsu_dctl.v
wire                    lsu_tlb_data_rd_vld_g;  // From dctl of lsu_dctl.v
wire                    lsu_tlb_perr_ld_rq_kill_w;// From excpctl of lsu_excpctl.v
wire [63:0]             lsu_tlb_rd_data;        // From tlbdp of lsu_tlbdp.v
wire [3:0]              lsu_tlb_st_sel_m;       // From dctl of lsu_dctl.v
wire                    lsu_tlbop_force_swo;    // From dctl of lsu_dctl.v
wire [2:0]              lsu_tlu_ctxt_sel_m;     // From dctl of lsu_dctl.v
wire                    lsu_tlu_nonalt_ldst_m;  // From dctl of lsu_dctl.v
wire                    lsu_tlu_write_op_m;     // From dctl of lsu_dctl.v
wire                    lsu_tlu_xslating_ldst_m;// From dctl of lsu_dctl.v
wire                    lsu_ttype_vld_m2;       // From excpctl of lsu_excpctl.v
wire                    lsu_ttype_vld_m2_bf1;   // From excpctl of lsu_excpctl.v
wire                    lsu_va_match_b31_b3_m;  // From qdp1 of lsu_qdp1.v
wire                    lsu_va_match_b47_b32_m; // From qdp1 of lsu_qdp1.v
wire                    lsu_va_wtchpt0_wr_en_l; // From dctl of lsu_dctl.v
wire                    lsu_va_wtchpt1_wr_en_l; // From dctl of lsu_dctl.v
wire                    lsu_va_wtchpt2_wr_en_l; // From dctl of lsu_dctl.v
wire                    lsu_va_wtchpt3_wr_en_l; // From dctl of lsu_dctl.v
wire [47:3]             lsu_va_wtchpt_addr;     // From qdp1 of lsu_qdp1.v
wire                    lsu_va_wtchpt_sel_g;    // From dctl of lsu_dctl.v
wire                    lsu_way_hit_or;         // From dctl of lsu_dctl.v
wire [3:0]              lsuctl_ctlbits_wr_en;   // From dctl of lsu_dctl.v
wire                    merge0_sel_byte0_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte1_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte2_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte3_default_m;// From dctl of lsu_dctl.v
wire                    merge0_sel_byte4_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte5_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte6_m;     // From dctl of lsu_dctl.v
wire                    merge0_sel_byte7_default_m;// From dctl of lsu_dctl.v
wire                    merge0_sel_byte_1h_m;   // From dctl of lsu_dctl.v
wire                    merge1_sel_byte0_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte1_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte2_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte3_default_m;// From dctl of lsu_dctl.v
wire                    merge1_sel_byte4_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte5_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte6_m;     // From dctl of lsu_dctl.v
wire                    merge1_sel_byte7_default_m;// From dctl of lsu_dctl.v
wire                    merge1_sel_byte_1h_m;   // From dctl of lsu_dctl.v
wire                    merge1_sel_byte_2h_m;   // From dctl of lsu_dctl.v
wire                    merge2_sel_byte1_m;     // From dctl of lsu_dctl.v
wire                    merge2_sel_byte2_m;     // From dctl of lsu_dctl.v
wire                    merge2_sel_byte5_m;     // From dctl of lsu_dctl.v
wire                    merge2_sel_byte6_default_m;// From dctl of lsu_dctl.v
wire                    merge2_sel_byte_m;      // From dctl of lsu_dctl.v
wire                    merge3_sel_byte0_m;     // From dctl of lsu_dctl.v
wire                    merge3_sel_byte3_m;     // From dctl of lsu_dctl.v
wire                    merge3_sel_byte4_m;     // From dctl of lsu_dctl.v
wire                    merge3_sel_byte7_default_m;// From dctl of lsu_dctl.v
wire                    merge3_sel_byte_m;      // From dctl of lsu_dctl.v
wire                    merge4_sel_byte3_m;     // From dctl of lsu_dctl.v
wire                    merge4_sel_byte4_m;     // From dctl of lsu_dctl.v
wire                    merge5_sel_byte2_m;     // From dctl of lsu_dctl.v
wire                    merge5_sel_byte5_m;     // From dctl of lsu_dctl.v
wire                    merge6_sel_byte1_m;     // From dctl of lsu_dctl.v
wire                    merge6_sel_byte6_m;     // From dctl of lsu_dctl.v
wire                    merge7_sel_byte0_m;     // From dctl of lsu_dctl.v
wire                    merge7_sel_byte7_m;     // From dctl of lsu_dctl.v
wire [3:0]              misc_ctl_sel_din;       // From dctl of lsu_dctl.v
wire                    mmu_rd_only_asi_m;      // From dctl of lsu_dctl.v
wire [7:0]              morphed_addr_m;         // From dctl of lsu_dctl.v
wire                    mrgn_tap_wr_en;         // From dctl of lsu_dctl.v
wire                    mrgnctl_wr_en;          // From dctl of lsu_dctl.v
wire                    nofault_asi_m;          // From dctl of lsu_dctl.v
wire [3:0]              pctxt_state_wr_thrd;    // From dctl of lsu_dctl.v
wire [3:0]              pcx_pkt_src_sel;        // From qctl1 of lsu_qctl1.v
wire [3:0]              pcx_rq_for_stb;         // From qctl1 of lsu_qctl1.v
wire [3:0]              pcx_rq_for_stb_d1;      // From qctl1 of lsu_qctl1.v
wire                    phy_byp_ec_asi_m;       // From dctl of lsu_dctl.v
wire                    phy_use_ec_asi_m;       // From dctl of lsu_dctl.v
wire [3:0]              pid_state_wr_en;        // From dctl of lsu_dctl.v
wire                    quad_asi_m;             // From dctl of lsu_dctl.v
wire                    rd_only_asi_m;          // From dctl of lsu_dctl.v
wire                    rd_only_ltlb_asi_e;     // From dctl of lsu_dctl.v
wire                    recognized_asi_m;       // From dctl of lsu_dctl.v
wire [3:0]              sctxt_state_wr_thrd;    // From dctl of lsu_dctl.v
wire                    signed_ldst_byte_m;     // From dctl of lsu_dctl.v
wire                    signed_ldst_hw_m;       // From dctl of lsu_dctl.v
wire                    signed_ldst_w_m;        // From dctl of lsu_dctl.v
wire [(6 + 4):0]             st_dcfill_addr;         // From qdp2 of lsu_qdp2.v
wire [63:0]             st_rs3_data_g;          // From qdp1 of lsu_qdp1.v
wire                    sta_internal_m;         // From dctl of lsu_dctl.v
wire [2:1]              stb0_atm_rq_type;       // From stb_ctl0 of lsu_stb_ctl.v
wire [7:0]              stb0_clk_en_l;          // From stb_ctl0 of lsu_stb_ctl.v
wire [2:0]              stb0_crnt_ack_id;       // From stb_ctl0 of lsu_stb_ctl.v
wire [2:0]              stb0_l2b_addr;          // From stb_ctl0 of lsu_stb_ctl.v
wire [7:0]              stb0_state_rmo;         // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_0;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_1;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_2;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_3;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_4;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_5;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_6;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb0_state_rtype_7;     // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_0;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_1;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_2;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_3;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_4;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_5;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_6;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [3:2]              stb0_state_si_7;        // From stb_ctldp0 of lsu_stb_ctldp.v
wire [2:1]              stb1_atm_rq_type;       // From stb_ctl1 of lsu_stb_ctl.v
wire [7:0]              stb1_clk_en_l;          // From stb_ctl1 of lsu_stb_ctl.v
wire [2:0]              stb1_crnt_ack_id;       // From stb_ctl1 of lsu_stb_ctl.v
wire [2:0]              stb1_l2b_addr;          // From stb_ctl1 of lsu_stb_ctl.v
wire [7:0]              stb1_state_rmo;         // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_0;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_1;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_2;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_3;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_4;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_5;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_6;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb1_state_rtype_7;     // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_0;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_1;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_2;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_3;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_4;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_5;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_6;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [3:2]              stb1_state_si_7;        // From stb_ctldp1 of lsu_stb_ctldp.v
wire [2:1]              stb2_atm_rq_type;       // From stb_ctl2 of lsu_stb_ctl.v
wire [7:0]              stb2_clk_en_l;          // From stb_ctl2 of lsu_stb_ctl.v
wire [2:0]              stb2_crnt_ack_id;       // From stb_ctl2 of lsu_stb_ctl.v
wire [2:0]              stb2_l2b_addr;          // From stb_ctl2 of lsu_stb_ctl.v
wire [7:0]              stb2_state_rmo;         // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_0;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_1;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_2;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_3;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_4;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_5;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_6;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb2_state_rtype_7;     // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_0;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_1;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_2;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_3;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_4;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_5;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_6;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [3:2]              stb2_state_si_7;        // From stb_ctldp2 of lsu_stb_ctldp.v
wire [2:1]              stb3_atm_rq_type;       // From stb_ctl3 of lsu_stb_ctl.v
wire [7:0]              stb3_clk_en_l;          // From stb_ctl3 of lsu_stb_ctl.v
wire [2:0]              stb3_crnt_ack_id;       // From stb_ctl3 of lsu_stb_ctl.v
wire [2:0]              stb3_l2b_addr;          // From stb_ctl3 of lsu_stb_ctl.v
wire [7:0]              stb3_state_rmo;         // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_0;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_1;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_2;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_3;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_4;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_5;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_6;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [2:1]              stb3_state_rtype_7;     // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_0;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_1;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_2;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_3;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_4;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_5;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_6;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [3:2]              stb3_state_si_7;        // From stb_ctldp3 of lsu_stb_ctldp.v
wire [1:0]              stb_cam_cm_tid;         // From stb_rwctl of lsu_stb_rwctl.v
wire                    stb_cam_hit;            // From stb_cam of bw_r_scm.v
wire                    stb_cam_hit_bf;         // From excpctl of lsu_excpctl.v
wire                    stb_cam_hit_bf1;        // From excpctl of lsu_excpctl.v
wire [2:0]              stb_cam_hit_ptr;        // From stb_cam of bw_r_scm.v
wire                    stb_cam_mhit;           // From stb_cam of bw_r_scm.v
wire                    stb_cam_rptr_vld;       // From stb_rwctl of lsu_stb_rwctl.v
wire [4:0]              stb_cam_rw_ptr;         // From stb_rwctl of lsu_stb_rwctl.v
wire [7:0]              stb_cam_sqsh_msk;       // From excpctl of lsu_excpctl.v
wire                    stb_cam_vld;            // From tlbdp of lsu_tlbdp.v
wire                    stb_cam_wptr_vld;       // From stb_rwctl of lsu_stb_rwctl.v
wire                    stb_cam_wr_no_ivld_m;   // From stb_rwctl of lsu_stb_rwctl.v
wire [3:0]              stb_cam_wvld_m;         // From stb_rwctl of lsu_stb_rwctl.v
wire [4:0]              stb_data_rd_ptr;        // From stb_rwctl of lsu_stb_rwctl.v
wire                    stb_data_rptr_vld;      // From stb_rwctl of lsu_stb_rwctl.v
wire                    stb_data_wptr_vld;      // From stb_rwctl of lsu_stb_rwctl.v
wire [4:0]              stb_data_wr_ptr;        // From stb_rwctl of lsu_stb_rwctl.v
wire [3:0]              stb_flush_st_g;         // From stb_rwctl of lsu_stb_rwctl.v
wire [7:0]              stb_ld_full_raw;        // From stb_cam of bw_r_scm.v
wire [7:0]              stb_ld_partial_raw;     // From stb_cam of bw_r_scm.v
wire [7:0]              stb_ldst_byte_msk;      // From stb_rwctl of lsu_stb_rwctl.v
wire [2:0]              stb_pcx_rptr0;          // From stb_ctl0 of lsu_stb_ctl.v
wire [2:0]              stb_pcx_rptr1;          // From stb_ctl1 of lsu_stb_ctl.v
wire [2:0]              stb_pcx_rptr2;          // From stb_ctl2 of lsu_stb_ctl.v
wire [2:0]              stb_pcx_rptr3;          // From stb_ctl3 of lsu_stb_ctl.v
wire [3:0]              stb_rd_for_pcx;         // From stb_ctl0 of lsu_stb_ctl.v, ...
wire [44:0]             stb_rdata_ramc;         // From stb_cam of bw_r_scm.v
wire [14:9]             stb_rdata_ramc_buf;     // From dcdp of lsu_dcdp.v
wire                    stb_rdata_ramd_b74_buf; // From stb_rwdp of lsu_stb_rwdp.v
wire [69:0]             stb_rdata_ramd_buf;     // From stb_rwdp of lsu_stb_rwdp.v
wire [7:0]              stb_state_ced0;         // From stb_ctl0 of lsu_stb_ctl.v
wire [7:0]              stb_state_ced1;         // From stb_ctl1 of lsu_stb_ctl.v
wire [7:0]              stb_state_ced2;         // From stb_ctl2 of lsu_stb_ctl.v
wire [7:0]              stb_state_ced3;         // From stb_ctl3 of lsu_stb_ctl.v
wire [7:0]              stb_state_vld0;         // From stb_ctl0 of lsu_stb_ctl.v
wire [7:0]              stb_state_vld1;         // From stb_ctl1 of lsu_stb_ctl.v
wire [7:0]              stb_state_vld2;         // From stb_ctl2 of lsu_stb_ctl.v
wire [7:0]              stb_state_vld3;         // From stb_ctl3 of lsu_stb_ctl.v
wire [3:0]              stb_thrd_en_g;          // From stb_rwctl of lsu_stb_rwctl.v
wire [2:0]              stb_wrptr0;             // From stb_ctl0 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr0_prev;        // From stb_ctl0 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr1;             // From stb_ctl1 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr1_prev;        // From stb_ctl1 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr2;             // From stb_ctl2 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr2_prev;        // From stb_ctl2 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr3;             // From stb_ctl3 of lsu_stb_ctl.v
wire [2:0]              stb_wrptr3_prev;        // From stb_ctl3 of lsu_stb_ctl.v
wire                    strm_asi_m;             // From dctl of lsu_dctl.v
wire                    tag_rd_vld_g;           // From dctl of lsu_dctl.v
wire                    thread0_ctxt;           // From dctl of lsu_dctl.v
wire                    thread0_d;              // From dctl of lsu_dctl.v
wire                    thread0_e;              // From dctl of lsu_dctl.v
wire                    thread0_g;              // From dctl of lsu_dctl.v
wire                    thread0_m;              // From dctl of lsu_dctl.v
wire                    thread1_ctxt;           // From dctl of lsu_dctl.v
wire                    thread1_d;              // From dctl of lsu_dctl.v
wire                    thread1_e;              // From dctl of lsu_dctl.v
wire                    thread1_g;              // From dctl of lsu_dctl.v
wire                    thread1_m;              // From dctl of lsu_dctl.v
wire                    thread2_ctxt;           // From dctl of lsu_dctl.v
wire                    thread2_d;              // From dctl of lsu_dctl.v
wire                    thread2_e;              // From dctl of lsu_dctl.v
wire                    thread2_g;              // From dctl of lsu_dctl.v
wire                    thread2_m;              // From dctl of lsu_dctl.v
wire                    thread3_ctxt;           // From dctl of lsu_dctl.v
wire                    thread3_d;              // From dctl of lsu_dctl.v
wire                    thread3_e;              // From dctl of lsu_dctl.v
wire                    thread3_g;              // From dctl of lsu_dctl.v
wire                    thread3_m;              // From dctl of lsu_dctl.v
wire                    thread_actxt;           // From dctl of lsu_dctl.v
wire                    thread_default;         // From dctl of lsu_dctl.v
wire                    thread_pctxt;           // From dctl of lsu_dctl.v
wire                    thread_sctxt;           // From dctl of lsu_dctl.v
wire                    tlb_access_en0_g;       // From dctl of lsu_dctl.v
wire                    tlb_access_en1_g;       // From dctl of lsu_dctl.v
wire                    tlb_access_en2_g;       // From dctl of lsu_dctl.v
wire                    tlb_access_en3_g;       // From dctl of lsu_dctl.v
wire                    tlb_access_sel_default; // From dctl of lsu_dctl.v
wire                    tlb_access_sel_thrd0;   // From dctl of lsu_dctl.v
wire                    tlb_access_sel_thrd1;   // From dctl of lsu_dctl.v
wire                    tlb_access_sel_thrd2;   // From dctl of lsu_dctl.v
wire                    tlb_cam_hit;            // From dtlb of bw_r_tlb.v
wire                    tlb_cam_hit_g;          // From dctl of lsu_dctl.v
wire [12:0]             tlb_ctxt;               // From dctldp of lsu_dctldp.v
wire                    tlb_ldst_cam_vld;       // From dctl of lsu_dctl.v
wire [39:10]            tlb_pgnum;              // From dtlb of bw_r_tlb.v
wire [39:10]            tlb_pgnum_buf;          // From tlbdp of lsu_tlbdp.v
wire [39:37]            tlb_pgnum_buf2;         // From tlbdp of lsu_tlbdp.v
wire [39:10]            tlb_pgnum_crit;         // From dtlb of bw_r_tlb.v
wire [42:0]             tlb_rd_tte_data;        // From dtlb of bw_r_tlb.v
wire                    tlb_rd_tte_data_ie_buf; // From tlbdp of lsu_tlbdp.v
wire [58:0]             tlb_rd_tte_tag;         // From dtlb of bw_r_tlb.v
wire                    tlu_lsu_asi_update_g;   // From dctl of lsu_dctl.v
wire                    tte_data_parity_error;  // From tlbdp of lsu_tlbdp.v
wire                    tte_data_perror_unc;    // From excpctl of lsu_excpctl.v
wire                    tte_tag_parity_error;   // From tlbdp of lsu_tlbdp.v
wire                    unimp_asi_m;            // From dctl of lsu_dctl.v
wire                    va_wtchpt_cmp_en_m;     // From dctl of lsu_dctl.v
wire                    va_wtchpt_msk_match_m;  // From dctldp of lsu_dctldp.v
wire                    wr_only_asi_m;          // From dctl of lsu_dctl.v
wire                    wr_only_ltlb_asi_e;     // From dctl of lsu_dctl.v
// End of automatics

wire stb_ncache_pcx_rq_g;


wire [32:0]         tlb_rd_tte_csm;
wire [32:0]         tlb_rd_tte_csm_crit;
wire [32:0]         lsu_blkst_csm_m;
wire [32:0]         stb_rcsm_ramc;
wire [32:0]         stb_cam_csm;
wire [32:0]         stb_alt_wr_csm;
wire                    lsu_tlb_csm_rd_vld_g;
wire                    csm_rd_vld_g;
wire                    lsu_dtlb_csm_rd_e;



//split bus. emacs cannot handle
input [145-1:0]  cpx_spc_data_cx;   // cpx to processor pkt
input [124-1:0]  spu_lsu_ldst_pckt;
input [47:0]            exu_lsu_ldst_va_e;  // VA for mem-ref (src-execute)
input [(6 + 4):3]            exu_lsu_early_va_e;  // early partial VA for lookup
input	[80:0]		ffu_lsu_data ;


output [7:0]            lsu_asi_state;
output [47:4]           lsu_ifu_err_addr;
output [15:0]		lsu_sscan_data ;	// fragmented across dbbs
output                  ifu_tlu_inst_vld_m_bf1;
output [2:0]		lsu_ffu_bld_cnt_w ;

wire [47:0]  lsu_local_ldxa_data_g;
wire [43:0]  lsu_iobrdge_rd_data;
wire [79:0]  stb_rdata_ramd;
wire [75:64]  stb_wdata_ramd_b75_b64;
wire [63:0]   lsu_stb_st_data_g;

wire [151:0] dfq_rdata;
wire [151:0] dfq_wdata;
wire         lsu_cpx_stack_icfill_vld;
wire [(29+1)-1:0]  dtag_wdata_m;
wire [(29+1)-1:0]  dtag_wdata_e;
   wire      lsu_cpx_stack_dcfill_vld_b130;
   wire [7:0] stb_ldst_byte_msk_min;

// scan chain
input                   si0,si1,short_si1,short_si0;
output                  so0, so1,short_so0,short_so1;
   wire     short_scan1_1;
   wire     short_scan1_2;
   wire     short_scan1_3;
   wire     short_scan1_4;
   wire     short_scan1_5;
   wire     short_scan1_6;
   wire     short_scan1_7;
   wire     short_scan1_8;

   wire     short_scan0_1;
   wire     short_scan0_2;
   wire     short_scan0_3;
   wire     short_scan0_4;
   wire     short_scan0_5;
   wire     short_scan0_6;
   wire     short_scan0_7;
   wire     short_scan0_8;
   wire     short_scan0_9;

   wire     scan1_1;
   wire     scan1_2;
   wire     scan1_3;
   wire     scan1_4;

   wire     scan0_1;
   wire     scan0_2;

/*defined input*/

input [7:0]            exu_tlu_wsr_data_m;

/*defined output*/

output                  lsu_tlu_nucleus_ctxt_m ;// access is nucleus context //??no driver
output  [2:0]           lsu_tlu_tte_pg_sz_g ;   // page-size of tte //??no driver


// dsfsr support moved from tlu_tcl to lsu_excpctl ; becomes wire
// !! first check if needed by iside in tlu_tcl, or mmu_ctl !!!
//output			lsu_tlu_nonalt_ldst_m;	// From dctl of lsu_dctl.v
output			lsu_tlu_squash_va_oor_m;// From dctl of lsu_dctl.v
output			lsu_tlu_wtchpt_trp_g;	// From excpctl of lsu_excpctl.v
//output			lsu_tlu_priv_violtn_g;	// From excpctl of lsu_excpctl.v
output			lsu_tlu_daccess_prot_g;	// From excpctl of lsu_excpctl.v
output			lsu_tlu_priv_action_g;	// From excpctl of lsu_excpctl.v
// To accommodate 1Thread design
wire [3:0] 		lsu_tlu_stb_full_w2_t;  // To accommodate 1T design
   wire [7:0]		lsu_asi_reg0_t;
   wire [7:0]		lsu_asi_reg1_t;
   wire [7:0]		lsu_asi_reg2_t;
   wire [7:0]		lsu_asi_reg3_t;
   wire [12:0] 		lsu_t0_pctxt_state_t;
   wire [12:0] 		lsu_t1_pctxt_state_t;
   wire [12:0] 		lsu_t2_pctxt_state_t;
   wire [12:0] 		lsu_t3_pctxt_state_t;
   wire [2:0] 		lsu_pid_state0_t;
   wire [2:0] 		lsu_pid_state1_t;
   wire [2:0] 		lsu_pid_state2_t;
   wire [2:0] 		lsu_pid_state3_t;

 // Use two threads unless this is defined

   assign       lsu_tlu_stb_full_w2[3:0] = {2'b00, lsu_tlu_stb_full_w2_t[1:0]};
   assign       lsu_asi_reg0[7:0] = lsu_asi_reg0_t[7:0];
   assign       lsu_asi_reg1[7:0] = lsu_asi_reg1_t[7:0];
   assign       lsu_asi_reg2[7:0] = 7'b0000000;
   assign       lsu_asi_reg3[7:0] = 7'b0000000;
   assign       lsu_t0_pctxt_state[12:0] = lsu_t0_pctxt_state_t[12:0];
   assign       lsu_t1_pctxt_state[12:0] = lsu_t1_pctxt_state_t[12:0];
   assign       lsu_t2_pctxt_state[12:0] = 13'b0000000000000;
   assign       lsu_t3_pctxt_state[12:0] = 13'b0000000000000;
   assign       lsu_pid_state0[2:0] = lsu_pid_state0_t[2:0];
   assign       lsu_pid_state1[2:0] = lsu_pid_state1_t[2:0];
   assign       lsu_pid_state2[2:0] = 2'b00;
   assign       lsu_pid_state3[2:0] = 2'b00;



















































































 // `ifndef CONFIG_NUM_THREADS

/* lsu_qctl1 AUTO_TEMPLATE (
                .grst_l                 (gdbginit_l),
                .rst_tri_en             (mux_drive_disable),
                .lsu_ttype_vld_m2       (lsu_ttype_vld_m2_bf1),
                .lsu_ldst_va_m          (lsu_ldst_va_m_buf[7:6]),
                .ifu_lsu_pcxpkt_e_b50   (ifu_lsu_pcxpkt_e[50]),
                .rclk                   (clk),
                .lsu_sscan_data		(lsu_sscan_data[12:0]),
                .ld_inst_vld_e          (ifu_lsu_ld_inst_e),
                .lsu_ld_miss_g          (lsu_ld_miss_wb),
                .spu_lsu_ldst_pckt_vld  (spu_lsu_ldst_pckt[`PCX_VLD]),
                .lsu_stb_empty        	(lsu_stb_empty_buf[3:0]),
                .tlb_pgnum_g            (tlb_pgnum_buf[39:37]),
                .tlu_lsu_pcxpkt_l2baddr (tlu_lsu_pcxpkt[11:10]),
                .tlu_lsu_pcxpkt_tid     (tlu_lsu_pcxpkt[19:18]),
                .tlu_lsu_pcxpkt_vld     (tlu_lsu_pcxpkt[25]),
                .ld_thrd_byp_sel_e      (lsu_ld_thrd_byp_sel_e[2:0]));
*/

 // Use two threads unless this is defined

   lsu_qctl1 qctl1  (
                  .so                   (short_scan1_1),
                  .si                   (short_si1),
                  /*AUTOINST*/
                  // Outputs
                  .lsu_bld_helper_cmplt_m(lsu_bld_helper_cmplt_m),
                  .lsu_bld_cnt_m        (lsu_bld_cnt_m[2:0]),
                  .lsu_bld_reset        (lsu_bld_reset),
                  .lsu_pcx_rq_sz_b3     (lsu_pcx_rq_sz_b3),
                  .lsu_ramtest_rd_w     (lsu_ramtest_rd_w),
                  .ld_stb_full_raw_w2   (ld_stb_full_raw_w2),
                  .lsu_ld_pcx_rq_sel_d2 (lsu_ld_pcx_rq_sel_d2[3:0]),
                  .spc_pcx_req_pq       (spc_pcx_req_pq[4:0]),
                  .spc_pcx_atom_pq      (spc_pcx_atom_pq),
                  .lsu_ifu_pcxpkt_ack_d (lsu_ifu_pcxpkt_ack_d),
                  .pcx_pkt_src_sel      (pcx_pkt_src_sel[3:0]),
                  .lmq_enable           (lmq_enable[3:0]),
                  .imiss_pcx_mx_sel     (imiss_pcx_mx_sel),
                  .fwd_int_fp_pcx_mx_sel(fwd_int_fp_pcx_mx_sel[2:0]),
                  .lsu_ffu_bld_cnt_w    (lsu_ffu_bld_cnt_w[2:0]),
                  .lsu_ld_pcx_rq_mxsel  (lsu_ld_pcx_rq_mxsel[3:0]),
                  .ld_pcx_thrd          (ld_pcx_thrd[1:0]),
                  .lsu_spu_ldst_ack     (lsu_spu_ldst_ack),
                  .pcx_rq_for_stb       (pcx_rq_for_stb[3:0]),
                  .pcx_rq_for_stb_d1    (pcx_rq_for_stb_d1[3:0]),
                  .lsu_ffu_ack          (lsu_ffu_ack),
                  .lsu_ifu_ld_pcxpkt_vld(lsu_ifu_ld_pcxpkt_vld),
                  .lsu_pcx_req_squash0  (lsu_pcx_req_squash0),
                  .lsu_pcx_req_squash1  (lsu_pcx_req_squash1),
                  .lsu_pcx_req_squash2  (lsu_pcx_req_squash2),
                  .lsu_pcx_req_squash3  (lsu_pcx_req_squash3),
                  .lsu_pcx_req_squash_d1(lsu_pcx_req_squash_d1),
                  .lsu_pcx_ld_dtag_perror_w2(lsu_pcx_ld_dtag_perror_w2),
                  .lsu_tlu_dcache_miss_w2(lsu_tlu_dcache_miss_w2[3:0]),
                  .lsu_bld_pcx_rq       (lsu_bld_pcx_rq),
                  .lsu_bld_rq_addr      (lsu_bld_rq_addr[1:0]),
                  .lsu_fwdpkt_pcx_rq_sel(lsu_fwdpkt_pcx_rq_sel),
                  .lsu_imiss_pcx_rq_sel_d1(lsu_imiss_pcx_rq_sel_d1),
                  .lsu_tlu_pcxpkt_ack   (lsu_tlu_pcxpkt_ack),
                  .lsu_intrpt_cmplt     (lsu_intrpt_cmplt[3:0]),
                  .lsu_lmq_byp_misc_sel (lsu_lmq_byp_misc_sel[3:0]),
                  .lsu_sscan_data       (lsu_sscan_data[12:0]),  // Templated
                  .lsu_dfq_byp_tid_d1_sel(lsu_dfq_byp_tid_d1_sel[3:0]),
                  .lmq0_pcx_pkt_way     (lmq0_pcx_pkt_way[2-1:0]),
                  .lmq1_pcx_pkt_way     (lmq1_pcx_pkt_way[2-1:0]),
                  .lmq2_pcx_pkt_way     (),
                  .lmq3_pcx_pkt_way     (),
                  .lsu_st_pcx_rq_pick   (lsu_st_pcx_rq_pick[3:0]),
                  .lsu_stb_pcx_rvld_d1  (lsu_stb_pcx_rvld_d1),
                  .lsu_stb_rd_tid       (lsu_stb_rd_tid[1:0]),
                  .lsu_ld0_spec_vld_kill_w2(lsu_ld0_spec_vld_kill_w2),
                  .lsu_ld1_spec_vld_kill_w2(lsu_ld1_spec_vld_kill_w2),
                  .lsu_ld2_spec_vld_kill_w2(),
                  .lsu_ld3_spec_vld_kill_w2(),
                  .lsu_st_pcx_rq_vld    (lsu_st_pcx_rq_vld),
                  // Inputs
                  .rclk                 (clk),                   // Templated
                  .se                   (se),
                  .sehold               (sehold),
                  .grst_l               (gdbginit_l),            // Templated
                  .arst_l               (arst_l),
                  .lsu_quad_word_access_g(lsu_quad_word_access_g),
                  .pcx_spc_grant_px     (pcx_spc_grant_px[4:0]),
                  .ld_inst_vld_e        (ifu_lsu_ld_inst_e),     // Templated
                  .lsu_ldst_va_m        (lsu_ldst_va_m_buf[7:6]), // Templated
                  .stb0_l2b_addr        (stb0_l2b_addr[2:0]),
                  .stb1_l2b_addr        (stb1_l2b_addr[2:0]),
                  .stb2_l2b_addr        (3'b000),
                  .stb3_l2b_addr        (3'b000),
                  .lsu_ld_miss_g        (lsu_ld_miss_wb),        // Templated
                  .ifu_lsu_ldst_fp_e    (ifu_lsu_ldst_fp_e),
                  .ld_rawp_st_ced_w2    (ld_rawp_st_ced_w2),
                  .ld_rawp_st_ackid_w2  (ld_rawp_st_ackid_w2[2:0]),
                  .stb0_crnt_ack_id     (stb0_crnt_ack_id[2:0]),
                  .stb1_crnt_ack_id     (stb1_crnt_ack_id[2:0]),
                  .stb2_crnt_ack_id     (3'b000),
                  .stb3_crnt_ack_id     (3'b000),
                  .ifu_tlu_thrid_e      (ifu_tlu_thrid_e[1:0]),
                  .ldxa_internal        (ldxa_internal),
                  .spu_lsu_ldst_pckt    (spu_lsu_ldst_pckt[64+7:64+6]),
                  .spu_lsu_ldst_pckt_vld(spu_lsu_ldst_pckt[123]), // Templated
                  .ifu_tlu_inst_vld_m   (ifu_tlu_inst_vld_m),
                  .ifu_lsu_flush_w      (ifu_lsu_flush_w),
                  .ifu_lsu_casa_e       (ifu_lsu_casa_e),
                  .lsu_ldstub_g         (lsu_ldstub_g),
                  .lsu_swap_g           (lsu_swap_g),
                  .stb0_atm_rq_type     (stb0_atm_rq_type[2:1]),
                  .stb1_atm_rq_type     (stb1_atm_rq_type[2:1]),
                  .stb2_atm_rq_type     (2'b00),
                  .stb3_atm_rq_type     (2'b00),
                  .tlb_pgnum_g          (tlb_pgnum_buf[39:37]),  // Templated
                  .stb_rd_for_pcx       ({2'b00, stb_rd_for_pcx[1:0]}),
                  .ffu_lsu_data         (ffu_lsu_data[80:79]),
                  .ffu_lsu_fpop_rq_vld  (ffu_lsu_fpop_rq_vld),
                  .ifu_lsu_ldst_dbl_e   (ifu_lsu_ldst_dbl_e),
                  .ifu_lsu_pcxreq_d     (ifu_lsu_pcxreq_d),
                  .ifu_lsu_destid_s     (ifu_lsu_destid_s[2:0]),
                  .ifu_lsu_pref_inst_e  (ifu_lsu_pref_inst_e),
                  .tlb_cam_hit_g        (tlb_cam_hit_g),
                  .lsu_blk_asi_m        (lsu_blk_asi_m),
                  .stb_cam_hit_bf       (stb_cam_hit_bf),
                  .lsu_fwdpkt_vld       (lsu_fwdpkt_vld),
                  .lsu_dcfill_active_e  (lsu_dcfill_active_e),
                  .dfq_byp_sel          (dfq_byp_sel[3:0]),
                  .lsu_dfq_ld_vld       (lsu_dfq_ld_vld),
                  .lsu_fldd_vld_en      (lsu_fldd_vld_en),
                  .lsu_dfill_dcd_thrd   (lsu_dfill_dcd_thrd[3:0]),
                  .lsu_fwdpkt_dest      (lsu_fwdpkt_dest[4:0]),
                  .tlu_lsu_pcxpkt_tid   (tlu_lsu_pcxpkt[19:18]), // Templated
                  .lsu_stb_empty        (lsu_stb_empty_buf[3:0]), // Templated
                  .tlu_lsu_pcxpkt_vld   (tlu_lsu_pcxpkt[25]),    // Templated
                  .tlu_lsu_pcxpkt_l2baddr(tlu_lsu_pcxpkt[11:10]), // Templated
                  .ld_sec_hit_thrd0     (ld_sec_hit_thrd0),
                  .ld_sec_hit_thrd1     (ld_sec_hit_thrd1),
                  .ld_sec_hit_thrd2     (1'b0),
                  .ld_sec_hit_thrd3     (1'b0),
                  .ld_thrd_byp_sel_e    (lsu_ld_thrd_byp_sel_e[2:0]), // Templated
                  .lsu_st_pcx_rq_kill_w2({2'b00, lsu_st_pcx_rq_kill_w2[1:0]}),
                  .ifu_lsu_alt_space_e  (ifu_lsu_alt_space_e),
                  .lsu_dfq_byp_tid      (lsu_dfq_byp_tid[1:0]),
                  .dfq_byp_ff_en        (dfq_byp_ff_en),
                  .stb_ld_full_raw      (stb_ld_full_raw[7:0]),
                  .stb_ld_partial_raw   (stb_ld_partial_raw[7:0]),
                  .stb_cam_mhit         (stb_cam_mhit),
                  .lsu_ldquad_inst_m    (lsu_ldquad_inst_m),
                  .stb_cam_wr_no_ivld_m (stb_cam_wr_no_ivld_m),
                  .lsu_ldst_va_way_g    (lsu_ldst_va_way_g[1:0]),
                  .lsu_dcache_rand      (lsu_dcache_rand[1:0]),
                  .lsu_encd_way_hit     (lsu_encd_way_hit[1:0]),
                  .lsu_way_hit_or       (lsu_way_hit_or),
                  .dc_direct_map        (dc_direct_map),
                  .lsu_tlb_perr_ld_rq_kill_w(lsu_tlb_perr_ld_rq_kill_w),
                  .lsu_dcache_tag_perror_g(lsu_dcache_tag_perror_g),
                  .lsu_ld_inst_vld_g    (lsu_ld_inst_vld_g[3:0]),
                  .asi_internal_m       (asi_internal_m),
                  .ifu_lsu_pcxpkt_e_b50 (ifu_lsu_pcxpkt_e[50]),  // Templated
                  .lda_internal_m       (lda_internal_m),
                  .atomic_m             (atomic_m),
                  .lsu_dcache_iob_rd_w  (lsu_dcache_iob_rd_w),
                  .ifu_lsu_fwd_data_vld (ifu_lsu_fwd_data_vld),
                  .rst_tri_en           (mux_drive_disable),     // Templated
                  .lsu_no_spc_pref      (lsu_no_spc_pref[3:0]),
                  .tlu_early_flush_pipe2_w(tlu_early_flush_pipe2_w),
                  .lsu_ttype_vld_m2     (lsu_ttype_vld_m2_bf1));  // Templated





































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/* lsu_qctl2 AUTO_TEMPLATE (
                .rst_tri_en             (mux_drive_disable),
                .rclk                    (clk),
                .lsu_dfq_rdata_b103      (dfq_rdata[103]),
                .lsu_dfq_rdata_rq_type   (dfq_rdata[`CPX_WIDTH-2:`CPX_WIDTH-5]),
                .lsu_dfq_rdata_type      (dfq_rdata[`DFQ_WIDTH-1:`DFQ_WIDTH-6]),
                .lsu_dfq_rdata_invwy_vld (dfq_rdata[`CPX_WYVLD]),
                .lsu_dfq_rdata_cpuid     (dfq_rdata[`CPX_INV_CID_HI:`CPX_INV_CID_LO]),
                .lsu_dfq_rdata_stack_iinv_vld(dfq_rdata[128]),
                .lsu_dfq_rdata_st_ack_type(dfq_rdata[`DFQ_WIDTH-4]),
                .lsu_dfq_rdata_stack_dcfill_vld(dfq_rdata[130]),
                .lsu_ifill_pkt_vld      (lsu_ifu_cpxpkt_vld_i1),
                .lsu_dfq_vld_entry_w 	(lsu_sscan_data[15]),
                .ifu_pcx_pkt_b10t5      (ifu_lsu_pcxpkt_e[10:5]),
                .ifu_pcx_pkt_b41t40     (ifu_lsu_pcxpkt_e[41:40]),
                .ifu_pcx_pkt_b51        (ifu_lsu_pcxpkt_e[51]),
                .ld_inst_vld_e          (ifu_lsu_ld_inst_e),
                .lsu_l2fill_fpld_e      (lsu_l2fill_fpld_e),
                .lsu_dfq_rdata_flush_bit (dfq_rdata[136]),
                .lsu_dfq_rdata_b17_b0    (dfq_rdata[17:0]),
                .lsu_ld_miss_g          (lsu_ld_miss_wb));
*/

 // Use two threads unless this is defined

   lsu_qctl2 qctl2  (
                  .so                   (scan1_1),
                  .si                   (si1),
                  .lsu_cpx_stack_dcfill_vld_b130  (lsu_cpx_stack_dcfill_vld_b130),

                  .cpx_spc_data_cx_b144to140  (cpx_spc_data_cx[145-1:140]),
                  .cpx_spc_data_cx_b138       (cpx_spc_data_cx[138]),
                  .cpx_spc_data_cx_b135to134  (cpx_spc_data_cx[135:134]),
                  .cpx_spc_data_cx_b133       (cpx_spc_data_cx[133]),
                  .cpx_spc_data_cx_b130       (cpx_spc_data_cx[130]),
                  .cpx_spc_data_cx_b129       (cpx_spc_data_cx[129]),
                  .cpx_spc_data_cx_b128       (cpx_spc_data_cx[128]),
                  .cpx_spc_data_cx_b125       (cpx_spc_data_cx[125]),
                  .cpx_spc_data_cx_b124to123  (cpx_spc_data_cx[123+1:123]),
                  .cpx_spc_data_cx_b120to118  (cpx_spc_data_cx[120:118]),
                  .cpx_spc_data_cx_b71to70    (cpx_spc_data_cx[71:70]),

                  .cpx_spc_data_cx_dcache_inval_val(cpx_spc_data_cx[0]),
                  .cpx_spc_data_cx_icache_inval_val(cpx_spc_data_cx[1]),

                  // .cpx_spc_data_cx_b0         (cpx_spc_data_cx[0]),
                  // .cpx_spc_data_cx_b4         (cpx_spc_data_cx[4]),
                  // .cpx_spc_data_cx_b8         (cpx_spc_data_cx[8]),
                  // .cpx_spc_data_cx_b12        (cpx_spc_data_cx[12]),
                  // .cpx_spc_data_cx_b16        (cpx_spc_data_cx[16]),
                  // .cpx_spc_data_cx_b20        (cpx_spc_data_cx[20]),
                  // .cpx_spc_data_cx_b24        (cpx_spc_data_cx[24]),
                  // .cpx_spc_data_cx_b28        (cpx_spc_data_cx[28]),
                  // .cpx_spc_data_cx_b32        (cpx_spc_data_cx[32]),
                  // .cpx_spc_data_cx_b35        (cpx_spc_data_cx[35]),
                  // .cpx_spc_data_cx_b38        (cpx_spc_data_cx[38]),
                  // .cpx_spc_data_cx_b41        (cpx_spc_data_cx[41]),
                  // .cpx_spc_data_cx_b44        (cpx_spc_data_cx[44]),
                  // .cpx_spc_data_cx_b47        (cpx_spc_data_cx[47]),
                  // .cpx_spc_data_cx_b50        (cpx_spc_data_cx[50]),
                  // .cpx_spc_data_cx_b53        (cpx_spc_data_cx[53]),
                  // .cpx_spc_data_cx_b56        (cpx_spc_data_cx[56]),
                  // .cpx_spc_data_cx_b60        (cpx_spc_data_cx[60]),
                  // .cpx_spc_data_cx_b64        (cpx_spc_data_cx[64]),
                  // .cpx_spc_data_cx_b68        (cpx_spc_data_cx[68]),
                  // .cpx_spc_data_cx_b72        (cpx_spc_data_cx[72]),
                  // .cpx_spc_data_cx_b76        (cpx_spc_data_cx[76]),
                  // .cpx_spc_data_cx_b80        (cpx_spc_data_cx[80]),
                  // .cpx_spc_data_cx_b84        (cpx_spc_data_cx[84]),
                  // .cpx_spc_data_cx_b88        (cpx_spc_data_cx[88]),
                  // .cpx_spc_data_cx_b91        (cpx_spc_data_cx[91]),
                  // .cpx_spc_data_cx_b94        (cpx_spc_data_cx[94]),
                  // .cpx_spc_data_cx_b97        (cpx_spc_data_cx[97]),
                  // .cpx_spc_data_cx_b100       (cpx_spc_data_cx[100]),
                  .cpx_spc_data_cx_b103       (cpx_spc_data_cx[103]),
                  // .cpx_spc_data_cx_b106       (cpx_spc_data_cx[106]),
                  // .cpx_spc_data_cx_b109       (cpx_spc_data_cx[109]),
                  // .cpx_spc_data_cx_b1         (cpx_spc_data_cx[1]),
                  // .cpx_spc_data_cx_b5         (cpx_spc_data_cx[5]),
                  // .cpx_spc_data_cx_b9         (cpx_spc_data_cx[9]),
                  // .cpx_spc_data_cx_b13        (cpx_spc_data_cx[13]),
                  // .cpx_spc_data_cx_b17        (cpx_spc_data_cx[17]),
                  // .cpx_spc_data_cx_b21        (cpx_spc_data_cx[21]),
                  // .cpx_spc_data_cx_b25        (cpx_spc_data_cx[25]),
                  // .cpx_spc_data_cx_b29        (cpx_spc_data_cx[29]),
                  // .cpx_spc_data_cx_b57        (cpx_spc_data_cx[57]),
                  // .cpx_spc_data_cx_b61        (cpx_spc_data_cx[61]),
                  // .cpx_spc_data_cx_b65        (cpx_spc_data_cx[65]),
                  // .cpx_spc_data_cx_b69        (cpx_spc_data_cx[69]),
                  // .cpx_spc_data_cx_b73        (cpx_spc_data_cx[73]),
                  // .cpx_spc_data_cx_b77        (cpx_spc_data_cx[77]),
                  // .cpx_spc_data_cx_b81        (cpx_spc_data_cx[81]),
                  // .cpx_spc_data_cx_b85        (cpx_spc_data_cx[85]),

          .lsu_cpx_stack_icfill_vld(lsu_cpx_stack_icfill_vld),
                  /*AUTOINST*/
                  // Outputs
                  .lsu_fwd_rply_sz1_unc (lsu_fwd_rply_sz1_unc),
                  .lsu_dcache_iob_rd_w  (lsu_dcache_iob_rd_w),
                  .ldd_in_dfq_out       (ldd_in_dfq_out),
                  .lsu_dfq_rd_vld_d1    (lsu_dfq_rd_vld_d1),
                  .dfq_byp_ff_en        (dfq_byp_ff_en),
                  .lsu_dfill_data_sel_hi(lsu_dfill_data_sel_hi),
                  .lsu_ifill_pkt_vld    (lsu_ifu_cpxpkt_vld_i1), // Templated
                  .cpx_fwd_pkt_en_cx    (cpx_fwd_pkt_en_cx),
                  .lsu_cpxpkt_type_dcd_cx(lsu_cpxpkt_type_dcd_cx[5:0]),
                  .lsu_cpu_dcd_sel      (lsu_cpu_dcd_sel[7:0]),
                  .lsu_cpu_uhlf_sel     (lsu_cpu_uhlf_sel),
                  .lsu_iobrdge_rply_data_sel(lsu_iobrdge_rply_data_sel[2:0]),
                  .lsu_iobrdge_fwd_pkt_vld(lsu_iobrdge_fwd_pkt_vld),
                  .lsu_tlu_cpx_vld      (lsu_tlu_cpx_vld),
                  .lsu_tlu_cpx_req      (lsu_tlu_cpx_req[3:0]),
                  .lsu_tlu_intpkt       (lsu_tlu_intpkt[17:0]),
                  .ld_sec_active        (ld_sec_active),
                  .dfq_byp_sel          (dfq_byp_sel[3:0]),
                  .lsu_cpx_ld_dtag_perror_e(lsu_cpx_ld_dtag_perror_e),
                  .lsu_cpx_ld_dcache_perror_e(lsu_cpx_ld_dcache_perror_e),
                  .lsu_exu_rd_m         (lsu_exu_rd_m[4:0]),
                  .lsu_spu_strm_ack_cmplt(lsu_spu_strm_ack_cmplt[1:0]),
                  .lsu_atm_st_cmplt_e   (lsu_atm_st_cmplt_e),
                  .dva_svld_e           (dva_svld_e),
                  .dfq_wptr_vld         (dfq_wptr_vld),
                  .dfq_wptr             (dfq_wptr[4:0]),
                  .lsu_dfq_flsh_cmplt   (lsu_dfq_flsh_cmplt[3:0]),
                  .dfq_rptr_vld         (dfq_rptr_vld),
                  .dfq_rptr             (dfq_rptr[4:0]),
                  .lsu_ifu_stallreq     (lsu_ifu_stallreq),
                  .dva_snp_addr_e       (dva_snp_addr_e[(6 + 4)-6:0]),
                  .lsu_st_ack_dq_stb    (lsu_st_ack_dq_stb[3:0]),
                  .lsu_cpx_rmo_st_ack   (lsu_cpx_rmo_st_ack[3:0]),
                  .lsu_st_wr_dcache     (lsu_st_wr_dcache),
                  .cpx_st_ack_tid0      (cpx_st_ack_tid0),
                  .cpx_st_ack_tid1      (cpx_st_ack_tid1),
                  .cpx_st_ack_tid2      (),
                  .cpx_st_ack_tid3      (),
                  .lsu_tlu_l2_dmiss     (lsu_tlu_l2_dmiss[3:0]),
                  .lsu_l2fill_vld       (lsu_l2fill_vld),
                  .lsu_byp_ldd_oddrd_m  (lsu_byp_ldd_oddrd_m),
                  .lsu_pcx_fwd_reply    (lsu_pcx_fwd_reply),
                  .lsu_fwdpkt_vld       (lsu_fwdpkt_vld),
                  .lsu_dcfill_active_e  (lsu_dcfill_active_e),
                  .lsu_dfq_ld_vld       (lsu_dfq_ld_vld),
                  .lsu_fldd_vld_en      (lsu_fldd_vld_en),
                  .lsu_dfill_dcd_thrd   (lsu_dfill_dcd_thrd[3:0]),
                  .lsu_fwdpkt_dest      (lsu_fwdpkt_dest[4:0]),
                  .dva_snp_bit_wr_en_e  (dva_snp_bit_wr_en_e[(4*4-1):0]),
                  .lsu_cpx_spc_inv_vld  (lsu_cpx_spc_inv_vld),
                  .lsu_cpx_thrdid       (lsu_cpx_thrdid[3:0]),
                  .lsu_cpx_stack_dcfill_vld(lsu_cpx_stack_dcfill_vld),
                  .lsu_dfq_vld_entry_w  (lsu_sscan_data[15]),    // Templated
                  .lsu_dfq_st_vld       (lsu_dfq_st_vld),
                  .lsu_dfq_ldst_vld     (lsu_dfq_ldst_vld),
                  .lsu_qdp2_dfq_ld_vld  (lsu_qdp2_dfq_ld_vld),
                  .lsu_qdp2_dfq_st_vld  (lsu_qdp2_dfq_st_vld),
                  .lsu_dfq_vld          (lsu_dfq_vld),
                  .lsu_dfq_byp_ff_en    (lsu_dfq_byp_ff_en),
                  // Inputs
                  .rclk                 (clk),                   // Templated
                  .grst_l               (grst_l),
                  .arst_l               (arst_l),
                  .se                   (se),
                  .rst_tri_en           (mux_drive_disable),     // Templated
                  .ld_inst_vld_e        (ifu_lsu_ld_inst_e),     // Templated
                  .ifu_pcx_pkt_b51      (ifu_lsu_pcxpkt_e[51]),  // Templated
                  .ifu_pcx_pkt_b41t40   (ifu_lsu_pcxpkt_e[41:40]), // Templated
                  .ifu_pcx_pkt_b10t5    (ifu_lsu_pcxpkt_e[10:5]), // Templated
                  .lsu_dfq_rdata_flush_bit(dfq_rdata[136]),      // Templated
                  .lsu_dfq_rdata_b17_b0 (dfq_rdata[17:0]),       // Templated
                  .ifu_lsu_rd_e         (ifu_lsu_rd_e[4:0]),
                  .lmq_ld_rd1           (lmq_ld_rd1[4:0]),
                  .lmq_ldd_vld          (lmq_ldd_vld),
                  .dfq_tid              (dfq_tid[1:0]),
                  .const_cpuid          (const_cpuid[2:0]),
                  .lmq_ld_addr_b3       (lmq_ld_addr_b3),
                  .ifu_lsu_ibuf_busy    (ifu_lsu_ibuf_busy),
                  .ifu_lsu_inv_clear    (ifu_lsu_inv_clear),
                  .lsu_byp_misc_sz_e    (lsu_byp_misc_sz_e[1:0]),
                  .lsu_dfq_byp_tid      (lsu_dfq_byp_tid[1:0]),
                  .lsu_cpx_pkt_atm_st_cmplt(lsu_cpx_pkt_atm_st_cmplt),
                  .lsu_cpx_pkt_l2miss   (lsu_cpx_pkt_l2miss),
                  .lsu_cpx_pkt_tid      (lsu_cpx_pkt_tid[1:0]),
                  .lsu_cpx_pkt_invwy    (lsu_cpx_pkt_invwy[2-1:0]),
                  .lsu_dfq_byp_flush    (lsu_dfq_byp_flush),
                  .lsu_dfq_byp_type     (lsu_dfq_byp_type[5:0]),
                  .lsu_dfq_byp_invwy_vld(lsu_dfq_byp_invwy_vld),
                  //.lsu_cpu_inv_data_b13to9(lsu_cpu_inv_data_b13to9[13:9]),
                  //.lsu_cpu_inv_data_b7to2(lsu_cpu_inv_data_b7to2[7:2]),
                  //.lsu_cpu_inv_data_b0  (lsu_cpu_inv_data_b0),
                  .lsu_cpu_inv_data_val          (lsu_cpu_inv_data_val),
                  .lsu_cpu_inv_data_way          (lsu_cpu_inv_data_way),
                  .lsu_cpx_pkt_inv_pa   (lsu_cpx_pkt_inv_pa[(6 + 4)-6:0]),
                  .lsu_cpx_pkt_ifill_type(lsu_cpx_pkt_ifill_type),
                  .lsu_cpx_pkt_atomic   (lsu_cpx_pkt_atomic),
                  .lsu_cpx_pkt_binit_st (lsu_cpx_pkt_binit_st),
                  .lsu_cpx_pkt_prefetch (lsu_cpx_pkt_prefetch),
                  .lsu_dfq_byp_binit_st (lsu_dfq_byp_binit_st),
                  .lsu_tlbop_force_swo  (lsu_tlbop_force_swo),
                  .lsu_iobrdge_tap_rq_type(lsu_iobrdge_tap_rq_type[7:3]),
                  .lsu_dcache_tag_perror_g(lsu_dcache_tag_perror_g),
                  .lsu_dcache_data_perror_g(lsu_dcache_data_perror_g),
                  .lsu_cpx_pkt_perror_iinv(lsu_cpx_pkt_perror_iinv),
                  .lsu_cpx_pkt_perror_dinv(lsu_cpx_pkt_perror_dinv),
                  .lsu_cpx_pkt_perror_set(lsu_cpx_pkt_perror_set[1:0]),
                  .lsu_l2fill_fpld_e    (lsu_l2fill_fpld_e),     // Templated
                  .lsu_cpx_pkt_strm_ack (lsu_cpx_pkt_strm_ack),
                  .ifu_lsu_memref_d     (ifu_lsu_memref_d),
                  .lsu_fwdpkt_pcx_rq_sel(lsu_fwdpkt_pcx_rq_sel),
                  .lsu_imiss_pcx_rq_sel_d1(lsu_imiss_pcx_rq_sel_d1),
                  .lsu_dfq_byp_cpx_inv  (lsu_dfq_byp_cpx_inv),
                  .lsu_dfq_byp_stack_adr_b54(lsu_dfq_byp_stack_adr_b54[1:0]),
                  .lsu_dfq_byp_stack_wrway(lsu_dfq_byp_stack_wrway[1:0]),
                  .lsu_dfq_rdata_st_ack_type(dfq_rdata[151-4]), // Templated
                  .lsu_dfq_rdata_stack_dcfill_vld(dfq_rdata[130]), // Templated
                  .lsu_dfq_rdata_stack_iinv_vld(dfq_rdata[128]), // Templated
                  .lsu_dfq_rdata_cpuid  (dfq_rdata[120:118]), // Templated
                  .lsu_dfq_byp_atm      (lsu_dfq_byp_atm),
                  .lsu_ld_inst_vld_g    (lsu_ld_inst_vld_g[3:0]),
                  .lsu_dfq_rdata_type   (dfq_rdata[151-1:151-6]), // Templated
                  .lsu_dfq_rdata_invwy_vld(dfq_rdata[133]), // Templated
                  .ifu_lsu_fwd_data_vld (ifu_lsu_fwd_data_vld),
                  .ifu_lsu_fwd_wr_ack   (ifu_lsu_fwd_wr_ack),
                  .lsu_dfq_rdata_rq_type(dfq_rdata[145-2:145-5]), // Templated
                  .lsu_dfq_rdata_b103   (dfq_rdata[103]),        // Templated
                  .sehold               (sehold));























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*   cmp_sram_redhdr AUTO_TEMPLATE(
                            .fuse_ary_wren(fuse_dcd_wren),
                            .fuse_ary_rid(fuse_dcd_rid[5:0]),
                            .fuse_ary_repair_value(fuse_dcd_repair_value[7:0]),
                            .fuse_ary_repair_en(fuse_dcd_repair_en[1:0]),
                            .spc_efc_xfuse_data(spc_efc_dfuse_data),

                            .efc_spc_xfuse_data(efc_spc_dfuse_data),
                            .efc_spc_xfuse_ashift(efc_spc_dfuse_ashift),
                            .efc_spc_xfuse_dshift(efc_spc_dfuse_dshift),
                            .ary_fuse_repair_value(dcd_fuse_repair_value[7:0]),
                            .ary_fuse_repair_en(dcd_fuse_repair_en[1:0]),
                            .scanin   (si0),
                            .rclk     (clk));
 */

// cmp_sram_redhdr dcdhdr(
//                        .scanout         (scan0_1),
//                        /*AUTOINST*/
//                        // Outputs
//                        .fuse_ary_wren   (fuse_dcd_wren),         // Templated
//                        .fuse_ary_rid    (fuse_dcd_rid[5:0]),     // Templated
//                        .fuse_ary_repair_value(fuse_dcd_repair_value[7:0]), // Templated
//                        .fuse_ary_repair_en(fuse_dcd_repair_en[1:0]), // Templated
//                        .spc_efc_xfuse_data(spc_efc_dfuse_data),  // Templated
//                        // Inputs
//                        .rclk            (clk),                   // Templated
//                        .se              (se),
//                        .scanin          (si0),                   // Templated
//                        .arst_l          (arst_l),
//                        .testmode_l      (testmode_l),
//                        .efc_spc_fuse_clk1(efc_spc_fuse_clk1),
//                        .efc_spc_fuse_clk2(efc_spc_fuse_clk2),
//                        .efc_spc_xfuse_data(efc_spc_dfuse_data),  // Templated
//                        .efc_spc_xfuse_ashift(efc_spc_dfuse_ashift), // Templated
//                        .efc_spc_xfuse_dshift(efc_spc_dfuse_dshift), // Templated
//                        .ary_fuse_repair_value(dcd_fuse_repair_value[7:0]), // Templated
//                        .ary_fuse_repair_en(dcd_fuse_repair_en[1:0])); // Templated
/* bw_r_dcd  AUTO_TEMPLATE (
                   .rst_tri_en           (mem_write_disable),
                   //.sehold               (),
                   .rclk                 (clk),
                   .dcache_alt_addr_e    (lsu_dcache_fill_addr_e[`L1D_ADDRESS_HI:3]),
                   .dcache_alt_rsel_way_e(lsu_bist_rsel_way_e[`L1D_WAY_COUNT-1:0]),
                   .dcache_rd_addr_e     (exu_lsu_early_va_e[`L1D_ADDRESS_HI:3]),
                   .dcache_rsel_way_wb   (cache_way_hit[`L1D_WAY_COUNT-1:0]),
                   .dcache_wdata_e       (lsu_dcache_fill_data_e[143:0]),
                   .dcache_wr_rway_e     (lsu_dcache_fill_way_e[`L1D_WAY_COUNT-1:0]),
                   .dcache_wvld_e        (lsu_dcache_wr_vld_e));
*/

bw_r_dcd dcache (
                 .so                    (scan1_2),
                 .si                    (scan1_1),
                 /*AUTOINST*/
                 // Outputs
                 .dcache_rdata_wb       (dcache_rdata_wb[63:0]),
                 .dcache_rparity_wb     (dcache_rparity_wb[7:0]),
                 .dcache_rparity_err_wb (dcache_rparity_err_wb),
                 .dcache_rdata_msb_m (dcache_rdata_msb_m),
                 // .dcache_rdata_msb_w0_m (dcache_rdata_msb_w0_m[7:0]),
                 // .dcache_rdata_msb_w1_m (dcache_rdata_msb_w1_m[7:0]),
                 // .dcache_rdata_msb_w2_m (dcache_rdata_msb_w2_m[7:0]),
                 // .dcache_rdata_msb_w3_m (dcache_rdata_msb_w3_m[7:0]),
                 .dcd_fuse_repair_value (dcd_fuse_repair_value[7:0]),
                 .dcd_fuse_repair_en    (dcd_fuse_repair_en[1:0]),
                 // Inputs
                 .dcache_rd_addr_e      (exu_lsu_early_va_e[(6 + 4):3]), // Templated
                 .dcache_alt_addr_e     (lsu_dcache_fill_addr_e[(6 + 4):3]), // Templated
                 .dcache_rvld_e         (dcache_rvld_e),
                 .dcache_wvld_e         (lsu_dcache_wr_vld_e),   // Templated
                 .dcache_wdata_e        (lsu_dcache_fill_data_e[143:0]), // Templated
                 .dcache_wr_rway_e      (lsu_dcache_fill_way_e[4-1:0]), // Templated
                 .dcache_byte_wr_en_e   (dcache_byte_wr_en_e[15:0]),
                 .dcache_alt_rsel_way_e (lsu_bist_rsel_way_e[4-1:0]), // Templated
                 .dcache_rsel_way_wb    (cache_way_hit[4-1:0]),    // Templated
                 .dcache_alt_mx_sel_e   (dcache_alt_mx_sel_e),
                 .se                    (se),
                 .sehold                (sehold),
                 .rst_tri_en            (mem_write_disable),     // Templated
                 .arst_l                (arst_l),
                 .rclk                  (clk),                   // Templated
                 .dcache_alt_data_w0_m  (dcache_alt_data_w0_m[63:0]),
                 .dcache_arry_data_sel_m(dcache_arry_data_sel_m),
                 .efc_spc_fuse_clk1     (efc_spc_fuse_clk1),
                 .fuse_dcd_wren         (fuse_dcd_wren),
                 .fuse_dcd_rid          (fuse_dcd_rid[2:0]),
                 .fuse_dcd_repair_value (fuse_dcd_repair_value[7:0]),
                 .fuse_dcd_repair_en    (fuse_dcd_repair_en[1:0]),

                 // interface to srams
                 .sram_dcache_w01_rtap_data (sram_dcache_w01_rtap_data),
                 .sram_dcache_w23_rtap_data (sram_dcache_w23_rtap_data),
                 .rtap_srams_bist_command (rtap_srams_bist_command),
                 .rtap_srams_bist_data (rtap_srams_bist_data)

                 );
/* sram_l1d_val  AUTO_TEMPLATE (
             .rst_tri_en           (mem_write_disable),
             .rclk             (clk),
             .bit_wen          (dva_bit_wr_en_e[`L1D_VAL_ARRAY_HI:0]),
             .din                (dva_din_e),
             .dout               (dva_vld_m[`L1D_WAY_COUNT-1:0]),
             .rd_adr1            (exu_lsu_early_va_e[`L1D_ADDRESS_HI:4]),
             .rd_adr1_sel        (1'b1),
             .rd_adr2            (7'b0),
             .rd_en              (ifu_lsu_ld_inst_e),
             .reset_l            (arst_l),
             //.sehold             (),
             .wr_adr             (dva_wr_adr_e[`L1D_ADDRESS_HI:6]),
             .wr_en              (lsu_dtagv_wr_vld_e));
*/

sram_l1d_val dva (
                  .so                   (short_scan0_1),
                  .si                   (short_si0),
                   /*AUTOINST*/
                  // Outputs
                  .dout                 (dva_vld_m[4-1:0]),        // Templated
                  // Inputs
                  .rclk                 (clk),                   // Templated
                  .se                   (se),
                  .reset_l              (arst_l),                // Templated
                  .sehold               (sehold),
                  .rst_tri_en           (mem_write_disable),     // Templated
                  .rd_adr1              (exu_lsu_early_va_e[(6 + 4):4]), // Templated
                  .rd_adr2              ({(6+1){1'b0}}),                  // Templated
                  .rd_adr1_sel          (1'b1),                  // Templated
                  .rd_en                (ifu_lsu_ld_inst_e),     // Templated
                  .wr_adr               (dva_wr_adr_e[(6 + 4):6]),    // Templated
                  .wr_en                (lsu_dtagv_wr_vld_e),    // Templated
                  .bit_wen              (dva_bit_wr_en_e[(4*4-1):0]), // Templated
                  .din                  (dva_din_e),             // Templated

                  // debug interface
                     .sramid            (8'd12),
                     .rtap_srams_bist_command   (rtap_srams_bist_command),
                     .rtap_srams_bist_data      (rtap_srams_bist_data),
                     .srams_rtap_data           (dcv_rtap_data)
                  );
/* bw_r_dct  AUTO_TEMPLATE (
               .rst_tri_en           (mem_write_disable),
               //.sehold                  (),
               .rclk                    (clk),
               .adj                     (lsu_dctag_mrgn[`L1D_WAY_COUNT-1:0]),
               .index0_x                (exu_lsu_early_va_e[`L1D_ADDRESS_HI:4]),
               .index1_x                (lsu_dcache_fill_addr_e[`L1D_ADDRESS_HI:4]),
               .index_sel_x             (lsu_dtag_index_sel_x_e),
               .rdreq_x                 (lsu_ldst_inst_vld_e),
               .rdtag_w0_y              (dtag_rdata_w0_m[32:0]),
               .rdtag_w1_y              (dtag_rdata_w1_m[32:0]),
               .rdtag_w2_y              (dtag_rdata_w2_m[32:0]),
               .rdtag_w3_y              (dtag_rdata_w3_m[32:0]),
               .wrreq_x                 (lsu_dtag_wrreq_x_e),
               //.wrtag_w0_y                 ({3'b000,dtag_wdata_m}),
               //.wrtag_w1_y                 ({3'b000,dtag_wdata_m}),
               //.wrtag_w2_y                 ({3'b000,dtag_wdata_m}),
               //.wrtag_w3_y                 ({3'b000,dtag_wdata_m}),
               .dec_wrway_x                (lsu_dcache_fill_way_e[`L1D_WAY_COUNT-1:0]),
               .reset_l                 (arst_l));
*/

bw_r_dct dtag (
                .so                     (short_scan0_2),
                .si                     (short_scan0_1),
		// .wrtag_w0_y		({3'b000,dtag_wdata_m}),
		// .wrtag_w1_y		({3'b000,dtag_wdata_m}),
		// .wrtag_w2_y		({3'b000,dtag_wdata_m}),
		// .wrtag_w3_y		({3'b000,dtag_wdata_m}),
      // .wrtag_w0_x    ({3'b000,dtag_wdata_e}),
      // .wrtag_w1_x    ({3'b000,dtag_wdata_e}),
      // .wrtag_w2_x    ({3'b000,dtag_wdata_e}),
      // .wrtag_w3_x    ({3'b000,dtag_wdata_e}),
      .wrtag_y    ({3'b0, dtag_wdata_m}),
      .wrtag_x    ({3'b0, dtag_wdata_e}),
                /*AUTOINST*/
                // Outputs
                // .rdtag_w0_y             (dtag_rdata_w0_m[32:0]), // Templated
                // .rdtag_w1_y             (dtag_rdata_w1_m[32:0]), // Templated
                // .rdtag_w2_y             (dtag_rdata_w2_m[32:0]), // Templated
                // .rdtag_w3_y             (dtag_rdata_w3_m[32:0]), // Templated
                .rdtag_y             (dtag_rdata_m), // Templated
                // Inputs
                .rclk                   (clk),                   // Templated
                .se                     (se),
                .reset_l                (arst_l),                // Templated
                .sehold                 (sehold),
                .rst_tri_en             (mem_write_disable),     // Templated
                .index0_x               (exu_lsu_early_va_e[(6 + 4):4]), // Templated
                .index1_x               (lsu_dcache_fill_addr_e[(6 + 4):4]), // Templated
                .index_sel_x            (lsu_dtag_index_sel_x_e), // Templated
                .dec_wrway_x            (lsu_dcache_fill_way_e[4-1:0]), // Templated
                .rdreq_x                (lsu_ldst_inst_vld_e),   // Templated
                .wrreq_x                (lsu_dtag_wrreq_x_e),    // Templated
                .adj                    (lsu_dctag_mrgn[4-1:0]),


               // debug interface
               .sramid   (8'd10),
               .srams_rtap_data   (sram_dtag_rtap_data),
               .rtap_srams_bist_command   (rtap_srams_bist_command),
               .rtap_srams_bist_data   (rtap_srams_bist_data)




                );

/*lsu_tlbdp  AUTO_TEMPLATE (
               .rclk  (clk));
*/

lsu_tlbdp tlbdp (
                 .so                    (scan1_3),
                 .si                    (scan1_2),
                 .tlb_rd_tte_data_parity  (tlb_rd_tte_data[42]),
                 .tlb_rd_tte_tag_parity   (tlb_rd_tte_tag[54]),
                 /*AUTOINST*/
                 // Outputs
                 .lsu_tlb_rd_data       (lsu_tlb_rd_data[63:0]),
                 .tlb_pgnum_buf         (tlb_pgnum_buf[39:10]),
                 .tlb_pgnum_buf2        (tlb_pgnum_buf2[39:37]),
                 .tlb_rd_tte_data_ie_buf(tlb_rd_tte_data_ie_buf),
                 .stb_cam_vld           (stb_cam_vld),
                 .tte_data_parity_error (tte_data_parity_error),
                 .tte_tag_parity_error  (tte_tag_parity_error),
                 .cache_way_hit_buf1    (cache_way_hit_buf1[4-1:0]),
                 .cache_way_hit_buf2    (cache_way_hit_buf2[4-1:0]),
                 .lsu_tlu_tte_pg_sz_g   (lsu_tlu_tte_pg_sz_g[2:0]),
                 // Inputs
                 .rclk                  (clk),                   // Templated
                 .se                    (se),
                 .tlb_rd_tte_tag        (tlb_rd_tte_tag[58:0]),
                 .tlb_rd_tte_data       (tlb_rd_tte_data[42:0]),
                 .lsu_tlb_data_rd_vld_g (lsu_tlb_data_rd_vld_g),
                 
                 .tlb_rd_tte_csm        (tlb_rd_tte_csm),
                 .lsu_tlb_csm_rd_vld_g  (lsu_tlb_csm_rd_vld_g),
                 
                 .tlb_pgnum             (tlb_pgnum[39:10]),
                 .asi_internal_m        (asi_internal_m),
                 .lsu_alt_space_m       (lsu_alt_space_m),
                 .tlb_cam_hit           (tlb_cam_hit),
                 .ifu_lsu_ld_inst_e     (ifu_lsu_ld_inst_e),
                 .lsu_dtlb_bypass_e     (lsu_dtlb_bypass_e),
                 .cache_way_hit         (cache_way_hit[4-1:0]));

/*
lsu_tagdp AUTO_TEMPLATE (
                  .dva_vld_m              (dva_vld_m_bf[`L1D_WAY_COUNT-1:0]),
                  .rclk                   (clk));
*/

lsu_tagdp tagdp (
                 .so                    (scan1_4),
                 .si                    (scan1_3),
		             .lsu_local_ldxa_data_g ({15'b0,lsu_local_ldxa_data_g[32:0]}),
                 /*AUTOINST*/
                 // Outputs
                 .lsu_misc_rdata_w2     (lsu_misc_rdata_w2[63:0]),
                 .lsu_rd_dtag_parity_g  (lsu_rd_dtag_parity_g[4-1:0]),
                 // Inputs
                 .rclk                  (clk),                   // Templated
                 .se                    (se),
                 .lsu_va_wtchpt_addr    (lsu_va_wtchpt_addr[47:3]),
                 .lsu_va_wtchpt_sel_g   (lsu_va_wtchpt_sel_g),
                 .dva_vld_m             (dva_vld_m_bf[4-1:0]),     // Templated
                 .dtag_rdata_m (dtag_rdata_m),
                 .lsu_dtag_rsel_m       (lsu_dtag_rsel_m[3:0]),
                 .lsu_local_ldxa_sel_g  (lsu_local_ldxa_sel_g),
                 .lsu_tlb_rd_data       (lsu_tlb_rd_data[63:0]),
                 .lsu_local_ldxa_tlbrd_sel_g(lsu_local_ldxa_tlbrd_sel_g),
                 .lsu_local_diagnstc_tagrd_sel_g(lsu_local_diagnstc_tagrd_sel_g));

/*
lsu_excpctl AUTO_TEMPLATE (
                .ifu_tlu_inst_vld_m     (ifu_tlu_inst_vld_m_bf2),
                .tlb_rd_tte_data_ebit   (tlb_rd_tte_data[`STLB_DATA_E]),
                .tlb_rd_tte_data_pbit   (tlb_rd_tte_data[`STLB_DATA_P]),
                .tlb_rd_tte_data_nfobit (tlb_rd_tte_data[`STLB_DATA_NFO]),
                .tlb_rd_tte_data_wbit   (tlb_rd_tte_data[`STLB_DATA_W]),
		.lsu_ldst_va_b39_m	(lsu_ldst_va_m_buf[39]),
                .tlb_pgnum_b39          (tlb_pgnum[39]),
       	        .lsu_sun4r_va_m_l	      (lsu_ldst_va_m[10]),
	              .lsu_sun4r_pgsz_b2t0_e  ({exu_lsu_rs3_data_e[48],exu_lsu_rs3_data_e[62:61]}),
	              .lsu_sun4v_pgsz_b2t0_e  (exu_lsu_rs3_data_e[2:0]),
                .ld_inst_vld_e          (ifu_lsu_ld_inst_e),
                .st_inst_vld_e          (ifu_lsu_st_inst_e),
                .rclk                   (clk));
*/

lsu_excpctl excpctl (
                     .so                (short_scan0_3),
                     .si                (short_scan0_2),

                 /*AUTOINST*/
                     // Outputs
                     .lsu_exu_st_dtlb_perr_g(lsu_exu_st_dtlb_perr_g),
                     .lsu_ffu_st_dtlb_perr_g(lsu_ffu_st_dtlb_perr_g),
                     .lsu_defr_trp_taken_g(lsu_defr_trp_taken_g),
                     .lsu_tlu_defr_trp_taken_g(lsu_tlu_defr_trp_taken_g),
                     .lsu_mmu_defr_trp_taken_g(lsu_mmu_defr_trp_taken_g),
                     .lsu_st_dtlb_perr_g(lsu_st_dtlb_perr_g[3:0]),
                     .lsu_dmmu_sfsr_trp_wr(lsu_dmmu_sfsr_trp_wr[3:0]),
                     .lsu_dsfsr_din_g   (lsu_dsfsr_din_g[23:0]),
                     .lsu_tlb_perr_ld_rq_kill_w(lsu_tlb_perr_ld_rq_kill_w),
                     .lsu_spu_early_flush_g(lsu_spu_early_flush_g),
                     .lsu_local_early_flush_g(lsu_local_early_flush_g),
                     .lsu_tlu_early_flush_w(lsu_tlu_early_flush_w),
                     .lsu_tlu_early_flush2_w(lsu_tlu_early_flush2_w),
                     .lsu_ttype_vld_m2  (lsu_ttype_vld_m2),
                     .lsu_ttype_vld_m2_bf1(lsu_ttype_vld_m2_bf1),
                     .lsu_ifu_flush_pipe_w(lsu_ifu_flush_pipe_w),
                     .lsu_exu_flush_pipe_w(lsu_exu_flush_pipe_w),
                     .lsu_mmu_flush_pipe_w(lsu_mmu_flush_pipe_w),
                     .lsu_ffu_flush_pipe_w(lsu_ffu_flush_pipe_w),
                     .lsu_tlu_wtchpt_trp_g(lsu_tlu_wtchpt_trp_g),
                     .lsu_tlu_dmmu_miss_g(lsu_tlu_dmmu_miss_g),
                     .lsu_tlu_misalign_addr_ldst_atm_m(lsu_tlu_misalign_addr_ldst_atm_m),
                     .lsu_tlu_daccess_excptn_g(lsu_tlu_daccess_excptn_g),
                     .lsu_tlu_daccess_prot_g(lsu_tlu_daccess_prot_g),
                     .lsu_tlu_priv_action_g(lsu_tlu_priv_action_g),
                     .lsu_ifu_tlb_data_su(lsu_ifu_tlb_data_su),
                     .lsu_ifu_tlb_data_ue(lsu_ifu_tlb_data_ue),
                     .lsu_ifu_tlb_tag_ue(lsu_ifu_tlb_tag_ue),
                     .lsu_tlu_ttype_m2  (lsu_tlu_ttype_m2[8:0]),
                     .lsu_tlu_ttype_vld_m2(lsu_tlu_ttype_vld_m2),
                     .stb_cam_sqsh_msk  (stb_cam_sqsh_msk[7:0]),
                     .stb_cam_hit_bf    (stb_cam_hit_bf),
                     .stb_cam_hit_bf1   (stb_cam_hit_bf1),
                     .tte_data_perror_unc(tte_data_perror_unc),
                     .asi_tte_data_perror(asi_tte_data_perror),
                     .asi_tte_tag_perror(asi_tte_tag_perror),
                     // Inputs
                     .rclk              (clk),                   // Templated
                     .se                (se),
                     .grst_l            (grst_l),
                     .arst_l            (arst_l),
                     .tlb_rd_tte_data_ebit(tlb_rd_tte_data[5]), // Templated
                     .tlb_rd_tte_data_pbit(tlb_rd_tte_data[4]), // Templated
                     .tlb_rd_tte_data_nfobit(tlb_rd_tte_data[10]), // Templated
                     .tlb_rd_tte_data_wbit(tlb_rd_tte_data[3]), // Templated
                     .tlb_cam_hit       (tlb_cam_hit),
                     .tlb_pgnum_b39     (tlb_pgnum[39]),         // Templated
                     .lsu_ldst_va_b39_m (lsu_ldst_va_m_buf[39]), // Templated
                     .lsu_sun4r_va_m_l  (lsu_ldst_va_m[10]),     // Templated
                     .lsu_sun4r_pgsz_b2t0_e({exu_lsu_rs3_data_e[48],exu_lsu_rs3_data_e[62:61]}), // Templated
                     .lsu_sun4v_pgsz_b2t0_e(exu_lsu_rs3_data_e[2:0]), // Templated
                     .tlu_early_flush_pipe_w(tlu_early_flush_pipe_w),
                     .ifu_lsu_flush_w   (ifu_lsu_flush_w),
                     .ifu_lsu_nceen     (ifu_lsu_nceen[3:0]),
                     .lsu_tlb_asi_data_perr_g(lsu_tlb_asi_data_perr_g),
                     .lsu_tlb_asi_tag_perr_g(lsu_tlb_asi_tag_perr_g),
                     .stb_state_vld0    (stb_state_vld0[7:0]),
                     .stb_state_vld1    (stb_state_vld1[7:0]),
                     .stb_state_vld2    (stb_state_vld2[7:0]),
                     .stb_state_vld3    (stb_state_vld3[7:0]),
                     .ifu_tlu_thrid_e   (ifu_tlu_thrid_e[1:0]),
                     .tlu_lsu_priv_trap_m(tlu_lsu_priv_trap_m),
                     .tlu_lsu_pstate_priv(tlu_lsu_pstate_priv[3:0]),
                     .st_inst_vld_e     (ifu_lsu_st_inst_e),     // Templated
                     .ld_inst_vld_e     (ifu_lsu_ld_inst_e),     // Templated
                     .ifu_lsu_alt_space_e(ifu_lsu_alt_space_e),
                     .lsu_ldst_va_m     (lsu_ldst_va_m[7:0]),
                     .hpv_priv_m        (hpv_priv_m),
                     .hpstate_en_m      (hpstate_en_m),
                     .stb_cam_hit       (stb_cam_hit),
                     .dtlb_bypass_m     (dtlb_bypass_m),
                     .lsu_alt_space_m   (lsu_alt_space_m),
                     .atomic_m          (atomic_m),
                     .ldst_dbl_m        (ldst_dbl_m),
                     .fp_ldst_m         (fp_ldst_m),
                     .lda_internal_m    (lda_internal_m),
                     .sta_internal_m    (sta_internal_m),
                     .cam_real_m        (cam_real_m),
                     .data_rd_vld_g     (data_rd_vld_g),
                     .tag_rd_vld_g      (tag_rd_vld_g),
                     .ldst_sz_m         (ldst_sz_m[1:0]),
                     .asi_internal_m    (asi_internal_m),
                     .rd_only_ltlb_asi_e(rd_only_ltlb_asi_e),
                     .wr_only_ltlb_asi_e(wr_only_ltlb_asi_e),
                     .dfill_tlb_asi_e   (dfill_tlb_asi_e),
                     .ifill_tlb_asi_e   (ifill_tlb_asi_e),
                     .nofault_asi_m     (nofault_asi_m),
                     .as_if_user_asi_m  (as_if_user_asi_m),
                     .atomic_asi_m      (atomic_asi_m),
                     .phy_use_ec_asi_m  (phy_use_ec_asi_m),
                     .phy_byp_ec_asi_m  (phy_byp_ec_asi_m),
                     .quad_asi_m        (quad_asi_m),
                     .binit_quad_asi_m  (binit_quad_asi_m),
                     .blk_asi_m         (blk_asi_m),
                     .recognized_asi_m  (recognized_asi_m),
                     .strm_asi_m        (strm_asi_m),
                     .mmu_rd_only_asi_m (mmu_rd_only_asi_m),
                     .rd_only_asi_m     (rd_only_asi_m),
                     .wr_only_asi_m     (wr_only_asi_m),
                     .unimp_asi_m       (unimp_asi_m),
                     .lsu_nonalt_nucl_access_m(lsu_nonalt_nucl_access_m),
                     .va_wtchpt_cmp_en_m(va_wtchpt_cmp_en_m),
                     .lsu_va_match_b47_b32_m(lsu_va_match_b47_b32_m),
                     .lsu_va_match_b31_b3_m(lsu_va_match_b31_b3_m),
                     .va_wtchpt_msk_match_m(va_wtchpt_msk_match_m),
                     .ifu_tlu_inst_vld_m(ifu_tlu_inst_vld_m_bf2), // Templated
                     .exu_tlu_misalign_addr_jmpl_rtn_m(exu_tlu_misalign_addr_jmpl_rtn_m),
                     .exu_tlu_va_oor_m  (exu_tlu_va_oor_m),
                     .tlu_dsfsr_flt_vld (tlu_dsfsr_flt_vld[3:0]),
                     .tlu_lsu_pstate_cle(tlu_lsu_pstate_cle[3:0]),
                     .tlu_lsu_pstate_am (tlu_lsu_pstate_am[3:0]),
                     .lsu_excpctl_asi_state_m(lsu_excpctl_asi_state_m[7:0]),
                     .lsu_tlu_nonalt_ldst_m(lsu_tlu_nonalt_ldst_m),
                     .lsu_squash_va_oor_m(lsu_squash_va_oor_m),
                     .lsu_tlu_xslating_ldst_m(lsu_tlu_xslating_ldst_m),
                     .lsu_tlu_ctxt_sel_m(lsu_tlu_ctxt_sel_m[2:0]),
                     .lsu_tlu_write_op_m(lsu_tlu_write_op_m),
                     .lsu_memref_m      (lsu_memref_m),
                     .lsu_flsh_inst_m   (lsu_flsh_inst_m),
                     .tte_data_parity_error(tte_data_parity_error),
                     .tte_tag_parity_error(tte_tag_parity_error));

/*lsu_dctldp AUTO_TEMPLATE (
               .thread0_m               (lsu_dctldp_thread0_m),
               .thread1_m               (lsu_dctldp_thread1_m),
               .thread2_m               (lsu_dctldp_thread2_m),
               .thread3_m               (lsu_dctldp_thread3_m),
               .rst_tri_en              (mux_drive_disable),
               .rclk                    (clk),
               .rst_l                   (dctl_rst_l),
      	       .tlu_dtlb_tte_tag_b58t56 (tlu_dtlb_tte_tag_w2[58:56]),
               .lsu_dcfill_addr_e       (lsu_dcache_fill_addr_e_err[`L1D_ADDRESS_HI:4]));
*/

 // Use two threads unless this is defined

   lsu_dctldp dctldp (
                   .so                  (short_scan1_2),
                   .si                  (short_scan1_1),
           .lsu_iobrdge_rd_data (lsu_iobrdge_rd_data[43:0]),
           .lsu_local_ldxa_data_g(lsu_local_ldxa_data_g[47:0]),
                   /*AUTOINST*/
                   // Outputs
                   .asi_d               (asi_d[7:0]),
                   .lsu_excpctl_asi_state_m(lsu_excpctl_asi_state_m[7:0]),
                   .lsu_dctl_asi_state_m(lsu_dctl_asi_state_m[7:0]),
                   .lsu_spu_asi_state_e (lsu_spu_asi_state_e[7:0]),
                   .lsu_tlu_rsr_data_e  (lsu_tlu_rsr_data_e[7:0]),
                   .lsu_asi_state       (lsu_asi_state[7:0]),
                   .lsu_asi_reg0        (lsu_asi_reg0_t[7:0]),
                   .lsu_asi_reg1        (lsu_asi_reg1_t[7:0]),
                   .lsu_asi_reg2        (),
                   .lsu_asi_reg3        (),
                   .lsu_t0_pctxt_state  (lsu_t0_pctxt_state_t[12:0]),
                   .lsu_t1_pctxt_state  (lsu_t1_pctxt_state_t[12:0]),
                   .lsu_t2_pctxt_state  (),
                   .lsu_t3_pctxt_state  (),
                   .lsu_tlu_dside_ctxt_m(lsu_tlu_dside_ctxt_m[12:0]),
                   .lsu_tlu_pctxt_m     (lsu_tlu_pctxt_m[12:0]),
                   .tlb_ctxt            (tlb_ctxt[12:0]),
                   .lsu_pid_state0      (lsu_pid_state0_t[2:0]),
                   .lsu_pid_state1      (lsu_pid_state1_t[2:0]),
                   .lsu_pid_state2      (),
                   .lsu_pid_state3      (),
                   .lsu_dtlb_cam_pid_e  (lsu_dtlb_cam_pid_e[2:0]),
                   .bist_ctl_reg_in     (bist_ctl_reg_in[6:0]),
                   .lsu_ifu_direct_map_l1(lsu_ifu_direct_map_l1),
                   .dc_direct_map       (dc_direct_map),
                   .lsu_ictag_mrgn      (lsu_ictag_mrgn[3:0]),
                   .lsu_dctag_mrgn      (lsu_dctag_mrgn[4-1:0]),
                   .lsu_mamem_mrgn      (lsu_mamem_mrgn[3:0]),
                   .lsu_dtlb_mrgn       (lsu_dtlb_mrgn[7:0]),
                   .lsu_itlb_mrgn       (lsu_itlb_mrgn[7:0]),
                   .lsu_ldst_va_m       (lsu_ldst_va_m[12:0]),
                   .lsu_ldst_va_m_buf   (lsu_ldst_va_m_buf[47:0]),
                   .lsu_tlu_ldst_va_m   (lsu_tlu_ldst_va_m[9:0]),
                   .lsu_tlu_tlb_asi_state_m(lsu_tlu_tlb_asi_state_m[7:0]),
                   .lsu_ifu_asi_state   (lsu_ifu_asi_state[7:0]),
                   .lsu_tlu_tlb_ldst_va_m(lsu_tlu_tlb_ldst_va_m[(6 + 4):0]),
                   .lsu_tlu_tlb_dmp_va_m(lsu_tlu_tlb_dmp_va_m[47:13]),
                   .lsu_ifu_asi_addr    (lsu_ifu_asi_addr[17:0]),
                   .lsu_diagnstc_wr_addr_e(lsu_diagnstc_wr_addr_e[(6 + 4):0]),
                   .lsu_diagnstc_dc_prty_invrt_e(lsu_diagnstc_dc_prty_invrt_e[7:0]),
                   .lsu_ifu_err_addr    (lsu_ifu_err_addr[47:4]),
                   .va_wtchpt_msk_match_m(va_wtchpt_msk_match_m),
                   .lsu_ldst_va_g       (lsu_ldst_va_g[7:0]),
                   .lsu_dp_ctl_reg0     (lsu_dp_ctl_reg0[5:0]),
                   .lsu_dp_ctl_reg1     (lsu_dp_ctl_reg1[5:0]),
                   .lsu_dp_ctl_reg2     (),
                   .lsu_dp_ctl_reg3     (),
                   .lsu_diagnstc_wr_way_e(lsu_diagnstc_wr_way_e[2-1:0]),
                   .lsu_diag_va_prty_invrt(lsu_diag_va_prty_invrt),
                   // Inputs
                   .rclk                (clk),                   // Templated
                   .rst_l               (dctl_rst_l),            // Templated
                   .se                  (se),
                   .async_tlb_index     (async_tlb_index[5:0]),
                   .lsu_dtlb_dmp_vld_e  (lsu_dtlb_dmp_vld_e),
                   .tlu_lsu_asi_m       (tlu_lsu_asi_m[7:0]),
                   .exu_tlu_wsr_data_m  (exu_tlu_wsr_data_m[7:0]),
                   .tlu_lsu_asi_update_g(tlu_lsu_asi_update_g),
                   .asi_state_wr_thrd   (asi_state_wr_thrd[3:0]),
                   .ifu_lsu_imm_asi_d   (ifu_lsu_imm_asi_d[7:0]),
                   .thread0_d           (thread0_d),
                   .thread1_d           (thread1_d),
                   .thread2_d           (1'b0),
                   .thread3_d           (1'b0),
                   .ifu_lsu_imm_asi_vld_d(ifu_lsu_imm_asi_vld_d),
                   .lsu_err_addr_sel    (lsu_err_addr_sel[2:0]),
                   .pctxt_state_wr_thrd (pctxt_state_wr_thrd[3:0]),
                   .sctxt_state_wr_thrd (sctxt_state_wr_thrd[3:0]),
                   .st_rs3_data_g       (st_rs3_data_g[32:0]),
                   .thread0_ctxt        (thread0_ctxt),
                   .thread1_ctxt        (thread1_ctxt),
                   .thread2_ctxt        (1'b0),
                   .thread3_ctxt        (1'b0),
                   .thread_pctxt        (thread_pctxt),
                   .thread_sctxt        (thread_sctxt),
                   .thread_actxt        (thread_actxt),
                   .thread_default      (thread_default),
                   .tlu_dtlb_tte_tag_w2 (tlu_dtlb_tte_tag_w2[12:0]),
                   .tlu_dtlb_tte_tag_b58t56(tlu_dtlb_tte_tag_w2[58:56]), // Templated
                   .thread0_g           (thread0_g),
                   .thread1_g           (thread1_g),
                   .thread2_g           (1'b0),
                   .thread3_g           (1'b0),
                   .pid_state_wr_en     (pid_state_wr_en[3:0]),
                   .thread0_e           (thread0_e),
                   .thread1_e           (thread1_e),
                   .thread2_e           (1'b0),
                   .thread3_e           (1'b0),
                   .thread0_m           (lsu_dctldp_thread0_m),  // Templated
                   .thread1_m           (lsu_dctldp_thread1_m),  // Templated
                   .thread2_m           (1'b0),  // Templated
                   .thread3_m           (1'b0),  // Templated
                   .lsu_iobrdge_wr_data (lsu_iobrdge_wr_data[27:0]),
                   .dfture_tap_wr_mx_sel(dfture_tap_wr_mx_sel),
                   .lctl_rst            (lctl_rst[3:0]),
                   .lsu_ctl_state_wr_en (lsu_ctl_state_wr_en[3:0]),
                   .lsuctl_ctlbits_wr_en(lsuctl_ctlbits_wr_en[3:0]),
                   .dfture_tap_rd_en    (dfture_tap_rd_en[3:0]),
                   .bist_tap_wr_en      (bist_tap_wr_en),
                   .bist_ctl_reg_out    (bist_ctl_reg_out[(6 + 4):0]),
                   .mrgn_tap_wr_en      (mrgn_tap_wr_en),
                   .ldiagctl_wr_en      (ldiagctl_wr_en),
                   .misc_ctl_sel_din    (misc_ctl_sel_din[3:0]),
                   .lsu_asi_sel_fmx1    (lsu_asi_sel_fmx1[2:0]),
                   .lsu_asi_sel_fmx2    (lsu_asi_sel_fmx2[2:0]),
                   .exu_lsu_ldst_va_e   (exu_lsu_ldst_va_e[47:0]),
                   .tlb_access_en0_g    (tlb_access_en0_g),
                   .tlb_access_en1_g    (tlb_access_en1_g),
                   .tlb_access_en2_g    (1'b0),
                   .tlb_access_en3_g    (1'b0),
                   .tlb_access_sel_thrd0(tlb_access_sel_thrd0),
                   .tlb_access_sel_thrd1(tlb_access_sel_thrd1),
                   .tlb_access_sel_thrd2(tlb_access_sel_thrd2),
                   .tlb_access_sel_default(tlb_access_sel_default),
                   .mrgnctl_wr_en       (mrgnctl_wr_en),
                   .lsu_dcfill_addr_e   (lsu_dcache_fill_addr_e_err[(6 + 4):4]), // Templated
                   .lsu_error_pa_m      (lsu_error_pa_m[28:0]),
                   .stb_ldst_byte_msk   (stb_ldst_byte_msk[7:0]),
                   .lsu_diagnstc_va_sel (lsu_diagnstc_va_sel[3:0]),
                   .rst_tri_en          (mux_drive_disable),


                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)

                   );     // Templated












































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*
lsu_dctl AUTO_TEMPLATE (
               .rst_tri_en           (mux_drive_disable),
               .stb_cam_hit             (stb_cam_hit_bf1),
               .lsu_ttype_vld_m2        (lsu_ttype_vld_m2_bf1),
               .ifu_tlu_inst_vld_m      (ifu_tlu_inst_vld_m_bf1),
               .bistctl_wr_en           (),
               .rclk                    (clk),
               .lsu_iobrdge_tap_rq_type_b8    (lsu_iobrdge_tap_rq_type[8:8]),
               .lsu_iobrdge_tap_rq_type_b6_b3 (lsu_iobrdge_tap_rq_type[6:3]),
               .lsu_iobrdge_tap_rq_type_b1_b0 (lsu_iobrdge_tap_rq_type[1:0]),

               .lsu_ifu_err_addr_b39    (lsu_ifu_err_addr[39]),
               .ld_inst_vld_e           (ifu_lsu_ld_inst_e),
               .lsu_sscan_data		(lsu_sscan_data[14:13]),
               .ldst_sz_e               (ifu_lsu_ldst_size_e[1:0]),
               .lsu_l1hit_sign_extend_e (ifu_lsu_sign_ext_e),
               .lsu_tlb_invert_endian_g (tlb_rd_tte_data_ie_buf),
               .lsu_tte_data_cp_g	(tlb_rd_tte_data[`STLB_DATA_CP]),
               .st_inst_vld_e           (ifu_lsu_st_inst_e),
               .tlb_demap_actxt         (tlu_dtlb_dmp_actxt_g),
               .tlb_demap_nctxt         (tlu_dtlb_dmp_nctxt_g),
               .tlb_demap_pctxt         (tlu_dtlb_dmp_pctxt_g),
               .tlb_demap_sctxt         (tlu_dtlb_dmp_sctxt_g),
               .tlb_demap_thrid         (tlu_idtlb_dmp_thrid_g[1:0]),
       	       .lsu_dfill_tid_e		      (dfq_tid[1:0]),
	             .tlb_pgnum		            ({tlb_pgnum_buf[39:10]}),
               .lsu_ldst_va_b12_b11_m   (lsu_ldst_va_m[12:11]),
               .lsu_ldst_va_b7_b0_m     (lsu_ldst_va_m[7:0]));

*/

 // Use two threads unless this is defined

   lsu_dctl dctl (
               .so                      (short_scan1_3),
               .si                      (short_scan1_2),

         .lsu_dtlb_cam_real_e     (lsu_dtlb_cam_real_e),

              /*AUTOINST*/
               // Outputs
               .stb_ncache_pcx_rq_g     (stb_ncache_pcx_rq_g),
               .lsu_tlu_nucleus_ctxt_m  (lsu_tlu_nucleus_ctxt_m),
               .lsu_quad_word_access_g  (lsu_quad_word_access_g),
               .dctl_rst_l              (dctl_rst_l),
               .lsu_tlu_wsr_inst_e      (lsu_tlu_wsr_inst_e),
               .lsu_l2fill_fpld_e       (lsu_l2fill_fpld_e),
               .dva_vld_m_bf            (dva_vld_m_bf[4-1:0]),
               .lsu_no_spc_pref         (lsu_no_spc_pref[3:0]),
               .ifu_tlu_flush_fd_w      (ifu_tlu_flush_fd_w),
               .ifu_tlu_flush_fd2_w     (ifu_tlu_flush_fd2_w),
               .ifu_tlu_flush_fd3_w     (ifu_tlu_flush_fd3_w),
               .ifu_lsu_flush_w         (ifu_lsu_flush_w),
               .lsu_tlu_thrid_d         (lsu_tlu_thrid_d[1:0]),
               .lsu_diagnstc_data_sel   (lsu_diagnstc_data_sel[3:0]),
               .lsu_diagnstc_va_sel     (lsu_diagnstc_va_sel[3:0]),
               .lsu_err_addr_sel        (lsu_err_addr_sel[2:0]),
               .dva_bit_wr_en_e         (dva_bit_wr_en_e[(4*4-1):0]),
               .dva_wr_adr_e            (dva_wr_adr_e[(6 + 4):6]),
               .lsu_exu_ldst_miss_w2    (lsu_exu_ldst_miss_w2),
               .lsu_exu_dfill_vld_w2    (lsu_exu_dfill_vld_w2),
               .lsu_ffu_ld_vld          (lsu_ffu_ld_vld),
               .lsu_ld_miss_wb          (lsu_ld_miss_wb),
               .lsu_dtlb_bypass_e       (lsu_dtlb_bypass_e),
               .ld_pcx_pkt_g            (ld_pcx_pkt_g[65-1:40]),
               .tlb_ldst_cam_vld        (tlb_ldst_cam_vld),
               .ldxa_internal           (ldxa_internal),
               .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
               .lsu_ifu_ldst_cmplt      (lsu_ifu_ldst_cmplt[3:0]),
               .lsu_ifu_itlb_en         (lsu_ifu_itlb_en[3:0]),
               .lsu_ifu_icache_en       (lsu_ifu_icache_en[3:0]),
               .lmq_byp_data_en_w2      (lmq_byp_data_en_w2[3:0]),
               .lmq_byp_data_fmx_sel    (lmq_byp_data_fmx_sel[3:0]),
               .lmq_byp_data_mxsel0     (lmq_byp_data_mxsel0[3:0]),
               .lmq_byp_data_mxsel1     (lmq_byp_data_mxsel1[3:0]),
               .lmq_byp_data_mxsel2     (lmq_byp_data_mxsel2[3:0]),
               .lmq_byp_data_mxsel3     (lmq_byp_data_mxsel3[3:0]),
               .lmq_byp_ldxa_mxsel0     (lmq_byp_ldxa_mxsel0[2:0]),
               .lmq_byp_ldxa_mxsel1     (lmq_byp_ldxa_mxsel1[2:0]),
               .lmq_byp_ldxa_mxsel2     (lmq_byp_ldxa_mxsel2[2:0]),
               .lmq_byp_ldxa_mxsel3     (lmq_byp_ldxa_mxsel3[2:0]),
               .lsu_ld_thrd_byp_sel_e   (lsu_ld_thrd_byp_sel_e[2:0]),
               .dcache_byte_wr_en_e     (dcache_byte_wr_en_e[15:0]),
               .lsu_dcache_wr_vld_e     (lsu_dcache_wr_vld_e),
               .lsu_ldstub_g            (lsu_ldstub_g),
               .lsu_swap_g              (lsu_swap_g),
               .lsu_tlu_dtlb_done       (lsu_tlu_dtlb_done),
               .lsu_exu_thr_m           (lsu_exu_thr_m[1:0]),
               .merge7_sel_byte0_m      (merge7_sel_byte0_m),
               .merge7_sel_byte7_m      (merge7_sel_byte7_m),
               .merge6_sel_byte1_m      (merge6_sel_byte1_m),
               .merge6_sel_byte6_m      (merge6_sel_byte6_m),
               .merge5_sel_byte2_m      (merge5_sel_byte2_m),
               .merge5_sel_byte5_m      (merge5_sel_byte5_m),
               .merge4_sel_byte3_m      (merge4_sel_byte3_m),
               .merge4_sel_byte4_m      (merge4_sel_byte4_m),
               .merge3_sel_byte0_m      (merge3_sel_byte0_m),
               .merge3_sel_byte3_m      (merge3_sel_byte3_m),
               .merge3_sel_byte4_m      (merge3_sel_byte4_m),
               .merge3_sel_byte7_default_m(merge3_sel_byte7_default_m),
               .merge3_sel_byte_m       (merge3_sel_byte_m),
               .merge2_sel_byte1_m      (merge2_sel_byte1_m),
               .merge2_sel_byte2_m      (merge2_sel_byte2_m),
               .merge2_sel_byte5_m      (merge2_sel_byte5_m),
               .merge2_sel_byte6_default_m(merge2_sel_byte6_default_m),
               .merge2_sel_byte_m       (merge2_sel_byte_m),
               .merge0_sel_byte0_m      (merge0_sel_byte0_m),
               .merge0_sel_byte1_m      (merge0_sel_byte1_m),
               .merge0_sel_byte2_m      (merge0_sel_byte2_m),
               .merge0_sel_byte3_default_m(merge0_sel_byte3_default_m),
               .merge0_sel_byte4_m      (merge0_sel_byte4_m),
               .merge0_sel_byte5_m      (merge0_sel_byte5_m),
               .merge0_sel_byte6_m      (merge0_sel_byte6_m),
               .merge0_sel_byte7_default_m(merge0_sel_byte7_default_m),
               .merge1_sel_byte0_m      (merge1_sel_byte0_m),
               .merge1_sel_byte1_m      (merge1_sel_byte1_m),
               .merge1_sel_byte2_m      (merge1_sel_byte2_m),
               .merge1_sel_byte3_default_m(merge1_sel_byte3_default_m),
               .merge1_sel_byte4_m      (merge1_sel_byte4_m),
               .merge1_sel_byte5_m      (merge1_sel_byte5_m),
               .merge1_sel_byte6_m      (merge1_sel_byte6_m),
               .merge1_sel_byte7_default_m(merge1_sel_byte7_default_m),
               .merge0_sel_byte_1h_m    (merge0_sel_byte_1h_m),
               .merge1_sel_byte_1h_m    (merge1_sel_byte_1h_m),
               .merge1_sel_byte_2h_m    (merge1_sel_byte_2h_m),
               .lsu_dtagv_wr_vld_e      (lsu_dtagv_wr_vld_e),
               .lsu_dtag_wrreq_x_e      (lsu_dtag_wrreq_x_e),
               .lsu_dtag_index_sel_x_e  (lsu_dtag_index_sel_x_e),
               .lsu_dtlb_wr_vld_e       (lsu_dtlb_wr_vld_e),
               .lsu_dtlb_tag_rd_e       (lsu_dtlb_tag_rd_e),
               .lsu_dtlb_data_rd_e      (lsu_dtlb_data_rd_e),
                
                .csm_rd_vld_g           (csm_rd_vld_g),
                .lsu_tlb_csm_rd_vld_g   (lsu_tlb_csm_rd_vld_g),
                .lsu_dtlb_csm_rd_e      (lsu_dtlb_csm_rd_e),
                .lsu_blkst_csm_m        (lsu_blkst_csm_m),
                
               .lsu_dtlb_dmp_vld_e      (lsu_dtlb_dmp_vld_e),
               .lsu_dtlb_dmp_all_e      (lsu_dtlb_dmp_all_e),
               .lsu_dtlb_rwindex_vld_e  (lsu_dtlb_rwindex_vld_e),
               .lsu_dtlb_invalid_all_l_m(lsu_dtlb_invalid_all_l_m),
               .lsu_tlu_tlb_ld_inst_m   (lsu_tlu_tlb_ld_inst_m),
               .lsu_tlu_tlb_st_inst_m   (lsu_tlu_tlb_st_inst_m),
               .lsu_tlu_tlb_access_tid_m(lsu_tlu_tlb_access_tid_m[1:0]),
               .lsu_tlb_data_rd_vld_g   (lsu_tlb_data_rd_vld_g),
               .lsu_tlb_st_sel_m        (lsu_tlb_st_sel_m[3:0]),
               .lsu_va_wtchpt0_wr_en_l  (lsu_va_wtchpt0_wr_en_l),
               .lsu_va_wtchpt1_wr_en_l  (lsu_va_wtchpt1_wr_en_l),
               .lsu_va_wtchpt2_wr_en_l  (lsu_va_wtchpt2_wr_en_l),
               .lsu_va_wtchpt3_wr_en_l  (lsu_va_wtchpt3_wr_en_l),
               .thread0_m               (thread0_m),
               .thread1_m               (thread1_m),
               .thread2_m               (),
               .thread3_m               (),
               .lsu_dctldp_thread0_m    (lsu_dctldp_thread0_m),
               .lsu_dctldp_thread1_m    (lsu_dctldp_thread1_m),
               .lsu_dctldp_thread2_m    (),
               .lsu_dctldp_thread3_m    (),
               .thread0_g               (thread0_g),
               .thread1_g               (thread1_g),
               .thread2_g               (),
               .thread3_g               (),
               .lsu_tlu_nonalt_ldst_m   (lsu_tlu_nonalt_ldst_m),
               .lsu_tlu_xslating_ldst_m (lsu_tlu_xslating_ldst_m),
               .lsu_tlu_ctxt_sel_m      (lsu_tlu_ctxt_sel_m[2:0]),
               .lsu_tlu_write_op_m      (lsu_tlu_write_op_m),
               .lsu_dtlb_addr_mask_l_e  (lsu_dtlb_addr_mask_l_e),
               .dva_din_e               (dva_din_e),
               .lsu_diagnstc_dtagv_prty_invrt_e(lsu_diagnstc_dtagv_prty_invrt_e),
               .lsu_ifu_asi_load        (lsu_ifu_asi_load),
               .lsu_ifu_asi_thrid       (lsu_ifu_asi_thrid[1:0]),
               .lsu_ifu_asi_vld         (lsu_ifu_asi_vld),
               .lsu_quad_asi_e          (lsu_quad_asi_e),
               .lsu_local_ldxa_sel_g    (lsu_local_ldxa_sel_g),
               .lsu_dtag_rsel_m         (lsu_dtag_rsel_m[3:0]),
               .lsu_tlbop_force_swo     (lsu_tlbop_force_swo),
               .lsu_atomic_pkt2_bsel_g  (lsu_atomic_pkt2_bsel_g[2:0]),
               .lsu_dcache_tag_perror_g (lsu_dcache_tag_perror_g),
               .lsu_dcache_data_perror_g(lsu_dcache_data_perror_g),
               .lsu_ifu_l2_unc_error    (lsu_ifu_l2_unc_error),
               .lsu_ifu_l2_corr_error   (lsu_ifu_l2_corr_error),
               .lsu_ifu_dcache_data_perror(lsu_ifu_dcache_data_perror),
               .lsu_ifu_dcache_tag_perror(lsu_ifu_dcache_tag_perror),
               .lsu_ifu_error_tid       (lsu_ifu_error_tid[1:0]),
               .lsu_ifu_io_error        (lsu_ifu_io_error),
               .lsu_tlu_squash_va_oor_m (lsu_tlu_squash_va_oor_m),
               .lsu_squash_va_oor_m     (lsu_squash_va_oor_m),
               .tlb_cam_hit_g           (tlb_cam_hit_g),
               .lsu_st_hw_le_g          (lsu_st_hw_le_g),
               .lsu_st_w_or_dbl_le_g    (lsu_st_w_or_dbl_le_g),
               .lsu_st_x_le_g           (lsu_st_x_le_g),
               .lsu_swap_sel_default_g  (lsu_swap_sel_default_g),
               .lsu_swap_sel_default_byte_7_2_g(lsu_swap_sel_default_byte_7_2_g),
               .lsu_st_rmo_m            (lsu_st_rmo_m),
               .lsu_bst_in_pipe_m       (lsu_bst_in_pipe_m),
               .lsu_snap_blk_st_m       (lsu_snap_blk_st_m),
               .lsu_blk_st_m            (lsu_blk_st_m),
               .lsu_blkst_pgnum_m       (lsu_blkst_pgnum_m[39:10]),
               .lsu_ffu_blk_asi_e       (lsu_ffu_blk_asi_e),
               .lsu_blk_asi_m           (lsu_blk_asi_m),
               .lsu_nonalt_nucl_access_m(lsu_nonalt_nucl_access_m),
               .dcache_alt_mx_sel_e     (dcache_alt_mx_sel_e),
               .dcache_alt_mx_sel_e_bf  (dcache_alt_mx_sel_e_bf),
               .dcache_rvld_e           (dcache_rvld_e),
               .lsu_dc_iob_access_e     (lsu_dc_iob_access_e),
               .lsu_ifu_ldst_miss_w     (lsu_ifu_ldst_miss_w),
               .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
               .lsu_ldst_inst_vld_e     (lsu_ldst_inst_vld_e),
               .lsu_local_ldxa_tlbrd_sel_g(lsu_local_ldxa_tlbrd_sel_g),
               .lsu_local_diagnstc_tagrd_sel_g(lsu_local_diagnstc_tagrd_sel_g),
               .lsu_va_wtchpt_sel_g     (lsu_va_wtchpt_sel_g),
               .asi_state_wr_thrd       (asi_state_wr_thrd[3:0]),
               .thread0_d               (thread0_d),
               .thread1_d               (thread1_d),
               .thread2_d               (),
               .thread3_d               (),
               .tlu_lsu_asi_update_g    (tlu_lsu_asi_update_g),
               .pctxt_state_wr_thrd     (pctxt_state_wr_thrd[3:0]),
               .sctxt_state_wr_thrd     (sctxt_state_wr_thrd[3:0]),
               .thread_pctxt            (thread_pctxt),
               .thread_sctxt            (thread_sctxt),
               .thread_actxt            (thread_actxt),
               .thread_default          (thread_default),
               .thread0_ctxt            (thread0_ctxt),
               .thread1_ctxt            (thread1_ctxt),
               .thread2_ctxt            (),
               .thread3_ctxt            (),
               .pid_state_wr_en         (pid_state_wr_en[3:0]),
               .thread0_e               (thread0_e),
               .thread1_e               (thread1_e),
               .thread2_e               (),
               .thread3_e               (),
               .dfture_tap_wr_mx_sel    (dfture_tap_wr_mx_sel),
               .lctl_rst                (lctl_rst[3:0]),
               .lsu_ctl_state_wr_en     (lsu_ctl_state_wr_en[3:0]),
               .lsuctl_ctlbits_wr_en    (lsuctl_ctlbits_wr_en[3:0]),
               .dfture_tap_rd_en        (dfture_tap_rd_en[3:0]),
               .bist_tap_wr_en          (bist_tap_wr_en),
               .bistctl_wr_en           (),                      // Templated
               .bist_ctl_reg_wr_en      (bist_ctl_reg_wr_en),
               .mrgn_tap_wr_en          (mrgn_tap_wr_en),
               .ldiagctl_wr_en          (ldiagctl_wr_en),
               .misc_ctl_sel_din        (misc_ctl_sel_din[3:0]),
               .lsu_asi_sel_fmx1        (lsu_asi_sel_fmx1[2:0]),
               .lsu_asi_sel_fmx2        (lsu_asi_sel_fmx2[2:0]),
               .tlb_access_en0_g        (tlb_access_en0_g),
               .tlb_access_en1_g        (tlb_access_en1_g),
               .tlb_access_en2_g        (),
               .tlb_access_en3_g        (),
               .tlb_access_sel_thrd0    (tlb_access_sel_thrd0),
               .tlb_access_sel_thrd1    (tlb_access_sel_thrd1),
               .tlb_access_sel_thrd2    (tlb_access_sel_thrd2),
               .tlb_access_sel_default  (tlb_access_sel_default),
               .mrgnctl_wr_en           (mrgnctl_wr_en),
               .hpv_priv_m              (hpv_priv_m),
               .hpstate_en_m            (hpstate_en_m),
               .dcache_arry_data_sel_m  (dcache_arry_data_sel_m),
               .dtlb_bypass_m           (dtlb_bypass_m),
               .lsu_alt_space_m         (lsu_alt_space_m),
               .atomic_m                (atomic_m),
               .ldst_dbl_m              (ldst_dbl_m),
               .fp_ldst_m               (fp_ldst_m),
               .lda_internal_m          (lda_internal_m),
               .sta_internal_m          (sta_internal_m),
               .cam_real_m              (cam_real_m),
               .data_rd_vld_g           (data_rd_vld_g),
               .tag_rd_vld_g            (tag_rd_vld_g),
               .ldst_sz_m               (ldst_sz_m[1:0]),
               .asi_internal_m          (asi_internal_m),
               .rd_only_ltlb_asi_e      (rd_only_ltlb_asi_e),
               .wr_only_ltlb_asi_e      (wr_only_ltlb_asi_e),
               .dfill_tlb_asi_e         (dfill_tlb_asi_e),
               .ifill_tlb_asi_e         (ifill_tlb_asi_e),
               .nofault_asi_m           (nofault_asi_m),
               .as_if_user_asi_m        (as_if_user_asi_m),
               .atomic_asi_m            (atomic_asi_m),
               .phy_use_ec_asi_m        (phy_use_ec_asi_m),
               .phy_byp_ec_asi_m        (phy_byp_ec_asi_m),
               .quad_asi_m              (quad_asi_m),
               .binit_quad_asi_m        (binit_quad_asi_m),
               .blk_asi_m               (blk_asi_m),
               .recognized_asi_m        (recognized_asi_m),
               .strm_asi_m              (strm_asi_m),
               .mmu_rd_only_asi_m       (mmu_rd_only_asi_m),
               .rd_only_asi_m           (rd_only_asi_m),
               .wr_only_asi_m           (wr_only_asi_m),
               .unimp_asi_m             (unimp_asi_m),
               .va_wtchpt_cmp_en_m      (va_wtchpt_cmp_en_m),
               .lsu_tlu_async_ttype_vld_w2(lsu_tlu_async_ttype_vld_w2),
               .lsu_tlu_async_ttype_w2  (lsu_tlu_async_ttype_w2[6:0]),
               .lsu_tlu_async_tid_w2    (lsu_tlu_async_tid_w2[1:0]),
               .async_tlb_index         (async_tlb_index[5:0]),
               .l2fill_vld_m            (l2fill_vld_m),
               .ld_thrd_byp_mxsel_m     (ld_thrd_byp_mxsel_m[3:0]),
               .morphed_addr_m          (morphed_addr_m[7:0]),
               .signed_ldst_byte_m      (signed_ldst_byte_m),
               .signed_ldst_hw_m        (signed_ldst_hw_m),
               .signed_ldst_w_m         (signed_ldst_w_m),
               .lsu_tlb_asi_data_perr_g (lsu_tlb_asi_data_perr_g),
               .lsu_tlb_asi_tag_perr_g  (lsu_tlb_asi_tag_perr_g),
               .lsu_sscan_data          (lsu_sscan_data[14:13]), // Templated
               .lsu_ld_inst_vld_g       (lsu_ld_inst_vld_g[3:0]),
               .lsu_dcache_rand         (lsu_dcache_rand[1:0]),
               .lsu_encd_way_hit        (lsu_encd_way_hit[1:0]),
               .lsu_way_hit_or          (lsu_way_hit_or),
               .lsu_memref_m            (lsu_memref_m),
               .lsu_flsh_inst_m         (lsu_flsh_inst_m),
               .lsu_ifu_asi_data_en_l   (lsu_ifu_asi_data_en_l),
               .lsu_dcache_fill_addr_e  (lsu_dcache_fill_addr_e[(6 + 4):3]),
               .lsu_dcache_fill_addr_e_err(lsu_dcache_fill_addr_e_err[(6 + 4):4]),
               .lsu_thread_g            (lsu_thread_g[3:0]),
               .lmq_ldd_vld             (lmq_ldd_vld),
               .lsu_bist_rsel_way_e     (lsu_bist_rsel_way_e[4-1:0]),
               .lsu_dcache_fill_way_e   (lsu_dcache_fill_way_e[4-1:0]),
               .lmq_ld_addr_b3          (lmq_ld_addr_b3),
               .lsu_outstanding_rmo_st_max(lsu_outstanding_rmo_st_max[3:0]),
               .lsu_dcfill_data_mx_sel_e(lsu_dcfill_data_mx_sel_e),
               // Inputs
               .se                      (se),
               .sehold                  (sehold),
               .rst_tri_en              (mux_drive_disable),     // Templated
               .rclk                    (clk),                   // Templated
               .grst_l                  (grst_l),
               .arst_l                  (arst_l),
               .lsu_diag_va_prty_invrt  (lsu_diag_va_prty_invrt),
               .dva_svld_e              (dva_svld_e),
               .dva_snp_bit_wr_en_e     (dva_snp_bit_wr_en_e[(4*4-1):0]),
               .dva_snp_addr_e          (dva_snp_addr_e[(6 + 4)-6:0]),
               .lsu_tte_data_cp_g       (tlb_rd_tte_data[7]), // Templated
               .lsu_l2fill_vld          (lsu_l2fill_vld),
               .ld_inst_vld_e           (ifu_lsu_ld_inst_e),     // Templated
               .st_inst_vld_e           (ifu_lsu_st_inst_e),     // Templated
               .ifu_lsu_ldst_fp_e       (ifu_lsu_ldst_fp_e),
               .ldst_sz_e               (ifu_lsu_ldst_size_e[1:0]), // Templated
               .lsu_ldst_va_b12_b11_m   (lsu_ldst_va_m[12:11]),  // Templated
               .lsu_ldst_va_b7_b0_m     (lsu_ldst_va_m[7:0]),    // Templated
               .ifu_lsu_rd_e            (ifu_lsu_rd_e[4:0]),
               .tlb_cam_hit             (tlb_cam_hit),
               .ifu_tlu_sraddr_d        (ifu_tlu_sraddr_d[6:0]),
               .ifu_tlu_wsr_inst_d      (ifu_tlu_wsr_inst_d),
               .ifu_lsu_alt_space_d     (ifu_lsu_alt_space_d),
               .tlu_lsu_int_ldxa_vld_w2 (tlu_lsu_int_ldxa_vld_w2),
               .tlu_lsu_int_ld_ill_va_w2(tlu_lsu_int_ld_ill_va_w2),
               .tlu_lsu_ldxa_tid_w2     (tlu_lsu_ldxa_tid_w2[1:0]),
               .ifu_lsu_ldxa_data_vld_w2(ifu_lsu_ldxa_data_vld_w2),
               .ifu_lsu_ldxa_illgl_va_w2(ifu_lsu_ldxa_illgl_va_w2),
               .ifu_lsu_ldxa_tid_w2     (ifu_lsu_ldxa_tid_w2[1:0]),
               .ifu_lsu_asi_rd_unc      (ifu_lsu_asi_rd_unc),
               .tlu_lsu_tl_zero         (tlu_lsu_tl_zero[3:0]),
               .ifu_lsu_thrid_s         (ifu_lsu_thrid_s[1:0]),
               .ifu_lsu_ldst_dbl_e      (ifu_lsu_ldst_dbl_e),
               .ld_stb_full_raw_w2      (ld_stb_full_raw_w2),
               .ld_sec_active           (ld_sec_active),
               .ifu_tlu_inst_vld_m      (ifu_tlu_inst_vld_m_bf1), // Templated
               .lsu_l2fill_bendian_m    (lsu_l2fill_bendian_m),
               .lmq0_l2fill_fpld        (lmq0_l2fill_fpld),
               .lmq1_l2fill_fpld        (lmq1_l2fill_fpld),
               .lmq2_l2fill_fpld        (lmq2_l2fill_fpld),
               .lmq3_l2fill_fpld        (lmq3_l2fill_fpld),
               .cache_way_hit_buf1      (cache_way_hit_buf1[4-1:0]),
               .cache_hit               (cache_hit),
               .lmq0_byp_misc_sz        (lmq0_byp_misc_sz[1:0]),
               .lmq1_byp_misc_sz        (lmq1_byp_misc_sz[1:0]),
               .lmq2_byp_misc_sz        (lmq2_byp_misc_sz[1:0]),
               .lmq3_byp_misc_sz        (lmq3_byp_misc_sz[1:0]),
               .lsu_l2fill_sign_extend_m(lsu_l2fill_sign_extend_m),
               .lsu_l1hit_sign_extend_e (ifu_lsu_sign_ext_e),    // Templated
               .tlu_lsu_pstate_cle      (tlu_lsu_pstate_cle[3:0]),
               .tlu_lsu_pstate_am       (tlu_lsu_pstate_am[3:0]),
               .tlb_pgnum               ({tlb_pgnum_buf[39:10]}), // Templated
               .tlb_demap_nctxt         (tlu_dtlb_dmp_nctxt_g),  // Templated
               .tlb_demap_pctxt         (tlu_dtlb_dmp_pctxt_g),  // Templated
               .tlb_demap_sctxt         (tlu_dtlb_dmp_sctxt_g),  // Templated
               .tlb_demap_actxt         (tlu_dtlb_dmp_actxt_g),  // Templated
               .tlb_demap_thrid         (tlu_idtlb_dmp_thrid_g[1:0]), // Templated
               .ifu_lsu_casa_e          (ifu_lsu_casa_e),
               .ifu_lsu_ldstub_e        (ifu_lsu_ldstub_e),
               .ifu_lsu_swap_e          (ifu_lsu_swap_e),
               .lsu_atm_st_cmplt_e      (lsu_atm_st_cmplt_e),
               .lsu_cpx_pkt_atm_st_cmplt(lsu_cpx_pkt_atm_st_cmplt),
               .spu_lsu_ldxa_data_vld_w2(spu_lsu_ldxa_data_vld_w2),
               .spu_lsu_ldxa_illgl_va_w2(spu_lsu_ldxa_illgl_va_w2),
               .spu_lsu_ldxa_tid_w2     (spu_lsu_ldxa_tid_w2[1:0]),
               .spu_lsu_stxa_ack_tid    (spu_lsu_stxa_ack_tid[1:0]),
               .spu_lsu_stxa_ack        (spu_lsu_stxa_ack),
               .spu_lsu_unc_error_w2    (spu_lsu_unc_error_w2),
               .spu_lsu_int_w2          (spu_lsu_int_w2),
               .tlu_lsu_stxa_ack        (tlu_lsu_stxa_ack),
               .tlu_lsu_stxa_ack_tid    (tlu_lsu_stxa_ack_tid[1:0]),
               .lsu_tlb_invert_endian_g (tlb_rd_tte_data_ie_buf), // Templated
               .lmq0_ncache_ld          (lmq0_ncache_ld),
               .lmq1_ncache_ld          (lmq1_ncache_ld),
               .lmq2_ncache_ld          (lmq2_ncache_ld),
               .lmq3_ncache_ld          (lmq3_ncache_ld),
               .ifu_tlu_mb_inst_e       (ifu_tlu_mb_inst_e),
               .ifu_tlu_flsh_inst_e     (ifu_tlu_flsh_inst_e),
               .lsu_stb_empty           ({2'b00, lsu_stb_empty[1:0]}),
               .tlu_dtlb_tag_rd_g       (tlu_dtlb_tag_rd_g),
               .tlu_dtlb_data_rd_g      (tlu_dtlb_data_rd_g),
                
                .tlu_dtlb_csm_rd_g      (tlu_dtlb_csm_rd_g),
                .tlb_rd_tte_csm         (tlb_rd_tte_csm),
                
               .tlu_dtlb_dmp_vld_g      (tlu_dtlb_dmp_vld_g),
               .tlu_dtlb_dmp_all_g      (tlu_dtlb_dmp_all_g),
               .tlu_dtlb_rw_index_vld_g (tlu_dtlb_rw_index_vld_g),
               .tlu_dtlb_invalidate_all_g(tlu_dtlb_invalidate_all_g),
               .lsu_st_wr_dcache        (lsu_st_wr_dcache),
               .tlu_lsu_asi_update_m    (tlu_lsu_asi_update_m),
               .tlu_lsu_tid_m           (tlu_lsu_tid_m[1:0]),
               .lsu_rd_dtag_parity_g    (lsu_rd_dtag_parity_g[4-1:0]),
               .dcache_rparity_err_wb   (dcache_rparity_err_wb),
               .lsu_diagnstc_wr_data_b0 (lsu_diagnstc_wr_data_b0),
               .lsu_byp_ldd_oddrd_m     (lsu_byp_ldd_oddrd_m),
               .tlu_lsu_redmode         (tlu_lsu_redmode[3:0]),
               .tlu_lsu_redmode_rst_d1  (tlu_lsu_redmode_rst_d1[3:0]),
               .dva_vld_m               (dva_vld_m[4-1:0]),
               .lsu_dfill_tid_e         (dfq_tid[1:0]),          // Templated
               .ifu_lsu_asi_ack         (ifu_lsu_asi_ack),
               .lsu_intrpt_cmplt        (lsu_intrpt_cmplt[3:0]),
               .lsu_iobrdge_tap_rq_type_b8(lsu_iobrdge_tap_rq_type[8:8]), // Templated
               .lsu_iobrdge_tap_rq_type_b6_b3(lsu_iobrdge_tap_rq_type[6:3]), // Templated
               .lsu_iobrdge_tap_rq_type_b1_b0(lsu_iobrdge_tap_rq_type[1:0]), // Templated
               .lsu_iobrdge_fwd_pkt_vld (lsu_iobrdge_fwd_pkt_vld),
               .lsu_cpx_ld_dtag_perror_e(lsu_cpx_ld_dtag_perror_e),
               .lsu_cpx_ld_dcache_perror_e(lsu_cpx_ld_dcache_perror_e),
               .lsu_cpx_pkt_ld_err      (lsu_cpx_pkt_ld_err[1:0]),
               .ifu_lsu_nceen           (ifu_lsu_nceen[3:0]),
               .tlu_lsu_ldxa_async_data_vld(tlu_lsu_ldxa_async_data_vld),
               .tlu_lsu_hpv_priv        (tlu_lsu_hpv_priv[3:0]),
               .tlu_lsu_hpstate_en      (tlu_lsu_hpstate_en[3:0]),
               .ifu_lsu_memref_d        (ifu_lsu_memref_d),
               .ifu_lsu_pref_inst_e     (ifu_lsu_pref_inst_e),
               .lsu_pref_pcx_req        (lsu_pref_pcx_req),
               .lsu_cpx_pkt_prefetch2   (lsu_cpx_pkt_prefetch2),
               .lsu_ld_pcx_rq_sel_d2    (lsu_ld_pcx_rq_sel_d2[3:0]),
               .lsu_pcx_req_squash_d1   (lsu_pcx_req_squash_d1),
               .lsu_bld_helper_cmplt_m  (lsu_bld_helper_cmplt_m),
               .lsu_bld_cnt_m           (lsu_bld_cnt_m[2:0]),
               .lsu_bld_reset           (lsu_bld_reset),
               .ffu_lsu_blk_st_e        (ffu_lsu_blk_st_e),
               .lsu_stb_rmo_st_issue    ({2'b00, lsu_stb_rmo_st_issue[1:0]}),
               .lsu_cpx_rmo_st_ack      (lsu_cpx_rmo_st_ack[3:0]),
               .lsu_dfq_flsh_cmplt      (lsu_dfq_flsh_cmplt[3:0]),
               .stb_cam_hit             (stb_cam_hit_bf1),       // Templated
               .ifu_tlu_flush_m         (ifu_tlu_flush_m),
               .ctu_sscan_tid           (ctu_sscan_tid[3:0]),
               .tte_data_perror_unc     (tte_data_perror_unc),
               .asi_tte_data_perror     (asi_tte_data_perror),
               .asi_tte_tag_perror      (asi_tte_tag_perror),
               .tlu_dtlb_rw_index_g     (tlu_dtlb_rw_index_g[5:0]),
               .lsu_local_early_flush_g (lsu_local_early_flush_g),
               .lsu_dfq_vld             (lsu_dfq_vld),
               .gdbginit_l              (gdbginit_l),
               .dc_direct_map           (dc_direct_map),
               .asi_d                   (asi_d[7:0]),
               .lsu_dctl_asi_state_m    (lsu_dctl_asi_state_m[7:0]),
               .lsu_ldst_va_g           (lsu_ldst_va_g[7:0]),
               .lsu_ifu_err_addr_b39    (lsu_ifu_err_addr[39]),  // Templated
               .lsu_dp_ctl_reg0         (lsu_dp_ctl_reg0[5:0]),
               .lsu_dp_ctl_reg1         (lsu_dp_ctl_reg1[5:0]),
               .lsu_dp_ctl_reg2         (6'b000000),
               .lsu_dp_ctl_reg3         (6'b000000),
               .ldd_in_dfq_out          (ldd_in_dfq_out),
               .dcache_iob_addr_e       (dcache_iob_addr_e[(6 + 4)-3:0]),
               .mbist_dcache_index      (mbist_dcache_index[(6 + 4)-4:0]),
               .mbist_dcache_word       (mbist_dcache_word),
               .lsu_diagnstc_wr_addr_e  (lsu_diagnstc_wr_addr_e[(6 + 4):0]),
               .st_dcfill_addr          (st_dcfill_addr[(6 + 4):0]),
               .lsu_dfq_ld_vld          (lsu_dfq_ld_vld),
               .lsu_dfq_st_vld          (lsu_dfq_st_vld),
               .lmq0_ldd_vld            (lmq0_ldd_vld),
               .lmq1_ldd_vld            (lmq1_ldd_vld),
               .lmq2_ldd_vld            (lmq2_ldd_vld),
               .lmq3_ldd_vld            (lmq3_ldd_vld),
               .lsu_dfq_byp_tid         (lsu_dfq_byp_tid[1:0]),
               .dfq_byp_ff_en           (dfq_byp_ff_en),
               .lsu_dcache_iob_way_e    (lsu_dcache_iob_way_e[2-1:0]),
               .mbist_dcache_way        (mbist_dcache_way[1:0]),
               .lsu_diagnstc_wr_way_e   (lsu_diagnstc_wr_way_e[2-1:0]),
               .lsu_st_way_e            (lsu_st_way_e[2-1:0]),
               .lmq0_pcx_pkt_way        (lmq0_pcx_pkt_way[2-1:0]),
               .lmq1_pcx_pkt_way        (lmq1_pcx_pkt_way[2-1:0]),
               .lmq2_pcx_pkt_way        ({2{1'b0}}),
               .lmq3_pcx_pkt_way        ({2{1'b0}}),
               .lmq0_ld_rq_type         (lmq0_ld_rq_type[2:0]),
               .lmq1_ld_rq_type         (lmq1_ld_rq_type[2:0]),
               .lmq2_ld_rq_type         (lmq2_ld_rq_type[2:0]),
               .lmq3_ld_rq_type         (lmq3_ld_rq_type[2:0]),
               .lmq0_pcx_pkt_addr       (lmq0_pcx_pkt_addr[(6 + 4):0]),
               .lmq1_pcx_pkt_addr       (lmq1_pcx_pkt_addr[(6 + 4):0]),
               .lmq2_pcx_pkt_addr       (lmq2_pcx_pkt_addr[(6 + 4):0]),
               .lmq3_pcx_pkt_addr       (lmq3_pcx_pkt_addr[(6 + 4):0]),
               .lsu_ttype_vld_m2        (lsu_ttype_vld_m2_bf1),  // Templated
               .tlu_early_flush_pipe2_w (tlu_early_flush_pipe2_w),
               .lsu_st_dcfill_size_e    (lsu_st_dcfill_size_e[1:0]),
               .mbist_dcache_write      (mbist_dcache_write),
               .mbist_dcache_read       (mbist_dcache_read),
               .cfg_asi_lsu_ldxa_vld_w2 (cfg_asi_lsu_ldxa_vld_w2),
               .cfg_asi_lsu_ldxa_tid_w2 (cfg_asi_lsu_ldxa_tid_w2)
               );
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*lsu_dcdp AUTO_TEMPLATE (
           .dcache_alt_mx_sel_e  (dcache_alt_mx_sel_e_bf),
           .rst_tri_en           (mux_drive_disable),
           .rclk                 (clk));
*/

lsu_dcdp dcdp (
               .so                      (scan0_2),
               .si                      (scan0_1),
                /*AUTOINST*/
               // Outputs
               .dcache_rdata_wb_buf     (dcache_rdata_wb_buf[63:0]),
               .mbist_dcache_data_in    (mbist_dcache_data_in[71:0]),
               .lsu_exu_dfill_data_w2   (lsu_exu_dfill_data_w2[63:0]),
               .lsu_ffu_ld_data         (lsu_ffu_ld_data[63:0]),
               .stb_rdata_ramc_buf      (stb_rdata_ramc_buf[14:9]),
               // Inputs
               .rclk                    (clk),                   // Templated
               .se                      (se),
               .rst_tri_en              (mux_drive_disable),     // Templated
               .dcache_rdata_wb         (dcache_rdata_wb[63:0]),
               .dcache_rparity_wb       (dcache_rparity_wb[7:0]),
                 .dcache_rdata_msb_m (dcache_rdata_msb_m),
                 // .dcache_rdata_msb_w0_m (dcache_rdata_msb_w0_m[7:0]),
                 // .dcache_rdata_msb_w1_m (dcache_rdata_msb_w1_m[7:0]),
                 // .dcache_rdata_msb_w2_m (dcache_rdata_msb_w2_m[7:0]),
                 // .dcache_rdata_msb_w3_m (dcache_rdata_msb_w3_m[7:0]),
               .lsu_bist_rsel_way_e     (lsu_bist_rsel_way_e[4-1:0]),
               .dcache_alt_mx_sel_e     (dcache_alt_mx_sel_e_bf), // Templated
               .cache_way_hit_buf2      (cache_way_hit_buf2[4-1:0]),
               .morphed_addr_m          (morphed_addr_m[7:0]),
               .signed_ldst_byte_m      (signed_ldst_byte_m),
               .signed_ldst_hw_m        (signed_ldst_hw_m),
               .signed_ldst_w_m         (signed_ldst_w_m),
               .merge7_sel_byte0_m      (merge7_sel_byte0_m),
               .merge7_sel_byte7_m      (merge7_sel_byte7_m),
               .merge6_sel_byte1_m      (merge6_sel_byte1_m),
               .merge6_sel_byte6_m      (merge6_sel_byte6_m),
               .merge5_sel_byte2_m      (merge5_sel_byte2_m),
               .merge5_sel_byte5_m      (merge5_sel_byte5_m),
               .merge4_sel_byte3_m      (merge4_sel_byte3_m),
               .merge4_sel_byte4_m      (merge4_sel_byte4_m),
               .merge3_sel_byte0_m      (merge3_sel_byte0_m),
               .merge3_sel_byte3_m      (merge3_sel_byte3_m),
               .merge3_sel_byte4_m      (merge3_sel_byte4_m),
               .merge3_sel_byte7_default_m(merge3_sel_byte7_default_m),
               .merge3_sel_byte_m       (merge3_sel_byte_m),
               .merge2_sel_byte1_m      (merge2_sel_byte1_m),
               .merge2_sel_byte2_m      (merge2_sel_byte2_m),
               .merge2_sel_byte5_m      (merge2_sel_byte5_m),
               .merge2_sel_byte6_default_m(merge2_sel_byte6_default_m),
               .merge2_sel_byte_m       (merge2_sel_byte_m),
               .merge0_sel_byte0_m      (merge0_sel_byte0_m),
               .merge0_sel_byte1_m      (merge0_sel_byte1_m),
               .merge0_sel_byte2_m      (merge0_sel_byte2_m),
               .merge0_sel_byte3_default_m(merge0_sel_byte3_default_m),
               .merge0_sel_byte4_m      (merge0_sel_byte4_m),
               .merge0_sel_byte5_m      (merge0_sel_byte5_m),
               .merge0_sel_byte6_m      (merge0_sel_byte6_m),
               .merge0_sel_byte7_default_m(merge0_sel_byte7_default_m),
               .merge1_sel_byte0_m      (merge1_sel_byte0_m),
               .merge1_sel_byte1_m      (merge1_sel_byte1_m),
               .merge1_sel_byte2_m      (merge1_sel_byte2_m),
               .merge1_sel_byte3_default_m(merge1_sel_byte3_default_m),
               .merge1_sel_byte4_m      (merge1_sel_byte4_m),
               .merge1_sel_byte5_m      (merge1_sel_byte5_m),
               .merge1_sel_byte6_m      (merge1_sel_byte6_m),
               .merge1_sel_byte7_default_m(merge1_sel_byte7_default_m),
               .merge0_sel_byte_1h_m    (merge0_sel_byte_1h_m),
               .merge1_sel_byte_1h_m    (merge1_sel_byte_1h_m),
               .merge1_sel_byte_2h_m    (merge1_sel_byte_2h_m),
               .stb_rdata_ramc          (stb_rdata_ramc[14:9]));

/*
bw_r_tlb  AUTO_TEMPLATE (
                 .rst_tri_en            (mem_write_disable),
                 .rclk                  (clk),
                 .adj                   (lsu_dtlb_mrgn[7:0]),
                 .cache_set_vld         (dva_vld_m[`L1D_WAY_COUNT-1:0]),
                 .grst_l                (1'b1), // hard reset not to be used
                 .rst_soft_l            (lsu_dtlb_invalid_all_l_m),
                 .hold              	(sehold),
                 .tlb_addr_mask_l       (lsu_dtlb_addr_mask_l_e),
                 .tlb_bypass            (lsu_dtlb_bypass_e),
                 .tlb_bypass_va         (exu_lsu_ldst_va_e[12:10]),
                 .tlb_cam_pid           (lsu_dtlb_cam_pid_e[2:0]),
                 //.tlb_cam_real          (lsu_dtlb_cam_real_e),
                 .tlb_cam_vld           (tlb_ldst_cam_vld),
                 .tlb_demap             (lsu_dtlb_dmp_vld_e),
                 .tlb_demap_all         (lsu_dtlb_dmp_all_e),
                 .tlb_demap_auto        (tlu_dtlb_dmp_actxt_g),
                 //.tlb_demap_ctxt        (tlu_dtlb_dmp_by_ctxt_g),
                 .tlb_demap_key         (tlu_idtlb_dmp_key_g[40:0]),
                 .tlb_rd_data_vld       (lsu_dtlb_data_rd_e),
                 .tlb_rd_tag_vld        (lsu_dtlb_tag_rd_e),
                 .tlb_rw_index          (tlu_dtlb_rw_index_g[5:0]),
                 .tlb_rw_index_vld      (lsu_dtlb_rwindex_vld_e),
                 .tlb_wr_tte_data       (tlu_dtlb_tte_data_w2[42:0]),
                 .tlb_wr_tte_tag        (tlu_dtlb_tte_tag_w2[58:0]),
                 .tlb_wr_vld            (lsu_dtlb_wr_vld_e),
                 .cache_ptag_w0   ({dtag_rdata_w0_m[28:0], lsu_ldst_va_m[10]}),
                 .cache_ptag_w1   ({dtag_rdata_w1_m[28:0], lsu_ldst_va_m[10]}),
                 .cache_ptag_w2   ({dtag_rdata_w2_m[28:0], lsu_ldst_va_m[10]}),
                 .cache_ptag_w3   ({dtag_rdata_w3_m[28:0], lsu_ldst_va_m[10]}));
*/

bw_r_dtlb dtlb  (
                .so                     (short_scan0_4),
                .si                     (short_scan0_3),
          .tlb_cam_key   ( {exu_lsu_ldst_va_e[47:28], 1'b1,
                            exu_lsu_ldst_va_e[27:22], 1'b1,
			                      exu_lsu_ldst_va_e[21:16], 1'b1,
                            exu_lsu_ldst_va_e[15:13], 1'b1,
                            //1'b1,
			                      lsu_dtlb_cam_real_e,
			                      lsu_dtlb_cam_real_e}
                          ),

                 /*AUTOINST*/
                // Outputs
                
                .tlb_rd_tte_csm         (tlb_rd_tte_csm),
                .tlb_rd_tte_csm_crit    (tlb_rd_tte_csm_crit),
                
                .tlb_rd_tte_tag         (tlb_rd_tte_tag[58:0]),
                .tlb_rd_tte_data        (tlb_rd_tte_data[42:0]),
                .tlb_pgnum              (tlb_pgnum[39:10]),
                .tlb_pgnum_crit         (tlb_pgnum_crit[39:10]),
                .tlb_cam_hit            (tlb_cam_hit),
                .cache_way_hit          (cache_way_hit[4-1:0]),
                .cache_hit              (cache_hit),

                // Inputs
                
                .tlb_wr_tte_csm_thrid   (tlu_idtlb_dmp_thrid_g[1:0]),
                .tlb_wr_tte_csm         (tlu_dtlb_tte_csm_w2),
                .tlb_rd_csm_vld         (lsu_dtlb_csm_rd_e),
                .tlb_wr_csm_sel         (tlu_dtlb_wr_csm_sel_g),

                .cfg_csm_tlb_state      (cfg_lsu_csm_dtlb_state),
                .cfg_csm_tlb_chipid     (cfg_lsu_csm_dtlb_chipid),
                .cfg_csm_tlb_x          (cfg_lsu_csm_dtlb_x),
                .cfg_csm_tlb_y          (cfg_lsu_csm_dtlb_y),
                .cfg_csm_tlb_hdid       (cfg_lsu_csm_dtlb_hdid),
                .cfg_csm_tlb_hd_size    (cfg_lsu_csm_dtlb_hd_size),
                .cfg_csm_tlb_sdid       (cfg_lsu_csm_dtlb_sdid),
                .cfg_csm_tlb_lsid       (cfg_lsu_csm_dtlb_lsid),
                


                .tlb_cam_vld            (tlb_ldst_cam_vld),      // Templated
                .tlb_cam_pid            (lsu_dtlb_cam_pid_e[2:0]), // Templated
                .tlb_demap_key          (tlu_idtlb_dmp_key_g[40:0]), // Templated
                .tlb_addr_mask_l        (lsu_dtlb_addr_mask_l_e), // Templated
                .tlb_ctxt               (tlb_ctxt[12:0]),
                .tlb_wr_vld             (lsu_dtlb_wr_vld_e),     // Templated
                .tlb_wr_tte_tag         (tlu_dtlb_tte_tag_w2[58:0]), // Templated
                .tlb_wr_tte_data        (tlu_dtlb_tte_data_w2[42:0]), // Templated
                .tlb_rd_tag_vld         (lsu_dtlb_tag_rd_e),     // Templated
                .tlb_rd_data_vld        (lsu_dtlb_data_rd_e),    // Templated
                .tlb_rw_index           (tlu_dtlb_rw_index_g[5:0]), // Templated
                .tlb_rw_index_vld       (lsu_dtlb_rwindex_vld_e), // Templated
                .tlb_demap              (lsu_dtlb_dmp_vld_e),    // Templated
                .tlb_demap_auto         (tlu_dtlb_dmp_actxt_g),  // Templated
                .tlb_demap_all          (lsu_dtlb_dmp_all_e),    // Templated
                .cache_ptag          ({lsu_ldst_va_m[10], dtag_rdata_m}), // Templated
                .cache_set_vld          (dva_vld_m[4-1:0]),        // Templated
                .tlb_bypass_va          (exu_lsu_ldst_va_e[12:10]), // Templated
                .tlb_bypass             (lsu_dtlb_bypass_e),     // Templated
                .se                     (se),
                .hold                   (sehold),                // Templated
                .adj                    (lsu_dtlb_mrgn[7:0]),    // Templated
                .arst_l                 (arst_l),
                .rst_soft_l             (lsu_dtlb_invalid_all_l_m), // Templated
                .rclk                   (clk),                   // Templated
                .rst_tri_en             (mem_write_disable));     // Templated
/*
lsu_stb_rwctl  AUTO_TEMPLATE  (
                         .rst_tri_en              (mux_drive_disable),
                         .rclk             (clk),
                         .stb_cam_hit      (stb_cam_hit_bf1),
 			                   .lsu_st_ack_rq_stb(4'b0000),
                         .ffu_lsu_blk_st_tid_m (ffu_lsu_data[77:76]),
                         .ld_inst_vld_e (ifu_lsu_ld_inst_e),
                         .ldst_sz_e     (ifu_lsu_ldst_size_e[1:0]),
                         .st_inst_vld_e (ifu_lsu_st_inst_e),
                         .stb_rdata_ramc_b8t0 (stb_rdata_ramc[8:0]),
                         .tlb_pgnum_b39_g(tlb_pgnum_buf[39]));
*/
 // Use two threads unless this is defined

   lsu_stb_rwctl stb_rwctl (
                         .so            (short_scan1_4),
                         .si            (short_scan1_3),
                         .stb_wdata_ramd_b75_b64(stb_wdata_ramd_b75_b64[75:64]),
                           .stb_ldst_byte_msk_min   (stb_ldst_byte_msk_min[7:0]),
                         /*AUTOINST*/
                         // Outputs
                         .lsu_stbctl_flush_pipe_w(lsu_stbctl_flush_pipe_w),
                         .stb_cam_wr_no_ivld_m(stb_cam_wr_no_ivld_m),
                         .ld_rawp_st_ced_w2(ld_rawp_st_ced_w2),
                         .stb_data_wr_ptr(stb_data_wr_ptr[4:0]),
                         .stb_data_wptr_vld(stb_data_wptr_vld),
                         .stb_data_rd_ptr(stb_data_rd_ptr[4:0]),
                         .stb_data_rptr_vld(stb_data_rptr_vld),
                         .stb_cam_cm_tid(stb_cam_cm_tid[1:0]),
                         .stb_ldst_byte_msk(stb_ldst_byte_msk[7:0]),
                         .stb_cam_rw_ptr(stb_cam_rw_ptr[4:0]),
                         .stb_cam_wptr_vld(stb_cam_wptr_vld),
                         .stb_cam_rptr_vld(stb_cam_rptr_vld),
                         .lsu_st_sz_bhww_m(lsu_st_sz_bhww_m),
                         .lsu_st_sz_dw_m(lsu_st_sz_dw_m),
                         .lsu_st_sz_bhw_m(lsu_st_sz_bhw_m),
                         .lsu_st_sz_wdw_m(lsu_st_sz_wdw_m),
                         .lsu_st_sz_b_m (lsu_st_sz_b_m),
                         .lsu_st_sz_w_m (lsu_st_sz_w_m),
                         .lsu_st_sz_hw_m(lsu_st_sz_hw_m),
                         .lsu_st_sz_hww_m(lsu_st_sz_hww_m),
                         .ld_rawp_st_ackid_w2(ld_rawp_st_ackid_w2[2:0]),
                         .stb_flush_st_g(stb_flush_st_g[3:0]),
                         .stb_cam_wvld_m(stb_cam_wvld_m[3:0]),
                         .lsu_st_rq_type_m(lsu_st_rq_type_m[2:1]),
                         .lsu_stb_data_early_sel_e(lsu_stb_data_early_sel_e[3:0]),
                         .lsu_stb_data_final_sel_m(lsu_stb_data_final_sel_m),
                         .lsu_ldquad_inst_m(lsu_ldquad_inst_m),
                         .stb_thrd_en_g (stb_thrd_en_g[3:0]),
                         .flsh_inst_m   (flsh_inst_m),
                         .lsu_stb_va_m  (lsu_stb_va_m[9:3]),
                         .lsu_stb_empty_buf(lsu_stb_empty_buf[3:0]),
                         .lsu_spu_stb_empty(lsu_spu_stb_empty[3:0]),
                         .ifu_tlu_inst_vld_m_bf1(ifu_tlu_inst_vld_m_bf1),
                         .ifu_tlu_inst_vld_m_bf2(ifu_tlu_inst_vld_m_bf2),
                         .lsu_ifu_stbcnt0(lsu_ifu_stbcnt0[3:0]),
                         .lsu_ifu_stbcnt1(lsu_ifu_stbcnt1[3:0]),
                         .lsu_ifu_stbcnt2(lsu_ifu_stbcnt2[3:0]),
                         .lsu_ifu_stbcnt3(lsu_ifu_stbcnt3[3:0]),
                         .lsu_ffu_stb_full0(lsu_ffu_stb_full0),
                         .lsu_ffu_stb_full1(lsu_ffu_stb_full1),
                         .lsu_ffu_stb_full2(lsu_ffu_stb_full2),
                         .lsu_ffu_stb_full3(lsu_ffu_stb_full3),
                         // Inputs
                         .rclk          (clk),                   // Templated
                         .rst_tri_en    (mux_drive_disable),     // Templated
                         .se            (se),
                         .ld_inst_vld_e (ifu_lsu_ld_inst_e),     // Templated
                         .ldst_sz_e     (ifu_lsu_ldst_size_e[1:0]), // Templated
                         .st_inst_vld_e (ifu_lsu_st_inst_e),     // Templated
                         .stb_pcx_rptr0 (stb_pcx_rptr0[2:0]),
                         .stb_wrptr0    (stb_wrptr0[2:0]),
                         .stb_pcx_rptr1 (stb_pcx_rptr1[2:0]),
                         .stb_wrptr1    (stb_wrptr1[2:0]),
                         .stb_pcx_rptr2 (stb_pcx_rptr2[2:0]),
                         .stb_wrptr2    (stb_wrptr2[2:0]),
                         .stb_pcx_rptr3 (stb_pcx_rptr3[2:0]),
                         .stb_wrptr3    (stb_wrptr3[2:0]),
                         .stb_cam_hit_ptr(stb_cam_hit_ptr[2:0]),
                         .stb_cam_hit   (stb_cam_hit_bf1),       // Templated
                         .lsu_ldst_va_m (lsu_ldst_va_m[9:0]),
                         .sta_internal_m(sta_internal_m),
                         .ifu_tlu_thrid_e(ifu_tlu_thrid_e[1:0]),
                         .tlu_exu_early_flush_pipe_w(tlu_exu_early_flush_pipe_w),
                         .lsu_ttype_vld_m2(lsu_ttype_vld_m2),
                         .ifu_lsu_flush_w(ifu_lsu_flush_w),
                         .lsu_defr_trp_taken_g(lsu_defr_trp_taken_g),
                         .ifu_lsu_casa_e(ifu_lsu_casa_e),
                         .ifu_lsu_ldstub_e(ifu_lsu_ldstub_e),
                         .ifu_lsu_swap_e(ifu_lsu_swap_e),
                         .ifu_lsu_ldst_dbl_e(ifu_lsu_ldst_dbl_e),
                         .stb_state_ced0(stb_state_ced0[7:0]),
                         .stb_state_ced1(stb_state_ced1[7:0]),
                         .stb_state_ced2(stb_state_ced2[7:0]),
                         .stb_state_ced3(stb_state_ced3[7:0]),
                         .stb_ld_full_raw(stb_ld_full_raw[7:0]),
                         .stb_ld_partial_raw(stb_ld_partial_raw[7:0]),
                         .stb_wrptr0_prev(stb_wrptr0_prev[2:0]),
                         .stb_wrptr1_prev(stb_wrptr1_prev[2:0]),
                         .stb_wrptr2_prev(stb_wrptr2_prev[2:0]),
                         .stb_wrptr3_prev(stb_wrptr3_prev[2:0]),
                         .ifu_lsu_alt_space_e(ifu_lsu_alt_space_e),
                         .ifu_lsu_ldst_fp_e(ifu_lsu_ldst_fp_e),
                         .lsu_quad_asi_e(lsu_quad_asi_e),
                         .lsu_st_rmo_m  (lsu_st_rmo_m),
                         .lsu_bst_in_pipe_m(lsu_bst_in_pipe_m),
                         .ffu_lsu_kill_fst_w(ffu_lsu_kill_fst_w),
                         .ffu_lsu_blk_st_e(ffu_lsu_blk_st_e),
                         .ffu_lsu_blk_st_tid_m(ffu_lsu_data[77:76]), // Templated
                         .ffu_lsu_blk_st_va_e(ffu_lsu_blk_st_va_e[5:3]),
                         .lsu_snap_blk_st_m(lsu_snap_blk_st_m),
                         .tlb_pgnum_b39_g(tlb_pgnum_buf[39]),    // Templated
                         .lsu_stb_empty ({2'b00, lsu_stb_empty[1:0]}),
                         .ifu_tlu_flsh_inst_e(ifu_tlu_flsh_inst_e),
                         .stb_cam_mhit  (stb_cam_mhit),
                         .ifu_tlu_inst_vld_m(ifu_tlu_inst_vld_m),
                         .lsu_st_pcx_rq_pick(lsu_st_pcx_rq_pick[3:0]),
                         .lsu_st_pcx_rq_vld(lsu_st_pcx_rq_vld),
                         .stb_rdata_ramc_b8t0(stb_rdata_ramc[8:0]), // Templated
                         .lsu_stbcnt0   (lsu_stbcnt0[3:0]),
                         .lsu_stbcnt1   (lsu_stbcnt1[3:0]),
                         .lsu_stbcnt2   (lsu_stbcnt2[3:0]),
                         .lsu_stbcnt3   (lsu_stbcnt3[3:0]));





















































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*
lsu_stb_rwdp AUTO_TEMPLATE (
      .rst_tri_en           (mux_drive_disable),
      .stb_rdata_ramd_b74     (stb_rdata_ramd[74]),
 			.rclk	(clk));
*/

lsu_stb_rwdp  stb_rwdp  (
                         .so            (so0),
                         .si            (scan0_2),
                         .lsu_stb_st_data_g(lsu_stb_st_data_g[63:0]),
                         /*AUTOINST*/
                         // Outputs
                         .stb_rdata_ramd_buf(stb_rdata_ramd_buf[69:0]),
                         .stb_rdata_ramd_b74_buf(stb_rdata_ramd_b74_buf),
                         // Inputs
                         .rclk          (clk),                   // Templated
                         .se            (se),
                         .rst_tri_en    (mux_drive_disable),     // Templated
                         .exu_lsu_rs3_data_e(exu_lsu_rs3_data_e[63:0]),
                         .lsu_stb_data_early_sel_e(lsu_stb_data_early_sel_e[3:0]),
                         .lsu_stb_data_final_sel_m(lsu_stb_data_final_sel_m),
                         .exu_lsu_rs2_data_e(exu_lsu_rs2_data_e[63:0]),
                         .lsu_st_sz_bhww_m(lsu_st_sz_bhww_m),
                         .lsu_st_sz_dw_m(lsu_st_sz_dw_m),
                         .lsu_st_sz_bhw_m(lsu_st_sz_bhw_m),
                         .lsu_st_sz_wdw_m(lsu_st_sz_wdw_m),
                         .lsu_st_sz_b_m (lsu_st_sz_b_m),
                         .lsu_st_sz_w_m (lsu_st_sz_w_m),
                         .lsu_st_sz_hw_m(lsu_st_sz_hw_m),
                         .lsu_st_sz_hww_m(lsu_st_sz_hww_m),
                         .ffu_lsu_data  (ffu_lsu_data[63:0]),
                         .lsu_st_hw_le_g(lsu_st_hw_le_g),
                         .lsu_st_w_or_dbl_le_g(lsu_st_w_or_dbl_le_g),
                         .lsu_st_x_le_g (lsu_st_x_le_g),
                         .lsu_swap_sel_default_g(lsu_swap_sel_default_g),
                         .lsu_swap_sel_default_byte_7_2_g(lsu_swap_sel_default_byte_7_2_g),
                         .stb_rdata_ramd(stb_rdata_ramd[69:0]),
                         .stb_rdata_ramd_b74(stb_rdata_ramd[74])); // Templated
/*
bw_r_scm  AUTO_TEMPLATE (
                         .rst_tri_en           (mem_write_disable),
                         .rclk            (clk),
                         .stb_quad_ld_cam (lsu_ldquad_inst_m),
                         .stb_alt_wr_data (lsu_blkst_pgnum_m[39:10]),
                         .stb_alt_wsel (lsu_blk_st_m),
                         .stb_cam_data  (tlb_pgnum_crit[39:10]),
                         .stb_cam_rw_tid(stb_cam_rw_ptr[4:3]));
*/

bw_r_scm   stb_cam   (
          .stb_camwr_data ({lsu_stb_va_m[9:3],stb_ldst_byte_msk_min[7:0]}),
          /*AUTOINST*/
                      // Outputs
                      
                      .stb_rcsm_ramc    (stb_rcsm_ramc),
                      
                      .stb_rdata_ramc   (stb_rdata_ramc[44:0]),
                      .stb_ld_full_raw  (stb_ld_full_raw[7:0]),
                      .stb_ld_partial_raw(stb_ld_partial_raw[7:0]),
                      .stb_cam_hit_ptr  (stb_cam_hit_ptr[2:0]),
                      .stb_cam_hit      (stb_cam_hit),
                      .stb_cam_mhit     (stb_cam_mhit),
                      // Inputs
                      
                      .stb_cam_csm      (tlb_rd_tte_csm_crit),
                      .stb_alt_wr_csm   (lsu_blkst_csm_m),
                      
                      .stb_cam_data     (tlb_pgnum_crit[39:10]), // Templated
                      .stb_alt_wr_data  (lsu_blkst_pgnum_m[39:10]), // Templated
                      .stb_alt_wsel     (lsu_blk_st_m),          // Templated
                      .stb_cam_vld      (stb_cam_vld),
                      .stb_cam_cm_tid   (stb_cam_cm_tid[1:0]),
                      .stb_cam_sqsh_msk (stb_cam_sqsh_msk[7:0]),
                      .stb_cam_rw_ptr   (stb_cam_rw_ptr[2:0]),
                      .stb_cam_wptr_vld (stb_cam_wptr_vld),
                      .stb_cam_rptr_vld (stb_cam_rptr_vld),
                      .stb_cam_rw_tid   (stb_cam_rw_ptr[4:3]),   // Templated
                      .stb_quad_ld_cam  (lsu_ldquad_inst_m),     // Templated
                      .rclk             (clk),                   // Templated
                      .rst_tri_en       (mem_write_disable));     // Templated
/*bw_r_rf32x80 AUTO_TEMPLATE (
                         .rst_tri_en           (mem_write_disable),
                         .dout   (stb_rdata_ramd[79:0]),
                         .wr_adr (stb_data_wr_ptr[4:0]),
                         .wr_en  (stb_data_wptr_vld),
                         .nib_wr_en ({20{1'b1}}),
                         .rd_adr (stb_data_rd_ptr[4:0]),
                         .rd_en  (stb_data_rptr_vld),
                         //.sehold (),
                         .reset_l(arst_l),
                         .rclk    (clk));

*/
bw_r_rf32x80 stb_data(
                      .din ({3'b0,stb_ncache_pcx_rq_g, stb_wdata_ramd_b75_b64[75:64], lsu_stb_st_data_g[63:0]}),
                      .so               (short_scan0_5),
                      .si               (short_scan0_4),
                      /*AUTOINST*/
                      // Outputs
                      .dout             (stb_rdata_ramd[79:0]),  // Templated
                      // Inputs
                      .rd_adr           (stb_data_rd_ptr[4:0]),  // Templated
                      .rd_en            (stb_data_rptr_vld),     // Templated
                      .wr_en            (stb_data_wptr_vld),     // Templated
                      .nib_wr_en        ({20{1'b1}}),            // Templated
                      .wr_adr           (stb_data_wr_ptr[4:0]),  // Templated
                      .rclk             (clk),                   // Templated
                      .reset_l          (arst_l),                // Templated
                      .rst_tri_en       (mem_write_disable),     // Templated
                      .sehold           (sehold),
                      .se               (se));
/*lsu_stb_ctl AUTO_TEMPLATE (
         .rclk             	(clk),
	 .st_dtlb_perr_g	(lsu_st_dtlb_perr_g[@]),
         .lsu_outstanding_rmo_st_max (lsu_outstanding_rmo_st_max[@]),
 	       .st_pcx_rq_kill_w2    (lsu_st_pcx_rq_kill_w2[@]),
      	 .flshinst_rst	       (lsu_dfq_flsh_cmplt[@]),
      	 .stb_rmo_st_issue     (lsu_stb_rmo_st_issue[@]),
         .lsu_stb_empty        (lsu_stb_empty[@]),
         .stb_l2bnk_addr       (stb@_l2b_addr[2:0]),
         .stb_atm_rq_type      (stb@_atm_rq_type[2:1]),
         .stb_wrptr            (stb_wrptr@[2:0]),
         .stb_wrptr_prev       (stb_wrptr@_prev[2:0]),
         .stb_state_ced_mod    (stb_state_ced@[7:0]),
         .stb_state_vld_out    (stb_state_vld@[7:0]),
         .stb_rd_for_pcx       (stb_rd_for_pcx[@]),
         .stb_dfq_rptr         (stb_dfq_rptr@[2:0]),
         .stb_pcx_rptr         (stb_pcx_rptr@[2:0]),
         .thrd_en_g            (stb_thrd_en_g[@]),
         .pcx_rq_for_stb       (pcx_rq_for_stb[@]),
         .stb_crnt_ack_id      (stb@_crnt_ack_id[2:0]),
         .lsu_stbcnt           (lsu_stbcnt@[3:0]),
         .pcx_req_squash       (lsu_pcx_req_squash@),
         .cpx_st_ack_tid       (cpx_st_ack_tid@),
         .st_ack_dq_stb        (lsu_st_ack_dq_stb[@]),
         .stb_cam_wvld_m       (stb_cam_wvld_m[@]),
         .stb_flush_st_g       (stb_flush_st_g[@]),
         .cpx_st_ack_tid       (cpx_st_ack_tid@),
	       .stb_full	           (lsu_tlu_stb_full_w2[@]),
         .tlb_pgnum_g          (tlb_pgnum_buf2[39:37]), // timing fix
	 .stb_alt_sel	       (lsu_blk_st_m),
	 .stb_alt_addr	       (lsu_blkst_pgnum_m[39:37]),
         .stb_clk_en_l         (stb@_clk_en_l[7:0]),
         .stb_non_l2bnk        (stb@_non_l2bnk),
         .stb_state_si_0       (stb@_state_si_0[3:2]),
         .stb_state_si_1       (stb@_state_si_1[3:2]),
         .stb_state_si_2       (stb@_state_si_2[3:2]),
         .stb_state_si_3       (stb@_state_si_3[3:2]),
         .stb_state_si_4       (stb@_state_si_4[3:2]),
         .stb_state_si_5       (stb@_state_si_5[3:2]),
         .stb_state_si_6       (stb@_state_si_6[3:2]),
         .stb_state_si_7       (stb@_state_si_7[3:2]),
         .stb_state_rtype_0    (stb@_state_rtype_0[2:1]),
         .stb_state_rtype_1    (stb@_state_rtype_1[2:1]),
         .stb_state_rtype_2    (stb@_state_rtype_2[2:1]),
         .stb_state_rtype_3    (stb@_state_rtype_3[2:1]),
         .stb_state_rtype_4    (stb@_state_rtype_4[2:1]),
         .stb_state_rtype_5    (stb@_state_rtype_5[2:1]),
         .stb_state_rtype_6    (stb@_state_rtype_6[2:1]),
         .stb_state_rtype_7    (stb@_state_rtype_7[2:1]),
         .stb_state_io         (stb@_state_io[7:0]),
         .stb_state_rmo        (stb@_state_rmo[7:0]));
*/

/*lsu_stb_ctldp AUTO_TEMPLATE (
         .rclk         	       (clk),
         .stb_clk_en_l         (stb@_clk_en_l[7:0]),
         .stb_non_l2bnk        (stb@_non_l2bnk),
         .stb_state_si_0       (stb@_state_si_0[3:2]),
         .stb_state_si_1       (stb@_state_si_1[3:2]),
         .stb_state_si_2       (stb@_state_si_2[3:2]),
         .stb_state_si_3       (stb@_state_si_3[3:2]),
         .stb_state_si_4       (stb@_state_si_4[3:2]),
         .stb_state_si_5       (stb@_state_si_5[3:2]),
         .stb_state_si_6       (stb@_state_si_6[3:2]),
         .stb_state_si_7       (stb@_state_si_7[3:2]),
         .stb_state_rtype_0    (stb@_state_rtype_0[2:1]),
         .stb_state_rtype_1    (stb@_state_rtype_1[2:1]),
         .stb_state_rtype_2    (stb@_state_rtype_2[2:1]),
         .stb_state_rtype_3    (stb@_state_rtype_3[2:1]),
         .stb_state_rtype_4    (stb@_state_rtype_4[2:1]),
         .stb_state_rtype_5    (stb@_state_rtype_5[2:1]),
         .stb_state_rtype_6    (stb@_state_rtype_6[2:1]),
         .stb_state_rtype_7    (stb@_state_rtype_7[2:1]),
         .stb_state_io         (stb@_state_io[7:0]),
         .stb_state_rmo        (stb@_state_rmo[7:0]));
*/

lsu_stb_ctl stb_ctl0  (
                       .so              (short_scan0_6),
                       .si              (short_scan0_5),
                       /*AUTOINST*/
                       // Outputs
                       .stb_clk_en_l    (stb0_clk_en_l[7:0]),    // Templated
                       .stb_crnt_ack_id (stb0_crnt_ack_id[2:0]), // Templated
                       .lsu_stb_empty   (lsu_stb_empty[0]),      // Templated
                       .stb_l2bnk_addr  (stb0_l2b_addr[2:0]),    // Templated
                       .stb_atm_rq_type (stb0_atm_rq_type[2:1]), // Templated
                       .stb_wrptr       (stb_wrptr0[2:0]),       // Templated
                       .stb_rd_for_pcx  (stb_rd_for_pcx[0]),     // Templated
                       .stb_pcx_rptr    (stb_pcx_rptr0[2:0]),    // Templated
                       .stb_wrptr_prev  (stb_wrptr0_prev[2:0]),  // Templated
                       .stb_state_ced_mod(stb_state_ced0[7:0]),  // Templated
                       .stb_state_vld_out(stb_state_vld0[7:0]),  // Templated
                       .lsu_stbcnt      (lsu_stbcnt0[3:0]),      // Templated
                       .stb_rmo_st_issue(lsu_stb_rmo_st_issue[0]), // Templated
                       .stb_full        (lsu_tlu_stb_full_w2_t[0]), // Templated
                       .st_pcx_rq_kill_w2(lsu_st_pcx_rq_kill_w2[0]), // Templated
                       // Inputs
                       .rclk            (clk),                   // Templated
                       .grst_l          (grst_l),
                       .arst_l          (arst_l),
                       .se              (se),
                       .thrd_en_g       (stb_thrd_en_g[0]),      // Templated
                       .cpx_st_ack_tid  (cpx_st_ack_tid0),       // Templated
                       .pcx_rq_for_stb  (pcx_rq_for_stb[0]),     // Templated
                       .st_ack_dq_stb   (lsu_st_ack_dq_stb[0]),  // Templated
                       .stb_flush_st_g  (stb_flush_st_g[0]),     // Templated
                       .stb_cam_wvld_m  (stb_cam_wvld_m[0]),     // Templated
                       .lsu_blk_st_m    (lsu_blk_st_m),
                       .tlb_pgnum_g     (tlb_pgnum_buf2[39:37]), // Templated
                       .pcx_req_squash  (lsu_pcx_req_squash0),   // Templated
                       .flshinst_rst    (lsu_dfq_flsh_cmplt[0]), // Templated
                       .lsu_stbctl_flush_pipe_w(lsu_stbctl_flush_pipe_w),
                       .flsh_inst_m     (flsh_inst_m),
                       .stb_state_si_0  (stb0_state_si_0[3:2]),  // Templated
                       .stb_state_si_1  (stb0_state_si_1[3:2]),  // Templated
                       .stb_state_si_2  (stb0_state_si_2[3:2]),  // Templated
                       .stb_state_si_3  (stb0_state_si_3[3:2]),  // Templated
                       .stb_state_si_4  (stb0_state_si_4[3:2]),  // Templated
                       .stb_state_si_5  (stb0_state_si_5[3:2]),  // Templated
                       .stb_state_si_6  (stb0_state_si_6[3:2]),  // Templated
                       .stb_state_si_7  (stb0_state_si_7[3:2]),  // Templated
                       .stb_state_rtype_0(stb0_state_rtype_0[2:1]), // Templated
                       .stb_state_rtype_1(stb0_state_rtype_1[2:1]), // Templated
                       .stb_state_rtype_2(stb0_state_rtype_2[2:1]), // Templated
                       .stb_state_rtype_3(stb0_state_rtype_3[2:1]), // Templated
                       .stb_state_rtype_4(stb0_state_rtype_4[2:1]), // Templated
                       .stb_state_rtype_5(stb0_state_rtype_5[2:1]), // Templated
                       .stb_state_rtype_6(stb0_state_rtype_6[2:1]), // Templated
                       .stb_state_rtype_7(stb0_state_rtype_7[2:1]), // Templated
                       .stb_state_rmo   (stb0_state_rmo[7:0]),   // Templated
                       .stb_alt_sel     (lsu_blk_st_m),          // Templated
                       .stb_alt_addr    (lsu_blkst_pgnum_m[39:37]), // Templated
                       .lsu_dtlb_bypass_e(lsu_dtlb_bypass_e),
                       .tlb_cam_hit     (tlb_cam_hit),
                       .st_dtlb_perr_g  (lsu_st_dtlb_perr_g[0]), // Templated
                       .lsu_outstanding_rmo_st_max(lsu_outstanding_rmo_st_max[0])); // Templated
lsu_stb_ctldp stb_ctldp0  (
                           .so          (short_scan1_5),
                           .si          (short_scan1_4),
                           /*AUTOINST*/
                           // Outputs
                           .stb_state_si_0(stb0_state_si_0[3:2]), // Templated
                           .stb_state_si_1(stb0_state_si_1[3:2]), // Templated
                           .stb_state_si_2(stb0_state_si_2[3:2]), // Templated
                           .stb_state_si_3(stb0_state_si_3[3:2]), // Templated
                           .stb_state_si_4(stb0_state_si_4[3:2]), // Templated
                           .stb_state_si_5(stb0_state_si_5[3:2]), // Templated
                           .stb_state_si_6(stb0_state_si_6[3:2]), // Templated
                           .stb_state_si_7(stb0_state_si_7[3:2]), // Templated
                           .stb_state_rtype_0(stb0_state_rtype_0[2:1]), // Templated
                           .stb_state_rtype_1(stb0_state_rtype_1[2:1]), // Templated
                           .stb_state_rtype_2(stb0_state_rtype_2[2:1]), // Templated
                           .stb_state_rtype_3(stb0_state_rtype_3[2:1]), // Templated
                           .stb_state_rtype_4(stb0_state_rtype_4[2:1]), // Templated
                           .stb_state_rtype_5(stb0_state_rtype_5[2:1]), // Templated
                           .stb_state_rtype_6(stb0_state_rtype_6[2:1]), // Templated
                           .stb_state_rtype_7(stb0_state_rtype_7[2:1]), // Templated
                           .stb_state_rmo(stb0_state_rmo[7:0]),  // Templated
                           // Inputs
                           .rclk        (clk),                   // Templated
                           .se          (se),
                           .stb_clk_en_l(stb0_clk_en_l[7:0]),    // Templated
                           .lsu_stb_va_m(lsu_stb_va_m[7:6]),
                           .lsu_st_rq_type_m(lsu_st_rq_type_m[2:1]),
                           .lsu_st_rmo_m(lsu_st_rmo_m));

 // Use two threads unless this is defined

   lsu_stb_ctl stb_ctl1  (
                       .so              (short_scan1_6),
                       .si              (short_scan1_5),
                       /*AUTOINST*/
                       // Outputs
                       .stb_clk_en_l    (stb1_clk_en_l[7:0]),    // Templated
                       .stb_crnt_ack_id (stb1_crnt_ack_id[2:0]), // Templated
                       .lsu_stb_empty   (lsu_stb_empty[1]),      // Templated
                       .stb_l2bnk_addr  (stb1_l2b_addr[2:0]),    // Templated
                       .stb_atm_rq_type (stb1_atm_rq_type[2:1]), // Templated
                       .stb_wrptr       (stb_wrptr1[2:0]),       // Templated
                       .stb_rd_for_pcx  (stb_rd_for_pcx[1]),     // Templated
                       .stb_pcx_rptr    (stb_pcx_rptr1[2:0]),    // Templated
                       .stb_wrptr_prev  (stb_wrptr1_prev[2:0]),  // Templated
                       .stb_state_ced_mod(stb_state_ced1[7:0]),  // Templated
                       .stb_state_vld_out(stb_state_vld1[7:0]),  // Templated
                       .lsu_stbcnt      (lsu_stbcnt1[3:0]),      // Templated
                       .stb_rmo_st_issue(lsu_stb_rmo_st_issue[1]), // Templated
                       .stb_full        (lsu_tlu_stb_full_w2_t[1]), // Templated
                       .st_pcx_rq_kill_w2(lsu_st_pcx_rq_kill_w2[1]), // Templated
                       // Inputs
                       .rclk            (clk),                   // Templated
                       .grst_l          (grst_l),
                       .arst_l          (arst_l),
                       .se              (se),
                       .thrd_en_g       (stb_thrd_en_g[1]),      // Templated
                       .cpx_st_ack_tid  (cpx_st_ack_tid1),       // Templated
                       .pcx_rq_for_stb  (pcx_rq_for_stb[1]),     // Templated
                       .st_ack_dq_stb   (lsu_st_ack_dq_stb[1]),  // Templated
                       .stb_flush_st_g  (stb_flush_st_g[1]),     // Templated
                       .stb_cam_wvld_m  (stb_cam_wvld_m[1]),     // Templated
                       .lsu_blk_st_m    (lsu_blk_st_m),
                       .tlb_pgnum_g     (tlb_pgnum_buf2[39:37]), // Templated
                       .pcx_req_squash  (lsu_pcx_req_squash1),   // Templated
                       .flshinst_rst    (lsu_dfq_flsh_cmplt[1]), // Templated
                       .lsu_stbctl_flush_pipe_w(lsu_stbctl_flush_pipe_w),
                       .flsh_inst_m     (flsh_inst_m),
                       .stb_state_si_0  (stb1_state_si_0[3:2]),  // Templated
                       .stb_state_si_1  (stb1_state_si_1[3:2]),  // Templated
                       .stb_state_si_2  (stb1_state_si_2[3:2]),  // Templated
                       .stb_state_si_3  (stb1_state_si_3[3:2]),  // Templated
                       .stb_state_si_4  (stb1_state_si_4[3:2]),  // Templated
                       .stb_state_si_5  (stb1_state_si_5[3:2]),  // Templated
                       .stb_state_si_6  (stb1_state_si_6[3:2]),  // Templated
                       .stb_state_si_7  (stb1_state_si_7[3:2]),  // Templated
                       .stb_state_rtype_0(stb1_state_rtype_0[2:1]), // Templated
                       .stb_state_rtype_1(stb1_state_rtype_1[2:1]), // Templated
                       .stb_state_rtype_2(stb1_state_rtype_2[2:1]), // Templated
                       .stb_state_rtype_3(stb1_state_rtype_3[2:1]), // Templated
                       .stb_state_rtype_4(stb1_state_rtype_4[2:1]), // Templated
                       .stb_state_rtype_5(stb1_state_rtype_5[2:1]), // Templated
                       .stb_state_rtype_6(stb1_state_rtype_6[2:1]), // Templated
                       .stb_state_rtype_7(stb1_state_rtype_7[2:1]), // Templated
                       .stb_state_rmo   (stb1_state_rmo[7:0]),   // Templated
                       .stb_alt_sel     (lsu_blk_st_m),          // Templated
                       .stb_alt_addr    (lsu_blkst_pgnum_m[39:37]), // Templated
                       .lsu_dtlb_bypass_e(lsu_dtlb_bypass_e),
                       .tlb_cam_hit     (tlb_cam_hit),
                       .st_dtlb_perr_g  (lsu_st_dtlb_perr_g[1]), // Templated
                       .lsu_outstanding_rmo_st_max(lsu_outstanding_rmo_st_max[1])); // Templated
lsu_stb_ctldp stb_ctldp1  (
                           .so          (short_scan0_7),
                           .si          (short_scan0_6),
                           /*AUTOINST*/
                           // Outputs
                           .stb_state_si_0(stb1_state_si_0[3:2]), // Templated
                           .stb_state_si_1(stb1_state_si_1[3:2]), // Templated
                           .stb_state_si_2(stb1_state_si_2[3:2]), // Templated
                           .stb_state_si_3(stb1_state_si_3[3:2]), // Templated
                           .stb_state_si_4(stb1_state_si_4[3:2]), // Templated
                           .stb_state_si_5(stb1_state_si_5[3:2]), // Templated
                           .stb_state_si_6(stb1_state_si_6[3:2]), // Templated
                           .stb_state_si_7(stb1_state_si_7[3:2]), // Templated
                           .stb_state_rtype_0(stb1_state_rtype_0[2:1]), // Templated
                           .stb_state_rtype_1(stb1_state_rtype_1[2:1]), // Templated
                           .stb_state_rtype_2(stb1_state_rtype_2[2:1]), // Templated
                           .stb_state_rtype_3(stb1_state_rtype_3[2:1]), // Templated
                           .stb_state_rtype_4(stb1_state_rtype_4[2:1]), // Templated
                           .stb_state_rtype_5(stb1_state_rtype_5[2:1]), // Templated
                           .stb_state_rtype_6(stb1_state_rtype_6[2:1]), // Templated
                           .stb_state_rtype_7(stb1_state_rtype_7[2:1]), // Templated
                           .stb_state_rmo(stb1_state_rmo[7:0]),  // Templated
                           // Inputs
                           .rclk        (clk),                   // Templated
                           .se          (se),
                           .stb_clk_en_l(stb1_clk_en_l[7:0]),    // Templated
                           .lsu_stb_va_m(lsu_stb_va_m[7:6]),
                           .lsu_st_rq_type_m(lsu_st_rq_type_m[2:1]),
                           .lsu_st_rmo_m(lsu_st_rmo_m));

lsu_stb_ctl stb_ctl2  (
                       .so              (short_scan1_7),
                       .si              (short_scan1_6),
                       /*AUTOINST*/
                       // Outputs
                       .stb_clk_en_l    (stb2_clk_en_l[7:0]),    // Templated
                       .stb_crnt_ack_id (), // Templated
                       .lsu_stb_empty   (),      // Templated
                       .stb_l2bnk_addr  (),    // Templated
                       .stb_atm_rq_type (), // Templated
                       .stb_wrptr       (),       // Templated
                       .stb_rd_for_pcx  (),     // Templated
                       .stb_pcx_rptr    (),    // Templated
                       .stb_wrptr_prev  (),  // Templated
                       .stb_state_ced_mod(),  // Templated
                       .stb_state_vld_out(),  // Templated
                       .lsu_stbcnt      (),      // Templated
                       .stb_rmo_st_issue(), // Templated
                       .stb_full        (), // Templated
                       .st_pcx_rq_kill_w2(), // Templated
                       // Inputs
                       .rclk            (clk),                   // Templated
                       .grst_l          (grst_l),
                       .arst_l          (arst_l),
                       .se              (se),
                       .thrd_en_g       (1'b0),      // Templated
                       .cpx_st_ack_tid  (1'b0),       // Templated
                       .pcx_rq_for_stb  (1'b0),     // Templated
                       .st_ack_dq_stb   (1'b0),  // Templated
                       .stb_flush_st_g  (1'b0),     // Templated
                       .stb_cam_wvld_m  (1'b0),     // Templated
                       .lsu_blk_st_m    (1'b0),
                       .tlb_pgnum_g     (3'b000), // Templated
                       .pcx_req_squash  (1'b0),   // Templated
                       .flshinst_rst    (1'b0), // Templated
                       .lsu_stbctl_flush_pipe_w(1'b0),
                       .flsh_inst_m     (1'b0),
                       .stb_state_si_0  (2'b00),  // Templated
                       .stb_state_si_1  (2'b00),  // Templated
                       .stb_state_si_2  (2'b00),  // Templated
                       .stb_state_si_3  (2'b00),  // Templated
                       .stb_state_si_4  (2'b00),  // Templated
                       .stb_state_si_5  (2'b00),  // Templated
                       .stb_state_si_6  (2'b00),  // Templated
                       .stb_state_si_7  (2'b00),  // Templated
                       .stb_state_rtype_0(2'b00), // Templated
                       .stb_state_rtype_1(2'b00), // Templated
                       .stb_state_rtype_2(2'b00), // Templated
                       .stb_state_rtype_3(2'b00), // Templated
                       .stb_state_rtype_4(2'b00), // Templated
                       .stb_state_rtype_5(2'b00), // Templated
                       .stb_state_rtype_6(2'b00), // Templated
                       .stb_state_rtype_7(2'b00), // Templated
                       .stb_state_rmo   (8'h00),   // Templated
                       .stb_alt_sel     (1'b0),          // Templated
                       .stb_alt_addr    (3'b000), // Templated
                       .lsu_dtlb_bypass_e(1'b0),
                       .tlb_cam_hit     (1'b0),
                       .st_dtlb_perr_g  (1'b0), // Templated
                       .lsu_outstanding_rmo_st_max(1'b0)); // Templated
lsu_stb_ctldp stb_ctldp2  (
                           .so          (short_scan1_8),
                           .si          (short_scan1_7),
                           /*AUTOINST*/
                           // Outputs
                           .stb_state_si_0(), // Templated
                           .stb_state_si_1(), // Templated
                           .stb_state_si_2(), // Templated
                           .stb_state_si_3(), // Templated
                           .stb_state_si_4(), // Templated
                           .stb_state_si_5(), // Templated
                           .stb_state_si_6(), // Templated
                           .stb_state_si_7(), // Templated
                           .stb_state_rtype_0(), // Templated
                           .stb_state_rtype_1(), // Templated
                           .stb_state_rtype_2(), // Templated
                           .stb_state_rtype_3(), // Templated
                           .stb_state_rtype_4(), // Templated
                           .stb_state_rtype_5(), // Templated
                           .stb_state_rtype_6(), // Templated
                           .stb_state_rtype_7(), // Templated
                           .stb_state_rmo(),  // Templated
                           // Inputs
                           .rclk        (clk),                   // Templated
                           .se          (se),
                           .stb_clk_en_l(stb2_clk_en_l[7:0]),    // Templated
                           .lsu_stb_va_m(2'b00),
                           .lsu_st_rq_type_m(2'b00),
                           .lsu_st_rmo_m(1'b0));

lsu_stb_ctl stb_ctl3  (
                       .so              (short_scan0_8),
                       .si              (short_scan0_7),
                       /*AUTOINST*/
                       // Outputs
                       .stb_clk_en_l    (stb3_clk_en_l[7:0]),    // Templated
                       .stb_crnt_ack_id (), // Templated
                       .lsu_stb_empty   (),      // Templated
                       .stb_l2bnk_addr  (),    // Templated
                       .stb_atm_rq_type (), // Templated
                       .stb_wrptr       (),       // Templated
                       .stb_rd_for_pcx  (),     // Templated
                       .stb_pcx_rptr    (),    // Templated
                       .stb_wrptr_prev  (),  // Templated
                       .stb_state_ced_mod(),  // Templated
                       .stb_state_vld_out(),  // Templated
                       .lsu_stbcnt      (),      // Templated
                       .stb_rmo_st_issue(), // Templated
                       .stb_full        (), // Templated
                       .st_pcx_rq_kill_w2(), // Templated
                       // Inputs
                       .rclk            (clk),                   // Templated
                       .grst_l          (grst_l),
                       .arst_l          (arst_l),
                       .se              (se),
                       .thrd_en_g       (1'b0),      // Templated
                       .cpx_st_ack_tid  (1'b0),       // Templated
                       .pcx_rq_for_stb  (1'b0),     // Templated
                       .st_ack_dq_stb   (1'b0),  // Templated
                       .stb_flush_st_g  (1'b0),     // Templated
                       .stb_cam_wvld_m  (1'b0),     // Templated
                       .lsu_blk_st_m    (1'b0),
                       .tlb_pgnum_g     (3'b000), // Templated
                       .pcx_req_squash  (1'b0),   // Templated
                       .flshinst_rst    (1'b0), // Templated
                       .lsu_stbctl_flush_pipe_w(1'b0),
                       .flsh_inst_m     (1'b0),
                       .stb_state_si_0  (2'b00),  // Templated
                       .stb_state_si_1  (2'b00),  // Templated
                       .stb_state_si_2  (2'b00),  // Templated
                       .stb_state_si_3  (2'b00),  // Templated
                       .stb_state_si_4  (2'b00),  // Templated
                       .stb_state_si_5  (2'b00),  // Templated
                       .stb_state_si_6  (2'b00),  // Templated
                       .stb_state_si_7  (2'b00),  // Templated
                       .stb_state_rtype_0(2'b00), // Templated
                       .stb_state_rtype_1(2'b00), // Templated
                       .stb_state_rtype_2(2'b00), // Templated
                       .stb_state_rtype_3(2'b00), // Templated
                       .stb_state_rtype_4(2'b00), // Templated
                       .stb_state_rtype_5(2'b00), // Templated
                       .stb_state_rtype_6(2'b00), // Templated
                       .stb_state_rtype_7(2'b00), // Templated
                       .stb_state_rmo   (8'h00),   // Templated
                       .stb_alt_sel     (1'b0),          // Templated
                       .stb_alt_addr    (3'b000), // Templated
                       .lsu_dtlb_bypass_e(1'b0),
                       .tlb_cam_hit     (1'b0),
                       .st_dtlb_perr_g  (1'b0), // Templated
                       .lsu_outstanding_rmo_st_max(1'b0)); // Templated
lsu_stb_ctldp stb_ctldp3  (
                           .so          (short_so1),
                           .si          (short_scan1_8),
                           /*AUTOINST*/
                           // Outputs
                           .stb_state_si_0(), // Templated
                           .stb_state_si_1(), // Templated
                           .stb_state_si_2(), // Templated
                           .stb_state_si_3(), // Templated
                           .stb_state_si_4(), // Templated
                           .stb_state_si_5(), // Templated
                           .stb_state_si_6(), // Templated
                           .stb_state_si_7(), // Templated
                           .stb_state_rtype_0(), // Templated
                           .stb_state_rtype_1(), // Templated
                           .stb_state_rtype_2(), // Templated
                           .stb_state_rtype_3(), // Templated
                           .stb_state_rtype_4(), // Templated
                           .stb_state_rtype_5(), // Templated
                           .stb_state_rtype_6(), // Templated
                           .stb_state_rtype_7(), // Templated
                           .stb_state_rmo(),  // Templated
                           // Inputs
                           .rclk        (clk),                   // Templated
                           .se          (se),
                           .stb_clk_en_l(stb3_clk_en_l[7:0]),    // Templated
                           .lsu_stb_va_m(2'b00),
                           .lsu_st_rq_type_m(2'b00),
                           .lsu_st_rmo_m(1'b0));























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*
lsu_qdp1 AUTO_TEMPLATE (
        .tlb_pgnum            (tlb_pgnum_buf[39:13]),
        .rst_tri_en           (mux_drive_disable),
        .lsu_ldst_va_m         (lsu_ldst_va_m_buf[47:0]),
        .rclk                  (clk),
        .dfq_byp_sel           (lsu_dfq_byp_tid_d1_sel[3:0]),
        .ld_pcx_rq_sel         (lsu_ld_pcx_rq_mxsel[3:0]),
        .lmq_byp_ldxa_sel0     (lmq_byp_ldxa_mxsel0[2:0]),
        .lmq_byp_ldxa_sel1     (lmq_byp_ldxa_mxsel1[2:0]),
        .lmq_byp_ldxa_sel2     (lmq_byp_ldxa_mxsel2[2:0]),
        .lmq_byp_ldxa_sel3     (lmq_byp_ldxa_mxsel3[2:0]),
        .lmq_byp_data_sel0     (lmq_byp_data_mxsel0[3:0]),
        .lmq_byp_data_sel1     (lmq_byp_data_mxsel1[3:0]),
        .lmq_byp_data_sel2     (lmq_byp_data_mxsel2[3:0]),
        .lmq_byp_data_sel3     (lmq_byp_data_mxsel3[3:0]),
        .ld_thrd_byp_sel_m     (ld_thrd_byp_mxsel_m[3:0]),
        .ifu_pcx_pkt           (ifu_lsu_pcxpkt_e[51:0]),
        .lmq_byp_misc_sel      (lsu_lmq_byp_misc_sel[3:0]),
        .lsu_dcache_rdata_w    (dcache_rdata_wb_buf[63:0]));
*/
 // Use two threads unless this is defined

   lsu_qdp1  qdp1  (
                 .so                    (short_scan0_9),
                 .si                    (short_scan0_8),
                     .lsu_iobrdge_rd_data     ({16'b0,lsu_iobrdge_rd_data[27:0]}),
                     .dtag_wdata_m            (dtag_wdata_m),
                     .dtag_wdata_e            (dtag_wdata_e),
                 /*AUTOINST*/
                 // Outputs
                 
                 .spc_pcx_csm_pa        (spc_pcx_csm_pa),
                 
                 .lsu_va_match_b47_b32_m(lsu_va_match_b47_b32_m),
                 .lsu_va_match_b31_b3_m (lsu_va_match_b31_b3_m),
                 .lsu_va_wtchpt_addr    (lsu_va_wtchpt_addr[47:3]),
                 .spc_pcx_data_pa       (spc_pcx_data_pa[124-1:0]),
                 .lmq0_byp_misc_sz      (lmq0_byp_misc_sz[1:0]),
                 .lmq1_byp_misc_sz      (lmq1_byp_misc_sz[1:0]),
                 .lmq2_byp_misc_sz      (lmq2_byp_misc_sz[1:0]),
                 .lmq3_byp_misc_sz      (lmq3_byp_misc_sz[1:0]),
                 .lsu_byp_misc_sz_e     (lsu_byp_misc_sz_e[1:0]),
                 .lsu_l2fill_sign_extend_m(lsu_l2fill_sign_extend_m),
                 .lsu_l2fill_bendian_m  (lsu_l2fill_bendian_m),
                 .lmq0_l2fill_fpld      (lmq0_l2fill_fpld),
                 .lmq1_l2fill_fpld      (lmq1_l2fill_fpld),
                 .lmq2_l2fill_fpld      (lmq2_l2fill_fpld),
                 .lmq3_l2fill_fpld      (lmq3_l2fill_fpld),
                 .lmq_ld_rd1            (lmq_ld_rd1[4:0]),
                 .lmq0_ncache_ld        (lmq0_ncache_ld),
                 .lmq1_ncache_ld        (lmq1_ncache_ld),
                 .lmq2_ncache_ld        (lmq2_ncache_ld),
                 .lmq3_ncache_ld        (lmq3_ncache_ld),
                 .lmq0_ld_rq_type       (lmq0_ld_rq_type[2:0]),
                 .lmq1_ld_rq_type       (lmq1_ld_rq_type[2:0]),
                 .lmq2_ld_rq_type       (lmq2_ld_rq_type[2:0]),
                 .lmq3_ld_rq_type       (lmq3_ld_rq_type[2:0]),
                 .lmq0_ldd_vld          (lmq0_ldd_vld),
                 .lmq1_ldd_vld          (lmq1_ldd_vld),
                 .lmq2_ldd_vld          (lmq2_ldd_vld),
                 .lmq3_ldd_vld          (lmq3_ldd_vld),
                 .ld_sec_hit_thrd0      (ld_sec_hit_thrd0),
                 .ld_sec_hit_thrd1      (ld_sec_hit_thrd1),
                 .ld_sec_hit_thrd2      (ld_sec_hit_thrd2),
                 .ld_sec_hit_thrd3      (ld_sec_hit_thrd3),
                 .lmq0_pcx_pkt_addr     (lmq0_pcx_pkt_addr[(6 + 4):0]),
                 .lmq1_pcx_pkt_addr     (lmq1_pcx_pkt_addr[(6 + 4):0]),
                 .lmq2_pcx_pkt_addr     (lmq2_pcx_pkt_addr[(6 + 4):0]),
                 .lmq3_pcx_pkt_addr     (lmq3_pcx_pkt_addr[(6 + 4):0]),
                 .lsu_mmu_rs3_data_g    (lsu_mmu_rs3_data_g[63:0]),
                 .lsu_tlu_rs3_data_g    (lsu_tlu_rs3_data_g[63:0]),
                 .lsu_diagnstc_wr_data_b0(lsu_diagnstc_wr_data_b0),
                 .lsu_diagnstc_wr_data_e(lsu_diagnstc_wr_data_e[63:0]),
                 .lsu_ifu_stxa_data     (lsu_ifu_stxa_data[47:0]),
                 .lsu_ifu_ld_icache_index(lsu_ifu_ld_icache_index[(6 + 5):5]),
                 .lsu_ifu_ld_pcxpkt_tid (lsu_ifu_ld_pcxpkt_tid[1:0]),
                 .lsu_error_pa_m        (lsu_error_pa_m[28:0]),
                 .lsu_pref_pcx_req      (lsu_pref_pcx_req),
                 .st_rs3_data_g         (st_rs3_data_g[63:0]),
                 .lsu_ldst_va_way_g     (lsu_ldst_va_way_g[1:0]),
                 .dcache_alt_data_w0_m  (dcache_alt_data_w0_m[63:0]),
                 // Inputs
                 
                 .tlb_rd_tte_csm        (tlb_rd_tte_csm),
                 .stb_rcsm_ramc         (stb_rcsm_ramc),
                 .ifu_pcx_csm           (ifu_lsu_pcxcsm_e),
                 
                 .rclk                  (clk),                   // Templated
                 .se                    (se),
                 .sehold                (sehold),
                 .lsu_dcache_iob_rd_w   (lsu_dcache_iob_rd_w),
                 .lsu_ramtest_rd_w      (lsu_ramtest_rd_w),
                 .lsu_pcx_rq_sz_b3      (lsu_pcx_rq_sz_b3),
                 .lsu_diagnstc_data_sel (lsu_diagnstc_data_sel[3:0]),
                 .pcx_pkt_src_sel       (pcx_pkt_src_sel[3:0]),
                 .lsu_stb_pcx_rvld_d1   (lsu_stb_pcx_rvld_d1),
                 .imiss_pcx_mx_sel      (imiss_pcx_mx_sel),
                 .fwd_int_fp_pcx_mx_sel (fwd_int_fp_pcx_mx_sel[2:0]),
                 .spu_lsu_ldst_pckt     (spu_lsu_ldst_pckt[124-1:0]),
                 .tlu_lsu_pcxpkt        (tlu_lsu_pcxpkt[25:0]),
                 .const_cpuid           (const_cpuid[2:0]),
                 .ifu_pcx_pkt           (ifu_lsu_pcxpkt_e[51:0]), // Templated
                 .lmq_byp_data_en_w2    (lmq_byp_data_en_w2[3:0]),
                 .lmq_byp_data_sel0     (lmq_byp_data_mxsel0[3:0]), // Templated
                 .lmq_byp_data_sel1     (lmq_byp_data_mxsel1[3:0]), // Templated
                 .lmq_byp_data_sel2     (lmq_byp_data_mxsel2[3:0]), // Templated
                 .lmq_byp_data_sel3     (lmq_byp_data_mxsel3[3:0]), // Templated
                 .lmq_byp_ldxa_sel0     (lmq_byp_ldxa_mxsel0[2:0]), // Templated
                 .lmq_byp_ldxa_sel1     (lmq_byp_ldxa_mxsel1[2:0]), // Templated
                 .lmq_byp_ldxa_sel2     (lmq_byp_ldxa_mxsel2[2:0]), // Templated
                 .lmq_byp_ldxa_sel3     (lmq_byp_ldxa_mxsel3[2:0]), // Templated
                 .lmq_byp_data_fmx_sel  (lmq_byp_data_fmx_sel[3:0]),
                 .exu_lsu_rs3_data_e    (exu_lsu_rs3_data_e[63:0]),
                 .ifu_lsu_ldxa_data_w2  (ifu_lsu_ldxa_data_w2[63:0]),
                 .tlu_lsu_int_ldxa_data_w2(tlu_lsu_int_ldxa_data_w2[63:0]),
                 .spu_lsu_ldxa_data_w2  (spu_lsu_ldxa_data_w2[63:0]),
                 .stb_rdata_ramd        (stb_rdata_ramd[76:0]),
                 .stb_rdata_ramc        (stb_rdata_ramc[44:9]),
                 .lmq_byp_misc_sel      (lsu_lmq_byp_misc_sel[3:0]), // Templated
                 .dfq_byp_sel           (lsu_dfq_byp_tid_d1_sel[3:0]), // Templated
                 .ld_pcx_rq_sel         (lsu_ld_pcx_rq_mxsel[3:0]), // Templated
                 .ld_pcx_thrd           (ld_pcx_thrd[1:0]),
                 .lmq_enable            (lmq_enable[3:0]),
                 .ld_pcx_pkt_g          (ld_pcx_pkt_g[65-1:40]),
                 .ffu_lsu_data          (ffu_lsu_data[80:0]),
                 .lsu_tlb_st_sel_m      (lsu_tlb_st_sel_m[3:0]),
                 .lsu_pcx_fwd_pkt       (lsu_pcx_fwd_pkt[107:0]),
                 .lsu_pcx_fwd_reply     (lsu_pcx_fwd_reply),
                 .lsu_diagnstc_dtagv_prty_invrt_e(lsu_diagnstc_dtagv_prty_invrt_e),
                 .lsu_misc_rdata_w2     (lsu_misc_rdata_w2[63:0]),
                 .lsu_stb_rd_tid        (lsu_stb_rd_tid[1:0]),
                 .lsu_iobrdge_rply_data_sel(lsu_iobrdge_rply_data_sel[2:0]),
                 .lsu_atomic_pkt2_bsel_g(lsu_atomic_pkt2_bsel_g[2:0]),
                 .lsu_pcx_ld_dtag_perror_w2(lsu_pcx_ld_dtag_perror_w2),
                 .lsu_dcache_rdata_w    (dcache_rdata_wb_buf[63:0]), // Templated
                 .lsu_va_wtchpt0_wr_en_l(lsu_va_wtchpt0_wr_en_l),
                 .lsu_va_wtchpt1_wr_en_l(lsu_va_wtchpt1_wr_en_l),
                 .lsu_va_wtchpt2_wr_en_l(lsu_va_wtchpt2_wr_en_l),
                 .lsu_va_wtchpt3_wr_en_l(lsu_va_wtchpt3_wr_en_l),
                 .thread0_m             (thread0_m),
                 .thread1_m             (thread1_m),
                 .thread2_m             (1'b0),
                 .thread3_m             (1'b0),
                 .lsu_thread_g          (lsu_thread_g[3:0]),
                 .lsu_ldst_va_m         (lsu_ldst_va_m_buf[47:0]), // Templated
                 .tlb_pgnum             (tlb_pgnum_buf[39:13]),  // Templated
                 .lsu_bld_pcx_rq        (lsu_bld_pcx_rq),
                 .lsu_bld_rq_addr       (lsu_bld_rq_addr[1:0]),
                 .lmq0_pcx_pkt_way      (lmq0_pcx_pkt_way[2-1:0]),
                 .lmq1_pcx_pkt_way      (lmq1_pcx_pkt_way[2-1:0]),
                 .lmq2_pcx_pkt_way      ({2{1'b0}}),
                 .lmq3_pcx_pkt_way      ({2{1'b0}}),
                 .lsu_dfq_ld_vld        (lsu_dfq_ld_vld),
                 .lsu_ifu_asi_data_en_l (lsu_ifu_asi_data_en_l),
                 .lsu_ld0_spec_vld_kill_w2(lsu_ld0_spec_vld_kill_w2),
                 .lsu_ld1_spec_vld_kill_w2(lsu_ld1_spec_vld_kill_w2),
                 .lsu_ld2_spec_vld_kill_w2(1'b0),
                 .lsu_ld3_spec_vld_kill_w2(1'b0),
                 .lsu_fwd_rply_sz1_unc  (lsu_fwd_rply_sz1_unc),
                 .rst_tri_en            (mux_drive_disable),     // Templated
                 .lsu_l2fill_data       (lsu_l2fill_data[63:0]),
                 .l2fill_vld_m          (l2fill_vld_m),
                 .ld_thrd_byp_sel_m     (ld_thrd_byp_mxsel_m[3:0]), // Templated
                 .cfg_asi_lsu_ldxa_vld_w2 (cfg_asi_lsu_ldxa_vld_w2),
                 .cfg_asi_lsu_ldxa_data_w2 (cfg_asi_lsu_ldxa_data_w2)
                 );




































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

/*
lsu_qdp2 AUTO_TEMPLATE (
       .rst_tri_en              (mux_drive_disable),
       .dfq_byp_ff_en          (lsu_dfq_byp_ff_en),
       .dfq_rd_vld_d1          (lsu_dfq_rd_vld_d1),
       .lsu_dfq_ld_vld         (lsu_qdp2_dfq_ld_vld),
       .lsu_dfq_st_vld         (lsu_qdp2_dfq_st_vld),
       .rclk                    (clk),
       .lsu_ifill_pkt          (lsu_ifu_cpxpkt_i1[`CPX_VLD-1:0]),
       .lsu_cpx_pkt_vld        ());
*/

lsu_qdp2 qdp2  (
                .so                     (so1),
                .si                     (scan1_4),
		.dfq_wdata		(dfq_wdata[151:0]),
                /*AUTOINST*/
                // Outputs
                .lsu_l2fill_data        (lsu_l2fill_data[63:0]),
                .dfq_tid                (dfq_tid[1:0]),
                .lsu_dcache_fill_data_e (lsu_dcache_fill_data_e[143:0]),
                .lsu_ifill_pkt          (lsu_ifu_cpxpkt_i1[144-1:0]), // Templated
                .lsu_pcx_fwd_pkt        (lsu_pcx_fwd_pkt[107:0]),
                .lsu_cpx_pkt_strm_ack   (lsu_cpx_pkt_strm_ack),
                .lsu_cpx_pkt_vld        (),                      // Templated
                .lsu_cpx_pkt_atm_st_cmplt(lsu_cpx_pkt_atm_st_cmplt),
                .lsu_cpx_pkt_tid        (lsu_cpx_pkt_tid[1:0]),
                .lsu_cpx_pkt_invwy      (lsu_cpx_pkt_invwy[2-1:0]),
                .lsu_cpx_pkt_inv_pa     (lsu_cpx_pkt_inv_pa[(6 + 4)-6:0]),
                .lsu_cpx_pkt_l2miss     (lsu_cpx_pkt_l2miss),
                .lsu_dfq_byp_invwy_vld  (lsu_dfq_byp_invwy_vld),
                .lsu_dfq_byp_type       (lsu_dfq_byp_type[5:0]),
                .lsu_dfq_byp_flush      (lsu_dfq_byp_flush),
                .lsu_dfq_byp_tid        (lsu_dfq_byp_tid[1:0]),
                // .lsu_cpu_inv_data_b13to9(lsu_cpu_inv_data_b13to9[13:9]),
                // .lsu_cpu_inv_data_b7to2 (lsu_cpu_inv_data_b7to2[7:2]),
                // .lsu_cpu_inv_data_b0    (lsu_cpu_inv_data_b0),
                .lsu_cpu_inv_data_val        (lsu_cpu_inv_data_val),
                .lsu_cpu_inv_data_way        (lsu_cpu_inv_data_way),
                .lsu_iobrdge_wr_data    (lsu_iobrdge_wr_data[43:0]),
                .lsu_iobrdge_tap_rq_type(lsu_iobrdge_tap_rq_type[8:0]),
                .lsu_cpx_pkt_perror_dinv(lsu_cpx_pkt_perror_dinv),
                .lsu_cpx_pkt_perror_iinv(lsu_cpx_pkt_perror_iinv),
                .lsu_cpx_pkt_perror_set (lsu_cpx_pkt_perror_set[1:0]),
                .lsu_cpx_pkt_ld_err     (lsu_cpx_pkt_ld_err[1:0]),
                .lsu_dfq_byp_binit_st   (lsu_dfq_byp_binit_st),
                .lsu_cpx_pkt_binit_st   (lsu_cpx_pkt_binit_st),
                .lsu_cpx_pkt_prefetch   (lsu_cpx_pkt_prefetch),
                .lsu_cpx_pkt_prefetch2  (lsu_cpx_pkt_prefetch2),
                .lsu_dfq_byp_cpx_inv    (lsu_dfq_byp_cpx_inv),
                .lsu_dfq_byp_stack_adr_b54(lsu_dfq_byp_stack_adr_b54[1:0]),
                .lsu_dfq_byp_stack_wrway(lsu_dfq_byp_stack_wrway[1:0]),
                .lsu_dfq_byp_atm        (lsu_dfq_byp_atm),
                .dcache_iob_addr_e      (dcache_iob_addr_e[(6 + 4)-3:0]),
                .st_dcfill_addr         (st_dcfill_addr[(6 + 4):0]),
                .lsu_st_way_e           (lsu_st_way_e[2-1:0]),
                .lsu_dcache_iob_way_e   (lsu_dcache_iob_way_e[2-1:0]),
                .lsu_st_dcfill_size_e   (lsu_st_dcfill_size_e[1:0]),
                .lsu_cpx_pkt_ifill_type (lsu_cpx_pkt_ifill_type),
                .lsu_cpx_pkt_atomic     (lsu_cpx_pkt_atomic),
                // Inputs
                .rst_tri_en             (mux_drive_disable),     // Templated
                .rclk                   (clk),                   // Templated
                .se                     (se),
                .lsu_dfill_data_sel_hi  (lsu_dfill_data_sel_hi),
                .dfq_byp_ff_en          (lsu_dfq_byp_ff_en),     // Templated
                .dfq_rd_vld_d1          (lsu_dfq_rd_vld_d1),     // Templated
                .dfq_rdata              (dfq_rdata[151:0]),
                .cpx_spc_data_cx        (cpx_spc_data_cx[145-1:0]),
                .stb_rdata_ramd_buf     (stb_rdata_ramd_buf[69:0]),
                .stb_rdata_ramd_b74_buf (stb_rdata_ramd_b74_buf),
                .stb_rdata_ramc_buf     (stb_rdata_ramc_buf[14:9]),
                .lsu_stb_pcx_rvld_d1    (lsu_stb_pcx_rvld_d1),
                .lsu_diagnstc_wr_data_e (lsu_diagnstc_wr_data_e[63:0]),
                .lsu_diagnstc_dc_prty_invrt_e(lsu_diagnstc_dc_prty_invrt_e[7:0]),
                .mbist_write_data       (mbist_write_data[7:0]),
                .cpx_fwd_pkt_en_cx      (cpx_fwd_pkt_en_cx),
                .lsu_cpu_dcd_sel        (lsu_cpu_dcd_sel[7:0]),
                .lsu_cpu_uhlf_sel       (lsu_cpu_uhlf_sel),
                .lsu_cpxpkt_type_dcd_cx (lsu_cpxpkt_type_dcd_cx[5:0]),
                .lsu_dc_iob_access_e    (lsu_dc_iob_access_e),
                .lsu_dcfill_data_mx_sel_e(lsu_dcfill_data_mx_sel_e),
                .lsu_cpx_spc_inv_vld    (lsu_cpx_spc_inv_vld),
                .lsu_cpx_thrdid         (lsu_cpx_thrdid[3:0]),
                .lsu_cpx_stack_dcfill_vld(lsu_cpx_stack_dcfill_vld),
                .pcx_rq_for_stb_d1      (pcx_rq_for_stb_d1[3:0]),
                .lsu_dfq_ld_vld         (lsu_qdp2_dfq_ld_vld),   // Templated
                .lsu_dfq_st_vld         (lsu_qdp2_dfq_st_vld),   // Templated
                .lsu_dfq_ldst_vld       (lsu_dfq_ldst_vld));


/*
bw_r_rf32x152b AUTO_TEMPLATE (
                 .rst_tri_en           (mem_write_disable),
                 .rclk                    (clk),
                 .dout                  (dfq_rdata[151:0]),
                 .wr_adr                (dfq_wptr[4:0]),
                 .rd_adr                (dfq_rptr[4:0]),
                 .wr_en                 (dfq_wptr_vld),
                 .rd_en                 (dfq_rptr_vld),
                 //.sehold                (),
                 .reset_l               (arst_l));
*/

bw_r_rf32x152b   dfq   (
                 .din            ({dfq_wdata[151:131],
                                   lsu_cpx_stack_dcfill_vld_b130,
                                   dfq_wdata[129],
                                   lsu_cpx_stack_icfill_vld,
                                   dfq_wdata[127:0]}),
                        .so             (short_so0),
                        .si             (short_scan0_9),
                 /*AUTOINST*/
                        // Outputs
                        .dout           (dfq_rdata[151:0]),      // Templated
                        // Inputs
                        .rd_adr         (dfq_rptr[4:0]),         // Templated
                        .rd_en          (dfq_rptr_vld),          // Templated
                        .wr_en          (dfq_wptr_vld),          // Templated
                        .wr_adr         (dfq_wptr[4:0]),         // Templated
                        .rclk           (clk),                   // Templated
                        .reset_l        (arst_l),                // Templated
                        .rst_tri_en     (mem_write_disable),     // Templated
                        .sehold         (sehold),
                        .se             (se));

endmodule

// Local Variables:
// verilog-library-directories:("." "../../../srams/rtl" "../../../common/rtl")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_asi_decode.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    ASI Decode for LSU
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                                        // time scale definition


// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////    

module lsu_asi_decode (/*AUTOARG*/
   // Outputs
   asi_internal_d, nucleus_asi_d, primary_asi_d, secondary_asi_d, 
   lendian_asi_d, nofault_asi_d, quad_asi_d, binit_quad_asi_d, 
   dcache_byp_asi_d, tlb_lng_ltncy_asi_d, tlb_byp_asi_d, 
   as_if_user_asi_d, atomic_asi_d, blk_asi_d, dc_diagnstc_asi_d, 
   dtagv_diagnstc_asi_d, wr_only_asi_d, rd_only_asi_d, unimp_asi_d, 
   ifu_nontlb_asi_d, recognized_asi_d, ifill_tlb_asi_d, 
   dfill_tlb_asi_d, rd_only_ltlb_asi_d, wr_only_ltlb_asi_d, 
   phy_use_ec_asi_d, phy_byp_ec_asi_d, mmu_rd_only_asi_d, 
   intrpt_disp_asi_d, dmmu_asi58_d, immu_asi50_d, 
   // Inputs
   asi_d
   );

input 	[7:0]	asi_d ;
output		asi_internal_d ;
output		nucleus_asi_d ;
output		primary_asi_d ;
output		secondary_asi_d ;
output		lendian_asi_d ;
output		nofault_asi_d ;
output		quad_asi_d ;
output		binit_quad_asi_d ;
output		dcache_byp_asi_d ;
output		tlb_lng_ltncy_asi_d ;
output		tlb_byp_asi_d ;
output		as_if_user_asi_d ;
output		atomic_asi_d ;
output		blk_asi_d ;
//output		blk_cmt_asi_d ;
output		dc_diagnstc_asi_d;
output		dtagv_diagnstc_asi_d;
output		wr_only_asi_d ;
output		rd_only_asi_d ;
output		unimp_asi_d ;
output		ifu_nontlb_asi_d ;	// non-tlb asi's in ifu
output		recognized_asi_d ;
output		ifill_tlb_asi_d ;	// itlb fill asi
output		dfill_tlb_asi_d ;	// dtlb fill asi
output		rd_only_ltlb_asi_d ;	// read-only long-latency asi
output		wr_only_ltlb_asi_d ;	// write-only long-latency asi
output		phy_use_ec_asi_d ;
output		phy_byp_ec_asi_d ;

output		mmu_rd_only_asi_d ;	// does not include asi with va
output		intrpt_disp_asi_d ;
output		dmmu_asi58_d ;
output    immu_asi50_d;
   
wire	quad_ldd_real, quad_ldd_real_little ;
wire	asi_if_user_prim_all_d,asi_if_user_sec_all_d ;
wire	asi_if_user_prim_d,asi_if_user_sec_d ;
wire	nucleus_asi_exact_d ;
wire	prim_asi_exact_d ;
wire	phy_use_ec_asi ;
wire	phy_byp_ec_asi ;
wire	sec_asi_exact_d ;
wire	idemap,ddemap,ddata_in,ddaccess ;
wire	dtag_read,idata_in,idaccess,invld_all,itag_read ;
wire	blk_asif_usr_plittle, blk_asif_usr_slittle ;
wire	blk_plittle, blk_slittle ;
wire	blk_asif_usr_p, blk_asif_usr_s ;
wire	blk_cmt_p, blk_cmt_s; 
wire	blk_p, blk_s ;
wire	binit_nucleus_d, binit_nucleus_little_d ;
wire	real_mem_little,real_io_little ;
   wire unimp_CD_prm;
   wire unimp_CD_sec;


wire    dcsm_in,icsm_in, dcsm_access, icsm_access; 

// Start decode in d-stage. Required late e-stage. The logic could
// be moved to the e-stage to save staging flops.

wire	dtsb_8k_ptr, dtsb_64k_ptr, dtsb_dir_ptr;
wire	itsb_8k_ptr, itsb_64k_ptr;
assign	dtsb_8k_ptr = (asi_d[7:0] == 8'h59) ;
assign	dtsb_64k_ptr = (asi_d[7:0] == 8'h5A) ;
assign	dtsb_dir_ptr = (asi_d[7:0] == 8'h5B) ;
assign	itsb_8k_ptr = (asi_d[7:0] == 8'h51) ;
assign	itsb_64k_ptr = (asi_d[7:0] == 8'h52) ;

assign	mmu_rd_only_asi_d =
	dtsb_8k_ptr | dtsb_64k_ptr | dtsb_dir_ptr | itsb_8k_ptr | itsb_64k_ptr ;

assign intrpt_disp_asi_d = (asi_d[7:0] == 8'h73) ; // INTR_W 

assign	dmmu_asi58_d =	(asi_d[7:0] == 8'h58) ; 
assign  immu_asi50_d =  (asi_d[7:0] == 8'h50) ;
   
// ASI Internal Registers - switches out thread among other things
assign	asi_internal_d =
    (asi_d[7:0] == 8'h1A) | // EPS configuration
	(asi_d[7:0] == 8'h40) |	// streaming/ma
	(asi_d[7:0] == 8'h45) |	// LSU Control 
	(asi_d[7:0] == 8'h50) | // I-TSB Tag Target/SFSR/TSB/Tag-Access
	itsb_8k_ptr	      | // I-TSB 8K Ptr 
	itsb_64k_ptr	      | // I-TSB 64K Ptr
	dmmu_asi58_d |
	//(asi_d[7:0] == 8'h58) | // D-TSB Tag Target/SFSR/SFAR/TSB/Tag-Access/VA-PA-Watchpt
	(asi_d[7:0] == 8'h21) | // Primary/Secondary Context
	(asi_d[7:0] == 8'h20) | // Scratchpad.
	(asi_d[7:0] == 8'h25) | // Queue
	(asi_d[7:0] == 8'h4F) | // Hyp Scratchpad
	dtsb_8k_ptr 	      | // D-TSB 8K Ptr
	dtsb_64k_ptr	      | // D-TSB 64K Ptr
	dtsb_dir_ptr	      | // D-TSB Direct Ptr
	(asi_d[7:0] == 8'h72) | // INTR_RECEIVE
	intrpt_disp_asi_d     | // INTR_W
	(asi_d[7:0] == 8'h74) | // INTR_R
	(asi_d[7:0] == 8'h44) | // Self-Timed Margin Ctl
	(asi_d[7:0] == 8'h31) | // dmmu_zctxt_ps0_tsb
	(asi_d[7:0] == 8'h32) | // dmmu_zctxt_ps1_tsb
	(asi_d[7:0] == 8'h39) | // dmmu_nzctxt_ps0_tsb
	(asi_d[7:0] == 8'h3A) | // dmmu_nzctxt_ps1_tsb
	(asi_d[7:0] == 8'h33) | // dmmu_zctxt_cfg_tsb
	(asi_d[7:0] == 8'h3B) | // dmmu_nzctxt_cfg_tsb
	(asi_d[7:0] == 8'h35) | // immu_zctxt_ps0_tsb
	(asi_d[7:0] == 8'h36) | // immu_zctxt_ps1_tsb
	(asi_d[7:0] == 8'h3D) | // immu_nzctxt_ps0_tsb
	(asi_d[7:0] == 8'h3E) | // immu_nzctxt_ps1_tsb
	(asi_d[7:0] == 8'h37) | // immu_zctxt_cfg_tsb
	(asi_d[7:0] == 8'h3F) | // immu_nzctxt_cfg_tsb
	dc_diagnstc_asi_d     | // Dcache Diagnostic
	dtagv_diagnstc_asi_d  | // Dcache Diagnostic
	tlb_lng_ltncy_asi_d   |
	ifu_nontlb_asi_d      ;	

assign	ifu_nontlb_asi_d = 
	(asi_d[7:0] == 8'h42) | // instruction-mask
	(asi_d[7:0] == 8'h43) | // error-inj
	(asi_d[7:0] == 8'h4B) | // sparc-error-enable
	(asi_d[7:0] == 8'h4C) | // sparc-error-status
	(asi_d[7:0] == 8'h4D) | // sparc-error-address
	(asi_d[7:0] == 8'h66) | // icache-instr
	(asi_d[7:0] == 8'h67) ; // icache-tag

assign	dc_diagnstc_asi_d = (asi_d[7:0] == 8'h46) ;
assign	dtagv_diagnstc_asi_d = (asi_d[7:0] == 8'h47) ;

assign	idemap = (asi_d[7:0] == 8'h57) ; // I-MMU Demap Operation
assign	ddemap = (asi_d[7:0] == 8'h5F) ; // D-MMU Demap Operation
assign	ddata_in = (asi_d[7:0] == 8'h5C) ; // D-TLB Data-In
assign	ddaccess = (asi_d[7:0] == 8'h5D) ; // D-TLB Data-Access
assign	dtag_read = (asi_d[7:0] == 8'h5E) ; // D-TLB Tag Read
assign	idata_in = (asi_d[7:0] == 8'h54) ; // I-TLB Data-In
assign	idaccess = (asi_d[7:0] == 8'h55) ; // I-TLB Data-Access
assign	invld_all = (asi_d[7:0] == 8'h60) ; // I/D Invalidate All
assign	itag_read = (asi_d[7:0] == 8'h56) ; // I-TLB Tag Read


assign dcsm_in = (asi_d[7:0] == 8'h0F);
assign icsm_in = (asi_d[7:0] == 8'h0E);
assign dcsm_access = (asi_d[7:0] == 8'h13);
assign icsm_access = (asi_d[7:0] == 8'h12);




assign	tlb_lng_ltncy_asi_d = 
	idemap 		| ddemap 	| ddata_in 	| 
	ddaccess 	| dtag_read 	| idata_in 	| 
	idaccess 	| invld_all 	| itag_read |	
    dcsm_in     | dcsm_access   | icsm_in   |
    icsm_access ;

assign	wr_only_ltlb_asi_d = 
	ddata_in 	|	idata_in 	|
	idemap		|	ddemap		|
    dcsm_in     |   icsm_in     |
	invld_all ;













assign	rd_only_ltlb_asi_d =
	dtag_read	|	itag_read	;



assign	ifill_tlb_asi_d =	// itlb fill asi
	idata_in	| 	idaccess  |	
    icsm_in     |   icsm_access ;

assign	dfill_tlb_asi_d =	// i/d tlb fill asi
	ddata_in	|	ddaccess  |	
    dcsm_in     |   dcsm_access ;








assign	nucleus_asi_exact_d =
	(asi_d[7:0] == 8'h04) |	// asi_nucleus
	(asi_d[7:0] == 8'h0C) ; // asi_nucleus_little

// Nucleus Ctxt
assign	nucleus_asi_d =
	 nucleus_asi_exact_d |
	(asi_d[7:0] == 8'h24) | // asi_nucleus_quad_ldd
	(asi_d[7:0] == 8'h2C) ; // asi_nucleus_quad_ldd_little

assign	asi_if_user_prim_d =
	(asi_d[7:0] == 8'h10) |	// asi_as_if_user_primary
	(asi_d[7:0] == 8'h18) ;	// asi_as_if_user_primary_little

// asi_if_user primary asi
assign	asi_if_user_prim_all_d =
	 asi_if_user_prim_d   |		
	(asi_d[7:0] == 8'h22) |	// asi_as_if_user_primary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'h2A) ;	// asi_as_if_user_primary_quad_ldd_little (blk-init)

assign	prim_asi_exact_d =
	(asi_d[7:0] == 8'h80) |	// asi_primary
	(asi_d[7:0] == 8'h88) ;	// asi_primary_little

// Primary Ctxt
assign	primary_asi_d =
	 asi_if_user_prim_all_d   |	
	 prim_asi_exact_d     |	
	(asi_d[7:0] == 8'h82) |	// asi_primary_no_fault
	(asi_d[7:0] == 8'h8A) |	// asi_primary_no_fault_little
	(asi_d[7:0] == 8'hE2) |	// asi_primary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'hEA) |	// asi_primary_quad_ldd_little (blk-init)
	blk_asif_usr_p | blk_asif_usr_plittle | 
	blk_plittle | blk_p | // block primary asi
	blk_cmt_p |	// Bug 4051
  unimp_CD_prm ;  // Bug 4532
   
assign	asi_if_user_sec_d =
	(asi_d[7:0] == 8'h11) | // asi_as_if_user_secondary
	(asi_d[7:0] == 8'h19) ; // asi_as_if_user_secondary_little

// asi_if_user secondary asi
assign	asi_if_user_sec_all_d =
	 asi_if_user_sec_d   |		
	(asi_d[7:0] == 8'h23) |	// asi_as_if_user_secondary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'h2B) ;	// asi_as_if_user_secondary_quad_ldd_little (blk-init)

assign	as_if_user_asi_d = asi_if_user_prim_all_d | asi_if_user_sec_all_d |
blk_asif_usr_p | blk_asif_usr_plittle | blk_asif_usr_s | blk_asif_usr_slittle ;

assign	sec_asi_exact_d =
	(asi_d[7:0] == 8'h81) | // asi_secondary
	(asi_d[7:0] == 8'h89) ; // asi_secondary_little

// Secondary Ctxt
assign	secondary_asi_d =
	 asi_if_user_sec_all_d    |
	 sec_asi_exact_d      |		
	(asi_d[7:0] == 8'h83) | // asi_secondary_no_fault
	(asi_d[7:0] == 8'h8B) | // asi_secondary_no_fault_little
	(asi_d[7:0] == 8'hE3) |	// asi_secondary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'hEB) |	// asi_secondary_quad_ldd_little (blk-init)
	blk_asif_usr_s | blk_asif_usr_slittle | 
	blk_slittle |  blk_s | // block secondary asi
	blk_cmt_s |  // Bug 4051
  unimp_CD_sec; // Bug 4532

// Little Endian
assign	lendian_asi_d =
	(asi_d[7:0] == 8'h0C) | // asi_nucleus_little
	(asi_d[7:0] == 8'h2C) | // asi_nucleus_quad_ldd_little 
	(asi_d[7:0] == 8'h18) |	// asi_as_if_user_primary_little
	(asi_d[7:0] == 8'h8A) |	// asi_primary_no_fault_little
	(asi_d[7:0] == 8'h8B) | // asi_secondary_no_fault_little
	(asi_d[7:0] == 8'h2A) |	// asi_as_if_user_primary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'hEA) |	// asi_primary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'h19) | // asi_as_if_user_secondary_little
	(asi_d[7:0] == 8'h89) | // asi_secondary_little
	(asi_d[7:0] == 8'h88) |	// asi_primary_little
	(asi_d[7:0] == 8'h2B) |	// asi_as_if_user_secondary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'hEB) |	// asi_secondary_quad_ldd_little (blk-init)
	real_mem_little |
	real_io_little	|
	//(asi_d[7:0] == 8'h1D) |	// asi_phys_bypass_ec_with_ebit_littl
	//(asi_d[7:0] == 8'h1C) |	// asi_phys_bypass_ec_with_ebit_littl
	blk_asif_usr_plittle  | blk_asif_usr_slittle |	// little
	blk_plittle	      | blk_slittle |		// little
	quad_ldd_real_little  | // asi_quad_ldd_real_little
	binit_nucleus_little_d ;// asi_nucleus_blk_init_st_quad_ldd_little

// No Fault
assign	nofault_asi_d =
	(asi_d[7:0] == 8'h82) |	// asi_primary_no_fault
	(asi_d[7:0] == 8'h8A) |	// asi_primary_no_fault_little
	(asi_d[7:0] == 8'h83) | // asi_secondary_no_fault
	(asi_d[7:0] == 8'h8B) ; // asi_secondary_no_fault_little

assign	binit_nucleus_d =
	(asi_d[7:0] == 8'h27) ;	// asi_nucleus_blk_init_st_quad_ldd
assign	binit_nucleus_little_d =
	(asi_d[7:0] == 8'h2F) ;	// asi_nucleus_blk_init_st_quad_ldd_little

// Quad (These are duplicated - they can be shared)
assign	binit_quad_asi_d =
   	binit_nucleus_d |	// asi_nucleus_blk_init_st_quad_ldd
	binit_nucleus_little_d |// asi_nucleus_blk_init_st_quad_ldd_little
	(asi_d[7:0] == 8'h22) |	// asi_as_if_user_primary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'h2A) |	// asi_as_if_user_primary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'h23) |	// asi_as_if_user_secondary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'h2B) |	// asi_as_if_user_secondary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'hE2) |	// asi_primary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'hEA) |	// asi_primary_quad_ldd_little (blk-init)
	(asi_d[7:0] == 8'hE3) |	// asi_secondary_quad_ldd (blk-init)
	(asi_d[7:0] == 8'hEB) ;	// asi_secondary_quad_ldd_little (blk-init)

assign	quad_ldd_real = 
	(asi_d[7:0] == 8'h26) ; // asi_quad_ldd_real
assign	quad_ldd_real_little = 
	(asi_d[7:0] == 8'h2E) ; // asi_quad_ldd_real_little

assign	quad_asi_d =
	binit_quad_asi_d      | // blk-init quad asi
	quad_ldd_real 	      | // asi_quad_ldd_real
	quad_ldd_real_little  | // asi_quad_ldd_real_little
	(asi_d[7:0] == 8'h24) | // asi_nucleus_quad_ldd 
	(asi_d[7:0] == 8'h2C) ; // asi_nucleus_quad_ldd_little 
	
// EC
assign	real_io_little = (asi_d[7:0] == 8'h1D) ;
assign	real_mem_little = (asi_d[7:0] == 8'h1C) ;
	
assign	phy_byp_ec_asi =
	(asi_d[7:0] == 8'h15) |	// asi_phys_bypass_ec_with_ebit(real_io)
	real_io_little ;	// asi_phys_bypass_ec_with_ebit_little(real_io_little)
	//(asi_d[7:0] == 8'h1D) ;	// asi_phys_bypass_ec_with_ebit_little(real_io_little)
				// asi assumed for io address specifically !!
				// asi assumed for io address specifically !!

assign	phy_use_ec_asi =
	(asi_d[7:0] == 8'h14) |	// asi_phys_use_ec(real_mem)
	real_mem_little ;	// asi_phys_use_ec_little(real_mem_little)
	//(asi_d[7:0] == 8'h1C) ;	// asi_phys_use_ec_little(real_mem_little)

assign	phy_use_ec_asi_d = phy_use_ec_asi ;
assign	phy_byp_ec_asi_d = phy_byp_ec_asi ;

// Physical Use - Always results in R->P xslation.
assign	tlb_byp_asi_d = 
		phy_byp_ec_asi | phy_use_ec_asi | 
		quad_ldd_real  | quad_ldd_real_little ;

// Atomic asi
assign	atomic_asi_d = nucleus_asi_exact_d | prim_asi_exact_d | sec_asi_exact_d | 
		asi_if_user_prim_d | asi_if_user_sec_d | phy_use_ec_asi ;

assign	dcache_byp_asi_d = tlb_byp_asi_d ;

// ASI causing Data Access Exceptions - (TBD)

assign	rd_only_asi_d =
	(asi_d[7:0] == 8'h82) |	// asi_primary_no_fault
	(asi_d[7:0] == 8'h8A) |	// asi_primary_no_fault_little
	(asi_d[7:0] == 8'h83) | // asi_secondary_no_fault
	(asi_d[7:0] == 8'h8B) | // asi_secondary_no_fault_little
	(asi_d[7:0] == 8'h74) ; // asi_swrvr_udb_intr_r !! Does not have to be done by intrpt blk !!

assign	wr_only_asi_d =
	(asi_d[7:0] == 8'h73) ; // asi_swrvr_udb_intr_w

// Block Asi
assign	blk_asif_usr_p = (asi_d[7:0] == 8'h16) ; // asi_block_as_if_user_primary
assign	blk_asif_usr_plittle = (asi_d[7:0] == 8'h1E) ; // asi_block_as_if_user_primary_little
assign	blk_asif_usr_s = (asi_d[7:0] == 8'h17) ; // asi_block_as_if_user_secondary
assign	blk_asif_usr_slittle = (asi_d[7:0] == 8'h1F) ; // asi_block_as_if_user_secondary_little
assign	blk_plittle = (asi_d[7:0] == 8'hF8) ; // asi_block_primary_little 
assign	blk_slittle = (asi_d[7:0] == 8'hF9) ; // asi_block_secondary_little 
assign	blk_cmt_p = (asi_d[7:0] == 8'hE0) ; // asi_block_commit_primary ?? behaviour 
assign	blk_cmt_s = (asi_d[7:0] == 8'hE1) ; // asi_block_commit_secondary ?? behaviour 
assign	blk_p = (asi_d[7:0] == 8'hF0) ; // asi_block_primary
assign	blk_s = (asi_d[7:0] == 8'hF1) ; // asi_block_secondary

//assign	blk_cmt_asi_d = blk_cmt_p | blk_cmt_s ;

assign	blk_asi_d = 
	blk_asif_usr_p 	| blk_asif_usr_s |
	blk_plittle	| blk_slittle	 |
	//blk_cmt_p	| blk_cmt_s	 |
	blk_p		| blk_s		 |
	blk_asif_usr_plittle  | blk_asif_usr_slittle |	// little
	blk_plittle	      | blk_slittle ;		// little

// add to little-endian decode
// add to use_real ...
//assign      as_if_supv = 
//    (asi_d[7:0] == 8'h??) | // asi_if_supv_real 
//    (asi_d[7:0] == 8'h??) ; // asi_if_supv_real_little 

wire	unimp_C ;
assign	unimp_C =
	((asi_d[7:4]==4'hC) & 
		~((asi_d[3:0]==4'h6) |
		  (asi_d[3:0]==4'h7) |
		  (asi_d[3:0]==4'hE) |
		  (asi_d[3:0]==4'hF))) ;

wire	unimp_D ;
assign	unimp_D =
	((asi_d[7:4]==4'hD) & 
		~((asi_d[3:0]==4'h4) |
		  (asi_d[3:0]==4'h5) |
		  (asi_d[3:0]==4'h6) |
		  (asi_d[3:0]==4'h7) |
		  (asi_d[3:0]==4'hC) |
		  (asi_d[3:0]==4'hD) |
		  (asi_d[3:0]==4'hE) |
		  (asi_d[3:0]==4'hF))) ;

assign  unimp_CD_prm =
(asi_d[7:0] == 8'hC0) |
(asi_d[7:0] == 8'hC2) |
(asi_d[7:0] == 8'hC4) |
(asi_d[7:0] == 8'hC8) |
(asi_d[7:0] == 8'hCA) |
(asi_d[7:0] == 8'hCC) |
(asi_d[7:0] == 8'hD0) |
(asi_d[7:0] == 8'hD2) |
(asi_d[7:0] == 8'hD8) |
(asi_d[7:0] == 8'hDA) ;
   
assign  unimp_CD_sec = 
(asi_d[7:0] == 8'hC1) |
(asi_d[7:0] == 8'hC3) |
(asi_d[7:0] == 8'hC5) |
(asi_d[7:0] == 8'hC9) |
(asi_d[7:0] == 8'hCB) |
(asi_d[7:0] == 8'hCD) |
(asi_d[7:0] == 8'hD1) |
(asi_d[7:0] == 8'hD3) |
(asi_d[7:0] == 8'hD9) |
(asi_d[7:0] == 8'hDB) ;
   
   
// Unimplemented asi
assign	unimp_asi_d =
// Bug 4692 - all unimplemented internal asi are now
// illegal.
//	(asi_d[7:0] == 8'h6E) | // asi_icache_pre_decode
//	(asi_d[7:0] == 8'h6F) | // asi_icache_next_field
//	(asi_d[7:0] == 8'h48) | // asi_intr_dispatch_status
//	(asi_d[7:0] == 8'h49) | // asi_intr_receive
//	(asi_d[7:0] == 8'h4A) | // asi_upa_config_register
//	(asi_d[7:0] == 8'h4E) | // asi_ecache_tag_data
//  	dflush_asi_d |      //Bug 4580
 	unimp_C | unimp_D | // Bug 4438	
	blk_cmt_p | blk_cmt_s ;
	
// Set of recognized asi's
assign	recognized_asi_d = 
	asi_internal_d | nucleus_asi_d |  primary_asi_d | secondary_asi_d | lendian_asi_d |
	nofault_asi_d | quad_asi_d | tlb_byp_asi_d | unimp_asi_d | blk_asi_d ;

// Displacement Flush for L2
//assign	dflush_asi_d =
//	(asi_d[7:0] == 8'h30) ; // asi_direct_map_ecache

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_excpctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module lsu_excpctl ( /*AUTOARG*/
   // Outputs
   so, lsu_exu_st_dtlb_perr_g, lsu_ffu_st_dtlb_perr_g, 
   lsu_defr_trp_taken_g, lsu_tlu_defr_trp_taken_g, 
   lsu_mmu_defr_trp_taken_g, lsu_st_dtlb_perr_g, 
   lsu_dmmu_sfsr_trp_wr, lsu_dsfsr_din_g, lsu_tlb_perr_ld_rq_kill_w, 
   lsu_spu_early_flush_g, lsu_local_early_flush_g, 
   lsu_tlu_early_flush_w, lsu_tlu_early_flush2_w, lsu_ttype_vld_m2, 
   lsu_ttype_vld_m2_bf1, lsu_ifu_flush_pipe_w, lsu_exu_flush_pipe_w, 
   lsu_mmu_flush_pipe_w, lsu_ffu_flush_pipe_w, lsu_tlu_wtchpt_trp_g, 
   lsu_tlu_dmmu_miss_g, lsu_tlu_misalign_addr_ldst_atm_m, 
   lsu_tlu_daccess_excptn_g, lsu_tlu_daccess_prot_g, 
   lsu_tlu_priv_action_g, lsu_ifu_tlb_data_su, lsu_ifu_tlb_data_ue, 
   lsu_ifu_tlb_tag_ue, lsu_tlu_ttype_m2, lsu_tlu_ttype_vld_m2, 
   stb_cam_sqsh_msk, stb_cam_hit_bf, stb_cam_hit_bf1, 
   tte_data_perror_unc, asi_tte_data_perror, asi_tte_tag_perror, 
   // Inputs
   rclk, si, se, grst_l, arst_l, tlb_rd_tte_data_ebit, 
   tlb_rd_tte_data_pbit, tlb_rd_tte_data_nfobit, 
   tlb_rd_tte_data_wbit, tlb_cam_hit, tlb_pgnum_b39, 
   lsu_ldst_va_b39_m, lsu_sun4r_va_m_l, lsu_sun4r_pgsz_b2t0_e, 
   lsu_sun4v_pgsz_b2t0_e, tlu_early_flush_pipe_w, ifu_lsu_flush_w, 
   ifu_lsu_nceen, lsu_tlb_asi_data_perr_g, lsu_tlb_asi_tag_perr_g, 
   stb_state_vld0, stb_state_vld1, stb_state_vld2, stb_state_vld3, 
   ifu_tlu_thrid_e, tlu_lsu_priv_trap_m, tlu_lsu_pstate_priv, 
   st_inst_vld_e, ld_inst_vld_e, ifu_lsu_alt_space_e, lsu_ldst_va_m, 
   hpv_priv_m, hpstate_en_m, stb_cam_hit, dtlb_bypass_m, 
   lsu_alt_space_m, atomic_m, ldst_dbl_m, fp_ldst_m, lda_internal_m, 
   sta_internal_m, cam_real_m, data_rd_vld_g, tag_rd_vld_g, 
   ldst_sz_m, asi_internal_m, rd_only_ltlb_asi_e, wr_only_ltlb_asi_e, 
   dfill_tlb_asi_e, ifill_tlb_asi_e, nofault_asi_m, as_if_user_asi_m, 
   atomic_asi_m, phy_use_ec_asi_m, phy_byp_ec_asi_m, quad_asi_m, 
   binit_quad_asi_m, blk_asi_m, recognized_asi_m, strm_asi_m, 
   mmu_rd_only_asi_m, rd_only_asi_m, wr_only_asi_m, unimp_asi_m, 
   lsu_nonalt_nucl_access_m, va_wtchpt_cmp_en_m, 
   lsu_va_match_b47_b32_m, lsu_va_match_b31_b3_m, 
   va_wtchpt_msk_match_m, ifu_tlu_inst_vld_m, 
   exu_tlu_misalign_addr_jmpl_rtn_m, exu_tlu_va_oor_m, 
   tlu_dsfsr_flt_vld, tlu_lsu_pstate_cle, tlu_lsu_pstate_am, 
   lsu_excpctl_asi_state_m, lsu_tlu_nonalt_ldst_m, 
   lsu_squash_va_oor_m, lsu_tlu_xslating_ldst_m, lsu_tlu_ctxt_sel_m, 
   lsu_tlu_write_op_m, lsu_memref_m, lsu_flsh_inst_m, 
   tte_data_parity_error, tte_tag_parity_error
   );

   
   input rclk;   
   input si;
   input se;
   input grst_l;
   input arst_l;
   output so;

   //=================================================================
   // input from tlb
//   input [`STLB_DATA_NFO:`STLB_DATA_W] tlb_rd_tte_data ; // tte data from tlb
   input  tlb_rd_tte_data_ebit;
   input  tlb_rd_tte_data_pbit;
   input  tlb_rd_tte_data_nfobit;
   input  tlb_rd_tte_data_wbit;


   input                               tlb_cam_hit;
   input                               tlb_pgnum_b39;
//   input                               tlb_rd_tte_data_locked ;    // lock bit from tte
   //=================================================================

   input	lsu_ldst_va_b39_m ;
   input	lsu_sun4r_va_m_l ; 
   input [2:0]	lsu_sun4r_pgsz_b2t0_e ;
   input [2:0]	lsu_sun4v_pgsz_b2t0_e ;

   input         tlu_early_flush_pipe_w;
   input         ifu_lsu_flush_w;
   input [3:0]   ifu_lsu_nceen ;             // uncorrectible error enable 

   input       	lsu_tlb_asi_data_perr_g ;
   input       	lsu_tlb_asi_tag_perr_g ;

   input [7:0]  stb_state_vld0 ;  // valid bits - stb0
   input [7:0]	stb_state_vld1 ;  // valid bits - stb1
   input [7:0]  stb_state_vld2 ;  // valid bits - stb2
   input [7:0]  stb_state_vld3 ;  // valid bits - stb3

   input [1:0]  ifu_tlu_thrid_e ; // thread-id.

   input	tlu_lsu_priv_trap_m ;	// daccess-excp in tlu

   output 	lsu_exu_st_dtlb_perr_g ;
   output 	lsu_ffu_st_dtlb_perr_g ;

   output	lsu_defr_trp_taken_g ;
   output	lsu_tlu_defr_trp_taken_g ;
   output	lsu_mmu_defr_trp_taken_g ;

   output [3:0]	lsu_st_dtlb_perr_g ;

   output [3:0]  lsu_dmmu_sfsr_trp_wr;	   // sfsr wr based on trap.
   output [23:0] lsu_dsfsr_din_g;


   output lsu_tlb_perr_ld_rq_kill_w ;
   output lsu_spu_early_flush_g;
   output lsu_local_early_flush_g;   //to lsu
   
//   output lsu_dctl_early_flush_w;
   output lsu_tlu_early_flush_w;
   output lsu_tlu_early_flush2_w;

   output lsu_ttype_vld_m2;
   output lsu_ttype_vld_m2_bf1;
   

//   output 	lsu_stbctl_flush_pipe_w ;
//   output 	lsu_stbrwctl_flush_pipe_w ;
   //output lsu_flush_pipe_w;
   output lsu_ifu_flush_pipe_w;
   output lsu_exu_flush_pipe_w;
   output lsu_mmu_flush_pipe_w;
   output lsu_ffu_flush_pipe_w;

   output lsu_tlu_wtchpt_trp_g ;        // watchpt trap has occurred.
   output lsu_tlu_dmmu_miss_g;
   output lsu_tlu_misalign_addr_ldst_atm_m ; // mem_addr unaligned
//   output lsu_tlu_priv_violtn_g;
   wire   lsu_tlu_priv_violtn_g;
   output lsu_tlu_daccess_excptn_g;
   output lsu_tlu_daccess_prot_g;
   output lsu_tlu_priv_action_g;
//   output lsu_tlu_tte_ebit_g;
//   output lsu_tlu_spec_access_epage_g;
//   output lsu_tlu_uncache_atomic_g;
//   output lsu_tlu_illegal_asi_action_g;
//   output lsu_tlu_flt_ld_nfo_pg_g;

   //output lsu_tlu_asi_rd_unc;

   output lsu_ifu_tlb_data_su ;	  // specific to st ue
   output lsu_ifu_tlb_data_ue ;   // dtlb data asi rd parity error ; now ld ue
   output lsu_ifu_tlb_tag_ue ;    // dtlb tag asi rd parity error
  
output [8:0]            lsu_tlu_ttype_m2;
output                  lsu_tlu_ttype_vld_m2;

   output  [7:0]   stb_cam_sqsh_msk ;  // squash spurious hits

   output	stb_cam_hit_bf;		  // buffered stb_cam_hit for qctl1.
   output	stb_cam_hit_bf1;		// buffered stb_cam_hit for stb_rwctl, dctl.

   input [3:0]          tlu_lsu_pstate_priv ;   
//   input [3:0]          tlu_lsu_hpv_priv;
//   input [3:0]          tlu_lsu_hpstate_en;
   
   
   input                st_inst_vld_e;
   input                ld_inst_vld_e;
   input                ifu_lsu_alt_space_e;        // alternate space ld/st

   //interface between lsu_dctldp
   input [7:0]          lsu_ldst_va_m;
   
   //interface between lsu_excpctl and lsu_dctl

   output               tte_data_perror_unc;
   //output               tte_data_perror_corr;
   output		asi_tte_data_perror ;
   output		asi_tte_tag_perror ;


   input hpv_priv_m;
   input hpstate_en_m;
   
   input		stb_cam_hit ;
   
   input                dtlb_bypass_m;
   
   input                lsu_alt_space_m;
   input                atomic_m;
//   input                atomic_g;
   input                ldst_dbl_m;
   input                fp_ldst_m;
//   input                lsu_inst_vld_w;
   input                lda_internal_m;
   input                sta_internal_m;
   input                cam_real_m;
//   input                va_wtchpt_match;

   input                data_rd_vld_g;
   input                tag_rd_vld_g;
   input [1:0]          ldst_sz_m;
   input                asi_internal_m;

//   input                dfill_thread0;
//   input                dfill_thread1;
//   input                dfill_thread2;
//   input                dfill_thread3;

   wire                ld_inst_vld_unflushed;
   wire                st_inst_vld_unflushed;
//   input                flsh_inst_g;
//   input                unc_err_trap_g;
   
   //asi decode
   input                rd_only_ltlb_asi_e;
   input                wr_only_ltlb_asi_e;
   input                dfill_tlb_asi_e;
   input                ifill_tlb_asi_e;

   input                nofault_asi_m;
   input                as_if_user_asi_m;

   input                atomic_asi_m;
   input                phy_use_ec_asi_m;
   input                phy_byp_ec_asi_m;
//   input                tlb_byp_asi_m;
   input                quad_asi_m;
   input                binit_quad_asi_m;
   input                blk_asi_m;
//   input                blk_cmt_asi_m;
   input                recognized_asi_m;
   input                strm_asi_m;
   input                mmu_rd_only_asi_m;
   input                rd_only_asi_m;
   input                wr_only_asi_m;
   input                unimp_asi_m;
   input		lsu_nonalt_nucl_access_m ;

   input    va_wtchpt_cmp_en_m;    //from dctl
   input    lsu_va_match_b47_b32_m;        //from qdp1
   input    lsu_va_match_b31_b3_m;         //from qdp1

   input    va_wtchpt_msk_match_m; //from dctldp

   input		ifu_tlu_inst_vld_m ;

input           exu_tlu_misalign_addr_jmpl_rtn_m;// misaligned addr - jmpl or return addr
input           exu_tlu_va_oor_m;       	// ??? - to be used in sfsr
input [3:0]     tlu_dsfsr_flt_vld;
input [3:0]   	tlu_lsu_pstate_cle ;       // current little endian
input [3:0]   	tlu_lsu_pstate_am ;        // address mask
input  [7:0]    lsu_excpctl_asi_state_m ;   // ASI State + imm asi
input          	lsu_tlu_nonalt_ldst_m ; // non-alternate load or store // FORCE
input      	lsu_squash_va_oor_m ;   // squash va_oor for mem-op. // FORCE
input           lsu_tlu_xslating_ldst_m ;// xslating ldst,atomic etc // FORCE
input   [2:0]   lsu_tlu_ctxt_sel_m;           // context selected:0-p,1-s,2-n // FORCE
input           lsu_tlu_write_op_m; // FORCE
input		lsu_memref_m ;
input           lsu_flsh_inst_m ;
   

input    tte_data_parity_error ;
input    tte_tag_parity_error ;

wire	other_flush_pipe_w ;
wire	defr_trp_taken ;
wire 	defr_trp_taken_m, defr_trp_taken_byp, defr_trp_taken_m_din ;   
wire  	tlb_tte_vld_m, tlb_tte_vld_g ;
wire 	priv_pg_usr_mode_m, priv_pg_usr_mode_g, priv_pg_usr_mode;
wire 	nfo_pg_nonnfo_asi_m, nfo_pg_nonnfo_asi_g, nfo_pg_nonnfo_asi;
wire  	spec_access_epage_m, spec_access_epage_g, spec_access_epage ;
wire   	nonwr_pg_st_access;
   
//=========================================================================================
// MISCELLANEOUS
//=========================================================================================

   wire       clk;
   assign     clk = rclk;
   wire       reset;

   wire       dbb_reset_l;

    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

   assign reset = ~dbb_reset_l ;

bw_u1_buf_30x UZsize_stb_cam_hit_bf1  (.a(stb_cam_hit),   .z(stb_cam_hit_bf1));  //to dctl, stb_rwctl
bw_u1_buf_30x UZsize_stb_cam_hit_bf   (.a(stb_cam_hit),   .z(stb_cam_hit_bf ));  //to qctl1

wire                ld_inst_vld_m;
wire                st_inst_vld_m;

dff_s #(2) inst_vld_stgm (
   .din ({ld_inst_vld_e, st_inst_vld_e}),
   .q   ({ld_inst_vld_m, st_inst_vld_m}),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);

dff_s #(2) inst_vld_stgg (
   .din ({ld_inst_vld_m, st_inst_vld_m}),
   .q   ({ld_inst_vld_unflushed, st_inst_vld_unflushed}),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);

wire	tlu_priv_trap_g ;
dff_s #(1) tprivtrp_g (
   .din (tlu_lsu_priv_trap_m),
   .q   (tlu_priv_trap_g),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);
   
  
//=========================================================================================
//  Thread Staging
//=========================================================================================

wire [1:0] thrid_m, thrid_g ;
dff_s #(2)  tid_stgm (
        .din    (ifu_tlu_thrid_e[1:0]),
        .q      (thrid_m[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	thread0_m, thread1_m, thread2_m, thread3_m;

assign	thread0_m = ~thrid_m[1] & ~thrid_m[0] ;
assign	thread1_m = ~thrid_m[1] &  thrid_m[0] ;
assign	thread2_m =  thrid_m[1] & ~thrid_m[0] ;
assign	thread3_m =  thrid_m[1] &  thrid_m[0] ;

wire thread0_g, thread1_g, thread2_g, thread3_g ;
dff_s #(4)  tid_stgg (
        .din    ({thread0_m, thread1_m, thread2_m, thread3_m}),
        .q      ({thread0_g, thread1_g, thread2_g, thread3_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//=========================================================================================
//  INST_VLD_W GENERATION
//=========================================================================================


assign	thrid_g[0] = thread1_g | thread3_g ;
assign	thrid_g[1] = thread2_g | thread3_g ;
   
wire    flush_w_inst_vld_m ;
wire    lsu_inst_vld_w ;
wire	lsu_flush_pipe_w;
assign  flush_w_inst_vld_m =
        ifu_tlu_inst_vld_m &
        ~(lsu_flush_pipe_w & (thrid_m[1:0] == thrid_g[1:0])) ; // really lsu_flush_pipe_w

dff_s  stgw_ivld (
        .din    (flush_w_inst_vld_m),
        .q      (lsu_inst_vld_w),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//========================================================================
//	Miscellaneous
//========================================================================


// Moved to excpctl from stb_rwctl as excpctl is closer to stb-cam.
mux4ds  #(8) stbvld_mx (
  .in0  (~stb_state_vld0[7:0]),
  .in1  (~stb_state_vld1[7:0]),
  .in2  (~stb_state_vld2[7:0]),
  .in3  (~stb_state_vld3[7:0]),
  .sel0 (thread0_g),
  .sel1 (thread1_g),
  .sel2 (thread2_g),
  .sel3 (thread3_g),
  .dout (stb_cam_sqsh_msk[7:0])
);
   
//========================================================================
//  Exception Handling Begin
//========================================================================

//va watch point
   wire va_match_g;
   wire va_wtchpt_msk_match_g;


wire	va_wtchpt_en_m ;

assign	va_wtchpt_en_m = 
va_wtchpt_cmp_en_m & 
(((~asi_internal_m & recognized_asi_m) & lsu_alt_space_m) | ~lsu_alt_space_m) // Bug5226
& (ld_inst_vld_m | st_inst_vld_m) & //bug 3681
 ~(hpv_priv_m & hpstate_en_m)  // ECO 4178
& ~cam_real_m ;                // ECO 5470 (TO_2_0)

//bug6480   
   wire lsu_va_match_m;
   wire	pstate_am_m ;

assign lsu_va_match_m = ((lsu_va_match_b47_b32_m & lsu_va_match_b31_b3_m) & ~pstate_am_m) |
                          (lsu_va_match_b31_b3_m & pstate_am_m);

wire va_wtchpt_en_g; 
dff_s #(3)  stgwtch_g (
        .din    ({va_wtchpt_en_m,
                  lsu_va_match_m,
                  va_wtchpt_msk_match_m}), 
        .q      ({va_wtchpt_en_g,
                  va_match_g,
                  va_wtchpt_msk_match_g}), 
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


// These signals will eventually generate exceptions.
   wire va_wtchpt_match;
   
assign  va_wtchpt_match = 
        va_match_g &  va_wtchpt_msk_match_g & lsu_inst_vld_w & va_wtchpt_en_g;

assign  lsu_tlu_wtchpt_trp_g = va_wtchpt_match ;


// tlb related exceptions/errors
wire  tlb_daccess_excptn_e, tlb_daccess_excptn_m ; 
wire  tlb_daccess_excptn_e_d1;
wire	tlb_illgl_pgsz_m ;

assign  tlb_daccess_excptn_e  =
  ((rd_only_ltlb_asi_e &  st_inst_vld_e)  |
   (wr_only_ltlb_asi_e &  ld_inst_vld_e)) & ifu_lsu_alt_space_e   ;
  
dff_s  #(1) tlbex_stgm (
        .din    ({tlb_daccess_excptn_e}),
        .q      ({tlb_daccess_excptn_e_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign tlb_daccess_excptn_m = tlb_daccess_excptn_e_d1 | tlb_illgl_pgsz_m;
      
wire pstate_priv_m;
//wire pstate_priv;

mux4ds  #(1) pstate_priv_m_mux (
        .in0    (tlu_lsu_pstate_priv[0]),
        .in1    (tlu_lsu_pstate_priv[1]),
        .in2    (tlu_lsu_pstate_priv[2]),
        .in3    (tlu_lsu_pstate_priv[3]),
        .sel0   (thread0_m),  
        .sel1   (thread1_m),
        .sel2   (thread2_m),  
        .sel3   (thread3_m),
        .dout   (pstate_priv_m)
);
   
//dff #(1)  priv_stgg (
//        .din    (pstate_priv_m),
//        .q      (pstate_priv),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );

// privilege violation - priv page accessed in user mode
//timing 
//assign  priv_pg_usr_mode =  // data access exception; TT=h30
//  (ld_inst_vld_unflushed | st_inst_vld_unflushed) & ~(pstate_priv | hpv_priv) & tlb_rd_tte_data_pbit ;

//SC2   wire hpv_priv_m;
     
   assign priv_pg_usr_mode_m = (ld_inst_vld_m | st_inst_vld_m) & ~(pstate_priv_m | hpv_priv_m);

dff_s #(1) priv_pg_usr_mode_stgg  (
        .din    (priv_pg_usr_mode_m),
        .q      (priv_pg_usr_mode_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
   assign priv_pg_usr_mode = priv_pg_usr_mode_g & tlb_rd_tte_data_pbit ;
   
// protection violation - store to a page that does not have write permission
//timing
//assign  nonwr_pg_st_access =  // data access protection; TT=h33
//  st_inst_vld_unflushed   & 
//  ~tlb_rd_tte_data_wbit & ~lsu_dtlb_bypass_g & tlb_cam_hit_g ;
//   //lsu_dtlb_bypass_g) ; // W=1 in bypass mode - In bypass mode this trap will never happen !!!

   assign nonwr_pg_st_access = ~tlb_rd_tte_data_wbit & st_inst_vld_unflushed & tlb_tte_vld_g;
   
wire  daccess_prot ;
assign  daccess_prot = nonwr_pg_st_access  ;
    //((~lsu_dtlb_bypass_g & tlb_cam_hit_g) | (tlb_byp_asi_g & lsu_alt_space_g)) ;

// access to a page marked with the nfo with an asi other than nfo asi.
//timing
//assign  nfo_pg_nonnfo_asi  =  // data access exception; TT=h30
//  (ld_inst_vld_unflushed | st_inst_vld_unflushed) &   // any access
//  ((~nofault_asi_g & lsu_alt_space_g) | ~lsu_alt_space_g) // in alternate space or not
//  & tlb_rd_tte_data_nfobit ;

assign nfo_pg_nonnfo_asi_m = (ld_inst_vld_m | st_inst_vld_m) &
                             ((~nofault_asi_m & lsu_alt_space_m) | ~lsu_alt_space_m) ;
   
dff_s #(1) nfo_pg_nonnfo_asi_stgg   (
        .din    (nfo_pg_nonnfo_asi_m),
        .q      (nfo_pg_nonnfo_asi_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
assign    nfo_pg_nonnfo_asi = nfo_pg_nonnfo_asi_g & tlb_rd_tte_data_nfobit ;
   
// as_if_usr asi accesses priv page.
//timing
//assign  as_if_usr_priv_pg  =  // data access exception; TT=h30
//  (ld_inst_vld_unflushed | st_inst_vld_unflushed) & as_if_user_asi_g & lsu_alt_space_g & 
//      tlb_rd_tte_data_pbit ;

   wire   as_if_usr_priv_pg_m, as_if_usr_priv_pg_g, as_if_usr_priv_pg;
   assign as_if_usr_priv_pg_m = (ld_inst_vld_m | st_inst_vld_m) & as_if_user_asi_m & lsu_alt_space_m;
 
dff_s #(1) as_if_usr_priv_pg_stgg   (
        .din    (as_if_usr_priv_pg_m),
        .q      (as_if_usr_priv_pg_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   assign  as_if_usr_priv_pg =  as_if_usr_priv_pg_g & tlb_rd_tte_data_pbit ; 
 
// non-cacheable address - iospace PA[39] = 1 
// atomic access to non-cacheable space.
   wire    atm_access_w_nc, atomic_g;

dff_s #(1) atm_stgg (
        .din    (atomic_m),
        .q      (atomic_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   
assign  atm_access_w_nc = atomic_g & tlb_pgnum_b39 ; // io space 

// atomic inst with unsupported asi.
//timing
//assign  atm_access_unsup_asi = atomic_g & ~atomic_asi_g & lsu_alt_space_g ;
   wire atm_access_unsup_asi_m, atm_access_unsup_asi;
   
assign  atm_access_unsup_asi_m = atomic_m & ~atomic_asi_m & lsu_alt_space_m;

dff_s #(1) atm_access_unsup_asi_stgg   (
        .din    (atm_access_unsup_asi_m),
        .q      (atm_access_unsup_asi),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   
//timing
//assign  tlb_tte_vld_g = ~lsu_dtlb_bypass_g & tlb_cam_hit_g ;

wire	dmmu_va_oor_m ;
assign  tlb_tte_vld_m = ~dtlb_bypass_m & tlb_cam_hit & 
			~((unimp_asi_m | asi_internal_m | ~recognized_asi_m) & 
				lsu_alt_space_m) & // Bug 3541,5186
			~dmmu_va_oor_m ; // Bug 5070
	
dff_s #(1) tlb_tte_vld_stgg   (
        .din    (tlb_tte_vld_m),
        .q      (tlb_tte_vld_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
wire  pg_with_ebit_m, pg_with_ebit_g, pg_with_ebit  ;
//timing   
//assign	pg_with_ebit = 
//	(tlb_rd_tte_data_ebit & tlb_tte_vld_g)  | // tte
//        (lsu_dtlb_bypass_g & ~(phy_use_ec_asi_g & lsu_alt_space_g)) | // regular bypass 
//        (tlb_byp_asi_g & ~phy_use_ec_asi_g & lsu_alt_space_g) ; // phy_byp

assign	pg_with_ebit_m = 
        (dtlb_bypass_m & ~(phy_use_ec_asi_m & lsu_alt_space_m) & 
	(lsu_ldst_va_b39_m & ~pstate_am_m)) |
	// regular bypass // Bug 4296,5050 related.
        (dtlb_bypass_m & (phy_byp_ec_asi_m & lsu_alt_space_m)) ; // phy_byp

dff_s #(1) pg_with_ebit_stgg   (
        .din    (pg_with_ebit_m),
        .q      (pg_with_ebit_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
assign  pg_with_ebit = (tlb_rd_tte_data_ebit & tlb_tte_vld_g)  | // tte  
	                      pg_with_ebit_g;
   
//timing
//assign  spec_access_epage = 
//  ((ld_inst_vld_unflushed & nofault_asi_g & lsu_alt_space_g) |  // spec load
//  flsh_inst_g) & // flush inst
//  pg_with_ebit ; // page with side effects
////  tlb_rd_tte_data_ebit ; // page with side effects

assign  spec_access_epage_m = 
// Bug 5166
((ld_inst_vld_m & ~atomic_m) & nofault_asi_m & lsu_alt_space_m);   // spec load
dff_s #(1) spec_access_epage_stgg   (
        .din    (spec_access_epage_m),
        .q      (spec_access_epage_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
// remove flsh_inst_g ??   
//assign spec_access_epage = (spec_access_epage_g  | flsh_inst_g) & pg_with_ebit;
assign spec_access_epage = (spec_access_epage_g) & pg_with_ebit;
   

   wire quad_asi_non_ldstda_m;
   // covers regular quad asi AND binit. 
   assign quad_asi_non_ldstda_m = 
	quad_asi_m & lsu_alt_space_m & 
		((~ldst_dbl_m & ld_inst_vld_m) | // only lddbl should use
		(fp_ldst_m & (ld_inst_vld_m | st_inst_vld_m))) ; // float should not use

   wire	true_quad_non_ldda_m ; 
   // catches case where st or non-ldd uses asi
   assign true_quad_non_ldda_m =
	(quad_asi_m & ~binit_quad_asi_m) & lsu_alt_space_m & 
  ((~ldst_dbl_m & ld_inst_vld_m) | st_inst_vld_m) ;
   
wire  blk_asi_non_ldstdfa_m ;

assign  blk_asi_non_ldstdfa_m = blk_asi_m & lsu_alt_space_m & 
     ~(ldst_dbl_m & fp_ldst_m) & (ld_inst_vld_m | st_inst_vld_m) ;

// trap on illegal asi
wire  illegal_asi_trap_m, illegal_asi_trap_g, illegal_asi_trap_m_d1 ;

assign  illegal_asi_trap_m = 
((ld_inst_vld_m | st_inst_vld_m) & lsu_alt_space_m & ~recognized_asi_m) | 
((ld_inst_vld_m | st_inst_vld_m) & asi_internal_m & fp_ldst_m & lsu_alt_space_m) | // Bug 4382
blk_asi_non_ldstdfa_m |
quad_asi_non_ldstda_m |
true_quad_non_ldda_m  ; 
   
dff_s #(1) illegal_asi_trap_stgg   (
        .din    (illegal_asi_trap_m),
        .q      (illegal_asi_trap_m_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   //need lsu_inst_vld_w ??
//   assign illegal_asi_trap_g = illegal_asi_trap_m_d1 & lsu_inst_vld_w;
   assign illegal_asi_trap_g = illegal_asi_trap_m_d1;
         
wire wr_to_strm_sync_m ;
//timing
//assign	wr_to_strm_sync =  	
//  strm_asi & ((ldst_va_g[7:0] == 8'hA0) | (ldst_va_g[7:0] == 8'h68)) &
//  st_inst_vld_unflushed & lsu_alt_space_g ;

assign	wr_to_strm_sync_m =  	// Bug 5742
  strm_asi_m & (lsu_ldst_va_m[7:0] == 8'hA0) & st_inst_vld_m & lsu_alt_space_m ;

/*dff #(1) wr_to_strm_sync_stgg   (
        .din    (wr_to_strm_sync_m),
        .q      (wr_to_strm_sync),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );*/
   

// HPV Changes 
// Push back into previous stage.
// qualification with hpv_priv and hpstate_en required to ensure hypervisor
// is not trying to access.
//SC2   wire hpv_priv_e;
   
//SC2 mux4ds  #(1) hpv_priv_e_mux (
//SC2        .in0    (tlu_lsu_hpv_priv[0]),
//SC2        .in1    (tlu_lsu_hpv_priv[1]),
//SC2        .in2    (tlu_lsu_hpv_priv[2]),
//SC2        .in3    (tlu_lsu_hpv_priv[3]),
//SC2        .sel0   (thread0_e),  
//SC2        .sel1   (thread1_e),
//SC2        .sel2   (thread2_e),  
//SC2        .sel3   (thread3_e),
//SC2       .dout   (hpv_priv_e)
//SC2);

//SC2   wire hpstate_en_e;
   
//SC2 mux4ds  #(1) hpstate_en_e_mux (
//SC2        .in0    (tlu_lsu_hpstate_en[0]),
//SC2        .in1    (tlu_lsu_hpstate_en[1]),
//SC2        .in2    (tlu_lsu_hpstate_en[2]),
//SC2        .in3    (tlu_lsu_hpstate_en[3]),
//SC2        .sel0   (thread0_e),  
//SC2        .sel1   (thread1_e),
//SC2        .sel2   (thread2_e),  
//SC2        .sel3   (thread3_e),
//SC2        .dout   (hpstate_en_e)
//SC2);
//SC2   wire hpstate_en_m;
   
//SC2 dff #(2) hpv_stgm (
//SC2        .din    ({hpv_priv_e, hpstate_en_e}),
//SC2        .q    	({hpv_priv_m, hpstate_en_m}),
//SC2        .clk    (clk),
//SC2        .se     (se),       .si (),          .so ()
//SC2        );
//SC2   wire hpv_priv, hpstate_en;

   
//SC2 dff #(2) hpv_stgg (
//SC2        .din    ({hpv_priv_m, hpstate_en_m}),
//SC2        .q     	({hpv_priv,   hpstate_en}),
//SC2        .clk    (clk),
//SC2        .se     (se),       .si (),          .so ()
//SC2        );

/*assign  priv_action = (ld_inst_vld_unflushed | st_inst_vld_unflushed) & ~lsu_asi_state[7] & 
      ~pstate_priv & ~(hpv_priv & hpstate_en) & lsu_alt_space_g ;*/
// Generate a stage earlier
   wire priv_action_m, priv_action;
   
assign  priv_action_m = (ld_inst_vld_m | st_inst_vld_m) & 
	((~lsu_excpctl_asi_state_m[7] & lsu_alt_space_m) |	// alt_space
	lsu_nonalt_nucl_access_m) &		// non-alt space - nucleus ctxt
      ~pstate_priv_m & ~(hpv_priv_m & hpstate_en_m) ;

/*assign  priv_action_m = (ld_inst_vld_m | st_inst_vld_m) & ~lsu_excpctl_asi_state_m[7] & 
      ~pstate_priv_m & ~(hpv_priv_m & hpstate_en_m) & lsu_alt_space_m ;*/

dff_s  pact_stgg (
        .din    (priv_action_m),
        .q    	(priv_action),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Take data_access exception if supervisor uses hypervisor asi  
   wire hpv_asi_range_m;
   wire spv_use_hpv_m ;
//timing
//assign  hpv_asi_range =
//                    ~lsu_asi_state[7] & (
//                         (~lsu_asi_state[6] & lsu_asi_state[5] & lsu_asi_state[4]) | // 0x3?
//                         ( lsu_asi_state[6]));  
    
assign  hpv_asi_range_m =
                         ~lsu_excpctl_asi_state_m[7] & (
                         (~lsu_excpctl_asi_state_m[6] & lsu_excpctl_asi_state_m[5] & lsu_excpctl_asi_state_m[4]) | // 0x3?
                         ( lsu_excpctl_asi_state_m[6]));                                   // 0x4?,5?,6?,7?

// Take data_access exception if supervisor uses hypervisor asi

assign  spv_use_hpv_m = (ld_inst_vld_m | st_inst_vld_m) &
                         hpv_asi_range_m &
                         pstate_priv_m & ~hpv_priv_m & lsu_alt_space_m ;

// EARLY TRAPS

// memory address not aligned
wire  qw_align_addr,blk_align_addr ;
wire  hw_align_addr,wd_align_addr,dw_align_addr;

assign  hw_align_addr = ~lsu_ldst_va_m[0] ;         // half-word addr
assign  wd_align_addr = ~lsu_ldst_va_m[1] & ~lsu_ldst_va_m[0] ;     // word addr
assign  dw_align_addr = ~lsu_ldst_va_m[2] & ~lsu_ldst_va_m[1] & ~lsu_ldst_va_m[0] ; // dw addr
assign  qw_align_addr = ~lsu_ldst_va_m[3] & ~lsu_ldst_va_m[2] & ~lsu_ldst_va_m[1] & ~lsu_ldst_va_m[0] ; // qw addr
assign  blk_align_addr = 
~lsu_ldst_va_m[5] & ~lsu_ldst_va_m[4] & ~lsu_ldst_va_m[3] & 
~lsu_ldst_va_m[2] & ~lsu_ldst_va_m[1] & ~lsu_ldst_va_m[0] ; // 64B aligned addr for block ld/st

wire  hw_size,wd_size,dw_size;

//assign  byte_size = ~ldst_sz_m[1] &  ~ldst_sz_m[0] ; // byte size    
assign  hw_size = ~ldst_sz_m[1] &  ldst_sz_m[0] ; // half-word size 
assign  wd_size =  ldst_sz_m[1] & ~ldst_sz_m[0] ; // word size
assign  dw_size =  ldst_sz_m[1] &  ldst_sz_m[0] ; // double-word size

wire  mem_addr_not_align ;
   
assign  mem_addr_not_align
  = (((hw_size & ~hw_align_addr) | // half-word check
    (wd_size & ~wd_align_addr)  | // word check
    (dw_size & ~dw_align_addr)  | // double word check
    //((quad_asi_m | binit_quad_asi_m) & lsu_alt_space_m & ldst_dbl_m & ~qw_align_addr) | // quad word check
    (blk_asi_m & lsu_alt_space_m & fp_ldst_m & ldst_dbl_m & ~blk_align_addr)) & // 64B blk ld/st check
    //(blk_asi_m & lsu_alt_space_m & blk_asi_m & ~blk_align_addr)) & // 64B blk ld/st check
    (ld_inst_vld_m | st_inst_vld_m)) |
    // check only for loads 
    (((quad_asi_m | binit_quad_asi_m) & lsu_alt_space_m & ldst_dbl_m & ~qw_align_addr) & ld_inst_vld_m) ; // quad word check

// To be removed !! Now supported for both ld and st thru unimp_asi.
//wire	blkst_cmt_daccess_excp_m ;
//assign	blkst_cmt_daccess_excp_m =
//    (blk_cmt_asi_m & lsu_alt_space_m & fp_ldst_m & ldst_dbl_m & st_inst_vld_m) ;

   wire    stdf_maddr_not_align, lddf_maddr_not_align ;

assign  stdf_maddr_not_align
    = st_inst_vld_m & fp_ldst_m & ldst_dbl_m & wd_align_addr & ~dw_align_addr 
      & ~((blk_asi_m | quad_asi_m) & lsu_alt_space_m);

assign  lddf_maddr_not_align
    = ld_inst_vld_m & fp_ldst_m & ldst_dbl_m & wd_align_addr & ~dw_align_addr 
      & ~((blk_asi_m | quad_asi_m) & lsu_alt_space_m);

// internal asi access by ld/st other than ldxa/stxa/lddfa/stdfa.
wire  asi_internal_non_xdw ;

assign  asi_internal_non_xdw 
    = (st_inst_vld_m | ld_inst_vld_m) & lsu_alt_space_m & asi_internal_m  & 
      ~(dw_size & (~ldst_dbl_m | fp_ldst_m)) ; //bug4149;


// asi related
// rd-only mmu asi requiring va decode.
wire	mmu_rd_only_asi_wva_m ;
assign	mmu_rd_only_asi_wva_m =
	((lsu_excpctl_asi_state_m[7:0]==8'h58) & (
		(lsu_ldst_va_m[7:0] == 8'h00) | 	// dtag_target
		(lsu_ldst_va_m[7:0] == 8'h20))) | 	// dsync_far
	((lsu_excpctl_asi_state_m[7:0]==8'h50) & 
		(lsu_ldst_va_m[7:0] == 8'h00)) ; 	// itag_target

wire  wr_to_rd_only_asi, rd_of_wr_only_asi, unimp_asi_used;   

assign  wr_to_rd_only_asi = 
	((mmu_rd_only_asi_wva_m |// mmu with non-unique asi
	mmu_rd_only_asi_m |	// mmu with unique asi
	rd_only_asi_m)		// non mmu
	 &  st_inst_vld_m & lsu_alt_space_m) |
	wr_to_strm_sync_m ;	// Bug 5399

assign  rd_of_wr_only_asi = wr_only_asi_m &  ld_inst_vld_m & lsu_alt_space_m ;
assign  unimp_asi_used = unimp_asi_m &  (ld_inst_vld_m | st_inst_vld_m) & lsu_alt_space_m ;

   wire asi_related_trap_m ; // asi_related_trap_g;

assign  asi_related_trap_m = wr_to_rd_only_asi | rd_of_wr_only_asi | unimp_asi_used | asi_internal_non_xdw ;

// Illegal page size for tlb fill

wire	[2:0]	pgszr_m,pgszv_m ;
dff_s #(6)   pgsz_stgm (
        .din    ({lsu_sun4r_pgsz_b2t0_e[2:0],lsu_sun4v_pgsz_b2t0_e[2:0]}),
        .q      ({pgszr_m[2:0],pgszv_m[2:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	[2:0]	pgsz_m ;

assign	pgsz_m[2:0] = lsu_sun4r_va_m_l ? pgszv_m[2:0] : pgszr_m[2:0] ;

wire	illgl_pgsz_m ;
assign	illgl_pgsz_m = 
	(~pgsz_m[2] &  pgsz_m[1] & ~pgsz_m[0]) | // 010 ; 512K
	( pgsz_m[2] & ~pgsz_m[1] & ~pgsz_m[0]) | // 100 ; 32M
	( pgsz_m[2] &  pgsz_m[1] & ~pgsz_m[0]) | // 110 ; 2G
	( pgsz_m[2] &  pgsz_m[1] &  pgsz_m[0]) ; // 111 ; 16G

wire	ifill_tlb_asi_m,dfill_tlb_asi_m ;
dff_s #(2)   idfill_stgm (
        .din    ({ifill_tlb_asi_e,dfill_tlb_asi_e}),
        .q      ({ifill_tlb_asi_m,dfill_tlb_asi_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	tlb_illgl_pgsz_m = 
	(ifill_tlb_asi_m | dfill_tlb_asi_m) & st_inst_vld_m & lsu_alt_space_m & illgl_pgsz_m ;

wire  [8:0] early_ttype_m,early_ttype_g ; 
wire    early_trap_vld_m, early_trap_vld_g ;  
assign  early_trap_vld_m =  
			stdf_maddr_not_align | lddf_maddr_not_align | 
			mem_addr_not_align ;
     
wire	lsu_tlu_misalign_addr_ldst_atm_m ; 
assign  lsu_tlu_misalign_addr_ldst_atm_m = early_trap_vld_m ;

// mux select order must be maintained
assign  early_ttype_m[8:0] = 
      stdf_maddr_not_align ? 9'h036 :
        lddf_maddr_not_align ? 9'h035 : 
           mem_addr_not_align ?  9'h034 : 9'hxxx ; 
   
dff_s #(10)   etrp_stgg (
        .din    ({early_ttype_m[8:0],early_trap_vld_m}),
        .q      ({early_ttype_g[8:0],early_trap_vld_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire daccess_excptn_early_m, daccess_excptn_early_g ;

wire atm_access_w_nc_byp_m,atm_access_w_nc_byp_g ;
assign atm_access_w_nc_byp_m = 
atomic_m & dtlb_bypass_m & (lsu_ldst_va_b39_m & ~pstate_am_m) ; 
						//Bug 5050

dff_s   atmbyp_stgg (
        .din    (atm_access_w_nc_byp_m),
        .q      (atm_access_w_nc_byp_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign daccess_excptn_early_m =
    asi_related_trap_m | tlb_daccess_excptn_m |
    spv_use_hpv_m |  
    atm_access_w_nc_byp_m ; // Bug 4281.

dff_s  #(1) dearly_stgg (
        .din    (daccess_excptn_early_m),
        .q      (daccess_excptn_early_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire daccess_excptn;
   
assign  daccess_excptn =  
    (priv_pg_usr_mode | as_if_usr_priv_pg | nfo_pg_nonnfo_asi | 
      atm_access_w_nc ) & tlb_tte_vld_g | 
      illegal_asi_trap_g | daccess_excptn_early_g | atm_access_unsup_asi | //bug4622
    	spec_access_epage ; 
 
   wire [3:0] lsu_nceen_d1;  
dff_s #(4)  nceen_d1_ff (
        .din    (ifu_lsu_nceen[3:0]),
        .q      (lsu_nceen_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
wire nceen_pipe_g ;
assign  nceen_pipe_g = 
  (thread0_g & lsu_nceen_d1[0]) | (thread1_g & lsu_nceen_d1[1]) |
  (thread2_g & lsu_nceen_d1[2]) | (thread3_g & lsu_nceen_d1[3]) ;

 // correctible dtlb data parity error on cam will cause dmmu miss.
// prefetch will rely on the ld_inst_vld/st_inst_vld not being asserted
// to prevent mmu_miss from being signalled if prefetch does not translate.
// Timing Change : Remove data perror from dmmu_miss ; to be treated as disrupting trap.
   wire dmmu_miss_m, dmmu_miss_m_d1;
   
assign dmmu_miss_m = 
  ~tlb_cam_hit & ~dtlb_bypass_m & 
  (ld_inst_vld_m | st_inst_vld_m) & 
  ~(lda_internal_m | sta_internal_m | early_trap_vld_m) ;

dff_s #(1)  dmmu_miss_stgg (
        .din    (dmmu_miss_m),
        .q      (dmmu_miss_m_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
//need lsu_inst_vld_w ??
   wire dmmu_miss_g;
   
   assign dmmu_miss_g = dmmu_miss_m_d1 & lsu_inst_vld_w;
   

wire [8:0] dmiss_type ;
   wire    cam_real_g;
   
dff_s #(1) cam_real_stgg (
   .din (cam_real_m),
   .q   (cam_real_g),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
   );  
 assign        dmiss_type[8:0] = cam_real_g ? 9'h03f : 9'h068 ;

// two wtchpt matches
//assign  lsu_tlu_ttype_m2[8:0] = 
//  early_trap_vld_g ? early_ttype_g[8:0] : 
//    priv_action ? 9'h037 : 
//      va_wtchpt_match ? 9'h062 :
//        daccess_excptn ? 9'h030 : 
//          dmmu_miss_g ? dmiss_type[8:0] :  // dmmu_miss
//            daccess_error ? 9'h032 : 
//              daccess_prot ? 9'h06c :
//	              spubyp_trap_active_g ? {3'b000,spubyp_ttype[5:0]} : // should be no other tttype to compare to. 
//                  9'bx_xxxx_xxxx ;

wire early_trap_vld_sel, priv_action_sel, va_wtchpt_match_sel, daccess_excptn_sel, dmmu_miss_sel,
     daccess_prot_sel ;

// Need to maintain this order in selects. Based on priority of traps    
   assign early_trap_vld_sel = early_trap_vld_g;
   assign priv_action_sel = ~early_trap_vld_sel & priv_action;
   assign va_wtchpt_match_sel = ~early_trap_vld_sel & ~priv_action_sel & va_wtchpt_match;
   assign daccess_excptn_sel = ~early_trap_vld_sel & ~priv_action_sel & ~va_wtchpt_match_sel &
                               daccess_excptn;
   assign dmmu_miss_sel = ~early_trap_vld_sel & ~priv_action_sel & ~va_wtchpt_match_sel &
                          ~daccess_excptn_sel & dmmu_miss_g;

   assign daccess_prot_sel = ~early_trap_vld_sel & ~priv_action_sel & ~va_wtchpt_match_sel &
                             ~daccess_excptn_sel & ~dmmu_miss_sel & daccess_prot;
   
assign  lsu_tlu_ttype_m2[8:0] =
          ({9{early_trap_vld_sel}}     &  early_ttype_g[8:0]) | 
          ({9{priv_action_sel}}        &  9'h037            ) |
          ({9{va_wtchpt_match_sel}}    &  9'h062            ) |
          ({9{daccess_excptn_sel}}     &  9'h030            ) |
          ({9{dmmu_miss_sel}}          &  dmiss_type[8:0]   ) |
          ({9{daccess_prot_sel}}       &  9'h06c            ) ;
      
assign  lsu_tlu_ttype_vld_m2 =  dmmu_miss_g | daccess_excptn | daccess_prot |
        priv_action | early_trap_vld_g  | 
	      va_wtchpt_match ;

assign lsu_ttype_vld_m2 = lsu_tlu_ttype_vld_m2 | defr_trp_taken ;  //to stb_rwctl

assign lsu_ttype_vld_m2_bf1 =    lsu_ttype_vld_m2; //to dctl, qctl1

wire	squash_priority_g ; // Bug 4678
assign	squash_priority_g = priv_action | early_trap_vld_g | va_wtchpt_match ;
   
assign  lsu_tlu_dmmu_miss_g = dmmu_miss_g & ~squash_priority_g ;
assign  lsu_tlu_priv_violtn_g = (priv_pg_usr_mode | as_if_usr_priv_pg) & tlb_tte_vld_g ; 
wire	dmmu_va_oor_g ;
assign  lsu_tlu_daccess_excptn_g = 
(daccess_excptn | dmmu_va_oor_g  // Bug 5036
| tlu_priv_trap_g) & ~squash_priority_g ;

// prioritize daccess_excptn higher than daccess_prot. This may
// be a critical path which needs to be resolved -> qual. now
// in mmu.
//assign  lsu_tlu_daccess_prot_g = daccess_prot ;
   wire daccess_prot_g;
assign  daccess_prot_g = daccess_prot & 
	~(tlu_priv_trap_g | daccess_excptn | squash_priority_g) ;   
assign  lsu_tlu_daccess_prot_g = daccess_prot & ~squash_priority_g ; // Bug 5336.
assign  lsu_tlu_priv_action_g = priv_action ; 
//assign  lsu_tlu_tte_ebit_g = tlb_rd_tte_data_ebit & tlb_tte_vld_g ;
wire	lsu_tlu_tte_ebit_g;
assign  lsu_tlu_tte_ebit_g = pg_with_ebit ;
//assign  lsu_tlu_spec_access_epage_g = spec_access_epage & tlb_tte_vld_g ; // page with side effects
wire	lsu_tlu_spec_access_epage_g ;
assign  lsu_tlu_spec_access_epage_g = spec_access_epage ; // page with side effects
wire	lsu_tlu_uncache_atomic_g;
assign  lsu_tlu_uncache_atomic_g = 
	(atm_access_w_nc & tlb_tte_vld_g) |
	(atm_access_w_nc_byp_g) ;
// Define illegal asi actions
// see sfsr description - excludes cases where 02 and 04 are set for ftype !!!
wire lsu_tlu_flt_ld_nfo_pg_g;
assign  lsu_tlu_flt_ld_nfo_pg_g = nfo_pg_nonnfo_asi & tlb_tte_vld_g ; 

wire illgl_asi_action_pre_m,illgl_asi_action_pre_g ;
assign	illgl_asi_action_pre_m = asi_related_trap_m | tlb_daccess_excptn_m | illegal_asi_trap_m | spv_use_hpv_m ; // bug 4181; //bug3660	

dff_s  illglasi_g (
        .din    (illgl_asi_action_pre_m),
        .q      (illgl_asi_action_pre_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire lsu_tlu_illegal_asi_action_g;
assign  lsu_tlu_illegal_asi_action_g = 
atm_access_unsup_asi | (illgl_asi_action_pre_g) & // Bug 4825
~(lsu_tlu_spec_access_epage_g | lsu_tlu_uncache_atomic_g) ;
//(illgl_asi_action_pre_g | (atm_access_unsup_asi)) & 
//~(lsu_tlu_spec_access_epage_g | lsu_tlu_uncache_atomic_g) ;

//=========================================================================================
//  Generate Flush Pipe
//=========================================================================================


assign	other_flush_pipe_w = 
tlu_early_flush_pipe_w | (lsu_tlu_ttype_vld_m2 & lsu_inst_vld_w) |
defr_trp_taken ;	// deferred trap.
assign	lsu_ifu_flush_pipe_w = other_flush_pipe_w ;
assign	lsu_exu_flush_pipe_w = other_flush_pipe_w ;
assign	lsu_mmu_flush_pipe_w = other_flush_pipe_w ;
assign	lsu_ffu_flush_pipe_w = other_flush_pipe_w ;


assign	lsu_flush_pipe_w = other_flush_pipe_w | ifu_lsu_flush_w ;

//assign 	lsu_qctl1_flush_pipe_w = lsu_flush_pipe_w ;
//assign 	lsu_stbctl_flush_pipe_w = lsu_flush_pipe_w ;
//assign 	lsu_stbrwctl_flush_pipe_w = lsu_flush_pipe_w ;

//=========================================================================================
//  Early Traps to SPU
//=========================================================================================

// detect st to ma/strm sync - data-access exception.
//wire	st_to_sync_dexcp_m ;
// qual with alt_space not required - spu will do it.
//assign	st_to_sync_dexcp_m = // Bug 5704
//strm_asi_m & ((lsu_ldst_va_m[7:0] == 8'ha0) | (lsu_ldst_va_m[7:0] == 8'h68)) & st_inst_vld_m ;  

wire	early_flush_m ;

assign  early_flush_m =
        (atomic_m & lsu_alt_space_m) |  // Bug 4650 - alt-space atomics should flush.
        priv_action_m           |
        early_trap_vld_m        |       // mem-addr-not-aligned.
        illegal_asi_trap_m      |       // for fp non use of internal asi.
        //st_to_sync_dexcp_m    |       // Bug 5742
        //wr_to_strm_sync_m     |       // Bug 5890 - redundant - make room.
        defr_trp_taken_m_din    |       // Bug 5890
        daccess_excptn_early_m  ;
        /*asi_related_trap_m    |       // Bug 2592
        spv_use_hpv_m       |
        wr_to_strm_sync_m;*/


dff_s  eflushspu_g (
        .din    (early_flush_m),
        .q      (lsu_spu_early_flush_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  eflushspu2_g (
        .din    (early_flush_m),
        .q      (lsu_local_early_flush_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  eflushtlu_g (
        .din    (early_flush_m),
        .q      (lsu_tlu_early_flush_w),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  eflushtlu2_g (
        .din    (early_flush_m),
        .q      (lsu_tlu_early_flush2_w),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   

//=========================================================================================
//  Parity Error Checking
//=========================================================================================

// DTLB Parity Errors. 
// ASI read of Tag/Data :
//  - uncorrectible error
//  - logging occurs on read.
//  - precise trap is taken when ldxa completes if nceen set.
//  - if not set then ldxa is allowed to complete.
// CAM Read of Tag/Data :
//  - correctible if locked bit not set.
//    - takes disrupting trap later.
//  - uncorrectible if locked bit set.
//  - both are treated as precise traps.
//  - if errors not enabled, then load completes as if hit in L1.
// ** TLB error will cause a trap which will preclude concurrent dcache,dtag  **
// ** parity errors.                **

// cam related tte data parity error - error assumed correctible if locked
// bit is not set. Will cause a dmmu_miss for correction.
// qualify with cam_hit ??
wire  tte_data_perror_unc ;

assign	lsu_tlb_perr_ld_rq_kill_w =
	//tte_data_perror_corr | (tte_data_perror_unc & nceen_pipe_g) ;
	(tte_data_perror_unc & nceen_pipe_g) ;

// correctible dtlb errors no longer supported.
/*assign  tte_data_perror_corr = 
  tte_data_parity_error & ~tlb_rd_tte_data_locked & tlb_tte_vld_g & 
  (ld_inst_vld_unflushed | st_inst_vld_unflushed) & lsu_inst_vld_w ;*/

// caused for both locked and unlocked entries.
assign  tte_data_perror_unc  = 
  //tte_data_parity_error &  tlb_rd_tte_data_locked & tlb_tte_vld_g & 
  tte_data_parity_error &  tlb_tte_vld_g & 
  (ld_inst_vld_unflushed | st_inst_vld_unflushed) & lsu_inst_vld_w &
  ~lsu_flush_pipe_w ;

// Asi rd parity error detection
wire  asi_tte_data_perror,asi_tte_tag_perror ;

assign  asi_tte_data_perror =
  tte_data_parity_error & data_rd_vld_g ;
// For data tte read, both tag and data arrays are read.
// Parity error on asi read of tag should not be reported.
assign  asi_tte_tag_perror =
  tte_tag_parity_error & tag_rd_vld_g & ~data_rd_vld_g ;

wire	st_dtlb_perror ;
assign	st_dtlb_perror =   tte_data_parity_error &  tlb_tte_vld_g & 
   st_inst_vld_unflushed & lsu_inst_vld_w ;
 // ~lsu_flush_pipe_w ;

wire	cancel_err_flush ;
assign	cancel_err_flush = // Bug 5165
((priv_pg_usr_mode | nfo_pg_nonnfo_asi |
atm_access_w_nc) & tlb_tte_vld_g) | // bug6052/eco6620
spec_access_epage | 
nonwr_pg_st_access ;

// Bug 6877
wire squash_err ;
assign squash_err = 
// assume always higher priority. BE - share common terms elsewhere.
tlu_early_flush_pipe_w | defr_trp_taken | ifu_lsu_flush_w |
// isolate to daccess_excptn/daccess_prot as per Bug 5165.
(lsu_tlu_ttype_vld_m2 & ~(daccess_excptn_sel | daccess_prot_sel)) | 
((daccess_excptn_sel | daccess_prot_sel) & ~cancel_err_flush) ;
   
wire	tlb_data_su_g ;
assign	tlb_data_su_g =   st_dtlb_perror & ~atomic_g &
  ~squash_err ;
  //~(lsu_flush_pipe_w & ~cancel_err_flush) ; // Bug 6877
   
wire	ld_dtlb_perror ;
assign	ld_dtlb_perror =   tte_data_parity_error &  tlb_tte_vld_g & 
  ld_inst_vld_unflushed  & lsu_inst_vld_w &
  ~squash_err ;
   
wire  tlb_data_ue_g ;
assign  tlb_data_ue_g = 
	ld_dtlb_perror |	// synchronous to pipe - xslate ; ue is for ld now.
	lsu_tlb_asi_data_perr_g ; // asychronous to pipe - asi rd

/* Simplify for Bug 5888.
wire	st_noatom_dtlb_perr ; // atomics not represented.
assign	st_noatom_dtlb_perr = st_dtlb_perror & ~lsu_flush_pipe_w & ~atomic_g ;
wire	st_noatom_dtlb_perr_en ; 
assign	st_noatom_dtlb_perr_en = st_noatom_dtlb_perr & nceen_pipe_g ; */
wire	st_noatom_dtlb_perr_en ; 
wire	st_dtlb_perr_en ;
assign	st_noatom_dtlb_perr_en = st_dtlb_perr_en & ~atomic_g ;

// rm corr err. reporting
dff_s  #(3) terr_stgd1 (
        .din    ({tlb_data_su_g,tlb_data_ue_g,lsu_tlb_asi_tag_perr_g}),
        //.din    ({st_noatom_dtlb_perr,tlb_data_ue_g,lsu_tlb_asi_tag_perr_g}),
        .q      ({lsu_ifu_tlb_data_su,lsu_ifu_tlb_data_ue,lsu_ifu_tlb_tag_ue}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// If st dtlb parity error detected, then need to invalidate st in stb.
// Considered unrecoverable for the thread itself.

assign	st_dtlb_perr_en = st_dtlb_perror & ~lsu_flush_pipe_w & nceen_pipe_g ;

// Kill will happen for atomics also.
//assign	lsu_exu_st_dtlb_perr_g = st_dtlb_perr_en ;
assign	lsu_exu_st_dtlb_perr_g = st_noatom_dtlb_perr_en ; // Bug 5888

assign	lsu_ffu_st_dtlb_perr_g = st_noatom_dtlb_perr_en ; // Bug 5910/ECO 6529
   
assign	lsu_st_dtlb_perr_g[0] = st_dtlb_perr_en & thread0_g ;
assign	lsu_st_dtlb_perr_g[1] = st_dtlb_perr_en & thread1_g ;
assign	lsu_st_dtlb_perr_g[2] = st_dtlb_perr_en & thread2_g ;
assign	lsu_st_dtlb_perr_g[3] = st_dtlb_perr_en & thread3_g ;

//==========================================================================
// DEFERRED TRAP DUE TO STORE 
//==========================================================================

// Cases :
// defr_trp_m=1,ifu_flush_w=0. 
//	- defr_trp is generated.
//	- next inst will not take redundant deferred trap as
//	its inst_vld will be annulled by trap flush.
// defr_trp_m=1,ifu_flush_w=1. 
//	- defr_trp is generated. TLU annuls.
//	- Other units see redundant defr_trp flush ORed with ifu_flush_w.
//	- next inst will not take redundant deferred trap as
//	its inst_vld will be annulled by ifu_flush_w .


// Log Deferred trap. Take on next available inst from thread.
// Inst vld must be qualified with flush.

wire    st_defr_trp_en0,st_defr_trp_en1,st_defr_trp_en2,st_defr_trp_en3 ;
wire    st_defr_trp0,st_defr_trp1,st_defr_trp2,st_defr_trp3 ;

assign  st_defr_trp_en0 = st_noatom_dtlb_perr_en & thread0_g ;
assign  st_defr_trp_en1 = st_noatom_dtlb_perr_en & thread1_g ;
assign  st_defr_trp_en2 = st_noatom_dtlb_perr_en & thread2_g ;
assign  st_defr_trp_en3 = st_noatom_dtlb_perr_en & thread3_g ;

wire    stpend_rst0_m,stpend_rst1_m,stpend_rst2_m,stpend_rst3_m;
wire    stpend_rst0_w,stpend_rst1_w,stpend_rst2_w,stpend_rst3_w;
wire    stpend_rst0,stpend_rst1,stpend_rst2,stpend_rst3;
assign  stpend_rst0_m = reset | 
((st_defr_trp0 | st_defr_trp_en0) & thread0_m & flush_w_inst_vld_m);
assign  stpend_rst1_m = reset | 
((st_defr_trp1 | st_defr_trp_en1) & thread1_m & flush_w_inst_vld_m);
assign  stpend_rst2_m = reset | 
((st_defr_trp2 | st_defr_trp_en2) & thread2_m & flush_w_inst_vld_m);
assign  stpend_rst3_m = reset | 
((st_defr_trp3 | st_defr_trp_en3) & thread3_m & flush_w_inst_vld_m);

// Postphone reset by a cycle - 4916
dff_s #(4)  stpend_d1 (
           .din    ({stpend_rst3_m,stpend_rst2_m,stpend_rst1_m,stpend_rst0_m}),
           .q      ({stpend_rst3_w,stpend_rst2_w,stpend_rst1_w,stpend_rst0_w}),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

// Prevent reset if inst is flushed by ifu.
assign	stpend_rst3 = stpend_rst3_w & ~ifu_lsu_flush_w ;
assign	stpend_rst2 = stpend_rst2_w & ~ifu_lsu_flush_w ;
assign	stpend_rst1 = stpend_rst1_w & ~ifu_lsu_flush_w ;
assign	stpend_rst0 = stpend_rst0_w & ~ifu_lsu_flush_w ;

dffre_s #(1)  deftrp_t0 (
           .din    (st_defr_trp_en0),
           .q      (st_defr_trp0),
           .rst    (stpend_rst0),
           .en     (st_defr_trp_en0),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

dffre_s #(1)  deftrp_t1 (
           .din    (st_defr_trp_en1),
           .q      (st_defr_trp1),
           .rst    (stpend_rst1),
           .en     (st_defr_trp_en1),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

dffre_s #(1)  deftrp_t2 (
           .din    (st_defr_trp_en2),
           .q      (st_defr_trp2),
           .rst    (stpend_rst2),
           .en     (st_defr_trp_en2),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

dffre_s #(1)  deftrp_t3 (
           .din    (st_defr_trp_en3),
           .q      (st_defr_trp3),
           .rst    (stpend_rst3),
           .en     (st_defr_trp_en3),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

// Deferred trap can be taken on any instruction.
// Selection is based on next thread available.

//instruction n+2, and the following...

assign  defr_trp_taken_m =
        //ifu_tlu_inst_vld_m & (
        flush_w_inst_vld_m & ( 	// <= rely of flush by defr-trp to clear
				// pended defr-trp
        (st_defr_trp0 & thread0_m) |
        (st_defr_trp1 & thread1_m) |
        (st_defr_trp2 & thread2_m) |
        (st_defr_trp3 & thread3_m)) ;

assign defr_trp_taken_byp = 
        //ifu_tlu_inst_vld_m & (
        flush_w_inst_vld_m & (
        (st_defr_trp_en0 & thread0_m) |
        (st_defr_trp_en1 & thread1_m) |
        (st_defr_trp_en2 & thread2_m) |
        (st_defr_trp_en3 & thread3_m) );
 
 
assign defr_trp_taken_m_din = defr_trp_taken_m |  defr_trp_taken_byp;
 
dff_s #(1) defr_trp_taken_stgg (
     .din (defr_trp_taken_m_din),
     .q   (defr_trp_taken),
     .clk    (clk),
     .se     (se),       .si (),          .so ()
    );
  
assign	lsu_defr_trp_taken_g = defr_trp_taken ;
assign	lsu_tlu_defr_trp_taken_g = defr_trp_taken ;
assign	lsu_mmu_defr_trp_taken_g = defr_trp_taken ;

//==========================================================================
// DSFSR/SFAR WR 
//==========================================================================



wire	[3:0]	pstate_cle,pstate_am ;
// flop'n use to prevent timing path.
dff_s #(8)  cle_stg (
        .din    ({tlu_lsu_pstate_cle[3:0],tlu_lsu_pstate_am[3:0]}),
        .q      ({pstate_cle[3:0],pstate_am[3:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	pstate_cle_m ;
assign  pstate_cle_m = 
        (thread0_m & pstate_cle[0]) |
        (thread1_m & pstate_cle[1]) |
        (thread2_m & pstate_cle[2]) |
        (thread3_m & pstate_cle[3]);

wire	[3:0]	dsfsr_asi_sel_m ;
wire	prim_asi_sel ;
assign	prim_asi_sel = 
exu_tlu_misalign_addr_jmpl_rtn_m | (lsu_tlu_nonalt_ldst_m & ~lsu_nonalt_nucl_access_m) ;
assign  dsfsr_asi_sel_m[0] =  // ASI_PRIMARY
		 prim_asi_sel & ~pstate_cle_m;
// Does asi_primary_little make sense for jmpl/return ?
assign  dsfsr_asi_sel_m[1] =  // ASI_PRIMARY_LITTLE
        	prim_asi_sel  &  pstate_cle_m;
assign  dsfsr_asi_sel_m[2] =  // ASI_NUCLEUS
        	lsu_nonalt_nucl_access_m &  ~pstate_cle_m;
assign  dsfsr_asi_sel_m[3] =  // ASI_NUCLEUS_LITTLE
        	lsu_nonalt_nucl_access_m &   pstate_cle_m;
/*assign  dsfsr_asi_sel_m[4] =  // assigned asi
        ~(exu_tlu_misalign_addr_jmpl_rtn_m | lsu_tlu_nonalt_ldst_m);*/

wire	[7:0]	asi_state_g ;
// flop'n use to prevent timing path.
dff_s #(8)  asistate_stgg (
        .din    (lsu_excpctl_asi_state_m[7:0]),
        .q      (asi_state_g[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	[7:0]	dsfsr_asi_g ;
wire	[3:0]	dsfsr_asi_sel_g ;

/*assign dsfsr_asi_g[7:0] =(dsfsr_asi_sel_g[0] ? 8'h80 : 8'h00) |
                         (dsfsr_asi_sel_g[1] ? 8'h88 : 8'h00) |
                         (dsfsr_asi_sel_g[2] ? asi_state_g[7:0] : 8'h00);*/
// Bug 4212 - spec problem
assign dsfsr_asi_g[7:0] =(dsfsr_asi_sel_g[0] ? 8'h80 :
                         	(dsfsr_asi_sel_g[1] ? 8'h88 : 
                         		(dsfsr_asi_sel_g[2] ? 8'h04 :
                         			(dsfsr_asi_sel_g[3] ?  8'h0C : asi_state_g[7:0]))));
 
assign  pstate_am_m = 
        (thread0_m & pstate_am[0]) |
        (thread1_m & pstate_am[1]) |
        (thread2_m & pstate_am[2]) |
        (thread3_m & pstate_am[3]);

assign  dmmu_va_oor_m = exu_tlu_va_oor_m & ~pstate_am_m & lsu_memref_m & ~lsu_squash_va_oor_m;

wire	[3:0]     dsfsr_flt_vld;
dff_s #(4)  fltvld_stgd1 (
        .din    (tlu_dsfsr_flt_vld[3:0]),
        .q      (dsfsr_flt_vld[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	dsfsr_flt_vld_m ;
assign  dsfsr_flt_vld_m = 
        (thread0_m & dsfsr_flt_vld[0]) |
        (thread1_m & dsfsr_flt_vld[1]) |
        (thread2_m & dsfsr_flt_vld[2]) |
        (thread3_m & dsfsr_flt_vld[3]);

wire	ldst_xslate_g,flsh_inst_g,dsfsr_flt_vld_g,dsfsr_wr_op_g ;
wire	misalign_addr_jmpl_rtn_g,misalign_addr_ldst_atm_g ;
wire	[2:0]	dsfsr_ctxt_sel ;

// flop flt_vld and use
dff_s #(14)  dsfsr_stgg (
        .din    ({dsfsr_asi_sel_m[3:0],dmmu_va_oor_m,// memref_m,
                lsu_tlu_xslating_ldst_m,lsu_flsh_inst_m,lsu_tlu_ctxt_sel_m[2:0],
                dsfsr_flt_vld_m,lsu_tlu_write_op_m,exu_tlu_misalign_addr_jmpl_rtn_m,
                lsu_tlu_misalign_addr_ldst_atm_m}),
        .q      ({dsfsr_asi_sel_g[3:0],dmmu_va_oor_g,ldst_xslate_g,// memref_g,
                flsh_inst_g,dsfsr_ctxt_sel[2:0],dsfsr_flt_vld_g, dsfsr_wr_op_g,
                misalign_addr_jmpl_rtn_g,misalign_addr_ldst_atm_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// To be set only for data_access_exception traps - only one can be
// reported at any time.        

wire	[6:0]	dsfsr_ftype_g ;
assign  dsfsr_ftype_g[6] = 1'b0;
assign  dsfsr_ftype_g[5] = dmmu_va_oor_g | lsu_tlu_wtchpt_trp_g;
assign  dsfsr_ftype_g[4] = lsu_tlu_flt_ld_nfo_pg_g;
assign  dsfsr_ftype_g[3] = lsu_tlu_illegal_asi_action_g 
			| tlu_priv_trap_g ; // Bug 4799
//assign  dsfsr_ftype_g[3] = lsu_tlu_illegal_asi_action_g | tlu_mmu_sync_data_excp_g;
assign  dsfsr_ftype_g[2] = (lsu_tlu_uncache_atomic_g & ~atm_access_unsup_asi);
assign  dsfsr_ftype_g[1] = lsu_tlu_spec_access_epage_g;
assign  dsfsr_ftype_g[0] = lsu_tlu_priv_violtn_g;

wire	dsfsr_side_effect_g ;
assign  dsfsr_side_effect_g = lsu_tlu_tte_ebit_g & (ldst_xslate_g | flsh_inst_g);

// Fault Type based on Priority Encoding of Traps
wire	[6:0]	dsfsr_pe_ftype_g ;
wire	dsfsr_ftype_zero ;
// Is this needed ? Doesn't it default to zero ?
assign  dsfsr_pe_ftype_g[6:0] = dsfsr_ftype_zero ? 7'h00 : dsfsr_ftype_g[6:0]; 

// set to 11 when the access does not have a translating asi.
wire	[1:0]	dsfsr_ctxt_g ;
assign  dsfsr_ctxt_g[1:0] =
        dsfsr_ctxt_sel[0] ? 2'b00 :     
                dsfsr_ctxt_sel[1] ? 2'b01 :     
                        dsfsr_ctxt_sel[2] ? 2'b10 : 2'b11;      


assign  lsu_dsfsr_din_g[23:0] =
        {dsfsr_asi_g[7:0],
        2'b0,
        dsfsr_pe_ftype_g[6:0],
        dsfsr_side_effect_g,
        dsfsr_ctxt_g[1:0],
	1'b0, // Bug 3323 - Arch change
        //pstate_priv,  
        dsfsr_wr_op_g,  // pipe
        dsfsr_flt_vld_g,
        1'b1};

// This is going to be a critical path !!!
// Assume that traps in front-end cause instructions to be no`oped
// further down the pipeline. Thus there is no need to qualify writes
// to dsfsr with writes to isfsr
wire	dsfsr_trp_wr_g ;
wire	dsfsr_trp_wr_pre_m,dsfsr_trp_wr_pre_g ;


assign	dsfsr_trp_wr_pre_m =
	spv_use_hpv_m	| // Bug 3254 ; add new data-access-excp
	// spec_access_epage_m | // Bug 3515
	priv_action_m | 
	exu_tlu_misalign_addr_jmpl_rtn_m |
	lsu_tlu_misalign_addr_ldst_atm_m ;

dff_s   dsfsrtrg_stgg (
        .din    (dsfsr_trp_wr_pre_m),
        .q      (dsfsr_trp_wr_pre_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  dsfsr_trp_wr_g = 
        ((lsu_tlu_priv_violtn_g  | 
	lsu_tlu_spec_access_epage_g |	// Bug 3515 - uncomment out.
        lsu_tlu_uncache_atomic_g | lsu_tlu_illegal_asi_action_g |
        lsu_tlu_flt_ld_nfo_pg_g  | dmmu_va_oor_g) |     // data access exceptions                       
        daccess_prot |	// daccess_excptn not excluded.
        lsu_tlu_wtchpt_trp_g     |      // watchpoint trap      
	dsfsr_trp_wr_pre_g |
	tlu_priv_trap_g 		// scratchpad/queue daccess;Bug 4799
        ) &
        lsu_inst_vld_w & ~(ifu_lsu_flush_w | defr_trp_taken) ; // Bug 4444,5196

assign  dsfsr_ftype_zero = 
        daccess_prot_g | lsu_tlu_priv_action_g | lsu_tlu_wtchpt_trp_g |
        misalign_addr_jmpl_rtn_g | misalign_addr_ldst_atm_g;

// terms below can be made common. (grape)
assign  lsu_dmmu_sfsr_trp_wr[0] = dsfsr_trp_wr_g & thread0_g;
assign  lsu_dmmu_sfsr_trp_wr[1] = dsfsr_trp_wr_g & thread1_g;
assign  lsu_dmmu_sfsr_trp_wr[2] = dsfsr_trp_wr_g & thread2_g;
assign  lsu_dmmu_sfsr_trp_wr[3] = dsfsr_trp_wr_g & thread3_g; 

//==========================================================================
// Exception Handling End
//==========================================================================

endmodule // lsu_dctl1

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_dctldp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications





module lsu_dctldp (/*AUTOARG*/
   // Outputs
   so, asi_d, lsu_excpctl_asi_state_m, lsu_dctl_asi_state_m, 
   lsu_spu_asi_state_e, lsu_tlu_rsr_data_e, lsu_asi_state, 
   lsu_asi_reg0, lsu_asi_reg1, lsu_asi_reg2, lsu_asi_reg3, 
   lsu_t0_pctxt_state, lsu_t1_pctxt_state, lsu_t2_pctxt_state, 
   lsu_t3_pctxt_state, lsu_tlu_dside_ctxt_m, lsu_tlu_pctxt_m, 
   tlb_ctxt, lsu_pid_state0, lsu_pid_state1, lsu_pid_state2, 
   lsu_pid_state3, lsu_dtlb_cam_pid_e, bist_ctl_reg_in, 
   lsu_ifu_direct_map_l1, dc_direct_map, lsu_iobrdge_rd_data, 
   lsu_ictag_mrgn, lsu_dctag_mrgn, lsu_mamem_mrgn, lsu_dtlb_mrgn, 
   lsu_itlb_mrgn, lsu_local_ldxa_data_g, lsu_ldst_va_m, 
   lsu_ldst_va_m_buf, lsu_tlu_ldst_va_m, lsu_tlu_tlb_asi_state_m, 
   lsu_ifu_asi_state, lsu_tlu_tlb_ldst_va_m, lsu_tlu_tlb_dmp_va_m, 
   lsu_ifu_asi_addr, lsu_diagnstc_wr_addr_e, 
   lsu_diagnstc_dc_prty_invrt_e, lsu_ifu_err_addr, 
   va_wtchpt_msk_match_m, lsu_ldst_va_g, lsu_dp_ctl_reg0, 
   lsu_dp_ctl_reg1, lsu_dp_ctl_reg2, lsu_dp_ctl_reg3, 
   lsu_diagnstc_wr_way_e, lsu_diag_va_prty_invrt, 
   // Inputs
   rclk, rst_l, si, se, async_tlb_index, lsu_dtlb_dmp_vld_e, 
   tlu_lsu_asi_m, exu_tlu_wsr_data_m, tlu_lsu_asi_update_g, 
   asi_state_wr_thrd, ifu_lsu_imm_asi_d, thread0_d, thread1_d, 
   thread2_d, thread3_d, ifu_lsu_imm_asi_vld_d, lsu_err_addr_sel, 
   pctxt_state_wr_thrd, sctxt_state_wr_thrd, st_rs3_data_g, 
   thread0_ctxt, thread1_ctxt, thread2_ctxt, thread3_ctxt, 
   thread_pctxt, thread_sctxt, thread_actxt, thread_default, 
   tlu_dtlb_tte_tag_w2, tlu_dtlb_tte_tag_b58t56, thread0_g, 
   thread1_g, thread2_g, thread3_g, pid_state_wr_en, thread0_e, 
   thread1_e, thread2_e, thread3_e, thread0_m, thread1_m, thread2_m, 
   thread3_m, lsu_iobrdge_wr_data, dfture_tap_wr_mx_sel, lctl_rst, 
   lsu_ctl_state_wr_en, lsuctl_ctlbits_wr_en, dfture_tap_rd_en, 
   bist_tap_wr_en, bist_ctl_reg_out, mrgn_tap_wr_en, ldiagctl_wr_en, 
   misc_ctl_sel_din, lsu_asi_sel_fmx1, lsu_asi_sel_fmx2, 
   exu_lsu_ldst_va_e, tlb_access_en0_g, tlb_access_en1_g, 
   tlb_access_en2_g, tlb_access_en3_g, tlb_access_sel_thrd0, 
   tlb_access_sel_thrd1, tlb_access_sel_thrd2, 
   tlb_access_sel_default, mrgnctl_wr_en, lsu_dcfill_addr_e, 
   lsu_error_pa_m, stb_ldst_byte_msk, lsu_diagnstc_va_sel, 
   rst_tri_en,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data
   );

   input rclk;
   input rst_l;
   input si;
   input se;
//   input tmb_l ;

   output so;

//   input	async_error_sel ;
   input [5:0]	async_tlb_index ;

   input	lsu_dtlb_dmp_vld_e ;
   
   input [7:0] tlu_lsu_asi_m;
   input [7:0] exu_tlu_wsr_data_m;
   input       tlu_lsu_asi_update_g;
   input [3:0] asi_state_wr_thrd;
   input [7:0] ifu_lsu_imm_asi_d;
   input       thread0_d;
   input       thread1_d;
   input       thread2_d;
   input       thread3_d;
   input       ifu_lsu_imm_asi_vld_d;

   input [2:0]	lsu_err_addr_sel ;
   
   output [7:0] asi_d;
   output [7:0] lsu_excpctl_asi_state_m;
   output [7:0] lsu_dctl_asi_state_m;
     
   output [7:0] lsu_spu_asi_state_e;
   output [7:0] lsu_tlu_rsr_data_e;

   output  [7:0]   lsu_asi_state ;   // ASI State + imm asi
   output  [7:0]   lsu_asi_reg0 ;    // ASI State Register.
   output  [7:0]   lsu_asi_reg1 ;    // ASI State Register.
   output  [7:0]   lsu_asi_reg2 ;    // ASI State Register.
   output  [7:0]   lsu_asi_reg3 ;    // ASI State Register.

input  [3:0] pctxt_state_wr_thrd ;
input  [3:0] sctxt_state_wr_thrd ;   
//input [63:0] st_rs3_data_g;
//input [59:56] st_rs3_data_g_59_56;
//input [51:48] st_rs3_data_g_51_48;
//input [43:40] st_rs3_data_g_43_40;
input [32:0]  st_rs3_data_g;

   input     thread0_ctxt;  //should be one hot, force default
   input     thread1_ctxt;
   input     thread2_ctxt;
   input     thread3_ctxt;

   input     thread_pctxt;
   input     thread_sctxt;
//   input     thread_nctxt;	
   input     thread_actxt;
   input     thread_default;
   
input [12:0]  tlu_dtlb_tte_tag_w2 ;
input [2:0]	tlu_dtlb_tte_tag_b58t56 ;

   input       thread0_g;
   input       thread1_g;
   input       thread2_g;
   input       thread3_g;
 
output  [12:0]    lsu_t0_pctxt_state ;  // primary ctxt - thread0
output  [12:0]    lsu_t1_pctxt_state ;  // primary ctxt - thread1
output  [12:0]    lsu_t2_pctxt_state ;  // primary ctxt - thread2
output  [12:0]    lsu_t3_pctxt_state ;  // primary ctxt - thread3

output  [12:0]    lsu_tlu_dside_ctxt_m ;
output  [12:0]    lsu_tlu_pctxt_m ;
output  [12:0]    tlb_ctxt ;    // ctxt for xslate or demap.

   input [3:0]    pid_state_wr_en;
   input          thread0_e;
   input          thread1_e;
   input          thread2_e;
   input          thread3_e;

   input          thread0_m;
   input          thread1_m;
   input          thread2_m;
   input          thread3_m;
   
output	[2:0]	lsu_pid_state0 ;	// pid thread0 ; global use
output	[2:0]	lsu_pid_state1 ;	// pid thread1 ; global use
output	[2:0]	lsu_pid_state2 ;	// pid thread2 ; global use
output	[2:0]	lsu_pid_state3 ;	// pid thread3 ; global use
output	[2:0] lsu_dtlb_cam_pid_e ;

input [27:0]  lsu_iobrdge_wr_data ;
   input      dfture_tap_wr_mx_sel;
   input [3:0] lctl_rst;
   input [3:0] lsu_ctl_state_wr_en;
   input [3:0] lsuctl_ctlbits_wr_en;
   input [3:0] dfture_tap_rd_en;

   input      bist_tap_wr_en;
//  input      bistctl_wr_en;
   output [6:0] bist_ctl_reg_in;
   
   input [(6 + 4):0] bist_ctl_reg_out;
   
   input      mrgn_tap_wr_en;

   output		lsu_ifu_direct_map_l1 ;	// l1 icache set to direct map.
   output   dc_direct_map;
   input    ldiagctl_wr_en;

   output [43:0] lsu_iobrdge_rd_data ;

   input [3:0]  misc_ctl_sel_din ;  //should force default

output	[3:0]	lsu_ictag_mrgn ;	// icache tag self-timed margin control
output	[4-1:0]	lsu_dctag_mrgn ;	// dcache tag self-timed margin control

output	[3:0]	lsu_mamem_mrgn ;	// mamem self-timed margin control
output	[7:0]	lsu_dtlb_mrgn ;	  // dtlb self-timed margin control
output	[7:0]	lsu_itlb_mrgn ;	  // itlb self-timed margin control

output  [47:0]    lsu_local_ldxa_data_g ;  // local ldxa data

//   input          misc_asi_rd_en;
//input [47:3]  lsu_va_wtchpt_addr ;
   input [2:0] lsu_asi_sel_fmx1;
   input [2:0] lsu_asi_sel_fmx2;

input  [47:0]  exu_lsu_ldst_va_e;      // sub VA for mem-ref (src-execute)

output [12:0]  lsu_ldst_va_m;  
output [47:0]  lsu_ldst_va_m_buf;  
output [9:0]  lsu_tlu_ldst_va_m;  

   input       tlb_access_en0_g;
   input       tlb_access_en1_g;
   input       tlb_access_en2_g;
   input       tlb_access_en3_g;

output  [7:0]   lsu_tlu_tlb_asi_state_m ;
output  [7:0]   lsu_ifu_asi_state;  

   input tlb_access_sel_thrd0;
   input tlb_access_sel_thrd1;
   input tlb_access_sel_thrd2;
   input tlb_access_sel_default;

output  [(6 + 4):0]   lsu_tlu_tlb_ldst_va_m ;
output  [47:13]         lsu_tlu_tlb_dmp_va_m ;
output  [17:0]    lsu_ifu_asi_addr ;

   output [(6 + 4):0]  lsu_diagnstc_wr_addr_e ;
   output [7:0]   lsu_diagnstc_dc_prty_invrt_e ;

///  output [13:11] lsu_lngltncy_ldst_va;
   
   input mrgnctl_wr_en;
input [(6 + 4):4]  lsu_dcfill_addr_e ;         // data cache fill addr
input [28:0]  lsu_error_pa_m ;            // error phy addr
//   input      sync_error_sel;
   output  [47:4]    lsu_ifu_err_addr ;    // error address

input [7:0]   stb_ldst_byte_msk ;
   output va_wtchpt_msk_match_m;

   output [7:0]  lsu_ldst_va_g;

   output [5:0] lsu_dp_ctl_reg0;
   output [5:0] lsu_dp_ctl_reg1;
   output [5:0] lsu_dp_ctl_reg2;
   output [5:0] lsu_dp_ctl_reg3;

   input   [3:0] lsu_diagnstc_va_sel ;
   output  [2-1:0] lsu_diagnstc_wr_way_e ;
   output	 lsu_diag_va_prty_invrt ;
   input   rst_tri_en;

// trin
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

   
wire  [12:0]  pctxt_state;
wire  [12:0]  sctxt_state;
wire  [2:0]   pid_state;

reg   [13:0] lsu_ctl_reg0;
reg   [13:0] lsu_ctl_reg1;
reg   [13:0] lsu_ctl_reg2;
reg   [13:0] lsu_ctl_reg3;

wire   [13:0] lsu_ctl_reg;
   
   wire       clk;
   assign     clk = rclk;

/********************* ASI state ***********************/   
   wire [7:0]  tlu_lsu_asi_g;
   
dff_s #(8) asi_stgw (
        .din    (tlu_lsu_asi_m[7:0]),
        .q      (tlu_lsu_asi_g[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
   wire [7:0]  exu_tlu_wsr_data_w;
   
dff_s #(8) ff_wsr_data_w (
        .din    (exu_tlu_wsr_data_m[7:0]),
        .q      (exu_tlu_wsr_data_w[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire [7:0]  asi_wr_din;
   
assign  asi_wr_din[7:0] = tlu_lsu_asi_update_g ? tlu_lsu_asi_g[7:0] : exu_tlu_wsr_data_w[7:0] ;   

// ASI - Thread0
   wire [7:0] asi_state0;
   wire [7:0] lsu_asi_reg0;

   wire       asi0_state_clk;
   


clken_buf asi0_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~asi_state_wr_thrd[0]),
                .tmb_l  (~se),
                .clk    (asi0_state_clk)
                ) ;

   








dff_s #(8) asi0_state_ff (
        .din    (asi_wr_din[7:0]),
        .q      (asi_state0[7:0]),
        .clk    (asi0_state_clk),
        .se     (se),       .si (),          .so ()
        );


assign  lsu_asi_reg0[7:0] = asi_state0[7:0] ; 

// ASI - Thread1
   wire [7:0] asi_state1;
   wire [7:0] lsu_asi_reg1;

   wire       asi1_state_clk;
   


clken_buf asi1_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~asi_state_wr_thrd[1]),
                .tmb_l  (~se),
                .clk    (asi1_state_clk)
                ) ;

   








dff_s #(8) asi1_state_ff (
        .din    (asi_wr_din[7:0]),
        .q      (asi_state1[7:0]),
        .clk    (asi1_state_clk),
        .se     (se),       .si (),          .so ()
        );

   
assign  lsu_asi_reg1[7:0] = asi_state1[7:0] ; 

// ASI - Thread2
   wire [7:0] asi_state2;
   wire [7:0] lsu_asi_reg2;

   wire       asi2_state_clk;
   


clken_buf asi2_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~asi_state_wr_thrd[2]),
                .tmb_l  (~se),
                .clk    (asi2_state_clk)
                ) ;

   








dff_s #(8) asi2_state_ff (
        .din    (asi_wr_din[7:0]),
        .q      (asi_state2[7:0]),
        .clk    (asi2_state_clk),
        .se     (se),       .si (),          .so ()
        );


assign  lsu_asi_reg2[7:0] = asi_state2[7:0] ; 

// ASI - Thread3
   wire [7:0] asi_state3;
   wire [7:0] lsu_asi_reg3;
   
   wire       asi3_state_clk;
   


clken_buf asi3_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~asi_state_wr_thrd[3]),
                .tmb_l  (~se),
                .clk    (asi3_state_clk)
                ) ;

   








dff_s #(8) asi3_state_ff (
        .din    (asi_wr_din[7:0]),
        .q      (asi_state3[7:0]),
        .clk    (asi3_state_clk),
        .se     (se),       .si (),          .so ()
        );


assign  lsu_asi_reg3[7:0] = asi_state3[7:0] ; 

   wire [7:0] asi_state;
   
mux4ds #(8) lsu_asi_mux_d (
   .in0 (asi_state0[7:0]),                        
   .in1 (asi_state1[7:0]),                        
   .in2 (asi_state2[7:0]),                        
   .in3 (asi_state3[7:0]),                        
   .sel0(thread0_d),
   .sel1(thread1_d),
   .sel2(thread2_d),
   .sel3(thread3_d),
   .dout(asi_state[7:0])                        
   );

assign  asi_d[7:0] = ifu_lsu_imm_asi_vld_d ? 
                     ifu_lsu_imm_asi_d[7:0] : asi_state[7:0];

wire  [7:0] asi_state_e, asi_state_m ;
   
dff_s #(8) asistate_stge (
        .din    (asi_d[7:0]),
        .q      (asi_state_e[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Make rsr_data independent of imm_asi.
dff_s #(8) rdasi_stge (
        .din    (asi_state[7:0]),
        .q      (lsu_tlu_rsr_data_e[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//assign lsu_tlu_rsr_data_e[7:0] =  asi_state_e[7:0] ;

assign  lsu_spu_asi_state_e[7:0] = asi_state_e[7:0] ;

dff_s #(8) asistate_stgm (
        .din    (asi_state_e[7:0]),
        .q      (asi_state_m[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  lsu_excpctl_asi_state_m[7:0] = asi_state_m[7:0] ;
assign  lsu_dctl_asi_state_m[7:0]    = asi_state_m[7:0] ;

   wire [7:0] lsu_asi_state;
dff_s #(8) asistate_stgg (
        .din    (asi_state_m[7:0]),
        .q      (lsu_asi_state[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


/*********************context************************/
wire  [12:0]  pctxt_state0,pctxt_state1;
wire  [12:0]  pctxt_state2,pctxt_state3;
wire  [12:0]  sctxt_state0,sctxt_state1;
wire  [12:0]  sctxt_state2,sctxt_state3;

// PRIMARY CONTEXT - Thread0
   wire       pctxt0_state_clk;



clken_buf pctxt0_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~pctxt_state_wr_thrd[0]),
                .tmb_l  (~se),
                .clk    (pctxt0_state_clk)
                ) ;

   








dff_s #(13) pctxt_state0_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (pctxt_state0[12:0]),
        .clk    (pctxt0_state_clk),
        .se     (se),       .si (),          .so ()
        );  


assign  lsu_t0_pctxt_state[12:0] = pctxt_state0[12:0] ;

// PRIMARY CONTEXT - Thread1
   wire       pctxt1_state_clk;



clken_buf pctxt1_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~pctxt_state_wr_thrd[1]),
                .tmb_l  (~se),
                .clk    (pctxt1_state_clk)
                ) ;

   








dff_s #(13) pctxt_state1_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (pctxt_state1[12:0]),
        .clk    (pctxt1_state_clk),
        .se     (se),       .si (),          .so ()
        );  


assign  lsu_t1_pctxt_state[12:0] = pctxt_state1[12:0] ;

// PRIMARY CONTEXT - Thread2
   wire       pctxt2_state_clk;



clken_buf pctxt2_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~pctxt_state_wr_thrd[2]),
                .tmb_l  (~se),
                .clk    (pctxt2_state_clk)
                ) ;

   








dff_s #(13) pctxt_state2_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (pctxt_state2[12:0]),
        .clk    (pctxt2_state_clk),
        .se     (se),       .si (),          .so ()
        );  


assign  lsu_t2_pctxt_state[12:0] = pctxt_state2[12:0] ;

// PRIMARY CONTEXT - Thread3
   wire       pctxt3_state_clk;



clken_buf pctxt3_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~pctxt_state_wr_thrd[3]),
                .tmb_l  (~se),
                .clk    (pctxt3_state_clk)
                ) ;

   








dff_s #(13) pctxt_state3_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (pctxt_state3[12:0]),
        .clk    (pctxt3_state_clk),
        .se     (se),       .si (),          .so ()
        );  


assign  lsu_t3_pctxt_state[12:0] = pctxt_state3[12:0] ;
   
// SECONDARY CONTEXT - Thread0
   wire       sctxt0_state_clk;



clken_buf sctxt0_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~sctxt_state_wr_thrd[0]),
                .tmb_l  (~se),
                .clk    (sctxt0_state_clk)
                ) ;

   








dff_s #(13) sctxt_state0_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (sctxt_state0[12:0]),
        .clk    (sctxt0_state_clk),
        .se     (se),       .si (),          .so ()
        );  


// SECONDARY CONTEXT - Thread1
   wire       sctxt1_state_clk;



clken_buf sctxt1_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~sctxt_state_wr_thrd[1]),
                .tmb_l  (~se),
                .clk    (sctxt1_state_clk)
                ) ;

   








dff_s #(13) sctxt_state1_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (sctxt_state1[12:0]),
        .clk    (sctxt1_state_clk),
        .se     (se),       .si (),          .so ()
        );  


// SECONDARY CONTEXT - Thread2
   wire       sctxt2_state_clk;



clken_buf sctxt2_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~sctxt_state_wr_thrd[2]),
                .tmb_l  (~se),
                .clk    (sctxt2_state_clk)
                ) ;

   








dff_s #(13) sctxt_state2_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (sctxt_state2[12:0]),
        .clk    (sctxt2_state_clk),
        .se     (se),       .si (),          .so ()
        );  


// SECONDARY CONTEXT - Thread3
   wire       sctxt3_state_clk;



clken_buf sctxt3_state_clkbuf (
                .rclk   (clk),
                .enb_l  (~sctxt_state_wr_thrd[3]),
                .tmb_l  (~se),
                .clk    (sctxt3_state_clk)
                ) ;

   








dff_s #(13) sctxt_state3_ff (
        .din    (st_rs3_data_g[12:0]),
        .q      (sctxt_state3[12:0]),
        .clk    (sctxt3_state_clk),
        .se     (se),       .si (),          .so ()
        );  


wire  [12:0]  current_pctxt_e,current_sctxt_e ;
wire  [12:0]  current_pctxt_m ;

wire  [12:0]  current_ctxt_e,current_ctxt_m ;

mux4ds #(13) current_pctxt_e_mux (
   .in0 (pctxt_state0[12:0]),                        
   .in1 (pctxt_state1[12:0]),                        
   .in2 (pctxt_state2[12:0]),                        
   .in3 (pctxt_state3[12:0]),                        
   .sel0(thread0_ctxt),
   .sel1(thread1_ctxt),
   .sel2(thread2_ctxt),
   .sel3(thread3_ctxt),
   .dout(current_pctxt_e[12:0])                        
   );

mux4ds #(13) current_sctxt_e_mux (
   .in0 (sctxt_state0[12:0]),                        
   .in1 (sctxt_state1[12:0]),                        
   .in2 (sctxt_state2[12:0]),                        
   .in3 (sctxt_state3[12:0]),                        
   .sel0(thread0_ctxt),
   .sel1(thread1_ctxt),
   .sel2(thread2_ctxt),
   .sel3(thread3_ctxt),
   .dout(current_sctxt_e[12:0])                        
   );
 
   wire [12:0] tlb_actxt;
  
assign tlb_actxt[12:0] =
       {tlu_dtlb_tte_tag_w2[12:0]} ; 

   wire [3:0] thread_sel;
   assign     thread_sel[0]= thread_pctxt   & ~rst_tri_en;
   assign     thread_sel[1]= thread_sctxt   & ~rst_tri_en;
   assign     thread_sel[2]= thread_actxt   & ~rst_tri_en;
   assign     thread_sel[3]= thread_default |  rst_tri_en;

// change buffer to nand /nor
   
mux4ds #(13) tlb_ctxt_mux (
   .in0 (current_pctxt_e[12:0]),                        
   .in1 (current_sctxt_e[12:0]),                        
   .in2 (tlb_actxt[12:0]),                        
   .in3 ({13'b0}),
   .sel0(thread_sel[0]),
   .sel1(thread_sel[1]),
   .sel2(thread_sel[2]),
   .sel3(thread_sel[3]),
   .dout(tlb_ctxt[12:0])                        
   );

assign  current_ctxt_e[12:0] = tlb_ctxt[12:0] ;

//Bug 3094
wire	[12:0]	itrap_pctxt_e ;
mux4ds #(13) itrap_pctxt_e_mux (
   .in0 (pctxt_state0[12:0]),                        
   .in1 (pctxt_state1[12:0]),                        
   .in2 (pctxt_state2[12:0]),                        
   .in3 (pctxt_state3[12:0]),                        
   .sel0(thread0_e),
   .sel1(thread1_e),
   .sel2(thread2_e),
   .sel3(thread3_e),
   .dout(itrap_pctxt_e[12:0])                        
   );

// Create current ctxt for tlu purpose.
dff_s #(26) cctxt_stgm (
        .din    ({current_ctxt_e[12:0],itrap_pctxt_e[12:0]}),
        .q      ({current_ctxt_m[12:0],current_pctxt_m[12:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  lsu_tlu_dside_ctxt_m[12:0] = current_ctxt_m[12:0] ;
assign  lsu_tlu_pctxt_m[12:0] = current_pctxt_m[12:0] ;

   // Primary Context 
mux4ds #(13)     pctxt_mx (
        .in0    (pctxt_state0[12:0]),
        .in1    (pctxt_state1[12:0]),
        .in2    (pctxt_state2[12:0]),
        .in3    (pctxt_state3[12:0]),
        .sel0   (thread0_g),
        .sel1   (thread1_g),
        .sel2   (thread2_g),
        .sel3   (thread3_g),
        .dout   (pctxt_state[12:0])
        );

// Secondary Context 
mux4ds #(13)     sctxt_mx (
        .in0    (sctxt_state0[12:0]),
        .in1    (sctxt_state1[12:0]),
        .in2    (sctxt_state2[12:0]),
        .in3    (sctxt_state3[12:0]),
        .sel0   (thread0_g),
        .sel1   (thread1_g),
        .sel2   (thread2_g),
        .sel3   (thread3_g),
        .dout   (sctxt_state[12:0])
        );

/********************partition id********************/
 // ** Reset put in temporarily to ensure pid is correctly initialized **
// ** Env/diags should be set-up to initialize pid correctly **
wire	[2:0]	pid_state0, pid_state1, pid_state2, pid_state3;

// Thread0
   wire [2:0] pid_state_din;
   assign     pid_state_din[2:0] = {3{rst_l}} & st_rs3_data_g[2:0];

   wire       pid_state0_clk;



clken_buf pid_state0_clkbuf (
                .rclk   (clk),
                .enb_l  (~pid_state_wr_en[0]),
                .tmb_l  (~se),
                .clk    (pid_state0_clk)
                ) ;

   








dff_s #(3) pid0_state (
        .din    (pid_state_din[2:0]),
        .q      (pid_state0[2:0]),
        .clk    (pid_state0_clk),
        .se     (se),       .si (),          .so ()
        );  


assign	lsu_pid_state0[2:0] = pid_state0[2:0] ;

// Thread1
   wire       pid_state1_clk;



clken_buf pid_state1_clkbuf (
                .rclk   (clk),
                .enb_l  (~pid_state_wr_en[1]),
                .tmb_l  (~se),
                .clk    (pid_state1_clk)
                ) ;

   








dff_s #(3) pid1_state (
        .din    (pid_state_din[2:0]),
        .q      (pid_state1[2:0]),
        .clk    (pid_state1_clk),
        .se     (se),       .si (),          .so ()
        );  


assign	lsu_pid_state1[2:0] = pid_state1[2:0] ;

// Thread2
   wire       pid_state2_clk;



clken_buf pid_state2_clkbuf (
                .rclk   (clk),
                .enb_l  (~pid_state_wr_en[2]),
                .tmb_l  (~se),
                .clk    (pid_state2_clk)
                ) ;

   








dff_s #(3) pid2_state (
        .din    (pid_state_din[2:0]),
        .q      (pid_state2[2:0]),
        .clk    (pid_state2_clk),
        .se     (se),       .si (),          .so ()
        );  


assign	lsu_pid_state2[2:0] = pid_state2[2:0] ;

// Thread3
   wire       pid_state3_clk;



clken_buf pid_state3_clkbuf (
                .rclk   (clk),
                .enb_l  (~pid_state_wr_en[3]),
                .tmb_l  (~se),
                .clk    (pid_state3_clk)
                ) ;

   








dff_s #(3) pid3_state (
        .din    (pid_state_din[2:0]),
        .q      (pid_state3[2:0]),
        .clk    (pid_state3_clk),
        .se     (se),       .si (),          .so ()
        );  


assign	lsu_pid_state3[2:0] = pid_state3[2:0] ;

wire [2:0] cam_pid_e ;
// Hypervisor related cam inputs
mux4ds #(3)     cam_pid_mx (
        .in0    (pid_state0[2:0]),
        .in1    (pid_state1[2:0]),
        .in2    (pid_state2[2:0]),
        .in3    (pid_state3[2:0]),
        .sel0   (thread0_e),
        .sel1   (thread1_e),
        .sel2   (thread2_e),
        .sel3   (thread3_e),
        .dout   (cam_pid_e[2:0])
        );

assign  lsu_dtlb_cam_pid_e[2:0] =
  lsu_dtlb_dmp_vld_e ? tlu_dtlb_tte_tag_b58t56[2:0] : cam_pid_e[2:0] ;
  //thread_actxt ? tlu_dtlb_tte_tag_b58t56[2:0] : cam_pid_e[2:0] ;
   
mux4ds #(3)     pid_mx (
        .in0    (pid_state0[2:0]),
        .in1    (pid_state1[2:0]),
        .in2    (pid_state2[2:0]),
        .in3    (pid_state3[2:0]),
        .sel0   (thread0_g),
        .sel1   (thread1_g),
        .sel2   (thread2_g),
        .sel3   (thread3_g),
        .dout   (pid_state[2:0])
        );

  
/***********************lsu ctl reg********************/
// Contents of lsu_ctl_reg
/*
  IC. I-Cache Enable. b0           b0
  DC. D-Cache Enable. b1           b1
  IM. I-MMU Enable.   b2           b2
  DM. D-MMU Enable.   b3           b3
  FM. Parity Mask.(delete) b4-19   --    
  Reserved    b20                  --
  VW. VA Wtchpt Wr  b21            b4
  VR. VA Wtchpt Rd  b22            b5
  PW. PA Wtchpt Wr  b23            --
  PR. PA Wtchpt Rd  b24            --
  VM. VA Wtchpt BMask   b25-32     b6-13
  PM. PA Wtchpt BMask   b33-40     --
*/

   assign lsu_dp_ctl_reg0[5:0] = lsu_ctl_reg0[5:0];
   assign lsu_dp_ctl_reg1[5:0] = lsu_ctl_reg1[5:0];
   assign lsu_dp_ctl_reg2[5:0] = lsu_ctl_reg2[5:0];
   assign lsu_dp_ctl_reg3[5:0] = lsu_ctl_reg3[5:0];
   
wire  [9:0]  lsu_ctl_reg_din ;

//assign  lsu_ctl_reg_din[19:0] = st_rs3_data_g[40:21] ;
   wire   lsu_ctl_reg_vw_din, lsu_ctl_reg_vr_din;
   wire [7:0] lsu_ctl_reg_vm_din;
   
assign  lsu_ctl_reg_vw_din = st_rs3_data_g[21] ;
assign  lsu_ctl_reg_vr_din = st_rs3_data_g[22] ;
assign  lsu_ctl_reg_vm_din[7:0] = st_rs3_data_g[32:25];

assign lsu_ctl_reg_din[9:0] = {lsu_ctl_reg_vm_din[7:0],
                               lsu_ctl_reg_vr_din,
                               lsu_ctl_reg_vw_din};
   
   
wire [3:0]  lsuctl_ctlbits_wr_data ;  

assign  lsuctl_ctlbits_wr_data[3:0] =
          dfture_tap_wr_mx_sel ? lsu_iobrdge_wr_data[3:0] : st_rs3_data_g[3:0] ;

// Thread0
   wire [9:0] lsu_ctl_reg0_din;
   assign      lsu_ctl_reg0_din[9:0] = {10{~lctl_rst[0]}} & lsu_ctl_reg_din[9:0];
   wire [3:0]  lsuctl_ctlbits0_wr_data_din;
   assign      lsuctl_ctlbits0_wr_data_din[3:0] = {4{~lctl_rst[0]}} & lsuctl_ctlbits_wr_data[3:0];
// Thread1
   wire [9:0] lsu_ctl_reg1_din;
   assign      lsu_ctl_reg1_din[9:0] = {10{~lctl_rst[1]}} & lsu_ctl_reg_din[9:0];
   wire [3:0]  lsuctl_ctlbits1_wr_data_din;
   assign      lsuctl_ctlbits1_wr_data_din[3:0] = {4{~lctl_rst[1]}} & lsuctl_ctlbits_wr_data[3:0];
// Thread2
   wire [9:0] lsu_ctl_reg2_din;
   assign      lsu_ctl_reg2_din[9:0] = {10{~lctl_rst[2]}} & lsu_ctl_reg_din[9:0];
   wire [3:0]  lsuctl_ctlbits2_wr_data_din;
   assign      lsuctl_ctlbits2_wr_data_din[3:0] = {4{~lctl_rst[2]}} & lsuctl_ctlbits_wr_data[3:0];
// Thread3
   wire [9:0] lsu_ctl_reg3_din;
   assign      lsu_ctl_reg3_din[9:0] = {10{~lctl_rst[3]}} & lsu_ctl_reg_din[9:0];
   wire [3:0]  lsuctl_ctlbits3_wr_data_din;
   assign      lsuctl_ctlbits3_wr_data_din[3:0] = {4{~lctl_rst[3]}} & lsuctl_ctlbits_wr_data[3:0];

// trin jtag input flops
reg [3:0] rtap_lsu_ctlbits_wr_en;
reg [13:0] rtap_lsu_ctlbits_data;
always @ *
begin
   rtap_lsu_ctlbits_wr_en = 0;
   if (rtap_core_val && rtap_core_id == 4'd1)
   begin
      if (rtap_core_threadid == 2'd0)
         rtap_lsu_ctlbits_wr_en = 4'b0001;
      else if (rtap_core_threadid == 2'd1)
         rtap_lsu_ctlbits_wr_en = 4'b0010;
      else if (rtap_core_threadid == 2'd2)
         rtap_lsu_ctlbits_wr_en = 4'b0100;
      else if (rtap_core_threadid == 2'd3)
         rtap_lsu_ctlbits_wr_en = 4'b1000;
   end
   rtap_lsu_ctlbits_data = rtap_core_data[13:0];
end

always @ (posedge clk)
begin
  // if (!rst_l)
  // begin
  //   lsu_ctl_reg0 <= 0;
  // end
  // else
  begin
    if (rtap_lsu_ctlbits_wr_en[0])
      lsu_ctl_reg0[13:0] <= rtap_lsu_ctlbits_data[13:0];
    if (lsuctl_ctlbits_wr_en[0])
      lsu_ctl_reg0[3:0] <= lsuctl_ctlbits0_wr_data_din[3:0];
    if (lsu_ctl_state_wr_en[0])
      lsu_ctl_reg0[13:4] <= lsu_ctl_reg0_din[9:0];

    if (rtap_lsu_ctlbits_wr_en[1])
      lsu_ctl_reg1[13:0] <= rtap_lsu_ctlbits_data[13:0];
    if (lsuctl_ctlbits_wr_en[1])
      lsu_ctl_reg1[3:0] <= lsuctl_ctlbits1_wr_data_din[3:0];
    if (lsu_ctl_state_wr_en[1])
      lsu_ctl_reg1[13:4] <= lsu_ctl_reg1_din[9:0];

    if (rtap_lsu_ctlbits_wr_en[2])
      lsu_ctl_reg2[13:0] <= rtap_lsu_ctlbits_data[13:0];
    if (lsuctl_ctlbits_wr_en[2])
      lsu_ctl_reg2[3:0] <= lsuctl_ctlbits2_wr_data_din[3:0];
    if (lsu_ctl_state_wr_en[2])
      lsu_ctl_reg2[13:4] <= lsu_ctl_reg2_din[9:0];

    if (rtap_lsu_ctlbits_wr_en[3])
      lsu_ctl_reg3[13:0] <= rtap_lsu_ctlbits_data[13:0];
    if (lsuctl_ctlbits_wr_en[3])
      lsu_ctl_reg3[3:0] <= lsuctl_ctlbits3_wr_data_din[3:0];
    if (lsu_ctl_state_wr_en[3])
      lsu_ctl_reg3[13:4] <= lsu_ctl_reg3_din[9:0];
  end
end



// LSU Ctl Reg
mux4ds #(14)     lctlrg_mx (
        .in0    (lsu_ctl_reg0[13:0]),
        .in1    (lsu_ctl_reg1[13:0]),
        .in2    (lsu_ctl_reg2[13:0]),
        .in3    (lsu_ctl_reg3[13:0]),
        .sel0   (thread0_g),
        .sel1   (thread1_g),
        .sel2   (thread2_g),
        .sel3   (thread3_g),
        .dout   (lsu_ctl_reg[13:0])
        );

   wire [3:0] dfture_tap_rd_data;

mux4ds #(4)     dfture_tap_rd_data_mx (
        .in0    (lsu_ctl_reg0[3:0]),
        .in1    (lsu_ctl_reg1[3:0]),
        .in2    (lsu_ctl_reg2[3:0]),
        .in3    (lsu_ctl_reg3[3:0]),
        .sel0   (dfture_tap_rd_en[0]),
        .sel1   (dfture_tap_rd_en[1]),
        .sel2   (dfture_tap_rd_en[2]),
        .sel3   (dfture_tap_rd_en[3]),
        .dout   (dfture_tap_rd_data[3:0])
        );
   
   wire [7:0] va_wtchpt_mask;

mux4ds #(8)     va_wtchpt_mask_mx (
        .in0    (lsu_ctl_reg0[13:6]),
        .in1    (lsu_ctl_reg1[13:6]),
        .in2    (lsu_ctl_reg2[13:6]),
        .in3    (lsu_ctl_reg3[13:6]),
        .sel0   (thread0_m),
        .sel1   (thread1_m),
        .sel2   (thread2_m),
        .sel3   (thread3_m),
        .dout   (va_wtchpt_mask[7:0])
        );  

// Bug 1671 fix
//assign va_wtchpt_msk_match_m  =   (stb_ldst_byte_msk[7:0] == va_wtchpt_mask[7:0]);
//assign va_wtchpt_msk_match_m  =   |(stb_ldst_byte_msk[7:0] & va_wtchpt_mask[7:0]);

assign va_wtchpt_msk_match_m  =   
       stb_ldst_byte_msk[0] & va_wtchpt_mask[7] |
       stb_ldst_byte_msk[1] & va_wtchpt_mask[6] |
       stb_ldst_byte_msk[2] & va_wtchpt_mask[5] |
       stb_ldst_byte_msk[3] & va_wtchpt_mask[4] |
       stb_ldst_byte_msk[4] & va_wtchpt_mask[3] |
       stb_ldst_byte_msk[5] & va_wtchpt_mask[2] |
       stb_ldst_byte_msk[6] & va_wtchpt_mask[1] |
       stb_ldst_byte_msk[7] & va_wtchpt_mask[0] ;
 
       
   
/***********************ldxa****************************/   
// BIST_Controller ASI
// tap wr takes precedence
//wire  [`L1D_ADDRESS_HI:0]  bistctl_data_in;
//wire  [`L1D_ADDRESS_HI:0]  bist_ctl_reg ;

//assign  bistctl_data_in[13:0] =
//  bist_tap_wr_en ? lsu_iobrdge_wr_data[13:0] : st_rs3_data_g[13:0] ;

//assign  bistctl_data_in[10:7] = lsu_iobrdge_wr_data[10:7];
//assign  bistctl_data_in[6:0] =
//  bist_tap_wr_en ? lsu_iobrdge_wr_data[6:0] : st_rs3_data_g[6:0] ;
   
assign  bist_ctl_reg_in[6:0] =  
bist_tap_wr_en ? lsu_iobrdge_wr_data[6:0] : st_rs3_data_g[6:0];

/*   wire bistctl_clk;
   
`ifdef FPGA_SYN_CLK_EN
`else
clken_buf bistctl_clkbuf (
                .rclk   (clk),
                .enb_l  (~bistctl_wr_en),
                .tmb_l  (tmb_l),
                .clk    (bistctl_clk)
                ) ;
`endif
   
`ifdef FPGA_SYN_CLK_DFF
dffe_s #(11) bistctl_ff (
        .din    (bistctl_data_in[`L1D_ADDRESS_HI:0]),
        .q      (bist_ctl_reg[`L1D_ADDRESS_HI:0]),
        .en (~(~bistctl_wr_en)), .clk(clk),
        .se     (se),       .si (),          .so ()
        );
`else
dff_s #(11) bistctl_ff (
        .din    (bistctl_data_in[`L1D_ADDRESS_HI:0]),
        .q      (bist_ctl_reg[`L1D_ADDRESS_HI:0]),
        .clk    (bistctl_clk),
        .se     (se),       .si (),          .so ()
        );
`endif
*/
   
// Self-Timed Margin Control ASI
// tap wr takes precedence
wire  [27:0]  mrgnctl_data_in;   
wire  [27:0]  spc_mrgnctl_data_in;
   
wire  [27:0]  mrgn_ctl_reg ;

//itlb         [27:20]
//dtlb         [19:12]
//idct (i)     [11: 8]
//idct (d)     [ 7: 4]
//idct (mamem) [ 3: 0]

assign mrgnctl_data_in[27:0] =
mrgn_tap_wr_en ? lsu_iobrdge_wr_data[27:0] :
                 spc_mrgnctl_data_in[27:0];
          
assign spc_mrgnctl_data_in[27:0] =        
(~rst_l) ?  {8'b01011011, 8'b01011011, 4'b0101,4'b0101,4'b0101} :
             st_rs3_data_g[27:0];
                               
   wire mrgnctl_clk;
   


clken_buf mrgnctl_clkbuf (
                .rclk   (clk),
                .enb_l  (~mrgnctl_wr_en),
                .tmb_l  (~se),
                .clk    (mrgnctl_clk)
                ) ;

   








dff_s #(28) mrgnctl_ff (
        .din    (mrgnctl_data_in[27:0]),
        .q      (mrgn_ctl_reg[27:0]),
        .clk    (mrgnctl_clk),
        .se     (se),       .si (),          .so ()
        );


assign	lsu_itlb_mrgn[7:0] = mrgn_ctl_reg[27:20] ;
assign	lsu_dtlb_mrgn[7:0] = mrgn_ctl_reg[19:12] ;
assign	lsu_ictag_mrgn[3:0] = mrgn_ctl_reg[11:8] ;
assign	lsu_dctag_mrgn[4-1:0] = mrgn_ctl_reg[7:4] ;
assign	lsu_mamem_mrgn[3:0] = mrgn_ctl_reg[3:0] ;

// LSU Diag Reg ASI
wire  [1:0] ldiagctl_data_in ;

wire  [1:0] ldiag_ctl_reg ;

assign  ldiagctl_data_in[1:0] = {2{rst_l}} & st_rs3_data_g[1:0] ;

   wire ldiagctl_clk;
   


clken_buf ldiagctl_clkbuf (
                .rclk   (clk),
                .enb_l  (~ldiagctl_wr_en),
                .tmb_l  (~se),
                .clk    (ldiagctl_clk)
                ) ;   

   








dff_s #(2) ldiagctl_ff (
        .din    (ldiagctl_data_in[1:0]),
        .q      (ldiag_ctl_reg[1:0]),
        .clk    (ldiagctl_clk),
        .se     (se),       .si (),          .so ()
        );


assign	lsu_ifu_direct_map_l1 = ldiag_ctl_reg[0] ;
assign	dc_direct_map = ldiag_ctl_reg[1] ;

   wire [43:0] misc_ctl_reg;

   wire [3:0] misc_ctl_sel_q;
   
dff_s #(4) misc_ctl_sel_stgg (
    .din ( misc_ctl_sel_din[3:0] ),
    .q   ( misc_ctl_sel_q[3:0]   ),       
    .clk (clk),
    .se  (se),       .si (),          .so ()
);
   wire [3:0] misc_ctl_sel;
 
   assign     misc_ctl_sel[0] =  misc_ctl_sel_q [0] & ~rst_tri_en;
   assign     misc_ctl_sel[1] =  misc_ctl_sel_q [1] & ~rst_tri_en;
   assign     misc_ctl_sel[2] =  misc_ctl_sel_q [2] |  rst_tri_en;
   assign     misc_ctl_sel[3] =  misc_ctl_sel_q [3] & ~rst_tri_en;
      
// Misc Ctl Registers
mux4ds #(44)     miscrg_mx (
        .in0    ({{43-(6 + 4){1'b0}},bist_ctl_reg_out[(6 + 4):0]}),
        .in1    ({16'b0,mrgn_ctl_reg[27:0]}),
        .in2    ({42'd0,ldiag_ctl_reg[1:0]}),
        .in3    ({40'd0,dfture_tap_rd_data[3:0]}),
        .sel0   (misc_ctl_sel[0]),
        .sel1   (misc_ctl_sel[1]),
        .sel2   (misc_ctl_sel[2]),
        .sel3   (misc_ctl_sel[3]),
        .dout   (misc_ctl_reg[43:0])
        );

assign	lsu_iobrdge_rd_data[43:0] = misc_ctl_reg[43:0] ;

wire	[12:0]	ldxa_data_fmx1 ;
   
mux3ds #(13)     lsuasi_fmx1 (
        .in0    (pctxt_state[12:0]),
        .in1    (sctxt_state[12:0]),
        .in2    ({10'd0,pid_state[2:0]}),
        .sel0   (lsu_asi_sel_fmx1[0]),
        .sel1   (lsu_asi_sel_fmx1[1]),
        .sel2   (lsu_asi_sel_fmx1[2]),
        .dout   (ldxa_data_fmx1[12:0])
        );

wire  [47:0]  final_ldxa_data_g ;
   
//mux3ds #(48)     lsuasi_fmx2 (
//        .in0    ({35'd0,ldxa_data_fmx1[12:0]}),
//        .in1    ({15'd0,lsu_ctl_reg[15:8],2'b00,lsu_ctl_reg[5:4],17'd0,lsu_ctl_reg[3:0]}),
//        .in2    ({lsu_va_wtchpt_addr[47:3],3'b000}),
//        .sel0   (lsu_asi_sel_fmx2[0]),
//        .sel1   (lsu_asi_sel_fmx2[1]),
//        .sel2   (lsu_asi_sel_fmx2[2]),
//        .dout   (local_ldxa_data_g[47:0])
//        );

//mux2ds #(48)     lsuasi_final (
//        .in0    (local_ldxa_data_g[47:0]),
//        .in1    ({4'd0,misc_ctl_reg[43:0]}),
//        .sel0   (~misc_asi_rd_en),
//        .sel1   (misc_asi_rd_en),
//        .dout   (final_ldxa_data_g[47:0])
//        );

mux3ds #(48)     lsuasi_fmx2 (
        .in0    ({35'd0,ldxa_data_fmx1[12:0]}),
        .in1    ({15'd0,lsu_ctl_reg[13:6],2'b00,lsu_ctl_reg[5:4],17'd0,lsu_ctl_reg[3:0]}),
        .in2    ({4'd0,misc_ctl_reg[43:0]}),
        .sel0   (lsu_asi_sel_fmx2[0]),
        .sel1   (lsu_asi_sel_fmx2[1]),
        .sel2   (lsu_asi_sel_fmx2[2]),
        .dout   (final_ldxa_data_g[47:0])
        );   

assign        lsu_local_ldxa_data_g[47:0] =  final_ldxa_data_g[47:0];


/****************va staging*******************/
 wire [47:0] ldst_va_m;   
dff_s  #(48) va_stgm (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign lsu_ldst_va_m[12:0] = ldst_va_m[12:0];   

assign lsu_ldst_va_m_buf[47:0] = ldst_va_m[47:0];
   
       
assign lsu_tlu_ldst_va_m[9:0] = ldst_va_m[9:0];   
   
wire [47:0] ldst_va_g;   
dff_s  #(48) va_stgg (
        .din    (ldst_va_m[47:0]),
        .q      (ldst_va_g[47:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign  lsu_ldst_va_g[7:0] = ldst_va_g[7:0] ;


wire  [7:0] asi_state_g ;
assign  asi_state_g[7:0] = lsu_asi_state[7:0] ; 

wire  [7:0] tlb_asi_state0,tlb_asi_state1,tlb_asi_state2,tlb_asi_state3 ;
wire  [47:13] lngltncy_dmp_va ;
   
// Thread 0
   wire [47:0] ldst_va0;

   wire        tlb_access0_clk;
   


clken_buf tlb_access0_clkbuf (
                .rclk   (clk),
                .enb_l  (~tlb_access_en0_g),
                .tmb_l  (~se),
                .clk    (tlb_access0_clk)
                ) ;

   








dff_s #(56)  asi_thrd0 (
        .din    ({asi_state_g[7:0],   ldst_va_g[47:0]}),
        .q      ({tlb_asi_state0[7:0],ldst_va0[47:0]}),
        .clk    (tlb_access0_clk),
        .se     (se),       .si (),          .so ()
        );


// Thread 1
   wire [47:0] ldst_va1;

   wire        tlb_access1_clk;
   


clken_buf tlb_access1_clkbuf (
                .rclk   (clk),
                .enb_l  (~tlb_access_en1_g),
                .tmb_l  (~se),
                .clk    (tlb_access1_clk)
                ) ;

   








dff_s #(56)  asi_thrd1 (
        .din    ({asi_state_g[7:0],   ldst_va_g[47:0]}),
        .q      ({tlb_asi_state1[7:0],ldst_va1[47:0]}),
        .clk    (tlb_access1_clk),
        .se     (se),       .si (),          .so ()
        );


// Thread 2
   wire [47:0] ldst_va2;

   wire        tlb_access2_clk;
   


clken_buf tlb_access2_clkbuf (
                .rclk   (clk),
                .enb_l  (~tlb_access_en2_g),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;

   








dff_s #(56)  asi_thrd2 (
        .din    ({asi_state_g[7:0],   ldst_va_g[47:0]}),
        .q      ({tlb_asi_state2[7:0],ldst_va2[47:0]}),
        .clk    (tlb_access2_clk),
        .se     (se),       .si (),          .so ()
        );


// Thread 3
   wire [47:0] ldst_va3;

   wire        tlb_access3_clk;
   


clken_buf tlb_access3_clkbuf (
                .rclk   (clk),
                .enb_l  (~tlb_access_en3_g),
                .tmb_l  (~se),
                .clk    (tlb_access3_clk)
                ) ;

   








dff_s #(56)  asi_thrd3 (
        .din    ({asi_state_g[7:0],   ldst_va_g[47:0]}),
        .q      ({tlb_asi_state3[7:0],ldst_va3[47:0]}),
        .clk    (tlb_access3_clk),
        .se     (se),       .si (),          .so ()
        );


   wire [47:0] ldst_va_dout;
   
mux4ds #(56)     ldst_va_mx (
        .in0    ({tlb_asi_state0[7:0],ldst_va0[47:0]}),
        .in1    ({tlb_asi_state1[7:0],ldst_va1[47:0]}),
        .in2    ({tlb_asi_state2[7:0],ldst_va2[47:0]}),
        .in3    ({tlb_asi_state3[7:0],ldst_va3[47:0]}),
        .sel0   (tlb_access_sel_thrd0),
        .sel1   (tlb_access_sel_thrd1),
        .sel2   (tlb_access_sel_thrd2),
        .sel3   (tlb_access_sel_default),
        .dout   ({lsu_tlu_tlb_asi_state_m[7:0], ldst_va_dout[47:0]})
        );

assign  lsu_ifu_asi_state[7:0] = lsu_tlu_tlb_asi_state_m[7:0] ;

wire [17:0] lngltncy_ldst_va ;

assign  lngltncy_ldst_va[17:0] = ldst_va_dout[17:0];
assign  lngltncy_dmp_va[47:13] = ldst_va_dout[47:13];   
assign  lsu_tlu_tlb_ldst_va_m[(6 + 4):0] = lngltncy_ldst_va[(6 + 4):0] ;
assign  lsu_tlu_tlb_dmp_va_m[47:13] = lngltncy_dmp_va[47:13] ;
assign  lsu_ifu_asi_addr[17:0] = lngltncy_ldst_va[17:0] ;

// Diagnostics

//wire	[3:0]	lsu_diag_access_sel_d1 ;

//dff #(4)  diagsel_stgd1 (
//        .din    (lsu_diag_access_sel[3:0]),
//        .q      (lsu_diag_access_sel_d1[3:0]),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        ); 
  wire [3:0] diagnstc_va_sel;
//change buffer to nand / nor 
assign     diagnstc_va_sel[0] =   lsu_diagnstc_va_sel[0] & ~rst_tri_en;
assign     diagnstc_va_sel[1] =   lsu_diagnstc_va_sel[1] & ~rst_tri_en;
assign     diagnstc_va_sel[2] =   lsu_diagnstc_va_sel[2] & ~rst_tri_en;
assign     diagnstc_va_sel[3] =   lsu_diagnstc_va_sel[3] |  rst_tri_en;
   
wire	[20:0] diag_va ;
mux4ds #(21)     diag_va_mx (
        .in0    (ldst_va0[20:0]),
        .in1    (ldst_va1[20:0]),
        .in2    (ldst_va2[20:0]),
        .in3    (ldst_va3[20:0]),
        .sel0   (diagnstc_va_sel[0]),
        .sel1   (diagnstc_va_sel[1]),
        .sel2   (diagnstc_va_sel[2]),
        .sel3   (diagnstc_va_sel[3]),
        .dout   (diag_va[20:0])
        );

assign  lsu_diagnstc_wr_addr_e[(6 + 4):0] = diag_va[(6 + 4):0] ;
assign  lsu_diagnstc_dc_prty_invrt_e[7:0] = diag_va[20:13] ;   

//assign  lsu_lngltncy_ldst_va[13:11]= lngltncy_ldst_va[13:11] ;

//assign  lsu_diagnstc_wr_way_e[0] = ~diag_va[12] & ~diag_va[11] ;
//assign  lsu_diagnstc_wr_way_e[1] = ~diag_va[12] &  diag_va[11] ;
//assign  lsu_diagnstc_wr_way_e[2] =  diag_va[12] & ~diag_va[11] ;
//assign  lsu_diagnstc_wr_way_e[3] =  diag_va[12] &  diag_va[11] ;

assign  lsu_diagnstc_wr_way_e[2-1:0] =  {diag_va[12],  diag_va[11]};
   
   
assign	lsu_diag_va_prty_invrt = diag_va[13] ;

/***************error addr***************/
wire  [(6 + 4):4] dcfill_addr_m,dcfill_addr_g ;

dff_s #((6+1))  filla_stgm (
        .din    (lsu_dcfill_addr_e[(6 + 4):4]),
        .q      (dcfill_addr_m[(6 + 4):4]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

dff_s #((6+1))  filla_stgg (
        .din    (dcfill_addr_m[(6 + 4):4]),
        .q      (dcfill_addr_g[(6 + 4):4]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire  [28:0]  error_pa_g ;
dff_s #(29)  epa_stgg (
        .din    (lsu_error_pa_m[28:0]),
        .q      (error_pa_g[28:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire  [47:4]  err_addr_g ;

mux3ds #(44)     erra_mx (
        .in0    (ldst_va_g[47:4]),
        .in1    ({38'd0,async_tlb_index[5:0]}),
        .in2    ({8'd0,error_pa_g[28:0],dcfill_addr_g[10:4]}), // trin todo; might not be right
        // .in2    ({8'd0,error_pa_g[28:0],dcfill_addr_g[`L1D_ADDRESS_HI:4]}), // trin todo; might not be right
        .sel0   (lsu_err_addr_sel[0]),
        .sel1   (lsu_err_addr_sel[1]),
        .sel2   (lsu_err_addr_sel[2]),
        .dout   (err_addr_g[47:4])
        );

/*assign  err_addr_g[47:4] =
  sync_error_sel ?  ldst_va_g[47:4] : 
	async_error_sel ? {38'd0,async_tlb_index[5:0]} :
			{8'd0,error_pa_g[28:0],dcfill_addr_g[`L1D_ADDRESS_HI:4]} ;*/

dff_s #(44)  errad_stgg (
        .din    (err_addr_g[47:4]),
        .q      (lsu_ifu_err_addr[47:4]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 
     
endmodule // lsu_dctldp
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_tlbdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module lsu_tlbdp(/*AUTOARG*/
   // Outputs
   so, lsu_tlb_rd_data, tlb_pgnum_buf, tlb_pgnum_buf2, 
   tlb_rd_tte_data_ie_buf, stb_cam_vld, tte_data_parity_error, 
   tte_tag_parity_error, cache_way_hit_buf1, cache_way_hit_buf2, 
   lsu_tlu_tte_pg_sz_g, 
   // Inputs
   
   tlb_rd_tte_csm, lsu_tlb_csm_rd_vld_g,
   
   rclk, si, se, tlb_rd_tte_tag, tlb_rd_tte_data, 
   lsu_tlb_data_rd_vld_g, tlb_pgnum, asi_internal_m, lsu_alt_space_m, 
   tlb_cam_hit, ifu_lsu_ld_inst_e, lsu_dtlb_bypass_e, 
   tlb_rd_tte_data_parity, tlb_rd_tte_tag_parity, cache_way_hit
   );

   input  rclk;
   input  si;
   input  se;
   output so;
   
input   [58:0]         	tlb_rd_tte_tag ;         // tte tag from tlb
input   [42:0]          tlb_rd_tte_data ;        // tte data from tlb
input			lsu_tlb_data_rd_vld_g ;	 // select between tte tag/data rd.		


input   [32:0]      tlb_rd_tte_csm ;        // tte csm from tlb
input          lsu_tlb_csm_rd_vld_g;


input [39:10]           tlb_pgnum;
input                   asi_internal_m;
   input                lsu_alt_space_m;
   
// **new**
output	[63:0]		lsu_tlb_rd_data ;	// tag or data rd from tlb



   output [39:10]        tlb_pgnum_buf;
   output [39:37]        tlb_pgnum_buf2;
//   output [42:0]         tlb_rd_tte_data_buf;
   output             tlb_rd_tte_data_ie_buf;

//======================================================
//stb cam vld mved from stb_rwctl    
input     tlb_cam_hit ;
input     ifu_lsu_ld_inst_e;
input     lsu_dtlb_bypass_e;
output    stb_cam_vld;


input    tlb_rd_tte_data_parity ; // data parity bit from tte data
input    tlb_rd_tte_tag_parity ;  // data parity bit from tte tag
output   tte_data_parity_error ;
output   tte_tag_parity_error ;

   input [4-1:0] cache_way_hit;
   output [4-1:0] cache_way_hit_buf1;
   output [4-1:0] cache_way_hit_buf2;

output  [2:0]           lsu_tlu_tte_pg_sz_g ;   // page-size of tte 

wire   tlb_rd_tte_data_27_22_sel_buf;
wire   tlb_rd_tte_data_21_16_sel_buf;
wire   tlb_rd_tte_data_15_13_sel_buf;
wire   lsu_tte_pg_sz_b2, lsu_tte_pg_sz_b1, lsu_tte_pg_sz_b0;
wire   pg_sz_b0, pg_sz_b1, pg_sz_b2;

//===============================================================
   wire   tlb_tte_data_mx_sel2, tlb_tte_data_mx_sel1, tlb_tte_data_mx_sel0;
//tlb_tte_data_mx_sel2 ;  // select for bits 21-19
//tlb_tte_data_mx_sel1 ;  // select for bits 18-16
//tlb_tte_data_mx_sel0 ;  // select for bits 15-13

   assign tlb_tte_data_mx_sel2 = tlb_rd_tte_data_27_22_sel_buf;
   assign tlb_tte_data_mx_sel1 = tlb_rd_tte_data_21_16_sel_buf;
   assign tlb_tte_data_mx_sel0 = tlb_rd_tte_data_15_13_sel_buf;
      
// assign  pg_sz_b0 = 
//  (~tlb_tte_data_mx_sel1 & tlb_tte_data_mx_sel0) | // 64K
//  ( tlb_tte_data_mx_sel1 & tlb_tte_data_mx_sel0) ; // 4M/256M

assign  pg_sz_b0 =  tlb_tte_data_mx_sel0;
   
assign  pg_sz_b1 = 
  (~tlb_tte_data_mx_sel2 & tlb_tte_data_mx_sel1 &  tlb_tte_data_mx_sel0) ; // 4M
assign  pg_sz_b2 = 
  ( tlb_tte_data_mx_sel2 & tlb_tte_data_mx_sel1 &  tlb_tte_data_mx_sel0) ; // 256M
   
assign  lsu_tte_pg_sz_b2 = pg_sz_b2 ;
assign  lsu_tte_pg_sz_b1 = pg_sz_b1 ;
assign  lsu_tte_pg_sz_b0 = pg_sz_b0 ;

assign lsu_tlu_tte_pg_sz_g[2:0] = {pg_sz_b2,pg_sz_b1,pg_sz_b0} ;
   
// CAM VLD GENERATION

// Unfortunately because of timing considerations, this cannot be qualified with
// flush and inst_vld. Must exclude other conditions though such as internal asi
// atomics etc !!! (NOTE : earlier version of inst_vld may be obtained.   
   wire   clk;

   assign   clk =rclk;
   
wire  dtlb_bypass_m ;
dff_s #(1) dtlb_bypass_stgm  (
  .din    (lsu_dtlb_bypass_e), .q (dtlb_bypass_m),
  .clk    (clk), 
  .se     (se), .si (), .so ()
  );

wire ld_inst_vld_m;
dff_s #(1) ld_inst_vld_stgm  (
  .din    (ifu_lsu_ld_inst_e), .q (ld_inst_vld_m),
  .clk    (clk), 
  .se     (se), .si (), .so ()
  );

assign  stb_cam_vld = ld_inst_vld_m & (tlb_cam_hit | dtlb_bypass_m) & 
                      ~(asi_internal_m  & lsu_alt_space_m); //bug 4635, revisit
//======================================================================   

//buffer all inputs first
wire   [58:0]         tlb_rd_tte_tag_buf ;       
wire   [42:0]         tlb_rd_tte_data_buf ;      
wire			            lsu_tte_pg_sz_b1_buf;
wire			            lsu_tte_pg_sz_b0_buf;
wire			            lsu_tte_pg_sz_b2_buf;
wire   [39:10]        tlb_pgnum_l;
wire   [39:10]        tlb_pgnum_buf;  
wire   [39:37]        tlb_pgnum_buf2;  

//BUFFERS
   assign             tlb_rd_tte_tag_buf[58:0] = tlb_rd_tte_tag[58:0];
   assign             lsu_tte_pg_sz_b1_buf = lsu_tte_pg_sz_b1;
   assign             lsu_tte_pg_sz_b0_buf = lsu_tte_pg_sz_b0;
   assign             lsu_tte_pg_sz_b2_buf = lsu_tte_pg_sz_b2;

   //tlb_pgnum buffer
   assign             tlb_pgnum_l [39:10] = ~ tlb_pgnum[39:10];
   assign             tlb_pgnum_buf[39:10] = ~ tlb_pgnum_l[39:10];
   assign             tlb_pgnum_buf2[39:37] = ~ tlb_pgnum_l[39:37];

   assign             tlb_rd_tte_data_buf[42:0] = tlb_rd_tte_data[42:0];
   
   assign tlb_rd_tte_data_ie_buf =  tlb_rd_tte_data_buf [9];
   assign tlb_rd_tte_data_27_22_sel_buf = tlb_rd_tte_data_buf [23];
   assign tlb_rd_tte_data_21_16_sel_buf = tlb_rd_tte_data_buf [16];
   assign tlb_rd_tte_data_15_13_sel_buf = tlb_rd_tte_data_buf [12];
   
   
wire	[63:0]	formatted_tte_tag, formatted_tte_data;

//=================================================================================================
//      Format TLB Tag 
//=================================================================================================

assign  formatted_tte_tag[63:0] =
        {
	tlb_rd_tte_tag_buf[58:56],
	tlb_rd_tte_tag_buf[55],
	// ECO 4265 begin
	tlb_rd_tte_tag_buf[54], 	  // Parity
	tlb_rd_tte_tag_buf[27], // mxsel2 - b27:22 vld 
	tlb_rd_tte_tag_buf[17], // mxsel1 - b21:16 vld
	tlb_rd_tte_tag_buf[13], // mxsel0 - b15:13 vld
        {8{tlb_rd_tte_tag_buf[53]}},                                        // (8b)
	// ECO 4265 end
        tlb_rd_tte_tag_buf[53:34],    // (20b)
        tlb_rd_tte_tag_buf[33:28],    // (6b)
        tlb_rd_tte_tag_buf[23:18],    // (6b)
        tlb_rd_tte_tag_buf[16:14],    // (3b)
        tlb_rd_tte_tag_buf[12:0] // (13b)
        } ;
/*
assign  formatted_tte_tag[63:0] =
        {
        {16{tlb_rd_tte_tag_buf[54]}},                                       // (16b)
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_47_22_HI:`STLB_TAG_VA_47_22_LO],    // (26b)
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_21_20_HI:`STLB_TAG_VA_21_20_LO],    // (3b)
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_19],
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_18_17_HI:`STLB_TAG_VA_18_17_LO],    // (3b)
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_16],
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_15_14_HI:`STLB_TAG_VA_15_14_LO],    // (3b)
        tlb_rd_tte_tag_buf[`STLB_TAG_VA_13],
        tlb_rd_tte_tag_buf[`STLB_TAG_CTXT_12_7_HI:`STLB_TAG_CTXT_12_7_LO],  // (13b)
        tlb_rd_tte_tag_buf[`STLB_TAG_CTXT_6_0_HI:`STLB_TAG_CTXT_6_0_LO]
        } ;
*/


//=================================================================================================
//      Format TLB Data 
//=================================================================================================

assign  formatted_tte_data[63:0] =
        {
        tlb_rd_tte_tag_buf[26],            // V    (1b)
        lsu_tte_pg_sz_b1_buf,                       // SZ   (2b)
        lsu_tte_pg_sz_b0_buf,
        tlb_rd_tte_data_buf[10],        // NFO  (1b)
        tlb_rd_tte_data_buf[9],         // IE   (1b)
        9'd0,         				    // Soft2
        1'b0,
        lsu_tte_pg_sz_b2_buf,                       // SZ   (1b)
        tlb_rd_tte_tag_buf[24],            // U    (1b)
	// ECO 4265 - begin
        tlb_rd_tte_data_buf[42],      // Parity   (1b)
        tlb_rd_tte_data_buf[23],   // mxsel2_l (1b)
        tlb_rd_tte_data_buf[16],   // mxsel1_l (1b)
        tlb_rd_tte_data_buf[12],   // mxsel0_l (1b)
        2'd0,                                        // Unused Diag bits
	// ECO 4265 - end 
        1'b0,                                        // PA   (28b)
        tlb_rd_tte_data_buf[41:30],
        tlb_rd_tte_data_buf[29:24],
        tlb_rd_tte_data_buf[22:17],
        tlb_rd_tte_data_buf[15:13],
        6'd0,                                   // ?? 12-7 (6b)
        tlb_rd_tte_data_buf[8],          // L    (1b)
        tlb_rd_tte_data_buf[7],         // CP   (1b)
        tlb_rd_tte_data_buf[6],         // CV   (1b)
        tlb_rd_tte_data_buf[5],          // E    (1b)
        tlb_rd_tte_data_buf[4],          // P    (1b)
        tlb_rd_tte_data_buf[3],          // W    (1b)
        1'b0
        } ;



wire [63:0] formatted_tte_csm;

assign formatted_tte_csm = 
        {
        32'b0,
        tlb_rd_tte_csm[31:22], 
        tlb_rd_tte_csm[21:16], 
        tlb_rd_tte_csm[15:6], 
        tlb_rd_tte_csm[5:0]
        };
        
/*
assign formatted_tte_csm = 
        {
        tlb_rd_tte_tag_buf[`STLB_TAG_V],            // V    (1b)
        lsu_tte_pg_sz_b1_buf,                       // SZ   (2b)
        lsu_tte_pg_sz_b0_buf,
        tlb_rd_tte_data_buf[`STLB_DATA_NFO],        // NFO  (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_IE],         // IE   (1b)
        9'd0,         				    // Soft2
        1'b0,
        lsu_tte_pg_sz_b2_buf,                       // SZ   (1b)
        tlb_rd_tte_tag_buf[`STLB_TAG_U],            // U    (1b)
	// ECO 4265 - begin
        tlb_rd_tte_data_buf[`STLB_DATA_PARITY],      // Parity   (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_27_22_SEL],   // mxsel2_l (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_21_16_SEL],   // mxsel1_l (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_15_13_SEL],   // mxsel0_l (1b)
        2'd0,                                        // Unused Diag bits
	// ECO 4265 - end 
        1'b0,                                      
        1'b0,                                       //TTE_CSM_RES1 
        tlb_rd_tte_csm[`TLB_CSM_SDID], 
        tlb_rd_tte_csm[`TLB_CSM_HDID], 
        tlb_rd_tte_csm[`TLB_CSM_LSID], 
        6'd0,                                   // ?? 12-7 (6b)
        tlb_rd_tte_data_buf[`STLB_DATA_L],          // L    (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_CP],         // CP   (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_CV],         // CV   (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_E],          // E    (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_P],          // P    (1b)
        tlb_rd_tte_data_buf[`STLB_DATA_W],          // W    (1b)
        1'b0
        };
*/
//CSM_CHANGE

//=================================================================================================
//      Select TLB Read data / TLB Read tag
//=================================================================================================


assign lsu_tlb_rd_data[63:0] =
                lsu_tlb_data_rd_vld_g ? formatted_tte_data[63:0] : 
                lsu_tlb_csm_rd_vld_g  ? formatted_tte_csm[63:0]  : formatted_tte_tag[63:0];





//=================================================================================================
//      Calculate parity for TLB Tag and Data
//=================================================================================================
   wire lsu_rd_tte_data_parity, lsu_rd_tte_tag_parity;
   
assign  lsu_rd_tte_data_parity = ^tlb_rd_tte_data_buf[41:0] ;
assign  lsu_rd_tte_tag_parity =  ^{tlb_rd_tte_tag_buf[58:55],tlb_rd_tte_tag_buf[53:27],
				tlb_rd_tte_tag_buf[25],tlb_rd_tte_tag_buf[23:0]} ;
 
assign  tte_data_parity_error = 
  tlb_rd_tte_data_parity ^ lsu_rd_tte_data_parity ;
assign  tte_tag_parity_error  = 
  tlb_rd_tte_tag_parity ^ lsu_rd_tte_tag_parity ;

   assign cache_way_hit_buf1[4-1:0] = cache_way_hit[4-1:0];
   assign cache_way_hit_buf2[4-1:0] = cache_way_hit[4-1:0];

   
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_pcx_qmon.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Monitors queue state of pcx.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                                        // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_pcx_qmon (/*AUTOARG*/
   // Outputs
   so, qwrite, sel_qentry0, 
   // Inputs
   rclk, grst_l, arst_l, si, se, send_by_pcx, send_to_pcx
   ) ;                                          

input           rclk ;
input           grst_l;
input           arst_l;
input           si;
input           se;
output          so;

input 	send_by_pcx ;		// PCX sends packet to dest.
input 	send_to_pcx ;		// SKB sends packet to PCX.
 	
output 	qwrite ;		// PCX queue is writable.
output 	sel_qentry0 ;		// entry to be written.

wire       clk;
wire 	reset ,dbb_reset_l ;
wire	entry0_rst, entry1_rst ;
wire	entry0_en, entry1_en ;
wire	entry0_din, entry1_din ;
wire	entry0_full,entry1_full;

    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

assign  reset =  ~dbb_reset_l;
assign  clk = rclk;


//======================================================================================
//
//	Queue Monitor 
//
//======================================================================================

//
//	Pipeline :
//--------------------------------------------------------------------------------------
//
//	| req to pcx 	| payload to pcx| 		|		|
//	| qfull=0	|   arb/grant=1 | 		|		|
//	| qentry=1	| 		| 		|		|
//	|		|	      	| 		|		|
//	|		| req to pcx 	| payload to pcx| 		|
//	|		| qfull=0	|   arb/grant=0	|		|
//	|		| qentry=2	|		|		|
//	|		|		| req to pcx 	| payload to pcx| 
//	|		|		| qfull=0	|     arb/grant	|
//
//	


// OPERATION :
// Monitors state per 2 input queue of pcx for given processor.
// - Implemented as FIFO.
// - The queue is cleared on reset. 
// - A packet sent from the core to pcx will set a bit in the 
// corresponding logical queue entry.
// - A packet sent from pcx to dest, will cause entry0 to be cleared.
// Only entry0 need be cleared as entry1 will shift to entry0 on
// a grant by the pcx.
// - The queue will never overflow as a packet will never be sent 
// from the skb to the pcx unless at least one queue entry is free.
// Timing : May have to flop grant and then use it.

assign entry0_rst = 	reset | 
			(send_by_pcx & ~entry0_en) ; 		// pcx sends to dest.
assign entry0_en  = 	( entry1_full & send_by_pcx)  	| 	// shift entry1 to entry0
			(~(entry0_full & ~send_by_pcx) & send_to_pcx) ;		
assign entry0_din = 	entry0_en ;

// represents oldest packet.
dffre_s  qstate_entry0 (
        .din    (entry0_din), .q  (entry0_full),
        .rst    (entry0_rst), .en (entry0_en), .clk (clk),
        .se     (1'b0),       .si (), 	       .so ()
        );

assign entry1_rst =	reset | 
			(send_by_pcx & ~entry1_en) ;
assign entry1_en  = 	entry0_full & send_to_pcx 
			& ~(send_by_pcx & ~entry1_full) ; // new packet to entry1
assign entry1_din = 	entry1_en ;

// represents youngest packet.
dffre_s  qstate_entry1 (
        .din    (entry1_din), .q  (entry1_full),
        .rst 	(entry1_rst), .en (entry1_en), 	.clk (clk),
        .se     (1'b0), .si     (), .so ()
        );

assign qwrite = ~entry1_full ; 
		//(entry1_full & send_by_pcx) ;		// look at top of stack only.
assign sel_qentry0 = 
	(~entry0_full & ~send_to_pcx) ; 
	//(~entry0_full | 
	//(~entry1_full & entry0_full & send_by_pcx)) & ~send_to_pcx ;					
									// select which entry to write.

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_rrobin_picker2.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Round-Robin Picker for 4 eventss.
//                      (see description of picker at the end of this file)
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                                        // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////    

module lsu_rrobin_picker2 (/*AUTOARG*/
   // Outputs
   so, pick_one_hot, 
   // Inputs
   rclk, grst_l, arst_l, si, se, events, events_picked, thread_force
   );

input           rclk ;
input           grst_l;
input           arst_l;
input           si;
input           se;
output          so;


input 	[3:0]	events ;		// multi-hot; events that could be chosen
input 	[3:0]	events_picked ;		// one-hot; events that were picked - same cycle as pick
input 	[3:0]	thread_force ;	        // multi-hot; thread events that have high priority

output 	[3:0]	pick_one_hot ;		// one-hot

wire         clk;
wire         reset,dbb_reset_l ;
   
wire  [3:0]  thread_force_pe_mask ;
wire  [3:0]  pick_thread_force_1hot ;
wire         thread_force_events_sel ;

wire  [3:0]  pick_rrobin_1hot, pick_rev_rrobin_1hot, pick_rrobin_1hot_mx ;
wire         events_pick_dir_d1 ;
wire         events_pick_dir ;
wire  [3:0]  pick_rrobin_status_or_one_hot ;
wire  [3:0]  pick_rrobin_din ;
wire  [3:0]  pick_rrobin ;
wire         pick_rrobin_reset ;
wire         pick_rrobin_dir_upd ;
wire  [3:0]  pick_rrobin_events ;

   

    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

assign  reset =  ~dbb_reset_l;
assign  clk = rclk;


//*******************************************************************************************************
//PICK  
//*******************************************************************************************************

   //pick for thread force events
assign	thread_force_events_sel = |(events[3:0] & thread_force[3:0]) ;

assign  thread_force_pe_mask[3:0]  =  events[3:0] & thread_force[3:0] ;
assign	pick_thread_force_1hot[0] = thread_force_pe_mask[0] ;
assign	pick_thread_force_1hot[1] = thread_force_pe_mask[1] & ~thread_force_pe_mask[0] ;
assign	pick_thread_force_1hot[2] = thread_force_pe_mask[2] & ~|thread_force_pe_mask[1:0] ;
assign	pick_thread_force_1hot[3] = thread_force_pe_mask[3] & ~|thread_force_pe_mask[2:0] ;

   //pick for round robin events
assign  pick_rrobin_events[3:0]  =  events[3:0] & ~pick_rrobin[3:0] ;

assign  pick_rrobin_1hot[0] = ~events_pick_dir_d1 & pick_rrobin_events[0] ;
assign	pick_rrobin_1hot[1] = ~events_pick_dir_d1 & pick_rrobin_events[1] & ~pick_rrobin_events[0] ;
assign	pick_rrobin_1hot[2] = ~events_pick_dir_d1 & pick_rrobin_events[2] & ~|pick_rrobin_events[1:0] ;
assign	pick_rrobin_1hot[3] = ~events_pick_dir_d1 & pick_rrobin_events[3] & ~|pick_rrobin_events[2:0] ;

   //pick for reverse round robin events
assign  pick_rev_rrobin_1hot[0] = events_pick_dir_d1 & pick_rrobin_events[0] & ~|pick_rrobin_events[3:1] ;
assign	pick_rev_rrobin_1hot[1] = events_pick_dir_d1 & pick_rrobin_events[1] & ~|pick_rrobin_events[3:2] ;
assign	pick_rev_rrobin_1hot[2] = events_pick_dir_d1 & pick_rrobin_events[2] & ~|pick_rrobin_events[3] ;
assign	pick_rev_rrobin_1hot[3] = events_pick_dir_d1 & pick_rrobin_events[3] ;

assign  pick_rrobin_1hot_mx[3:0]  =  pick_rev_rrobin_1hot[3:0] | pick_rrobin_1hot[3:0] ;
assign  pick_one_hot[3:0]    =  thread_force_events_sel ? pick_thread_force_1hot[3:0] : 
                                                          pick_rrobin_1hot_mx[3:0] ;

//*******************************************************************************************************



//*******************************************************************************************************
//PICK ROUND ROBIN (bug4814)
//*******************************************************************************************************
// this is used if there are no requests to be picked based on pick_status[3:0]

assign pick_rrobin_status_or_one_hot[3:0] = pick_rrobin[3:0] | events_picked[3:0] ;
assign pick_rrobin_reset = reset | ~|(events[3:0] & ~pick_rrobin_status_or_one_hot[3:0]) ;
   //change direction bit only when events are non-zero
assign pick_rrobin_dir_upd = |events[3:0] & (~|(events[3:0] & ~pick_rrobin_status_or_one_hot[3:0])) ;

   // make reset dominant
assign pick_rrobin_din[3:0] = pick_rrobin_status_or_one_hot[3:0] & ~{4{pick_rrobin_reset}};

dff_s   #(4) ff_pick_rrobin (
           .din    (pick_rrobin_din[3:0]),
           .q      (pick_rrobin[3:0]    ),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
            );
//*******************************************************************************************************


//*******************************************************************************************************
// PICK DIRECTION
//*******************************************************************************************************

   //bug4609 - change direction of pick all events are picked in round robin pick
   //          this is needed when the condition below occurs. assuming misc is less frequent
   //          this should pick load/store in round robin fashion
   //-------------------------------------------------------
   // cycle                 0   1   2
   //-------------------------------------------------------
   // history{misc,st,ld}  010 011 011
   // vld{misc,st,ld}      011 011 011
   //-------------------------------------------------------

assign events_pick_dir  =  ~reset &
                           (( ~pick_rrobin_dir_upd & events_pick_dir_d1) |		//hold
                            (  pick_rrobin_dir_upd & ~events_pick_dir_d1)) ;		//set - invert direction
   
   dff_s   #(1) ff_events_pick_dir (
        .din    (events_pick_dir),
        .q      (events_pick_dir_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );
   
//*******************************************************************************************************
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_stb_ctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	Control for STB of LSU
//				- Contains control for a single STB currently.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_stb_ctl (/*AUTOARG*/
   // Outputs
   so, stb_clk_en_l, stb_crnt_ack_id, lsu_stb_empty, stb_l2bnk_addr, 
   stb_atm_rq_type, stb_wrptr, stb_rd_for_pcx, stb_pcx_rptr, 
   stb_wrptr_prev, stb_state_ced_mod, stb_state_vld_out, 
   lsu_stbcnt, stb_rmo_st_issue, stb_full, st_pcx_rq_kill_w2, 
   // Inputs
   rclk, grst_l, arst_l, si, se, thrd_en_g, cpx_st_ack_tid, 
   pcx_rq_for_stb, st_ack_dq_stb, stb_flush_st_g, stb_cam_wvld_m, 
   lsu_blk_st_m, tlb_pgnum_g, pcx_req_squash, flshinst_rst, 
   lsu_stbctl_flush_pipe_w, flsh_inst_m, stb_state_si_0, 
   stb_state_si_1, stb_state_si_2, stb_state_si_3, stb_state_si_4, 
   stb_state_si_5, stb_state_si_6, stb_state_si_7, stb_state_rtype_0, 
   stb_state_rtype_1, stb_state_rtype_2, stb_state_rtype_3, 
   stb_state_rtype_4, stb_state_rtype_5, stb_state_rtype_6, 
   stb_state_rtype_7, stb_state_rmo, stb_alt_sel, stb_alt_addr, 
   lsu_dtlb_bypass_e, tlb_cam_hit, lsu_outstanding_rmo_st_max,
   st_dtlb_perr_g
   ) ;	


   input rclk ;			
   input grst_l;
   input arst_l;
   
   input si;
   input se;
   output so;
   
input		thrd_en_g ;
input		cpx_st_ack_tid ;	// st ack for given thread
input		pcx_rq_for_stb ;	// stb's st selected for read for pcx
input		st_ack_dq_stb ;		// store dequeued from stb
input		stb_flush_st_g ;	// flush stb write in cycle g
input		stb_cam_wvld_m ;	// stb write in cycle m

input		lsu_blk_st_m ;		// blk st wr

//input  [7:6]    lsu_ldst_va_m ;         // staging purposes
//input  [2:1]    lsu_st_rq_type_m ;	// st request type
//input		lsu_st_rmo_m ;		// rmo store in m-stage

input  [39:37]  tlb_pgnum_g ;  	        // ldst access to io 
input		pcx_req_squash ;	// pcx req is squashed

input		flshinst_rst ;		// reset by flush inst on return
input		lsu_stbctl_flush_pipe_w ;

   input flsh_inst_m;
   

//from stb_ctldp
   input [3:2] stb_state_si_0;
   input [3:2] stb_state_si_1;
   input [3:2] stb_state_si_2;
   input [3:2] stb_state_si_3;
   input [3:2] stb_state_si_4;
   input [3:2] stb_state_si_5;
   input [3:2] stb_state_si_6;
   input [3:2] stb_state_si_7;

   input [2:1] stb_state_rtype_0;
   input [2:1] stb_state_rtype_1;
   input [2:1] stb_state_rtype_2;
   input [2:1] stb_state_rtype_3;
   input [2:1] stb_state_rtype_4;
   input [2:1] stb_state_rtype_5;
   input [2:1] stb_state_rtype_6;
   input [2:1] stb_state_rtype_7;

   //input [7:0] stb_state_io;
   input [7:0] stb_state_rmo;

   input       stb_alt_sel ;
   input [2:0] stb_alt_addr ;

input          lsu_dtlb_bypass_e;
input          tlb_cam_hit;		// m-cycle

input		st_dtlb_perr_g ;	// enabled st dtlb parity err.
 
   //output      stb_non_l2bnk;
   output [7:0] stb_clk_en_l;
  
output  [2:0]   stb_crnt_ack_id ;       // ackid for current outstanding st.

output		lsu_stb_empty ;		// stb is empty

output	[2:0]	stb_l2bnk_addr ;	// l2bank address.	
output	[2:1]	stb_atm_rq_type ;	// identify atomic transaction

output	[2:0]	stb_wrptr ;		// write ptr - per thread
//output	[2:0]	stb_dfq_rptr ;		// rptr for dfq - per thread
output		stb_rd_for_pcx ; 	// rd vld for pcx - per thread
output	[2:0]	stb_pcx_rptr ;		// rptr for pcx - per thread
output	[2:0]	stb_wrptr_prev ;
output  [7:0]   stb_state_ced_mod ;
output  [7:0]   stb_state_vld_out ;

output	[3:0]	lsu_stbcnt ;	// # of vld entries

output		stb_rmo_st_issue ;		// rmo store issued from thread's stb.

output		stb_full ;
output		st_pcx_rq_kill_w2 ;

   input  lsu_outstanding_rmo_st_max;
   
   wire [7:0] stb_state_rst;
   
   wire [7:0] stb_state_vld;
   wire [7:0] stb_state_vld_din;
   wire [7:0] stb_state_vld_set;
   
   wire [7:0] stb_state_ced;
   wire [7:0] stb_state_ced_din;
   wire [7:0] stb_state_ced_set;

   wire [7:0] stb_state_ack;
   wire [7:0] stb_state_ack_din;
   wire [7:0] stb_state_ack_set;

   wire [3:2] stb_state_si_0;	// removed 8x4 bits
   wire [3:2] stb_state_si_1;
   wire [3:2] stb_state_si_2;
   wire [3:2] stb_state_si_3;
   wire [3:2] stb_state_si_4;
   wire [3:2] stb_state_si_5;
   wire [3:2] stb_state_si_6;
   wire [3:2] stb_state_si_7;
/*
   wire [3:2] stb_state_si_0_din;
   wire [3:2] stb_state_si_1_din;
   wire [3:2] stb_state_si_2_din;
   wire [3:2] stb_state_si_3_din;
   wire [3:2] stb_state_si_4_din;
   wire [3:2] stb_state_si_5_din;
   wire [3:2] stb_state_si_6_din;
   wire [3:2] stb_state_si_7_din;
*/   
   wire [7:0] stb_state_io;
   wire [7:0] stb_state_io_din;

   wire [7:0] stb_state_rmo;
//   wire [7:0] stb_state_rmo_din;
   
   wire [2:1] stb_state_rtype_0; // rm 8x1 bits
   wire [2:1] stb_state_rtype_1;
   wire [2:1] stb_state_rtype_2;
   wire [2:1] stb_state_rtype_3;
   wire [2:1] stb_state_rtype_4;
   wire [2:1] stb_state_rtype_5;
   wire [2:1] stb_state_rtype_6;
   wire [2:1] stb_state_rtype_7;
/*
   wire [2:1] stb_state_rtype_0_din;
   wire [2:1] stb_state_rtype_1_din;
   wire [2:1] stb_state_rtype_2_din;
   wire [2:1] stb_state_rtype_3_din;
   wire [2:1] stb_state_rtype_4_din;
   wire [2:1] stb_state_rtype_5_din;
   wire [2:1] stb_state_rtype_6_din;
   wire [2:1] stb_state_rtype_7_din;
*/
   wire [2:0] stb_l2bnk_addr;
   wire [2:1] stb_atm_rq_type;
      
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics
wire	[3:0]	stb_wptr_prev ;
wire		stb_rptr_dfq_en ;
wire		update_stb_wptr ;
//wire 	[1:0] 	st_enc_set_way ;
wire	[3:0]	stb_rptr_dfq_new, stb_rptr_dfq ;
wire 	valid_entry_for_pcx ;
wire	[7:0]	dec_wptr_g, dec_rptr_dfq, dec_rptr_pcx, dec_ackptr ;
wire	[7:0]	dec_wptr_m ;
//wire		stb_wvld_g ;
//wire	[5:0]	stb_inv_set0,stb_inv_set1;
//wire	[5:0]	stb_inv_set2,stb_inv_set3;

wire		ack_vld ;
wire	[3:0]	stb_wptr_new, stb_wptr ;	
wire		stb_cam_wvld_g ;
wire	[7:0] 	inflight_vld_g ;
wire		dq_vld_d1,dq_vld_d2 ;
wire	[7:0]	dqptr_d1,dqptr_d2;
wire		pcx_rq_for_stb_d1 ;
wire    	pcx_rq_for_stb_d2,pcx_req_squash_d2 ;

   wire       clk;
   assign     clk = rclk;

   wire       rst_l;
   wire       stb_ctl_rst_l;
   
   dffrl_async rstff(.din (grst_l),
                     .q   (stb_ctl_rst_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));
   assign     rst_l = stb_ctl_rst_l;
   
//=========================================================================================
//	RESET
//=========================================================================================

// A flush will reset the vld bit in the stb - it should be the only one as
// the stb has drained.

   wire   reset;
   //waiting int 3.0
   //assign rst_l = stb_ctl_rst_l;

   assign reset = ~rst_l | flshinst_rst ;

//=========================================================================================
//	STB READ FOR PCX
//=========================================================================================

// Assumes that an entry can be sent to the pcx iff the next oldest
// entry has received its ack. This pointer will not look for L2Bank
// overlap as the ptr calculation is much more complicated.

// (1)--> Entry must be valid and not already sent to pcx.
//		Includes squashing of speculative req
// (2)--> Previous in linked list must be valid and acked (or invalid)
// (3)--> This is to break the deadlock between oldest and youngest
// entries when queue is full. Oldest entry can always exit to pcx.

// This vector is one-hot. Assumption is that stb is a circular queue.
// deadlock has to be broken between oldest and youngest entry when the
// queue is full. The dfq ptr is used to mark oldest

dff_s #(2)  rq_stgd1       (
        .din    ({pcx_rq_for_stb_d1,pcx_req_squash}), 
        .q    	({pcx_rq_for_stb_d2,pcx_req_squash_d2}), 
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

wire	ffu_bst_wr_g ;
dff_s #(1)  ff_bstg       (
        .din    (lsu_blk_st_m),
        .q    	(ffu_bst_wr_g),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

wire	full_flush_st_g ;
// flush_pipe does not apply to blk st wr.
assign	full_flush_st_g = (stb_flush_st_g | (lsu_stbctl_flush_pipe_w & ~ffu_bst_wr_g)) & stb_cam_wvld_g ;

// timing fix: 5/6 -  begin
// qual dec_rptr_pcx w/ tlb camhit and in qctl1 move kill qual after store pick
wire      tlb_cam_hit_g, tlb_hit_g;
wire      dtlb_bypass_m, dtlb_bypass_g ;

dff_s #(1)  ff_dtlb_bypass_m       (
        .din    (lsu_dtlb_bypass_e),
        .q    	(dtlb_bypass_m),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

dff_s #(1)  ff_dtlb_bypass_g       (
        .din    (dtlb_bypass_m),
        .q    	(dtlb_bypass_g),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

dff_s #(1)  ff_tlb_cam_hit_g       (
        .din    (tlb_cam_hit),
        .q    	(tlb_cam_hit_g),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

assign  tlb_hit_g  =  tlb_cam_hit_g | dtlb_bypass_g | ffu_bst_wr_g; //bug6406/eco6610
// timing fix: 5/6 -  end

// st rq can now speculate on flush
assign	inflight_vld_g[7:0] = 
	dec_wptr_g[7:0] & {8{stb_cam_wvld_g & thrd_en_g}} ; 
	// the later term is for an inflight ld which gets squashed. It
	// should not effect dec_rptr_pcx. This is related to a timing fix
	// where the flush is taken out of inflight_vld_g.
//assign	inflight_vld_g[7:0] = dec_wptr_g[7:0] & {8{stb_wvld_g & thrd_en_g}} ;

//timing fix: 5/6/03 - kill inflight vld if tlb_hit_g=0; dec_rptr_pcx will be 0 and hence kill_w2 will be 0
// leave inflight_vld_g as is, since it is used to set squash - which eventually reset state_vld
wire [7:0] inflight_issue_g_tmp ;

assign  inflight_issue_g_tmp[7:0]  =  inflight_vld_g[7:0] & {8{tlb_hit_g}};

wire [7:0] inflight_issue_g ;
assign	inflight_issue_g[7:0] = 
	inflight_issue_g_tmp[7:0] & {8{~(|(stb_state_vld[7:0] & ~stb_state_ack[7:0]))}};  
	//inflight_vld_g[7:0] & {8{~(|(stb_state_vld[7:0] & ~stb_state_ack[7:0]))}};  // timing fix : 5/6


// Modified state ced includes in-flight pcx sel which is not squashed.
// Timing : pcx_req_squash delayed. A st that is squashed can then make a request 3-cycles
// later.
wire	skid_ced, st_vld_rq_d2 ;
assign	st_vld_rq_d2 = pcx_rq_for_stb_d2 & ~pcx_req_squash_d2 ;
assign	skid_ced = pcx_rq_for_stb_d1 | st_vld_rq_d2 ;
// For squashing rawp.
assign	stb_state_ced_mod[7:0] =
	((dec_ackptr[7:0] & {8{st_vld_rq_d2}}) | stb_state_ced[7:0]) ;

//RMO st counter satuated
   
wire  rmo_st_satuated;   
//dff #(1) rmo_st_satuated_ff  (
//    .din (lsu_outstanding_rmo_st_max),
//    .q   (rmo_st_satuated),
//    .clk    (clk),
//    .se     (se), .si     (), .so ()
//);
                          
   assign rmo_st_satuated  =  lsu_outstanding_rmo_st_max;
                      
wire	[7:0]	stb_state_ced_spec ;
assign	stb_state_ced_spec[7:0] =
	((dec_ackptr[7:0] & {8{skid_ced}}) | stb_state_ced[7:0]) | 
   (stb_state_rmo[7:0] & {8{rmo_st_satuated}});
   
assign 	dec_rptr_pcx[7:0] =
		 (inflight_issue_g[7:0] | stb_state_vld[7:0]) 
		 //(inflight_vld_g[7:0] | stb_state_vld[7:0]) 
			& ~stb_state_ced_spec[7:0] &	// -->(1)
		(({stb_state_vld[6:0],stb_state_vld[7]} &	// 
		  {stb_state_ack[6:0],stb_state_ack[7]}) // 
		| ~{stb_state_vld[6:0],stb_state_vld[7]}	// -->(2)
		| dec_rptr_dfq[7:0]) ;				// -->(3)


// There should be only one such entry i.e., the vector is 1-hot.
// Incorporate st dtlb parity error. It should not propagate to memory.
// Tracing full_flush_st_g, note that the pointers will not be restored
// correctly for timing reasons - anyway, this is considered unrecoverable.
// Monitor !
assign valid_entry_for_pcx = |dec_rptr_pcx[7:0] ;

wire	any_inflight_iss_g,any_inflight_iss_w2 ;
assign	any_inflight_iss_g = |inflight_vld_g[7:0] ;
wire	pick_inflight_iss_g,pick_inflight_iss_w2 ;
assign	pick_inflight_iss_g = |(dec_rptr_pcx[7:0] & inflight_issue_g[7:0]) ;

wire	st_pcx_rq_kill_g ;
assign	st_pcx_rq_kill_g = pick_inflight_iss_g & full_flush_st_g ;
//assign	st_pcx_rq_kill_g = (|(dec_rptr_pcx[7:0] & inflight_issue_g[7:0])) & full_flush_st_g ;

wire	st_vld_squash_g,st_vld_squash_w2 ;
assign	st_vld_squash_g = any_inflight_iss_g & full_flush_st_g ;
//assign	st_vld_squash_g = (|inflight_vld_g[7:0]) & full_flush_st_g ;

wire st_pcx_rq_kill_tmp,st_vld_squash_tmp ;
wire st_dtlb_perr_w2 ;
dff_s #(5)  stkill_stgd1       (
        .din    ({st_pcx_rq_kill_g,st_vld_squash_g,
		any_inflight_iss_g,pick_inflight_iss_g,st_dtlb_perr_g}), 
	.q      ({st_pcx_rq_kill_tmp,st_vld_squash_tmp,
		any_inflight_iss_w2,pick_inflight_iss_w2,st_dtlb_perr_w2}), 
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

assign	st_pcx_rq_kill_w2 = 
		st_pcx_rq_kill_tmp | 
		(pick_inflight_iss_w2 & st_dtlb_perr_w2); 

assign	st_vld_squash_w2  =
		st_vld_squash_tmp  |
		(any_inflight_iss_w2 & st_dtlb_perr_w2);


// Encode pcx rptr
// ** Timing : Could put flop in rwctl. 
assign stb_pcx_rptr[0] = dec_rptr_pcx[1] | dec_rptr_pcx[3] | dec_rptr_pcx[5] | dec_rptr_pcx[7] ;	
assign stb_pcx_rptr[1] = dec_rptr_pcx[2] | dec_rptr_pcx[3] | dec_rptr_pcx[6] | dec_rptr_pcx[7] ;	
assign stb_pcx_rptr[2] = dec_rptr_pcx[4] | dec_rptr_pcx[5] | dec_rptr_pcx[6] | dec_rptr_pcx[7] ;	

// This is used in qctl.
// Timing : flopped in qctl before use.
assign	stb_rd_for_pcx = valid_entry_for_pcx ; 

//=========================================================================================
//	STB READ FOR DFQ
//=========================================================================================


// Read Pointer to generate the next available entry for the dfq.
// Timing : This should be fine as st_ack_dq_stb is decode out of dfq byp flop.
wire	incr_dfq_ptr ;
// stb_rmo_st_issue added for rmo st bug - if critical then add flop.

// bug2983: incr_dfq_ptr is set by both st_ack_dq_stb and stb_rmo_st_issue
//          in the same cycle. this results in losing a dequeue.
//
//          fix is to detect rmo store after regular store. issue the rmo
//          store and dont reset the rmo store vld until the dequeue of the older
//          regular store.

wire    stb_dq_rmo ;

//assign	incr_dfq_ptr = st_ack_dq_stb | stb_rmo_st_issue ; //bug 2983
assign	incr_dfq_ptr = st_ack_dq_stb | stb_dq_rmo ;

assign	stb_rptr_dfq_new[3:0]	=	stb_rptr_dfq[3:0]  + {3'b0, incr_dfq_ptr} ;
//assign	stb_rptr_dfq_new[3:0]	=	stb_rptr_dfq[3:0]  + {3'b0, st_ack_dq_stb} ;

assign stb_rptr_dfq_en = st_ack_dq_stb | incr_dfq_ptr ; 

dffre_s #(4)  rptr_d	(
	.din		(stb_rptr_dfq_new[3:0]),.q	(stb_rptr_dfq[3:0]),
	.en		(stb_rptr_dfq_en),	.rst	(reset), 
	.clk		(clk), 
	.se		(se),	.si	(), .so	()
	);

//assign	stb_dfq_rptr[2:0] = stb_rptr_dfq_new[2:0] ;

// Decode Read Ptr
// Generated cycle before actual read.
assign	dec_rptr_dfq[0]	= ~stb_rptr_dfq[2] & ~stb_rptr_dfq[1] & ~stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[1]	= ~stb_rptr_dfq[2] & ~stb_rptr_dfq[1] &  stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[2]	= ~stb_rptr_dfq[2] &  stb_rptr_dfq[1] & ~stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[3]	= ~stb_rptr_dfq[2] &  stb_rptr_dfq[1] &  stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[4]	=  stb_rptr_dfq[2] & ~stb_rptr_dfq[1] & ~stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[5]	=  stb_rptr_dfq[2] & ~stb_rptr_dfq[1] &  stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[6]	=  stb_rptr_dfq[2] &  stb_rptr_dfq[1] & ~stb_rptr_dfq[0] ;	
assign	dec_rptr_dfq[7]	=  stb_rptr_dfq[2] &  stb_rptr_dfq[1] &  stb_rptr_dfq[0] ;

// Stge dfq ptr and dq vld by 2-cycles to appropriate invalidation pt
dff_s #(9)  dq_stgd1       (
        .din    ({dec_rptr_dfq[7:0],st_ack_dq_stb}), 
	.q      ({dqptr_d1[7:0],dq_vld_d1}),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

dff_s #(9)  dq_stgd2       (
        .din    ({dqptr_d1[7:0],dq_vld_d1}), 
	.q      ({dqptr_d2[7:0],dq_vld_d2}),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

//=========================================================================================
//	WPTR FOR STB
//=========================================================================================

// It is assumed that if there is a store in the pipe, there is a
// free entry in the corresponding stb. Otherwise, the pipe would've
// have stalled for the thread. This is maintained locally instead of in
// stb rw ctl.

// 00(flush,wr) - no update,01 - +1,10 - d1,11 - no update 
// cam or data wr ptr would do. 
//assign  update_stb_wptr         =       stb_cam_wvld_m |  stb_flush_st_g ;
assign  update_stb_wptr         =       stb_cam_wvld_m ^  (full_flush_st_g | st_dtlb_perr_g);

assign  stb_wptr_new[3:0]       =       (full_flush_st_g | st_dtlb_perr_g) ?
                                                        stb_wptr_prev[3:0] :
                                                        stb_wptr[3:0] + {3'b0, stb_cam_wvld_m} ;

dff_s  wvld_stgg       (
        .din    (stb_cam_wvld_m), .q      (stb_cam_wvld_g),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );


//assign	stb_wvld_g = stb_cam_wvld_g & ~full_flush_st_g ;

dffre_s #(4)  wptr_new    (
        .din            (stb_wptr_new[3:0]),    .q      (stb_wptr[3:0]),
        .en             (update_stb_wptr),    .rst    (reset),
        .clk            (clk),
        .se             (se), .si     (), .so ()
        );

assign	stb_wrptr[2:0]	= stb_wptr[2:0] ;

wire [2:0] stb_wptr_m ;
// flush should not be required. If the previous st is flushed then
// the current st should be invalid.
assign  stb_wptr_m[2:0]       =      stb_wptr[2:0] ;
/*assign  stb_wptr_m[3:0]       =       (full_flush_st_g) ?
                                                        stb_wptr_prev[3:0] :
                                                        stb_wptr[3:0] ;*/

// Decode wptr
assign	dec_wptr_m[0] = ~stb_wptr_m[2] & ~stb_wptr_m[1] & ~stb_wptr_m[0] ;	
assign	dec_wptr_m[1] = ~stb_wptr_m[2] & ~stb_wptr_m[1] &  stb_wptr_m[0] ;	
assign	dec_wptr_m[2] = ~stb_wptr_m[2] &  stb_wptr_m[1] & ~stb_wptr_m[0] ;	
assign	dec_wptr_m[3] = ~stb_wptr_m[2] &  stb_wptr_m[1] &  stb_wptr_m[0] ;	
assign	dec_wptr_m[4] =  stb_wptr_m[2] & ~stb_wptr_m[1] & ~stb_wptr_m[0] ;	
assign	dec_wptr_m[5] =  stb_wptr_m[2] & ~stb_wptr_m[1] &  stb_wptr_m[0] ;	
assign	dec_wptr_m[6] =  stb_wptr_m[2] &  stb_wptr_m[1] & ~stb_wptr_m[0] ;	
assign	dec_wptr_m[7] =  stb_wptr_m[2] &  stb_wptr_m[1] &  stb_wptr_m[0] ;

dff_s #(8)  dwptr_stgg       (
        .din    (dec_wptr_m[7:0]), .q      (dec_wptr_g[7:0]),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

// stb_wptr_prev represents the latest valid entry in stb
/*dffre #(4)  wptr_prev   (
        .din            (stb_wptr[3:0]),        .q      (stb_wptr_prev[3:0]),
        .en             (update_stb_wptr),      .rst    (reset),
        .clk            (clk),
        .se             (se), .si     (), .so ()
        );*/

assign	stb_wptr_prev[3:0] = stb_wptr[3:0] - {4'b0001} ;

// Bug 2419 - In case this is a critical path, a flop can be inserted.
assign	stb_wrptr_prev[2:0]	= stb_wptr_prev[2:0] ;

//=========================================================================================
//	# OF STORES IN STB
//=========================================================================================

wire	[3:0]	stb_wptr_w2 ;

// Count should not include stores in pipe-stages 'g' or before.
dff_s #(4)  wptr_stgw2       (
        .din    (stb_wptr[3:0]), .q      (stb_wptr_w2[3:0]),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

assign	lsu_stbcnt[3:0] =  (stb_wptr_w2[3:0] - stb_rptr_dfq[3:0]) ;

// Performance Cntr Info
wire	stb_full_w2 ;
assign	stb_full_w2 = lsu_stbcnt[2] & lsu_stbcnt[1] & lsu_stbcnt[0] ;
dff_s   sfull (
        .din    (stb_full_w2), .q      (stb_full),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

//=========================================================================================
//	CONTROL STATE
//=========================================================================================

// (V) 	-	Valid State. Initialized by write and cleared once entry
// 		has written DFQ and then written the cache. If the store
//		will only bypass then it still needs to enter DFQ but 
//		can be deallocated immediately on entry into DFQ. (1b)
// (A)	-	(NA) Allocate. Determined on read of cache. May be modified by
//		invalidate or st mv'ing to DFQ. The load woust have to
//		have same set index and same replacement way to clear A bit. (1b)
// (SI) -	cache set index for invalidate/load cam'ing. (6b)
// (WY) -	(NA) Allocate way for store. (2b)
// (CED) -	Committed to SKB. Entry written to SKB. (1b)
// (ACK) - 	Ack for store received from L2. (1b)
// (UPD) -	(NA) Entry mv'ed to DFQ. (1b)
// (W)   -  	(NA) Wrap bit. (1b) <--- Not used
// * All state needs to be reset when entry is freed.
//
// Total - 14b.

// ack_id is internally tracked. 
// There can only be one outstanding
dffre_s #(8)  ackptr_ff	(
	.din		(dec_rptr_pcx[7:0]), .q	(dec_ackptr[7:0]),
	.en		(pcx_rq_for_stb), .rst (reset),
	.clk		(clk), 
	.se		(se),	.si	(), .so	()
	);

   
assign 	ack_vld = cpx_st_ack_tid ;
//assign	st_dc_hit_g = lsu_st_hit_g ;

assign  stb_crnt_ack_id[0] = dec_ackptr[1] | dec_ackptr[3] |
                                dec_ackptr[5] | dec_ackptr[7] ;
assign  stb_crnt_ack_id[1] = dec_ackptr[2] | dec_ackptr[3] |
                                dec_ackptr[6] | dec_ackptr[7] ;
assign  stb_crnt_ack_id[2] = dec_ackptr[4] | dec_ackptr[5] |
                                dec_ackptr[6] | dec_ackptr[7] ;       

// Decode valid dequeue ids arriving from dfq.

// pa[39:36] 
// 0x00-0x7f  dram
// 0xa0-0xbf  l2csr
// others as non l2 accsess = b39 & ~(~b38 & b37)   
// timing fix: stb_non_l2bnk is delayed 1 cycle - gen in w/g cycle
//assign	stb_non_l2bnk = stb_alt_sel ?
//	stb_alt_addr[2] & ~(~stb_alt_addr[1] & stb_alt_addr[0]) :
//	tlb_pgnum_m[39]  & ~(~tlb_pgnum_m[38]  & tlb_pgnum_m[37])  & ~flsh_inst_m;

wire   [2:0]  stb_alt_addr_g;
wire          stb_alt_sel_g;

dff_s #(4) ff_alt_addr_g       (
        .din    ({stb_alt_sel,stb_alt_addr[2:0]}), 
        .q      ({stb_alt_sel_g,stb_alt_addr_g[2:0]}),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

wire  flsh_inst_g;
dff_s #(1) ff_flsh_inst_g       (
        .din    (flsh_inst_m),
        .q      (flsh_inst_g),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

wire   stb_alt_io_g , tlb_pgnum_io_g ;

assign  stb_alt_io_g  =  
        stb_alt_addr_g[2] & ~(~stb_alt_addr_g[1] & stb_alt_addr_g[0]);
assign  tlb_pgnum_io_g  =  
        tlb_pgnum_g[39]  & ~(~tlb_pgnum_g[38]  & tlb_pgnum_g[37])  & ~flsh_inst_g;

// used as input to state_io in stb_ctldp
wire   stb_non_l2bnk_g;
assign  stb_non_l2bnk_g  =  
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

// used as output to qctl1 - this has to be qual'ed w/dec_rptr_pcx so no x's propagate
//alt_sel_g  state_vld  comment
// 0         0          select tlb_pgnum_io_g(bypass)
// 0         1          select stb_state_io
// 1         0          select stb_alt_io_g
// 1         1          select stb_alt_io_g

wire  [7:0]  stb_l2bnk_addr_b2;

//  inflight (stb_alt / tlb)
//  stb
//  bug3875       
assign  stb_l2bnk_addr_b2[0]  =  
     stb_state_vld[0] ? stb_state_io[0] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[1]  =  
     stb_state_vld[1] ? stb_state_io[1] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[2]  =  
     stb_state_vld[2] ? stb_state_io[2] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[3]  =  
     stb_state_vld[3] ? stb_state_io[3] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[4]  =  
     stb_state_vld[4] ? stb_state_io[4] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[5]  =  
     stb_state_vld[5] ? stb_state_io[5] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[6]  =  
     stb_state_vld[6] ? stb_state_io[6] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;

assign  stb_l2bnk_addr_b2[7]  =  
     stb_state_vld[7] ? stb_state_io[7] :
        stb_alt_sel_g ? stb_alt_io_g :
                        tlb_pgnum_io_g ;


dff_s  rqsel_stgg       (
        .din    (pcx_rq_for_stb), .q      (pcx_rq_for_stb_d1),
        .clk    (clk),
        .se     (se), .si     (), .so ()
        );

// Use of tlb_pgnum_m will be critical !!! 

//always @( posedge clk)
//	begin
//	for (i=0;i<8;i=i+1) 	
//		begin
//			if (reset                                                 // reset
//                                | (dqptr_d2[i] & dq_vld_d2)                  	  // dequeue from stb
//				  | (dec_ackptr[i] & pcx_rq_for_stb_d1 & 
//						~pcx_req_squash & stb_state_rmo[i])) 
//				// write will be visible in cache.
//				begin
//					stb_state_vld[i] <= 1'b0 ;
//					stb_state_ced[i] <= 1'b0 ;
//					stb_state_ack[i] <= 1'b0 ;
//				end
//			if (dec_wptr_g[i] & stb_wvld_g & thrd_en_g )
//				begin
//					stb_state_vld[i] <= 1'b1 ;
//					stb_state_wy[i] <=  st_enc_set_way[1:0];
//				end
//			if (dec_wptr_m[i] & stb_cam_wvld_m)	// spec. write
//				begin
//					stb_state_si[i] <=  lsu_ldst_va_m[9:4] ;
//					stb_state_rtype[i] <= lsu_st_rq_type_m[2:0] ;
//					stb_state_io[i] <=  non_l2bnk ;
//					stb_state_rmo[i] <= lsu_st_rmo_m ;
//				end
//			// atomic will not write to cache even if it hits.
//			// rd_for_pcx needs to be gated for a cycle.
//			// This is delayed by a cycle to take into account
//			// squashing of speculative requests.
//			// rmo's will dequeue entry immediately.
//			if (dec_ackptr[i] & pcx_rq_for_stb_d1 & ~pcx_req_squash & ~stb_state_rmo[i]) 
//				stb_state_ced[i] = 1'b1 ;
//			if (dec_ackptr[i] & ack_vld)
//				stb_state_ack[i] = 1'b1 ;
			
//		end
//	end

// UNIFY : mux select destination address of pcx pkt

// always->dff translation begin

   // =================================
   // rst  set  din
   // 0    0    q
   // 1    0    0 (reset)
   // x    1    1 (set)
   // ==================================
   // din = set | (~r & q)

   //vld 
   wire	[7:0]	stb_issue_rmo ;
   wire	[7:0]	flush_vld_w2 ;
   // Timing 
   assign	stb_issue_rmo[7:0] = 
	(dec_ackptr[7:0] & {8{st_vld_rq_d2}} & stb_state_rmo[7:0]) ;
	// (dec_ackptr[7:0] & {8{pcx_rq_for_stb_d1}} & 
	//	{8{~pcx_req_squash}} & stb_state_rmo[7:0]) ;
   assign	stb_rmo_st_issue = |stb_issue_rmo[7:0] ;

   //bug2983 - begin
   wire        rmo_pend,rmo_pend_d1;
   wire [7:0]  rmo_pend_ackptr , stb_dq_rmo_dfq_ptr;
   // this will set 1 cycle after pcx_rq_for_stb and before the corresponding ced is set(which is 2 cycles
   // after pcx_rq_for_stb
   //bug3249: dec_rptr_dfq catches up w/ dec_ackptr; i.e. dec_ackptr entry is the oldset. rmo_pend should not
   //         be set in this case based on previuos entry (since it will be the youngest)
   //         fix - kill pend if issue and dq ptr are same (~{8{|(dec_ackptr[7:0] & dec_rptr_dfq[7:0])}})
   assign rmo_pend_ackptr[7:0]  =
          // is the current req RMO store
          //(dec_ackptr[7:0] & stb_state_rmo[7:0]) &  //bug3249
          //(dec_ackptr[7:0] & stb_state_rmo[7:0] & ~dec_rptr_dfq[7:0]) &    //bug7100 new fix, bug7117
          (dec_ackptr[7:0] & stb_state_rmo[7:0] & ~dqptr_d2[7:0]) & 
          // is the older store a regular store
          ({stb_state_vld[6:0],stb_state_vld[7]} & ~{stb_state_rmo[6:0],stb_state_rmo[7]});

   assign rmo_pend = |rmo_pend_ackptr[7:0];

   wire   rmo_pend_rst;
   assign rmo_pend_rst  =  reset | stb_dq_rmo;

   dffre_s #(1)  ff_rmo_pend      (
         .din  (rmo_pend),
         .q    (rmo_pend_d1),
         .en   (st_vld_rq_d2),      
         .rst  (rmo_pend_rst),
         .clk  (clk),
         .se   (se), .si     (), .so ()
         );

   // ok to use either dec_ackptr[7:0] OR dec_rptr_dfq[7:0] 'cos the stores younger to 1st RMO store
   // are not issued ('cos vld of RMO store is not reset). Hence ackptr and rptr_dfq will be the same
   // when rmo_pend=0.
   //
   // has to qual'ed w/ st_vld_rq_d2. otherwise can result in vld reset before ced is set. the next
   // time the entry is used it will have ced=1 and not issue.
   //
   // cannot use rmo_pend_ackptr[7:0] instead of dec_ackptr[7:0] 'cos the former will be reset when
   // rmo_pend=0 and will not dequeue the rmo stb entry. i.e if rmo_pend=1 when st_vld_rq_d2=1, use
   // dec_ackptr[7:0]

   //------------------------------------------------------------------------------------------------
   // Case 1: NO older regular store vld dequeue pending
   //------------------------------------------------------------------------------------------------
   // |        1           |    2    |    3    |    4     |     5    |          |          |
   // stb_state_vld=8'h1------------------------------------->8'h0
   // stb_state_rmo=8'h1
   //
   // pcx_rq_for_stb=1-------->0                     
   //
   // dec_ackptr=8'h0--------->8'h1
   //
   // st_vld_rq_d2=0--------------------->1           0
   // stb_issue_rmo=8'h0-------------->8'h1        8'h0
   // stb_dq_rmo_dfq_ptr=8'h0--------->8'h1       8'h0
   //
   // rmo_pend=0
   // rmo_pend_d1=0
   //
   // dq_vld_d2=0
   // dqptr_d2=8'h0
   //------------------------------------------------------------------------------------------------
   // Case 2: older regular store vld dequeue pending(entry0-older reg store; entry1-rmo younger store)
   //------------------------------------------------------------------------------------------------
   // |        1              |    2     |   3    |    4    |    5    |    6    |          | 
   // stb_state_vld=8'h3-------------------------------------->8'h2      8'h0
   // stb_state_rmo=8'h2
   // stb_state_ack=8'h1-------------------------------------->8'h0
   //
   // pcx_rq_for_stb=1-------------->0                     
   //
   // dec_ackptr=8'h1------------>8'h2
   //
   // st_vld_rq_d2=0-------------------------->1        0
   // stb_issue_rmo=8'h0------------------->8'h1     8'h0
   // stb_dq_rmo_dfq_ptr=8'h0--------------------------------->8'h2      8'h0 (dequeue rmo store)
   //
   // rmo_pend=0-------------------->1                           0
   // rmo_pend_d1=0--------------------------->1                            0
   //
   // dq_vld_d2=0-------------------------------------->1        0
   // dqptr_d2=8'h0--------------------------------->8'h1     8'h0 (dequeue regular store)
   //------------------------------------------------------------------------------------------------

   assign stb_dq_rmo_dfq_ptr[7:0] = 
          (stb_issue_rmo[7:0]   & ~rmo_pend_ackptr[7:0]) |         // if rmo_pend=0 when st_vld_rq_d2=1
          (dec_ackptr[7:0]      & {8{rmo_pend_d1 & ~rmo_pend}});   // if rmo_pend=1 when st_vld_rq_d2=1

   assign stb_dq_rmo  =  |stb_dq_rmo_dfq_ptr[7:0];
   //bug2983 - end

   assign stb_state_rst[7:0] = 
	{8{reset}} | (dqptr_d2[7:0] & {8{dq_vld_d2}})
	// reset vld,ced,ack immed. on issue to pcx for rmo store.
	| stb_dq_rmo_dfq_ptr[7:0] |  // fix for bug2983
	// | stb_issue_rmo[7:0] |  // bug2983
        flush_vld_w2[7:0] ;	// because of trap

   // vld is now speculatively written
   assign stb_state_vld_set[7:0] = dec_wptr_g[7:0] & {8{stb_cam_wvld_g & thrd_en_g}} ;
   //assign stb_state_vld_set[7:0] = dec_wptr_g[7:0] & {8{stb_wvld_g & thrd_en_g}} ;
   assign stb_state_vld_din[7:0] = stb_state_vld_set[7:0] | 
                                  (~stb_state_rst[7:0] & stb_state_vld[7:0]);
  
   wire	[7:0] stb_state_vld_tmp ; 
   dff_s #(8)  ff_stb_state_vld       (
        .din    (stb_state_vld_din[7:0]), 
        .q      (stb_state_vld_tmp[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );
	
   assign stb_state_vld[7:0] = stb_state_vld_tmp[7:0] & ~flush_vld_w2[7:0] ;

   wire	[7:0] stb_state_vld_set_w2 ;
   dff_s #(8)  ff_stb_state_vld_set       (
        .din    (stb_state_vld_set[7:0]), 
        .q      (stb_state_vld_set_w2[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );

   assign flush_vld_w2[7:0] = stb_state_vld_set_w2[7:0] & {8{st_vld_squash_w2}} ;

   // The stb valids for the scm need not include the intermediate flush condition
   // (flush_vld_w2). It is assumed that the flush of the store will invalidate 
   // a subsequent ld. (8 extra flops).
   // Bug 3201 - rmo st are made invisible to loads.
   
   wire [7:0]  st_scm_vld ;
   assign st_scm_vld[7:0] = stb_state_vld_din[7:0] & ~stb_state_rmo[7:0] ;
   
   dff_s #(8)  ff_st_scm_vld       (
        .din    (st_scm_vld[7:0]), 
        .q      (stb_state_vld_out[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );

   //ced
   assign stb_state_ced_set[7:0] = dec_ackptr[7:0] & {8{st_vld_rq_d2}} ;
   // Timing fix.
   //assign stb_state_ced_set[7:0] = dec_ackptr[7:0] & {8{pcx_rq_for_stb_d1 & ~pcx_req_squash}};
   // make reset dominant - specifically for coincident set and reset by rmo st.
   assign stb_state_ced_din[7:0] = ~stb_state_rst[7:0] & 
					(stb_state_ced_set[7:0] | stb_state_ced[7:0]);
   //assign stb_state_ced_din[7:0] = stb_state_ced_set[7:0] | 
   //                               (~stb_state_rst[7:0] & stb_state_ced[7:0]);
   
   dff_s #(8)  ff_stb_state_ced       (
        .din    (stb_state_ced_din[7:0]), 
        .q      (stb_state_ced[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );

   //ack
   assign stb_state_ack_set[7:0] = dec_ackptr[7:0] & {8{ack_vld}};
   assign stb_state_ack_din[7:0] = stb_state_ack_set[7:0] | 
                                  (~stb_state_rst[7:0] & stb_state_ack[7:0]);
   
   dff_s #(8)  ff_stb_state_ack       (
        .din    (stb_state_ack_din[7:0]), 
        .q      (stb_state_ack[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );

   //spec. write
   wire [7:0] spec_wrt;   
   assign     spec_wrt [7:0] = dec_wptr_m[7:0] & {8{stb_cam_wvld_m}};
   assign     stb_clk_en_l [7:0] = ~spec_wrt[7:0];

  //spec write Ffs move to lsu_stb_ctldp to save area      
 

  // moved state_io logic from ctldp 

  assign stb_state_io_din[7:0]  =  (stb_state_vld_set[7:0] & {8{stb_non_l2bnk_g}}) |
                                   (~stb_state_rst[7:0] & stb_state_io[7:0]);

   dff_s #(8)  ff_stb_state_io       (
        .din    (stb_state_io_din[7:0]), 
        .q      (stb_state_io[7:0]    ),
        .clk    (clk),
        .se     (se), .si (), .so ()
        );

// always->dff translation end    
// streaming unit does not have to care about outstanding rmo sparc-stores.
// membar will take care of that. spu must insert appr. delay in sampling signal.
assign	lsu_stb_empty = ~(|stb_state_vld[7:0]);

//=========================================================================================
//	SELECT L2BANK ADDRESS
//=========================================================================================

//reg [5:0] temp ;
//reg [2:0] stb_l2bnk_addr ;

//// This is modelling a mux. 
//always @(/*AUTOSENSE*/ /*memory or*/ dec_rptr_pcx)
//	begin
//		for (j=0;j<8;j=j+1) 	
//			if (dec_rptr_pcx[j])	// 1-hot
//				begin
//				temp[5:0] 		= stb_state_si[j] ;
//				stb_l2bnk_addr[2:0] 	= {stb_state_io[j],temp[4:3]} ;
//				stb_atm_rq_type[2:0] 	= stb_state_rtype[j] ;
//				end
//	end


//always->and-or translation begin
   assign stb_l2bnk_addr[2:0] = {3{dec_rptr_pcx[0]}} & {stb_l2bnk_addr_b2[0], stb_state_si_0[3:2]} |
                                {3{dec_rptr_pcx[1]}} & {stb_l2bnk_addr_b2[1], stb_state_si_1[3:2]} |
                                {3{dec_rptr_pcx[2]}} & {stb_l2bnk_addr_b2[2], stb_state_si_2[3:2]} |
                                {3{dec_rptr_pcx[3]}} & {stb_l2bnk_addr_b2[3], stb_state_si_3[3:2]} |
                                {3{dec_rptr_pcx[4]}} & {stb_l2bnk_addr_b2[4], stb_state_si_4[3:2]} |
                                {3{dec_rptr_pcx[5]}} & {stb_l2bnk_addr_b2[5], stb_state_si_5[3:2]} |
                                {3{dec_rptr_pcx[6]}} & {stb_l2bnk_addr_b2[6], stb_state_si_6[3:2]} |
                                {3{dec_rptr_pcx[7]}} & {stb_l2bnk_addr_b2[7], stb_state_si_7[3:2]} ;
   
   assign stb_atm_rq_type[2:1]= {2{dec_rptr_pcx[0]}} &  stb_state_rtype_0[2:1] |
                                {2{dec_rptr_pcx[1]}} &  stb_state_rtype_1[2:1] |
                                {2{dec_rptr_pcx[2]}} &  stb_state_rtype_2[2:1] |
                                {2{dec_rptr_pcx[3]}} &  stb_state_rtype_3[2:1] |
                                {2{dec_rptr_pcx[4]}} &  stb_state_rtype_4[2:1] |
                                {2{dec_rptr_pcx[5]}} &  stb_state_rtype_5[2:1] |
                                {2{dec_rptr_pcx[6]}} &  stb_state_rtype_6[2:1] |
                                {2{dec_rptr_pcx[7]}} &  stb_state_rtype_7[2:1] ;
   
//always->and-or translation end
          
   
endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_stb_ctldp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//PITON_PROTO enables all FPGA related modifications





module lsu_stb_ctldp (/*AUTOARG*/
   // Outputs
   so, stb_state_si_0, stb_state_si_1, stb_state_si_2, 
   stb_state_si_3, stb_state_si_4, stb_state_si_5, stb_state_si_6, 
   stb_state_si_7, stb_state_rtype_0, stb_state_rtype_1, 
   stb_state_rtype_2, stb_state_rtype_3, stb_state_rtype_4, 
   stb_state_rtype_5, stb_state_rtype_6, stb_state_rtype_7, 
   stb_state_rmo, 
   // Inputs
   rclk, si, se, stb_clk_en_l, lsu_stb_va_m, lsu_st_rq_type_m, 
   lsu_st_rmo_m
   );
   
   input rclk;
   input si;
   input se;
//   input tmb_l;

   output so;
   
   input [7:0] stb_clk_en_l;

   input [7:6] lsu_stb_va_m;
   input [2:1] lsu_st_rq_type_m;
   input       lsu_st_rmo_m;

   output [3:2] stb_state_si_0;
   output [3:2] stb_state_si_1;
   output [3:2] stb_state_si_2;
   output [3:2] stb_state_si_3;
   output [3:2] stb_state_si_4;
   output [3:2] stb_state_si_5;
   output [3:2] stb_state_si_6;
   output [3:2] stb_state_si_7;

   output [2:1] stb_state_rtype_0;
   output [2:1] stb_state_rtype_1;
   output [2:1] stb_state_rtype_2;
   output [2:1] stb_state_rtype_3;
   output [2:1] stb_state_rtype_4;
   output [2:1] stb_state_rtype_5;
   output [2:1] stb_state_rtype_6;
   output [2:1] stb_state_rtype_7;

   output [7:0] stb_state_rmo;
   

   wire [7:0] stb_clk;

   wire       clk;
   assign     clk = rclk;
   


   clken_buf stb0_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[0]),
                .tmb_l  (~se),
                .clk    (stb_clk[0])
                ) ;




   clken_buf stb1_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[1]),
                .tmb_l  (~se),
                .clk    (stb_clk[1])
                ) ;




   clken_buf stb2_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[2]),
                .tmb_l  (~se),
                .clk    (stb_clk[2])
                ) ;




   clken_buf stb3_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[3]),
                .tmb_l  (~se),
                .clk    (stb_clk[3])
                ) ;




   clken_buf stb4_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[4]),
                .tmb_l  (~se),
                .clk    (stb_clk[4])
                ) ;




   clken_buf stb5_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[5]),
                .tmb_l  (~se),
                .clk    (stb_clk[5])
                ) ;




   clken_buf stb6_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[6]),
                .tmb_l  (~se),
                .clk    (stb_clk[6])
                ) ;




   clken_buf stb7_clkbuf (
                .rclk   (clk),
                .enb_l  (stb_clk_en_l[7]),
                .tmb_l  (~se),
                .clk    (stb_clk[7])
                ) ;


   
   










  dff_s #(5)  ff_spec_write_0         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                      lsu_st_rmo_m}),
        .q      ({stb_state_si_0[3:2], stb_state_rtype_0[2:1],     
		                       stb_state_rmo[0]}    ),
        .clk    (stb_clk[0]),
        .se     (se), .si (), .so ()
        );












  dff_s #(5)  ff_spec_write_1         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                      lsu_st_rmo_m}),
        .q      ({stb_state_si_1[3:2], stb_state_rtype_1[2:1],     
		                   stb_state_rmo[1]}    ),
        .clk    (stb_clk[1]),
        .se     (se), .si (), .so ()
        );












  dff_s #(5)  ff_spec_write_2         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_2[3:2], stb_state_rtype_2[2:1],     
		                   stb_state_rmo[2]}    ),
        .clk    (stb_clk[2]),
        .se     (se), .si (), .so ()
        );











  dff_s #(5)  ff_spec_write_3         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_3[3:2], stb_state_rtype_3[2:1],     
		                   stb_state_rmo[3]}    ),
        .clk    (stb_clk[3]),
        .se     (se), .si (), .so ()
        );











  dff_s #(5)  ff_spec_write_4         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_4[3:2], stb_state_rtype_4[2:1],     
		                   stb_state_rmo[4]}    ),
        .clk    (stb_clk[4]),
        .se     (se), .si (), .so ()
        );











  dff_s #(5)  ff_spec_write_5         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_5[3:2], stb_state_rtype_5[2:1],     
		                   stb_state_rmo[5]}    ),
        .clk    (stb_clk[5]),
        .se     (se), .si (), .so ()
        );











  dff_s #(5)  ff_spec_write_6         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_6[3:2], stb_state_rtype_6[2:1],     
		                   stb_state_rmo[6]}    ),
        .clk    (stb_clk[6]),
        .se     (se), .si (), .so ()
        );












  dff_s #(5)  ff_spec_write_7         (
        .din    ({lsu_stb_va_m[7:6], lsu_st_rq_type_m[2:1], 
		                    lsu_st_rmo_m}),
        .q      ({stb_state_si_7[3:2], stb_state_rtype_7[2:1],     
              		     stb_state_rmo[7]}    ),
        .clk    (stb_clk[7]),
        .se     (se), .si (), .so ()
        );



endmodule // lsu_stb_ctldp
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_stb_rwctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////
/*
//  Description:  Control for Unified STB CAM/DATA of LSU
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
          // time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_stb_rwctl (/*AUTOARG*/
   // Outputs
   so, lsu_stbctl_flush_pipe_w, stb_cam_wr_no_ivld_m, 
   ld_rawp_st_ced_w2, stb_data_wr_ptr, stb_data_wptr_vld, 
   stb_data_rd_ptr, stb_data_rptr_vld, stb_wdata_ramd_b75_b64, 
   stb_cam_cm_tid, stb_ldst_byte_msk, stb_ldst_byte_msk_min, 
   stb_cam_rw_ptr, stb_cam_wptr_vld, stb_cam_rptr_vld, 
   lsu_st_sz_bhww_m, lsu_st_sz_dw_m, lsu_st_sz_bhw_m, 
   lsu_st_sz_wdw_m, lsu_st_sz_b_m, lsu_st_sz_w_m, lsu_st_sz_hw_m, 
   lsu_st_sz_hww_m, ld_rawp_st_ackid_w2, stb_flush_st_g, 
   stb_cam_wvld_m, lsu_st_rq_type_m, lsu_stb_data_early_sel_e, 
   lsu_stb_data_final_sel_m, lsu_ldquad_inst_m, stb_thrd_en_g, 
   flsh_inst_m, lsu_stb_va_m, lsu_stb_empty_buf, lsu_spu_stb_empty, 
   ifu_tlu_inst_vld_m_bf1, ifu_tlu_inst_vld_m_bf2, lsu_ifu_stbcnt0, 
   lsu_ifu_stbcnt1, lsu_ifu_stbcnt2, lsu_ifu_stbcnt3, 
   lsu_ffu_stb_full0, lsu_ffu_stb_full1, lsu_ffu_stb_full2, 
   lsu_ffu_stb_full3, 
   // Inputs
   rclk, rst_tri_en, si, se, ld_inst_vld_e, ldst_sz_e, st_inst_vld_e, 
   stb_pcx_rptr0, stb_wrptr0, stb_pcx_rptr1, stb_wrptr1, 
   stb_pcx_rptr2, stb_wrptr2, stb_pcx_rptr3, stb_wrptr3, 
   stb_cam_hit_ptr, stb_cam_hit, lsu_ldst_va_m, sta_internal_m, 
   ifu_tlu_thrid_e, tlu_exu_early_flush_pipe_w, lsu_ttype_vld_m2, 
   ifu_lsu_flush_w, lsu_defr_trp_taken_g, ifu_lsu_casa_e, 
   ifu_lsu_ldstub_e, ifu_lsu_swap_e, ifu_lsu_ldst_dbl_e, 
   stb_state_ced0, stb_state_ced1, stb_state_ced2, stb_state_ced3, 
   stb_ld_full_raw, stb_ld_partial_raw, stb_wrptr0_prev, 
   stb_wrptr1_prev, stb_wrptr2_prev, stb_wrptr3_prev, 
   ifu_lsu_alt_space_e, ifu_lsu_ldst_fp_e, lsu_quad_asi_e, 
   lsu_st_rmo_m, lsu_bst_in_pipe_m, ffu_lsu_kill_fst_w, 
   ffu_lsu_blk_st_e, ffu_lsu_blk_st_tid_m, ffu_lsu_blk_st_va_e, 
   lsu_snap_blk_st_m, tlb_pgnum_b39_g, lsu_stb_empty, 
   ifu_tlu_flsh_inst_e, stb_cam_mhit, ifu_tlu_inst_vld_m, 
   lsu_st_pcx_rq_pick, lsu_st_pcx_rq_vld, stb_rdata_ramc_b8t0, 
   lsu_stbcnt0, lsu_stbcnt1, lsu_stbcnt2, lsu_stbcnt3
   ) ;  

input     rclk ;     
//input     grst_l ;   
//input     arst_l ;   
   input  rst_tri_en;
   
   input  si;
   input  se;
   output so;
   

input     ld_inst_vld_e ;   // load in pipe.
input [1:0]   ldst_sz_e ;   // size of load.
input     st_inst_vld_e ;   // store in pipe.
// Currently bypass flop make request 
//input [3:0]   pcx_rq_for_stb ;  // pcx request rd of dfq - threaded
//input [2:0]   stb_dfq_rptr0 ;   // dfq rptr for stb0
input [2:0]   stb_pcx_rptr0 ;   // pcx rptr for stb0
input [2:0]   stb_wrptr0 ;    // wrt ptr - stb0
//input [2:0]   stb_dfq_rptr1 ;   // dfq rptr for stb1
input [2:0]   stb_pcx_rptr1 ;   // pcx rptr for stb1
input [2:0]   stb_wrptr1 ;    // wrt ptr - stb1
//input [2:0]   stb_dfq_rptr2 ;   // dfq rptr for stb2
input [2:0]   stb_pcx_rptr2 ;   // pcx rptr for stb2
input [2:0]   stb_wrptr2 ;    // wrt ptr - stb2
//input [2:0]   stb_dfq_rptr3 ;   // dfq rptr for stb3
input [2:0]   stb_pcx_rptr3 ;   // pcx rptr for stb3
input [2:0]   stb_wrptr3 ;    // wrt ptr - stb3
input [2:0]     stb_cam_hit_ptr ; // entry which hit
input     stb_cam_hit ;   // hit has occurred
//input [7:0]     stb_state_vld0 ;  // valid bits - stb0
//input [7:0]     stb_state_vld1 ;  // valid bits - stb1
//input [7:0]     stb_state_vld2 ;  // valid bits - stb2
//input [7:0]     stb_state_vld3 ;  // valid bits - stb3
input [9:0]    lsu_ldst_va_m ;
input     sta_internal_m ;   // internal stxa
input [1:0]   ifu_tlu_thrid_e ; // thread-id.

//   output     lsu_stbrwctl_flush_pipe_w ;  // tmp for tso_mon
   input      tlu_exu_early_flush_pipe_w;
   input      lsu_ttype_vld_m2;
   
   input      ifu_lsu_flush_w;
   input      lsu_defr_trp_taken_g;
   output     lsu_stbctl_flush_pipe_w;
   
   
input                   ifu_lsu_casa_e ;        // compare-swap instr
input                   ifu_lsu_ldstub_e ;      // ldstub
input                   ifu_lsu_swap_e ;        // swap
input     ifu_lsu_ldst_dbl_e; // ldst dbl, specifically for stquad.
//input   [63:0]          lsu_stb_st_data_g ;     // data to be written to stb
input [7:0]   stb_state_ced0 ;
input [7:0]   stb_state_ced1 ;
input [7:0]   stb_state_ced2 ;
input [7:0]   stb_state_ced3 ;
input [7:0]   stb_ld_full_raw ;
input [7:0]   stb_ld_partial_raw ;
input   [2:0]   stb_wrptr0_prev ;
input   [2:0]   stb_wrptr1_prev ;
input   [2:0]     stb_wrptr2_prev ;
input   [2:0]   stb_wrptr3_prev ;
input     ifu_lsu_alt_space_e ; // alt_space inst
input     ifu_lsu_ldst_fp_e ;
//input     tlb_cam_hit ;   // tlb cam hit - mstage
input     lsu_quad_asi_e ;  // quad ldst asi
//input  [3:0]      lsu_st_ack_rq_stb ;
//input     lsu_dtlb_bypass_e ;
input	lsu_st_rmo_m ;	// rmo st in m cycle.
input	lsu_bst_in_pipe_m ;	// 1st helper for bst.
input           ffu_lsu_kill_fst_w ;	// ecc error on st.
input  		ffu_lsu_blk_st_e ;     	// blk st helper signalled by ffu
input  	[1:0]	ffu_lsu_blk_st_tid_m ;  // blk st tid - from ffu_lsu_data
input	[5:3]  	ffu_lsu_blk_st_va_e ;	// bits 5:3 of va from increment
input  		lsu_snap_blk_st_m ;     	// snap blk st state
input		tlb_pgnum_b39_g ;

input 	[3:0]   lsu_stb_empty ;         // thread's stb is empty
input           ifu_tlu_flsh_inst_e;
input		stb_cam_mhit ;
input           ifu_tlu_inst_vld_m ;
//input   [3:0]   lsu_st_pcx_rq_kill_w2 ;

input [3:0]   lsu_st_pcx_rq_pick ;  

input         lsu_st_pcx_rq_vld ;

input	[8:0]	stb_rdata_ramc_b8t0 ;	// scan-only

output          stb_cam_wr_no_ivld_m ;

//output      ld_rawp_st_ced_g ;
output      ld_rawp_st_ced_w2 ;
output  [4:0]   stb_data_wr_ptr ; // write ptr - stb data
output      stb_data_wptr_vld ; // wr vld for stb data
output  [4:0]   stb_data_rd_ptr ; // rd ptr for stb data
output      stb_data_rptr_vld ; // rptr vld for stb data
output  [75:64]    stb_wdata_ramd_b75_b64 ;  // write data for DATA RAM. 

// partial or full raw required
output  [1:0]   stb_cam_cm_tid ;  // cam tid - stb cam
//output  [7:0]   stb_cam_sqsh_msk ;  // squash spurious hits
//output      stb_cam_vld ;
output  [7:0]   stb_ldst_byte_msk ; // byte mask for write/cam
output  [7:0]   stb_ldst_byte_msk_min ; // byte mask for write/cam for min path

//output  [3:0]   stb_rd_for_pcx_sel ;    // stb's st selected for read for pcx
output  [4:0]   stb_cam_rw_ptr ;        // rw ptr for shared stb cam port
output          stb_cam_wptr_vld ;      // wr vld for stb write   
output          stb_cam_rptr_vld ;      // rd vld for stb write   


//output      lsu_stb_pcx_rvld_d1 ; // stb has been read-delayby1cycle
//output      lsu_stb_dfq_rvld ;  // wr to dfq stb bypass ff

output                  lsu_st_sz_bhww_m ;      // byte or hword or word
output                  lsu_st_sz_dw_m ;        // double word
output                  lsu_st_sz_bhw_m ;       // byte or hword
output                  lsu_st_sz_wdw_m ;       // word or dword
output                  lsu_st_sz_b_m ;         // byte
output                  lsu_st_sz_w_m ;         // word
output                  lsu_st_sz_hw_m ;        // hword
output                  lsu_st_sz_hww_m ;       // hword or word

//output     ld_stb_full_raw_g ;
//output     ld_stb_partial_raw_g ;
//output  [3:0]   ld_stb_full_raw_g ;
//output  [3:0]   ld_stb_partial_raw_g ;

output  [2:0]   ld_rawp_st_ackid_w2 ;

//output  [2:0]   stb_dfq_rd_id ;   // stb entry being read for current thread for current thread

output  [3:0]     stb_flush_st_g ;  // st is flushed in cycle g
output  [3:0]     stb_cam_wvld_m ;

output  [2:1]   lsu_st_rq_type_m ;

output  [3:0]   lsu_stb_data_early_sel_e ;// select source of stb data.
output      lsu_stb_data_final_sel_m ;// select source of stb data.

output      lsu_ldquad_inst_m ; // stquad inst
//output      lsu_stdbl_inst_m ;  // stdbl inst

//output  [1:0]   lsu_stb_rd_tid ;  // thread for which stb read occurs

output	[3:0]	stb_thrd_en_g ;	// thread id for current stb access

   output     flsh_inst_m;

   output [9:3] lsu_stb_va_m;

output	[3:0]	lsu_stb_empty_buf ;
output	[3:0]	lsu_spu_stb_empty ;

   output     ifu_tlu_inst_vld_m_bf1;
   output     ifu_tlu_inst_vld_m_bf2;

   input [3:0] lsu_stbcnt0;
   input [3:0] lsu_stbcnt1;
   input [3:0] lsu_stbcnt2;
   input [3:0] lsu_stbcnt3;

   output [3:0] lsu_ifu_stbcnt0;
   output [3:0] lsu_ifu_stbcnt1;
   output [3:0] lsu_ifu_stbcnt2;
   output [3:0] lsu_ifu_stbcnt3;

   output       lsu_ffu_stb_full0;
   output       lsu_ffu_stb_full1;
   output       lsu_ffu_stb_full2;
   output       lsu_ffu_stb_full3;
 
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics
//wire  [4:0] stb_dequeue_ptr ;
wire  [2:0] stb_wptr_prev ;
wire  [1:0] st_thrid_m,st_thrid_g ;
wire  [7:0] ld_any_raw_vld ;
wire  [7:0] ld_any_raw_vld_d1 ;
//wire    ld_raw_mhit ;
wire  [2:0] st_rq_type_m,st_rq_type_g ;

wire  [1:0] ldst_sz_m,ldst_sz_g, pipe_ldst_sz_m ;
wire    ldst_byte, ldst_hwrd, ldst_word, ldst_dwrd ;
wire  [7:0] ldst_byte_mask ;
wire  [2:0] stb_wptr ;  
wire  [1:0] thrid_m,thrid_g ;
wire    ld_inst_vld_m, st_inst_vld_m ;

wire    ldst_dbl_m;
wire    atomic_m ;
wire    ldstub_m ;
wire    casa_m, casa_g ;
wire    swap_m;
wire    flush_st_g ;
wire    cam_wptr_vld_g ;
wire  [2:0] cam_wptr_d1 ;

wire  [2:0] stb_rdptr0,stb_rdptr1 ;
wire  [2:0] stb_rdptr2,stb_rdptr3 ;

//wire  [3:0] stb_rd_mask ;
wire  [3:0] stb_select_rptr ;
wire  [1:0] stb_rd_thrid ;
//wire    cam_vld_g ;
wire  [9:0]  ldst_va_m, pipe_ldst_va_m ;
wire  [3:0]  ldst_va_g ;
wire  [2:0] cam_wr_ptr ;
wire  thread0_m, thread1_m, thread2_m, thread3_m ;
wire  thread0_g, thread1_g, thread2_g, thread3_g ;
wire  [2:0]   ld_rawp_stb_id ;

//wire  rd_for_dfq_granted ;
wire  [7:0] stb_state_ced,stb_state_ced_d1 ;
//wire    stq_wr_en ;
//wire  [3:0] stq_wr_en_g ;
//wire  [3:0] stquad_vld ;
//wire  [2:0] stquad_ptr0,stquad_ptr1,stquad_ptr2,stquad_ptr3 ;
//wire  [3:0] ld_stq_hit_g ;
//wire  ldq_hit_g ;
//wire  [3:0] ldq_hit_g ;
wire  ldst_fp_m;
wire  ldstub_e,casa_e,ldst_dbl_e;
//wire  stb_data_final_sel_e ;
wire  alt_space_e,alt_space_m ;
wire  quad_asi_m ;
//wire  stquad_e, stquad_m ;
wire  stdbl_e ;
//wire  dfq_any_rq_for_stb ;
//wire  [3:0]   stb_rd_for_dfq ;  // read rq for dfq - threaded
wire    blkst_m,blkst_g ;
wire	stb_not_empty ;

   wire       clk;
   assign     clk = rclk;

//   wire       rst_l;
//   wire       stb_rwctl_rst_l;
   
//   dffrl_async rstff(.din (grst_l),
//                     .q   (stb_rwctl_rst_l),
//                     .clk (clk), .se(se), .si(), .so(),
//                     .rst_l (arst_l));

//=========================================================================================
//  MISC
//=========================================================================================

// Scan-only flops.

wire	[8:0]	stb_rdata_ramc_b8t0_so ;
dff_s #(9)  scmscan_ff (
        .din    (stb_rdata_ramc_b8t0[8:0]),
        .q      (stb_rdata_ramc_b8t0_so[8:0]),
        .clk    (clk),
        .se   (se),       .si (),          .so ()
        );

//=========================================================================================
//  INST_VLD_W GENERATION
//=========================================================================================

wire    flush_w_inst_vld_m ;
wire    lsu_inst_vld_w ;
wire    lsu_stbrwctl_flush_pipe_w;

//=======================================
//instaniate buffers
//======================================

   wire   ifu_tlu_inst_vld_m_bf0;
   
bw_u1_buf_10x UZfix_ifu_tlu_inst_vld_m_bf0 ( .a(ifu_tlu_inst_vld_m), .z(ifu_tlu_inst_vld_m_bf0) );
bw_u1_buf_30x UZfix_ifu_tlu_inst_vld_m_bf1 ( .a(ifu_tlu_inst_vld_m_bf0), .z(ifu_tlu_inst_vld_m_bf1) );
bw_u1_buf_20x UZfix_ifu_tlu_inst_vld_m_bf2 ( .a(ifu_tlu_inst_vld_m_bf0), .z(ifu_tlu_inst_vld_m_bf2) );
   
assign  flush_w_inst_vld_m =
        ifu_tlu_inst_vld_m_bf0 &
        ~(lsu_stbrwctl_flush_pipe_w & (thrid_m[1:0] == thrid_g[1:0])) ; // really lsu_flush_pipe_w

dff_s  stgw_ivld (
        .din    (flush_w_inst_vld_m),
        .q      (lsu_inst_vld_w),
        .clk    (clk),
        .se   (se),       .si (),          .so ()
        );

   wire other_flush_pipe_w;
   wire tlu_early_flush_pipe_w;
   assign tlu_early_flush_pipe_w = tlu_exu_early_flush_pipe_w;
   
assign	other_flush_pipe_w = 
tlu_early_flush_pipe_w | (lsu_ttype_vld_m2 & lsu_inst_vld_w) |
lsu_defr_trp_taken_g ;
   
   wire lsu_flush_pipe_w;
   
assign	lsu_flush_pipe_w = other_flush_pipe_w | ifu_lsu_flush_w ;
assign 	lsu_stbctl_flush_pipe_w = lsu_flush_pipe_w ;
assign 	lsu_stbrwctl_flush_pipe_w = lsu_flush_pipe_w ;   

//=========================================================================================
//  STB Array Addr/Ctl Generation
//=========================================================================================

assign  ldstub_e = ifu_lsu_ldstub_e ;
assign  casa_e   = ifu_lsu_casa_e ;
assign  ldst_dbl_e = ifu_lsu_ldst_dbl_e ;

assign  alt_space_e = ifu_lsu_alt_space_e ;

//assign  stdbl_e =  ldst_dbl_e & (~alt_space_e | (alt_space_e & ~lsu_quad_asi_e)) ;
assign  stdbl_e =  ldst_dbl_e ;

//   wire lsu_stdbl_inst_m;
   
//dff  stq_stgm (
//  .din  (stdbl_e), 
//  .q  	(lsu_stdbl_inst_m),  
//  .clk  (clk), 
//  .se (se), .si (), .so ()
//  );

// This path can probably be eased.
assign  lsu_stb_data_early_sel_e[0] = ldstub_e  & ~rst_tri_en;
assign  lsu_stb_data_early_sel_e[1] = casa_e & ~rst_tri_en;
assign  lsu_stb_data_early_sel_e[2] = ~(ldstub_e | casa_e |  stdbl_e) | rst_tri_en;
assign  lsu_stb_data_early_sel_e[3] = stdbl_e & ~rst_tri_en ;

// modify for accepting bst data out of pipe.
//assign  stb_data_final_sel_e = ~(ldst_fp_e | ffu_lsu_blk_st_e) ;

/*dff  lsel_g (
  .din  (stb_data_final_sel_e), 
  .q  (lsu_stb_data_final_sel_m),
  .clk  (clk), 
  .se (se), .si (), .so ()
  );*/

assign	lsu_stb_data_final_sel_m = ~(ldst_fp_m | blkst_m) ;

wire	real_st_m ;
wire	flsh_inst_m, flsh_inst_g ;
// !!! could qualify st_inst_vld_e with stxa_internal !!!
dff_s #(13) stgm_vld  (
  .din  ({ld_inst_vld_e,st_inst_vld_e,ldst_sz_e[1:0], 
    ifu_lsu_swap_e, ifu_lsu_ldstub_e, ifu_lsu_casa_e,ifu_lsu_ldst_dbl_e,
    ifu_tlu_thrid_e[1:0],ifu_lsu_ldst_fp_e,lsu_quad_asi_e,ifu_tlu_flsh_inst_e}),  
  .q  ({ld_inst_vld_m,real_st_m,pipe_ldst_sz_m[1:0], 
    swap_m,ldstub_m,casa_m,ldst_dbl_m,thrid_m[1:0],ldst_fp_m,quad_asi_m,flsh_inst_m}),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );

assign	st_inst_vld_m = real_st_m | flsh_inst_m ;

// do we need ld/st unflushed ?
   wire sta_internal_g;
   
dff_s #(7) stgw_vld  (
  .din  ({sta_internal_m,   
    casa_m, thrid_m[1:0],ldst_sz_m[1:0], flsh_inst_m}),  
  .q    ({sta_internal_g,   
    casa_g, thrid_g[1:0],ldst_sz_g[1:0], flsh_inst_g}),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );


// stb-cam will be written by st at rising edge of g-stage.
// However, st can be flushed after write. To keep, the stb state consistent,
// The valid and write ptr will not be updated until the rising edge of w2.

wire	early_flush_cond_g,partial_flush_st_g ;
assign early_flush_cond_g = 
(sta_internal_g | ~(lsu_inst_vld_w | blkst_g) | ffu_lsu_kill_fst_w) ;
assign	flush_st_g = (early_flush_cond_g | lsu_stbrwctl_flush_pipe_w) & cam_wptr_vld_g ;

//timing, send to stb_ctl and qualified by stb_cam_wvld_g (thread version of cam_wptr_vld_g)   
//assign	partial_flush_st_g = early_flush_cond_g & cam_wptr_vld_g ;
assign	partial_flush_st_g = early_flush_cond_g ; 

assign  atomic_m = (casa_m | ldstub_m | swap_m) & st_inst_vld_m ;

// WRITE PTR VALID GENERATION.

// meant specifically to squash pcx_rq_for_stb.
assign  stb_cam_wr_no_ivld_m 
  = (st_inst_vld_m | casa_m | ldstub_m | swap_m | blkst_m) ;

//bug3610 - kill cam write vld(==stb data write vld next cycle) to avoid datat read and write same cycle
//          to the same entry
wire  b2b_st_detect ;

assign  stb_cam_wptr_vld  
  = (((st_inst_vld_m | atomic_m) & ifu_tlu_inst_vld_m_bf0) | blkst_m) & ~(flush_st_g & b2b_st_detect) ;
  //= ((st_inst_vld_m | atomic_m) & ifu_tlu_inst_vld_m_bf0) | blkst_m ;  // bug3610
  //= (st_inst_vld_m | atomic_m | (ldst_dbl_m & st_inst_vld_m) | blkst_m) ;

dff_s  wptr_g (
  .din  (stb_cam_wptr_vld), .q  (cam_wptr_vld_g),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );

//flop move into mem cell (roll back)  
assign  stb_data_wptr_vld = cam_wptr_vld_g ;

// WRITE PTR GENERATION

// It is assumed that if there is a store in the pipe, there is a 
// free entry in the corresponding stb. Otherwise, the pipe would've
// stalled for the thread.      

// If a store-like inst has been flushed, then the old ptr has to be restored
// and used.  This is done within thread specific stb control

assign  thread0_m = ~st_thrid_m[1] & ~st_thrid_m[0] ;
assign  thread1_m = ~st_thrid_m[1] &  st_thrid_m[0] ;
assign  thread2_m =  st_thrid_m[1] & ~st_thrid_m[0] ;
assign  thread3_m =  st_thrid_m[1] &  st_thrid_m[0] ;

dff_s #(4) stgg_thrd (
  .din  ({thread0_m,thread1_m,thread2_m,thread3_m}),  
  .q  ({thread0_g,thread1_g,thread2_g,thread3_g}),  
  .clk  (clk), 
  .se (se), .si (), .so ()
  );

assign	stb_thrd_en_g[0] = thread0_g ;
assign	stb_thrd_en_g[1] = thread1_g ;
assign	stb_thrd_en_g[2] = thread2_g ;
assign	stb_thrd_en_g[3] = thread3_g ;

//assign  stb_wptr[2:0] = 
//  thread0_m ? stb_wrptr0[2:0] :
//    thread1_m ? stb_wrptr1[2:0] :
//      thread2_m ? stb_wrptr2[2:0] :
//        thread3_m ? stb_wrptr3[2:0] : 3'bxxx ;

assign  stb_wptr[2:0] = 
  (thread0_m ? stb_wrptr0[2:0] :  3'b000) |
  (thread1_m ? stb_wrptr1[2:0] :  3'b000) |
  (thread2_m ? stb_wrptr2[2:0] :  3'b000) |
  (thread3_m ? stb_wrptr3[2:0] :  3'b000) ;
   
assign  b2b_st_detect =   // detect back-to-back store
  (thread0_m & thread0_g) |
  (thread1_m & thread1_g) |
  (thread2_m & thread2_g) |
  (thread3_m & thread3_g) ;

assign  cam_wr_ptr[2:0] = (flush_st_g & b2b_st_detect) ? cam_wptr_d1[2:0] : stb_wptr[2:0] ;

dff_s #(3)  wptr_d1 (
  .din  (cam_wr_ptr[2:0]),  .q  (cam_wptr_d1[2:0]),
  .clk  (clk), 
  .se (se), .si (), .so ()
  );

assign  stb_cam_wvld_m[0] = stb_cam_wptr_vld & thread0_m ;
assign  stb_cam_wvld_m[1] = stb_cam_wptr_vld & thread1_m ;
assign  stb_cam_wvld_m[2] = stb_cam_wptr_vld & thread2_m ;
assign  stb_cam_wvld_m[3] = stb_cam_wptr_vld & thread3_m ;

// contains potential flush conditions.
assign  stb_flush_st_g[0] = partial_flush_st_g ;
assign  stb_flush_st_g[1] = partial_flush_st_g ;
assign  stb_flush_st_g[2] = partial_flush_st_g ;
assign  stb_flush_st_g[3] = partial_flush_st_g ;

// stb-data has a delayed write in w2. Alignment of stb data will be done on write
// of 64b into stb. This allows write of stb cam and data to be done in the
// same cycle, and thus read can occur simultaneously for pcx. 

//mem cell change to bw_r_rf32x80, flop move into mem cell (roll back)
//flop outside mem cell
assign  stb_data_wr_ptr[4:0] =  {st_thrid_g[1:0],cam_wptr_d1[2:0]};
   
// RD PTR/VLD GENERATION

// stb read for dfq dumps data into a bypass flop. Thus a read for the dfq can occur
// if a thread's stb has an acked entry and the bypass flop is empty.
// stb read for pcx occurs on availability of queue entry. 

// Both dfq and pcx require a read of the cam and data. The reads
// can thus not happen when load that hits in the stb is in the w2 (change to W3)
// stage and a store is in the g-stage of the pipe. Both
// probabilities are low.

// ??Read for pcx takes priority over dfq. No deadlock can occur
// ??as at some point the pcx reads will be exhausted and the stb
// ??will have to drain itself. The stb is self-regulating in this regard.

// priority of stb read: ld_cam_hit (full raw bypass) > dfq > pcx 

//====================================================================================
//raw bypass timing 
//G/WB                          W2     W3                      W4
//cam_hit(from stb_cam output)  flop   stb_data rd_ptr/rd_vld  read STB_DATA/BYP
//====================================================================================

   wire [1:0] thrid_w2;
   wire [2:0] stb_cam_hit_ptr_w2;
   wire       stb_cam_hit_w2;   
   wire       stb_cam_hit_w;   
   
   //bug3503
   assign stb_cam_hit_w  =  stb_cam_hit & lsu_inst_vld_w & ~lsu_stbrwctl_flush_pipe_w;

dff_s #(6) stb_cam_hit_stg_w2 (
  .din  ({thrid_g[1:0],  stb_cam_hit_ptr[2:0],    stb_cam_hit_w   }), 
  .q  	({thrid_w2[1:0], stb_cam_hit_ptr_w2[2:0], stb_cam_hit_w2}),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );
   
// logic moved to qctl1
// pcx is making request for data in current cycle. Can be multi-hot.
//assign  pcx_any_rq_for_stb = |pcx_rq_for_stb[3:0] ;
//assign  pcx_any_rq_for_stb = 
//	(pcx_rq_for_stb[0] & ~lsu_st_pcx_rq_kill_w2[0]) | 
//	(pcx_rq_for_stb[1] & ~lsu_st_pcx_rq_kill_w2[1]) | 
//	(pcx_rq_for_stb[2] & ~lsu_st_pcx_rq_kill_w2[2]) | 
//	(pcx_rq_for_stb[3] & ~lsu_st_pcx_rq_kill_w2[3]) ; 

// ??ld-cam hit based read takes precedence
// ??Timing : This could be made pessimistic by using ld_inst_vld_g

//assign  stb_select_rptr[3:0] =  pcx_rq_for_stb[3:0] ;  // timing fix
assign  stb_select_rptr[3:0] =  lsu_st_pcx_rq_pick[3:0] ; 

// This could be a critical path. Be careful !
//assign  stb_rdptr0[2:0] = ~dfq_any_rq_for_stb ? stb_pcx_rptr0[2:0] : stb_dfq_rptr0[2:0] ; 
assign  stb_rdptr0[2:0] = stb_pcx_rptr0[2:0] ;
assign  stb_rdptr1[2:0] = stb_pcx_rptr1[2:0] ;
assign  stb_rdptr2[2:0] = stb_pcx_rptr2[2:0] ;
assign  stb_rdptr3[2:0] = stb_pcx_rptr3[2:0] ;

// logic moved to qctl1
//wire  [1:0] stb_rd_tid ;
//
//assign  stb_rd_tid[0] = pcx_rq_for_stb[1] | pcx_rq_for_stb[3] ;
//assign  stb_rd_tid[1] = pcx_rq_for_stb[2] | pcx_rq_for_stb[3] ;
//   
//dff #(2) stbtid_stgd1 (
//  .din    (stb_rd_tid[1:0]),  .q  (lsu_stb_rd_tid[1:0]),
//  .clk    (clk), 
//  .se   (se), .si (), .so ()
//  );

//assign  stb_dfq_rd_id[2:0] = stb_data_rd_ptr[2:0] ; // or cam rd ptr

//timing fix:5/6/03
//bug4988 - change the prirority from 0->3 to 3->0; the reason is when select_rptr=0, the
//          default thread id(rptr[4:3])=thread0 but the default rptr[2:0]=thread3. If
//          thread0 and thread3 rptr are the same and the thread0 write is occuring, the
//          rptr[4:0] is same as wptr[4:0]
wire  [2:0]  stb_rdptr ;
//assign  stb_rdptr[2:0] = 
//  stb_select_rptr[0] ? stb_rdptr0[2:0] :
//    stb_select_rptr[1] ? stb_rdptr1[2:0] :
//      stb_select_rptr[2] ? stb_rdptr2[2:0] :
//                             stb_rdptr3[2:0] ;

//assign  stb_rdptr[2:0] = 
//  stb_select_rptr[3] ? stb_rdptr3[2:0] :
//    stb_select_rptr[2] ? stb_rdptr2[2:0] :
//      stb_select_rptr[1] ? stb_rdptr1[2:0] :
//                             stb_rdptr0[2:0] ;

assign  stb_rdptr[2:0] = 
  (stb_select_rptr[3] ? stb_rdptr3[2:0] : 3'b0) |
  (stb_select_rptr[2] ? stb_rdptr2[2:0] : 3'b0) |
  (stb_select_rptr[1] ? stb_rdptr1[2:0] : 3'b0) |
  (stb_select_rptr[0] ? stb_rdptr0[2:0] : 3'b0) ;
    
//timing fix: 8/29/03 - remove the default select logic for stb_select_rptr since synthesis is forced to replace 
//            4to1 mux w/ and-or mux or 2to1 mux
//wire   stb_select_rptr_b3;
//assign stb_select_rptr_b3 =  ~|stb_select_rptr[2:0];

wire  [2:0]  stb_rdptr_l;

assign stb_rdptr_l[2:0] =  ~stb_rdptr[2:0] ;
//bw_u1_muxi41d_2x  UZsize_stb_rdptr_b0_mux(
//                  .z(stb_rdptr_l[0]), 
//                  .d0(stb_rdptr0[0]), 
//                  .d1(stb_rdptr1[0]), 
//                  .d2(stb_rdptr2[0]), 
//                  .d3(stb_rdptr3[0]), 
//                  .s0(stb_select_rptr[0]), 
//                  .s1(stb_select_rptr[1]), 
//                  .s2(stb_select_rptr[2]), 
//                  .s3(stb_select_rptr[3]));
//   
//bw_u1_muxi41d_2x  UZsize_stb_rdptr_b1_mux(
//                  .z(stb_rdptr_l[1]), 
//                  .d0(stb_rdptr0[1]), 
//                  .d1(stb_rdptr1[1]), 
//                  .d2(stb_rdptr2[1]), 
//                  .d3(stb_rdptr3[1]), 
//                  .s0(stb_select_rptr[0]), 
//                  .s1(stb_select_rptr[1]), 
//                  .s2(stb_select_rptr[2]), 
//                  .s3(stb_select_rptr[3]));
//   
//bw_u1_muxi41d_2x  UZsize_stb_rdptr_b2_mux(
//                  .z(stb_rdptr_l[2]), 
//                  .d0(stb_rdptr0[2]), 
//                  .d1(stb_rdptr1[2]), 
//                  .d2(stb_rdptr2[2]), 
//                  .d3(stb_rdptr3[2]), 
//                  .s0(stb_select_rptr[0]), 
//                  .s1(stb_select_rptr[1]), 
//                  .s2(stb_select_rptr[2]), 
//                  .s3(stb_select_rptr[3]));
//   
   
assign  stb_rd_thrid[0] = stb_select_rptr[1] | stb_select_rptr[3] ;
assign  stb_rd_thrid[1] = stb_select_rptr[2] | stb_select_rptr[3] ;

// read
// this mux will have to be accommodated in path !!! Talk to Satya. 
// Timing : This could be made pessimistic by using ld_inst_vld_g

// raw read STB at W3 (changed from W2)        
assign  stb_data_rd_ptr[4:0] = stb_cam_hit_w2 ? 
        {thrid_w2[1:0],stb_cam_hit_ptr_w2[2:0]} :  // rd based on ld hit
        {stb_rd_thrid[1:0],~stb_rdptr_l[2:0]} ;       // rd for pcx or dfq
   
// Blk-st modification for thread.
assign	st_thrid_m[1:0] = blkst_m ? ffu_lsu_blk_st_tid_m[1:0] : thrid_m[1:0] ;
dff_s #(2)  stid_stgg (
  .din  (st_thrid_m[1:0]), 
  .q  	(st_thrid_g[1:0]),
  .clk  (clk), 
  .se (se), .si (), .so ()
  );

//timing fix: 5/6/03
//assign  stb_cam_rw_ptr[4:0]  = stb_cam_wptr_vld ? 
//        {st_thrid_m[1:0],cam_wr_ptr[2:0]} :  // write
//        {stb_rd_thrid[1:0],stb_rdptr[2:0]} ;  // read

wire [2:0] cam_wr_ptr_l;
wire [1:0] stb_rd_thrid_l;
wire [1:0] st_thrid_m_l;

assign cam_wr_ptr_l[2:0]  =  ~cam_wr_ptr[2:0];
assign stb_rd_thrid_l[1:0]  =  ~stb_rd_thrid[1:0];
assign st_thrid_m_l[1:0]  =  ~st_thrid_m[1:0];

bw_u1_muxi21_2x  UZsize_stb_cam_rw_ptr_b0_mux(
                  .z(stb_cam_rw_ptr[0]), 
                  .d0(stb_rdptr_l[0]), 
                  .d1(cam_wr_ptr_l[0]), 
                  .s(stb_cam_wptr_vld));
   
bw_u1_muxi21_2x  UZsize_stb_cam_rw_ptr_b1_mux(
                  .z(stb_cam_rw_ptr[1]), 
                  .d0(stb_rdptr_l[1]), 
                  .d1(cam_wr_ptr_l[1]), 
                  .s(stb_cam_wptr_vld));
   
bw_u1_muxi21_2x  UZsize_stb_cam_rw_ptr_b2_mux(
                  .z(stb_cam_rw_ptr[2]), 
                  .d0(stb_rdptr_l[2]), 
                  .d1(cam_wr_ptr_l[2]), 
                  .s(stb_cam_wptr_vld));
   
bw_u1_muxi21_2x  UZsize_stb_cam_rw_ptr_b3_mux(
                  .z(stb_cam_rw_ptr[3]), 
                  .d0(stb_rd_thrid_l[0]), 
                  .d1(st_thrid_m_l[0]), 
                  .s(stb_cam_wptr_vld));
   
bw_u1_muxi21_2x  UZsize_stb_cam_rw_ptr_b4_mux(
                  .z(stb_cam_rw_ptr[4]), 
                  .d0(stb_rd_thrid_l[1]), 
                  .d1(st_thrid_m_l[1]), 
                  .s(stb_cam_wptr_vld));
   


//raw read STB at W3 (not W2)
//timing fix: 9/2/03 - reduce fanout in stb_rwctl for lsu_st_pcx_rq_pick - gen separate signal for
//                     stb_cam_rptr_vld and stb_data_rptr_vld

//bug4988 - qual lsu_st_pcx_rq_vld w/ no write vld to stb_data. use stb_cam_wr_no_ivld_m instead of write vld.
//          this is the same signal used to kill pcx_rq_for_stb
//          stb_cam_rptr_vld is not set if stb_cam_wptr_vld=1
     
assign  stb_data_rptr_vld = 
  //(|stb_select_rptr[3:0]) |  // pcx/dfq rd - timing fix
  //lsu_st_pcx_rq_vld |  // pcx/dfq rd  // bug4988
   (lsu_st_pcx_rq_vld & ~stb_cam_wr_no_ivld_m) |  // pcx/dfq rd
    stb_cam_hit_w2 ;         // cam hit requires read whether single or multiple

//raw read STB at W3 (not W2)      
//timing fix: 9/2/03 - reduce fanout in stb_rwctl for lsu_st_pcx_rq_pick - gen separate signal for
//                     stb_cam_rptr_vld and stb_data_rptr_vld
assign  stb_cam_rptr_vld = 
  //((|stb_select_rptr[3:0]) & ~(stb_cam_hit_w2)) & // only pcx read  - timing fix
  (lsu_st_pcx_rq_vld & ~(stb_cam_hit_w2)) & // only pcx read 
      ~stb_cam_wptr_vld ;   // st,st-like write does not block
   
// lsu_stb_rd_vld_d1 - not used
//dff  stbrd_stgd1  (
//  .din    (stb_cam_rptr_vld), .q  (lsu_stb_rd_vld_d1),
//  .clk    (clk), 
//  .se   (se), .si (), .so ()
//  );

// logic moved to qctl1
//dff #(1)  prvld_stgd1 (
//  .din  (pcx_any_rq_for_stb), 
//  .q  (lsu_stb_pcx_rvld_d1),
//  .clk  (clk), 
//  .se (se), .si (), .so ()
//  );

assign  stb_cam_cm_tid[1:0] = thrid_m[1:0] ;


//=========================================================================================
//  BYTE MASK FORMATTING
//=========================================================================================


// Write/CAM Data for CAM RAM.
// Physical dword aligned addr - PA[39:3] (37b)
// Byte Mask - (8b)
// Total - 45b

//  | b7  |  b6 | b5  | b4  | b3  | b2  | b1  | b0  |
//  |   hw3 |   hw2 |   hw1 |   hw0 |
//  |     w1    |   w0    |
//  |       dw        | 



//dff  #(11) va_m (
//  .din    (exu_lsu_ldst_va_e[10:0]),  .q  (pipe_ldst_va_m[10:0]),
//  .clk    (clk), 
//  .se   (se), .si (), .so ()
//  );

assign pipe_ldst_va_m[9:0] = lsu_ldst_va_m[9:0];

// ldst_byte may not be needed
assign ldst_byte = ~ldst_sz_m[1] & ~ldst_sz_m[0] ;  // 00
assign ldst_hwrd = ~ldst_sz_m[1] &  ldst_sz_m[0] ;  // 01
assign ldst_word =  ldst_sz_m[1] & ~ldst_sz_m[0] ;  // 10
assign ldst_dwrd =  ldst_sz_m[1] &  ldst_sz_m[0] ;  // 11

// Note : dword term is common. 
assign ldst_byte_mask[0]  =
  ( ldst_va_m[2] &  ldst_va_m[1] &  ldst_va_m[0] )       |
  ( ldst_va_m[2] &  ldst_va_m[1] & ~ldst_va_m[0] & (ldst_hwrd)) |
  ( ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_word))  |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd))  ; 
assign ldst_byte_mask[1]  =
  ( ldst_va_m[2] &  ldst_va_m[1] & ~ldst_va_m[0])        |
  ( ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_word))  |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd))  ; 
assign ldst_byte_mask[2]  =
  ( ldst_va_m[2] & ~ldst_va_m[1] &  ldst_va_m[0])         |
  ( ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_hwrd | ldst_word))  |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd))  ; 
assign ldst_byte_mask[3]  =
  ( ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0])       |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd))  ; 
assign ldst_byte_mask[4]  =
  (~ldst_va_m[2] &  ldst_va_m[1] &  ldst_va_m[0])        |
  (~ldst_va_m[2] &  ldst_va_m[1] & ~ldst_va_m[0] & (ldst_hwrd)) |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd | ldst_word)) ;
assign ldst_byte_mask[5]  =
  (~ldst_va_m[2] &  ldst_va_m[1] & ~ldst_va_m[0])         |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] &  (ldst_dwrd | ldst_word))  ;
assign ldst_byte_mask[6]  =
  (~ldst_va_m[2] & ~ldst_va_m[1] &  ldst_va_m[0])     |
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] & (ldst_dwrd | ldst_word | ldst_hwrd)) ;
assign ldst_byte_mask[7]  =
  (~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0])   ;

assign  stb_ldst_byte_msk[7:0]  = ldst_byte_mask[7:0]; 

   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b0 (.a(ldst_byte_mask[0]), .z(stb_ldst_byte_msk_min[0]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b1 (.a(ldst_byte_mask[1]), .z(stb_ldst_byte_msk_min[1]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b2 (.a(ldst_byte_mask[2]), .z(stb_ldst_byte_msk_min[2]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b3 (.a(ldst_byte_mask[3]), .z(stb_ldst_byte_msk_min[3]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b4 (.a(ldst_byte_mask[4]), .z(stb_ldst_byte_msk_min[4]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b5 (.a(ldst_byte_mask[5]), .z(stb_ldst_byte_msk_min[5]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b6 (.a(ldst_byte_mask[6]), .z(stb_ldst_byte_msk_min[6]));
   bw_u1_minbuf_5x UZfix_stb_ldst_byte_msk_min_b7 (.a(ldst_byte_mask[7]), .z(stb_ldst_byte_msk_min[7]));
   
   
// Generate selects to format st data
assign  lsu_st_sz_bhww_m = ldst_byte | ldst_hwrd | ldst_word ;      // byte or hword or word
assign  lsu_st_sz_dw_m   = ldst_dwrd ;            // double word
assign  lsu_st_sz_bhw_m  = ldst_byte | ldst_hwrd ;      // byte or hword
assign  lsu_st_sz_wdw_m  = ldst_word | ldst_dwrd ;      // word or dword
assign  lsu_st_sz_b_m    = ldst_byte ;            // byte
assign  lsu_st_sz_w_m    = ldst_word ;            // word
assign  lsu_st_sz_hw_m   = ldst_hwrd ;            // hword
assign  lsu_st_sz_hww_m  = ldst_hwrd | ldst_word ;      // hword or word

//=========================================================================================
//  BLK-ST HANDLING
//=========================================================================================

wire	blkst_m_tmp ;
dff_s  stgm_bst (
  .din (ffu_lsu_blk_st_e),
  .q   (blkst_m_tmp),
  .clk (clk),
  .se   (se),       .si (),          .so ()
);

assign	blkst_m = blkst_m_tmp & ~(real_st_m  | flsh_inst_m |
		ld_inst_vld_m) ; // Bug 3444

dff_s  stgg_bst (
  .din (blkst_m),
  .q   (blkst_g),
  .clk (clk),
  .se   (se),       .si (),          .so ()
);

wire	snap_blk_st_local_m ;
assign	snap_blk_st_local_m = lsu_snap_blk_st_m & ifu_tlu_inst_vld_m_bf0 ;

wire	[1:0]	bst_sz_m ;
wire	[9:0]	bst_va_m ;
// output to be used in m-stage.
dffe_s #(9) bst_state_m (
        .din    ({ldst_sz_m[1:0],ldst_va_m[9:6],ldst_va_m[2:0]}),
        .q      ({bst_sz_m[1:0],bst_va_m[9:6],bst_va_m[2:0]}),
        .en     (snap_blk_st_local_m),
        .clk    (clk),
        .se   (se),       .si (),          .so ()
        );

dff_s #(3)  bsva_stgm (
  .din    (ffu_lsu_blk_st_va_e[5:3]), .q (bst_va_m[5:3]),
  .clk    (clk), 
  .se   (se), .si (), .so ()
  );

//assign	bst_va_m[5:3]	= ffu_lsu_blk_st_va_e[5:3] ;

//assign  ldst_va_m[10] =  pipe_ldst_va_m[10] ;
assign  ldst_va_m[9:0] = blkst_m ?  bst_va_m[9:0] : pipe_ldst_va_m[9:0] ;

assign	lsu_stb_va_m[9:3] = ldst_va_m[9:3] ;

assign	ldst_sz_m[1:0]	=  blkst_m ? bst_sz_m[1:0] : pipe_ldst_sz_m[1:0] ;

//=========================================================================================
//  WRITE DATA FOR DATA RAM
//=========================================================================================

// Write Data for DATA RAM.
// Data - (64b)
// (8b parity is generated on read)
// Rqtype - (3b)
// Size - (3b). 
// Addr - (3b). Lower 3b of 40b addr.
// (set index and way available from ctl state.
// Total - 73b.

// st-quad requires own encoding.
// assume does not have to be changed for blk-st
assign  st_rq_type_m[2:0] =
                casa_m ? 3'b010 :                       // cas pkt 1
                        (ldstub_m | swap_m) ? 3'b110 :  // ldstub/swap
                          //(stquad_m)  ? 3'b111 :  // stquad-pkt1
                                  3'b001 ;        // normal store or partial interrupt rq type

//assign  lsu_st_rq_type_m[2:0] = st_rq_type_m[2:0] ;
assign  lsu_st_rq_type_m[2:1] = st_rq_type_m[2:1] ;

// Need ASI decode
/*wire	lsu_stquad_inst_m ;
assign  lsu_stquad_inst_m = ldst_dbl_m & st_inst_vld_m & quad_asi_m ; 
*/

wire	st_rmo_m,st_rmo_g ;
assign	st_rmo_m = lsu_st_rmo_m | blkst_m ; // binit and blk rmo stores.
wire bst_in_pipe_g;
dff_s #(9)  stgg_etc  (
  .din    ({ldst_va_m[3:0],st_rq_type_m[2:0],st_rmo_m,lsu_bst_in_pipe_m}), 
  .q      ({ldst_va_g[3:0],st_rq_type_g[2:0],st_rmo_g,bst_in_pipe_g}),
  .clk    (clk), 
  .se   (se), .si (), .so ()
  );

wire	bst_any_helper ;
assign	bst_any_helper = blkst_g | bst_in_pipe_g ; // Bug 3934

// Size will have to be changed to 2bits.
// 7 more bits could be added to data ram to save read of cam in providing dfq pkt !!! 
assign stb_wdata_ramd_b75_b64[75:64]   = 
  {st_rmo_g,st_rq_type_g[2:0],flsh_inst_g,bst_any_helper,ldst_sz_g[1:0],ldst_va_g[3:0]}; 
	// Bug3395, 3934

//=========================================================================================
//  FULL/PARTIAL RAW CALCULATION
//=========================================================================================

// io load cannot bypass from stb. A stb hit results in an io-ld being treated
// as a partial-raw. (OR should it be serialized behind any io store ??)
wire	io_ld,io_ld_w2 ;
assign	io_ld = tlb_pgnum_b39_g ; // Bug 4362

// full-raw is squashed on multiple hits in stb. Treated like partial raw.
// Ensure that all ld and ld-like instructions signal ld_inst_vld. We can then
// remove qualification with ld_inst_vld_g.
/*assign  ld_stb_full_raw_g = 
	(|stb_ld_full_raw[7:0]) & ~(stb_cam_mhit | ldq_hit_g | io_ld) ;
assign  ld_stb_full_raw_g[0] = (|stb_ld_full_raw[7:0]) & ld_inst_vld_g & 
          ~(stb_cam_mhit | ldq_hit_g[0] | io_ld) & thread0_g ;
          //~(ld_raw_mhit | ld_stq_hit_g[0] | io_ld) & thread0_g ;
assign  ld_stb_full_raw_g[1] = (|stb_ld_full_raw[7:0]) & ld_inst_vld_g & 
          ~(stb_cam_mhit | ldq_hit_g[1] | io_ld) & thread1_g ;
assign  ld_stb_full_raw_g[2] = (|stb_ld_full_raw[7:0]) & ld_inst_vld_g & 
          ~(stb_cam_mhit | ldq_hit_g[2] | io_ld) & thread2_g ;
assign  ld_stb_full_raw_g[3] = (|stb_ld_full_raw[7:0]) & ld_inst_vld_g & 
          ~(stb_cam_mhit | ldq_hit_g[3] | io_ld) & thread3_g ; */
// Multiple full raws are also treated like a partial.
/*assign  ld_stb_partial_raw_g = 
	((|stb_ld_partial_raw[7:0]) | stb_cam_mhit | ldq_hit_g | (io_ld & stb_not_empty)) ;
assign  ld_stb_partial_raw_g[0] = 
	((|stb_ld_partial_raw[7:0]) | stb_cam_mhit | ldq_hit_g[0] | (io_ld & stb_not_empty)) 
          & ld_inst_vld_g & thread0_g ;
assign  ld_stb_partial_raw_g[1] = 
	((|stb_ld_partial_raw[7:0]) | stb_cam_mhit | ldq_hit_g[1] | (io_ld & stb_not_empty)) 
          & ld_inst_vld_g & thread1_g ;
assign  ld_stb_partial_raw_g[2] = 
	((|stb_ld_partial_raw[7:0]) | stb_cam_mhit | ldq_hit_g[2] | (io_ld & stb_not_empty)) 
          & ld_inst_vld_g & thread2_g ;
assign  ld_stb_partial_raw_g[3] = 
	((|stb_ld_partial_raw[7:0]) | stb_cam_mhit | ldq_hit_g[3] | (io_ld & stb_not_empty)) 
          & ld_inst_vld_g & thread3_g; */

//=========================================================================================
//  STQ HANDLING
//=========================================================================================

/*	REMOVE STQUAD */

//=========================================================================================
//	LD QUAD HANDLING
//=========================================================================================

dff_s  altsp_stgm (
  .din    (alt_space_e), .q (alt_space_m),
  .clk    (clk), 
  .se   (se), .si (), .so ()
  );

assign  lsu_ldquad_inst_m = ldst_dbl_m & ld_inst_vld_m & quad_asi_m & alt_space_m ; 

/*wire	ldquad_inst_g ;
dff_s  ldq_stgg (
  .din    (lsu_ldquad_inst_m), .q (ldquad_inst_g),
  .clk    (clk), 
  .se   (se), .si (), .so ()
  );

wire	ldq_stb_cam_hit ;
assign	ldq_stb_cam_hit = stb_cam_hit & ldquad_inst_g ;
// Terms can be made common.
assign  ldq_hit_g = ldq_stb_cam_hit ; */
/*assign  ldq_hit_g[0] = thread0_g & ldq_stb_cam_hit ;
assign  ldq_hit_g[1] = thread1_g & ldq_stb_cam_hit ;
assign  ldq_hit_g[2] = thread2_g & ldq_stb_cam_hit ;
assign  ldq_hit_g[3] = thread3_g & ldq_stb_cam_hit ; */

//=========================================================================================
//  STB MULTIPLE HIT GENERATION
//=========================================================================================

// Multiple hits in stb is to be treated as a partial raw case. The ld however must wait
// until the youngest store which hit exits the stb. A ptr needs to be calculated for this case.
// A version of stb_wptr is used instead because it is easily available. (Would this have
// any significant performance impact ? - No)

assign  ld_any_raw_vld[7:0] = stb_ld_full_raw[7:0] | stb_ld_partial_raw[7:0] ;

dff_s #(16)  stgw2_rvld (
        .din    ({ld_any_raw_vld[7:0],stb_state_ced[7:0]}),
        .q    	({ld_any_raw_vld_d1[7:0],stb_state_ced_d1[7:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


// This equation can be optimized for the grape flow.
// This can be obtained from stb.
/*assign  ld_raw_mhit =
  (ld_any_raw_vld[7] & |(ld_any_raw_vld[6:0])) |
  (ld_any_raw_vld[6] & |(ld_any_raw_vld[5:0])) |
  (ld_any_raw_vld[5] & |(ld_any_raw_vld[4:0])) |
  (ld_any_raw_vld[4] & |(ld_any_raw_vld[3:0])) |
  (ld_any_raw_vld[3] & |(ld_any_raw_vld[2:0])) |
  (ld_any_raw_vld[2] & |(ld_any_raw_vld[1:0])) |
  (ld_any_raw_vld[1] &   ld_any_raw_vld[0]) ; */

//=========================================================================================
//  STB Partial Raw ptr generation
//=========================================================================================

// The loading on the raw output of the stb cam will be significant if the signal 
// has to fan out to all 4 ctl blocks. That's why the control has to be localized.

// Using the ack bit may result in pessimistic issue of partial raw loads.
// For a single partial raw or multiple hit case, detecting whether there is any
// unacked store is sufficient. Calculation is for no unacked store.
// Can we use cam_hit ptr instead !!!

//assign  ld_rawp_st_ced_w2 = (~(|(ld_any_raw_vld_d1[7:0] & ~stb_state_ced_d1[7:0]))) ;
wire [2:0] wptr_prev ;
assign	wptr_prev[2:0] = stb_wptr_prev[2:0] ;
wire [7:0] wptr_dcd ; // Bug 4294
assign	wptr_dcd[0] = ~wptr_prev[2] & ~wptr_prev[1] & ~wptr_prev[0] ;
assign	wptr_dcd[1] = ~wptr_prev[2] & ~wptr_prev[1] &  wptr_prev[0] ;
assign	wptr_dcd[2] = ~wptr_prev[2] &  wptr_prev[1] & ~wptr_prev[0] ;
assign	wptr_dcd[3] = ~wptr_prev[2] &  wptr_prev[1] &  wptr_prev[0] ;
assign	wptr_dcd[4] =  wptr_prev[2] & ~wptr_prev[1] & ~wptr_prev[0] ;
assign	wptr_dcd[5] =  wptr_prev[2] & ~wptr_prev[1] &  wptr_prev[0] ;
assign	wptr_dcd[6] =  wptr_prev[2] &  wptr_prev[1] & ~wptr_prev[0] ;
assign  wptr_dcd[7] =  wptr_prev[2] &  wptr_prev[1] &  wptr_prev[0] ;

wire iold_st_ced_g,iold_st_ced_w2 ;
assign	iold_st_ced_g = |(wptr_dcd[7:0] & stb_state_ced[7:0]) ;

dff_s #(2)   ioldced_stgw2  (
  .din  ({iold_st_ced_g,io_ld}), 
  .q 	({iold_st_ced_w2,io_ld_w2}),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );

assign  ld_rawp_st_ced_w2 = 
	io_ld_w2 ? iold_st_ced_w2 :
	(~(|(ld_any_raw_vld_d1[7:0] & ~stb_state_ced_d1[7:0]))) ;

// For the case of a single partial raw.
assign  ld_rawp_stb_id[0] = stb_cam_hit_ptr[0] ;
assign  ld_rawp_stb_id[1] = stb_cam_hit_ptr[1] ;
assign  ld_rawp_stb_id[2] = stb_cam_hit_ptr[2] ;
/*assign  ld_rawp_stb_id[0] = stb_ld_partial_raw[1] | stb_ld_partial_raw[3] |
        stb_ld_partial_raw[5] | stb_ld_partial_raw[7] ;
assign  ld_rawp_stb_id[1] = stb_ld_partial_raw[2] | stb_ld_partial_raw[3] |
        stb_ld_partial_raw[6] | stb_ld_partial_raw[7] ;
assign  ld_rawp_stb_id[2] = stb_ld_partial_raw[4] | stb_ld_partial_raw[5] |
        stb_ld_partial_raw[6] | stb_ld_partial_raw[7] ; */

   wire [3:0] pipe_thread_g;
   assign     pipe_thread_g[0] = ~thrid_g[1] & ~thrid_g[0];
   assign     pipe_thread_g[1] = ~thrid_g[1] &  thrid_g[0];
   assign     pipe_thread_g[2] =  thrid_g[1] & ~thrid_g[0];
   assign     pipe_thread_g[3] =  thrid_g[1] &  thrid_g[0];
 
assign  stb_state_ced[7:0] = 
( pipe_thread_g[0] ? stb_state_ced0[7:0] : 8'b0 ) |
( pipe_thread_g[1] ? stb_state_ced1[7:0] : 8'b0 ) |
( pipe_thread_g[2] ? stb_state_ced2[7:0] : 8'b0 ) |
( pipe_thread_g[3] ? stb_state_ced3[7:0] : 8'b0 );

assign  stb_wptr_prev[2:0] = 
  (pipe_thread_g[0] ? stb_wrptr0_prev[2:0] : 3'b0) |
  (pipe_thread_g[1] ? stb_wrptr1_prev[2:0] : 3'b0) |
  (pipe_thread_g[2] ? stb_wrptr2_prev[2:0] : 3'b0) |
  (pipe_thread_g[3] ? stb_wrptr3_prev[2:0] : 3'b0);

assign  stb_not_empty  =
  (pipe_thread_g[0]  & ~lsu_stb_empty[0] ) | 
  (pipe_thread_g[1]  & ~lsu_stb_empty[1] ) |
  (pipe_thread_g[2]  & ~lsu_stb_empty[2] ) |
  (pipe_thread_g[3]  & ~lsu_stb_empty[3] ) ;

assign	lsu_stb_empty_buf[3:0] = lsu_stb_empty[3:0] ;
assign	lsu_spu_stb_empty[3:0] = lsu_stb_empty[3:0] ;

//wire ldstdbl_g ;
// stdbl should be qualified with quad_asi_g !!!
//assign  ldstdbl_g = ldst_dbl_g & (ld_inst_vld_g | st_inst_vld_g) & ~ldst_fp_g ;

// casa_g and stdbl_g may not be required.
//assign  ld_rawp_st_ackid_g[2:0] = 
//  (casa_g | ldstdbl_g | stb_cam_mhit | (io_ld & stb_not_empty))
//  ? stb_wptr_prev[2:0] : ld_rawp_stb_id[2:0] ;

//===================================================
//casa: need st-st order
//st cam mhit: cannot figure out the youngest
//io: side effect
//remove int ldd and quad ldd, why need ldstdbl?
//===================================================
wire	[2:0]	ld_rawp_st_ackid_g ;

assign  ld_rawp_st_ackid_g[2:0] = 
  (casa_g | stb_cam_mhit | (io_ld & stb_not_empty))?
   stb_wptr_prev[2:0] : ld_rawp_stb_id[2:0] ;
   
dff_s #(3)  rawpackid_w2 (
  .din  (ld_rawp_st_ackid_g[2:0]), 
  .q 	(ld_rawp_st_ackid_w2[2:0]),
  .clk  (clk), 
  .se   (se), .si (), .so ()
  );


   assign lsu_ifu_stbcnt0[3:0] = lsu_stbcnt0[3:0] ;
   assign lsu_ifu_stbcnt1[3:0] = lsu_stbcnt1[3:0] ;
   assign lsu_ifu_stbcnt2[3:0] = lsu_stbcnt2[3:0] ;
   assign lsu_ifu_stbcnt3[3:0] = lsu_stbcnt3[3:0] ;

   assign lsu_ffu_stb_full0 =    lsu_stbcnt0[3];
   assign lsu_ffu_stb_full1 =    lsu_stbcnt1[3];
   assign lsu_ffu_stb_full2 =    lsu_stbcnt2[3];
   assign lsu_ffu_stb_full3 =    lsu_stbcnt3[3];
   
endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_stb_rwdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////
/*
//	Description:	Datapath for STB
//				- Mainly for formatting stb data 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_stb_rwdp (/*AUTOARG*/
   // Outputs
   so, stb_rdata_ramd_buf, stb_rdata_ramd_b74_buf, lsu_stb_st_data_g, 
   // Inputs
   rclk, si, se, rst_tri_en, exu_lsu_rs3_data_e, 
   lsu_stb_data_early_sel_e, lsu_stb_data_final_sel_m, 
   exu_lsu_rs2_data_e, lsu_st_sz_bhww_m, lsu_st_sz_dw_m, 
   lsu_st_sz_bhw_m, lsu_st_sz_wdw_m, lsu_st_sz_b_m, lsu_st_sz_w_m, 
   lsu_st_sz_hw_m, lsu_st_sz_hww_m, ffu_lsu_data, lsu_st_hw_le_g, 
   lsu_st_w_or_dbl_le_g, lsu_st_x_le_g, lsu_swap_sel_default_g, 
   lsu_swap_sel_default_byte_7_2_g, stb_rdata_ramd, 
   stb_rdata_ramd_b74
   ) ;	

   input  rclk ;
   input  si;
   output so;
   input  se;
   input  rst_tri_en;
   
input   [63:0]          exu_lsu_rs3_data_e ;    // data for store.
input	[3:0]		lsu_stb_data_early_sel_e ;// early source of data for stb
input			lsu_stb_data_final_sel_m ;// early source of data for stb
input   [63:0]          exu_lsu_rs2_data_e ;    // rs2 data for cas.
input			lsu_st_sz_bhww_m ;	// byte or hword or word
input			lsu_st_sz_dw_m ;	// double word
input			lsu_st_sz_bhw_m ;	// byte or hword
input			lsu_st_sz_wdw_m ;	// word or dword
input			lsu_st_sz_b_m ;		// byte
input			lsu_st_sz_w_m ;		// word
input			lsu_st_sz_hw_m ;	// hword
input			lsu_st_sz_hww_m ;	// hword or word
input	[63:0]		ffu_lsu_data ;	// fp store data - m stage
//input			lsu_bendian_access_g ;	// bendian st
//input			lsu_stdbl_inst_m ;	// stdbl

   input        lsu_st_hw_le_g;
   input        lsu_st_w_or_dbl_le_g;
   input        lsu_st_x_le_g;
   input        lsu_swap_sel_default_g;
   input        lsu_swap_sel_default_byte_7_2_g;
   
   input [69:0] stb_rdata_ramd;
   input        stb_rdata_ramd_b74;
   
   output [69:0] stb_rdata_ramd_buf;
   output        stb_rdata_ramd_b74_buf;
   
output	[63:0]		lsu_stb_st_data_g ;	// data to be written to stb

wire	[7:0]	byte0, byte1, byte2, byte3 ;
wire	[7:0]	byte4, byte5, byte6, byte7 ;
wire	[7:0]	swap_byte0, swap_byte1, swap_byte2, swap_byte3 ;
wire	[7:0]	swap_byte4, swap_byte5, swap_byte6, swap_byte7 ;

wire	[63:0]	stb_st_data_g ;
wire	[63:0]	stb_st_data_early_e ;
wire	[63:0]	stb_st_data_early_m ;
wire	[63:0]	stb_st_data_final_m ;
wire		st_sz_bhww_g ;
wire		st_sz_dw_g ;
wire		st_sz_bhw_g ;
wire		st_sz_wdw_g ;
wire		st_sz_b_g ;
wire		st_sz_w_g ;
wire		st_sz_hw_g ;
wire		st_sz_hww_g ;
//wire		bendian ;
//wire		stdbl_g ;

   wire clk;
   assign clk = rclk;
   
//assign  stb_st_data_early_e[63:0] =       //@@ bw_u1_muxi41d_2x   
//        lsu_stb_data_early_sel_e[0] ? 64'hffff_ffff_ffff_ffff :            		// ldstub writes all ones
//                lsu_stb_data_early_sel_e[1] ? exu_lsu_rs2_data_e[63:0] :        	// cas pkt1 uses rs2
//                	lsu_stb_data_early_sel_e[2] ? exu_lsu_rs3_data_e[63:0] :   	// use rs3/rd data.
//                		lsu_stb_data_early_sel_e[3] ? {exu_lsu_rs2_data_e[31:0],exu_lsu_rs3_data_e[31:0]} :  
											// else std non-alt
//						64'hxxxx_xxxx_xxxx_xxxx ;				

mux4ds #(64) stb_st_data_early_e_mx (
 .in0 (64'hffff_ffff_ffff_ffff), 
 .in1 (exu_lsu_rs2_data_e[63:0]),
 .in2 (exu_lsu_rs3_data_e[63:0]),
 .in3 ({exu_lsu_rs2_data_e[31:0],exu_lsu_rs3_data_e[31:0]}),
 .sel0(lsu_stb_data_early_sel_e[0]),
 .sel1(lsu_stb_data_early_sel_e[1]),
 .sel2(lsu_stb_data_early_sel_e[2]),
 .sel3(lsu_stb_data_early_sel_e[3]),
 .dout(stb_st_data_early_e[63:0]));
                                    

// Stage early data to m
dff_s #(64)  stgm_rs2     (             //@@ bw_u1_soffi_2x
        .din            (stb_st_data_early_e[63:0]),
        .q              (stb_st_data_early_m[63:0]),
        .clk            (clk),
        .se             (se), .si     (), .so ()
        );

assign  stb_st_data_final_m[63:0] =    //@@ bw_u1_muxi21_2x
        lsu_stb_data_final_sel_m ? stb_st_data_early_m[63:0] : ffu_lsu_data[63:0] ; 	// mux in fpst data

// Precursor of data to be stored in stb
// For ldstub, all one's need to be written to stb.
// For cas/swap, data remains unmodified.
// Stage final data to g
dff_s #(64)  stgg_rs2     (             //@@ bw_u1_soffi_2x
        .din            (stb_st_data_final_m[63:0]),
        .q              (stb_st_data_g[63:0]),
        .clk            (clk),
        .se             (se), .si     (), .so ()
        );

dff_s #(8)  stgm_sel     (             //@@ bw_u1_soff_8x
	.din		({lsu_st_sz_bhww_m,lsu_st_sz_dw_m,lsu_st_sz_bhw_m,lsu_st_sz_wdw_m,
			lsu_st_sz_b_m,lsu_st_sz_w_m,lsu_st_sz_hw_m,lsu_st_sz_hww_m}),
	.q		({st_sz_bhww_g,st_sz_dw_g,st_sz_bhw_g,st_sz_wdw_g,
			st_sz_b_g,st_sz_w_g,st_sz_hw_g,st_sz_hww_g}),
        .clk            (clk),
        .se             (se), .si     (), .so ()
        );

// Now format data for st data.
assign	byte0[7:0] = stb_st_data_g[7:0] ; //@@ PASS
assign	byte1[7:0] = stb_st_data_g[15:8] ; //@@ PASS
assign	byte2[7:0] = stb_st_data_g[23:16] ; //@@ PASS
assign	byte3[7:0] = stb_st_data_g[31:24] ; //@@ PASS
assign	byte4[7:0] = stb_st_data_g[39:32] ; //@@ PASS
assign	byte5[7:0] = stb_st_data_g[47:40] ; //@@ PASS
assign	byte6[7:0] = stb_st_data_g[55:48] ; //@@ PASS
assign	byte7[7:0] = stb_st_data_g[63:56] ; //@@ PASS


//assign	bendian = lsu_bendian_access_g ;	// bendian store

// Control needs to move to lsu_stb_rwctl once this is fully tested.

// First do swap for big-endian vs little-endian case.

//wire	swap_sel_default ;

//assign	swap_sel_default = bendian | (~bendian & st_sz_b_g) ;
 
// swap byte0
//assign	swap_byte0[7:0] =               //@@ bw_u1_muxi41d_4x
//	lsu_swap_sel_default_g ? byte0[7:0] : 
//		lsu_st_hw_le_g ? byte1[7:0] :
//			lsu_st_w_or_dbl_le_g ? byte3[7:0] :
//				lsu_st_x_le_g ? byte7[7:0] : 8'bxxxx_xxxx ; 

mux4ds #(8) swap_byte0_mx (
  .in0 (byte0[7:0]), .sel0(lsu_swap_sel_default_g),
  .in1 (byte1[7:0]), .sel1(lsu_st_hw_le_g),
  .in2 (byte3[7:0]), .sel2(lsu_st_w_or_dbl_le_g),
  .in3 (byte7[7:0]), .sel3(lsu_st_x_le_g),
  .dout(swap_byte0[7:0]));
                         
// swap byte1
//assign	swap_byte1[7:0] =               //@@ bw_u1_muxi41d_4x
//	lsu_swap_sel_default_g ? byte1[7:0] : 
//		lsu_st_hw_le_g ? byte0[7:0] :	
//			 lsu_st_w_or_dbl_le_g ? byte2[7:0] :
//				 lsu_st_x_le_g ? byte6[7:0] : 8'bxxxx_xxxx ; 

mux4ds #(8) swap_byte1_mx (
 .in0 (byte1[7:0]), .sel0(lsu_swap_sel_default_g),
 .in1 (byte0[7:0]), .sel1(lsu_st_hw_le_g),
 .in2 (byte2[7:0]), .sel2(lsu_st_w_or_dbl_le_g),
 .in3 (byte6[7:0]), .sel3(lsu_st_x_le_g),
 .dout (swap_byte1[7:0]));
    
// swap byte2
//assign	swap_byte2[7:0] =                //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte2[7:0] : 
//		lsu_st_w_or_dbl_le_g ? byte1[7:0] :
//			lsu_st_x_le_g ? byte5[7:0] : 8'bxxxx_xxxx ; 
   
mux3ds #(8) swap_byte2_mx (
  .in0 (byte2[7:0]), .sel0(lsu_swap_sel_default_byte_7_2_g),
  .in1 (byte1[7:0]), .sel1(lsu_st_w_or_dbl_le_g),
  .in2 (byte5[7:0]), .sel2(lsu_st_x_le_g),
  .dout (swap_byte2[7:0]));
      
// swap byte3
//assign	swap_byte3[7:0] =                 //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte3[7:0] : 
//		lsu_st_w_or_dbl_le_g ? byte0[7:0] :
//			lsu_st_x_le_g ? byte4[7:0] : 8'bxxxx_xxxx ; 

mux3ds #(8) swap_byte3_mx (
 .in0 (byte3[7:0]), .sel0(lsu_swap_sel_default_byte_7_2_g),
 .in1 (byte0[7:0]), .sel1(lsu_st_w_or_dbl_le_g),
 .in2 (byte4[7:0]), .sel2(lsu_st_x_le_g),
 .dout(swap_byte3[7:0]));
                          
// swap byte4
//assign	swap_byte4[7:0] =                 //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte4[7:0] : 
//		 lsu_st_w_or_dbl_le_g ? byte7[7:0] :
//			 lsu_st_x_le_g ? byte3[7:0] : 8'bxxxx_xxxx ; 

mux3ds #(8) swap_byte4_mx (
.in0 (byte4[7:0]), .sel0(lsu_swap_sel_default_byte_7_2_g),
.in1 (byte7[7:0]), .sel1(lsu_st_w_or_dbl_le_g),
.in2 (byte3[7:0]), .sel2(lsu_st_x_le_g),
.dout(swap_byte4[7:0]));
  
// swap byte5
//assign	swap_byte5[7:0] =                 //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte5[7:0] : 
//		 lsu_st_w_or_dbl_le_g ? byte6[7:0] :
//			  lsu_st_x_le_g ? byte2[7:0] : 8'bxxxx_xxxx ; 

mux3ds #(8) swap_byte5_mx (
 .in0 (byte5[7:0]), .sel0(lsu_swap_sel_default_byte_7_2_g),
 .in1 (byte6[7:0]), .sel1(lsu_st_w_or_dbl_le_g),
 .in2 (byte2[7:0]), .sel2(lsu_st_x_le_g),
 .dout(swap_byte5[7:0]));
 
// swap byte6
//assign	swap_byte6[7:0] =                 //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte6[7:0] : 
//		 lsu_st_w_or_dbl_le_g ? byte5[7:0] :
//			  lsu_st_x_le_g ? byte1[7:0] : 8'bxxxx_xxxx ; 

mux3ds #(8) swap_byte6_mx (
 .in0 (byte6[7:0]), .sel0 (lsu_swap_sel_default_byte_7_2_g),
 .in1 (byte5[7:0]), .sel1 (lsu_st_w_or_dbl_le_g),
 .in2 (byte1[7:0]), .sel2 (lsu_st_x_le_g),
 .dout(swap_byte6[7:0]));
  
// swap byte7
//assign	swap_byte7[7:0] =                 //@@ bw_u1_muxi31d_4x
//	lsu_swap_sel_default_g ? byte7[7:0] : 
//		 lsu_st_w_or_dbl_le_g ? byte4[7:0] :
//		    lsu_st_x_le_g ? byte0[7:0] : 8'bxxxx_xxxx ; 

mux3ds #(8) swap_byte7_mx (
 .in0 (byte7[7:0]), .sel0 (lsu_swap_sel_default_byte_7_2_g),
 .in1 (byte4[7:0]), .sel1 (lsu_st_w_or_dbl_le_g),
 .in2 (byte0[7:0]), .sel2 (lsu_st_x_le_g),
 .dout (swap_byte7[7:0]));
   
// Now replicate date across 8 bytes.

// replicated byte0
assign	lsu_stb_st_data_g[7:0] = swap_byte0[7:0] ;	// all data sizes //@@ bw_u1_inv_8x

// replicated byte1
assign	lsu_stb_st_data_g[15:8] =                 //@@ bw_u1_muxi21_6x
		st_sz_b_g ? swap_byte0[7:0] : swap_byte1[7:0] ;

// replicated byte2
assign	lsu_stb_st_data_g[23:16] =                //@@ bw_u1_muxi21_6x
		st_sz_bhw_g ? swap_byte0[7:0] : swap_byte2[7:0] ;

// replicated byte3
//assign	lsu_stb_st_data_g[31:24] =                 //@@ bw_u1_muxi31d_6x
//		st_sz_b_g ? swap_byte0 :			// swap_byte
//			st_sz_hw_g ? swap_byte1 :	// hword
//				st_sz_wdw_g ? swap_byte3 : // dword or word
//					8'bxxxx_xxxx ;

   wire st_sz_b_g_sel, st_sz_hw_g_sel, st_sz_wdw_g_sel;
   assign st_sz_b_g_sel = st_sz_b_g & ~rst_tri_en;
   assign st_sz_hw_g_sel = st_sz_hw_g & ~rst_tri_en;
   assign st_sz_wdw_g_sel = st_sz_wdw_g | rst_tri_en;
   
mux3ds #(8) rpl_byte3_mx (
  .in0 (swap_byte0[7:0]), .sel0 (st_sz_b_g_sel),
  .in1 (swap_byte1[7:0]), .sel1 (st_sz_hw_g_sel),
  .in2 (swap_byte3[7:0]), .sel2 (st_sz_wdw_g_sel),
  .dout (lsu_stb_st_data_g[31:24]));
                             
// replicated byte4
assign	lsu_stb_st_data_g[39:32] =                 //@@ bw_u1_muxi21_6x
	st_sz_bhww_g ? swap_byte0[7:0] : swap_byte4[7:0] ;	// dword


// replicated byte5
//assign	lsu_stb_st_data_g[47:40] =                 //@@ bw_u1_muxi31d_6x
//		st_sz_b_g ? swap_byte0 :			// swap_byte 
//			st_sz_hww_g ? swap_byte1 :	// hword or word
//				st_sz_dw_g ? swap_byte5 : // dword
//					8'bxxxx_xxxx ;

    wire  st_sz_hww_g_sel, st_sz_dw_g_sel;
   assign st_sz_hww_g_sel = st_sz_hww_g & ~rst_tri_en;
   assign st_sz_dw_g_sel = st_sz_dw_g | rst_tri_en;
  
mux3ds #(8) rpl_byte5_mx (
  .in0 (swap_byte0[7:0]), .sel0(st_sz_b_g_sel),
  .in1 (swap_byte1[7:0]), .sel1(st_sz_hww_g_sel),
  .in2 (swap_byte5[7:0]), .sel2(st_sz_dw_g_sel),
  .dout(lsu_stb_st_data_g[47:40]));
                           
// replicated byte6
//assign	lsu_stb_st_data_g[55:48] =                 //@@ bw_u1_muxi31d_6x
//		st_sz_bhw_g ? swap_byte0 :		// swap_byte or hword
//			st_sz_w_g ? swap_byte2 :		// word
//				st_sz_wdw_g ? swap_byte6 : // dword
//					8'bxxxx_xxxx ;

   wire   st_sz_bhw_g_sel, st_sz_w_g_sel;
   assign st_sz_bhw_g_sel = st_sz_bhw_g & ~rst_tri_en;
   assign st_sz_w_g_sel = st_sz_w_g & ~rst_tri_en;
   
  
mux3ds #(8) rpl_byte6_mx (
  .in0 (swap_byte0[7:0]),
  .in1 (swap_byte2[7:0]),
  .in2 (swap_byte6[7:0]),
  .sel0(st_sz_bhw_g_sel),
  .sel1(st_sz_w_g_sel),
  .sel2(st_sz_dw_g_sel),
  .dout(lsu_stb_st_data_g[55:48]));
 
// replicated byte7
//assign	lsu_stb_st_data_g[63:56] =                //@@ bw_u1_muxi41d_6x
//		st_sz_b_g ? swap_byte0 :			// swap_byte
//			st_sz_hw_g ? swap_byte1 :	// hword
//				st_sz_w_g ? swap_byte3 :	// word
//					st_sz_dw_g ? swap_byte7 : // dword
//						8'bxxxx_xxxx ;

mux4ds #(8) rpl_byte7_mx (
  .in0(swap_byte0[7:0]), .sel0(st_sz_b_g_sel),
  .in1(swap_byte1[7:0]), .sel1(st_sz_hw_g_sel),
  .in2(swap_byte3[7:0]), .sel2(st_sz_w_g_sel),
  .in3(swap_byte7[7:0]), .sel3(st_sz_dw_g_sel),
  .dout (lsu_stb_st_data_g[63:56]));
    
//=========================================================
//stb rdata buffer
   assign stb_rdata_ramd_buf[69:0] = stb_rdata_ramd[69:0];
   assign stb_rdata_ramd_b74_buf = stb_rdata_ramd_b74;
      
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_qctl1.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//////////////////////////////////////////////////////////////////////
/*
//  Description:  LSU Queue Control for Sparc Core  
//      - includes monitoring for pcx queues
//      - control for lsu datapath
//      - rd/wr control of dfq 
*/
////////////////////////////////////////////////////////////////////////
// header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
                  // time scale definition
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_qctl1 ( /*AUTOARG*/
   // Outputs
   lsu_bld_helper_cmplt_m, lsu_bld_cnt_m, lsu_bld_reset, 
   lsu_pcx_rq_sz_b3, lsu_ramtest_rd_w, ld_stb_full_raw_w2, 
   lsu_ld_pcx_rq_sel_d2, spc_pcx_req_pq, spc_pcx_atom_pq, 
   lsu_ifu_pcxpkt_ack_d, pcx_pkt_src_sel, lmq_enable, 
   imiss_pcx_mx_sel, fwd_int_fp_pcx_mx_sel, lsu_ffu_bld_cnt_w, 
   lsu_ld_pcx_rq_mxsel, ld_pcx_thrd, lsu_spu_ldst_ack, 
   pcx_rq_for_stb, pcx_rq_for_stb_d1, lsu_ffu_ack, 
   lsu_ifu_ld_pcxpkt_vld, lsu_pcx_req_squash0, lsu_pcx_req_squash1, 
   lsu_pcx_req_squash2, lsu_pcx_req_squash3, lsu_pcx_req_squash_d1, 
   lsu_pcx_ld_dtag_perror_w2, lsu_tlu_dcache_miss_w2, lsu_bld_pcx_rq, 
   lsu_bld_rq_addr, lsu_fwdpkt_pcx_rq_sel, lsu_imiss_pcx_rq_sel_d1, 
   lsu_tlu_pcxpkt_ack, lsu_intrpt_cmplt, lsu_lmq_byp_misc_sel, 
   lsu_sscan_data, so, lsu_dfq_byp_tid_d1_sel, lmq0_pcx_pkt_way, 
   lmq1_pcx_pkt_way, lmq2_pcx_pkt_way, lmq3_pcx_pkt_way, 
   lsu_st_pcx_rq_pick, lsu_stb_pcx_rvld_d1, lsu_stb_rd_tid, 
   lsu_ld0_spec_vld_kill_w2, lsu_ld1_spec_vld_kill_w2, 
   lsu_ld2_spec_vld_kill_w2, lsu_ld3_spec_vld_kill_w2, 
   lsu_st_pcx_rq_vld, 
   // Inputs
   rclk, si, se, sehold, grst_l, arst_l, lsu_quad_word_access_g, 
   pcx_spc_grant_px, ld_inst_vld_e, lsu_ldst_va_m, stb0_l2b_addr, 
   stb1_l2b_addr, stb2_l2b_addr, stb3_l2b_addr, lsu_ld_miss_g, 
   ifu_lsu_ldst_fp_e, ld_rawp_st_ced_w2, ld_rawp_st_ackid_w2, 
   stb0_crnt_ack_id, stb1_crnt_ack_id, stb2_crnt_ack_id, 
   stb3_crnt_ack_id, ifu_tlu_thrid_e, ldxa_internal, 
   spu_lsu_ldst_pckt, spu_lsu_ldst_pckt_vld, ifu_tlu_inst_vld_m, 
   ifu_lsu_flush_w, ifu_lsu_casa_e, lsu_ldstub_g, lsu_swap_g, 
   stb0_atm_rq_type, stb1_atm_rq_type, stb2_atm_rq_type, 
   stb3_atm_rq_type, tlb_pgnum_g, stb_rd_for_pcx, ffu_lsu_data, 
   ffu_lsu_fpop_rq_vld, ifu_lsu_ldst_dbl_e, ifu_lsu_pcxreq_d, 
   ifu_lsu_destid_s, ifu_lsu_pref_inst_e, tlb_cam_hit_g, 
   lsu_blk_asi_m, stb_cam_hit_bf, lsu_fwdpkt_vld, 
   lsu_dcfill_active_e, dfq_byp_sel, lsu_dfq_ld_vld, lsu_fldd_vld_en, 
   lsu_dfill_dcd_thrd, lsu_fwdpkt_dest, tlu_lsu_pcxpkt_tid, 
   lsu_stb_empty, tlu_lsu_pcxpkt_vld, tlu_lsu_pcxpkt_l2baddr, 
   ld_sec_hit_thrd0, ld_sec_hit_thrd1, ld_sec_hit_thrd2, 
   ld_sec_hit_thrd3, ld_thrd_byp_sel_e, lsu_st_pcx_rq_kill_w2, 
   ifu_lsu_alt_space_e, lsu_dfq_byp_tid, dfq_byp_ff_en, 
   stb_ld_full_raw, stb_ld_partial_raw, stb_cam_mhit, 
   lsu_ldquad_inst_m, stb_cam_wr_no_ivld_m, lsu_ldst_va_way_g, 
   lsu_dcache_rand, lsu_encd_way_hit, lsu_way_hit_or, dc_direct_map, 
   lsu_tlb_perr_ld_rq_kill_w, lsu_dcache_tag_perror_g, 
   lsu_ld_inst_vld_g, asi_internal_m, ifu_lsu_pcxpkt_e_b50, 
   lda_internal_m, atomic_m, lsu_dcache_iob_rd_w, 
   ifu_lsu_fwd_data_vld, rst_tri_en, lsu_no_spc_pref, 
   tlu_early_flush_pipe2_w, lsu_ttype_vld_m2
   );


input     rclk ;
input                   si;
input                   se;
input                   sehold;
input                   grst_l;
input                   arst_l;

//input [1:0] 		ld_pcx_pkt_wy_g ;
input			lsu_quad_word_access_g ;

// LSU <- PCX
// bit5 - FP, bit4 - IO.
input [4:0]             pcx_spc_grant_px ;    // pcx grants packet to destination.
input                   ld_inst_vld_e;        // valid ld inst; d-stage
input [7:6]             lsu_ldst_va_m ;           // Virt. Addr. of ld/st/atomic.

input [2:0]             stb0_l2b_addr ;         // st's addr for pcx - thread0.
input [2:0]             stb1_l2b_addr ;         // st's addr for pcx - thread1.
input [2:0]             stb2_l2b_addr ;         // st's addr for pcx - thread2.
input [2:0]             stb3_l2b_addr ;         // st's addr for pcx - thread3.
input                   lsu_ld_miss_g ;         // load misses in dcache.
//input                   lsu_ld_hit_g ;          // load hits in dcache.
input                   ifu_lsu_ldst_fp_e ;     // fp load/store.

//input                   ld_stb_full_raw_g ;    // full raw for load - thread0
//input                   ld_stb_partial_raw_g ; // partial raw for load - thread0
input                   ld_rawp_st_ced_w2 ;      // store has been acked - thread0
//input                   ld_rawp_st_ced_g ;      // store has been acked - thread0
input   [2:0]           ld_rawp_st_ackid_w2 ;    // ackid for acked store - thread0
input [2:0]             stb0_crnt_ack_id ;      // ackid for crnt outstanding st. 
input [2:0]             stb1_crnt_ack_id ;      // ackid for crnt outstanding st. 
input [2:0]             stb2_crnt_ack_id ;      // ackid for crnt outstanding st. 
input [2:0]             stb3_crnt_ack_id ;      // ackid for crnt outstanding st. 
input [1:0]             ifu_tlu_thrid_e ;       // thread-id
input                   ldxa_internal ;         // internal ldxa, stg g 

input [64+7:64+6] spu_lsu_ldst_pckt ;  // addr bits
input                   spu_lsu_ldst_pckt_vld ; // vld
input                   ifu_tlu_inst_vld_m ;    // inst is vld - wstage

input                   ifu_lsu_flush_w ;  	// ifu's flush
input                   ifu_lsu_casa_e ;        // compare-swap instr
input                   lsu_ldstub_g ;          // ldstub(a) instruction
input                   lsu_swap_g ;            // swap(a) instruction 
input  [2:1]            stb0_atm_rq_type ;      // stb pcx rq type - atomic
input  [2:1]            stb1_atm_rq_type ;      // stb pcx rq type - atomic
input  [2:1]            stb2_atm_rq_type ;      // stb pcx rq type - atomic
input  [2:1]            stb3_atm_rq_type ;      // stb_pcx_rq_type - atomic
input [39:37]           tlb_pgnum_g ;           // ldst access to io 
input [3:0]             stb_rd_for_pcx ;        // rd for pcx can be scheduled
input [80:79]           ffu_lsu_data ;
input                   ffu_lsu_fpop_rq_vld ;   // ffu dispatches fpop issue request.
input                   ifu_lsu_ldst_dbl_e ;    // ld/st double
input                   ifu_lsu_pcxreq_d ;
input   [2:0]           ifu_lsu_destid_s ;
input			ifu_lsu_pref_inst_e ;	   // prefetch inst
input 			tlb_cam_hit_g ;		   // tlb cam hit ; error included
input			lsu_blk_asi_m ;
//input                   stb_cam_wptr_vld;
input		        stb_cam_hit_bf;

input                   lsu_fwdpkt_vld;
//input  [3:0]            lsu_error_rst;
input                   lsu_dcfill_active_e;
input  [3:0]            dfq_byp_sel ;	
//input  [3:0]            lsu_dfq_byp_mxsel ;	
//input  [3:0]            lsu_st_ack_rq_stb ;
input                   lsu_dfq_ld_vld;
input                   lsu_fldd_vld_en;
input  [3:0]            lsu_dfill_dcd_thrd ;
input  [4:0]            lsu_fwdpkt_dest ;
   
input [19:18]           tlu_lsu_pcxpkt_tid ;
input   [3:0]           lsu_stb_empty ;
input                   tlu_lsu_pcxpkt_vld ;
input [11:10]           tlu_lsu_pcxpkt_l2baddr ;
input                   ld_sec_hit_thrd0 ;      // ld has sec. hit against th0
input                   ld_sec_hit_thrd1 ;      // ld has sec. hit against th1
input                   ld_sec_hit_thrd2 ;      // ld has sec. hit against th2
input                   ld_sec_hit_thrd3 ;      // ld has sec. hit against th3
input [2:0]             ld_thrd_byp_sel_e ;       // stb,ldxa thread byp sel
input   [3:0]   	lsu_st_pcx_rq_kill_w2 ;

input			ifu_lsu_alt_space_e ;
input   [1:0]           lsu_dfq_byp_tid;

input                   dfq_byp_ff_en;

//input	[3:0]		lsu_dtag_perror_w2 ;

input [7:0]   		stb_ld_full_raw ;
input [7:0]   		stb_ld_partial_raw ;

input			stb_cam_mhit ;		// multiple hits in stb
input      		lsu_ldquad_inst_m ; // ldquad inst

input			stb_cam_wr_no_ivld_m ;

input  [1:0]            lsu_ldst_va_way_g ;          // 12:11 for direct map
input  [1:0]            lsu_dcache_rand;
input  [1:0]            lsu_encd_way_hit;
input                   lsu_way_hit_or;
input                   dc_direct_map;
//input                   lsu_quad_asi_g;

input			lsu_tlb_perr_ld_rq_kill_w ;

input                   lsu_dcache_tag_perror_g ;  // dcache tag parity error
input   [3:0]           lsu_ld_inst_vld_g ;
//input                  lsu_pcx_ld_dtag_perror_w2 ;	// from qctl2

input			asi_internal_m ;

input			ifu_lsu_pcxpkt_e_b50 ;

input			lda_internal_m ;
input			atomic_m ;

input			lsu_dcache_iob_rd_w ;
input			ifu_lsu_fwd_data_vld ;

input                   rst_tri_en ;

output			lsu_bld_helper_cmplt_m ;
output	[2:0]		lsu_bld_cnt_m ;
output			lsu_bld_reset ;

output			lsu_pcx_rq_sz_b3 ;

output			lsu_ramtest_rd_w ;


output 	   		ld_stb_full_raw_w2 ;

output 	[3:0]		lsu_ld_pcx_rq_sel_d2 ;
   
output  [4:0]           spc_pcx_req_pq;         // request destination for packet.
              // FPU, IO, L2_BANK[3:0].
              // 1-hot - create monitor !
output                  spc_pcx_atom_pq ;       // atomic packet. 
output                  lsu_ifu_pcxpkt_ack_d ;  // ack for I$ fill request.
output  [3:0]           pcx_pkt_src_sel ;	// - qdp1
output  [3:0]           lmq_enable ;	// - qdp1
output                  imiss_pcx_mx_sel ;	// - qdp1
output  [2:0]           fwd_int_fp_pcx_mx_sel ;	// - qdp1
output	[2:0]		lsu_ffu_bld_cnt_w ;
//output  [3:0]           ld_pcx_rq_sel ;	// - qctl2
output  [3:0]           lsu_ld_pcx_rq_mxsel ;	// - qdp1
output  [1:0]           ld_pcx_thrd ;	// - qdp1
output                  lsu_spu_ldst_ack ;  // strm ld/st ack to spu
//output                  strm_sldst_cam_vld; // strm ld/st xslate rq
//output                  strm_sld_dc_rd_vld; // strm alloc. ld xslate rq.
//output                  strm_sldst_cam_d2;  // strm ld/st xslate rq-d2
output  [3:0]           pcx_rq_for_stb ;      // pcx demands rd for store - stb_ctl
output  [3:0]           pcx_rq_for_stb_d1 ;  // pcx demands rd for store - qdp2
output                  lsu_ffu_ack ;         // ack to ffu.
output                  lsu_ifu_ld_pcxpkt_vld ;
//output  [3:0]           lsu_iobrdge_rply_data_sel ;	// - qdp1
//output                  lsu_pcx_req_squash ;
output                  lsu_pcx_req_squash0 ;
output                  lsu_pcx_req_squash1 ;
output                  lsu_pcx_req_squash2 ;
output                  lsu_pcx_req_squash3 ;
output                  lsu_pcx_req_squash_d1 ;
output                  lsu_pcx_ld_dtag_perror_w2 ;	// - qdp1
output	[3:0]		lsu_tlu_dcache_miss_w2 ;
output 			lsu_bld_pcx_rq ;	// cycle after request	// - qdp1
output [1:0] 		lsu_bld_rq_addr ;	// cycle after request	// - qdp1
//output			lsu_ifu_flush_ireg ;

output                 lsu_fwdpkt_pcx_rq_sel ;
//output                 lsu_ld0_pcx_rq_sel_d1, lsu_ld1_pcx_rq_sel_d1 ;
//output                 lsu_ld2_pcx_rq_sel_d1, lsu_ld3_pcx_rq_sel_d1 ;
output                 lsu_imiss_pcx_rq_sel_d1 ;
output                 lsu_tlu_pcxpkt_ack;
output  [3:0]           lsu_intrpt_cmplt ;      // intrpt can restart thread
//output                  lsu_ld_sec_hit_l2access_g ;
//output  [1:0]           lsu_ld_sec_hit_wy_g ;
output  [3:0]           lsu_lmq_byp_misc_sel ;    // select g-stage lmq source

output	[12:0]		lsu_sscan_data ;

output                  so;
output  [3:0]           lsu_dfq_byp_tid_d1_sel;


   input [3:0]          lsu_no_spc_pref;
   
//output  [1:0]           lsu_lmq_pkt_way_g;
output  [2-1:0]           lmq0_pcx_pkt_way;
output  [2-1:0]           lmq1_pcx_pkt_way;
output  [2-1:0]           lmq2_pcx_pkt_way;
output  [2-1:0]           lmq3_pcx_pkt_way;
output  [3:0]           lsu_st_pcx_rq_pick;

// signals related to logic moved from stb_rwctl
output                  lsu_stb_pcx_rvld_d1;
output  [1:0]           lsu_stb_rd_tid;

output                  lsu_ld0_spec_vld_kill_w2 ;
output                  lsu_ld1_spec_vld_kill_w2 ;
output                  lsu_ld2_spec_vld_kill_w2 ;
output                  lsu_ld3_spec_vld_kill_w2 ;

output                  lsu_st_pcx_rq_vld ;


   input                tlu_early_flush_pipe2_w;
   input                lsu_ttype_vld_m2;

/* adif: added this parameter to fix L2 bank packet destinations */
localparam AVAILABLE_L2_BANKS  = 4'b0001; 

   
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

wire  thread0_e,thread1_e,thread2_e,thread3_e;
wire  thread0_w2,thread1_w2,thread2_w2,thread3_w2;
wire    ld0_inst_vld_e,ld1_inst_vld_e,ld2_inst_vld_e,ld3_inst_vld_e ;
wire    ld0_inst_vld_g,ld1_inst_vld_g,ld2_inst_vld_g,ld3_inst_vld_g ;
wire    ld0_inst_vld_w2,ld1_inst_vld_w2,ld2_inst_vld_w2,ld3_inst_vld_w2 ;
//wire    st_inst_vld_m,st_inst_vld_g;
wire  imiss_pcx_rq_sel_d1, strm_pcx_rq_sel_d1 ;
wire  imiss_pcx_rq_sel_d2 ;
wire    fpop_pcx_rq_sel_d1, fpop_pcx_rq_sel_d2 ;
wire        imiss_pcx_rq_sel ;
wire        imiss_pkt_vld ;
wire  [2:0]     imiss_l2bnk_addr ;
wire  [4:0]     imiss_l2bnk_dest ;
wire    fpst_vld_m, fpst_vld_g ;
wire    fpop_vld_reset ;
wire    fpop_pcx_rq_sel ;
wire    fpop_pcx_rq_sel_tmp ;
wire    fpop_vld_en ;
wire    fpop_pkt1 ;
wire    fpop_pkt_vld,fpop_pkt_vld_unmasked ;
wire    fpop_atom_req, fpop_atom_rq_pq ;
wire  [4:0] fpop_l2bnk_dest ;
wire        pcx_req_squash ;
wire  [4:0] strm_l2bnk_dest ;
wire    strm_pkt_vld;
wire        st0_pkt_vld ;
wire        st1_pkt_vld ;
wire        st2_pkt_vld ;
wire        st3_pkt_vld ;
wire    st0_pcx_rq_sel_d1, st1_pcx_rq_sel_d1;
wire    st2_pcx_rq_sel_d1, st3_pcx_rq_sel_d1;
wire    st0_pcx_rq_sel_d2, st1_pcx_rq_sel_d2;
wire    st2_pcx_rq_sel_d2, st3_pcx_rq_sel_d2;
wire    st0_pcx_rq_sel_d3, st1_pcx_rq_sel_d3;
wire    st2_pcx_rq_sel_d3, st3_pcx_rq_sel_d3;
wire    st0_cas_vld, st1_cas_vld, st2_cas_vld, st3_cas_vld ;
wire    st0_atomic_vld, st1_atomic_vld, st2_atomic_vld, st3_atomic_vld ;
wire  [4:0]     st0_l2bnk_dest,st1_l2bnk_dest ;
wire  [4:0]     st2_l2bnk_dest,st3_l2bnk_dest ;
wire	bld_helper_cmplt_e, bld_helper_cmplt_m, bld_helper_cmplt_g ;	
wire	bld_din,bld_dout ;
wire	bld_g ;
wire	bld_en ;
wire	[1:0]	bld_cnt ;
wire	[1:0]	bcnt_din ;
wire	[2:0]	bld_rd_din, bld_rd_dout, bld_rd_dout_m ;
wire	[3:0]	bld_annul,bld_annul_d1 ;
wire	bld_rd_en ;
wire    casa_m, casa_g ;
wire        ld0_vld_reset, ld0_pkt_vld ;
wire        ld0_pcx_rq_sel_d2, ld1_pcx_rq_sel_d2 ;
wire        ld2_pcx_rq_sel_d2, ld3_pcx_rq_sel_d2 ;
wire    ld0_fill_reset, ld1_fill_reset,ld2_fill_reset,ld3_fill_reset;
wire    ld0_fill_reset_d1,ld1_fill_reset_d1,ld2_fill_reset_d1,ld3_fill_reset_d1;
wire    ld0_fill_reset_d2,ld1_fill_reset_d2,ld2_fill_reset_d2,ld3_fill_reset_d2;
wire    ld0_fill_reset_d2_tmp,ld1_fill_reset_d2_tmp,ld2_fill_reset_d2_tmp,ld3_fill_reset_d2_tmp;
wire  [4:0]     ld0_l2bnk_dest, ld1_l2bnk_dest ;
wire  [4:0]     ld2_l2bnk_dest, ld3_l2bnk_dest ;
wire        ld1_vld_reset, ld1_pkt_vld ;
wire        ld2_vld_reset, ld2_pkt_vld ;
wire        ld3_vld_reset, ld3_pkt_vld ;
//wire    casa0_g, casa1_g, casa2_g, casa3_g;
wire    ld0_rawp_reset,ld0_rawp_en,ld0_rawp_disabled;
wire    ld1_rawp_reset,ld1_rawp_en,ld1_rawp_disabled;
wire    ld2_rawp_reset,ld2_rawp_en,ld2_rawp_disabled;
wire    ld3_rawp_reset,ld3_rawp_en,ld3_rawp_disabled;
wire  [2:0] ld0_rawp_ackid,ld1_rawp_ackid ;
wire  [2:0] ld2_rawp_ackid,ld3_rawp_ackid ;
wire        ld0_pcx_rq_vld, ld1_pcx_rq_vld ;
wire        ld2_pcx_rq_vld, ld3_pcx_rq_vld ;
wire  [4:0]     queue_write ;
wire	mcycle_squash_d1 ;
//wire        ld_pcx_rq_vld, st_pcx_rq_vld ;
wire  [4:0] st0_q_wr,st1_q_wr,st2_q_wr,st3_q_wr ;
wire  [4:0]     sel_qentry0 ;
wire    st0_atom_rq,st1_atom_rq,st2_atom_rq,st3_atom_rq ;
wire    st0_atom_rq_d1,st1_atom_rq_d1,st2_atom_rq_d1,st3_atom_rq_d1 ;
wire    st0_cas_vld_d1,st1_cas_vld_d1,st2_cas_vld_d1,st3_cas_vld_d1 ;
wire    st0_atom_rq_d2,st1_atom_rq_d2,st2_atom_rq_d2,st3_atom_rq_d2 ;
wire    st0_cas_vld_d2,st1_cas_vld_d2,st2_cas_vld_d2,st3_cas_vld_d2 ;
//wire    st_cas_rq_d2,st_quad_rq_d2;
wire    st_cas_rq_d2 ;
wire        st0_pcx_rq_vld, st1_pcx_rq_vld;
wire        st2_pcx_rq_vld, st3_pcx_rq_vld;
wire    st_atom_rq ;
wire    st_atom_rq_d1 ;
wire        imiss_pcx_rq_vld ;
wire  [4:0] spc_pcx_req_update_g,spc_pcx_req_update_w2 ;
wire    strm_pcx_rq_vld ;
wire    fwdpkt_rq_vld ;
wire    intrpt_pcx_rq_vld ;
wire    fpop_pcx_rq_vld ;
wire	[4:0]	pre_qwr ;
wire        ld0_pcx_rq_sel, ld1_pcx_rq_sel ;
wire        ld2_pcx_rq_sel, ld3_pcx_rq_sel ;
wire    strm_pcx_rq_sel ;
wire    intrpt_pcx_rq_sel ;
//wire    imiss_strm_pcx_rq_sel ;
//wire  [2:0]     dest_pkt_sel ;
wire  [4:0] spc_pcx_req_g ;
wire  [1:0]   strm_l2bnk_addr ;
wire  [2:0]     ld0_l2bnk_addr, ld1_l2bnk_addr ;
wire  [2:0]     ld2_l2bnk_addr, ld3_l2bnk_addr ;
wire  [4:0]     current_pkt_dest ;
wire  [7:6]      ldst_va_m, ldst_va_g ;
wire  [4:0]     ld_pkt_dest ;
wire  [4:0] st_pkt_dest  ;


wire  [4:0]            intrpt_l2bnk_dest ;
wire                   pcx_req_squash_d1, pcx_req_squash_d2 ;
wire                   intrpt_pcx_rq_sel_d1 ;
wire  [2:0] intrpt_l2bnk_addr ;
//wire                  st0_stq_vld,st1_stq_vld,st2_stq_vld,st3_stq_vld ;
wire        st0_pcx_rq_sel, st1_pcx_rq_sel;
wire        st2_pcx_rq_sel, st3_pcx_rq_sel;
//wire    ld0_sec_hit_g,ld1_sec_hit_g,ld2_sec_hit_g,ld3_sec_hit_g;
wire    ld0_sec_hit_w2,ld1_sec_hit_w2,ld2_sec_hit_w2,ld3_sec_hit_w2;
//wire  [3:0] dfq_byp_sel_m, dfq_byp_sel_g ;
//wire  [3:0] dfq_byp_sel_m;
wire                 ld0_unfilled,ld1_unfilled,ld2_unfilled,ld3_unfilled;
wire                 ld0_unfilled_tmp,ld1_unfilled_tmp,ld2_unfilled_tmp,ld3_unfilled_tmp;
wire  [2-1:0]          ld0_unfilled_wy,ld1_unfilled_wy,ld2_unfilled_wy,ld3_unfilled_wy ;
wire        ld0_l2cache_rq,ld1_l2cache_rq ;
wire        ld2_l2cache_rq,ld3_l2cache_rq ;
wire                 ld0_pcx_rq_sel_d1, ld1_pcx_rq_sel_d1 ;
wire                 ld2_pcx_rq_sel_d1, ld3_pcx_rq_sel_d1 ;
wire         intrpt_pkt_vld;
wire                 fwdpkt_pcx_rq_sel;
wire		fwdpkt_pcx_rq_sel_d1,fwdpkt_pcx_rq_sel_d2,fwdpkt_pcx_rq_sel_d3 ;
wire         reset,dbb_reset_l;
wire         clk;
//wire         st_inst_vld_unflushed;
wire         ldst_dbl_g;
//wire                  lsu_ld_sec_hit_l2access_g ;
wire                  lsu_ld_sec_hit_l2access_w2 ;
//wire  [1:0]           lsu_ld_sec_hit_wy_g ;
wire  [2-1:0]           lsu_ld_sec_hit_wy_w2 ;
//wire  [1:0]  ld_way;
//wire [1:0]	      ld_pcx_pkt_wy_g ;

wire	[3:0]		lsu_dtag_perror_w2 ;

wire	[3:0]		lmq_enable_w2 ;
wire  ld0_spec_pick_vld_g ,
      ld0_spec_pick_vld_w2 ;
wire  ld1_spec_pick_vld_g ,
      ld1_spec_pick_vld_w2 ;
wire  ld2_spec_pick_vld_g ,
      ld2_spec_pick_vld_w2 ;
wire  ld3_spec_pick_vld_g ,
      ld3_spec_pick_vld_w2 ;
wire  non_l2bnk_mx0_d1 ;
wire  non_l2bnk_mx1_d1 ;
wire  non_l2bnk_mx2_d1 ;
wire  non_l2bnk_mx3_d1 ;
wire  lsu_pcx_req_squash ;
wire  spc_pcx_atom_pq_buf2 ;
wire  [4:0]  spc_pcx_req_pq_buf2 ;
wire         lsu_ld0_pcx_rq_sel_d1, lsu_ld1_pcx_rq_sel_d1 ;
wire         lsu_ld2_pcx_rq_sel_d1, lsu_ld3_pcx_rq_sel_d1 ;

wire  [3:0]  ld_thrd_force_d1 ;
wire  [3:0]  st_thrd_force_d1 ;
wire  [3:0]  misc_thrd_force_d1 ;
wire  [3:0]  ld_thrd_force_vld ;
wire  [3:0]  st_thrd_force_vld ;
wire  [3:0]  misc_thrd_force_vld ;
wire  [3:0]  all_thrd_force_vld ;
wire  [3:0]  ld_thrd_pick_din ;
wire  [3:0]  st_thrd_pick_din ;
wire  [3:0]  misc_thrd_pick_din ;
wire  [3:0]  ld_thrd_pick_status_din ;
wire  [3:0]  st_thrd_pick_status_din ;
wire  [3:0]  misc_thrd_pick_status_din ;
wire  [3:0]  ld_thrd_pick_status ;
wire  [3:0]  st_thrd_pick_status ;
wire  [3:0]  misc_thrd_pick_status ;
wire         ld_thrd_pick_rst ;
wire         st_thrd_pick_rst ;
wire         misc_thrd_pick_rst ;
wire         all_thrd_pick_rst ;


   
   
assign  clk = rclk;

    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

assign  reset  =  ~dbb_reset_l;


//assign	lsu_ifu_flush_ireg = 1'b0 ;
//=================================================================================================
// TEMP !! rm from vlin.filter also !!
//=================================================================================================

wire atm_in_stb_g ;
assign atm_in_stb_g = 1'b0 ;

//=================================================================================================
// LOGIC MOVED FROM STB_RWCTL
//=================================================================================================

// pcx is making request for data in current cycle. Can be multi-hot.
//assign  pcx_any_rq_for_stb = |pcx_rq_for_stb[3:0] ;
//assign  pcx_any_rq_for_stb = 
//        (pcx_rq_for_stb[0] & ~lsu_st_pcx_rq_kill_w2[0]) | 
//        (pcx_rq_for_stb[1] & ~lsu_st_pcx_rq_kill_w2[1]) | 
//        (pcx_rq_for_stb[2] & ~lsu_st_pcx_rq_kill_w2[2]) | 
//        (pcx_rq_for_stb[3] & ~lsu_st_pcx_rq_kill_w2[3]) ; 
//
//dff #(1)  prvld_stgd1 (
//  .din  (pcx_any_rq_for_stb), 
//  .q  (lsu_stb_pcx_rvld_d1),
//  .clk  (clk), 
//  .se (1'b0), .si (), .so ()
//  );

// replacement for above logic - pcx_rq_for_stb is already qual'ed w/ lsu_st_pcx_rq_kill_w2
// this signal is used in qdp1 and qdp2 as pcx paket valids.
assign  lsu_stb_pcx_rvld_d1  =  st3_pcx_rq_sel_d1 |
                                st2_pcx_rq_sel_d1 |
                                st1_pcx_rq_sel_d1 | 
                                st0_pcx_rq_sel_d1 ;


//assign  stb_rd_tid[0] = pcx_rq_for_stb[1] | pcx_rq_for_stb[3] ;
//assign  stb_rd_tid[1] = pcx_rq_for_stb[2] | pcx_rq_for_stb[3] ;
//
//dff #(2) stbtid_stgd1 (
//  .din    (stb_rd_tid[1:0]),  .q  (lsu_stb_rd_tid[1:0]),
//  .clk    (clk),
//  .se   (1'b0), .si (), .so ()
//  );

assign  lsu_stb_rd_tid[0]  =  st1_pcx_rq_sel_d1 | st3_pcx_rq_sel_d1;
assign  lsu_stb_rd_tid[1]  =  st2_pcx_rq_sel_d1 | st3_pcx_rq_sel_d1;

//=================================================================================================

assign	lsu_ramtest_rd_w = lsu_dcache_iob_rd_w | ifu_lsu_fwd_data_vld ;

//=================================================================================================
// LD PCX PKT WAY
//=================================================================================================


// For direct-map mode, assume that addition set-index bits 12:11 are
// used to file line in set.
// timing fix: 5/19/03: move secondary hit way generation to w2
//assign  ld_way[1:0] = 
//    lsu_way_hit_or ? lsu_encd_way_hit[1:0]: 
//                lsu_ld_sec_hit_l2access_g ? lsu_ld_sec_hit_wy_g[1:0] :
//                        (dc_direct_map ? lsu_ldst_va_way_g[1:0] : lsu_dcache_rand[1:0]) ;
//
//assign  lsu_lmq_pkt_way_g[1:0] = 
//(ldst_dbl_g & st_inst_vld_unflushed & lsu_quad_asi_g) ? 2'b01 :
//        casa_g ? 2'b00 : ld_way[1:0] ;
//
//assign  ld_pcx_pkt_wy_g[1:0] = lsu_lmq_pkt_way_g[1:0];
wire  [2-1:0]  ld_way_mx1_g , ld_way_mx2_g , ld_way_mx2_w2;

assign  ld_way_mx1_g[2-1:0] = 
    lsu_way_hit_or ? lsu_encd_way_hit[2-1:0]: 
                        (dc_direct_map ? lsu_ldst_va_way_g[2-1:0] : lsu_dcache_rand[2-1:0]) ;

assign  ld_way_mx2_g[2-1:0] = 
//(ldst_dbl_g & st_inst_vld_unflushed & lsu_quad_asi_g) ? 2'b01 :  //quad st, obsolete
        casa_g ? {2{1'b0}} : ld_way_mx1_g[2-1:0] ;

dff_s #(2)  ff_ld_way_mx2_w2 (
        .din    (ld_way_mx2_g[2-1:0]),
        .q      (ld_way_mx2_w2[2-1:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire  [2-1:0]  lsu_lmq_pkt_way_w2;
assign  lsu_lmq_pkt_way_w2[2-1:0] =  lsu_ld_sec_hit_l2access_w2 ? lsu_ld_sec_hit_wy_w2[2-1:0] :
                                         ld_way_mx2_w2[2-1:0];

//bug2705 - add mx for way in w2-cycle
wire  [2-1:0]  lmq0_pcx_pkt_way_tmp, lmq1_pcx_pkt_way_tmp, lmq2_pcx_pkt_way_tmp, lmq3_pcx_pkt_way_tmp ;

assign  lmq0_pcx_pkt_way[2-1:0] =  ld0_spec_pick_vld_w2 ? lsu_lmq_pkt_way_w2[2-1:0] : lmq0_pcx_pkt_way_tmp[2-1:0] ;
assign  lmq1_pcx_pkt_way[2-1:0] =  ld1_spec_pick_vld_w2 ? lsu_lmq_pkt_way_w2[2-1:0] : lmq1_pcx_pkt_way_tmp[2-1:0] ;
assign  lmq2_pcx_pkt_way[2-1:0] =  ld2_spec_pick_vld_w2 ? lsu_lmq_pkt_way_w2[2-1:0] : lmq2_pcx_pkt_way_tmp[2-1:0] ;
assign  lmq3_pcx_pkt_way[2-1:0] =  ld3_spec_pick_vld_w2 ? lsu_lmq_pkt_way_w2[2-1:0] : lmq3_pcx_pkt_way_tmp[2-1:0] ;

wire	qword_access0,qword_access1,qword_access2,qword_access3;

// Extend by 1-b to add support for 3rd size bit for iospace.
// move the flops from qdp1 to qctl1
dffe_s #(2)  ff_lmq0_pcx_pkt_way (
           .din    (lsu_lmq_pkt_way_w2[2-1:0]),
           .q      (lmq0_pcx_pkt_way_tmp[2-1:0]),
           .en     (lmq_enable_w2[0]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s #(2)  ff_lmq1_pcx_pkt_way (
           .din    (lsu_lmq_pkt_way_w2[2-1:0]),
           .q      (lmq1_pcx_pkt_way_tmp[2-1:0]),
           .en     (lmq_enable_w2[1]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s #(2)  ff_lmq2_pcx_pkt_way (
           .din    (lsu_lmq_pkt_way_w2[2-1:0]),
           .q      (lmq2_pcx_pkt_way_tmp[2-1:0]),
           .en     (lmq_enable_w2[2]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s #(2)  ff_lmq3_pcx_pkt_way (
           .din    (lsu_lmq_pkt_way_w2[2-1:0]),
           .q      (lmq3_pcx_pkt_way_tmp[2-1:0]),
           .en     (lmq_enable_w2[3]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );

// Q Word Access to IO
dffe_s   ff_lmq0_qw (
           .din    (lsu_quad_word_access_g),
           .q      (qword_access0),
           .en     (lmq_enable[0]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s   ff_lmq1_qw (
           .din    (lsu_quad_word_access_g),
           .q      (qword_access1),
           .en     (lmq_enable[1]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s   ff_lmq2_qw(
           .din    (lsu_quad_word_access_g),
           .q      (qword_access2),
           .en     (lmq_enable[2]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
dffe_s   ff_lmq3_qw (
           .din    (lsu_quad_word_access_g),
           .q      (qword_access3),
           .en     (lmq_enable[3]),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );

assign	lsu_pcx_rq_sz_b3 =
	(ld0_pcx_rq_sel_d1 & qword_access0) |
	(ld1_pcx_rq_sel_d1 & qword_access1) |
	(ld2_pcx_rq_sel_d1 & qword_access2) |
	(ld3_pcx_rq_sel_d1 & qword_access3) ;

//=================================================================================================
// SHADOW SCAN
//=================================================================================================


// Monitors outstanding loads. This would hang a thread.
assign	lsu_sscan_data[3:0] = 
		{ld0_pcx_rq_vld, ld1_pcx_rq_vld , ld2_pcx_rq_vld , ld3_pcx_rq_vld} ;
// Monitors outstanding loads. This would hang issue from stb
assign	lsu_sscan_data[7:4] = 
		{st0_pcx_rq_vld, st1_pcx_rq_vld, st2_pcx_rq_vld, st3_pcx_rq_vld} ;
assign	lsu_sscan_data[8] = imiss_pcx_rq_vld ; 	// imiss
assign	lsu_sscan_data[9] = strm_pcx_rq_vld ;  	// strm
assign	lsu_sscan_data[10] = fwdpkt_rq_vld ;	// fwd rply/rq 
assign	lsu_sscan_data[11] = intrpt_pcx_rq_vld ; // intrpt
assign	lsu_sscan_data[12] = fpop_pcx_rq_vld ;	// fpop


//=================================================================================================
// QDP1 selects
//=================================================================================================

wire [3:0] dfq_byp_tid_sel;
   
assign dfq_byp_tid_sel[0]  =  (lsu_dfq_byp_tid[1:0]==2'b00);
assign dfq_byp_tid_sel[1]  =  (lsu_dfq_byp_tid[1:0]==2'b01);
assign dfq_byp_tid_sel[2]  =  (lsu_dfq_byp_tid[1:0]==2'b10);
assign dfq_byp_tid_sel[3]  =  (lsu_dfq_byp_tid[1:0]==2'b11);
//assign dfq_byp_tid__sel[3]  =  ~|(lsu_dfq_byp_d1_sel[2:0]);

wire  [3:0]  lsu_dfq_byp_tid_d1_sel_tmp ;
   
dffe_s #(4)  dfq_byp_tid_sel_ff (
           .din    (dfq_byp_tid_sel[3:0]),
           .q      (lsu_dfq_byp_tid_d1_sel_tmp[3:0]),
           .en     (dfq_byp_ff_en),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );

//11/21/03 - add rst_tri_en to lsu_dfq_byp_tid_d1_sel[3:0] going to qdp1 as dfq_byp_sel[3:0]

assign  lsu_dfq_byp_tid_d1_sel[2:0]  =  lsu_dfq_byp_tid_d1_sel_tmp[2:0]  & {3{~rst_tri_en}};
assign  lsu_dfq_byp_tid_d1_sel[3]    =  lsu_dfq_byp_tid_d1_sel_tmp[3]    | rst_tri_en;


//=================================================================================================
// INST_VLD_W GENERATION
//=================================================================================================


wire [1:0] thrid_m, thrid_g ;
dff_s #(2)  stgm_thrid (
        .din    (ifu_tlu_thrid_e[1:0]),
        .q      (thrid_m[1:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(2) stgg_thrid (
        .din    (thrid_m[1:0]),
        .q      (thrid_g[1:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	flush_w_inst_vld_m ;
wire	lsu_inst_vld_w,lsu_inst_vld_tmp ;
wire	other_flush_pipe_w ;
wire  qctl1_flush_pipe_w;
   
assign	flush_w_inst_vld_m = 
	ifu_tlu_inst_vld_m & 
	~(qctl1_flush_pipe_w & (thrid_m[1:0] == thrid_g[1:0])) ; // really lsu_flush_pipe_w
   
dff_s  stgw_ivld (
        .din    (flush_w_inst_vld_m),
        .q      (lsu_inst_vld_tmp),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


assign	other_flush_pipe_w = tlu_early_flush_pipe2_w | (lsu_ttype_vld_m2 & lsu_inst_vld_tmp);     
assign	qctl1_flush_pipe_w = other_flush_pipe_w | ifu_lsu_flush_w ;

assign	lsu_inst_vld_w = lsu_inst_vld_tmp & ~qctl1_flush_pipe_w ;


//=================================================================================================
// SECONDARY VS. PRIMARY LOADS
//=================================================================================================

// An incoming load can hit can match addresses with an outstanding load request
// from another thread. In this case, the secondary load must wait until the primary
// load returns and then it will bypass (but not fill). There can only be one primary
// load but multiple secondary loads. The secondary loads will not enter the dfq.
// The primary load will however be recirculated until all secondary loads have bypassed.

// Could have multiple secondary hits. Only one thread can be chosen
// as primary though.

//An incoming load can match addresses with any outstanding load request from other threads.
//can be multiple hits
// timing fix: 5/19/03: move secondary hit way generation to w2
//
//assign  ld0_sec_hit_g = ld_sec_hit_thrd0 & ld0_unfilled  ;
//assign  ld1_sec_hit_g = ld_sec_hit_thrd1 & ld1_unfilled  ;
//assign  ld2_sec_hit_g = ld_sec_hit_thrd2 & ld2_unfilled  ;
//assign  ld3_sec_hit_g = ld_sec_hit_thrd3 & ld3_unfilled  ;
//
//
// Fix for Bug1606
//assign  lsu_ld_sec_hit_l2access_g =
//         ld0_sec_hit_g | ld1_sec_hit_g | ld2_sec_hit_g | ld3_sec_hit_g ;
//
//phase 2
//since can be multiple hits, it isn't one-hot mux, but fix priority-sel mux
//assign  lsu_ld_sec_hit_wy_g[1:0] =
//    ld0_sec_hit_g ? ld0_unfilled_wy[1:0] :
//      ld1_sec_hit_g ? ld1_unfilled_wy[1:0] :
//        ld2_sec_hit_g ? ld2_unfilled_wy[1:0] :
//          ld3_sec_hit_g ? ld3_unfilled_wy[1:0] : 2'bxx ;

wire  ld_sec_hit_thrd0_w2,ld_sec_hit_thrd1_w2,ld_sec_hit_thrd2_w2,ld_sec_hit_thrd3_w2;

dff_s #(4) ff_ld_sec_hit_thrd0to3_d1 (
        .din    ({ld_sec_hit_thrd0,ld_sec_hit_thrd1,ld_sec_hit_thrd2,ld_sec_hit_thrd3}),
        .q      ({ld_sec_hit_thrd0_w2,ld_sec_hit_thrd1_w2,ld_sec_hit_thrd2_w2,ld_sec_hit_thrd3_w2}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  ld0_sec_hit_w2 = ld_sec_hit_thrd0_w2 & ld0_unfilled  ;
assign  ld1_sec_hit_w2 = ld_sec_hit_thrd1_w2 & ld1_unfilled  ;
assign  ld2_sec_hit_w2 = ld_sec_hit_thrd2_w2 & ld2_unfilled  ;
assign  ld3_sec_hit_w2 = ld_sec_hit_thrd3_w2 & ld3_unfilled  ;

// Fix for Bug1606
assign  lsu_ld_sec_hit_l2access_w2 =
         ld0_sec_hit_w2 | ld1_sec_hit_w2 | ld2_sec_hit_w2 | ld3_sec_hit_w2 ;

//phase 2
//since can be multiple hits, it isn't one-hot mux, but fix priority-sel mux
assign  lsu_ld_sec_hit_wy_w2[2-1:0] =
    ld0_sec_hit_w2 ? ld0_unfilled_wy[2-1:0] :
      ld1_sec_hit_w2 ? ld1_unfilled_wy[2-1:0] :
        ld2_sec_hit_w2 ? ld2_unfilled_wy[2-1:0] :
          ld3_sec_hit_w2 ? ld3_unfilled_wy[2-1:0] : {2{1'bx}} ;

//dff #(4)  stgm_dbypsel (
//        .din    (dfq_byp_sel[3:0]),
//        .q      (dfq_byp_sel_m[3:0]),
//        .clk    (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

//dff #(4)  stgg_dbypsel (
//        .din    (dfq_byp_sel_m[3:0]),
//        .q      (dfq_byp_sel_g[3:0]),
//        .clk    (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

// select g-stage lmq source.
// Selects for lmq contents shared by fill/hit and alternate sources such as ldxa/raw.
// Is qualification of dfq_byp_sel_g by ld_thrd_byp_sel necessary ???

wire	[3:0] lmq_byp_misc_sel_e ;

assign  lmq_byp_misc_sel_e[0] = ld_thrd_byp_sel_e[0]  |        // select for ldxa/raw.
                                dfq_byp_sel[0]  ;              // select for dfq.
assign  lmq_byp_misc_sel_e[1] = ld_thrd_byp_sel_e[1]  |        // select for ldxa/raw.
                                dfq_byp_sel[1] ;               // select for dfq.
assign  lmq_byp_misc_sel_e[2] = ld_thrd_byp_sel_e[2]  |        // select for ldxa/raw.
                                dfq_byp_sel[2] ;               // select for dfq.
assign  lmq_byp_misc_sel_e[3] = ~|lmq_byp_misc_sel_e[2:0];
                                //ld_thrd_byp_sel_e[3]  |        // select for ldxa/raw.
                                //dfq_byp_sel[3] ;               // select for dfq.

/*
assign  lmq_byp_misc_sel_e[0] = ld_thrd_byp_sel_e[0]  |        // select for ldxa/raw.
          (dfq_byp_sel[0] & ~ld_thrd_byp_sel_e[0]) ;  // select for dfq.
assign  lmq_byp_misc_sel_e[1] = ld_thrd_byp_sel_e[1]  |        // select for ldxa/raw.
          (dfq_byp_sel[1] & ~ld_thrd_byp_sel_e[1]) ; // select for dfq.
assign  lmq_byp_misc_sel_e[2] = ld_thrd_byp_sel_e[2]  |        // select for ldxa/raw.
          (dfq_byp_sel[2] & ~ld_thrd_byp_sel_e[2]) ; // select for dfq.
assign  lmq_byp_misc_sel_e[3] = ld_thrd_byp_sel_e[3]  |        // select for ldxa/raw.
          (dfq_byp_sel[3] & ~ld_thrd_byp_sel_e[3]) ; // select for dfq.
*/

// M-Stage 
//10/27/03 - add rst_tri_en for the select - lsu_lmq_byp_misc_sel to qdp1
wire  [3:0]  lsu_lmq_byp_misc_sel_tmp ;
dff_s #(4)  stgg_lbsel (
        .din    (lmq_byp_misc_sel_e[3:0]),
        .q      (lsu_lmq_byp_misc_sel_tmp[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign lsu_lmq_byp_misc_sel[2:0]=  lsu_lmq_byp_misc_sel_tmp[2:0] & {3{~rst_tri_en}} ;
assign lsu_lmq_byp_misc_sel[3]  =  lsu_lmq_byp_misc_sel_tmp[3] | rst_tri_en ;


/*
assign  lsu_lmq_byp_misc_sel[0] = ld_thrd_byp_sel[0]  |        // select for ldxa/raw.
          (dfq_byp_sel_g[0] & ~ld_thrd_byp_sel[0]) ;  // select for dfq.
assign  lsu_lmq_byp_misc_sel[1] = ld_thrd_byp_sel[1]  |        // select for ldxa/raw.
          (dfq_byp_sel_g[1] & ~ld_thrd_byp_sel[1]) ; // select for dfq.
assign  lsu_lmq_byp_misc_sel[2] = ld_thrd_byp_sel[2]  |        // select for ldxa/raw.
          (dfq_byp_sel_g[2] & ~ld_thrd_byp_sel[2]) ; // select for dfq.
assign  lsu_lmq_byp_misc_sel[3] = ld_thrd_byp_sel[3]  |        // select for ldxa/raw.
          (dfq_byp_sel_g[3] & ~ld_thrd_byp_sel[3]) ; // select for dfq.
*/



//=================================================================================================
//  Miscellaneous Staging
//=================================================================================================

   
assign  thread0_e = ~ifu_tlu_thrid_e[1] & ~ifu_tlu_thrid_e[0] ;
assign  thread1_e = ~ifu_tlu_thrid_e[1] &  ifu_tlu_thrid_e[0] ;
assign  thread2_e =  ifu_tlu_thrid_e[1] & ~ifu_tlu_thrid_e[0] ;
assign  thread3_e =  ifu_tlu_thrid_e[1] &  ifu_tlu_thrid_e[0] ;

assign  ld0_inst_vld_e = ld_inst_vld_e & thread0_e ;
assign  ld1_inst_vld_e = ld_inst_vld_e & thread1_e ;
assign  ld2_inst_vld_e = ld_inst_vld_e & thread2_e ;
assign  ld3_inst_vld_e = ld_inst_vld_e & thread3_e ;
     
assign ldst_va_m[7:6] = lsu_ldst_va_m[7:6];
   
wire ld0_inst_vld_m;
wire ld1_inst_vld_m;
wire ld2_inst_vld_m;
wire ld3_inst_vld_m;
wire ldst_fp_m;
wire ldst_dbl_m;
dff_s  #(6) stgm_ad_m (
        .din    ({ld0_inst_vld_e,ld1_inst_vld_e,
    ld2_inst_vld_e,ld3_inst_vld_e,ifu_lsu_ldst_fp_e,
    ifu_lsu_ldst_dbl_e}),
        .q      ({ld0_inst_vld_m,ld1_inst_vld_m,
    ld2_inst_vld_m,ld3_inst_vld_m,ldst_fp_m,
    ldst_dbl_m}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

wire ld0_inst_vld_unflushed;
wire ld1_inst_vld_unflushed;
wire ld2_inst_vld_unflushed;
wire ld3_inst_vld_unflushed;
wire ldst_fp_g;
dff_s  #(8) stgm_ad_g (
        .din    ({ldst_va_m[7:6],ld0_inst_vld_m,ld1_inst_vld_m,
        //.din    ({ldst_va_m[8:6],ld0_inst_vld_m,ld1_inst_vld_m,
    ld2_inst_vld_m,ld3_inst_vld_m,ldst_fp_m,
    //ld2_inst_vld_m,ld3_inst_vld_m,st_inst_vld_m,ldst_fp_m,
    ldst_dbl_m}),
        .q      ({ldst_va_g[7:6],ld0_inst_vld_unflushed,ld1_inst_vld_unflushed,
        //.q      ({ldst_va_g[8:6],ld0_inst_vld_unflushed,ld1_inst_vld_unflushed,
    ld2_inst_vld_unflushed,ld3_inst_vld_unflushed,
    //ld2_inst_vld_unflushed,ld3_inst_vld_unflushed,st_inst_vld_unflushed,
    ldst_fp_g,ldst_dbl_g}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
  );

assign  ld0_inst_vld_g = ld0_inst_vld_unflushed & lsu_inst_vld_w ;
assign  ld1_inst_vld_g = ld1_inst_vld_unflushed & lsu_inst_vld_w ;
assign  ld2_inst_vld_g = ld2_inst_vld_unflushed & lsu_inst_vld_w ;
assign  ld3_inst_vld_g = ld3_inst_vld_unflushed & lsu_inst_vld_w ;
//assign  st_inst_vld_g  = st_inst_vld_unflushed & lsu_inst_vld_w  ;

dff_s  #(4) ivld_stgw2 (
        .din    ({ld0_inst_vld_g,ld1_inst_vld_g,ld2_inst_vld_g,ld3_inst_vld_g}),
        .q    	({ld0_inst_vld_w2,ld1_inst_vld_w2,ld2_inst_vld_w2,ld3_inst_vld_w2}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
  );

wire thread0_m;
wire thread1_m;
wire thread2_m;
wire thread3_m;
dff_s  #(4) th_stgm (
        .din    ({thread0_e,thread1_e,thread2_e,thread3_e}),
        .q      ({thread0_m,thread1_m,thread2_m,thread3_m}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
  );

wire thread0_g;
wire thread1_g;
wire thread2_g;
wire thread3_g;
dff_s  #(4) th_stgg (
        .din    ({thread0_m,thread1_m,thread2_m,thread3_m}),
        .q      ({thread0_g,thread1_g,thread2_g,thread3_g}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
  );

dff_s  #(4) th_stgw2 (
        .din    ({thread0_g,thread1_g,thread2_g,thread3_g}),
        .q      ({thread0_w2,thread1_w2,thread2_w2,thread3_w2}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
  );



//=================================================================================================
//
// IMISS PCX PKT REQ CTL
//
//=================================================================================================


// ** ifu request packet should be sent out in e-stage **
// ** Prefer not to make dfq dual-ported **

// Format of IFU pcx packet (50b) :
//  b49 - valid
//  b48:44 - req type
//  b43:42 - rep way (for "eviction" - maintains directory consistency )
//  b41:40 - mil id
//  b39:0  - imiss address
// *
// destid :
//  b2  - b39 of pa
//  b1  - b8  of pa
//  b0  - b7  of pa 
// pcxpkt :
//  b51 - valid
//  b50 - reserved
//  b49 - NC
//  b48:44 - req type
//  b43:42 - rep way (for "eviction" - maintains directory consistency )
//  b41:40 - mil id
//  b39:0  - imiss address

// IMISS REQUEST CONTROL
// Vld is reset if imiss pkt requests and request is not subsequently
// squashed and new imiss pkt unavailable.

// Request rate is 1/3 cycles.

/*dff  iack_stg (
        .din    (imiss_pcx_rq_sel),
        .q      (lsu_ifu_pcxpkt_ack_d),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

assign	lsu_ifu_pcxpkt_ack_d = imiss_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;

assign  imiss_pkt_vld =  ifu_lsu_pcxreq_d & ~(imiss_pcx_rq_sel_d1 | imiss_pcx_rq_sel_d2) ;

//timing fix: 5/21/03 - ifu sends destid 1 cycle early
//assign  imiss_l2bnk_addr[2:0] = ifu_lsu_destid_d[2:0] ;

wire  ifu_destid_en ;
assign  ifu_destid_en  =  ~ifu_lsu_pcxreq_d | (lsu_ifu_pcxpkt_ack_d & ~ifu_lsu_pcxpkt_e_b50);

wire  [2:0]  ifu_destid_d;
dffe_s #(3)  ff_ifu_destid_d (
           .din    (ifu_lsu_destid_s[2:0]),
           .q      (ifu_destid_d[2:0]),
           .en     (ifu_destid_en),
           .clk    (clk),
           .se     (1'b0),       .si (),          .so ()
           );
assign  imiss_l2bnk_addr[2:0] = ifu_destid_d[2:0] ;

assign imiss_l2bnk_dest[0] = 
~imiss_l2bnk_addr[2] & ~imiss_l2bnk_addr[1] & ~imiss_l2bnk_addr[0] ;
assign imiss_l2bnk_dest[1] = 
~imiss_l2bnk_addr[2] & ~imiss_l2bnk_addr[1] &  imiss_l2bnk_addr[0] ;
assign imiss_l2bnk_dest[2] = 
~imiss_l2bnk_addr[2] & imiss_l2bnk_addr[1] & ~imiss_l2bnk_addr[0] ;
assign imiss_l2bnk_dest[3] = 
~imiss_l2bnk_addr[2] & imiss_l2bnk_addr[1] &  imiss_l2bnk_addr[0] ;
assign imiss_l2bnk_dest[4] = imiss_l2bnk_addr[2] ;


//=================================================================================================
//  FPOP PCX RQ CTL
//=================================================================================================


assign  fpst_vld_m = ffu_lsu_data[80] & ffu_lsu_data[79] ;

dff_s  fpst_stg (
        .din    (fpst_vld_m),
        .q      (fpst_vld_g),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// ffu req is  never speculative as it must always begin with the queue empty 
assign  lsu_ffu_ack =   
	fpop_pcx_rq_sel_d1 |   // fpop needs to wait until selected;d1 for timing
	//fpop_pcx_rq_sel |   // fpop needs to wait until selected
      	fpst_vld_g ;    // fpst responds immediately.

// req_squash needs to match up with rq_sel_d1 !!!
// keep vld around for two cycles.
assign fpop_vld_reset = 
  (reset | fpop_pcx_rq_sel) ; 
  //(reset | fpop_pcx_rq_sel_d1) ; 

assign fpop_vld_en = ffu_lsu_fpop_rq_vld ;

// fpop valid
dffre_s #(1)  fpop_vld (
        .din  (ffu_lsu_fpop_rq_vld),
        .q    (fpop_pkt_vld_unmasked),
  	.rst  (fpop_vld_reset), .en (fpop_vld_en),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        );

// ** fpop_pkt1 should not be required.
assign	fpop_pkt1 = fpop_pkt_vld_unmasked & ~fpop_pcx_rq_sel_d1 ;

assign  fpop_pkt_vld = fpop_pkt_vld_unmasked ; // & ~ffu_lsu_kill_fpop_rq ;

assign  fpop_atom_req = fpop_pkt1 & fpop_pcx_rq_sel ;

dff_s  fpatm_stg (
        .din    (fpop_atom_req),
        .q      (fpop_atom_rq_pq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign fpop_l2bnk_dest[4:0]   = 5'b10000 ;



//=================================================================================================
//  SPU PCX PKT REQ CONTROL
//=================================================================================================
  
// If ack is sent in a given cycle, then the earliest the spu can send
// a response is in the same cycle. 

wire	strm_pcx_rq_sel_d2 ;
assign  lsu_spu_ldst_ack = 
  strm_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;  // spu request sent to pcx.
  //strm_pcx_rq_sel_d1 & ~pcx_req_squash ;  // spu request sent to pcx.

dff_s #(1) rqsel_d2 (
  .din (strm_pcx_rq_sel_d1),
  .q   (strm_pcx_rq_sel_d2),
  .clk (clk),
  .se     (1'b0),       .si (),          .so ()
);              

wire spu_ack_d1 ;
dff_s #(1) spuack_d1 (
  .din (lsu_spu_ldst_ack),
  .q   (spu_ack_d1),
  .clk (clk),
  .se     (1'b0),       .si (),          .so ()
);              

dff_s #(2) ff_spu_lsu_ldst_pckt_d1 (
  .din (spu_lsu_ldst_pckt[64+7:64+6]),
  .q   (strm_l2bnk_addr[1:0]),
  .clk (clk),
  .se     (1'b0),       .si (),          .so ()
);              
                              
// Streaming does not access io space.
assign strm_l2bnk_dest[0] = 
~strm_l2bnk_addr[1] & ~strm_l2bnk_addr[0] ;
assign strm_l2bnk_dest[1] = 
~strm_l2bnk_addr[1] &  strm_l2bnk_addr[0] ;
assign strm_l2bnk_dest[2] = 
strm_l2bnk_addr[1] & ~strm_l2bnk_addr[0] ;
assign strm_l2bnk_dest[3] = 
strm_l2bnk_addr[1] &  strm_l2bnk_addr[0] ;
assign strm_l2bnk_dest[4] = 1'b0 ;

wire  strm_pkt_vld_unmasked ;

dff_s #(1) spu_pkt_vld_d1 (
        .din    (spu_lsu_ldst_pckt_vld),
        .q      (strm_pkt_vld_unmasked),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );              
                                  
assign  strm_pkt_vld = 
	strm_pkt_vld_unmasked & ~(strm_pcx_rq_sel_d1 | lsu_spu_ldst_ack | spu_ack_d1);

// temp = remove strming interface
//assign strm_sldst_cam_vld = 1'b0 ;
//assign strm_sld_dc_rd_vld = 1'b0 ;
//assign strm_sldst_cam_d2 = 1'b0 ;
// temp = remove strming interface


//=================================================================================================
//  STORE PCX PKT REQ CONTROL
//=================================================================================================

// Stage by a cycle.

// Thread0
wire	[2:1]	stb0_rqtype ;
wire	[2:0]	stb0_rqaddr ; 
dff_s #(5) stgd1_s0rq (
        .din    ({stb0_atm_rq_type[2:1], stb0_l2b_addr[2:0]}),
        .q      ({stb0_rqtype[2:1],stb0_rqaddr[2:0]}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Thread1
wire	[2:1]	stb1_rqtype ;
wire	[2:0]	stb1_rqaddr ; 
dff_s #(5) stgd1_s1rq (
        .din    ({stb1_atm_rq_type[2:1], stb1_l2b_addr[2:0]}),
        .q      ({stb1_rqtype[2:1],stb1_rqaddr[2:0]}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Thread2
wire	[2:1]	stb2_rqtype ;
wire	[2:0]	stb2_rqaddr ; 
dff_s #(5) stgd1_s2rq (
        .din    ({stb2_atm_rq_type[2:1], stb2_l2b_addr[2:0]}),
        .q      ({stb2_rqtype[2:1],stb2_rqaddr[2:0]}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Thread3
wire	[2:1]	stb3_rqtype ;
wire	[2:0]	stb3_rqaddr ; 
dff_s #(5) stgd1_s3rq (
        .din    ({stb3_atm_rq_type[2:1], stb3_l2b_addr[2:0]}),
        .q      ({stb3_rqtype[2:1],stb3_rqaddr[2:0]}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	stb0_rd_for_pcx,stb1_rd_for_pcx,stb2_rd_for_pcx,stb3_rd_for_pcx ;
wire	stb0_rd_for_pcx_tmp,stb1_rd_for_pcx_tmp,stb2_rd_for_pcx_tmp,stb3_rd_for_pcx_tmp ;
dff_s #(4) stgd1_rdpcx (
        .din    (stb_rd_for_pcx[3:0]),
        .q      ({stb3_rd_for_pcx_tmp,stb2_rd_for_pcx_tmp,stb1_rd_for_pcx_tmp,stb0_rd_for_pcx_tmp}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

// timing fix: 5/6 - move kill qual after store pick
//assign	stb0_rd_for_pcx = stb0_rd_for_pcx_tmp & ~lsu_st_pcx_rq_kill_w2[0] ;
//assign	stb1_rd_for_pcx = stb1_rd_for_pcx_tmp & ~lsu_st_pcx_rq_kill_w2[1] ;
//assign	stb2_rd_for_pcx = stb2_rd_for_pcx_tmp & ~lsu_st_pcx_rq_kill_w2[2] ;
//assign	stb3_rd_for_pcx = stb3_rd_for_pcx_tmp & ~lsu_st_pcx_rq_kill_w2[3] ;

assign	stb0_rd_for_pcx = stb0_rd_for_pcx_tmp;
assign	stb1_rd_for_pcx = stb1_rd_for_pcx_tmp;
assign	stb2_rd_for_pcx = stb2_rd_for_pcx_tmp;
assign	stb3_rd_for_pcx = stb3_rd_for_pcx_tmp;

// STORE REQUEST CONTROL
// ** Data must come from bypass mux output.
// THREAD0

// Reads for stores will have to be made non-speculative ????
// or delay when ced bit is set such that there is no need
// to replay store.
// The size of atm_rq_type can be reduced in stb_ctl etc !!!
assign  st0_pkt_vld = stb0_rd_for_pcx & ~st0_pcx_rq_sel_d1 ;
assign  st0_cas_vld = ~stb0_rqtype[2] & stb0_rqtype[1] ;
// stquad not supported.
//assign  st0_stq_vld = 1'b0 ;
assign  st0_atomic_vld = st0_cas_vld ;
  //st0_stq_vld |               // stq(1)
  //(~stb0_rqtype[2] & stb0_rqtype[1] & ~stb0_rqtype[0]) ; // cas(1)

assign  st1_pkt_vld = stb1_rd_for_pcx & ~st1_pcx_rq_sel_d1 ;
assign  st1_cas_vld = ~stb1_rqtype[2] & stb1_rqtype[1] ;
//assign  st1_stq_vld = 1'b0 ;
assign  st1_atomic_vld = st1_cas_vld ;

assign  st2_pkt_vld = stb2_rd_for_pcx & ~st2_pcx_rq_sel_d1 ;
assign  st2_cas_vld = ~stb2_rqtype[2] & stb2_rqtype[1] ;
//assign  st2_stq_vld = 1'b0 ;
assign  st2_atomic_vld = st2_cas_vld ;

assign  st3_pkt_vld = stb3_rd_for_pcx & ~st3_pcx_rq_sel_d1 ;
assign  st3_cas_vld = ~stb3_rqtype[2] & stb3_rqtype[1] ;
//assign  st3_stq_vld = 1'b0 ;
assign  st3_atomic_vld = st3_cas_vld ;

// Can this be based on st0_pcx_rq_vld instead to ease critical path.

//assign  pcx_rq_for_stb[0] = st_pcx_rq_mhot_sel[0] ;
//assign  pcx_rq_for_stb[1] = st_pcx_rq_mhot_sel[1] ;
//assign  pcx_rq_for_stb[2] = st_pcx_rq_mhot_sel[2] ;
//assign  pcx_rq_for_stb[3] = st_pcx_rq_mhot_sel[3] ;

   
assign st0_l2bnk_dest[0] = 
~stb0_rqaddr[2] & ~stb0_rqaddr[1] & ~stb0_rqaddr[0] ;
assign st0_l2bnk_dest[1] = 
~stb0_rqaddr[2] & ~stb0_rqaddr[1] &  stb0_rqaddr[0] ;
assign st0_l2bnk_dest[2] = 
~stb0_rqaddr[2] &  stb0_rqaddr[1] & ~stb0_rqaddr[0] ;
assign st0_l2bnk_dest[3] = 
~stb0_rqaddr[2] &  stb0_rqaddr[1] &  stb0_rqaddr[0] ;
assign st0_l2bnk_dest[4] =  stb0_rqaddr[2] ;

assign st1_l2bnk_dest[0] = 
~stb1_rqaddr[2] & ~stb1_rqaddr[1] & ~stb1_rqaddr[0] ;
assign st1_l2bnk_dest[1] = 
~stb1_rqaddr[2] & ~stb1_rqaddr[1] &  stb1_rqaddr[0] ;
assign st1_l2bnk_dest[2] = 
~stb1_rqaddr[2] &  stb1_rqaddr[1] & ~stb1_rqaddr[0] ;
assign st1_l2bnk_dest[3] = 
~stb1_rqaddr[2] &  stb1_rqaddr[1] &  stb1_rqaddr[0] ;
assign st1_l2bnk_dest[4] =  stb1_rqaddr[2] ;

assign st2_l2bnk_dest[0] = 
~stb2_rqaddr[2] & ~stb2_rqaddr[1] & ~stb2_rqaddr[0] ;
assign st2_l2bnk_dest[1] = 
~stb2_rqaddr[2] & ~stb2_rqaddr[1] &  stb2_rqaddr[0] ;
assign st2_l2bnk_dest[2] = 
~stb2_rqaddr[2] &  stb2_rqaddr[1] & ~stb2_rqaddr[0] ;
assign st2_l2bnk_dest[3] = 
~stb2_rqaddr[2] &  stb2_rqaddr[1] &  stb2_rqaddr[0] ;
assign st2_l2bnk_dest[4] =  stb2_rqaddr[2] ;

assign st3_l2bnk_dest[0] = 
~stb3_rqaddr[2] & ~stb3_rqaddr[1] & ~stb3_rqaddr[0] ;
assign st3_l2bnk_dest[1] = 
~stb3_rqaddr[2] & ~stb3_rqaddr[1] &  stb3_rqaddr[0] ;
assign st3_l2bnk_dest[2] = 
~stb3_rqaddr[2] &  stb3_rqaddr[1] & ~stb3_rqaddr[0] ;
assign st3_l2bnk_dest[3] = 
~stb3_rqaddr[2] &  stb3_rqaddr[1] &  stb3_rqaddr[0] ;
assign st3_l2bnk_dest[4] =  stb3_rqaddr[2] ;

//=================================================================================================
//  	BLK-LOAD TRACKING
//=================================================================================================

// The 64B load request is divided into 4 16B requests, i.e., 4 pcx pkts.
// The last bld request to the pcx must be marked as so. 
// Only one bld can be processed at any time.

   wire [1:0] bld_thrd_din;
   wire [1:0] bld_thrd_dout;
   wire [3:0] bld_dcd_thrd;
   wire       ld_03_inst_vld_g;
   wire       bld_pcx_rq_sel_d1;
   
wire blk_asi_g;
dff_s  stgg_blkasi (
        .din    (lsu_blk_asi_m),
        .q      (blk_asi_g),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	bld_helper_cmplt_e = lsu_fldd_vld_en & bld_dout & (
                             bld_dcd_thrd[0] & lsu_dfill_dcd_thrd[0] |
                             bld_dcd_thrd[1] & lsu_dfill_dcd_thrd[1] |
                             bld_dcd_thrd[2] & lsu_dfill_dcd_thrd[2] |
                             bld_dcd_thrd[3] & lsu_dfill_dcd_thrd[3] );

   
dff_s #(1) stgm_bldhlpr (
        .din    (bld_helper_cmplt_e),
        .q    	(bld_helper_cmplt_m),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	lsu_bld_helper_cmplt_m = bld_helper_cmplt_m ;

dff_s #(1) stgg_bldhlpr (
        .din    (bld_helper_cmplt_m),
        .q    	(bld_helper_cmplt_g),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	alt_space_m, alt_space_g, alt_space_w2 ;
dff_s stg_aspacem(
        .din    (ifu_lsu_alt_space_e),
        .q    	(alt_space_m),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s stg_aspaceg(
        .din    (alt_space_m),
        .q    	(alt_space_g),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s stg_aspacew2 (
        .din    (alt_space_g),
        .q    	(alt_space_w2),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );


// PCX bld helper issue :
// 00-1st->01-2nd->10-3rd->11-4th->00
    
   assign     bld_thrd_din[0] = ld1_inst_vld_unflushed | ld3_inst_vld_unflushed;
   assign     bld_thrd_din[1] = ld2_inst_vld_unflushed | ld3_inst_vld_unflushed;


   assign ld_03_inst_vld_g =  lsu_inst_vld_w & (
                              ld0_inst_vld_unflushed | ld1_inst_vld_unflushed | 
                              ld2_inst_vld_unflushed | ld3_inst_vld_unflushed );
   
   assign	bld_g = blk_asi_g & ldst_fp_g & ldst_dbl_g & alt_space_g & ld_03_inst_vld_g ;
		//~lsu_tlb_perr_ld_rq_kill_w ; // Bug 4645

wire	bld_w2 ;
dff_s #(1) bldstg (
        .din    (bld_g),
        .q      (bld_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	perr_ld_rq_kill_w2 ;
wire	bld_perr_kill_w2 ;
assign	bld_perr_kill_w2 = bld_w2 & perr_ld_rq_kill_w2 ;

wire bld_reset; 
dffre_s #(2) bld_thrd (
        .din  (bld_thrd_din[1:0] ),
        .q    (bld_thrd_dout[1:0]),
  	.rst  (bld_reset), .en (bld_g),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        );                     
   assign bld_dcd_thrd[0] = ~bld_thrd_dout[1] & ~bld_thrd_dout[0];
   assign bld_dcd_thrd[1] = ~bld_thrd_dout[1] &  bld_thrd_dout[0];
   assign bld_dcd_thrd[2] =  bld_thrd_dout[1] & ~bld_thrd_dout[0];
   assign bld_dcd_thrd[3] =  bld_thrd_dout[1] &  bld_thrd_dout[0];

//bug 2757    
   assign bld_pcx_rq_sel_d1 = ld0_pcx_rq_sel_d1 & bld_dcd_thrd[0] | 
                              ld1_pcx_rq_sel_d1 & bld_dcd_thrd[1] |
                              ld2_pcx_rq_sel_d1 & bld_dcd_thrd[2] | 
                              ld3_pcx_rq_sel_d1 & bld_dcd_thrd[3];

   //wire   bld_pcx_rq_sel_d2, bld_pcx_rq_sel;
   wire    bld_pcx_rq_sel;
   //bug 3322
//   assign bld_pcx_rq_sel = bld_pcx_rq_sel_d2 & ~pcx_req_squash_d1;
   
//dff #(1) ff_bld_pcx_rq_sel_d2 (
//        .din  (bld_pcx_rq_sel_d1),
//        .q    (bld_pcx_rq_sel_d2),
//        .clk  (clk),
//        .se   (1'b0),       .si (),          .so ()
//        );                  

  assign bld_pcx_rq_sel = (ld0_pcx_rq_sel_d2 & bld_dcd_thrd[0] | 
                           ld1_pcx_rq_sel_d2 & bld_dcd_thrd[1] |
                           ld2_pcx_rq_sel_d2 & bld_dcd_thrd[2] | 
                           ld3_pcx_rq_sel_d2 & bld_dcd_thrd[3] ) &
                           ~pcx_req_squash_d1;
     
  assign	bld_en = bld_g |  (bld_pcx_rq_sel & bld_dout & ~(bld_cnt[1] & bld_cnt[0])) ; 
  assign	bld_din = bld_g | bld_dout ;
  assign	bcnt_din[1:0] = bld_cnt[1:0] + {1'b0,(bld_pcx_rq_sel & bld_dout)} ;

// Reset by last completing bld helper.  
  assign	bld_reset = 
	reset | bld_perr_kill_w2 |
	(bld_rd_dout[2] & bld_rd_dout[1] & bld_rd_dout[0] & bld_helper_cmplt_g) ;

assign	lsu_bld_reset = bld_reset ;

wire	bld_dout_tmp ;
dffre_s #(3)   bld_pcx_cnt (
        .din  ({bcnt_din[1:0],bld_din}),
        .q    ({bld_cnt[1:0], bld_dout_tmp}),
       	.rst  (bld_reset), .en (bld_en),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        );

assign	bld_dout = bld_dout_tmp & ~bld_perr_kill_w2 ;

// Last one allows ld-rq-vld to be reset.
assign  bld_annul[0] =  bld_dcd_thrd[0] & (bld_dout & ~(bld_cnt[1] & bld_cnt[0])) ;
assign  bld_annul[1] =  bld_dcd_thrd[1] & (bld_dout & ~(bld_cnt[1] & bld_cnt[0])) ;
assign  bld_annul[2] =  bld_dcd_thrd[2] & (bld_dout & ~(bld_cnt[1] & bld_cnt[0])) ;
assign  bld_annul[3] =  bld_dcd_thrd[3] & (bld_dout & ~(bld_cnt[1] & bld_cnt[0])) ;

dff_s #(4) bannul_d1 (
        .din    (bld_annul[3:0]),
        .q      (bld_annul_d1[3:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );
   
// Maintain rd (cpx return pkt counter). This is based on when the blk ld helper completes.
// lower 3b of rd have to start out as zero.
// Should be asserted 8 times for the entire bld.
assign	bld_rd_en = (bld_helper_cmplt_m & bld_dout) ;
assign	bld_rd_din[2:0] = bld_rd_dout_m[2:0] + {2'b00,(bld_helper_cmplt_m & bld_dout)} ;
//assign	bld_rd_en = (bld_helper_cmplt_g & bld_dout) ;
//assign	bld_rd_din[2:0] = bld_rd_dout[2:0] + {2'b00,(bld_helper_cmplt_g & bld_dout)} ;

dffre_s #(3)   bld_cpx_cnt (
        .din  (bld_rd_din[2:0]),
        .q    (bld_rd_dout_m[2:0]),
  	    .rst  (bld_reset), .en   (bld_rd_en),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        );

dff_s #(3) bld_cnt_stg (
        .din    (bld_rd_dout_m[2:0]),
        .q      (bld_rd_dout[2:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Select appr. rd. (cpx return pkt counter)
assign	lsu_ffu_bld_cnt_w[2:0] = bld_rd_dout[2:0] ;
assign	lsu_bld_cnt_m[2:0] = bld_rd_dout_m[2:0] ;

// pcx pkt address cntrl.
wire	[1:0]	addr_b54 ;
assign   addr_b54[1:0] = bld_cnt[1:0];

/*wire bld_rq_w2 ;
assign bld_rq_w2 = bld_dout; */

dff_s #(2) blkrq_d1 (
        .din    ({addr_b54[1:0]}),
        .q      ({lsu_bld_rq_addr[1:0]}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	lsu_bld_pcx_rq = bld_pcx_rq_sel_d1 & bld_dout ;

/*dff #(3) blkrq_d1 (
        .din    ({addr_b54[1:0],bld_rq_w2}),
        .q      ({lsu_bld_rq_addr[1:0],lsu_bld_pcx_rq}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );*/


//=================================================================================================
//  	LOAD PCX PKT REQ CONTROL
//=================================================================================================

// Staging pref.
wire pref_inst_m, pref_inst_g ;

dff_s  stgm_prf (
        .din    (ifu_lsu_pref_inst_e),
        .q      (pref_inst_m),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  stgg_prf (
        .din    (pref_inst_m),
        .q      (pref_inst_g),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Performance Ctr Info
dff_s #(4)  stgg_dmiss (
        .din    ({ld3_l2cache_rq,ld2_l2cache_rq,ld1_l2cache_rq,ld0_l2cache_rq}),
        .q      (lsu_tlu_dcache_miss_w2[3:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire  ld0_l2cache_rq_w2, ld1_l2cache_rq_w2, ld2_l2cache_rq_w2, ld3_l2cache_rq_w2 ;

assign ld0_l2cache_rq_w2  =  lsu_tlu_dcache_miss_w2[0];
assign ld1_l2cache_rq_w2  =  lsu_tlu_dcache_miss_w2[1];
assign ld2_l2cache_rq_w2  =  lsu_tlu_dcache_miss_w2[2];
assign ld3_l2cache_rq_w2  =  lsu_tlu_dcache_miss_w2[3];

wire    pref_vld0_g, pref_vld1_g, pref_vld2_g, pref_vld3_g ;
wire    pref_rq_vld0_g, pref_rq_vld1_g, pref_rq_vld2_g, pref_rq_vld3_g ;
wire    pref_vld_g ;
assign  pref_vld_g = pref_inst_g & ~tlb_pgnum_g[39] & tlb_cam_hit_g ; // Bug 4318. 
assign  pref_rq_vld0_g = pref_vld_g & thread0_g & lsu_inst_vld_w ;
assign  pref_rq_vld1_g = pref_vld_g & thread1_g & lsu_inst_vld_w ;
assign  pref_rq_vld2_g = pref_vld_g & thread2_g & lsu_inst_vld_w ;
assign  pref_rq_vld3_g = pref_vld_g & thread3_g & lsu_inst_vld_w ;
assign  pref_vld0_g = pref_inst_g & thread0_g ;
assign  pref_vld1_g = pref_inst_g & thread1_g ;
assign  pref_vld2_g = pref_inst_g & thread2_g ;
assign  pref_vld3_g = pref_inst_g & thread3_g ;

//=========================================================================================
// Shift full-raw/partial-raw logic from rw_ctl to qctl1

wire    ldquad_inst_g ;
dff_s  ldq_stgg (
  .din    (lsu_ldquad_inst_m), .q (ldquad_inst_g),
  .clk    (clk),
  .se   (1'b0), .si (), .so ()
  );

wire    io_ld,io_ld_w2 ;
assign  io_ld = tlb_pgnum_g[39] ; // Bug 4362
//assign  io_ld = tlb_pgnum_g[39]  & ~(~tlb_pgnum_g[38]  & tlb_pgnum_g[37]) ;

wire	stb_not_empty ;
assign  stb_not_empty  =
  thread0_g ? ~lsu_stb_empty[0] :
    thread1_g ? ~lsu_stb_empty[1] :
      thread2_g ? ~lsu_stb_empty[2] :
                        ~lsu_stb_empty[3] ;

wire  	ldq_hit_g,ldq_hit_w2 ;
wire    ldq_stb_cam_hit ;
assign  ldq_stb_cam_hit = stb_cam_hit_bf & ldquad_inst_g ;
// Terms can be made common.
assign  ldq_hit_g = ldq_stb_cam_hit ;

wire	full_raw_g,partial_raw_g ;
wire	full_raw_w2,partial_raw_w2 ;
assign	full_raw_g = |stb_ld_full_raw[7:0] ;
assign	partial_raw_g = |stb_ld_partial_raw[7:0] ;

wire	stb_cam_mhit_w2 ;
wire	stb_not_empty_w2 ;
dff_s #(6) stgw2_rawcond (
        .din    ({full_raw_g,partial_raw_g,stb_cam_mhit,ldq_hit_g,io_ld,stb_not_empty}),
        .q      ({full_raw_w2,partial_raw_w2,stb_cam_mhit_w2,ldq_hit_w2,io_ld_w2,
		stb_not_empty_w2}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// BEGIN !!! ld_stb_full_raw_g for SAS support only !!!
//wire	ld_stb_full_raw_g ;
//wire	ld_stb_partial_raw_g ;

// END !!! ld_stb_full_raw_g for SAS support only !!!
assign  ld_stb_full_raw_w2 =
        (full_raw_w2 & ~(stb_cam_mhit_w2 | ldq_hit_w2 | io_ld_w2)) ;
        //(full_raw_w2 & ~(stb_cam_mhit_w2 | ldq_hit_w2 | io_ld_w2)) ; // Bug 3624
wire	ld_stb_partial_raw_w2 ;
wire	stb_cam_hit_w2 ;
assign  ld_stb_partial_raw_w2 =
        (partial_raw_w2 | stb_cam_mhit_w2 | ldq_hit_w2 | 
	(io_ld_w2 & stb_not_empty_w2)) ;
        //(partial_raw_w2 | stb_cam_mhit_w2 | ldq_hit_w2 | (io_ld_w2 & stb_not_empty_w2)) ;

//=========================================================================================

/*wire	ld_stb_full_raw_w2 ;
dff_s #(1) stgw2_fraw (
        .din    (ld_stb_full_raw_g),
        .q      (ld_stb_full_raw_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

// THREAD0 LOAD PCX REQUEST CONTROL

//=====
// For delayed ld0,1,2,3_l2cache_rq, we need to delay certain
// inputs to flops enabled by ld0,1,2,3_l2cache_rq.

wire	ld0_ldbl_rq_w2 ;
wire	ld1_ldbl_rq_w2 ;
wire	ld2_ldbl_rq_w2 ;
wire	ld3_ldbl_rq_w2 ;
// wire [1:0] 	ld_pcx_pkt_wy_w2 ;
 wire		pref_rq_vld0_w2,pref_rq_vld1_w2,pref_rq_vld2_w2,pref_rq_vld3_w2 ;
 wire    	non_l2bnk ;
 wire		non_l2bnk_w2 ;
 wire [7:6]	ldst_va_w2 ;

dff_s #(7) stgw2_l2crqmx (
        .din    ({
                //ld_pcx_pkt_wy_g[1:0],
 		pref_rq_vld0_g,pref_rq_vld1_g,pref_rq_vld2_g,pref_rq_vld3_g,
 		non_l2bnk,
		ldst_va_g[7:6]}),
        .q    	({
                //ld_pcx_pkt_wy_w2[1:0],
 		pref_rq_vld0_w2,pref_rq_vld1_w2,pref_rq_vld2_w2,pref_rq_vld3_w2,
 		non_l2bnk_w2,
		ldst_va_w2[7:6]}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// wire [1:0] 	ld_pcx_pkt_wy_mx0,ld_pcx_pkt_wy_mx1,ld_pcx_pkt_wy_mx2,ld_pcx_pkt_wy_mx3 ;
 wire		pref_rq_vld0_mx,pref_rq_vld1_mx,pref_rq_vld2_mx,pref_rq_vld3_mx ;
 wire		non_l2bnk_mx0,non_l2bnk_mx1,non_l2bnk_mx2,non_l2bnk_mx3 ;
 wire [7:6]	ldst_va_mx0,ldst_va_mx1,ldst_va_mx2,ldst_va_mx3 ;

// timing fix: 5/19/03: move secondary hit way generation to w2
//                      remove ld_pcx_pkt_wy_mx[0-3] and replace w/ lsu_lmq_pkt_way_w2
// assign	ld_pcx_pkt_wy_mx0[1:0] = 
//	ld0_ldbl_rq_w2 ? ld_pcx_pkt_wy_w2[1:0] : ld_pcx_pkt_wy_g[1:0] ;
// assign	ld_pcx_pkt_wy_mx1[1:0] = 
//	ld1_ldbl_rq_w2 ? ld_pcx_pkt_wy_w2[1:0] : ld_pcx_pkt_wy_g[1:0] ;
// assign	ld_pcx_pkt_wy_mx2[1:0] = 
//	ld2_ldbl_rq_w2 ? ld_pcx_pkt_wy_w2[1:0] : ld_pcx_pkt_wy_g[1:0] ;
// assign	ld_pcx_pkt_wy_mx3[1:0] = 
//	ld3_ldbl_rq_w2 ? ld_pcx_pkt_wy_w2[1:0] : ld_pcx_pkt_wy_g[1:0] ;


 assign	pref_rq_vld0_mx =
	ld0_ldbl_rq_w2 ? pref_rq_vld0_w2 : pref_rq_vld0_g ;
 assign	pref_rq_vld1_mx =
	ld1_ldbl_rq_w2 ? pref_rq_vld1_w2 : pref_rq_vld1_g ;
 assign	pref_rq_vld2_mx =
	ld2_ldbl_rq_w2 ? pref_rq_vld2_w2 : pref_rq_vld2_g ;
 assign	pref_rq_vld3_mx =
	ld3_ldbl_rq_w2 ? pref_rq_vld3_w2 : pref_rq_vld3_g ;
 assign	non_l2bnk_mx0 =
	ld0_ldbl_rq_w2 ? non_l2bnk_w2 : non_l2bnk ;
 assign	non_l2bnk_mx1 =
	ld1_ldbl_rq_w2 ? non_l2bnk_w2 : non_l2bnk ;
 assign	non_l2bnk_mx2 =
	ld2_ldbl_rq_w2 ? non_l2bnk_w2 : non_l2bnk ;
 assign	non_l2bnk_mx3 =
	ld3_ldbl_rq_w2 ? non_l2bnk_w2 : non_l2bnk ;

//timing fix: 10/13/03 - ldst_va_mx[0-3] is used in the same cycle 'cos of perf bug fix-bug2705
//            this delays the ld request valid which in turn delays pcx_rq_for_stb
//            fix is to isolate this mux and the following l2bank addr mux from ld?_ldbl_rq_w2;
//            use ld[0-3]_inst_vld_w2 instead of ld[0-3]_ldbl_rq_w2 as select
 assign	ldst_va_mx0[7:6] =
	ld0_inst_vld_w2 ? ldst_va_w2[7:6] : ldst_va_g[7:6] ;
 assign	ldst_va_mx1[7:6] =
	ld1_inst_vld_w2 ? ldst_va_w2[7:6] : ldst_va_g[7:6] ;
 assign	ldst_va_mx2[7:6] =
	ld2_inst_vld_w2 ? ldst_va_w2[7:6] : ldst_va_g[7:6] ;
 assign	ldst_va_mx3[7:6] =
	ld3_inst_vld_w2 ? ldst_va_w2[7:6] : ldst_va_g[7:6] ;

//=====

wire	atomic_g ;
assign  atomic_g = casa_g | lsu_swap_g | lsu_ldstub_g ;

   wire dbl_force_l2access_g;
   wire dbl_force_l2access_w2;
   assign dbl_force_l2access_g = ldst_dbl_g & ~(ldst_fp_g & ~(alt_space_g & blk_asi_g));
   
wire atomic_w2;
dff_s #(2) stgw2_atm (
        .din    ({atomic_g, dbl_force_l2access_g}),
        .q      ({atomic_w2,dbl_force_l2access_w2}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s #(1) stgw2_perrkill (
        .din    (lsu_tlb_perr_ld_rq_kill_w),
        .q      (perr_ld_rq_kill_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	asi_internal_g,asi_internal_w2;
dff_s #(1) stgg_intasi (
        .din    (asi_internal_m),
        .q      (asi_internal_g),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s #(1) stgw2_intasi (
        .din    (asi_internal_g),
        .q      (asi_internal_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	ld0_l2cache_rq_kill ; 
assign	ld0_l2cache_rq_kill = 
	ld0_inst_vld_w2 & ((ld_stb_full_raw_w2 & ~dbl_force_l2access_w2) | perr_ld_rq_kill_w2) ; 
						// full-raw which looks like partial
assign	ld0_ldbl_rq_w2 = 
		((ld_stb_full_raw_w2 & dbl_force_l2access_w2) | ld_stb_partial_raw_w2)
			& ~atomic_w2 & ~perr_ld_rq_kill_w2 & ~(asi_internal_w2 & alt_space_w2) 
			& ld0_inst_vld_w2 ;

//bug:2877 - dtag parity error 2nd packet request; dont reset if dtag parity error 2nd pkt valid
//           dtag error is reset 1 cycle after 1st pkt sent
//----------------------------------------------------------------------------------------------------------
// |       1       |        2       |         3          |        4       |        5        |        6    |
//  spc_pcx_rq_pq=1   ld_err-pkt1                                           spc_pcx_rq_pq=1   ld_err-pkt2
//                                     ld0_vld_reset=0       pick 2nd pkt
//                                     error_rst=1
//----------------------------------------------------------------------------------------------------------

wire   [3:0]  dtag_perr_pkt2_vld_d1 ;
assign ld0_vld_reset = 
  (reset | (ld0_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld0_inst_vld_g | bld_annul_d1[0] | dtag_perr_pkt2_vld_d1[0]))) |
  ld0_l2cache_rq_kill ;
  //(reset | (ld0_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld0_inst_vld_g | bld_annul_d1[0]))) |

// The equation for partial raw has redundancy !! Change it.
// prefetch will not bypass from stb
/* prim vs sec phase 2 change
assign ld0_l2cache_rq = 
        (((lsu_ld_miss_g & ~ld_stb_full_raw_g  & ~ld_sec_hit_g & ~ldxa_internal) |
        ((lsu_ld_hit_g | lsu_ld_miss_g) & (ld_stb_partial_raw_g | (ld_stb_full_raw_g & ldst_dbl_g))))
        & ~atomic_g & ld0_inst_vld_g) |
	| (pref_inst_g & tlb_cam_hit_g & thread0_g) ;
*/


wire  ld0_l2cache_rq_g;

assign ld0_l2cache_rq_g = 
        (((lsu_ld_miss_g & ~ldxa_internal))
        //((lsu_ld_hit_g | lsu_ld_miss_g) & (ld_stb_partial_raw_g)))
        & ~atomic_g & ld0_inst_vld_g)
        | pref_rq_vld0_g; 

assign ld0_l2cache_rq = ld0_l2cache_rq_g | ld0_ldbl_rq_w2 ;
   
wire  ld0_pkt_vld_unmasked ;
wire  ld1_pkt_vld_unmasked ;
wire  ld2_pkt_vld_unmasked ;
wire  ld3_pkt_vld_unmasked ;
   
// ld valid until request made.
wire pref_rq_vld0;         
dffre_s #(2)  ld0_vld (
        .din    ({ld0_l2cache_rq, pref_rq_vld0_mx}    ),
        .q      ({ld0_pkt_vld_unmasked, pref_rq_vld0}),
  .rst  (ld0_vld_reset),  .en (ld0_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// bug2705 - speculative pick in w-cycle -begin
// dbl_force_l2access_g is set for ldd(f),std(f),ldq,stq
//perf fix: 7/29/03 - kill spec vld if other thread non-spec valids are set
//timing fix: 8/29/03 - flop atomic_m and ldxa_internal_m from dctl for spec req
wire    atomic_or_ldxa_internal_rq_m ;
assign  atomic_or_ldxa_internal_rq_m  =  atomic_m | lda_internal_m ;

wire atomic_or_ldxa_internal_rq_g;
dff_s #(1) ff_atomic_or_ldxa_internal_rq_g (
        .din    (atomic_or_ldxa_internal_rq_m),
        .q      (atomic_or_ldxa_internal_rq_g),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire    ld0_spec_vld_g ;
assign  ld0_spec_vld_g  =  ld0_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g &
                           ~atomic_or_ldxa_internal_rq_g &
                           ~(ld1_pkt_vld_unmasked | ld2_pkt_vld_unmasked | ld3_pkt_vld_unmasked);
//assign  ld0_spec_vld_g  =  ld0_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g ;

dff_s #(1) ff_ld0_spec_pick_vld_w2 (
        .din    (ld0_spec_pick_vld_g),
        .q      (ld0_spec_pick_vld_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// kill packet valid if spec req is picked in w and stb hits in w2
// cannot use ld0_ldbl_rawp_en_w2 because it is late signal instead use ld0_ldbl_rq_w2
//timing fix: 7/21/03 - kill pkt vld if spec pick in w-cycle was to non$ address
//timing fix: 8/6/03 - kill pkt_vld if ld?_l2cache_rq_g=0 in w-cycle but spec_pick=1
wire    ld0_pkt_vld_tmp ;
//bug 3964 - replace ld0_pkt_vld_unmasked w/ ld0_l2cache_rq_w2
//assign lsu_ld0_spec_vld_kill_w2  =  ld0_spec_pick_vld_w2 & (~ld0_pkt_vld_unmasked | ld0_l2cache_rq_kill | ld0_ldbl_rq_w2 | non_l2bnk_mx0_d1) ;
assign lsu_ld0_spec_vld_kill_w2  =  ld0_spec_pick_vld_w2 & (~ld0_l2cache_rq_w2 | ld0_l2cache_rq_kill | ld0_ldbl_rq_w2 | non_l2bnk_mx0_d1) ;

assign  ld0_pkt_vld_tmp =  ld0_pkt_vld_unmasked & ~(ld0_pcx_rq_sel_d1 | ld0_pcx_rq_sel_d2) &
                      ~(ld0_l2cache_rq_kill | ld0_ldbl_rq_w2) &
                      ~(pref_rq_vld0 & lsu_no_spc_pref[0]) ;  // prefetch pending 
                       
assign  ld0_pkt_vld = ld0_pkt_vld_tmp | ld0_spec_vld_g ;
// bug2705 - speculative pick in w-cycle -end

//assign  ld0_pkt_vld = ld0_pkt_vld_unmasked & ~ld0_pcx_rq_sel_d1 ; 

assign  ld0_fill_reset = reset | (lsu_dfq_ld_vld & lsu_dcfill_active_e & dfq_byp_sel[0]) ;


dff_s #(4) stgm_lduwyd1 (
        .din    ({ld0_fill_reset,ld1_fill_reset,ld2_fill_reset,ld3_fill_reset}),
        .q      ({ld0_fill_reset_d1,ld1_fill_reset_d1,ld2_fill_reset_d1,ld3_fill_reset_d1}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s #(4) stgm_lduwyd2 (
        .din    ({ld0_fill_reset_d1,ld1_fill_reset_d1,ld2_fill_reset_d1,ld3_fill_reset_d1}),
        .q      ({ld0_fill_reset_d2_tmp,ld1_fill_reset_d2_tmp,ld2_fill_reset_d2_tmp,ld3_fill_reset_d2_tmp}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire  ld0_l2cache_rq_w2_tmp;
wire  ld0_l2cache_rq_g_tmp;

assign ld0_l2cache_rq_g_tmp  =  ld0_l2cache_rq_g & ~pref_inst_g ;

dff_s #(1) ff_ld0_l2cache_rq_w2 (
        .din    (ld0_l2cache_rq_g_tmp),
        .q      (ld0_l2cache_rq_w2_tmp),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );


//wire ld0_unfilled_en ;
//assign	ld0_unfilled_en = ld0_l2cache_rq & ~pref_inst_g ;
wire ld0_unfilled_wy_en ;
assign	ld0_unfilled_wy_en = ld0_l2cache_rq_w2_tmp | ld0_ldbl_rq_w2 ;

wire  ld0_l2cache_rq_tmp;
assign ld0_l2cache_rq_tmp  = ld0_unfilled_wy_en & ~ld0_l2cache_rq_kill;

// ld valid until fill occur.
dffre_s #(1)  ld0out_state (
        //.din    (ld0_l2cache_rq),
        .din    (ld0_l2cache_rq_tmp),
        .q      (ld0_unfilled_tmp),
        .rst    (ld0_fill_reset_d2),  .en     (ld0_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dffre_s #(2)  ld0out_state_way (
        //.din    (ld_pcx_pkt_wy_mx0[`L1D_WAY_MASK]}),
        .din    (lsu_lmq_pkt_way_w2[2-1:0]),
        .q      (ld0_unfilled_wy[2-1:0]),
        .rst    (ld0_fill_reset_d2),  .en     (ld0_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	ld0_fill_reset_d2 = ld0_fill_reset_d2_tmp | ld0_l2cache_rq_kill ;
//assign	ld0_unfilled = ld0_unfilled_tmp & ~ld0_l2cache_rq_kill ;
assign	ld0_unfilled = ld0_unfilled_tmp ;

//bug3516
//assign  non_l2bnk = tlb_pgnum_g[39] & tlb_pgnum_g[38] ;
assign  non_l2bnk = tlb_pgnum_g[39]  & ~(~tlb_pgnum_g[38]  & tlb_pgnum_g[37]) ;

// ld l2bank address
dffe_s  #(3) ld0_l2bnka (
        .din    ({non_l2bnk_mx0,ldst_va_mx0[7:6]}),
        .q      (ld0_l2bnk_addr[2:0]),
  .en (ld0_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - add byp for address to be available in w-cycle
//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2 if non_l2bnk_mx0=1 (non$ access)
wire  [2:0]  ld0_l2bnk_addr_mx ;
assign  ld0_l2bnk_addr_mx[2:0]  =  ld0_pkt_vld_unmasked ? ld0_l2bnk_addr[2:0] :
                                                          {1'b0,ldst_va_mx0[7:6]} ;             // assume $able access for spec pick

//assign  ld0_l2bnk_addr_mx[2:0]  =  (ld0_inst_vld_unflushed  & lsu_inst_vld_tmp) ? 
//                                        {1'b0,ldst_va_mx0[7:6]} :             // assume $able access for spec pick
//                                        //{non_l2bnk_mx0,ldst_va_mx0[7:6]} : 
//				             ld0_l2bnk_addr[2:0] ;

//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2
dff_s #(1) ff_non_l2bnk_mx0_d1 (
        .din    (non_l2bnk_mx0),
        .q      (non_l2bnk_mx0_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - change ld0_l2bnk_addr[2:0] to ld0_l2bnk_addr_mx[2:0]
assign ld0_l2bnk_dest[0] = ~ld0_l2bnk_addr_mx[2] & ~ld0_l2bnk_addr_mx[1] & ~ld0_l2bnk_addr_mx[0] ;
assign ld0_l2bnk_dest[1] = ~ld0_l2bnk_addr_mx[2] & ~ld0_l2bnk_addr_mx[1] &  ld0_l2bnk_addr_mx[0] ;
assign ld0_l2bnk_dest[2] = ~ld0_l2bnk_addr_mx[2] &  ld0_l2bnk_addr_mx[1] & ~ld0_l2bnk_addr_mx[0] ;
assign ld0_l2bnk_dest[3] = ~ld0_l2bnk_addr_mx[2] &  ld0_l2bnk_addr_mx[1] &  ld0_l2bnk_addr_mx[0] ;
assign ld0_l2bnk_dest[4] =  ld0_l2bnk_addr_mx[2] ;

// THREAD1 LOAD PCX REQUEST CONTROL

wire	ld1_l2cache_rq_kill ; 
assign	ld1_l2cache_rq_kill = 
	ld1_inst_vld_w2 & ((ld_stb_full_raw_w2 & ~dbl_force_l2access_w2) | perr_ld_rq_kill_w2) ; 	
					// full-raw which looks like partial
assign	ld1_ldbl_rq_w2 = 
		((ld_stb_full_raw_w2 & dbl_force_l2access_w2) | ld_stb_partial_raw_w2)
			& ~atomic_w2 & ~perr_ld_rq_kill_w2 & ~(asi_internal_w2 & alt_space_w2) &
			ld1_inst_vld_w2 ;

assign ld1_vld_reset = 
  (reset | (ld1_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld1_inst_vld_g | bld_annul_d1[1] | dtag_perr_pkt2_vld_d1[1]))) |
  ld1_l2cache_rq_kill ;
  //(reset | (ld1_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld1_inst_vld_g | bld_annul_d1[1]))) | // bug2877
  //(reset | (ld1_pcx_rq_sel_d1 & ~(pcx_req_squash | ld1_inst_vld_g | bld_annul[1]))) ;

wire  ld1_l2cache_rq_g;
assign ld1_l2cache_rq_g = 
        (((lsu_ld_miss_g & ~ldxa_internal))
        //((lsu_ld_hit_g | lsu_ld_miss_g) & (ld_stb_partial_raw_g))) // ldst_dbl always rqs
        & ~atomic_g & ld1_inst_vld_g)  
        | pref_rq_vld1_g ;

assign ld1_l2cache_rq =  ld1_l2cache_rq_g | ld1_ldbl_rq_w2 ;

   
// ld valid
wire pref_rq_vld1;   
dffre_s #(2)  ld1_vld (
        .din    ({ld1_l2cache_rq, pref_rq_vld1_mx}),
        .q      ({ld1_pkt_vld_unmasked, pref_rq_vld1}),
  .rst  (ld1_vld_reset),  .en (ld1_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// bug2705 - speculative pick in w-cycle-begin
wire    ld1_spec_vld_g ;
assign  ld1_spec_vld_g  =  ld1_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g  &
                           ~atomic_or_ldxa_internal_rq_g &
                           ~(ld0_pkt_vld_unmasked | ld2_pkt_vld_unmasked | ld3_pkt_vld_unmasked);
//assign  ld1_spec_vld_g  =  ld1_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g ;

dff_s #(1) ff_ld1_spec_pick_vld_w2 (
        .din    (ld1_spec_pick_vld_g),
        .q      (ld1_spec_pick_vld_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// kill packet valid if spec req is picked in w and stb hits in w2
wire    ld1_pkt_vld_tmp ;
assign lsu_ld1_spec_vld_kill_w2  =  ld1_spec_pick_vld_w2 & (~ld1_l2cache_rq_w2 | ld1_l2cache_rq_kill | ld1_ldbl_rq_w2 | non_l2bnk_mx1_d1) ;

assign  ld1_pkt_vld_tmp =  ld1_pkt_vld_unmasked & ~(ld1_pcx_rq_sel_d1 | ld1_pcx_rq_sel_d2) &
                      ~(ld1_l2cache_rq_kill | ld1_ldbl_rq_w2) &
                      ~(pref_rq_vld1 & lsu_no_spc_pref[1]) ; 

assign  ld1_pkt_vld = ld1_pkt_vld_tmp | ld1_spec_vld_g ;
// bug2705 - speculative pick in w-cycle-end

//assign  ld1_pkt_vld = ld1_pkt_vld_unmasked & ~ld1_pcx_rq_sel_d1 ; 


assign  ld1_fill_reset = reset | (lsu_dfq_ld_vld & lsu_dcfill_active_e & dfq_byp_sel[1]) ;

wire  ld1_l2cache_rq_g_tmp;
wire  ld1_l2cache_rq_w2_tmp;

assign ld1_l2cache_rq_g_tmp  =  ld1_l2cache_rq_g & ~pref_inst_g ;
 
dff_s #(1) ff_ld1_l2cache_rq_w2 (
         .din    (ld1_l2cache_rq_g_tmp),
         .q      (ld1_l2cache_rq_w2_tmp),
         .clk  (clk),
         .se     (1'b0),       .si (),          .so ()
         );

//wire ld1_unfilled_en ;
//assign	ld1_unfilled_en = ld1_l2cache_rq & ~pref_inst_g ;
wire ld1_unfilled_wy_en ;
assign	ld1_unfilled_wy_en = ld1_l2cache_rq_w2_tmp | ld1_ldbl_rq_w2 ;

wire  ld1_l2cache_rq_tmp;
assign ld1_l2cache_rq_tmp  = ld1_unfilled_wy_en & ~ld1_l2cache_rq_kill;

// ld valid until fill occur.
dffre_s  #(1)  ld1out_state (
        //.din    (ld1_l2cache_rq),
        .din    (ld1_l2cache_rq_tmp),
        .q      (ld1_unfilled_tmp),
        .rst    (ld1_fill_reset_d2),  .en     (ld1_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
  );
dffre_s  #(2)  ld1out_state_way (
        //.din    (ld_pcx_pkt_wy_mx1[`L1D_WAY_MASK]),
        .din    (lsu_lmq_pkt_way_w2[2-1:0]),
        .q      (ld1_unfilled_wy[2-1:0]),
        .rst    (ld1_fill_reset_d2),  .en     (ld1_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
  );


assign	ld1_fill_reset_d2 = ld1_fill_reset_d2_tmp | ld1_l2cache_rq_kill ;
//assign	ld1_unfilled = ld1_unfilled_tmp & ~ld1_l2cache_rq_kill ;
assign	ld1_unfilled = ld1_unfilled_tmp ;

// ld l2bank address
dffe_s  #(3) ld1_l2bnka (
        .din    ({non_l2bnk_mx1,ldst_va_mx1[7:6]}),
        .q      (ld1_l2bnk_addr[2:0]),
  .en (ld1_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - add byp for address to be available in w-cycle
//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2 if non_l2bnk_mx0=1 (non$ access)

wire  [2:0]  ld1_l2bnk_addr_mx ;
assign  ld1_l2bnk_addr_mx[2:0]  =  ld1_pkt_vld_unmasked  ? ld1_l2bnk_addr[2:0] :
				           {1'b0,ldst_va_mx1[7:6]} ; 

//assign  ld1_l2bnk_addr_mx[2:0]  =  (ld1_inst_vld_unflushed  & lsu_inst_vld_tmp) ? 
//				           {1'b0,ldst_va_mx1[7:6]} : 
//				           //{non_l2bnk_mx1,ldst_va_mx1[7:6]} : 
//						ld1_l2bnk_addr[2:0] ;

//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2
dff_s #(1) ff_non_l2bnk_mx1_d1 (
        .din    (non_l2bnk_mx1),
        .q      (non_l2bnk_mx1_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - change ld1_l2bnk_addr[2:0] to ld1_l2bnk_addr_mx[2:0]
assign ld1_l2bnk_dest[0] = ~ld1_l2bnk_addr_mx[2] & ~ld1_l2bnk_addr_mx[1] & ~ld1_l2bnk_addr_mx[0] ;
assign ld1_l2bnk_dest[1] = ~ld1_l2bnk_addr_mx[2] & ~ld1_l2bnk_addr_mx[1] &  ld1_l2bnk_addr_mx[0] ;
assign ld1_l2bnk_dest[2] = ~ld1_l2bnk_addr_mx[2] &  ld1_l2bnk_addr_mx[1] & ~ld1_l2bnk_addr_mx[0] ;
assign ld1_l2bnk_dest[3] = ~ld1_l2bnk_addr_mx[2] &  ld1_l2bnk_addr_mx[1] &  ld1_l2bnk_addr_mx[0] ;
assign ld1_l2bnk_dest[4] =  ld1_l2bnk_addr_mx[2] ;


// THREAD2 LOAD PCX REQUEST CONTROL

wire	ld2_l2cache_rq_kill ; 
assign	ld2_l2cache_rq_kill = 
	ld2_inst_vld_w2 & ((ld_stb_full_raw_w2 & ~dbl_force_l2access_w2) | perr_ld_rq_kill_w2) ; 	
						// full-raw which looks like partial
assign	ld2_ldbl_rq_w2 = 
		((ld_stb_full_raw_w2 & dbl_force_l2access_w2) | ld_stb_partial_raw_w2)
			& ~atomic_w2 & ~perr_ld_rq_kill_w2 & ~(asi_internal_w2 & alt_space_w2) & 
			ld2_inst_vld_w2 ;
//assign	ld2_l2cache_rq_kill = ld2_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 ;
//assign	ld2_ldbl_rq_w2 = ld_stb_full_raw_w2 & dbl_force_l2access_w2 & ~atomic_w2 & ld2_inst_vld_w2 ;

assign ld2_vld_reset = 
  (reset | (ld2_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld2_inst_vld_g | bld_annul_d1[2] | dtag_perr_pkt2_vld_d1[2]))) |
  ld2_l2cache_rq_kill ;
  //(reset | (ld2_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld2_inst_vld_g | bld_annul_d1[2]))) | // bug2877
  //(reset | (ld2_pcx_rq_sel_d1 & ~(pcx_req_squash | ld2_inst_vld_g | bld_annul[2]))) ;

wire  ld2_l2cache_rq_g;

assign ld2_l2cache_rq_g = 
        (((lsu_ld_miss_g & ~ldxa_internal)) 
        //((lsu_ld_hit_g | lsu_ld_miss_g) & (ld_stb_partial_raw_g))) // ldst_dbl always rqs
        & ~atomic_g & ld2_inst_vld_g )
        | pref_rq_vld2_g ;
   
assign ld2_l2cache_rq = ld2_l2cache_rq_g | ld2_ldbl_rq_w2 ;

   
// ld valid
wire pref_rq_vld2;         
dffre_s #(2) ld2_vld (
        .din    ({ld2_l2cache_rq, pref_rq_vld2_mx}),
        .q      ({ld2_pkt_vld_unmasked, pref_rq_vld2} ),
  .rst  (ld2_vld_reset),  .en (ld2_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// bug2705 - speculative pick in w-cycle - begin
wire    ld2_spec_vld_g ;
assign  ld2_spec_vld_g  =  ld2_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g  &
                           ~atomic_or_ldxa_internal_rq_g &
                           ~(ld0_pkt_vld_unmasked | ld1_pkt_vld_unmasked | ld3_pkt_vld_unmasked);
//assign  ld2_spec_vld_g  =  ld2_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g ;

dff_s #(1) ff_ld2_spec_pick_vld_w2 (
        .din    (ld2_spec_pick_vld_g),
        .q      (ld2_spec_pick_vld_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// kill packet valid if spec req is picked in w and stb hits in w2
wire    ld2_pkt_vld_tmp ;
assign lsu_ld2_spec_vld_kill_w2  =  ld2_spec_pick_vld_w2 & (~ld2_l2cache_rq_w2 | ld2_l2cache_rq_kill | ld2_ldbl_rq_w2 | non_l2bnk_mx2_d1) ;

assign  ld2_pkt_vld_tmp = ld2_pkt_vld_unmasked & ~(ld2_pcx_rq_sel_d1 | ld2_pcx_rq_sel_d2) & 
                      ~(ld2_l2cache_rq_kill | ld2_ldbl_rq_w2) &
                      ~(pref_rq_vld2 & lsu_no_spc_pref[2]) ; 

assign  ld2_pkt_vld = ld2_pkt_vld_tmp | ld2_spec_vld_g ;
// bug2705 - speculative pick in w-cycle - end

//assign  ld2_pkt_vld = ld2_pkt_vld_unmasked & ~ld2_pcx_rq_sel_d1 ; 


assign  ld2_fill_reset = reset | (lsu_dfq_ld_vld & lsu_dcfill_active_e & dfq_byp_sel[2]) ;

wire  ld2_l2cache_rq_g_tmp;
wire  ld2_l2cache_rq_w2_tmp;

assign ld2_l2cache_rq_g_tmp  =  ld2_l2cache_rq_g & ~pref_inst_g ;

dff_s #(1) ff_ld2_l2cache_rq_w2 (
         .din    (ld2_l2cache_rq_g_tmp),
         .q      (ld2_l2cache_rq_w2_tmp),
         .clk  (clk),
         .se     (1'b0),       .si (),          .so ()
         );

//wire ld2_unfilled_en ;
//assign	ld2_unfilled_en = ld2_l2cache_rq & ~pref_inst_g ;
wire ld2_unfilled_wy_en ;
assign	ld2_unfilled_wy_en = ld2_l2cache_rq_w2_tmp | ld2_ldbl_rq_w2 ;

wire  ld2_l2cache_rq_tmp;
assign ld2_l2cache_rq_tmp  = ld2_unfilled_wy_en & ~ld2_l2cache_rq_kill;

// ld valid until fill occur.
dffre_s  #(1) ld2out_state (
        //.din    (ld2_l2cache_rq),
        .din    (ld2_l2cache_rq_tmp),
        .q      (ld2_unfilled_tmp),
        .rst    (ld2_fill_reset_d2),  .en     (ld2_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );
dffre_s  #(2) ld2out_state_way (
        .din    (lsu_lmq_pkt_way_w2[2-1:0]),
        .q      (ld2_unfilled_wy[2-1:0]),
        .rst    (ld2_fill_reset_d2),  .en     (ld2_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


assign	ld2_fill_reset_d2 = ld2_fill_reset_d2_tmp | ld2_l2cache_rq_kill ;
//assign	ld2_unfilled = ld2_unfilled_tmp & ~ld2_l2cache_rq_kill ;
assign	ld2_unfilled = ld2_unfilled_tmp ;

// ld l2bank address
dffe_s  #(3) ld2_l2bnka (
        .din    ({non_l2bnk_mx2,ldst_va_mx2[7:6]}),
        .q      (ld2_l2bnk_addr[2:0]),
  .en (ld2_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - add byp for address to be available in w-cycle
//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2 if non_l2bnk_mx0=1 (non$ access)

wire  [2:0]  ld2_l2bnk_addr_mx ;
assign  ld2_l2bnk_addr_mx[2:0]  =  ld2_pkt_vld_unmasked ? ld2_l2bnk_addr[2:0] :
					{1'b0,ldst_va_mx2[7:6]} ; 

//assign  ld2_l2bnk_addr_mx[2:0]  =  (ld2_inst_vld_unflushed  & lsu_inst_vld_tmp) ? 
//					{1'b0,ldst_va_mx2[7:6]} : 
//					//{non_l2bnk_mx2,ldst_va_mx2[7:6]} : 
//						ld2_l2bnk_addr[2:0] ;

//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2
dff_s #(1) ff_non_l2bnk_mx2_d1 (
        .din    (non_l2bnk_mx2),
        .q      (non_l2bnk_mx2_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - change ld2_l2bnk_addr[2:0] to ld2_l2bnk_addr_mx[2:0]
assign ld2_l2bnk_dest[0] = ~ld2_l2bnk_addr_mx[2] & ~ld2_l2bnk_addr_mx[1] & ~ld2_l2bnk_addr_mx[0] ;
assign ld2_l2bnk_dest[1] = ~ld2_l2bnk_addr_mx[2] & ~ld2_l2bnk_addr_mx[1] &  ld2_l2bnk_addr_mx[0] ;
assign ld2_l2bnk_dest[2] = ~ld2_l2bnk_addr_mx[2] &  ld2_l2bnk_addr_mx[1] & ~ld2_l2bnk_addr_mx[0] ;
assign ld2_l2bnk_dest[3] = ~ld2_l2bnk_addr_mx[2] &  ld2_l2bnk_addr_mx[1] &  ld2_l2bnk_addr_mx[0] ;
assign ld2_l2bnk_dest[4] =  ld2_l2bnk_addr_mx[2] ;

// THREAD3 LOAD PCX REQUEST CONTROL

wire	ld3_l2cache_rq_kill ; 
assign	ld3_l2cache_rq_kill = 
	ld3_inst_vld_w2 & ((ld_stb_full_raw_w2 & ~dbl_force_l2access_w2) | perr_ld_rq_kill_w2) ; 	
						// full-raw which looks like partial
assign	ld3_ldbl_rq_w2 = 
		((ld_stb_full_raw_w2 & dbl_force_l2access_w2) | ld_stb_partial_raw_w2)
			& ~atomic_w2 & ~perr_ld_rq_kill_w2 & ~(asi_internal_w2 & alt_space_w2) &
			ld3_inst_vld_w2 ;
//assign	ld3_l2cache_rq_kill = ld3_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 ;
//assign	ld3_ldbl_rq_w2 = ld_stb_full_raw_w2 & dbl_force_l2access_w2 & ~atomic_w2 & ld3_inst_vld_w2 ;

assign ld3_vld_reset = 
  (reset | (ld3_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld3_inst_vld_g | bld_annul_d1[3] | dtag_perr_pkt2_vld_d1[3]))) |
  ld3_l2cache_rq_kill ;
  //(reset | (ld3_pcx_rq_sel_d2 & ~(pcx_req_squash_d1 | ld3_inst_vld_g | bld_annul_d1[3]))) | // bug 2877
  //(reset | (ld3_pcx_rq_sel_d1 & ~(pcx_req_squash | ld3_inst_vld_g | bld_annul[3]))) ;

wire  ld3_l2cache_rq_g;
assign ld3_l2cache_rq_g = 
        (((lsu_ld_miss_g & ~ldxa_internal))
        //((lsu_ld_hit_g | lsu_ld_miss_g) & (ld_stb_partial_raw_g))) // ldst_dbl always rqs
        & ~atomic_g & ld3_inst_vld_g) 
        | pref_rq_vld3_g ;

assign  ld3_l2cache_rq =  ld3_l2cache_rq_g | ld3_ldbl_rq_w2 ;
   
   
// ld valid
wire pref_rq_vld3;         
dffre_s  #(2) ld3_vld (
        .din    ({ld3_l2cache_rq, pref_rq_vld3_mx} ),
        .q      ({ld3_pkt_vld_unmasked, pref_rq_vld3}),
  .rst  (ld3_vld_reset),  .en (ld3_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// bug2705 - speculative pick in w-cycle - begin
wire    ld3_spec_vld_g ;
assign  ld3_spec_vld_g  =  ld3_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g  &
                           ~atomic_or_ldxa_internal_rq_g &
                           ~(ld0_pkt_vld_unmasked | ld1_pkt_vld_unmasked | ld2_pkt_vld_unmasked);
//assign  ld3_spec_vld_g  =  ld3_inst_vld_unflushed & lsu_inst_vld_tmp & ~dbl_force_l2access_g & tlb_cam_hit_g ;


dff_s #(1) ff_ld3_spec_pick_vld_w2 (
        .din    (ld3_spec_pick_vld_g),
        .q      (ld3_spec_pick_vld_w2),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// kill packet valid if spec req is picked in w and stb hits in w2
wire    ld3_pkt_vld_tmp ;
assign lsu_ld3_spec_vld_kill_w2  =  ld3_spec_pick_vld_w2 & (~ld3_l2cache_rq_w2 | ld3_l2cache_rq_kill | ld3_ldbl_rq_w2 | non_l2bnk_mx3_d1) ;

assign  ld3_pkt_vld_tmp = ld3_pkt_vld_unmasked & ~(ld3_pcx_rq_sel_d1 | ld3_pcx_rq_sel_d2) & 
                      ~(ld3_l2cache_rq_kill | ld3_ldbl_rq_w2) &
                      ~(pref_rq_vld3 & lsu_no_spc_pref[3]) ;

assign  ld3_pkt_vld = ld3_pkt_vld_tmp | ld3_spec_vld_g ;
// bug2705 - speculative pick in w-cycle - end

//assign  ld3_pkt_vld = ld3_pkt_vld_unmasked & ~ld3_pcx_rq_sel_d1 ; 

assign  ld3_fill_reset = reset | (lsu_dfq_ld_vld & lsu_dcfill_active_e & dfq_byp_sel[3]) ;

wire  ld3_l2cache_rq_g_tmp;
wire  ld3_l2cache_rq_w2_tmp;

assign ld3_l2cache_rq_g_tmp  =  ld3_l2cache_rq_g & ~pref_inst_g ;

dff_s #(1) ff_ld3_l2cache_rq_w2 (
         .din    (ld3_l2cache_rq_g_tmp),
         .q      (ld3_l2cache_rq_w2_tmp),
         .clk  (clk),
         .se     (1'b0),       .si (),          .so ()
         );

//wire ld3_unfilled_en ;
//assign	ld3_unfilled_en = ld3_l2cache_rq & ~pref_inst_g ;
wire ld3_unfilled_wy_en ;
assign	ld3_unfilled_wy_en = ld3_l2cache_rq_w2_tmp | ld3_ldbl_rq_w2 ;

wire  ld3_l2cache_rq_tmp;
assign ld3_l2cache_rq_tmp  = ld3_unfilled_wy_en & ~ld3_l2cache_rq_kill;

// ld valid until fill occur.
dffre_s #(1)  ld3out_state (
        //.din    (ld3_l2cache_rq),
        .din    (ld3_l2cache_rq_tmp),
        .q      (ld3_unfilled_tmp),
        .rst    (ld3_fill_reset_d2),  .en     (ld3_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );
dffre_s #(2)  ld3out_state_way (
        .din    (lsu_lmq_pkt_way_w2[2-1:0]),
        .q      (ld3_unfilled_wy[2-1:0]),
        .rst    (ld3_fill_reset_d2),  .en     (ld3_unfilled_wy_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


assign	ld3_fill_reset_d2 = ld3_fill_reset_d2_tmp | ld3_l2cache_rq_kill ;
//assign	ld3_unfilled = ld3_unfilled_tmp & ~ld3_l2cache_rq_kill ;
assign	ld3_unfilled = ld3_unfilled_tmp;

// ld l2bank address
dffe_s  #(3) ld3_l2bnka (
        .din    ({non_l2bnk_mx3,ldst_va_mx3[7:6]}),
        .q      (ld3_l2bnk_addr[2:0]),
  .en (ld3_l2cache_rq),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//bug2705 - add byp for address to be available in w-cycle
//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2 if non_l2bnk_mx0=1 (non$ access)

wire  [2:0]  ld3_l2bnk_addr_mx ;
assign  ld3_l2bnk_addr_mx[2:0]  =  ld3_pkt_vld_unmasked ? ld3_l2bnk_addr[2:0] :
					{1'b0,ldst_va_mx3[7:6]} ; 

//assign  ld3_l2bnk_addr_mx[2:0]  =  (ld3_inst_vld_unflushed  & lsu_inst_vld_tmp) ? 
//					{1'b0,ldst_va_mx3[7:6]} : 
//					//{non_l2bnk_mx3,ldst_va_mx3[7:6]} : 
//						ld3_l2bnk_addr[2:0] ;

//7/21/03: timing fix - non_l2bnk_mx0 (uses tlb_pgnum_g[39:37] which arrives in qctl1 ~400ps)
//         this will cause timing paths in spec pick in w-cycle; hence assume $able access for
//         spec pick and kill pkt vld in w2
dff_s #(1) ff_non_l2bnk_mx3_d1 (
        .din    (non_l2bnk_mx3),
        .q      (non_l2bnk_mx3_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );


//bug2705 - change ld3_l2bnk_addr[2:0] to ld3_l2bnk_addr_mx[2:0]
assign ld3_l2bnk_dest[0] = ~ld3_l2bnk_addr_mx[2] & ~ld3_l2bnk_addr_mx[1] & ~ld3_l2bnk_addr_mx[0] ;
assign ld3_l2bnk_dest[1] = ~ld3_l2bnk_addr_mx[2] & ~ld3_l2bnk_addr_mx[1] &  ld3_l2bnk_addr_mx[0] ;
assign ld3_l2bnk_dest[2] = ~ld3_l2bnk_addr_mx[2] &  ld3_l2bnk_addr_mx[1] & ~ld3_l2bnk_addr_mx[0] ;
assign ld3_l2bnk_dest[3] = ~ld3_l2bnk_addr_mx[2] &  ld3_l2bnk_addr_mx[1] &  ld3_l2bnk_addr_mx[0] ;
assign ld3_l2bnk_dest[4] =  ld3_l2bnk_addr_mx[2] ;

//=================================================================================================
//  LMQ Miscellaneous Control
//=================================================================================================

dff_s #(1) stgm_cas (
        .din    (ifu_lsu_casa_e),
        .q      (casa_m),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(1) stgg_cas (
        .din    (casa_m),
        .q      (casa_g),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign  casa0_g = casa_g & thread0_g ;
//assign  casa1_g = casa_g & thread1_g ;
//assign  casa2_g = casa_g & thread2_g ;
//assign  casa3_g = casa_g & thread3_g ;

// PARTIAL RAW BYPASSING.

// Partial raw of load in stb. Even if the load hits in the dcache, it must follow
// the st to the pcx, obtain merged data to bypass to the pipeline. This load will 
// also fill the dcache. i.e., once the store is received it looks like a normal load.

// This path is also used for 2nd cas pkt. rs1(addr) and rs2(cmp data) are in 1st
// pkt which is written to stb. rd(swap value) is written to lmq as 2nd pkt. The
// 2nd pkt will wait in the lmq until the 1st pkt is sent.

// *** Atomics need to switch out the thread ***

// THREAD0

// timing fix: 9/15/03 - reduce loading on pcx_rq_for_stb[3:0] to stb_clt[0-3]. it had FO2 (stb_ctl,qdp2 - cap=0.5-0.8)
//             move the flop from qdp2 to qctl1

dff_s #(4)  ff_pcx_rq_for_stb_d1 (
        .din    (pcx_rq_for_stb[3:0]),
        .q      (pcx_rq_for_stb_d1[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dff_s #(4)  srqsel_d1 (
        .din    (pcx_rq_for_stb[3:0]),
        //.q      ({st3_pcx_rq_tmp, st2_pcx_rq_tmp,st1_pcx_rq_tmp, st0_pcx_rq_tmp}),
        .q      ({st3_pcx_rq_sel_d1, st2_pcx_rq_sel_d1,st1_pcx_rq_sel_d1, st0_pcx_rq_sel_d1}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dff_s #(4)  srqsel_d2 (
        .din      ({st3_pcx_rq_sel_d1, st2_pcx_rq_sel_d1,st1_pcx_rq_sel_d1, st0_pcx_rq_sel_d1}),
        .q      ({st3_pcx_rq_sel_d2, st2_pcx_rq_sel_d2,st1_pcx_rq_sel_d2, st0_pcx_rq_sel_d2}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dff_s #(4)  srqsel_d3 (
        .din    ({st3_pcx_rq_sel_d2, st2_pcx_rq_sel_d2,st1_pcx_rq_sel_d2, st0_pcx_rq_sel_d2}),
        .q      ({st3_pcx_rq_sel_d3, st2_pcx_rq_sel_d3,st1_pcx_rq_sel_d3, st0_pcx_rq_sel_d3}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

wire	ld0_ldbl_rawp_en_w2 ;
assign	ld0_ldbl_rawp_en_w2 = ld0_ldbl_rq_w2 & ~ld_rawp_st_ced_w2 & ~ld0_rawp_reset ;

/*assign	st3_pcx_rq_sel_d1 = st3_pcx_rq_tmp & ~pcx_req_squash ;
assign	st2_pcx_rq_sel_d1 = st2_pcx_rq_tmp & ~pcx_req_squash ;
assign	st1_pcx_rq_sel_d1 = st1_pcx_rq_tmp & ~pcx_req_squash ;
assign	st0_pcx_rq_sel_d1 = st0_pcx_rq_tmp & ~pcx_req_squash ;*/

assign ld0_rawp_reset =
        (reset | (st0_pcx_rq_sel_d3 & ~pcx_req_squash_d2 & ld0_rawp_disabled & (ld0_rawp_ackid[2:0] == stb0_crnt_ack_id[2:0])));
        //(reset | (st0_pcx_rq_sel_d2 & ~pcx_req_squash_d1 & ld0_rawp_disabled & (ld0_rawp_ackid[2:0] == stb0_crnt_ack_id[2:0])));

// TO BE REMOVED ALONG WITH defines !!!
//wire	ld_rawp_st_ced_g ;
//assign 	ld_rawp_st_ced_g = 1'b0 ;

// reset needs to be dominant in case ack comes on fly.
// atomics will not set rawp_disabled
assign ld0_rawp_en = 
        //(((ld_stb_partial_raw_g) & ~ld_rawp_st_ced_g & ~ld0_rawp_reset)     // partial_raw
        //& ~atomic_g & ld0_inst_vld_g) |          // cas inst - 2nd pkt
	ld0_ldbl_rawp_en_w2 ;

// ack-id and wait-for-ack disable - Thread 0
dffre_s #(1)  ldrawp0_dis (
        .din    (ld0_rawp_en),
        .q      (ld0_rawp_disabled),
        .rst    (ld0_rawp_reset),  .en     (ld0_rawp_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dffe_s #(3)  ldrawp0_ackid (
        .din    (ld_rawp_st_ackid_w2[2:0]),
        .q      (ld0_rawp_ackid[2:0]),
        .en     (ld0_inst_vld_w2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

// THREAD1

wire	ld1_ldbl_rawp_en_w2 ;
assign	ld1_ldbl_rawp_en_w2 = ld1_ldbl_rq_w2 & ~ld_rawp_st_ced_w2 & ~ld1_rawp_reset ;

// 1st st ack for st-quad will not cause ack.

assign ld1_rawp_reset =
        (reset | (st1_pcx_rq_sel_d3 & ~pcx_req_squash_d2 & ld1_rawp_disabled & 
        //(reset | (st1_pcx_rq_sel_d2 & ~pcx_req_squash_d1 & ld1_rawp_disabled & 
			(ld1_rawp_ackid[2:0] == stb1_crnt_ack_id[2:0])));

// reset needs to be dominant in case ack comes on fly.
// atomics will not set rawp_disabled
assign ld1_rawp_en = 
        //(((ld_stb_partial_raw_g) & ~ld_rawp_st_ced_g & ~ld1_rawp_reset) // partial raw
        //(((ld_stb_partial_raw_g | (ld_stb_full_raw_g & ldst_dbl_g)) & ~ld_rawp_st_ced_g & ~ld1_rawp_reset) // partial raw
        //& ~atomic_g  & ld1_inst_vld_g)  |                // cas inst - 2nd pkt
	ld1_ldbl_rawp_en_w2 ;

// ack-id and wait-for-ack disable - Thread 0
dffre_s #(1)  ldrawp1_dis (
        .din    (ld1_rawp_en),
        .q      (ld1_rawp_disabled),
        .rst    (ld1_rawp_reset),  .en     (ld1_rawp_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dffe_s #(3)  ldrawp1_ackid (
        .din    (ld_rawp_st_ackid_w2[2:0]),
        .q      (ld1_rawp_ackid[2:0]),
        .en     (ld1_inst_vld_w2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

// THREAD2

wire	ld2_ldbl_rawp_en_w2 ;
assign	ld2_ldbl_rawp_en_w2 = ld2_ldbl_rq_w2 & ~ld_rawp_st_ced_w2 & ~ld2_rawp_reset ;

assign ld2_rawp_reset =
        (reset | (st2_pcx_rq_sel_d3 & ~pcx_req_squash_d2 & ld2_rawp_disabled & 
        //(reset | (st2_pcx_rq_sel_d2 & ~pcx_req_squash_d1 & ld2_rawp_disabled & 
			(ld2_rawp_ackid[2:0] == stb2_crnt_ack_id[2:0])));

// reset needs to be dominant in case ack comes on fly.
// atomics will not set rawp_disabled
assign ld2_rawp_en = 
        //(((ld_stb_partial_raw_g) & ~ld_rawp_st_ced_g & ~ld2_rawp_reset) // partial raw
        //& ~atomic_g & ld2_inst_vld_g) |          // cas inst - 2nd pkt
	ld2_ldbl_rawp_en_w2 ;

// ack-id and wait-for-ack disable - Thread 0
dffre_s #(1)  ldrawp2_dis (
        .din    (ld2_rawp_en),
        .q      (ld2_rawp_disabled),
        .rst    (ld2_rawp_reset),  .en     (ld2_rawp_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dffe_s #(3)  ldrawp2_ackid (
        .din    (ld_rawp_st_ackid_w2[2:0]),
        .q      (ld2_rawp_ackid[2:0]),
        .en     (ld2_inst_vld_w2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

// THREAD3

wire	ld3_ldbl_rawp_en_w2 ;
assign	ld3_ldbl_rawp_en_w2 = ld3_ldbl_rq_w2 & ~ld_rawp_st_ced_w2 & ~ld3_rawp_reset ;

assign ld3_rawp_reset =
        (reset | (st3_pcx_rq_sel_d3 & ~pcx_req_squash_d2 & ld3_rawp_disabled & 
        //(reset | (st3_pcx_rq_sel_d2 & ~pcx_req_squash_d1 & ld3_rawp_disabled & 
				(ld3_rawp_ackid[2:0] == stb3_crnt_ack_id[2:0])));

// reset needs to be dominant in case ack comes on fly.
// atomics will not set rawp_disabled
assign ld3_rawp_en = 
        //(((ld_stb_partial_raw_g) & ~ld_rawp_st_ced_g & ~ld3_rawp_reset) // partial raw
        //& ~atomic_g & ld3_inst_vld_g) |          // cas inst - 2nd pkt
	ld3_ldbl_rawp_en_w2 ;

// ack-id and wait-for-ack disable - Thread 0
dffre_s #(1)  ldrawp3_dis (
        .din    (ld3_rawp_en),
        .q      (ld3_rawp_disabled),
        .rst    (ld3_rawp_reset),  .en     (ld3_rawp_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                

dffe_s #(3)  ldrawp3_ackid (
        .din    (ld_rawp_st_ackid_w2[2:0]),
        .q      (ld3_rawp_ackid[2:0]),
        .en     (ld3_inst_vld_w2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                



//=================================================================================================
//  INTERRUPT PCX PKT REQ CTL
//=================================================================================================

wire    intrpt_pcx_rq_sel_d2 ;
wire    intrpt_vld_reset;
wire    intrpt_vld_en ;
wire  [3:0] intrpt_thread ;
wire    intrpt_clr ;


assign  lsu_tlu_pcxpkt_ack = intrpt_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;

assign intrpt_vld_reset =
        reset | lsu_tlu_pcxpkt_ack ;
        //reset | (intrpt_pcx_rq_sel_d1 & ~pcx_req_squash);
wire    intrpt_pkt_vld_unmasked ;
// assumption is that pkt vld cannot be turned around in same cycle
assign intrpt_vld_en = ~intrpt_pkt_vld_unmasked ;
//assign intrpt_vld_en = ~lsu_intrpt_pkt_vld ;

dff_s #(1) intpkt_stgd2 (
        .din    (intrpt_pcx_rq_sel_d1),
        .q      (intrpt_pcx_rq_sel_d2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// intrpt valid
dffre_s  intrpt_vld (
        .din    (tlu_lsu_pcxpkt_vld),
        .q      (intrpt_pkt_vld_unmasked),
        .rst    (intrpt_vld_reset),     .en     (intrpt_vld_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  intrpt_thread[0] = ~tlu_lsu_pcxpkt_tid[19] & ~tlu_lsu_pcxpkt_tid[18] ;
assign  intrpt_thread[1] = ~tlu_lsu_pcxpkt_tid[19] &  tlu_lsu_pcxpkt_tid[18] ;
assign  intrpt_thread[2] =  tlu_lsu_pcxpkt_tid[19] & ~tlu_lsu_pcxpkt_tid[18] ;
assign  intrpt_thread[3] =  tlu_lsu_pcxpkt_tid[19] &  tlu_lsu_pcxpkt_tid[18] ;

assign  intrpt_clr =
  (intrpt_thread[0] & lsu_stb_empty[0]) |
  (intrpt_thread[1] & lsu_stb_empty[1]) |
  (intrpt_thread[2] & lsu_stb_empty[2]) |
  (intrpt_thread[3] & lsu_stb_empty[3]) ;

wire	intrpt_clr_d1 ;
dff_s #(1) intclr_stgd1 (
        .din    (intrpt_clr),
        .q      (intrpt_clr_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[3:0]	intrpt_cmplt ;

assign  intrpt_cmplt[0] = lsu_tlu_pcxpkt_ack & intrpt_thread[0] ;
assign  intrpt_cmplt[1] = lsu_tlu_pcxpkt_ack & intrpt_thread[1] ;
assign  intrpt_cmplt[2] = lsu_tlu_pcxpkt_ack & intrpt_thread[2] ;
assign  intrpt_cmplt[3] = lsu_tlu_pcxpkt_ack & intrpt_thread[3] ;

dff_s #(4) intrpt_stg (
        .din    (intrpt_cmplt[3:0]),
        .q      (lsu_intrpt_cmplt[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  intrpt_pkt_vld =
intrpt_pkt_vld_unmasked & ~(intrpt_pcx_rq_sel_d1 | intrpt_pcx_rq_sel_d2) & intrpt_clr_d1 ;

// ** enabled flop should not be required !!
// intrpt l2bank address
// ?? Can interrupt requests go to io-bridge ??
// Using upper 3b of 5b thread field of INTR_W to address 4 l2 banks
dffe_s #(3) intrpt_l2bnka (
        .din    ({1'b0,tlu_lsu_pcxpkt_l2baddr[11:10]}),
        .q      (intrpt_l2bnk_addr[2:0]),
        .en     (intrpt_vld_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// IO Requests should not go to iobrdge.
assign intrpt_l2bnk_dest[0] =
~intrpt_l2bnk_addr[2] & ~intrpt_l2bnk_addr[1] & ~intrpt_l2bnk_addr[0] ;
assign intrpt_l2bnk_dest[1] =
~intrpt_l2bnk_addr[2] & ~intrpt_l2bnk_addr[1] &  intrpt_l2bnk_addr[0] ;
assign intrpt_l2bnk_dest[2] =
~intrpt_l2bnk_addr[2] & intrpt_l2bnk_addr[1] & ~intrpt_l2bnk_addr[0] ;
assign intrpt_l2bnk_dest[3] =
~intrpt_l2bnk_addr[2] & intrpt_l2bnk_addr[1] &  intrpt_l2bnk_addr[0] ;
assign intrpt_l2bnk_dest[4] = intrpt_l2bnk_addr[2] ;

//=================================================================================================
//
// QDP Specific Control
//
//=================================================================================================


// Qualify with thread.
// Write cas pckt 2 to lmq
// Timing Change : ld0_l2cache_rq guarantees validity.
//assign lmq_enable[0] = lsu_ld_miss_g & thread0_g ;
//assign lmq_enable[0] = ld0_inst_vld_g | pref_vld0_g ;

//assign lmq_enable[0] = (ld0_inst_vld_unflushed & lsu_inst_vld_w) | pref_vld0_g ;
//assign lmq_enable[1] = (ld1_inst_vld_unflushed & lsu_inst_vld_w) | pref_vld1_g ;
//assign lmq_enable[2] = (ld2_inst_vld_unflushed & lsu_inst_vld_w) | pref_vld2_g ;
//assign lmq_enable[3] = (ld3_inst_vld_unflushed & lsu_inst_vld_w) | pref_vld3_g ;

//bug 2771; timing path - remove flush-pipe, add ifu's flush signal
//assign lmq_enable[0] = (ld0_inst_vld_unflushed | pref_vld0_g) & lsu_inst_vld_w ;
assign lmq_enable[0] = (ld0_inst_vld_unflushed | pref_vld0_g) & lsu_inst_vld_tmp & ~ifu_lsu_flush_w ;
assign lmq_enable[1] = (ld1_inst_vld_unflushed | pref_vld1_g) & lsu_inst_vld_tmp & ~ifu_lsu_flush_w ;
assign lmq_enable[2] = (ld2_inst_vld_unflushed | pref_vld2_g) & lsu_inst_vld_tmp & ~ifu_lsu_flush_w ;
assign lmq_enable[3] = (ld3_inst_vld_unflushed | pref_vld3_g) & lsu_inst_vld_tmp & ~ifu_lsu_flush_w ; 
        
// timing fix: 5/19/03: move secondary hit way generation to w2
dff_s #(4) ff_lmq_enable_w2 (
        .din    (lmq_enable[3:0]),
        .q      (lmq_enable_w2[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


// needs to be 1-hot always.
assign imiss_pcx_mx_sel = imiss_pcx_rq_sel_d1 ;
//assign imiss_pcx_mx_sel[1] = strm_pcx_rq_sel_d1 ;
//assign imiss_pcx_mx_sel[2] = intrpt_pcx_rq_sel_d1 ;
//assign imiss_pcx_mx_sel[3] = fpop_pcx_rq_sel_d1 ;

//11/7/03: add rst_tri_en
wire  [2:0]  fwd_int_fp_pcx_mx_sel_tmp ;

assign fwd_int_fp_pcx_mx_sel_tmp[0]= ~fwd_int_fp_pcx_mx_sel[1] & ~fwd_int_fp_pcx_mx_sel[2];
assign fwd_int_fp_pcx_mx_sel_tmp[1]=  intrpt_pcx_rq_sel_d1 ;
assign fwd_int_fp_pcx_mx_sel_tmp[2]=  fpop_pcx_rq_sel_d1 | fpop_pcx_rq_sel_d2 ;

assign fwd_int_fp_pcx_mx_sel[1:0] = fwd_int_fp_pcx_mx_sel_tmp[1:0] & ~{2{rst_tri_en}} ;
assign fwd_int_fp_pcx_mx_sel[2]   = fwd_int_fp_pcx_mx_sel_tmp[2] | rst_tri_en ;


//*************************************************************************************************
// 			PCX REQUEST GENERATION (BEGIN)

//=================================================================================================
//  PCX REQUEST SELECTION CONTROL
//=================================================================================================

// LOAD
// fpops have to squash other rqs in the 2nd cycle also.
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign ld0_pcx_rq_vld = 
  (|(queue_write[4:0] & ld0_l2bnk_dest[4:0])) & 
    ld0_pkt_vld & ~ld0_rawp_disabled;
    //ld0_pkt_vld & ~ld0_rawp_disabled & ~mcycle_squash_d1;
    //ld0_pkt_vld & ~ld0_rawp_disabled & ~st_atom_rq_d1 ;
assign ld1_pcx_rq_vld = 
  (|(queue_write[4:0] & ld1_l2bnk_dest[4:0])) & 
    ld1_pkt_vld & ~ld1_rawp_disabled;
    //ld1_pkt_vld & ~ld1_rawp_disabled & ~mcycle_squash_d1;
    //ld1_pkt_vld & ~ld1_rawp_disabled & ~st_atom_rq_d1 ;
assign ld2_pcx_rq_vld = 
  (|(queue_write[4:0] & ld2_l2bnk_dest[4:0])) & 
    ld2_pkt_vld & ~ld2_rawp_disabled ;
    //ld2_pkt_vld & ~ld2_rawp_disabled & ~mcycle_squash_d1;
    //ld2_pkt_vld & ~ld2_rawp_disabled & ~st_atom_rq_d1 ;
assign ld3_pcx_rq_vld = 
  (|(queue_write[4:0] & ld3_l2bnk_dest[4:0])) & 
    ld3_pkt_vld & ~ld3_rawp_disabled;
    //ld3_pkt_vld & ~ld3_rawp_disabled & ~mcycle_squash_d1;
    //ld3_pkt_vld & ~ld3_rawp_disabled & ~st_atom_rq_d1 ;

//assign  ld_pcx_rq_vld = ld0_pcx_rq_vld | ld1_pcx_rq_vld 
//      | ld2_pcx_rq_vld | ld3_pcx_rq_vld ;

wire    st0_atomic_pend_d1, st1_atomic_pend_d1, st2_atomic_pend_d1, st3_atomic_pend_d1 ;

assign  st0_q_wr[4:0] = st0_atomic_pend_d1 ? pre_qwr[4:0] : queue_write[4:0] ;
assign  st1_q_wr[4:0] = st1_atomic_pend_d1 ? pre_qwr[4:0] : queue_write[4:0] ;
assign  st2_q_wr[4:0] = st2_atomic_pend_d1 ? pre_qwr[4:0] : queue_write[4:0] ;
assign  st3_q_wr[4:0] = st3_atomic_pend_d1 ? pre_qwr[4:0] : queue_write[4:0] ;

assign  st0_atom_rq = (st0_pcx_rq_sel & st0_atomic_vld) ; 
assign  st1_atom_rq = (st1_pcx_rq_sel & st1_atomic_vld) ;
assign  st2_atom_rq = (st2_pcx_rq_sel & st2_atomic_vld) ;
assign  st3_atom_rq = (st3_pcx_rq_sel & st3_atomic_vld) ;

dff_s #(8)  avlds_d1 (
        .din    ({st0_atom_rq,st1_atom_rq,st2_atom_rq,st3_atom_rq,
    st0_cas_vld,st1_cas_vld,st2_cas_vld,st3_cas_vld}),
        .q      ({st0_atom_rq_d1,st1_atom_rq_d1,st2_atom_rq_d1,st3_atom_rq_d1,
    st0_cas_vld_d1,st1_cas_vld_d1,st2_cas_vld_d1,st3_cas_vld_d1}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s #(8)  avlds_d2 (
        .din    ({st0_atom_rq_d1,st1_atom_rq_d1,st2_atom_rq_d1,st3_atom_rq_d1,
    st0_cas_vld_d1,st1_cas_vld_d1,st2_cas_vld_d1,st3_cas_vld_d1}),
        .q      ({st0_atom_rq_d2,st1_atom_rq_d2,st2_atom_rq_d2,st3_atom_rq_d2,
    st0_cas_vld_d2,st1_cas_vld_d2,st2_cas_vld_d2,st3_cas_vld_d2}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//timing fix : 7/28/03 - move the OR before flop
assign st_atom_rq = st0_atom_rq | st1_atom_rq | st2_atom_rq | st3_atom_rq ; 
//assign st_atom_rq_d1 = st0_atom_rq_d1 | st1_atom_rq_d1 | st2_atom_rq_d1 | st3_atom_rq_d1 ; 

// timing fix: 7/28/03 - move the OR before flop
dff_s #(1)  ff_st_atom_pq (
  .din (st_atom_rq),
  .q   (st_atom_rq_d1),
  .clk (clk),
  .se  (1'b0), .si (), .so ()
  );


assign st_cas_rq_d2 = 
  (st0_atom_rq_d2 & st0_cas_vld_d2)  | 
  (st1_atom_rq_d2 & st1_cas_vld_d2)  | 
  (st2_atom_rq_d2 & st2_cas_vld_d2)  | 
  (st3_atom_rq_d2 & st3_cas_vld_d2)  ; 
//assign st_quad_rq_d2 = 
//  (st0_atom_rq_d2 & ~st0_cas_vld_d2)  | 
//  (st1_atom_rq_d2 & ~st1_cas_vld_d2)  | 
//  (st2_atom_rq_d2 & ~st2_cas_vld_d2)  | 
//  (st3_atom_rq_d2 & ~st3_cas_vld_d2)  ; 

//timing fix: 9/17/03 - move the OR to previous cycle and add flop for spc_pcx_atom_pq
//                      instantiate buf30 for flop output
//assign  spc_pcx_atom_pq = 
//    st_atom_rq_d1 |  
//    fpop_atom_rq_pq ;

wire  spc_pcx_atom_w, spc_pcx_atom_pq_tmp ;
assign spc_pcx_atom_w  =  st_atom_rq | fpop_atom_req ;

dff_s #(1)  ff_spc_pcx_atom_pq (
  .din (spc_pcx_atom_w),
  .q   (spc_pcx_atom_pq_tmp),
  .clk (clk),
  .se  (1'b0), .si (), .so ()
  );

bw_u1_buf_30x UZfix_spc_pcx_atom_pq_buf1 ( .a(spc_pcx_atom_pq_tmp), .z(spc_pcx_atom_pq) );
bw_u1_buf_30x UZsize_spc_pcx_atom_pq_buf2 ( .a(spc_pcx_atom_pq_tmp), .z(spc_pcx_atom_pq_buf2) );

// STORE
// st will wait in pcx bypass until previous st in chain is acked !!!!
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign st0_pcx_rq_vld = 
  (|(st0_q_wr[4:0] & st0_l2bnk_dest[4:0])) & st0_pkt_vld ;
  //(|(st0_q_wr[4:0] & st0_l2bnk_dest[4:0])) & st0_pkt_vld & ~mcycle_squash_d1;
  //(|(st0_q_wr[4:0] & st0_l2bnk_dest[4:0])) & st0_pkt_vld & ~st_atom_rq_d1 ;
assign st1_pcx_rq_vld = 
  (|(st1_q_wr[4:0] & st1_l2bnk_dest[4:0])) & st1_pkt_vld ;
  //(|(st1_q_wr[4:0] & st1_l2bnk_dest[4:0])) & st1_pkt_vld & ~mcycle_squash_d1;
  //(|(st1_q_wr[4:0] & st1_l2bnk_dest[4:0])) & st1_pkt_vld & ~st_atom_rq_d1 ;
assign st2_pcx_rq_vld = 
  (|(st2_q_wr[4:0] & st2_l2bnk_dest[4:0])) & st2_pkt_vld ;
  //(|(st2_q_wr[4:0] & st2_l2bnk_dest[4:0])) & st2_pkt_vld & ~mcycle_squash_d1;
  //(|(st2_q_wr[4:0] & st2_l2bnk_dest[4:0])) & st2_pkt_vld & ~st_atom_rq_d1 ;
assign st3_pcx_rq_vld = 
  (|(st3_q_wr[4:0] & st3_l2bnk_dest[4:0])) & st3_pkt_vld ;
  //(|(st3_q_wr[4:0] & st3_l2bnk_dest[4:0])) & st3_pkt_vld & ~mcycle_squash_d1;
  //(|(st3_q_wr[4:0] & st3_l2bnk_dest[4:0])) & st3_pkt_vld & ~st_atom_rq_d1 ;

// IMISS
// imiss requests will not speculate - ** change !!!
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign imiss_pcx_rq_vld = 
  (|(queue_write[4:0] & imiss_l2bnk_dest[4:0])) & imiss_pkt_vld ;
  //(|(queue_write[4:0] & imiss_l2bnk_dest[4:0])) & imiss_pkt_vld & ~mcycle_squash_d1;
  //(|((queue_write[4:0] & (sel_qentry0[4:0] | (~sel_qentry0[4:0] & ~spc_pcx_req_update_w2[4:0]))) & imiss_l2bnk_dest[4:0])) & imiss_pkt_vld & ~mcycle_squash_d1;

// SPU
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign strm_pcx_rq_vld = 
  (|(queue_write[4:0] & strm_l2bnk_dest[4:0])) & strm_pkt_vld ;
  //(|(queue_write[4:0] & strm_l2bnk_dest[4:0])) & strm_pkt_vld & ~mcycle_squash_d1;

wire lsu_fwdpkt_vld_d1 ;
wire	[4:0]	fwdpkt_dest_d1 ;
// This delay is to compensate for the 1-cycle delay for internal rd/wr.
dff_s #(6)  fvld_stgd1 (
  .din ({lsu_fwdpkt_vld,lsu_fwdpkt_dest[4:0]}),
  .q   ({lsu_fwdpkt_vld_d1,fwdpkt_dest_d1[4:0]}),
  .clk (clk),
  .se  (1'b0), .si (), .so ()
  );

// FWD PKT
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign fwdpkt_rq_vld = 
  (|(queue_write[4:0] & fwdpkt_dest_d1[4:0])) & 
	lsu_fwdpkt_vld_d1 & 
	~(fwdpkt_pcx_rq_sel_d1 | fwdpkt_pcx_rq_sel_d2 |  // screen vld until reset can be sent.
	fwdpkt_pcx_rq_sel_d3) ;	// extra cycle since fwdpkt_vld is now flop delayed.
	//~mcycle_squash_d1;

// This to reset state. It must thus take into account speculative requests.
assign lsu_fwdpkt_pcx_rq_sel =  fwdpkt_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;

// INTERRUPT
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign intrpt_pcx_rq_vld = 
  (|(queue_write[4:0] & intrpt_l2bnk_dest[4:0])) & intrpt_pkt_vld ;
  //(|(queue_write[4:0] & intrpt_l2bnk_dest[4:0])) & intrpt_pkt_vld & ~mcycle_squash_d1;

// FFU
// fpop will never get squashed.
// ** Should be able to simplify equation.
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
//for fpop pre_qwr is good enough to qual 'cos there are no ld/st atomics to IOB
wire [4:0]  fpop_q_wr ;
assign fpop_pcx_rq_vld = 
  //sel_qentry0[4] & fpop_l2bnk_dest[4] & fpop_pkt_vld ;
  //(|(queue_write[4:0] & fpop_l2bnk_dest[4:0])) & 
  //(|(pre_qwr[4:0] & fpop_l2bnk_dest[4:0])) &
  (|(fpop_q_wr[4:0] & fpop_l2bnk_dest[4:0])) & 
	// change sel_qentry0[5] to sel_qentry0[4] for fpio merge
      fpop_pkt_vld ;
      //fpop_pkt_vld & ((sel_qentry0[4] & fpop_pkt1) | ~fpop_pkt1) ;
	//~mcycle_squash_d1 ;


//=================================================================================================
// HIERARCHICAL PICKER FOR PCX REQ GENERATION
//=================================================================================================

// 13 requests to choose from :
// - imiss, 4 ld, 4 st, (intrpt,strm,fpop,fwdpkt).
// - 4 categories are thus formed, each with equal weight.
// - As a consequence, imiss has the highest priority (because it is one vs. 4 in others)
// - Fair scheduling thru round-robin is ensured between and within categories.
// - Starvation for 2-cycle b2b ops (cas/fpop) is prevented.
// - strm requests, even though they lie in the misc category, will get good 
// thruput as the other misc requests will be infrequent.

// LEVEL ONE - PICK WITHIN CATEGORIES

// Note : picker defaults to 1-hot.

wire	[3:0]	all_pcx_rq_pick ;
wire	[3:0]	ld_events_raw ;
//wire	[3:0]	ld_events_final ;
wire	ld3_pcx_rq_pick,ld2_pcx_rq_pick,ld1_pcx_rq_pick,ld0_pcx_rq_pick ;

//bug6807 - kill load events raw when partial raw is detected.
assign ld_events_raw[0]  =  (ld0_pkt_vld_unmasked & ~ld0_rawp_disabled) | ld0_pcx_rq_sel_d1 | ld0_pcx_rq_sel_d2 ;
assign ld_events_raw[1]  =  (ld1_pkt_vld_unmasked & ~ld1_rawp_disabled) | ld1_pcx_rq_sel_d1 | ld1_pcx_rq_sel_d2 ;
assign ld_events_raw[2]  =  (ld2_pkt_vld_unmasked & ~ld2_rawp_disabled) | ld2_pcx_rq_sel_d1 | ld2_pcx_rq_sel_d2 ;
assign ld_events_raw[3]  =  (ld3_pkt_vld_unmasked & ~ld3_rawp_disabled) | ld3_pcx_rq_sel_d1 | ld3_pcx_rq_sel_d2 ;

//bug4814 - change rrobin_picker1 to rrobin_picker2
// Choose one among 4 loads.
//lsu_rrobin_picker1 ld4_rrobin  (
//    .events   	  ({ld3_pcx_rq_vld,ld2_pcx_rq_vld,
//		    ld1_pcx_rq_vld,ld0_pcx_rq_vld}),
//    .events_raw   ({ld3_pkt_vld_unmasked,ld2_pkt_vld_unmasked,
//		    ld1_pkt_vld_unmasked,ld0_pkt_vld_unmasked}),
//    .pick_one_hot ({ld3_pcx_rq_pick,ld2_pcx_rq_pick,
//		    ld1_pcx_rq_pick,ld0_pcx_rq_pick}),
//    .events_final (ld_events_final[3:0]),
//    .rclk         (rclk),
//    .grst_l       (grst_l),
//    .arst_l       (arst_l),
//    .si(),
//    .se(se),
//    .so()
//  );

lsu_rrobin_picker2 ld4_rrobin  (
    .events   	  ({ld3_pcx_rq_vld,ld2_pcx_rq_vld,ld1_pcx_rq_vld,ld0_pcx_rq_vld}),
    .thread_force (ld_thrd_force_vld[3:0]),
    .pick_one_hot ({ld3_pcx_rq_pick,ld2_pcx_rq_pick,ld1_pcx_rq_pick,ld0_pcx_rq_pick}),
    .events_picked({ld3_pcx_rq_sel,ld2_pcx_rq_sel,ld1_pcx_rq_sel,ld0_pcx_rq_sel}),
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so()
  );




//timing fix: 05/20/03 - move mcycle_squash_d1 after pick instead of before pick
//assign	ld3_pcx_rq_sel = ld3_pcx_rq_pick & ld3_pcx_rq_vld & all_pcx_rq_pick[1] ;
//assign	ld2_pcx_rq_sel = ld2_pcx_rq_pick & ld2_pcx_rq_vld & all_pcx_rq_pick[1] ;
//assign	ld1_pcx_rq_sel = ld1_pcx_rq_pick & ld1_pcx_rq_vld & all_pcx_rq_pick[1] ;
//assign	ld0_pcx_rq_sel = ld0_pcx_rq_pick & ld0_pcx_rq_vld & all_pcx_rq_pick[1] ;
//bug2705 - add spec valid qualification
//assign	ld3_pcx_rq_sel = ld3_pcx_rq_pick & ld3_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
//timing fix: 08/06/03 - tag_rdata->gen tag_parity_err->lsu_ld_miss_g arrives @625 in qctl1
//                       cache_way_hit ->lsu_ld_miss_g arrives @525 in qctl1
//                       cache_way_hit ->lsu_way_hit_or arrives @510 in qctl1
//                       625ps + ld?_l2cache_rq_g (130ps) + urq_stgpq flop logic(100ps) (slack=-100ps)
//assign  ld0_spec_pick_vld_g  =   ld0_spec_vld_g & ld0_l2cache_rq_g & ld0_pcx_rq_pick & ld0_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
wire    ld0_nspec_pick_vld ,
        ld1_nspec_pick_vld ,
        ld2_nspec_pick_vld ,
        ld3_nspec_pick_vld ;

assign  ld0_spec_pick_vld_g  =   ld0_spec_vld_g & ~lsu_way_hit_or & ld0_pcx_rq_pick & ld0_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
assign  ld0_nspec_pick_vld   =  ~ld0_spec_vld_g &                   ld0_pcx_rq_pick & ld0_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;

assign  ld1_spec_pick_vld_g  =   ld1_spec_vld_g & ~lsu_way_hit_or & ld1_pcx_rq_pick & ld1_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
assign  ld1_nspec_pick_vld   =  ~ld1_spec_vld_g &                   ld1_pcx_rq_pick & ld1_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;

assign  ld2_spec_pick_vld_g  =   ld2_spec_vld_g & ~lsu_way_hit_or & ld2_pcx_rq_pick & ld2_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
assign  ld2_nspec_pick_vld   =  ~ld2_spec_vld_g &                   ld2_pcx_rq_pick & ld2_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;

assign  ld3_spec_pick_vld_g  =   ld3_spec_vld_g & ~lsu_way_hit_or & ld3_pcx_rq_pick & ld3_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;
assign  ld3_nspec_pick_vld   =  ~ld3_spec_vld_g &                   ld3_pcx_rq_pick & ld3_pcx_rq_vld & all_pcx_rq_pick[1] & ~mcycle_squash_d1 ;


assign	ld0_pcx_rq_sel = (ld0_spec_pick_vld_g | ld0_nspec_pick_vld) ;
assign	ld1_pcx_rq_sel = (ld1_spec_pick_vld_g | ld1_nspec_pick_vld) ;
assign	ld2_pcx_rq_sel = (ld2_spec_pick_vld_g | ld2_nspec_pick_vld) ;
assign	ld3_pcx_rq_sel = (ld3_spec_pick_vld_g | ld3_nspec_pick_vld) ;

//bug3506: set mask in the level1 pick in w3-cycle if picked by pcx
//assign  ld_events_final[3] = ld3_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  ld_events_final[2] = ld2_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  ld_events_final[1] = ld1_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  ld_events_final[0] = ld0_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;



wire	st3_pcx_rq_pick,st2_pcx_rq_pick,st1_pcx_rq_pick,st0_pcx_rq_pick ;

// Choose one among 4 st.

wire   pcx_rq_for_stb_en;
//wire [3:0]  st_events_final ;
wire [3:0]  st_events_raw ;

//8/20/03: bug3506 fix is incomplete - vld may not be held until d2 cycle
assign st_events_raw[0]  =  stb0_rd_for_pcx | st0_pcx_rq_sel_d1 | st0_pcx_rq_sel_d2 ;
assign st_events_raw[1]  =  stb1_rd_for_pcx | st1_pcx_rq_sel_d1 | st1_pcx_rq_sel_d2 ;
assign st_events_raw[2]  =  stb2_rd_for_pcx | st2_pcx_rq_sel_d1 | st2_pcx_rq_sel_d2 ;
assign st_events_raw[3]  =  stb3_rd_for_pcx | st3_pcx_rq_sel_d1 | st3_pcx_rq_sel_d2 ;

//bug4814 - change rrobin_picker1 to rrobin_picker2
//lsu_rrobin_picker1 st4_rrobin  (
//    .events   	  ({st3_pcx_rq_vld,st2_pcx_rq_vld,
//		                st1_pcx_rq_vld,st0_pcx_rq_vld}),
//    .events_raw	  (st_events_raw[3:0]),
//    .pick_one_hot ({st3_pcx_rq_pick,st2_pcx_rq_pick,
//		                st1_pcx_rq_pick,st0_pcx_rq_pick}),
//    //.en           (pcx_rq_for_stb_en),                                                                
//    .events_final (st_events_final[3:0]),
//    .rclk         (rclk),
//    .grst_l       (grst_l),
//    .arst_l       (arst_l),
//    .si(),
//    .se(se),
//    .so()
//
//  );

lsu_rrobin_picker2 st4_rrobin  (
    .events   	  ({st3_pcx_rq_vld,st2_pcx_rq_vld,st1_pcx_rq_vld,st0_pcx_rq_vld}),
    .thread_force(st_thrd_force_vld[3:0]),
    .pick_one_hot ({st3_pcx_rq_pick,st2_pcx_rq_pick,st1_pcx_rq_pick,st0_pcx_rq_pick}),

    .events_picked(pcx_rq_for_stb[3:0]),
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so()
  );



assign lsu_st_pcx_rq_pick[3:0]  =  {st3_pcx_rq_pick,st2_pcx_rq_pick,st1_pcx_rq_pick,st0_pcx_rq_pick};
//timing fix: 9/2/03 - reduce fanout in stb_rwctl for lsu_st_pcx_rq_pick - gen separate signal for
//                     stb_cam_rptr_vld and stb_data_rptr_vld
assign lsu_st_pcx_rq_vld  =  st0_pcx_rq_vld | st1_pcx_rq_vld | st2_pcx_rq_vld | st3_pcx_rq_vld ;

//wire        st0_pcx_rq_sel_tmp, st1_pcx_rq_sel_tmp;
//wire        st2_pcx_rq_sel_tmp, st3_pcx_rq_sel_tmp;
   

   wire stb_cam_hit_w;

//bug3503
assign stb_cam_hit_w  =  stb_cam_hit_bf & lsu_inst_vld_w ;

dff_s #(1)  stb_cam_hit_stg_w2  (
  .din (stb_cam_hit_w),
  .q   (stb_cam_hit_w2),
  .clk (clk),
  .se  (1'b0), .si (), .so ()
  );


//RAW read STB at W3 (not W2), so stb_cam_hit_w2 isn't critical   
//assign pcx_rq_for_stb_en = ~(|lsu_st_ack_rq_stb[3:0]) &   ~stb_cam_hit_w2 & ~stb_cam_wptr_vld;
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
assign pcx_rq_for_stb_en = ~stb_cam_hit_w2 & ~stb_cam_wr_no_ivld_m & ~mcycle_squash_d1 ;

//timing fix : 5/6 - move kill_w2 after store pick
//assign	pcx_rq_for_stb[3] = st3_pcx_rq_pick & st3_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en;
//assign	pcx_rq_for_stb[2] = st2_pcx_rq_pick & st2_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en;
//assign	pcx_rq_for_stb[1] = st1_pcx_rq_pick & st1_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en;
//assign	pcx_rq_for_stb[0] = st0_pcx_rq_pick & st0_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en;

//timing fix: 05/20/03 - move mcycle_squash_d1 after pick instead of before pick
//bug4513 - kill pcx_rq_for_stb if atomic request is picked and 2 entries to the l2bank are not available

wire  [3:0]  pcx_rq_for_stb_tmp ;
wire   st0_qmon_2entry_avail,st1_qmon_2entry_avail,st2_qmon_2entry_avail,st3_qmon_2entry_avail ;

assign	pcx_rq_for_stb_tmp[3] =
        st3_pcx_rq_pick & st3_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[3] & ~mcycle_squash_d1 ;
        //st3_pcx_rq_pick & st3_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[3];

assign	pcx_rq_for_stb_tmp[2] =
        st2_pcx_rq_pick & st2_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[2] & ~mcycle_squash_d1 ;
        //st2_pcx_rq_pick & st2_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[2];

assign	pcx_rq_for_stb_tmp[1] =
        st1_pcx_rq_pick & st1_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[1] & ~mcycle_squash_d1 ;
        //st1_pcx_rq_pick & st1_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[1];

assign	pcx_rq_for_stb_tmp[0] = 
        st0_pcx_rq_pick & st0_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[0] & ~mcycle_squash_d1 ;
        //st0_pcx_rq_pick & st0_pcx_rq_vld & all_pcx_rq_pick[2] & pcx_rq_for_stb_en & ~lsu_st_pcx_rq_kill_w2[0];

//bug4513 - kill pcx_rq_for_stb if atomic request is picked and 2 entries to the l2bank are not available
assign	pcx_rq_for_stb[3] = ((st3_atomic_vld & st3_qmon_2entry_avail) | ~st3_atomic_vld) & pcx_rq_for_stb_tmp[3] ;
assign	pcx_rq_for_stb[2] = ((st2_atomic_vld & st2_qmon_2entry_avail) | ~st2_atomic_vld) & pcx_rq_for_stb_tmp[2] ;
assign	pcx_rq_for_stb[1] = ((st1_atomic_vld & st1_qmon_2entry_avail) | ~st1_atomic_vld) & pcx_rq_for_stb_tmp[1] ;
assign	pcx_rq_for_stb[0] = ((st0_atomic_vld & st0_qmon_2entry_avail) | ~st0_atomic_vld) & pcx_rq_for_stb_tmp[0] ;

//assign	st3_pcx_rq_sel_tmp = st3_pcx_rq_pick & st3_pcx_rq_vld & all_pcx_rq_pick[2] ;
//assign	st2_pcx_rq_sel_tmp = st2_pcx_rq_pick & st2_pcx_rq_vld & all_pcx_rq_pick[2] ;
//assign	st1_pcx_rq_sel_tmp = st1_pcx_rq_pick & st1_pcx_rq_vld & all_pcx_rq_pick[2] ;
//assign	st0_pcx_rq_sel_tmp = st0_pcx_rq_pick & st0_pcx_rq_vld & all_pcx_rq_pick[2] ;

//bug3506: set mask in the level1 pick in w3-cycle if picked by pcx
//assign  st_events_final[3] = st3_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  st_events_final[2] = st2_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  st_events_final[1] = st1_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;
//assign  st_events_final[0] = st0_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;



wire	strm_pcx_rq_pick,fpop_pcx_rq_pick,intrpt_pcx_rq_pick,fwdpkt_pcx_rq_pick;
//wire [3:0]  misc_events_final ;
wire [3:0]  misc_events_raw ;

//8/20/03: bug3506 fix is incomplete - vld may not be held until d2 cycle
assign  misc_events_raw[0]   =  lsu_fwdpkt_vld_d1 | fwdpkt_pcx_rq_sel_d1 | fwdpkt_pcx_rq_sel_d2 ;
//bug6807 - kill interrupt events raw when store buffer is not empty i.e. interrupt clear=0
assign  misc_events_raw[1]   =  (intrpt_pkt_vld_unmasked & intrpt_clr_d1) | intrpt_pcx_rq_sel_d1 | intrpt_pcx_rq_sel_d2 ;
assign  misc_events_raw[2]   =  fpop_pkt_vld_unmasked | fpop_pcx_rq_sel_d1 | fpop_pcx_rq_sel_d2 ;
assign  misc_events_raw[3]   =  strm_pkt_vld_unmasked | strm_pcx_rq_sel_d1 | strm_pcx_rq_sel_d2 ;


//bug4814 - change rrobin_picker1 to rrobin_picker2
//lsu_rrobin_picker1 misc4_rrobin  (
//    .events   	  ({strm_pcx_rq_vld,fpop_pcx_rq_vld,
//		    intrpt_pcx_rq_vld,fwdpkt_rq_vld}),
//    .events_raw   (misc_events_raw[3:0]),
//    .pick_one_hot ({strm_pcx_rq_pick,fpop_pcx_rq_pick,
//		    intrpt_pcx_rq_pick,fwdpkt_pcx_rq_pick}),
//    .events_final (misc_events_final[3:0]),
//    .rclk         (rclk),
//    .grst_l       (grst_l),
//    .arst_l       (arst_l),
//    .si(),
//    .se(se),
//    .so()
//  );

lsu_rrobin_picker2 misc4_rrobin  (
    .events   	  ({strm_pcx_rq_vld,fpop_pcx_rq_vld,intrpt_pcx_rq_vld,fwdpkt_rq_vld}),
    .thread_force(misc_thrd_force_vld[3:0]),
    .pick_one_hot ({strm_pcx_rq_pick,fpop_pcx_rq_pick,intrpt_pcx_rq_pick,fwdpkt_pcx_rq_pick}),

    .events_picked({strm_pcx_rq_sel,fpop_pcx_rq_sel,intrpt_pcx_rq_sel,fwdpkt_pcx_rq_sel}),
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so()
  );


//timing fix: 05/20/03 - move mcycle_squash_d1 after pick instead of before pick
//assign	strm_pcx_rq_sel = strm_pcx_rq_pick & strm_pcx_rq_vld & all_pcx_rq_pick[3] ;
//assign	fpop_pcx_rq_sel = fpop_pcx_rq_pick & fpop_pcx_rq_vld & all_pcx_rq_pick[3] ;
//assign	intrpt_pcx_rq_sel = intrpt_pcx_rq_pick & intrpt_pcx_rq_vld & all_pcx_rq_pick[3] ;
//assign	fwdpkt_pcx_rq_sel = fwdpkt_pcx_rq_pick & fwdpkt_rq_vld & all_pcx_rq_pick[3] ;
assign	strm_pcx_rq_sel = strm_pcx_rq_pick & strm_pcx_rq_vld & all_pcx_rq_pick[3] & ~mcycle_squash_d1 ;

//11/15/03 - change fpop atomic to be same as store atomic (bug4513)
//assign	fpop_pcx_rq_sel = fpop_pcx_rq_pick & fpop_pcx_rq_vld & all_pcx_rq_pick[3] & ~mcycle_squash_d1 ;
wire    fpop_qmon_2entry_avail ;
assign	fpop_pcx_rq_sel_tmp = fpop_pcx_rq_pick & fpop_pcx_rq_vld & all_pcx_rq_pick[3] & ~mcycle_squash_d1 ;
assign	fpop_pcx_rq_sel = fpop_pcx_rq_sel_tmp & fpop_qmon_2entry_avail ;

assign	intrpt_pcx_rq_sel = intrpt_pcx_rq_pick & intrpt_pcx_rq_vld & all_pcx_rq_pick[3] & ~mcycle_squash_d1 ;
assign	fwdpkt_pcx_rq_sel = fwdpkt_pcx_rq_pick & fwdpkt_rq_vld & all_pcx_rq_pick[3] & ~mcycle_squash_d1 ;


//bug3506: set mask in the level1 pick in w3-cycle if picked by pcx
//assign  misc_events_final[3] = lsu_spu_ldst_ack ;
//assign  misc_events_final[2] = lsu_tlu_pcxpkt_ack ;
//assign  misc_events_final[1] = lsu_fwdpkt_pcx_rq_sel ;
//assign  misc_events_final[0] = fpop_pcx_rq_sel_d2 & ~pcx_req_squash_d1 ;




// LEVEL TWO - PICK AMONG CATEGORIES
// In parallel with level one

wire	ld_pcx_rq_all, st_pcx_rq_all, misc_pcx_rq_all ;
assign	ld_pcx_rq_all = ld3_pcx_rq_vld | ld2_pcx_rq_vld | ld1_pcx_rq_vld | ld0_pcx_rq_vld ;	
assign	st_pcx_rq_all = st3_pcx_rq_vld | st2_pcx_rq_vld | st1_pcx_rq_vld | st0_pcx_rq_vld ; 
assign	misc_pcx_rq_all = strm_pcx_rq_vld | fpop_pcx_rq_vld | intrpt_pcx_rq_vld | fwdpkt_rq_vld ;

//bug3506- raw valid used in resetting pick status
//8/20/03: bug3506 fix is incomplete - vld may not be held until d2 cycle

//wire all4_rrobin_en;
//timing fix: 5/20/03 - pcx_rq_for_stb will be independent of ifu_lsu_pcxreq_d
//assign all4_rrobin_en = ~(all_pcx_rq_pick[2] & ~pcx_rq_for_stb_en) ;
//timing fix: 05/20/03 - move mycle_squash_d1 after pick instead of before pick
//assign all4_rrobin_en = ~((all_pcx_rq_pick[2] & ~pcx_rq_for_stb_en) | imiss_pcx_rq_vld );
//bug3348 - setting history moved from w-stage to w3-stage(1-cycle after spc_pcx_req_pq)
//          and hence there are no cases to disable logging of history
//assign all4_rrobin_en = ~((all_pcx_rq_pick[2] & ~pcx_rq_for_stb_en) | imiss_pcx_rq_vld | mcycle_squash_d1);
//wire   spc_pcx_req_vld_pq1 ;
//assign all4_rrobin_en =  spc_pcx_req_vld_pq1 ;
 
//wire  [3:1]  all_pcx_rq_pick_no_iqual;
wire  [3:0]  all_pcx_rq_pick_no_iqual;  
//wire  [3:0]  all_pcx_pick_status_d2;  // bug 3348
//wire  [3:0]  all_pick_status_rst_d2;    //bug 3506
wire  [3:0]  all_pick_status_set;

//bug3506: set pick status in the same cycle
assign  all_pick_status_set[3]  =  |{ strm_pcx_rq_sel, intrpt_pcx_rq_sel,fpop_pcx_rq_sel, fwdpkt_pcx_rq_sel} ;
assign  all_pick_status_set[2]  =  |pcx_rq_for_stb[3:0] ;
assign  all_pick_status_set[1]  =  |{ld0_pcx_rq_sel,ld1_pcx_rq_sel,ld2_pcx_rq_sel,ld3_pcx_rq_sel} ;
assign  all_pick_status_set[0]  =  1'b0 ;



lsu_rrobin_picker2 all4_rrobin  (
    .events   	  ({misc_pcx_rq_all,st_pcx_rq_all,ld_pcx_rq_all,1'b0}),
    .thread_force(all_thrd_force_vld[3:0]),
    .pick_one_hot (all_pcx_rq_pick_no_iqual[3:0]),

    .events_picked(all_pick_status_set[3:0]),
    //.en           (all4_rrobin_en),      // bug 3348
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so()
  );


// 5/22/03: cmp1_regr fail - qual all pick w/  ~mcycle_squash_d1; not doing this causes multi-hot select to
//          pcx_pkt mux
assign all_pcx_rq_pick[0]    =  imiss_pcx_rq_vld & ~mcycle_squash_d1;
assign all_pcx_rq_pick[3:1]  =  all_pcx_rq_pick_no_iqual[3:1] & ~{3{imiss_pcx_rq_vld | mcycle_squash_d1}};

wire   all_pcx_rq_dest_sel3 ;
assign all_pcx_rq_dest_sel3  =  ~|all_pcx_rq_pick[2:0];

//timing fix: 5/20/03 - pcx_rq_for_stb will be independent of ifu_lsu_pcxreq_d
//assign	imiss_pcx_rq_sel = imiss_pcx_rq_vld & all_pcx_rq_pick[0] ;
//timing fix: 05/20/03 - move mcycle_squash_d1 after pick instead of before pick
//assign	imiss_pcx_rq_sel = imiss_pcx_rq_vld;
assign	imiss_pcx_rq_sel = imiss_pcx_rq_vld & ~mcycle_squash_d1 ;

//=================================================================================================

// Select appr. load. Need a scheme which allows threads to
// make fwd progress.
/*assign  ld0_pcx_rq_sel = ld0_pcx_rq_vld ;
assign  ld1_pcx_rq_sel = ld1_pcx_rq_vld & ~ld0_pcx_rq_vld ;
assign  ld2_pcx_rq_sel = ld2_pcx_rq_vld & ~(ld0_pcx_rq_vld | ld1_pcx_rq_vld);
assign  ld3_pcx_rq_sel = ld3_pcx_rq_vld & ~(ld0_pcx_rq_vld | ld1_pcx_rq_vld | ld2_pcx_rq_vld)   ; */

dff_s #(4)  lrsel_stgd1 (
        .din    ({ld0_pcx_rq_sel, ld1_pcx_rq_sel, ld2_pcx_rq_sel, ld3_pcx_rq_sel}),
        .q      ({ld0_pcx_rq_sel_d1, ld1_pcx_rq_sel_d1, ld2_pcx_rq_sel_d1, ld3_pcx_rq_sel_d1}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//bug2705- kill pcx pick if spec vld kill is set
assign  lsu_ld0_pcx_rq_sel_d1  =  ld0_pcx_rq_sel_d1 & ~lsu_ld0_spec_vld_kill_w2 ;
assign  lsu_ld1_pcx_rq_sel_d1  =  ld1_pcx_rq_sel_d1 & ~lsu_ld1_spec_vld_kill_w2 ;
assign  lsu_ld2_pcx_rq_sel_d1  =  ld2_pcx_rq_sel_d1 & ~lsu_ld2_spec_vld_kill_w2 ;
assign  lsu_ld3_pcx_rq_sel_d1  =  ld3_pcx_rq_sel_d1 & ~lsu_ld3_spec_vld_kill_w2 ;


dff_s #(4)  lrsel_stgd2 (
        .din    ({lsu_ld0_pcx_rq_sel_d1, lsu_ld1_pcx_rq_sel_d1, lsu_ld2_pcx_rq_sel_d1, lsu_ld3_pcx_rq_sel_d1}),
        .q      ({ld0_pcx_rq_sel_d2, ld1_pcx_rq_sel_d2, ld2_pcx_rq_sel_d2, ld3_pcx_rq_sel_d2}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// Used to complete prefetch. Be careful ! ld could be squashed. Add pcx_req_squash.
assign	lsu_ld_pcx_rq_sel_d2[3] = ld3_pcx_rq_sel_d2 ;
assign	lsu_ld_pcx_rq_sel_d2[2] = ld2_pcx_rq_sel_d2 ;
assign	lsu_ld_pcx_rq_sel_d2[1] = ld1_pcx_rq_sel_d2 ;
assign	lsu_ld_pcx_rq_sel_d2[0] = ld0_pcx_rq_sel_d2 ;

//bug2705- kill pcx pick if spec vld kill is set
wire	ld_pcxpkt_vld ;
assign  ld_pcxpkt_vld = 
  lsu_ld0_pcx_rq_sel_d1 | lsu_ld1_pcx_rq_sel_d1 | lsu_ld2_pcx_rq_sel_d1 | lsu_ld3_pcx_rq_sel_d1 ;
  //ld0_pcx_rq_sel_d1 | ld1_pcx_rq_sel_d1 | ld2_pcx_rq_sel_d1 | ld3_pcx_rq_sel_d1 ;

dff_s #(1)  icindx_stgd1 (
        .din    (ld_pcxpkt_vld), 
	.q  	(lsu_ifu_ld_pcxpkt_vld),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

wire  [3:0]           ld_pcx_rq_sel ;	

assign  ld_pcx_rq_sel[0] =  ld0_pcx_rq_sel_d1 | st0_atom_rq_d2 ;
assign  ld_pcx_rq_sel[1] =  ld1_pcx_rq_sel_d1 | st1_atom_rq_d2 ;
assign  ld_pcx_rq_sel[2] =  ld2_pcx_rq_sel_d1 | st2_atom_rq_d2 ;
assign  ld_pcx_rq_sel[3] =  ld3_pcx_rq_sel_d1 | st3_atom_rq_d2 ;

//11/7/03: add rst_tri_en
assign  lsu_ld_pcx_rq_mxsel[2:0]  =    ld_pcx_rq_sel[2:0] & {3{~rst_tri_en}} ;
assign  lsu_ld_pcx_rq_mxsel[3]    =  (~|ld_pcx_rq_sel[2:0]) | rst_tri_en ;

assign ld_pcx_thrd[0] = ld_pcx_rq_sel[1] | ld_pcx_rq_sel[3] ;
assign ld_pcx_thrd[1] = ld_pcx_rq_sel[2] | ld_pcx_rq_sel[3] ;
   
// Assume a simple priority based scheme for now.
// This should not be prioritized at this point. 
//assign st_pcx_rq_mhot_sel[0] = st0_pcx_rq_sel_tmp ;
//assign st_pcx_rq_mhot_sel[1] = st1_pcx_rq_sel_tmp ;
//assign st_pcx_rq_mhot_sel[2] = st2_pcx_rq_sel_tmp ;
//assign st_pcx_rq_mhot_sel[3] = st3_pcx_rq_sel_tmp ;
   
/*assign st_pcx_rq_mhot_sel[0] = 
  ~ld_pcx_rq_vld  & st0_pcx_rq_vld ;
assign st_pcx_rq_mhot_sel[1] = 
  ~ld_pcx_rq_vld  & st1_pcx_rq_vld ;
assign st_pcx_rq_mhot_sel[2] = 
  ~ld_pcx_rq_vld  & st2_pcx_rq_vld ;
assign st_pcx_rq_mhot_sel[3] = 
  ~ld_pcx_rq_vld  & st3_pcx_rq_vld ;*/

   
assign  st0_pcx_rq_sel = pcx_rq_for_stb[0] ;
assign  st1_pcx_rq_sel = pcx_rq_for_stb[1] ;
assign  st2_pcx_rq_sel = pcx_rq_for_stb[2] ;
assign  st3_pcx_rq_sel = pcx_rq_for_stb[3] ;

//assign  st_pcx_rq_vld =  (|pcx_rq_for_stb[3:0]);

// Temporary.
//assign  st0_pcx_rq_sel = stb_rd_for_pcx_sel[0] ;
//assign  st1_pcx_rq_sel = stb_rd_for_pcx_sel[1] ;
//assign  st2_pcx_rq_sel = stb_rd_for_pcx_sel[2] ;
//assign  st3_pcx_rq_sel = stb_rd_for_pcx_sel[3] ;

// This will be on a critical path. Massage !!!
// Allows for speculative requests.
//assign  st_pcx_rq_vld = 
//    (st0_pcx_rq_sel & stb_rd_for_pcx_sel[0]) | 
//    (st1_pcx_rq_sel & stb_rd_for_pcx_sel[1]) | 
//    (st2_pcx_rq_sel & stb_rd_for_pcx_sel[2]) | 
//    (st3_pcx_rq_sel & stb_rd_for_pcx_sel[3])  ;


   
/*assign imiss_pcx_rq_sel = 
  imiss_pcx_rq_vld & ~(ld_pcx_rq_vld | st_pcx_rq_vld) ;
assign strm_pcx_rq_sel = 
  strm_pcx_rq_vld & ~(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_sel) ;
assign fpop_pcx_rq_sel = 
  fpop_pcx_rq_vld & ~(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_vld | strm_pcx_rq_vld) ;
assign intrpt_pcx_rq_sel = 
  intrpt_pcx_rq_vld & ~(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_vld | strm_pcx_rq_vld | fpop_pcx_rq_sel) ;
assign fwdpkt_pcx_rq_sel = 
  fwdpkt_rq_vld & ~(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_vld | strm_pcx_rq_vld | intrpt_pcx_rq_vld 
                        | fpop_pcx_rq_sel) ; */


//assign imiss_strm_pcx_rq_sel = imiss_pcx_rq_sel | strm_pcx_rq_sel ;

// request was made with the queues full but not grant. 
assign  pcx_req_squash = 
  (|(spc_pcx_req_pq_buf2[4:0] & ~pre_qwr[4:0] & ~pcx_spc_grant_px[4:0])) ;
//(|(spc_pcx_req_pq[4:0] & ~queue_write[4:0] & ~pcx_spc_grant_px[4:0])) ;
//  (|lsu_error_rst[3:0]) | // dtag parity error requires two ld pkts
//  (st_atom_rq_d1) ; // cas,stq - 2 pkt requests

//bug:2877 - dtag parity error 2nd packet request;
//wire	error_rst ;

//assign	error_rst =
//	(ld0_pcx_rq_sel_d1 & lsu_dtag_perror_w2[0]) |
//	(ld1_pcx_rq_sel_d1 & lsu_dtag_perror_w2[1]) |
//	(ld2_pcx_rq_sel_d1 & lsu_dtag_perror_w2[2]) |
//	(ld3_pcx_rq_sel_d1 & lsu_dtag_perror_w2[3]) ;

//wire	error_rst_d1 ;
//dff #(1)  erst_stgd1 (
//        .din    (error_rst), 
//	.q  	(error_rst_d1),
//        .clk  	(clk),
//        .se     (1'b0),       .si (),          .so ()
//        ); 

wire   [3:0]  dtag_perr_pkt2_vld ;
assign  dtag_perr_pkt2_vld[0] =  lsu_ld0_pcx_rq_sel_d1 & lsu_dtag_perror_w2[0];
assign  dtag_perr_pkt2_vld[1] =  lsu_ld1_pcx_rq_sel_d1 & lsu_dtag_perror_w2[1];
assign  dtag_perr_pkt2_vld[2] =  lsu_ld2_pcx_rq_sel_d1 & lsu_dtag_perror_w2[2];
assign  dtag_perr_pkt2_vld[3] =  lsu_ld3_pcx_rq_sel_d1 & lsu_dtag_perror_w2[3];

//bug:2877 - dtag parity error 2nd packet request; flop to sync w/ ld?_pcx_rq_sel_d2
dff_s #(4) ff_dtag_perr_pkt2_vld_d1 (
        .din    (dtag_perr_pkt2_vld[3:0]), 
        .q      (dtag_perr_pkt2_vld_d1[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



//bug:2877 - dtag parity error 2nd packet request; error_rst can be removed from mcycle_mask_d1 since
//           it does not behave like an atomic i.e. it is sent as 2 separate packets.
assign	mcycle_squash_d1 =
 // error_rst | // dtag parity error requires two ld pkts
  //(|lsu_error_rst[3:0]) | // dtag parity error requires two ld pkts
  spc_pcx_atom_pq_buf2 ;   // cas/fpop

dff_s #(1)  sqsh_stgd1 (
        .din    (pcx_req_squash), 
	.q  	(pcx_req_squash_d1),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

dff_s #(1)  sqsh_stgd2 (
        .din    (pcx_req_squash_d1), 
	.q  	(pcx_req_squash_d2),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 
//timing fix: 9/19/03 - split the lsu_pcx_req_squash to 4 signals to stb_ctl[0-3] to reduce loading
assign  lsu_pcx_req_squash = pcx_req_squash & ~st_atom_rq_d1 ;
assign  lsu_pcx_req_squash0 = lsu_pcx_req_squash ;
assign  lsu_pcx_req_squash1 = lsu_pcx_req_squash ;
assign  lsu_pcx_req_squash2 = lsu_pcx_req_squash ;
assign  lsu_pcx_req_squash3 = lsu_pcx_req_squash ;

assign  lsu_pcx_req_squash_d1 = pcx_req_squash_d1 ;

dff_s #(5)  rsel_stgd1 (
        //.din    ({imiss_strm_pcx_rq_sel,
        .din    ({
    imiss_pcx_rq_sel, strm_pcx_rq_sel, intrpt_pcx_rq_sel, fpop_pcx_rq_sel,
    fwdpkt_pcx_rq_sel}), 
        //.q      ({imiss_strm_pcx_rq_sel_d1,
        .q      ({
    imiss_pcx_rq_sel_d1, strm_pcx_rq_sel_d1, intrpt_pcx_rq_sel_d1,fpop_pcx_rq_sel_d1,
    fwdpkt_pcx_rq_sel_d1}), 
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

assign  lsu_imiss_pcx_rq_sel_d1  =  imiss_pcx_rq_sel_d1;

dff_s  imrqs_stgd2 (
        .din    (imiss_pcx_rq_sel_d1), 
	.q  	(imiss_pcx_rq_sel_d2),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

dff_s  fwdrqs_stgd2 (
        .din    (fwdpkt_pcx_rq_sel_d1), 
	.q  	(fwdpkt_pcx_rq_sel_d2),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

dff_s  fwdrqs_stgd3 (
        .din    (fwdpkt_pcx_rq_sel_d2), 
	.q  	(fwdpkt_pcx_rq_sel_d3),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

dff_s  fpop_stgd2 (
        .din    (fpop_pcx_rq_sel_d1), .q  (fpop_pcx_rq_sel_d2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//bug4665: add sehold to pcx_pkt_src_sel[1]
//wire	ld_pcx_rq_sel_d1,st_pcx_rq_sel_d1,misc_pcx_rq_sel_d1;
wire	ld_pcx_rq_sel_d1,st_pcx_rq_sel_d1;
wire    all_pcx_rq_pick_b2 ;
assign  all_pcx_rq_pick_b2  =  sehold ? st_pcx_rq_sel_d1 : all_pcx_rq_pick[2] ;

dff_s #(2)  pick_stgd1 (
        .din    ({all_pcx_rq_pick_b2, all_pcx_rq_pick[1]}), 
        .q      ({st_pcx_rq_sel_d1,ld_pcx_rq_sel_d1}),
        //.din    ({all_pcx_rq_pick[3], all_pcx_rq_pick_b2, all_pcx_rq_pick[1]}), 
        //.q      ({misc_pcx_rq_sel_d1,st_pcx_rq_sel_d1,ld_pcx_rq_sel_d1}),
        //.din    (all_pcx_rq_pick[2:1]), .q      ({st_pcx_rq_sel_d1,ld_pcx_rq_sel_d1}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// add other sources in such as interrupt and fpop.
//bug:2877 - dtag parity error 2nd packet request; remove error_rst_d1 since dtag parity error does not
//           behave as an atomic
//assign pcx_pkt_src_sel[0] = ld_pcx_rq_sel_d1 | st_cas_rq_d2 | error_rst_d1 ;

//11/7/03 - add rst_tri_en
wire  [3:0]  pcx_pkt_src_sel_tmp ;
assign pcx_pkt_src_sel_tmp[0] = ld_pcx_rq_sel_d1 | st_cas_rq_d2 ;
assign pcx_pkt_src_sel_tmp[1] = st_pcx_rq_sel_d1 ;
assign pcx_pkt_src_sel_tmp[2] = ~|{pcx_pkt_src_sel[3],pcx_pkt_src_sel[1:0]};
                                //imiss_strm_pcx_rq_sel_d1  ;
assign pcx_pkt_src_sel_tmp[3] = fpop_pcx_rq_sel_d1 | fpop_pcx_rq_sel_d2 |
			        fwdpkt_pcx_rq_sel_d1 | intrpt_pcx_rq_sel_d1 ;

//bug4888 -  change rst_tri_en to select b[1] instead of b[3]

assign pcx_pkt_src_sel[3:2]  =  pcx_pkt_src_sel_tmp[3:2] & {2{~rst_tri_en}} ;
assign pcx_pkt_src_sel[1]    =  pcx_pkt_src_sel_tmp[1] | rst_tri_en ;
assign pcx_pkt_src_sel[0]    =  pcx_pkt_src_sel_tmp[0] & ~rst_tri_en ;

//assign  dest_pkt_sel[0] = ld_pcx_rq_vld ;
//assign  dest_pkt_sel[1] = st_pcx_rq_vld ;
//assign  dest_pkt_sel[2] = ~(ld_pcx_rq_vld | st_pcx_rq_vld);

//=================================================================================================
//		SELECT DESTINATION
//=================================================================================================

// Select dest for load.
mux4ds  #(5) ldsel_dest (
  .in0  (ld0_l2bnk_dest[4:0]),
  .in1  (ld1_l2bnk_dest[4:0]),
  .in2  (ld2_l2bnk_dest[4:0]),
  .in3  (ld3_l2bnk_dest[4:0]),
  .sel0 (ld0_pcx_rq_pick),
  .sel1 (ld1_pcx_rq_pick),
  .sel2 (ld2_pcx_rq_pick),
  .sel3 (ld3_pcx_rq_pick),
  .dout (ld_pkt_dest[4:0])
);

// Select dest for store
mux4ds  #(5) stsel_dest (
  .in0  (st0_l2bnk_dest[4:0]),
  .in1  (st1_l2bnk_dest[4:0]),
  .in2  (st2_l2bnk_dest[4:0]),
  .in3  (st3_l2bnk_dest[4:0]),
  .sel0 (st0_pcx_rq_pick),
  .sel1 (st1_pcx_rq_pick),
  .sel2 (st2_pcx_rq_pick),
  .sel3 (st3_pcx_rq_pick),
  .dout (st_pkt_dest[4:0])
);

wire	[4:0]	misc_pkt_dest ;
mux4ds  #(5) miscsel_dest (
  .in0  (strm_l2bnk_dest[4:0]),
  .in1  (fpop_l2bnk_dest[4:0]),
  .in2  (intrpt_l2bnk_dest[4:0]),
  .in3  (fwdpkt_dest_d1[4:0]),
  .sel0 (strm_pcx_rq_pick),
  .sel1 (fpop_pcx_rq_pick),
  .sel2 (intrpt_pcx_rq_pick),
  .sel3 (fwdpkt_pcx_rq_pick),
  .dout (misc_pkt_dest[4:0])
);

// This is temporary until the req/ack path is restructured
/*assign  imiss_strm_pkt_dest[4:0] =
  imiss_pcx_rq_sel ? imiss_l2bnk_dest[4:0] :  
    strm_pcx_rq_sel ? strm_l2bnk_dest[4:0] :
      fpop_pcx_rq_sel ? fpop_l2bnk_dest[4:0] :
        intrpt_pcx_rq_sel ? intrpt_l2bnk_dest[4:0] :
                lsu_fwdpkt_dest[4:0] ;  */

/*
// This needs to be replaced with structural mux once rq/ack resolved.
mux4ds  #(5) istrmsel_dest (
  .in0  (imiss_l2bnk_dest[4:0]),
  .in1  (strm_l2bnk_dest[4:0]),
  .in2  (fpop_l2bnk_dest[4:0]),
  .in3  (intrpt_l2bnk_dest[4:0]),
  .sel0 (imiss_pcx_rq_sel),  
  .sel1   (strm_pcx_rq_sel),
  .sel2   (fpop_pcx_rq_sel),
  .sel3   (intrpt_pcx_rq_sel),
  .dout (imiss_strm_pkt_dest[4:0])
);
*/

/* Tri
mux4ds  #(5) sel_final_dest (
  .in0  (imiss_l2bnk_dest[4:0]),
  .in1  (ld_pkt_dest[4:0]),
  .in2  (st_pkt_dest[4:0]),
  .in3  (misc_pkt_dest[4:0]),
  .sel0 (all_pcx_rq_pick[0]),  
  .sel1 (all_pcx_rq_pick[1]),
  .sel2 (all_pcx_rq_pick[2]), 
  .sel3 (all_pcx_rq_dest_sel3), 
  //.sel3 (all_pcx_rq_pick[3]), 
  .dout (current_pkt_dest[4:0])
);
*/
// Tri: the only destination is the PCX decoder in the transceiver (0)
//assign current_pkt_dest[4:0] = 5'b00001; adif: setting the available banks here and in the atomic availability logic  
assign current_pkt_dest[4:0] = {1'b0,AVAILABLE_L2_BANKS};
/*mux3ds  #(5) sel_dest (
  .in0  (ld_pkt_dest[4:0]),
  .in1  (st_pkt_dest[4:0]),
  .in2    (imiss_strm_pkt_dest[4:0]),
  .sel0 (dest_pkt_sel[0]),  
  .sel1   (dest_pkt_sel[1]),
  .sel2   (dest_pkt_sel[2]), 
  .dout (current_pkt_dest[4:0])
);*/

wire	pcx_rq_sel ;
assign	pcx_rq_sel = 
  ld0_pcx_rq_sel | ld1_pcx_rq_sel | ld2_pcx_rq_sel | ld3_pcx_rq_sel |
  st0_pcx_rq_sel | st1_pcx_rq_sel | st2_pcx_rq_sel | st3_pcx_rq_sel |
  imiss_pcx_rq_sel | strm_pcx_rq_sel | fpop_pcx_rq_sel | intrpt_pcx_rq_sel |
  fwdpkt_pcx_rq_sel ;

assign spc_pcx_req_g[4:0] = 
  (current_pkt_dest[4:0] & {5{pcx_rq_sel}}) ;
  //(current_pkt_dest[4:0] & 
  //{5{(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_vld | strm_pcx_rq_vld | intrpt_pcx_rq_vld | fpop_atom_req | fwdpkt_rq_vld)}}) ;

//timing fix: 9/19/03 - instantiate buffer for spc_pcx_req_pq
wire  [4:0]  spc_pcx_req_pq_tmp ;
dff_s #(5)  rq_stgpq (
        .din    (spc_pcx_req_g[4:0]), .q  (spc_pcx_req_pq_tmp[4:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 


bw_u1_buf_30x UZfix_spc_pcx_req_pq0_buf1 ( .a(spc_pcx_req_pq_tmp[0]), .z(spc_pcx_req_pq[0]) );
bw_u1_buf_30x UZfix_spc_pcx_req_pq1_buf1 ( .a(spc_pcx_req_pq_tmp[1]), .z(spc_pcx_req_pq[1]) );
bw_u1_buf_30x UZfix_spc_pcx_req_pq2_buf1 ( .a(spc_pcx_req_pq_tmp[2]), .z(spc_pcx_req_pq[2]) );
bw_u1_buf_30x UZfix_spc_pcx_req_pq3_buf1 ( .a(spc_pcx_req_pq_tmp[3]), .z(spc_pcx_req_pq[3]) );
bw_u1_buf_30x UZfix_spc_pcx_req_pq4_buf1 ( .a(spc_pcx_req_pq_tmp[4]), .z(spc_pcx_req_pq[4]) );

bw_u1_buf_30x UZsize_spc_pcx_req_pq0_buf2 ( .a(spc_pcx_req_pq_tmp[0]), .z(spc_pcx_req_pq_buf2[0]) );
bw_u1_buf_30x UZsize_spc_pcx_req_pq1_buf2 ( .a(spc_pcx_req_pq_tmp[1]), .z(spc_pcx_req_pq_buf2[1]) );
bw_u1_buf_30x UZsize_spc_pcx_req_pq2_buf2 ( .a(spc_pcx_req_pq_tmp[2]), .z(spc_pcx_req_pq_buf2[2]) );
bw_u1_buf_30x UZsize_spc_pcx_req_pq3_buf2 ( .a(spc_pcx_req_pq_tmp[3]), .z(spc_pcx_req_pq_buf2[3]) );
bw_u1_buf_30x UZsize_spc_pcx_req_pq4_buf2 ( .a(spc_pcx_req_pq_tmp[4]), .z(spc_pcx_req_pq_buf2[4]) );

//bug3348 - not needed
//wire   spc_pcx_req_vld_pq ;
//assign spc_pcx_req_vld_pq =  |spc_pcx_req_pq[4:0];
//
//dff #(1)  rq_stgpq1 (
//        .din    (spc_pcx_req_vld_pq), .q  (spc_pcx_req_vld_pq1),
//        .clk  (clk),
//        .se     (1'b0),       .si (),          .so ()
//        ); 

assign spc_pcx_req_update_g[4:0] = 
        (st_atom_rq_d1 | fpop_atom_rq_pq) ?
        spc_pcx_req_pq_buf2[4:0] :           // Recirculate same request if back to back case - stda, cas etc
        (current_pkt_dest[4:0] & 
        {5{pcx_rq_sel}}) ;
        //{5{(ld_pcx_rq_vld | st_pcx_rq_vld | imiss_pcx_rq_vld | strm_pcx_rq_vld | intrpt_pcx_rq_vld | fpop_pcx_rq_vld | fwdpkt_rq_vld)}}) ;
                                        // Standard request

dff_s #(5)  urq_stgpq (
        .din    (spc_pcx_req_update_g[4:0]), .q  (spc_pcx_req_update_w2[4:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//=================================================================================================
//	2-CYCLE OP HANDLING
//=================================================================================================

// cas,fpop,dtag-error pkt. dtag-error pkt does not have to be b2b.
// prevent starvation, ensure requests are b2b.
// fpop can only request to fpu.(bit4) cas can only request to L2 (b3:0) 
// ** error rst needs to be handled correctly.

// ** This needs to be massaged for timing.
// timing fix: 5/7/03 - delay the mask 1 cycle for stores.
wire	[3:0]	mcycle_mask_qwr ;
wire	[4:0]	mcycle_mask_qwr_d1 ;
//assign	mcycle_mask_qwr[3:0] =
//	({4{(stb0_rd_for_pcx & st0_atomic_vld)}} & st0_l2bnk_dest[3:0]) |
//	({4{(stb1_rd_for_pcx & st1_atomic_vld)}} & st1_l2bnk_dest[3:0]) |
//	({4{(stb2_rd_for_pcx & st2_atomic_vld)}} & st2_l2bnk_dest[3:0]) |
//	({4{(stb3_rd_for_pcx & st3_atomic_vld)}} & st3_l2bnk_dest[3:0]) ;


//bug4513- kill the atomic store pcx req in this cycle if only 1 entry is available -
//         atomic packets have to be sent b2bto pcx.
//
// ex. thread0 to l2 bank0 atomic store - w/ only 1 bank0 entry available
//---------------------------------------------------------------------------------
//				1	2	3	4	5	6	7
//---------------------------------------------------------------------------------
// st0_atomic_vld-------------->1
// pcx_rq_for_stb_tmp[0]------->1
// pcx_rq_for_stb[0]----------->0                               1
// st0_qmon_2entry_avail------->0                               1
//---------------------------------------------------------------------------------
// st0_atomic_pend------------->1                               0
// st0_atomic_pend_d1------------------>1                               0
// mcycle_mask_qwr_d1[0]--------------->1                               0
//---------------------------------------------------------------------------------

/*
assign  st0_qmon_2entry_avail =  |(st0_l2bnk_dest[3:0] & sel_qentry0[3:0]) ;
assign  st1_qmon_2entry_avail =  |(st1_l2bnk_dest[3:0] & sel_qentry0[3:0]) ;
assign  st2_qmon_2entry_avail =  |(st2_l2bnk_dest[3:0] & sel_qentry0[3:0]) ;
assign  st3_qmon_2entry_avail =  |(st3_l2bnk_dest[3:0] & sel_qentry0[3:0]) ;
*/
// adif: adding back pressure to atomic availability accoording to available banks
// 9/25/14 trin: simplify logics, also fixing fpop 2entry logics
assign  st0_qmon_2entry_avail =  sel_qentry0[0];
assign  st1_qmon_2entry_avail =  sel_qentry0[0];
assign  st2_qmon_2entry_avail =  sel_qentry0[0];
assign  st3_qmon_2entry_avail =  sel_qentry0[0];

 // assign  fpop_qmon_2entry_avail =  fpop_l2bnk_dest[4] & sel_qentry0[4] ;
 // 9/25/14 trin: should fix the problem (bug #96)
 assign  fpop_qmon_2entry_avail =  sel_qentry0[0];


//bug4513 - when atomic is picked, if 2 entries are not free, kill all requests until 2entries are free
wire    st0_atomic_pend, st1_atomic_pend, st2_atomic_pend, st3_atomic_pend ;

assign  st0_atomic_pend  =  (pcx_rq_for_stb_tmp[0] & st0_atomic_vld & ~st0_qmon_2entry_avail) |  //set
                            (st0_atomic_pend_d1 & ~st0_qmon_2entry_avail) ;		     //recycle/reset

assign  st1_atomic_pend  =  (pcx_rq_for_stb_tmp[1] & st1_atomic_vld & ~st1_qmon_2entry_avail) |  //set
                            (st1_atomic_pend_d1 & ~st1_qmon_2entry_avail) ;		     //recycle/reset

assign  st2_atomic_pend  =  (pcx_rq_for_stb_tmp[2] & st2_atomic_vld & ~st2_qmon_2entry_avail) |  //set
                            (st2_atomic_pend_d1 & ~st2_qmon_2entry_avail) ;		     //recycle/reset

assign  st3_atomic_pend  =  (pcx_rq_for_stb_tmp[3] & st3_atomic_vld & ~st3_qmon_2entry_avail) |  //set
                            (st3_atomic_pend_d1 & ~st3_qmon_2entry_avail) ;		     //recycle/reset

dff_s #(4)  ff_st0to3_atomic_pend_d1 (
        .din ({st3_atomic_pend,st2_atomic_pend,st1_atomic_pend,st0_atomic_pend}),
        .q   ({st3_atomic_pend_d1,st2_atomic_pend_d1,st1_atomic_pend_d1,st0_atomic_pend_d1}),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//bug4513 - kill all requests after atomic if 2 entries to the bank are not available
assign	mcycle_mask_qwr[3:0] =
	({4{st0_atomic_pend}} & st0_l2bnk_dest[3:0]) |
	({4{st1_atomic_pend}} & st1_l2bnk_dest[3:0]) |
	({4{st2_atomic_pend}} & st2_l2bnk_dest[3:0]) |
	({4{st3_atomic_pend}} & st3_l2bnk_dest[3:0]) ;

//11/15/03 - change fpop atomic to be same as store atomic (bug4513)
//assign	mcycle_mask_qwr[4] = fpop_pkt_vld | fpop_pcx_rq_sel_d1 ;

wire    fpop_atomic_pend, fpop_atomic_pend_d1 ;


assign fpop_atomic_pend = (fpop_pcx_rq_sel_tmp & ~fpop_qmon_2entry_avail) |
                          (fpop_atomic_pend_d1 & ~fpop_qmon_2entry_avail) ;

assign  fpop_q_wr[4:0] = fpop_atomic_pend_d1 ? pre_qwr[4:0] : queue_write[4:0] ;

dff_s #(1)  ff_fpop_atomic_pend_d1 (
        .din (fpop_atomic_pend),
        .q   (fpop_atomic_pend_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 


dff_s #(5)  ff_mcycle_mask_qwr_b4to0 (
        .din ({fpop_atomic_pend,mcycle_mask_qwr[3:0]}), 
        .q   (mcycle_mask_qwr_d1[4:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 


// 			PCX REQUEST GENERATION (END)
//*************************************************************************************************

//=================================================================================================
//
// CPX Packet Processing
//
//=================================================================================================


// D-SIDE PROCESSING

/*input  [3:0]   lsu_cpx_pkt_rqtype ;
input          lsu_cpx_pkt_vld ;*/

// non-cacheables are processed at the head of the dfq.
// cpx_ld_type may not have to factor in strm load.

//=================================================================================================
//
// PCX Queue Control
//
//=================================================================================================

//timing fix: 5/7/03 - delay mask 1 cycle for stores
//11/15/03 - change fpop atomic to be same as store atomic (bug4513)
//assign	queue_write[4:0] = pre_qwr[4:0] & ~{mcycle_mask_qwr[4],mcycle_mask_qwr_d1[3:0]} ;
assign	queue_write[4:0] = pre_qwr[4:0] & ~mcycle_mask_qwr_d1[4:0] ;

//bug4513 - mcycle_mask_qwr will kill all requests other than stores. stores can be killed
//          by fpop atomics
//11/14/03- fox for bug4513 was incorrect ; st_queue_write[3:0] not needed 'cos st[0-3]_q_wr 
//          has been changed to use st0_atomic_pend instead of st0_atomic_vld
//assign	st_queue_write[4] = pre_qwr[4] & ~mcycle_mask_qwr[4] ;
//assign	st_queue_write[3:0] = pre_qwr[3:0] ;

//assign	queue_write[4:0] = pre_qwr[4:0] & ~mcycle_mask_qwr[4:0] ; // timing fix
// assign	queue_write[4:0] = pre_qwr[4:0] ;

// PCX Queue Control
// - qctl tracks 2-input queue state for each of 6 destinations
// through grant signals available from pcx.

// L2 Bank0 Queue Monitor
lsu_pcx_qmon  l2bank0_qmon (
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so(),
  .send_by_pcx  (pcx_spc_grant_px[0]),
  .send_to_pcx  (spc_pcx_req_update_w2[0]),
  //.qwrite   (queue_write[0]),
  .qwrite   (pre_qwr[0]),
  .sel_qentry0  (sel_qentry0[0])
);

// L2 Bank1 Queue Monitor
lsu_pcx_qmon  l2bank1_qmon (
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so(),
  .send_by_pcx  (pcx_spc_grant_px[1]),
  .send_to_pcx  (spc_pcx_req_update_w2[1]),
  //.qwrite   (queue_write[1]),
  .qwrite   (pre_qwr[1]),
  .sel_qentry0  (sel_qentry0[1])
);

// L2 Bank2 Queue Monitor
lsu_pcx_qmon  l2bank2_qmon (
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so(),
  .send_by_pcx  (pcx_spc_grant_px[2]),
  .send_to_pcx  (spc_pcx_req_update_w2[2]),
  //.qwrite   (queue_write[2]),
  .qwrite   (pre_qwr[2]),
  .sel_qentry0  (sel_qentry0[2])
);

// L2 Bank3 Queue Monitor
lsu_pcx_qmon  l2bank3_qmon (
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so(),
  .send_by_pcx  (pcx_spc_grant_px[3]),
  .send_to_pcx  (spc_pcx_req_update_w2[3]),
  //.qwrite   (queue_write[3]),
  .qwrite   (pre_qwr[3]),
  .sel_qentry0  (sel_qentry0[3])
);

// FP/IO Bridge Queue Monitor
lsu_pcx_qmon  fpiobridge_qmon (
    .rclk         (rclk),
    .grst_l       (grst_l),
    .arst_l       (arst_l),
    .si(),
    .se(se),
    .so(),
  .send_by_pcx  (pcx_spc_grant_px[4]),
  .send_to_pcx  (spc_pcx_req_update_w2[4]),
  //.qwrite   (queue_write[4]),
  .qwrite   (pre_qwr[4]),
  .sel_qentry0  (sel_qentry0[4])
);




// 5/13/03: timing fix for lsu_dtag_perror_w2 thru st_pick
wire  [3:0]  error_en;
wire  [3:0]  error_rst_thrd;

//assign  error_en[0] = lmq_enable[0] | (lsu_cpx_pkt_atm_st_cmplt & dcfill_active_e & dfq_byp_sel[0]);
assign  error_en[0] = lsu_ld_inst_vld_g[0];
assign  error_en[1] = lsu_ld_inst_vld_g[1];
assign  error_en[2] = lsu_ld_inst_vld_g[2];
assign  error_en[3] = lsu_ld_inst_vld_g[3];

//assign  error_rst_thrd[0] = reset | (lsu_ld0_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst_thrd[1] = reset | (lsu_ld1_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst_thrd[2] = reset | (lsu_ld2_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst_thrd[3] = reset | (lsu_ld3_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;

// reset moved to d2 'cos if 1st pkt is speculative and grant=0, error should not be reset.
//bug4512 - stb_full_raw has to be qual w/ ld[0-3] inst_vld_w2
//          also, need to qualify stb_full_raw w/ fp loads i.e. dont reset error if full raw is for fp double loads
assign  error_rst_thrd[0] = reset | (ld0_pcx_rq_sel_d2 & ~pcx_req_squash_d1) 
				| (ld0_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 & thread0_w2) ; // Bug4512
				//| (ld_stb_full_raw_w2 & thread0_w2) ; // Bug 4361

assign  error_rst_thrd[1] = reset | (ld1_pcx_rq_sel_d2 & ~pcx_req_squash_d1)
				| (ld1_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 & thread1_w2) ;

assign  error_rst_thrd[2] = reset | (ld2_pcx_rq_sel_d2 & ~pcx_req_squash_d1)
				| (ld2_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 & thread2_w2) ;

assign  error_rst_thrd[3] = reset | (ld3_pcx_rq_sel_d2 & ~pcx_req_squash_d1)
				| (ld3_inst_vld_w2 & ld_stb_full_raw_w2 & ~dbl_force_l2access_w2 & thread3_w2) ;

//assign  lsu_error_rst[3:0]  =  error_rst[3:0];

wire	dtag_perror3,dtag_perror2,dtag_perror1,dtag_perror0;

// Thread 0
dffre_s  #(1) error_t0 (
        .din    (lsu_dcache_tag_perror_g),
        .q      (dtag_perror0),
        .rst  (error_rst_thrd[0]), .en     (error_en[0]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 1
dffre_s  #(1) error_t1 (
        .din    (lsu_dcache_tag_perror_g),
        .q      (dtag_perror1),
        .rst  (error_rst_thrd[1]), .en     (error_en[1]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 2
dffre_s  #(1) error_t2 (
        .din    (lsu_dcache_tag_perror_g),
        .q      (dtag_perror2),
        .rst  (error_rst_thrd[2]), .en     (error_en[2]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 3
dffre_s  #(1) error_t3 (
        .din    (lsu_dcache_tag_perror_g),
        .q      (dtag_perror3),
        .rst  (error_rst_thrd[3]), .en     (error_en[3]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

assign	lsu_dtag_perror_w2[3] = dtag_perror3 ;
assign	lsu_dtag_perror_w2[2] = dtag_perror2 ;
assign	lsu_dtag_perror_w2[1] = dtag_perror1 ;
assign	lsu_dtag_perror_w2[0] = dtag_perror0 ;

// Determine if ld pkt requires correction due to dtag parity error.
assign  lsu_pcx_ld_dtag_perror_w2 =
  ld_pcx_rq_sel[0] ? dtag_perror0 :
    ld_pcx_rq_sel[1] ? dtag_perror1 :
      ld_pcx_rq_sel[2] ? dtag_perror2 : dtag_perror3 ;


//=================================================================================================
//
// THREAD RETRY DETECTION (picker related logic)
//
//=================================================================================================

//bug4814 - move pick_staus out of picker and reset pick status when all 12 valid requests have
//          is picked and not squashed.

assign  ld_thrd_pick_din[0]  =  ld_thrd_pick_status[0] | (ld0_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  ld_thrd_pick_din[1]  =  ld_thrd_pick_status[1] | (ld1_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  ld_thrd_pick_din[2]  =  ld_thrd_pick_status[2] | (ld2_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  ld_thrd_pick_din[3]  =  ld_thrd_pick_status[3] | (ld3_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;

assign  ld_thrd_pick_rst  =  ~|(ld_events_raw[3:0] & ~ld_thrd_pick_din[3:0]) ;
   
assign  ld_thrd_pick_status_din[3:0] =  ld_thrd_pick_din[3:0] & ~{4{all_thrd_pick_rst}} ;
//assign  ld_thrd_pick_status_din[3:0]  =  ld_thrd_pick_din[3:0] & ~{4{ld_thrd_pick_rst}} ;

assign  st_thrd_pick_din[0] = st_thrd_pick_status[0] | (st0_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  st_thrd_pick_din[1] = st_thrd_pick_status[1] | (st1_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  st_thrd_pick_din[2] = st_thrd_pick_status[2] | (st2_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  st_thrd_pick_din[3] = st_thrd_pick_status[3] | (st3_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;

assign  st_thrd_pick_rst  =  ~|(st_events_raw[3:0] & ~st_thrd_pick_din[3:0]) ;
assign  st_thrd_pick_status_din[3:0]  =  st_thrd_pick_din[3:0] & ~{4{all_thrd_pick_rst}} ;
//assign  st_thrd_pick_status_din[3:0]  =  st_thrd_pick_din[3:0] & ~{4{st_thrd_pick_rst}} ;

assign  misc_thrd_pick_din[3] = misc_thrd_pick_status[3] | lsu_spu_ldst_ack ;
assign  misc_thrd_pick_din[2] = misc_thrd_pick_status[2] | (fpop_pcx_rq_sel_d2 & ~pcx_req_squash_d1) ;
assign  misc_thrd_pick_din[1] = misc_thrd_pick_status[1] | lsu_tlu_pcxpkt_ack ;
assign  misc_thrd_pick_din[0] = misc_thrd_pick_status[0] | lsu_fwdpkt_pcx_rq_sel ;

assign  misc_thrd_pick_rst  =  ~|(misc_events_raw[3:0] & ~misc_thrd_pick_din[3:0]) ;
   
assign  misc_thrd_pick_status_din[3:0]  =  misc_thrd_pick_din[3:0] & ~{4{all_thrd_pick_rst}} ;
//assign  misc_thrd_pick_status_din[3:0]  =  misc_thrd_pick_din[3:0] & ~{4{misc_thrd_pick_rst}} ;

assign  all_thrd_pick_rst  =  ld_thrd_pick_rst & st_thrd_pick_rst & misc_thrd_pick_rst ;


dff_s    #(4) ff_ld_thrd_force(
        .din    (ld_thrd_pick_status_din[3:0]),
        .q      (ld_thrd_pick_status[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s    #(4) ff_st_thrd_force(
        .din    (st_thrd_pick_status_din[3:0]),
        .q      (st_thrd_pick_status[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s    #(4) ff_misc_thrd_force(
        .din    (misc_thrd_pick_status_din[3:0]),
        .q      (misc_thrd_pick_status[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  ld_thrd_force_d1[3:0]  =  ~ld_thrd_pick_status[3:0] ;
assign  st_thrd_force_d1[3:0]  =  ~st_thrd_pick_status[3:0] ;
assign  misc_thrd_force_d1[3:0]  =  ~misc_thrd_pick_status[3:0] ;

assign ld_thrd_force_vld[0]  =  ld_thrd_force_d1[0] & 
                               ~(ld0_pcx_rq_sel_d1 | ld0_pcx_rq_sel_d2) ;

assign ld_thrd_force_vld[1]  =  ld_thrd_force_d1[1] &
                               ~(ld1_pcx_rq_sel_d1 | ld1_pcx_rq_sel_d2) ;

assign ld_thrd_force_vld[2]  =  ld_thrd_force_d1[2] &
                               ~(ld2_pcx_rq_sel_d1 | ld2_pcx_rq_sel_d2) ;

assign ld_thrd_force_vld[3]  =  ld_thrd_force_d1[3] &
                               ~(ld3_pcx_rq_sel_d1 | ld3_pcx_rq_sel_d2) ;


// force valid to store picker if 1 entry is free and if it not picked in d1/d2
assign st_thrd_force_vld[0]  =  st_thrd_force_d1[0] &
                               ~(st0_pcx_rq_sel_d1 | st0_pcx_rq_sel_d2) ;

assign st_thrd_force_vld[1]  =  st_thrd_force_d1[1] &
                               ~(st1_pcx_rq_sel_d1 | st1_pcx_rq_sel_d2) ;

assign st_thrd_force_vld[2]  =  st_thrd_force_d1[2] &
                               ~(st2_pcx_rq_sel_d1 | st2_pcx_rq_sel_d2) ;

assign st_thrd_force_vld[3]  =  st_thrd_force_d1[3] &
                               ~(st3_pcx_rq_sel_d1 | st3_pcx_rq_sel_d2) ;



// force valid to misc picker if 1 entry is free and if it is not picked in d1/d2
assign misc_thrd_force_vld[0]  =  misc_thrd_force_d1[0] &
                                 ~(fwdpkt_pcx_rq_sel_d1 | fwdpkt_pcx_rq_sel_d2) ;

assign misc_thrd_force_vld[1]  =  misc_thrd_force_d1[1] &
                                 ~(intrpt_pcx_rq_sel_d1 | intrpt_pcx_rq_sel_d2);

assign misc_thrd_force_vld[2]  =  misc_thrd_force_d1[2] &
                                 ~(fpop_pcx_rq_sel_d1 | fpop_pcx_rq_sel_d2) ;

assign misc_thrd_force_vld[3]  =  misc_thrd_force_d1[3] &
                                 ~(strm_pcx_rq_sel_d1 | strm_pcx_rq_sel_d2) ;

//2nd level pick thread force - force only req are valid and l2bnk is free
assign all_thrd_force_vld[0]  =  1'b0 ;

assign all_thrd_force_vld[1]  =  
                    |(ld_thrd_force_vld[3:0] & 
                     {ld3_pcx_rq_vld,ld2_pcx_rq_vld,ld1_pcx_rq_vld,ld0_pcx_rq_vld}) ;

assign all_thrd_force_vld[2]  =  
                    |(st_thrd_force_vld[3:0] &
                     {st3_pcx_rq_vld,st2_pcx_rq_vld,st1_pcx_rq_vld,st0_pcx_rq_vld}) ;

assign all_thrd_force_vld[3]  =  
                    |(misc_thrd_force_vld[3:0] &
                     {strm_pcx_rq_vld,fpop_pcx_rq_vld,intrpt_pcx_rq_vld,fwdpkt_rq_vld}) ;


endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: lsu_qdp1.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Description:  LSU PCX Datapath - QDP1
*/
////////////////////////////////////////////////////////////////////////
// header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
          // time scale definition
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications





module lsu_qdp1 ( /*AUTOARG*/
   // Outputs
  
  spc_pcx_csm_pa,
  

   so, lsu_va_match_b47_b32_m, lsu_va_match_b31_b3_m, lsu_va_wtchpt_addr, spc_pcx_data_pa,
   dtag_wdata_m, dtag_wdata_e, lmq0_byp_misc_sz, lmq1_byp_misc_sz,
   lmq2_byp_misc_sz, lmq3_byp_misc_sz, lsu_byp_misc_sz_e,
   lsu_l2fill_sign_extend_m, lsu_l2fill_bendian_m, lmq0_l2fill_fpld,
   lmq1_l2fill_fpld, lmq2_l2fill_fpld, lmq3_l2fill_fpld, lmq_ld_rd1,
   lmq0_ncache_ld, lmq1_ncache_ld, lmq2_ncache_ld, lmq3_ncache_ld,
   lmq0_ld_rq_type, lmq1_ld_rq_type, lmq2_ld_rq_type,
   lmq3_ld_rq_type, lmq0_ldd_vld, lmq1_ldd_vld, lmq2_ldd_vld,
   lmq3_ldd_vld, ld_sec_hit_thrd0, ld_sec_hit_thrd1,
   ld_sec_hit_thrd2, ld_sec_hit_thrd3, lmq0_pcx_pkt_addr,
   lmq1_pcx_pkt_addr, lmq2_pcx_pkt_addr, lmq3_pcx_pkt_addr,
   lsu_mmu_rs3_data_g, lsu_tlu_rs3_data_g, lsu_diagnstc_wr_data_b0,
   lsu_diagnstc_wr_data_e, lsu_ifu_stxa_data,
   lsu_ifu_ld_icache_index, lsu_ifu_ld_pcxpkt_tid, lsu_error_pa_m,
   lsu_pref_pcx_req, st_rs3_data_g, lsu_ldst_va_way_g,
   dcache_alt_data_w0_m,
   // Inputs
  
  tlb_rd_tte_csm, stb_rcsm_ramc, ifu_pcx_csm,
  

   rclk, si, se, lsu_dcache_iob_rd_w, lsu_ramtest_rd_w,
   lsu_pcx_rq_sz_b3, lsu_diagnstc_data_sel, pcx_pkt_src_sel,
   lsu_stb_pcx_rvld_d1, imiss_pcx_mx_sel, fwd_int_fp_pcx_mx_sel,
   spu_lsu_ldst_pckt, tlu_lsu_pcxpkt, const_cpuid, ifu_pcx_pkt,
   lmq_byp_data_en_w2, lmq_byp_data_sel0, lmq_byp_data_sel1,
   lmq_byp_data_sel2, lmq_byp_data_sel3, lmq_byp_ldxa_sel0,
   lmq_byp_ldxa_sel1, lmq_byp_ldxa_sel2, lmq_byp_ldxa_sel3,
   lmq_byp_data_fmx_sel, exu_lsu_rs3_data_e, ifu_lsu_ldxa_data_w2,
   tlu_lsu_int_ldxa_data_w2, spu_lsu_ldxa_data_w2, stb_rdata_ramd,
   stb_rdata_ramc, lmq_byp_misc_sel, dfq_byp_sel, ld_pcx_rq_sel,
   ld_pcx_thrd, lmq_enable, ld_pcx_pkt_g, ffu_lsu_data,
   lsu_tlb_st_sel_m, lsu_pcx_fwd_pkt, lsu_pcx_fwd_reply,
   lsu_diagnstc_dtagv_prty_invrt_e, lsu_misc_rdata_w2,
   lsu_stb_rd_tid, lsu_iobrdge_rply_data_sel, lsu_iobrdge_rd_data,
   lsu_atomic_pkt2_bsel_g, lsu_pcx_ld_dtag_perror_w2,
   lsu_dcache_rdata_w, lsu_va_wtchpt0_wr_en_l,
   lsu_va_wtchpt1_wr_en_l, lsu_va_wtchpt2_wr_en_l,
   lsu_va_wtchpt3_wr_en_l, thread0_m, thread1_m, thread2_m,
   thread3_m, lsu_thread_g, lsu_ldst_va_m, tlb_pgnum, lsu_bld_pcx_rq,
   lsu_bld_rq_addr, lmq0_pcx_pkt_way, lmq1_pcx_pkt_way,
   lmq2_pcx_pkt_way, lmq3_pcx_pkt_way, lsu_dfq_ld_vld,
   lsu_ifu_asi_data_en_l, lsu_ld0_spec_vld_kill_w2,
   lsu_ld1_spec_vld_kill_w2, lsu_ld2_spec_vld_kill_w2,
   lsu_ld3_spec_vld_kill_w2, lsu_fwd_rply_sz1_unc, rst_tri_en,
   lsu_l2fill_data, l2fill_vld_m, ld_thrd_byp_sel_m, sehold,
   cfg_asi_lsu_ldxa_vld_w2, cfg_asi_lsu_ldxa_data_w2
   ) ;

input                     rclk ;
input                     si;
input                     se;
input       sehold;
//input       tmb_l;

output                    so;
input         lsu_dcache_iob_rd_w ;
input         lsu_ramtest_rd_w ;

input      lsu_pcx_rq_sz_b3 ;

input  [3:0]        lsu_diagnstc_data_sel ;

input   [3:0]             pcx_pkt_src_sel ;       // sel 1/4 pkt src for pcx.
input                     lsu_stb_pcx_rvld_d1 ;   // stb has been read-delayby1cycle
input                     imiss_pcx_mx_sel ;      // select imiss over spu.
input   [2:0]             fwd_int_fp_pcx_mx_sel ; // select fwd/intrpt/fpop

input   [124-1:0]  spu_lsu_ldst_pckt ;     // stream ld/st pkt for pcx.
input   [25:0]            tlu_lsu_pcxpkt ;        // truncated pcx interrupt pkt.
input   [2:0]             const_cpuid ;           // cpu id
input   [51:0]            ifu_pcx_pkt ;           // ifu imiss request.
input   [3:0]             lmq_byp_data_en_w2 ;
input   [3:0]             lmq_byp_data_sel0 ;     // ldxa/stb/cas bypass data sel.
input   [3:0]             lmq_byp_data_sel1 ;     // ldxa/stb/cas bypass data sel.
input   [3:0]             lmq_byp_data_sel2 ;     // ldxa/stb/cas bypass data sel.
input   [3:0]             lmq_byp_data_sel3 ;     // ldxa/stb/cas bypass data sel.
input   [2:0]             lmq_byp_ldxa_sel0 ;     // ldxa data sel - thread0
input   [2:0]             lmq_byp_ldxa_sel1 ;     // ldxa data sel - thread1
input   [2:0]             lmq_byp_ldxa_sel2 ;     // ldxa data sel - thread2
input   [2:0]             lmq_byp_ldxa_sel3 ;     // ldxa data sel - thread3
input [3:0]     lmq_byp_data_fmx_sel ;  // final sel for lmq data.
input   [63:0]            exu_lsu_rs3_data_e ;    // rs3_data for cas pkt 2.
input   [63:0]            ifu_lsu_ldxa_data_w2 ;  // ldxa data from ifu.
//input   [63:0]            tlu_lsu_ldxa_data_w2 ;  // ldxa data from tlu (mmu)
input   [63:0]            tlu_lsu_int_ldxa_data_w2 ;  // ldxa data from tlu (intrpt/scpd)
input   [63:0]            spu_lsu_ldxa_data_w2 ;  // ldxa data from spu
input   [76:0]            stb_rdata_ramd ;        // stb0 data ram output.
input   [44:9]            stb_rdata_ramc ;        // stb0 tag ram output.
input   [3:0]             lmq_byp_misc_sel ;      // select g-stage lmq source
input   [3:0]             dfq_byp_sel ;
input   [3:0]             ld_pcx_rq_sel ;
input   [1:0]             ld_pcx_thrd ;

input   [3:0]             lmq_enable ;             // 4 enables for lmq.
input   [65-1:40]  ld_pcx_pkt_g ;           // ld miss pkt for thread.
input   [80:0]            ffu_lsu_data ;
input   [3:0]             lsu_tlb_st_sel_m ;
//input   [3:0]             lsu_tlb_st_sel_g ;
//input                     lsu_tlb_st_vld_g ;
input   [107:0]           lsu_pcx_fwd_pkt ;         // local fwd reply/req
input                     lsu_pcx_fwd_reply ;       // fwd reply on pcx pkt
input                     lsu_diagnstc_dtagv_prty_invrt_e ;
//input                     lsu_diagnstc_wr_src_sel_e ;// dcache/dtag/v write - diag
//input   [47:0]            lsu_local_ldxa_data_w2 ;   // local ldxa data
input   [63:0]            lsu_misc_rdata_w2 ;   // local ldxa data
input   [1:0]             lsu_stb_rd_tid ;           // thread for which stb rd occurs
input   [2:0]             lsu_iobrdge_rply_data_sel ;
input   [43:0]            lsu_iobrdge_rd_data ;
input   [2:0]             lsu_atomic_pkt2_bsel_g ;
input                     lsu_pcx_ld_dtag_perror_w2 ;
input [63:0]      lsu_dcache_rdata_w ;
//input   [47:0]            tlu_lsu_iobrdge_pc_data ;  // NOTE: unused: remove this in sync w/ tlu

input         lsu_va_wtchpt0_wr_en_l;
input         lsu_va_wtchpt1_wr_en_l;
input         lsu_va_wtchpt2_wr_en_l;
input         lsu_va_wtchpt3_wr_en_l;
input         thread0_m;
input         thread1_m;
input         thread2_m;
input         thread3_m;

   input [3:0] lsu_thread_g;


//input         lsu_pa_wtchpt_wr_en_l;
input [47:0]  lsu_ldst_va_m;
input [39:13] tlb_pgnum;
input         lsu_bld_pcx_rq ;        // cycle after request
input [1:0]   lsu_bld_rq_addr ;       // cycle after request

//input  [1:0]           lsu_lmq_pkt_way_g;
input  [2-1:0]           lmq0_pcx_pkt_way;
input  [2-1:0]           lmq1_pcx_pkt_way;
input  [2-1:0]           lmq2_pcx_pkt_way;
input  [2-1:0]           lmq3_pcx_pkt_way;

input           lsu_dfq_ld_vld ;
input   lsu_ifu_asi_data_en_l ;

input           lsu_ld0_spec_vld_kill_w2 ;
input           lsu_ld1_spec_vld_kill_w2 ;
input           lsu_ld2_spec_vld_kill_w2 ;
input           lsu_ld3_spec_vld_kill_w2 ;

input   lsu_fwd_rply_sz1_unc ;

input           rst_tri_en ;



input  [32:0]   tlb_rd_tte_csm;
input  [32:0]   stb_rcsm_ramc;
input  [32:0]   ifu_pcx_csm;

output [32:0]   spc_pcx_csm_pa;


//extra asi
input         cfg_asi_lsu_ldxa_vld_w2;
input [63:0]  cfg_asi_lsu_ldxa_data_w2;

output        lsu_va_match_b47_b32_m;
output        lsu_va_match_b31_b3_m;

//output        lsu_pa_match_b39_13_g;
//output        lsu_pa_match_b12_3_m;
output [47:3] lsu_va_wtchpt_addr;
//output [39:3] lsu_pa_wtchpt_addr;

//output  [63:0]            ld_stb_bypass_data ;  // st to load bypass data.

output  [124-1:0]  spc_pcx_data_pa ;
output  [29:0]            dtag_wdata_m ;            // tag to write to dtag.
output  [29:0]            dtag_wdata_e ;            // tag to write to dtag.
//output  [3:0]             lsu_byp_misc_addr_m ;     // lower 3bits of addr for ldxa/raw etc
//output  [1:0]             lsu_byp_misc_sz_m ;       // size for ldxa/raw etc
output  [1:0]             lmq0_byp_misc_sz ;
output  [1:0]             lmq1_byp_misc_sz ;
output  [1:0]             lmq2_byp_misc_sz ;
output  [1:0]             lmq3_byp_misc_sz ;

output  [1:0]             lsu_byp_misc_sz_e ;       // size for ldxa/raw etc
output                    lsu_l2fill_sign_extend_m ;// requires sign-extend else zero extend
output                    lsu_l2fill_bendian_m ;    // big endian fill/bypass.
//output                    lsu_l2fill_fpld_e ;       // fp load
output                    lmq0_l2fill_fpld ;       // fp load
output                    lmq1_l2fill_fpld ;       // fp load
output                    lmq2_l2fill_fpld ;       // fp load
output                    lmq3_l2fill_fpld ;       // fp load

output  [4:0]             lmq_ld_rd1 ;              // rd for all loads
//output                    lsu_ncache_ld_e ;         // non-cacheable ld from dfq
output                    lmq0_ncache_ld ;         // non-cacheable ld from dfq
output                    lmq1_ncache_ld ;         // non-cacheable ld from dfq
output                    lmq2_ncache_ld ;         // non-cacheable ld from dfq
output                    lmq3_ncache_ld ;         // non-cacheable ld from dfq
//output  [2:0]             lsu_ld_rq_type_e ;        // for identifying atomic ld.

output  [2:0]             lmq0_ld_rq_type ;        // for identifying atomic ld.
output  [2:0]             lmq1_ld_rq_type ;        // for identifying atomic ld.
output  [2:0]             lmq2_ld_rq_type ;        // for identifying atomic ld.
output  [2:0]             lmq3_ld_rq_type ;        // for identifying atomic ld.

output                    lmq0_ldd_vld ;             // ld double
output                    lmq1_ldd_vld ;             // ld double
output                    lmq2_ldd_vld ;             // ld double
output                    lmq3_ldd_vld ;             // ld double

output                    ld_sec_hit_thrd0 ;        // ld has sec. hit against th0
output                    ld_sec_hit_thrd1 ;        // ld has sec. hit against th1
output                    ld_sec_hit_thrd2 ;        // ld has sec. hit against th2
output                    ld_sec_hit_thrd3 ;        // ld has sec. hit against th3
//output  [1:0]             lmq_pcx_pkt_sz ;
//output  [39:0]            lmq_pcx_pkt_addr ;
output  [(6 + 4):0]            lmq0_pcx_pkt_addr;
output  [(6 + 4):0]            lmq1_pcx_pkt_addr;
output  [(6 + 4):0]            lmq2_pcx_pkt_addr;
output  [(6 + 4):0]            lmq3_pcx_pkt_addr;

//output  [63:0]            lsu_tlu_st_rs3_data_g ;
output  [63:0]            lsu_mmu_rs3_data_g ;
output  [63:0]            lsu_tlu_rs3_data_g ;

output                    lsu_diagnstc_wr_data_b0 ; // diagnostic wr data - bit 0
output  [63:0]            lsu_diagnstc_wr_data_e ;

output  [47:0]            lsu_ifu_stxa_data ;       // stxa related data

output  [(6 + 5):5]            lsu_ifu_ld_icache_index ;
output  [1:0]             lsu_ifu_ld_pcxpkt_tid ;

//output  [1:0]             lmq_ld_way ;              // cache set way for ld fill

output  [28:0]            lsu_error_pa_m ;          // error phy addr
//output  [13:0]            lsu_spu_rsrv_data_m ;     // rs3 data for reserved fields.
output                    lsu_pref_pcx_req ;        // pref sent to pcx

   output [63:0]          st_rs3_data_g;

output  [1:0]             lsu_ldst_va_way_g ;          // 12:11 for direct map
//====================================================================
//dc_fill CP

   input [63:0]           lsu_l2fill_data; //from qdp2
   input                  l2fill_vld_m;    //from dctl
   input   [3:0]          ld_thrd_byp_sel_m;//from dctl

   output [63:0]          dcache_alt_data_w0_m;  //to d$
//   output [7:0]           lsu_l2fill_or_byp_msb_m;   //to dctl
//====================================================================


wire  [115-1:0]  store_pcx_pkt ;
wire  [124-1:0]  pcx_pkt_data ;
wire  [115-1:0]  stb_pcx_pkt ;
wire  [124-1:0]  imiss_strm_pcx_pkt ;
wire  [124-1:0]  intrpt_full_pcxpkt ;
wire  [124-1:0]  ifu_full_pcx_pkt_e ;
wire  [51:0]      ifu_pcx_pkt_e ;
wire  [63:0]      cas_pkt2_data ;
wire  [63:0]      lmq0_bypass_data_in,lmq1_bypass_data_in ;
wire  [63:0]      lmq2_bypass_data_in,lmq3_bypass_data_in ;
wire  [63:0]      lmq0_bypass_data, lmq1_bypass_data ;
wire  [63:0]      lmq2_bypass_data, lmq3_bypass_data ;
wire  [39:0]      lmq_ld_addr ;
wire  [65:0]    load_pcx_pkt ;
wire  [65-1:0]  lmq0_pcx_pkt, lmq1_pcx_pkt ;
wire  [65-1:0]  lmq2_pcx_pkt, lmq3_pcx_pkt ;
wire  [124-1:0]  fpop_full_pcxpkt ;
wire  [63:0]      tlb_st_data ;
//wire    [63:0]      formatted_tte_tag ;
//wire    [63:0]      formatted_tte_data ;
wire  [63:0]      lmq0_bypass_ldxa_data ;
wire  [63:0]      lmq1_bypass_ldxa_data ;
wire  [63:0]      lmq2_bypass_ldxa_data ;
wire  [63:0]      lmq3_bypass_ldxa_data ;
wire  [124-1:0]  fwd_full_pcxpkt ;
wire  [47:3]            lsu_tlu_st_rs3_data_g ;



wire [32:0] lmq0_pcx_csm;
wire [32:0] lmq1_pcx_csm;
wire [32:0] lmq2_pcx_csm;
wire [32:0] lmq3_pcx_csm;
wire [32:0] load_pcx_csm;
wire [32:0] stb_pcx_csm;
wire [32:0] pcx_pkt_csm;


//===================================================
//  clock buffer
//===================================================
//wire   lsu_qdp1_clk ;
wire   clk;
assign  clk = rclk;

wire         thread0_g;
wire         thread1_g;
wire         thread2_g;
wire         thread3_g;

   assign    thread0_g = lsu_thread_g[0];
   assign    thread1_g = lsu_thread_g[1];
   assign    thread2_g = lsu_thread_g[2];
   assign    thread3_g = lsu_thread_g[3];

//=================================================================================================
//    LMQ DP
//=================================================================================================

wire  [12:0]  ldst_va_g;

dff_s  #(13) ff_ldst_va_g (
        .din    (lsu_ldst_va_m[12:0]),
        .q      (ldst_va_g[12:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  lsu_ldst_va_way_g[1:0] =  ldst_va_g[12:11];


wire [32:0] ld_pcx_csm_g_tmp;
assign ld_pcx_csm_g_tmp = tlb_rd_tte_csm;



wire  [64:0]  ld_pcx_pkt_g_tmp;

assign ld_pcx_pkt_g_tmp[64:0] =  {ld_pcx_pkt_g[65-1:44],
                                        2'b00,      // done after the flop
                                        //lsu_lmq_pkt_way_g[1:0],
                                        ld_pcx_pkt_g[41:40],
                                        tlb_pgnum[39:13],ldst_va_g[12:0]};

// Unfortunately ld_pcx_pkt_g is now 65 bits wide. Grape-mapper needs to give feedback.
// THREAD 0.
/*
dffe_s  #(`LMQ_WIDTH) lmq0 (
        .din    (ld_pcx_pkt_g_tmp[`LMQ_VLD:0]),
        .q      (lmq0_pcx_pkt[`LMQ_VLD:0]),
        .en     (lmq_enable[0]), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        );
*/
wire lmq0_clk;


clken_buf lmq0_clkbuf (
                .rclk   (clk),
                .enb_l  (~lmq_enable[0]),
                .tmb_l  (~se),
                .clk    (lmq0_clk)
                ) ;

wire  [64:0]  lmq0_pcx_pkt_tmp ;




















dff_s  #(65) lmq0 (
        .din    (ld_pcx_pkt_g_tmp[64:0]),
        .q      (lmq0_pcx_pkt_tmp[64:0]),
        .clk    (lmq0_clk),
        .se     (1'b0),       .si (),          .so ()
        );


dff_s  #(33) lmq_csm0 (
        .din    (ld_pcx_csm_g_tmp),
        .q      (lmq0_pcx_csm),
        .clk    (lmq0_clk),
        .se     (1'b0),       .si (),          .so ()
        );









//bug2705 - speculative pick in w-cycle
wire    lmq0_pcx_pkt_vld ;
assign  lmq0_pcx_pkt_vld  =  lmq0_pcx_pkt_tmp[64] & ~lsu_ld0_spec_vld_kill_w2 ;

wire [1:0] lmq0_pcx_pkt_way_trin = lmq0_pcx_pkt_way; // trin reconfig: this format prevents way > 4

assign  lmq0_pcx_pkt[64:0]  = {lmq0_pcx_pkt_vld,
                                     lmq0_pcx_pkt_tmp[64-1:44],
                                     lmq0_pcx_pkt_way_trin, 
                                     lmq0_pcx_pkt_tmp[41:0]};

// Needs to be multi-threaded.
//assign lmq_pcx_pkt_sz[1:0] = lmq0_pcx_pkt[`LMQ_SZ_HI:`LMQ_SZ_LO]  ;

assign  ld_sec_hit_thrd0 =
(ld_pcx_pkt_g_tmp[39:0+4] == lmq0_pcx_pkt[39:0+4]) ;

 // Use two threads unless this is defined

 // THREAD 1.
/*
dffe_s  #(`LMQ_WIDTH) lmq1 (
        .din    (ld_pcx_pkt_g_tmp[`LMQ_VLD:0]),
        .q      (lmq1_pcx_pkt[`LMQ_VLD:0]),
        .en     (lmq_enable[1]), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        );
*/
wire lmq1_clk;


clken_buf lmq1_clkbuf (
                .rclk   (clk),
                .enb_l  (~lmq_enable[1]),
                .tmb_l  (~se),
                .clk    (lmq1_clk)
                ) ;


wire  [64:0]  lmq1_pcx_pkt_tmp;



















dff_s  #(65) lmq1 (
        .din    (ld_pcx_pkt_g_tmp[64:0]),
        .q      (lmq1_pcx_pkt_tmp[64:0]),
        .clk    (lmq1_clk),
        .se     (1'b0),       .si (),          .so ()
        );


dff_s  #(33) lmq_csm1 (
        .din    (ld_pcx_csm_g_tmp),
        .q      (lmq1_pcx_csm),
        .clk    (lmq1_clk),
        .se     (1'b0),       .si (),          .so ()
        );




//bug2705 - speculative pick in w-cycle
wire    lmq1_pcx_pkt_vld ;
assign  lmq1_pcx_pkt_vld  =  lmq1_pcx_pkt_tmp[64] & ~lsu_ld1_spec_vld_kill_w2 ;

wire [1:0] lmq1_pcx_pkt_way_trin = lmq1_pcx_pkt_way; // trin reconfig: this format prevents way > 4

assign  lmq1_pcx_pkt[64:0]  =  {lmq1_pcx_pkt_vld,
                                      lmq1_pcx_pkt_tmp[64-1:44],
                                      lmq1_pcx_pkt_way_trin[1:0],
                                      lmq1_pcx_pkt_tmp[41:0]};

assign  ld_sec_hit_thrd1 =
(ld_pcx_pkt_g_tmp[39:0+4] == lmq1_pcx_pkt[39:0+4]) ;

// Select 1 of 2 LMQ Contents.
// selection is based on which thread's load is chosen for pcx.
mux2ds  #(65) lmq_pthrd_sel (
  .in0  (lmq0_pcx_pkt[65-1:0]),
  .in1  (lmq1_pcx_pkt[65-1:0]),
  .sel0 (ld_pcx_rq_sel[0]),
  .sel1   (ld_pcx_rq_sel[1]),
  .dout (load_pcx_pkt[65-1:0])
);


mux2ds  #(33) lmq_csm_pthrd_sel (
  .in0  (lmq0_pcx_csm),
  .in1  (lmq1_pcx_csm),
  .sel0 (ld_pcx_rq_sel[0]),
  .sel1   (ld_pcx_rq_sel[1]),
  .dout (load_pcx_csm)
);

  


































































































































































































































































































































































































































































































































assign  lsu_pref_pcx_req = load_pcx_pkt[62] ;

// Choose data to src for fill/bypass.
// E-stage muxing : required for fills specifically.

   assign lmq0_ldd_vld =   lmq0_pcx_pkt[53];
 // Use two threads unless this is defined

   assign lmq1_ldd_vld =   lmq1_pcx_pkt[53];
   assign lmq2_ldd_vld =   1'b0;
   assign lmq3_ldd_vld =   1'b0;
































 // `ifndef CONFIG_NUM_THREADS

   assign lmq0_pcx_pkt_addr[(6 + 4):0] =  lmq0_pcx_pkt[0 + (6 + 4) :0];
 // Use two threads unless this is defined

   assign lmq1_pcx_pkt_addr[(6 + 4):0] =  lmq1_pcx_pkt[0 + (6 + 4) :0];
   assign lmq2_pcx_pkt_addr[(6 + 4):0] =  {(6 + 4)+1{1'b0}};
   assign lmq3_pcx_pkt_addr[(6 + 4):0] =  {(6 + 4)+1{1'b0}};
































 // `ifndef CONFIG_NUM_THREADS

   assign lmq0_ld_rq_type[2:0] = lmq0_pcx_pkt[47:45];
 // Use two threads unless this is defined

   assign lmq1_ld_rq_type[2:0] = lmq1_pcx_pkt[47:45];
   assign lmq2_ld_rq_type[2:0] = 3'b0;
   assign lmq3_ld_rq_type[2:0] = 3'b0;
































 // `ifndef CONFIG_NUM_THREADS

    assign lmq0_l2fill_fpld =  lmq0_pcx_pkt[61];
 // Use two threads unless this is defined

    assign lmq1_l2fill_fpld =  lmq1_pcx_pkt[61];
    assign lmq2_l2fill_fpld =  1'b0;
    assign lmq3_l2fill_fpld =  1'b0;
































 // `ifndef CONFIG_NUM_THREADS
/*
   wire    lsu_l2fill_fpld_e;

mux4ds  #(44) lmq_dthrd_sel1 (
  .in0  ({lmq0_pcx_pkt[`LMQ_AD_HI:`LMQ_AD_LO], lmq0_pcx_pkt[`LMQ_NC],
          lmq0_pcx_pkt[`LMQ_FPLD],lmq0_pcx_pkt[`LMQ_SZ_HI: `LMQ_SZ_LO]}),
  .in1  ({lmq1_pcx_pkt[`LMQ_AD_HI:`LMQ_AD_LO], lmq1_pcx_pkt[`LMQ_NC],
          lmq1_pcx_pkt[`LMQ_FPLD],lmq1_pcx_pkt[`LMQ_SZ_HI: `LMQ_SZ_LO]}),
  .in2  ({lmq2_pcx_pkt[`LMQ_AD_HI:`LMQ_AD_LO], lmq2_pcx_pkt[`LMQ_NC],
          lmq2_pcx_pkt[`LMQ_FPLD],lmq2_pcx_pkt[`LMQ_SZ_HI: `LMQ_SZ_LO]}),
  .in3  ({lmq3_pcx_pkt[`LMQ_AD_HI:`LMQ_AD_LO], lmq3_pcx_pkt[`LMQ_NC],
          lmq3_pcx_pkt[`LMQ_FPLD],lmq3_pcx_pkt[`LMQ_SZ_HI: `LMQ_SZ_LO]}),
  .sel0 (dfq_byp_sel[0]),
  .sel1 (dfq_byp_sel[1]),
  .sel2 (dfq_byp_sel[2]),
  .sel3 (dfq_byp_sel[3]),
  .dout ({lmq_ld_addr[39:0], lsu_ncache_ld_e,
          lsu_l2fill_fpld_e, lsu_byp_misc_sz_e[1:0]})
);
*/

   assign  lmq0_ncache_ld =   lmq0_pcx_pkt[44];
 // Use two threads unless this is defined

   assign  lmq1_ncache_ld =   lmq1_pcx_pkt[44];
   assign  lmq2_ncache_ld =   1'b0;
   assign  lmq3_ncache_ld =   1'b0;
































 // `ifndef CONFIG_NUM_THREADS

 // Use two threads unless this is defined

mux2ds  #(42) lmq_dthrd_sel1 (
  .in0  ({lmq0_pcx_pkt[39:0],
          lmq0_pcx_pkt[41: 40]}),
  .in1  ({lmq1_pcx_pkt[39:0],
          lmq1_pcx_pkt[41: 40]}),
  .sel0 (dfq_byp_sel[0]),
  .sel1 (dfq_byp_sel[1]),
  .dout ({lmq_ld_addr[39:0], lsu_byp_misc_sz_e[1:0]})
);

// POR
// M-stage muxing : require for alignment and bypassing to exu.
// flopped then used in qctl/dctl G-stage
// lmq_ld_rd1 to lsu_qctl
// others to lsu_dctl

// M-Stage Muxing

mux2ds  #(7) lmq_dthrd_sel2 (
  .in0  ({lmq0_pcx_pkt[58: 54],lmq0_pcx_pkt[59],
    lmq0_pcx_pkt[60]}),
  .in1  ({lmq1_pcx_pkt[58: 54],lmq1_pcx_pkt[59],
    lmq1_pcx_pkt[60]}),
  .sel0 (lmq_byp_misc_sel[0]),
  .sel1 (lmq_byp_misc_sel[1]),
  .dout ({lmq_ld_rd1[4:0],lsu_l2fill_bendian_m,lsu_l2fill_sign_extend_m})
);






























































































































 // `ifndef CONFIG_NUM_THREADS

   assign  lmq0_byp_misc_sz[1:0] = lmq0_pcx_pkt[41: 40];
 // Use two threads unless this is defined

   assign  lmq1_byp_misc_sz[1:0] = lmq1_pcx_pkt[41: 40];
   assign  lmq2_byp_misc_sz[1:0] = 2'b0;
   assign  lmq3_byp_misc_sz[1:0] = 2'b0;
































 // `ifndef CONFIG_NUM_THREADS

//assign  lmq_pcx_pkt_addr[`L1D_ADDRESS_HI:0] = lmq_ld_addr[`L1D_ADDRESS_HI:0] ;


   wire [29:0] dtag_wdata_e;

assign  dtag_wdata_e[28:0] =
        ~lsu_dfq_ld_vld ?
        lsu_diagnstc_wr_data_e[29:1] : lmq_ld_addr[39:11] ;

// Parity Generation for Tag. Match with macro.
wire    dtag_wr_parity ;
wire    dtag_wr_parity_e;
assign  dtag_wr_parity_e = ^dtag_wdata_e[28:0] ;
assign  dtag_wdata_e[29] =
       ~lsu_dfq_ld_vld ?
       lsu_diagnstc_dtagv_prty_invrt_e^dtag_wr_parity_e : dtag_wr_parity_e ;

   wire dtag_wr_parity_7_0, dtag_wr_parity_15_8,
        dtag_wr_parity_23_16,  dtag_wr_parity_28_24;

   assign dtag_wr_parity_7_0  =  ^dtag_wdata_e[7:0];   //zzpar8
   assign dtag_wr_parity_15_8 =  ^dtag_wdata_e[15:8];  //zzpar8
   assign dtag_wr_parity_23_16 = ^dtag_wdata_e[23:16]; //zzpar8
   assign dtag_wr_parity_28_24 = ^dtag_wdata_e[28:24]; //zzpar8

   wire   dtag_wr_parity_28_24_with_invrt;

   assign dtag_wr_parity_28_24_with_invrt =
           (^dtag_wdata_e[28:24]) ^ lsu_diagnstc_dtagv_prty_invrt_e; //zzpar8


   wire dtag_wr_parity_7_0_m, dtag_wr_parity_15_8_m,
        dtag_wr_parity_23_16_m,  dtag_wr_parity_28_24_m;
   wire lsu_dfq_ld_vld_m;
   wire dtag_wr_parity_28_24_with_invrt_m;


// 12/12/03 : Change for Macrotest. I didn't mention
// these 4 bits ! Pls check for a max time violation.
wire  dtag_wr_parity_7_0_din, dtag_wr_parity_15_8_din ;
wire  dtag_wr_parity_23_16_din, dtag_wr_parity_28_24_din ;
assign  dtag_wr_parity_7_0_din =
sehold ? dtag_wr_parity_7_0_m : dtag_wr_parity_7_0 ;
assign  dtag_wr_parity_15_8_din =
sehold ? dtag_wr_parity_15_8_m : dtag_wr_parity_15_8 ;
assign  dtag_wr_parity_23_16_din =
sehold ? dtag_wr_parity_23_16_m : dtag_wr_parity_23_16 ;
assign  dtag_wr_parity_28_24_din =
sehold ? dtag_wr_parity_28_24_m : dtag_wr_parity_28_24 ;

dff_s #(6) tag_parity_m (
     .din ({dtag_wr_parity_7_0_din, dtag_wr_parity_15_8_din,
            dtag_wr_parity_23_16_din, dtag_wr_parity_28_24_din,
            lsu_dfq_ld_vld,   dtag_wr_parity_28_24_with_invrt}),
     .q   ({dtag_wr_parity_7_0_m, dtag_wr_parity_15_8_m,
            dtag_wr_parity_23_16_m, dtag_wr_parity_28_24_m,
            lsu_dfq_ld_vld_m, dtag_wr_parity_28_24_with_invrt_m}),
     .clk  (clk),
     .se   (1'b0),     .si (),          .so ()
);

assign dtag_wr_parity = dtag_wr_parity_7_0_m ^ dtag_wr_parity_15_8_m ^
                        dtag_wr_parity_23_16_m ^ dtag_wr_parity_28_24_m;

   wire dtag_wr_parity_with_invrt;

assign dtag_wr_parity_with_invrt =
       dtag_wr_parity_7_0_m ^ dtag_wr_parity_15_8_m ^
       dtag_wr_parity_23_16_m ^ dtag_wr_parity_28_24_with_invrt_m;

wire [29:0] dtag_wdata_m;

// 12/12/03 : Change for Macrotest.
assign dtag_wdata_m[29] =
        ~(lsu_dfq_ld_vld_m | sehold) ?
        dtag_wr_parity_with_invrt : dtag_wr_parity ;

// 12/12/03 : Change for Macrotest.
wire [28:0] dtag_wdata_e_din ;
assign  dtag_wdata_e_din[28:0] =
sehold ? dtag_wdata_m[28:0] : dtag_wdata_e[28:0] ;

dff_s  #(29) tag_stgm (
        .din  (dtag_wdata_e_din[28:0]),
        .q    (dtag_wdata_m[28:0]),
        .clk  (clk),
        .se   (1'b0),     .si (),          .so ()
        );

   assign      lsu_error_pa_m[28:0] =  dtag_wdata_m[28:0];


//=================================================================================================
//    RS3 DATA ALIGNMENT FOR CAS
//=================================================================================================

wire  [7:0] rs3_byte0, rs3_byte1, rs3_byte2, rs3_byte3 ;
wire  [7:0] rs3_byte4, rs3_byte5, rs3_byte6, rs3_byte7 ;
wire  [63:0]  atm_byte_g ;
wire  [63:0]  st_rs3_data_m,st_rs3_data_g ;

dff_s  #(64) rs3_stgm (
        .din  (exu_lsu_rs3_data_e[63:0]),
        .q    (st_rs3_data_m[63:0]),
        .clk  (clk),
        .se   (1'b0),     .si (),          .so ()
        );

// rm (along with spu).
//assign  lsu_spu_rsrv_data_m[13:0] =
//  {st_rs3_data_m[27:23],st_rs3_data_m[21:16],st_rs3_data_m[8:6]} ;

dff_s  #(64) rs3_stgg (
        .din  (st_rs3_data_m[63:0]),
        .q    (st_rs3_data_g[63:0]),
        .clk  (clk),
        .se   (1'b0),     .si (),          .so ()
        );

assign  rs3_byte0[7:0] = st_rs3_data_g[7:0] ;
assign  rs3_byte1[7:0] = st_rs3_data_g[15:8] ;
assign  rs3_byte2[7:0] = st_rs3_data_g[23:16] ;
assign  rs3_byte3[7:0] = st_rs3_data_g[31:24] ;
assign  rs3_byte4[7:0] = st_rs3_data_g[39:32] ;
assign  rs3_byte5[7:0] = st_rs3_data_g[47:40] ;
assign  rs3_byte6[7:0] = st_rs3_data_g[55:48] ;
assign  rs3_byte7[7:0] = st_rs3_data_g[63:56] ;

//assign  atm_byte_g[7:0] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte0[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte3[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte7[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_7_0 (
    .in0 (rs3_byte0[7:0]),
    .in1 (rs3_byte3[7:0]),
    .in2 (rs3_byte7[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[7:0]));


//assign  atm_byte_g[15:8] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte1[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte2[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte6[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_15_8 (
    .in0 (rs3_byte1[7:0]),
    .in1 (rs3_byte2[7:0]),
    .in2 (rs3_byte6[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[15:8]));

//assign  atm_byte_g[23:16] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte2[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte1[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte5[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_23_16 (
    .in0 (rs3_byte2[7:0]),
    .in1 (rs3_byte1[7:0]),
    .in2 (rs3_byte5[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[23:16]));

//assign  atm_byte_g[31:24] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte3[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte0[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte4[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_31_24 (
    .in0 (rs3_byte3[7:0]),
    .in1 (rs3_byte0[7:0]),
    .in2 (rs3_byte4[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[31:24]));

//assign  atm_byte_g[39:32] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte4[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte0[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte3[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_39_32 (
    .in0 (rs3_byte4[7:0]),
    .in1 (rs3_byte0[7:0]),
    .in2 (rs3_byte3[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[39:32]));

//assign  atm_byte_g[47:40] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte5[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte1[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte2[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_47_40(
    .in0 (rs3_byte5[7:0]),
    .in1 (rs3_byte1[7:0]),
    .in2 (rs3_byte2[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[47:40]));

//assign  atm_byte_g[55:48] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte6[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte2[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte1[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_55_48(
    .in0 (rs3_byte6[7:0]),
    .in1 (rs3_byte2[7:0]),
    .in2 (rs3_byte1[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[55:48]));

//assign  atm_byte_g[63:56] =
//lsu_atomic_pkt2_bsel_g[2] ? rs3_byte7[7:0] :
//  lsu_atomic_pkt2_bsel_g[1] ? rs3_byte3[7:0] :
//    lsu_atomic_pkt2_bsel_g[0] ? rs3_byte0[7:0] : 8'bxxxx_xxxx ;

mux3ds #(8) mx_atm_byte_g_63_56 (
    .in0 (rs3_byte7[7:0]),
    .in1 (rs3_byte3[7:0]),
    .in2 (rs3_byte0[7:0]),
    .sel0(lsu_atomic_pkt2_bsel_g[2]),
    .sel1(lsu_atomic_pkt2_bsel_g[1]),
    .sel2(lsu_atomic_pkt2_bsel_g[0]),
    .dout(atm_byte_g[63:56]));

//=================================================================================================
//    STB/LDXA DATA BYPASSING
//=================================================================================================

// Add STB to load bypass data flops.
// Attempt is made to bypass data in G-stage for load. If not
// possible then flop data and wait for next available bubble.
// Once bypass occurs then load can be considered resolved.
// Load Full Raw bypassing does not have to use DFQ.

// ldxa data will reside in bypass flops until an opportunity
// is available to write to irf. ldxa's must write to lmq
// in order to provide information such as rd to irf.

// ** The two conditions are mutually exclusive. **

// lsu_local_ldxa_data_w2 w/ lsu_misc_rdata_w2 for all 4 threads

// 1-hot fix: 8/1/03 - can be multihot during scan
// grape mapper convert the 1 of the inverter used for the select to the logic below
wire  [2:0]  lmq_byp_ldxa_sel0_1hot ;
assign  lmq_byp_ldxa_sel0_1hot[0]  =  lmq_byp_ldxa_sel0[0] & ~rst_tri_en;
assign  lmq_byp_ldxa_sel0_1hot[1]  =  lmq_byp_ldxa_sel0[1] & ~rst_tri_en;
assign  lmq_byp_ldxa_sel0_1hot[2]  =  lmq_byp_ldxa_sel0[2] |  rst_tri_en;


// THREAD 0
mux3ds  #(64) ldbyp0_ldxa_mx (
  .in0  (ifu_lsu_ldxa_data_w2[63:0]), // ifu-ldxa bypass data
  //.in1  (tlu_lsu_ldxa_data_w2[63:0]), // tlu-ldxa bypass data
  .in1  (spu_lsu_ldxa_data_w2[63:0]), // spu-ldxa bypass data
  .in2  (lsu_misc_rdata_w2[63:0]),    // local asi bypass data
  .sel0 (lmq_byp_ldxa_sel0_1hot[0]),
  //.sel1 (lmq_byp_ldxa_sel0[1]),
  .sel1 (lmq_byp_ldxa_sel0_1hot[1]),
  .sel2 (lmq_byp_ldxa_sel0_1hot[2]),
  .dout (lmq0_bypass_ldxa_data[63:0])
);

// 1-hot fix: 8/1/03 - can be multihot during scan
// grape mapper convert the 1 of the inverter used for the select to the logic below
wire  [3:0]  lmq_byp_data_sel0_1hot ;
assign  lmq_byp_data_sel0_1hot[0]  =  lmq_byp_data_sel0[0] ;
assign  lmq_byp_data_sel0_1hot[1]  =  lmq_byp_data_sel0[1] ;
assign  lmq_byp_data_sel0_1hot[2]  =  lmq_byp_data_sel0[2] ;
assign  lmq_byp_data_sel0_1hot[3]  =  lmq_byp_data_sel0[3] ;

wire  [63:0]  lmq0_bypass_misc_data ;
mux4ds  #(64) ldbyp0_data_mx (
  .in0  (stb_rdata_ramd[63:0]),   // stb bypass data
  .in1  (exu_lsu_rs3_data_e[63:0]), // rs3 data
  .in2  (atm_byte_g[63:0]),   // cas formatted data
  .in3  (lmq0_bypass_ldxa_data[63:0]),  // ldxa bypass data
  .sel0 (lmq_byp_data_sel0_1hot[0]),
  .sel1 (lmq_byp_data_sel0_1hot[1]),
  .sel2 (lmq_byp_data_sel0_1hot[2]),
  .sel3 (lmq_byp_data_sel0_1hot[3]),
  .dout (lmq0_bypass_misc_data[63:0])
);


//Addition as per OpenSPARC T1 Internals
wire [63:0] ldxa_data_w2;

assign ldxa_data_w2 = cfg_asi_lsu_ldxa_vld_w2 ?
                      cfg_asi_lsu_ldxa_data_w2[63:0] :
                      tlu_lsu_int_ldxa_data_w2[63:0];

// 2:1 mux for additional data bus from tlu.
// Grape : merge into mux-flop.
mux2ds  #(64) ldbyp0_fmx (
  .in0  (lmq0_bypass_misc_data[63:0]),
  .in1  (ldxa_data_w2[63:0]),   // Changed input from (tlu_lsu_int_ldxa_data_w2[63:0]),
  .sel0 (~lmq_byp_data_fmx_sel[0]),
  .sel1 (lmq_byp_data_fmx_sel[0]),
  .dout (lmq0_bypass_data_in[63:0])
);

/*
dffe_s  #(64) ldbyp0_data_ff (
        .din    (lmq0_bypass_data_in[63:0]),
        .q      (lmq0_bypass_data[63:0]),
        .en     (lmq_byp_data_en_w2[0]), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        );
*/
wire ldbyp0_data_clk;


clken_buf ldbyp0_data_clkbuf (
                .rclk   (clk),
                .enb_l  (~lmq_byp_data_en_w2[0]),
                .tmb_l  (~se),
                .clk    (ldbyp0_data_clk)
                ) ;










dff_s  #(64) ldbyp0_data_ff (
        .din    (lmq0_bypass_data_in[63:0]),
        .q      (lmq0_bypass_data[63:0]),
        .clk    (ldbyp0_data_clk),
        .se     (1'b0),       .si (),          .so ()
        );


 // Use two threads unless this is defined

// THREAD 1
// 1-hot fix: 8/1/03 - can be multihot during scan
// grape mapper convert the 1 of the inverter used for the select to the logic below
wire  [2:0]  lmq_byp_ldxa_sel1_1hot ;
assign  lmq_byp_ldxa_sel1_1hot[0]  =  lmq_byp_ldxa_sel1[0] & ~rst_tri_en;
assign  lmq_byp_ldxa_sel1_1hot[1]  =  lmq_byp_ldxa_sel1[1] & ~rst_tri_en;
assign  lmq_byp_ldxa_sel1_1hot[2]  =  lmq_byp_ldxa_sel1[2] |  rst_tri_en;


mux3ds  #(64) ldbyp1_ldxa_mx (
        .in0    (ifu_lsu_ldxa_data_w2[63:0]),   // ifu-ldxa bypass data
        //.in1    (tlu_lsu_ldxa_data_w2[63:0]),   // tlu-ldxa bypass data
    .in1    (spu_lsu_ldxa_data_w2[63:0]), // spu-ldxa bypass data
    .in2    (lsu_misc_rdata_w2[63:0]),// local asi bypass data
        .sel0   (lmq_byp_ldxa_sel1_1hot[0]),
        //.sel1   (lmq_byp_ldxa_sel1[1]),
    .sel1   (lmq_byp_ldxa_sel1_1hot[1]),
    .sel2   (lmq_byp_ldxa_sel1_1hot[2]),
        .dout   (lmq1_bypass_ldxa_data[63:0])
);

// 1-hot fix: 8/1/03 - can be multihot during scan
// grape mapper convert the 1 of the inverter used for the select to the logic below
wire  [3:0]  lmq_byp_data_sel1_1hot ;
assign  lmq_byp_data_sel1_1hot[0]  =  lmq_byp_data_sel1[0] ;
assign  lmq_byp_data_sel1_1hot[1]  =  lmq_byp_data_sel1[1] ;
assign  lmq_byp_data_sel1_1hot[2]  =  lmq_byp_data_sel1[2] ;
assign  lmq_byp_data_sel1_1hot[3]  =  lmq_byp_data_sel1[3] ;


wire    [63:0]  lmq1_bypass_misc_data ;
mux4ds  #(64) ldbyp1_data_mx (
  .in0  (stb_rdata_ramd[63:0]),   // stb bypass data
  .in1  (exu_lsu_rs3_data_e[63:0]), // rs3 data
  .in2  (atm_byte_g[63:0]),   // cas formatted data
  .in3  (lmq1_bypass_ldxa_data[63:0]),  // ldxa bypass data
  .sel0 (lmq_byp_data_sel1_1hot[0]),
  .sel1 (lmq_byp_data_sel1_1hot[1]),
  .sel2 (lmq_byp_data_sel1_1hot[2]),
  .sel3 (lmq_byp_data_sel1_1hot[3]),
  .dout (lmq1_bypass_misc_data[63:0])
);

// 2:1 mux for additional data bus from tlu.
// Grape : merge into mux-flop.
mux2ds  #(64) ldbyp1_fmx (
  .in0  (lmq1_bypass_misc_data[63:0]),
  .in1  (ldxa_data_w2[63:0]),   // Changed input from (tlu_lsu_int_ldxa_data_w2[63:0]),
  .sel0 (~lmq_byp_data_fmx_sel[1]),
  .sel1 (lmq_byp_data_fmx_sel[1]),
  .dout (lmq1_bypass_data_in[63:0])
);

/*
dffe_s  #(64) ldbyp1_data_ff (
        .din    (lmq1_bypass_data_in[63:0]),
        .q      (lmq1_bypass_data[63:0]),
        .en     (lmq_byp_data_en_w2[1]), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        );
*/
wire ldbyp1_data_clk;


clken_buf ldbyp1_data_clkbuf (
                .rclk   (clk),
                .enb_l  (~lmq_byp_data_en_w2[1]),
                .tmb_l  (~se),
                .clk    (ldbyp1_data_clk)
                ) ;










dff_s  #(64) ldbyp1_data_ff (
        .din    (lmq1_bypass_data_in[63:0]),
        .q      (lmq1_bypass_data[63:0]),
        .clk    (ldbyp1_data_clk),
        .se     (1'b0),       .si (),          .so ()
        );

































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS

 // Use two threads unless this is defined

// This can be merged with above mux !!!!
mux2ds  #(64) ld_byp_cas_mx (
  .in0  (lmq0_bypass_data[63:0]),
  .in1  (lmq1_bypass_data[63:0]),
  .sel0 (ld_pcx_rq_sel[0]),
  .sel1   (ld_pcx_rq_sel[1]),
  .dout (cas_pkt2_data[63:0])
);

// Can this be merged with above muxes ?
mux2ds  #(64) tlb_st_mx (
  .in0  (lmq0_bypass_data[63:0]),
  .in1  (lmq1_bypass_data[63:0]),
  .sel0 (lsu_tlb_st_sel_m[0]),
  .sel1   (lsu_tlb_st_sel_m[1]),
  .dout (tlb_st_data[63:0])
);




















































































 // `ifndef CONFIG_NUM_THREADS

/*mux4ds  #(64) tlb_st_mx (
  .in0  (lmq0_bypass_data[63:0]),
  .in1  (lmq1_bypass_data[63:0]),
  .in2  (lmq2_bypass_data[63:0]),
  .in3  (lmq3_bypass_data[63:0]),
  .sel0 (lsu_tlb_st_sel_g[0]),
  .sel1   (lsu_tlb_st_sel_g[1]),
  .sel2 (lsu_tlb_st_sel_g[2]),
  .sel3   (lsu_tlb_st_sel_g[3]),
  .dout (tlb_st_data[63:0])
);*/

wire  [63:0] tlb_st_data_d1 ;
dff_s  #(64) std_d1 (
        .din    (tlb_st_data[63:0]),
        .q      (tlb_st_data_d1[63:0]),
        .clk    (clk),
        .se     (1'b0),     .si (),          .so ()
        );

// Begin - Bug3487.


wire asi_data_clk;


clken_buf asid_clkbuf (
                .rclk   (clk),
                .enb_l  (lsu_ifu_asi_data_en_l),
                .tmb_l  (~se),
                .clk    (asi_data_clk)
                ) ;










dff_s  #(48) ifu_std_d1 (
        .din    (tlb_st_data[47:0]),
        .q      (lsu_ifu_stxa_data[47:0]),
        .clk    (asi_data_clk),
        .se     (1'b0),     .si (),          .so ()
        );


// select is now a stage earlier, which should be
// fine as selects stay constant.
//assign  lsu_ifu_stxa_data[47:0] = tlb_st_data_d1[47:0] ;

// End - Bug3487.


//wire    [3:0]   lsu_diag_access_sel_d1 ;

//dff #(4)  diagsel_stgd1 (
//        .din    (lsu_diag_access_sel[3:0]),
//        .q      (lsu_diag_access_sel_d1[3:0]),
//        .clk    (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

//mux4ds  #(64) diag_st_mx (
//  .in0  (lmq0_bypass_data[63:0]),
//  .in1  (lmq1_bypass_data[63:0]),
//  .in2  (lmq2_bypass_data[63:0]),
//  .in3  (lmq3_bypass_data[63:0]),
//  .sel0 (lsu_diag_access_sel_d1[0]),
//  .sel1 (lsu_diag_access_sel_d1[1]),
//  .sel2 (lsu_diag_access_sel_d1[2]),
//  .sel3 (lsu_diag_access_sel_d1[3]),
//  .dout (lsu_diagnstc_wr_data_e[63:0])
//);

// 1-hot fix: 8/1/03 - can be multihot during scan
// grape mapper convert the 1 of the inverter used for the select to the logic below
wire  [3:0]  lsu_diagnstc_data_sel_1hot ;
assign  lsu_diagnstc_data_sel_1hot[0]  =  lsu_diagnstc_data_sel[0] & ~rst_tri_en;
assign  lsu_diagnstc_data_sel_1hot[1]  =  lsu_diagnstc_data_sel[1] & ~rst_tri_en;
assign  lsu_diagnstc_data_sel_1hot[2]  =  lsu_diagnstc_data_sel[2] & ~rst_tri_en;
assign  lsu_diagnstc_data_sel_1hot[3]  =  lsu_diagnstc_data_sel[3] |  rst_tri_en;


 // Use two threads unless this is defined

mux2ds  #(64) diag_st_mx (
  .in0  (lmq0_bypass_data[63:0]),
  .in1  (lmq1_bypass_data[63:0]),
  .sel0 (lsu_diagnstc_data_sel_1hot[0]),
  .sel1 (lsu_diagnstc_data_sel_1hot[1]),
  .dout (lsu_diagnstc_wr_data_e[63:0])
);














































 // `ifndef CONFIG_NUM_THREADS

// Remove flops
/*dff  #(64) dgndt_d1 (
        .din    (tlb_st_data[63:0]),
        .q      (lsu_diagnstc_wr_data_e[63:0]),
        .clk    (clk),
        .se     (1'b0),     .si (),          .so ()
        ); */

assign lsu_diagnstc_wr_data_b0 = lsu_diagnstc_wr_data_e[0] ;

// Move tte format and parity calc to tlbdp

//assign lsu_tlu_st_rs3_data_g[63:0] = tlb_st_data_d1[63:0];
assign lsu_tlu_st_rs3_data_g[47:3] = tlb_st_data_d1[47:3];
assign lsu_mmu_rs3_data_g[63:0] = tlb_st_data_d1[63:0];
assign lsu_tlu_rs3_data_g[63:0] = tlb_st_data_d1[63:0];

// Removed Fast bypass as penalty is negligible.

//=================================================================================================
//    STQ PKT2 DATA
//=================================================================================================

//** stquad support removed **

//=================================================================================================
//    IMISS/SPU DP
//=================================================================================================

// Format of IFU pcx packet (50b) :
//  b49 - valid
//  b48:44 - req type
//  b43:42 - rep way (for "eviction" - maintains directory consistency )
//  b41:40 - mil id
//  b39:0  - imiss address


// Align ifu pkt with ldst pkt - temporary !
// Does this need to be enabled ?!!!! No.
assign  ifu_pcx_pkt_e[51:0] = ifu_pcx_pkt[51:0] ;

// Form pcx-wide ifu request packet.
assign  ifu_full_pcx_pkt_e[123] = ifu_pcx_pkt_e[51] ;
assign  ifu_full_pcx_pkt_e[122:118] = ifu_pcx_pkt_e[48:44];
assign  ifu_full_pcx_pkt_e[117] = ifu_pcx_pkt_e[49] ;
assign  ifu_full_pcx_pkt_e[116:114] = const_cpuid[2:0] ;
// thread-id unused - use mil id instead.
assign  ifu_full_pcx_pkt_e[113:112] = ifu_pcx_pkt_e[41:40] ;
assign  ifu_full_pcx_pkt_e[111] =  ifu_pcx_pkt_e[50] ;
assign  ifu_full_pcx_pkt_e[111-1:109] =  2'b00;
assign  ifu_full_pcx_pkt_e[108:107] =  ifu_pcx_pkt_e[43:42] ;
// unused - always infer 32b
assign  ifu_full_pcx_pkt_e[106:104] =  3'b000 ;
assign  ifu_full_pcx_pkt_e[103:64] =  ifu_pcx_pkt_e[39:0] ;
// no data
assign  ifu_full_pcx_pkt_e[63:0] =  64'd0 ;

// Form pcx-wide interrupt request packet.
assign  intrpt_full_pcxpkt[123] = tlu_lsu_pcxpkt[25] ;
assign  intrpt_full_pcxpkt[122:118] = tlu_lsu_pcxpkt[24:20];
assign  intrpt_full_pcxpkt[117] = 1'b0 ;

//tlu_lsu_pcxpkt[12:8] is the 5 bit interrupt destination thread id,
//so [12:10] is the cpu id, and [9:8] is the thread id.
assign  intrpt_full_pcxpkt[116:114] = tlu_lsu_pcxpkt[12:10];

// or should thread-id be 19:18 ?
assign  intrpt_full_pcxpkt[113:112] = tlu_lsu_pcxpkt[19:18] ;
// May actually make undriven fields x.
assign  intrpt_full_pcxpkt[111:109] =  3'b000;
assign  intrpt_full_pcxpkt[108:107] =  2'b00 ;
assign  intrpt_full_pcxpkt[106:104] =  3'b000 ;
assign  intrpt_full_pcxpkt[103:64] =  40'd0 ;
assign  intrpt_full_pcxpkt[63:0] =  {46'd0,tlu_lsu_pcxpkt[17:0]} ;

// Format fpop_full_pcxpkt.

assign  fpop_full_pcxpkt[123] = ffu_lsu_data[80] ;
assign  fpop_full_pcxpkt[122:118] = {4'b0101,ffu_lsu_data[78]} ;
assign  fpop_full_pcxpkt[117] = 1'b0 ;
assign  fpop_full_pcxpkt[116:114] = const_cpuid[2:0] ;
assign  fpop_full_pcxpkt[113:112] = ffu_lsu_data[77:76] ;
assign  fpop_full_pcxpkt[111:104] = 8'd0 ;
assign  fpop_full_pcxpkt[103:64+16] = 24'd0 ;
assign  fpop_full_pcxpkt[64+15:64+8] = ffu_lsu_data[75:68]; // 79:72
assign  fpop_full_pcxpkt[64+7:64+4] = 4'b0000;      // 71:68
assign  fpop_full_pcxpkt[64+3:64] = ffu_lsu_data[67:64] ; // 67:64
assign  fpop_full_pcxpkt[63:0] = ffu_lsu_data[63:0] ;


// RAMTest Data Merging.
wire cacherd_clk;


clken_buf cacherd_clkbuf (
                .rclk   (clk),
                .enb_l  (~lsu_ramtest_rd_w),
                .tmb_l  (~se),
                .clk    (cacherd_clk)
                ) ;


wire  [63:0]  cache_rdata_w,cache_rdata_w2 ;

mux2ds  #(64) cacherd_sel (
  .in0  (ifu_lsu_ldxa_data_w2[63:0]),
  .in1  (lsu_dcache_rdata_w[63:0]),
  .sel0 (~lsu_dcache_iob_rd_w),
  .sel1 (lsu_dcache_iob_rd_w),
  .dout (cache_rdata_w[63:0])
);









dff_s  #(64) cachedata (
        .din    (cache_rdata_w[63:0]),
        .q      (cache_rdata_w2[63:0]), // references dcache rd staging
        .clk    (cacherd_clk),
        .se     (1'b0),       .si (),          .so ()
        );


assign  fwd_full_pcxpkt[123] = 1'b1 ;
assign  fwd_full_pcxpkt[122:118] = {3'b011,lsu_pcx_fwd_reply,~lsu_pcx_fwd_reply} ;
assign  fwd_full_pcxpkt[117] = lsu_pcx_fwd_pkt[107] ;
assign  fwd_full_pcxpkt[116:114] = lsu_pcx_fwd_pkt[106:104] ;
assign  fwd_full_pcxpkt[113:112] = 2'b00 ;
assign  fwd_full_pcxpkt[111:104] =
      {6'b000000,lsu_fwd_rply_sz1_unc,1'b1} ;
// All address bits should not be required !!!
assign  fwd_full_pcxpkt[103:64] = lsu_pcx_fwd_pkt[103:64] ;

//  Mux sources of TAP request data - margin,pc,defeature/debug/bist.
// Be careful about pc - could be a critical path.
// ** Assume read-data stays constant at output latches of dcache **
//assign  fwd_full_pcxpkt[`PCX_DA_HI:`PCX_DA_LO] =
//lsu_iobrdge_rply_data_sel[0] ?  {20'd0,lsu_iobrdge_rd_data[43:0]} :
//  lsu_iobrdge_rply_data_sel[1] ?  cache_rdata_w2[63:0] :
//            lsu_iobrdge_rply_data_sel[2] ?  lsu_pcx_fwd_pkt[63:0] :
//                                    64'hxxxx_xxxx_xxxx_xxxx ;

mux3ds #(64) mx_fwd_full_pcxpkt (
    .in0 ({20'd0,lsu_iobrdge_rd_data[43:0]}),
    .in1 (cache_rdata_w2[63:0]),
    .in2 (lsu_pcx_fwd_pkt[63:0]),
    .sel0(lsu_iobrdge_rply_data_sel[0]),
    .sel1(lsu_iobrdge_rply_data_sel[1]),
    .sel2(lsu_iobrdge_rply_data_sel[2]),
    .dout(fwd_full_pcxpkt[63:0]));


wire  [124-1:0]  spu_lsu_ldst_pckt_d1 ;
dff_s  #(124) ff_spu_lsu_ldst_pckt_d1 (
        .din  (spu_lsu_ldst_pckt[124-1:0]),
        .q    (spu_lsu_ldst_pckt_d1[124-1:0]),
        .clk  (clk),
        .se   (1'b0),     .si (),          .so ()
        );

assign  imiss_strm_pcx_pkt[124-1:0] = imiss_pcx_mx_sel ?
          ifu_full_pcx_pkt_e[124-1:0] : spu_lsu_ldst_pckt_d1[124-1:0] ;

wire  [124-1:0]  fwd_int_fp_pcx_pkt ;
mux3ds #(124) mux_fwd_int_fp_pcx_pkt (
     .in0  (fwd_full_pcxpkt[124-1:0]),
     .in1  (intrpt_full_pcxpkt[124-1:0]),
     .in2  (fpop_full_pcxpkt[124-1:0]),
     .sel0 (fwd_int_fp_pcx_mx_sel[0]),
     .sel1 (fwd_int_fp_pcx_mx_sel[1]),
     .sel2 (fwd_int_fp_pcx_mx_sel[2]),
     .dout (fwd_int_fp_pcx_pkt [124-1:0])
);

//=================================================================================================
//    PCX PKT SELECTION
//=================================================================================================

assign stb_pcx_pkt[114] = lsu_stb_pcx_rvld_d1 ;                // Valid
// Support stores for now.
assign stb_pcx_pkt[113:111] = stb_rdata_ramd[74:72] ;     // Rq-type
assign stb_pcx_pkt[110] =
  // Mina the OR gate has been extended to a 3 input gate
  stb_rdata_ramd[74] | stb_rdata_ramd[73] |   // atomics
  stb_rdata_ramd[71] |  // flush inst
  stb_rdata_ramd[76];  // non-cacheable conditions from stb_ncache_pcx_rq_g 
// cpu-id will be inserted on way out of core.
assign  stb_pcx_pkt[109:108] = lsu_stb_rd_tid[1:0] ;    // TID
// bf-id is not required.
// mux will have to be placed elsewhere. (grape)
assign  stb_pcx_pkt[107] = stb_rdata_ramd[71] ; // flush
assign  stb_pcx_pkt[107-1] = 1'b0 ;
//assign  stb_pcx_pkt[`STB_PCX_WY_HI:`STB_PCX_WY_LO] = 2'b00 ;

//bug 2511
assign  stb_pcx_pkt[105:104] =
                        stb_rdata_ramd[69:68];                          // Size

//assign  stb_pcx_pkt[`STB_PCX_AD_HI:`STB_PCX_AD_LO] = stb_pcx_pkt[`STB_PCX_FLSH] ? 40'b0 :
//                        {stb_rdata_ramc[44:9],stb_rdata_ramd[67:64]} ;// Addr

assign  stb_pcx_pkt[103:64] =
                        {stb_rdata_ramc[44:9],stb_rdata_ramd[67:64]} ;// Addr


assign  stb_pcx_pkt[63:0] =
                        stb_rdata_ramd[63:0];                           // Data

assign  store_pcx_pkt[115-1:0] = stb_pcx_pkt[115-1:0] ;


assign stb_pcx_csm = stb_rcsm_ramc;


// bld addr select.
wire [1:0] bld_addr_b54 ;
assign  bld_addr_b54[1:0] =
  lsu_bld_pcx_rq ? lsu_bld_rq_addr[1:0] : load_pcx_pkt[0+5:0+4] ;

// Select between load and store outbound pkt.
// *** cpu-id currently hardwired in pkt
// *** Thrd id currently hardwired.
mux4ds  #(124) pcx_pkt_src (
  .in0  ({load_pcx_pkt[64],2'b00,
    load_pcx_pkt[47: 45],
    load_pcx_pkt[44],const_cpuid[2:0],
    ld_pcx_thrd[1:0],lsu_pcx_ld_dtag_perror_w2,
    load_pcx_pkt[62],load_pcx_pkt[63],
    load_pcx_pkt[43:42],lsu_pcx_rq_sz_b3,
    //load_pcx_pkt[`LMQ_WY_HI:`LMQ_WY_LO],1'b0,
    //load_pcx_pkt[`LMQ_SZ_HI:0],cas_pkt2_data[63:0]}), // load
    load_pcx_pkt[41:0+6], bld_addr_b54[1:0],
    load_pcx_pkt[0+3:0],cas_pkt2_data[63:0]}), // load
  .in1  ({store_pcx_pkt[114],1'b0,
  store_pcx_pkt[107], // turn into interrupt request.
    store_pcx_pkt[113:111],
    store_pcx_pkt[110], const_cpuid[2:0],
    store_pcx_pkt[109:108],
    1'b0,
    stb_rdata_ramd[70], // blk-st : Bug 3395
    stb_rdata_ramd[75],
    2'b00,
    //store_pcx_pkt[`STB_PCX_WY_HI:`STB_PCX_WY_LO],
    1'b0,store_pcx_pkt[105:0]}),     // store
  .in2  (imiss_strm_pcx_pkt[124-1:0]),   // alt src : imiss,stream.
  .in3  (fwd_int_fp_pcx_pkt[124-1:0]),   // fwd, interrupt, fpop
  .sel0 (pcx_pkt_src_sel[0]),
  .sel1 (pcx_pkt_src_sel[1]),
  .sel2 (pcx_pkt_src_sel[2]),
  .sel3 (pcx_pkt_src_sel[3]),
  .dout (pcx_pkt_data[124-1:0])
);

dff_s  #(124) pcx_xmit_ff (
        .din  (pcx_pkt_data[124-1:0]),
        .q    (spc_pcx_data_pa[124-1:0]),
        .clk  (clk),
        .se     (1'b0),     .si (),          .so ()
        );


mux4ds  #(33) pcx_csm_src (
  .in0  (load_pcx_csm), // load
  .in1  (stb_pcx_csm),     // store
  .in2  (ifu_pcx_csm),   // alt src : imiss,stream.
  .in3  ({33{1'b1}}),   // fwd, interrupt, fpop
  .sel0 (pcx_pkt_src_sel[0]),
  .sel1 (pcx_pkt_src_sel[1]),
  .sel2 (pcx_pkt_src_sel[2]),
  .sel3 (pcx_pkt_src_sel[3]),
  .dout (pcx_pkt_csm)
);

dff_s  #(33) pcx_csm_xmit_ff (
        .din  (pcx_pkt_csm),
        .q    (spc_pcx_csm_pa),
        .clk  (clk),
        .se     (1'b0),     .si (),          .so ()
        );



//  Stage to avoid critical path
/*assign  lsu_ifu_ld_icache_index[11:5] = pcx_pkt_data[`PCX_AD_LO+11:`PCX_AD_LO+5] ;
assign  lsu_ifu_ld_pcxpkt_tid[1:0] = pcx_pkt_data[`PCX_TH_HI:`PCX_TH_LO] ;*/

dff_s  #(6+3) stg_icindx (
        .din  ({pcx_pkt_data[64+(6 + 5):64+5],pcx_pkt_data[113:112]}),
        .q    ({lsu_ifu_ld_icache_index[(6 + 5):5],lsu_ifu_ld_pcxpkt_tid[1:0]}),
        .clk  (clk),
        .se     (1'b0),     .si (),          .so ()
        );

//=========================================================================================
//  VA Watchpt Reg per thread
//=========================================================================================

//VA_watchpoint_thread0
   wire        va_wtchpt0_clk ;
   wire [47:3] va_wtchpt0_addr;



clken_buf clkbf_va_wtchpt0 (
                .rclk   (clk),
                .enb_l  (lsu_va_wtchpt0_wr_en_l),
                .tmb_l  (~se),
                .clk    (va_wtchpt0_clk)
                ) ;










dff_s #(45) va_wtchpt0_ff (
        .din    (lsu_tlu_st_rs3_data_g[47:3]),
        .q      (va_wtchpt0_addr[47:3]),
        .clk    (va_wtchpt0_clk),
        .se     (1'b0),       .si (),          .so ()
        );


//VA_watchpoint_thread1
   wire        va_wtchpt1_clk ;
   wire [47:3] va_wtchpt1_addr;



clken_buf clkbf_va_wtchpt1 (
                .rclk   (clk),
                .enb_l  (lsu_va_wtchpt1_wr_en_l),
                .tmb_l  (~se),
                .clk    (va_wtchpt1_clk)
                ) ;










dff_s #(45) va_wtchpt1_ff (
        .din    (lsu_tlu_st_rs3_data_g[47:3]),
        .q      (va_wtchpt1_addr[47:3]),
        .clk    (va_wtchpt1_clk),
        .se     (1'b0),       .si (),          .so ()
        );


//VA_watchpoint_thread2
   wire        va_wtchpt2_clk ;
   wire [47:3] va_wtchpt2_addr;



clken_buf clkbf_va_wtchpt2 (
                .rclk   (clk),
                .enb_l  (lsu_va_wtchpt2_wr_en_l),
                .tmb_l  (~se),
                .clk    (va_wtchpt2_clk)
                ) ;










dff_s #(45) va_wtchpt2_ff (
        .din    (lsu_tlu_st_rs3_data_g[47:3]),
        .q      (va_wtchpt2_addr[47:3]),
        .clk    (va_wtchpt2_clk),
        .se     (1'b0),       .si (),          .so ()
        );


//VA_watchpoint_thread3
   wire        va_wtchpt3_clk ;
   wire [47:3] va_wtchpt3_addr;



clken_buf clkbf_va_wtchpt3 (
                .rclk   (clk),
                .enb_l  (lsu_va_wtchpt3_wr_en_l),
                .tmb_l  (~se),
                .clk    (va_wtchpt3_clk)
                ) ;










dff_s #(45) va_wtchpt3_ff (
        .din    (lsu_tlu_st_rs3_data_g[47:3]),
        .q      (va_wtchpt3_addr[47:3]),
        .clk    (va_wtchpt3_clk),
        .se     (1'b0),       .si (),          .so ()
        );


   wire [47:3] va_wtchpt_addr;

mux4ds #(45)     va_wtchpt_mx_m (
        .in0    (va_wtchpt0_addr[47:3]),
        .in1    (va_wtchpt1_addr[47:3]),
        .in2    (va_wtchpt2_addr[47:3]),
        .in3    (va_wtchpt3_addr[47:3]),
        .sel0   (thread0_m),
        .sel1   (thread1_m),
        .sel2   (thread2_m),
        .sel3   (thread3_m),
        .dout   (va_wtchpt_addr[47:3])
        );

mux4ds #(45)     va_wtchpt_mx_g (
        .in0    (va_wtchpt0_addr[47:3]),
        .in1    (va_wtchpt1_addr[47:3]),
        .in2    (va_wtchpt2_addr[47:3]),
        .in3    (va_wtchpt3_addr[47:3]),
        .sel0   (thread0_g),
        .sel1   (thread1_g),
        .sel2   (thread2_g),
        .sel3   (thread3_g),
        .dout   (lsu_va_wtchpt_addr[47:3])
        );

//VA wtchpt comparison at M stage
//assign lsu_va_match_m = (lsu_ldst_va_m[47:3] == va_wtchpt_addr[47:3]);
//bug6480/eco6623
assign lsu_va_match_b47_b32_m = (lsu_ldst_va_m[47:32] == va_wtchpt_addr[47:32]);
assign lsu_va_match_b31_b3_m =  (lsu_ldst_va_m[31:3 ] == va_wtchpt_addr[31:3 ]);

//====================================================================
//dc_fill CP
   wire [63:0] l2fill_data_m;

//dff #(64) stgm_l2fd (
//        .din    (lsu_l2fill_data[63:0]),
//        .q      (l2fill_data_m[63:0]),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );
   assign      l2fill_data_m[63:0] = lsu_l2fill_data[63:0];


   wire [63:0] ld_byp_data_m;

 // Use two threads unless this is defined

mux2ds  #(64) ld_byp_mx (
  .in0  (lmq0_bypass_data[63:0]),
  .in1  (lmq1_bypass_data[63:0]),
  .sel0 (ld_thrd_byp_sel_m[0]),
  .sel1 (ld_thrd_byp_sel_m[1]),
  .dout (ld_byp_data_m[63:0])
);














































 // `ifndef CONFIG_NUM_THREADS

assign dcache_alt_data_w0_m[63:0] =
       l2fill_vld_m ? l2fill_data_m[63:0] :
                      ld_byp_data_m[63:0];

//assign  lsu_l2fill_or_byp_msb_m[7:0]
//  = {lsu_l2fill_or_byp_data_m[63],
//     lsu_l2fill_or_byp_data_m[55],
//     lsu_l2fill_or_byp_data_m[47],
//     lsu_l2fill_or_byp_data_m[39],
//     lsu_l2fill_or_byp_data_m[31],
//     lsu_l2fill_or_byp_data_m[23],
//     lsu_l2fill_or_byp_data_m[15],
//     lsu_l2fill_or_byp_data_m[07]} ;
//====================================================================

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_qdp2.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Module Name:  LSU_QDP2
//  Description:  LSU CPX Datapath.
*/
////////////////////////////////////////////////////////////////////////
// header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
                  // time scale definition
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


 
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications





module lsu_qdp2 ( /*AUTOARG*/
   // Outputs
   so, lsu_l2fill_data, dfq_wdata, dfq_tid, lsu_dcache_fill_data_e, 
   lsu_ifill_pkt, lsu_pcx_fwd_pkt, lsu_cpx_pkt_strm_ack, 
   lsu_cpx_pkt_vld, lsu_cpx_pkt_atm_st_cmplt, lsu_cpx_pkt_tid, 
   lsu_cpx_pkt_invwy, lsu_cpx_pkt_inv_pa, lsu_cpx_pkt_l2miss, 
   lsu_dfq_byp_invwy_vld, lsu_dfq_byp_type, lsu_dfq_byp_flush, 
   lsu_dfq_byp_tid, 
   // lsu_cpu_inv_data_b13to9, lsu_cpu_inv_data_b7to2, 
   // lsu_cpu_inv_data_b0,
   lsu_cpu_inv_data_val, lsu_cpu_inv_data_way,

   lsu_iobrdge_wr_data, lsu_iobrdge_tap_rq_type, 
   lsu_cpx_pkt_perror_dinv, lsu_cpx_pkt_perror_iinv, 
   lsu_cpx_pkt_perror_set, lsu_cpx_pkt_ld_err, lsu_dfq_byp_binit_st, 
   lsu_cpx_pkt_binit_st, lsu_cpx_pkt_prefetch, lsu_cpx_pkt_prefetch2, 
   lsu_dfq_byp_cpx_inv, lsu_dfq_byp_stack_adr_b54, 
   lsu_dfq_byp_stack_wrway, lsu_dfq_byp_atm, dcache_iob_addr_e, 
   st_dcfill_addr, lsu_st_way_e, lsu_dcache_iob_way_e, 
   lsu_st_dcfill_size_e, lsu_cpx_pkt_ifill_type, lsu_cpx_pkt_atomic, 
   // Inputs
   rst_tri_en, rclk, si, se, lsu_dfill_data_sel_hi, dfq_byp_ff_en, 
   dfq_rd_vld_d1, dfq_rdata, cpx_spc_data_cx, stb_rdata_ramd_buf, 
   stb_rdata_ramd_b74_buf, stb_rdata_ramc_buf, lsu_stb_pcx_rvld_d1, 
   lsu_diagnstc_wr_data_e, lsu_diagnstc_dc_prty_invrt_e, 
   mbist_write_data, cpx_fwd_pkt_en_cx, lsu_cpu_dcd_sel, 
   lsu_cpu_uhlf_sel, lsu_cpxpkt_type_dcd_cx, lsu_dc_iob_access_e, 
   lsu_dcfill_data_mx_sel_e, lsu_cpx_spc_inv_vld, lsu_cpx_thrdid, 
   lsu_cpx_stack_dcfill_vld, pcx_rq_for_stb_d1, lsu_dfq_ld_vld, 
   lsu_dfq_st_vld, lsu_dfq_ldst_vld
   ) ;  

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
//
   input rst_tri_en;
   
input                     rclk ;
input                     si;
input                     se;
output                    so;

input                       lsu_dfill_data_sel_hi ; // select hi or low order 8B. 
//input                       dcfill_src_dfq_sel ;
input                       dfq_byp_ff_en ;
input                       dfq_rd_vld_d1 ;
input [151:0]        dfq_rdata ;             // dfq rd output
input [145-1:0]      cpx_spc_data_cx;        // cpx to processor pkt
//input [2:0]                 stb_dfq_rd_id ;         // stb entry id 
input [69:0]                stb_rdata_ramd_buf ;        // stb0 data ram output.
input                       stb_rdata_ramd_b74_buf ;        // stb0 data ram output.
input [14:9]                stb_rdata_ramc_buf ;        // stb0 tag ram output.
input                       lsu_stb_pcx_rvld_d1 ;   // stb has been read-delayby1cycle
//input                       lsu_stb_dfq_rvld ;      // wr to dfq stb bypass ff
//input [1:0]                 lmq_pcx_pkt_sz ;
//input [39:0]                lmq_pcx_pkt_addr ;

// diagnostic write information
//input                       lsu_diagnstc_wr_src_sel_e ;    // diagnstc write - diag/store
input  [63:0]               lsu_diagnstc_wr_data_e ;       // Store data
input  [7:0]                lsu_diagnstc_dc_prty_invrt_e ; // invert parity of dw
//input  [3:0]                lsu_diagnstc_wr_way_e ;        // cache way to be written
//input  [`L1D_ADDRESS_HI:0]               lsu_diagnstc_wr_addr_e ;       // address

//input                     lsu_ifill_pkt_vld ;     // ifill pkt vld
//input                     lsu_bist_wvld_e ;       // bist write to dcache
//input                     lsu_bist_rvld_e ;       // bist read from dcache  

//input   [6:0]             mbist_dcache_index ;    // bist rd/wr address 
//input                     mbist_dcache_word;
//input   [1:0]             mbist_dcache_way;   
input   [7:0]             mbist_write_data ;      // bist wdata
   
input                     cpx_fwd_pkt_en_cx ;     // cpx fwd reply/req
input   [7:0]             lsu_cpu_dcd_sel ;
input                     lsu_cpu_uhlf_sel ;
input   [5:0]             lsu_cpxpkt_type_dcd_cx ;
//input                     lsu_st_wr_sel_e ;
//input   [1:0]             lmq_ld_way ;
//input   [1:0]             lsu_st_ack_wrwy ;       // cache set way to write to.  
//input   [1:0]             lsu_st_ack_addr_b54 ;
//input   [1:0]             lsu_stb_rd_tid ;
input			  lsu_dc_iob_access_e ;	// iob read/write of dcache

//input                     tmb_l;
//input   [3:0]             lsu_dcfill_mx_sel_e;
//input                     lsu_dcfill_addr_mx_sel_e;
input                     lsu_dcfill_data_mx_sel_e;

input                     lsu_cpx_spc_inv_vld;
input   [3:0]             lsu_cpx_thrdid;
input                     lsu_cpx_stack_dcfill_vld ;
input   [3:0]             pcx_rq_for_stb_d1;

input                     lsu_dfq_ld_vld ;
input                     lsu_dfq_st_vld ;
input                     lsu_dfq_ldst_vld ;

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics
//

output  [63:0]            lsu_l2fill_data ;       // dfill data for write to irf

output  [151:0]    dfq_wdata ;
output  [1:0]             dfq_tid ;               // thread-id for load at head of DFQ.

output  [143:0]           lsu_dcache_fill_data_e ;// store-write/ld-miss fill 

output  [144-1:0]  lsu_ifill_pkt ;
output  [107:0]           lsu_pcx_fwd_pkt ;       // local fwd reply/req 
output               	  lsu_cpx_pkt_strm_ack ;
output                    lsu_cpx_pkt_vld ;
output                    lsu_cpx_pkt_atm_st_cmplt ;
output  [1:0]             lsu_cpx_pkt_tid ;
output  [2-1:0]             lsu_cpx_pkt_invwy ;     // invalidate way
output  [(6 + 4)-6:0]             lsu_cpx_pkt_inv_pa ;    // invalidate pa [10:6]
output			  lsu_cpx_pkt_l2miss ;	// ld req missed in L2
output                    lsu_dfq_byp_invwy_vld ;
output  [5:0]             lsu_dfq_byp_type ;
output                    lsu_dfq_byp_flush ;
//output  [2:0]             lsu_dfq_byp_cpuid ;
output  [1:0]             lsu_dfq_byp_tid ;
//output  [13:0]            lsu_cpu_inv_data ;
// output  [13:9]            lsu_cpu_inv_data_b13to9 ;
// output  [7:2]             lsu_cpu_inv_data_b7to2 ;
// output                    lsu_cpu_inv_data_b0 ;
output                        lsu_cpu_inv_data_val ;
output  [2-1:0]  lsu_cpu_inv_data_way ;
//output                    lsu_dfq_byp_stquad_pkt2 ;
//output                    lsu_cpx_pkt_stquad_pkt2 ;
output  [43:0]            lsu_iobrdge_wr_data ;
output  [8:0]             lsu_iobrdge_tap_rq_type ;
//output                    lsu_dfq_byp_perror_dinv ;  // dtag perror corr. st ack
//output                    lsu_dfq_byp_perror_iinv ;  // itag perror corr. st ack
output                    lsu_cpx_pkt_perror_dinv ;  // dtag perror corr. st ack
output                    lsu_cpx_pkt_perror_iinv ;  // itag perror corr. st ack
output  [1:0]             lsu_cpx_pkt_perror_set ;  // dtag perror - spec. b54
output  [1:0]             lsu_cpx_pkt_ld_err ;      // err field - cpx ld pkt
output			  lsu_dfq_byp_binit_st ;	// blk-init st in bypass.
output			  lsu_cpx_pkt_binit_st ;    // blk-init store
output			  lsu_cpx_pkt_prefetch;    // prefetch
output			  lsu_cpx_pkt_prefetch2;   // prefetch - for dctl

output                    lsu_dfq_byp_cpx_inv;
//output			  lsu_dfq_byp_stack_dcfill_vld;
output  [1:0]             lsu_dfq_byp_stack_adr_b54;
output  [1:0]             lsu_dfq_byp_stack_wrway;
output                    lsu_dfq_byp_atm;

   //dcache_fill_addr_e change
   output [(6 + 4)-3:0]           dcache_iob_addr_e;
   output [(6 + 4):0]          st_dcfill_addr;

   output [2-1:0]           lsu_st_way_e;
   output [2-1:0]           lsu_dcache_iob_way_e;

   output [1:0]           lsu_st_dcfill_size_e;
   
/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics
//wire  [`STB_PCX_WIDTH-1:0]  stb_pcx_pkt ;
//wire  [`STB_DFQ_WIDTH-1:0]  stb_dfq_pkt_data ;
wire  [83-1:0]  stb_dfq_data_in ;
//wire  [`DFQ_WIDTH-1:0]  cpx_dfq_data ;
//wire  [`DFQ_WIDTH-1:0]  cpx_dfq_data_d1 ;
//wire  [`CPX_WIDTH-1:0]  cpx_data_cx_d1 ;
//wire        cpx_st_cmplt_d1 ;
wire  [151:0]  dfq_byp_mx_data ;
wire  [151-1:0]    dfq_byp_ff_data ;
//wire  [`STB_DFQ_WIDTH-1:0]  store_dfq_pkt ;
wire  [127:0]   st_dcfill_data ;
wire  [63:0]      dcache_wr_data ;
wire  [127:0]   ldinv_dcfill_data ;
//wire  [`LMQ_WIDTH-1:0]  lmq0_pcx_pkt, lmq1_pcx_pkt ;
//wire  [`LMQ_WIDTH-1:0]  lmq2_pcx_pkt, lmq3_pcx_pkt ;
wire  [127:0] lsu_dcfill_data ;
wire  [15:0]      dcache_wr_parity_mod ;
//wire  [3:0]     bist_rsel_way_e ;
wire  [107:0]     cpx_fwd_pkt_din ;

//wire [3:0]     bist_rsel_way_m ;
//wire [3:0]     lsu_bist_rsel_way_wb ;  // way select for read
wire  [2-1:0]  cpx_st_dcfill_wrway;
wire  [82:0]   stb_dcfill_data_mx;
wire           clk;
// wire  [13:0]            lsu_cpu_inv_data ;

assign  clk = rclk;


//=================================================================================================
//      STB Datapath
//=================================================================================================

// PCX PKT FORMATTING
// THREAD0
//assign stb_pcx_pkt[`STB_PCX_VLD] = lsu_stb_pcx_rvld_d1 ;    // Valid
// Support stores for now.
//assign stb_pcx_pkt[`STB_PCX_RQ_HI:`STB_PCX_RQ_LO] = stb_rdata_ramd[74:72] ; // Rq-type
//assign stb_pcx_pkt[`STB_PCX_NC] = stb_rdata_ramd[74] ;  // NC
// cpu-id will be inserted on way out of core.
//assign  stb_pcx_pkt[`STB_PCX_TH_HI:`STB_PCX_TH_LO] = lsu_stb_rd_tid[1:0] ;  // TID
// bf-id is not required.
//assign  stb_pcx_pkt[`STB_PCX_WY_HI:`STB_PCX_WY_LO] = stb_rdata_ramd[71:70] ;  // WAY
//assign  stb_pcx_pkt[`STB_PCX_SZ_HI:`STB_PCX_SZ_LO] = 
//      stb_rdata_ramd[69:68];        // Size
//assign  stb_pcx_pkt[`STB_PCX_AD_HI:`STB_PCX_AD_LO] = 
//      {stb_rdata_ramc[44:9],stb_rdata_ramd[67:64]} ;// Addr        
//assign  stb_pcx_pkt[`STB_PCX_DA_HI:`STB_PCX_DA_LO] = 
//      stb_rdata_ramd[63:0];         // Data   

// STB to DFQ Data Formatting
// THREAD0
assign  stb_dfq_data_in[83-1:0] =
  {lsu_stb_pcx_rvld_d1,                         // 82:82 vld  //stb_pcx_pkt[`STB_PCX_VLD],
  stb_rdata_ramd_b74_buf,                           // 81:81 ??   //stb_rdata_ramd[74],
  2'b00,                                        // 80:79 not used
  //stb_pcx_pkt[`STB_PCX_WY_HI:`STB_PCX_WY_LO],
  3'b000,                                       // 78:76 instead of stb_dfq_rd_id[2:0],
  stb_rdata_ramd_buf[69:68],                        // 75:74 size //stb_pcx_pkt[`STB_PCX_SZ_HI:`STB_PCX_SZ_LO], 
  {stb_rdata_ramc_buf[14:9],stb_rdata_ramd_buf[67:64]}, // 73:64 Addr //stb_pcx_pkt[`STB_PCX_AD_LO+9:`STB_PCX_AD_LO],
  stb_rdata_ramd_buf[63:0]};                        // 63:0  data  //stb_pcx_pkt[`STB_PCX_DA_HI:`STB_PCX_DA_LO]};


// STB DATA BYPASS FLOP
// Data is read out on read for pcx. The data is then
// bypassed to the dfq when the st-ack is received.
//wire  [3:0]   pcx_rq_for_stb_d1;
wire  [3:0]   clk_stb_data;
wire  [82:0]  stb_dfq_pkt_data0,
                        stb_dfq_pkt_data1,
                        stb_dfq_pkt_data2,
                        stb_dfq_pkt_data3;

// timing fix: 9/15/03 - reduce loading on pcx_rq_for_stb[3:0] to stb_clt[0-3]. it had FO2 (stb_ctl,qdp2 - cap=0.5-0.8)
//             move the flop from qdp2 to qctl1

//flop pcx rq to read stb data
//dff  #(4) pcx_rq_for_stb_ff (                       
//           .din  (pcx_rq_for_stb[3:0]),
//           .q    (pcx_rq_for_stb_d1[3:0]),
//           .clk  (clk), 
//           .se   (1'b0),       .si (),          .so ());                                

//dffe  #(83) stb_dfq_byp_ff (
//        .din  (stb_dfq_data_in[`STB_DFQ_VLD:0]), 
//  .q    (stb_dfq_pkt_data[`STB_DFQ_VLD:0]),
//        .en   (lsu_stb_dfq_rvld), .clk (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

//THREAD0


clken_buf stb_dfq_byp0_clken(                
          .clk(clk_stb_data[0]),             
          .rclk(clk),                         
          .enb_l(~pcx_rq_for_stb_d1[0]),           
          .tmb_l(~se));                       

                                                 







dff_s  #(83) stb_dfq_byp0_ff (                       
           .din  (stb_dfq_data_in[82:0]),
           .q    (stb_dfq_pkt_data0[82:0]),
           .clk  (clk_stb_data[0]), 
           .se   (1'b0),       .si (),          .so ());                                


//THREAD1


clken_buf stb_dfq_byp1_clken(                
          .clk(clk_stb_data[1]),             
          .rclk(clk),                         
          .enb_l(~pcx_rq_for_stb_d1[1]),           
          .tmb_l(~se));                       

                                                 







dff_s  #(83) stb_dfq_byp1_ff (                       
           .din  (stb_dfq_data_in[82:0]),
           .q    (stb_dfq_pkt_data1[82:0]),
           .clk  (clk_stb_data[1]), 
           .se   (1'b0),       .si (),          .so ());                                


//THREAD2


clken_buf stb_dfq_byp2_clken(                
          .clk(clk_stb_data[2]),             
          .rclk(clk),                         
          .enb_l(~pcx_rq_for_stb_d1[2]),           
          .tmb_l(~se));                       

                                                 







dff_s  #(83) stb_dfq_byp2_ff (                       
           .din  (stb_dfq_data_in[82:0]),
           .q    (stb_dfq_pkt_data2[82:0]),
           .clk  (clk_stb_data[2]), 
           .se   (1'b0),       .si (),          .so ());                                


//THREAD3


clken_buf stb_dfq_byp3_clken(                
          .clk(clk_stb_data[3]),             
          .rclk(clk),                         
          .enb_l(~pcx_rq_for_stb_d1[3]),           
          .tmb_l(~se));                       

                                                 







dff_s  #(83) stb_dfq_byp3_ff (                       
           .din  (stb_dfq_data_in[82:0]),
           .q    (stb_dfq_pkt_data3[82:0]),
           .clk  (clk_stb_data[3]), 
           .se   (1'b0),       .si (),          .so ());                                


// MUX the store data if cpx_pkt==st_ack w/ dcfill vld=1
mux4ds  #(82+1) stb_data_mx (
  .in0  (stb_dfq_pkt_data0[82:0]),
  .in1  (stb_dfq_pkt_data1[82:0]),
  .in2  (stb_dfq_pkt_data2[82:0]),
  .in3  (stb_dfq_pkt_data3[82:0]),
  .sel0 (lsu_cpx_thrdid[0]),  
  .sel1 (lsu_cpx_thrdid[1]),
  .sel2 (lsu_cpx_thrdid[2]),
  .sel3 (lsu_cpx_thrdid[3]),
  .dout (stb_dcfill_data_mx[82:0])
);

//NOTE: mux this raw data w/ modified data to generate dfq input and feed into dfq_wdata




//=================================================================================================
//    FWD PKT - REQ/REPLY
//=================================================================================================

// Design Note !! - Bus can be decreased - do not have to keep tag.

// TAP ACCESS FORMAT
// BEGIN (OLD)
// Control bits :
// R/W,TID,BIST,MARGIN,DEFEATURE,PC (R=1,W=0)
// These 7b are mapped to bits 70:64 of the cpx pkt.
// (R/W is the highest order bit). 
// *Note that a write to pc is ignored by hardware.
// *The cpx-reply will not contain the control information.
// *TID(Thread id) applies only to pc and defeature.
// Data bits :
// PC(48b),Margin(36b),Bist-Ctl(14b),Defeature(4b).
// The largest field of 48b is mapped to bits 47:0 of the cpx pkt.
// END (OLD)

// Control bits (mapped to data[127:96] of cpx packet):
// L1I data,L1D data,BIST,MARGIN,DEFEATURE,PC,TID[1:0]
// These 8b are mapped to bits 103:96 of the cpx pkt.
// Unused bits are zeros.
// (TID is the lowest order 2 bits).
// *Note that a write to pc is ignored by hardware.
// *The cpx-reply will not contain the control information.
// *TID(Thread id) applies only to pc and defeature.
//
// Address bits (mapped to data[95:64] of cpx packet):
// This is used to access the L1 cache arrays.  This field
// is a dont-care for the bist/margin/defeature/pc ASIs.
// Only the lower 32 address bits are specified here.
// The core (lsu) will pad zeros create a 64-bit address.
//
// Data bits (mapped to data[63:0] of cpx packet):
// PC(48b),Margin(36b),Bist-Ctl(14b),Defeature(4b).
// The largest field of 48b is mapped to bits 47:0 of the cpx pkt.


// Formatted to contain fwd req which is of largest size.
// Truncate address !!! 40b should not be required.
assign  cpx_fwd_pkt_din[107:0] = 
  {
  cpx_spc_data_cx[136], // r/!w   (1b)
  cpx_spc_data_cx[133:131], // src/tar  (3b)
  cpx_spc_data_cx[103:0]    // 64b data + 40b addr (104b)
  } ;

// Contains cpx fwd reply or req
//dffe  #(108) fwdpkt_ff  (
//        .din  (cpx_fwd_pkt_din[107:0]), 
//  .q    (lsu_pcx_fwd_pkt[107:0]),
//        .en   (cpx_fwd_pkt_en_cx), 
//  .clk  (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

wire clk_cpx_fwd_pkt_en_cx;


clken_buf fwdpkt_clken(                             
          .clk(clk_cpx_fwd_pkt_en_cx),               
          .rclk(clk),                                 
          .enb_l(~cpx_fwd_pkt_en_cx),                  
          .tmb_l(~se));                               

                                                         







dff_s  #(108) fwdpkt_ff  (                                  
            .din  (cpx_fwd_pkt_din[107:0]),                
            .q    (lsu_pcx_fwd_pkt[107:0]),                 
            .clk  (clk_cpx_fwd_pkt_en_cx),                   
            .se     (1'b0),       .si (),          .so ());   



// New mapping for address bits given that tag is gone. (OBSOLETE)
// pkt[74:73] - Way
// pkt[72:65] - Set Index
// pkt[64] - Word
// New mapping - based on 0-in testing, alignment with PRM.
// pkt[76:75] - Way
// pkt[74:68] - Set Index
// pkt[67] -DWord

wire [(6 + 4)-3:0] dcache_iob_addr_e ;
assign	dcache_iob_addr_e[(6 + 4)-3:0] = lsu_pcx_fwd_pkt[74:67] ; // trinn: need to lookup and change the pcx fwd packet format, but the feature is probably deprecated in piton

//wire [3:0] dcache_iob_wy_e ; 
//assign	dcache_iob_wy_e[0] = ~lsu_pcx_fwd_pkt[76] & ~lsu_pcx_fwd_pkt[75] ;
//assign	dcache_iob_wy_e[1] = ~lsu_pcx_fwd_pkt[76] &  lsu_pcx_fwd_pkt[75] ;
//assign	dcache_iob_wy_e[2] =  lsu_pcx_fwd_pkt[76] & ~lsu_pcx_fwd_pkt[75] ;
//assign	dcache_iob_wy_e[3] =  lsu_pcx_fwd_pkt[76] &  lsu_pcx_fwd_pkt[75] ;

wire [1:0] lsu_pcx_fwd_pkt_iob_way = {lsu_pcx_fwd_pkt[76],  lsu_pcx_fwd_pkt[75]}; // trin reconfig
assign lsu_dcache_iob_way_e[2-1:0] =  lsu_pcx_fwd_pkt_iob_way[2-1:0];
  
wire [63:0] dcache_iob_data_e ; 
assign	dcache_iob_data_e[63:0] = lsu_pcx_fwd_pkt[63:0] ;

assign  lsu_iobrdge_wr_data[43:0] = lsu_pcx_fwd_pkt[43:0] ;
assign  lsu_iobrdge_tap_rq_type[8:0] = {lsu_pcx_fwd_pkt[107],lsu_pcx_fwd_pkt[103:96]} ;

//=================================================================================================
//    DFQ PKT SELECTION
//=================================================================================================

// There are two sources :
// - from the ccx - load,inv 
// - from the stb - ack'ed store update.
// ** store updates do not have to be inserted into DFQ for ordering purposes. An inv will
// clear stale data in the stb and bypass flops to ensure TSO.

// to be written to dfq if bypass full else wr to byp mx.
//assign  dfq_wdata[`DFQ_WIDTH:0] = 
//  {lsu_cpx_spc_inv_vld,lsu_cpxpkt_type_dcd_cx[5:0],cpx_spc_data_cx[`CPX_WIDTH-1:0]};
//  //{{(`DFQ_WIDTH-`CPX_WIDTH)1'b0},cpx_spc_data_cx[`CPX_WIDTH-1:0]},

wire  [151:0]  dfq_st_data,dfq_cpx_raw_wdata;
wire  [1:0]           cpx_st_ack_addr_b54;

assign  dfq_cpx_raw_wdata[151:0] = 
  {lsu_cpx_spc_inv_vld,lsu_cpxpkt_type_dcd_cx[5:0],cpx_spc_data_cx[145-1:0]};

wire [1:0] cpx_st_dcfill_wrway_trin = cpx_st_dcfill_wrway; // trin reconfig

assign  dfq_st_data[151:0]  =  
        {lsu_cpx_spc_inv_vld,lsu_cpxpkt_type_dcd_cx[5:0],
         cpx_spc_data_cx[145-1:87],
         cpx_st_ack_addr_b54[1:0],             // 86:85
         cpx_st_dcfill_wrway_trin[1:0],             // 84:83 // trin reconfig
         stb_dcfill_data_mx[82:0]};  // 82:0

mux2ds  #(151+1) dfq_st_data_mx (
  .in0  (dfq_st_data[151:0]),
  .in1  (dfq_cpx_raw_wdata[151:0]),
  .sel0 (lsu_cpx_stack_dcfill_vld),  
  .sel1 (~lsu_cpx_stack_dcfill_vld),
  .dout (dfq_wdata[151:0])
);

//timing fix: 05/31/03: decouple byp mux from lsu_cpx_stack_dcfill_vld
//            i.e. replace dfq_wdata w/ dfq_cpx_raw_wdata in byp mux
// select between dfq output and cpx bypass.
mux2ds  #(151+1) dfq_byp_mx (
  .in0  (dfq_rdata[151:0]),
  .in1  (dfq_cpx_raw_wdata[151:0]),
  .sel0 (dfq_rd_vld_d1),  
  .sel1 (~dfq_rd_vld_d1),
  .dout (dfq_byp_mx_data[151:0])
);

assign  lsu_dfq_byp_cpx_inv     =   dfq_byp_mx_data[151];
assign  lsu_dfq_byp_tid[1:0]    =   dfq_byp_mx_data[135:134] ;
//assign  lsu_dfq_byp_cpuid[2:0]  =   dfq_byp_mx_data[`CPX_INV_CID_HI:`CPX_INV_CID_LO] ;
assign  lsu_dfq_byp_flush = 	dfq_byp_mx_data[136] ;
assign  lsu_dfq_byp_invwy_vld = dfq_byp_mx_data[133] ;

//assign  lsu_dfq_byp_type[5:0]   =   dfq_byp_mx_data[`DFQ_WIDTH-1:`DFQ_WIDTH-6] ;
assign  lsu_dfq_byp_type[5:3]   =   dfq_byp_mx_data[151-1:151-3] ;
assign  lsu_dfq_byp_type[2]   =   dfq_byp_mx_data[151-4] & dfq_rd_vld_d1;
assign  lsu_dfq_byp_type[1:0]   =   dfq_byp_mx_data[151-5:151-6] ;

//assign  lsu_dfq_byp_stquad_pkt2 =   dfq_byp_mx_data[130] ;
assign  lsu_dfq_byp_binit_st =   dfq_byp_mx_data[125] ;
//assign  lsu_dfq_byp_perror_iinv    = dfq_byp_mx_data[`CPX_PERR_DINV+1] ;
//assign  lsu_dfq_byp_perror_dinv    = dfq_byp_mx_data[`CPX_PERR_DINV] ;
//assign  lsu_dfq_byp_stack_dcfill_vld =   dfq_byp_mx_data[87] ;
assign  lsu_dfq_byp_stack_adr_b54[1:0] =   dfq_byp_mx_data[86:85] ;
assign  lsu_dfq_byp_stack_wrway[1:0] =   dfq_byp_mx_data[84:83] ;

assign  lsu_ifill_pkt[144-1:0] = dfq_byp_mx_data[144-1:0] ;
//assign  lsu_ifill_pkt[`CPX_WIDTH-1:0] = {lsu_ifill_pkt_vld,dfq_byp_mx_data[`CPX_VLD-1:0]} ;

assign  lsu_dfq_byp_atm  = dfq_byp_mx_data[129] ;

// Decode in qctl !!!
//assign  dfq_byp_tid[1:0] = dfq_byp_mx_data[`CPX_TH_HI:`CPX_TH_LO] ;
//assign  dfq_byp_tid[1:0] = dfq_byp_mx_data[`DFQ_TH_HI:`DFQ_TH_LO] ;

// Stage dfq output
// In case of multiple inv or other such cases, pkt will be held in
// byp ff until pkt completely utilized.
//dffe  #(`DFQ_WIDTH) dfq_data_stg (
//        .din  (dfq_byp_mx_data[`DFQ_WIDTH-1:0]),
//  .q    (dfq_byp_ff_data[`DFQ_WIDTH-1:0]),
//        .en (dfq_byp_ff_en),  .clk  (clk),
//        .se     (1'b0),     .si (),          .so ()
//);

wire clk_dfq_byp_ff_en;


clken_buf dfq_byp_ff_en_clken(                     
          .clk(clk_dfq_byp_ff_en),                  
          .rclk(clk),                                
          .enb_l(~dfq_byp_ff_en),                     
          .tmb_l(~se));                              

                                                        







dff_s  #(151) dfq_data_stg (                        
                  .din  (dfq_byp_mx_data[151-1:0]),
                  .q    (dfq_byp_ff_data[151-1:0]),
                  .clk  (clk_dfq_byp_ff_en),
                  .se   (1'b0),     .si (),          .so ());



// To be decoded in qctl
//assign  lsu_st_cmplt_type = dfq_byp_ff_data[`DFQ_ST_CMPLT];

assign  dfq_tid[1:0] = dfq_byp_ff_data[135:134] ;

output    lsu_cpx_pkt_ifill_type;
output    lsu_cpx_pkt_atomic ;

// Tri: be careful with CPX packet because some fields are not parameterized
// Should some of these be in-flight ?
//assign  lsu_cpx_pkt_rqtype[3:0]   = dfq_byp_ff_data[`CPX_RQ_HI:`CPX_RQ_LO] ;
assign  lsu_cpx_pkt_ifill_type    = dfq_byp_ff_data[151-2];
assign  lsu_cpx_pkt_tid[1:0]      = dfq_byp_ff_data[135:134] ;
assign  lsu_cpx_pkt_vld     = dfq_byp_ff_data[144] ;
assign  lsu_cpx_pkt_atm_st_cmplt  = dfq_byp_ff_data[129] ;

wire [1:0] lsu_cpx_pkt_invwy_trin = dfq_byp_ff_data[132:131]; // trin reconfig
assign  lsu_cpx_pkt_invwy[2-1:0]    = lsu_cpx_pkt_invwy_trin[2-1:0] ; // trin reconfig: not enough way bits
// Upper 6bits are used to store decoded request type information.
assign  lsu_cpx_pkt_strm_ack   = dfq_byp_ff_data[151-5];
//assign  lsu_cpx_pkt_inv_pa[4:0]   = dfq_byp_ff_data[`CPX_INV_PA_HI-1:`CPX_INV_PA_LO];  //!!

wire [15:6] dfq_byp_ff_data_addr_15_6;
assign dfq_byp_ff_data_addr_15_6 = {dfq_byp_ff_data[27:24],
                                          dfq_byp_ff_data[117:112]};

assign  lsu_cpx_pkt_inv_pa[(6 + 4)-6:0]   = dfq_byp_ff_data_addr_15_6[(6 + 4):6];
assign  lsu_cpx_pkt_atomic    = dfq_byp_ff_data[129]  | //atomic st ack
            dfq_byp_ff_data[131]  ; //stquad pkt1
//assign  lsu_cpx_pkt_stquad_pkt2   = dfq_byp_ff_data[130] ;
assign  lsu_cpx_pkt_binit_st   = dfq_byp_ff_data[125] ;
assign  lsu_cpx_pkt_prefetch = dfq_byp_ff_data[128] ; // for qctl2
assign  lsu_cpx_pkt_prefetch2 = dfq_byp_ff_data[128] ;  // for dctl
//assign	lsu_spu_strm_st = dfq_byp_ff_data[134] ; // strm store ack (vs. ma)

assign  lsu_cpx_pkt_perror_iinv    = dfq_byp_ff_data[123+1] ;
assign  lsu_cpx_pkt_perror_dinv    = dfq_byp_ff_data[123] ;
assign  lsu_cpx_pkt_perror_set[1:0] = 
	dfq_byp_ff_data[122:121] ;

assign  lsu_cpx_pkt_ld_err[1:0] = dfq_byp_ff_data[138:137] ;  
assign  lsu_cpx_pkt_l2miss = dfq_byp_ff_data[139] ;  


//=================================================================================================
//      DFQ OUTPUT - LOCAL PROCESSING
//=================================================================================================


// assign lsu_cpu_inv_data = {dfq_byp_mx_data[`CPX_A11_C0_HI:`CPX_A11_C0_LO],
//                   dfq_byp_mx_data[`CPX_A10_C0_HI:`CPX_A10_C0_LO],
//                   dfq_byp_mx_data[`CPX_A01_C0_HI:`CPX_A01_C0_LO],
//                   dfq_byp_mx_data[`CPX_A00_C0_HI:`CPX_A00_C0_LO]};

// assign  lsu_cpu_inv_data_b13to9[13:9]  =  lsu_cpu_inv_data[13:9] ;
// assign  lsu_cpu_inv_data_b7to2[7:2]  =  lsu_cpu_inv_data[7:2] ;
// assign  lsu_cpu_inv_data_b0  =  lsu_cpu_inv_data[0] ;

assign lsu_cpu_inv_data_val = dfq_byp_mx_data[0];
wire [3:0] dfq_byp_mx_data_inv_way = dfq_byp_mx_data[5:2]; 
assign lsu_cpu_inv_data_way[2-1:0] = dfq_byp_mx_data_inv_way[2-1:0]; 

// same structure as above for st data write way
// wire  [13:0]  cpx_st_dcfill_wrway_sel;

// assign cpx_st_dcfill_wrway_sel = cpx_spc_data_cx[`CPX_INV_WAY];
// wire cpx_st_dcfill_wrway_val = cpx_spc_data_cx[`CPX_INV_DCACHE_VAL];
// wire [1:0] cpx_st_dcfill_pa_54 = cpx_spc_data_cx[`CPX_INVPA5:`CPX_INVPA4];

// select the appropriate offset

//bug3718 - 0in bug - cpx_st_dcfill_wrway_sel can be multi-hot foe non-stack cpx responses
//          hence qual w/ stack req type
// wire  [3:0]  st_dcfill_wrway_mxsel ;

// assign st_dcfill_wrway_mxsel[0] =  (lsu_cpxpkt_type_dcd_cx[2] & cpx_st_dcfill_wrway_val) & ~rst_tri_en ;
// assign st_dcfill_wrway_mxsel[1] =  (lsu_cpxpkt_type_dcd_cx[2] & cpx_st_dcfill_wrway_val) & ~rst_tri_en ;
// assign st_dcfill_wrway_mxsel[2] =  (lsu_cpxpkt_type_dcd_cx[2] & cpx_st_dcfill_wrway_val) & ~rst_tri_en ;
// assign st_dcfill_wrway_mxsel[3] =  ~|st_dcfill_wrway_mxsel[2:0] | rst_tri_en;

// mux4ds  #(2) st_dcfill_wrway_sel_b54 (
//         .in0    (cpx_st_dcfill_wrway_sel[3:2]),
//         .in1    (cpx_st_dcfill_wrway_sel[6:5]),
//         .in2    (cpx_st_dcfill_wrway_sel[10:9]),
//         .in3    (cpx_st_dcfill_wrway_sel[13:12]),
//         .sel0   (st_dcfill_wrway_mxsel[0]),
//         .sel1   (st_dcfill_wrway_mxsel[1]),
//         .sel2   (st_dcfill_wrway_mxsel[2]),
//         .sel3   (st_dcfill_wrway_mxsel[3]),
//         .dout   (cpx_st_dcfill_wrway[1:0])
// );

wire [3:0] cpx_spc_data_cx_wrway = cpx_spc_data_cx[5:2]; 
assign cpx_st_dcfill_wrway[2-1:0] = cpx_spc_data_cx_wrway[2-1:0]; // trin: width mismatch okay
assign cpx_st_ack_addr_b54 = cpx_spc_data_cx[122:121];
// assign  cpx_st_ack_addr_b54[0] = cpx_st_dcfill_wrway_sel[4] | cpx_st_dcfill_wrway_sel[11] ;
// assign  cpx_st_ack_addr_b54[1] = cpx_st_dcfill_wrway_sel[7] | cpx_st_dcfill_wrway_sel[11] ;

//=================================================================================================


//assign store_dfq_pkt[`STB_DFQ_WIDTH-1:0] = stb_dfq_pkt_data[`STB_DFQ_WIDTH-1:0] ;

// Items generated/prior to fill cycle (but after DFQ read).
// This logic will be put in qctl and then be fwded to dcache.
// - Parity (16b) - load & store.
// - Byte Enable (16b) - store (8b), ld (16b) all high.
// - Cache Tag (30b) - obtained from LMQ.
// - RD1 (5b) - obtained from LMQ.
// - RD2 (5b) - obtained from LMQ.
// ** DFQ will contain either loads or inv.

// Need to do alignment. Assume dw for now.
// For a load, a bypass will always happen, a write is 
  
// Mux in diagnostic information. Only data is muxed in because
// all other info is critical

   wire [63:0] diagnstc_wr_data;
   
dff_s  #(64) diagnstc_wr_data_ff (
        .din    (lsu_diagnstc_wr_data_e[63:0]), 
        .q      (diagnstc_wr_data[63:0]),
        .clk    (clk),
        .se     (1'b0),     .si (),          .so ()
        ); 
   
mux2ds  #(64) dcwr_sel (
  //.in0  ({store_dfq_pkt[`STB_DFQ_DA_HI:`STB_DFQ_DA_LO]}),
  .in0  ({dfq_byp_ff_data[63:0]}),
  .in1  ({diagnstc_wr_data[63:0]}),
  .sel0 ( lsu_dfq_st_vld),  
  .sel1 (~lsu_dfq_st_vld),
  //.sel0 (~lsu_diagnstc_wr_src_sel_e),  
  //.sel1 ( lsu_diagnstc_wr_src_sel_e),
  .dout (dcache_wr_data[63:0])
);


// store currently assumed to be dword.
// st dword is duplicated across 16B.
// currently assume st and not atomics supported.
// The width can be reduced !!!
assign st_dcfill_data[127:0] =
  {                                                            //dfq_byp_ff_data[`STB_DFQ_VLD],
                                                               //2'b00,   // need thread-id
                                                               //2'b00,1'b0,5'b00000,
//   dfq_byp_ff_data[84:83],                          // 131:130 - wr_way[1:0]
//   dfq_byp_ff_data[`STB_DFQ_SZ_HI:`STB_DFQ_SZ_LO],  // 129:128 - size[1:0]
                                                               //29'd0,                                           //!!! reduce 
                                                               //{dfq_byp_ff_data[`CPX_INV_IDX_HI:`CPX_INV_IDX_LO], // addr 10:6
                                                               //dfq_byp_ff_data[86:85],        // addr 5:4
                                                               //dfq_byp_ff_data[`STB_DFQ_AD_LO+3:`STB_DFQ_AD_LO]}, // addr 3:0
   dcache_wr_data[63:0],                            // 127:64
   dcache_wr_data[63:0]};                           // 63:0


   assign st_dcfill_addr[(6 + 4):0] =    
   {dfq_byp_ff_data_addr_15_6[(6 + 4):6],    // addr 10:6
    dfq_byp_ff_data[86:85],                            // addr 5:4
    dfq_byp_ff_data[64+3:64]}; // addr 3:0
   
// lmq0_pcx_pkt will have to be brought in. Same for lmq_ld_addr
// The width can be reduced !!!

//potentially we can take one cycle earlier version dfq_st_data   
   wire [1:0] dfq_byp_ff_data_st_way = dfq_byp_ff_data[84:83]; // trin reconfig: this format prevents way > 4
   assign lsu_st_way_e[2-1:0] = dfq_byp_ff_data_st_way[2-1:0];
   assign lsu_st_dcfill_size_e [1:0] = dfq_byp_ff_data[75:74];
       
assign ldinv_dcfill_data[127:0] =
  {                                                            //1'b0,
                                                               //dfq_byp_ff_data[`DFQ_TH_HI:`DFQ_TH_LO],
                                                               //dfq_byp_ff_data[`DFQ_LD_TYPE:`DFQ_INV_TYPE],
                                                               //1'b1,  //assume ld always writes.
                                                               //5'b00000,
//   lmq_ld_way[1:0],                                // 131:130 - way[1:0]- dfq_byp_ff_data[`DFQ_WY_HI:`DFQ_WY_LO],
//   2'b0,                                           // 129:128 - size[1:0]- lmq_pcx_pkt_sz[1:0],      //!!! reduce 
                                                               //40'b0,  //lmq_pcx_pkt_addr[39:0],   //!!! reduce
   dfq_byp_ff_data[127:0]};        // 127:0


// Select between dfq-bypass (ld-inv) and store.
// *** cpu-id currently hardwired in pkt
// This may be further restricted in width !!!

mux2ds  #(128) dfq_pkt_src (
  .in0  (st_dcfill_data[127:0]),    
  .in1  (ldinv_dcfill_data[127:0]), 
  .sel0 (~lsu_dfq_ld_vld),  
  .sel1 (lsu_dfq_ld_vld),
  .dout (lsu_dcfill_data[127:0])
);

// Parity Generation for write data - from load or store.
wire  [15:0]  dcache_wr_parity ;
lsu_dc_parity_gen parity_gen (
    .data_in  (lsu_dcfill_data[127:0]),
    .parity_out (dcache_wr_parity[15:0])
  );

// Bug 4125. Corrupt parity if l2 unc err detected. Corrupt both upper and lower half
// as subsequent read will pick up one of two halves.
//wire	parity_byte0_flip ;
//wire	parity_byte8_flip ;
wire	ld_unc_error ;
assign	ld_unc_error = (dfq_byp_ff_data[138] & dfq_byp_ff_data[151-1]); // not critical !

//bug7021/ECO7022
//assign	parity_byte0_flip = dcache_wr_parity[0] ^ ld_unc_error ;
//assign	parity_byte8_flip = dcache_wr_parity[8] ^ ld_unc_error ;

   wire [15:0] parity_byte_flip;
   assign      parity_byte_flip[15:0] = dcache_wr_parity[15:0] ^ {16{ld_unc_error }};
   
//assign  dcache_wr_parity_mod[15:0]  =
//    lsu_diagnstc_wr_src_sel_e ? 
//    ({lsu_diagnstc_dc_prty_invrt_e[7:0],lsu_diagnstc_dc_prty_invrt_e[7:0]} ^ dcache_wr_parity[15:0]) :
//    dcache_wr_parity[15:0] ;

wire  [15:0]  diagnstc_wr_parity;

assign diagnstc_wr_parity[15:0]  =  {lsu_diagnstc_dc_prty_invrt_e[7:0],lsu_diagnstc_dc_prty_invrt_e[7:0]} ^ dcache_wr_parity[15:0];

mux2ds  #(16) dcache_wr_parity_mod_mux (
              .in0(diagnstc_wr_parity[15:0]),
//              .in1({dcache_wr_parity[15:9],parity_byte8_flip,dcache_wr_parity[7:1],parity_byte0_flip}),
              .in1(parity_byte_flip[15:0]),        //bug7021/ECO7022                  
              .sel0(~lsu_dfq_ldst_vld),
              .sel1( lsu_dfq_ldst_vld),
              //.sel0(lsu_diagnstc_wr_src_sel_e),
              //.sel1(~lsu_diagnstc_wr_src_sel_e),
              .dout(dcache_wr_parity_mod[15:0])
);


// Bist read and write address sent thru fill_addr
//assign  lsu_dcache_fill_addr_e[`L1D_ADDRESS_HI:0] = 
//lsu_dc_iob_access_e ? {dcache_iob_addr_e[`L1D_ADDRESS_HI-3:0],2'b00} :
//(lsu_bist_wvld_e | lsu_bist_rvld_e) ? {1'b0, lsu_bist_addr_e[7:0],2'b00} :  //??FIX
//  lsu_diagnstc_wr_src_sel_e ? lsu_diagnstc_wr_addr_e[`L1D_ADDRESS_HI:0] :
//    lsu_dcfill_data[`DCFILL_AD_LO+10:`DCFILL_AD_LO];

//   wire [`L1D_ADDRESS_HI:0] lsu_dcache_fill_addr_e;
   
//mux4ds  #(11) lsu_dcache_fill_addr_e_mux (
//  .in0  ({dcache_iob_addr_e[`L1D_ADDRESS_HI-3:0],2'b00}),
//  .in1  ({mbist_dcache_index[6:0], mbist_dcache_word, 3'b00}),
//  .in2  (lsu_diagnstc_wr_addr_e[`L1D_ADDRESS_HI:0]),
//  .in3  (lsu_dcfill_data[`DCFILL_AD_LO+10:`DCFILL_AD_LO]),
//  .sel0 (lsu_dcfill_mx_sel_e[0]),
//  .sel1 (lsu_dcfill_mx_sel_e[1]),
//  .sel2 (lsu_dcfill_mx_sel_e[2]),
//  .sel3 (lsu_dcfill_mx_sel_e[3]),
//  .dout (lsu_dcache_fill_addr_e[`L1D_ADDRESS_HI:0])
//);

wire	[63:0] misc_fill_data_e ;
// Use smaller width mux to save area.
//assign	misc_fill_data_e[63:0] =
//lsu_dc_iob_access_e ? dcache_iob_data_e[63:0] :
//	 		{32{lsu_bist_wdata_e[1:0]}} ;

   wire [7:0] mbist_write_data_d1;

dff_s #(8) mbist_write_data_ff (
   .din (mbist_write_data[7:0]),
   .q   (mbist_write_data_d1[7:0]),
   .clk    (clk),
   .se     (1'b0),     .si (),          .so ()
); 
    

   wire      [3:0] misc_fill_parity_e;
assign    misc_fill_parity_e[3:0] = {4{~lsu_dc_iob_access_e}} & mbist_write_data_d1[3:0];

mux2ds  #(64) misc_fill_data_e_mux (
              .in0(dcache_iob_data_e[63:0]),
              .in1({8{mbist_write_data_d1[7:0]}}),
              .sel0(lsu_dc_iob_access_e),
              .sel1(~lsu_dc_iob_access_e),
              .dout(misc_fill_data_e[63:0])
);

mux2ds  #(144) lsu_dcache_fill_data_e_mux (
               .in0({misc_fill_data_e[63:0],misc_fill_data_e[63:0],{4{misc_fill_parity_e[3:0]}}}),
               .in1({lsu_dcfill_data[127:0],dcache_wr_parity_mod[15:0]}),
               .sel0(lsu_dcfill_data_mx_sel_e),
               .sel1(~lsu_dcfill_data_mx_sel_e),
               .dout(lsu_dcache_fill_data_e[143:0])
);

//assign  lsu_dcache_fill_size_e[1:0] = 
//(lsu_dc_iob_access_e | lsu_bist_wvld_e | lsu_diagnstc_wr_src_sel_e) ? 2'b11 :
//    lsu_dcfill_data[`DCFILL_SZ_HI:`DCFILL_SZ_LO] ;



//   wire [1:0] bist_way_e;
   
//assign bist_way_e[1:0] = (lsu_bist_rvld_e | lsu_bist_wvld_e) ? 
//                          mbist_dcache_way[1:0] : 2'b00;
   
//assign  bist_rsel_way_e[0] = ~bist_way_e[1] & ~bist_way_e[0] ;
//assign  bist_rsel_way_e[1] = ~bist_way_e[1] &  bist_way_e[0] ;
//assign  bist_rsel_way_e[2] =  bist_way_e[1] & ~bist_way_e[0] ;
//assign  bist_rsel_way_e[3] =  bist_way_e[1] &  bist_way_e[0] ;

//   assign lsu_bist_rsel_way_e[3:0] = bist_rsel_way_e[3:0];
   
 
// This staging may have to go elsewhere 
//always @(posedge clk)
//  begin
//    bist_rsel_way_m[3:0] <= bist_rsel_way_e[3:0] ;  
//  end

//always @(posedge clk)
//  begin
//    lsu_bist_rsel_way_wb[3:0] <= bist_rsel_way_m[3:0] ; 
//  end

//dff #(4) bist_rsel_way_m_ff (
//        .din    (bist_rsel_way_e[3:0]),
//        .q      (bist_rsel_way_m[3:0]),
//        .clk    (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

//dff #(4) lsu_bist_rsel_way_wb_ff (
//        .din    (bist_rsel_way_m[3:0]),
//        .q      (lsu_bist_rsel_way_wb[3:0]),
//        .clk    (clk),
//        .se     (1'b0),       .si (),          .so ()
//        );

//assign  lsu_dcache_fill_way_e[0] = 
//lsu_dc_iob_access_e ? dcache_iob_wy_e[0] : 
//	(lsu_bist_wvld_e | lsu_bist_rvld_e) ? bist_rsel_way_e[0] :
//  		lsu_diagnstc_wr_src_sel_e ? lsu_diagnstc_wr_way_e[0] : 
//    			~lsu_dcfill_data[`DCFILL_WY_HI] & ~lsu_dcfill_data[`DCFILL_WY_LO] ;
//assign  lsu_dcache_fill_way_e[1] = 
//lsu_dc_iob_access_e ? dcache_iob_wy_e[1] : 
//	(lsu_bist_wvld_e | lsu_bist_rvld_e) ? bist_rsel_way_e[1] :
//  		lsu_diagnstc_wr_src_sel_e ? lsu_diagnstc_wr_way_e[1] : 
//    			~lsu_dcfill_data[`DCFILL_WY_HI] &  lsu_dcfill_data[`DCFILL_WY_LO] ;
//assign  lsu_dcache_fill_way_e[2] =  
//lsu_dc_iob_access_e ? dcache_iob_wy_e[2] : 
//	(lsu_bist_wvld_e | lsu_bist_rvld_e) ?  bist_rsel_way_e[2] :
//  		lsu_diagnstc_wr_src_sel_e ? lsu_diagnstc_wr_way_e[2] : 
//    			lsu_dcfill_data[`DCFILL_WY_HI] & ~lsu_dcfill_data[`DCFILL_WY_LO] ;
//assign  lsu_dcache_fill_way_e[3] =  
//lsu_dc_iob_access_e ? dcache_iob_wy_e[3] : 
//	(lsu_bist_wvld_e | lsu_bist_rvld_e) ?  bist_rsel_way_e[3] :
//  		lsu_diagnstc_wr_src_sel_e ? lsu_diagnstc_wr_way_e[3] : 
//    			lsu_dcfill_data[`DCFILL_WY_HI] &  lsu_dcfill_data[`DCFILL_WY_LO] ;

/*   
mux4ds  #(1) lsu_dcache_fill_way0_e_mux (
  .in0  (dcache_iob_wy_e[0]),
  .in1  (bist_rsel_way_e[0]),        
  .in2  (lsu_diagnstc_wr_way_e[0]),    
  .in3  (~lsu_dcfill_data[131] & ~lsu_dcfill_data[130]),
  .sel0 (lsu_dcfill_mx_sel_e[0]),
  .sel1 (lsu_dcfill_mx_sel_e[1]),
  .sel2 (lsu_dcfill_mx_sel_e[2]),
  .sel3 (lsu_dcfill_mx_sel_e[3]),
  .dout (lsu_dcache_fill_way_e[0]));                                 

mux4ds  #(1) lsu_dcache_fill_way1_e_mux (
  .in0  (dcache_iob_wy_e[1]),
  .in1  (bist_rsel_way_e[1]),        
  .in2  (lsu_diagnstc_wr_way_e[1]),    
  .in3  (~lsu_dcfill_data[131] &  lsu_dcfill_data[130]),
  .sel0 (lsu_dcfill_mx_sel_e[0]),
  .sel1 (lsu_dcfill_mx_sel_e[1]),
  .sel2 (lsu_dcfill_mx_sel_e[2]),
  .sel3 (lsu_dcfill_mx_sel_e[3]),
  .dout (lsu_dcache_fill_way_e[1]));                                 

mux4ds  #(1) lsu_dcache_fill_way2_e_mux (
  .in0  (dcache_iob_wy_e[2]),
  .in1  (bist_rsel_way_e[2]),        
  .in2  (lsu_diagnstc_wr_way_e[2]),    
  .in3  ( lsu_dcfill_data[131] & ~lsu_dcfill_data[130]),
  .sel0 (lsu_dcfill_mx_sel_e[0]),
  .sel1 (lsu_dcfill_mx_sel_e[1]),
  .sel2 (lsu_dcfill_mx_sel_e[2]),
  .sel3 (lsu_dcfill_mx_sel_e[3]),
  .dout (lsu_dcache_fill_way_e[2]));                                 


mux4ds  #(1) lsu_dcache_fill_way3_e_mux (
  .in0  (dcache_iob_wy_e[3]),
  .in1  (bist_rsel_way_e[3]),        
  .in2  (lsu_diagnstc_wr_way_e[3]),    
  .in3  ( lsu_dcfill_data[131] &  lsu_dcfill_data[130]),
  .sel0 (lsu_dcfill_mx_sel_e[0]),
  .sel1 (lsu_dcfill_mx_sel_e[1]),
  .sel2 (lsu_dcfill_mx_sel_e[2]),
  .sel3 (lsu_dcfill_mx_sel_e[3]),
  .dout (lsu_dcache_fill_way_e[3]));                
*/
//   assign lsu_dcache_fill_way_enc_e[0] =  lsu_dcache_fill_way_e[1] |  lsu_dcache_fill_way_e[3];
//   assign lsu_dcache_fill_way_enc_e[1] =  lsu_dcache_fill_way_e[2] |  lsu_dcache_fill_way_e[3];

wire [63:0] l2fill_data_e;
 
mux2ds        #(64) half_sel (
      .in0    (lsu_dcfill_data[127:0+64]),
      .in1    (lsu_dcfill_data[0+63:0]),
      .sel0   (lsu_dfill_data_sel_hi),  .sel1 (~lsu_dfill_data_sel_hi),
      .dout   (l2fill_data_e[63:0])
);

dff_s #(64) stgm_l2fd (
        .din    (l2fill_data_e[63:0]),
        .q      (lsu_l2fill_data[63:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_dcache_lfsr.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: lsu_dcache_lfsr
*/
////////////////////////////////////////////////////////////////////////

module lsu_dcache_lfsr (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   advance, clk, se, si, so, reset
   );

   input 	advance;
   
   input 	clk, se, si, so, reset;

   output [1:0] out;

   reg [4:0]    q_next;
   wire [4:0]   q;
   

/*
   always @ (posedge clk)
     begin
	out = $random;
     end // always @ posedge
 */

//   always @ (posedge clk)
//     begin
//	q[4:0] <= q_next[4:0];
//     end

   always @ (/*AUTOSENSE*/advance or q or reset)
     begin
	      if (reset)
	        q_next = 5'b11111;
	      else if (advance)
	        begin
	           // lfsr -- stable at 000000, period of 63
	           q_next[1] = q[0];
	           q_next[2] = q[1];
	           q_next[3] = q[2];
	           q_next[4] = q[3];
	           q_next[0] = q[1] ^ q[4];
	        end
	      else
	        q_next = q;
     end // always @ (...

   assign out = {q[0], q[2]};

   dff_s #(5) lfsr_reg(.din  (q_next),
                     .q    (q),
                     .clk  (clk), .se(se), .si(), .so());
   
endmodule // lsu_dcache_lfsr

		
	       

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_dcdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================


// devices.xml



////////////////////////////////////////////////////////////////////////
/*
//	Description:	LSU Data Cache Data Path
//			- Final Way-Select Mux.
//			- Alignment, Sign-Extension, Endianness.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_dcdp ( /*AUTOARG*/
   // Outputs
   so, dcache_rdata_wb_buf, mbist_dcache_data_in, 
   lsu_exu_dfill_data_w2, lsu_ffu_ld_data, stb_rdata_ramc_buf, 
   // Inputs
   rclk, si, se, rst_tri_en, dcache_rdata_wb, dcache_rparity_wb, 
   // dcache_rdata_msb_w0_m, dcache_rdata_msb_w1_m, 
   // dcache_rdata_msb_w2_m, dcache_rdata_msb_w3_m, 
   dcache_rdata_msb_m,
   lsu_bist_rsel_way_e, 
   dcache_alt_mx_sel_e, cache_way_hit_buf2, morphed_addr_m, 
   signed_ldst_byte_m, signed_ldst_hw_m, signed_ldst_w_m, 
   merge7_sel_byte0_m, merge7_sel_byte7_m, merge6_sel_byte1_m, 
   merge6_sel_byte6_m, merge5_sel_byte2_m, merge5_sel_byte5_m, 
   merge4_sel_byte3_m, merge4_sel_byte4_m, merge3_sel_byte0_m, 
   merge3_sel_byte3_m, merge3_sel_byte4_m, 
   merge3_sel_byte7_default_m, merge3_sel_byte_m, merge2_sel_byte1_m, 
   merge2_sel_byte2_m, merge2_sel_byte5_m, 
   merge2_sel_byte6_default_m, merge2_sel_byte_m, merge0_sel_byte0_m, 
   merge0_sel_byte1_m, merge0_sel_byte2_m, 
   merge0_sel_byte3_default_m, merge0_sel_byte4_m, 
   merge0_sel_byte5_m, merge0_sel_byte6_m, 
   merge0_sel_byte7_default_m, merge1_sel_byte0_m, 
   merge1_sel_byte1_m, merge1_sel_byte2_m, 
   merge1_sel_byte3_default_m, merge1_sel_byte4_m, 
   merge1_sel_byte5_m, merge1_sel_byte6_m, 
   merge1_sel_byte7_default_m, merge0_sel_byte_1h_m, 
   merge1_sel_byte_1h_m, merge1_sel_byte_2h_m, stb_rdata_ramc
   ) ;	

   input rclk;
   input si;
   input se;
   output so;
   input  rst_tri_en;
   
input  [63:0]  dcache_rdata_wb;
output [63:0]  dcache_rdata_wb_buf;

input [7:0] dcache_rparity_wb;
output [71:0] mbist_dcache_data_in;

output [63:0]		lsu_exu_dfill_data_w2; 	// bypass data - d$ fill or hit
output [63:0]		lsu_ffu_ld_data ;	      // ld data to frf
   

//=========================================
//dc_fill CP
//=========================================
   // input [7:0]           dcache_rdata_msb_w0_m;    //from D$
   // input [7:0]           dcache_rdata_msb_w1_m;    //from D$
   // input [7:0]           dcache_rdata_msb_w2_m;    //from D$
   // input [7:0]           dcache_rdata_msb_w3_m;    //from D$
   input [4*8-1:0]           dcache_rdata_msb_m;    //from D$

  wire [7:0]           dcache_rdata_msb_w0_m = dcache_rdata_msb_m[((0+1)*8)-1 -: 8];


  wire [7:0]           dcache_rdata_msb_w1_m = dcache_rdata_msb_m[((1+1)*8)-1 -: 8];


  wire [7:0]           dcache_rdata_msb_w2_m = dcache_rdata_msb_m[((2+1)*8)-1 -: 8];


  wire [7:0]           dcache_rdata_msb_w3_m = dcache_rdata_msb_m[((3+1)*8)-1 -: 8];




   input [4-1:0]           lsu_bist_rsel_way_e;     //from qdp2

   input                 dcache_alt_mx_sel_e;
   input [4-1:0]           cache_way_hit_buf2;    //from dtlb
   
   input [7:0]           morphed_addr_m;  //from dctl

   input          signed_ldst_byte_m;    //from dctl
//   input          unsigned_ldst_byte_m;  //from dctl 
   input          signed_ldst_hw_m;      //from dctl
//   input          unsigned_ldst_hw_m;    //from dctl
   input          signed_ldst_w_m;       //from dctl
//   input          unsigned_ldst_w_m;     //from dctl

input                   merge7_sel_byte0_m;
input                   merge7_sel_byte7_m;
   
input                   merge6_sel_byte1_m;
input                   merge6_sel_byte6_m;

input                   merge5_sel_byte2_m;   
input                   merge5_sel_byte5_m;

input                   merge4_sel_byte3_m;
input                   merge4_sel_byte4_m;

input                   merge3_sel_byte0_m;
input                   merge3_sel_byte3_m;
input                   merge3_sel_byte4_m;
input                   merge3_sel_byte7_default_m;
input                   merge3_sel_byte_m ;

input                   merge2_sel_byte1_m;
input                   merge2_sel_byte2_m;
input                   merge2_sel_byte5_m;
input                   merge2_sel_byte6_default_m;
input                   merge2_sel_byte_m ;

input                   merge0_sel_byte0_m, merge0_sel_byte1_m;
input                   merge0_sel_byte2_m, merge0_sel_byte3_default_m;
   
input                   merge0_sel_byte4_m, merge0_sel_byte5_m;
input                   merge0_sel_byte6_m, merge0_sel_byte7_default_m;
                                                               
input                   merge1_sel_byte0_m, merge1_sel_byte1_m;
input                   merge1_sel_byte2_m, merge1_sel_byte3_default_m;
input                   merge1_sel_byte4_m, merge1_sel_byte5_m;
input                   merge1_sel_byte6_m, merge1_sel_byte7_default_m; 

input			             merge0_sel_byte_1h_m ;
   
input			             merge1_sel_byte_1h_m, merge1_sel_byte_2h_m ;

   input [14:9]        stb_rdata_ramc;
   output [14:9]       stb_rdata_ramc_buf;
   
//wire   [3:1]           lsu_byp_byte_zero_extend ; // zero-extend for bypass bytes 7-1
reg   [7:1]           lsu_byp_byte_sign_extend ; // sign-extend by 1 for byp bytes 7-1
   
wire	[7:0]		byte0,byte1,byte2,byte3;
wire	[7:0]		byte4,byte5,byte6,byte7;
//wire [3:1] zero_extend_g;
wire [7:1] sign_extend_g;

wire	[7:0]		align_byte3 ;
wire	[7:0]		align_byte2 ;
wire	[7:0]		align_byte1_1h,align_byte1_2h;
wire	[7:0]		align_byte0_1h,align_byte0_2h ;
wire	[63:0]	align_byte ;


wire                   merge7_sel_byte0;
wire                   merge7_sel_byte7;
   
wire                   merge6_sel_byte1;
wire                   merge6_sel_byte6;

wire                   merge5_sel_byte2;   
wire                   merge5_sel_byte5;

wire                   merge4_sel_byte3;
wire                   merge4_sel_byte4;

wire                   merge3_sel_byte0;
wire                   merge3_sel_byte3;
wire                   merge3_sel_byte4;
wire                   merge3_sel_byte7;
wire                   merge3_sel_byte ;

wire                   merge2_sel_byte1;
wire                   merge2_sel_byte2;
wire                   merge2_sel_byte5;
wire                   merge2_sel_byte6;
wire                   merge2_sel_byte ;

wire                   merge0_sel_byte0, merge0_sel_byte1;
wire                   merge0_sel_byte2, merge0_sel_byte3;
wire                   merge0_sel_byte4, merge0_sel_byte5;
wire                   merge0_sel_byte6, merge0_sel_byte7;
wire                   merge1_sel_byte0, merge1_sel_byte1;
wire                   merge1_sel_byte2, merge1_sel_byte3;
wire                   merge1_sel_byte4, merge1_sel_byte5;
wire                   merge1_sel_byte6, merge1_sel_byte7; 

wire			              merge0_sel_byte_1h ;
wire			              merge1_sel_byte_1h, merge1_sel_byte_2h ;

   wire       clk;
   assign     clk = rclk;

   assign     stb_rdata_ramc_buf[14:9] = stb_rdata_ramc[14:9];
   
//=========================================================================================
//	Alignment of Fill Data
//=========================================================================================

// Alignment needs to be done for following reasons :
// - Write of data to irf on ld hit in l1.
// - Write of data to irf on ld fill to l1 after miss in l1.
// - Store of irf data to memory.
//	- Data must be aligned before write to stb.
//	- If data is bypassed from stb by ld then it will
//	need realignment thru dfq i.e., it looks like a fill.
// This applies to data either read from the dcache (hit) or dfq(fill on miss). 


assign	byte7[7:0] = dcache_rdata_wb[63:56];
assign	byte6[7:0] = dcache_rdata_wb[55:48];
assign	byte5[7:0] = dcache_rdata_wb[47:40];
assign	byte4[7:0] = dcache_rdata_wb[39:32];
assign	byte3[7:0] = dcache_rdata_wb[31:24];
assign	byte2[7:0] = dcache_rdata_wb[23:16];
assign	byte1[7:0] = dcache_rdata_wb[15:8];
assign	byte0[7:0] = dcache_rdata_wb[7:0];

//assign	zero_extend_g[3:1] = lsu_byp_byte_zero_extend[3:1] ;
assign	sign_extend_g[7:1] = lsu_byp_byte_sign_extend[7:1] ;

//buffer
   assign     dcache_rdata_wb_buf[63:0] = dcache_rdata_wb[63:0];
   assign     mbist_dcache_data_in[71:0] = {dcache_rdata_wb_buf[63:0], dcache_rparity_wb[7:0]};

// Final endian/justified/sign-extend Byte 0.
//assign	align_byte0_1h[7:0]
//	= merge0_sel_byte0 ? byte0[7:0] :
//		  merge0_sel_byte1 ? byte1[7:0] :
//			  merge0_sel_byte2 ? byte2[7:0] :
//				  merge0_sel_byte3 ?  byte3[7:0] :
//					  8'hxx ;

   wire       merge0_sel_byte0_mxsel0, merge0_sel_byte1_mxsel1, merge0_sel_byte2_mxsel2, merge0_sel_byte3_mxsel3;
   assign     merge0_sel_byte0_mxsel0 = merge0_sel_byte0 & ~rst_tri_en;
   assign     merge0_sel_byte1_mxsel1 = merge0_sel_byte1 & ~rst_tri_en;
   assign     merge0_sel_byte2_mxsel2 = merge0_sel_byte2 & ~rst_tri_en;
   assign     merge0_sel_byte3_mxsel3 = merge0_sel_byte3 |  rst_tri_en;
   
mux4ds #(8) align_byte0_1h_mx (
      .in0 (byte0[7:0]),
      .in1 (byte1[7:0]), 
      .in2 (byte2[7:0]),
      .in3 (byte3[7:0]),
      .sel0(merge0_sel_byte0_mxsel0),
      .sel1(merge0_sel_byte1_mxsel1),
      .sel2(merge0_sel_byte2_mxsel2),
      .sel3(merge0_sel_byte3_mxsel3),
      .dout(align_byte0_1h[7:0])
);
                             
//assign	align_byte0_2h[7:0]
//	= merge0_sel_byte4 ? byte4[7:0] :
//		  merge0_sel_byte5 ? byte5[7:0] :
//			  merge0_sel_byte6 ? byte6[7:0] :
//				  merge0_sel_byte7 ? byte7[7:0] :
//					  8'hxx ;

   wire       merge0_sel_byte4_mxsel0, merge0_sel_byte5_mxsel1, merge0_sel_byte6_mxsel2, merge0_sel_byte7_mxsel3;
   assign     merge0_sel_byte4_mxsel0 = merge0_sel_byte4 & ~rst_tri_en;
   assign     merge0_sel_byte5_mxsel1 = merge0_sel_byte5 & ~rst_tri_en;
   assign     merge0_sel_byte6_mxsel2 = merge0_sel_byte6 & ~rst_tri_en;
   assign     merge0_sel_byte7_mxsel3 = merge0_sel_byte7 |  rst_tri_en;
   
mux4ds #(8) align_byte0_2h_mx (
      .in0 (byte4[7:0]),
      .in1 (byte5[7:0]), 
      .in2 (byte6[7:0]),
      .in3 (byte7[7:0]),
      .sel0(merge0_sel_byte4_mxsel0),
      .sel1(merge0_sel_byte5_mxsel1),
      .sel2(merge0_sel_byte6_mxsel2),
      .sel3(merge0_sel_byte7_mxsel3),
      .dout(align_byte0_2h[7:0])
);
   
// No sign-extension or zero-extension for byte0
//assign	align_byte[7:0]	
//	= merge0_sel_byte_1h ? align_byte0_1h[7:0] :
//					align_byte0_2h[7:0] ;
   
   assign align_byte[7:0] = merge0_sel_byte_1h ? align_byte0_1h[7:0] :
                                                 align_byte0_2h[7:0];
   

// Final endian/justified/sign-extend Byte 1.
// *** The path thru byte1 is the most critical ***
//assign	align_byte1_1h[7:0]
//	= merge1_sel_byte0 ? byte0[7:0] :
//		  merge1_sel_byte1 ? byte1[7:0] :
//			  merge1_sel_byte2 ? byte2[7:0] :
//				  merge1_sel_byte3 ? byte3[7:0] :
//						8'hxx ;

   wire       merge1_sel_byte0_mxsel0, merge1_sel_byte1_mxsel1, merge1_sel_byte2_mxsel2, merge1_sel_byte3_mxsel3;
   assign     merge1_sel_byte0_mxsel0 = merge1_sel_byte0 & ~rst_tri_en;
   assign     merge1_sel_byte1_mxsel1 = merge1_sel_byte1 & ~rst_tri_en;
   assign     merge1_sel_byte2_mxsel2 = merge1_sel_byte2 & ~rst_tri_en;
   assign     merge1_sel_byte3_mxsel3 = merge1_sel_byte3 |  rst_tri_en;
   
mux4ds #(8) align_byte1_1h_mx (
    .in0 (byte0[7:0]),
    .in1 (byte1[7:0]),
    .in2 (byte2[7:0]), 
    .in3 (byte3[7:0]),
    .sel0(merge1_sel_byte0_mxsel0),
    .sel1(merge1_sel_byte1_mxsel1),
    .sel2(merge1_sel_byte2_mxsel2),
    .sel3(merge1_sel_byte3_mxsel3),
    .dout(align_byte1_1h[7:0])
);
      
//assign	align_byte1_2h[7:0]
//	= merge1_sel_byte4 ? byte4[7:0] :
//		  merge1_sel_byte5 ? byte5[7:0] :
//			  merge1_sel_byte6 ? byte6[7:0] :
//					merge1_sel_byte7 ? byte7[7:0] :
//						8'hxx ; 

   wire       merge1_sel_byte4_mxsel0, merge1_sel_byte5_mxsel1, merge1_sel_byte6_mxsel2, merge1_sel_byte7_mxsel3;
   assign     merge1_sel_byte4_mxsel0 = merge1_sel_byte4 & ~rst_tri_en;
   assign     merge1_sel_byte5_mxsel1 = merge1_sel_byte5 & ~rst_tri_en;
   assign     merge1_sel_byte6_mxsel2 = merge1_sel_byte6 & ~rst_tri_en;
   assign     merge1_sel_byte7_mxsel3 = merge1_sel_byte7 |  rst_tri_en;

mux4ds #(8) align_byte1_2h_mx (
    .in0 (byte4[7:0]),
    .in1 (byte5[7:0]),
    .in2 (byte6[7:0]), 
    .in3 (byte7[7:0]),
    .sel0(merge1_sel_byte4_mxsel0),
    .sel1(merge1_sel_byte5_mxsel1),
    .sel2(merge1_sel_byte6_mxsel2),
    .sel3(merge1_sel_byte7_mxsel3),
    .dout(align_byte1_2h[7:0])
);
   
//assign	align_byte[15:8] = 	
//	zero_extend_g[1] ? 8'h00 :
//		sign_extend_g[1] ? 8'hff :
//			merge1_sel_byte_1h ? align_byte1_1h[7:0] :
//				merge1_sel_byte_2h ? align_byte1_2h[7:0] :
//						8'hxx ;

//mux4ds #(8) align_byte1_mx (
//    .in0 (8'h00),
//    .in1 (8'hff),
//    .in2 (align_byte1_1h[7:0]), 
//    .in3 (align_byte1_2h[7:0]),
//    .sel0(zero_extend_g[1]),
//    .sel1(sign_extend_g[1]),
//    .sel2(merge1_sel_byte_1h),
//    .sel3(merge1_sel_byte_2h),
//    .dout(align_byte[15:8])
//);

   //change to aoi from pass gate
   //don't need zero_extend
   
assign  align_byte[15:8] =
 (sign_extend_g[1] ? 8'hff : 8'h00) |
 (merge1_sel_byte_1h ? align_byte1_1h[7:0] : 8'h00) |
 (merge1_sel_byte_2h ? align_byte1_2h[7:0] : 8'h00);
 
// Final endian/justified/sign-extend Byte 2.
//assign	align_byte2[7:0]
//	= merge2_sel_byte1 ? byte1[7:0] :
//		  merge2_sel_byte2 ? byte2[7:0] :
//					merge2_sel_byte5 ? byte5[7:0] :
//           merge2_sel_byte6 ?  byte6[7:0] :
//							8'hxx ;

   wire       merge2_sel_byte1_mxsel0, merge2_sel_byte2_mxsel1, merge2_sel_byte5_mxsel2, merge2_sel_byte6_mxsel3;
   assign     merge2_sel_byte1_mxsel0 = merge2_sel_byte1 & ~rst_tri_en;
   assign     merge2_sel_byte2_mxsel1 = merge2_sel_byte2 & ~rst_tri_en;
   assign     merge2_sel_byte5_mxsel2 = merge2_sel_byte5 & ~rst_tri_en;
   assign     merge2_sel_byte6_mxsel3 = merge2_sel_byte6 |  rst_tri_en;
   
mux4ds #(8) align_byte2_1st_mx (
         .in0 (byte1[7:0]),
         .in1 (byte2[7:0]),
         .in2 (byte5[7:0]),
         .in3 (byte6[7:0]),
         .sel0(merge2_sel_byte1_mxsel0),
         .sel1(merge2_sel_byte2_mxsel1),
         .sel2(merge2_sel_byte5_mxsel2),
         .sel3(merge2_sel_byte6_mxsel3),
         .dout(align_byte2[7:0])                     
                                );
   
//assign	align_byte[23:16] = 	
//	zero_extend_g[2] ? 8'h00 :
//		sign_extend_g[2] ? 8'hff :
//				merge2_sel_byte ? align_byte2[7:0] :
//								8'hxx ;

//mux3ds #(8) align_byte2_2nd_mx  (
//         .in0 (8'h00),
//         .in1 (8'hff),
//         .in2 (align_byte2[7:0]),
//         .sel0(zero_extend_g[2]),
//         .sel1(sign_extend_g[2]),
//         .sel2(merge2_sel_byte),
//         .dout(align_byte[23:16])
//                                      );

assign    align_byte[23:16] =
( sign_extend_g[2] ? 8'hff : 8'h00) |
(  merge2_sel_byte ? align_byte2[7:0] : 8'h00);
                                 
// Final endian/justified/sign-extend Byte 3.
//assign	align_byte3[7:0]
//	= merge3_sel_byte0 ? byte0[7:0] :
//			merge3_sel_byte3 ? byte3[7:0] :
//				merge3_sel_byte4 ? byte4[7:0] :
// 				merge3_sel_byte7 ? byte7[7:0] :
//					  8'hxx ;

   wire       merge3_sel_byte0_mxsel0, merge3_sel_byte3_mxsel1, merge3_sel_byte4_mxsel2, merge3_sel_byte7_mxsel3;
   assign     merge3_sel_byte0_mxsel0 = merge3_sel_byte0 & ~rst_tri_en;
   assign     merge3_sel_byte3_mxsel1 = merge3_sel_byte3 & ~rst_tri_en;
   assign     merge3_sel_byte4_mxsel2 = merge3_sel_byte4 & ~rst_tri_en;
   assign     merge3_sel_byte7_mxsel3 = merge3_sel_byte7 |  rst_tri_en;
   
mux4ds #(8) align_byte3_1st_mx (
         .in0 (byte0[7:0]),
         .in1 (byte3[7:0]),
         .in2 (byte4[7:0]),
         .in3 (byte7[7:0]),
         .sel0(merge3_sel_byte0_mxsel0),
         .sel1(merge3_sel_byte3_mxsel1),
         .sel2(merge3_sel_byte4_mxsel2),
         .sel3(merge3_sel_byte7_mxsel3),
         .dout(align_byte3[7:0])
                                     );
   
//assign	align_byte[31:24] =	
//	zero_extend_g[3] ? 8'h00 :
//		sign_extend_g[3] ? 8'hff :
//			merge3_sel_byte ? align_byte3[7:0] :
//				8'hxx ;

//mux3ds #(8) align_byte3_2nd_mx (
//         .in0 (8'h00),
//         .in1 (8'hff), 
//         .in2 (align_byte3[7:0]),
//         .sel0(zero_extend_g[3]),
//         .sel1(sign_extend_g[3]),
//         .sel2(merge3_sel_byte),
//         .dout(align_byte[31:24])
//                                     );

assign    align_byte[31:24] =
  (sign_extend_g[3] ? 8'hff : 8'h00 ) |
  (merge3_sel_byte  ?  align_byte3[7:0] : 8'h00);
        
// Final endian/justified/sign-extend Byte 4.
//assign	align_byte[39:32]
//	= zero_extend_g[4] ? 8'h00 :
//		 sign_extend_g[4] ? 8'hff :
//       merge4_sel_byte3 ? byte3[7:0] : 
//         merge4_sel_byte4 ? byte4[7:0] : 
//           8'hxx;

//mux4ds #(8) align_byte4_mx (
//        .in0 (8'h00),
//        .in1 (8'hff),
//        .in2 (byte3[7:0]),
//        .in3 (byte4[7:0]),
//        .sel0(zero_extend_g[4]),
//        .sel1(sign_extend_g[4]),
//        .sel2(merge4_sel_byte3),
//        .sel3(merge4_sel_byte4),
//        .dout(align_byte[39:32])
//                                 );

assign align_byte[39:32] = 
  (sign_extend_g[4] ? 8'hff : 8'h00) |
  (merge4_sel_byte3 ? byte3[7:0] : 8'h00) |
  (merge4_sel_byte4 ? byte4[7:0] : 8'h00);
   
// Final endian/justified/sign-extend Byte 5.
//assign	align_byte[47:40]
//  = zero_extend_g[5] ? 8'h00 :
//		  sign_extend_g[5] ? 8'hff :
//	      merge5_sel_byte2 ? byte2[7:0] : 
//          merge5_sel_byte5 ? byte5[7:0] :
//            8'hxx ;

//mux4ds #(8) align_byte5_mx (
//        .in0 (8'h00),
//        .in1 (8'hff),
//        .in2 (byte2[7:0]),
//        .in3 (byte5[7:0]),
//        .sel0(zero_extend_g[5]),
//        .sel1(sign_extend_g[5]),
//        .sel2(merge5_sel_byte2),
//        .sel3(merge5_sel_byte5),
//        .dout(align_byte[47:40])
//                                 );
 
assign align_byte[47:40] =
 (sign_extend_g[5] ? 8'hff : 8'h00) |
 (merge5_sel_byte2 ? byte2[7:0] : 8'h00) |
 (merge5_sel_byte5 ? byte5[7:0] : 8'h00);
   
 
// Final endian/justified/sign-extend Byte 6.
//assign	align_byte[55:48]
//  = zero_extend_g[6] ? 8'h00 :
//		  sign_extend_g[6] ? 8'hff :     
//	      merge6_sel_byte1 ? byte1[7:0] : 
//         merge6_sel_byte6 ? byte6[7:0] :
//            8'hxx ;

//mux4ds #(8) align_byte6_mx (
//        .in0 (8'h00),
//        .in1 (8'hff),
//        .in2 (byte1[7:0]),
//        .in3 (byte6[7:0]),
//        .sel0(zero_extend_g[6]),
//        .sel1(sign_extend_g[6]),
//        .sel2(merge6_sel_byte1),
//        .sel3(merge6_sel_byte6),
//        .dout(align_byte[55:48])
//                                 );

assign  align_byte[55:48] = 
 (sign_extend_g[6] ? 8'hff : 8'h00) |
 (merge6_sel_byte1 ? byte1[7:0] : 8'h00) |
 (merge6_sel_byte6 ? byte6[7:0] : 8'h00);
       
 
// Final endian/justified/sign-extend Byte 7.
//assign	align_byte[63:56] =	
//	zero_extend_g[7] ? 8'h00 :
//		sign_extend_g[7] ? 8'hff :
//			merge7_sel_byte0 ? byte0[7:0] :
//  			merge7_sel_byte7 ? byte7[7:0] :
//					8'hxx ;

//mux4ds #(8) align_byte7_mx (
//        .in0 (8'h00),
//        .in1 (8'hff),
//        .in2 (byte0[7:0]),
//        .in3 (byte7[7:0]),
//        .sel0(zero_extend_g[7]),
//        .sel1(sign_extend_g[7]),
//        .sel2(merge7_sel_byte0),
//        .sel3(merge7_sel_byte7),
//        .dout(align_byte[63:56])
//                                 );

assign align_byte[63:56] =
  (sign_extend_g[7] ?  8'hff : 8'h00 ) |
  (merge7_sel_byte0 ?  byte0[7:0] : 8'h00) |
  (merge7_sel_byte7 ?  byte7[7:0] : 8'h00);
   
//====================================================
//dc_fill CP sign/zero control signals
//====================================================
   // wire [7:0] ld_data_msb_w0_m;
   // wire [7:0] ld_data_msb_w1_m;
   // wire [7:0] ld_data_msb_w2_m;
   // wire [7:0] ld_data_msb_w3_m;

   // wire [7:0] ld_data_msb_w0_g;
   // wire [7:0] ld_data_msb_w1_g;
   // wire [7:0] ld_data_msb_w2_g;
   // wire [7:0] ld_data_msb_w3_g;
   
// assign ld_data_msb_w0_m[7:0] = dcache_rdata_msb_w0_m[7:0];
// assign ld_data_msb_w1_m[7:0] = dcache_rdata_msb_w1_m[7:0];
// assign ld_data_msb_w2_m[7:0] = dcache_rdata_msb_w2_m[7:0];
// assign ld_data_msb_w3_m[7:0] = dcache_rdata_msb_w3_m[7:0];

  wire [7:0] ld_data_msb_w0_m;
  reg [7:0] ld_data_msb_w0_g;
  assign ld_data_msb_w0_m[7:0] = dcache_rdata_msb_w0_m[7:0];


  wire [7:0] ld_data_msb_w1_m;
  reg [7:0] ld_data_msb_w1_g;
  assign ld_data_msb_w1_m[7:0] = dcache_rdata_msb_w1_m[7:0];


  wire [7:0] ld_data_msb_w2_m;
  reg [7:0] ld_data_msb_w2_g;
  assign ld_data_msb_w2_m[7:0] = dcache_rdata_msb_w2_m[7:0];


  wire [7:0] ld_data_msb_w3_m;
  reg [7:0] ld_data_msb_w3_g;
  assign ld_data_msb_w3_m[7:0] = dcache_rdata_msb_w3_m[7:0];


   
// dff_s #(32) ld_data_msb_stgg (
//         .din    ({ld_data_msb_w0_m[7:0], ld_data_msb_w1_m[7:0], ld_data_msb_w2_m[7:0], ld_data_msb_w3_m[7:0]}),
//         .q      ({ld_data_msb_w0_g[7:0], ld_data_msb_w1_g[7:0], ld_data_msb_w2_g[7:0], ld_data_msb_w3_g[7:0]}),
//         .clk    (clk),
//         .se     (se),       .si (),          .so ()
//         );

always @ (posedge clk)
begin

  ld_data_msb_w0_g[7:0] <= ld_data_msb_w0_m[7:0];


  ld_data_msb_w1_g[7:0] <= ld_data_msb_w1_m[7:0];


  ld_data_msb_w2_g[7:0] <= ld_data_msb_w2_m[7:0];


  ld_data_msb_w3_g[7:0] <= ld_data_msb_w3_m[7:0];


end

   wire [4-1:0] dcache_alt_rsel_way_m;
   wire       dcache_alt_mx_sel_m;
   
dff_s #(4+1) dcache_alt_stgm  (
        .din    ({lsu_bist_rsel_way_e[4-1:0],  dcache_alt_mx_sel_e}),
        .q      ({dcache_alt_rsel_way_m[4-1:0], dcache_alt_mx_sel_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire [4-1:0] dcache_alt_rsel_way_g;
   wire       dcache_alt_mx_sel_g;
   
dff_s #(4+1) dcache_alt_stgg  (
        .din    ({dcache_alt_rsel_way_m[4-1:0],  dcache_alt_mx_sel_m}),
        .q      ({dcache_alt_rsel_way_g[4-1:0],  dcache_alt_mx_sel_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   wire [4-1:0] cache_way_mx_sel;
   
   assign     cache_way_mx_sel [4-1:0] = dcache_alt_mx_sel_g ? dcache_alt_rsel_way_g[4-1:0] : cache_way_hit_buf2[4-1:0];

//   wire [7:0] align_bytes_msb;
   
//mux4ds  #(8) align_bytes_msb_mux (
//        .in0    (ld_data_msb_w0_g[7:0]),
//        .in1    (ld_data_msb_w1_g[7:0]),
//        .in2    (ld_data_msb_w2_g[7:0]),
//        .in3    (ld_data_msb_w3_g[7:0]),
//        .sel0   (cache_way_mx_sel[0]),  
//        .sel1   (cache_way_mx_sel[1]),
//        .sel2   (cache_way_mx_sel[2]),  
//        .sel3   (cache_way_mx_sel[3]),
//        .dout   (align_bytes_msb[7:0])
//);

   wire       signed_ldst_byte_g;
   wire       signed_ldst_hw_g;
   wire       signed_ldst_w_g;
   
dff_s #(3) ldst_size_stgg(
 .din    ({signed_ldst_byte_m, signed_ldst_hw_m, signed_ldst_w_m}),
 .q      ({signed_ldst_byte_g, signed_ldst_hw_g, signed_ldst_w_g}),
 .clk    (clk),
 .se     (se),       .si (),          .so ()
);

wire [7:0] morphed_addr_g;
   
dff_s #(8) stgg_morphadd(
        .din    (morphed_addr_m[7:0]),
        .q      (morphed_addr_g[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   // wire       sign_bit_w0_g, sign_bit_w1_g, sign_bit_w2_g, sign_bit_w3_g;

// assign  sign_bit_w0_g =
//   (morphed_addr_g[0] & ld_data_msb_w0_g[7]) |
//   (morphed_addr_g[1] & ld_data_msb_w0_g[6]) |
//   (morphed_addr_g[2] & ld_data_msb_w0_g[5]) |
//   (morphed_addr_g[3] & ld_data_msb_w0_g[4]) |
//   (morphed_addr_g[4] & ld_data_msb_w0_g[3]) |
//   (morphed_addr_g[5] & ld_data_msb_w0_g[2]) |
//   (morphed_addr_g[6] & ld_data_msb_w0_g[1]) |
//   (morphed_addr_g[7] & ld_data_msb_w0_g[0]) ;

// assign  sign_bit_w1_g =
//   (morphed_addr_g[0] & ld_data_msb_w1_g[7]) |
//   (morphed_addr_g[1] & ld_data_msb_w1_g[6]) |
//   (morphed_addr_g[2] & ld_data_msb_w1_g[5]) |
//   (morphed_addr_g[3] & ld_data_msb_w1_g[4]) |
//   (morphed_addr_g[4] & ld_data_msb_w1_g[3]) |
//   (morphed_addr_g[5] & ld_data_msb_w1_g[2]) |
//   (morphed_addr_g[6] & ld_data_msb_w1_g[1]) |
//   (morphed_addr_g[7] & ld_data_msb_w1_g[0]) ;

// assign  sign_bit_w2_g =
//   (morphed_addr_g[0] & ld_data_msb_w2_g[7]) |
//   (morphed_addr_g[1] & ld_data_msb_w2_g[6]) |
//   (morphed_addr_g[2] & ld_data_msb_w2_g[5]) |
//   (morphed_addr_g[3] & ld_data_msb_w2_g[4]) |
//   (morphed_addr_g[4] & ld_data_msb_w2_g[3]) |
//   (morphed_addr_g[5] & ld_data_msb_w2_g[2]) |
//   (morphed_addr_g[6] & ld_data_msb_w2_g[1]) |
//   (morphed_addr_g[7] & ld_data_msb_w2_g[0]) ;

// assign  sign_bit_w3_g =
//   (morphed_addr_g[0] & ld_data_msb_w3_g[7]) |
//   (morphed_addr_g[1] & ld_data_msb_w3_g[6]) |
//   (morphed_addr_g[2] & ld_data_msb_w3_g[5]) |
//   (morphed_addr_g[3] & ld_data_msb_w3_g[4]) |
//   (morphed_addr_g[4] & ld_data_msb_w3_g[3]) |
//   (morphed_addr_g[5] & ld_data_msb_w3_g[2]) |
//   (morphed_addr_g[6] & ld_data_msb_w3_g[1]) |
//   (morphed_addr_g[7] & ld_data_msb_w3_g[0]) ;


  wire  sign_bit_w0_g =
    (morphed_addr_g[0] & ld_data_msb_w0_g[7]) |
    (morphed_addr_g[1] & ld_data_msb_w0_g[6]) |
    (morphed_addr_g[2] & ld_data_msb_w0_g[5]) |
    (morphed_addr_g[3] & ld_data_msb_w0_g[4]) |
    (morphed_addr_g[4] & ld_data_msb_w0_g[3]) |
    (morphed_addr_g[5] & ld_data_msb_w0_g[2]) |
    (morphed_addr_g[6] & ld_data_msb_w0_g[1]) |
    (morphed_addr_g[7] & ld_data_msb_w0_g[0]) ;


  wire  sign_bit_w1_g =
    (morphed_addr_g[0] & ld_data_msb_w1_g[7]) |
    (morphed_addr_g[1] & ld_data_msb_w1_g[6]) |
    (morphed_addr_g[2] & ld_data_msb_w1_g[5]) |
    (morphed_addr_g[3] & ld_data_msb_w1_g[4]) |
    (morphed_addr_g[4] & ld_data_msb_w1_g[3]) |
    (morphed_addr_g[5] & ld_data_msb_w1_g[2]) |
    (morphed_addr_g[6] & ld_data_msb_w1_g[1]) |
    (morphed_addr_g[7] & ld_data_msb_w1_g[0]) ;


  wire  sign_bit_w2_g =
    (morphed_addr_g[0] & ld_data_msb_w2_g[7]) |
    (morphed_addr_g[1] & ld_data_msb_w2_g[6]) |
    (morphed_addr_g[2] & ld_data_msb_w2_g[5]) |
    (morphed_addr_g[3] & ld_data_msb_w2_g[4]) |
    (morphed_addr_g[4] & ld_data_msb_w2_g[3]) |
    (morphed_addr_g[5] & ld_data_msb_w2_g[2]) |
    (morphed_addr_g[6] & ld_data_msb_w2_g[1]) |
    (morphed_addr_g[7] & ld_data_msb_w2_g[0]) ;


  wire  sign_bit_w3_g =
    (morphed_addr_g[0] & ld_data_msb_w3_g[7]) |
    (morphed_addr_g[1] & ld_data_msb_w3_g[6]) |
    (morphed_addr_g[2] & ld_data_msb_w3_g[5]) |
    (morphed_addr_g[3] & ld_data_msb_w3_g[4]) |
    (morphed_addr_g[4] & ld_data_msb_w3_g[3]) |
    (morphed_addr_g[5] & ld_data_msb_w3_g[2]) |
    (morphed_addr_g[6] & ld_data_msb_w3_g[1]) |
    (morphed_addr_g[7] & ld_data_msb_w3_g[0]) ;


   
//assign  sign_bit_g =
//  (morphed_addr_g[0] & align_bytes_msb[7]) |
//  (morphed_addr_g[1] & align_bytes_msb[6]) |
//  (morphed_addr_g[2] & align_bytes_msb[5]) |
//  (morphed_addr_g[3] & align_bytes_msb[4]) |
//  (morphed_addr_g[4] & align_bytes_msb[3]) |
//  (morphed_addr_g[5] & align_bytes_msb[2]) |
//  (morphed_addr_g[6] & align_bytes_msb[1]) |
//  (morphed_addr_g[7] & align_bytes_msb[0]) ;


//dff #(4) ssign_bit_stgg (
//        .din    ({sign_bit_w0_m, sign_bit_w1_m, sign_bit_w2_m, sign_bit_w3_m}),
//        .q      ({sign_bit_w0_g, sign_bit_w1_g, sign_bit_w2_g, sign_bit_w3_g}),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );
   
//    wire [7:1] lsu_byp_byte_sign_extend_w0;
// assign  lsu_byp_byte_sign_extend_w0[1] =
//         signed_ldst_byte_g & sign_bit_w0_g;
// assign  lsu_byp_byte_sign_extend_w0[2] =
//         signed_ldst_hw_g & sign_bit_w0_g;
// assign  lsu_byp_byte_sign_extend_w0[3] =
//         lsu_byp_byte_sign_extend_w0[2] ;
// assign  lsu_byp_byte_sign_extend_w0[4] =
//         signed_ldst_w_g & sign_bit_w0_g;
// assign  lsu_byp_byte_sign_extend_w0[5] =
//     lsu_byp_byte_sign_extend_w0[4] ;
// assign  lsu_byp_byte_sign_extend_w0[6] =
//     lsu_byp_byte_sign_extend_w0[4] ;
// assign  lsu_byp_byte_sign_extend_w0[7] =
//     lsu_byp_byte_sign_extend_w0[4] ;

//    wire [7:1] lsu_byp_byte_sign_extend_w1;
// assign  lsu_byp_byte_sign_extend_w1[1] =
//         signed_ldst_byte_g & sign_bit_w1_g;
// assign  lsu_byp_byte_sign_extend_w1[2] =
//         signed_ldst_hw_g & sign_bit_w1_g;
// assign  lsu_byp_byte_sign_extend_w1[3] =
//         lsu_byp_byte_sign_extend_w1[2] ;
// assign  lsu_byp_byte_sign_extend_w1[4] =
//         signed_ldst_w_g & sign_bit_w1_g;
// assign  lsu_byp_byte_sign_extend_w1[5] =
//     lsu_byp_byte_sign_extend_w1[4] ;
// assign  lsu_byp_byte_sign_extend_w1[6] =
//     lsu_byp_byte_sign_extend_w1[4] ;
// assign  lsu_byp_byte_sign_extend_w1[7] =
//     lsu_byp_byte_sign_extend_w1[4] ;

// //w2
// //   wire [3:1] lsu_byp_byte_zero_extend_w2;
//    wire [7:1] lsu_byp_byte_sign_extend_w2;
   
// //assign  lsu_byp_byte_zero_extend_w2[1] =
// //        unsigned_ldst_byte_g | (signed_ldst_byte_g & ~sign_bit_w2_g);
   
// assign  lsu_byp_byte_sign_extend_w2[1] =
//         signed_ldst_byte_g & sign_bit_w2_g;
 
// //assign  lsu_byp_byte_zero_extend_w2[2] =
// //        unsigned_ldst_hw_g | (signed_ldst_hw_g & ~sign_bit_w2_g);

// assign  lsu_byp_byte_sign_extend_w2[2] =
//         signed_ldst_hw_g & sign_bit_w2_g;
   
// //assign  lsu_byp_byte_zero_extend_w2[3] =
// //        lsu_byp_byte_zero_extend_w2[2] ;

// assign  lsu_byp_byte_sign_extend_w2[3] =
//         lsu_byp_byte_sign_extend_w2[2] ;

// //assign  lsu_byp_byte_zero_extend_w2[4] =
// //        unsigned_ldst_w_g | (signed_ldst_w_g & ~sign_bit_w2_g);
   
// assign  lsu_byp_byte_sign_extend_w2[4] =
//         signed_ldst_w_g & sign_bit_w2_g;
        
// //assign  lsu_byp_byte_zero_extend_w2[5] =
// //    lsu_byp_byte_zero_extend_w2[4] ;
// assign  lsu_byp_byte_sign_extend_w2[5] =
//     lsu_byp_byte_sign_extend_w2[4] ;
// //assign  lsu_byp_byte_zero_extend_w2[6] =
// //    lsu_byp_byte_zero_extend_w2[4] ;
// assign  lsu_byp_byte_sign_extend_w2[6] =
//     lsu_byp_byte_sign_extend_w2[4] ;
// //assign  lsu_byp_byte_zero_extend_w2[7] =
// //    lsu_byp_byte_zero_extend_w2[4] ;
// assign  lsu_byp_byte_sign_extend_w2[7] =
//     lsu_byp_byte_sign_extend_w2[4] ;

// //w3
// //   wire [3:1] lsu_byp_byte_zero_extend_w3;
//    wire [7:1] lsu_byp_byte_sign_extend_w3;
   
// //assign  lsu_byp_byte_zero_extend_w3[1] =
// //        unsigned_ldst_byte_g | (signed_ldst_byte_g & ~sign_bit_w3_g);
   
// assign  lsu_byp_byte_sign_extend_w3[1] =
//         signed_ldst_byte_g & sign_bit_w3_g;
 
// //assign  lsu_byp_byte_zero_extend_w3[2] =
// //        unsigned_ldst_hw_g | (signed_ldst_hw_g & ~sign_bit_w3_g);

// assign  lsu_byp_byte_sign_extend_w3[2] =
//         signed_ldst_hw_g & sign_bit_w3_g;
   
// //assign  lsu_byp_byte_zero_extend_w3[3] =
// //        lsu_byp_byte_zero_extend_w3[2] ;

// assign  lsu_byp_byte_sign_extend_w3[3] =
//         lsu_byp_byte_sign_extend_w3[2] ;

// //assign  lsu_byp_byte_zero_extend_w3[4] =
// //        unsigned_ldst_w_g | (signed_ldst_w_g & ~sign_bit_w3_g);
   
// assign  lsu_byp_byte_sign_extend_w3[4] =
//         signed_ldst_w_g & sign_bit_w3_g;
        
// //assign  lsu_byp_byte_zero_extend_w3[5] =
// //    lsu_byp_byte_zero_extend_w3[4] ;
// assign  lsu_byp_byte_sign_extend_w3[5] =
//     lsu_byp_byte_sign_extend_w3[4] ;
// //assign  lsu_byp_byte_zero_extend_w3[6] =
// //    lsu_byp_byte_zero_extend_w3[4] ;
// assign  lsu_byp_byte_sign_extend_w3[6] =
//     lsu_byp_byte_sign_extend_w3[4] ;
// //assign  lsu_byp_byte_zero_extend_w3[7] =
// //    lsu_byp_byte_zero_extend_w3[4] ;
// assign  lsu_byp_byte_sign_extend_w3[7] =
//     lsu_byp_byte_sign_extend_w3[4] ;



  wire [7:1] lsu_byp_byte_sign_extend_w0;
  assign  lsu_byp_byte_sign_extend_w0[1] =
          signed_ldst_byte_g & sign_bit_w0_g;
  assign  lsu_byp_byte_sign_extend_w0[2] =
          signed_ldst_hw_g & sign_bit_w0_g;
  assign  lsu_byp_byte_sign_extend_w0[3] =
          lsu_byp_byte_sign_extend_w0[2] ;
  assign  lsu_byp_byte_sign_extend_w0[4] =
          signed_ldst_w_g & sign_bit_w0_g;
  assign  lsu_byp_byte_sign_extend_w0[5] =
          lsu_byp_byte_sign_extend_w0[4] ;
  assign  lsu_byp_byte_sign_extend_w0[6] =
          lsu_byp_byte_sign_extend_w0[4] ;
  assign  lsu_byp_byte_sign_extend_w0[7] =
          lsu_byp_byte_sign_extend_w0[4] ;


  wire [7:1] lsu_byp_byte_sign_extend_w1;
  assign  lsu_byp_byte_sign_extend_w1[1] =
          signed_ldst_byte_g & sign_bit_w1_g;
  assign  lsu_byp_byte_sign_extend_w1[2] =
          signed_ldst_hw_g & sign_bit_w1_g;
  assign  lsu_byp_byte_sign_extend_w1[3] =
          lsu_byp_byte_sign_extend_w1[2] ;
  assign  lsu_byp_byte_sign_extend_w1[4] =
          signed_ldst_w_g & sign_bit_w1_g;
  assign  lsu_byp_byte_sign_extend_w1[5] =
          lsu_byp_byte_sign_extend_w1[4] ;
  assign  lsu_byp_byte_sign_extend_w1[6] =
          lsu_byp_byte_sign_extend_w1[4] ;
  assign  lsu_byp_byte_sign_extend_w1[7] =
          lsu_byp_byte_sign_extend_w1[4] ;


  wire [7:1] lsu_byp_byte_sign_extend_w2;
  assign  lsu_byp_byte_sign_extend_w2[1] =
          signed_ldst_byte_g & sign_bit_w2_g;
  assign  lsu_byp_byte_sign_extend_w2[2] =
          signed_ldst_hw_g & sign_bit_w2_g;
  assign  lsu_byp_byte_sign_extend_w2[3] =
          lsu_byp_byte_sign_extend_w2[2] ;
  assign  lsu_byp_byte_sign_extend_w2[4] =
          signed_ldst_w_g & sign_bit_w2_g;
  assign  lsu_byp_byte_sign_extend_w2[5] =
          lsu_byp_byte_sign_extend_w2[4] ;
  assign  lsu_byp_byte_sign_extend_w2[6] =
          lsu_byp_byte_sign_extend_w2[4] ;
  assign  lsu_byp_byte_sign_extend_w2[7] =
          lsu_byp_byte_sign_extend_w2[4] ;


  wire [7:1] lsu_byp_byte_sign_extend_w3;
  assign  lsu_byp_byte_sign_extend_w3[1] =
          signed_ldst_byte_g & sign_bit_w3_g;
  assign  lsu_byp_byte_sign_extend_w3[2] =
          signed_ldst_hw_g & sign_bit_w3_g;
  assign  lsu_byp_byte_sign_extend_w3[3] =
          lsu_byp_byte_sign_extend_w3[2] ;
  assign  lsu_byp_byte_sign_extend_w3[4] =
          signed_ldst_w_g & sign_bit_w3_g;
  assign  lsu_byp_byte_sign_extend_w3[5] =
          lsu_byp_byte_sign_extend_w3[4] ;
  assign  lsu_byp_byte_sign_extend_w3[6] =
          lsu_byp_byte_sign_extend_w3[4] ;
  assign  lsu_byp_byte_sign_extend_w3[7] =
          lsu_byp_byte_sign_extend_w3[4] ;



//mux4ds  #(14) zero_sign_sel_mux (
//        .in0    ({lsu_byp_byte_zero_extend_w0[7:1],lsu_byp_byte_sign_extend_w0[7:1]}),
//        .in1    ({lsu_byp_byte_zero_extend_w1[7:1],lsu_byp_byte_sign_extend_w1[7:1]}),
//        .in2    ({lsu_byp_byte_zero_extend_w2[7:1],lsu_byp_byte_sign_extend_w2[7:1]}),
//        .in3    ({lsu_byp_byte_zero_extend_w3[7:1],lsu_byp_byte_sign_extend_w3[7:1]}),
//        .sel0   (cache_way_mx_sel[0]),  
//        .sel1   (cache_way_mx_sel[1]),
//        .sel2   (cache_way_mx_sel[2]),  
//        .sel3   (cache_way_mx_sel[3]),
//        .dout   ({lsu_byp_byte_zero_extend[7:1],lsu_byp_byte_sign_extend[7:1]})
//);

//assign lsu_byp_byte_zero_extend[3:1] =
//   (cache_way_mx_sel[0] ?  lsu_byp_byte_zero_extend_w0[3:1] : 3'b0 ) |   
//   (cache_way_mx_sel[1] ?  lsu_byp_byte_zero_extend_w1[3:1] : 3'b0 ) |   
//   (cache_way_mx_sel[2] ?  lsu_byp_byte_zero_extend_w2[3:1] : 3'b0 ) |   
//   (cache_way_mx_sel[3] ?  lsu_byp_byte_zero_extend_w3[3:1] : 3'b0 ) ;

// assign lsu_byp_byte_sign_extend[7:1] = 
//    (cache_way_mx_sel[0] ?  lsu_byp_byte_sign_extend_w0[7:1] : 7'b0) |
//    (cache_way_mx_sel[1] ?  lsu_byp_byte_sign_extend_w1[7:1] : 7'b0) |
//    (cache_way_mx_sel[2] ?  lsu_byp_byte_sign_extend_w2[7:1] : 7'b0) |
//    (cache_way_mx_sel[3] ?  lsu_byp_byte_sign_extend_w3[7:1] : 7'b0) ;

always @ *
begin

  lsu_byp_byte_sign_extend[7:1]
 = 0;
if (
  cache_way_mx_sel[0]
)
   
  lsu_byp_byte_sign_extend[7:1]
 = 
  lsu_byp_byte_sign_extend[7:1]
 | 
  lsu_byp_byte_sign_extend_w0[7:1]
;
if (
  cache_way_mx_sel[1]
)
   
  lsu_byp_byte_sign_extend[7:1]
 = 
  lsu_byp_byte_sign_extend[7:1]
 | 
  lsu_byp_byte_sign_extend_w1[7:1]
;
if (
  cache_way_mx_sel[2]
)
   
  lsu_byp_byte_sign_extend[7:1]
 = 
  lsu_byp_byte_sign_extend[7:1]
 | 
  lsu_byp_byte_sign_extend_w2[7:1]
;
if (
  cache_way_mx_sel[3]
)
   
  lsu_byp_byte_sign_extend[7:1]
 = 
  lsu_byp_byte_sign_extend[7:1]
 | 
  lsu_byp_byte_sign_extend_w3[7:1]
;
end


dff_s #(37) stgg_mergesel(
        .din    ({
         merge7_sel_byte0_m, merge7_sel_byte7_m,
         merge6_sel_byte1_m, merge6_sel_byte6_m,
         merge5_sel_byte2_m, merge5_sel_byte5_m,
         merge4_sel_byte3_m, merge4_sel_byte4_m,
         merge3_sel_byte0_m, merge3_sel_byte3_m,
         merge3_sel_byte4_m, merge3_sel_byte7_default_m, merge3_sel_byte_m,
         merge2_sel_byte1_m, merge2_sel_byte2_m,         merge2_sel_byte5_m,
         merge2_sel_byte6_default_m, merge2_sel_byte_m,
         merge0_sel_byte0_m, merge0_sel_byte1_m,
         merge0_sel_byte2_m, merge0_sel_byte3_default_m,
         merge0_sel_byte4_m, merge0_sel_byte5_m,
         merge0_sel_byte6_m, merge0_sel_byte7_default_m,
         merge1_sel_byte0_m, merge1_sel_byte1_m,
         merge1_sel_byte2_m, merge1_sel_byte3_default_m,
         merge1_sel_byte4_m, merge1_sel_byte5_m,
         merge1_sel_byte6_m, merge1_sel_byte7_default_m,
         merge0_sel_byte_1h_m,merge1_sel_byte_1h_m, merge1_sel_byte_2h_m
                }),
        .q      ({
         merge7_sel_byte0, merge7_sel_byte7,
         merge6_sel_byte1, merge6_sel_byte6,
         merge5_sel_byte2, merge5_sel_byte5,
         merge4_sel_byte3, merge4_sel_byte4,
         merge3_sel_byte0, merge3_sel_byte3,
         merge3_sel_byte4, merge3_sel_byte7,merge3_sel_byte,
         merge2_sel_byte1, merge2_sel_byte2, merge2_sel_byte5,
         merge2_sel_byte6, merge2_sel_byte,
         merge0_sel_byte0, merge0_sel_byte1,
         merge0_sel_byte2, merge0_sel_byte3,
         merge0_sel_byte4, merge0_sel_byte5,
         merge0_sel_byte6, merge0_sel_byte7,
         merge1_sel_byte0, merge1_sel_byte1,
         merge1_sel_byte2, merge1_sel_byte3,
         merge1_sel_byte4, merge1_sel_byte5,
         merge1_sel_byte6, merge1_sel_byte7,
         merge0_sel_byte_1h,merge1_sel_byte_1h, merge1_sel_byte_2h
                }),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


assign 	lsu_exu_dfill_data_w2[63:0] = align_byte[63:0] ; 
assign	lsu_ffu_ld_data[63:0] = align_byte[63:0] ;

endmodule


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_dctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================


// devices.xml



/////////////////////////////////////////////////////////////////
/*
//  Description:  LSU Data Cache Control and Minor Datapath
//      - Tag Comparison - hit/miss.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
          // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module lsu_dctl ( /*AUTOARG*/
   // Outputs
  
  csm_rd_vld_g, lsu_tlb_csm_rd_vld_g, lsu_dtlb_csm_rd_e, lsu_blkst_csm_m,
  
   stb_ncache_pcx_rq_g,
   lsu_tlu_nucleus_ctxt_m, lsu_quad_word_access_g, so, dctl_rst_l, 
   lsu_tlu_wsr_inst_e, lsu_l2fill_fpld_e, dva_vld_m_bf, 
   lsu_no_spc_pref, ifu_tlu_flush_fd_w, ifu_tlu_flush_fd2_w, 
   ifu_tlu_flush_fd3_w, ifu_lsu_flush_w, lsu_tlu_thrid_d, 
   lsu_diagnstc_data_sel, lsu_diagnstc_va_sel, lsu_err_addr_sel, 
   dva_bit_wr_en_e, dva_wr_adr_e, lsu_exu_ldst_miss_w2, 
   lsu_exu_dfill_vld_w2, lsu_ffu_ld_vld, lsu_ld_miss_wb, 
   lsu_dtlb_bypass_e, ld_pcx_pkt_g, tlb_ldst_cam_vld, ldxa_internal, 
   lsu_ifu_ldsta_internal_e, lsu_ifu_ldst_cmplt, lsu_ifu_itlb_en, 
   lsu_ifu_icache_en, lmq_byp_data_en_w2, lmq_byp_data_fmx_sel, 
   lmq_byp_data_mxsel0, lmq_byp_data_mxsel1, lmq_byp_data_mxsel2, 
   lmq_byp_data_mxsel3, lmq_byp_ldxa_mxsel0, lmq_byp_ldxa_mxsel1, 
   lmq_byp_ldxa_mxsel2, lmq_byp_ldxa_mxsel3, lsu_ld_thrd_byp_sel_e, 
   dcache_byte_wr_en_e, lsu_dcache_wr_vld_e, lsu_ldstub_g, 
   lsu_swap_g, lsu_tlu_dtlb_done, lsu_exu_thr_m, merge7_sel_byte0_m, 
   merge7_sel_byte7_m, merge6_sel_byte1_m, merge6_sel_byte6_m, 
   merge5_sel_byte2_m, merge5_sel_byte5_m, merge4_sel_byte3_m, 
   merge4_sel_byte4_m, merge3_sel_byte0_m, merge3_sel_byte3_m, 
   merge3_sel_byte4_m, merge3_sel_byte7_default_m, merge3_sel_byte_m, 
   merge2_sel_byte1_m, merge2_sel_byte2_m, merge2_sel_byte5_m, 
   merge2_sel_byte6_default_m, merge2_sel_byte_m, merge0_sel_byte0_m, 
   merge0_sel_byte1_m, merge0_sel_byte2_m, 
   merge0_sel_byte3_default_m, merge0_sel_byte4_m, 
   merge0_sel_byte5_m, merge0_sel_byte6_m, 
   merge0_sel_byte7_default_m, merge1_sel_byte0_m, 
   merge1_sel_byte1_m, merge1_sel_byte2_m, 
   merge1_sel_byte3_default_m, merge1_sel_byte4_m, 
   merge1_sel_byte5_m, merge1_sel_byte6_m, 
   merge1_sel_byte7_default_m, merge0_sel_byte_1h_m, 
   merge1_sel_byte_1h_m, merge1_sel_byte_2h_m, lsu_dtlb_cam_real_e, 
   lsu_dtagv_wr_vld_e, lsu_dtag_wrreq_x_e, lsu_dtag_index_sel_x_e, 
   lsu_dtlb_wr_vld_e, lsu_dtlb_tag_rd_e, lsu_dtlb_data_rd_e, 
   lsu_dtlb_dmp_vld_e, lsu_dtlb_dmp_all_e, lsu_dtlb_rwindex_vld_e, 
   lsu_dtlb_invalid_all_l_m, lsu_tlu_tlb_ld_inst_m, 
   lsu_tlu_tlb_st_inst_m, lsu_tlu_tlb_access_tid_m, 
   lsu_tlb_data_rd_vld_g, lsu_tlb_st_sel_m, lsu_va_wtchpt0_wr_en_l, 
   lsu_va_wtchpt1_wr_en_l, lsu_va_wtchpt2_wr_en_l, 
   lsu_va_wtchpt3_wr_en_l, thread0_m, thread1_m, thread2_m, 
   thread3_m, lsu_dctldp_thread0_m, lsu_dctldp_thread1_m, 
   lsu_dctldp_thread2_m, lsu_dctldp_thread3_m, thread0_g, thread1_g, 
   thread2_g, thread3_g, lsu_tlu_nonalt_ldst_m, 
   lsu_tlu_xslating_ldst_m, lsu_tlu_ctxt_sel_m, lsu_tlu_write_op_m, 
   lsu_dtlb_addr_mask_l_e, dva_din_e, 
   lsu_diagnstc_dtagv_prty_invrt_e, lsu_ifu_asi_load, 
   lsu_ifu_asi_thrid, lsu_ifu_asi_vld, lsu_quad_asi_e, 
   lsu_local_ldxa_sel_g, lsu_dtag_rsel_m, lsu_tlbop_force_swo, 
   lsu_atomic_pkt2_bsel_g, lsu_dcache_tag_perror_g, 
   lsu_dcache_data_perror_g, lsu_ifu_l2_unc_error, 
   lsu_ifu_l2_corr_error, lsu_ifu_dcache_data_perror, 
   lsu_ifu_dcache_tag_perror, lsu_ifu_error_tid, lsu_ifu_io_error, 
   lsu_tlu_squash_va_oor_m, lsu_squash_va_oor_m, tlb_cam_hit_g, 
   lsu_st_hw_le_g, lsu_st_w_or_dbl_le_g, lsu_st_x_le_g, 
   lsu_swap_sel_default_g, lsu_swap_sel_default_byte_7_2_g, 
   lsu_st_rmo_m, lsu_bst_in_pipe_m, lsu_snap_blk_st_m, lsu_blk_st_m, 
   lsu_blkst_pgnum_m, lsu_ffu_blk_asi_e, lsu_blk_asi_m, 
   lsu_nonalt_nucl_access_m, dcache_alt_mx_sel_e, 
   dcache_alt_mx_sel_e_bf, dcache_rvld_e, lsu_dc_iob_access_e, 
   lsu_ifu_ldst_miss_w, lsu_ifu_dc_parity_error_w2, 
   lsu_ldst_inst_vld_e, lsu_local_ldxa_tlbrd_sel_g, 
   lsu_local_diagnstc_tagrd_sel_g, lsu_va_wtchpt_sel_g, 
   asi_state_wr_thrd, thread0_d, thread1_d, thread2_d, thread3_d, 
   tlu_lsu_asi_update_g, pctxt_state_wr_thrd, sctxt_state_wr_thrd, 
   thread_pctxt, thread_sctxt, thread_actxt, thread_default, 
   thread0_ctxt, thread1_ctxt, thread2_ctxt, thread3_ctxt, 
   pid_state_wr_en, thread0_e, thread1_e, thread2_e, thread3_e, 
   dfture_tap_wr_mx_sel, lctl_rst, lsu_ctl_state_wr_en, 
   lsuctl_ctlbits_wr_en, dfture_tap_rd_en, bist_tap_wr_en, 
   bistctl_wr_en, bist_ctl_reg_wr_en, mrgn_tap_wr_en, ldiagctl_wr_en, 
   misc_ctl_sel_din, lsu_asi_sel_fmx1, lsu_asi_sel_fmx2, 
   tlb_access_en0_g, tlb_access_en1_g, tlb_access_en2_g, 
   tlb_access_en3_g, tlb_access_sel_thrd0, tlb_access_sel_thrd1, 
   tlb_access_sel_thrd2, tlb_access_sel_default, mrgnctl_wr_en, 
   hpv_priv_m, hpstate_en_m, dcache_arry_data_sel_m, dtlb_bypass_m, 
   lsu_alt_space_m, atomic_m, ldst_dbl_m, fp_ldst_m, lda_internal_m, 
   sta_internal_m, cam_real_m, data_rd_vld_g, tag_rd_vld_g, 
   ldst_sz_m, asi_internal_m, rd_only_ltlb_asi_e, wr_only_ltlb_asi_e, 
   dfill_tlb_asi_e, ifill_tlb_asi_e, nofault_asi_m, as_if_user_asi_m, 
   atomic_asi_m, phy_use_ec_asi_m, phy_byp_ec_asi_m, quad_asi_m, 
   binit_quad_asi_m, blk_asi_m, recognized_asi_m, strm_asi_m, 
   mmu_rd_only_asi_m, rd_only_asi_m, wr_only_asi_m, unimp_asi_m, 
   va_wtchpt_cmp_en_m, lsu_tlu_async_ttype_vld_w2, 
   lsu_tlu_async_ttype_w2, lsu_tlu_async_tid_w2, async_tlb_index, 
   l2fill_vld_m, ld_thrd_byp_mxsel_m, morphed_addr_m, 
   signed_ldst_byte_m, signed_ldst_hw_m, signed_ldst_w_m, 
   lsu_tlb_asi_data_perr_g, lsu_tlb_asi_tag_perr_g, lsu_sscan_data, 
   lsu_ld_inst_vld_g, lsu_dcache_rand, lsu_encd_way_hit, 
   lsu_way_hit_or, lsu_memref_m, lsu_flsh_inst_m, 
   lsu_ifu_asi_data_en_l, lsu_dcache_fill_addr_e, 
   lsu_dcache_fill_addr_e_err, lsu_thread_g, lmq_ldd_vld, 
   lsu_bist_rsel_way_e, lsu_dcache_fill_way_e, lmq_ld_addr_b3, 
   lsu_outstanding_rmo_st_max, lsu_dcfill_data_mx_sel_e, 
   // Inputs

  
   tlu_dtlb_csm_rd_g, tlb_rd_tte_csm,
  
   si, se, sehold, rst_tri_en, rclk, grst_l, arst_l, 
   lsu_diag_va_prty_invrt, dva_svld_e, dva_snp_bit_wr_en_e, 
   dva_snp_addr_e, lsu_tte_data_cp_g, lsu_l2fill_vld, ld_inst_vld_e, 
   st_inst_vld_e, ifu_lsu_ldst_fp_e, ldst_sz_e, 
   lsu_ldst_va_b12_b11_m, lsu_ldst_va_b7_b0_m, ifu_lsu_rd_e, 
   tlb_cam_hit, ifu_tlu_sraddr_d, ifu_tlu_wsr_inst_d, 
   ifu_lsu_alt_space_d, tlu_lsu_int_ldxa_vld_w2, 
   tlu_lsu_int_ld_ill_va_w2, tlu_lsu_ldxa_tid_w2, 
   ifu_lsu_ldxa_data_vld_w2, ifu_lsu_ldxa_illgl_va_w2, 
   ifu_lsu_ldxa_tid_w2, ifu_lsu_asi_rd_unc, tlu_lsu_tl_zero, 
   ifu_lsu_thrid_s, ifu_lsu_ldst_dbl_e, ld_stb_full_raw_w2, 
   ld_sec_active, ifu_tlu_inst_vld_m, lsu_l2fill_bendian_m, 
   lmq0_l2fill_fpld, lmq1_l2fill_fpld, lmq2_l2fill_fpld, 
   lmq3_l2fill_fpld, cache_way_hit_buf1, cache_hit, lmq0_byp_misc_sz, 
   lmq1_byp_misc_sz, lmq2_byp_misc_sz, lmq3_byp_misc_sz, 
   lsu_l2fill_sign_extend_m, lsu_l1hit_sign_extend_e, 
   tlu_lsu_pstate_cle, tlu_lsu_pstate_am, tlb_pgnum, tlb_demap_nctxt, 
   tlb_demap_pctxt, tlb_demap_sctxt, tlb_demap_actxt, 
   tlb_demap_thrid, ifu_lsu_casa_e, ifu_lsu_ldstub_e, ifu_lsu_swap_e, 
   lsu_atm_st_cmplt_e, lsu_cpx_pkt_atm_st_cmplt, 
   spu_lsu_ldxa_data_vld_w2, spu_lsu_ldxa_illgl_va_w2, 
   spu_lsu_ldxa_tid_w2, spu_lsu_stxa_ack_tid, spu_lsu_stxa_ack, 
   spu_lsu_unc_error_w2, spu_lsu_int_w2, tlu_lsu_stxa_ack, 
   tlu_lsu_stxa_ack_tid, lsu_tlb_invert_endian_g, lmq0_ncache_ld, 
   lmq1_ncache_ld, lmq2_ncache_ld, lmq3_ncache_ld, ifu_tlu_mb_inst_e, 
   ifu_tlu_flsh_inst_e, lsu_stb_empty, tlu_dtlb_tag_rd_g, 
   tlu_dtlb_data_rd_g, tlu_dtlb_dmp_vld_g, tlu_dtlb_dmp_all_g, 
   tlu_dtlb_rw_index_vld_g, tlu_dtlb_invalidate_all_g, 
   lsu_st_wr_dcache, tlu_lsu_asi_update_m, tlu_lsu_tid_m, 
   lsu_rd_dtag_parity_g, dcache_rparity_err_wb, 
   lsu_diagnstc_wr_data_b0, lsu_byp_ldd_oddrd_m, tlu_lsu_redmode, 
   tlu_lsu_redmode_rst_d1, dva_vld_m, lsu_dfill_tid_e, 
   ifu_lsu_asi_ack, lsu_intrpt_cmplt, lsu_iobrdge_tap_rq_type_b8, 
   lsu_iobrdge_tap_rq_type_b6_b3, lsu_iobrdge_tap_rq_type_b1_b0, 
   lsu_iobrdge_fwd_pkt_vld, lsu_cpx_ld_dtag_perror_e, 
   lsu_cpx_ld_dcache_perror_e, lsu_cpx_pkt_ld_err, ifu_lsu_nceen, 
   tlu_lsu_ldxa_async_data_vld, tlu_lsu_hpv_priv, tlu_lsu_hpstate_en, 
   ifu_lsu_memref_d, ifu_lsu_pref_inst_e, lsu_pref_pcx_req, 
   lsu_cpx_pkt_prefetch2, lsu_ld_pcx_rq_sel_d2, 
   lsu_pcx_req_squash_d1, lsu_bld_helper_cmplt_m, lsu_bld_cnt_m, 
   lsu_bld_reset, ffu_lsu_blk_st_e, lsu_stb_rmo_st_issue, 
   lsu_cpx_rmo_st_ack, lsu_dfq_flsh_cmplt, stb_cam_hit, 
   ifu_tlu_flush_m, ctu_sscan_tid, tte_data_perror_unc, 
   asi_tte_data_perror, asi_tte_tag_perror, tlu_dtlb_rw_index_g, 
   lsu_local_early_flush_g, lsu_dfq_vld, gdbginit_l, dc_direct_map, 
   asi_d, lsu_dctl_asi_state_m, lsu_ldst_va_g, lsu_ifu_err_addr_b39, 
   lsu_dp_ctl_reg0, lsu_dp_ctl_reg1, lsu_dp_ctl_reg2, 
   lsu_dp_ctl_reg3, ldd_in_dfq_out, dcache_iob_addr_e, 
   mbist_dcache_index, mbist_dcache_word, lsu_diagnstc_wr_addr_e, 
   st_dcfill_addr, lsu_dfq_ld_vld, lsu_dfq_st_vld, lmq0_ldd_vld, 
   lmq1_ldd_vld, lmq2_ldd_vld, lmq3_ldd_vld, lsu_dfq_byp_tid, 
   dfq_byp_ff_en, lsu_dcache_iob_way_e, mbist_dcache_way, 
   lsu_diagnstc_wr_way_e, lsu_st_way_e, lmq0_pcx_pkt_way, 
   lmq1_pcx_pkt_way, lmq2_pcx_pkt_way, lmq3_pcx_pkt_way, 
   lmq0_ld_rq_type, lmq1_ld_rq_type, lmq2_ld_rq_type, 
   lmq3_ld_rq_type, lmq0_pcx_pkt_addr, lmq1_pcx_pkt_addr, 
   lmq2_pcx_pkt_addr, lmq3_pcx_pkt_addr, lsu_ttype_vld_m2, 
   tlu_early_flush_pipe2_w, lsu_st_dcfill_size_e, mbist_dcache_write, 
   mbist_dcache_read,
   cfg_asi_lsu_ldxa_vld_w2, cfg_asi_lsu_ldxa_tid_w2
   ) ;  


output                  lsu_tlu_nucleus_ctxt_m ;// access is nucleus context 
output			lsu_quad_word_access_g ; // 128b ld request.

input si;
input se;
input sehold ;
input rst_tri_en ;
output so;    

input      rclk ;
input                   grst_l;
input                   arst_l;
output     dctl_rst_l;

input  lsu_diag_va_prty_invrt ;

   input         dva_svld_e ;
   input [(4*4-1):0] dva_snp_bit_wr_en_e;
   input [(6 + 4)-6:0]  dva_snp_addr_e;

input	      lsu_tte_data_cp_g ; // cp bit from tlb    
input         lsu_l2fill_vld ;    // fill from dfq to d$.
input         ld_inst_vld_e ;     // load accesses d$.
input         st_inst_vld_e ;     // load accesses d$.
input         ifu_lsu_ldst_fp_e ; // fp load or store
input [1:0]   ldst_sz_e ;         // sz of ld/st xsaction.


input [12:11]  lsu_ldst_va_b12_b11_m;      
input [7:0]    lsu_ldst_va_b7_b0_m;      

input [4:0]   ifu_lsu_rd_e;           // primary rd of ld
input         tlb_cam_hit ;           // xlation hits in tlb.     
// Read/Write Privileged State Register Access.
input [6:0]   ifu_tlu_sraddr_d ;      // addr of sr(st/pr)

input         ifu_tlu_wsr_inst_d ;    // valid wr sr(st/pr)
output        lsu_tlu_wsr_inst_e ;    // valid wr sr(st/pr)

input         ifu_lsu_alt_space_d;        // alternate space ld/st

input         tlu_lsu_int_ldxa_vld_w2 ;  // tlu ldxa data is valid (intrpt/scpd)
input         tlu_lsu_int_ld_ill_va_w2 ;  // tlu ldxa'va is invalid (intrpt/scpd)

input [1:0]   tlu_lsu_ldxa_tid_w2 ;       // thread id for tlu ldxa data. 

input         ifu_lsu_ldxa_data_vld_w2 ;  // ifu ldxa data is valid
input         ifu_lsu_ldxa_illgl_va_w2 ;  // ifu ldxa with illgl va
input [1:0]   ifu_lsu_ldxa_tid_w2   ;     // thread id for ifu ldxa data. 
input         ifu_lsu_asi_rd_unc ;        // unc error for tlb rd

input [3:0]   tlu_lsu_tl_zero ;           // trap level is zero.
input [1:0]   ifu_lsu_thrid_s ;           // thread id
input         ifu_lsu_ldst_dbl_e ;        // ldd, atomic quad.

input         ld_stb_full_raw_w2 ;     // full raw for load-thread0
input         ld_sec_active ;          // secondary bypassing
input         ifu_tlu_inst_vld_m ;     // inst vld in w stage

input         lsu_l2fill_bendian_m ;

//input         lsu_l2fill_fpld_e ;      // fp load
output         lsu_l2fill_fpld_e ;      // fp load
input         lmq0_l2fill_fpld ;      // fp load
input         lmq1_l2fill_fpld ;      // fp load
input         lmq2_l2fill_fpld ;      // fp load
input         lmq3_l2fill_fpld ;      // fp load

input [4-1:0]   cache_way_hit_buf1 ;          // hit in set of cache.
   input      cache_hit;
   
//input [3:0]   lsu_byp_misc_addr_m ;   // lower 3bits of addr for ldxa/raw etc
   
input [1:0]   lmq0_byp_misc_sz ;     // size for ldxa/raw etc
input [1:0]   lmq1_byp_misc_sz ;     // size for ldxa/raw etc
input [1:0]   lmq2_byp_misc_sz ;     // size for ldxa/raw etc
input [1:0]   lmq3_byp_misc_sz ;     // size for ldxa/raw etc

input         lsu_l2fill_sign_extend_m ; // l2fill requires sign-extension
input         lsu_l1hit_sign_extend_e ;  // l1hit requires sign-extension
input [3:0]   tlu_lsu_pstate_cle ;       // current little endian
input [3:0]   tlu_lsu_pstate_am ;        // address mask
input [39:10] tlb_pgnum ;
input         tlb_demap_nctxt;         // demap with nctxt
input         tlb_demap_pctxt;         // demap with pctxt
input         tlb_demap_sctxt;         // demap with sctxt
input         tlb_demap_actxt;         // demap w autodemap ctxt
input [1:0]   tlb_demap_thrid;         // demap thrid

input         ifu_lsu_casa_e ;         // compare-swap instr
input         ifu_lsu_ldstub_e ;       // ldstub
input         ifu_lsu_swap_e ;         // swap


input         lsu_atm_st_cmplt_e ;      // atm st ack will restart thread
input	      lsu_cpx_pkt_atm_st_cmplt ; // applies to atomic ld also.

input         spu_lsu_ldxa_data_vld_w2 ; // ldxa data from spu is valid
input         spu_lsu_ldxa_illgl_va_w2 ; // ldxa data from spu with illgl va
input [1:0]   spu_lsu_ldxa_tid_w2 ;      // ldxa data from spu is valid
input [1:0]   spu_lsu_stxa_ack_tid ;     // stxa data from spu is valid
input         spu_lsu_stxa_ack ;         // write to sdata reg complete
input	      spu_lsu_unc_error_w2 ;
input	      spu_lsu_int_w2 ;		 // spu disrupting trap.

input         tlu_lsu_stxa_ack ;         // for mmu reads/writes/demaps
input [1:0]   tlu_lsu_stxa_ack_tid ;      // for mmu reads/writes/demaps - tid

input         lsu_tlb_invert_endian_g ;
//input         lsu_ncache_ld_e ;       // non-cacheable ld from dfq
   input      lmq0_ncache_ld;
   input      lmq1_ncache_ld;
   input      lmq2_ncache_ld;
   input      lmq3_ncache_ld;
   

input         ifu_tlu_mb_inst_e ;     // membar instruction
input         ifu_tlu_flsh_inst_e ;   // flush  instruction

input [3:0]   lsu_stb_empty ;         // thread's stb is empty

//input         tlu_dtlb_wr_vld_g ;
input         tlu_dtlb_tag_rd_g ;
input         tlu_dtlb_data_rd_g ;
input         tlu_dtlb_dmp_vld_g ;
input         tlu_dtlb_dmp_all_g ;
input         tlu_dtlb_rw_index_vld_g ;
input         tlu_dtlb_invalidate_all_g ;


input         tlu_dtlb_csm_rd_g ;
input [32:0] tlb_rd_tte_csm;



input         lsu_st_wr_dcache ;

input         tlu_lsu_asi_update_m ;  // update asi
input  [1:0]  tlu_lsu_tid_m ;         // thread for asi update
input [4-1:0]   lsu_rd_dtag_parity_g;     // calculated tag parity

input         dcache_rparity_err_wb;     // calculated tag parity
   
input         lsu_diagnstc_wr_data_b0 ;
input         lsu_byp_ldd_oddrd_m ;   // rd fill for non-alt ldd

input [3:0]   tlu_lsu_redmode ;       // redmode
input [3:0]   tlu_lsu_redmode_rst_d1 ;   // redmode
//input [2:0]   const_cpuid ;           // cpu's id
input [4-1:0]   dva_vld_m ;             // valid bits for cache.
output [4-1:0]  dva_vld_m_bf;
   
input [1:0]   lsu_dfill_tid_e ;       // thread id
input         ifu_lsu_asi_ack;        // asi ack from ifu

input [3:0]   lsu_intrpt_cmplt ;          // intrpt can restart thread
//input [8:0]   lsu_iobrdge_tap_rq_type ;
input  [8:8]  lsu_iobrdge_tap_rq_type_b8 ;
input  [6:3]  lsu_iobrdge_tap_rq_type_b6_b3 ;
input  [1:0]  lsu_iobrdge_tap_rq_type_b1_b0 ;

input         lsu_iobrdge_fwd_pkt_vld ;

input         lsu_cpx_ld_dtag_perror_e ;  // dtag parity error on issue
input         lsu_cpx_ld_dcache_perror_e ;// dcache parity error on issue
//input [1:1]   lsu_cpx_atm_st_err ;        // atomic st error field
input [1:0]   lsu_cpx_pkt_ld_err ;        // err field - cpx ld pkt
input [3:0]   ifu_lsu_nceen ;             // uncorrectible error enable 
input         tlu_lsu_ldxa_async_data_vld ;   // tlu_lsu_ldxa_data_vld is for async op.
input [3:0]   tlu_lsu_hpv_priv ;	  // hypervisor privilege modified
input [3:0]   tlu_lsu_hpstate_en ;	  // enable bit from hpstate

input         ifu_lsu_memref_d;
input         ifu_lsu_pref_inst_e ;       // prefetch inst
input         lsu_pref_pcx_req ;      	  // pref sent to pcx

input	      lsu_cpx_pkt_prefetch2 ;	  // ld is prefetch

// pref counter   
input [3:0]   lsu_ld_pcx_rq_sel_d2 ;
input         lsu_pcx_req_squash_d1;

input	      lsu_bld_helper_cmplt_m ;	  // bld helper completes.
input [2:0]   lsu_bld_cnt_m ;	
input	      lsu_bld_reset ;
   
output [3:0]  lsu_no_spc_pref;
    
input	      ffu_lsu_blk_st_e ;	// blk st helper signalled by ffu
input	[3:0]	lsu_stb_rmo_st_issue ;	// thread's stb issues rmo st
input	[3:0]	lsu_cpx_rmo_st_ack ;	// rmo ack clears

input	[3:0]	lsu_dfq_flsh_cmplt ;

input   	stb_cam_hit ;
 
input   ifu_tlu_flush_m;

output  ifu_tlu_flush_fd_w;
output  ifu_tlu_flush_fd2_w;
output  ifu_tlu_flush_fd3_w;
output  ifu_lsu_flush_w;
   
input   [3:0]           ctu_sscan_tid ;

//input		tte_data_perror_corr ;
input		tte_data_perror_unc ;
input		asi_tte_data_perror ;
input		asi_tte_tag_perror ;

input  	[5:0]	tlu_dtlb_rw_index_g ;

input		lsu_local_early_flush_g ;

//input		lsu_error_pa_b39_m ;

input         lsu_dfq_vld;

input		gdbginit_l ;
input		dc_direct_map ;

input           cfg_asi_lsu_ldxa_vld_w2;
input   [1:0]   cfg_asi_lsu_ldxa_tid_w2;

output 	[1:0]	lsu_tlu_thrid_d ;

output	[3:0] lsu_diagnstc_data_sel ;
output	[3:0] lsu_diagnstc_va_sel ;

output	[2:0] lsu_err_addr_sel ;

output [(4*4-1):0] dva_bit_wr_en_e;
output [(6 + 4):6] dva_wr_adr_e;
   
output      lsu_exu_ldst_miss_w2 ;  // load misses in d$.
//output  [3:0]   lsu_way_hit ;   // ld/st access hits in d$.
output      lsu_exu_dfill_vld_w2 ;  // data fill to irf(exu).
output      lsu_ffu_ld_vld ;  // fp load writes to frf
output      lsu_ld_miss_wb ;  // load misses in d$.
//output      lsu_ld_hit_wb ;   // load hits in d$.
   
output      lsu_dtlb_bypass_e ; // dtlb is bypassed

output [65-1:40] ld_pcx_pkt_g ;    // ld miss pkt for thread.
output      tlb_ldst_cam_vld ;
   

//output      stxa_internal ;   // internal stxa, stg g 
output      ldxa_internal ;   // internal ldxa, stg g

output      lsu_ifu_ldsta_internal_e ; // any internal asi
output  [3:0]   lsu_ifu_ldst_cmplt ;
output  [3:0]   lsu_ifu_itlb_en ;
output  [3:0]   lsu_ifu_icache_en ;
   
   
output  [3:0]           lmq_byp_data_en_w2 ;

output  [3:0]           lmq_byp_data_fmx_sel ;  // final data sel for lmq byp
output  [3:0]           lmq_byp_data_mxsel0 ;     // ldxa vs stb bypass data sel.
output  [3:0]           lmq_byp_data_mxsel1 ;     // ldxa vs stb bypass data sel.
output  [3:0]           lmq_byp_data_mxsel2 ;     // ldxa vs stb bypass data sel.
output  [3:0]           lmq_byp_data_mxsel3 ;     // ldxa vs stb bypass data sel.
output  [2:0]           lmq_byp_ldxa_mxsel0 ;     // ldxa data sel - thread0
output  [2:0]           lmq_byp_ldxa_mxsel1 ;     // ldxa data sel - thread1
output  [2:0]           lmq_byp_ldxa_mxsel2 ;     // ldxa data sel - thread2
output  [2:0]           lmq_byp_ldxa_mxsel3 ;     // ldxa data sel - thread3
output  [2:0]   lsu_ld_thrd_byp_sel_e ;
   
output  [15:0]    dcache_byte_wr_en_e ; // 16-byte write enable mask.

output      lsu_dcache_wr_vld_e ; // write to dcache.

output      lsu_ldstub_g ;    // ldstub(a) instruction
output      lsu_swap_g ;    // swap(a) instruction
output                  lsu_tlu_dtlb_done;  // dtlb rd/dmp/wr cmplt
output  [1:0]   lsu_exu_thr_m ;

output                   merge7_sel_byte0_m;
output                   merge7_sel_byte7_m;
   
output                   merge6_sel_byte1_m;
output                   merge6_sel_byte6_m;

output                   merge5_sel_byte2_m;   
output                   merge5_sel_byte5_m;

output                   merge4_sel_byte3_m;
output                   merge4_sel_byte4_m;

output                   merge3_sel_byte0_m;
output                   merge3_sel_byte3_m;
output                   merge3_sel_byte4_m;
output                   merge3_sel_byte7_default_m;
output                   merge3_sel_byte_m ;

output                   merge2_sel_byte1_m;
output                   merge2_sel_byte2_m;
output                   merge2_sel_byte5_m;
output                   merge2_sel_byte6_default_m;
output                   merge2_sel_byte_m ;

output                   merge0_sel_byte0_m, merge0_sel_byte1_m;
output                   merge0_sel_byte2_m, merge0_sel_byte3_default_m;
   
output                   merge0_sel_byte4_m, merge0_sel_byte5_m;
output                   merge0_sel_byte6_m, merge0_sel_byte7_default_m;
                                                               
output                   merge1_sel_byte0_m, merge1_sel_byte1_m;
output                   merge1_sel_byte2_m, merge1_sel_byte3_default_m;
output                   merge1_sel_byte4_m, merge1_sel_byte5_m;
output                   merge1_sel_byte6_m, merge1_sel_byte7_default_m; 

output			             merge0_sel_byte_1h_m ;
   
output			             merge1_sel_byte_1h_m, merge1_sel_byte_2h_m ;
   
output		lsu_dtlb_cam_real_e ;
output      lsu_dtagv_wr_vld_e ;

output      lsu_dtag_wrreq_x_e ;
output      lsu_dtag_index_sel_x_e ;
   
output      lsu_dtlb_wr_vld_e ;
output      lsu_dtlb_tag_rd_e ;
output      lsu_dtlb_data_rd_e ;
output      lsu_dtlb_dmp_vld_e ;
output      lsu_dtlb_dmp_all_e ;
output      lsu_dtlb_rwindex_vld_e ;
output      lsu_dtlb_invalid_all_l_m ;
output      lsu_tlu_tlb_ld_inst_m ;
output      lsu_tlu_tlb_st_inst_m ;
output  [1:0]   lsu_tlu_tlb_access_tid_m ;
output      lsu_tlb_data_rd_vld_g ;


output      csm_rd_vld_g;
output      lsu_tlb_csm_rd_vld_g;
output      lsu_dtlb_csm_rd_e ;
output	[32:0]	lsu_blkst_csm_m ;


output stb_ncache_pcx_rq_g;
   
output  [3:0]   lsu_tlb_st_sel_m ;
   
output         lsu_va_wtchpt0_wr_en_l;
output         lsu_va_wtchpt1_wr_en_l;
output         lsu_va_wtchpt2_wr_en_l;
output         lsu_va_wtchpt3_wr_en_l;

output         thread0_m;
output         thread1_m;
output         thread2_m;
output         thread3_m;

output         lsu_dctldp_thread0_m;
output         lsu_dctldp_thread1_m;
output         lsu_dctldp_thread2_m;
output         lsu_dctldp_thread3_m;
   
output         thread0_g;
output         thread1_g;
output         thread2_g;
output         thread3_g;
   
output                  lsu_tlu_nonalt_ldst_m ; // non-alternate load or store
output                  lsu_tlu_xslating_ldst_m ;// xslating ldst,atomic etc

output   [2:0]          lsu_tlu_ctxt_sel_m;           // context selected:0-p,1-s,2-n
output                  lsu_tlu_write_op_m;           // fault occurs for data write operation

output                  lsu_dtlb_addr_mask_l_e ;  // address mask applies


output            dva_din_e;

output            lsu_diagnstc_dtagv_prty_invrt_e ;
   
output                  lsu_ifu_asi_load;   // asi load to ifu
output [1:0]            lsu_ifu_asi_thrid;    // asi event thrid to ifu
output                  lsu_ifu_asi_vld;    // asi event vld - ld+st
output      lsu_quad_asi_e ;
//output      lsu_tlu_64kpg_hit_g ;   // 64k page page accessed

output            lsu_local_ldxa_sel_g;
output  [3:0]     lsu_dtag_rsel_m ;  // dtag way sel

output      lsu_tlbop_force_swo ;
output  [2:0]     lsu_atomic_pkt2_bsel_g ;
output      lsu_dcache_tag_perror_g ;       // dcache tag parity error
output      lsu_dcache_data_perror_g ;      // dcache data parity error
   
output      lsu_ifu_l2_unc_error ;    // l2 uncorrectible error
output      lsu_ifu_l2_corr_error ;   // l2 correctible error
output      lsu_ifu_dcache_data_perror ;  // dcache data parity error
output      lsu_ifu_dcache_tag_perror ; // dcache tag parity error
output  [1:0]   lsu_ifu_error_tid ;   // thread id for error
output      lsu_ifu_io_error ;    // error on io ld
//output  [1:0]   lsu_tlu_derr_tid_g ;    // daccess error tid
   
output      lsu_tlu_squash_va_oor_m ;   // squash va_oor for mem-op.
output      lsu_squash_va_oor_m ;   // squash va_oor for mem-op.

output          tlb_cam_hit_g ;           // xlation hits in tlb.     

   output        lsu_st_hw_le_g;
   output        lsu_st_w_or_dbl_le_g;
   output        lsu_st_x_le_g;
   output        lsu_swap_sel_default_g;
   output        lsu_swap_sel_default_byte_7_2_g;

output		lsu_st_rmo_m ;		// rmo store in m stage
output		lsu_bst_in_pipe_m ;	// 1st helper for bst.
output  	lsu_snap_blk_st_m ;	// snap blk st state 
output		lsu_blk_st_m ;		// blk st in m
output	[39:10]	lsu_blkst_pgnum_m ;
output		lsu_ffu_blk_asi_e ;	// blk
output		lsu_blk_asi_m ;

output		lsu_nonalt_nucl_access_m ;

//output	[3:0]	lsu_spu_stb_empty ;

   output     dcache_alt_mx_sel_e;
   output     dcache_alt_mx_sel_e_bf;
   output     dcache_rvld_e;
   
output		lsu_dc_iob_access_e ;	// dcache iob access

output		lsu_ifu_ldst_miss_w ;

   output lsu_ifu_dc_parity_error_w2;
   
   output lsu_ldst_inst_vld_e;

output          lsu_local_ldxa_tlbrd_sel_g;
output          lsu_local_diagnstc_tagrd_sel_g;
output          lsu_va_wtchpt_sel_g;
   

   input [7:0]   asi_d;
   input [7:0]   lsu_dctl_asi_state_m;
   
   output  [3:0] asi_state_wr_thrd;
   output        thread0_d;
   output        thread1_d;
   output        thread2_d;
   output        thread3_d;
   output        tlu_lsu_asi_update_g;

output  [3:0] pctxt_state_wr_thrd ;
output  [3:0] sctxt_state_wr_thrd ;

   output     thread_pctxt;
   output     thread_sctxt;

   output     thread_actxt;
   output     thread_default;
   
   output     thread0_ctxt;  
   output     thread1_ctxt;
   output     thread2_ctxt;
   output     thread3_ctxt;

   output [3:0] pid_state_wr_en;
   output       thread0_e;
   output       thread1_e;
   output       thread2_e;
   output       thread3_e;

   output       dfture_tap_wr_mx_sel;
   output [3:0] lctl_rst;
   output [3:0] lsu_ctl_state_wr_en;
   output [3:0] lsuctl_ctlbits_wr_en;
   output [3:0] dfture_tap_rd_en;

   output      bist_tap_wr_en;
   output      bistctl_wr_en;
   output      bist_ctl_reg_wr_en;
   output      mrgn_tap_wr_en;

   output      ldiagctl_wr_en;

   output [3:0]  misc_ctl_sel_din ;

   output [2:0] lsu_asi_sel_fmx1;
   output [2:0] lsu_asi_sel_fmx2;


   output       tlb_access_en0_g;
   output       tlb_access_en1_g;
   output       tlb_access_en2_g;
   output       tlb_access_en3_g;

   output tlb_access_sel_thrd0;
   output tlb_access_sel_thrd1;
   output tlb_access_sel_thrd2;
   output tlb_access_sel_default;

   input [7:0] lsu_ldst_va_g;
   
   output mrgnctl_wr_en;

   input  lsu_ifu_err_addr_b39;

   input [5:0] lsu_dp_ctl_reg0;
   input [5:0] lsu_dp_ctl_reg1;
   input [5:0] lsu_dp_ctl_reg2;
   input [5:0] lsu_dp_ctl_reg3;

   input       ldd_in_dfq_out;     //from qctl2 
   

   output hpv_priv_m;
   output hpstate_en_m;
   
   output                dcache_arry_data_sel_m;
   
   output                dtlb_bypass_m;
   
   output                lsu_alt_space_m;
   output                atomic_m;

   output                ldst_dbl_m;
   output                fp_ldst_m;

   output                lda_internal_m;
   output                sta_internal_m;
   output                cam_real_m;

   output                data_rd_vld_g;
   output                tag_rd_vld_g;
   output [1:0]          ldst_sz_m;
   output                asi_internal_m;

//   output                ld_inst_vld_unflushed;
//   output                st_inst_vld_unflushed;
   
   output                rd_only_ltlb_asi_e;
   output                wr_only_ltlb_asi_e;
   output                dfill_tlb_asi_e;
   output                ifill_tlb_asi_e;

   output                nofault_asi_m;
   output                as_if_user_asi_m;

   output                atomic_asi_m;
   output                phy_use_ec_asi_m;
   output                phy_byp_ec_asi_m;

   output                quad_asi_m;
   output                binit_quad_asi_m;
   output                blk_asi_m;

   output                recognized_asi_m;
   output                strm_asi_m;
   output                mmu_rd_only_asi_m;
   output                rd_only_asi_m;
   output                wr_only_asi_m;
   output                unimp_asi_m;

   output                va_wtchpt_cmp_en_m;

   output		lsu_tlu_async_ttype_vld_w2 ;	// daccess error - asynchronous
   output   [6:0]	lsu_tlu_async_ttype_w2 ;
   output   [1:0] 	lsu_tlu_async_tid_w2 ;		// asynchronous trap - thread 

   output   [5:0]	async_tlb_index ;
   
//=========================================
//dc_fill CP
//=========================================   
   output                l2fill_vld_m;    //to qdp1
   output  [3:0]   ld_thrd_byp_mxsel_m ;  //to qdp1
   output [7:0]    morphed_addr_m;        //to dcdp
 
   
   output          signed_ldst_byte_m;    //to dcdp
//   output          unsigned_ldst_byte_m;  //to dcdp 
   output          signed_ldst_hw_m;      //to dcdp
//   output          unsigned_ldst_hw_m;    //to dcdp
   output          signed_ldst_w_m;       //to dcdp
//   output          unsigned_ldst_w_m;     //to dcdp

   output	lsu_tlb_asi_data_perr_g ;	
   output	lsu_tlb_asi_tag_perr_g ;

   output  [14:13]   lsu_sscan_data ;

   output  [3:0] 	lsu_ld_inst_vld_g ;
   
   output  [1:0]     lsu_dcache_rand;
   output reg  [1:0]     lsu_encd_way_hit;
   output            lsu_way_hit_or;
//   output            lsu_quad_asi_g;

   output	     lsu_memref_m ;
   output	     lsu_flsh_inst_m ;

   output	    	lsu_ifu_asi_data_en_l ;


//dcfill_addr [`L1D_ADDRESS_HI:0]
   input [(6 + 4)-3:0]  dcache_iob_addr_e;
   input [(6 + 4)-4:0]  mbist_dcache_index;
   input        mbist_dcache_word;
   input [(6 + 4):0] lsu_diagnstc_wr_addr_e;
   input [(6 + 4):0] st_dcfill_addr;
   output [(6 + 4):3] lsu_dcache_fill_addr_e;
   output [(6 + 4):4] lsu_dcache_fill_addr_e_err;

   input         lsu_dfq_ld_vld;
   input         lsu_dfq_st_vld;

   output [3:0]  lsu_thread_g;

//=========================================
//LMQ thread sel
//=========================================
   input         lmq0_ldd_vld;      //from qdp1
   input         lmq1_ldd_vld;
   input         lmq2_ldd_vld;
   input         lmq3_ldd_vld;
   output        lmq_ldd_vld;       //to  qctl2 
      
   input [1:0]   lsu_dfq_byp_tid;   //from qdp2
   input         dfq_byp_ff_en;     //from qctl2 

   input [2-1:0]   lsu_dcache_iob_way_e;   //from qdp2
 
   input   [1:0]  mbist_dcache_way;   
   output  [4-1:0]  lsu_bist_rsel_way_e;
   
   input   [2-1:0]   lsu_diagnstc_wr_way_e ;  //from dctldp

   input [2-1:0]     lsu_st_way_e;    //from qdp2

   input [2-1:0]     lmq0_pcx_pkt_way;  //from qctl1
   input [2-1:0]     lmq1_pcx_pkt_way;
   input [2-1:0]     lmq2_pcx_pkt_way;
   input [2-1:0]     lmq3_pcx_pkt_way;
   output [4-1:0]    lsu_dcache_fill_way_e;

// input  [3*(`L1D_WAY_COUNT)-1:0]             lmq_ld_rq_type ;        // for identifying atomic ld.

input  [2:0]             lmq0_ld_rq_type ;        // for identifying atomic ld.
input  [2:0]             lmq1_ld_rq_type ;        // for identifying atomic ld.
input  [2:0]             lmq2_ld_rq_type ;        // for identifying atomic ld.
input  [2:0]             lmq3_ld_rq_type ;        // for identifying atomic ld.
   
input  [(6 + 4):0]            lmq0_pcx_pkt_addr;
input  [(6 + 4):0]            lmq1_pcx_pkt_addr;
input  [(6 + 4):0]            lmq2_pcx_pkt_addr;
input  [(6 + 4):0]            lmq3_pcx_pkt_addr;

output                   lmq_ld_addr_b3;

output [3:0]             lsu_outstanding_rmo_st_max;

input                 lsu_ttype_vld_m2;
input                 tlu_early_flush_pipe2_w;
input [1:0]           lsu_st_dcfill_size_e;

   input              mbist_dcache_write;
   input              mbist_dcache_read;

   output             lsu_dcfill_data_mx_sel_e;
   
wire  [3:0]   ld_thrd_byp_sel_e ;
wire	      ifu_asi_vld,ifu_asi_vld_d1 ;
wire  [1:0]   dcache_wr_size_e ;   
wire          lsu_ncache_ld_e;
wire          lsu_diagnstc_wr_src_sel_e ; // dcache/dtag/v write - diag
   
wire         dctl_flush_pipe_w ;   // flush pipe due to error
 wire        dctl_early_flush_w;
   
wire  [(6 + 4):0] lmq_pcx_pkt_addr;
wire  [2:0]  lmq_ld_rq_type_e;
   
wire [(6 + 4):0]  dcache_fill_addr_e;
wire [2:0]   dcache_wr_addr_e ;       
wire	lsuctl_dtlb_byp_e ;
   
wire	cam_perr_unc0,asi_data_perr0,asi_tag_perr0,ifu_unc_err0 ;
wire	cam_perr_unc1,asi_data_perr1,asi_tag_perr1,ifu_unc_err1 ;
wire	cam_perr_unc2,asi_data_perr2,asi_tag_perr2,ifu_unc_err2 ;
wire	cam_perr_unc3,asi_data_perr3,asi_tag_perr3,ifu_unc_err3 ;
wire	cam_perr_unc_e, asi_data_perr_e,asi_tag_perr_e,ifu_unc_err_e ;
wire	cam_perr_unc_m, asi_data_perr_m,asi_tag_perr_m,ifu_unc_err_m ;
wire	cam_perr_unc_g, asi_data_perr_g,asi_tag_perr_g,ifu_unc_err_g ;
//wire	cam_real_err_e, cam_real_err_m ;
wire	[3:0] squash_byp_cmplt,squash_byp_cmplt_m, squash_byp_cmplt_g ;
wire      ld_inst_vld_m,ld_inst_vld_g ;
wire      st_inst_vld_m,st_inst_vld_g ;
wire      fp_ldst_m,fp_ldst_g,fp_ldst_w2 ;
wire      lsu_ld_hit_wb, lsu_ld_miss_wb ;
wire  [4-1:0]   lsu_way_hit ;
wire  [1:0]   ldst_sz_m,ldst_sz_g ;
wire  [4:0]   ld_rd_m, ld_rd_g ;
wire      lsu_dtlb_bypass_g,dtlb_bypass_e,dtlb_bypass_m ;
wire [6:0]  lsu_sraddr_e ;
//wire    lsu_rsr_inst_e,lsu_rsr_inst_m, lsu_rsr_inst_w ;
wire    lsu_wsr_inst_e;
wire    pctxt_state_en, sctxt_state_en ;
wire    asi_state_wr_en ;
//wire  [3:0] pctxt_state_rd_en, sctxt_state_rd_en ;
wire    lsu_alt_space_m,lsu_alt_space_g ;
wire    ldxa_internal, stxa_internal ;
wire    lsu_ctl_state_en;
//wire  [3:0] lsu_ctl_state_rd_en;
wire  [3:0]   lsu_ctl_state_wr_en ;
//wire  [7:0] imm_asi_e,imm_asi_m,imm_asi_g ;
//wire    imm_asi_vld_e,imm_asi_vld_m,imm_asi_vld_g;
//wire  [7:0]   asi_state0,asi_state1,asi_state2,asi_state3 ;

wire    ldsta_internal_e,sta_internal_e,lda_internal_e;
wire    sta_internal_m,lda_internal_m;
wire  [7:0] asi_d ;
wire    [1:0]   thrid_d,thrid_e,thrid_m, thrid_g, thrid_w2, thrid_w3, ldxa_thrid_w2 ;
wire    stxa_internal_d1, stxa_internal_d2 ;
wire    ld_pcx_pkt_vld_e ;
wire    ld_pcx_pkt_vld_m ;
wire    ld_pcx_pkt_vld_g ;
wire    ldst_dbl_m, ldst_dbl_g;
wire    ldd_force_l2access_w2, ldd_force_l2access_w3;
   
//wire    ld_stb_full_raw_w2 ;
wire    ld_stb_full_raw_w3 ;

wire    ldbyp0_vld_rst, ldbyp0_vld_en, ldbyp0_fpld ;
wire    ldbyp1_vld_rst, ldbyp1_vld_en, ldbyp1_fpld ;
wire    ldbyp2_vld_rst, ldbyp2_vld_en, ldbyp2_fpld ;
wire    ldbyp3_vld_rst, ldbyp3_vld_en, ldbyp3_fpld ;
//wire    ldbyp0_vld_en_d1,ldbyp1_vld_en_d1,ldbyp2_vld_en_d1,ldbyp3_vld_en_d1 ;

wire    thread0_e,thread1_e,thread2_e,thread3_e;
wire    thread0_d,thread1_d,thread2_d,thread3_d;
wire    thread0_m,thread1_m,thread2_m,thread3_m;
wire    thread0_g,thread1_g,thread2_g,thread3_g;
wire    thread0_w2,thread1_w2,thread2_w2,thread3_w2;
wire    thread0_w3,thread1_w3,thread2_w3,thread3_w3;
wire    tlu_stxa_thread0_w2,tlu_stxa_thread1_w2 ;
wire    tlu_stxa_thread2_w2,tlu_stxa_thread3_w2 ;
wire    tlu_ldxa_thread0_w2,tlu_ldxa_thread1_w2 ;
wire    tlu_ldxa_thread2_w2,tlu_ldxa_thread3_w2 ;
wire    spu_ldxa_thread0_w2,spu_ldxa_thread1_w2 ;
wire    spu_ldxa_thread2_w2,spu_ldxa_thread3_w2 ;
wire    spu_stxa_thread0,spu_stxa_thread1 ;
wire    spu_stxa_thread2,spu_stxa_thread3 ;
wire    ifu_ldxa_thread0_w2,ifu_ldxa_thread1_w2 ;
wire    ifu_ldxa_thread2_w2,ifu_ldxa_thread3_w2 ;
wire    ifu_stxa_thread0_w2,ifu_stxa_thread1_w2 ;
wire    ifu_stxa_thread2_w2,ifu_stxa_thread3_w2 ;
wire    ldbyp0_vld, ldbyp1_vld, ldbyp2_vld, ldbyp3_vld ;
//wire    ld_any_byp_data_vld ;              
wire  [3:0] asi_state_wr_thrd;
wire  [3:0] pctxt_state_wr_thrd ;
wire  [3:0] sctxt_state_wr_thrd ;
wire    tlb_cam_hit_g ;
wire    ld_inst_vld_unflushed ;
wire    st_inst_vld_unflushed ;

wire  [7:0]  baddr_m ;
wire  [15:0]  byte_wr_enable ;
//wire  [1:0] st_size ;
//wire    l2fill_bendian_g ;
wire    ldst_byte,ldst_hword,ldst_word,ldst_dword;
wire    byte_m,hword_m,word_m,dword_m;
wire    tlb_invert_endian_g ;
//wire  [7:0] l2fill_bytes_msb_m, l2fill_bytes_msb_g ;
//wire    byte_g, hword_g, word_g ;

   wire signed_ldst_m ;
//wire  unsigned_ldst_m ;
//wire    sign_bit_g  ;
//wire  [7:0] align_bytes_msb ;

wire    l2fill_vld_m, l2fill_vld_g ;
wire    l2fill_fpld_e, l2fill_fpld_m, l2fill_fpld_g ;
wire    pstate_cle_e, pstate_cle_m, pstate_cle_g ;
wire    l1hit_lendian_g ;
wire    l1hit_sign_extend_m, l1hit_sign_extend_g ;
wire    demap_thread0, demap_thread1, demap_thread2, demap_thread3 ;

wire    misc_byte_m,misc_hword_m,misc_word_m,misc_dword_m;
wire    byp_word_g;
//wire  [15:0]  byp_baddr_g ;
//wire    ld_stb_hit_g ;
wire    atomic_ld_squash_e ;
wire    atomic_m,atomic_g,atomic_w2, atomic_w3 ;
wire  [2:0] ld_rq_type ;
wire    ncache_pcx_rq_g ;
wire    lmq_pkt_vld_g ;
wire    tlb_lng_ltncy_asi_d,tlb_lng_ltncy_asi_e, tlb_lng_ltncy_asi_m,tlb_lng_ltncy_asi_g ; 
wire    recognized_asi_d,recognized_asi_e,recognized_asi_m,recognized_asi_g,recognized_asi_tmp ;
wire    asi_internal_d, asi_internal_e ;  
wire    asi_internal_m, asi_internal_g ;  
wire    dcache_byp_asi_d, dcache_byp_asi_e ;
wire    dcache_byp_asi_m, dcache_byp_asi_g ;
wire	phy_use_ec_asi_d,phy_use_ec_asi_e,phy_use_ec_asi_m;
wire	phy_byp_ec_asi_d,phy_byp_ec_asi_e,phy_byp_ec_asi_m;
wire    lendian_asi_d, lendian_asi_e;
wire    lendian_asi_m, lendian_asi_g;
wire	intrpt_disp_asi_d,intrpt_disp_asi_e,intrpt_disp_asi_m,intrpt_disp_asi_g ;
wire    nofault_asi_d, nofault_asi_e, nofault_asi_m ;
wire    nucleus_asi_d, nucleus_asi_e ;
wire    primary_asi_d, primary_asi_e ;
wire    quad_asi_d,quad_asi_e,quad_asi_m,quad_asi_g;
wire    binit_quad_asi_d,binit_quad_asi_e,binit_quad_asi_m,binit_quad_asi_g ;
wire    secondary_asi_d, secondary_asi_e ;
wire    tlb_byp_asi_d, tlb_byp_asi_e;
wire    thread0_ctxt, thread1_ctxt ; 
wire    thread2_ctxt, thread3_ctxt ;


wire    altspace_ldst_e, non_altspace_ldst_e ;
wire    altspace_ldst_m, altspace_ldst_g ;
wire    non_altspace_ldst_m, non_altspace_ldst_g ;
wire    thread_pctxt, thread_sctxt, thread_nctxt, thread_actxt ;
wire    ncache_asild_rq_g ;
//SC wire    pstate_priv, pstate_priv_m ;
//SC wire    priv_pg_usr_mode ;
//SC wire    nonwr_pg_st_access ;
//SC wire    nfo_pg_nonnfo_asi ;
//wire    daccess_excptn ;
wire    mbar_inst_m,flsh_inst_m ; 
wire    mbar_inst_g,flsh_inst_g ; 
wire    bsync0_reset,bsync1_reset;
wire    bsync2_reset,bsync3_reset ;
wire    bsync0_en,bsync1_en ;
wire    bsync2_en,bsync3_en ;
wire    flush_inst0_g,mbar_inst0_g ;
wire    flush_inst1_g,mbar_inst1_g ;
wire    flush_inst2_g,mbar_inst2_g ;
wire    flush_inst3_g,mbar_inst3_g ;
wire    dfill_thread0,dfill_thread1;
wire    dfill_thread2,dfill_thread3;
wire    mbar_vld0, flsh_vld0 ;
wire    mbar_vld1, flsh_vld1 ;
wire    mbar_vld2, flsh_vld2 ;
wire    mbar_vld3, flsh_vld3 ;
   wire [1:0] dfq_tid_m,dfq_tid_g;

wire  [1:0]   ldbyp_tid_m ;
wire    stxa_stall_asi_g ;
wire    stxa_stall_wr_cmplt0, stxa_stall_wr_cmplt1 ;
wire    stxa_stall_wr_cmplt2, stxa_stall_wr_cmplt3 ;
wire    stxa_stall_wr_cmplt0_d1, stxa_stall_wr_cmplt1_d1 ;
wire    stxa_stall_wr_cmplt2_d1, stxa_stall_wr_cmplt3_d1 ;
wire    dtlb_done ;
wire    tag_rd_vld_m, tag_rd_vld_g ;
wire    data_rd_vld_m, data_rd_vld_g ;

wire    csm_rd_vld_m, csm_rd_vld_g ;

wire    tlb_demap_vld ;
wire    dtlb_done_d1 ;
wire    dtlb_done_d2 ;


wire    tlu_lsu_asi_update_g ;
wire  [1:0] tlu_lsu_tid_g ;
wire    tsa_update_asi0,tsa_update_asi1;
wire    tsa_update_asi2,tsa_update_asi3;
wire    tlb_ld_inst0,tlb_ld_inst1,tlb_ld_inst2,tlb_ld_inst3 ;
wire    tlb_st_inst0,tlb_st_inst1,tlb_st_inst2,tlb_st_inst3 ;
wire    tlb_access_en0_e,tlb_access_en1_e,tlb_access_en2_e,tlb_access_en3_e ;
wire    tlb_access_en0_m,tlb_access_en1_m,tlb_access_en2_m,tlb_access_en3_m ;
wire    tlb_access_en0_tmp,tlb_access_en1_tmp,tlb_access_en2_tmp,tlb_access_en3_tmp ;
wire    tlb_access_en0_g,tlb_access_en1_g,tlb_access_en2_g,tlb_access_en3_g ;
wire    tlb_access_en0_unflushed,tlb_access_en1_unflushed,tlb_access_en2_unflushed,tlb_access_en3_unflushed ;
wire    tlb_access_rst0,tlb_access_rst1,tlb_access_rst2,tlb_access_rst3 ;
wire    tlb_access_sel_thrd0,tlb_access_sel_thrd1;
wire    tlb_access_sel_thrd2,tlb_access_sel_thrd3;
wire    tlb_access_blocked ;
wire    tlb_access_pending ;
wire    tlb_access_initiated ;
//wire    tlb_pending_access_rst ;

wire    vw_wtchpt_cmp_en_m,vr_wtchpt_cmp_en_m ;


//wire    va_b12_3_match_m,va_b47_40_match_m ;
//wire    va_b12_3_match_g,va_b47_40_match_g ;
//wire    wtchpt_msk_match_m,wtchpt_msk_match_g ;

wire    as_if_user_asi_d,as_if_user_asi_e,as_if_user_asi_m;
//SC wire    as_if_usr_priv_pg ;
//SC wire    priv_action,priv_action_m ;
//SC wire    stdf_maddr_not_align, lddf_maddr_not_align ;
//wire  [8:0] early_ttype_m,early_ttype_g ; 
//wire    early_trap_vld_m, early_trap_vld_g ;  
//SC wire    atm_access_w_nc, atm_access_unsup_asi ;
wire    atomic_asi_d,atomic_asi_e,atomic_asi_m ;  
//wire    dflush_asi_d,dflush_asi_e,dflush_asi_m,dflush_asi_g;  
wire    blk_asi_d,blk_asi_e,blk_asi_m, blk_asi_g ;

wire    fpld_byp_data_vld ;
//wire  [7:0] dcache_rd_parity ;
wire    dcache_rd_parity_error ;
//SC wire    tte_data_parity_error ;

wire  [4-1:0]   dtag_parity_error;
//wire    dtag_mtag_parity_error ;
//wire    daccess_error ;
//SC wire    dmmu_miss_g ;
wire  [2:0]   ctxt_sel_e ;
wire    dc_diagnstc_asi_d, dc_diagnstc_asi_e ;
wire    dc_diagnstc_asi_m, dc_diagnstc_asi_g ;
wire    dtagv_diagnstc_asi_d, dtagv_diagnstc_asi_e ;
wire    dtagv_diagnstc_asi_m, dtagv_diagnstc_asi_g ;
//wire    dc_diagnstc_wr_e,dtagv_diagnstc_wr_e ;
//wire    dside_diagnstc_wr_e ;
wire    dc_diagnstc_wr_en,dtagv_diagnstc_wr_en ;

wire  dtagv_diagnstc_rd_g ;
wire  dc0_diagnstc_asi,dtagv0_diagnstc_asi;
wire  dc1_diagnstc_asi,dtagv1_diagnstc_asi;
wire  dc2_diagnstc_asi,dtagv2_diagnstc_asi;
wire  dc3_diagnstc_asi,dtagv3_diagnstc_asi;
//wire [3:0] lngltncy_st_go ;
wire  [3:0]   tlb_st_data_sel_m ;
wire  dc0_diagnstc_wr_en, dc1_diagnstc_wr_en, dc2_diagnstc_wr_en, dc3_diagnstc_wr_en ;  
wire  dtagv0_diagnstc_wr_en, dtagv1_diagnstc_wr_en, dtagv2_diagnstc_wr_en, dtagv3_diagnstc_wr_en ;  
//wire  merge2_sel_byte7, merge3_sel_byte7 ; 
//SC wire  hw_align_addr,wd_align_addr,dw_align_addr;
wire   hw_size,wd_size,dw_size;
//SC wire  mem_addr_not_align ;

wire  wr_only_asi_d,wr_only_asi_e,wr_only_asi_m ;
wire  rd_only_asi_d,rd_only_asi_e,rd_only_asi_m ;
wire  mmu_rd_only_asi_d,mmu_rd_only_asi_e,mmu_rd_only_asi_m ;
wire  unimp_asi_d,unimp_asi_e,unimp_asi_m;
wire  dmmu_asi58_d,dmmu_asi58_e,dmmu_asi58_m;
wire  immu_asi50_d,immu_asi50_e,immu_asi50_m;

wire  ifu_asi_store ;
wire  nontlb_asi0, nontlb_asi1, nontlb_asi2, nontlb_asi3 ;
//wire  stxa_stall_reset ;
wire  ifu_nontlb0_asi,ifu_nontlb1_asi,ifu_nontlb2_asi,ifu_nontlb3_asi;
wire  ifu_nontlb_asi_d, ifu_nontlb_asi_e,ifu_nontlb_asi_m,ifu_nontlb_asi_g ;
wire  [2:0] lsu_asi_sel_fmx1 ;
wire  [2:0] lsu_asi_sel_fmx2;   
wire    lsu_asi_rd_en, lsu_asi_rd_en_w2 ;
//wire  [12:0]  pctxt_state ;
//wire  [12:0]  sctxt_state ;

//wire  [1:0] dcache_rand,dcache_rand_new ;
wire    dtlb_inv_all_e,dtlb_inv_all_m ;
wire  dtlb_wr_vld_d1,dtlb_tag_rd_d1,dtlb_data_rd_d1,dtlb_dmp_vld_d1,dtlb_inv_all_d1 ;
wire  ldst_in_pipe ;
wire  tlbop_init, tlbop_init_d1, tlbop_init_d2 ;
wire  tlbop_init_d3, tlbop_init_d4, tlbop_init_d5 ;
wire  [3:0] ldxa_illgl_va_cmplt,ldxa_illgl_va_cmplt_d1 ;

wire  lsuctl_va_vld ;
wire  lsuctl_illgl_va ;
wire  sctxt_va_vld;
//wire  scxt_ldxa_illgl_va ;
wire  pctxt_va_vld;

wire  pscxt_ldxa_illgl_va ;
wire  lsu_asi_illgl_va ;
wire  [3:0] lsu_asi_illgl_va_cmplt,lsu_asi_illgl_va_cmplt_w2 ;
wire  bistctl_va_vld,mrgnctl_va_vld,ldiagctl_va_vld ;
wire  bistctl_state_en,mrgnctl_state_en,ldiagctl_state_en ;
wire  mrgnctl_illgl_va ;
wire  asi42_illgl_va ;

wire    [3:0]   tap_thread ;
wire    mrgn_tap_wr_en ;
wire    bist_tap_wr_en ;

wire [3:0] dfture_tap_rd_d1;
wire [3:0] dfture_tap_wr_en;

//wire  dfture_tap_rd_sel ;

wire  misc_asi_rd_en ;

wire [3:0]  lsuctl_ctlbits_wr_en ;
wire  bistctl_wr_en;
wire  mrgnctl_wr_en;
//wire  ldiagctl_rd_en,ldiagctl_wr_en;
wire  casa_m, casa_g ;
wire  tte_data_perror_unc ;
wire  asi_tte_data_perror,asi_tte_tag_perror ;

wire  [1:0] dfill_tid_m,dfill_tid_g ;
wire  dtag_error_m,dcache_error_m;
wire  dtag_error_g,dcache_error_g;
wire  dtag_error_w2,dcache_error_w2;
wire  l2_unc_error_e,l2_corr_error_e;
wire  l2_unc_error_m,l2_corr_error_m;
wire  l2_unc_error_g,l2_corr_error_g;
wire  l2_unc_error_w2,l2_corr_error_w2;
wire  unc_err_trap_e,unc_err_trap_m,unc_err_trap_g ;
//wire  corr_err_trap_e, corr_err_trap_m, corr_err_trap_g ;
wire  dtag_perror_g ;


wire  ifill_tlb_asi_d,dfill_tlb_asi_d,rd_only_ltlb_asi_d,wr_only_ltlb_asi_d ;
wire  ifill_tlb_asi_e,dfill_tlb_asi_e,rd_only_ltlb_asi_e,wr_only_ltlb_asi_e ;
//SC wire  tlb_daccess_excptn_e,tlb_daccess_error_e  ;
//SC wire  tlb_daccess_excptn_m,tlb_daccess_error_m  ;
//SC wire  tlb_daccess_excptn_g,tlb_daccess_error_g  ;
wire  thread_tl_zero ;
wire	pid_va_vld, pid_state_en ;
wire	[3:0]	pid_state_wr_en ;

//wire	[3:0]	pid_state_rd_en ;
//wire	[2:0]	pid_state ;
wire    [3:0]   intld_byp_cmplt ;

//wire	hpv_priv,hpstate_en ;	
wire	hpv_priv_m,hpstate_en_m ;	
wire	hpv_priv_e,hpstate_en_e ;	
wire	blkst_m, blkst_g ;
//wire	dc_direct_map ;		
wire	spubyp_trap_active_e,spubyp_trap_active_m, spubyp_trap_active_g ;
wire [6:0] spubyp_ttype ;
wire	spu_trap ;
wire	spu_trap0, spu_trap1, spu_trap2, spu_trap3 ;
wire	[6:0]	spu_ttype ; 
wire	spubyp0_trap,spubyp1_trap,spubyp2_trap,spubyp3_trap;
wire [6:0]	spubyp0_ttype,spubyp1_ttype,spubyp2_ttype,spubyp3_ttype;
wire	bendian_g ;
//wire va_wtchpt_rd_en, pa_wtchpt_rd_en;   
//wire lsu_bendian_access_g;
wire      lsu_tlb_tag_rd_vld_g ;
wire      lsu_dtlb_invalid_all_m ;

wire  [4-1:0]   dva_vld_g;
wire          lsu_diagnstc_asi_rd_en;
wire  [3:0]   ld_thrd_byp_sel_g ;
wire  [3:0]           lmq_byp_data_sel0 ;     // ldxa vs stb bypass data sel.
wire  [3:0]           lmq_byp_data_sel1 ;     // ldxa vs stb bypass data sel.
wire  [3:0]           lmq_byp_data_sel2 ;     // ldxa vs stb bypass data sel.
wire  [3:0]           lmq_byp_data_sel3 ;     // ldxa vs stb bypass data sel.
wire  [2:0]           lmq_byp_ldxa_sel0 ;     // ldxa data sel - thread0
wire  [2:0]           lmq_byp_ldxa_sel1 ;     // ldxa data sel - thread1
wire  [2:0]           lmq_byp_ldxa_sel2 ;     // ldxa data sel - thread2
wire  [2:0]           lmq_byp_ldxa_sel3 ;     // ldxa data sel - thread3
wire    endian_mispred_g ;

   wire       ld_inst_vld_w2, ld_inst_vld_w3;

   wire [3:0] lmq_byp_data_raw_sel_d1;
   wire [3:0] lmq_byp_data_raw_sel_d2;

wire	asi_st_vld_g ;
wire  ignore_fill;

wire  [3:0]  pend_atm_ld_ue ;

wire [2:0]   lsu_byp_misc_addr_m ;   // lower 3bits of addr for ldxa/raw etc
wire [1:0]   lsu_byp_misc_sz_m ;     // size for ldxa/raw etc

//==========================================================
//RESET, CLK
//==========================================================     
   wire       reset;

//   assign     reset = ~rst_l;
   wire       dbb_reset_l;
   wire       clk;
   
    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

   assign  reset  =  ~dbb_reset_l;
   assign dctl_rst_l = dbb_reset_l;
   assign clk = rclk;

wire      lsu_bist_wvld_e ;           // bist writes to cache
wire  		lsu_bist_rvld_e ;	          // bist reads dcache

dff_s #(2) mbist_stge (
   .din ({mbist_dcache_write, mbist_dcache_read}),
   .q   ({lsu_bist_wvld_e,    lsu_bist_rvld_e  }),
   .clk (clk),
   .se  (se),       .si (),          .so ()
);   
  
//===========================================================
//from lsu_excpctl
//wire		lsu_flush_pipe_w ;	// flush - local to lsu

//   assign lsu_flush_pipe_w = dctl_flush_pipe_w;
   
//===========================================================
//   
   assign     lsu_ldst_inst_vld_e = ld_inst_vld_e | st_inst_vld_e;

//wire    lsu_l2fill_bendian_g;

wire memref_e;
   
dff_s #(1) stge_ad_e (
  .din (ifu_lsu_memref_d),
  .q   (memref_e),
  .clk (clk),
  .se     (se),       .si (),          .so ()
);   

//=================================================================================================
// SHADOW SCAN
//=================================================================================================

wire	sscan_data_13, sscan_data_14 ;
// stb status - this monitors the stb state
assign sscan_data_13 =
  ctu_sscan_tid[0] & lsu_stb_empty[0] |
  ctu_sscan_tid[1] & lsu_stb_empty[1] |
  ctu_sscan_tid[2] & lsu_stb_empty[2] |
  ctu_sscan_tid[3] & lsu_stb_empty[3] ;
   
     
// Monitors outstanding long-latency asi transactions - hangs thread. Doesn't cover all asi.
assign  sscan_data_14 =
                ctu_sscan_tid[0] & (tlb_ld_inst0 | tlb_st_inst0) |
               	ctu_sscan_tid[1] & (tlb_ld_inst1 | tlb_st_inst1) |
             		ctu_sscan_tid[2] & (tlb_ld_inst2 | tlb_st_inst2) | 
               	ctu_sscan_tid[3] & (tlb_ld_inst3 | tlb_st_inst3) ;

   
dff_s #(2) stg_d1 (
  .din ({sscan_data_14,sscan_data_13}),
  .q   (lsu_sscan_data[14:13]),
  .clk (clk),
  .se     (se),       .si (),          .so ()
);   

//=========================================================================================
//  INST_VLD_W GENERATION
//=========================================================================================
   
wire    flush_w_inst_vld_m ;
wire    lsu_inst_vld_w ;
assign  flush_w_inst_vld_m =
        ifu_tlu_inst_vld_m &
	~(dctl_flush_pipe_w & (thrid_m[1:0] == thrid_g[1:0])) ; // really lsu_flush_pipe_w

dff_s  stgw_ivld (
        .din    (flush_w_inst_vld_m),
        .q      (lsu_inst_vld_w),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


// Specifically for qctl2. Does not include flush-pipe, but does include ifu's flush.
wire	ld_vld ;

   wire ifu_lsu_flush_w;

   wire ifu_tlu_flush_fd_w_q, ifu_tlu_flush_fd2_w_q, ifu_tlu_flush_fd3_w_q;
   
dff_s #(4) ifu_tlu_flush_stgw (
        .din    ({ifu_tlu_flush_m,ifu_tlu_flush_m,     ifu_tlu_flush_m,      ifu_tlu_flush_m}     ),
        .q      ({ifu_lsu_flush_w,ifu_tlu_flush_fd_w_q,ifu_tlu_flush_fd2_w_q,ifu_tlu_flush_fd3_w_q}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

bw_u1_buf_30x UZfix_ifu_tlu_flush_fd_w  ( .a(ifu_tlu_flush_fd_w_q),  .z(ifu_tlu_flush_fd_w)  );
bw_u1_buf_30x UZfix_ifu_tlu_flush_fd2_w ( .a(ifu_tlu_flush_fd2_w_q), .z(ifu_tlu_flush_fd2_w) );
bw_u1_buf_30x UZfix_ifu_tlu_flush_fd3_w ( .a(ifu_tlu_flush_fd3_w_q), .z(ifu_tlu_flush_fd3_w) );
   
assign	ld_vld = ld_inst_vld_unflushed & lsu_inst_vld_w & ~ifu_lsu_flush_w ;
wire	ld_vld_w_flush ;
assign	ld_vld_w_flush = ld_vld & ~dctl_flush_pipe_w ;
assign	lsu_ld_inst_vld_g[0] = ld_vld_w_flush & thread0_g ;
assign	lsu_ld_inst_vld_g[1] = ld_vld_w_flush & thread1_g ;
assign	lsu_ld_inst_vld_g[2] = ld_vld_w_flush & thread2_g ;
assign	lsu_ld_inst_vld_g[3] = ld_vld_w_flush & thread3_g ;

//=========================================================================================
//  TLB Control 
//=========================================================================================

wire	alt_space_e ;
dff_s #(1) aspace_e (
        .din    (ifu_lsu_alt_space_d),
        .q      (alt_space_e),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//Atomics require translation.
assign tlb_ldst_cam_vld = 
  memref_e & 
    ~dtlb_bypass_e & ~(asi_internal_e & alt_space_e)  ;

// in hyper-lite mode, assumption is that real translation is not supported -
// a miss in tlb with real-translation enabled would result in real-address
// translation miss. This would be purely accidental on software's part.
//wire	dtlb_real_byp_e ;
//assign	dtlb_real_byp_e = hpstate_en_e & ~hpv_priv_e ;
// In hyper-lite mode, no concept of real xslation.
assign	lsu_dtlb_cam_real_e =
	// lsu-ctl based RA->PA 
  ( lsuctl_dtlb_byp_e & ~hpv_priv_e & hpstate_en_e) |
	// means RA->PA if used by hypervisor.
  ( tlb_byp_asi_e & hpstate_en_e & altspace_ldst_e) ;  
  //( tlb_byp_asi_e & dtlb_real_byp_e & altspace_ldst_e) ;  

assign  demap_thread0 = ~tlb_demap_thrid[1] & ~tlb_demap_thrid[0] ;
assign  demap_thread1 = ~tlb_demap_thrid[1] &  tlb_demap_thrid[0] ;
assign  demap_thread2 =  tlb_demap_thrid[1] & ~tlb_demap_thrid[0] ;
assign  demap_thread3 =  tlb_demap_thrid[1] &  tlb_demap_thrid[0] ;

// demap access and regular ldst access to tlb are assumed to
// be mutex.
assign thread0_ctxt =   ( demap_thread0 & tlb_demap_vld) | 
      (~tlb_demap_vld & thread0_e) ;
      //(thread0_e & memref_e) ;
assign thread1_ctxt =   ( demap_thread1 & tlb_demap_vld) | 
      (~tlb_demap_vld & thread1_e) ;
      //(thread1_e & memref_e) ;
assign thread2_ctxt =   ( demap_thread2 & tlb_demap_vld) | 
      (~tlb_demap_vld & thread2_e) ;
      //(thread2_e & memref_e) ;
assign thread3_ctxt =   ( demap_thread3 & tlb_demap_vld) | 
      (~tlb_demap_vld & thread3_e) ;
      //(thread3_e & memref_e) ;

assign  altspace_ldst_e   = memref_e &  alt_space_e ;
assign  non_altspace_ldst_e = memref_e & ~alt_space_e ;

dff_s #(2) aspace_stgm (
        .din    ({altspace_ldst_e,non_altspace_ldst_e}),
        .q      ({altspace_ldst_m,non_altspace_ldst_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s #(2) aspace_stgg (
        .din    ({altspace_ldst_m,non_altspace_ldst_m}),
        .q      ({altspace_ldst_g,non_altspace_ldst_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	[3:0]	tl_zero_d1 ;
dff_s #(4) tlz_stgd1 (
        .din    (tlu_lsu_tl_zero[3:0]),
        .q      (tl_zero_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

mux4ds  #(1) trap_level_zero_mux (
        .in0    (tl_zero_d1[0]),
        .in1    (tl_zero_d1[1]),
        .in2    (tl_zero_d1[2]),
        .in3    (tl_zero_d1[3]),
        .sel0   (thread0_e),  
        .sel1   (thread1_e),
        .sel2   (thread2_e),  
        .sel3   (thread3_e),
        .dout   (thread_tl_zero)
);

wire	thread_tl_zero_m ;
dff_s #(1) ttlz_stgm (
        .din    (thread_tl_zero),
        .q      (thread_tl_zero_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


assign	lsu_nonalt_nucl_access_m = non_altspace_ldst_m & ~thread_tl_zero_m ;

// Note : autodemap will need to be or'ed into tlb_demap_vld !!!
// use of tlu_lsu_tl_zero needs to be threaded.
assign  thread_pctxt =  ( tlb_demap_pctxt     &  tlb_demap_vld)      |  // demap
      ( non_altspace_ldst_e &  thread_tl_zero) |  // ldst. non-alt- space
      ( altspace_ldst_e     &  primary_asi_e)      |  // ldst. alt_space
      (~(memref_e | tlb_demap_vld)) ; // default for pipe
      //(~(ld_inst_vld_e | st_inst_vld_e | tlb_demap_vld)) ; // default for pipe
assign  thread_sctxt =  ( tlb_demap_sctxt     &  tlb_demap_vld)      |  // demap
      ( altspace_ldst_e     &  secondary_asi_e) ; // ldst. alt_space
assign  thread_nctxt =  ( tlb_demap_nctxt     &  tlb_demap_vld)      |  // demap
      ( non_altspace_ldst_e & ~thread_tl_zero) |  // ldst. non-alt- space
      ( altspace_ldst_e     &  nucleus_asi_e) ; // ldst. alt_space
assign  thread_actxt =  tlb_demap_actxt & tlb_demap_vld ; 

//tmp
   wire thread_default;
   assign thread_default = ~(thread_pctxt | thread_sctxt | thread_actxt);
   
wire	[3:0]	pstate_am ;
dff_s #(4) psam_stgd1 (
        .din    (tlu_lsu_pstate_am[3:0]),
        .q      (pstate_am[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//assign  lsu_dtlb_addr_mask_l_e = 
//  thread0_e ? ~pstate_am[0] :
//    thread1_e ? ~pstate_am[1] :
//      thread2_e ? ~pstate_am[2] :
//          ~pstate_am[3] ;

mux4ds  #(1) pstate_am_mux (
        .in0    (~pstate_am[0]),
        .in1    (~pstate_am[1]),
        .in2    (~pstate_am[2]),
        .in3    (~pstate_am[3]),
        .sel0   (thread0_e),  
        .sel1   (thread1_e),
        .sel2   (thread2_e),  
        .sel3   (thread3_e),
        .dout   (lsu_dtlb_addr_mask_l_e)
);
   
//=========================================================================================
//  TLB RD/WR/DMP HANDLING
//=========================================================================================

// To speed up the tlb miss handler, wr_vld will now be generated based on
// admp occurence. lsu_dtlb_wr_vld_g is to be ignored. The following paths
// can be improved
// admp->write initiation (+2)
// write->completion initiation (+3)

wire admp_write ;
assign  admp_write = lsu_dtlb_dmp_vld_e & tlb_demap_actxt ;
wire admp_rst ;
assign  admp_rst = reset | lsu_dtlb_wr_vld_e ;

wire    local_dtlb_wr_vld_g ;
dffre_s #(1) twr_stgd1 (
        .din    (admp_write),
        .q      (local_dtlb_wr_vld_g),
        .clk    (clk),
        .en     (admp_write),   .rst    (admp_rst),
        .se     (se),       .si (),          .so ()
        );


wire    dtlb_wr_init_d1,dtlb_wr_init_d2,dtlb_wr_init_d3 ;
// Handshake between tlu and lsu needs to be fine-tuned !!!
assign  lsu_dtlb_wr_vld_e =  local_dtlb_wr_vld_g & ~(memref_e | dtlb_wr_init_d1 | dtlb_wr_init_d2) ;
//assign  lsu_dtlb_wr_vld_e =  tlu_dtlb_wr_vld_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;
assign  lsu_dtlb_tag_rd_e =  tlu_dtlb_tag_rd_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;
assign  lsu_dtlb_data_rd_e =  tlu_dtlb_data_rd_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;
assign  lsu_dtlb_dmp_vld_e =  tlu_dtlb_dmp_vld_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;

assign  lsu_dtlb_csm_rd_e = tlu_dtlb_csm_rd_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;


   wire lsu_dtlb_dmp_all_e_tmp;
   
assign  lsu_dtlb_dmp_all_e_tmp =  tlu_dtlb_dmp_all_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;
 bw_u1_buf_5x UZsize_lsu_dtlb_dmp_all_e (.a(lsu_dtlb_dmp_all_e_tmp), .z(lsu_dtlb_dmp_all_e));
   
assign  lsu_dtlb_rwindex_vld_e =  tlu_dtlb_rw_index_vld_g & ~(memref_e | dtlb_wr_init_d1 | dtlb_wr_init_d2) ;
//assign  lsu_dtlb_rwindex_vld_e =  tlu_dtlb_rw_index_vld_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;
// Can remove reset once invalidate asi in place !!!
// assign lsu_dtlb_invalid_all_w2 = reset | tlu_dtlb_invalidate_all_g ;

assign  tlb_demap_vld = lsu_dtlb_dmp_vld_e ;

// Switchout for threads. Force threads to swo if tlb operation does not occur for over 5 cycles.


wire dtlb_csm_rd_d1;
dff_s #(6) tlbop_stgd1 (
        //.din    ({tlu_dtlb_wr_vld_g,tlu_dtlb_tag_rd_g,tlu_dtlb_data_rd_g,tlu_dtlb_dmp_vld_g,
        .din    ({local_dtlb_wr_vld_g,tlu_dtlb_tag_rd_g,tlu_dtlb_data_rd_g,tlu_dtlb_csm_rd_g,tlu_dtlb_dmp_vld_g,
    tlu_dtlb_invalidate_all_g}),
        .q      ({dtlb_wr_vld_d1,dtlb_tag_rd_d1,dtlb_data_rd_d1,dtlb_csm_rd_d1,dtlb_dmp_vld_d1,
    dtlb_inv_all_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );











// Detect event.
//bug6193 / ECO bug6511   
assign  ldst_in_pipe = memref_e ;
assign tlbop_init = 
  ((~dtlb_wr_vld_d1 & local_dtlb_wr_vld_g)  |
  (~dtlb_tag_rd_d1  & tlu_dtlb_tag_rd_g)   |
  (~dtlb_data_rd_d1 & tlu_dtlb_data_rd_g) |
  
  (~dtlb_csm_rd_d1 & tlu_dtlb_csm_rd_g) | 
    
  (~dtlb_inv_all_d1 & tlu_dtlb_invalidate_all_g) |
  (~dtlb_dmp_vld_d1 & tlu_dtlb_dmp_vld_g)) & ldst_in_pipe ;

dff_s #(1) tlbinit_stgd1 ( .din    (tlbop_init), .q      (tlbop_init_d1),
        .clk    (clk), .se     (se),       .si (),          .so ());
dff_s #(1) tlbinit_stgd2 ( .din    (tlbop_init_d1 &  ldst_in_pipe), .q      (tlbop_init_d2),
        .clk    (clk), .se     (se),       .si (),          .so ());
dff_s #(1) tlbinit_stgd3 ( .din    (tlbop_init_d2 &  ldst_in_pipe), .q      (tlbop_init_d3),
        .clk    (clk), .se     (se),       .si (),          .so ());
dff_s #(1) tlbinit_stgd4 ( .din    (tlbop_init_d3 &  ldst_in_pipe), .q      (tlbop_init_d4),
        .clk    (clk), .se     (se),       .si (),          .so ());
dff_s #(1) tlbinit_stgd5 ( .din    (tlbop_init_d4 &  ldst_in_pipe), .q      (tlbop_init_d5),
        .clk    (clk), .se     (se),       .si (),          .so ());


assign  lsu_tlbop_force_swo = tlbop_init_d5 & ldst_in_pipe ;

//assign  dtlb_done =   lsu_dtlb_wr_vld_e  | lsu_dtlb_tag_rd_e | 
assign  dtlb_done =   	lsu_dtlb_tag_rd_e | lsu_dtlb_data_rd_e |

            lsu_dtlb_csm_rd_e | 
 
			lsu_dtlb_dmp_vld_e | dtlb_inv_all_e ;

assign  dtlb_inv_all_e = tlu_dtlb_invalidate_all_g & ~(memref_e | dtlb_done_d1 | dtlb_done_d2) ;


dff_s #(4) dn_stgd1 (
        .din    ({dtlb_done,lsu_dtlb_tag_rd_e,lsu_dtlb_data_rd_e,lsu_dtlb_csm_rd_e}),
        .q      ({dtlb_done_d1,tag_rd_vld_m,data_rd_vld_m,csm_rd_vld_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );








wire	dtlb_inv_all_din ;
assign	dtlb_inv_all_din = sehold ? dtlb_inv_all_m : dtlb_inv_all_e ;

dff_s #(1) dinv_stgd1 (
        .din    (dtlb_inv_all_din),
        .q      (dtlb_inv_all_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  lsu_dtlb_invalid_all_m = dtlb_inv_all_m ;
// added by sureshT
assign  lsu_dtlb_invalid_all_l_m = ~lsu_dtlb_invalid_all_m;


dff_s #(4) dn_stgd2 (
        .din    ({dtlb_done_d1,tag_rd_vld_m,data_rd_vld_m,csm_rd_vld_m}),
        .q      ({dtlb_done_d2,tag_rd_vld_g,data_rd_vld_g,csm_rd_vld_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );










assign lsu_tlb_csm_rd_vld_g = csm_rd_vld_g;

assign  lsu_tlb_data_rd_vld_g = data_rd_vld_g ;
assign  lsu_tlb_tag_rd_vld_g  = tag_rd_vld_g ;
//assign  lsu_tlb_st_vld_g = ~lsu_tlb_tag_rd_vld_g & ~lsu_tlb_data_rd_vld_g ;
   
// The handshake will have to change !!!
assign  lsu_tlu_dtlb_done = 
	dtlb_done_d2 |		// rest
	dtlb_wr_init_d3 ;	// write

// Note : if mx_sel bit is high, then it selects va instead of pa.


   
//=========================================================================================
//  State/ASI Registers.
//=========================================================================================

dff_s #(8) stctl_stg_e (
        .din    ({ifu_tlu_sraddr_d[6:0],ifu_tlu_wsr_inst_d}),
        .q      ({lsu_sraddr_e[6:0],    lsu_wsr_inst_e}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign lsu_tlu_wsr_inst_e = lsu_wsr_inst_e;

   wire asi_state_wr_en_e, asi_state_wr_en_m;
   
assign  asi_state_wr_en_e =   
	      ~lsu_sraddr_e[6] &  // 1=hypervisor
	      ~lsu_sraddr_e[5] &  // =0 for state reg. 
        ~lsu_sraddr_e[4] & ~lsu_sraddr_e[3] & 
        ~lsu_sraddr_e[2] &  lsu_sraddr_e[1] & 
         lsu_sraddr_e[0] & 
         lsu_wsr_inst_e ; // write
   
dff_s #(2) stctl_stg_m (
        .din    ({asi_state_wr_en_e, alt_space_e}),
        .q      ({asi_state_wr_en_m, lsu_alt_space_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2) stctl_stg_w (
        .din    ({asi_state_wr_en_m, lsu_alt_space_m}),
        .q      ({asi_state_wr_en,   lsu_alt_space_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

//assign  asi_state_wr_en =   
//	~lsu_sraddr_w[6] &  // 1=hypervisor
//	~lsu_sraddr_w[5] &  // =0 for state reg. 
//        ~lsu_sraddr_w[4] & ~lsu_sraddr_w[3] & 
//        ~lsu_sraddr_w[2] &  lsu_sraddr_w[1] & 
//         lsu_sraddr_w[0] &  
//         lsu_wsr_inst_w ; // write


dff_s #(3) asi_stgw (
        .din    ({tlu_lsu_asi_update_m,tlu_lsu_tid_m[1:0]}),
        .q      ({tlu_lsu_asi_update_g,tlu_lsu_tid_g[1:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 


assign  tsa_update_asi0 =  ~tlu_lsu_tid_g[1] & ~tlu_lsu_tid_g[0] & tlu_lsu_asi_update_g ;
assign  tsa_update_asi1 =  ~tlu_lsu_tid_g[1] &  tlu_lsu_tid_g[0] & tlu_lsu_asi_update_g ;
assign  tsa_update_asi2 =   tlu_lsu_tid_g[1] & ~tlu_lsu_tid_g[0] & tlu_lsu_asi_update_g ;
assign  tsa_update_asi3 =   tlu_lsu_tid_g[1] &  tlu_lsu_tid_g[0] & tlu_lsu_asi_update_g ;

assign  asi_state_wr_thrd[0] = 
((asi_state_wr_en & thread0_g) | tsa_update_asi0) & lsu_inst_vld_w & ~dctl_early_flush_w ;
//((asi_state_wr_en & thread0_g) | tsa_update_asi0) & lsu_inst_vld_w & ~lsu_flush_pipe_w ;
assign  asi_state_wr_thrd[1] = 
((asi_state_wr_en & thread1_g) | tsa_update_asi1) & lsu_inst_vld_w & ~dctl_early_flush_w ;
assign  asi_state_wr_thrd[2] = 
((asi_state_wr_en & thread2_g) | tsa_update_asi2) & lsu_inst_vld_w & ~dctl_early_flush_w ;
assign  asi_state_wr_thrd[3] = 
((asi_state_wr_en & thread3_g) | tsa_update_asi3) & lsu_inst_vld_w & ~dctl_early_flush_w ;

// dc diagnstc will swo on write.							
assign  sta_internal_e = asi_internal_e & st_inst_vld_e & alt_space_e ;
// dc diagnstc will not swo on read.							
assign  lda_internal_e = asi_internal_e & ~dc_diagnstc_asi_e & ld_inst_vld_e & alt_space_e ;

assign  ldsta_internal_e = sta_internal_e | lda_internal_e ;

// MMU_ASI
// Do no switch out for lds. lds switched out thru ldst_miss.
// qualification must be removed.
assign  lsu_ifu_ldsta_internal_e = asi_internal_e ;
//assign  lsu_ifu_ldsta_internal_e = asi_internal_e & ~ld_inst_vld_e  ;


dff_s #(2)  stai_stgm (
        .din    ({sta_internal_e,lda_internal_e}),
        .q      ({sta_internal_m,lda_internal_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire stxa_internal_m;
   assign stxa_internal_m = sta_internal_m & ~(dtagv_diagnstc_asi_m | dc_diagnstc_asi_m);
   
dff_s #(2)  stai_stgg (
        .din    ({stxa_internal_m, lda_internal_m}),
        .q      ({stxa_internal,   ldxa_internal}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire [7:0] ldst_va_g;
   
   assign ldst_va_g[7:0] = lsu_ldst_va_g[7:0];

   wire	[7:0]	lsu_asi_state ;
dff_s #(8)  asistate_stgg (
        .din    (lsu_dctl_asi_state_m[7:0]),
        .q      (lsu_asi_state[7:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
assign  pctxt_va_vld = (ldst_va_g[7:0] == 8'h08) ;
assign  pctxt_state_en =  (lsu_asi_state[7:0] == 8'h21) & pctxt_va_vld &
        lsu_alt_space_g & lsu_inst_vld_w ; 


//assign  pctxt_state_wr_thrd[0] = pctxt_state_en & st_inst_vld_g & thread0_g ;
assign  pctxt_state_wr_thrd[0] = pctxt_state_en & asi_st_vld_g & thread0_g ;
assign  pctxt_state_wr_thrd[1] = pctxt_state_en & asi_st_vld_g & thread1_g ;
assign  pctxt_state_wr_thrd[2] = pctxt_state_en & asi_st_vld_g & thread2_g ;
assign  pctxt_state_wr_thrd[3] = pctxt_state_en & asi_st_vld_g & thread3_g ;

//assign  pctxt_state_rd_en[0] = pctxt_state_en & ld_inst_vld_g & thread0_g ;

//assign  pctxt_state_rd_en[0] = pctxt_state_en & asi_ld_vld_g & thread0_g ;
//assign  pctxt_state_rd_en[1] = pctxt_state_en & asi_ld_vld_g & thread1_g ;
//assign  pctxt_state_rd_en[2] = pctxt_state_en & asi_ld_vld_g & thread2_g ;
//assign  pctxt_state_rd_en[3] = pctxt_state_en & asi_ld_vld_g & thread3_g ;


assign  sctxt_va_vld = (ldst_va_g[7:0] == 8'h10) ;
assign  sctxt_state_en =  (lsu_asi_state[7:0] == 8'h21) & sctxt_va_vld &
        lsu_alt_space_g & lsu_inst_vld_w ; 

assign  pscxt_ldxa_illgl_va = 
	(lsu_asi_state[7:0] == 8'h21) & ~(pctxt_va_vld | sctxt_va_vld) &
        lsu_alt_space_g & lsu_inst_vld_w ; 

//assign  sctxt_state_wr_thrd[0] = sctxt_state_en & st_inst_vld_g & thread0_g ;
assign  sctxt_state_wr_thrd[0] = sctxt_state_en & asi_st_vld_g & thread0_g ;
assign  sctxt_state_wr_thrd[1] = sctxt_state_en & asi_st_vld_g & thread1_g ;
assign  sctxt_state_wr_thrd[2] = sctxt_state_en & asi_st_vld_g & thread2_g ;
assign  sctxt_state_wr_thrd[3] = sctxt_state_en & asi_st_vld_g & thread3_g ;

//assign  sctxt_state_rd_en[0]   = sctxt_state_en & ld_inst_vld_g & thread0_g ;

//assign  sctxt_state_rd_en[0]   = sctxt_state_en & asi_ld_vld_g & thread0_g ;
//assign  sctxt_state_rd_en[1]   = sctxt_state_en & asi_ld_vld_g & thread1_g ;
//assign  sctxt_state_rd_en[2]   = sctxt_state_en & asi_ld_vld_g & thread2_g ;
//assign  sctxt_state_rd_en[3]   = sctxt_state_en & asi_ld_vld_g & thread3_g ;
   

// LSU CONTROL REGISTER. ASI=0x45,VA=0x00.
// b0 - i$ enable.
// b1 - d$ enable. 
// b2 - immu enable.
// b3 - dmmu enable.

assign  lsuctl_va_vld = (ldst_va_g[7:0] == 8'h00);
assign  lsu_ctl_state_en = (lsu_asi_state[7:0] == 8'h45) & lsuctl_va_vld &
        lsu_alt_space_g & lsu_inst_vld_w ; 
assign  lsuctl_illgl_va = (lsu_asi_state[7:0] == 8'h45) & ~lsuctl_va_vld &
        lsu_alt_space_g & lsu_inst_vld_w ; 

wire  [3:0] lctl_rst ;
   
//assign  lsu_ctl_state_wr_en[0] = (lsu_ctl_state_en & st_inst_vld_g & thread0_g) | lctl_rst[0] ;
assign  lsu_ctl_state_wr_en[0] = (lsu_ctl_state_en & asi_st_vld_g & thread0_g) | lctl_rst[0] ;
assign  lsu_ctl_state_wr_en[1] = (lsu_ctl_state_en & asi_st_vld_g & thread1_g) | lctl_rst[1] ;
assign  lsu_ctl_state_wr_en[2] = (lsu_ctl_state_en & asi_st_vld_g & thread2_g) | lctl_rst[2];
assign  lsu_ctl_state_wr_en[3] = (lsu_ctl_state_en & asi_st_vld_g & thread3_g) | lctl_rst[3];

//assign  lsu_ctl_state_rd_en[0] = lsu_ctl_state_en & ld_inst_vld_g & thread0_g ;
//assign  lsu_ctl_state_rd_en[0] = lsu_ctl_state_en & asi_ld_vld_g & thread0_g ;
//assign  lsu_ctl_state_rd_en[1] = lsu_ctl_state_en & asi_ld_vld_g & thread1_g ;
//assign  lsu_ctl_state_rd_en[2] = lsu_ctl_state_en & asi_ld_vld_g & thread2_g ;
//assign  lsu_ctl_state_rd_en[3] = lsu_ctl_state_en & asi_ld_vld_g & thread3_g ;

   

wire	[3:0]	redmode_rst ;
//dff #(4) rdmode_stgd1 (
//        .din    ({tlu_lsu_redmode_rst[3:0]}),
//        .q      ({redmode_rst[3:0]}),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );  

   assign   redmode_rst[3:0] =  tlu_lsu_redmode_rst_d1[3:0];
 
assign  lctl_rst[0] = redmode_rst[0] | reset ;
assign  lctl_rst[1] = redmode_rst[1] | reset ;
assign  lctl_rst[2] = redmode_rst[2] | reset ;
assign  lctl_rst[3] = redmode_rst[3] | reset ;

assign  lsuctl_ctlbits_wr_en[0] = lsu_ctl_state_wr_en[0] | dfture_tap_wr_en[0] | lctl_rst[0]; 
assign  lsuctl_ctlbits_wr_en[1] = lsu_ctl_state_wr_en[1] | dfture_tap_wr_en[1] | lctl_rst[1]; 
assign  lsuctl_ctlbits_wr_en[2] = lsu_ctl_state_wr_en[2] | dfture_tap_wr_en[2] | lctl_rst[2]; 
assign  lsuctl_ctlbits_wr_en[3] = lsu_ctl_state_wr_en[3] | dfture_tap_wr_en[3] | lctl_rst[3]; 

   assign dfture_tap_wr_mx_sel = | dfture_tap_wr_en[3:0];
   
// Could enhance bypass/enable conditions by adding all asi conditions.  
wire   [5:0] lsu_ctl_reg0;
wire   [5:0] lsu_ctl_reg1;
wire   [5:0] lsu_ctl_reg2;
wire   [5:0] lsu_ctl_reg3;

   assign lsu_ctl_reg0[5:0] = lsu_dp_ctl_reg0[5:0];
   assign lsu_ctl_reg1[5:0] = lsu_dp_ctl_reg1[5:0];
   assign lsu_ctl_reg2[5:0] = lsu_dp_ctl_reg2[5:0];
   assign lsu_ctl_reg3[5:0] = lsu_dp_ctl_reg3[5:0];

wire lsu_dcache_enable;
assign lsu_dcache_enable = 
  ((lsu_ctl_reg0[1] & thread0_e) | (lsu_ctl_reg1[1] & thread1_e)  | 
   (lsu_ctl_reg2[1] & thread2_e) | (lsu_ctl_reg3[1] & thread3_e)) ;

assign	lsuctl_dtlb_byp_e =
  (~lsu_ctl_reg0[3] & thread0_e) | (~lsu_ctl_reg1[3] & thread1_e) | 
  (~lsu_ctl_reg2[3] & thread2_e) | (~lsu_ctl_reg3[3] & thread3_e) ;
assign dtlb_bypass_e = 
  (lsuctl_dtlb_byp_e & ~hpstate_en_e) | // hpv enabled - byp is RA->PA for supv.
  ( tlb_byp_asi_e & ~hpstate_en_e & altspace_ldst_e) |  // altspace tlb bypass - non-hpv
    ((hpv_priv_e & hpstate_en_e) & ~(alt_space_e & (as_if_user_asi_e | tlb_byp_asi_e)));
	// hpv enabled VA->PA 

assign  lsu_dtlb_bypass_e = dtlb_bypass_e ; 
wire  dcache_enable_m,dcache_enable_g ;
dff_s #(2) dbyp_stgm (
        .din    ({dtlb_bypass_e,lsu_dcache_enable}),
        .q      ({dtlb_bypass_m,dcache_enable_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2) dbyp_stgg (
        .din    ({dtlb_bypass_m,dcache_enable_m}),
        .q      ({lsu_dtlb_bypass_g,dcache_enable_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

   wire lsu_ctl_reg0_bf_b0, lsu_ctl_reg1_bf_b0, lsu_ctl_reg2_bf_b0, lsu_ctl_reg3_bf_b0;
   wire lsu_ctl_reg0_bf_b2, lsu_ctl_reg1_bf_b2, lsu_ctl_reg2_bf_b2, lsu_ctl_reg3_bf_b2;
   
bw_u1_buf_1x UZsize_ctl_reg0_b0  ( .a(lsu_ctl_reg0[0]),  .z(lsu_ctl_reg0_bf_b0)  );
bw_u1_buf_1x UZsize_ctl_reg0_b2  ( .a(lsu_ctl_reg0[2]),  .z(lsu_ctl_reg0_bf_b2)  );
bw_u1_buf_1x UZsize_ctl_reg1_b0  ( .a(lsu_ctl_reg1[0]),  .z(lsu_ctl_reg1_bf_b0)  );
bw_u1_buf_1x UZsize_ctl_reg1_b2  ( .a(lsu_ctl_reg1[2]),  .z(lsu_ctl_reg1_bf_b2)  );
bw_u1_buf_1x UZsize_ctl_reg2_b0  ( .a(lsu_ctl_reg2[0]),  .z(lsu_ctl_reg2_bf_b0)  );
bw_u1_buf_1x UZsize_ctl_reg2_b2  ( .a(lsu_ctl_reg2[2]),  .z(lsu_ctl_reg2_bf_b2)  );
bw_u1_buf_1x UZsize_ctl_reg3_b0  ( .a(lsu_ctl_reg3[0]),  .z(lsu_ctl_reg3_bf_b0)  );
bw_u1_buf_1x UZsize_ctl_reg3_b2  ( .a(lsu_ctl_reg3[2]),  .z(lsu_ctl_reg3_bf_b2)  );
   
assign lsu_ifu_icache_en[3:0] = 
  {lsu_ctl_reg3_bf_b0,lsu_ctl_reg2_bf_b0,lsu_ctl_reg1_bf_b0,lsu_ctl_reg0_bf_b0} & ~tlu_lsu_redmode[3:0] ;
assign lsu_ifu_itlb_en[3:0] = 
  {lsu_ctl_reg3_bf_b2,lsu_ctl_reg2_bf_b2,lsu_ctl_reg1_bf_b2,lsu_ctl_reg0_bf_b2} & ~tlu_lsu_redmode[3:0] ;

//=========================================================================================
//  DCACHE Access thru IOBrdge
//=========================================================================================

wire	iob_fwdpkt_vld ;
dff_s  iobvld_stg (
        .din    (lsu_iobrdge_fwd_pkt_vld),
        .q      (iob_fwdpkt_vld),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

wire	dcache_iob_wr_e, dcache_iob_rd_e ;
wire	dcache_iob_wr, dcache_iob_rd ;
assign dcache_iob_wr =
~lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[6] & lsu_iobrdge_fwd_pkt_vld ;
assign dcache_iob_rd =
 lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[6] & lsu_iobrdge_fwd_pkt_vld ;

dff_s #(2) dcrw_stge (
        .din    ({dcache_iob_wr,dcache_iob_rd}),
        .q      ({dcache_iob_wr_e,dcache_iob_rd_e}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign	lsu_dc_iob_access_e = dcache_iob_wr_e | dcache_iob_rd_e ;

//=========================================================================================
//  Miscellaneous ASI
//=========================================================================================

// Defeature effects the asi lsu_ctl_reg.
// Margin ASI
// Diag  ASI - No TAP access
// BIST ASI   

assign  tap_thread[0] = ~lsu_iobrdge_tap_rq_type_b1_b0[1] & ~lsu_iobrdge_tap_rq_type_b1_b0[0] ;
assign  tap_thread[1] = ~lsu_iobrdge_tap_rq_type_b1_b0[1] &  lsu_iobrdge_tap_rq_type_b1_b0[0] ;
assign  tap_thread[2] =  lsu_iobrdge_tap_rq_type_b1_b0[1] & ~lsu_iobrdge_tap_rq_type_b1_b0[0] ;
assign  tap_thread[3] =  lsu_iobrdge_tap_rq_type_b1_b0[1] &  lsu_iobrdge_tap_rq_type_b1_b0[0] ;

wire bist_tap_rd,bist_tap_wr ;
assign  bist_tap_rd =  
 lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[5] & iob_fwdpkt_vld ;
assign  bist_tap_wr = 
~lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[5] & iob_fwdpkt_vld ;

/*   
dff_s #(2) bstrw_stge (
        .din    ({bist_tap_rd,bist_tap_wr}),
        .q      ({bist_tap_rd_en,bist_tap_wr_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
*/
dff_s #(1) bstrw_stge (
        .din    ({bist_tap_wr}),
        .q      ({bist_tap_wr_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
   
wire mrgn_tap_rd,mrgn_tap_wr ;
assign  mrgn_tap_rd =  
lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[4] & iob_fwdpkt_vld ;
assign  mrgn_tap_wr = 
~lsu_iobrdge_tap_rq_type_b8[8] & lsu_iobrdge_tap_rq_type_b6_b3[4] & iob_fwdpkt_vld ;
/*
dff_s #(2) mrgnrw_stge (
        .din    ({mrgn_tap_rd,mrgn_tap_wr}),
        .q      ({mrgn_tap_rd_en,mrgn_tap_wr_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
*/
dff_s #(1) mrgnrw_stge (
        .din    ({mrgn_tap_wr}),
        .q      ({mrgn_tap_wr_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
   
wire  dfture_access_vld ;
wire	[3:0]	dfture_tap_rd,dfture_tap_wr ;
assign  dfture_access_vld = lsu_iobrdge_tap_rq_type_b6_b3[3] & iob_fwdpkt_vld ;

assign  dfture_tap_rd[0] =  
  lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[0] ;
assign  dfture_tap_rd[1] =  
  lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[1] ;
assign  dfture_tap_rd[2] =  
  lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[2] ;
assign  dfture_tap_rd[3] =  
  lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[3] ;

   wire dfture_tap_rd_default;
   assign dfture_tap_rd_default = ~| dfture_tap_rd[2:0];
   
assign  dfture_tap_wr[0] = 
  ~lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[0] ;
assign  dfture_tap_wr[1] = 
  ~lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[1] ;
assign  dfture_tap_wr[2] = 
  ~lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[2] ;
assign  dfture_tap_wr[3] = 
  ~lsu_iobrdge_tap_rq_type_b8[8] & dfture_access_vld & tap_thread[3] ;

dff_s #(8) dftrw_stge (
        .din    ({dfture_tap_rd_default, dfture_tap_rd[2:0],dfture_tap_wr[3:0]}),
        .q    	({dfture_tap_rd_d1[3:0],                    dfture_tap_wr_en[3:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

   
   assign dfture_tap_rd_en [0] = dfture_tap_rd_d1[0] & ~rst_tri_en;
   assign dfture_tap_rd_en [1] = dfture_tap_rd_d1[1] & ~rst_tri_en;
   assign dfture_tap_rd_en [2] = dfture_tap_rd_d1[2] & ~rst_tri_en;
   assign dfture_tap_rd_en [3] = dfture_tap_rd_d1[3] | rst_tri_en;
   
                                      
// BIST_Controller ASI

wire	bistctl_va_vld_m,bistctl_state_en_m;
assign  bistctl_va_vld_m = (lsu_ldst_va_b7_b0_m[7:0] == 8'h00);
assign  bistctl_state_en_m = (lsu_dctl_asi_state_m[7:0] == 8'h42) & bistctl_va_vld_m &
        lsu_alt_space_m ;
dff_s  #(2) bistdcd_stw (
        .din    ({bistctl_va_vld_m,bistctl_state_en_m}),
        .q    	({bistctl_va_vld,bistctl_state_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 
// asi42 dealt with as a whole.
/*assign  bistctl_illgl_va = (lsu_asi_state[7:0] == 8'h42) & ~bistctl_va_vld &
        lsu_alt_space_g ;*/
//assign  bistctl_rd_en = bistctl_state_en & asi_ld_vld_g ;
assign  bistctl_wr_en = (bistctl_state_en & asi_st_vld_g) | bist_tap_wr_en ;
//assign  bistctl_rd_en = bistctl_state_en & ld_inst_vld_g ;
//assign  bistctl_wr_en = (bistctl_state_en & st_inst_vld_g) | bist_tap_wr_en ;
   
//test_stub interface. bist_tap_wr_en should exclude?
assign  bist_ctl_reg_wr_en = bistctl_wr_en;
   

// Self-Timed Margin Control ASI

wire	mrgnctl_va_vld_m,mrgnctl_state_en_m;
assign  mrgnctl_va_vld_m = (lsu_ldst_va_b7_b0_m[7:0] == 8'h00);
assign  mrgnctl_state_en_m = (lsu_dctl_asi_state_m[7:0] == 8'h44) & mrgnctl_va_vld_m &
        lsu_alt_space_m ;
dff_s  #(2) mrgndcd_stw (
        .din    ({mrgnctl_va_vld_m,mrgnctl_state_en_m}),
        .q    	({mrgnctl_va_vld,mrgnctl_state_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign  mrgnctl_illgl_va = (lsu_asi_state[7:0] == 8'h44) & ~mrgnctl_va_vld &
        lsu_alt_space_g ;

assign  mrgnctl_wr_en = ((mrgnctl_state_en & asi_st_vld_g) | mrgn_tap_wr_en | ~dctl_rst_l) & ~sehold; //bug 4508

// LSU Diag Reg ASI
// No access from tap.
wire	ldiagctl_va_vld_m,ldiagctl_state_en_m;
assign  ldiagctl_va_vld_m = (lsu_ldst_va_b7_b0_m[7:0] == 8'h10);
assign  ldiagctl_state_en_m = (lsu_dctl_asi_state_m[7:0] == 8'h42) & ldiagctl_va_vld_m &
        lsu_alt_space_m ;
dff_s  #(2) ldiagdcd_stw (
        .din    ({ldiagctl_va_vld_m,ldiagctl_state_en_m}),
        .q    	({ldiagctl_va_vld,ldiagctl_state_en}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 
// asi42 dealt with as a whole.
/*assign  ldiagctl_illgl_va = (lsu_asi_state[7:0] == 8'h42) & ~ldiagctl_va_vld &
        lsu_alt_space_g ;*/

wire	asi42_g ;
wire	ifu_asi42_flush_g ;
assign	ifu_asi42_flush_g = 
	bistctl_state_en | ldiagctl_state_en | // lsu's asi42 should not set asi queue.
	(asi42_g & asi42_illgl_va) ; 		// illgl-va should not set asi queue.

//assign  ldiagctl_rd_en = ldiagctl_state_en & asi_ld_vld_g ;
assign  ldiagctl_wr_en = (ldiagctl_state_en & asi_st_vld_g) | reset;
//assign  ldiagctl_rd_en = ldiagctl_state_en & ld_inst_vld_g ;
//assign  ldiagctl_wr_en = (ldiagctl_state_en & st_inst_vld_g) | reset;

wire  instmsk_va_vld ;
assign  instmsk_va_vld = (ldst_va_g[7:0] == 8'h08);
assign	asi42_g = (lsu_asi_state[7:0] == 8'h42) ; 
assign  asi42_illgl_va = 
	asi42_g &
	~(ldiagctl_va_vld | bistctl_va_vld | instmsk_va_vld) &
        lsu_alt_space_g ;



//=========================================================================================
//  Partition ID Register
//=========================================================================================

// ASI=58, VA=0x80, Per thread
// The pid is to be used by tlb-cam, and writes to tlb. It is kept in the lsu
// as it is used by the dtlb, plus changes to mmu_dp are to be kept to a minimum.

// Trap if supervisor accesses hyperpriv asi - see supv_use_hyp. Could be incorrect.
// Correct on merge to mainline.

// The VA compares can probably be shortened.
assign  pid_va_vld = (ldst_va_g[7:0] == 8'h80);
assign  pid_state_en = (lsu_asi_state[7:0] == 8'h58) & pid_va_vld &
        lsu_alt_space_g & lsu_inst_vld_w ; 
//assign  pid_illgl_va = (lsu_asi_state[7:0] == 8'h58) & ~pid_va_vld &
//        lsu_alt_space_g & lsu_inst_vld_w ; 

// remove reset ??
//assign  pid_state_wr_en[0] = (pid_state_en & st_inst_vld_g & thread0_g) | reset ;
assign  pid_state_wr_en[0] = (pid_state_en & asi_st_vld_g & thread0_g) | reset ;
assign  pid_state_wr_en[1] = (pid_state_en & asi_st_vld_g & thread1_g) | reset ;
assign  pid_state_wr_en[2] = (pid_state_en & asi_st_vld_g & thread2_g) | reset ;
assign  pid_state_wr_en[3] = (pid_state_en & asi_st_vld_g & thread3_g) | reset ;

//assign  pid_state_rd_en[0] = pid_state_en & ld_inst_vld_g & thread0_g ;

//assign  pid_state_rd_en[0] = pid_state_en & asi_ld_vld_g & thread0_g ;
//assign  pid_state_rd_en[1] = pid_state_en & asi_ld_vld_g & thread1_g ;
//assign  pid_state_rd_en[2] = pid_state_en & asi_ld_vld_g & thread2_g ;
//assign  pid_state_rd_en[3] = pid_state_en & asi_ld_vld_g & thread3_g ;


//=========================================================================================
//  Local LDXA Read
//=========================================================================================

// Timing : rd_en changed to _en with inst_vld

//wire  [3:0] misc_ctl_sel ;
wire    misc_tap_rd_sel ;
/*
assign  misc_tap_rd_sel = mrgn_tap_rd_en | bist_tap_rd_en |  dfture_tap_rd_sel ;
assign  misc_ctl_sel[0] = bist_tap_rd_en | (~misc_tap_rd_sel &  bistctl_state_en & ld_inst_vld_unflushed) ;
assign  misc_ctl_sel[1] = mrgn_tap_rd_en | (~misc_tap_rd_sel &  mrgnctl_state_en & ld_inst_vld_unflushed) ;
assign  misc_ctl_sel[3] = dfture_tap_rd_sel ;

//assign  misc_ctl_sel[2] = (~misc_tap_rd_sel & ldiagctl_state_en & ld_inst_vld_unflushed) ;
assign  misc_ctl_sel[2] = ~(misc_ctl_sel[0] | misc_ctl_sel[1] | misc_ctl_sel[3] ); //force default
*/
   
//****push misc_ctl_sel in previosu cycle*****
   wire [3:0] misc_ctl_sel_din;

//0-in bug, priority encode tap requests to prevent illegal type through one-hot mux   
   wire       dfture_tap_rd_or ;
   assign     dfture_tap_rd_or = | (dfture_tap_rd [3:0]);
   assign     misc_tap_rd_sel = mrgn_tap_rd | bist_tap_rd |  dfture_tap_rd_or ;
   assign     misc_ctl_sel_din[0] = bist_tap_rd | 
                                   (~misc_tap_rd_sel &  bistctl_state_en_m & ld_inst_vld_m) ;
   assign     misc_ctl_sel_din[1] = (~bist_tap_rd & mrgn_tap_rd) | 
                                    (~misc_tap_rd_sel &  mrgnctl_state_en_m & ld_inst_vld_m) ;
   assign     misc_ctl_sel_din[3] = ~bist_tap_rd & ~mrgn_tap_rd & dfture_tap_rd_or;
   assign     misc_ctl_sel_din[2] = ~(misc_ctl_sel_din[0] | misc_ctl_sel_din[1] | misc_ctl_sel_din[3] ) ;


  
// ASI accesses should be mutex except for non-access cases.
assign  lsu_asi_sel_fmx1[0] = pctxt_state_en & ld_inst_vld_unflushed;  
assign  lsu_asi_sel_fmx1[1] = sctxt_state_en & ld_inst_vld_unflushed & ~lsu_asi_sel_fmx1[0]; 
assign  lsu_asi_sel_fmx1[2] = ~(|lsu_asi_sel_fmx1[1:0]);   //force default

assign  lsu_asi_sel_fmx2[0] = |lsu_asi_sel_fmx1[1:0] | (pid_state_en & ld_inst_vld_unflushed) ;  
assign  lsu_asi_sel_fmx2[1] = lsu_ctl_state_en & ld_inst_vld_unflushed & ~(lsu_asi_sel_fmx2[0]);  
assign  lsu_asi_sel_fmx2[2] = ~(|lsu_asi_sel_fmx2[1:0]) ; //force default

   wire va_wtchpt_en;
  
wire	lsu_asi_rd_sel ; 
//assign  lsu_asi_rd_sel = ((|lsu_asi_sel_fmx1[1:0]) | 
//                         ((pid_state_en | va_wtchpt_en) & ld_inst_vld_unflushed) |
//		                   	 (|lsu_asi_sel_fmx2[1:0]) | 
//                          misc_asi_rd_en) & 
//                        lsu_inst_vld_w ;   

assign  lsu_asi_rd_sel = ((|lsu_asi_sel_fmx1[1:0]) | 
                         (pid_state_en  & ld_inst_vld_unflushed) |     //remove va_wtchpt_en
		                   	 (|lsu_asi_sel_fmx2[1:0]) | 
                          misc_asi_rd_en) & 
                          lsu_inst_vld_w ;   

   
assign	lsu_asi_rd_en = (lsu_asi_rd_sel | lsu_va_wtchpt_sel_g) & ~dctl_early_flush_w ; //add va_wtchpt

//assign	lsu_asi_rd_en = lsu_asi_rd_sel & ~lsu_flush_pipe_w ;

assign  misc_asi_rd_en = (bistctl_state_en | mrgnctl_state_en | ldiagctl_state_en) & ld_inst_vld_unflushed ;

assign        lsu_local_ldxa_sel_g =  lsu_asi_rd_sel  & ~rst_tri_en ; // w/o flush

assign        lsu_local_ldxa_tlbrd_sel_g  =  (lsu_tlb_tag_rd_vld_g | lsu_tlb_data_rd_vld_g | lsu_tlb_csm_rd_vld_g) & ~rst_tri_en;



assign        lsu_va_wtchpt_sel_g =  (va_wtchpt_en & ld_inst_vld_unflushed) & ~rst_tri_en;

assign        lsu_local_diagnstc_tagrd_sel_g  =  (~(lsu_local_ldxa_sel_g | lsu_local_ldxa_tlbrd_sel_g |
                                                   lsu_va_wtchpt_sel_g)) | rst_tri_en; //add va_wtchpt

// or diagnostic read w/ asi read enable
assign  lsu_diagnstc_asi_rd_en  =  lsu_asi_rd_en | dtagv_diagnstc_rd_g  ; //Bug 3959
//assign  lsu_diagnstc_asi_rd_en  =  lsu_asi_rd_en | dtagv_diagnstc_rd_g  | lsu_local_ldxa_tlbrd_sel_g;


dff_s  #(1) lldxa_stw2 (
        .din    (lsu_diagnstc_asi_rd_en),
        .q      (lsu_asi_rd_en_w2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire	ldxa_tlbrd0_w2,ldxa_tlbrd1_w2,ldxa_tlbrd2_w2,ldxa_tlbrd3_w2;
wire	ldxa_tlbrd0_w3,ldxa_tlbrd1_w3,ldxa_tlbrd2_w3,ldxa_tlbrd3_w3;

// stg mismatched intentionally. stxa_tid decode can be used by ldxa.
assign	ldxa_tlbrd3_w2 = tlu_stxa_thread3_w2 & lsu_local_ldxa_tlbrd_sel_g ;
assign	ldxa_tlbrd2_w2 = tlu_stxa_thread2_w2 & lsu_local_ldxa_tlbrd_sel_g ;
assign	ldxa_tlbrd1_w2 = tlu_stxa_thread1_w2 & lsu_local_ldxa_tlbrd_sel_g ;
assign	ldxa_tlbrd0_w2 = tlu_stxa_thread0_w2 & lsu_local_ldxa_tlbrd_sel_g ;

// Bug 3959
dff_s  #(4) tlbrd_stw3 (
        .din    ({ldxa_tlbrd3_w2,ldxa_tlbrd2_w2,
        	ldxa_tlbrd1_w2,ldxa_tlbrd0_w2}),
        .q    	({ldxa_tlbrd3_w3,ldxa_tlbrd2_w3,
        	ldxa_tlbrd1_w3,ldxa_tlbrd0_w3}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

// pid and va-wtchpt va removed.
assign  lsu_asi_illgl_va = 
  lsuctl_illgl_va | pscxt_ldxa_illgl_va | mrgnctl_illgl_va | asi42_illgl_va ;
assign  lsu_asi_illgl_va_cmplt[0] = lsu_asi_illgl_va & ld_inst_vld_g & thread0_g ;
assign  lsu_asi_illgl_va_cmplt[1] = lsu_asi_illgl_va & ld_inst_vld_g & thread1_g ;
assign  lsu_asi_illgl_va_cmplt[2] = lsu_asi_illgl_va & ld_inst_vld_g & thread2_g ;
assign  lsu_asi_illgl_va_cmplt[3] = lsu_asi_illgl_va & ld_inst_vld_g & thread3_g ;

dff_s  #(4) lsuillgl_stgw2(
        .din    (lsu_asi_illgl_va_cmplt[3:0]),
        .q      (lsu_asi_illgl_va_cmplt_w2[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

//=========================================================================================
//  ASI_DCACHE_TAG way decode
//=========================================================================================

// Bug 4569. 
// add sehold. adding in dctldp flop will cause critical path.

wire	[3:0]	dtag_rsel_dcd,dtag_rsel_hold ;
assign  dtag_rsel_dcd[3:0]  =  	{(lsu_ldst_va_b12_b11_m[12:11] == 2'b11),
                               	(lsu_ldst_va_b12_b11_m[12:11] == 2'b10),
                               	(lsu_ldst_va_b12_b11_m[12:11] == 2'b01),
                                (lsu_ldst_va_b12_b11_m[12:11] == 2'b00)};
//bug5994
dffe_s #(4) dtag_hold (
        .din    (dtag_rsel_dcd[3:0]),
        .q      (dtag_rsel_hold[3:0]),
        .en     (sehold),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_dtag_rsel_m[3:0] = sehold ? dtag_rsel_hold[3:0] : dtag_rsel_dcd[3:0] ;


//=========================================================================================
//  Watchpoint Control
//=========================================================================================
   wire va_vld;
   
assign  va_vld = (ldst_va_g[7:0] == 8'h38);
   
assign  va_wtchpt_en = (lsu_asi_state[7:0] == 8'h58)  & va_vld &
      lsu_alt_space_g & lsu_inst_vld_w ; 

// Illegal va checking for asi 58 done in MMU.
   
// one VA watchptr supported per thread

// Need to read register !!!
// Switchout thread on read.
// qualify with inst_vld_w.
//assign  va_wtchpt_rd_en = va_wtchpt_en & ld_inst_vld_g ;

   wire va_wtchpt0_wr_en, va_wtchpt1_wr_en, va_wtchpt2_wr_en, va_wtchpt3_wr_en;
  
//assign  va_wtchpt0_wr_en = va_wtchpt_en & st_inst_vld_g & thread0_g;
assign  va_wtchpt0_wr_en = va_wtchpt_en & asi_st_vld_g & thread0_g;
assign  va_wtchpt1_wr_en = va_wtchpt_en & asi_st_vld_g & thread1_g;
assign  va_wtchpt2_wr_en = va_wtchpt_en & asi_st_vld_g & thread2_g;
assign  va_wtchpt3_wr_en = va_wtchpt_en & asi_st_vld_g & thread3_g;
assign  lsu_va_wtchpt0_wr_en_l = ~va_wtchpt0_wr_en ;
assign  lsu_va_wtchpt1_wr_en_l = ~va_wtchpt1_wr_en ;
assign  lsu_va_wtchpt2_wr_en_l = ~va_wtchpt2_wr_en ;
assign  lsu_va_wtchpt3_wr_en_l = ~va_wtchpt3_wr_en ;

assign  vw_wtchpt_cmp_en_m =  // VA Write Watchpoint Enable
  (thread0_m & lsu_ctl_reg0[4]) | 
  (thread1_m & lsu_ctl_reg1[4]) | 
  (thread2_m & lsu_ctl_reg2[4]) | 
  (thread3_m & lsu_ctl_reg3[4]) ; 

assign  vr_wtchpt_cmp_en_m =  // VA Read Watchpoint Enable
  (thread0_m & lsu_ctl_reg0[5]) | 
  (thread1_m & lsu_ctl_reg1[5]) | 
  (thread2_m & lsu_ctl_reg2[5]) | 
  (thread3_m & lsu_ctl_reg3[5]) ; 

   assign  va_wtchpt_cmp_en_m =
(vw_wtchpt_cmp_en_m & st_inst_vld_m) | 
(vr_wtchpt_cmp_en_m & ld_inst_vld_m) ; 

//=========================================================================================
//  Hit/Miss/Fill Control
//=========================================================================================
dff_s  #(10) stg_m (
        .din    ({ld_inst_vld_e, st_inst_vld_e,ldst_sz_e[1:0],
    ifu_lsu_rd_e[4:0],ifu_lsu_ldst_fp_e}),
        .q      ({ld_inst_vld_m, st_inst_vld_m,ldst_sz_m[1:0],
    ld_rd_m[4:0],fp_ldst_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire    dcache_arry_data_sel_e;

assign   dcache_arry_data_sel_e = lsu_bist_rvld_e | ld_inst_vld_e | dcache_iob_rd_e ;
dff_s #(1) dcache_arry_data_sel_stgm (
  .din (dcache_arry_data_sel_e),
  .q   (dcache_arry_data_sel_m),
  .clk    (clk),
  .se     (se),       .si (),          .so ()
); 

   
dff_s  #(10) stg_g (
        .din    ({ld_inst_vld_m, st_inst_vld_m,ldst_sz_m[1:0],
    ld_rd_m[4:0],fp_ldst_m}),
        .q      ({ld_inst_vld_unflushed, st_inst_vld_unflushed,ldst_sz_g[1:0],
    ld_rd_g[4:0],fp_ldst_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 


//assign  asi_ld_vld_g = ld_inst_vld_unflushed & lsu_inst_vld_w & ~dctl_early_flush_w ;
assign  asi_st_vld_g = st_inst_vld_unflushed & lsu_inst_vld_w & ~dctl_early_flush_w ;
assign  ld_inst_vld_g = ld_inst_vld_unflushed & lsu_inst_vld_w & ~dctl_flush_pipe_w ;
assign  st_inst_vld_g = st_inst_vld_unflushed & lsu_inst_vld_w & ~dctl_flush_pipe_w ;

// assign  lsu_way_hit[0] = cache_way_hit_buf1[0] & dcache_enable_g ;
// assign  lsu_way_hit[1] = cache_way_hit_buf1[1] & dcache_enable_g ;
// assign  lsu_way_hit[2] = cache_way_hit_buf1[2] & dcache_enable_g ;
// assign  lsu_way_hit[3] = cache_way_hit_buf1[3] & dcache_enable_g ;
  

 assign  lsu_way_hit[0] = cache_way_hit_buf1[0] & dcache_enable_g ;


 assign  lsu_way_hit[1] = cache_way_hit_buf1[1] & dcache_enable_g ;


 assign  lsu_way_hit[2] = cache_way_hit_buf1[2] & dcache_enable_g ;


 assign  lsu_way_hit[3] = cache_way_hit_buf1[3] & dcache_enable_g ;


 
//assign  st_set_index_g[5:0] = ldst_va_g[9:4] ;
//assign  st_set_way_g[3:1] = lsu_way_hit[3:1] ;

// This should contain ld miss, MMU miss, exception. 
// should tlb_cam_miss be factored in or can miss/hit be solely
// based on way_hit.

wire  tlb_cam_hit_mod ;
dff_s  stgcmiss_g (
        .din    (tlb_cam_hit),
        .q      (tlb_cam_hit_mod),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// NOTE !! qualification with tte_data_parity_error removed for timing.
assign tlb_cam_hit_g = tlb_cam_hit_mod ;
//assign tlb_cam_hit_g = tlb_cam_hit_mod & ~tte_data_parity_error ;

/*assign  ld_stb_hit_g = 
        ld_stb0_full_raw_g | ld_stb1_full_raw_g |
        ld_stb2_full_raw_g | ld_stb3_full_raw_g |
        ld_stb0_partial_raw_g | ld_stb1_partial_raw_g |
        ld_stb2_partial_raw_g | ld_stb3_partial_raw_g ; */

wire nceen_pipe_m, nceen_pipe_g ;

   wire [3:0] lsu_nceen_d1;
   
dff_s #(4) nceen_stg (
   .din (ifu_lsu_nceen[3:0]),
   .q   (lsu_nceen_d1[3:0]),
   .clk (clk),
   .se  (se),       .si (),          .so ()
);
                
   
assign  nceen_pipe_m = 
(thread0_m & lsu_nceen_d1[0]) | (thread1_m & lsu_nceen_d1[1]) |
(thread2_m & lsu_nceen_d1[2]) | (thread3_m & lsu_nceen_d1[3]) ;

dff_s #(1)  stgg_een (
        .din    (nceen_pipe_m),
        .q      (nceen_pipe_g),
        .clk  	(clk),
        .se     (se),       .si (),          .so ()
        );

//wire	tte_data_perror_corr_en ;
wire	tte_data_perror_unc_en ;
// separate ld from st for error reporting.
assign	tte_data_perror_unc_en = ld_inst_vld_unflushed & tte_data_perror_unc & nceen_pipe_g ;
//assign	tte_data_perror_unc_en = tte_data_perror_unc & nceen_pipe_g ;
//assign	tte_data_perror_corr_en = tte_data_perror_corr ;
//assign	tte_data_perror_corr_en = tte_data_perror_corr & ceen_pipe_g ;

wire	dtlb_perror_en_w,dtlb_perror_en_w2,dtlb_perror_en_w3 ;
assign	dtlb_perror_en_w = tte_data_perror_unc_en ;
//assign	dtlb_perror_en_w = tte_data_perror_unc_en | tte_data_perror_corr_en ;

dff_s #(1)  stgw2_perr (
        .din    (dtlb_perror_en_w),
        .q      (dtlb_perror_en_w2),
        .clk  	(clk),
        .se     (se),       .si (),          .so ()
        );

dff_s #(1)  stgw3_perr (
        .din    (dtlb_perror_en_w2),
        .q      (dtlb_perror_en_w3),
        .clk  	(clk),
        .se     (se),       .si (),          .so ()
        );

// For now, "or" ld_inst_vld_g and ldst_dbl. Ultimately, it ldst_dbl
// needs to cause ld_inst_vld_g to be asserted.
// st and ld ldst_dbl terms are redundant.
// Diagnostic Dcache access will force a hit in cache. Whatever is read
// out will be written back to irf regardless of whether hit or not. The
// expectation is that cache has been set up to hit.
// lsu_dcache_enable is redundant as factored in lsu_way_hit !!!
// squash both ld_miss and ld_hit in cause of dtlb unc data error.
   wire ldd_force_l2access_g;
   
   wire int_ldd_g, fp_ldd_g;
   assign fp_ldd_g = fp_ldst_g & ~(blk_asi_g & lsu_alt_space_g);

   //sas code need int_ldd_g
   assign int_ldd_g = ldst_dbl_g  & ~fp_ldd_g;
   assign ldd_force_l2access_g = int_ldd_g;

assign  lsu_ld_miss_wb  = 
(~(|lsu_way_hit[4-1:0]) | ~dcache_enable_g | ~(tlb_cam_hit_g | lsu_dtlb_bypass_g) |
  ldxa_internal | ldd_force_l2access_g | atomic_g |  endian_mispred_g | // remove stb_cam_hit
  dcache_rd_parity_error | dtag_perror_g) & 
	~((dc_diagnstc_asi_g & lsu_alt_space_g)) & 
	//~(tte_data_perror_unc_en | tte_data_perror_corr_en | (dc_diagnstc_asi_g & lsu_alt_space_g)) & 
  (ld_vld & (~lsu_alt_space_g | (lsu_alt_space_g & recognized_asi_g))) |
  //(ld_inst_vld_g & (~lsu_alt_space_g | (lsu_alt_space_g & recognized_asi_g))) |
  //(ldst_dbl_g & st_inst_vld_g)  // signal ld-miss for stdbl.
  ncache_asild_rq_g ;   // asi ld requires bypass

assign  lsu_ld_hit_wb   = 
((|lsu_way_hit[4-1:0])  & dcache_enable_g & (tlb_cam_hit_g | lsu_dtlb_bypass_g) &  //bug3702
  ~ldxa_internal & ~dcache_rd_parity_error & ~dtag_perror_g & ~endian_mispred_g &
  ~ldd_force_l2access_g & ~atomic_g &  ~ncache_asild_rq_g) &  // remove stb_cam_hit
~((dc_diagnstc_asi_g & lsu_alt_space_g)) &
//~(tte_data_perror_unc_en | tte_data_perror_corr_en | (dc_diagnstc_asi_g & lsu_alt_space_g)) &
  ld_vld & (~lsu_alt_space_g | (lsu_alt_space_g & recognized_asi_g)) ;
//ld_inst_vld_g & (~lsu_alt_space_g | (lsu_alt_space_g & recognized_asi_g)) ;
// force hit for diagnostic write. 

// correctible dtlb data parity error on cam will cause dmmu miss.
// prefetch will rely on the ld_inst_vld/st_inst_vld not being asserted
// to prevent mmu_miss from being signalled if prefetch does not translate.
// Timing Change : Remove data perror from dmmu_miss ; to be treated as disrupting trap.
//SC assign dmmu_miss_g = 
//SC   ~tlb_cam_hit_mod & ~lsu_dtlb_bypass_g & 
//SC   //~(tlb_cam_hit_mod & ~tte_data_perror_corr) & ~lsu_dtlb_bypass_g & 
//SC   ((ld_inst_vld_unflushed & lsu_inst_vld_w) | 
//SC    (st_inst_vld_unflushed & lsu_inst_vld_w)) & 
//SC     ~(ldxa_internal | stxa_internal | early_trap_vld_g) ;

//SC    wire dmmu_miss_only_g ;
   
//SC assign dmmu_miss_only_g = 
//SC  ~tlb_cam_hit_mod & ~lsu_dtlb_bypass_g & 
//SC   //~(tlb_cam_hit_mod & ~tte_data_perror_corr) & ~lsu_dtlb_bypass_g & 
//SC   ((ld_inst_vld_unflushed & lsu_inst_vld_w) | 
//SC    (st_inst_vld_unflushed & lsu_inst_vld_w)) & 
//SC     ~(ldxa_internal | stxa_internal);
    
// Atomic Handling :
// Bypass to irf will occur. However, the loads will not write to cache/tag etc.

// Exceptions, tlb miss will have to be included.  
// diagnostic dcache/dtagv will read respective arrays in pipeline. (changed!)
// They will not switch out thread with this assumption. 

//dc_diagnstc will not switch out, dtagv will switch out
 
//wire dc_diagnstc_rd_g;  
//assign  dc_diagnstc_rd_g = dc_diagnstc_asi_g & ld_inst_vld_g & lsu_alt_space_g ; 

//wire	dc0_diagnstc_rd_g,dc1_diagnstc_rd_g,dc2_diagnstc_rd_g,dc3_diagnstc_rd_g ;
//wire	dc0_diagnstc_rd_w2,dc1_diagnstc_rd_w2,dc2_diagnstc_rd_w2,dc3_diagnstc_rd_w2 ;
//assign  dc0_diagnstc_rd_g = dc_diagnstc_rd_g & thread0_g ;
//assign  dc1_diagnstc_rd_g = dc_diagnstc_rd_g & thread1_g ;
//assign  dc2_diagnstc_rd_g = dc_diagnstc_rd_g & thread2_g ;
//assign  dc3_diagnstc_rd_g = dc_diagnstc_rd_g & thread3_g ;

//dff #(4)  stgw2_dcdiag (
//        .din  ({dc3_diagnstc_rd_g,dc2_diagnstc_rd_g,dc1_diagnstc_rd_g,dc0_diagnstc_rd_g}),
//        .q    ({dc3_diagnstc_rd_w2,dc2_diagnstc_rd_w2,dc1_diagnstc_rd_w2,dc0_diagnstc_rd_w2}),
//        .clk  (clk),
//        .se     (se),       .si (),          .so ()
//        );

assign  dtagv_diagnstc_rd_g = dtagv_diagnstc_asi_g & ld_inst_vld_g & lsu_alt_space_g ; 

// Prefetch will swo thread if it does not miss in tlb.
wire pref_inst_m;
wire pref_inst_g;
dff_s  stgm_prf (
        .din    (ifu_lsu_pref_inst_e),
        .q      (pref_inst_m),
        .clk  (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  stgg_prf (
        .din    (pref_inst_m),
        .q      (pref_inst_g),
        .clk  (clk),
        .se     (se),       .si (),          .so ()
        );



//assign	lsu_ifu_data_error_w = 1'b0 ;

// is this redundant ? isn't lsu_ncache_ld_e sufficient ?
assign  atomic_ld_squash_e = 
  ~lmq_ld_rq_type_e[2] & lmq_ld_rq_type_e[1] & lmq_ld_rq_type_e[0] ;

// bypass will occur with hit in d$ or data return from L2.
// Fill for dcache diagnostic rd will happen regardless. dfill vld qualified with
// flush_pipe and inst_vld !!!

//timing fix. move logic to previous cycle M.   
//assign  lsu_exu_dfill_vld_w2  =   
//  (l2fill_vld_g & ~(unc_err_trap_g | l2fill_fpld_g))  	      | // fill
//  (~fp_ldst_g & ld_inst_vld_unflushed & lsu_inst_vld_w)       | // in pipe
//  intld_byp_data_vld ;	                                        // bypass

   wire lsu_exu_dfill_vld_m;
   wire	intld_byp_data_vld_e,intld_byp_data_vld_m ;
   wire	intld_byp_data_vld ;
   wire	ldxa_swo_annul ;

assign lsu_exu_dfill_vld_m = 
  (l2fill_vld_m & ~(unc_err_trap_m | l2fill_fpld_m))  	      | // fill
  (~fp_ldst_m & ld_inst_vld_m & 
	~(ldxa_swo_annul & lsu_alt_space_m) & flush_w_inst_vld_m) | // in pipe
  intld_byp_data_vld_m ;	                                      // bypass

dff_s #(1) dfill_vld_stgg (
   .din (lsu_exu_dfill_vld_m),
   .q   (lsu_exu_dfill_vld_w2),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);       

//------              
// Bld errors : Bug 4315
// Errors need to be accummulated across helpers. Once unc error detected 
// in any helper, then all further writes to frf are squashed.
// daccess_error trap taken at very end if *any* helper had an unc error.

wire	bld_cnt_max_m,bld_cnt_max_g ;
assign	bld_cnt_max_m = lsu_bld_cnt_m[2] & lsu_bld_cnt_m[1] & lsu_bld_cnt_m[0] ;

wire	[1:0]	cpx_ld_err_m ;
dff_s #(3) lderr_stgm (
   .din ({lsu_cpx_pkt_ld_err[1:0],bld_cnt_max_m}),
   .q   ({cpx_ld_err_m[1:0],bld_cnt_max_g}),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);       

wire [1:0] bld_err ;
wire [1:0] bld_err_din ;
wire 	   bld_rst ;
// Accummulate errors.
assign	bld_err_din[1:0] = cpx_ld_err_m[1:0] | bld_err[1:0] ;
assign	bld_rst = reset | lsu_bld_reset ;

dffre_s #(2) blderr_ff (
        .din    (bld_err_din[1:0]),
        .q      (bld_err[1:0]),
        .clk    (clk),
        .en     (lsu_bld_helper_cmplt_m), .rst (bld_rst),
        .se     (se),	.si (),	.so ()
        );

wire	bld_helper_cmplt_g ;
dff_s  bldh_stgg (
   .din (lsu_bld_helper_cmplt_m),
   .q   (bld_helper_cmplt_g),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);

wire	bld_unc_err_pend_g, bld_unc_err_pend_w2 ;
assign	bld_unc_err_pend_g = bld_err[1] & bld_helper_cmplt_g ;
wire	bld_corr_err_pend_g, bld_corr_err_pend_w2 ;
// pended unc error gets priority.
assign	bld_corr_err_pend_g = bld_err[0] & ~bld_err[1] & bld_helper_cmplt_g ;

wire	bld_squash_err_g,bld_squash_err_w2 ;
// bld cnt should be vld till g
assign	bld_squash_err_g = bld_helper_cmplt_g & ~bld_cnt_max_g ;

dff_s #(3)  bldsq_stgw2 (
   .din ({bld_squash_err_g,bld_unc_err_pend_g,bld_corr_err_pend_g}),
   .q   ({bld_squash_err_w2,bld_unc_err_pend_w2,bld_corr_err_pend_w2}),
   .clk    (clk),
   .se     (se),       .si (),          .so ()
);

//------              
   
wire	stb_cam_hit_w2 ;
wire	fld_vld_sync_no_camhit,fld_vld_sync_no_camhit_w2 ;
wire	fld_vld_async,fld_vld_async_w2 ;
dff_s  #(3) stbchit_stg (
        .din    ({stb_cam_hit,fld_vld_sync_no_camhit,fld_vld_async}),
        .q      ({stb_cam_hit_w2,fld_vld_sync_no_camhit_w2,fld_vld_async_w2}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  fld_vld_sync_no_camhit =  
	(lsu_ld_hit_wb & ~tte_data_perror_unc_en & fp_ldst_g &
	~dctl_flush_pipe_w) ; // l1hit 

assign	fld_vld_async =
        (l2fill_vld_g & l2fill_fpld_g & ~(unc_err_trap_g | bld_unc_err_pend_g))  | 
						// fill from l2, // bug 3705, 4315(err_trap)
        fpld_byp_data_vld ;     // bypass data

assign	lsu_ffu_ld_vld = 
	(fld_vld_sync_no_camhit_w2 & ~stb_cam_hit_w2) |
	fld_vld_async_w2 ;


/*dff  #(1) fldvld_stgw2 (
        .din    (ffu_ld_vld),
        .q      (lsu_ffu_ld_vld),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

dff_s  #(2) dtid_stgm (
        .din    (lsu_dfill_tid_e[1:0]),
        .q      (dfq_tid_m[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  #(2) dtid_stgg (
        .din    (dfq_tid_m[1:0]),
        .q      (dfq_tid_g[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Timing Change -  shifting dfill-data sel gen. to m-stage
//assign  ldbyp_tid[0] = ld_thrd_byp_sel_g[1] | ld_thrd_byp_sel_g[3] ;
//assign  ldbyp_tid[1] = ld_thrd_byp_sel_g[2] | ld_thrd_byp_sel_g[3] ;
wire 	[3:0]	ld_thrd_byp_sel_m ;
assign  ldbyp_tid_m[0] = ld_thrd_byp_sel_m[1] | ld_thrd_byp_sel_m[3] ;
assign  ldbyp_tid_m[1] = ld_thrd_byp_sel_m[2] | ld_thrd_byp_sel_m[3] ;


/*assign  lsu_exu_thr_g[1:0] = ld_inst_vld_unflushed ? thrid_g[1:0] :
          l2fill_vld_g ? dfq_tid_g[1:0] : ldbyp_tid[1:0] ; */
assign  lsu_exu_thr_m[1:0] = ld_inst_vld_m ? thrid_m[1:0] :
          l2fill_vld_m ? dfq_tid_m[1:0] : ldbyp_tid_m[1:0] ; 

// What is the policy for load-double/atomics to update cache ?
// cas will not update cache. similary neither will ldstub nor cas.
// BIST will effect dcache only, not tags and vld bits.
// Removed dcache_enable from dc_diagnstc_wr_en !!!
wire	l2fill_vld_e ;
wire	dcache_alt_src_wr_e ;
assign	l2fill_vld_e = lsu_l2fill_vld & ~lsu_cpx_pkt_prefetch2 ;
assign  lsu_dcache_wr_vld_e = 
  (l2fill_vld_e & ~ignore_fill & ~atomic_ld_squash_e & ~ld_sec_active & ~lsu_ncache_ld_e) |
  lsu_st_wr_dcache  | // st writes from stb
  dcache_alt_src_wr_e ;

assign  dcache_alt_src_wr_e =
  (lsu_diagnstc_wr_src_sel_e & dc_diagnstc_wr_en)
  | lsu_bist_wvld_e     // bist engine writes to cache
  | dcache_iob_wr_e ;  // iobridge request write to dcache

//d$ valid bit 
   wire dv_diagnstic_wr;  
assign  dv_diagnstic_wr = (lsu_diagnstc_wr_src_sel_e & dtagv_diagnstc_wr_en & lsu_diagnstc_wr_data_b0) ;

   wire dva_din_e;
   wire ld_fill_e;
   
   assign ld_fill_e= (l2fill_vld_e & ~atomic_ld_squash_e & ~ld_sec_active & ~lsu_ncache_ld_e) ;   //ld-fill
   //######################################
   //snp      => dva_din = 0
   //ld fill  => dva_din = 1
   //diag wrt => dva_din = wrt_value
   //######################################
   assign dva_din_e =  ld_fill_e  | //ld-fill
                       dv_diagnstic_wr; // diagnostic write valid bit

   
// iob rd dominates
   wire lsu_dc_alt_rd_vld_e;
   
assign	lsu_dc_alt_rd_vld_e = dcache_iob_rd_e | lsu_bist_rvld_e ;

   //?? default when no ld in pipe
   assign dcache_alt_mx_sel_e = 
		//lsu_dcache_wr_vld_e | : Timing
		dcache_alt_src_wr_e | // rm st updates/fill - ~ld_inst_vld_e.
		lsu_dcache_wr_vld_e | 
		lsu_dc_alt_rd_vld_e  | ~ld_inst_vld_e;
  
   assign dcache_alt_mx_sel_e_bf = dcache_alt_mx_sel_e;

   wire   dcache_rvld_e_tmp, dcache_rvld_e_minbf;   
   assign dcache_rvld_e_tmp =  ld_inst_vld_e | lsu_dc_alt_rd_vld_e ;
   bw_u1_minbuf_5x  UZfix_dcache_rvld_e_minbf (.a(dcache_rvld_e_tmp), .z(dcache_rvld_e_minbf));
   assign dcache_rvld_e = dcache_rvld_e_minbf;
   
   wire   lsu_dtag_wr_vld_e_tmp;
   
assign  lsu_dtag_wr_vld_e_tmp = 
  ld_fill_e  & ~ignore_fill | //ld fill   //bug3601, 3676
  (lsu_diagnstc_wr_src_sel_e & dtagv_diagnstc_wr_en) ; // dtag/vld diagnostic wr

bw_u1_buf_30x UZsize_lsu_dtag_wrreq_x     ( .a(lsu_dtag_wr_vld_e_tmp), .z(lsu_dtag_wrreq_x_e)     );
bw_u1_buf_30x UZsize_lsu_dtag_index_sel_x ( .a(lsu_dtag_wr_vld_e_tmp), .z(lsu_dtag_index_sel_x_e) );
   
assign  lsu_dtagv_wr_vld_e = 
  lsu_dtag_wr_vld_e_tmp | 	// fill
  dva_svld_e        |   // snp
  lsu_bist_wvld_e ;     // bist clears dva by default

// mem cell change for dva
   wire [(4*4-1):0] dva_fill_bit_wr_en_e;

   // assign      dva_fill_bit_wr_en_e[15] = dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[3];
   // assign      dva_fill_bit_wr_en_e[14] = dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[2];
   // assign      dva_fill_bit_wr_en_e[13] = dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[1];
   // assign      dva_fill_bit_wr_en_e[12] = dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[0];
   // assign dva_fill_bit_wr_en_e[15:12] = (dcache_fill_addr_e[5:4] == 2'b11) ? lsu_dcache_fill_way_e[3:0] : 4'b0;

   // assign      dva_fill_bit_wr_en_e[11] = dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[3];
   // assign      dva_fill_bit_wr_en_e[10] = dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[2];
   // assign      dva_fill_bit_wr_en_e[09] = dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[1];
   // assign      dva_fill_bit_wr_en_e[08] = dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[0];
   // assign dva_fill_bit_wr_en_e[11:08] = (dcache_fill_addr_e[5:4] == 2'b10) ? lsu_dcache_fill_way_e[3:0] : 4'b0;
  
   // assign      dva_fill_bit_wr_en_e[07] = ~dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[3];
   // assign      dva_fill_bit_wr_en_e[06] = ~dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[2];
   // assign      dva_fill_bit_wr_en_e[05] = ~dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[1];
   // assign      dva_fill_bit_wr_en_e[04] = ~dcache_fill_addr_e[5] & dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[0];
   // assign dva_fill_bit_wr_en_e[07:04] = (dcache_fill_addr_e[5:4] == 2'b01) ? lsu_dcache_fill_way_e[3:0] : 4'b0;

   // assign      dva_fill_bit_wr_en_e[03] = ~dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[3];
   // assign      dva_fill_bit_wr_en_e[02] = ~dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[2];
   // assign      dva_fill_bit_wr_en_e[01] = ~dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[1];
   // assign      dva_fill_bit_wr_en_e[00] = ~dcache_fill_addr_e[5] & ~dcache_fill_addr_e[4] & lsu_dcache_fill_way_e[0];
   // assign dva_fill_bit_wr_en_e[03:00] = (dcache_fill_addr_e[5:4] == 2'b00) ? lsu_dcache_fill_way_e[3:0] : 4'b0;
   assign dva_fill_bit_wr_en_e[4*1-1 -: 4] = (dcache_fill_addr_e[5:4] == 2'b00) ? lsu_dcache_fill_way_e[4-1:0] : {4{1'b0}};
   assign dva_fill_bit_wr_en_e[4*2-1 -: 4] = (dcache_fill_addr_e[5:4] == 2'b01) ? lsu_dcache_fill_way_e[4-1:0] : {4{1'b0}};
   assign dva_fill_bit_wr_en_e[4*3-1 -: 4] = (dcache_fill_addr_e[5:4] == 2'b10) ? lsu_dcache_fill_way_e[4-1:0] : {4{1'b0}};
   assign dva_fill_bit_wr_en_e[4*4-1 -: 4] = (dcache_fill_addr_e[5:4] == 2'b11) ? lsu_dcache_fill_way_e[4-1:0] : {4{1'b0}};



   wire [(4*4-1):0] dva_bit_wr_en_e;
   assign      dva_bit_wr_en_e[(4*4-1):0] = dva_svld_e ? dva_snp_bit_wr_en_e[(4*4-1):0] : dva_fill_bit_wr_en_e;

   // wire [`L1D_ADDRESS_HI-6:0]  dva_snp_addr_e_bf;
   // bw_u1_buf_5x UZsize_dva_snp_addr_e_bf_b4 (.a(dva_snp_addr_e[4]), .z(dva_snp_addr_e_bf[4]));
   // bw_u1_buf_5x UZsize_dva_snp_addr_e_bf_b3 (.a(dva_snp_addr_e[3]), .z(dva_snp_addr_e_bf[3]));
   // bw_u1_buf_5x UZsize_dva_snp_addr_e_bf_b2 (.a(dva_snp_addr_e[2]), .z(dva_snp_addr_e_bf[2]));
   // bw_u1_buf_5x UZsize_dva_snp_addr_e_bf_b1 (.a(dva_snp_addr_e[1]), .z(dva_snp_addr_e_bf[1]));
   // bw_u1_buf_5x UZsize_dva_snp_addr_e_bf_b0 (.a(dva_snp_addr_e[0]), .z(dva_snp_addr_e_bf[0]));

   assign      dva_wr_adr_e[(6 + 4):6] = dva_svld_e ? dva_snp_addr_e[(6 + 4)-6:0] : dcache_fill_addr_e[(6 + 4):6];

// should ldxa_data_vld be included ?

assign  dfill_thread0 = ~lsu_dfill_tid_e[1] & ~lsu_dfill_tid_e[0] ;
assign  dfill_thread1 = ~lsu_dfill_tid_e[1] &  lsu_dfill_tid_e[0] ;
assign  dfill_thread2 =  lsu_dfill_tid_e[1] & ~lsu_dfill_tid_e[0] ;
assign  dfill_thread3 =  lsu_dfill_tid_e[1] &  lsu_dfill_tid_e[0] ;

assign  l2fill_fpld_e = lsu_l2fill_fpld_e ;

//=========================================================================================
//  LD/ST COMPLETE SIGNAL
//=========================================================================================

// Prefetch

wire	pref_tlbmiss_g ;
assign	pref_tlbmiss_g = 
pref_inst_g & 
(~tlb_cam_hit_g | (tlb_cam_hit_g & tlb_pgnum[39])) // nop on tlbmiss or io access
& lsu_inst_vld_w & ~dctl_flush_pipe_w ; // Bug 4318 bug6406/eco6619
   
//assign	pref_tlbmiss_g = pref_inst_g & lsu_inst_vld_w & ~tlb_cam_hit_g ;
wire	[3:0] pref_tlbmiss_cmplt,pref_tlbmiss_cmplt_d1,pref_tlbmiss_cmplt_d2 ;
assign	pref_tlbmiss_cmplt[0] = pref_tlbmiss_g & thread0_g ;
assign	pref_tlbmiss_cmplt[1] = pref_tlbmiss_g & thread1_g ;
assign	pref_tlbmiss_cmplt[2] = pref_tlbmiss_g & thread2_g ;
assign	pref_tlbmiss_cmplt[3] = pref_tlbmiss_g & thread3_g ;

dff_s  #(4) pfcmpl_stgd1 (
        .din    (pref_tlbmiss_cmplt[3:0]),
        .q      (pref_tlbmiss_cmplt_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  #(4) pfcmpl_stgd2 (
        .din    (pref_tlbmiss_cmplt_d1[3:0]),
        .q      (pref_tlbmiss_cmplt_d2[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// *** add diagnstc rd and prefetch(tlb-miss) signals. ***
// *** add ifu asi ack.

// This equation is critical and needs to be optimized.
wire [3:0] 	lsu_pcx_pref_issue;
wire	diag_wr_cmplt0,diag_wr_cmplt1,diag_wr_cmplt2,diag_wr_cmplt3;
wire	ldst_cmplt_late_0, ldst_cmplt_late_1 ;
wire	ldst_cmplt_late_2, ldst_cmplt_late_3 ;
wire	ldst_cmplt_late_0_d1, ldst_cmplt_late_1_d1 ;
wire	ldst_cmplt_late_2_d1, ldst_cmplt_late_3_d1 ;

   assign ignore_fill = lmq_ldd_vld & ~ldd_in_dfq_out;
   
assign  lsu_ifu_ldst_cmplt[0] = 
    // * can be early or
    ((stxa_internal_d2 & thread0_w3) | stxa_stall_wr_cmplt0_d1) | 
    // * late signal and critical.
    // Can this be snapped earlier ?
    //(((l2fill_vld_e & ~atomic_ld_squash_e & ~ignore_fill)) //Bug 3624
    (((l2fill_vld_e & ~ignore_fill))  // 1st fill for ldd.
      & ~l2fill_fpld_e & ~lsu_cpx_pkt_atm_st_cmplt & 
	~(lsu_cpx_pkt_ld_err[1] & lsu_nceen_d1[0]) & dfill_thread0)  |
    intld_byp_cmplt[0] |
    // * early-or signals
    ldst_cmplt_late_0_d1 ;

wire	atm_st_cmplt0 ;
assign	atm_st_cmplt0 = lsu_atm_st_cmplt_e & dfill_thread0 ;
assign	ldst_cmplt_late_0 = 
    (atm_st_cmplt0 & ~pend_atm_ld_ue[0]) |  // Bug 3624,4048
    bsync0_reset    |
    lsu_intrpt_cmplt[0]   |
    diag_wr_cmplt0 |
//    dc0_diagnstc_rd_w2 |
    ldxa_illgl_va_cmplt_d1[0] |
    pref_tlbmiss_cmplt_d2[0] |
    lsu_pcx_pref_issue[0];


assign  lsu_ifu_ldst_cmplt[1] = 
    ((stxa_internal_d2 & thread1_w3) | stxa_stall_wr_cmplt1_d1) | 
    (((l2fill_vld_e & ~ignore_fill)) // // 1st fill for ldd
      & ~l2fill_fpld_e & ~lsu_cpx_pkt_atm_st_cmplt & 
	~(lsu_cpx_pkt_ld_err[1] & lsu_nceen_d1[1]) & dfill_thread1)  |
    intld_byp_cmplt[1] |
    ldst_cmplt_late_1_d1 ;

wire	atm_st_cmplt1 ;
assign	atm_st_cmplt1 = lsu_atm_st_cmplt_e & dfill_thread1 ;
assign	ldst_cmplt_late_1 = 
    (atm_st_cmplt1 & ~pend_atm_ld_ue[1]) |  // Bug 3624,4048
    bsync1_reset    |
    lsu_intrpt_cmplt[1]   |
    diag_wr_cmplt1 |
//    dc1_diagnstc_rd_w2 |
    ldxa_illgl_va_cmplt_d1[1] |
    pref_tlbmiss_cmplt_d2[1] |
    lsu_pcx_pref_issue[1];

assign  lsu_ifu_ldst_cmplt[2] = 
    ((stxa_internal_d2 & thread2_w3) | stxa_stall_wr_cmplt2_d1) | 
    (((l2fill_vld_e & ~ignore_fill)) // 1st fill for ldd.
      & ~l2fill_fpld_e & ~lsu_cpx_pkt_atm_st_cmplt & 
	~(lsu_cpx_pkt_ld_err[1] & lsu_nceen_d1[2]) & dfill_thread2)  |
    intld_byp_cmplt[2] |
    ldst_cmplt_late_2_d1 ;

wire	atm_st_cmplt2 ;
assign	atm_st_cmplt2 = lsu_atm_st_cmplt_e & dfill_thread2 ;
assign	ldst_cmplt_late_2 = 
    (atm_st_cmplt2 & ~pend_atm_ld_ue[2]) |  // Bug 3624,4048
    bsync2_reset    |
    lsu_intrpt_cmplt[2]   |
    diag_wr_cmplt2 |
//    dc2_diagnstc_rd_w2 |
    ldxa_illgl_va_cmplt_d1[2] |
    pref_tlbmiss_cmplt_d2[2] |
    lsu_pcx_pref_issue[2];

assign  lsu_ifu_ldst_cmplt[3] = 
    ((stxa_internal_d2 & thread3_w3) | stxa_stall_wr_cmplt3_d1) | 
    //(((l2fill_vld_e & atomic_st_cmplt) | 
    (((l2fill_vld_e & ~ignore_fill)) // 1st fill for ldd.
      & ~l2fill_fpld_e & ~lsu_cpx_pkt_atm_st_cmplt & 
	~(lsu_cpx_pkt_ld_err[1] & lsu_nceen_d1[3]) & dfill_thread3)  |
    intld_byp_cmplt[3] |
    ldst_cmplt_late_3_d1 ;

wire	atm_st_cmplt3 ;
assign	atm_st_cmplt3 = lsu_atm_st_cmplt_e & dfill_thread3 ;
assign	ldst_cmplt_late_3 = 
    (atm_st_cmplt3 & ~pend_atm_ld_ue[3]) |  // Bug 3624,4048
    bsync3_reset    |
    lsu_intrpt_cmplt[3]   |
    diag_wr_cmplt3 |
//    dc3_diagnstc_rd_w2 |
    ldxa_illgl_va_cmplt_d1[3] |
    pref_tlbmiss_cmplt_d2[3] |
    lsu_pcx_pref_issue[3];

dff_s #(4) ldstcmplt_d1 (
        .din    ({ldst_cmplt_late_3,ldst_cmplt_late_2,ldst_cmplt_late_1,ldst_cmplt_late_0}),
        .q      ({ldst_cmplt_late_3_d1,ldst_cmplt_late_2_d1,
		ldst_cmplt_late_1_d1,ldst_cmplt_late_0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//=========================================================================================
//  LD/ST MISS SIGNAL - IFU
//=========================================================================================

// Switchout of internal asi ld
// Do not switchout for tag-target,
assign  ldxa_swo_annul = 
	(lsu_dctl_asi_state_m[7:4] == 4'h3)   | 	// ldxa to 0x3X does not swo
	(((lsu_dctl_asi_state_m[7:0] == 8'h58) &   	// tag-target,tag-access,sfsr,sfar
		~((lsu_ldst_va_b7_b0_m[7:0] == 8'h38) | (lsu_ldst_va_b7_b0_m[7:0] == 8'h80))) | // wtcpt/pid
	 (lsu_dctl_asi_state_m[7:0] == 8'h50)) |
	mmu_rd_only_asi_m ;

wire	ldxa_internal_swo_m,ldxa_internal_swo_g ;
assign	ldxa_internal_swo_m = lda_internal_m & ~ldxa_swo_annul ;

// This represents *all* ld asi.
wire	asi_internal_ld_m,asi_internal_ld_g ;
assign	asi_internal_ld_m =
	asi_internal_m & ld_inst_vld_m & lsu_alt_space_m ;

dff_s #(2) ldaswo_stgg (
        .din    ({ldxa_internal_swo_m,asi_internal_ld_m}),
        .q      ({ldxa_internal_swo_g,asi_internal_ld_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
		   
wire	common_ldst_miss_w ;
assign	common_ldst_miss_w =
(~(cache_hit & (tlb_cam_hit_g | lsu_dtlb_bypass_g)) |	// include miss in tlb;bypass
   ~dcache_enable_g 	| 	// 
    //endian_mispred_g    |	// endian mispredict
    ldd_force_l2access_g 		| 	// ifu to incorporate directly
    ncache_asild_rq_g   ) &	// bypass asi
 	~asi_internal_ld_g ;

assign	lsu_ifu_ldst_miss_w =
  (common_ldst_miss_w  |         // common between ifu and exu.
    // MMU_ASI : ifu must switch out early only for stores.
    ldxa_internal_swo_g)
//  ldxa_internal	|	// ifu incorporates directly
//  atomic_g 		| 	// ifu incorporates directly
//  ld_stb_hit_g 	| 	// late 
//    stb_cam_hit)		// ** rm once ifu uses late signal. ** 
//  dcache_rd_parity_error | 	// late
//  dtag_perror_g) & 	|	// late
    & (lsu_inst_vld_w & ld_inst_vld_unflushed) ;	// flush uptil m accounted for.
//  & ld_inst_vld_g ;		// assume flush=1 clears ldst_miss=1
//  ~tte_data_perror_unc & 	// in flush 
//  (ld_inst_vld_g & (~lsu_alt_space_g | (lsu_alt_space_g & recognized_asi_g))) |
//  ncache_asild_rq_g ;   // asi ld requires bypass


   //timing fix
   wire lsu_ifu_dc_parity_error_w;
   assign lsu_ifu_dc_parity_error_w = 
	( 
	lsu_dcache_data_perror_g | // bug 4267
	lsu_dcache_tag_perror_g  |  
  endian_mispred_g         |	// endian mispredict ; mv'ed from ldst_miss
	tte_data_perror_unc_en) ;
   
/*
   wire   lsu_ld_inst_vld_flush_w, lsu_ld_inst_vld_flush_w2;
   assign lsu_ld_inst_vld_flush_w = lsu_inst_vld_w & ld_inst_vld_unflushed & ~dctl_flush_pipe_w ;

   
dff_s #(1) lsu_ld_inst_vld_flush_stgw2 (
        .din    (lsu_ld_inst_vld_flush_w),
        .q      (lsu_ld_inst_vld_flush_w2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
*/
   
   wire   lsu_ifu_dc_parity_error_w2_q;
  
dff_s #(1) lsu_ifu_dc_parity_error_stgw2 (
        .din    (lsu_ifu_dc_parity_error_w),
        .q      (lsu_ifu_dc_parity_error_w2_q),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   assign lsu_ifu_dc_parity_error_w2 = (lsu_ifu_dc_parity_error_w2_q | stb_cam_hit_w2) & ld_inst_vld_w2;
   
//=========================================================================================
//  LD/ST MISS SIGNAL - EXU
//=========================================================================================

// for a diagnstc access to the cache, the if it misses in the cache, then 
// ldst_miss is asserted, preventing a write into the cache, but code is
// allowed to continue executing.
wire	exu_ldst_miss_g_no_stb_cam_hit ;
assign  exu_ldst_miss_g_no_stb_cam_hit =  
  (common_ldst_miss_w 	  |
   ldxa_internal_swo_g	  |
   endian_mispred_g    	  |	
   atomic_g 		  |
   lsu_dcache_data_perror_g 	|
   lsu_dcache_tag_perror_g 	|  
   tte_data_perror_unc_en    	|
   pref_inst_g) & ld_inst_vld_unflushed & lsu_inst_vld_w ; // flush qual done in exu


   wire ld_inst_vld_no_flush_w, ld_inst_vld_no_flush_w2;
   assign ld_inst_vld_no_flush_w = ld_inst_vld_unflushed & lsu_inst_vld_w;
   
dff_s #(1) ld_inst_vld_no_flush_stgw2 (
        .din    (ld_inst_vld_no_flush_w),
        .q      (ld_inst_vld_no_flush_w2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
   wire lsu_exu_ldst_miss_w2_tmp;
 
dff_s #(1) exuldstmiss_stgw2 (
        .din    (exu_ldst_miss_g_no_stb_cam_hit),
        .q      (lsu_exu_ldst_miss_w2_tmp),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   assign lsu_exu_ldst_miss_w2 =  (lsu_exu_ldst_miss_w2_tmp | stb_cam_hit_w2) & ld_inst_vld_no_flush_w2;
   
                                   
wire	lsu_ldst_miss_w2;
assign	lsu_ldst_miss_w2 = lsu_exu_ldst_miss_w2 ;

//=========================================================================================
//  RMO Store control data
//=========================================================================================

assign	lsu_st_rmo_m = (st_inst_vld_m & (binit_quad_asi_m | blk_asi_m) & lsu_alt_space_m) | blkst_m ;
assign	lsu_bst_in_pipe_m = (st_inst_vld_m &  blk_asi_m & lsu_alt_space_m) ;

//=========================================================================================
//  ASI BUS 
//=========================================================================================

// *** This logic is now used by all long-latency asi operations on chip. ***

// Start with SDATA Reg for Streaming
wire	strm_asi, strm_asi_m ;
assign	strm_asi_m = (lsu_dctl_asi_state_m[7:0]==8'h40) ;

dff_s  strm_stgg (
        .din    (strm_asi_m),
        .q      (strm_asi),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  stxa_stall_asi_g = 
  strm_asi & ((ldst_va_g[7:0] == 8'h80)) ;  	// ma ctl
  /*strm_asi & (	(ldst_va_g[7:0] == 8'h18) |  	// streaming stxa to sdata
  		(ldst_va_g[7:0] == 8'h00) |  	// stream ctl
  		(ldst_va_g[7:0] == 8'h08) ) ;  	// ma ctl */

wire    dtlb_wr_cmplt0, dtlb_wr_cmplt1;
wire    dtlb_wr_cmplt2, dtlb_wr_cmplt3;
assign  dtlb_wr_cmplt0 = demap_thread0 & lsu_dtlb_wr_vld_e ;
assign  dtlb_wr_cmplt1 = demap_thread1 & lsu_dtlb_wr_vld_e ;
assign  dtlb_wr_cmplt2 = demap_thread2 & lsu_dtlb_wr_vld_e ;
assign  dtlb_wr_cmplt3 = demap_thread3 & lsu_dtlb_wr_vld_e ;

dff_s  dtlbw_stgd1 (
        .din    (lsu_dtlb_wr_vld_e),
        .q      (dtlb_wr_init_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  dtlbw_stgd2 (
        .din    (dtlb_wr_init_d1),
        .q      (dtlb_wr_init_d2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  dtlbw_stgd3 (
        .din    (dtlb_wr_init_d2),
        .q      (dtlb_wr_init_d3),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire    dtlb_wr_init_d4 ;
dff_s  dtlbw_stgd4 (
        .din    (dtlb_wr_init_d3),
        .q      (dtlb_wr_init_d4),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );



wire	tlb_access_sel_thrd3_d1,tlb_access_sel_thrd2_d1;
wire	tlb_access_sel_thrd1_d1,tlb_access_sel_thrd0_d1 ;
wire	ifu_asi_store_cmplt_en, ifu_asi_store_cmplt_en_d1 ;
assign  stxa_stall_wr_cmplt0 =  (spu_lsu_stxa_ack & spu_stxa_thread0) |
        (tlu_stxa_thread0_w2 & tlu_lsu_stxa_ack & ~dtlb_wr_init_d4) |
	(ifu_asi_store_cmplt_en_d1 & tlb_access_sel_thrd0_d1) |
	dtlb_wr_cmplt0 ;
assign  stxa_stall_wr_cmplt1 =  (spu_lsu_stxa_ack & spu_stxa_thread1) |
        (tlu_stxa_thread1_w2 & tlu_lsu_stxa_ack & ~dtlb_wr_init_d4) |
	(ifu_asi_store_cmplt_en_d1 & tlb_access_sel_thrd1_d1) |
	dtlb_wr_cmplt1 ;
assign  stxa_stall_wr_cmplt2 =  (spu_lsu_stxa_ack & spu_stxa_thread2) |
        (tlu_stxa_thread2_w2 & tlu_lsu_stxa_ack & ~dtlb_wr_init_d4) |
	(ifu_asi_store_cmplt_en_d1 & tlb_access_sel_thrd2_d1) |
	dtlb_wr_cmplt2 ;
assign  stxa_stall_wr_cmplt3 =  (spu_lsu_stxa_ack & spu_stxa_thread3) |
        (tlu_stxa_thread3_w2 & tlu_lsu_stxa_ack & ~dtlb_wr_init_d4) |
	(ifu_asi_store_cmplt_en_d1 & tlb_access_sel_thrd3_d1) |
	dtlb_wr_cmplt3 ;

dff_s  #(4) stxastall_stgd1 (
        .din    ({stxa_stall_wr_cmplt3,stxa_stall_wr_cmplt2,
		stxa_stall_wr_cmplt1,stxa_stall_wr_cmplt0}),
        .q    	({stxa_stall_wr_cmplt3_d1,stxa_stall_wr_cmplt2_d1,
		stxa_stall_wr_cmplt1_d1,stxa_stall_wr_cmplt0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


// enable speculates on inst not being flushed
// Only dside diagnostic writes will be logged for long-latency action. dside diagnostic
// reads are aligned to pipe.
wire wr_dc_diag_asi_e, wr_dtagv_diag_asi_e ;

assign	wr_dc_diag_asi_e = dc_diagnstc_asi_e & st_inst_vld_e ;
assign	wr_dtagv_diag_asi_e =  dtagv_diagnstc_asi_e & st_inst_vld_e ;

assign  tlb_access_en0_e = 
  (tlb_lng_ltncy_asi_e | wr_dc_diag_asi_e | wr_dtagv_diag_asi_e | ifu_nontlb_asi_e)  
    & thread0_e & alt_space_e ;
assign  tlb_access_en1_e = 
  (tlb_lng_ltncy_asi_e | wr_dc_diag_asi_e | wr_dtagv_diag_asi_e | ifu_nontlb_asi_e)  
    & thread1_e & alt_space_e ;
assign  tlb_access_en2_e = 
  (tlb_lng_ltncy_asi_e | wr_dc_diag_asi_e | wr_dtagv_diag_asi_e | ifu_nontlb_asi_e)  
    & thread2_e & alt_space_e ;
assign  tlb_access_en3_e = 
  (tlb_lng_ltncy_asi_e | wr_dc_diag_asi_e | wr_dtagv_diag_asi_e | ifu_nontlb_asi_e)  
    & thread3_e & alt_space_e ;

dff_s  #(4) tlbac_stgm (
        .din    ({tlb_access_en0_e,tlb_access_en1_e,tlb_access_en2_e,tlb_access_en3_e}),
        .q      ({tlb_access_en0_tmp,tlb_access_en1_tmp,tlb_access_en2_tmp,tlb_access_en3_tmp}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	ldst_vld_m = ld_inst_vld_m | st_inst_vld_m ;
assign	tlb_access_en0_m = tlb_access_en0_tmp & ldst_vld_m ;
assign	tlb_access_en1_m = tlb_access_en1_tmp & ldst_vld_m ;
assign	tlb_access_en2_m = tlb_access_en2_tmp & ldst_vld_m ;
assign	tlb_access_en3_m = tlb_access_en3_tmp & ldst_vld_m ;

dff_s  #(4) tlbac_stgw (
        .din    ({tlb_access_en0_m,tlb_access_en1_m,tlb_access_en2_m,tlb_access_en3_m}),
        .q      ({tlb_access_en0_unflushed,tlb_access_en1_unflushed,tlb_access_en2_unflushed,tlb_access_en3_unflushed}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Flush ld/st with as=42 belonging to lsu. bistctl and ldiag

assign  tlb_access_en0_g = tlb_access_en0_unflushed & lsu_inst_vld_w & ~(dctl_early_flush_w | ifu_asi42_flush_g) ;
//assign  tlb_access_en0_g = tlb_access_en0_unflushed & lsu_inst_vld_w & ~(dctl_flush_pipe_w | ifu_asi42_flush_g) ;
assign  tlb_access_en1_g = tlb_access_en1_unflushed & lsu_inst_vld_w & ~(dctl_early_flush_w | ifu_asi42_flush_g) ;
assign  tlb_access_en2_g = tlb_access_en2_unflushed & lsu_inst_vld_w & ~(dctl_early_flush_w | ifu_asi42_flush_g) ;
assign  tlb_access_en3_g = tlb_access_en3_unflushed & lsu_inst_vld_w & ~(dctl_early_flush_w | ifu_asi42_flush_g) ;

assign	diag_wr_cmplt0 = lsu_diagnstc_wr_src_sel_e & tlb_access_sel_thrd0_d1 ;
assign	diag_wr_cmplt1 = lsu_diagnstc_wr_src_sel_e & tlb_access_sel_thrd1_d1 ;
assign	diag_wr_cmplt2 = lsu_diagnstc_wr_src_sel_e & tlb_access_sel_thrd2_d1 ;
assign	diag_wr_cmplt3 = lsu_diagnstc_wr_src_sel_e & tlb_access_sel_thrd3_d1 ;

wire	ifu_tlb_rd_cmplt0,ifu_tlb_rd_cmplt1,ifu_tlb_rd_cmplt2,ifu_tlb_rd_cmplt3 ;
wire	st_sqsh_m, ifu_asi_ack_d1 ;
assign	ifu_tlb_rd_cmplt0 =  (ifu_ldxa_thread0_w2 & ifu_lsu_ldxa_data_vld_w2 & ~ifu_nontlb0_asi) ;
assign	ifu_tlb_rd_cmplt1 =  (ifu_ldxa_thread1_w2 & ifu_lsu_ldxa_data_vld_w2 & ~ifu_nontlb1_asi) ;
assign	ifu_tlb_rd_cmplt2 =  (ifu_ldxa_thread2_w2 & ifu_lsu_ldxa_data_vld_w2 & ~ifu_nontlb2_asi) ;
assign	ifu_tlb_rd_cmplt3 =  (ifu_ldxa_thread3_w2 & ifu_lsu_ldxa_data_vld_w2 & ~ifu_nontlb3_asi) ;
  
// stxa ack will share tid with ldxa
// This should be qualified with inst_vld_w also !!!
// ldxa_data_vld needs to be removed once full interface in !!!
assign  tlb_access_rst0 =  reset | 
  (tlu_ldxa_thread0_w2 & tlu_lsu_ldxa_async_data_vld) | 
  (tlu_stxa_thread0_w2 & tlu_lsu_stxa_ack) | 
  (ifu_tlb_rd_cmplt0) | 
  (ifu_stxa_thread0_w2 & ifu_lsu_asi_ack) |
  diag_wr_cmplt0 ;
assign  tlb_access_rst1 =  reset | 
  (tlu_ldxa_thread1_w2 & tlu_lsu_ldxa_async_data_vld) |
  (tlu_stxa_thread1_w2 & tlu_lsu_stxa_ack) |
  (ifu_tlb_rd_cmplt1) | 
  (ifu_stxa_thread1_w2 & ifu_lsu_asi_ack) |
  diag_wr_cmplt1 ;
assign  tlb_access_rst2 =  reset | 
  (tlu_ldxa_thread2_w2 & tlu_lsu_ldxa_async_data_vld) |
  (tlu_stxa_thread2_w2 & tlu_lsu_stxa_ack) |
  (ifu_tlb_rd_cmplt2) | 
  (ifu_stxa_thread2_w2 & ifu_lsu_asi_ack) |
  diag_wr_cmplt2 ;
assign  tlb_access_rst3 =  reset | 
  (tlu_ldxa_thread3_w2 & tlu_lsu_ldxa_async_data_vld) |
  (tlu_stxa_thread3_w2 & tlu_lsu_stxa_ack) |
  (ifu_tlb_rd_cmplt3) | 
  (ifu_stxa_thread3_w2 & ifu_lsu_asi_ack) |
  diag_wr_cmplt3 ;


// tlb_ld_inst* and tlb_st_inst* are generically used to indicate a read or write. 
// Thread 0
   
dffre_s #(2)  asiv_thrd0 (
        .din    ({ld_inst_vld_g,st_inst_vld_g}),
        .q      ({tlb_ld_inst0,tlb_st_inst0}),
        .rst    (tlb_access_rst0),        .en     (tlb_access_en0_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dffe_s #(3)  asiv_thrd0_sec (
        .din    ({dc_diagnstc_asi_g,dtagv_diagnstc_asi_g,ifu_nontlb_asi_g}),
        .q      ({dc0_diagnstc_asi,dtagv0_diagnstc_asi,ifu_nontlb0_asi}),
        .en     (tlb_access_en0_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  nontlb_asi0 = dc0_diagnstc_asi | dtagv0_diagnstc_asi | ifu_nontlb0_asi ;

// Thread 1

dffre_s #(2)  asiv_thrd1 (
        .din    ({ld_inst_vld_g,st_inst_vld_g}),
        .q      ({tlb_ld_inst1,tlb_st_inst1}),
        .rst    (tlb_access_rst1),        .en     (tlb_access_en1_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dffe_s #(3)  asiv_thrd1_sec (
        .din    ({dc_diagnstc_asi_g,dtagv_diagnstc_asi_g,ifu_nontlb_asi_g}),
        .q      ({dc1_diagnstc_asi,dtagv1_diagnstc_asi,ifu_nontlb1_asi}),
        .en     (tlb_access_en1_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  nontlb_asi1 = dc1_diagnstc_asi | dtagv1_diagnstc_asi | ifu_nontlb1_asi ;

// Thread 2

dffre_s #(2)  asiv_thrd2 (
        .din    ({ld_inst_vld_g,st_inst_vld_g}),
        .q      ({tlb_ld_inst2,tlb_st_inst2}),
        .rst    (tlb_access_rst2),        .en     (tlb_access_en2_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dffe_s #(3)  asiv_thrd2_sec (
        .din    ({dc_diagnstc_asi_g,dtagv_diagnstc_asi_g,ifu_nontlb_asi_g}),
        .q      ({dc2_diagnstc_asi,dtagv2_diagnstc_asi,ifu_nontlb2_asi}),
        .en     (tlb_access_en2_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  nontlb_asi2 = dc2_diagnstc_asi | dtagv2_diagnstc_asi | ifu_nontlb2_asi ;

// Thread 3

dffre_s #(2)  asiv_thrd3 (
        .din    ({ld_inst_vld_g,st_inst_vld_g}),
        .q      ({tlb_ld_inst3,tlb_st_inst3}),
        .rst    (tlb_access_rst3),        .en     (tlb_access_en3_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dffe_s #(3)  asiv_thrd3_sec (
        .din    ({dc_diagnstc_asi_g,dtagv_diagnstc_asi_g,ifu_nontlb_asi_g}),
        .q      ({dc3_diagnstc_asi,dtagv3_diagnstc_asi,ifu_nontlb3_asi}),
        .en     (tlb_access_en3_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  nontlb_asi3 = dc3_diagnstc_asi | dtagv3_diagnstc_asi | ifu_nontlb3_asi ;

//---
//  Prioritization of threaded events from asi queue.
//  - It is not expected that a significant bias will exist in selecting
//  1 of 4 possible events from the asi queue because of the low frequency
//  of such events. However, to bulletproof we will prioritize the events
//  in a fifo manner.
//---

// Control :

wire	[3:0]	fifo_top ;
wire	asi_fifo0_vld,asi_fifo1_vld,asi_fifo2_vld,asi_fifo3_vld;

assign	fifo_top[0] = ~asi_fifo0_vld ; 
assign	fifo_top[1] = ~asi_fifo1_vld & asi_fifo0_vld ; 
assign	fifo_top[2] = ~asi_fifo2_vld & asi_fifo1_vld & asi_fifo0_vld ; 
assign	fifo_top[3] = ~asi_fifo3_vld & asi_fifo2_vld & asi_fifo1_vld & asi_fifo0_vld ; 

// Check for timing on flush.
// Do not confuse thread# with fifo entry#.
wire	fifo_wr, fifo_shift ;
assign	fifo_wr = 
tlb_access_en0_g | tlb_access_en1_g | tlb_access_en2_g | tlb_access_en3_g ;
assign	fifo_shift =
tlb_access_rst0 | tlb_access_rst1 | tlb_access_rst2 | tlb_access_rst3 ;

wire	[3:0]	fifo_top_wr ;
assign	fifo_top_wr[0] = fifo_top[0] & fifo_wr ;
assign	fifo_top_wr[1] = fifo_top[1] & fifo_wr ;
assign	fifo_top_wr[2] = fifo_top[2] & fifo_wr ;
assign	fifo_top_wr[3] = fifo_top[3] & fifo_wr ;

// Matrix for Data Selection.
// shift | wr | din for entry
// 0	   0	na
// 0	   1	thrid_g
// 1	   0	q
// 1	   1	q if top is not 1 above
// 1	   1	thrid_g if top is 1 above

// shift writeable entry into correct position, if exists.
wire	asi_fifo0_sel,asi_fifo1_sel,asi_fifo2_sel ;
assign	asi_fifo0_sel = fifo_shift ? fifo_top_wr[1] : fifo_top_wr[0] ;
assign	asi_fifo1_sel = fifo_shift ? fifo_top_wr[2] : fifo_top_wr[1] ;
assign	asi_fifo2_sel = fifo_shift ? fifo_top_wr[3] : fifo_top_wr[2] ;

wire	[1:0]	asi_fifo3_din,asi_fifo2_din,asi_fifo1_din,asi_fifo0_din ;
wire	[1:0] 	asi_fifo3_q,asi_fifo2_q,asi_fifo1_q,asi_fifo0_q ;
assign	asi_fifo0_din[1:0] = asi_fifo0_sel ? thrid_g[1:0] : asi_fifo1_q[1:0] ;
assign	asi_fifo1_din[1:0] = asi_fifo1_sel ? thrid_g[1:0] : asi_fifo2_q[1:0] ;
assign	asi_fifo2_din[1:0] = asi_fifo2_sel ? thrid_g[1:0] : asi_fifo3_q[1:0] ;
assign	asi_fifo3_din[1:0] = thrid_g[1:0] ; // can never shift into.

// Matrix for Enable 
// shift | wr | Entry Written ?
// 0	   0	0
// 0	   1	if top
// 1	   0	if entry+1 is vld
// 1	   1	if entry itself is vld => as is.

wire	wr_not_sh,sh_not_wr,wr_and_sh ;
assign	wr_not_sh =  fifo_wr & ~fifo_shift ; // write not shift
assign	sh_not_wr = ~fifo_wr &  fifo_shift ; // shift not write
assign	wr_and_sh =  fifo_wr &  fifo_shift ; // shift and write

wire	asi_fifo0_vin,asi_fifo1_vin,asi_fifo2_vin,asi_fifo3_vin ;
assign	asi_fifo0_vin =  
	(wr_not_sh & fifo_top[0]) |
	(sh_not_wr & asi_fifo1_vld) |
	(wr_and_sh & asi_fifo0_vld) ;
assign	asi_fifo1_vin =  
	(wr_not_sh & fifo_top[1]) |
	(sh_not_wr & asi_fifo2_vld) |
	(wr_and_sh & asi_fifo1_vld) ;
assign	asi_fifo2_vin =  
	(wr_not_sh & fifo_top[2]) |
	(sh_not_wr & asi_fifo3_vld) |
	(wr_and_sh & asi_fifo2_vld) ;
assign	asi_fifo3_vin =  
	(wr_not_sh & fifo_top[3]) |
	(wr_and_sh & asi_fifo3_vld) ;

wire	asi_fifo0_en,asi_fifo1_en,asi_fifo2_en,asi_fifo3_en ;
assign	asi_fifo0_en = (fifo_wr & fifo_top[0]) | fifo_shift ; 
assign	asi_fifo1_en = (fifo_wr & fifo_top[1]) | fifo_shift ; 
assign	asi_fifo2_en = (fifo_wr & fifo_top[2]) | fifo_shift ; 
assign	asi_fifo3_en = (fifo_wr & fifo_top[3]) | fifo_shift ; 

wire	asi_fifo3_rst,asi_fifo2_rst,asi_fifo1_rst,asi_fifo0_rst ;
assign	asi_fifo0_rst = reset ;
assign	asi_fifo1_rst = reset ;
assign	asi_fifo2_rst = reset ;
assign	asi_fifo3_rst = reset ;

// Datapath :
// fifo entry 0 is earliest. fifo entry 3 is latest.
dffe_s #(2)  asiq_fifo_0 (
        .din    (asi_fifo0_din[1:0]),
        .q      (asi_fifo0_q[1:0]),
        .en     (asi_fifo0_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffre_s   asiqv_fifo_0 (
        .din    (asi_fifo0_vin),
        .q      (asi_fifo0_vld),
        .en     (asi_fifo0_en),	.rst (asi_fifo0_rst),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

wire	asi_sel_thrd3,asi_sel_thrd2,asi_sel_thrd1,asi_sel_thrd0;
assign	asi_sel_thrd0 = ~asi_fifo0_q[1] & ~asi_fifo0_q[0] & (tlb_ld_inst0 | tlb_st_inst0) ;
assign	asi_sel_thrd1 = ~asi_fifo0_q[1] &  asi_fifo0_q[0] & (tlb_ld_inst1 | tlb_st_inst1) ;
assign	asi_sel_thrd2 =  asi_fifo0_q[1] & ~asi_fifo0_q[0] & (tlb_ld_inst2 | tlb_st_inst2) ;
assign	asi_sel_thrd3 =  asi_fifo0_q[1] &  asi_fifo0_q[0] & (tlb_ld_inst3 | tlb_st_inst3) ;

dffe_s #(2)  asiq_fifo_1 (
        .din    (asi_fifo1_din[1:0]),
        .q      (asi_fifo1_q[1:0]),
        .en     (asi_fifo1_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffre_s  asiqv_fifo_1 (
        .din    (asi_fifo1_vin),
        .q      (asi_fifo1_vld),
        .en     (asi_fifo1_en),	.rst	(asi_fifo1_rst),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffe_s #(2)  asiq_fifo_2 (
        .din    (asi_fifo2_din[1:0]),
        .q      (asi_fifo2_q[1:0]),
        .en     (asi_fifo2_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffre_s   asiqv_fifo_2 (
        .din    (asi_fifo2_vin),
        .q      (asi_fifo2_vld),
        .en     (asi_fifo2_en),	.rst	(asi_fifo2_rst),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffe_s #(2)  asiq_fifo_3 (
        .din    (asi_fifo3_din[1:0]),
        .q      (asi_fifo3_q[1:0]),
        .en     (asi_fifo3_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffre_s  asiqv_fifo_3 (
        .din    (asi_fifo3_vin),
        .q      (asi_fifo3_vld),
        .en     (asi_fifo3_en),	.rst	(asi_fifo3_rst),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

//---

assign  tlb_access_initiated =
  ((tlb_access_sel_thrd0 & ~tlb_access_rst0) |
   (tlb_access_sel_thrd1 & ~tlb_access_rst1) |
   (tlb_access_sel_thrd2 & ~tlb_access_rst2) |
   (tlb_access_sel_thrd3 & ~tlb_access_rst3)) & ~tlb_access_pending ;
   

wire  tlb_blocking_rst ;
assign  tlb_blocking_rst = reset |
  tlu_lsu_stxa_ack | tlu_lsu_ldxa_async_data_vld |
  ifu_tlb_rd_cmplt0 | ifu_tlb_rd_cmplt1 | 
  ifu_tlb_rd_cmplt2 | ifu_tlb_rd_cmplt3 | 
  ifu_lsu_asi_ack |
  lsu_diagnstc_wr_src_sel_e;


// MMU/IFU/DIAG Action is pending
dffre_s #(1)  tlbpnd (
        .din    (tlb_access_initiated),
        .q      (tlb_access_pending),
        .rst    (tlb_blocking_rst),        .en     (tlb_access_initiated),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

/*wire	asi_pend0,asi_pend1,asi_pend2,asi_pend3 ;
dffre_s #(4)  asithrdpnd (
      	.din	({tlb_access_sel_thrd3,tlb_access_sel_thrd2,
		            tlb_access_sel_thrd1,tlb_access_sel_thrd0}),
        .q    ({asi_pend3,asi_pend2,asi_pend1,asi_pend0}),
        .rst	(tlb_blocking_rst), 	.en     (tlb_access_initiated),
        .clk  (clk),
        .se   (se),       .si (),          .so ()
        );

wire	asi_pend_non_thrd0 ;
assign	asi_pend_non_thrd0 = asi_pend1 | asi_pend2 | asi_pend3 ;
wire	asi_pend_non_thrd1 ;
assign	asi_pend_non_thrd1 = asi_pend0 | asi_pend2 | asi_pend3 ;
wire	asi_pend_non_thrd2 ;
assign	asi_pend_non_thrd2 = asi_pend0 | asi_pend1 | asi_pend3 ;
wire	asi_pend_non_thrd3 ;
assign	asi_pend_non_thrd3 = asi_pend0 | asi_pend1 | asi_pend2 ; */

// Would like to remove st_inst_vld_m. This is however required to
// source rs3 data to tlu/mmu. Send rs3_data directly !!!

wire	diag_wr_src, diag_wr_src_d1, diag_wr_src_d2 ;
   
assign  tlb_access_blocked = 
  (tlb_access_pending & ~ifu_asi_vld_d1 & ~diag_wr_src_d1) |
  (st_sqsh_m & ~(ifu_asi_vld_d1 & ~ifu_asi_ack_d1) & ~diag_wr_src_d1) ; // Bug 4875
  //(st_inst_vld_m & ~lsu_ifu_asi_vld_d1 & ~diag_wr_src_d1) ;

// fixed priority. tlb accesses are issued speculatively in the m-stage and are
// Change priority to round-robin !!!
// flushed in the g-stage in the tlu if necessary.
// diagnstc writes will block for cache/tag access.
// This means that access can be blocked if a st is 
// in the m-stage or a memref in the d stage. (!!!)
// In this case, it is better to stage a different
// bus for rs3 data.

// Note : Selection Process.
// 1. Priority Encoded selection if no access pending.
// This may have to be changed to prevent bias towards a
// single thread.
// 2. Once thread is selected :
//	a. generate single pulse - mmu. tlb_access_blocked
//	used for this purpose.
//	b. generate window - ifu/diag. To prevent spurious change
// 	in selects, asi_pend_non_thrdx and tlb_access_pending
//	qual. is required.


assign  tlb_access_sel_thrd0 = ~rst_tri_en &  
  asi_sel_thrd0 & ~tlb_access_blocked ;
assign  tlb_access_sel_thrd1 = ~rst_tri_en & 
  asi_sel_thrd1 & ~tlb_access_blocked ;
assign  tlb_access_sel_thrd2 = ~rst_tri_en &  
  asi_sel_thrd2 & ~tlb_access_blocked ;
assign  tlb_access_sel_thrd3 = ~rst_tri_en &  
  asi_sel_thrd3 & ~tlb_access_blocked ;

//assign  tlb_access_sel_thrd0 = ~rst_tri_en & ( 
//  (tlb_ld_inst0 | tlb_st_inst0) & ~tlb_access_blocked & 
//  ~asi_pend_non_thrd0 );
//assign  tlb_access_sel_thrd1 = ~rst_tri_en & (
//  (tlb_ld_inst1 | tlb_st_inst1) & 
//  ~(((tlb_ld_inst0 | tlb_st_inst0) & ~tlb_access_pending) | tlb_access_blocked) & 
//  ~asi_pend_non_thrd1 );
//assign  tlb_access_sel_thrd2 = ~rst_tri_en & ( 
//  (tlb_ld_inst2 | tlb_st_inst2) & 
//  ~(((tlb_ld_inst0 | tlb_st_inst0 | tlb_ld_inst1 | tlb_st_inst1) & ~tlb_access_pending) 
//		| tlb_access_blocked) &
//  ~asi_pend_non_thrd2 );
//assign  tlb_access_sel_thrd3 = ~rst_tri_en & ( 
//  (tlb_ld_inst3 | tlb_st_inst3) & 
//  ~(((tlb_ld_inst0 | tlb_st_inst0 | tlb_ld_inst1 | tlb_st_inst1 | 
//    tlb_ld_inst2 | tlb_st_inst2) & ~tlb_access_pending) | tlb_access_blocked) &
//  ~asi_pend_non_thrd3 );
        
dff_s  #(4) selt_stgd1 (
        .din    ({tlb_access_sel_thrd3,tlb_access_sel_thrd2,
		tlb_access_sel_thrd1,tlb_access_sel_thrd0}),
        .q     ({tlb_access_sel_thrd3_d1,tlb_access_sel_thrd2_d1,
		tlb_access_sel_thrd1_d1,tlb_access_sel_thrd0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   wire tlb_access_sel_default;
assign  tlb_access_sel_default = rst_tri_en | ( 
        ~(tlb_access_sel_thrd2 | tlb_access_sel_thrd1 | tlb_access_sel_thrd0));
   
dff_s  #(4) lsu_diagnstc_data_sel_ff (
        .din    ({tlb_access_sel_default,tlb_access_sel_thrd2,
		tlb_access_sel_thrd1,tlb_access_sel_thrd0}),
        .q     ({lsu_diagnstc_data_sel[3:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  #(4) lsu_diagnstc_va_sel_ff (
        .din    ({tlb_access_sel_default,tlb_access_sel_thrd2,
		tlb_access_sel_thrd1,tlb_access_sel_thrd0}),
        .q     ({lsu_diagnstc_va_sel[3:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

   
// Begin - Bug 3487
assign	st_sqsh_m = 
	(st_inst_vld_m & asi_internal_m & lsu_alt_space_m) ; // Squash as bus required for stxa.
assign  tlb_st_data_sel_m[0] = (tlb_access_sel_thrd0 & ~st_sqsh_m) | (st_sqsh_m & thread0_m) ;
assign  tlb_st_data_sel_m[1] = (tlb_access_sel_thrd1 & ~st_sqsh_m) | (st_sqsh_m & thread1_m) ;
assign  tlb_st_data_sel_m[2] = (tlb_access_sel_thrd2 & ~st_sqsh_m) | (st_sqsh_m & thread2_m) ;
assign  tlb_st_data_sel_m[3] = ~|tlb_st_data_sel_m[2:0];

assign	lsu_ifu_asi_data_en_l = ~(ifu_asi_vld & tlb_access_initiated) ;

// End - Bug 3487

/*assign  tlb_st_data_sel_m[0] = tlb_access_sel_thrd0 | ((st_inst_vld_m & thread0_m) & tlb_access_blocked) ;
assign  tlb_st_data_sel_m[1] = tlb_access_sel_thrd1 | ((st_inst_vld_m & thread1_m) & tlb_access_blocked) ;
assign  tlb_st_data_sel_m[2] = tlb_access_sel_thrd2 | ((st_inst_vld_m & thread2_m) & tlb_access_blocked) ;
assign  tlb_st_data_sel_m[3] = ~|tlb_st_data_sel_m[2:0];*/

//assign	lsu_tlb_st_sel_m[3:0] = tlb_st_data_sel_m[3:0] ;
assign	lsu_tlb_st_sel_m[0] = tlb_st_data_sel_m[0] & ~rst_tri_en;
assign	lsu_tlb_st_sel_m[1] = tlb_st_data_sel_m[1] & ~rst_tri_en;
assign	lsu_tlb_st_sel_m[2] = tlb_st_data_sel_m[2] & ~rst_tri_en;
assign	lsu_tlb_st_sel_m[3] = tlb_st_data_sel_m[3] |  rst_tri_en;

assign  lsu_tlu_tlb_ld_inst_m =
  (tlb_access_sel_thrd0 & tlb_ld_inst0 & ~nontlb_asi0) |
  (tlb_access_sel_thrd1 & tlb_ld_inst1 & ~nontlb_asi1) |
  (tlb_access_sel_thrd2 & tlb_ld_inst2 & ~nontlb_asi2) |
  (tlb_access_sel_thrd3 & tlb_ld_inst3 & ~nontlb_asi3) ;

// diagnstic write for dside will not go thru tlu.
assign  lsu_tlu_tlb_st_inst_m =
  (tlb_access_sel_thrd0 & tlb_st_inst0 & ~nontlb_asi0) |
  (tlb_access_sel_thrd1 & tlb_st_inst1 & ~nontlb_asi1) |
  (tlb_access_sel_thrd2 & tlb_st_inst2 & ~nontlb_asi2) |
  (tlb_access_sel_thrd3 & tlb_st_inst3 & ~nontlb_asi3) ;

assign  lsu_tlu_tlb_access_tid_m[0] = tlb_access_sel_thrd1 | tlb_access_sel_thrd3 ;
assign  lsu_tlu_tlb_access_tid_m[1] = tlb_access_sel_thrd2 | tlb_access_sel_thrd3 ;

// Diagnostic write to dcache
assign  dc0_diagnstc_wr_en = (tlb_access_sel_thrd0 & tlb_st_inst0 & dc0_diagnstc_asi) ;
assign  dc1_diagnstc_wr_en = (tlb_access_sel_thrd1 & tlb_st_inst1 & dc1_diagnstc_asi) ;
assign  dc2_diagnstc_wr_en = (tlb_access_sel_thrd2 & tlb_st_inst2 & dc2_diagnstc_asi) ;
assign  dc3_diagnstc_wr_en = (tlb_access_sel_thrd3 & tlb_st_inst3 & dc3_diagnstc_asi) ;
assign  dc_diagnstc_wr_en = 
  dc0_diagnstc_wr_en | dc1_diagnstc_wr_en | dc2_diagnstc_wr_en | dc3_diagnstc_wr_en ;

// Diagnostic write to dtag/vld
assign  dtagv0_diagnstc_wr_en = (tlb_access_sel_thrd0 & tlb_st_inst0 & dtagv0_diagnstc_asi) ;
assign  dtagv1_diagnstc_wr_en = (tlb_access_sel_thrd1 & tlb_st_inst1 & dtagv1_diagnstc_asi) ;
assign  dtagv2_diagnstc_wr_en = (tlb_access_sel_thrd2 & tlb_st_inst2 & dtagv2_diagnstc_asi) ;
assign  dtagv3_diagnstc_wr_en = (tlb_access_sel_thrd3 & tlb_st_inst3 & dtagv3_diagnstc_asi) ;
assign  dtagv_diagnstc_wr_en = 
  dtagv0_diagnstc_wr_en | dtagv1_diagnstc_wr_en | dtagv2_diagnstc_wr_en | dtagv3_diagnstc_wr_en ;

// If a diagnostic access is selected in a cycle, then the earliest the
// e-stage can occur for the write is 2-cycles later.

assign  diag_wr_src = dtagv_diagnstc_wr_en | dc_diagnstc_wr_en ;

   wire diag_wr_src_with_rst;
   assign diag_wr_src_with_rst = diag_wr_src & ~lsu_diagnstc_wr_src_sel_e;
   
dff_s  #(1) diagwr_d1 (
        .din    (diag_wr_src_with_rst),
        .q      (diag_wr_src_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
   wire diag_wr_src_d1_with_rst;
   assign diag_wr_src_d1_with_rst = diag_wr_src_d1 & ~lsu_diagnstc_wr_src_sel_e;
     
dff_s  #(1) diagwr_d2 (
        .din    (diag_wr_src_d1_with_rst),
        .q      (diag_wr_src_d2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
// If there is no memory reference, then the diag access is free to go.
// tlb_access_blocked must be set appr. 
wire diag_wr_src_sel_d1, diag_wr_src_sel_din;

//bug4057: kill diagnostic write if dfq has valid requests to l1d$
//assign diag_wr_src_sel_din = diag_wr_src_d2 & ~memref_e;
assign diag_wr_src_sel_din = diag_wr_src_d2 & ~(memref_e | lsu_dfq_vld);
   
assign  lsu_diagnstc_wr_src_sel_e =  ~diag_wr_src_sel_d1 & diag_wr_src_sel_din ;

dff_s  #(1) diagwrsel_d1 (
        .din    (diag_wr_src_sel_din),
        .q      (diag_wr_src_sel_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Decode for diagnostic cache/dtag/vld write 
   //wire [13:11] lngltncy_ldst_va;
   
   //assign lngltncy_ldst_va[13:11]= lsu_lngltncy_ldst_va[13:11];

//assign  lsu_diagnstc_wr_way_e[0] = ~lngltncy_ldst_va[12] & ~lngltncy_ldst_va[11] ;
//assign  lsu_diagnstc_wr_way_e[1] = ~lngltncy_ldst_va[12] &  lngltncy_ldst_va[11] ;
//assign  lsu_diagnstc_wr_way_e[2] =  lngltncy_ldst_va[12] & ~lngltncy_ldst_va[11] ;
//assign  lsu_diagnstc_wr_way_e[3] =  lngltncy_ldst_va[12] &  lngltncy_ldst_va[11] ;

assign  lsu_diagnstc_dtagv_prty_invrt_e = 
	lsu_diag_va_prty_invrt & dtagv_diagnstc_wr_en & lsu_diagnstc_wr_src_sel_e ;   

// ASI Interface to IFU

assign  lsu_ifu_asi_load =
  (tlb_access_sel_thrd0 & tlb_ld_inst0 & ifu_nontlb0_asi) |
  (tlb_access_sel_thrd1 & tlb_ld_inst1 & ifu_nontlb1_asi) |
  (tlb_access_sel_thrd2 & tlb_ld_inst2 & ifu_nontlb2_asi) |
  (tlb_access_sel_thrd3 & tlb_ld_inst3 & ifu_nontlb3_asi) ;

assign  ifu_asi_store =
  (tlb_access_sel_thrd0 & tlb_st_inst0 & ifu_nontlb0_asi) |
  (tlb_access_sel_thrd1 & tlb_st_inst1 & ifu_nontlb1_asi) |
  (tlb_access_sel_thrd2 & tlb_st_inst2 & ifu_nontlb2_asi) |
  (tlb_access_sel_thrd3 & tlb_st_inst3 & ifu_nontlb3_asi) ;

assign  ifu_asi_vld = lsu_ifu_asi_load | ifu_asi_store ;

dff_s  #(2) iasiv_d1 (
        .din    ({ifu_asi_vld,ifu_lsu_asi_ack}),
        .q      ({ifu_asi_vld_d1,ifu_asi_ack_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

// Bug 3932 - delay asi_vld for ifu.
assign	lsu_ifu_asi_vld = ifu_asi_vld_d1 & ~ifu_asi_ack_d1 ;

assign	ifu_asi_store_cmplt_en = ifu_asi_store & ifu_lsu_asi_ack ;
dff_s  #(1) iasist_d1 (
        .din    (ifu_asi_store_cmplt_en),
        .q      (ifu_asi_store_cmplt_en_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign  lsu_ifu_asi_thrid[1:0] = lsu_tlu_tlb_access_tid_m[1:0] ;


//=========================================================================================
//  MEMBAR/FLUSH HANDLING
//=========================================================================================

// Check for skids in this area - verification.

wire [3:0] no_spc_rmo_st ;

// Can membar/flush cause switch out from front end ??? Need to remove from
// ldst_miss if case.
// membar/flush will both swo thread and assert flush.
// membar will signal completion once stb for thread empty
// flush  will signal completion once flush pkt is visible at head of cfq and
// i-side invalidates are complete
// ** flush bit needs to be added to dfq **

dff_s  #(2) bsync_stgm (
        .din    ({ifu_tlu_mb_inst_e,ifu_tlu_flsh_inst_e}),
        .q      ({mbar_inst_m,flsh_inst_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_flsh_inst_m = flsh_inst_m ;

wire  mbar_inst_unflushed,flsh_inst_unflushed ;

dff_s  #(2) bsync_stgg (
        .din    ({mbar_inst_m,flsh_inst_m}),
        .q      ({mbar_inst_unflushed,flsh_inst_unflushed}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

wire	[3:0]	flsh_cmplt_d1 ;
/*dff  #(4) flshcmplt (
        .din    (lsu_dfq_flsh_cmplt[3:0]),
        .q      (flsh_cmplt_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );*/

// now flopped in dctl
assign	flsh_cmplt_d1[3:0] = lsu_dfq_flsh_cmplt[3:0] ;

assign  mbar_inst_g = mbar_inst_unflushed & lsu_inst_vld_w ;
assign  flsh_inst_g = flsh_inst_unflushed & lsu_inst_vld_w ;

// THREAD0 MEMBAR/FLUSH

// barrier sync
assign bsync0_reset = 
        reset  | (mbar_vld0 & lsu_stb_empty[0] & no_spc_rmo_st[0]) 
               | (flsh_vld0 & flsh_cmplt_d1[0]) ;

assign  bsync0_en = (flush_inst0_g | mbar_inst0_g) & lsu_inst_vld_w & ~dctl_flush_pipe_w ;

assign  flush_inst0_g = flsh_inst_g & thread0_g ; 
assign  mbar_inst0_g  = mbar_inst_g & thread0_g ; 

// bsyncs are set in g-stage to allow earlier stores in pipe to drain to 
// thread's stb
dffre_s #(2)  bsync_vld0 (
        .din    ({mbar_inst0_g,flush_inst0_g}),
        .q      ({mbar_vld0,flsh_vld0}),
        .rst    (bsync0_reset),        .en     (bsync0_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// THREAD1 MEMBAR/FLUSH

// barrier sync
assign bsync1_reset = 
        reset  | (mbar_vld1 & lsu_stb_empty[1] & no_spc_rmo_st[1])  
               | (flsh_vld1 & flsh_cmplt_d1[1]) ;

assign  bsync1_en = (flush_inst1_g | mbar_inst1_g) & lsu_inst_vld_w & ~dctl_flush_pipe_w ;

assign  flush_inst1_g = flsh_inst_g & thread1_g ; 
assign  mbar_inst1_g  = mbar_inst_g & thread1_g ; 

// bsyncs are set in g-stage to allow earlier stores in pipe to drain to 
// thread's stb
dffre_s #(2)  bsync_vld1 (
        .din    ({mbar_inst1_g,flush_inst1_g}),
        .q      ({mbar_vld1,flsh_vld1}),
        .rst    (bsync1_reset),        .en     (bsync1_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// THREAD2 MEMBAR/FLUSH

// barrier sync
assign bsync2_reset = 
        reset  | (mbar_vld2 & lsu_stb_empty[2] & no_spc_rmo_st[2]) 
               | (flsh_vld2 & flsh_cmplt_d1[2]) ;

assign  bsync2_en = (flush_inst2_g | mbar_inst2_g) & lsu_inst_vld_w & ~dctl_flush_pipe_w ;

assign  flush_inst2_g = flsh_inst_g & thread2_g ; 
assign  mbar_inst2_g  = mbar_inst_g & thread2_g ; 

// bsyncs are set in g-stage to allow earlier stores in pipe to drain to 
// thread's stb
dffre_s #(2)  bsync_vld2 (
        .din    ({mbar_inst2_g,flush_inst2_g}),
        .q      ({mbar_vld2,flsh_vld2}),
        .rst    (bsync2_reset),        .en     (bsync2_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// THREAD3 MEMBAR/FLUSH

// barrier sync
assign bsync3_reset = 
        reset  | (mbar_vld3 & lsu_stb_empty[3] & no_spc_rmo_st[3]) 
               | (flsh_vld3 & flsh_cmplt_d1[3]) ;

assign  bsync3_en = (flush_inst3_g | mbar_inst3_g) & lsu_inst_vld_w & ~dctl_flush_pipe_w ;

assign  flush_inst3_g = flsh_inst_g & thread3_g ; 
assign  mbar_inst3_g  = mbar_inst_g & thread3_g ; 

// bsyncs are set in g-stage to allow earlier stores in pipe to drain to 
// thread's stb
dffre_s #(2)  bsync_vld3 (
        .din    ({mbar_inst3_g,flush_inst3_g}),
        .q      ({mbar_vld3,flsh_vld3}),
        .rst    (bsync3_reset),        .en     (bsync3_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//=========================================================================================
//  RMO Store Ack Count
//=========================================================================================

// Each thread maintains an 8b outstanding rmo ack count. To avoid overflow,
// it is the responsiblity of software to insert a membar after at most 256 rmo stores.
// 03/08/2003 now change from 256 to 16
// 8 outstanding instead of 16   

wire	[3:0]	ackcnt0,ackcnt1,ackcnt2,ackcnt3 ;
wire	[3:0]	ackcnt0_din,ackcnt1_din,ackcnt2_din,ackcnt3_din ;

// st_rmo_issue/st_rmo_ack vectors are one hot.
// Adders(2). Need two as two separate threads can be incremented and decremented
// in a cycle.
wire 	[3:0]	ackcnt_incr, ackcnt_decr ;
wire 	[3:0]	ackcnt_mx_incr, ackcnt_mx_decr ;

   wire [3:0] acknt_mx_incr_sel;
   assign     acknt_mx_incr_sel[3:0] = lsu_stb_rmo_st_issue[3:0];

assign ackcnt_mx_incr[3:0] =
  (acknt_mx_incr_sel[0] ? ackcnt0[3:0] :  4'b0) |
  (acknt_mx_incr_sel[1] ? ackcnt1[3:0] :  4'b0) |
  (acknt_mx_incr_sel[2] ? ackcnt2[3:0] :  4'b0) |
  (acknt_mx_incr_sel[3] ? ackcnt3[3:0] :  4'b0) ;
   

   wire [3:0] acknt_mx_decr_sel;
   assign     acknt_mx_decr_sel[3:0] = lsu_cpx_rmo_st_ack[3:0];

assign ackcnt_mx_decr[3:0] =
  (acknt_mx_decr_sel[0] ? ackcnt0[3:0] : 4'b0 ) |
  (acknt_mx_decr_sel[1] ? ackcnt1[3:0] : 4'b0 ) |
  (acknt_mx_decr_sel[2] ? ackcnt2[3:0] : 4'b0 ) |
  (acknt_mx_decr_sel[3] ? ackcnt3[3:0] : 4'b0 ) ;
   
    
assign	ackcnt_incr[3:0] = ackcnt_mx_incr[3:0] + 4'b0001 ;
assign	ackcnt_decr[3:0] = ackcnt_mx_decr[3:0] - 4'b0001 ;

assign	ackcnt0_din[3:0] = lsu_cpx_rmo_st_ack[0] ? ackcnt_decr[3:0] : ackcnt_incr[3:0] ;
assign	ackcnt1_din[3:0] = lsu_cpx_rmo_st_ack[1] ? ackcnt_decr[3:0] : ackcnt_incr[3:0] ;
assign	ackcnt2_din[3:0] = lsu_cpx_rmo_st_ack[2] ? ackcnt_decr[3:0] : ackcnt_incr[3:0] ;
assign	ackcnt3_din[3:0] = lsu_cpx_rmo_st_ack[3] ? ackcnt_decr[3:0] : ackcnt_incr[3:0] ;

wire	[3:0]	ackcnt_en ;
// if both occur in the same cycle then they cancel out.
assign	ackcnt_en[0] = lsu_stb_rmo_st_issue[0] ^ lsu_cpx_rmo_st_ack[0] ;
assign	ackcnt_en[1] = lsu_stb_rmo_st_issue[1] ^ lsu_cpx_rmo_st_ack[1] ;
assign	ackcnt_en[2] = lsu_stb_rmo_st_issue[2] ^ lsu_cpx_rmo_st_ack[2] ;
assign	ackcnt_en[3] = lsu_stb_rmo_st_issue[3] ^ lsu_cpx_rmo_st_ack[3] ;

// Thread0
dffre_s #(4)  ackcnt0_ff (
        .din    (ackcnt0_din[3:0]),
        .q      (ackcnt0[3:0]),
        .rst    (reset),        .en     (ackcnt_en[0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread1
dffre_s #(4)  ackcnt1_ff (
        .din    (ackcnt1_din[3:0]),
        .q      (ackcnt1[3:0]),
        .rst    (reset),        .en     (ackcnt_en[1]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread2
dffre_s #(4)  ackcnt2_ff (
        .din    (ackcnt2_din[3:0]),
        .q      (ackcnt2[3:0]),
        .rst    (reset),        .en     (ackcnt_en[2]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread3
dffre_s #(4)  ackcnt3_ff (
        .din    (ackcnt3_din[3:0]),
        .q      (ackcnt3[3:0]),
        .rst    (reset),        .en     (ackcnt_en[3]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

assign	no_spc_rmo_st[0] = ~(|ackcnt0[3:0]) ;
assign	no_spc_rmo_st[1] = ~(|ackcnt1[3:0]) ;
assign	no_spc_rmo_st[2] = ~(|ackcnt2[3:0]) ;
assign	no_spc_rmo_st[3] = ~(|ackcnt3[3:0]) ;

//8 outstanding rmo st will throttle the PCX issue st   
assign lsu_outstanding_rmo_st_max [0] = ackcnt0[3];
assign lsu_outstanding_rmo_st_max [1] = ackcnt1[3];
assign lsu_outstanding_rmo_st_max [2] = ackcnt2[3];
assign lsu_outstanding_rmo_st_max [3] = ackcnt3[3];
  
// streaming unit does not have to care about outstanding rmo sparc-stores.
// membar will take care of that. spu must insert appr. delay in sampling signal.

/*dff #(4)  spustb_d1 ( // moved to stb_rwctl
        .din    (lsu_stb_empty[3:0]),
        .q      (lsu_spu_stb_empty[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); */              

//assign		lsu_spu_stb_empty[3:0] = lsu_stb_empty[3:0] ;

//=========================================================================================
//  Thread Staging
//=========================================================================================

// Thread staging can be optimized. 

dff_s  #(2) thrid_stgd (
        .din    (ifu_lsu_thrid_s[1:0]),
        .q      (thrid_d[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s  #(2) lsu_tlu_thrid_stgd (
        .din    (ifu_lsu_thrid_s[1:0]),
        .q      (lsu_tlu_thrid_d[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
//assign	lsu_tlu_thrid_d[1:0] = thrid_d[1:0] ;

assign  thread0_d = ~thrid_d[1] & ~thrid_d[0] ;
assign  thread1_d = ~thrid_d[1] &  thrid_d[0] ;
assign  thread2_d =  thrid_d[1] & ~thrid_d[0] ;
assign  thread3_d =  thrid_d[1] &  thrid_d[0] ;

dff_s  #(2) thrid_stge (
        .din    (thrid_d[1:0]),
        .q      (thrid_e[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  thread0_e = ~thrid_e[1] & ~thrid_e[0] ;
assign  thread1_e = ~thrid_e[1] &  thrid_e[0] ;
assign  thread2_e =  thrid_e[1] & ~thrid_e[0] ;
assign  thread3_e =  thrid_e[1] &  thrid_e[0] ;

dff_s  #(2) thrid_stgm (
        .din    (thrid_e[1:0]),
        .q      (thrid_m[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  thread0_m = ~thrid_m[1] & ~thrid_m[0] ;
assign  thread1_m = ~thrid_m[1] &  thrid_m[0] ;
assign  thread2_m =  thrid_m[1] & ~thrid_m[0] ;
assign  thread3_m =  thrid_m[1] &  thrid_m[0] ;
   
bw_u1_buf_30x UZfix_thread0_m  ( .a(thread0_m),  .z(lsu_dctldp_thread0_m)  );
bw_u1_buf_30x UZfix_thread1_m  ( .a(thread1_m),  .z(lsu_dctldp_thread1_m)  );
bw_u1_buf_30x UZfix_thread2_m  ( .a(thread2_m),  .z(lsu_dctldp_thread2_m)  );
bw_u1_buf_30x UZfix_thread3_m  ( .a(thread3_m),  .z(lsu_dctldp_thread3_m)  );
   
dff_s  #(2) thrid_stgg (
        .din    (thrid_m[1:0]),
        .q      (thrid_g[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  thread0_g = ~thrid_g[1] & ~thrid_g[0] ;
assign  thread1_g = ~thrid_g[1] &  thrid_g[0] ;
assign  thread2_g =  thrid_g[1] & ~thrid_g[0] ;
assign  thread3_g =  thrid_g[1] &  thrid_g[0] ;

dff_s  #(2) thrid_stgw2 (
        .din    (thrid_g[1:0]),
        .q      (thrid_w2[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  thread0_w2 = ~thrid_w2[1] & ~thrid_w2[0] ;
assign  thread1_w2 = ~thrid_w2[1] &  thrid_w2[0] ;
assign  thread2_w2 =  thrid_w2[1] & ~thrid_w2[0] ;
assign  thread3_w2 =  thrid_w2[1] &  thrid_w2[0] ;

dff_s  #(2) thrid_stgw3 (
        .din    (thrid_w2[1:0]),
        .q      (thrid_w3[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  thread0_w3 = ~thrid_w3[1] & ~thrid_w3[0] ;
assign  thread1_w3 = ~thrid_w3[1] &  thrid_w3[0] ;
assign  thread2_w3 =  thrid_w3[1] & ~thrid_w3[0] ;
assign  thread3_w3 =  thrid_w3[1] &  thrid_w3[0] ;
   
//dff  #(4) thrid_stgw3 (
//        .din    ({thread0_w2,thread1_w2,thread2_w2,thread3_w2}),
//        .q      ({thread0_w3,thread1_w3,thread2_w3,thread3_w3}),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );

// ldxa thread id

//assign  ldxa_thrid_w2[1:0] = tlu_lsu_ldxa_tid_w2[1:0] ; // Removed original assign as per OpenSPARC T1 Internals 

assign ldxa_thrid_w2[1:0] = cfg_asi_lsu_ldxa_vld_w2 ? 
                            cfg_asi_lsu_ldxa_tid_w2[1:0] :
                            tlu_lsu_ldxa_tid_w2[1:0];

assign  tlu_ldxa_thread0_w2 = ~ldxa_thrid_w2[1] & ~ldxa_thrid_w2[0] ;
assign  tlu_ldxa_thread1_w2 = ~ldxa_thrid_w2[1] &  ldxa_thrid_w2[0] ;
assign  tlu_ldxa_thread2_w2 =  ldxa_thrid_w2[1] & ~ldxa_thrid_w2[0] ;
assign  tlu_ldxa_thread3_w2 =  ldxa_thrid_w2[1] &  ldxa_thrid_w2[0] ;

assign  spu_stxa_thread0 = ~spu_lsu_stxa_ack_tid[1] & ~spu_lsu_stxa_ack_tid[0] ;
assign  spu_stxa_thread1 = ~spu_lsu_stxa_ack_tid[1] &  spu_lsu_stxa_ack_tid[0] ;
assign  spu_stxa_thread2 =  spu_lsu_stxa_ack_tid[1] & ~spu_lsu_stxa_ack_tid[0] ;
assign  spu_stxa_thread3 =  spu_lsu_stxa_ack_tid[1] &  spu_lsu_stxa_ack_tid[0] ;

assign  spu_ldxa_thread0_w2 = ~spu_lsu_ldxa_tid_w2[1] & ~spu_lsu_ldxa_tid_w2[0] ;
assign  spu_ldxa_thread1_w2 = ~spu_lsu_ldxa_tid_w2[1] &  spu_lsu_ldxa_tid_w2[0] ;
assign  spu_ldxa_thread2_w2 =  spu_lsu_ldxa_tid_w2[1] & ~spu_lsu_ldxa_tid_w2[0] ;
assign  spu_ldxa_thread3_w2 =  spu_lsu_ldxa_tid_w2[1] &  spu_lsu_ldxa_tid_w2[0] ;

assign  ifu_ldxa_thread0_w2 = ~ifu_lsu_ldxa_tid_w2[1] & ~ifu_lsu_ldxa_tid_w2[0] ;
assign  ifu_ldxa_thread1_w2 = ~ifu_lsu_ldxa_tid_w2[1] &  ifu_lsu_ldxa_tid_w2[0] ;
assign  ifu_ldxa_thread2_w2 =  ifu_lsu_ldxa_tid_w2[1] & ~ifu_lsu_ldxa_tid_w2[0] ;
assign  ifu_ldxa_thread3_w2 =  ifu_lsu_ldxa_tid_w2[1] &  ifu_lsu_ldxa_tid_w2[0] ;

wire	[1:0]	ifu_nontlb_asi_tid ;
dff_s  #(2) iasi_tid (
        .din    (lsu_ifu_asi_thrid[1:0]),
        .q      (ifu_nontlb_asi_tid[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  ifu_stxa_thread0_w2 = ~ifu_nontlb_asi_tid[1] & ~ifu_nontlb_asi_tid[0] ;
assign  ifu_stxa_thread1_w2 = ~ifu_nontlb_asi_tid[1] &  ifu_nontlb_asi_tid[0] ;
assign  ifu_stxa_thread2_w2 =  ifu_nontlb_asi_tid[1] & ~ifu_nontlb_asi_tid[0] ;
assign  ifu_stxa_thread3_w2 =  ifu_nontlb_asi_tid[1] &  ifu_nontlb_asi_tid[0] ;

assign  tlu_stxa_thread0_w2 = ~tlu_lsu_stxa_ack_tid[1] & ~tlu_lsu_stxa_ack_tid[0] ;
assign  tlu_stxa_thread1_w2 = ~tlu_lsu_stxa_ack_tid[1] &  tlu_lsu_stxa_ack_tid[0] ;
assign  tlu_stxa_thread2_w2 =  tlu_lsu_stxa_ack_tid[1] & ~tlu_lsu_stxa_ack_tid[0] ;
assign  tlu_stxa_thread3_w2 =  tlu_lsu_stxa_ack_tid[1] &  tlu_lsu_stxa_ack_tid[0] ;

//=========================================================================================
//  Exception Handling
//=========================================================================================


// tlb related exceptions/errors
//SC assign  tlb_daccess_excptn_e  =
//SC  ((rd_only_ltlb_asi_e &  st_inst_vld_e)  |
//SC   (wr_only_ltlb_asi_e &  ld_inst_vld_e)) & alt_space_e   ;

//SC assign  tlb_daccess_error_e =
//SC   ((dfill_tlb_asi_e & ~lsu_tlb_writeable)     | 
//SC   (ifill_tlb_asi_e & ~ifu_lsu_tlb_writeable)) & st_inst_vld_e & alt_space_e ; 

//SC dff  #(2) tlbex_stgm (
//SC         .din    ({tlb_daccess_excptn_e,tlb_daccess_error_e}),
//SC         .q      ({tlb_daccess_excptn_m,tlb_daccess_error_m}),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//SC dff  #(2) tlbex_stgg (
//SC         .din    ({tlb_daccess_excptn_m,tlb_daccess_error_m}),
//SC         .q      ({tlb_daccess_excptn_g,tlb_daccess_error_g}),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//assign  pstate_priv_m = 
//  thread0_m ? tlu_lsu_pstate_priv[0] :
//    thread1_m ? tlu_lsu_pstate_priv[1] :
//      thread2_m ? tlu_lsu_pstate_priv[2] :
//          tlu_lsu_pstate_priv[3] ;

//SC mux4ds  #(1) pstate_priv_m_mux (
//SC         .in0    (tlu_lsu_pstate_priv[0]),
//SC         .in1    (tlu_lsu_pstate_priv[1]),
//SC         .in2    (tlu_lsu_pstate_priv[2]),
//SC         .in3    (tlu_lsu_pstate_priv[3]),
//SC         .sel0   (thread0_m),  
//SC         .sel1   (thread1_m),
//SC         .sel2   (thread2_m),  
//SC         .sel3   (thread3_m),
//SC         .dout   (pstate_priv_m)
//SC );
   
//SC dff  priv_stgg (
//SC         .din    (pstate_priv_m),
//SC         .q      (pstate_priv),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

// privilege violation - priv page accessed in user mode
//SC assign  priv_pg_usr_mode =  // data access exception; TT=h30
//SC   (ld_inst_vld_unflushed | st_inst_vld_unflushed) & ~(pstate_priv | hpv_priv) & tlb_rd_tte_data[`STLB_DATA_P] ;

// protection violation - store to a page that does not have write permission
//SC assign  nonwr_pg_st_access =  // data access protection; TT=h33
//SC   st_inst_vld_unflushed   & 
//SC   ~tlb_rd_tte_data[`STLB_DATA_W] & ~lsu_dtlb_bypass_g & tlb_cam_hit_g ;
   //lsu_dtlb_bypass_g) ; // W=1 in bypass mode - In bypass mode this trap will never happen !!!

//SC wire  daccess_prot ;
//SC assign  daccess_prot = nonwr_pg_st_access  ;
    //((~lsu_dtlb_bypass_g & tlb_cam_hit_g) | (tlb_byp_asi_g & lsu_alt_space_g)) ;

// access to a page marked with the nfo with an asi other than nfo asi.
//SC assign  nfo_pg_nonnfo_asi  =  // data access exception; TT=h30
//SC   (ld_inst_vld_unflushed | st_inst_vld_unflushed) &   // any access
//SC   ((~nofault_asi_g & lsu_alt_space_g) | ~lsu_alt_space_g) // in alternate space or not
//SC   & tlb_rd_tte_data[`STLB_DATA_NFO] ;

// as_if_usr asi accesses priv page.
//SC assign  as_if_usr_priv_pg  =  // data access exception; TT=h30
//SC   (ld_inst_vld_unflushed | st_inst_vld_unflushed) & as_if_user_asi_g & lsu_alt_space_g & 
//SC       tlb_rd_tte_data[`STLB_DATA_P] ;


// non-cacheable address - iospace or cp=0 (???)
// atomic access to non-cacheable space.
//SC assign  atm_access_w_nc = atomic_g & tlb_pgnum[39] ; // io space 

// atomic inst with unsupported asi.
//SC assign  atm_access_unsup_asi = atomic_g & ~atomic_asi_g & lsu_alt_space_g ;

//SC wire  tlb_tte_vld_g ;
//SC assign  tlb_tte_vld_g = ~lsu_dtlb_bypass_g & tlb_cam_hit_g ;

//SC wire  pg_with_ebit ;
//SC assign	pg_with_ebit = 
//SC 	(tlb_rd_tte_data[`STLB_DATA_E] & tlb_tte_vld_g)  | // tte
//SC         (lsu_dtlb_bypass_g & ~(phy_use_ec_asi_g & lsu_alt_space_g)) | // regular bypass 
//SC         (tlb_byp_asi_g & ~phy_use_ec_asi_g & lsu_alt_space_g) ; // phy_byp
	
//SC wire  spec_access_epage ;
//SC assign  spec_access_epage = 
//SC   ((ld_inst_vld_unflushed & nofault_asi_g & lsu_alt_space_g) |  // spec load
//SC   flsh_inst_g) & // flush inst
//SC   pg_with_ebit ; // page with side effects
//  tlb_rd_tte_data[`STLB_DATA_E] ; // page with side effects

//SC wire  quad_asi_non_ldstda ;
// quad-asi used with non ldda/stda
// remove st_inst_vld - stquad unused
// the equation may be incorrect - needs to be for a non-ldda
//SC assign  quad_asi_non_ldstda = quad_asi_g & lsu_alt_space_g & ~ldst_dbl_g & 
//SC      (ld_inst_vld_unflushed | st_inst_vld_unflushed) ;
// need to put in similar exception for binit st
//SC wire  binit_asi_non_ldda ;
//SC assign  binit_asi_non_ldda = binit_quad_asi_g & lsu_alt_space_g & ~ldst_dbl_g & 
//SC      (ld_inst_vld_unflushed) ;
//SC wire  blk_asi_non_ldstdfa ;
//SC assign  blk_asi_non_ldstdfa = blk_asi_g & lsu_alt_space_g & 
//SC      ~(ldst_dbl_g & fp_ldst_g) & (ld_inst_vld_unflushed | st_inst_vld_unflushed) ;

// trap on illegal asi
//SC wire  illegal_asi_trap_g ;
//SC assign  illegal_asi_trap_g = 
//SC (ld_inst_vld_unflushed | st_inst_vld_unflushed) &
//SC lsu_alt_space_g & ~recognized_asi_g & lsu_inst_vld_w ;

// This can be pushed back into previous cycle.
//SC wire wr_to_strm_sync ;
//SC assign	wr_to_strm_sync =  	
//SC   strm_asi & ((ldst_va_g[7:0] == 8'hA0) | (ldst_va_g[7:0] == 8'h68)) &
//SC   st_inst_vld_unflushed & lsu_alt_space_g ;

// This should not be double-anded with tlb_tte_vld_g. Check !!!
//SC assign  daccess_excptn =  
//SC     ((priv_pg_usr_mode | as_if_usr_priv_pg | nfo_pg_nonnfo_asi | 
//SC     atm_access_w_nc | atm_access_unsup_asi)) 
//SC       & tlb_tte_vld_g | 
//SC     spec_access_epage |
//SC     asi_related_trap_g | quad_asi_non_ldstda | tlb_daccess_excptn_g |
//SC     illegal_asi_trap_g | spv_use_hpv | binit_asi_non_ldda | wr_to_strm_sync | 
//SC    blk_asi_non_ldstdfa ;

// HPV Changes 
// Push back into previous stage.
// qualification with hpv_priv and hpstate_en required to ensure hypervisor
// is not trying to access.

//assign  hpv_priv_e = 
//  thread0_e ? tlu_lsu_hpv_priv[0] :
//    thread1_e ? tlu_lsu_hpv_priv[1] :
//      thread2_e ? tlu_lsu_hpv_priv[2] :
//          		tlu_lsu_hpv_priv[3] ;

// Timing change :

wire [3:0] hpv_priv_d1 ;
wire [3:0] hpstate_en_d1 ;

dff_s #(8) hpv_stgd1 (
        .din    ({tlu_lsu_hpv_priv[3:0],tlu_lsu_hpstate_en[3:0]}),
        .q    	({hpv_priv_d1[3:0],hpstate_en_d1[3:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
  
mux4ds  #(1) hpv_priv_e_mux (
        .in0    (hpv_priv_d1[0]),
        .in1    (hpv_priv_d1[1]),
        .in2    (hpv_priv_d1[2]),
        .in3    (hpv_priv_d1[3]),
        .sel0   (thread0_e),  
        .sel1   (thread1_e),
        .sel2   (thread2_e),  
        .sel3   (thread3_e),
        .dout   (hpv_priv_e)
);
 
//assign  hpstate_en_e = 
//  thread0_e ? tlu_lsu_hpstate_en[0] :
//    thread1_e ? tlu_lsu_hpstate_en[1] :
//      thread2_e ? tlu_lsu_hpstate_en[2] :
//          		tlu_lsu_hpstate_en[3] ;

mux4ds  #(1) hpstate_en_e_mux (
        .in0    (hpstate_en_d1[0]),
        .in1    (hpstate_en_d1[1]),
        .in2    (hpstate_en_d1[2]),
        .in3    (hpstate_en_d1[3]),
        .sel0   (thread0_e),  
        .sel1   (thread1_e),
        .sel2   (thread2_e),  
        .sel3   (thread3_e),
        .dout   (hpstate_en_e)
);
   
dff_s #(2) hpv_stgm (
        .din    ({hpv_priv_e, hpstate_en_e}),
        .q    	({hpv_priv_m, hpstate_en_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//dff #(2) hpv_stgg (
//        .din    ({hpv_priv_m, hpstate_en_m}),
//        .q    	({hpv_priv,   hpstate_en}),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        );

/*assign  priv_action = (ld_inst_vld_unflushed | st_inst_vld_unflushed) & ~lsu_asi_state[7] & 
      ~pstate_priv & ~(hpv_priv & hpstate_en) & lsu_alt_space_g ;*/
// Generate a stage earlier
//SC assign  priv_action_m = (ld_inst_vld_m | st_inst_vld_m) & ~lsu_dctl_asi_state_m[7] & 
//SC       ~pstate_priv_m & ~(hpv_priv_m & hpstate_en_m) & lsu_alt_space_m ;

//SC dff  pact_stgg (
//SC         .din    (priv_action_m),
//SC         .q    	(priv_action),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

// Take data_access exception if supervisor uses hypervisor asi
//SC wire    hpv_asi_range ;
//SC assign  hpv_asi_range =
//SC                     ~lsu_asi_state[7] & (
//SC                          (~lsu_asi_state[6] & lsu_asi_state[5] & lsu_asi_state[4]) | // 0x3?
//SC                          ( lsu_asi_state[6]));                                   // 0x4?,5?,6?,7?

// Take data_access exception if supervisor uses hypervisor asi
//SC `ifdef  SPARC_HPV_EN
//SC assign  spv_use_hpv = (ld_inst_vld_unflushed | st_inst_vld_unflushed) &
//SC                          hpv_asi_range &
//SC                          //~lsu_asi_state[7] & lsu_asi_state[6] & lsu_asi_state[5] & // 0x30-0x7f
//SC                          pstate_priv & ~hpv_priv & lsu_alt_space_g ;
//SC `else
//SC assign  spv_use_hpv = 1'b0 ;
//SC `endif


// EARLY TRAPS

// memory address not aligned
//SC wire  qw_align_addr,blk_align_addr ;
//SC assign  hw_align_addr = ~ldst_va_m[0] ;         // half-word addr
//SC assign  wd_align_addr = ~ldst_va_m[1] & ~ldst_va_m[0] ;     // word addr
//SC assign  dw_align_addr = ~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] ; // dw addr
//SC assign  qw_align_addr = ~ldst_va_m[3] & ~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] ; // qw addr
//SC assign  blk_align_addr = 
//SC ~ldst_va_m[5] & ~ldst_va_m[4] & ~ldst_va_m[3] & 
//SC ~ldst_va_m[2] & ~ldst_va_m[1] & ~ldst_va_m[0] ; // 64B aligned addr for block ld/st

//assign  byte_size = ~ldst_sz_m[1] &  ~ldst_sz_m[0] ; // byte size    
//assign  hw_size = ~ldst_sz_m[1] &  ldst_sz_m[0] ; // half-word size 
//assign  wd_size =  ldst_sz_m[1] & ~ldst_sz_m[0] ; // word size
//assign  dw_size =  ldst_sz_m[1] &  ldst_sz_m[0] ; // double-word size

//assign  byte_size = byte_m;
assign  hw_size = hword_m; 
assign  wd_size = word_m;
assign  dw_size = dword_m;
   
//SC assign  mem_addr_not_align
//SC   = ((hw_size & ~hw_align_addr) | // half-word check
//SC     (wd_size & ~wd_align_addr)  | // word check
//SC     (dw_size & ~dw_align_addr)  | // double word check
//SC    ((quad_asi_m | binit_quad_asi_m) & lsu_alt_space_m & ldst_dbl_m & ~qw_align_addr) | // quad word check
//SC     (blk_asi_m & lsu_alt_space_m & fp_ldst_m & ldst_dbl_m & ~blk_align_addr)) & // 64B blk ld/st check
//SC     //(blk_asi_m & lsu_alt_space_m & blk_asi_m & ~blk_align_addr)) & // 64B blk ld/st check
//SC     (ld_inst_vld_m | st_inst_vld_m) ;

//SC assign  stdf_maddr_not_align
//SC     = st_inst_vld_m & fp_ldst_m & ldst_dbl_m & wd_align_addr & ~dw_align_addr ;

//SC assign  lddf_maddr_not_align
//SC     = ld_inst_vld_m & fp_ldst_m & ldst_dbl_m & wd_align_addr & ~dw_align_addr ;

// internal asi access by ld/st other than ldxa/stxa/lddfa/stdfa.
// qual with ldst_dbl_m needed. lda and stda should take trap if accessing internal asi.
//SC assign  asi_internal_non_xdw 
//SC     = (st_inst_vld_m | ld_inst_vld_m) & lsu_alt_space_m & asi_internal_m  & ~(dw_size & ~ldst_dbl_m) ;


// asi related
// rd-only mmu asi requiring va decode.
//SC wire	mmu_rd_only_asi_wva_m ;
//SC assign	mmu_rd_only_asi_wva_m =
//SC 	((lsu_dctl_asi_state_m[7:0]==8'h58) & (
//SC 		(ldst_va_m[8:0] == 9'h000) | 	// dtag_target
//SC 		(ldst_va_m[8:0] == 9'h020))) | 	// dsync_far
//SC 	((lsu_dctl_asi_state_m[7:0]==8'h50) & 
//SC 		(ldst_va_m[8:0] == 9'h000)) ; 	// itag_target

//SC assign  wr_to_rd_only_asi = 
//SC 	(mmu_rd_only_asi_wva_m |// mmu with non-unique asi
//SC 	mmu_rd_only_asi_m |	// mmu with unique asi
//SC 	rd_only_asi_m)		// non mmu
//SC 	 &  st_inst_vld_m & lsu_alt_space_m ;

//SC assign  rd_of_wr_only_asi = wr_only_asi_m &  ld_inst_vld_m & lsu_alt_space_m ;
//SC assign  unimp_asi_used = unimp_asi_m &  (ld_inst_vld_m | st_inst_vld_m) & lsu_alt_space_m ;
//assign  asi_related_trap_m = wr_to_rd_only_asi | rd_of_wr_only_asi | unimp_asi_used | asi_internal_non_xdw ;

//SC assign  early_trap_vld_m =  stdf_maddr_not_align | lddf_maddr_not_align | mem_addr_not_align ;
      
//SC assign  lsu_tlu_misalign_addr_ldst_atm_m = early_trap_vld_m ;

// mux select order must be maintained
//SC assign  early_ttype_m[8:0] = 
//SC       stdf_maddr_not_align ? 9'h036 :
//SC         lddf_maddr_not_align ? 9'h035 : 
//SC           mem_addr_not_align ? 9'h034 : 9'hxxx ;

//SC dff #(11)   etrp_stgg (
//SC         .din    ({early_ttype_m[8:0],early_trap_vld_m,asi_related_trap_m}),
//SC         .q      ({early_ttype_g[8:0],early_trap_vld_g,asi_related_trap_g}),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//SC wire nceen_pipe_g ;
//SC assign  nceen_pipe_g = 
//SC   (thread0_g & ifu_lsu_nceen[0]) | (thread1_g & ifu_lsu_nceen[1]) |
//SC   (thread2_g & ifu_lsu_nceen[2]) | (thread3_g & ifu_lsu_nceen[3]) ;
//SC wire nceen_fill_e,nceen_fill_m,nceen_fill_g ;
//SC assign  nceen_fill_e = 
//SC   (dfill_thread0 & ifu_lsu_nceen[0]) | (dfill_thread1 & ifu_lsu_nceen[1]) |
//SC   (dfill_thread2 & ifu_lsu_nceen[2]) | (dfill_thread3 & ifu_lsu_nceen[3]) ;

//SC dff  #(1) nce_stgm (
//SC         .din    (nceen_fill_e),
//SC         .q      (nceen_fill_m),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//SC dff  #(1) nce_stgg (
//SC         .din    (nceen_fill_m),
//SC         .q      (nceen_fill_g),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//SC assign  daccess_error = 1'b0 ;
  // Commented out currently for timing reasons. This needs to be
  // rolled into the ttype_vld sent to the tlu, but can be left out
  // of the flush sent to the remaining units.
  /*((tte_data_perror_unc) & nceen_pipe_g & // on xslate 
  ~(early_trap_vld_g | priv_action | va_wtchpt_match | dmmu_miss_g)) |
  tlb_asi_unc_err_g |     // asi read
  (unc_err_trap_g & nceen_fill_g) | // cache data
  tlb_daccess_error_g ;     // tlb not writeable */

//SC assign  lsu_tlu_async_dacc_err_g = unc_err_trap_g | tlb_asi_unc_err_g ;

//SC assign  lsu_tlu_dmmu_miss_g = dmmu_miss_g ;

 wire  cam_real_m ;
 dff_s   real_stgm (
         .din    (lsu_dtlb_cam_real_e),
         .q      (cam_real_m),
         .clk    (clk),
         .se     (se),       .si (),          .so ()
         );
 
// dff   real_stgg (
//         .din    (cam_real_m),
//         .q      (cam_real_g),
//         .clk    (clk),
//         .se     (se),       .si (),          .so ()
//         );
 
assign  lsu_tlu_nonalt_ldst_m =  (st_inst_vld_m | ld_inst_vld_m) & ~lsu_alt_space_m  ;
assign  lsu_tlu_xslating_ldst_m = (st_inst_vld_m | ld_inst_vld_m) & 
	(((~asi_internal_m  & recognized_asi_m) & lsu_alt_space_m)  | // Bug 4327
	~lsu_alt_space_m) ;

assign  ctxt_sel_e[0] = thread_pctxt ; 
assign  ctxt_sel_e[1] = thread_sctxt ; 
assign  ctxt_sel_e[2] = 
	thread_nctxt | 
	(~(thread_pctxt | thread_sctxt) &  // default to nucleus - translating asi
	~(alt_space_e & (asi_internal_e | ~recognized_asi_e ))) ; //bug3660
					   // nontranslating asi to select 11 in CT
					   // field of dsfsr.

dff_s  #(3) ctxsel (
        .din    (ctxt_sel_e[2:0]),
        .q      (lsu_tlu_ctxt_sel_m[2:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_tlu_nucleus_ctxt_m = lsu_tlu_ctxt_sel_m[2] ;

assign  lsu_tlu_write_op_m = st_inst_vld_m | atomic_m ;

// va_oor_m check needs to be in case of bypass, pstate.am=1, internal and illegal asi. 
// pstate.am squashing is done locally in tlu.

assign  lsu_tlu_squash_va_oor_m =
  dtlb_bypass_m   |     // bypass
  //sta_internal_m  | lda_internal_m |  // internal asi
  (asi_internal_m & lsu_alt_space_m) |	// Bug 5156
  (~recognized_asi_tmp & lsu_alt_space_m) ; // illegal asi // Timing change.

   assign lsu_squash_va_oor_m =  lsu_tlu_squash_va_oor_m;
  
//=========================================================================================
//  Generate Flush Pipe
//=========================================================================================

//SC wire	other_flush_pipe_w ;
// lsu_tlu_ttype_vld needs to be optimized in terms of timing.
//SC assign	other_flush_pipe_w = tlu_early_flush_pipe_w | (lsu_tlu_ttype_vld_m2 & lsu_inst_vld_w);
//SC assign	lsu_ifu_flush_pipe_w = other_flush_pipe_w ;
//SC assign	lsu_exu_flush_pipe_w = other_flush_pipe_w ;
//SC assign	lsu_ffu_flush_pipe_w = other_flush_pipe_w ;

//SC //assign	lsu_flush_pipe_w = other_flush_pipe_w | ifu_tlu_flush_w ;

//=========================================================================================
//  Early Traps to SPU
//=========================================================================================

// detect st to ma/strm sync - data-access exception.
//SC wire	st_to_sync_dexcp_m ;
// qual with alt_space not required - spu will do it.
//SC assign	st_to_sync_dexcp_m = 
//SC   strm_asi_m & ((ldst_va_m[7:0] == 8'ha0) | (ldst_va_m[7:0] == 8'h68)) & st_inst_vld_m ;  

//SC wire	spu_early_flush_m ;

//SC assign	spu_early_flush_m =
//SC 	priv_action_m 		|
//SC 	mem_addr_not_align 	|
//SC 	st_to_sync_dexcp_m 	; 

//SC dff  eflushspu_g (
//SC         .din    (spu_early_flush_m),
//SC         .q      (lsu_spu_early_flush_g),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

//SC dff  eflushtlu_g (
//SC         .din    (spu_early_flush_m),
//SC         .q      (lsu_tlu_early_flush_w),
//SC        .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
 //SC        );

//=========================================================================================
//  Parity Error Checking
//=========================================================================================

// DCache Parity Error
// - Parity Check is done for entire 64b. No attempt is made to match on size. A
// parity error will force a miss and refetch a line to the same way of the cache.
// - Logging of error is done in g-stage of issue.
// - Trap taken on data return

wire	dcache_perr_en ;
assign	dcache_perr_en  =
  dcache_enable_g & ~(asi_internal_g & lsu_alt_space_g) & 
  ~atomic_g  & 
  // dcache_rd_parity_err qualified with cache_way_hit - could be x.
  (lsu_dtlb_bypass_g | (~lsu_dtlb_bypass_g & tlb_cam_hit_g)) ;
assign dcache_rd_parity_error = dcache_rparity_err_wb & dcache_perr_en ;
 
// dtag parity error gets priority over dcache priority.
assign  lsu_dcache_data_perror_g = 
  dcache_rd_parity_error & ld_inst_vld_unflushed & lsu_inst_vld_w & ~dtag_perror_g & 
  dcache_perr_en ;
//  dcache_enable_g & ~(asi_internal_g & lsu_alt_space_g) & 
//  ~atomic_g ; 

// DTLB Parity Errors. 
// ASI read of Tag/Data :
//  - uncorrectible error
//  - logging occurs on read.
//  - precise trap is taken when ldxa completes if nceen set.
//  - if not set then ldxa is allowed to complete.
// CAM Read of Tag/Data :
//  - correctible if locked bit not set.
//    - takes disrupting trap later.
//  - uncorrectible if locked bit set.
//  - both are treated as precise traps.
//  - if errors not enabled, then load completes as if hit in L1.
// ** TLB error will cause a trap which will preclude concurrent dcache,dtag  **
// ** parity errors.                **

//SC assign  tte_data_parity_error = 
//SC   tlb_rd_tte_data_parity ^ lsu_rd_tte_data_parity ;
//SC assign  tte_tag_parity_error  = 
//SC   tlb_rd_tte_tag_parity ^ lsu_rd_tte_tag_parity ;

// cam related tte data parity error - error assumed correctible if locked
// bit is not set. Will cause a dmmu_miss for correction.
// qualify with cam_hit ??
//SC assign  tte_data_perror_corr = 
//SC   tte_data_parity_error & ~tlb_rd_tte_data_locked & tlb_tte_vld_g & 
//SC   (ld_inst_vld_unflushed | st_inst_vld_unflushed) & lsu_inst_vld_w ;
// same as above except error is treated as uncorrectible. This is to be posted to 
// error status register which will cause a disrupting trap later.
//SC assign  tte_data_perror_unc  = 
//SC   tte_data_parity_error &  tlb_rd_tte_data_locked & tlb_tte_vld_g & 
//SC   (ld_inst_vld_unflushed | st_inst_vld_unflushed) & lsu_inst_vld_w ;
// Asi rd parity error detection
//SC assign  asi_tte_data_perror =
//SC   tte_data_parity_error & data_rd_vld_g ;
// For data tte read, both tag and data arrays are read.
// Parity error on asi read of tag should not be reported.
//SC assign  asi_tte_tag_perror =
//SC   tte_tag_parity_error & tag_rd_vld_g & ~data_rd_vld_g ;
//SC assign  lsu_tlu_asi_rd_unc = asi_tte_data_perror | asi_tte_tag_perror ;

// asi rd parity errors need to be reported thru asi bus
/*assign  lsu_ifu_tlb_data_ce = tte_data_perror_corr ;
assign  lsu_ifu_tlb_data_ue = tte_data_perror_unc | asi_tte_data_perror ;
assign  lsu_ifu_tlb_tag_ue  = asi_tte_tag_perror ; */


//SC wire  tlb_data_ue_g ;
//SC assign  tlb_data_ue_g = tte_data_perror_unc | asi_tte_data_perror ;

//SC dff  #(3) terr_stgd1 (
//SC         .din    ({tte_data_perror_corr,tlb_data_ue_g,asi_tte_tag_perror}),
//SC         .q      ({lsu_ifu_tlb_data_ce,lsu_ifu_tlb_data_ue,lsu_ifu_tlb_tag_ue}),
//SC         .clk    (clk),
//SC         .se     (se),       .si (),          .so ()
//SC         );

// Dtag Parity Error
// - corrected thru special mechanism
// - correctible error
// - Trap taken on data return

// move parity error calculation to g stage

dff_s  #(4) dva_vld_g_ff (
         .din    (dva_vld_m[4-1:0]),
         .q      (dva_vld_g[4-1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

   assign dva_vld_m_bf[4-1:0] = dva_vld_m[4-1:0];
   
wire	dtag_perr_en ; 
assign	dtag_perr_en = 
dcache_enable_g & ~(asi_internal_g & lsu_alt_space_g) & // Bug 3541
  ~(lsu_alt_space_g & blk_asi_g) &  // Bug 3926. 
  ~atomic_g & // Bug 4274,4297 
  ~pref_inst_g ; // Bug 5046
// assign  dtag_parity_error[0] = 
//       lsu_rd_dtag_parity_g[0] & dva_vld_g[0] & dtag_perr_en;
// assign  dtag_parity_error[1] = 
//       lsu_rd_dtag_parity_g[1] & dva_vld_g[1] & dtag_perr_en ;
// assign  dtag_parity_error[2] = 
//       lsu_rd_dtag_parity_g[2] & dva_vld_g[2] & dtag_perr_en ;
// assign  dtag_parity_error[3] = 
//       lsu_rd_dtag_parity_g[3] & dva_vld_g[3] & dtag_perr_en ;

    assign  dtag_parity_error[0] = 
          lsu_rd_dtag_parity_g[0] & dva_vld_g[0] & dtag_perr_en ;


    assign  dtag_parity_error[1] = 
          lsu_rd_dtag_parity_g[1] & dva_vld_g[1] & dtag_perr_en ;


    assign  dtag_parity_error[2] = 
          lsu_rd_dtag_parity_g[2] & dva_vld_g[2] & dtag_perr_en ;


    assign  dtag_parity_error[3] = 
          lsu_rd_dtag_parity_g[3] & dva_vld_g[3] & dtag_perr_en ;





assign  dtag_perror_g = |dtag_parity_error[4-1:0] ;
assign  lsu_dcache_tag_perror_g = 
  (|dtag_parity_error[4-1:0]) & ld_inst_vld_unflushed & lsu_inst_vld_w &
  // Correction pkt should not be generated to io.
  ~(tlb_pgnum[39] & (lsu_dtlb_bypass_g | (~lsu_dtlb_bypass_g & tlb_cam_hit_g))) ;
//  (|dtag_parity_error[3:0]) & ld_inst_vld_unflushed & lsu_inst_vld_w &
//  ~(lsu_alt_space_g & blk_asi_g) &  // Bug 3926. 
//  // Correction pkt should not be generated to io.
//  ~(tlb_pgnum[39] & (lsu_dtlb_bypass_g | (~lsu_dtlb_bypass_g & tlb_cam_hit_g))) &
//  ~atomic_g ; // Bug 4274,4297 
//=========================================================================================
//  Error Related Traps 
//=========================================================================================

//bug6382/eco6621   
dff_s #(2)  derrtrp_stgm (
        .din    ({lsu_cpx_ld_dtag_perror_e & ~ignore_fill, lsu_cpx_ld_dcache_perror_e & ~ignore_fill}),
        .q      ({dtag_error_m,dcache_error_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2)  derrtrp_stgg (
        .din    ({dtag_error_m,dcache_error_m}),
        .q      ({dtag_error_g,dcache_error_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2)  derrtrp_stgw2 (
        .din    ({dtag_error_g,dcache_error_g}),
        .q      ({dtag_error_w2,dcache_error_w2}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign  lsu_ifu_dcache_data_perror = dcache_error_w2 & ~bld_squash_err_w2;  //bug6382/eco6621
assign  lsu_ifu_dcache_tag_perror  = dtag_error_w2  ;

assign  l2_unc_error_e  = lsu_cpx_pkt_ld_err[1] & l2fill_vld_e & ~ignore_fill  ; // Bug 4998
assign  l2_corr_error_e = lsu_cpx_pkt_ld_err[0] & l2fill_vld_e & ~ignore_fill  ;

dff_s #(2)  lerrtrp_stgm (
        .din    ({l2_unc_error_e,l2_corr_error_e}),
        .q      ({l2_unc_error_m,l2_corr_error_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2)  lerrtrp_stgg (
        .din    ({l2_unc_error_m,l2_corr_error_m}),
        .q      ({l2_unc_error_g,l2_corr_error_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2)  lerrtrp_stgw2 (
        .din    ({l2_unc_error_g,l2_corr_error_g}),
        .q      ({l2_unc_error_w2,l2_corr_error_w2}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign  lsu_ifu_l2_unc_error  = // Bug 4315
(l2_unc_error_w2 | bld_unc_err_pend_w2) & ~lsu_ifu_err_addr_b39 & ~bld_squash_err_w2 ;
assign  lsu_ifu_l2_corr_error = 
(l2_corr_error_w2 | bld_corr_err_pend_w2) & ~bld_squash_err_w2 ;

wire	fill_err_trap_e ;

//assign  unc_err_trap_e = 
assign  fill_err_trap_e = 
  (lsu_cpx_pkt_ld_err[1] & l2fill_vld_e) ;
   /*(lsu_cpx_atm_st_err[1] & lsu_atm_st_cmplt_e)) & 
      ((dfill_thread0 & ifu_lsu_nceen[0]) |
       (dfill_thread1 & ifu_lsu_nceen[1]) |
       (dfill_thread2 & ifu_lsu_nceen[2]) |
       (dfill_thread3 & ifu_lsu_nceen[3])) ; */ // Bug 3624

assign	unc_err_trap_e = fill_err_trap_e ;

/*assign  corr_err_trap_e = 
  ((lsu_cpx_pkt_ld_err[0] | lsu_cpx_ld_dtag_perror_e | lsu_cpx_ld_dcache_perror_e) & 
   l2fill_vld_e) |
   (lsu_cpx_atm_st_err[0] & lsu_atm_st_cmplt_e)) & 
   & ~unc_err_trap_e &
      ((dfill_thread0 & ifu_lsu_ceen[0]) |
       (dfill_thread1 & ifu_lsu_ceen[1]) |
       (dfill_thread2 & ifu_lsu_ceen[2]) |
       (dfill_thread3 & ifu_lsu_ceen[3])) ; */


dff_s #(1)  errtrp_stgm (
        .din    ({unc_err_trap_e}),
        .q      ({unc_err_trap_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(1)  errtrp_stgg (
        .din    ({unc_err_trap_m}),
        .q      ({unc_err_trap_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

// The tlu should source demap_thrid for all tlb operations !!!
dff_s #(2)  filla_stgm (
        .din    ({lsu_dfill_tid_e[1:0]}),
        .q      ({dfill_tid_m[1:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

dff_s #(2)  filla_stgg (
        .din    ({dfill_tid_m[1:0]}),
        .q      ({dfill_tid_g[1:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 



//=========================================================================================
//  LSU to IRF Data Bypass Control
//=========================================================================================

assign	spu_trap =  spu_lsu_unc_error_w2 ;
assign	spu_trap0 = spu_trap & spu_ldxa_thread0_w2 ;
assign	spu_trap1 = spu_trap & spu_ldxa_thread1_w2 ;
assign	spu_trap2 = spu_trap & spu_ldxa_thread2_w2 ;
assign	spu_trap3 = spu_trap & spu_ldxa_thread3_w2 ;

assign	spu_ttype[6:0]	= spu_lsu_int_w2 ? 7'h70 : 7'h32 ;

dff_s #(2)   lfraw_stgw2 (
        .din    ({ld_inst_vld_g,fp_ldst_g}),
        .q      ({ld_inst_vld_w2,fp_ldst_w2}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dff_s #(2)   lfraw_stgw3 (
        .din    ({ld_stb_full_raw_w2, ld_inst_vld_w2}),
        .q      ({ld_stb_full_raw_w3, ld_inst_vld_w3}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// Delay all ldbyp*vld_en by a cycle for write of unc error
//dff #(4)  lbypen_stgd1 (
//        .din    ({ldbyp0_vld_en,ldbyp1_vld_en,ldbyp2_vld_en,ldbyp3_vld_en}),
//        .q      ({ldbyp0_vld_en_d1,ldbyp1_vld_en_d1,ldbyp2_vld_en_d1,ldbyp3_vld_en_d1}),
//        .clk    (clk),
//        .se     (se),       .si (),          .so ()
//        ); 


wire   fp_ldst_thrd0_w2,fp_ldst_thrd1_w2,fp_ldst_thrd2_w2,fp_ldst_thrd3_w2 ;
wire   fp_ldst_thrd0_w3,fp_ldst_thrd1_w3,fp_ldst_thrd2_w3,fp_ldst_thrd3_w3 ;
wire   fp_ldst_thrd0_w4,fp_ldst_thrd1_w4,fp_ldst_thrd2_w4,fp_ldst_thrd3_w4 ;
wire   fp_ldst_thrd0_w5,fp_ldst_thrd1_w5,fp_ldst_thrd2_w5,fp_ldst_thrd3_w5 ;

//RAW read STB at W3 (changed from W2)
   
dff_s #(4) fp_ldst_stg_w3 (
  .din ({fp_ldst_thrd0_w2,fp_ldst_thrd1_w2,fp_ldst_thrd2_w2,fp_ldst_thrd3_w2}),
  .q   ({fp_ldst_thrd0_w3,fp_ldst_thrd1_w3,fp_ldst_thrd2_w3,fp_ldst_thrd3_w3}),
  .clk    (clk),
  .se     (se),       .si (),          .so ()
  );

dff_s #(4) fp_ldst_stg_w4 (
  .din ({fp_ldst_thrd0_w3,fp_ldst_thrd1_w3,fp_ldst_thrd2_w3,fp_ldst_thrd3_w3}),
  .q   ({fp_ldst_thrd0_w4,fp_ldst_thrd1_w4,fp_ldst_thrd2_w4,fp_ldst_thrd3_w4}),
  .clk    (clk),
  .se     (se),       .si (),          .so ()
  );

dff_s #(4) fp_ldst_stg_w5 (
  .din ({fp_ldst_thrd0_w4,fp_ldst_thrd1_w4,fp_ldst_thrd2_w4,fp_ldst_thrd3_w4}),
  .q   ({fp_ldst_thrd0_w5,fp_ldst_thrd1_w5,fp_ldst_thrd2_w5,fp_ldst_thrd3_w5}),
  .clk    (clk),
  .se     (se),       .si (),          .so ()
  );
   
// THREAD 0

wire	tte_data_perror_unc_w2,asi_tte_data_perror_w2,asi_tte_tag_perror_w2 ;
// if nceen/ceen=0, then tte_data_perror* are not logged for trap generation. Earlier error-reporting
// is however never screened off.
// asi_tte* however has to be logged in order to report errors thru the asiQ. Traps must be squashed. 
dff_s #(3) ltlbrd_w2 (
  .din ({tte_data_perror_unc_en,asi_tte_data_perror,asi_tte_tag_perror}),
  .q   ({tte_data_perror_unc_w2,asi_tte_data_perror_w2,asi_tte_tag_perror_w2}),
  .clk    (clk),
  .se     (se),       .si (),          .so ()
  );


// Error Table for Queue
// ** In all cases; squash writes to irf.
//				| Error Reporting	| Trap ?	| 
// ifu_lsu_asi_rd_unc		| NA;done by ifu	| daccess-error	|
// tte_data_perror_unc_w2	| sync;in pipe		| daccess-error	|
// tte_data_perror_corr_w2	| sync;in pipe		| dmmu-miss	| --> NA !! all unc.
// asi_tte_data_perror_w2	| async;out of Q	| daccess-error	|
// asi_tte_tag_perror_w2	| async;out of Q	| daccess-error	|

wire [3:0] tlb_err_en_w2 ; 
// used for xslate errors - enable queues
//assign	tlb_err_en_w2[0] = (tte_data_perror_unc_w2 | tte_data_perror_corr_w2) & thread0_w2 ;	
assign	tlb_err_en_w2[0] = tte_data_perror_unc_w2 & thread0_w2 ;	
assign	tlb_err_en_w2[1] = tte_data_perror_unc_w2 & thread1_w2 ;	
assign	tlb_err_en_w2[2] = tte_data_perror_unc_w2 & thread2_w2 ;	
assign	tlb_err_en_w2[3] = tte_data_perror_unc_w2 & thread3_w2 ;	

assign ldbyp0_vld_rst =
        (reset | (ld_thrd_byp_sel_e[0])) | 
	atm_st_cmplt0 ; // Bug 4048

// thread qualification required.
//assign ldbyp0_vld_en = (lmq_byp_data_en_w2[0] & 
//        ~(|lmq_byp_data_sel0[2:1]))  // do not set vld for cas/stdbl
//	| spu_trap0 ;

wire 		atm_ld_w_uerr ;
assign		atm_ld_w_uerr = l2fill_vld_e & lsu_cpx_pkt_atm_st_cmplt & lsu_cpx_pkt_ld_err[1] ;

//bug6525 notes
// spu ldxa and spu trap can async with the main pipe, and cause more than one ldbyp*_vld_en asserted 
// at the same cycle   
assign ldbyp0_vld_en = lmq_byp_data_raw_sel_d2[0] |                  //ld hit stb RAW bypass
                       lmq_byp_data_sel0[3]       |                  //ldxa (ifu, spu*, lsu)
		       (atm_ld_w_uerr & lsu_nceen_d1[0] & dfill_thread0) |       //atomic
                       lmq_byp_data_fmx_sel[0]    |                  //tlu ldxa
		       tlb_err_en_w2[0]	  |                                      //tlb parity err
                       spu_trap0 ;                                   //spu trap*
                  
assign   fp_ldst_thrd0_w2 = fp_ldst_w2 & thread0_w2 & ld_inst_vld_w2 ;
   
// ld valid
wire	ldbyp0_vld_tmp ;
dffre_s #(1)  ldbyp0_vld_ff (
        .din    (ldbyp0_vld_en),
        .q      (ldbyp0_vld_tmp),
        .rst    (ldbyp0_vld_rst),        .en     (ldbyp0_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              
// Bug 5379 - make ld ue invisible in q until atm st ack resets.

assign	ldbyp0_vld = ldbyp0_vld_tmp & ~pend_atm_ld_ue[0] ;


// assumes that rw_index is not reset at mmu.
wire [6:0]	misc_data_in ;
wire [6:0]	misc_data0,misc_data1,misc_data2,misc_data3 ;
wire		misc_sel ;
wire [5:0]	rw_index_d1 ;
dff_s #(6)  rwind_d1 (
        .din    (tlu_dtlb_rw_index_g[5:0]),
        .q      (rw_index_d1[5:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              
assign	misc_sel = asi_tte_data_perror_w2 | asi_tte_tag_perror_w2 ;
assign	misc_data_in[6:0] = misc_sel ? {1'b0,rw_index_d1[5:0]} : spu_ttype[6:0] ; 

dffe_s #(9)  ldbyp0_other_ff (
        .din    ({fp_ldst_thrd0_w5,spu_trap0,misc_data_in[6:0]}),  //bug6525 fix2
        .q      ({ldbyp0_fpld,spubyp0_trap,misc_data0[6:0]}),
        .en     (ldbyp0_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              


dffre_s #(5)  ldbyp0_err_ff (
  	.din   	({tte_data_perror_unc_w2,atm_ld_w_uerr,
		asi_tte_data_perror_w2,asi_tte_tag_perror_w2,ifu_lsu_asi_rd_unc}),
	.q	({cam_perr_unc0,pend_atm_ld_ue[0],asi_data_perr0,asi_tag_perr0,
		ifu_unc_err0}),
        .rst    (ldbyp0_vld_rst), .en     (ldbyp0_vld_en & ~spu_trap0 & ~lmq_byp_ldxa_sel0[1]), //bug6525 fix2
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              


//assign  ldbyp0_unc_err = ldbyp0_unc_err_q & ifu_lsu_nceen[0] ;

// THREAD 1

assign ldbyp1_vld_rst =
        (reset | (ld_thrd_byp_sel_e[1])) |
	atm_st_cmplt1 ; // Bug 4048

assign   fp_ldst_thrd1_w2 = fp_ldst_w2 & thread1_w2 & ld_inst_vld_w2 ;

// thread qualification required.
//assign ldbyp1_vld_en = (lmq_byp_data_en_w2[1] &
//        ~(|lmq_byp_data_sel1[2:1])) | // do not set vld for cas/stdbl
//	| spu_trap1 ;

assign ldbyp1_vld_en = lmq_byp_data_raw_sel_d2[1] |
                       lmq_byp_data_sel1[3]       |
		       (atm_ld_w_uerr & lsu_nceen_d1[1] & dfill_thread1) |
                       lmq_byp_data_fmx_sel[1]    |
		       tlb_err_en_w2[1]	  |
                       spu_trap1 ;
   
// ld valid
wire	ldbyp1_vld_tmp ;
dffre_s #(1)  ldbyp1_vld_ff (
        .din    (ldbyp1_vld_en),
        .q      (ldbyp1_vld_tmp),
        .rst    (ldbyp1_vld_rst),        .en     (ldbyp1_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              
assign	ldbyp1_vld = ldbyp1_vld_tmp & ~pend_atm_ld_ue[1] ;


dffe_s #(9)  ldbyp1_other_ff (
        .din    ({fp_ldst_thrd1_w5,spu_trap1,misc_data_in[6:0]}),  //bug6525 fix2
        .q      ({ldbyp1_fpld,spubyp1_trap,misc_data1[6:0]}),
        .en     (ldbyp1_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// The tlb rd unc errors are delayed a cycle wrt to ldxa_data
// No reset required
dffre_s #(5)  ldbyp1_err_ff (
  	.din   	({tte_data_perror_unc_w2,atm_ld_w_uerr,
		asi_tte_data_perror_w2,asi_tte_tag_perror_w2,ifu_lsu_asi_rd_unc}),
	.q	({cam_perr_unc1,pend_atm_ld_ue[1],asi_data_perr1,asi_tag_perr1,
		ifu_unc_err1}),
        .rst    (ldbyp1_vld_rst), .en     (ldbyp1_vld_en & ~spu_trap1 & ~lmq_byp_ldxa_sel1[1]), //bug6525 fix2
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

//assign  ldbyp1_unc_err = ldbyp1_unc_err_q & ifu_lsu_nceen[1] ;

// THREAD 2

assign ldbyp2_vld_rst =
        (reset | (ld_thrd_byp_sel_e[2])) |
	atm_st_cmplt2 ; // Bug 4048

// thread qualification required.
//assign ldbyp2_vld_en = (lmq_byp_data_en_w2[2] &
//        ~(|lmq_byp_data_sel2[2:1])) | // do not set vld for cas/stdbl
//	spu_trap2 ;

assign ldbyp2_vld_en = lmq_byp_data_raw_sel_d2[2] |
                       lmq_byp_data_sel2[3]       |
		       (atm_ld_w_uerr & lsu_nceen_d1[2] & dfill_thread2) |
                       lmq_byp_data_fmx_sel[2]    |
		       tlb_err_en_w2[2]	  |
                       spu_trap2 ;

assign   fp_ldst_thrd2_w2 = fp_ldst_w2 & thread2_w2 & ld_inst_vld_w2 ;

// ld valid
wire	ldbyp2_vld_tmp ;
dffre_s #(1)  ldbyp2_vld_ff (
        .din    (ldbyp2_vld_en),
        .q      (ldbyp2_vld_tmp),
        .rst    (ldbyp2_vld_rst),        .en     (ldbyp2_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              
assign	ldbyp2_vld = ldbyp2_vld_tmp & ~pend_atm_ld_ue[2] ;

dffe_s #(9)  ldbyp2_other_ff (
        .din    ({fp_ldst_thrd2_w5,spu_trap2,misc_data_in[6:0]}),  //bug6525 fix2
        .q      ({ldbyp2_fpld,spubyp2_trap,misc_data2[6:0]}),
        .en     (ldbyp2_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

dffre_s #(5)  ldbyp2_err_ff (
  	.din   	({tte_data_perror_unc_w2, atm_ld_w_uerr,
		asi_tte_data_perror_w2,asi_tte_tag_perror_w2,ifu_lsu_asi_rd_unc}),
	.q	({cam_perr_unc2,pend_atm_ld_ue[2],asi_data_perr2,asi_tag_perr2,
		ifu_unc_err2}),
        .rst    (ldbyp2_vld_rst), .en     (ldbyp2_vld_en & ~spu_trap2 & ~lmq_byp_ldxa_sel2[1]), //bug6525 fix2
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

//assign  ldbyp2_unc_err = ldbyp2_unc_err_q & ifu_lsu_nceen[2] ;

// THREAD 3

assign ldbyp3_vld_rst =
        (reset | (ld_thrd_byp_sel_e[3])) |
	atm_st_cmplt3 ; // Bug 4048

// thread qualification required.
//assign ldbyp3_vld_en = (lmq_byp_data_en_w2[3] &
//        ~(|lmq_byp_data_sel3[2:1])) | // do not set vld for cas/stdbl
//	| spu_trap3 ;

assign ldbyp3_vld_en = lmq_byp_data_raw_sel_d2[3] |
                       lmq_byp_data_sel3[3]       |
		       (atm_ld_w_uerr & lsu_nceen_d1[3] & dfill_thread3) |
                       lmq_byp_data_fmx_sel[3]    |
		       tlb_err_en_w2[3]	  |
                       spu_trap3 ;

assign   fp_ldst_thrd3_w2 = fp_ldst_w2 & thread3_w2 & ld_inst_vld_w2 ;

// ld valid
wire	ldbyp3_vld_tmp ;
dffre_s #(1)  ldbyp3_vld_ff (
        .din    (ldbyp3_vld_en),
        .q      (ldbyp3_vld_tmp),
        .rst    (ldbyp3_vld_rst),        .en     (ldbyp3_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
assign	ldbyp3_vld = ldbyp3_vld_tmp & ~pend_atm_ld_ue[3] ;


dffe_s #(9)  ldbyp3_other_ff (
        .din    ({fp_ldst_thrd3_w5,spu_trap3,misc_data_in[6:0]}),  //bug6525 fix2
        .q      ({ldbyp3_fpld,spubyp3_trap,misc_data3[6:0]}),
        .en     (ldbyp3_vld_en),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

dffre_s #(5)  ldbyp3_err_ff (
  	.din   	({tte_data_perror_unc_w2,atm_ld_w_uerr,
		asi_tte_data_perror_w2,asi_tte_tag_perror_w2,ifu_lsu_asi_rd_unc}),
	.q	({cam_perr_unc3,pend_atm_ld_ue[3],asi_data_perr3,asi_tag_perr3,
		ifu_unc_err3}),
        .rst    (ldbyp3_vld_rst), .en     (ldbyp3_vld_en & ~spu_trap3 & ~lmq_byp_ldxa_sel3[1]), //bug6525 fix2
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

//assign  ldbyp3_unc_err = ldbyp3_unc_err_q & ifu_lsu_nceen[3] ;

//assign  ld_any_byp_data_vld = 
//  ldbyp0_vld | ldbyp1_vld | ldbyp2_vld | ldbyp3_vld ;

dff_s #(4)   stgm_sqshcmplt (
        .din    (squash_byp_cmplt[3:0]),
        .q      (squash_byp_cmplt_m[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(4)  stgg_sqshcmplt (
        .din    (squash_byp_cmplt_m[3:0]),
        .q      (squash_byp_cmplt_g[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign  fpld_byp_data_vld = 
  (ld_thrd_byp_sel_g[0] & ldbyp0_fpld & ~squash_byp_cmplt_g[0]) | // Bug 4998
  (ld_thrd_byp_sel_g[1] & ldbyp1_fpld & ~squash_byp_cmplt_g[1]) |
  (ld_thrd_byp_sel_g[2] & ldbyp2_fpld & ~squash_byp_cmplt_g[2]) |
  (ld_thrd_byp_sel_g[3] & ldbyp3_fpld & ~squash_byp_cmplt_g[3]) ;

//assign  intld_byp_data_vld = |intld_byp_cmplt[3:0] ;
// squash for spu-trap situation.
assign  intld_byp_data_vld_e = 
	//(intld_byp_cmplt[0] & ~spubyp0_trap) |
	(intld_byp_cmplt[0]) | // squash now thru squash_byp_cmplt
	(intld_byp_cmplt[1]) |
	(intld_byp_cmplt[2]) |
	(intld_byp_cmplt[3]) ;

dff_s   stgm_ibvld (
        .din    (intld_byp_data_vld_e),
        .q      (intld_byp_data_vld_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

// to be removed - intld_byp_data_vld in lsu_mon.v
/*
dff_s   stgg_ibvld (
        .din    (intld_byp_data_vld_m),
        .q      (intld_byp_data_vld),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 
*/
assign	spubyp_trap_active_e =
	//(intld_byp_cmplt[0] & spubyp0_trap) | // Bug 4040
	(ld_thrd_byp_sel_e[0] & spubyp0_trap) |
	(ld_thrd_byp_sel_e[1] & spubyp1_trap) |
	(ld_thrd_byp_sel_e[2] & spubyp2_trap) |
	(ld_thrd_byp_sel_e[3] & spubyp3_trap) ;

dff_s   stgm_strmtrp (
        .din    (spubyp_trap_active_e),
        .q      (spubyp_trap_active_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s   stgg_strmtrp (
        .din    (spubyp_trap_active_m),
        .q      (spubyp_trap_active_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign	spubyp0_ttype[6:0] = misc_data0[6:0] ;
assign	spubyp1_ttype[6:0] = misc_data1[6:0] ;
assign	spubyp2_ttype[6:0] = misc_data2[6:0] ;
assign	spubyp3_ttype[6:0] = misc_data3[6:0] ;

mux4ds #(7) mux_spubyp_ttype (
        .in0(spubyp0_ttype[6:0]),
        .in1(spubyp1_ttype[6:0]),
        .in2(spubyp2_ttype[6:0]),
        .in3(spubyp3_ttype[6:0]),
        .sel0(ld_thrd_byp_mxsel_m[0]),
        .sel1(ld_thrd_byp_mxsel_m[1]),
        .sel2(ld_thrd_byp_mxsel_m[2]),
        .sel3(ld_thrd_byp_mxsel_m[3]),
        .dout(spubyp_ttype[6:0])
);               
              
assign  intld_byp_cmplt[0] = (ld_thrd_byp_sel_e[0] & ~(ldbyp0_fpld | squash_byp_cmplt[0])) ;
assign  intld_byp_cmplt[1] = (ld_thrd_byp_sel_e[1] & ~(ldbyp1_fpld | squash_byp_cmplt[1])) ;
assign  intld_byp_cmplt[2] = (ld_thrd_byp_sel_e[2] & ~(ldbyp2_fpld | squash_byp_cmplt[2])) ;
assign  intld_byp_cmplt[3] = (ld_thrd_byp_sel_e[3] & ~(ldbyp3_fpld | squash_byp_cmplt[3])) ;

dff_s #(2)  stgm_l2fv (
        .din    ({l2fill_vld_e,lsu_l2fill_fpld_e}),
        .q      ({l2fill_vld_m,l2fill_fpld_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2) stgg_l2fv (
        .din    ({l2fill_vld_m,l2fill_fpld_m}),
        .q      ({l2fill_vld_g,l2fill_fpld_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

// write to irf will need to be postphoned by a few cycles. 
// may wish to find more bubbles by counting misses !!!
//assign  lsu_irf_byp_data_src[0]  =      ld_inst_vld_unflushed ;
//assign  lsu_irf_byp_data_src[1]  =    l2fill_vld_g ;
//assign  lsu_irf_byp_data_src[2]  =    
//  ~l2fill_vld_g    &      // no dfq fill
//  ~ld_inst_vld_unflushed ;  // no ld/st in pipe.

  //~(ld_inst_vld_unflushed | st_inst_vld_unflushed) ;  // no ld/st in pipe.
   // Timing Change.
   //ld_any_byp_data_vld ;      // full raw bypasses data


// Store to load full raw bypassing. Plus ldxa data bypassing.
// ldxa-data may be bypassed asap if port available.
// ldxa/stb raw and atomics assumed to be mutually exclusive.

wire int_ldxa_vld ;
assign int_ldxa_vld = tlu_lsu_int_ldxa_vld_w2 & ~tlu_lsu_int_ld_ill_va_w2 ;
assign	lmq_byp_data_fmx_sel[0] = (int_ldxa_vld | cfg_asi_lsu_ldxa_vld_w2) & thread0_w2 ;
assign	lmq_byp_data_fmx_sel[1] = (int_ldxa_vld | cfg_asi_lsu_ldxa_vld_w2) & thread1_w2 ;
assign	lmq_byp_data_fmx_sel[2] = (int_ldxa_vld | cfg_asi_lsu_ldxa_vld_w2) & thread2_w2 ;
assign	lmq_byp_data_fmx_sel[3] = (int_ldxa_vld | cfg_asi_lsu_ldxa_vld_w2) & thread3_w2 ;

assign lmq_byp_data_en_w2[0] =  (|lmq_byp_data_sel0[3:0]) | lmq_byp_data_fmx_sel[0] ;
assign lmq_byp_data_en_w2[1] =  (|lmq_byp_data_sel1[3:0]) | lmq_byp_data_fmx_sel[1] ;
assign lmq_byp_data_en_w2[2] =  (|lmq_byp_data_sel2[3:0]) | lmq_byp_data_fmx_sel[2] ;
assign lmq_byp_data_en_w2[3] =  (|lmq_byp_data_sel3[3:0]) | lmq_byp_data_fmx_sel[3] ;

/*
assign  stq_pkt2_data_en[0] = 
  st_inst_vld_g & ldst_dbl_g & quad_asi_g & thread0_g ;
assign  stq_pkt2_data_en[1] = 
  st_inst_vld_g & ldst_dbl_g & quad_asi_g & thread1_g ;
assign  stq_pkt2_data_en[2] = 
  st_inst_vld_g & ldst_dbl_g & quad_asi_g & thread2_g ;
assign  stq_pkt2_data_en[3] = 
  st_inst_vld_g & ldst_dbl_g & quad_asi_g & thread3_g ;
*/
   
// casxa to be decoded as doubleword.
// casa to be decoded as word.
// ldstuba to be decoded as byte.
// casa, casxa and ldstuba needed to be decoded as alternate space insts with optional
// imm_asi use.
// An atomic will switch out a thread.


wire  ifu_ldxa_vld,  spu_ldxa_vld ;
assign  ifu_ldxa_vld = ifu_lsu_ldxa_data_vld_w2 & ~ifu_lsu_ldxa_illgl_va_w2 ;
//assign  tlu_ldxa_vld = tlu_lsu_ldxa_data_vld_w2 & ~tlu_lsu_ldxa_illgl_va_w2 ;
assign  spu_ldxa_vld = spu_lsu_ldxa_data_vld_w2 & ~spu_lsu_ldxa_illgl_va_w2 ; 

wire int_ldxa_ivld ;
assign int_ldxa_ivld = tlu_lsu_int_ldxa_vld_w2 & tlu_lsu_int_ld_ill_va_w2 ;
// ldxa data returns need to cmplt thread without writing to register file
assign  ldxa_illgl_va_cmplt[0] =
  ((ifu_lsu_ldxa_data_vld_w2 & ifu_lsu_ldxa_illgl_va_w2) & ifu_ldxa_thread0_w2) |
  //((tlu_lsu_ldxa_data_vld_w2 & tlu_lsu_ldxa_illgl_va_w2) & tlu_ldxa_thread0_w2) |
  ((spu_lsu_ldxa_data_vld_w2 & spu_lsu_ldxa_illgl_va_w2) & spu_ldxa_thread0_w2) |
  (int_ldxa_ivld & thread0_w2) |
  lsu_asi_illgl_va_cmplt_w2[0] ; 
assign  ldxa_illgl_va_cmplt[1] =
  ((ifu_lsu_ldxa_data_vld_w2 & ifu_lsu_ldxa_illgl_va_w2) & ifu_ldxa_thread1_w2) |
  //((tlu_lsu_ldxa_data_vld_w2 & tlu_lsu_ldxa_illgl_va_w2) & tlu_ldxa_thread1_w2) |
  ((spu_lsu_ldxa_data_vld_w2 & spu_lsu_ldxa_illgl_va_w2) & spu_ldxa_thread1_w2) |
  (int_ldxa_ivld & thread1_w2) |
  lsu_asi_illgl_va_cmplt_w2[1] ; 
assign  ldxa_illgl_va_cmplt[2] =
  ((ifu_lsu_ldxa_data_vld_w2 & ifu_lsu_ldxa_illgl_va_w2) & ifu_ldxa_thread2_w2) |
  //((tlu_lsu_ldxa_data_vld_w2 & tlu_lsu_ldxa_illgl_va_w2) & tlu_ldxa_thread2_w2) |
  ((spu_lsu_ldxa_data_vld_w2 & spu_lsu_ldxa_illgl_va_w2) & spu_ldxa_thread2_w2) |
  (int_ldxa_ivld & thread2_w2) |
  lsu_asi_illgl_va_cmplt_w2[2] ; 
assign  ldxa_illgl_va_cmplt[3] =
  ((ifu_lsu_ldxa_data_vld_w2 & ifu_lsu_ldxa_illgl_va_w2) & ifu_ldxa_thread3_w2) |
  //((tlu_lsu_ldxa_data_vld_w2 & tlu_lsu_ldxa_illgl_va_w2) & tlu_ldxa_thread3_w2) |
  ((spu_lsu_ldxa_data_vld_w2 & spu_lsu_ldxa_illgl_va_w2) & spu_ldxa_thread3_w2) |
  (int_ldxa_ivld & thread3_w2) |
  lsu_asi_illgl_va_cmplt_w2[3] ; 

dff_s #(4)  illglva_cmplt_d1 (
        .din    (ldxa_illgl_va_cmplt[3:0]),
        .q      (ldxa_illgl_va_cmplt_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

// Thread0
// Should be able to remove thread qualification for full-raw.
// Could have and e stage store and w2 stage stb rd in same cycle !!! Qualify select3
// with select0 to give the earlier event priority. 
assign  lmq_byp_ldxa_sel0[0] = ifu_ldxa_vld & ifu_ldxa_thread0_w2 ; 
//assign  lmq_byp_ldxa_sel0[1] = tlu_ldxa_vld & tlu_ldxa_thread0_w2 ; 
assign  lmq_byp_ldxa_sel0[1] = spu_ldxa_vld & spu_ldxa_thread0_w2 ; 
assign  lmq_byp_ldxa_sel0[2] = (lsu_asi_rd_en_w2 & thread0_w2) | ldxa_tlbrd0_w3 ;

wire	fraw_annul0,fraw_annul1,fraw_annul2,fraw_annul3 ;
wire	ldst_miss0,ldst_miss1,ldst_miss2,ldst_miss3 ;

//RAW read STB at W3 (not W2)
//   E M W        W2 W3                      w4
//LD     cam_hit     RD STB, flop in byp FFs
//inst+1 D        E  
//inst+2          D  E                            <= squash (stxa) rs3_e to write into byp FFs
//  
assign	fraw_annul0 = ld_stb_full_raw_w3 & thread0_w3 & ld_inst_vld_w3;
assign	fraw_annul1 = ld_stb_full_raw_w3 & thread1_w3 & ld_inst_vld_w3;
assign	fraw_annul2 = ld_stb_full_raw_w3 & thread2_w3 & ld_inst_vld_w3;
assign	fraw_annul3 = ld_stb_full_raw_w3 & thread3_w3 & ld_inst_vld_w3;

assign	ldst_miss0 = lsu_ldst_miss_w2 & thread0_w2 ;
assign	ldst_miss1 = lsu_ldst_miss_w2 & thread1_w2 ;
assign	ldst_miss2 = lsu_ldst_miss_w2 & thread2_w2 ;
assign	ldst_miss3 = lsu_ldst_miss_w2 & thread3_w2 ;

wire	fraw_annul0_d1,fraw_annul1_d1,fraw_annul2_d1,fraw_annul3_d1 ;
wire	ldst_miss0_d1,ldst_miss1_d1,ldst_miss2_d1,ldst_miss3_d1 ;

dff_s #(4)  fraw_d1 (
        .din    ({fraw_annul3,fraw_annul2,fraw_annul1,fraw_annul0}),
        .q      ({fraw_annul3_d1,fraw_annul2_d1,fraw_annul1_d1,fraw_annul0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(4)  ldstm_d1 (
        .din    ({ldst_miss3,ldst_miss2,ldst_miss1,ldst_miss0}),
        .q      ({ldst_miss3_d1,ldst_miss2_d1,ldst_miss1_d1,ldst_miss0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

//wire	memref_d ;
//assign	memref_d = ifu_lsu_memref_d ;
/*wire	mref_vld0,mref_vld1,mref_vld2,mref_vld3;
wire	mref_vld0_d1,mref_vld1_d1,mref_vld2_d1,mref_vld3_d1;

// Bug 3053 - prevent overwrite of ldxa data with subsequent st-data
assign	mref_vld0 = (memref_d | memref_e) & ~(lsu_ldst_miss_w2 & thread0_w2) ;
assign	mref_vld1 = (memref_d | memref_e) & ~(lsu_ldst_miss_w2 & thread1_w2) ;
assign	mref_vld2 = (memref_d | memref_e) & ~(lsu_ldst_miss_w2 & thread2_w2) ;
assign	mref_vld3 = (memref_d | memref_e) & ~(lsu_ldst_miss_w2 & thread3_w2) ;

dff_s #(4)  mrefv_d1 (
        .din    ({mref_vld3,mref_vld2,mref_vld1,mref_vld0}),
        .q      ({mref_vld3_d1,mref_vld2_d1,mref_vld1_d1,mref_vld0_d1}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  */

//RAW timing change   
assign  lmq_byp_data_sel0[0] = ld_stb_full_raw_w3 & ~(ldd_force_l2access_w3 | atomic_w3 | dtlb_perror_en_w3)  & thread0_w3 & ld_inst_vld_w3 ;  
//assign  lmq_byp_data_sel0[1] = st_inst_vld_e & thread0_e & ~ifu_lsu_casa_e & ~fraw_annul0 ;
// Timing fix - at most ld will also update the bypass buffer also.
//assign  lmq_byp_data_sel0[1] = memref_e & thread0_e & ~ifu_lsu_casa_e & ~fraw_annul0 ; //bug3009
assign  lmq_byp_data_sel0[1] =  ~lmq_byp_data_sel0[0] & memref_e & thread0_e & ~ifu_lsu_casa_e & 
			~(fraw_annul0 | fraw_annul0_d1 | ldst_miss0 | ldst_miss0_d1); // Bug 3053,3180
//assign  lmq_byp_data_sel0[1] = mref_vld0_d1 & thread0_e & ~ifu_lsu_casa_e & ~(fraw_annul0 | fraw_annul0_d1); // Bug 3053
//assign  lmq_byp_data_sel0[1] = memref_e & thread0_e & ~ifu_lsu_casa_e & ~(fraw_annul0 | fraw_annul0_d1);
assign  lmq_byp_data_sel0[2] = ~(|lmq_byp_data_sel0[1:0]) & casa_g & thread0_g & lsu_inst_vld_w & ~fraw_annul0_d1 ;
assign  lmq_byp_data_sel0[3] = |lmq_byp_ldxa_sel0[2:0];
//assign  lmq_byp_data_sel0[3] = |lmq_byp_ldxa_sel0[3:0];
   
// Thread1
assign  lmq_byp_ldxa_sel1[0] = ifu_ldxa_vld & ifu_ldxa_thread1_w2 ; 
//assign  lmq_byp_ldxa_sel1[1] = tlu_ldxa_vld & tlu_ldxa_thread1_w2 ; 
assign  lmq_byp_ldxa_sel1[1] = spu_ldxa_vld & spu_ldxa_thread1_w2 ; 
assign  lmq_byp_ldxa_sel1[2] = (lsu_asi_rd_en_w2 & thread1_w2) | ldxa_tlbrd1_w3 ;

assign  lmq_byp_data_sel1[0] = ld_stb_full_raw_w3 & ~(ldd_force_l2access_w3 | atomic_w3 | dtlb_perror_en_w3) & ld_inst_vld_w3 & thread1_w3 ;   
assign  lmq_byp_data_sel1[1] = ~lmq_byp_data_sel1[0] & memref_e & thread1_e & ~ifu_lsu_casa_e & 
			~(fraw_annul1 | fraw_annul1_d1 | ldst_miss1 | ldst_miss1_d1); // Bug 3053,3180
//assign  lmq_byp_data_sel1[1] = memref_e & thread1_e & ~ifu_lsu_casa_e & ~fraw_annul1; // bug3009
//assign  lmq_byp_data_sel1[1] = mref_vld1_d1 & thread1_e & ~ifu_lsu_casa_e & ~(fraw_annul1 | fraw_annul1_d1);
//assign  lmq_byp_data_sel1[1] = memref_e & thread1_e & ~ifu_lsu_casa_e & ~(fraw_annul1 | fraw_annul1_d1); // Bug 3053
assign  lmq_byp_data_sel1[2] =  ~(|lmq_byp_data_sel1[1:0]) & casa_g & thread1_g & lsu_inst_vld_w & ~fraw_annul1_d1 ;
assign  lmq_byp_data_sel1[3] = |lmq_byp_ldxa_sel1[2:0];

// Thread2
assign  lmq_byp_ldxa_sel2[0] = ifu_ldxa_vld & ifu_ldxa_thread2_w2 ; 
//assign  lmq_byp_ldxa_sel2[1] = tlu_ldxa_vld & tlu_ldxa_thread2_w2 ; 
assign  lmq_byp_ldxa_sel2[1] = spu_ldxa_vld & spu_ldxa_thread2_w2 ; 
assign  lmq_byp_ldxa_sel2[2] = (lsu_asi_rd_en_w2 & thread2_w2) | ldxa_tlbrd2_w3 ;

assign  lmq_byp_data_sel2[0] = ld_stb_full_raw_w3 & ~(ldd_force_l2access_w3 | atomic_w3 | dtlb_perror_en_w3) & ld_inst_vld_w3 & thread2_w3 ;   
//assign  lmq_byp_data_sel2[1] = memref_e & thread2_e & ~ifu_lsu_casa_e & ~fraw_annul2; // bug3009
assign  lmq_byp_data_sel2[1] = ~lmq_byp_data_sel2[0] & memref_e & thread2_e & ~ifu_lsu_casa_e & 
			~(fraw_annul2 | fraw_annul2_d1 | ldst_miss2 | ldst_miss2_d1); // Bug 3053,3180
//assign  lmq_byp_data_sel2[1] = memref_e & thread2_e & ~ifu_lsu_casa_e & ~(fraw_annul2 | fraw_annul2_d1); // Bug 3053
assign  lmq_byp_data_sel2[2] =  ~(|lmq_byp_data_sel2[1:0]) & casa_g & thread2_g & lsu_inst_vld_w & ~fraw_annul2_d1 ;
assign  lmq_byp_data_sel2[3] = |lmq_byp_ldxa_sel2[2:0];

// Thread3
assign  lmq_byp_ldxa_sel3[0] = ifu_ldxa_vld & ifu_ldxa_thread3_w2 ; 
//assign  lmq_byp_ldxa_sel3[1] = tlu_ldxa_vld & tlu_ldxa_thread3_w2 ; 
assign  lmq_byp_ldxa_sel3[1] = spu_ldxa_vld & spu_ldxa_thread3_w2 ; 
assign  lmq_byp_ldxa_sel3[2] =  (lsu_asi_rd_en_w2 & thread3_w2) | ldxa_tlbrd3_w3 ;

assign  lmq_byp_data_sel3[0] = ld_stb_full_raw_w3 & ~(ldd_force_l2access_w3 | atomic_w3 | dtlb_perror_en_w3) & ld_inst_vld_w3 & thread3_w3 ;   
assign  lmq_byp_data_sel3[1] = ~lmq_byp_data_sel3[0] & memref_e & thread3_e & ~ifu_lsu_casa_e & 
			~(fraw_annul3 | fraw_annul3_d1 | ldst_miss3 | ldst_miss3_d1); // Bug 3053,3180
//assign  lmq_byp_data_sel3[1] = memref_e & thread3_e & ~ifu_lsu_casa_e & ~(fraw_annul3 | fraw_annul3_d1); // Bug 3053
assign  lmq_byp_data_sel3[2] = ~(|lmq_byp_data_sel3[1:0]) & casa_g & thread3_g & lsu_inst_vld_w & ~fraw_annul3_d1 ;
assign  lmq_byp_data_sel3[3] = |lmq_byp_ldxa_sel3[2:0];


dff_s #(4)  ff_lmq_byp_data_raw_sel_d1 (
        .din    ({lmq_byp_data_sel3[0], lmq_byp_data_sel2[0],
                  lmq_byp_data_sel1[0], lmq_byp_data_sel0[0]}),
        .q      (lmq_byp_data_raw_sel_d1[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(4)  ff_lmq_byp_data_raw_sel_d2 (
        .din    (lmq_byp_data_raw_sel_d1[3:0]),
        .q      (lmq_byp_data_raw_sel_d2[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
   
wire 		lsu_irf_raw_byp_e;   
// Includes both ldxa and raw bypass. 
assign  lsu_irf_raw_byp_e  =    
  ~l2fill_vld_e    &      // no dfq fill
  ~(memref_e) ; // no ld/st in pipe. 
  //~(ld_inst_vld_e | st_inst_vld_e) ; // no ld/st in pipe. 

// bug 5379 plus misc (randomize selection to prevent deadlock.
wire [3:0] bypass_sel ;
assign	bypass_sel[0] = lsu_dcache_rand[0] ? 
	ldbyp0_vld : (ldbyp0_vld & ~(ldbyp3_vld | ldbyp2_vld | ldbyp1_vld)) ; 
assign	bypass_sel[1] = lsu_dcache_rand[0] ? 
	(ldbyp1_vld & ~ldbyp0_vld) : (ldbyp1_vld & ~(ldbyp3_vld | ldbyp2_vld)) ; 
assign	bypass_sel[2] = lsu_dcache_rand[0] ? 
	(ldbyp2_vld & ~(ldbyp0_vld | ldbyp1_vld)) : (ldbyp2_vld & ~ldbyp3_vld) ; 
assign	bypass_sel[3] = lsu_dcache_rand[0] ? 
	(ldbyp3_vld & ~(ldbyp0_vld | ldbyp1_vld | ldbyp2_vld)) : ldbyp3_vld ; 
  
assign ld_thrd_byp_sel_e[0] = bypass_sel[0] & lsu_irf_raw_byp_e ;
assign ld_thrd_byp_sel_e[1] = bypass_sel[1] & lsu_irf_raw_byp_e ;
assign ld_thrd_byp_sel_e[2] = bypass_sel[2] & lsu_irf_raw_byp_e ;
assign ld_thrd_byp_sel_e[3] = bypass_sel[3] & lsu_irf_raw_byp_e ;

/*assign ld_thrd_byp_sel_e[0] = ldbyp0_vld & lsu_irf_raw_byp_e ;
assign ld_thrd_byp_sel_e[1] = ldbyp1_vld & lsu_irf_raw_byp_e &
      ~ldbyp0_vld ;                                     
assign ld_thrd_byp_sel_e[2] = ldbyp2_vld & lsu_irf_raw_byp_e &
      ~(ldbyp0_vld | ldbyp1_vld);                       
assign ld_thrd_byp_sel_e[3] = ldbyp3_vld & lsu_irf_raw_byp_e &
      ~(ldbyp0_vld | ldbyp1_vld | ldbyp2_vld) ; */

   
   //assign lsu_ld_thrd_byp_sel_e[2:0] = ld_thrd_byp_sel_e[2:0];
    bw_u1_buf_30x UZsize_lsu_ld_thrd_byp_sel_e_b2 (.a(ld_thrd_byp_sel_e[2]), .z(lsu_ld_thrd_byp_sel_e[2]));  
    bw_u1_buf_30x UZsize_lsu_ld_thrd_byp_sel_e_b1 (.a(ld_thrd_byp_sel_e[1]), .z(lsu_ld_thrd_byp_sel_e[1]));  
    bw_u1_buf_30x UZsize_lsu_ld_thrd_byp_sel_e_b0 (.a(ld_thrd_byp_sel_e[0]), .z(lsu_ld_thrd_byp_sel_e[0]));  
   
dff_s #(4)  tbyp_stgd1 (
        .din    (ld_thrd_byp_sel_e[3:0]),
        .q      (ld_thrd_byp_sel_m[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

//assign ld_thrd_byp_mxsel_m[2:0]  =    ld_thrd_byp_sel_m[2:0];
//assign ld_thrd_byp_mxsel_m[3]    =  ~|ld_thrd_byp_sel_m[2:0];

assign ld_thrd_byp_mxsel_m[0]  =    ld_thrd_byp_sel_m[0] & ~rst_tri_en;
assign ld_thrd_byp_mxsel_m[1]  =    ld_thrd_byp_sel_m[1] & ~rst_tri_en;
assign ld_thrd_byp_mxsel_m[2]  =    ld_thrd_byp_sel_m[2] & ~rst_tri_en;
assign ld_thrd_byp_mxsel_m[3]  =    (~|ld_thrd_byp_sel_m[2:0]) |  rst_tri_en;
   
dff_s #(4)  tbyp_stgd2 (
        .din    (ld_thrd_byp_sel_m[3:0]),
        .q      (ld_thrd_byp_sel_g[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

  //should move to M stage 
   
//assign ld_thrd_byp_mxsel_g[2:0]  =    ld_thrd_byp_sel_g[2:0];
//assign ld_thrd_byp_mxsel_g[3]    =  ~|ld_thrd_byp_sel_g[2:0];

assign  lmq_byp_ldxa_mxsel0[1:0] =   lmq_byp_ldxa_sel0[1:0];
assign  lmq_byp_ldxa_mxsel0[2]   = ~|lmq_byp_ldxa_sel0[1:0];
assign  lmq_byp_ldxa_mxsel1[1:0] =   lmq_byp_ldxa_sel1[1:0];
assign  lmq_byp_ldxa_mxsel1[2]   = ~|lmq_byp_ldxa_sel1[1:0];
assign  lmq_byp_ldxa_mxsel2[1:0] =   lmq_byp_ldxa_sel2[1:0];
assign  lmq_byp_ldxa_mxsel2[2]   = ~|lmq_byp_ldxa_sel2[1:0];
assign  lmq_byp_ldxa_mxsel3[1:0] =   lmq_byp_ldxa_sel3[1:0];
assign  lmq_byp_ldxa_mxsel3[2]   = ~|lmq_byp_ldxa_sel3[1:0];

assign  lmq_byp_data_mxsel0[0] =   lmq_byp_data_sel0[0] & ~rst_tri_en |  sehold;
assign  lmq_byp_data_mxsel0[1] =   lmq_byp_data_sel0[1] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel0[2] =   lmq_byp_data_sel0[2] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel0[3]   = (~|lmq_byp_data_sel0[2:0] | rst_tri_en) & ~sehold;

assign  lmq_byp_data_mxsel1[0] =   lmq_byp_data_sel1[0] & ~rst_tri_en |  sehold;
assign  lmq_byp_data_mxsel1[1] =   lmq_byp_data_sel1[1] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel1[2] =   lmq_byp_data_sel1[2] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel1[3]   = (~|lmq_byp_data_sel1[2:0] | rst_tri_en) & ~sehold;

assign  lmq_byp_data_mxsel2[0] =   lmq_byp_data_sel2[0] & ~rst_tri_en |  sehold;
assign  lmq_byp_data_mxsel2[1] =   lmq_byp_data_sel2[1] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel2[2] =   lmq_byp_data_sel2[2] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel2[3]   = (~|lmq_byp_data_sel2[2:0] | rst_tri_en) & ~sehold;

assign  lmq_byp_data_mxsel3[0] =   lmq_byp_data_sel3[0] & ~rst_tri_en |  sehold;
assign  lmq_byp_data_mxsel3[1] =   lmq_byp_data_sel3[1] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel3[2] =   lmq_byp_data_sel3[2] & ~rst_tri_en & ~sehold;
assign  lmq_byp_data_mxsel3[3]   = (~|lmq_byp_data_sel3[2:0] | rst_tri_en) & ~sehold;

//=========================================================================================
//	Error Based Traps/Reporting
//
//=========================================================================================

// !!! ORIGINAL ABOVE !!!
// Error Table for Queue
// ** In all cases; squash writes to irf.
//				| Error Reporting	| Trap ?	| 
// ifu_lsu_asi_rd_unc		| NA;done by ifu	| daccess-error	|
// tte_data_perror_unc_w2	| sync;in pipe		| daccess-error	|
// tte_data_perror_corr_w2	| sync;in pipe		| dmmu-miss	|
// asi_tte_data_perror_w2	| async;out of Q	| daccess-error	|
// asi_tte_tag_perror_w2	| async;out of Q	| daccess-error	|

assign	squash_byp_cmplt[0] = 
	((cam_perr_unc0  |  		
	asi_data_perr0 |  		
	asi_tag_perr0  |  		
	ifu_unc_err0   ) & lsu_nceen_d1[0]) |
	pend_atm_ld_ue[0] |
	spubyp0_trap ; // Bug 3873. add spu trap squash. (change reverted).
assign	squash_byp_cmplt[1] = 
	((cam_perr_unc1 | asi_data_perr1 | asi_tag_perr1 | ifu_unc_err1) & lsu_nceen_d1[1]) | 
	pend_atm_ld_ue[1] | spubyp1_trap ;	
assign	squash_byp_cmplt[2] = 
	((cam_perr_unc2 | asi_data_perr2 | asi_tag_perr2 | ifu_unc_err2) & lsu_nceen_d1[2]) | 
	pend_atm_ld_ue[2] | spubyp2_trap ;	
assign	squash_byp_cmplt[3] = 
	((cam_perr_unc3 | asi_data_perr3 | asi_tag_perr3 | ifu_unc_err3) & lsu_nceen_d1[3]) | 
	pend_atm_ld_ue[3] | spubyp3_trap ;	

assign  cam_perr_unc_e = 
  (ld_thrd_byp_sel_e[0] & cam_perr_unc0) |
  (ld_thrd_byp_sel_e[1] & cam_perr_unc1) |
  (ld_thrd_byp_sel_e[2] & cam_perr_unc2) |
  (ld_thrd_byp_sel_e[3] & cam_perr_unc3) ;
assign  asi_data_perr_e = 
  (ld_thrd_byp_sel_e[0] & asi_data_perr0) |
  (ld_thrd_byp_sel_e[1] & asi_data_perr1) |
  (ld_thrd_byp_sel_e[2] & asi_data_perr2) |
  (ld_thrd_byp_sel_e[3] & asi_data_perr3) ;
assign  asi_tag_perr_e = 
  (ld_thrd_byp_sel_e[0] & asi_tag_perr0) |
  (ld_thrd_byp_sel_e[1] & asi_tag_perr1) |
  (ld_thrd_byp_sel_e[2] & asi_tag_perr2) |
  (ld_thrd_byp_sel_e[3] & asi_tag_perr3) ;
assign  ifu_unc_err_e = 
  (ld_thrd_byp_sel_e[0] & ifu_unc_err0) |
  (ld_thrd_byp_sel_e[1] & ifu_unc_err1) |
  (ld_thrd_byp_sel_e[2] & ifu_unc_err2) |
  (ld_thrd_byp_sel_e[3] & ifu_unc_err3) ;
wire atm_st_unc_err_e,atm_st_unc_err_m,atm_st_unc_err_g ;
assign	atm_st_unc_err_e = 
(atm_st_cmplt0 & pend_atm_ld_ue[0]) | 
(atm_st_cmplt1 & pend_atm_ld_ue[1]) | 
(atm_st_cmplt2 & pend_atm_ld_ue[2]) | 
(atm_st_cmplt3 & pend_atm_ld_ue[3]) ; 

dff_s #(5)  stgm_tlberr (
        .din    ({cam_perr_unc_e,asi_data_perr_e,
		asi_tag_perr_e,ifu_unc_err_e,atm_st_unc_err_e}),
        .q      ({cam_perr_unc_m,asi_data_perr_m,
		asi_tag_perr_m,ifu_unc_err_m,atm_st_unc_err_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  


dff_s #(5)  stgg_tlberr (
        .din    ({cam_perr_unc_m,asi_data_perr_m,
		asi_tag_perr_m,ifu_unc_err_m,atm_st_unc_err_m}),
        .q      ({cam_perr_unc_g,asi_data_perr_g,
		asi_tag_perr_g,ifu_unc_err_g,atm_st_unc_err_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign	lsu_tlb_asi_data_perr_g = asi_data_perr_g ;
assign	lsu_tlb_asi_tag_perr_g = asi_tag_perr_g ;

// Asynchronous Trap Reporting to TLU (Traps are still precise).
// This version of nceen is meant specifically for trap reporting
// out of the asi queue.
wire nceen_m, nceen_g ;
assign nceen_m =
	(ld_thrd_byp_sel_m[0] & lsu_nceen_d1[0]) |
	(ld_thrd_byp_sel_m[1] & lsu_nceen_d1[1]) |
	(ld_thrd_byp_sel_m[2] & lsu_nceen_d1[2]) |
	(ld_thrd_byp_sel_m[3] & lsu_nceen_d1[3]) ;

wire nceen_dfq_m,nceen_dfq_g ;

// This version is meant specifically for lds reporting traps
// from the dfq.
assign	nceen_dfq_m =
	((~dfq_tid_m[1] & ~dfq_tid_m[0]) & lsu_nceen_d1[0]) |
	((~dfq_tid_m[1] &  dfq_tid_m[0]) & lsu_nceen_d1[1]) |
	(( dfq_tid_m[1] & ~dfq_tid_m[0]) & lsu_nceen_d1[2]) |
	(( dfq_tid_m[1] &  dfq_tid_m[0]) & lsu_nceen_d1[3]) ;

dff_s #(2)  trpen_stg (
        .din    ({nceen_m,nceen_dfq_m}),
        .q    	({nceen_g,nceen_dfq_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 


// l2c/dram
wire	atm_ld_w_uerr_m ;
dff_s #(1)  atmldu_stm (
        .din    (atm_ld_w_uerr),
        .q    	(atm_ld_w_uerr_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire	pmem_unc_error_m,pmem_unc_error_g ;
assign	pmem_unc_error_m = 
	l2_unc_error_m &  // bug3666
	~atm_ld_w_uerr_m ; //bug4048 - squash for atm ld with error.

wire	pmem_unc_error_tmp ;
dff_s #(1)  pmem_stg (
        .din    (pmem_unc_error_m),
        .q    	(pmem_unc_error_tmp),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign	pmem_unc_error_g = 
	(pmem_unc_error_tmp | bld_unc_err_pend_g) & ~bld_squash_err_g ;

wire	async_ttype_vld_g ;
wire [6:0] async_ttype_g ;
wire [1:0] async_tid_g ;

//wire	st_dtlb_perr_en ;
//assign	st_dtlb_perr_en = st_inst_vld_unflushed & tte_data_perror_unc & nceen_pipe_g ;

// traps are not to be taken if enables are not set. The asi rds of the tlb must
// thus complete as usual.
assign	async_ttype_vld_g =
	(((cam_perr_unc_g | asi_data_perr_g | asi_tag_perr_g | ifu_unc_err_g) & nceen_g) | 
		(pmem_unc_error_g & nceen_dfq_g)) | // Bug 3335,3518
	atm_st_unc_err_g |	// Bug 4048
	//lsu_defr_trp_taken_g |
	//st_dtlb_perr_en |
	//cam_perr_corr_g |
	spubyp_trap_active_g ;

wire [6:0]	async_ttype_m ;
assign	async_ttype_m[6:0] =
	spubyp_trap_active_m ? spubyp_ttype[6:0] : 7'h32 ;

dff_s #(7)  attype_stg (
        .din    (async_ttype_m[6:0]),
        .q      (async_ttype_g[6:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire [1:0]	async_err_tid_e,async_err_tid_m,async_err_tid_g ;
assign	async_err_tid_e[0] = ld_thrd_byp_sel_e[1] | ld_thrd_byp_sel_e[3] ;
assign	async_err_tid_e[1] = ld_thrd_byp_sel_e[3] | ld_thrd_byp_sel_e[2] ;

dff_s #(2)  ldbyperr_stgm (
        .din    (async_err_tid_e[1:0]),
        .q      (async_err_tid_m[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

dff_s #(2)  ldbyperr_stgg (
        .din    (async_err_tid_m[1:0]),
        .q      (async_err_tid_g[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

wire	sel_dfq_tid ;
assign	sel_dfq_tid = pmem_unc_error_g | atm_st_unc_err_g ;
assign	async_tid_g[1:0] = 
	//lsu_defr_trp_taken_g ? thrid_g[1:0] : // Bug 4660 - remove.
	sel_dfq_tid ? // Bug 3335,4048
	dfq_tid_g[1:0] : async_err_tid_g[1:0] ;

// Delay async_trp interface to TLU by a cycle.

dff_s #(10)  asynctrp_stgw2 (
        .din    ({async_ttype_vld_g,async_tid_g[1:0],async_ttype_g[6:0]}),
        .q      ({lsu_tlu_async_ttype_vld_w2,lsu_tlu_async_tid_w2[1:0],
		lsu_tlu_async_ttype_w2[6:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

// Asynchronous Error Reporting to IFU 
// Partial.

wire  sync_error_sel ;
wire	memref_m ,memref_g;
   
dff_s #(1) memref_stgg (
        .din    (memref_m),
        .q    	(memref_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
//assign  sync_error_sel = tte_data_perror_unc | tte_data_perror_corr ;

//for in1 or in2 to be selected, memref_g must be 0.
//in1 is reported thru the bypass/asi queues, in2 thru the dfq.
//So err_addr_sel[0] can be memref_g.
   assign sync_error_sel = memref_g;
   
wire	async_error_sel ;
assign	async_error_sel = asi_data_perr_g | asi_tag_perr_g ;

assign	lsu_err_addr_sel[0] =  sync_error_sel & ~rst_tri_en;
assign	lsu_err_addr_sel[1] =  async_error_sel & ~rst_tri_en;
assign	lsu_err_addr_sel[2] = ~(sync_error_sel | async_error_sel) | rst_tri_en;

//mux4ds  #(6) async_tlb_index_mx(
//  .in0  (misc_data0[5:0]),
//  .in1  (misc_data1[5:0]),
//  .in2  (misc_data2[5:0]),
//  .in3  (misc_data3[5:0]),
//  .sel0 (ld_thrd_byp_sel_g[0]),
//  .sel1 (ld_thrd_byp_sel_g[1]),
//  .sel2 (ld_thrd_byp_sel_g[2]),
//  .sel3 (ld_thrd_byp_sel_g[3]),
//  .dout (async_tlb_index[5:0])
//   );
   
assign async_tlb_index[5:0] =  
  (ld_thrd_byp_sel_g[0] ? misc_data0[5:0] : 6'b0) |
  (ld_thrd_byp_sel_g[1] ? misc_data1[5:0] : 6'b0) |
  (ld_thrd_byp_sel_g[2] ? misc_data2[5:0] : 6'b0) |
  (ld_thrd_byp_sel_g[3] ? misc_data3[5:0] : 6'b0) ;
        
wire	[1:0] err_tid_g ;
//assign  err_tid_g[1:0] =
//  sync_error_sel ? thrid_g[1:0] :
//  	async_error_sel ? async_err_tid_g[1:0] : dfill_tid_g[1:0] ;

mux3ds #(2) err_tid_mx (
  .in0 (thrid_g[1:0]),
  .in1 (async_err_tid_g[1:0]),
  .in2 (dfill_tid_g[1:0]),
  .sel0(lsu_err_addr_sel[0]),
  .sel1(lsu_err_addr_sel[1]),
  .sel2(lsu_err_addr_sel[2]),
  .dout(err_tid_g[1:0])
                   );
                
// Can shift to m.
//assign  lsu_tlu_derr_tid_g[1:0] = err_tid_g[1:0] ;

dff_s #(2)  errad_stgg (
        .din    (err_tid_g[1:0]),
        .q      (lsu_ifu_error_tid[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        ); 

assign  lsu_ifu_io_error = //l2_unc_error_w2 & lsu_ifu_err_addr_b39 ;
// extend for bld to io space.
(l2_unc_error_w2 | bld_unc_err_pend_w2) & lsu_ifu_err_addr_b39 & ~bld_squash_err_w2 ;

 
//=========================================================================================


wire stxa_internal_cmplt ;
assign	stxa_internal_cmplt = 
stxa_internal & 
~(intrpt_disp_asi_g | stxa_stall_asi_g | (ifu_nontlb_asi_g & ~ifu_asi42_flush_g) | tlb_lng_ltncy_asi_g) & 
					lsu_inst_vld_w & ~dctl_early_flush_w ;
					//lsu_inst_vld_w & ~dctl_flush_pipe_w ;

// Need to add stxa's related to ifu non-tlb asi.
dff_s  stxa_int_d1 (
        .din    (stxa_internal_cmplt),
        //.din    (stxa_internal & ~(stxa_stall_asi_g | tlb_lng_ltncy_asi_g) & lsu_inst_vld_w),
        .q      (stxa_internal_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s  stxa_int_d2 (
        .din    (stxa_internal_d1),
        .q      (stxa_internal_d2),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  


//=========================================================================================
//  Replacement Algorithm for Cache
//=========================================================================================



// Increment Condition.
wire	lfsr_incr, lfsr_incr_d1 ;
assign	lfsr_incr = 
	ld_inst_vld_g & ~lsu_way_hit_or & ~ldxa_internal & 
	~ncache_pcx_rq_g ; // must be cacheable

dff_s  lfsrd1_ff (
        .din    (lfsr_incr),
        .q      (lfsr_incr_d1),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

wire	lfsr_rst ;
assign	lfsr_rst = 
		reset 		| 	
		~gdbginit_l 	| // debug init.
		dc_direct_map 	; // direct map mode will reset.

// Bug 4027
lsu_dcache_lfsr lfsr(.out (lsu_dcache_rand[1:0]),
                                           .clk  (clk),
                                           .advance (lfsr_incr_d1),
                                           .reset (lfsr_rst),
                                           .se (se),
                                           .si (),
                                           .so ());

//assign  lsu_dcache_rand[1:0]  =  dcache_rand[1:0]; 


/*assign  dcache_rand_new[1:0] = dcache_rand[1:0] + {1'b0, lsu_ld_miss_wb} ;
dffre_s #(2) drand (
        .din    (dcache_rand_new[1:0]),
        .q      (dcache_rand[1:0]),
        .rst  (reset), .en    (lsu_ld_miss_wb),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign  lsu_dcache_rand[1:0]  =  dcache_rand[1:0]; */

//=========================================================================================
//  Packet Assembly
//=========================================================================================

// assign lsu_encd_way_hit[0] = cache_way_hit_buf1[1] | cache_way_hit_buf1[3] ;
// assign lsu_encd_way_hit[1] = cache_way_hit_buf1[2] | cache_way_hit_buf1[3] ;
always @ *
begin
lsu_encd_way_hit = 0;
if (cache_way_hit_buf1[0])
   lsu_encd_way_hit = 0;
else if (cache_way_hit_buf1[1])
   lsu_encd_way_hit = 1;
else if (cache_way_hit_buf1[2])
   lsu_encd_way_hit = 2;
else if (cache_way_hit_buf1[3])
   lsu_encd_way_hit = 3;
end


//assign lsu_way_hit_or  =  |lsu_way_hit[3:0];
assign lsu_way_hit_or  =  |cache_way_hit_buf1; // Bug 3940
   
//assign  stb_byp_pkt_vld_e = st_inst_vld_e & ~(ldsta_internal_e & alt_space_e);
assign  ld_pcx_pkt_vld_e = ld_inst_vld_e & ~(ldsta_internal_e & alt_space_e);

wire ldstub_m;
wire swap_m;
dff_s #(5)  pktctl_stgm (
        .din    ({ifu_lsu_ldst_dbl_e, ld_pcx_pkt_vld_e,
    ifu_lsu_casa_e,ifu_lsu_ldstub_e,ifu_lsu_swap_e}),
        .q      ({ldst_dbl_m, ld_pcx_pkt_vld_m,
    casa_m,ldstub_m,swap_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

assign  atomic_m = casa_m | ldstub_m | swap_m ;

wire ldstub_g;
wire swap_g;
dff_s #(6) pktctl_stgg (
        .din    ({ldst_dbl_m, ld_pcx_pkt_vld_m,
    casa_m,ldstub_m,swap_m,atomic_m}),
        .q      ({ldst_dbl_g, ld_pcx_pkt_vld_g,
    casa_g,ldstub_g,swap_g,atomic_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2) pktctl_stgw2 (
        .din    ({ldd_force_l2access_g, atomic_g}),
        .q      ({ldd_force_l2access_w2,atomic_w2}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

dff_s #(2) pktctl_stgw3 (
        .din    ({ldd_force_l2access_w2, atomic_w2}),
        .q      ({ldd_force_l2access_w3, atomic_w3}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  
   
assign  lsu_ldstub_g = ldstub_g ;
assign  lsu_swap_g = swap_g ;

// Choose way for load. If load hits in dcache but sent out to xbar because
// of partial raw then need to use hit way else use random. Similarly, dcache
// parity error will force a miss and fill to same way.

// Moved to qctl1
// For direct-map mode, assume that addition set-index bits 12:11 are
// used to file line in set.
//assign  ld_way[1:0] = 
//    (|lsu_way_hit[3:0]) ? 
//        {lsu_encd_way_hit[1],lsu_encd_way_hit[0]} : 
//          	lsu_ld_sec_hit_l2access_g ? lsu_ld_sec_hit_wy_g[1:0] :
//	   		(dc_direct_map ? ldst_va_g[12:11] : dcache_rand[1:0]) ;

// set to 011 for atomic - only cas encoding used for pcx pkt.
assign  ld_rq_type[2:0] =
    atomic_g ? 3'b011 :       // cas pkt 2/ldstub/swap 
//        (ldst_dbl_g & st_inst_vld_g & quad_asi_g) ? 3'b001 : // stquad - label as store.
    3'b000 ;      // normal load


//assign  lmq_pkt_vld_g = ld_pcx_pkt_vld_g | (ldst_dbl_g & st_inst_vld_unflushed) | pref_inst_g ; 
assign  lmq_pkt_vld_g = ld_pcx_pkt_vld_g | pref_inst_g ; 

// Moved to qctl1
// 2'b01 encodes ld as st-quad pkt2. 2'b00 needed for cas-pkt2
//assign  lmq_pkt_way_g[1:0] = 
//(ldst_dbl_g & st_inst_vld_unflushed & quad_asi_g) ? 2'b01 :
//        casa_g ? 2'b00 : ld_way[1:0] ;

// ld is 128b request.
wire	qword_access_g;
assign	qword_access_g = 
(quad_asi_g | blk_asi_g ) & lsu_alt_space_g & ld_inst_vld_unflushed ;

assign	lsu_quad_word_access_g = qword_access_g ;

wire  fp_ld_inst_g ;
assign  fp_ld_inst_g  = fp_ldst_g & ld_inst_vld_g ;  

wire  ldst_sz_b0_g ;
assign  ldst_sz_b0_g =  
  ldst_sz_g[0] & 
  ~(ldst_dbl_g & ~fp_ldst_g & 
    (~lsu_alt_space_g | (lsu_alt_space_g & ~quad_asi_g))) ; 
                // word for ld-dbl

wire	asi_real_iomem_m,asi_real_iomem_g ;
assign	asi_real_iomem_m = 
(dtlb_bypass_m & (phy_use_ec_asi_m | phy_byp_ec_asi_m) & lsu_alt_space_m) ;

dff_s #(1) stgg_asir (
        .din    (asi_real_iomem_m),
        .q    	(asi_real_iomem_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign  ncache_pcx_rq_g   = 
  atomic_g    |   // cas,ldstub,swap  
  asi_real_iomem_g | // real_mem, real_io
  ~dcache_enable_g | // dcache disabled : Bug 5174 (accidental removal)
  ((tlb_pgnum[39] & ~lsu_dtlb_bypass_g & tlb_cam_hit_g) | // IO - tlb not in bypass
   (tlb_pgnum[39] &  lsu_dtlb_bypass_g)) |    // IO - tlb bypass
  (~lsu_tte_data_cp_g & tlb_cam_hit_g) |      // cp bit is clear
  ((quad_asi_g | binit_quad_asi_g | blk_asi_g)  & lsu_alt_space_g & ldst_dbl_g & ld_inst_vld_unflushed) |  // quad-ld
  pref_inst_g ; // pref will not alloc. in L2 dir

assign  stb_ncache_pcx_rq_g   = 
  asi_real_iomem_g | // real_mem, real_io
  ~dcache_enable_g | // dcache disabled : Bug 5174 (accidental removal)
  ((tlb_pgnum[39] & ~lsu_dtlb_bypass_g & tlb_cam_hit_g) | // IO - tlb not in bypass
   (tlb_pgnum[39] &  lsu_dtlb_bypass_g)) |    // IO - tlb bypass
  (~lsu_tte_data_cp_g & tlb_cam_hit_g);      // cp bit is clear


//wire	dflush_ld_g ;
//assign  dflush_ld_g = dflush_asi_g & lsu_alt_space_g ;

// st-quad pkt1 and pkt2 need different addresses !!
// ** should be able to reduce the width, rd2,stquad,lmq_pkt_way ** 
//assign  ld_pcx_pkt_g[`LMQ_WIDTH-1:0] =

//bug3601
//dbl_data_return will become lmq_ldd
//it includes quad ld, int ldd, block ld, all these cases need return data twice.    
   wire dbl_data_return;
   assign dbl_data_return = ldst_dbl_g & ~ (fp_ldst_g & ~ (blk_asi_g & lsu_alt_space_g));
   
assign  ld_pcx_pkt_g[65-1:40] =
  {lmq_pkt_vld_g,
  1'b0,                  //dflush_ld_g, bug 4580 
  pref_inst_g, 
  fp_ld_inst_g, 
  l1hit_sign_extend_g,
  //lsu_bendian_access_g,
  bendian_g,	// l2fill_bendian removed.
  ld_rd_g[4:0], // use rd1 only for now.
  dbl_data_return,  //bug 3601
  //ldst_dbl_g & ~fp_ldst_g,  // rd2 used by ld double.
  {ld_rd_g[4:1],~ld_rd_g[0]}, // rd2 to be used with atomics.
  ld_rq_type[2:0],
  ncache_pcx_rq_g,  // NC.
  //lmq_pkt_way_g[1:0], // replacement way
  2'b00,
  ldst_sz_g[1],ldst_sz_b0_g};
  //{tlb_pgnum[39:10], ldst_va_g[9:0]}};

//=========================================================================================
//  Byte Masking for writes
//=========================================================================================

// Byte-enables will be generated in cycle prior to fill (E-stage)
// Reads and writes are mutex as array is single-ported.
// byte-enables are handled thru read-modify-writes.

// Create 16b Write Mask based on size and va ;
// This is to be put in the DFQ once the DFQ is on-line.


wire [2:0] dc_waddr_m ;
dff_s #(4) stgm_addr (
        .din    ({memref_e, dcache_wr_addr_e[2:0]}),
        .q    	({memref_m, dc_waddr_m[2:0]}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_memref_m = memref_m ;

//wire [3:0] rwaddr_enc ;
//assign  rwaddr_enc[3:0] = memref_m ? 
//        lsu_ldst_va_b7_b0_m[3:0] : dc_waddr_m[3:0];

wire [2:0] rwaddr_enc ;
assign  rwaddr_enc[2:0] = memref_m ? 
        lsu_ldst_va_b7_b0_m[2:0] : dc_waddr_m[2:0];
   

   wire [1:0] wr_size;
   
   assign wr_size[1:0] = dcache_wr_size_e[1:0];

   wire   wr_hword, wr_word, wr_dword;
   
//assign  wr_byte    = ~wr_size[1] & ~wr_size[0] ; // 01
assign  wr_hword   = ~wr_size[1] &  wr_size[0] ; // 01
assign  wr_word    =  wr_size[1] & ~wr_size[0] ; // 10
assign  wr_dword   =  wr_size[1] &  wr_size[0] ; // 11

assign  ldst_byte    = ~ldst_sz_e[1] & ~ldst_sz_e[0] ; // 01
assign  ldst_hword   = ~ldst_sz_e[1] &  ldst_sz_e[0] ; // 01
assign  ldst_word    =  ldst_sz_e[1] & ~ldst_sz_e[0] ; // 10
assign  ldst_dword   =  ldst_sz_e[1] &  ldst_sz_e[0] ; // 11

// In Bypass mode, endianness is determined by asi.
// Need to complete this equation.

// Note : add MMU disable bypass conditions !!!
assign  tlb_invert_endian_g = lsu_tlb_invert_endian_g & ~lsu_dtlb_bypass_g & tlb_cam_hit_g ; 

// Is qualification with reset needed ?
//assign  l2fill_bendian_g = lsu_l2fill_bendian_g & ~reset;

//assign  pstate_cle_m = 
//  thread0_m ? tlu_lsu_pstate_cle[0] :
//    thread1_m ? tlu_lsu_pstate_cle[1] :
//      thread2_m ? tlu_lsu_pstate_cle[2] :
//          tlu_lsu_pstate_cle[3] ;

mux4ds  #(1) pstate_cle_e_mux (
        .in0    (tlu_lsu_pstate_cle[0]),
        .in1    (tlu_lsu_pstate_cle[1]),
        .in2    (tlu_lsu_pstate_cle[2]),
        .in3    (tlu_lsu_pstate_cle[3]),
        .sel0   (thread0_e),  
        .sel1   (thread1_e),
        .sel2   (thread2_e),  
        .sel3   (thread3_e),
        .dout   (pstate_cle_e)
);

dff_s #(1) stgm_pstatecle (
        .din    (pstate_cle_e),
        .q      (pstate_cle_m),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
   
dff_s #(1) stgg_pstatecle (
        .din    (pstate_cle_m),
        .q      (pstate_cle_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//SPARC V9 page 52. pstate.cle should only affect implicit ASI   
assign  l1hit_lendian_g = 
    ((non_altspace_ldst_g & (pstate_cle_g ^ tlb_invert_endian_g)) |       // non altspace ldst
     (altspace_ldst_g     & (lendian_asi_g ^ tlb_invert_endian_g)))       // altspace ldst
    & ~(asi_internal_g & lsu_alt_space_g);                                // internal asi is big-endian

wire    l1hit_lendian_predict_m ;
// Predict endian-ness in m-stage. Assume tte.IE=0
assign  l1hit_lendian_predict_m =
    ((non_altspace_ldst_m & pstate_cle_m) |        // non altspace ldst
     (altspace_ldst_m     & lendian_asi_m))        // altspace ldst
    & ~asi_internal_m ;                            // internal asi is big-endian
   
// Further, decode of ASI is not factored into endian calculation. 
//assign  lsu_bendian_access_g = (ld_inst_vld_unflushed | st_inst_vld_unflushed) ?
//    ~l1hit_lendian_g : l2fill_bendian_g ;

// m stage endian signal is predicted for in-pipe lds only.
wire    bendian_pred_m, bendian_pred_g ;
assign  bendian_pred_m = (ld_inst_vld_m | st_inst_vld_m) ?
    ~l1hit_lendian_predict_m : lsu_l2fill_bendian_m ;

dff_s #(1) stgg_bendpr(
        .din    (bendian_pred_m),
        .q      (bendian_pred_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

// mispredict applies to only in-pipe lds.
assign  endian_mispred_g =  bendian_pred_g ^ ~l1hit_lendian_g ;

// Staging for alignment on read from l1 or fill to l2.
dff_s #(4) stgm_sz (
        .din    ({ldst_byte,  ldst_hword,  ldst_word,  ldst_dword}),
        .q      ({byte_m,hword_m,word_m,dword_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  

wire	[7:0]	rwaddr_dcd_part ;

assign  rwaddr_dcd_part[0]  = ~rwaddr_enc[2] & ~rwaddr_enc[1] & ~rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[1]  = ~rwaddr_enc[2] & ~rwaddr_enc[1] &  rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[2]  = ~rwaddr_enc[2] &  rwaddr_enc[1] & ~rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[3]  = ~rwaddr_enc[2] &  rwaddr_enc[1] &  rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[4]  =  rwaddr_enc[2] & ~rwaddr_enc[1] & ~rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[5]  =  rwaddr_enc[2] & ~rwaddr_enc[1] &  rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[6]  =  rwaddr_enc[2] &  rwaddr_enc[1] & ~rwaddr_enc[0] ; 
assign  rwaddr_dcd_part[7]  =  rwaddr_enc[2] &  rwaddr_enc[1] &  rwaddr_enc[0] ; 

   assign baddr_m[7:0] = rwaddr_dcd_part[7:0];
/*    
assign baddr_m[0]  = ~rwaddr_enc[3] & rwaddr_dcd_part[0] ;
assign baddr_m[1]  = ~rwaddr_enc[3] & rwaddr_dcd_part[1] ;
assign baddr_m[2]  = ~rwaddr_enc[3] & rwaddr_dcd_part[2] ;
assign baddr_m[3]  = ~rwaddr_enc[3] & rwaddr_dcd_part[3] ;
assign baddr_m[4]  = ~rwaddr_enc[3] & rwaddr_dcd_part[4] ; 
assign baddr_m[5]  = ~rwaddr_enc[3] & rwaddr_dcd_part[5] ;
assign baddr_m[6]  = ~rwaddr_enc[3] & rwaddr_dcd_part[6] ;
assign baddr_m[7]  = ~rwaddr_enc[3] & rwaddr_dcd_part[7] ;
assign baddr_m[8]  =  rwaddr_enc[3] & rwaddr_dcd_part[0] ;
assign baddr_m[9]  =  rwaddr_enc[3] & rwaddr_dcd_part[1] ;
assign baddr_m[10] =  rwaddr_enc[3] & rwaddr_dcd_part[2] ;
assign baddr_m[11] =  rwaddr_enc[3] & rwaddr_dcd_part[3] ;
assign baddr_m[12] =  rwaddr_enc[3] & rwaddr_dcd_part[4] ;
assign baddr_m[13] =  rwaddr_enc[3] & rwaddr_dcd_part[5] ;
assign baddr_m[14] =  rwaddr_enc[3] & rwaddr_dcd_part[6] ;
assign baddr_m[15] =  rwaddr_enc[3] & rwaddr_dcd_part[7] ;
*/
// Byte Address to start write from. Quantity can be byte/hword/word/dword.
// E-stage decoding for write to cache.

wire	[3:0]	waddr_enc ;
wire	[7:0]	waddr_dcd_part ;
wire	[15:0]	waddr_dcd ;

assign  waddr_dcd_part[0]  = ~waddr_enc[2] & ~waddr_enc[1] & ~waddr_enc[0] ; 
assign  waddr_dcd_part[1]  = ~waddr_enc[2] & ~waddr_enc[1] &  waddr_enc[0] ; 
assign  waddr_dcd_part[2]  = ~waddr_enc[2] &  waddr_enc[1] & ~waddr_enc[0] ; 
assign  waddr_dcd_part[3]  = ~waddr_enc[2] &  waddr_enc[1] &  waddr_enc[0] ; 
assign  waddr_dcd_part[4]  =  waddr_enc[2] & ~waddr_enc[1] & ~waddr_enc[0] ; 
assign  waddr_dcd_part[5]  =  waddr_enc[2] & ~waddr_enc[1] &  waddr_enc[0] ; 
assign  waddr_dcd_part[6]  =  waddr_enc[2] &  waddr_enc[1] & ~waddr_enc[0] ; 
assign  waddr_dcd_part[7]  =  waddr_enc[2] &  waddr_enc[1] &  waddr_enc[0] ; 

assign  waddr_dcd[0]  = ~waddr_enc[3] & waddr_dcd_part[0] ;
assign  waddr_dcd[1]  = ~waddr_enc[3] & waddr_dcd_part[1] ;
assign  waddr_dcd[2]  = ~waddr_enc[3] & waddr_dcd_part[2] ;
assign  waddr_dcd[3]  = ~waddr_enc[3] & waddr_dcd_part[3] ;
assign  waddr_dcd[4]  = ~waddr_enc[3] & waddr_dcd_part[4] ; 
assign  waddr_dcd[5]  = ~waddr_enc[3] & waddr_dcd_part[5] ;
assign  waddr_dcd[6]  = ~waddr_enc[3] & waddr_dcd_part[6] ;
assign  waddr_dcd[7]  = ~waddr_enc[3] & waddr_dcd_part[7] ;
assign  waddr_dcd[8]  =  waddr_enc[3] & waddr_dcd_part[0] ;
assign  waddr_dcd[9]  =  waddr_enc[3] & waddr_dcd_part[1] ;
assign  waddr_dcd[10] =  waddr_enc[3] & waddr_dcd_part[2] ;
assign  waddr_dcd[11] =  waddr_enc[3] & waddr_dcd_part[3] ;
assign  waddr_dcd[12] =  waddr_enc[3] & waddr_dcd_part[4] ;
assign  waddr_dcd[13] =  waddr_enc[3] & waddr_dcd_part[5] ;
assign  waddr_dcd[14] =  waddr_enc[3] & waddr_dcd_part[6] ;
assign  waddr_dcd[15] =  waddr_enc[3] & waddr_dcd_part[7] ;

// Byte enables for 16 bytes.
   //bug6216/eco6624
   wire write_16byte_e;
   assign write_16byte_e = l2fill_vld_e | lsu_bist_wvld_e;
    
assign byte_wr_enable[15] = 
    write_16byte_e  |   waddr_dcd[0] ;    
assign byte_wr_enable[14] = 
    write_16byte_e  |   waddr_dcd[1]    |   
    (wr_hword & waddr_dcd[0])  |   (wr_word & waddr_dcd[0]) |
    (wr_dword & waddr_dcd[0])  ;     
assign byte_wr_enable[13] = 
    write_16byte_e  |   waddr_dcd[2]    |
    (wr_word & waddr_dcd[0]) |     (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[12] = 
    write_16byte_e  |   waddr_dcd[3]    |
    (wr_hword & waddr_dcd[2])  |   (wr_word & waddr_dcd[0]) |
    (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[11] = 
    write_16byte_e  |   waddr_dcd[4]    |     
    (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[10] = 
    write_16byte_e  |   waddr_dcd[5]    |
    (wr_hword & waddr_dcd[4])  |   (wr_word & waddr_dcd[4]) |
    (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[9] = 
    write_16byte_e  |   waddr_dcd[6]    |
    (wr_word & waddr_dcd[4]) |     (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[8] = 
    write_16byte_e  |   waddr_dcd[7]    |
    (wr_hword & waddr_dcd[6])  |   (wr_word & waddr_dcd[4]) |
    (wr_dword & waddr_dcd[0])  ;   
assign byte_wr_enable[7] = 
    write_16byte_e  |   waddr_dcd[8] ;    
assign byte_wr_enable[6] = 
    write_16byte_e  |   waddr_dcd[9]    |   
    (wr_hword & waddr_dcd[8])  |   (wr_word & waddr_dcd[8]) |
    (wr_dword & waddr_dcd[8])  ;     
assign byte_wr_enable[5] = 
    write_16byte_e  |   waddr_dcd[10]   |
    (wr_word & waddr_dcd[8]) |     (wr_dword & waddr_dcd[8])  ;   
assign byte_wr_enable[4] = 
    write_16byte_e  |   waddr_dcd[11]   |
    (wr_hword & waddr_dcd[10]) |   (wr_word & waddr_dcd[8]) |
    (wr_dword & waddr_dcd[8])  ;   
assign byte_wr_enable[3] = 
    write_16byte_e  |   waddr_dcd[12]   |     
    (wr_dword & waddr_dcd[8])  ;   
assign byte_wr_enable[2] = 
    write_16byte_e  |   waddr_dcd[13]   |
    (wr_hword & waddr_dcd[12]) |   (wr_word & waddr_dcd[12])  |
    (wr_dword & waddr_dcd[8])  ;   
assign byte_wr_enable[1] = 
    write_16byte_e  |   waddr_dcd[14]   |
    (wr_word & waddr_dcd[12])  |   (wr_dword & waddr_dcd[8])  ;   
assign byte_wr_enable[0] = 
    write_16byte_e  |   waddr_dcd[15]   |
    (wr_hword & waddr_dcd[14]) |   (wr_word & waddr_dcd[12])  |
    (wr_dword & waddr_dcd[8])  ; 

assign  dcache_byte_wr_en_e[15:0] = byte_wr_enable[15:0] ;
//assign  lsu_st_byte_addr_g[15:0]  = byp_baddr_g[15:0] ;

//=========================================================================================
//  Sign/Zero-Extension
//=========================================================================================

dff_s #(1) stgm_msb (
       .din    ({lsu_l1hit_sign_extend_e}),
       .q      ({l1hit_sign_extend_m}),
       .clk    (clk),
       .se     (se),       .si (),          .so ()
       );  

dff_s #(1) stgg_msb (
       .din    ({l1hit_sign_extend_m}),
       .q      ({l1hit_sign_extend_g}),
       .clk    (clk),
       .se     (se),       .si (),          .so ()
       ); 


//wire [1:0] lsu_byp_misc_sz_g ;   

/*dff #(2) ff_lsu_byp_misc_sz_g (
        .din   (lsu_byp_misc_sz_m[1:0]),
        .q     (lsu_byp_misc_sz_g[1:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );  */

assign  misc_byte_m   = ~lsu_byp_misc_sz_m[1] & ~lsu_byp_misc_sz_m[0] ; // 00
assign  misc_hword_m  = ~lsu_byp_misc_sz_m[1] &  lsu_byp_misc_sz_m[0] ; // 01
assign  misc_word_m   =  lsu_byp_misc_sz_m[1] & ~lsu_byp_misc_sz_m[0] ; // 10
assign  misc_dword_m  =  lsu_byp_misc_sz_m[1] &  lsu_byp_misc_sz_m[0] ; // 11

wire    byp_byte_m,byp_hword_m,byp_word_m,byp_dword_m;
assign  byp_byte_m =  (ld_inst_vld_m) ?  byte_m :  misc_byte_m ;
assign  byp_hword_m = (ld_inst_vld_m) ? hword_m :  misc_hword_m ;
assign  byp_word_m =  (ld_inst_vld_m) ?  word_m :  misc_word_m ;
assign  byp_dword_m = (ld_inst_vld_m) ? dword_m :  misc_dword_m ;

/*assign  byp_byte_g =  (|lsu_irf_byp_data_src[2:1]) ? misc_byte_g : byte_g ;
assign  byp_hword_g = (|lsu_irf_byp_data_src[2:1]) ? misc_hword_g : hword_g ;
assign  byp_word_g =  (|lsu_irf_byp_data_src[2:1]) ? misc_word_g : word_g ;*/

dff_s #(1) bypsz_stgg(
        .din   ({byp_word_m}),
        .q     ({byp_word_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//wire [3:0]	misc_waddr_m ; 
//assign  misc_waddr_m[3:0] = {lsu_byp_misc_addr_m[3],lsu_byp_misc_addr_m[2]^lsu_byp_ldd_oddrd_m,lsu_byp_misc_addr_m[1:0]} ;

wire [2:0]	misc_waddr_m ; 
assign  misc_waddr_m[2:0] = {lsu_byp_misc_addr_m[2]^lsu_byp_ldd_oddrd_m,lsu_byp_misc_addr_m[1:0]} ;
   
//wire    [15:0] misc_baddr_m ;
wire    [7:0] misc_baddr_m ;

// m-stage decoding
// Might be better to stage encoded waddr, mux and then decode.
/*
assign  misc_baddr_m[0] = ~misc_waddr_m[3] & ~misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[1] = ~misc_waddr_m[3] & ~misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[2] = ~misc_waddr_m[3] & ~misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[3] = ~misc_waddr_m[3] & ~misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[4] = ~misc_waddr_m[3] &  misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[5] = ~misc_waddr_m[3] &  misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[6] = ~misc_waddr_m[3] &  misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[7] = ~misc_waddr_m[3] &  misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[8] =  misc_waddr_m[3] & ~misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[9] =  misc_waddr_m[3] & ~misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[10] =  misc_waddr_m[3] & ~misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[11] =  misc_waddr_m[3] & ~misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[12] =  misc_waddr_m[3] &  misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[13] =  misc_waddr_m[3] &  misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[14] =  misc_waddr_m[3] &  misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[15] =  misc_waddr_m[3] &  misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
*/
assign  misc_baddr_m[0] = ~misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[1] = ~misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[2] = ~misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[3] = ~misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[4] =  misc_waddr_m[2] & ~misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[5] =  misc_waddr_m[2] & ~misc_waddr_m[1] &  misc_waddr_m[0] ; 
assign  misc_baddr_m[6] =  misc_waddr_m[2] &  misc_waddr_m[1] & ~misc_waddr_m[0] ; 
assign  misc_baddr_m[7] =  misc_waddr_m[2] &  misc_waddr_m[1] &  misc_waddr_m[0] ; 
   
//wire [15:0] byp_baddr_m ;
//assign  byp_baddr_m[15:0] = (~(ld_inst_vld_m | st_inst_vld_m)) ? misc_baddr_m[15:0] : baddr_m[15:0] ;
wire [7:0] byp_baddr_m ;
assign  byp_baddr_m[7:0] = (~(ld_inst_vld_m | st_inst_vld_m)) ? misc_baddr_m[7:0] : baddr_m[7:0] ;

   wire l2fill_sign_extend_m;
   
assign  l2fill_sign_extend_m = lsu_l2fill_sign_extend_m ;
//?? why need st ??
assign  signed_ldst_m = (ld_inst_vld_m | st_inst_vld_m) ?
                         l1hit_sign_extend_m : l2fill_sign_extend_m ; 

//assign  unsigned_ldst_m = ~signed_ldst_m ;

   assign signed_ldst_byte_m = signed_ldst_m & byp_byte_m;
//   assign unsigned_ldst_byte_m = unsigned_ldst_m & byp_byte_m;

   assign signed_ldst_hw_m = signed_ldst_m & ( byp_byte_m | byp_hword_m );
//   assign unsigned_ldst_hw_m = unsigned_ldst_m & ( byp_byte_m | byp_hword_m );
 
   assign signed_ldst_w_m = signed_ldst_m & ( byp_byte_m | byp_hword_m | byp_word_m );
//   assign unsigned_ldst_w_m = unsigned_ldst_m & ( byp_byte_m | byp_hword_m | byp_word_m );
   
//C assign  align_bytes_msb[7:0] = (ld_inst_vld_unflushed | st_inst_vld_unflushed) ? lsu_l1hit_bytes_msb_g[7:0] :
//C	(l2fill_vld_g ? l2fill_bytes_msb_g[7:0] : lsu_misc_bytes_msb_g[7:0])  ;

//assign  align_bytes_msb[7:0] = (ld_inst_vld_unflushed | st_inst_vld_unflushed) ? lsu_l1hit_bytes_msb_g[7:0] :
//    (lsu_irf_byp_data_src[2] ? lsu_misc_bytes_msb_g[7:0] : l2fill_bytes_msb_g[7:0])  ;


// For little-endian accesses, the following morphing must occur to the byte addr.
//
// Byte Addr(lower 3b)  
//  000(0)  ->  001(1) (hw)
//    ->  011(3) (w)
//    ->  111(7) (dw)
//  001(1)  ->  not morphed
//  010(2)  ->  011(3) (hw)
//  011(3)  ->  not morphed
//  100(4)  ->  101(5) (hw)
//    ->  111(7) (w)
//  101(5)  ->  not morphed
//  110(6)  ->  111(7) (hw)
//  111(7)  ->  not morphed

wire  [7:0] merged_addr_m ;   
wire  [7:0] morphed_addr_m ;    

//wire  bendian ;

//assign  merged_addr_m[7:0] = byp_baddr_m[15:8] | byp_baddr_m[7:0] ;
assign  merged_addr_m[7:0] = byp_baddr_m[7:0] ;

assign  morphed_addr_m[0] 
  =  merged_addr_m[0] & ~(~bendian_pred_m & ~byp_byte_m) ;
assign  morphed_addr_m[1] 
  =  merged_addr_m[1] | (merged_addr_m[0] & ~bendian_pred_m & byp_hword_m) ;
assign  morphed_addr_m[2] 
  =  merged_addr_m[2] & ~(~bendian_pred_m & byp_hword_m) ;
assign  morphed_addr_m[3] 
  =  merged_addr_m[3] | (merged_addr_m[0] & ~bendian_pred_m & byp_word_m) |
  (merged_addr_m[2] & ~bendian_pred_m & byp_hword_m) ;
assign  morphed_addr_m[4] 
  =  merged_addr_m[4] & ~(~bendian_pred_m & (byp_hword_m | byp_word_m)) ;
assign  morphed_addr_m[5] 
  =  merged_addr_m[5] | (merged_addr_m[4] & ~bendian_pred_m & byp_hword_m) ;
assign  morphed_addr_m[6] 
  =  merged_addr_m[6] & ~(~bendian_pred_m & byp_hword_m) ;
assign  morphed_addr_m[7] 
  =  merged_addr_m[7] | (merged_addr_m[0] & ~bendian_pred_m & ~(byp_byte_m | byp_hword_m | byp_word_m))  |
  (merged_addr_m[4] & ~bendian_pred_m & byp_word_m) | (merged_addr_m[6] & ~bendian_pred_m & byp_hword_m) ;


   
   
//=========================================================================================
//  ALIGNMENT CONTROL FOR DCDP 
//=========================================================================================

// First generate control for swapping related to endianness.
// byte7-byte0 is source data from cache etc.
// swap7-swap0 is result of endianness swapping.

// First logical level - Swapping of bytes. 
// Swap byte 0 

wire  swap0_sel_byte0, swap0_sel_byte1, swap0_sel_byte3  ;
wire  swap1_sel_byte0, swap1_sel_byte1, swap1_sel_byte2, swap1_sel_byte6 ;
wire  swap2_sel_byte1, swap2_sel_byte2, swap2_sel_byte3, swap2_sel_byte5 ;
wire  swap3_sel_byte0, swap3_sel_byte2, swap3_sel_byte3, swap3_sel_byte4 ;
wire  swap4_sel_byte3, swap4_sel_byte4, swap4_sel_byte5 ;
wire  swap5_sel_byte2, swap5_sel_byte4, swap5_sel_byte5, swap5_sel_byte6 ;
wire  swap6_sel_byte1, swap6_sel_byte5, swap6_sel_byte6 ;
wire  swap7_sel_byte0, swap7_sel_byte4, swap7_sel_byte6, swap7_sel_byte7 ;

//assign  bendian = bendian_pred_m ;
//assign  bendian = lsu_bendian_access_g ;

assign  swap0_sel_byte0   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap0_sel_byte1   = ~bendian_pred_m & byp_hword_m ;
assign  swap0_sel_byte3   = ~bendian_pred_m & byp_word_m ;
// could be substituted with dword encoding.
//assign  swap0_sel_byte7   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;

// Swap byp_byte_m 1 
assign  swap1_sel_byte0   = ~bendian_pred_m & byp_hword_m ;
assign  swap1_sel_byte1   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap1_sel_byte2   = ~bendian_pred_m & byp_word_m ;
assign  swap1_sel_byte6   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;

// Swap byp_byte_m 2 
assign  swap2_sel_byte1   = ~bendian_pred_m & byp_word_m ;
assign  swap2_sel_byte2   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap2_sel_byte3   = ~bendian_pred_m & byp_hword_m ;
assign  swap2_sel_byte5   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;

// Swap byp_byte_m 3 
assign  swap3_sel_byte0   = ~bendian_pred_m & byp_word_m ;
assign  swap3_sel_byte2   = ~bendian_pred_m & byp_hword_m ;
assign  swap3_sel_byte3   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap3_sel_byte4   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;

// Swap byp_byte_m 4 
assign  swap4_sel_byte3   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;
assign  swap4_sel_byte4   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap4_sel_byte5   = ~bendian_pred_m & byp_hword_m ;
//assign  swap4_sel_byte7   = ~bendian_pred_m & byp_word_m ;

// Swap byp_byte_m 5 
assign  swap5_sel_byte2   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;
assign  swap5_sel_byte4   = ~bendian_pred_m & byp_hword_m ;
assign  swap5_sel_byte5   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
assign  swap5_sel_byte6   = ~bendian_pred_m & byp_word_m ;

// Swap byp_byte_m 6 
assign  swap6_sel_byte1   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;
assign  swap6_sel_byte5   = ~bendian_pred_m & byp_word_m ;
assign  swap6_sel_byte6   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;
//assign  swap6_sel_byte7   = ~bendian_pred_m & byp_hword_m ;

// Swap byp_byte_m 7 
assign  swap7_sel_byte0   = ~bendian_pred_m & ~(byp_word_m | byp_hword_m | byp_byte_m) ;
assign  swap7_sel_byte4   = ~bendian_pred_m & byp_word_m ;
assign  swap7_sel_byte6   = ~bendian_pred_m & byp_hword_m ;
assign  swap7_sel_byte7   = bendian_pred_m | (~bendian_pred_m & byp_byte_m) ;

// 2nd logical level - Alignment. 
// rjust7-rjust0 is result of alignment operation.
// sbyte7-sbyte0 is the result of the endian swapping from the 1st logic level.

wire  rjust0_sel_sbyte0, rjust0_sel_sbyte1, rjust0_sel_sbyte2, rjust0_sel_sbyte3 ;
wire  rjust0_sel_sbyte4, rjust0_sel_sbyte5, rjust0_sel_sbyte6, rjust0_sel_sbyte7 ;
wire  rjust1_sel_sbyte1, rjust1_sel_sbyte3, rjust1_sel_sbyte5, rjust1_sel_sbyte7 ;
wire  rjust2_sel_sbyte2, rjust2_sel_sbyte6 ;
wire  rjust3_sel_sbyte3, rjust3_sel_sbyte7 ;

// Aligned Byte 0
assign  rjust0_sel_sbyte0   = 
  ~(rjust0_sel_sbyte1 | rjust0_sel_sbyte2 | rjust0_sel_sbyte3 |
    rjust0_sel_sbyte4 | rjust0_sel_sbyte5 | rjust0_sel_sbyte6 |
    rjust0_sel_sbyte7) ;
assign  rjust0_sel_sbyte1   = 
//  ((byp_baddr_m[14] | byp_baddr_m[6]) & byp_byte_m) ;
  ((byp_baddr_m[6]) & byp_byte_m) ;

assign  rjust0_sel_sbyte2   = 
//  ((byp_baddr_m[12] | byp_baddr_m[4]) & byp_hword_m) | 
  ((byp_baddr_m[4]) & byp_hword_m) | 
//  ((byp_baddr_m[13] | byp_baddr_m[5]) & byp_byte_m) ;
  ((byp_baddr_m[5]) & byp_byte_m) ;
assign  rjust0_sel_sbyte3 = 
//  (byp_baddr_m[12] | byp_baddr_m[4]) & byp_byte_m ; 
  (byp_baddr_m[4]) & byp_byte_m ; 
assign  rjust0_sel_sbyte4 = 
//  ((byp_baddr_m[10] | byp_baddr_m[2]) & byp_hword_m) | 
//  ((byp_baddr_m[11] | byp_baddr_m[3]) & byp_byte_m) |
//  ((byp_baddr_m[8] | byp_baddr_m[0]) & byp_word_m) ;
  ((byp_baddr_m[2]) & byp_hword_m) | 
  ((byp_baddr_m[3]) & byp_byte_m) |
  ((byp_baddr_m[0]) & byp_word_m) ;
assign  rjust0_sel_sbyte5 = 
//  ((byp_baddr_m[10] | byp_baddr_m[2]) & byp_byte_m) ; 
  ((byp_baddr_m[2]) & byp_byte_m) ; 
assign  rjust0_sel_sbyte6 = 
//  ((byp_baddr_m[8] | byp_baddr_m[0]) & byp_hword_m) | 
//  ((byp_baddr_m[9] | byp_baddr_m[1]) & byp_byte_m) ;
  ((byp_baddr_m[0]) & byp_hword_m) | 
  ((byp_baddr_m[1]) & byp_byte_m) ;
assign  rjust0_sel_sbyte7 = 
//  (byp_baddr_m[8] | byp_baddr_m[0]) & byp_byte_m ;
  (byp_baddr_m[0]) & byp_byte_m ;

// Aligned Byte 1
assign  rjust1_sel_sbyte1   = 
  ~(rjust1_sel_sbyte3 | rjust1_sel_sbyte5 | rjust1_sel_sbyte7) ;
assign  rjust1_sel_sbyte3   = 
//  (byp_baddr_m[12] | byp_baddr_m[4]) & byp_hword_m ;
  (byp_baddr_m[4]) & byp_hword_m ;
assign  rjust1_sel_sbyte5   = 
//  ((byp_baddr_m[10] | byp_baddr_m[2]) & byp_hword_m) | 
//  ((byp_baddr_m[8] | byp_baddr_m[0]) & byp_word_m) ;
  ((byp_baddr_m[2]) & byp_hword_m) | 
  ((byp_baddr_m[0]) & byp_word_m) ;
assign  rjust1_sel_sbyte7   = 
//  (byp_baddr_m[8] | byp_baddr_m[0]) & byp_hword_m ;
  (byp_baddr_m[0]) & byp_hword_m ;

// Aligned Byte 2
assign  rjust2_sel_sbyte2   = ~rjust2_sel_sbyte6 ;
//assign  rjust2_sel_sbyte6   = (byp_baddr_m[8] | byp_baddr_m[0]) & byp_word_m ;
assign  rjust2_sel_sbyte6   = (byp_baddr_m[0]) & byp_word_m ;

// Aligned Byte 3
assign  rjust3_sel_sbyte3   = ~rjust3_sel_sbyte7 ;
//assign  rjust3_sel_sbyte7   = (byp_baddr_m[8] | byp_baddr_m[0]) & byp_word_m ;
assign  rjust3_sel_sbyte7   = (byp_baddr_m[0]) & byp_word_m ;

// 3rd logical level - Complete alignment. Sign-Extension/Zero-Extension.
// merge7-merge0 corresponds to cumulative swapping and alignment result.
// byte[7]-byte[0] refers to the original pre-swap/alignment data.

wire merge7_sel_byte0_m, merge7_sel_byte7_m;
wire merge6_sel_byte1_m, merge6_sel_byte6_m;
wire merge5_sel_byte2_m, merge5_sel_byte5_m;
wire merge4_sel_byte3_m, merge4_sel_byte4_m;
wire merge3_sel_byte0_m, merge3_sel_byte3_m;
wire merge3_sel_byte4_m, merge3_sel_byte7_m,merge3_sel_byte_m;
wire merge2_sel_byte1_m, merge2_sel_byte2_m, merge2_sel_byte5_m;
wire merge2_sel_byte6_m, merge2_sel_byte_m;
wire merge0_sel_byte0_m, merge0_sel_byte1_m;
wire merge0_sel_byte2_m, merge0_sel_byte3_m;
wire merge0_sel_byte4_m, merge0_sel_byte5_m;
wire merge0_sel_byte6_m;
wire merge1_sel_byte0_m, merge1_sel_byte1_m;
wire merge1_sel_byte2_m, merge1_sel_byte3_m;
wire merge1_sel_byte4_m, merge1_sel_byte5_m;
wire merge1_sel_byte6_m, merge1_sel_byte7_m;
wire merge0_sel_byte_1h_m,merge1_sel_byte_1h_m, merge1_sel_byte_2h_m;

// Final Merged Byte 0
assign  merge0_sel_byte0_m  = 
  (rjust0_sel_sbyte0 & swap0_sel_byte0) |
  (rjust0_sel_sbyte1 & swap1_sel_byte0) |
  (rjust0_sel_sbyte3 & swap3_sel_byte0) |
  (rjust0_sel_sbyte7 & swap7_sel_byte0) ;

assign  merge0_sel_byte1_m  = 
  (rjust0_sel_sbyte0 & swap0_sel_byte1) |
  (rjust0_sel_sbyte1 & swap1_sel_byte1) |
  (rjust0_sel_sbyte2 & swap2_sel_byte1) |
  (rjust0_sel_sbyte6 & swap6_sel_byte1) ;

assign  merge0_sel_byte2_m  = 
  (rjust0_sel_sbyte1 & swap1_sel_byte2) |
  (rjust0_sel_sbyte2 & swap2_sel_byte2) |
  (rjust0_sel_sbyte3 & swap3_sel_byte2) |
  (rjust0_sel_sbyte5 & swap5_sel_byte2) ;

   
assign  merge0_sel_byte3_m  = 
  (rjust0_sel_sbyte0 & swap0_sel_byte3) |
  (rjust0_sel_sbyte2 & swap2_sel_byte3) |
  (rjust0_sel_sbyte3 & swap3_sel_byte3) |
  (rjust0_sel_sbyte4 & swap4_sel_byte3) ;

assign merge0_sel_byte3_default_m = ~ (merge0_sel_byte0_m | merge0_sel_byte1_m | merge0_sel_byte2_m);

assign  merge0_sel_byte4_m  = 
  (rjust0_sel_sbyte3 & swap3_sel_byte4) |
  (rjust0_sel_sbyte4 & swap4_sel_byte4) |
  (rjust0_sel_sbyte5 & swap5_sel_byte4) |
  (rjust0_sel_sbyte7 & swap7_sel_byte4) ;

assign  merge0_sel_byte5_m  = 
  (rjust0_sel_sbyte2 & swap2_sel_byte5) |
  (rjust0_sel_sbyte4 & swap4_sel_byte5) |
  (rjust0_sel_sbyte5 & swap5_sel_byte5) |
  (rjust0_sel_sbyte6 & swap6_sel_byte5) ;

assign  merge0_sel_byte6_m  = 
  (rjust0_sel_sbyte1 & swap1_sel_byte6) |
  (rjust0_sel_sbyte5 & swap5_sel_byte6) |
  (rjust0_sel_sbyte6 & swap6_sel_byte6) |
  (rjust0_sel_sbyte7 & swap7_sel_byte6) ;

//assign  merge0_sel_byte7_m  = 
//  (rjust0_sel_sbyte0 & swap0_sel_byte7) |
//  (rjust0_sel_sbyte4 & swap4_sel_byte7) |
//  (rjust0_sel_sbyte6 & swap6_sel_byte7) |
//  (rjust0_sel_sbyte7 & swap7_sel_byte7) ;

   assign merge0_sel_byte7_default_m = ~(merge0_sel_byte4_m | merge0_sel_byte5_m |  merge0_sel_byte6_m);
   
assign  merge0_sel_byte_1h_m = 
  merge0_sel_byte0_m |  merge0_sel_byte1_m | merge0_sel_byte2_m | merge0_sel_byte3_m ;

// Final Merged Byte 1
assign  merge1_sel_byte0_m  = 
  (rjust1_sel_sbyte1 & swap1_sel_byte0) |
  (rjust1_sel_sbyte3 & swap3_sel_byte0) |
  (rjust1_sel_sbyte7 & swap7_sel_byte0) ;

assign  merge1_sel_byte1_m  = 
  (rjust1_sel_sbyte1 & swap1_sel_byte1) ;

assign  merge1_sel_byte2_m  = 
  (rjust1_sel_sbyte1 & swap1_sel_byte2) |
  (rjust1_sel_sbyte3 & swap3_sel_byte2) |
  (rjust1_sel_sbyte5 & swap5_sel_byte2) ;

assign  merge1_sel_byte3_m  = 
  (rjust1_sel_sbyte3 & swap3_sel_byte3) ;

   assign merge1_sel_byte3_default_m = ~( merge1_sel_byte0_m | merge1_sel_byte1_m | merge1_sel_byte2_m);
                                              
assign  merge1_sel_byte4_m  = 
  (rjust1_sel_sbyte3 & swap3_sel_byte4) |
  (rjust1_sel_sbyte5 & swap5_sel_byte4) |
  (rjust1_sel_sbyte7 & swap7_sel_byte4) ;

assign  merge1_sel_byte5_m  = 
  (rjust1_sel_sbyte5 & swap5_sel_byte5) ;

assign  merge1_sel_byte6_m  = 
  (rjust1_sel_sbyte1 & swap1_sel_byte6) |
  (rjust1_sel_sbyte5 & swap5_sel_byte6) |
  (rjust1_sel_sbyte7 & swap7_sel_byte6) ;

assign  merge1_sel_byte7_m  = 
  (rjust1_sel_sbyte7 & swap7_sel_byte7) ;

   assign merge1_sel_byte7_default_m = ~( merge1_sel_byte4_m | merge1_sel_byte5_m | merge1_sel_byte6_m);
   
assign  merge1_sel_byte_1h_m = ~byp_byte_m &
  (merge1_sel_byte0_m |  merge1_sel_byte1_m | merge1_sel_byte2_m | merge1_sel_byte3_m) ;
   
assign  merge1_sel_byte_2h_m = ~byp_byte_m &
  (merge1_sel_byte4_m |  merge1_sel_byte5_m | merge1_sel_byte6_m | merge1_sel_byte7_m) ;


// Final Merged Byte 2

assign  merge2_sel_byte1_m  = 
  (rjust2_sel_sbyte2 & swap2_sel_byte1) |
  (rjust2_sel_sbyte6 & swap6_sel_byte1) ;

assign  merge2_sel_byte2_m  = 
  (rjust2_sel_sbyte2 & swap2_sel_byte2) ;

assign  merge2_sel_byte5_m  = 
  (rjust2_sel_sbyte2 & swap2_sel_byte5) |
  (rjust2_sel_sbyte6 & swap6_sel_byte5) ;

assign  merge2_sel_byte6_m  = 
  (rjust2_sel_sbyte6 & swap6_sel_byte6) ;

   assign merge2_sel_byte6_default_m  = ~(merge2_sel_byte1_m | merge2_sel_byte2_m | merge2_sel_byte5_m);
    
assign merge2_sel_byte_m = ~byp_byte_m & ~byp_hword_m &
(merge2_sel_byte1_m | merge2_sel_byte2_m | merge2_sel_byte5_m | merge2_sel_byte6_m);   

// Final Merged Byte 3
assign  merge3_sel_byte0_m  = 
  (rjust3_sel_sbyte3 & swap3_sel_byte0) |
  (rjust3_sel_sbyte7 & swap7_sel_byte0) ;

assign  merge3_sel_byte3_m  = 
  (rjust3_sel_sbyte3 & swap3_sel_byte3) ;

assign  merge3_sel_byte4_m  = 
  (rjust3_sel_sbyte3 & swap3_sel_byte4) |
  (rjust3_sel_sbyte7 & swap7_sel_byte4) ;

assign  merge3_sel_byte7_m  = 
  (rjust3_sel_sbyte7 & swap7_sel_byte7) ;

assign merge3_sel_byte7_default_m  =  ~(merge3_sel_byte0_m | merge3_sel_byte3_m | merge3_sel_byte4_m);

assign merge3_sel_byte_m = ~byp_byte_m & ~byp_hword_m & 
(merge3_sel_byte0_m | merge3_sel_byte3_m | merge3_sel_byte4_m | merge3_sel_byte7_m);
   
// Final Merged Byte 4
assign  merge4_sel_byte3_m = byp_dword_m & swap4_sel_byte3 ;
assign  merge4_sel_byte4_m = byp_dword_m & swap4_sel_byte4 ;


// Final Merged Byte 5
assign  merge5_sel_byte2_m = byp_dword_m & swap5_sel_byte2 ;
assign  merge5_sel_byte5_m = byp_dword_m & swap5_sel_byte5 ;

// Final Merged Byte 6
assign  merge6_sel_byte1_m = byp_dword_m & swap6_sel_byte1 ;
assign  merge6_sel_byte6_m = byp_dword_m & swap6_sel_byte6 ;

// Final Merged Byte 7
assign  merge7_sel_byte0_m = byp_dword_m & swap7_sel_byte0 ;
assign  merge7_sel_byte7_m = byp_dword_m & swap7_sel_byte7 ;



//=========================================================================================
//  STQ/CAS 2ND PKT FORMATTING 
//=========================================================================================

// stq and cas write to an extra buffer. stq always uses a full 64bits.
// cas may use either 64b or 32b. stq requires at most endian alignment.
// cas may require both address and endian alignment.

// Byte Alignment. Assume 8 bytes, 7-0
//  Case 1 : 7,6,5,4,3,2,1,0 
//  Case 2 : 3,2,1,0,0,1,2,3 
//  Case 3 : 0,1,2,3,4,5,6,7  

wire casa_wd_g ;
assign  casa_wd_g = casa_g & byp_word_g ;
wire casa_dwd_g ;
assign  casa_dwd_g = casa_g & ~byp_word_g ;

// Change bendian to bendian_g - should not be dependent on fill. 

//assign  lsu_atomic_pkt2_bsel_g[2] =   // Case 1
//  (casa_dwd_g &  bendian_g)   |  // bendian stq and dw cas
//  (casa_wd_g &  bendian_g &  ldst_va_g[2]) ;  // bendian_g wd casa addr to uhalf

assign lsu_atomic_pkt2_bsel_g[2] = ~| (lsu_atomic_pkt2_bsel_g[1:0]) | rst_tri_en ; //one-hot default

assign  lsu_atomic_pkt2_bsel_g[1] =   // Case 2
  ((casa_wd_g &  bendian_g & ~ldst_va_g[2]) |  // bendian_g wd casa addr to lhalf
  (casa_wd_g & ~bendian_g &  ldst_va_g[2])) &  ~rst_tri_en ;  // lendian wd casa addr to uhalf
assign  lsu_atomic_pkt2_bsel_g[0] =   // Case 3 
  ((casa_dwd_g & ~bendian_g) |    // lendian stq and dw cas
  (casa_wd_g & ~bendian_g & ~ldst_va_g[2])) &  ~rst_tri_en ;  // lendian wd cas addr to lhalf

// Alignment done in qdp1

//=========================================================================================
//  ASI DECODE
//=========================================================================================

// Note : tlb_byp_asi same as phy_use/phy_byp asi.


lsu_asi_decode asi_decode (/*AUTOINST*/
                           // Outputs
                           .asi_internal_d(asi_internal_d),
                           .nucleus_asi_d(nucleus_asi_d),
                           .primary_asi_d(primary_asi_d),
                           .secondary_asi_d(secondary_asi_d),
                           .lendian_asi_d(lendian_asi_d),
                           .nofault_asi_d(nofault_asi_d),
                           .quad_asi_d  (quad_asi_d),
                           .binit_quad_asi_d(binit_quad_asi_d),
                           .dcache_byp_asi_d(dcache_byp_asi_d),
                           .tlb_lng_ltncy_asi_d(tlb_lng_ltncy_asi_d),
                           .tlb_byp_asi_d(tlb_byp_asi_d),
                           .as_if_user_asi_d(as_if_user_asi_d),
                           .atomic_asi_d(atomic_asi_d),
                           .blk_asi_d   (blk_asi_d),
                           .dc_diagnstc_asi_d(dc_diagnstc_asi_d),
                           .dtagv_diagnstc_asi_d(dtagv_diagnstc_asi_d),
                           .wr_only_asi_d(wr_only_asi_d),
                           .rd_only_asi_d(rd_only_asi_d),
                           .unimp_asi_d (unimp_asi_d),
                           .ifu_nontlb_asi_d(ifu_nontlb_asi_d),
                           .recognized_asi_d(recognized_asi_d),
                           .ifill_tlb_asi_d(ifill_tlb_asi_d),
                           .dfill_tlb_asi_d(dfill_tlb_asi_d),
                           .rd_only_ltlb_asi_d(rd_only_ltlb_asi_d),
                           .wr_only_ltlb_asi_d(wr_only_ltlb_asi_d),
                           .phy_use_ec_asi_d(phy_use_ec_asi_d),
                           .phy_byp_ec_asi_d(phy_byp_ec_asi_d),
                           .mmu_rd_only_asi_d(mmu_rd_only_asi_d),
                           .intrpt_disp_asi_d(intrpt_disp_asi_d),
                           .dmmu_asi58_d(dmmu_asi58_d),
                           .immu_asi50_d(immu_asi50_d),
                           // Inputs
                           .asi_d       (asi_d[7:0]));

dff_s #(31)  asidcd_stge (
        .din    ({asi_internal_d,primary_asi_d,secondary_asi_d,nucleus_asi_d,
    lendian_asi_d, tlb_byp_asi_d, dcache_byp_asi_d,nofault_asi_d,
    tlb_lng_ltncy_asi_d,as_if_user_asi_d,atomic_asi_d, blk_asi_d,
    dc_diagnstc_asi_d,dtagv_diagnstc_asi_d,
    wr_only_asi_d, rd_only_asi_d,mmu_rd_only_asi_d,unimp_asi_d,dmmu_asi58_d, immu_asi50_d, quad_asi_d, binit_quad_asi_d,
    ifu_nontlb_asi_d,recognized_asi_d, ifill_tlb_asi_d,
    dfill_tlb_asi_d, rd_only_ltlb_asi_d,wr_only_ltlb_asi_d,phy_use_ec_asi_d, phy_byp_ec_asi_d, intrpt_disp_asi_d}),
        .q      ({asi_internal_e,primary_asi_e,secondary_asi_e,nucleus_asi_e,
    lendian_asi_e, tlb_byp_asi_e, dcache_byp_asi_e,nofault_asi_e,
    tlb_lng_ltncy_asi_e,as_if_user_asi_e,atomic_asi_e, blk_asi_e,
    dc_diagnstc_asi_e,dtagv_diagnstc_asi_e,
    wr_only_asi_e, rd_only_asi_e,mmu_rd_only_asi_e,unimp_asi_e,dmmu_asi58_e, immu_asi50_e, quad_asi_e, binit_quad_asi_e,
    ifu_nontlb_asi_e,recognized_asi_e,ifill_tlb_asi_e,
    dfill_tlb_asi_e,rd_only_ltlb_asi_e,wr_only_ltlb_asi_e,phy_use_ec_asi_e, phy_byp_ec_asi_e, intrpt_disp_asi_e}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_ffu_blk_asi_e = blk_asi_e & alt_space_e;
assign  lsu_quad_asi_e = quad_asi_e ;

wire	unimp_asi_tmp ;
dff_s #(23)  asidcd_stgm (
        .din    ({asi_internal_e,dcache_byp_asi_e,nofault_asi_e,lendian_asi_e,tlb_lng_ltncy_asi_e,
    as_if_user_asi_e,atomic_asi_e, blk_asi_e,dc_diagnstc_asi_e,dtagv_diagnstc_asi_e,
    wr_only_asi_e, rd_only_asi_e,mmu_rd_only_asi_e,unimp_asi_e,dmmu_asi58_e, immu_asi50_e, quad_asi_e,binit_quad_asi_e,recognized_asi_e,
    ifu_nontlb_asi_e,phy_use_ec_asi_e, phy_byp_ec_asi_e, intrpt_disp_asi_e}),
        .q      ({asi_internal_m,dcache_byp_asi_m,nofault_asi_m,lendian_asi_m,tlb_lng_ltncy_asi_m,
    as_if_user_asi_m,atomic_asi_m, blk_asi_m,dc_diagnstc_asi_m,dtagv_diagnstc_asi_m,
    wr_only_asi_m, rd_only_asi_m,mmu_rd_only_asi_m,unimp_asi_tmp,dmmu_asi58_m, immu_asi50_m, quad_asi_m,binit_quad_asi_m,recognized_asi_tmp,
    ifu_nontlb_asi_m,phy_use_ec_asi_m, phy_byp_ec_asi_m, intrpt_disp_asi_m}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

assign	lsu_blk_asi_m = blk_asi_m ;

   wire	pa_wtchpt_unimp_m ; // Bug 3408
   wire d_tsb_unimp_m, i_tsb_unimp_m, pctxt_unimp_m, sctxt_unimp_m;
   wire unimp_m;
   
assign  pa_wtchpt_unimp_m  = dmmu_asi58_m & (lsu_ldst_va_b7_b0_m[7:0] == 8'h40);
assign  d_tsb_unimp_m = dmmu_asi58_m & (lsu_ldst_va_b7_b0_m[7:0] == 8'h28);
assign  pctxt_unimp_m = dmmu_asi58_m & (lsu_ldst_va_b7_b0_m[7:0] == 8'h8);   
assign  sctxt_unimp_m = dmmu_asi58_m & (lsu_ldst_va_b7_b0_m[7:0] == 8'h10);
assign  i_tsb_unimp_m = immu_asi50_m & (lsu_ldst_va_b7_b0_m[7:0] == 8'h28);
assign  unimp_m =  pa_wtchpt_unimp_m |  
                   d_tsb_unimp_m | i_tsb_unimp_m |
                   pctxt_unimp_m | sctxt_unimp_m;
   
assign	unimp_asi_m = unimp_asi_tmp | unimp_m ;
assign	recognized_asi_m = recognized_asi_tmp | unimp_m ;

dff_s #(12)  asidcd_stgg (
        .din    ({asi_internal_m,dcache_byp_asi_m, lendian_asi_m,tlb_lng_ltncy_asi_m,
  blk_asi_m,dc_diagnstc_asi_m,dtagv_diagnstc_asi_m,quad_asi_m,
  binit_quad_asi_m,recognized_asi_m,ifu_nontlb_asi_m,  intrpt_disp_asi_m}),
        .q      ({asi_internal_g,dcache_byp_asi_g, lendian_asi_g,tlb_lng_ltncy_asi_g,
  blk_asi_g,dc_diagnstc_asi_g,dtagv_diagnstc_asi_g,quad_asi_g,
  binit_quad_asi_g,recognized_asi_g,ifu_nontlb_asi_g,  intrpt_disp_asi_g}),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

//assign lsu_quad_asi_g = quad_asi_g;
assign  ncache_asild_rq_g   = dcache_byp_asi_g & altspace_ldst_g ;

//st data alignment control signals
wire st_sz_hw_g, st_sz_w_g, st_sz_dw_g, stdbl_g;
wire stdbl_m;

//assign stdbl_m =  ldst_dbl_m & (~lsu_alt_space_m | (lsu_alt_space_m & ~blk_asi_m)) ;
assign stdbl_m =  ldst_dbl_m ;
         
dff_s #(4) ff_st_sz_m (
  .din ({hw_size, wd_size, dw_size, stdbl_m }),
  .q   ({st_sz_hw_g, st_sz_w_g, st_sz_dw_g, stdbl_g}),
  .clk (clk),                   
  .se  (se), .si (), .so ()
);   

   
//assign	bendian = lsu_bendian_access_g ;	// bendian store

wire	swap_sel_default_g, swap_sel_default_byte_7_2_g, st_hw_le_g,st_w_or_dbl_le_g,st_x_le_g;
assign	bendian_g = ~l1hit_lendian_g ;
//assign	swap_sel_default_g = (bendian_g | (~bendian_g & st_sz_b_g)) ;

assign swap_sel_default_g = ~ (st_hw_le_g | st_w_or_dbl_le_g | st_x_le_g);
assign swap_sel_default_byte_7_2_g = ~ (st_w_or_dbl_le_g | st_x_le_g);
   
assign  st_hw_le_g = (st_sz_hw_g & ~bendian_g) & (~stdbl_g | fp_ldst_g) & st_inst_vld_unflushed ;  //0-in bug
//bug 3169 
// std(a) on floating point is the same as stx(a)
assign  st_w_or_dbl_le_g = ((st_sz_w_g | (stdbl_g & ~fp_ldst_g)) & ~bendian_g) &  st_inst_vld_unflushed ;
assign  st_x_le_g = (st_sz_dw_g & (~stdbl_g | fp_ldst_g)  & ~bendian_g) &  st_inst_vld_unflushed;

wire blkst_m_tmp ;
dff_s  stgm_bst (
  .din (ffu_lsu_blk_st_e),
  .q   (blkst_m_tmp),
  .clk (clk),
  .se     (se),       .si (),          .so ()
);

assign	blkst_m = blkst_m_tmp & ~(st_inst_vld_m  | flsh_inst_m 
		| ld_inst_vld_m) ; // Bug 3444

assign	lsu_blk_st_m = blkst_m ;

dff_s  stgg_bst (
  .din (blkst_m),
  .q   (blkst_g),
  .clk (clk),
  .se     (se),       .si (),          .so ()
);

wire	bst_swap_sel_default_g,	bst_swap_sel_default_byte_7_2_g,bst_st_hw_le_g,bst_st_w_or_dbl_le_g,bst_st_x_le_g;
assign	lsu_swap_sel_default_g = (blkst_g ? bst_swap_sel_default_g : swap_sel_default_g) | rst_tri_en ;
assign	lsu_swap_sel_default_byte_7_2_g = (blkst_g ? bst_swap_sel_default_byte_7_2_g : swap_sel_default_byte_7_2_g) 
                                         | rst_tri_en ;

assign	lsu_st_hw_le_g	= (blkst_g ? bst_st_hw_le_g : st_hw_le_g) & ~rst_tri_en ;
assign	lsu_st_w_or_dbl_le_g = (blkst_g ? bst_st_w_or_dbl_le_g : st_w_or_dbl_le_g) & ~rst_tri_en ;
assign	lsu_st_x_le_g = (blkst_g ? bst_st_x_le_g : st_x_le_g) & ~rst_tri_en ;


//=========================================================================================
//	BLK STORE
//=========================================================================================

// Blk-St Handling : Snap state in g-stage of issue from IFU.

wire snap_blk_st_m,snap_blk_st_g ;
assign snap_blk_st_m = st_inst_vld_m & blk_asi_m & lsu_alt_space_m & fp_ldst_m;

assign lsu_snap_blk_st_m = snap_blk_st_m ; 

wire	snap_blk_st_local_m;
assign	snap_blk_st_local_m = snap_blk_st_m & ifu_tlu_inst_vld_m ;

dff_s  stgg_snap (
  .din (snap_blk_st_local_m),
  .q   (snap_blk_st_g),
  .clk (clk),
  .se     (se),       .si (),          .so ()
);

// output to be used in g-stage.
dffe_s #(5) bst_state_g (
        .din    ({lsu_swap_sel_default_g, lsu_swap_sel_default_byte_7_2_g, lsu_st_hw_le_g,
		lsu_st_w_or_dbl_le_g,lsu_st_x_le_g}),
        .q      ({bst_swap_sel_default_g, bst_swap_sel_default_byte_7_2_g,  bst_st_hw_le_g,
		bst_st_w_or_dbl_le_g,bst_st_x_le_g}),
        .en     (snap_blk_st_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );


// snapped in g, used in m

   wire [39:10] blkst_pgnum_m;
   
dffe_s #(30) bst_pg_g (
        .din    (tlb_pgnum[39:10]),
        .q      (blkst_pgnum_m[39:10]),
        .en     (snap_blk_st_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );

bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b10 (.a(blkst_pgnum_m[10]), .z(lsu_blkst_pgnum_m[10]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b11 (.a(blkst_pgnum_m[11]), .z(lsu_blkst_pgnum_m[11]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b12 (.a(blkst_pgnum_m[12]), .z(lsu_blkst_pgnum_m[12]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b13 (.a(blkst_pgnum_m[13]), .z(lsu_blkst_pgnum_m[13]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b14 (.a(blkst_pgnum_m[14]), .z(lsu_blkst_pgnum_m[14]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b15 (.a(blkst_pgnum_m[15]), .z(lsu_blkst_pgnum_m[15]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b16 (.a(blkst_pgnum_m[16]), .z(lsu_blkst_pgnum_m[16]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b17 (.a(blkst_pgnum_m[17]), .z(lsu_blkst_pgnum_m[17]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b18 (.a(blkst_pgnum_m[18]), .z(lsu_blkst_pgnum_m[18]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b19 (.a(blkst_pgnum_m[19]), .z(lsu_blkst_pgnum_m[19]));

bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b20 (.a(blkst_pgnum_m[20]), .z(lsu_blkst_pgnum_m[20]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b21 (.a(blkst_pgnum_m[21]), .z(lsu_blkst_pgnum_m[21]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b22 (.a(blkst_pgnum_m[22]), .z(lsu_blkst_pgnum_m[22]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b23 (.a(blkst_pgnum_m[23]), .z(lsu_blkst_pgnum_m[23]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b24 (.a(blkst_pgnum_m[24]), .z(lsu_blkst_pgnum_m[24]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b25 (.a(blkst_pgnum_m[25]), .z(lsu_blkst_pgnum_m[25]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b26 (.a(blkst_pgnum_m[26]), .z(lsu_blkst_pgnum_m[26]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b27 (.a(blkst_pgnum_m[27]), .z(lsu_blkst_pgnum_m[27]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b28 (.a(blkst_pgnum_m[28]), .z(lsu_blkst_pgnum_m[28]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b29 (.a(blkst_pgnum_m[29]), .z(lsu_blkst_pgnum_m[29]));
   
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b30 (.a(blkst_pgnum_m[30]), .z(lsu_blkst_pgnum_m[30]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b31 (.a(blkst_pgnum_m[31]), .z(lsu_blkst_pgnum_m[31]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b32 (.a(blkst_pgnum_m[32]), .z(lsu_blkst_pgnum_m[32]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b33 (.a(blkst_pgnum_m[33]), .z(lsu_blkst_pgnum_m[33]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b34 (.a(blkst_pgnum_m[34]), .z(lsu_blkst_pgnum_m[34]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b35 (.a(blkst_pgnum_m[35]), .z(lsu_blkst_pgnum_m[35]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b36 (.a(blkst_pgnum_m[36]), .z(lsu_blkst_pgnum_m[36]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b37 (.a(blkst_pgnum_m[37]), .z(lsu_blkst_pgnum_m[37]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b38 (.a(blkst_pgnum_m[38]), .z(lsu_blkst_pgnum_m[38]));
bw_u1_minbuf_5x UZfix_lsu_blkst_pgnum_m_b39 (.a(blkst_pgnum_m[39]), .z(lsu_blkst_pgnum_m[39]));



   
dffe_s #(33) bst_csm_g (
        .din    (tlb_rd_tte_csm),
        .q      (lsu_blkst_csm_m),
        .en     (snap_blk_st_g),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );





//=========================================================================================
//  Prefetch Count
//=========================================================================================

wire [3:0] lsu_cpx_pref_ack;
wire [3:0] no_spc_pref;

wire	[3:0]	pref_ackcnt0,pref_ackcnt1,pref_ackcnt2,pref_ackcnt3 ;
wire	[3:0]	pref_ackcnt0_din,pref_ackcnt1_din,pref_ackcnt2_din,pref_ackcnt3_din ;

wire 	[3:0]	pref_ackcnt_incr, pref_ackcnt_decr ;
wire 	[3:0]	pref_ackcnt_mx_incr, pref_ackcnt_mx_decr ;

   wire     lsu_pref_pcx_req_d1;
   
dff_s #(1) pref_pcx_req_stg (
         .din (lsu_pref_pcx_req),
         .q   (lsu_pref_pcx_req_d1),
         .clk (clk),
         .se  (se),       .si (),          .so ()
);                   

assign   lsu_pcx_pref_issue[0] =  lsu_pref_pcx_req_d1 & lsu_ld_pcx_rq_sel_d2[0] & ~lsu_pcx_req_squash_d1;
assign   lsu_pcx_pref_issue[1] =  lsu_pref_pcx_req_d1 & lsu_ld_pcx_rq_sel_d2[1] & ~lsu_pcx_req_squash_d1;
assign   lsu_pcx_pref_issue[2] =  lsu_pref_pcx_req_d1 & lsu_ld_pcx_rq_sel_d2[2] & ~lsu_pcx_req_squash_d1;
assign   lsu_pcx_pref_issue[3] =  lsu_pref_pcx_req_d1 & lsu_ld_pcx_rq_sel_d2[3] & ~lsu_pcx_req_squash_d1;
  

   wire [3:0] pref_acknt_mx_incr_sel;
   assign     pref_acknt_mx_incr_sel[3:0] = lsu_pcx_pref_issue[3:0];

assign  pref_ackcnt_mx_incr[3:0] = 
  (pref_acknt_mx_incr_sel[0] ? pref_ackcnt0[3:0] : 4'b0) |
  (pref_acknt_mx_incr_sel[1] ? pref_ackcnt1[3:0] : 4'b0) |
  (pref_acknt_mx_incr_sel[2] ? pref_ackcnt2[3:0] : 4'b0) |
  (pref_acknt_mx_incr_sel[3] ? pref_ackcnt3[3:0] : 4'b0) ;
   
  
//====================================================================================
// prefetch ack back from CPX
   wire       dcfill_active_e;   
   assign dcfill_active_e = lsu_dfq_ld_vld & ~memref_e ;

   wire   dfq_thread0, dfq_thread1, dfq_thread2, dfq_thread3;

   assign dfq_thread0 = dfill_thread0;
   assign dfq_thread1 = dfill_thread1;
   assign dfq_thread2 = dfill_thread2;
   assign dfq_thread3 = dfill_thread3;
   
   assign lsu_cpx_pref_ack[0]  = dfq_thread0  & dcfill_active_e & lsu_cpx_pkt_prefetch2;
   assign lsu_cpx_pref_ack[1]  = dfq_thread1  & dcfill_active_e & lsu_cpx_pkt_prefetch2;
   assign lsu_cpx_pref_ack[2]  = dfq_thread2  & dcfill_active_e & lsu_cpx_pkt_prefetch2;
   assign lsu_cpx_pref_ack[3]  = dfq_thread3  & dcfill_active_e & lsu_cpx_pkt_prefetch2;
   
   wire [3:0] pref_acknt_mx_decr_sel;
   assign     pref_acknt_mx_decr_sel[3:0] = lsu_cpx_pref_ack[3:0];

assign    pref_ackcnt_mx_decr[3:0] =
  (pref_acknt_mx_decr_sel[0] ? pref_ackcnt0[3:0] : 4'b0) |
  (pref_acknt_mx_decr_sel[1] ? pref_ackcnt1[3:0] : 4'b0) |
  (pref_acknt_mx_decr_sel[2] ? pref_ackcnt2[3:0] : 4'b0) |
  (pref_acknt_mx_decr_sel[3] ? pref_ackcnt3[3:0] : 4'b0) ;
   
    
assign	pref_ackcnt_incr[3:0] = pref_ackcnt_mx_incr[3:0] + 4'b0001 ;
assign	pref_ackcnt_decr[3:0] = pref_ackcnt_mx_decr[3:0] - 4'b0001 ;

assign	pref_ackcnt0_din[3:0] = lsu_cpx_pref_ack[0] ? pref_ackcnt_decr[3:0] : pref_ackcnt_incr[3:0] ;
assign	pref_ackcnt1_din[3:0] = lsu_cpx_pref_ack[1] ? pref_ackcnt_decr[3:0] : pref_ackcnt_incr[3:0] ;
assign	pref_ackcnt2_din[3:0] = lsu_cpx_pref_ack[2] ? pref_ackcnt_decr[3:0] : pref_ackcnt_incr[3:0] ;
assign	pref_ackcnt3_din[3:0] = lsu_cpx_pref_ack[3] ? pref_ackcnt_decr[3:0] : pref_ackcnt_incr[3:0] ;

wire	[3:0]	pref_ackcnt_en ;
// if both occur in the same cycle then they cancel out.
assign	pref_ackcnt_en[0] = lsu_pcx_pref_issue[0] ^ lsu_cpx_pref_ack[0] ;
assign	pref_ackcnt_en[1] = lsu_pcx_pref_issue[1] ^ lsu_cpx_pref_ack[1] ;
assign	pref_ackcnt_en[2] = lsu_pcx_pref_issue[2] ^ lsu_cpx_pref_ack[2] ;
assign	pref_ackcnt_en[3] = lsu_pcx_pref_issue[3] ^ lsu_cpx_pref_ack[3] ;

// Thread0
dffre_s #(4)  pref_ackcnt0_ff (
        .din    (pref_ackcnt0_din[3:0]),
        .q      (pref_ackcnt0[3:0]),
        .rst    (reset),        .en     (pref_ackcnt_en[0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread1
dffre_s #(4)  pref_ackcnt1_ff (
        .din    (pref_ackcnt1_din[3:0]),
        .q      (pref_ackcnt1[3:0]),
        .rst    (reset),        .en     (pref_ackcnt_en[1]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread2
dffre_s #(4)  pref_ackcnt2_ff (
        .din    (pref_ackcnt2_din[3:0]),
        .q      (pref_ackcnt2[3:0]),
        .rst    (reset),        .en     (pref_ackcnt_en[2]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

// Thread3
dffre_s #(4)  pref_ackcnt3_ff (
        .din    (pref_ackcnt3_din[3:0]),
        .q      (pref_ackcnt3[3:0]),
        .rst    (reset),        .en     (pref_ackcnt_en[3]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );              

assign	no_spc_pref[0] = pref_ackcnt0[3] ;
assign	no_spc_pref[1] = pref_ackcnt1[3] ;
assign	no_spc_pref[2] = pref_ackcnt2[3] ;
assign	no_spc_pref[3] = pref_ackcnt3[3] ;

assign  lsu_no_spc_pref[3:0] = no_spc_pref[3:0];

//====================================================================
   wire lsu_bist_e;

   assign lsu_bist_e = lsu_bist_wvld_e | lsu_bist_rvld_e;

   wire [(6 + 4):0]      lmq_pcx_pkt_addr_din;

   wire [3:0] dfq_byp_thrd_sel;
   
mux4ds #((6 + 4)+1) lmq_pcx_pkt_addr_mux (
       .in0 ({lmq0_pcx_pkt_addr[(6 + 4):0]}),
       .in1 ({lmq1_pcx_pkt_addr[(6 + 4):0]}),
       .in2 ({lmq2_pcx_pkt_addr[(6 + 4):0]}),
       .in3 ({lmq3_pcx_pkt_addr[(6 + 4):0]}),
       .sel0(dfq_byp_thrd_sel[0]),
       .sel1(dfq_byp_thrd_sel[1]),
       .sel2(dfq_byp_thrd_sel[2]),
       .sel3(dfq_byp_thrd_sel[3]),
       .dout({lmq_pcx_pkt_addr_din[(6 + 4):0]})
);
                    
dffe_s #((6 + 4)+1)  lmq_pcx_pkt_addr_ff (
           .din    ({lmq_pcx_pkt_addr_din[(6 + 4):0]}),
           .q      ({lmq_pcx_pkt_addr[(6 + 4):0]}),
           .en     (dfq_byp_ff_en),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );


   wire [(6 + 4):4] lmq_pcx_pkt_addr_minbf;
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b10 (.a(lmq_pcx_pkt_addr[10]), .z(lmq_pcx_pkt_addr_minbf[10]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b9 (.a(lmq_pcx_pkt_addr[9]), .z(lmq_pcx_pkt_addr_minbf[9]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b8 (.a(lmq_pcx_pkt_addr[8]), .z(lmq_pcx_pkt_addr_minbf[8]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b7 (.a(lmq_pcx_pkt_addr[7]), .z(lmq_pcx_pkt_addr_minbf[7]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b6 (.a(lmq_pcx_pkt_addr[6]), .z(lmq_pcx_pkt_addr_minbf[6]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b5 (.a(lmq_pcx_pkt_addr[5]), .z(lmq_pcx_pkt_addr_minbf[5]));
   // bw_u1_minbuf_5x UZfix_lmq_pcx_pkt_addr_minbf_b4 (.a(lmq_pcx_pkt_addr[4]), .z(lmq_pcx_pkt_addr_minbf[4]));
   assign lmq_pcx_pkt_addr_minbf = lmq_pcx_pkt_addr[(6 + 4):4];
   
   
assign           lmq_ld_addr_b3 = lmq_pcx_pkt_addr[3];
   
   
assign  dcache_fill_addr_e[(6 + 4):0] =
{(6 + 4)+1{lsu_dc_iob_access_e}}               & {dcache_iob_addr_e[(6 + 4)-3:0],3'b000} |
{(6 + 4)+1{lsu_bist_wvld_e | lsu_bist_rvld_e}} & {mbist_dcache_index[(6 + 4)-4:0], mbist_dcache_word, 3'b000} | 
{(6 + 4)+1{lsu_diagnstc_wr_src_sel_e}}         & lsu_diagnstc_wr_addr_e[(6 + 4):0] |
{(6 + 4)+1{lsu_dfq_st_vld}}                    & st_dcfill_addr[(6 + 4):0] |
{(6 + 4)+1{lsu_dfq_ld_vld}}                    & {lmq_pcx_pkt_addr_minbf[(6 + 4):4], lmq_pcx_pkt_addr[3:0]}; 

assign lsu_dcache_fill_addr_e[(6 + 4):3] = dcache_fill_addr_e[(6 + 4):3];  

   wire [(6 + 4):4] dcache_fill_addr_e_tmp;
assign dcache_fill_addr_e_tmp[(6 + 4):4]    = dcache_fill_addr_e[(6 + 4):4];
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b10 ( .a(dcache_fill_addr_e_tmp[10]),  .z(lsu_dcache_fill_addr_e_err[10]));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b9  ( .a(dcache_fill_addr_e_tmp[9]),  .z(lsu_dcache_fill_addr_e_err[9] ));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b8  ( .a(dcache_fill_addr_e_tmp[8]),  .z(lsu_dcache_fill_addr_e_err[8]));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b7  ( .a(dcache_fill_addr_e_tmp[7]),  .z(lsu_dcache_fill_addr_e_err[7]));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b6  ( .a(dcache_fill_addr_e_tmp[6]),  .z(lsu_dcache_fill_addr_e_err[6]));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b5  ( .a(dcache_fill_addr_e_tmp[5]),  .z(lsu_dcache_fill_addr_e_err[5]));
// bw_u1_buf_30x UZfix_lsu_dcache_fill_addr_e_err_b4  ( .a(dcache_fill_addr_e_tmp[4]),  .z(lsu_dcache_fill_addr_e_err[4]));
assign lsu_dcache_fill_addr_e_err[(6 + 4):4] = dcache_fill_addr_e[(6 + 4):4];

// used as ld bypass 
assign dcache_wr_addr_e[2:0] = dcache_fill_addr_e[2:0];

//ldfill doesn't need to create wrt byte msk, always fill one line
assign waddr_enc[3:0] = 
{4{lsu_dc_iob_access_e}}               & {dcache_iob_addr_e[0],3'b000} |
{4{lsu_bist_e}}                        & {mbist_dcache_word, 3'b000} | 
{4{lsu_diagnstc_wr_src_sel_e}}         & lsu_diagnstc_wr_addr_e[3:0] |
{4{lsu_dfq_st_vld}}                    & st_dcfill_addr[3:0] ;

//==============================================================
/*
dff_s  #(4) lsu_thread_stgg (
        .din    ({thread3_m, thread2_m, thread1_m,thread0_m}),
        .q      (lsu_thread_g[3:0]),
        .clk    (clk),
        .se     (se),       .si (),          .so ()
        );
*/
   assign lsu_thread_g[3] = thread3_g;
   assign lsu_thread_g[2] = thread2_g;
   assign lsu_thread_g[1] = thread1_g;
   assign lsu_thread_g[0] = thread0_g;
   
//===============================================================
//LMQ thread sel
//===============================================================
//lmq_ldd_vld
   assign     dfq_byp_thrd_sel[0] = ~lsu_dfq_byp_tid[1] & ~lsu_dfq_byp_tid[0];
   assign     dfq_byp_thrd_sel[1] = ~lsu_dfq_byp_tid[1] &  lsu_dfq_byp_tid[0];
   assign     dfq_byp_thrd_sel[2] =  lsu_dfq_byp_tid[1] & ~lsu_dfq_byp_tid[0];
   assign     dfq_byp_thrd_sel[3] =  lsu_dfq_byp_tid[1] &  lsu_dfq_byp_tid[0];

   wire       lmq_ldd_vld_din;
   
mux4ds #(1) lmq_ldd_vld_mux (
       .in0 ({lmq0_ldd_vld}),
       .in1 ({lmq1_ldd_vld}),
       .in2 ({lmq2_ldd_vld}),
       .in3 ({lmq3_ldd_vld}),
       .sel0(dfq_byp_thrd_sel[0]),
       .sel1(dfq_byp_thrd_sel[1]),
       .sel2(dfq_byp_thrd_sel[2]),
       .sel3(dfq_byp_thrd_sel[3]),
       .dout({lmq_ldd_vld_din})
);
                    
dffe_s #(1)  lmq_ldd_vld_ff (
           .din    ({lmq_ldd_vld_din}),
           .q      ({lmq_ldd_vld}),
           .en     (dfq_byp_ff_en),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );
                       
//bist
wire [2-1:0] bist_way_enc_e;
reg [4-1:0] bist_way_e;


assign bist_way_enc_e[2-1:0] =  lsu_dc_iob_access_e ?  
       lsu_dcache_iob_way_e[2-1:0] : mbist_dcache_way[2-1:0] ;
   
// assign  bist_way_e[0] = ~bist_way_enc_e[1] & ~bist_way_enc_e[0] ;
// assign  bist_way_e[1] = ~bist_way_enc_e[1] &  bist_way_enc_e[0] ;
// assign  bist_way_e[2] =  bist_way_enc_e[1] & ~bist_way_enc_e[0] ;
// assign  bist_way_e[3] =  bist_way_enc_e[1] &  bist_way_enc_e[0] ;
always @ *
begin
bist_way_e = 0;
if (bist_way_enc_e == 0)
   bist_way_e[0] = 1'b1;
else if (bist_way_enc_e == 1)
   bist_way_e[1] = 1'b1;
else if (bist_way_enc_e == 2)
   bist_way_e[2] = 1'b1;
else if (bist_way_enc_e == 3)
   bist_way_e[3] = 1'b1;
end


assign lsu_bist_rsel_way_e[4-1:0] = bist_way_e[4-1:0];

   wire lmq_l2fill_fp_din;
assign    lmq_l2fill_fp_din =
       dfq_byp_thrd_sel[0] & lmq0_l2fill_fpld | 
       dfq_byp_thrd_sel[1] & lmq1_l2fill_fpld | 
       dfq_byp_thrd_sel[2] & lmq2_l2fill_fpld | 
       dfq_byp_thrd_sel[3] & lmq3_l2fill_fpld ;
 
dffe_s #(1) lmq_l2fill_fp_ff (
           .din (lmq_l2fill_fp_din),
           .q   (lsu_l2fill_fpld_e),
           .en  (dfq_byp_ff_en),
           .clk (clk),
           .se  (se),       .si (),          .so ()
           );   

   wire lmq_ncache_ld_din;
assign    lmq_ncache_ld_din =
       dfq_byp_thrd_sel[0] & lmq0_ncache_ld | 
       dfq_byp_thrd_sel[1] & lmq1_ncache_ld | 
       dfq_byp_thrd_sel[2] & lmq2_ncache_ld | 
       dfq_byp_thrd_sel[3] & lmq3_ncache_ld ;
 
dffe_s #(1) lmq_ncache_ld_ff (
           .din (lmq_ncache_ld_din),
           .q   (lsu_ncache_ld_e),
           .en  (dfq_byp_ff_en),
           .clk (clk),
           .se  (se),       .si (),          .so ()
           );   
                         
//lmq
   wire [2-1:0]      lmq_ldfill_way_din;
   
mux4ds #(2) lmq_ldfill_way_mux (
       .in0 ({lmq0_pcx_pkt_way[2-1:0]}),
       .in1 ({lmq1_pcx_pkt_way[2-1:0]}),
       .in2 ({lmq2_pcx_pkt_way[2-1:0]}),
       .in3 ({lmq3_pcx_pkt_way[2-1:0]}),
       .sel0(dfq_byp_thrd_sel[0]),
       .sel1(dfq_byp_thrd_sel[1]),
       .sel2(dfq_byp_thrd_sel[2]),
       .sel3(dfq_byp_thrd_sel[3]),
       .dout({lmq_ldfill_way_din[2-1:0]})
);
   wire [2-1:0]      lmq_ldfill_way;
                    
dffe_s #(2)  lmq_ldfill_way_ff (
           .din    ({lmq_ldfill_way_din[2-1:0]}),
           .q      ({lmq_ldfill_way[2-1:0]}),
           .en     (dfq_byp_ff_en),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

wire [2-1:0] dcache_fill_way_enc_e;
   
assign dcache_fill_way_enc_e[2-1:0] = 
{2{lsu_dc_iob_access_e}}               & lsu_dcache_iob_way_e[2-1:0] |
{2{lsu_bist_e}}                        & bist_way_enc_e[2-1:0]       | 
{2{lsu_diagnstc_wr_src_sel_e}}         & lsu_diagnstc_wr_way_e[2-1:0]|
{2{lsu_dfq_st_vld}}                    & lsu_st_way_e[2-1:0]         |
{2{lsu_dfq_ld_vld}}                    & lmq_ldfill_way[2-1:0]; 

   // assign lsu_dcache_fill_way_e[0] =   ~dcache_fill_way_enc_e[1] & ~dcache_fill_way_enc_e[0];
   // assign lsu_dcache_fill_way_e[1] =   ~dcache_fill_way_enc_e[1] &  dcache_fill_way_enc_e[0];
   // assign lsu_dcache_fill_way_e[2] =    dcache_fill_way_enc_e[1] & ~dcache_fill_way_enc_e[0];
   // assign lsu_dcache_fill_way_e[3] =    dcache_fill_way_enc_e[1] &  dcache_fill_way_enc_e[0];


    assign lsu_dcache_fill_way_e[0] = (dcache_fill_way_enc_e == 0);


    assign lsu_dcache_fill_way_e[1] = (dcache_fill_way_enc_e == 1);


    assign lsu_dcache_fill_way_e[2] = (dcache_fill_way_enc_e == 2);


    assign lsu_dcache_fill_way_e[3] = (dcache_fill_way_enc_e == 3);



//ld_rq_type

   wire [2:0]      lmq_ld_rq_type_din;
   
mux4ds #(3) lmq_ld_rq_type_mux (
       .in0 ({lmq0_ld_rq_type[2:0]}),
       .in1 ({lmq1_ld_rq_type[2:0]}),
       .in2 ({lmq2_ld_rq_type[2:0]}),
       .in3 ({lmq3_ld_rq_type[2:0]}),
       .sel0(dfq_byp_thrd_sel[0]),
       .sel1(dfq_byp_thrd_sel[1]),
       .sel2(dfq_byp_thrd_sel[2]),
       .sel3(dfq_byp_thrd_sel[3]),
       .dout({lmq_ld_rq_type_din[2:0]})
);
                    
dffe_s #(3)  lmq_ld_rq_type_e_ff (
           .din    ({lmq_ld_rq_type_din[2:0]}),
           .q      ({lmq_ld_rq_type_e[2:0]}),
           .en     (dfq_byp_ff_en),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );

//================================================================
wire	other_flush_pipe_w ;

assign	other_flush_pipe_w = tlu_early_flush_pipe2_w | (lsu_ttype_vld_m2 & lsu_inst_vld_w);     
assign	dctl_flush_pipe_w = other_flush_pipe_w | ifu_lsu_flush_w ;
// Staged ifu_tlu_flush_m should be used !!
assign  dctl_early_flush_w = (lsu_local_early_flush_g | tlu_early_flush_pipe2_w | ifu_lsu_flush_w) ;

//================================================================
// dcfill size
   wire dcfill_size_mx_sel_e;
//bug6216/eco6624 
assign  dcfill_size_mx_sel_e  =  lsu_dc_iob_access_e | lsu_diagnstc_wr_src_sel_e;    

mux2ds  #(2)  dcache_wr_size_e_mux (
              .in0(2'b11),
              .in1(lsu_st_dcfill_size_e[1:0]),
              .sel0(dcfill_size_mx_sel_e),
              .sel1(~dcfill_size_mx_sel_e),
              .dout(dcache_wr_size_e[1:0])
);


//assign  lsu_dcfill_data_mx_sel_e  =   (dcache_iob_wr_e | dcache_iob_rd_e | lsu_bist_wvld_e);   
   wire dcfill_data_mx_sel_e_l;
   
bw_u1_nor3_8x  UZsize_dcfill_data_mx_sel_e_l (.a (dcache_iob_wr_e),
                                              .b (dcache_iob_rd_e), 
                                              .c (lsu_bist_wvld_e),
                                              .z (dcfill_data_mx_sel_e_l));

bw_u1_inv_30x  UZsize_dcfill_data_mx_sel_e   ( .a(dcfill_data_mx_sel_e_l), .z (lsu_dcfill_data_mx_sel_e));
   
//================================================================
   wire [3:0] dfq_thread_e;
   assign     dfq_thread_e[0] = ~lsu_dfill_tid_e[1] & ~lsu_dfill_tid_e[0];
   assign     dfq_thread_e[1] = ~lsu_dfill_tid_e[1] &  lsu_dfill_tid_e[0];
   assign     dfq_thread_e[2] =  lsu_dfill_tid_e[1] & ~lsu_dfill_tid_e[0];
   assign     dfq_thread_e[3] =  lsu_dfill_tid_e[1] &  lsu_dfill_tid_e[0];

   wire [3:0] dfq_byp_sel_e;
   assign     dfq_byp_sel_e[0] = dfq_thread_e[0] & dcfill_active_e & ~lsu_cpx_pkt_prefetch2;
   assign     dfq_byp_sel_e[1] = dfq_thread_e[1] & dcfill_active_e & ~lsu_cpx_pkt_prefetch2;
   assign     dfq_byp_sel_e[2] = dfq_thread_e[2] & dcfill_active_e & ~lsu_cpx_pkt_prefetch2;
   assign     dfq_byp_sel_e[3] = dfq_thread_e[3] & dcfill_active_e & ~lsu_cpx_pkt_prefetch2;
   
wire	[3:0] lmq_byp_misc_sel_e ;

assign  lmq_byp_misc_sel_e[0] = ld_thrd_byp_sel_e[0]  |        // select for ldxa/raw.
                                dfq_byp_sel_e[0]  ;              // select for dfq.
assign  lmq_byp_misc_sel_e[1] = ld_thrd_byp_sel_e[1]  |        // select for ldxa/raw.
                                dfq_byp_sel_e[1] ;               // select for dfq.
assign  lmq_byp_misc_sel_e[2] = ld_thrd_byp_sel_e[2]  |        // select for ldxa/raw.
                                dfq_byp_sel_e[2] ;               // select for dfq.
assign  lmq_byp_misc_sel_e[3] = ld_thrd_byp_sel_e[3]  | 
                                dfq_byp_sel_e[3] ; 

   wire [2:0] byp_misc_addr_e;
assign byp_misc_addr_e[2:0] = (lmq_byp_misc_sel_e[0] ? lmq0_pcx_pkt_addr[2:0] : 3'b0) |
                              (lmq_byp_misc_sel_e[1] ? lmq1_pcx_pkt_addr[2:0] : 3'b0) |
                              (lmq_byp_misc_sel_e[2] ? lmq2_pcx_pkt_addr[2:0] : 3'b0) |
                              (lmq_byp_misc_sel_e[3] ? lmq3_pcx_pkt_addr[2:0] : 3'b0) ;
   
   wire [1:0] byp_misc_sz_e;
assign byp_misc_sz_e[1:0] = (lmq_byp_misc_sel_e[0] ? lmq0_byp_misc_sz[1:0] : 2'b0) |
                            (lmq_byp_misc_sel_e[1] ? lmq1_byp_misc_sz[1:0] : 2'b0) |
                            (lmq_byp_misc_sel_e[2] ? lmq2_byp_misc_sz[1:0] : 2'b0) |
                            (lmq_byp_misc_sel_e[3] ? lmq3_byp_misc_sz[1:0] : 2'b0) ;
   
                                
dff_s #(5)  lmq_byp_misc_stgm (
           .din    ({byp_misc_addr_e[2:0], byp_misc_sz_e[1:0]}),
           .q      ({lsu_byp_misc_addr_m[2:0], lsu_byp_misc_sz_m[1:0]}),
           .clk    (clk),
           .se     (se),       .si (),          .so ()
           );
  
endmodule


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_qctl2.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// devices.xml


/////////////////////////////////////////////////////////////////////
/*
//  Description:  LSU Queue Control for Sparc Core  
//      - includes monitoring for pcx queues
//      - control for lsu datapath
//      - rd/wr control of dfq 
//
*/
////////////////////////////////////////////////////////////////////////
// header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
                  // time scale definition
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




























//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module lsu_qctl2 ( /*AUTOARG*/
   // Outputs
   so, lsu_fwd_rply_sz1_unc, lsu_dcache_iob_rd_w, ldd_in_dfq_out, 
   lsu_dfq_rd_vld_d1, dfq_byp_ff_en, lsu_dfill_data_sel_hi, 
   lsu_ifill_pkt_vld, cpx_fwd_pkt_en_cx, lsu_cpxpkt_type_dcd_cx, 
   lsu_cpu_dcd_sel, lsu_cpu_uhlf_sel, lsu_iobrdge_rply_data_sel, 
   lsu_iobrdge_fwd_pkt_vld, lsu_tlu_cpx_vld, lsu_tlu_cpx_req, 
   lsu_tlu_intpkt, ld_sec_active, dfq_byp_sel, 
   lsu_cpx_ld_dtag_perror_e, lsu_cpx_ld_dcache_perror_e, 
   lsu_exu_rd_m, lsu_spu_strm_ack_cmplt, lsu_atm_st_cmplt_e, 
   dva_svld_e, dfq_wptr_vld, dfq_wptr, lsu_dfq_flsh_cmplt, 
   dfq_rptr_vld, dfq_rptr, lsu_ifu_stallreq, dva_snp_addr_e, 
   lsu_st_ack_dq_stb, lsu_cpx_rmo_st_ack, lsu_st_wr_dcache, 
   cpx_st_ack_tid0, cpx_st_ack_tid1, cpx_st_ack_tid2, 
   cpx_st_ack_tid3, lsu_tlu_l2_dmiss, lsu_l2fill_vld, 
   lsu_byp_ldd_oddrd_m, lsu_pcx_fwd_reply, lsu_fwdpkt_vld, 
   lsu_dcfill_active_e, lsu_dfq_ld_vld, lsu_fldd_vld_en, 
   lsu_dfill_dcd_thrd, lsu_fwdpkt_dest, dva_snp_bit_wr_en_e, 
   lsu_cpx_spc_inv_vld, lsu_cpx_thrdid, lsu_cpx_stack_dcfill_vld, 
   lsu_dfq_vld_entry_w, lsu_cpx_stack_icfill_vld, lsu_dfq_st_vld, 
   lsu_dfq_ldst_vld, lsu_qdp2_dfq_ld_vld, lsu_qdp2_dfq_st_vld, 
   lsu_cpx_stack_dcfill_vld_b130, lsu_dfq_vld, lsu_dfq_byp_ff_en, 
   // Inputs
   rclk, grst_l, arst_l, si, se, rst_tri_en, ld_inst_vld_e, 
   ifu_pcx_pkt_b51, ifu_pcx_pkt_b41t40, ifu_pcx_pkt_b10t5, 
   lsu_dfq_rdata_flush_bit, lsu_dfq_rdata_b17_b0, 
   cpx_spc_data_cx_b144to140, cpx_spc_data_cx_b138, 
   cpx_spc_data_cx_b135to134, 
   cpx_spc_data_cx_b133, cpx_spc_data_cx_b130, cpx_spc_data_cx_b129, 
   cpx_spc_data_cx_b128, cpx_spc_data_cx_b125, 
   cpx_spc_data_cx_b124to123, cpx_spc_data_cx_b120to118, 

   cpx_spc_data_cx_b71to70, 
   // cpx_spc_data_cx_b0, cpx_spc_data_cx_b4, 
   // cpx_spc_data_cx_b8, cpx_spc_data_cx_b12, cpx_spc_data_cx_b16, 
   // cpx_spc_data_cx_b20, cpx_spc_data_cx_b24, cpx_spc_data_cx_b28, 
   // cpx_spc_data_cx_b32, cpx_spc_data_cx_b35, cpx_spc_data_cx_b38, 
   // cpx_spc_data_cx_b41, cpx_spc_data_cx_b44, cpx_spc_data_cx_b47, 
   // cpx_spc_data_cx_b50, cpx_spc_data_cx_b53, cpx_spc_data_cx_b56, 
   // cpx_spc_data_cx_b60, cpx_spc_data_cx_b64, cpx_spc_data_cx_b68, 
   // cpx_spc_data_cx_b72, cpx_spc_data_cx_b76, cpx_spc_data_cx_b80, 
   // cpx_spc_data_cx_b84, cpx_spc_data_cx_b88, cpx_spc_data_cx_b91, 
   // cpx_spc_data_cx_b94, cpx_spc_data_cx_b97, cpx_spc_data_cx_b100, 
   cpx_spc_data_cx_b103,
   // cpx_spc_data_cx_b106, cpx_spc_data_cx_b109, 
   // cpx_spc_data_cx_b1, cpx_spc_data_cx_b5, cpx_spc_data_cx_b9, 
   // cpx_spc_data_cx_b13, cpx_spc_data_cx_b17, cpx_spc_data_cx_b21, 
   // cpx_spc_data_cx_b25, cpx_spc_data_cx_b29, cpx_spc_data_cx_b57, 
   // cpx_spc_data_cx_b61, cpx_spc_data_cx_b65, cpx_spc_data_cx_b69, 
   // cpx_spc_data_cx_b73, cpx_spc_data_cx_b77, cpx_spc_data_cx_b81, 
   // cpx_spc_data_cx_b85, 

   cpx_spc_data_cx_dcache_inval_val,
   cpx_spc_data_cx_icache_inval_val,

   ifu_lsu_rd_e, lmq_ld_rd1, lmq_ldd_vld, 
   dfq_tid, const_cpuid, lmq_ld_addr_b3, ifu_lsu_ibuf_busy, 
   ifu_lsu_inv_clear, lsu_byp_misc_sz_e, lsu_dfq_byp_tid, 
   lsu_cpx_pkt_atm_st_cmplt, lsu_cpx_pkt_l2miss, lsu_cpx_pkt_tid, 
   lsu_cpx_pkt_invwy, lsu_dfq_byp_flush, lsu_dfq_byp_type, 
   lsu_dfq_byp_invwy_vld, 
   // lsu_cpu_inv_data_b13to9, 
   // lsu_cpu_inv_data_b7to2, 
   // lsu_cpu_inv_data_b0, 
   lsu_cpu_inv_data_val, lsu_cpu_inv_data_way,
   lsu_cpx_pkt_inv_pa, 
   lsu_cpx_pkt_ifill_type, lsu_cpx_pkt_atomic, lsu_cpx_pkt_binit_st, 
   lsu_cpx_pkt_prefetch, lsu_dfq_byp_binit_st, lsu_tlbop_force_swo, 
   lsu_iobrdge_tap_rq_type, lsu_dcache_tag_perror_g, 
   lsu_dcache_data_perror_g, lsu_cpx_pkt_perror_iinv, 
   lsu_cpx_pkt_perror_dinv, lsu_cpx_pkt_perror_set, 
   lsu_l2fill_fpld_e, lsu_cpx_pkt_strm_ack, ifu_lsu_memref_d, 
   lsu_fwdpkt_pcx_rq_sel, lsu_imiss_pcx_rq_sel_d1, 
   lsu_dfq_byp_cpx_inv, lsu_dfq_byp_stack_adr_b54, 
   lsu_dfq_byp_stack_wrway, lsu_dfq_rdata_st_ack_type, 
   lsu_dfq_rdata_stack_dcfill_vld, lsu_dfq_rdata_stack_iinv_vld, 
   lsu_dfq_rdata_cpuid, lsu_dfq_byp_atm, lsu_ld_inst_vld_g, 
   lsu_dfq_rdata_type, lsu_dfq_rdata_invwy_vld, ifu_lsu_fwd_data_vld, 
   ifu_lsu_fwd_wr_ack, lsu_dfq_rdata_rq_type, lsu_dfq_rdata_b103, 
   sehold
   ) ;  


input     rclk ;
input     grst_l;
input     arst_l;
input     si;
input     se;
input     rst_tri_en;
output    so;

input                   ld_inst_vld_e;        // valid ld inst; d-stage
input                   ifu_pcx_pkt_b51;        // pcx pkt from ifu on imiss
input [1:0]             ifu_pcx_pkt_b41t40;     // pcx pkt from ifu on imiss
input [5:0]             ifu_pcx_pkt_b10t5;      // pcx pkt from ifu on imiss
//input                   cpx_spc_data_rdy_cx ;   // data ready to processor
//input [`CPX_WIDTH-1:71] cpx_spc_data_cx ;       // cpx to processor packet
//input [`CPX_WIDTH-1:0] cpx_spc_data_cx ;       // cpx to processor packet
//input [17:0]            cpx_spc_data_b17t0_cx ; // cpx to processor packet
   input                lsu_dfq_rdata_flush_bit;
   input [17:0]         lsu_dfq_rdata_b17_b0;
   
input [145-1:140] cpx_spc_data_cx_b144to140 ;       // vld, req type
input                   cpx_spc_data_cx_b138 ;  
//input                   cpx_spc_data_cx_b136 ;  
input [135:134] cpx_spc_data_cx_b135to134 ;  // thread id
input                   cpx_spc_data_cx_b133 ;  
input                   cpx_spc_data_cx_b130 ;  
input                   cpx_spc_data_cx_b129 ;  
input                   cpx_spc_data_cx_b128 ;  
input                   cpx_spc_data_cx_b125 ;  
input [123+1:123] cpx_spc_data_cx_b124to123 ;  // inv packet iinv,dinv
input [120:118] cpx_spc_data_cx_b120to118 ;  // inv packet cpu id
input [1:0]             cpx_spc_data_cx_b71to70 ;  

// input        cpx_spc_data_cx_b0 ;
// input        cpx_spc_data_cx_b4 ;
// input        cpx_spc_data_cx_b8 ;
// input        cpx_spc_data_cx_b12 ;
// input        cpx_spc_data_cx_b16 ;
// input        cpx_spc_data_cx_b20 ;
// input        cpx_spc_data_cx_b24 ;
// input        cpx_spc_data_cx_b28 ;

// input        cpx_spc_data_cx_b32 ;
// input        cpx_spc_data_cx_b35 ;
// input        cpx_spc_data_cx_b38 ;
// input        cpx_spc_data_cx_b41 ;
// input        cpx_spc_data_cx_b44 ;
// input        cpx_spc_data_cx_b47 ;
// input        cpx_spc_data_cx_b50 ;
// input        cpx_spc_data_cx_b53 ;

// input        cpx_spc_data_cx_b56 ;
// input        cpx_spc_data_cx_b60 ;
// input        cpx_spc_data_cx_b64 ;
// input        cpx_spc_data_cx_b68 ;
// input        cpx_spc_data_cx_b72 ;
// input        cpx_spc_data_cx_b76 ;
// input        cpx_spc_data_cx_b80 ;
// input        cpx_spc_data_cx_b84 ;

// input        cpx_spc_data_cx_b88 ;
// input        cpx_spc_data_cx_b91 ;
// input        cpx_spc_data_cx_b94 ;
// input        cpx_spc_data_cx_b97 ;
// input        cpx_spc_data_cx_b100 ;
input        cpx_spc_data_cx_b103 ;
// input        cpx_spc_data_cx_b106 ;
// input        cpx_spc_data_cx_b109 ;

// input        cpx_spc_data_cx_b1 ;
// input        cpx_spc_data_cx_b5 ;
// input        cpx_spc_data_cx_b9 ;
// input        cpx_spc_data_cx_b13 ;
// input        cpx_spc_data_cx_b17 ;
// input        cpx_spc_data_cx_b21 ;
// input        cpx_spc_data_cx_b25 ;
// input        cpx_spc_data_cx_b29 ;

// input        cpx_spc_data_cx_b57 ;
// input        cpx_spc_data_cx_b61 ;
// input        cpx_spc_data_cx_b65 ;
// input        cpx_spc_data_cx_b69 ;
// input        cpx_spc_data_cx_b73 ;
// input        cpx_spc_data_cx_b77 ;
// input        cpx_spc_data_cx_b81 ;
// input        cpx_spc_data_cx_b85 ;
input       cpx_spc_data_cx_dcache_inval_val;
input       cpx_spc_data_cx_icache_inval_val;

input [4:0]             ifu_lsu_rd_e ;          // rd for current load request.
//input                   lsu_ld_miss_g ;         // load misses in dcache.
input  [4:0]            lmq_ld_rd1 ;            // rd for all loads
input                   lmq_ldd_vld ;           // ld double   
//input                   ld_stb_full_raw_g ;    // full raw for load - thread0
//input                   ld_stb_partial_raw_g ; // partial raw for load - thread0
/*
input                   ld_sec_hit_thrd0 ;      // ld has sec. hit against th0
input                   ld_sec_hit_thrd1 ;      // ld has sec. hit against th1
input                   ld_sec_hit_thrd2 ;      // ld has sec. hit against th2
input                   ld_sec_hit_thrd3 ;      // ld has sec. hit against th3
*/
input   [1:0]           dfq_tid ;               // thread-id for load at head of DFQ. 
//input   [1:0]           dfq_byp_tid ;           // in-flight thread-id for load at head of DFQ. 
//input                   ldxa_internal ;         // internal ldxa, stg g 
//input [3:0]             ld_thrd_byp_sel ;       // stb,ldxa thread byp sel
input [2:0]             const_cpuid ;           // cpu id
input                   lmq_ld_addr_b3 ;        // bit3 of addr at head of queue.
//input                   ifu_tlu_inst_vld_m ;    // inst is vld - wstage
//input                   tlu_ifu_flush_pipe_w ;  // flush event in wstage
//input                   lsu_ldstub_g ;          // ldstub(a) instruction
//input                   lsu_swap_g ;            // swap(a) instruction 
//input                   tlu_lsu_pcxpkt_vld ;
//input [11:10]           tlu_lsu_pcxpkt_l2baddr ;
//input [19:18]           tlu_lsu_pcxpkt_tid ;
input                   ifu_lsu_ibuf_busy ;
input                   ifu_lsu_inv_clear ;
input   [1:0]           lsu_byp_misc_sz_e ;     // size for ldxa/raw etc
input   [1:0]           lsu_dfq_byp_tid ;
input                   lsu_cpx_pkt_atm_st_cmplt ;
input                   lsu_cpx_pkt_l2miss ;
input   [1:0]           lsu_cpx_pkt_tid ;
input   [2-1:0]           lsu_cpx_pkt_invwy ;     // invalidate way
input                   lsu_dfq_byp_flush ;
input   [5:0]           lsu_dfq_byp_type ;
input                   lsu_dfq_byp_invwy_vld ;
//input   [13:0]          lsu_cpu_inv_data ;

// input   [13:9]          lsu_cpu_inv_data_b13to9 ;
// input   [7:2]           lsu_cpu_inv_data_b7to2 ;
// input                   lsu_cpu_inv_data_b0 ;
input                        lsu_cpu_inv_data_val ;
input  [2-1:0]  lsu_cpu_inv_data_way ;

//input   [2:0]           lsu_dfq_byp_cpuid ;
input   [(6 + 4)-6:0]           lsu_cpx_pkt_inv_pa ;    // invalidate pa [10:6]
input                   lsu_cpx_pkt_ifill_type ;
//input                   stb_cam_hit ; REMOVED
input                   lsu_cpx_pkt_atomic ;
//input                   lsu_dfq_byp_stquad_pkt2 ;
//input                   lsu_cpx_pkt_stquad_pkt2 ;
input                   lsu_cpx_pkt_binit_st ;
input                   lsu_cpx_pkt_prefetch ;
input                   lsu_dfq_byp_binit_st ;
//input   [3:0]           lsu_stb_empty ;
input                   lsu_tlbop_force_swo ;
input   [7:3]           lsu_iobrdge_tap_rq_type ; 
input                   lsu_dcache_tag_perror_g ;  // dcache tag parity error
input                   lsu_dcache_data_perror_g ; // dcache data parity error
//input                   lsu_dfq_byp_perror_dinv ;  // dtag perror corr. st ack
//input                   lsu_dfq_byp_perror_iinv ;  // itag perror corr. st ack


input                   lsu_cpx_pkt_perror_iinv ;   // itag perror corr. st ack
input                   lsu_cpx_pkt_perror_dinv ;   // dtag perror corr. st ack
input   [1:0]           lsu_cpx_pkt_perror_set ;   // dtag perror - spec. b54
//input                   lsu_diagnstc_wr_src_sel_e ;// dcache/dtag/vld
input         		lsu_l2fill_fpld_e ;      // fp load
input                   lsu_cpx_pkt_strm_ack ;
   
input                   ifu_lsu_memref_d ;
//input   [3:0]           lmq_enable;
//input   [3:0]           ld_pcx_rq_sel ;
input                   lsu_fwdpkt_pcx_rq_sel ;
//input                   lsu_ld0_pcx_rq_sel_d1, lsu_ld1_pcx_rq_sel_d1 ;
//input                   lsu_ld2_pcx_rq_sel_d1, lsu_ld3_pcx_rq_sel_d1 ;
input                   lsu_imiss_pcx_rq_sel_d1 ;

//input                   lsu_dc_iob_access_e;

//   input                mbist_dcache_write;
//   input                mbist_dcache_read;
   

input                   lsu_dfq_byp_cpx_inv ;
//input			lsu_dfq_byp_stack_dcfill_vld ;
input  [1:0]            lsu_dfq_byp_stack_adr_b54;
input  [1:0]            lsu_dfq_byp_stack_wrway;

input                   lsu_dfq_rdata_st_ack_type;
input                   lsu_dfq_rdata_stack_dcfill_vld;

input                   lsu_dfq_rdata_stack_iinv_vld;

input  [2:0]            lsu_dfq_rdata_cpuid;

input                   lsu_dfq_byp_atm;

input	[3:0]		lsu_ld_inst_vld_g ;

input	[5:0]		lsu_dfq_rdata_type ;
input			lsu_dfq_rdata_invwy_vld ;

input			ifu_lsu_fwd_data_vld ; // icache ramtest read cmplt
input			ifu_lsu_fwd_wr_ack ;   // icache ramtest wr cmplt

input	[3:0]		lsu_dfq_rdata_rq_type ;
input                   lsu_dfq_rdata_b103 ;

input                   sehold ;

output 			lsu_fwd_rply_sz1_unc ;
output			lsu_dcache_iob_rd_w ;

output     		ldd_in_dfq_out;
   
output                  lsu_dfq_rd_vld_d1 ;
output                  dfq_byp_ff_en ;
output                  lsu_dfill_data_sel_hi;// select hi or low order 8B. 
output                  lsu_ifill_pkt_vld ;   // ifill pkt vld
output                  cpx_fwd_pkt_en_cx ;
output  [5:0]           lsu_cpxpkt_type_dcd_cx ;
output  [7:0]           lsu_cpu_dcd_sel ;
output                  lsu_cpu_uhlf_sel ;
//output                  lsu_st_wr_sel_e ;
//output  [1:0]           lsu_st_ack_addr_b54 ;
//output  [1:0]           lsu_st_ack_wrwy ;       // cache set way to write to.

output  [2:0]           lsu_iobrdge_rply_data_sel ;
output                  lsu_iobrdge_fwd_pkt_vld ;
output                  lsu_tlu_cpx_vld;    // cpx pkt vld
output  [3:0]           lsu_tlu_cpx_req;    // cpx pkt rq type
output  [17:0]          lsu_tlu_intpkt;     // cpx interrupt pkt
//output                  lsu_tlu_pcxpkt_ack; // ack for intr pkt.
//output  [3:0]           lsu_intrpt_cmplt ;      // intrpt can restart thread
//output                  lsu_ld_sec_hit_l2access_g ;
//output  [1:0]           lsu_ld_sec_hit_wy_g ;
output                  ld_sec_active ;     // secondary bypassing
output  [3:0]           dfq_byp_sel ;
//output  [3:0]           lsu_dfq_byp_mxsel ; // to qdp1
//output  [3:0]           lmq_byp_misc_sel ;    // select g-stage lmq source
//output                  lsu_pcx_ld_dtag_perror_w2 ;
output                  lsu_cpx_ld_dtag_perror_e ;
output                  lsu_cpx_ld_dcache_perror_e ;
//output  [1:0]           lsu_cpx_atm_st_err ;
//output                  lsu_ignore_fill ;
//output  [4:0]           lsu_exu_rd_w2 ;
output  [4:0]           lsu_exu_rd_m ;
output  [1:0]           lsu_spu_strm_ack_cmplt ;
output	           	lsu_atm_st_cmplt_e ;  // atm st ack will restart thread
output                  dva_svld_e ;        // snoop is valid
output                  dfq_wptr_vld ;          // write pointer valid
output  [4:0]           dfq_wptr ;              // encoded write pointer
output  [3:0]           lsu_dfq_flsh_cmplt ;
output                  dfq_rptr_vld ;          // read pointer valid
output  [4:0]           dfq_rptr ;              // encoded read pointer
output                  lsu_ifu_stallreq ;      // cfq has crossed high-water mark
output  [(6 + 4)-6:0]           dva_snp_addr_e;         // Upper 5b of cache set index PA[10:6]
//output  [3:0]           dva_snp_set_vld_e;      // Lower 2b of cache set index - decoded
//output  [1:0]           dva_snp_wy0_e ;         // way for addr<5:4>=00
//output  [1:0]           dva_snp_wy1_e ;         // way for addr<5:4>=01
//output  [1:0]           dva_snp_wy2_e ;         // way for addr<5:4>=10
//output  [1:0]           dva_snp_wy3_e ;         // way for addr<5:4>=11
//output  [3:0]           lsu_st_ack_rq_stb ;
output  [3:0]           lsu_st_ack_dq_stb ;
output  [3:0]           lsu_cpx_rmo_st_ack ;    // rmo ack clears
output                  lsu_st_wr_dcache ;
output                  cpx_st_ack_tid0 ;   // st ack for thread0
output                  cpx_st_ack_tid1 ;   // st ack for thread1
output                  cpx_st_ack_tid2 ;   // st ack for thread2
output                  cpx_st_ack_tid3 ;   // st ack for thread3
output  [3:0]           lsu_tlu_l2_dmiss ;       // performance cntr
//output  [3:0]           lsu_ifu_stq_busy ;         // thread is busy with 1 stq - not used
output                  lsu_l2fill_vld ;        // dfill data vld
output                  lsu_byp_ldd_oddrd_m ; // rd fill for non-alt ldd
output                  lsu_pcx_fwd_reply ;   // fwd reply on pcx pkt
//output                  lsu_intrpt_pkt_vld ;
output                  lsu_fwdpkt_vld;
//output  [3:0]           lsu_error_rst ;
output                  lsu_dcfill_active_e;	// not same as dcfill_active_e; qual'ed w/ ignore_fill
//output                  lsu_dfq_byp_vld ;
output                  lsu_dfq_ld_vld;
output                  lsu_fldd_vld_en;
output  [3:0]           lsu_dfill_dcd_thrd ;
output  [4:0]           lsu_fwdpkt_dest ;
//output                  dcfill_src_dfq_sel ;    // ld-inv is src
output [(4*4-1):0]        dva_snp_bit_wr_en_e;

//output [3:0]         lsu_dcfill_mx_sel_e;
//output               lsu_dcfill_addr_mx_sel_e;
//output               lsu_dcfill_data_mx_sel_e;
//output               lsu_dcfill_size_mx_sel_e;

output               lsu_cpx_spc_inv_vld;  // dfq write data in[152]
output [3:0]         lsu_cpx_thrdid;
output               lsu_cpx_stack_dcfill_vld ;

//output	[3:0]		lsu_dtag_perror_w2 ;

output  		lsu_dfq_vld_entry_w ;

output  		lsu_cpx_stack_icfill_vld ;

output                  lsu_dfq_st_vld;
output                  lsu_dfq_ldst_vld;
   //pref counter
//   output [3:0] lsu_cpx_pref_ack;

output                  lsu_qdp2_dfq_ld_vld;
output                  lsu_qdp2_dfq_st_vld;

output                  lsu_cpx_stack_dcfill_vld_b130;
   
output  		lsu_dfq_vld ;

output                  lsu_dfq_byp_ff_en ;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics


wire        cpx_local_st_ack_type ;
wire  [3:0] cpx_pkt_thrd_sel ;
//wire  [3:0] tap_thread ;
wire      cpx_reverse_req , cpx_reverse_req_d1 ;
wire    cpx_fwd_req,cpx_fwd_reply;
wire    fwdpkt_reset ;
wire        dfq_inv_vld ;
//wire    intrpt_vld_reset ;
//wire    intrpt_vld_en ;
//wire    ld0_sec_hit_g,ld1_sec_hit_g,ld2_sec_hit_g,ld3_sec_hit_g;
//wire  [3:0] intrpt_thread ;
wire    dfq_byp_ld_vld ;
//wire    intrpt_clr ;
wire    dfq_rptr_vld_d1 ;
wire    dfq_rd_advance ;
wire        dfq_wr_en, dfq_byp_full, dcfill_active_e ;
wire    dfq_thread0,dfq_thread1,dfq_thread2,dfq_thread3;
//wire    ld_any_thrd_byp_sel ;
wire    stwr_active_e,stdq_active_e ;
wire  [3:0] error_en ;
wire        ldd_vld_reset, ldd_vld_en, ldd_in_dfq_out ;
wire    ldd_non_alt_space ;
wire    ldd_oddrd_e ;
wire        inv_active_e ;
wire    dfq_st_vld ;
//wire    local_inv ;
wire    dfq_local_inv ;
//wire    st_ack_rq_stb_d1 ;
//wire    cpx_inv ;
wire    dfq_byp_inv_vld ;
wire    dfq_invwy_vld;
wire    local_pkt ;
wire    dfq_byp_st_vld ;
wire        dfq_vld_reset, dfq_vld_en ;
//wire  [3:0] st_wrwy_sel ;
//wire  [13:0]  cpx_cpu_inv_data ;
wire        dfq_vld_entry_exists ;
wire    cpx_st_ack_type,cpx_strm_st_ack_type,cpx_int_type;
wire    cpx_ld_type,cpx_ifill_type,cpx_evict_type;
wire  [5:0]     dfq_wptr_new_w_wrap ;   // 5b ptr with wrap bit.
wire  [5:0]     dfq_rptr_new_w_wrap ;   // 5b ptr with wrap bit.
wire  [5:0]     dfq_wptr_w_wrap ;   // 5b ptr with wrap bit.
//wire    i_and_d_codepend ;
wire    dfq_ld_type,dfq_ifill_type,dfq_evict_type ;
wire    dfq_st_ack_type,dfq_strm_st_ack_type,dfq_int_type;
wire  [5:0]     dfq_rptr_w_wrap ;   // 3b ptr with wrap bit.
wire  [3:0]   imiss_dcd_b54 ;
//wire    st_ack_rq_stb ;
//wire  [1:0] st_ack_tid ;
wire  [3:0] cpu_sel ;
wire  [1:0] fwdpkt_l2bnk_addr ;
//wire  [2:0] intrpt_l2bnk_addr ;
//wire  [3:0] dfq_byp_sel_m, dfq_byp_sel_g ;
//wire  [1:0] ld_error0,ld_error1,ld_error2,ld_error3 ;
//wire  [4:0] ld_l1hit_rd_m,ld_l1hit_rd_g;
wire  [4:0] ld_l1hit_rd_m;
//wire  [13:0]  dfq_inv_data ;
// wire  [13:9]  dfq_inv_data_b13to9 ;
// wire  [7:2]   dfq_inv_data_b7to2 ;
// wire          dfq_inv_data_b0 ;
wire                        dfq_inv_data_val ;
wire  [2-1:0]  dfq_inv_data_way ;
wire          fwdpkt_vld;
wire  [3:0]   dfill_dcd_thrd ;
wire  [3:0]   error_rst ;
wire          dfq_ld_vld;
wire          dfq_byp_vld ;
wire          reset;
wire          st_rd_advance;
wire	vld_dfq_pkt ;
wire          dfq_vld_entry_exists_w;
wire          dfq_rdata_local_pkt;
wire 	      dfq_st_cmplt ;
wire          cpx_fp_type ;
wire	dfq_stall, dfq_stall_d1 ;
wire          cpx_error_type ;
wire          dfq_error_type ;
wire          cpx_fwd_req_ic ;
wire          dfq_fwd_req_ic_type ;
wire          dfq_rd_vld_d1 ;


    wire dbb_reset_l;
    wire clk;
    dffrl_async rstff(.din (grst_l),
                        .q   (dbb_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

assign  reset  =  ~dbb_reset_l;
assign  clk = rclk;



//wire                   lsu_bist_wvld_e;
//wire                   lsu_bist_rvld_e;

//dff #(2) mbist_stge (
//   .din ({mbist_dcache_write, mbist_dcache_read}),
//   .q   ({lsu_bist_wvld_e,    lsu_bist_rvld_e  }),
//   .clk (clk),
//   .se  (1'b0),       .si (),          .so ()
//);   
   
//=================================================================================================
// SHADOW SCAN
//=================================================================================================

// Monitors whether there is a valid entry in the dfq.
assign	lsu_dfq_vld_entry_w = dfq_vld_entry_exists_w ;
// Monitors whether dfq_byp flop remains full
//assign	lsu_sscan_data[?] = dfq_byp_full ;
   
//=================================================================================================
//
// QDP2 Specific Control
//
//=================================================================================================

// Need to be careful. This may prevent stores
//assign  dcfill_src_dfq_sel = dcfill_active_e ;





//=================================================================================================
//  IMISS X-INVALIDATION
//=================================================================================================

// Assume all imisses are alligned to a 32B boundary in L2 ?
// trin note: in piton, xinval is not used

wire  imiss0_inv_en, imiss1_inv_en ;
wire  imiss2_inv_en, imiss3_inv_en ;
wire  [10:5] imiss0_set_index,imiss1_set_index ;
wire  [10:5] imiss2_set_index,imiss3_set_index ;
//8/28/03 - vlint cleanup
//wire  [10:4] imiss0_set_index,imiss1_set_index ;
//wire  [10:4] imiss2_set_index,imiss3_set_index ;

assign  imiss0_inv_en = ifu_pcx_pkt_b51 & ~ifu_pcx_pkt_b41t40[1] & ~ifu_pcx_pkt_b41t40[0] & lsu_imiss_pcx_rq_sel_d1 ;
assign  imiss1_inv_en = ifu_pcx_pkt_b51 & ~ifu_pcx_pkt_b41t40[1] &  ifu_pcx_pkt_b41t40[0] & lsu_imiss_pcx_rq_sel_d1 ;
assign  imiss2_inv_en = ifu_pcx_pkt_b51 &  ifu_pcx_pkt_b41t40[1] & ~ifu_pcx_pkt_b41t40[0] & lsu_imiss_pcx_rq_sel_d1 ;
assign  imiss3_inv_en = ifu_pcx_pkt_b51 &  ifu_pcx_pkt_b41t40[1] &  ifu_pcx_pkt_b41t40[0] & lsu_imiss_pcx_rq_sel_d1 ;

dffe_s #(6) imiss_inv0 (
        .din    ({ifu_pcx_pkt_b10t5[5:0]}),
        .q      ({imiss0_set_index[10:5]}),
        .en (imiss0_inv_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dffe_s #(6) imiss_inv1 (
        .din    ({ifu_pcx_pkt_b10t5[5:0]}),
        .q      ({imiss1_set_index[10:5]}),
        .en (imiss1_inv_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dffe_s #(6) imiss_inv2 (
        .din    ({ifu_pcx_pkt_b10t5[5:0]}),
        .q      ({imiss2_set_index[10:5]}),
        .en (imiss2_inv_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dffe_s #(6) imiss_inv3 (
        .din    ({ifu_pcx_pkt_b10t5[5:0]}),
        .q      ({imiss3_set_index[10:5]}),
        .en (imiss3_inv_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign  cpx_pkt_thrd_sel[0] = ~lsu_cpx_pkt_tid[1] & ~lsu_cpx_pkt_tid[0] ;
assign  cpx_pkt_thrd_sel[1] = ~lsu_cpx_pkt_tid[1] &  lsu_cpx_pkt_tid[0] ;
assign  cpx_pkt_thrd_sel[2] =  lsu_cpx_pkt_tid[1] & ~lsu_cpx_pkt_tid[0] ;
assign  cpx_pkt_thrd_sel[3] =  lsu_cpx_pkt_tid[1] &  lsu_cpx_pkt_tid[0] ;
// This needs to be included once the change for the stb bug is complete
wire  [6:1] imiss_inv_set_index ;
assign  imiss_inv_set_index[6:1] =
  cpx_pkt_thrd_sel[0] ? imiss0_set_index[10:5] : 
    cpx_pkt_thrd_sel[1] ? imiss1_set_index[10:5] : 
      cpx_pkt_thrd_sel[2] ? imiss2_set_index[10:5] : 
        cpx_pkt_thrd_sel[3] ? imiss3_set_index[10:5] : 6'bxx_xxxx ;  



//=================================================================================================
//  FWD REPLY/REQUEST
//=================================================================================================

// cpx pkt decode. fwd req/reply do not go into dfq.


//assign  tap_thread[0] = ~lsu_iobrdge_tap_rq_type[1] & ~lsu_iobrdge_tap_rq_type[0] ;
//assign  tap_thread[1] = ~lsu_iobrdge_tap_rq_type[1] &  lsu_iobrdge_tap_rq_type[0] ;
//assign  tap_thread[2] =  lsu_iobrdge_tap_rq_type[1] & ~lsu_iobrdge_tap_rq_type[0] ;
//assign  tap_thread[3] =  lsu_iobrdge_tap_rq_type[1] &  lsu_iobrdge_tap_rq_type[0] ;

// This is the pkt from the TAP to be returned to the TAP
//assign  cpx_reverse_req = cpx_spc_data_cx[130] ;
assign  cpx_reverse_req = cpx_spc_data_cx_b130;

// removed tap_rq_type[2] from the data_sel logic
assign  lsu_iobrdge_rply_data_sel[0] =  // defeature, margin, bist
  (|lsu_iobrdge_tap_rq_type[5:3]) & cpx_reverse_req_d1 ;
assign  lsu_iobrdge_rply_data_sel[1] =  // i/dcache
  (|lsu_iobrdge_tap_rq_type[7:6] & ~(|lsu_iobrdge_tap_rq_type[5:3])) & cpx_reverse_req_d1 ;
// regular fwd pkt
//  - sothea - 0in bug - can be 0-hot
//assign  lsu_iobrdge_rply_data_sel[2] = ~((|lsu_iobrdge_tap_rq_type[7:3]) & cpx_reverse_req_d1) ;
assign  lsu_iobrdge_rply_data_sel[2] = ~|lsu_iobrdge_rply_data_sel[1:0] ;

wire dcache_iob_rd,dcache_iob_rd_e, dcache_iob_rd_m, dcache_iob_rd_w ;
assign	dcache_iob_rd = lsu_iobrdge_tap_rq_type[6] & lsu_iobrdge_fwd_pkt_vld ;

dff_s  dciob_rd_e (
        .din    (dcache_iob_rd),
        .q      (dcache_iob_rd_e),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  dciob_rd_m (
        .din    (dcache_iob_rd_e),
        .q      (dcache_iob_rd_m),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  dciob_rd_w (
        .din    (dcache_iob_rd_m),
        .q      (dcache_iob_rd_w),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	lsu_dcache_iob_rd_w = dcache_iob_rd_w ;

wire  cpx_fwd_rq_type ;
assign  cpx_fwd_rq_type =
        cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // fwd req
        cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140];
wire  cpx_fwd_rply_type ;
assign  cpx_fwd_rply_type =
        cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // fwd reply
        cpx_spc_data_cx_b144to140[140+1] &  cpx_spc_data_cx_b144to140[140] ;

// cpx pkt decode. fwd req/reply do not go into dfq.
assign  cpx_fwd_req =
         cpx_spc_data_cx_b144to140[144] & ~cpx_reverse_req & cpx_fwd_rq_type ;

//8/25/03: add fwd req to L1I$ for RAMTEST to dfq_wr_en, dfq_rd_dvance
//bug4293 - set fwd_req_ic based on cpx_fwd_req_type and not based on cpx_fwd_req. this causes the request to 
//          de dropped i.e. not written into dfq 'cos cpx_fwd_req_ic is not set
//assign  cpx_fwd_req_ic =  cpx_fwd_req & cpx_spc_data_cx_b103 ;

assign  cpx_fwd_req_ic =  cpx_spc_data_cx_b144to140[144] & cpx_fwd_rq_type &
                          cpx_reverse_req & cpx_spc_data_cx_b103 ;

assign  cpx_fwd_pkt_en_cx = cpx_fwd_req | cpx_fwd_reply ;

assign  cpx_fwd_reply =
         cpx_spc_data_cx_b144to140[144] & (cpx_fwd_rply_type | (cpx_fwd_rq_type & cpx_reverse_req)) ;

wire fwd_reply_vld;
dff_s #(1) fwdpkt_stgd1 (
        .din    (fwd_reply_vld),
        .q      (lsu_pcx_fwd_reply),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );


// Requests from iobrdge will not be speculative as core is expected to be quiescent.
assign  fwdpkt_reset = 
  (reset | lsu_fwdpkt_pcx_rq_sel) ; 
  // (reset | (lsu_fwdpkt_pcx_rq_sel & ~pcx_req_squash)) ; 
wire	fwdpkt_vld_unmasked,fwdpkt_vld_unmasked_d1 ;
wire	fwd_unc_err ;
wire    fwd_req_vld;
// There can be only one outstanding fwd reply or request.
dffre_s #(7)  fwdpkt_ff (
        .din    ({cpx_fwd_pkt_en_cx,cpx_fwd_req,cpx_fwd_reply, 
		cpx_spc_data_cx_b138,cpx_spc_data_cx_b71to70[1:0], cpx_reverse_req}),
        .q      ({fwdpkt_vld_unmasked,fwd_req_vld,fwd_reply_vld, 
		fwd_unc_err,fwdpkt_l2bnk_addr[1:0],cpx_reverse_req_d1}),
  .rst  (fwdpkt_reset), .en (cpx_fwd_pkt_en_cx),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	fwd_rply_sz1_unc ; // Either size[1] for fwd-rq or unc-err for fwd-rply.
assign	fwd_rply_sz1_unc = fwd_reply_vld ? fwd_unc_err : 1'b1 ;	

dff_s  fpktunc_d1 (
        .din    (fwd_rply_sz1_unc),
        .q      (lsu_fwd_rply_sz1_unc),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  fpktv_d1 (
        .din    (fwdpkt_vld_unmasked),
        .q      (fwdpkt_vld_unmasked_d1),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );


wire icache_rd_done,icache_wr_done ;
dff_s #(2) ifwd_d1 (
        .din    ({ifu_lsu_fwd_data_vld,ifu_lsu_fwd_wr_ack}),
        .q      ({icache_rd_done,icache_wr_done}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

// make one-shot : read data may be off.
assign  lsu_iobrdge_fwd_pkt_vld = fwdpkt_vld_unmasked & ~fwdpkt_vld_unmasked_d1 & cpx_reverse_req_d1 ;
//assign  lsu_iobrdge_fwd_pkt_vld = fwdpkt_vld ;
assign  fwdpkt_vld = 
	// immediate for all but dcache rd.
	(fwdpkt_vld_unmasked & ~((|lsu_iobrdge_tap_rq_type[7:6]) & cpx_reverse_req_d1)) |
        // dcache rd - wait until w.
	(fwdpkt_vld_unmasked &  lsu_iobrdge_tap_rq_type[6] & cpx_reverse_req_d1 & 
		~(dcache_iob_rd | dcache_iob_rd_e | dcache_iob_rd_m | dcache_iob_rd_w)) |
	// icache rd - wait for rd & wr 
	(fwdpkt_vld_unmasked &  lsu_iobrdge_tap_rq_type[7] & cpx_reverse_req_d1 &
			(icache_rd_done | icache_wr_done)) ;

assign  lsu_fwdpkt_vld  =  fwdpkt_vld;

assign  lsu_fwdpkt_dest[0] = fwd_req_vld & ~fwdpkt_l2bnk_addr[1] & ~fwdpkt_l2bnk_addr[0] ; // l2bank=0
assign  lsu_fwdpkt_dest[1] = fwd_req_vld & ~fwdpkt_l2bnk_addr[1] &  fwdpkt_l2bnk_addr[0] ; // l2bank=1
assign  lsu_fwdpkt_dest[2] = fwd_req_vld &  fwdpkt_l2bnk_addr[1] & ~fwdpkt_l2bnk_addr[0] ; // l2bank=2
assign  lsu_fwdpkt_dest[3] = fwd_req_vld &  fwdpkt_l2bnk_addr[1] &  fwdpkt_l2bnk_addr[0] ; // l2bank=3
assign  lsu_fwdpkt_dest[4] = fwd_reply_vld ; // reply always goes back to IO Bridge

//=================================================================================================
//  INTERRUPT CPX PKT REQ CTL
//=================================================================================================

//bug6322
//assign  lsu_tlu_cpx_vld = cpx_spc_data_cx_b144to140[`CPX_VLD] & ~cpx_spc_data_cx_b136 ;
//assign  lsu_tlu_cpx_req[3:0] = cpx_spc_data_cx_b144to140[`CPX_RQ_HI:`CPX_RQ_LO] ;
//assign  lsu_tlu_intpkt[17:0] = cpx_spc_data_b17t0_cx[17:0] ;

   wire lsu_tlu_cpx_vld_din_l;
   wire [17:0] lsu_tlu_intpkt_din;
   wire [3:0]  lsu_tlu_cpx_req_din_l;
   
assign  lsu_tlu_cpx_vld_din_l = ~(dfq_int_type & ~lsu_dfq_rdata_flush_bit & dfq_rd_advance) ; 
assign  lsu_tlu_intpkt_din[17:0] = lsu_dfq_rdata_b17_b0[17:0] ;
assign  lsu_tlu_cpx_req_din_l[3:0] = ~ lsu_dfq_rdata_rq_type[3:0];

   wire lsu_tlu_cpx_vld_l;
   wire [3:0] lsu_tlu_cpx_req_l;
   
dff_s  #(23) lsu_tlu_stg (
        .din    ({lsu_tlu_cpx_vld_din_l, lsu_tlu_intpkt_din[17:0], lsu_tlu_cpx_req_din_l[3:0]}),
        .q      ({lsu_tlu_cpx_vld_l,     lsu_tlu_intpkt[17:0], lsu_tlu_cpx_req_l[3:0]}),
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        );

   assign     lsu_tlu_cpx_vld = ~lsu_tlu_cpx_vld_l;
   assign     lsu_tlu_cpx_req[3:0] = ~lsu_tlu_cpx_req_l[3:0];
   
//=================================================================================================
//  STQUAD PKT CONTROL
//=================================================================================================





//=================================================================================================
// SECONDARY VS. PRIMARY LOADS
//=================================================================================================

   
// NOT USED
//wire  [1:0] dfq_sel_tid ;
//assign  dfq_sel_tid[1:0] = 
//  // select byp tid if ld from cfq or cpx will be latched in byp ff next cycle
//  (dfq_byp_ld_vld & ((dfq_rptr_vld_d1 & dfq_rd_advance) | (cpx_spc_data_cx_b144to140[`CPX_VLD] & ~dfq_wr_en))) ? 
//  dfq_byp_tid[1:0] : dfq_tid[1:0] ;

//temp, send to dctl, phase 2     
assign  ld_sec_active = 1'b0 ;
   
assign  dfq_thread0 = ~dfq_tid[1] & ~dfq_tid[0] ;
assign  dfq_thread1 = ~dfq_tid[1] &  dfq_tid[0] ;
assign  dfq_thread2 =  dfq_tid[1] & ~dfq_tid[0] ;
assign  dfq_thread3 =  dfq_tid[1] &  dfq_tid[0] ;

// NOT USED
//assign  ld_any_thrd_byp_sel = |(ld_thrd_byp_sel[3:0]);

// phase 2 change   
// L2$ sends response for both prim and sec requests. Both will go into DFQ
// and fill D$
// can we eliminate dcfill_active_e ?
   
//11/7/03 - add rst_tri_en
wire  [3:0]  dfq_byp_sel_tmp ;
   assign dfq_byp_sel_tmp[0]  = dfq_thread0  & dcfill_active_e & ~lsu_cpx_pkt_prefetch;
   assign dfq_byp_sel_tmp[1]  = dfq_thread1  & dcfill_active_e & ~lsu_cpx_pkt_prefetch;
   assign dfq_byp_sel_tmp[2]  = dfq_thread2  & dcfill_active_e & ~lsu_cpx_pkt_prefetch;
   assign dfq_byp_sel_tmp[3]  = dfq_thread3  & dcfill_active_e & ~lsu_cpx_pkt_prefetch;

   assign dfq_byp_sel[2:0]  =  dfq_byp_sel_tmp[2:0]  & {3{~rst_tri_en}} ;
   assign dfq_byp_sel[3]    =  dfq_byp_sel_tmp[3]    | rst_tri_en ;
   
//   assign lsu_dfq_byp_mxsel[0]  = dfq_thread0  & dcfill_active_e;
//   assign lsu_dfq_byp_mxsel[1]  = dfq_thread1  & dcfill_active_e;
//   assign lsu_dfq_byp_mxsel[2]  = dfq_thread2  & dcfill_active_e;
//   assign lsu_dfq_byp_mxsel[3]  = ~|lsu_dfq_byp_mxsel[2:0];
   
// includes store cmplt tid also. 
assign  dfill_dcd_thrd[0] =   dfq_byp_sel[0] |    // for load
        (dfq_thread0 & stdq_active_e)  ;// for store
assign  dfill_dcd_thrd[1] =   dfq_byp_sel[1] |    // for load
        (dfq_thread1 & stdq_active_e)  ;// for store
assign  dfill_dcd_thrd[2] =   dfq_byp_sel[2] |    // for load
        (dfq_thread2 & stdq_active_e)  ;// for store
assign  dfill_dcd_thrd[3] =   dfq_byp_sel[3] |    // for load
        (dfq_thread3 & stdq_active_e)  ;// for store

assign  lsu_dfill_dcd_thrd[3:0]  =  dfill_dcd_thrd[3:0];

//=================================================================================================
//  Error Related Logic
//=================================================================================================

// Equivalent of lmq but lmq has run out of bits
// Following bits need to be logged.
// Dtag parity error 
//  - output on bit 130 of equivalent ld pkt
//  - when cpx pkt is at head of cfq, then log error
//  and take corresponding trap synchronous to pipe.
// DCache parity error
//  - when cpx pkt is at head of cfq, then log error
//  and take corresponding trap synchronous to pipe.


// The load component of the cpx response for an atomic will
// save it's error info for the store component. The store
// component will take the trap in the g stage, depending
// on the error information from the ld. However, it can
// always override the parity error info initially written,
// as atomics do not lookup the cache or tag.


//assign  error_en[0] = lmq_enable[0] | (lsu_cpx_pkt_atm_st_cmplt & dcfill_active_e & dfq_byp_sel[0]);
assign  error_en[0] = 
	//lsu_ld_inst_vld_g[0] | (lsu_cpx_pkt_atm_st_cmplt & dcfill_active_e & dfq_byp_sel[0]); // Bug 3624
	lsu_ld_inst_vld_g[0] ; 
assign  error_en[1] = 
	lsu_ld_inst_vld_g[1] ; 
assign  error_en[2] = 
	lsu_ld_inst_vld_g[2] ; 
assign  error_en[3] = 
	lsu_ld_inst_vld_g[3] ;

// 10/15/03: error reset is set only by reset. lsu_ld[0-3]_pcx_rq_sel_d1 is not needed because the
//           the flop is used only for reporting error to ifu. Also, the error_en is set for new requests.
//tmp fix for reset
//wire              lsu_pcx_ld_dtag_perror_w2 ;
//assign lsu_pcx_ld_dtag_perror_w2  = 1'b0;

//assign  error_rst[0] = reset | (lsu_ld0_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst[1] = reset | (lsu_ld1_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst[2] = reset | (lsu_ld2_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;
//assign  error_rst[3] = reset | (lsu_ld3_pcx_rq_sel_d1 & lsu_pcx_ld_dtag_perror_w2) ;

assign  error_rst[0] = reset ;
assign  error_rst[1] = reset ;
assign  error_rst[2] = reset ;
assign  error_rst[3] = reset ;

//assign  lsu_error_rst[3:0]  =  error_rst[3:0];

wire	dtag_perror3,dtag_perror2,dtag_perror1,dtag_perror0;

// Thread 0
wire dcache_perror0;
dffre_s  #(2) error_t0 (
        .din    ({lsu_dcache_tag_perror_g,lsu_dcache_data_perror_g}),
    //lsu_cpx_pkt_ld_err[1:0]}),
        .q      ({dtag_perror0,dcache_perror0}),
        //.q      ({dtag_perror0,dcache_perror0,ld_error0[1:0]}),
        .rst  (error_rst[0]), .en     (error_en[0]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 1
wire dcache_perror1;
dffre_s  #(2) error_t1 (
        .din    ({lsu_dcache_tag_perror_g,lsu_dcache_data_perror_g}),
    //lsu_cpx_pkt_ld_err[1:0]}),
        .q      ({dtag_perror1,dcache_perror1}),
        //.q      ({dtag_perror1,dcache_perror1,ld_error1[1:0]}),
        .rst  (error_rst[1]), .en     (error_en[1]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 2
wire dcache_perror2;
dffre_s  #(2) error_t2 (
        .din    ({lsu_dcache_tag_perror_g,lsu_dcache_data_perror_g}),
    //lsu_cpx_pkt_ld_err[1:0]}),
        .q      ({dtag_perror2,dcache_perror2}),
        //.q      ({dtag_perror2,dcache_perror2,ld_error2[1:0]}),
        .rst  (error_rst[2]), .en     (error_en[2]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

// Thread 3
wire dcache_perror3;
dffre_s  #(2) error_t3 (
        .din    ({lsu_dcache_tag_perror_g,lsu_dcache_data_perror_g}),
    //lsu_cpx_pkt_ld_err[1:0]}),
        .q      ({dtag_perror3,dcache_perror3}),
        //.q      ({dtag_perror3,dcache_perror3,ld_error3[1:0]}),
        .rst  (error_rst[3]), .en     (error_en[3]),               
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );            

//assign	lsu_dtag_perror_w2[3] = dtag_perror3 ;
//assign	lsu_dtag_perror_w2[2] = dtag_perror2 ;
//assign	lsu_dtag_perror_w2[1] = dtag_perror1 ;
//assign	lsu_dtag_perror_w2[0] = dtag_perror0 ;

// Determine if ld pkt requires correction due to dtag parity error.
//5/22/03: moved to qctl1
//assign  lsu_pcx_ld_dtag_perror_w2 =
//  ld_pcx_rq_sel[0] ? dtag_perror0 :
//    ld_pcx_rq_sel[1] ? dtag_perror1 :
//      ld_pcx_rq_sel[2] ? dtag_perror2 : dtag_perror3 ;

// Now post sparc related errors and take traps
// error is reset after it is sent to pcx. the logic below will never be set!!
assign  lsu_cpx_ld_dtag_perror_e =
  dfq_byp_sel[0] ? dtag_perror0 :
    dfq_byp_sel[1] ? dtag_perror1 :
      dfq_byp_sel[2] ? dtag_perror2 : (dfq_byp_sel[3] & dtag_perror3) ; // Bug 4655

assign  lsu_cpx_ld_dcache_perror_e =
  dfq_byp_sel[0] ? dcache_perror0 :
    dfq_byp_sel[1] ? dcache_perror1 :
      dfq_byp_sel[2] ? dcache_perror2 : (dfq_byp_sel[3] & dcache_perror3) ; // Bug 4655

//Bug 3624
/*
assign  lsu_cpx_atm_st_err[1:0] =
  cpx_pkt_thrd_sel[0] ? ld_error0[1:0] :
    cpx_pkt_thrd_sel[1] ? ld_error1[1:0] :
      cpx_pkt_thrd_sel[2] ? ld_error2[1:0] : ld_error3[1:0] ;*/ 

//===
wire memref_e;

dff_s #(1) stge_ad_e (
  .din (ifu_lsu_memref_d),
  .q   (memref_e),
  .clk (clk),
  .se     (1'b0),       .si (),          .so ()
);
   
  
  
  
//=================================================================================================
//  LDD HANDLING
//=================================================================================================

assign ldd_vld_reset =
        (reset | (dcfill_active_e & ldd_in_dfq_out)); 

// prefetch qual is required for case where prefetch may get interference
// from lmq contents set by a later load that issues before the prefetch
// is returned.
// integer
assign ldd_vld_en = lmq_ldd_vld & ~lsu_cpx_pkt_prefetch & dcfill_active_e ;
// fp
assign lsu_fldd_vld_en = lmq_ldd_vld & ~lsu_cpx_pkt_prefetch & lsu_l2fill_fpld_e & dcfill_active_e ;


dffre_s   ldd_in_dfq_ff (
        .din    (lmq_ldd_vld), .q  (ldd_in_dfq_out),
        .rst    (ldd_vld_reset),        .en     (ldd_vld_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 


wire lsu_ignore_fill;
//dfq_ld_vld is redundant   
assign lsu_ignore_fill = dfq_ld_vld & lmq_ldd_vld & ~ldd_in_dfq_out & dcfill_active_e ;


dff_s #(5)   dfq_rd_m (
        .din    (ifu_lsu_rd_e[4:0]), .q  (ld_l1hit_rd_m[4:0]),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//dff #(5)   dfq_rd_g (
//        .din    (ld_l1hit_rd_m[4:0]), .q  (ld_l1hit_rd_g[4:0]),
//        .clk  (clk),
//        .se     (1'b0),       .si (),          .so ()
//        ); 

wire ldd_in_dfq_out_d1;
dff_s #(1)   stgd1_lrd (
        .din    (ldd_in_dfq_out), 
  .q    (ldd_in_dfq_out_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//dff #(1)   stgd2_lrd (
//        .din    (ldd_in_dfq_out_d1), 
//  .q    (ldd_in_dfq_out_d2),
//        .clk  (clk),
//        .se     (1'b0),       .si (),          .so ()
//        ); 


//wire [4:0] lmq_ld_rd1_g;   
//dff #(5) ff_lmq_ld_rd1 (
//        .din  (lmq_ld_rd1[4:0]), 
//        .q    (lmq_ld_rd1_g[4:0]),
//        .clk  (clk),
//        .se   (1'b0),       .si (),          .so ()
//        ); 
   

// Stage l2fill vld
//wire	l2fill_vld_m, l2fill_vld_g ;
wire	l2fill_vld_e,l2fill_vld_m ;
dff_s    	l2fv_stgm (
        .din  (l2fill_vld_e), 
  	.q    (l2fill_vld_m),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        ); 

//dff    	l2fv_stgg (
//        .din  (l2fill_vld_m), 
//  	.q    (l2fill_vld_g),
//        .clk  (clk),
//        .se   (1'b0),       .si (),          .so ()
//        ); 

wire	ld_inst_vld_m ;
dff_s    	lvld_stgm (
        .din  (ld_inst_vld_e), 
  	.q    (ld_inst_vld_m),
        .clk  (clk),
        .se   (1'b0),       .si (),          .so ()
        ); 

//wire	ld_inst_vld_g ;
//dff    	lvld_stgg (
//        .din  (ld_inst_vld_m), 
//  	.q    (ld_inst_vld_g),
//        .clk  (clk),
//        .se   (1'b0),       .si (),          .so ()
//        ); 

wire	ldd_in_dfq_out_vld ;
assign	ldd_in_dfq_out_vld = ldd_in_dfq_out_d1 & l2fill_vld_m ;
assign lsu_exu_rd_m[4:0] = 
  ld_inst_vld_m ? ld_l1hit_rd_m[4:0] : 
    		ldd_in_dfq_out_vld ?  {lmq_ld_rd1[4:1],~lmq_ld_rd1[0]} 
						: lmq_ld_rd1[4:0];
/*wire	ldd_in_dfq_out_vld ;
assign	ldd_in_dfq_out_vld = ldd_in_dfq_out_d2 & l2fill_vld_g ;
assign lsu_exu_rd_w2[4:0] = 
  ld_inst_vld_g ? ld_l1hit_rd_g[4:0] : 
    		ldd_in_dfq_out_vld ?  {lmq_ld_rd1_g[4:1],~lmq_ld_rd1_g[0]} 
						: lmq_ld_rd1_g[4:0];*/


// Generate data select for 128b. ldd will cause hi-order 8B followed by low order
// 8B to be selected.

// ldd will select from same 64b dw.
assign  lsu_dfill_data_sel_hi = ~lmq_ld_addr_b3 ^ (ldd_in_dfq_out & ~ldd_non_alt_space) ;

// ldd non-alternate space. sz distinguishes between quad, fp ldd and int ldd.
// quad ldd, fp ldd sz = 2'b11, int ldd sz = 2'b10   
assign  ldd_non_alt_space = lsu_byp_misc_sz_e[1] & ~lsu_byp_misc_sz_e[0] ;

assign  ldd_oddrd_e = ldd_in_dfq_out & ldd_non_alt_space ;

dff_s   ldd_stgm (
        .din    (ldd_oddrd_e), 
  .q    (lsu_byp_ldd_oddrd_m),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// all incoming ld and inv packets must be written to dfq or its bypass flop.
// wrt ptr must be updated in cycle that cpx pkt is sent.

// invalidate does not need bubble, only ld bypass and/or fill.
// fill bypass can only occur if bubble is in pipeline.

//------
// strm ack cmplt - needs to be visible in dcache
//------

//bug4460 - qualify stream store ack w/ local packet
//Bug4969
wire    dfq_local_pkt ;
wire	strmack_cmplt1, strmack_cmplt2, strmack_cmplt3 ;
wire	strmack_cmplt1_d1, strmack_cmplt2_d1, strmack_cmplt3_d1 ;
//wire	strm_ack_cmplt ;
assign	strmack_cmplt1 =
	// check inflight, no inv. if inv, write to dfq_byp.
	(cpx_strm_st_ack_type & ~(dfq_wr_en | lsu_cpx_spc_inv_vld) & 
         (const_cpuid[2:0] == cpx_spc_data_cx_b120to118[120:118])) ;
assign	strmack_cmplt2 = 
	// check dfq-rd - no inv, gets dropped.
	(lsu_dfq_byp_type[1] & dfq_rd_advance & ~lsu_dfq_byp_cpx_inv & local_pkt) ;
assign	strmack_cmplt3 = 
	// check dfq-rd - inv, and thus process from dfq_bypass.
	(lsu_cpx_pkt_strm_ack & inv_active_e & dfq_inv_vld & dfq_local_pkt) ;

/*assign	strm_ack_cmplt =
	// check inflight, no inv. if inv, write to dfq_byp.
	(cpx_strm_st_ack_type & ~(dfq_wr_en | lsu_cpx_spc_inv_vld) & 
         (const_cpuid[2:0] == cpx_spc_data_cx_b120to118[`CPX_INV_CID_HI:`CPX_INV_CID_LO])) |
	// check dfq-rd - no inv, gets dropped.
	(lsu_dfq_byp_type[1] & dfq_rd_advance & ~lsu_dfq_byp_cpx_inv & local_pkt) |
	// check dfq-rd - inv, and thus process from dfq_bypass.
	(lsu_cpx_pkt_strm_ack & inv_active_e & dfq_inv_vld & dfq_local_pkt) ;*/

dff_s #(3)   strmackcnt_stg (
        .din  	({strmack_cmplt3,strmack_cmplt2,strmack_cmplt1}), 
        .q  	({strmack_cmplt3_d1,strmack_cmplt2_d1,strmack_cmplt1_d1}), 
        .clk  	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

assign	lsu_spu_strm_ack_cmplt[0] =	// lsb  of cnt, 1 or 3.
	(~strmack_cmplt1_d1 & ~strmack_cmplt2_d1 &  strmack_cmplt3_d1) | //001
	(~strmack_cmplt1_d1 &  strmack_cmplt2_d1 & ~strmack_cmplt3_d1) | //010
	( strmack_cmplt1_d1 &  strmack_cmplt2_d1 &  strmack_cmplt3_d1) | //111
	( strmack_cmplt1_d1 & ~strmack_cmplt2_d1 & ~strmack_cmplt3_d1) ; //100

assign	lsu_spu_strm_ack_cmplt[1] =	// msb  of cnt, 2 or 3.
	(strmack_cmplt1_d1 & strmack_cmplt2_d1) |
	(strmack_cmplt2_d1 & strmack_cmplt3_d1) |
	(strmack_cmplt1_d1 & strmack_cmplt3_d1) ;

/*dff   strmack_d1 (
        .din  (strm_ack_cmplt), 
  	.q    (lsu_spu_strm_ack_cmplt),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */
	
// Active as soon as it is visible in dfq byp ff.
assign  inv_active_e = dfq_inv_vld ;      // evict/icache/strm-st
//wire  st_atm_err ;
// An atomic st is forced to punch a bubble in the pipe if
// an error is encountered on the load. error en is not checked
// at this point.
/*assign  st_atm_err = 
  ((|lsu_cpx_atm_st_err[1:0]) & lsu_cpx_pkt_atm_st_cmplt) ;*/

assign  stwr_active_e = 
  dfq_st_vld & dfq_local_inv  & ~memref_e &
  ~lsu_cpx_pkt_atm_st_cmplt & ~lsu_cpx_pkt_binit_st ;
// & ~lsu_cpx_pkt_stquad_pkt2 ;  // fix for ifill_pkt_vld -b[130]
//  dfq_st_vld & local_inv & ~st_ack_rq_stb_d1 & ~memref_e & //st ack timing fix
//  ~lsu_cpx_pkt_stquad_pkt2 // bug 2942

assign  stdq_active_e = 
  dfq_st_vld & 
  //((~dfq_local_inv & (~st_atm_err | (st_atm_err & ~memref_e))) | //Bug 3624
  ((~dfq_local_inv) | 
   (dfq_local_inv & ~memref_e)) ;
//  ((~local_inv & (~st_atm_err | (st_atm_err & ~memref_e))) | 
//   (local_inv & (~st_ack_rq_stb_d1 & ~memref_e))) ;


assign	dfq_st_cmplt = stdq_active_e | (inv_active_e & dfq_st_vld) ;

wire	atm_st_cmplt ;
assign  atm_st_cmplt = dfq_st_cmplt & lsu_cpx_pkt_atm_st_cmplt ; 
assign  lsu_atm_st_cmplt_e = atm_st_cmplt ;

assign  dcfill_active_e = dfq_ld_vld & ~memref_e ;

//bug3753 - qualify ld*_fill_reset w/ dcfill_active & ~ignore_fill
//          in qctl1 this is qual'ed w/ dfq_ld_vld
assign  lsu_dcfill_active_e  =  dcfill_active_e & ~lsu_ignore_fill;
//assign  lsu_dcfill_active_e  =  dcfill_active_e;

assign  dva_svld_e = 
  inv_active_e |      // evict/icache/strm-st
  (dfq_st_vld & lsu_cpx_pkt_perror_dinv) |	// dtag parity error invalidation.
  (dfq_local_inv & dfq_st_vld & // local st - atomic
  lsu_cpx_pkt_atomic ) ;
  //lsu_cpx_pkt_atomic & ~lsu_cpx_pkt_stquad_pkt2) ; // store quad pkt not present - cmp1_regr fail
  //(local_inv & dfq_st_vld & // local st - stquad/atomic
assign  l2fill_vld_e  = dcfill_active_e & 
			~lsu_cpx_pkt_prefetch ; // prefetch will not fill

assign	lsu_l2fill_vld = dcfill_active_e ;

//=================================================================================================
//  DFQ RD/WR CONTROL
//=================================================================================================
  
//assign  cpx_inv =
//  lsu_cpu_inv_data[`CPX_AX0_INV_DVLD]   |   // line 0
//  lsu_cpu_inv_data[`CPX_AX1_INV_DVLD+4] |   // line 1
//  lsu_cpu_inv_data[`CPX_AX0_INV_DVLD+7] |   // line 2
//  lsu_cpu_inv_data[`CPX_AX1_INV_DVLD+11] ;  // line 3

// All invalidates go into byp buffer
assign  dfq_byp_ld_vld = lsu_dfq_byp_type[5] ;
// local store inv path is separate.
assign  dfq_byp_inv_vld = 
       (lsu_dfq_byp_type[4] & dfq_invwy_vld)  	| // icache x-inv
       (lsu_dfq_byp_type[3]    			| // evict
       (lsu_dfq_byp_type[2] & ~local_pkt)   	| // sparc st-ack - non-local
        lsu_dfq_byp_type[1] 			| // strm st-ack
	(lsu_dfq_byp_type[2] & local_pkt & lsu_dfq_byp_binit_st)) &     
				// blk init st invalidates L1
        lsu_dfq_byp_cpx_inv ;         // local invalidate
        //cpx_inv ;         // local invalidate

// Local store which writes to cache
//timing fix: 7/14/03 - to improve setup of dfq_st_vld and dfq_ld_vld and move the flop to qdp2 -
//            to eventually improve dcache_fill_data timing
//            add byp mux for cpuid in qctl2
wire  [2:0]  dfq_byp_cpuid ;
assign  dfq_byp_cpuid[2:0]  =  dfq_rd_vld_d1 ? lsu_dfq_rdata_cpuid[2:0] : 
                                   cpx_spc_data_cx_b120to118[120:118] ;

//assign  local_pkt =  &(const_cpuid[2:0] ~^ lsu_dfq_byp_cpuid[2:0]) ;
assign  local_pkt =  &(const_cpuid[2:0] ~^ dfq_byp_cpuid[2:0]) ;
assign  dfq_rdata_local_pkt =  &(const_cpuid[2:0] ~^ lsu_dfq_rdata_cpuid[2:0]) ;
assign  dfq_byp_st_vld = lsu_dfq_byp_type[2] & local_pkt ;

// Add ifill invalidate
// screen cpx data which gets written to dfq
assign  dfq_byp_vld = 
(dfq_byp_ld_vld | dfq_byp_inv_vld | dfq_byp_st_vld) & 
(dfq_rd_vld_d1 | (~dfq_rd_vld_d1 & ~dfq_wr_en))  ;  

//assign  lsu_dfq_byp_vld  =  dfq_byp_vld;

/*assign dfq_vld_reset =
        reset | ((dcfill_active_e | inv_active_e | stdq_active_e) & 
    ~dfq_vld_en & // dside pkt in waiting
    ~lsu_ignore_fill &  // ldd
    ~ld_ignore_sec  // secondary loads
    ) ; */

/*wire  ld_sec_rst, ld_sec_rst_d1 ;
assign  ld_sec_rst = dcfill_active_e & ld_ignore_sec_last ;
dff_s   secl_d1 (
        .din    (ld_sec_rst), .q  (ld_sec_rst_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

/* phase 2 change
assign dfq_vld_reset =
    // dside pkt in waiting, ldd, secondary loads
        reset | (dcfill_active_e & ~(dfq_vld_en | lsu_ignore_fill | (ld_ignore_sec & ~ld_ignore_sec_last))) |
    // dside pkt in waiting
          ((inv_active_e | stdq_active_e) & ~dfq_vld_en) ; 
*/

assign dfq_vld_reset =
    // dside pkt in waiting, ldd, no need secondary loads waiting
        reset | (dcfill_active_e & ~(dfq_vld_en | (lsu_ignore_fill & ~lsu_cpx_pkt_prefetch))) |
    // dside pkt in waiting
          ((inv_active_e | stdq_active_e) & ~dfq_vld_en) ; 
   
// vld is enabled only if both i and d side buffers are clear
// for co-dependent events. co-dependent events are rare.
wire    dfq_rd_advance_buf1 ;
assign dfq_vld_en = dfq_byp_vld & 
		(dfq_rd_advance_buf1 | 
		(cpx_spc_data_cx_b144to140[144] & vld_dfq_pkt & ~dfq_wr_en)) ;

/* phase 2 change
assign  dfq_byp_ff_en = 
  (~dfq_byp_full |
  ( dfq_byp_full & ((dcfill_active_e & ~(lsu_ignore_fill | ld_ignore_sec)) | 
       (inv_active_e | stdq_active_e)))) ; 
*/

assign  dfq_byp_ff_en = 
  (~dfq_byp_full |
  ( dfq_byp_full & ((dcfill_active_e & ~lsu_ignore_fill) | 
       (inv_active_e | stdq_active_e)))) ; 

//bug4576: add sehold to the flop enable in qdp2
assign lsu_dfq_byp_ff_en  =  sehold | dfq_byp_ff_en ;
   
   // i.e., byp currently filling.

/*
assign  dfq_byp_ff_en = 
  (~dfq_byp_full |
  (dfq_byp_full & (dcfill_active_e | inv_active_e | stdq_active_e) & ~(lsu_ignore_fill | ld_ignore_sec))) ; 
  // i.e., byp currently filling.
*/

// dfq bypass valid
//timing fix: 6/6/03: add duplicate flop for dfq_byp_ld_vld and dfq_byp_st_vld
//timing fix: 10/3/03 - add separate flop for lsu_dfq_vld lsu_dfq_st_vld to dctl
//bug4460:  qualify stream store ack w/ local packet - add local pkt flop
dffre_s  #(10) dfq_vld (
        .din({local_pkt,dfq_byp_st_vld,dfq_byp_vld,dfq_byp_vld,
              dfq_byp_ld_vld,dfq_byp_inv_vld,dfq_byp_st_vld,
              lsu_dfq_byp_cpx_inv,dfq_byp_ld_vld,dfq_byp_st_vld}),
        .q  ({dfq_local_pkt,lsu_dfq_st_vld,lsu_dfq_vld,dfq_byp_full,
              dfq_ld_vld,dfq_inv_vld,dfq_st_vld,
              dfq_local_inv,lsu_qdp2_dfq_ld_vld,lsu_qdp2_dfq_st_vld}),
//.din    ({dfq_byp_vld,dfq_byp_ld_vld,dfq_byp_inv_vld,dfq_byp_st_vld,cpx_inv,lsu_dfq_byp_cpx_inv}),
//.q      ({dfq_byp_full,dfq_ld_vld,dfq_inv_vld,dfq_st_vld,local_inv,dfq_local_inv}),
        .rst    (dfq_vld_reset),        .en     (dfq_vld_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                    

//bug4057: kill diagnostic write if dfq has valid requests to l1d$
//timing fix: 10/3/03 - add separate flop for lsu_dfq_vld
//assign  lsu_dfq_vld  =  dfq_byp_full ;

assign  lsu_dfq_ld_vld  =  dfq_ld_vld;
//timing fix: 9/29/03 - instantiate buffer for dfq_st_vld to dctl
//timing fix: 10/3/03 - remove buffer and add separate flop
//assign  lsu_dfq_st_vld  =  dfq_st_vld;
//bw_u1_buf_30x UZsize_lsu_dfq_st_vld_buf1 ( .a(dfq_st_vld), .z(lsu_dfq_st_vld) );
assign  lsu_dfq_ldst_vld  =  lsu_qdp2_dfq_ld_vld | lsu_qdp2_dfq_st_vld;


// Flop invalidate bits
dffe_s  #(2+1) dfq_inv (
        .din    ({lsu_cpu_inv_data_val,lsu_cpu_inv_data_way}),
        .q    ({dfq_inv_data_val,dfq_inv_data_way}),
        //.din    (lsu_cpu_inv_data[13:0]),
        //.q      (dfq_inv_data[13:0]),
        .en     (dfq_vld_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );                                    

// dfq_inv_data_b0


/*
assign  lsu_st_ack_addr_b54[0] = dfq_inv_data[4] | dfq_inv_data[11] ;
assign  lsu_st_ack_addr_b54[1] = dfq_inv_data[7] | dfq_inv_data[11] ;


assign  st_wrwy_sel[0] = ~lsu_st_ack_addr_b54[1] & ~lsu_st_ack_addr_b54[0] ;
assign  st_wrwy_sel[1] = ~lsu_st_ack_addr_b54[1] &  lsu_st_ack_addr_b54[0] ;
assign  st_wrwy_sel[2] =  lsu_st_ack_addr_b54[1] & ~lsu_st_ack_addr_b54[0] ;
assign  st_wrwy_sel[3] =  lsu_st_ack_addr_b54[1] &  lsu_st_ack_addr_b54[0] ;

assign  lsu_st_ack_wrwy[1:0]   = 
st_wrwy_sel[0] ? dfq_inv_data[`CPX_AX0_INV_WY_HI:`CPX_AX0_INV_WY_LO] :
  st_wrwy_sel[1] ? dfq_inv_data[`CPX_AX1_INV_WY_HI+4:`CPX_AX1_INV_WY_LO+4] :
    st_wrwy_sel[2] ? dfq_inv_data[`CPX_AX0_INV_WY_HI+7:`CPX_AX0_INV_WY_LO+7] :
      st_wrwy_sel[3] ? dfq_inv_data[`CPX_AX1_INV_WY_HI+11:`CPX_AX1_INV_WY_LO+11] :
            2'bxx ;
*/

// cpx invalidate data obtained via the cfq.
// b[8[ and b[1] are unused
//8/28/03: vlint cleanup - remove cpx_cpu_inv_data and use dfq_inv_data directly
//assign  cpx_cpu_inv_data[13:0] =  {dfq_inv_data_b13to9,1'b0,dfq_inv_data_b7to2,1'b0,dfq_inv_data_b0} ;
//assign  cpx_cpu_inv_data[13:0] =  dfq_inv_data[13:0] ;

// write control set up.   
// All cpx pkts are written.
// - unwanted pkts are explicity overwritten by next incoming pkt.

   /*wire stb_cam_hit_w2;
   
dff_s #(1)  stb_cam_hit_stg_w2  (
  .din (stb_cam_hit), 
  .q   (stb_cam_hit_w2),
  .clk (clk), 
  .se  (1'b0), .si (), .so ()
  ); */

// Need to include error pkt !!
//8/25/03: add error type to dfq_wr_en, dfq_rd_advance
//8/25/03: add fwd req to L1I$ for RAMTEST to dfq_wr_en, dfq_rd_dvance
assign	vld_dfq_pkt = 
cpx_int_type | cpx_ld_type | cpx_ifill_type | cpx_evict_type | cpx_st_ack_type | cpx_strm_st_ack_type | cpx_error_type | cpx_fwd_req_ic ;

//NOTE: restore cpx_inv qualification after adding cpx_inv part of dfq read - done

assign  dfq_wr_en = 
  // local st wr which writes to cache is put in dfq if cam-hit occurs.
  //(cpx_local_st_ack_type & stb_cam_hit_w2 & cpx_inv) |
  //(cpx_local_st_ack_type & stb_cam_hit_w2 & lsu_dfq_byp_cpx_inv) |
  //(cpx_local_st_ack_type) |  //bug2623
  (cpx_st_ack_type) |
  // always write under these conditions
  //(vld_dfq_pkt & (dfq_vld_entry_exists | dfq_rptr_vld_d1)) | 
  (vld_dfq_pkt & (dfq_vld_entry_exists_w | dfq_rptr_vld_d1)) | 
  //(cpx_spc_data_cx_b144to140[`CPX_VLD] & (dfq_vld_entry_exists | dfq_rptr_vld_d1)) | 
  // interrupts always write to queue
    cpx_int_type |
  // error type or forward request to l1i$ - bypass
   ((cpx_error_type | cpx_fwd_req_ic) & ifu_lsu_ibuf_busy)  |
  // selectively write under these conditions
   ((cpx_ld_type & ~dfq_byp_ff_en)          | 
    (cpx_ld_type &  cpx_spc_data_cx_b133 & ifu_lsu_ibuf_busy)  |
    (cpx_ifill_type & ifu_lsu_ibuf_busy)          |
    (cpx_ifill_type & cpx_spc_data_cx_b133 & ~dfq_byp_ff_en) |
    // the evictions/acks will wr to the dfq if any buffer is full
    ((cpx_evict_type | cpx_st_ack_type | cpx_strm_st_ack_type) & (ifu_lsu_ibuf_busy | ~dfq_byp_ff_en))) ;
      
assign  dfq_wptr_new_w_wrap[5:0]  = dfq_wptr_w_wrap[5:0] + {5'b00000, dfq_wr_en} ;
//assign  dfq_wptr_vld = dfq_wr_en ;
// every pkt is to be written to dfq. The pkt may be rejected by not updating
// write ptr based on certain conditions.
assign  dfq_wptr_vld = cpx_spc_data_cx_b144to140[144] ;

dffre_s  #(6) dfq_wptr_ff (
        .din    (dfq_wptr_new_w_wrap[5:0]), .q  (dfq_wptr_w_wrap[5:0]),
        .rst    (reset), .en (dfq_wr_en), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//1/20/04: mintime fix - add minbuf to dfq_wptr
//assign  dfq_wptr[4:0] = dfq_wptr_w_wrap[4:0] ;

wire  [4:0]  dfq_wptr_minbuf ;
bw_u1_minbuf_5x UZfix_dfq_wptr_b0_minbuf (.a(dfq_wptr_w_wrap[0]), .z(dfq_wptr_minbuf[0]));
bw_u1_minbuf_5x UZfix_dfq_wptr_b1_minbuf (.a(dfq_wptr_w_wrap[1]), .z(dfq_wptr_minbuf[1]));
bw_u1_minbuf_5x UZfix_dfq_wptr_b2_minbuf (.a(dfq_wptr_w_wrap[2]), .z(dfq_wptr_minbuf[2]));
bw_u1_minbuf_5x UZfix_dfq_wptr_b3_minbuf (.a(dfq_wptr_w_wrap[3]), .z(dfq_wptr_minbuf[3]));
bw_u1_minbuf_5x UZfix_dfq_wptr_b4_minbuf (.a(dfq_wptr_w_wrap[4]), .z(dfq_wptr_minbuf[4]));

bw_u1_buf_10x UZsize_dfq_wptr_b0_buf2 ( .a(dfq_wptr_minbuf[0]), .z(dfq_wptr[0]) );
bw_u1_buf_10x UZsize_dfq_wptr_b1_buf2 ( .a(dfq_wptr_minbuf[1]), .z(dfq_wptr[1]) );
bw_u1_buf_10x UZsize_dfq_wptr_b2_buf2 ( .a(dfq_wptr_minbuf[2]), .z(dfq_wptr[2]) );
bw_u1_buf_10x UZsize_dfq_wptr_b3_buf2 ( .a(dfq_wptr_minbuf[3]), .z(dfq_wptr[3]) );
bw_u1_buf_10x UZsize_dfq_wptr_b4_buf2 ( .a(dfq_wptr_minbuf[4]), .z(dfq_wptr[4]) );

// Bit3 of both pointers is a wrap bit. Including this in the compare
// will tell us whether the queue is empty or not. It is assumed that
// the wptr will never runover the rptr because of flow control.
// This will have to be fine-tuned once dfq is accurate !!!
assign  dfq_vld_entry_exists = (dfq_rptr_new_w_wrap[5:0] != dfq_wptr_w_wrap[5:0]) ;

assign  dfq_vld_entry_exists_w = (dfq_rptr_w_wrap[5:0] != dfq_wptr_w_wrap[5:0]) ;

// dfq is read iff bypass flop is empty and valid entry in dfq available. 
// i.e., we need to initialize bypass ff such that it always contains
// latest entry.
//  (dfq_rptr_vld_d1 & (~i_and_d_codepend | (i_and_d_codepend & dfq_rd_advance))) |

//assign  lsu_ifill_pkt_vld =   
//  (dfq_rptr_vld_d1 & ~(dfq_st_ack_type & lsu_dfq_byp_stack_dcfill_vld) & (~i_and_d_codepend | (i_and_d_codepend & dfq_byp_ff_en))) |
//        (cpx_spc_data_cx[`CPX_VLD] & ~dfq_wr_en) ;
//
//  (dfq_rptr_vld_d1 & ~(dfq_st_ack_type & lsu_dfq_byp_stack_dcfill_vld) & ~ifill_pkt_fwd_done_d1) |
//
//  (dfq_rptr_vld_d1 & ~(lsu_dfq_rdata_st_ack_type & lsu_dfq_rdata_stack_dcfill_vld) & ~ifill_pkt_fwd_done_d1) | // bug:2767
//  change lsu_dfq_rdata_stack_dcfill_vld from b[87] to b[151] in the top level 
//
//timing fix: 6/16/03 - fix for ifill_pkt_vld - use b130 if store_ack_dcfill_vld=1
//            change lsu_dfq_rdata_stack_dcfill_vld from b[151] to b[130] in the top level 
//  (dfq_rptr_vld_d1 & ~(lsu_dfq_rdata_st_ack_type & dfq_rdata_local_pkt & lsu_dfq_rdata_stack_dcfill_vld) & ~ifill_pkt_fwd_done_d1) |
//
//bug3657 - kill ifill vld in bypass path when cpxtype=fp/fwd_reply
//NOTE: stream loads should also be included
//bug5080 - kill ifill vld in bypass path when cpxtype=strm load - similar to bug3657
//          kill bypass when dfq_rptr_vld_d1=1
//  (cpx_spc_data_cx_b144to140[`CPX_VLD] & ~(dfq_wr_en | cpx_fwd_rply_type | cpx_fp_type)) ;
//
//bug6372: ifill dcache x-inv causes incorrect dcache index to be invalidated.
//         - this occurs 'cos the imiss index gets overwritten by another imiss to the same thread.
//           the dcache x-inv(head of dfq) is stalled in dfq 'cos of load in bypass flop being stalled by memref_e=1
//           but the ifill pkt vld is set to 1 and ifu starts issuing the next imiss for same thread
//         
//  (dfq_rptr_vld_d1 & ~(lsu_dfq_rdata_st_ack_type & lsu_dfq_rdata_stack_dcfill_vld) & ~ifill_pkt_fwd_done_d1) |

wire   ifill_pkt_fwd_done,ifill_pkt_fwd_done_d1;
wire   ifill_dinv_head_of_dfq_pend ;


assign  ifill_dinv_head_of_dfq_pend  =  lsu_dfq_rdata_type[4] & lsu_dfq_rdata_invwy_vld & ~dfq_byp_ff_en ;

assign  lsu_ifill_pkt_vld =   
  (dfq_rptr_vld_d1 & ~(lsu_dfq_rdata_st_ack_type & lsu_dfq_rdata_stack_dcfill_vld) & 
                     ~ifill_dinv_head_of_dfq_pend &
                     ~ifill_pkt_fwd_done_d1 ) |
  (~dfq_rptr_vld_d1 & cpx_spc_data_cx_b144to140[144] & ~(dfq_wr_en | cpx_fwd_rply_type | cpx_fp_type)) ;

// this signal acts as a mask i.e. fill valid will be asserted until the ifu_lsu_ibuf_busy=0. But certain packets need
// both busy=0 and memref_e=0 - in which case it is safer to mask until the dfq_rd_advance=1.

//bug5309: add reset to the flop; x's get recycled from flop o/p until a dfq_rd_advance occurs i.e. flop reset
//         after first ifill; failed in cmp1.92 cmp8 regression w/ vcs7.1

assign  ifill_pkt_fwd_done  =  ~reset & 
                               (((dfq_rptr_vld_d1 & ~ifu_lsu_ibuf_busy & ~ifill_dinv_head_of_dfq_pend) | 
                                ifill_pkt_fwd_done_d1)   // set|hold
                                & ~dfq_rd_advance);				                  // reset

dff_s  #(1) ifill_pkt_fwd_done_ff (
        .din    (ifill_pkt_fwd_done),
        .q      (ifill_pkt_fwd_done_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );



// Note that this becomes valid in cycle of read. Flush will be continuously read
// out of dfq until all intermmediate buffers are clear.

// timing fix: 06/04/03: dfq_rd_advance uses byp_mux output; instead use dfq read output
//             i.e. dfq_rd_advance is valid only when there is a valid entry in dfq
//             it is already qual'ed w/ dfq_rd_vld_d1 to determine this.

//assign  dfq_ld_type     = lsu_dfq_byp_type[5] ;
//assign  dfq_ifill_type    = lsu_dfq_byp_type[4] ;
//assign  dfq_evict_type    = lsu_dfq_byp_type[3] ;
//assign  dfq_st_ack_type   = lsu_dfq_byp_type[2] ;
//assign  dfq_strm_st_ack_type  = lsu_dfq_byp_type[1] ;
//assign  dfq_int_type    = lsu_dfq_byp_type[0] ;

assign  dfq_ld_type     = lsu_dfq_rdata_type[5] ;
assign  dfq_ifill_type    = lsu_dfq_rdata_type[4] ;
assign  dfq_evict_type    = lsu_dfq_rdata_type[3] ;
assign  dfq_st_ack_type   = lsu_dfq_rdata_type[2] ;
assign  dfq_strm_st_ack_type  = lsu_dfq_rdata_type[1] ;
assign  dfq_int_type    = lsu_dfq_rdata_type[0] ;

//8/25/03: add error type to dfq_wr_en, dfq_rd_advance
assign  dfq_error_type    = (lsu_dfq_rdata_rq_type[3:0]==4'b1100) ;
//8/25/03: add fwd req to L1I$ for RAMTEST to dfq_wr_en, dfq_rd_dvance
assign  dfq_fwd_req_ic_type  = (lsu_dfq_rdata_rq_type[3:0]==4'b1010) & lsu_dfq_rdata_b103;

assign  dfq_invwy_vld     = lsu_dfq_byp_invwy_vld ;

// if the there is a co-dependent event, then the ifu will not
// be signalled vld until rd_advance is asserted.
//assign  i_and_d_codepend = 
//    ((dfq_ld_type | dfq_ifill_type) &  dfq_invwy_vld)   |
//    (dfq_evict_type | dfq_st_ack_type | dfq_strm_st_ack_type) |
//    dfq_int_type ;

//NOTE: restore cpx_inv qualification after adding cpx_inv part of dfq read - done
//assign  st_rd_advance  =  dfq_byp_st_vld & (~lsu_dfq_byp_cpx_inv | (lsu_dfq_byp_cpx_inv & ~stb_cam_hit_w2)) & dfq_byp_ff_en;
//assign  st_rd_advance  =  dfq_byp_st_vld & dfq_byp_ff_en; // bug:2770
//                          (dfq_byp_st_vld &  lsu_dfq_rdata_stack_iinv_vld & ~ifu_lsu_ibuf_busy) ; // bug:2775

// timing fix: 06/04/03: dfq_rd_advance uses byp_mux output; instead use dfq read output
//             i.e. dfq_rd_advance is valid only when there is a valid entry in dfq
//             it is already qual'ed w/ dfq_rd_vld_d1 to determine this.


assign  st_rd_advance  =  
        (dfq_st_ack_type & dfq_rdata_local_pkt & ~lsu_dfq_rdata_stack_iinv_vld & dfq_byp_ff_en) |
        (dfq_st_ack_type & dfq_rdata_local_pkt &  lsu_dfq_rdata_stack_iinv_vld & ~ifu_lsu_ibuf_busy & dfq_byp_ff_en) ;

// The pointer is advanced based on pre-flop bypass data.

wire inv_clear_d1 ;
dff_s  #(1) invclr_d1 (
        .din    (ifu_lsu_inv_clear),
        .q      (inv_clear_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//---
// Dealing with skid involving invalidate clear.
// 1. No stall asserted. If the int is immed. preceeded by an inv,
// then the the inv will not be visible thru inv_clear. For this
// reason, int will always wait an additional cycle before examining
// inv_clear.
// 2. In case int has been dispatched to the ifu with stall asserted,
// stalls are conditionally inserted. 
// Note : interrupts are always written into dfq.
//---

wire	dfq_rd_advance_d1 ;
dff_s   rda_d1 (
        .din    (dfq_rd_advance),
        .q      (dfq_rd_advance_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


// Begin Bug 5583
wire	dfq_int_type_d1 ;
wire	int_skid_c1,int_skid_c2;
wire	int_skid_stall ;
dff_s   itype_d1 (
        .din    (dfq_int_type),
        .q      (dfq_int_type_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// decision made to issue intrpt from dfq even though 
// intr-clear was not high, thus introduce stall for
// 2 more cycles.
assign int_skid_c1 = 
	dfq_int_type_d1 & dfq_rd_advance_d1 & ~inv_clear_d1 ;

dff_s   iskid_c2 (
        .din    (int_skid_c1),
        .q      (int_skid_c2),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	int_skid_stall = int_skid_c1 | int_skid_c2 ;

// End Bug 5583

// timing fix: 06/04/03: dfq_rd_advance uses byp_mux output; instead use dfq read output
//             i.e. dfq_rd_advance is valid only when there is a valid entry in dfq
//             it is already qual'ed w/ dfq_rd_vld_d1 to determine this.
//8/25/03: add error type to dfq_wr_en, dfq_rd_advance
//8/25/03: add fwd req to L1I$ for RAMTEST to dfq_wr_en, dfq_rd_dvance

assign  dfq_rd_advance   =  
  // local st which writes to cache cannot advance if simultaneous cam hit. 
  //((dfq_byp_st_vld & (~cpx_inv | (cpx_inv & ~stb_cam_hit_w2)) & dfq_byp_ff_en)  | 
  (st_rd_advance |
  // advance beyond a dside ld if it can be written to the byp ff
  (dfq_ld_type & ~lsu_dfq_rdata_invwy_vld & dfq_byp_ff_en) |
  // advance beyond a dside & iside ld if it can be written to the byp ff/ibuf clr
  (dfq_ld_type &  lsu_dfq_rdata_invwy_vld & (dfq_byp_ff_en & ~ifu_lsu_ibuf_busy))   |
  // advance beyond a iside ifill if it can be written to the ibuf
  (dfq_ifill_type & ~lsu_dfq_rdata_invwy_vld & ~ifu_lsu_ibuf_busy)      |
  // advance beyond a dside & iside ifill if it can be written to the byp ff/ibuf clr
  (dfq_ifill_type &  lsu_dfq_rdata_invwy_vld & (dfq_byp_ff_en & ~ifu_lsu_ibuf_busy))  |
  // any form of invalidate could invalidate both i and dside.
  ((dfq_evict_type | (dfq_st_ack_type & ~dfq_rdata_local_pkt) | dfq_strm_st_ack_type) & 
        (dfq_byp_ff_en & ~ifu_lsu_ibuf_busy)) |
  // interrupts and flushes have to ensure invalidates are visible in caches.
  // interrupts do not enter d-side byp buffer.  flush needs to look at inv clear.
  (dfq_int_type & (dfq_byp_ff_en & ~ifu_lsu_ibuf_busy & ((inv_clear_d1 & ~dfq_rd_advance_d1) | dfq_stall_d1))) | // Bug 3820.
  //(dfq_int_type & (dfq_byp_ff_en & ~ifu_lsu_ibuf_busy & ((inv_clear_d1 & ~dfq_rd_advance_d1) | dfq_stall_d2))) | // Bug 3820.
  ((dfq_error_type | dfq_fwd_req_ic_type) & ~ifu_lsu_ibuf_busy))
    & dfq_rptr_vld_d1 & ~reset ;

//timing fix: 9/16/03 - dfq_rd_advance is late signal; use it as mux select to pick the correct read pointer
//            add duplicate signal for dfq_rd_advance - has FO16 - adds 3inv to this path
//            fix for dfq_read -> dfq_rd_advance -> dfq_rptr to dfq
wire   dfq_rd_advance_dup ;
assign dfq_rd_advance_dup =  dfq_rd_advance ;

//timing fix: 9/29/03 - instantiate buffer for dfq_rd_advance to dfq_vld_en
bw_u1_buf_30x UZsize_dfq_rd_advance_buf1 ( .a(dfq_rd_advance), .z(dfq_rd_advance_buf1) );

wire	local_flush ;
assign	local_flush = lsu_dfq_byp_type[0] & lsu_dfq_byp_flush & local_pkt & dfq_rd_advance ;

wire	[3:0]	dfq_flsh_cmplt ;
assign	dfq_flsh_cmplt[0] = local_flush & ~lsu_dfq_byp_tid[1] & ~lsu_dfq_byp_tid[0] ;
assign	dfq_flsh_cmplt[1] = local_flush & ~lsu_dfq_byp_tid[1] &  lsu_dfq_byp_tid[0] ;
assign	dfq_flsh_cmplt[2] = local_flush &  lsu_dfq_byp_tid[1] & ~lsu_dfq_byp_tid[0] ;
assign	dfq_flsh_cmplt[3] = local_flush &  lsu_dfq_byp_tid[1] &  lsu_dfq_byp_tid[0] ;

dff_s  #(4) flshcmplt (
        .din    (dfq_flsh_cmplt[3:0]),
        .q      (lsu_dfq_flsh_cmplt[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


// Check for extra bubbles in pipeline.
//timing fix: 10/3/03 - use dfq_rd_advance as mux select
//assign  dfq_rptr_new_w_wrap[5:0] =  dfq_rptr_w_wrap[5:0] + {5'b00000, dfq_rd_advance} ;
wire  [5:0]  dfq_rptr_new_w_wrap_inc ;
assign  dfq_rptr_new_w_wrap_inc[5:0] =  dfq_rptr_w_wrap[5:0] + 6'b000001 ;
assign  dfq_rptr_new_w_wrap[5:0]  =  dfq_rd_advance ? dfq_rptr_new_w_wrap_inc[5:0] : dfq_rptr_w_wrap[5:0] ;

// The dfq will always read as long as there is a valid entry.
// ** Design note : If dfq output is held at latches, this is not longer required !! **
//assign  dfq_rptr_vld  =   dfq_vld_entry_exists ;
assign  dfq_rptr_vld  =   dfq_vld_entry_exists_w ;

wire   dfq_rptr_vld_w_d1;

wire dfq_vld_entry_exists_d1;
dff_s   rvld_stgd1_new (
        .din    (dfq_vld_entry_exists), .q  (dfq_vld_entry_exists_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 
dff_s   rvld_stgd1 (
        .din    (dfq_rptr_vld), .q  (dfq_rptr_vld_w_d1),
        //.din    (dfq_rptr_vld), .q  (dfq_rptr_vld_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 
//dff   rdad_stgd1 (
//        .din    (dfq_rd_advance), .q  (dfq_rd_advance_d1),
//        .clk  (clk),
//        .se     (1'b0),       .si (),          .so ()
//        ); 

dffre_s  #(6) dfq_rptr_ff (
        .din    (dfq_rptr_new_w_wrap[5:0]), .q  (dfq_rptr_w_wrap[5:0]),
        .rst    (reset), .en (dfq_rd_advance), .clk (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

assign  dfq_rptr_vld_d1 = dfq_rptr_vld_w_d1 & dfq_vld_entry_exists_d1;
assign  dfq_rd_vld_d1 = dfq_rptr_vld_d1 ;
//bug4576: add sehold to the dfq_rdata mux select
assign  lsu_dfq_rd_vld_d1 = sehold | dfq_rptr_vld_d1 ;

//timing fix: 9/16/03 - dfq_rd_advance is late signal; use it as mux select to pick the correct read pointer
//            add duplicate signal for dfq_rd_advance - has FO16 - adds 3inv to this path
//            fix for dfq_read -> dfq_rd_advance -> dfq_rptr to dfq
//assign  dfq_rptr[4:0] = dfq_rptr_w_wrap[4:0] + {4'b0000, dfq_rd_advance} ;

//1/20/04: mintime fix - add minbuf to dfq_rptr_w_wrap in dfq_rptr
wire  [4:0]  dfq_rptr_w_wrap_minbuf ;

bw_u1_minbuf_5x UZfix_dfq_rptr_b0 (.a(dfq_rptr_w_wrap[0]), .z(dfq_rptr_w_wrap_minbuf[0]));
bw_u1_minbuf_5x UZfix_dfq_rptr_b1 (.a(dfq_rptr_w_wrap[1]), .z(dfq_rptr_w_wrap_minbuf[1]));
bw_u1_minbuf_5x UZfix_dfq_rptr_b2 (.a(dfq_rptr_w_wrap[2]), .z(dfq_rptr_w_wrap_minbuf[2]));
bw_u1_minbuf_5x UZfix_dfq_rptr_b3 (.a(dfq_rptr_w_wrap[3]), .z(dfq_rptr_w_wrap_minbuf[3]));
bw_u1_minbuf_5x UZfix_dfq_rptr_b4 (.a(dfq_rptr_w_wrap[4]), .z(dfq_rptr_w_wrap_minbuf[4]));

wire  [4:0]  dfq_rptr_inc ;
assign dfq_rptr_inc[4:0]  =  dfq_rptr_w_wrap[4:0] + 5'b00001 ;
assign  dfq_rptr[4:0] = dfq_rd_advance_dup ? dfq_rptr_inc[4:0] : dfq_rptr_w_wrap_minbuf[4:0] ;
//assign  dfq_rptr[4:0] = dfq_rd_advance_dup ? dfq_rptr_inc[4:0] : dfq_rptr_w_wrap[4:0] ;

// Determine whether cfq has crossed high-water mark. IFU must switchout all threads
// for every cycle that this is valid.
// Need to change wptr size once new cfq array description incorporated.
// Wrap bit may not be needed !!!
wire  [5:0] dfq_vld_entries ;
assign  dfq_vld_entries[5:0] = (dfq_wptr_w_wrap[5:0] - dfq_rptr_w_wrap[5:0]) ;
/*assign  dfq_vld_entries[3:0] =
  (dfq_rptr_w_wrap[4] ^ dfq_wptr_w_wrap[4]) ? 
  (dfq_rptr_w_wrap[3:0] - dfq_wptr_w_wrap[3:0]) : (dfq_wptr_w_wrap[3:0] - dfq_rptr_w_wrap[3:0]) ;*/

// High water mark conservatively put at 16-4 = 12
assign	dfq_stall = (dfq_vld_entries[5:0] >= 6'd4) ;
assign  lsu_ifu_stallreq = 
	dfq_stall |  int_skid_stall | lsu_tlbop_force_swo ; 
	//dfq_stall | dfq_stall_d1 | dfq_stall_d2 | int_skid_stall | lsu_tlbop_force_swo ; 

dff_s   dfqst_d1 (
        .din  (dfq_stall), .q  (dfq_stall_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//=================================================================================================
//  INVALIDATE PROCESSING
//=================================================================================================

assign  dva_snp_addr_e[(6 + 4)-6:0]  =  
  lsu_cpx_pkt_ifill_type ? imiss_inv_set_index[6:2] : {lsu_cpx_pkt_inv_pa[(6 + 4)-6:0]} ; 
// trin: mismatch fine for reconfigurable caches; xinval is not used

//bug3356 - b4 never changed to invalidate the 2nd offset of the i$ fill.
//          l2 now generates b4 in b129 of cpx ifill packet. for ifill pkt
//          b[129] = 0 for 1st ifill packet, b[129]=1 for 2nd ifill packet.

wire    cpxpkt_ifill_b4 ;
assign  cpxpkt_ifill_b4  =  lsu_cpx_pkt_atm_st_cmplt & lsu_cpx_pkt_ifill_type ;

assign  imiss_dcd_b54[0] = ~imiss_inv_set_index[1] & ~cpxpkt_ifill_b4 ;
assign  imiss_dcd_b54[1] = ~imiss_inv_set_index[1] &  cpxpkt_ifill_b4 ;
assign  imiss_dcd_b54[2] =  imiss_inv_set_index[1] & ~cpxpkt_ifill_b4 ;
assign  imiss_dcd_b54[3] =  imiss_inv_set_index[1] &  cpxpkt_ifill_b4 ;

wire  [3:0] perror_dcd_b54 ;
assign  perror_dcd_b54[0] = ~lsu_cpx_pkt_perror_set[1] & ~lsu_cpx_pkt_perror_set[0] ;
assign  perror_dcd_b54[1] = ~lsu_cpx_pkt_perror_set[1] &  lsu_cpx_pkt_perror_set[0] ;
assign  perror_dcd_b54[2] =  lsu_cpx_pkt_perror_set[1] & ~lsu_cpx_pkt_perror_set[0] ;
assign  perror_dcd_b54[3] =  lsu_cpx_pkt_perror_set[1] &  lsu_cpx_pkt_perror_set[0] ;

wire   [3:0]           dva_snp_set_vld_e;      // Lower 2b of cache set index - decoded
wire   [2-1:0]           dva_snp_wy0_e ;         // way for addr<5:4>=00
wire   [2-1:0]           dva_snp_wy1_e ;         // way for addr<5:4>=01
wire   [2-1:0]           dva_snp_wy2_e ;         // way for addr<5:4>=10
wire   [2-1:0]           dva_snp_wy3_e ;         // way for addr<5:4>=11



/*
assign  dva_snp_set_vld_e[0] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[0] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[0] : cpx_cpu_inv_data[`CPX_AX0_INV_DVLD] ;
assign  dva_snp_set_vld_e[1] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[1] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[1] : cpx_cpu_inv_data[`CPX_AX1_INV_DVLD+4] ;
assign  dva_snp_set_vld_e[2] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[2] :
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[2] : cpx_cpu_inv_data[`CPX_AX0_INV_DVLD+7] ;
assign  dva_snp_set_vld_e[3] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[3] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[3] : cpx_cpu_inv_data[`CPX_AX1_INV_DVLD+11] ; 

assign  dva_snp_wy0_e[1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[1:0] : cpx_cpu_inv_data[`CPX_AX0_INV_WY_HI:`CPX_AX0_INV_WY_LO];
assign  dva_snp_wy1_e[1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[1:0] : cpx_cpu_inv_data[`CPX_AX1_INV_WY_HI+4:`CPX_AX1_INV_WY_LO+4];
assign  dva_snp_wy2_e[1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[1:0] : cpx_cpu_inv_data[`CPX_AX0_INV_WY_HI+7:`CPX_AX0_INV_WY_LO+7];
assign  dva_snp_wy3_e[1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[1:0] : cpx_cpu_inv_data[`CPX_AX1_INV_WY_HI+11:`CPX_AX1_INV_WY_LO+11];
*/

wire    stack_type_dcfill_vld,
        stack_type_dcfill_vld_d1;
//assign  stack_type_dcfill_vld  =  dfq_st_ack_type & lsu_dfq_byp_stack_dcfill_vld; // bug 2767
//--------------------------------------------------------------
// st_ack_type  local_pkt   b[87]  dcfill_vld==b[151]
//--------------------------------------------------------------
//   1           0          0          -      pkt not modified
//   1           0          1          -      pkt not modified
//--------------------------------------------------------------
//   1           1          0          0      pkt not modified
//   1           1          0          1      pkt modified
//--------------------------------------------------------------
//   1           1          1          0      pkt not modified  <---using b[87] will fail even w/ local pkt qual; hence use b[151]
//   1           1          1          1      pkt modified 
//--------------------------------------------------------------

// 4/7/03: set dcfill_vld only for local dcache data write and not for invalidate
//         atomic and bis do not write dcache and hence dont set dcfill_vld
assign  stack_type_dcfill_vld  =  lsu_dfq_byp_type[2] & local_pkt & lsu_dfq_byp_cpx_inv & ~(lsu_dfq_byp_atm | lsu_dfq_byp_binit_st) ;

wire  [1:0]  lsu_dfq_byp_stack_adr_b54_d1,
             lsu_dfq_byp_stack_wrway_d1;

// bug3375: add enable to this flop - dfq_vld_en
dffe_s #(5)  dfq_by_wrway_ad54_ff (
        .din    ({stack_type_dcfill_vld,lsu_dfq_byp_stack_adr_b54[1:0],lsu_dfq_byp_stack_wrway[1:0]}),
        .q      ({stack_type_dcfill_vld_d1,lsu_dfq_byp_stack_adr_b54_d1[1:0],lsu_dfq_byp_stack_wrway_d1[1:0]}),
        .en     (dfq_vld_en),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//cpx_cpu_inv_data[13:0] =  {dfq_inv_data_b13to9,1'b0,dfq_inv_data_b7to2,1'b0,dfq_inv_data_b0} 
//CPX_AX0_INV_DVLD 0
//CPX_AX0_INV_WY_LO 2
//CPX_AX0_INV_WY_HI 3
//CPX_AX1_INV_DVLD 0
//CPX_AX1_INV_WY_LO 1
//CPX_AX1_INV_WY_HI 2

assign  dva_snp_set_vld_e[0] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[0] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[0] : 
     stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b00) : dfq_inv_data_val ;
     //stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b00) : cpx_cpu_inv_data[`CPX_AX0_INV_DVLD] ;
assign  dva_snp_set_vld_e[1] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[1] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[1] : 
     stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b01) : dfq_inv_data_val;
     //stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b01) : cpx_cpu_inv_data[`CPX_AX1_INV_DVLD+4] ;
assign  dva_snp_set_vld_e[2] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[2] :
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[2] : 
     stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b10) : dfq_inv_data_val;
     //stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b10) : cpx_cpu_inv_data[`CPX_AX0_INV_DVLD+7] ;
assign  dva_snp_set_vld_e[3] = 
lsu_cpx_pkt_ifill_type ? imiss_dcd_b54[3] : 
  lsu_cpx_pkt_perror_dinv ? perror_dcd_b54[3] : 
      stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b11) : dfq_inv_data_val;
      //stack_type_dcfill_vld_d1 ? (lsu_dfq_byp_stack_adr_b54_d1[1:0]==2'b11) : cpx_cpu_inv_data[`CPX_AX1_INV_DVLD+11] ; 

assign  dva_snp_wy0_e[2-1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[2-1:0] : 
   stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[2-1:0] : dfq_inv_data_way;
   //stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[`L1D_WAY_MASK] : cpx_cpu_inv_data[`CPX_AX0_INV_WY_HI:`CPX_AX0_INV_WY_LO] ;
assign  dva_snp_wy1_e[2-1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[2-1:0] : 
   stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[2-1:0] : dfq_inv_data_way;
   //stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[`L1D_WAY_MASK] : cpx_cpu_inv_data[`CPX_AX1_INV_WY_HI+4:`CPX_AX1_INV_WY_LO+4] ;
assign  dva_snp_wy2_e[2-1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[2-1:0] : 
   stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[2-1:0] : dfq_inv_data_way;
   //stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[`L1D_WAY_MASK] : cpx_cpu_inv_data[`CPX_AX0_INV_WY_HI+7:`CPX_AX0_INV_WY_LO+7] ;
assign  dva_snp_wy3_e[2-1:0]   = 
lsu_cpx_pkt_ifill_type ? lsu_cpx_pkt_invwy[2-1:0] : 
   stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[2-1:0] : dfq_inv_data_way;
   //stack_type_dcfill_vld_d1 ? lsu_dfq_byp_stack_wrway_d1[`L1D_WAY_MASK] : cpx_cpu_inv_data[`CPX_AX1_INV_WY_HI+11:`CPX_AX1_INV_WY_LO+11] ;



//   wire [1:0] dva_snp_way_e;
//assign dva_snp_way_e[1:0] =  
//  dva_snp_set_vld_e[0] ?  dva_snp_wy0_e[1:0]:
//  dva_snp_set_vld_e[1] ?  dva_snp_wy1_e[1:0]:
//  dva_snp_set_vld_e[2] ?  dva_snp_wy2_e[1:0]:
//  dva_snp_set_vld_e[3] ?  dva_snp_wy3_e[1:0]: 2'bxx;

//bug 2333 fix
//06/09/03: bug 3420 - add logic for dtag parity error invalidate - inv all 4 ways of the index that had error
//bug 3608 - qualify perror_dinv w/ dfq_st_vld
wire     derror_inv_vld ;
assign   derror_inv_vld  =  dfq_st_vld & lsu_cpx_pkt_perror_dinv ;

   // assign dva_snp_bit_wr_en_e [15] =  dva_snp_set_vld_e[3] &  (( dva_snp_wy3_e [1] &  dva_snp_wy3_e[0]) | derror_inv_vld ) ;
   // assign dva_snp_bit_wr_en_e [14] =  dva_snp_set_vld_e[3] &  (( dva_snp_wy3_e [1] & ~dva_snp_wy3_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [13] =  dva_snp_set_vld_e[3] &  ((~dva_snp_wy3_e [1] &  dva_snp_wy3_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [12] =  dva_snp_set_vld_e[3] &  ((~dva_snp_wy3_e [1] & ~dva_snp_wy3_e[0]) | derror_inv_vld );
                                                                                               
   // assign dva_snp_bit_wr_en_e [11] =  dva_snp_set_vld_e[2] &  (( dva_snp_wy2_e [1] &  dva_snp_wy2_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [10] =  dva_snp_set_vld_e[2] &  (( dva_snp_wy2_e [1] & ~dva_snp_wy2_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [09] =  dva_snp_set_vld_e[2] &  ((~dva_snp_wy2_e [1] &  dva_snp_wy2_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [08] =  dva_snp_set_vld_e[2] &  ((~dva_snp_wy2_e [1] & ~dva_snp_wy2_e[0]) | derror_inv_vld );
                                                                                               
   // assign dva_snp_bit_wr_en_e [07] =  dva_snp_set_vld_e[1] &  (( dva_snp_wy1_e [1] &  dva_snp_wy1_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [06] =  dva_snp_set_vld_e[1] &  (( dva_snp_wy1_e [1] & ~dva_snp_wy1_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [05] =  dva_snp_set_vld_e[1] &  ((~dva_snp_wy1_e [1] &  dva_snp_wy1_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [04] =  dva_snp_set_vld_e[1] &  ((~dva_snp_wy1_e [1] & ~dva_snp_wy1_e[0]) | derror_inv_vld );
                                                                                               
   // assign dva_snp_bit_wr_en_e [03] =  dva_snp_set_vld_e[0] &  (( dva_snp_wy0_e [1] &  dva_snp_wy0_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [02] =  dva_snp_set_vld_e[0] &  (( dva_snp_wy0_e [1] & ~dva_snp_wy0_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [01] =  dva_snp_set_vld_e[0] &  ((~dva_snp_wy0_e [1] &  dva_snp_wy0_e[0]) | derror_inv_vld );
   // assign dva_snp_bit_wr_en_e [00] =  dva_snp_set_vld_e[0] &  ((~dva_snp_wy0_e [1] & ~dva_snp_wy0_e[0]) | derror_inv_vld );
                                                                                               


    assign dva_snp_bit_wr_en_e [(0*4) + 0] =  dva_snp_set_vld_e[0] &  ((dva_snp_wy0_e == 0) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(1*4) + 0] =  dva_snp_set_vld_e[1] &  ((dva_snp_wy1_e == 0) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(2*4) + 0] =  dva_snp_set_vld_e[2] &  ((dva_snp_wy2_e == 0) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(3*4) + 0] =  dva_snp_set_vld_e[3] &  ((dva_snp_wy3_e == 0) | derror_inv_vld );


    assign dva_snp_bit_wr_en_e [(0*4) + 1] =  dva_snp_set_vld_e[0] &  ((dva_snp_wy0_e == 1) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(1*4) + 1] =  dva_snp_set_vld_e[1] &  ((dva_snp_wy1_e == 1) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(2*4) + 1] =  dva_snp_set_vld_e[2] &  ((dva_snp_wy2_e == 1) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(3*4) + 1] =  dva_snp_set_vld_e[3] &  ((dva_snp_wy3_e == 1) | derror_inv_vld );


    assign dva_snp_bit_wr_en_e [(0*4) + 2] =  dva_snp_set_vld_e[0] &  ((dva_snp_wy0_e == 2) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(1*4) + 2] =  dva_snp_set_vld_e[1] &  ((dva_snp_wy1_e == 2) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(2*4) + 2] =  dva_snp_set_vld_e[2] &  ((dva_snp_wy2_e == 2) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(3*4) + 2] =  dva_snp_set_vld_e[3] &  ((dva_snp_wy3_e == 2) | derror_inv_vld );


    assign dva_snp_bit_wr_en_e [(0*4) + 3] =  dva_snp_set_vld_e[0] &  ((dva_snp_wy0_e == 3) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(1*4) + 3] =  dva_snp_set_vld_e[1] &  ((dva_snp_wy1_e == 3) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(2*4) + 3] =  dva_snp_set_vld_e[2] &  ((dva_snp_wy2_e == 3) | derror_inv_vld );
    assign dva_snp_bit_wr_en_e [(3*4) + 3] =  dva_snp_set_vld_e[3] &  ((dva_snp_wy3_e == 3) | derror_inv_vld );




//=================================================================================================
//  LOCAL ST ACK PROCESSING
//=================================================================================================

// st-ack at head of cfq may write to cache if not indicated as invalid 
// L2.

//wire	byp_tag_perror ;
//assign	byp_tag_perror = lsu_dfq_byp_perror_dinv | lsu_dfq_byp_perror_iinv ;

// one-shot rd-enable for stb for st data.
// st-quad pkt2 will not rd stb
//NOTE: restore cpx_inv qualification after adding cpx_inv part of dfq read - done
/*
assign  st_ack_rq_stb = 
   (dfq_byp_st_vld & st_rd_advance & ~byp_tag_perror)   // local st ack from dfq
  & lsu_dfq_byp_cpx_inv ;
*/
  //((cpx_local_st_ack_type & ~dfq_wr_en & ~(|cpx_spc_data_cx[`CPX_PERR_DINV+1:`CPX_PERR_DINV])) | // local st ack from cpx
  //(dfq_byp_st_vld & dfq_rd_advance & ~byp_tag_perror))   // local st ack from dfq
  //(dfq_byp_st_vld & dfq_rd_advance_d1)) // local st ack from dfq

/*assign  st_ack_rq_stb = 
  ((cpx_local_st_ack_type & ~dfq_wr_en & ~cpx_spc_data_cx[107]) | // local st ack from cpx
  (dfq_byp_st_vld & dfq_rd_advance & ~lsu_dfq_byp_stquad_pkt2))   // local st ack from dfq
  //(dfq_byp_st_vld & dfq_rd_advance_d1)) // local st ack from dfq
  & cpx_inv ; */

/*
dff_s #(1)  stackr_d1 (
        .din    (st_ack_rq_stb),
        .q      (st_ack_rq_stb_d1),
        .clk  (clk),
        .se     (1'b0),       .si (),          .so ()
        );
*/

// Mux's control signal can be flipped - TIMING
//assign  st_ack_tid[1:0] =
//  (dfq_byp_st_vld & dfq_rd_advance) ?  
//	lsu_dfq_byp_tid[1:0] : cpx_spc_data_cx[`CPX_TH_HI:`CPX_TH_LO] ;

// This can be critical !!!
//assign  lsu_st_ack_rq_stb[0] = ~st_ack_tid[1] & ~st_ack_tid[0] & st_ack_rq_stb ;
//assign  lsu_st_ack_rq_stb[1] = ~st_ack_tid[1] &  st_ack_tid[0] & st_ack_rq_stb ;
//assign  lsu_st_ack_rq_stb[2] =  st_ack_tid[1] & ~st_ack_tid[0] & st_ack_rq_stb ;
//assign  lsu_st_ack_rq_stb[3] =  st_ack_tid[1] &  st_ack_tid[0] & st_ack_rq_stb ;

// the ack decode can be combined with the above (grape)

assign  lsu_st_ack_dq_stb[0] = 
	cpx_pkt_thrd_sel[0] & dfq_st_cmplt &
	~(lsu_cpx_pkt_perror_dinv | lsu_cpx_pkt_perror_iinv | lsu_cpx_pkt_binit_st) ;
assign  lsu_st_ack_dq_stb[1] = 
	cpx_pkt_thrd_sel[1] & dfq_st_cmplt &
	~(lsu_cpx_pkt_perror_dinv | lsu_cpx_pkt_perror_iinv | lsu_cpx_pkt_binit_st) ;
assign  lsu_st_ack_dq_stb[2] = 
	cpx_pkt_thrd_sel[2] & dfq_st_cmplt &
	~(lsu_cpx_pkt_perror_dinv | lsu_cpx_pkt_perror_iinv | lsu_cpx_pkt_binit_st) ;
assign  lsu_st_ack_dq_stb[3] = 
	cpx_pkt_thrd_sel[3] & dfq_st_cmplt &
	~(lsu_cpx_pkt_perror_dinv | lsu_cpx_pkt_perror_iinv | lsu_cpx_pkt_binit_st) ;

// Signal rmo ack completion.
assign  lsu_cpx_rmo_st_ack[0] = 
	cpx_pkt_thrd_sel[0] & dfq_st_cmplt  & lsu_cpx_pkt_binit_st ;
assign  lsu_cpx_rmo_st_ack[1] = 
	cpx_pkt_thrd_sel[1] & dfq_st_cmplt  & lsu_cpx_pkt_binit_st ;
assign  lsu_cpx_rmo_st_ack[2] = 
	cpx_pkt_thrd_sel[2] & dfq_st_cmplt  & lsu_cpx_pkt_binit_st ;
assign  lsu_cpx_rmo_st_ack[3] = 
	cpx_pkt_thrd_sel[3] & dfq_st_cmplt  & lsu_cpx_pkt_binit_st ;

assign  lsu_st_wr_dcache = stwr_active_e ;

//assign  lsu_st_wr_sel_e = stwr_active_e |  lsu_diagnstc_wr_src_sel_e ;

//=================================================================================================
//  CPX PKT DECODE
//=================================================================================================

// The decode is meant to qualify writes into the dfq.
// These values are also stored in the dfq to save on decode at the head of the queue.

assign lsu_cpxpkt_type_dcd_cx[5:0] = 
{cpx_ld_type,cpx_ifill_type,cpx_evict_type,cpx_st_ack_type,cpx_strm_st_ack_type,cpx_int_type};

assign  cpx_ld_type = 
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // 0000
          ~cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140]));

assign  cpx_ifill_type = 
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // 0001
          ~cpx_spc_data_cx_b144to140[140+1] &  cpx_spc_data_cx_b144to140[140]));

assign  cpx_evict_type = 
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // 0011
           cpx_spc_data_cx_b144to140[140+1] &  cpx_spc_data_cx_b144to140[140]));

assign  cpx_st_ack_type =
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]  &   cpx_spc_data_cx_b144to140[140+2] & // 0100
          ~cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140])); 
         //~cpx_spc_data_cx[108] ;  // 1st stquad ack is rejected

assign  cpx_strm_st_ack_type =
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]   &  cpx_spc_data_cx_b144to140[140+2] & // 0110
           cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140]));

assign  cpx_int_type =
         cpx_spc_data_cx_b144to140[144] &
        ((~cpx_spc_data_cx_b144to140[143]   &  cpx_spc_data_cx_b144to140[140+2] & // 0111
           cpx_spc_data_cx_b144to140[140+1] &  cpx_spc_data_cx_b144to140[140]));

//bug3657  - kill ifill vld in bypass path when cpxtype=fp/fwd_reply

assign  cpx_fp_type =
         cpx_spc_data_cx_b144to140[144] &
        (( cpx_spc_data_cx_b144to140[143]   & ~cpx_spc_data_cx_b144to140[140+2] & // 1000
          ~cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140]));

//8/25/03: add error type to dfq_wr_en, dfq_rd_advance
assign  cpx_error_type =
         cpx_spc_data_cx_b144to140[144] &
        (( cpx_spc_data_cx_b144to140[143]   &  cpx_spc_data_cx_b144to140[140+2] & // 1100
          ~cpx_spc_data_cx_b144to140[140+1] & ~cpx_spc_data_cx_b144to140[140]));

// Miscellaneous cpu based decode

assign  lsu_cpu_dcd_sel[7:0]  = {cpu_sel[3:0],cpu_sel[3:0]} ;
assign  lsu_cpu_uhlf_sel  = const_cpuid[2] ;

// removed cpu_id[2] qual in the eqn.
assign  cpu_sel[0] =  ~const_cpuid[1] & ~const_cpuid[0] ;
assign  cpu_sel[1] =  ~const_cpuid[1] &  const_cpuid[0] ;
assign  cpu_sel[2] =   const_cpuid[1] & ~const_cpuid[0] ;
assign  cpu_sel[3] =   const_cpuid[1] &  const_cpuid[0] ;


// st ack to respective stb's. will not be generated for blk init stores
// as such stores have already been deallocated.

assign  cpx_local_st_ack_type = 
  cpx_st_ack_type & (const_cpuid[2:0] == cpx_spc_data_cx_b120to118[120:118]) ;
 // & ~(cpx_spc_data_cx[`CPX_BINIT_STACK] | (|cpx_spc_data_cx[`CPX_PERR_DINV+1:`CPX_PERR_DINV])) ;

wire	squash_ack ;
assign squash_ack =
(cpx_spc_data_cx_b125 | (|cpx_spc_data_cx_b124to123[123+1:123])) ;

assign  cpx_st_ack_tid0 = cpx_local_st_ack_type & ~squash_ack &
                        ~cpx_spc_data_cx_b135to134[135] & ~cpx_spc_data_cx_b135to134[134] ;
                        //~cpx_spc_data_cx[125] ; // rmo st will not ack
                        //~cpx_spc_data_cx[`CPX_WY_LO] ; // stquad1 will not ack - just invalidate.
                                                      // b131 of cpx pkt used.  

assign  cpx_st_ack_tid1 = cpx_local_st_ack_type & ~squash_ack &
                        ~cpx_spc_data_cx_b135to134[135] &  cpx_spc_data_cx_b135to134[134] ;
                        //~cpx_spc_data_cx[125] ; // rmo st will not ack
                        //~cpx_spc_data_cx[`CPX_WY_LO] ; // stquad1 will not ack - just invalidate.
                                                      // b131 of cpx pkt used.

assign  cpx_st_ack_tid2 = cpx_local_st_ack_type & ~squash_ack &
                         cpx_spc_data_cx_b135to134[135] & ~cpx_spc_data_cx_b135to134[134] ;
                        //~cpx_spc_data_cx[125] ; // rmo st will not ack
                        //~cpx_spc_data_cx[`CPX_WY_LO] ; // stquad1 will not ack - just invalidate.
                                                      // b131 of cpx pkt used. 

assign  cpx_st_ack_tid3 = cpx_local_st_ack_type & ~squash_ack &
                         cpx_spc_data_cx_b135to134[135] & cpx_spc_data_cx_b135to134[134] ;
                        //~cpx_spc_data_cx[125] ; // rmo st will not ack
                        //~cpx_spc_data_cx[`CPX_WY_LO] ; // stquad1 will not ack - just invalidate.
                                                      // b131 of cpx pkt used.

// Performance Ctr Info
//assign lsu_tlu_l2_dmiss[0] =  dfill_dcd_thrd[0] & dcfill_active_e & lsu_cpx_pkt_l2miss ;
assign lsu_tlu_l2_dmiss[0] =  dfq_thread0 & dcfill_active_e & lsu_cpx_pkt_l2miss ;
assign lsu_tlu_l2_dmiss[1] =  dfq_thread1 & dcfill_active_e & lsu_cpx_pkt_l2miss ;
assign lsu_tlu_l2_dmiss[2] =  dfq_thread2 & dcfill_active_e & lsu_cpx_pkt_l2miss ;
assign lsu_tlu_l2_dmiss[3] =  dfq_thread3 & dcfill_active_e & lsu_cpx_pkt_l2miss ;

//=================================================================================================
//  GENERATE b[151] of DFQ WRITE DATA
//=================================================================================================
wire  [7:0]  cpx_inv_vld;
wire  [7:0]  cpu_sel_dcd;

// assign  cpx_inv_vld[0] = cpx_spc_data_cx_b88 |
//                          cpx_spc_data_cx_b56 |
//                          cpx_spc_data_cx_b32 |
//                          cpx_spc_data_cx_b0 ;

assign  cpx_inv_vld[0] = cpx_spc_data_cx_dcache_inval_val;
assign  cpx_inv_vld[7:1] = 7'b0;

assign cpu_sel_dcd[7:4] =  ({4{ lsu_cpu_uhlf_sel}} & cpu_sel[3:0]);
assign cpu_sel_dcd[3:0] =  ({4{~lsu_cpu_uhlf_sel}} & cpu_sel[3:0]);

assign lsu_cpx_spc_inv_vld  =  |(cpx_inv_vld[7:0] & cpu_sel_dcd[7:0]);

//=================================================================================================
//  GENERATE ICACHE INVALIDATE VALID (bug:2770)
//=================================================================================================

wire  [7:0]  cpx_iinv_vld;
wire         cpx_spc_iinv_vld;

// assign  cpx_iinv_vld[0] = cpx_spc_data_cx_b57 |
//                           cpx_spc_data_cx_b1  ;

// assign  cpx_iinv_vld[1] = cpx_spc_data_cx_b61 |
//                           cpx_spc_data_cx_b5  ;

// assign  cpx_iinv_vld[2] = cpx_spc_data_cx_b65 |
//                           cpx_spc_data_cx_b9  ;

// assign  cpx_iinv_vld[3] = cpx_spc_data_cx_b69 |
//                           cpx_spc_data_cx_b13 ;

// assign  cpx_iinv_vld[4] = cpx_spc_data_cx_b73 |
//                           cpx_spc_data_cx_b17 ;

// assign  cpx_iinv_vld[5] = cpx_spc_data_cx_b77 |
//                           cpx_spc_data_cx_b21 ;

// assign  cpx_iinv_vld[6] = cpx_spc_data_cx_b81 |
//                           cpx_spc_data_cx_b25 ;

// assign  cpx_iinv_vld[7] = cpx_spc_data_cx_b85 |
//                           cpx_spc_data_cx_b29 ;

assign cpx_iinv_vld[0] = cpx_spc_data_cx_icache_inval_val;
assign cpx_iinv_vld[7:1] = 7'b0;

//bug3701 - include i$ parity error invalidate - b[124]
assign cpx_spc_iinv_vld  =  |( (cpx_iinv_vld[7:0] | {8{cpx_spc_data_cx_b124to123[123+1]}}) & cpu_sel_dcd[7:0] )  ;


// dfq_rd_advance - local st ack not qualified w/ ifu_lsu_ibuf_busy
// qualify ifu_busy w/ local_st_ack=1 and iinv=1

assign lsu_cpx_stack_icfill_vld  =  
                  ( cpx_local_st_ack_type & cpx_spc_iinv_vld) |	       //if local st_ack=1, b[128]=iinv
                  (~cpx_local_st_ack_type & cpx_spc_data_cx_b128) ;    //if local st_ack=0, b[128]=cpx_data[128]

//=================================================================================================
//  MISC QDP2 MUX SELECTS
//=================================================================================================

//assign  lsu_dcfill_mx_sel_e[0]  =  lsu_dc_iob_access_e;
//assign  lsu_dcfill_mx_sel_e[1]  =  lsu_bist_wvld_e | lsu_bist_rvld_e;
//assign  lsu_dcfill_mx_sel_e[2]  =  lsu_diagnstc_wr_src_sel_e;
//assign  lsu_dcfill_mx_sel_e[3]  =  ~|lsu_dcfill_mx_sel_e[2:0];

//assign  lsu_dcfill_addr_mx_sel_e  =  ~|lsu_dcfill_mx_sel_e[1:0];

//assign  lsu_dcfill_data_mx_sel_e  =  lsu_dc_iob_access_e | lsu_bist_wvld_e;

assign lsu_cpx_thrdid[0]  =  ~cpx_spc_data_cx_b135to134[135] & ~cpx_spc_data_cx_b135to134[134] ;
assign lsu_cpx_thrdid[1]  =  ~cpx_spc_data_cx_b135to134[135] &  cpx_spc_data_cx_b135to134[134] ;
assign lsu_cpx_thrdid[2]  =   cpx_spc_data_cx_b135to134[135] & ~cpx_spc_data_cx_b135to134[134] ;
assign lsu_cpx_thrdid[3]  =   cpx_spc_data_cx_b135to134[135] &  cpx_spc_data_cx_b135to134[134] ;

// modify cpx packet only if dcache update from stb has to be made. 
// lsu_cpx_spc_inv_vld = 1 => invalidate dcache for atomic- b[129] and bst- b[125]
// 			      update dcache for other requests
//
// i.e. cpx_pkt==st_ack and local and dcfill_vld=1; if dcfill_vld==0, ifill info
// has to be left as is. hence no pkt modification

assign lsu_cpx_stack_dcfill_vld  =  
                       (cpx_local_st_ack_type & ~(cpx_spc_data_cx_b129 | cpx_spc_data_cx_b125))  &
                       lsu_cpx_spc_inv_vld ;

//timing fix: 6/16/03 - fix for ifill_pkt_vld - use b130 if store_ack_dcfill_vld=1
//bug3582 - b[130] for store ack is a dont-care i.e. capture b[130] only if packet type is not store ack
assign lsu_cpx_stack_dcfill_vld_b130  =  // if lsu_cpx_stack_dcfill_vld=1 b[130]=lsu_cpx_stack_dcfill_vld
                                         // if cpx_st_ack=0 b[130]=cpx_data[130]
                                       lsu_cpx_stack_dcfill_vld |    
                                       (~cpx_st_ack_type & cpx_spc_data_cx_b130) ;
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: lsu_tagdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================


// devices.xml



module lsu_tagdp( /*AUTOARG*/
   // Outputs
   so, lsu_misc_rdata_w2, lsu_rd_dtag_parity_g, 
   // Inputs
   rclk, si, se, lsu_va_wtchpt_addr, lsu_va_wtchpt_sel_g, dva_vld_m, 
   // dtag_rdata_w0_m, dtag_rdata_w1_m, dtag_rdata_w2_m, 
   // dtag_rdata_w3_m, 
   dtag_rdata_m, lsu_dtag_rsel_m, lsu_local_ldxa_data_g, 
   lsu_local_ldxa_sel_g, lsu_tlb_rd_data, lsu_local_ldxa_tlbrd_sel_g, 
   lsu_local_diagnstc_tagrd_sel_g
   );

   input         rclk;
   input         si;
   input         se;
   output        so;
   
input [47:3]  lsu_va_wtchpt_addr ;
input         lsu_va_wtchpt_sel_g;
   
input  [4-1:0]     dva_vld_m;	  // valid array read
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w0_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w1_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w2_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w3_m; // 29b tag; 1b parity  from dtag
input  [(33*4)-1:0]    dtag_rdata_m; // 29b tag; 1b parity  from dtag
input  [3:0]     lsu_dtag_rsel_m; // select one of the above tag  from ??

input  [47:0]    lsu_local_ldxa_data_g; // from dctl
input            lsu_local_ldxa_sel_g;  //used to mux ldxa data with 1/4 tags. from ??

input  [63:0]    lsu_tlb_rd_data; // from tlbdp - used in local ldxa mux
input            lsu_local_ldxa_tlbrd_sel_g;
input            lsu_local_diagnstc_tagrd_sel_g;


output [63:0]    lsu_misc_rdata_w2; // to qdp1
output [4-1:0]     lsu_rd_dtag_parity_g; // parity check on 4 tags. to dctl

// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w0_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w1_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w2_m; // 29b tag; 1b parity  from dtag
// input  [`L1D_TAG_PARITY_WIDTH-1:0]    dtag_rdata_w3_m; // 29b tag; 1b parity  from dtag
wire [33-1:0]    dtag_rdata_real_w0_m = dtag_rdata_m[33*(0+1)-1 -: 33];
wire [(29+1)-1:0]    dtag_rdata_w0_m = dtag_rdata_real_w0_m[(29+1)-1:0];
wire [3:0] dtag_rdata_w0_8b_parity_m;
wire [3:0] dtag_rdata_w0_8b_parity_g;
wire [33-1:0]    dtag_rdata_real_w1_m = dtag_rdata_m[33*(1+1)-1 -: 33];
wire [(29+1)-1:0]    dtag_rdata_w1_m = dtag_rdata_real_w1_m[(29+1)-1:0];
wire [3:0] dtag_rdata_w1_8b_parity_m;
wire [3:0] dtag_rdata_w1_8b_parity_g;
wire [33-1:0]    dtag_rdata_real_w2_m = dtag_rdata_m[33*(2+1)-1 -: 33];
wire [(29+1)-1:0]    dtag_rdata_w2_m = dtag_rdata_real_w2_m[(29+1)-1:0];
wire [3:0] dtag_rdata_w2_8b_parity_m;
wire [3:0] dtag_rdata_w2_8b_parity_g;
wire [33-1:0]    dtag_rdata_real_w3_m = dtag_rdata_m[33*(3+1)-1 -: 33];
wire [(29+1)-1:0]    dtag_rdata_w3_m = dtag_rdata_real_w3_m[(29+1)-1:0];
wire [3:0] dtag_rdata_w3_8b_parity_m;
wire [3:0] dtag_rdata_w3_8b_parity_g;


// wire             dtag_rdata_w0_parity_g,
//                  dtag_rdata_w1_parity_g,
//                  dtag_rdata_w2_parity_g,
//                  dtag_rdata_w3_parity_g;

reg [4-1:0] dtag_rdata_parity_g;
// wire [`L1D_WAY_COUNT-1:0] dtag_rdata_parity_g;

reg   [(29+1)-1:0] dtag_rdata_sel_m;
wire  [(29+1)-1:0] dtag_rdata_sel_g;


// wire   [3:0]     dtag_rdata_w0_8b_parity_m,
//                  dtag_rdata_w1_8b_parity_m,
//                  dtag_rdata_w2_8b_parity_m,
//                  dtag_rdata_w3_8b_parity_m;

// wire   [3:0]     dtag_rdata_w0_8b_parity_g,
//                  dtag_rdata_w1_8b_parity_g,
//                  dtag_rdata_w2_8b_parity_g,
//                  dtag_rdata_w3_8b_parity_g;

wire	[63:0]	 lsu_misc_rdata_g;

reg		 dtag_vld_sel_m;
wire dtag_vld_sel_g;

   wire  clk;
   assign clk = rclk;
   
//=================================================================================================
//      Select Tag Read data / ldxa data
//=================================================================================================

// select 1 out of 4 tags
// mux4ds  #(31) dtag_rdata_sel (
//         .in0    ({dtag_rdata_m[`L1D_TAG_ARRAY_WAY0_MASK],dva_vld_m[0]}),
//         .in1    ({dtag_rdata_m[`L1D_TAG_ARRAY_WAY1_MASK],dva_vld_m[1]}),
//         .in2    ({dtag_rdata_m[`L1D_TAG_ARRAY_WAY2_MASK],dva_vld_m[2]}),
//         .in3    ({dtag_rdata_m[`L1D_TAG_ARRAY_WAY3_MASK],dva_vld_m[3]}),
//         .sel0   (lsu_dtag_rsel_m[0]),  
//         .sel1   (lsu_dtag_rsel_m[1]),
//         .sel2   (lsu_dtag_rsel_m[2]),  
//         .sel3   (lsu_dtag_rsel_m[3]),
//         .dout   ({dtag_rdata_sel_m[`L1D_TAG_PARITY_WIDTH-1:0],dtag_vld_sel_m})
// );

always @ *
begin
{dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m} = 0;
if (lsu_dtag_rsel_m[0])
   {dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m} = {dtag_rdata_w0_m,dva_vld_m[0]};
else if (lsu_dtag_rsel_m[1])
   {dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m} = {dtag_rdata_w1_m,dva_vld_m[1]};
else if (lsu_dtag_rsel_m[2])
   {dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m} = {dtag_rdata_w2_m,dva_vld_m[2]};
else if (lsu_dtag_rsel_m[3])
   {dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m} = {dtag_rdata_w3_m,dva_vld_m[3]};
end


dff_s  #(31) dtag_rdata_sel_g_ff (
           .din  ({dtag_rdata_sel_m[(29+1)-1:0],dtag_vld_sel_m}),
           .q    ({dtag_rdata_sel_g[(29+1)-1:0],dtag_vld_sel_g}),
           .clk  (clk),
           .se   (se),       .si (),          .so ());

mux4ds  #(64) lsu_misc_rdata_sel (
        .in0    ({16'h0,lsu_local_ldxa_data_g[47:0]}),
        .in1    (lsu_tlb_rd_data[63:0]),
        .in2    ({16'h0,lsu_va_wtchpt_addr[47:3],3'b000}),                           
        .in3    ({33'h0,dtag_rdata_sel_g[(29+1)-1:0],dtag_vld_sel_g}),
        .sel0   (lsu_local_ldxa_sel_g),  
        .sel1   (lsu_local_ldxa_tlbrd_sel_g),
        .sel2   (lsu_va_wtchpt_sel_g),
        .sel3   (lsu_local_diagnstc_tagrd_sel_g),
        .dout   (lsu_misc_rdata_g[63:0])
);

dff_s  #(64) lsu_misc_rdata_w2_ff (
           .din  (lsu_misc_rdata_g[63:0]),
           .q    (lsu_misc_rdata_w2[63:0]),
           .clk  (clk),
           .se   (se),       .si (),          .so ());


//=================================================================================================
//      Tag Parity Calculation
//=================================================================================================

// flop tag parity bits 
// dff_s  #(4) dtag_rdata_parity_g_ff (
//            .din  ({dtag_rdata_m[`L1D_TAG_ARRAY_WAY0_PARITY_MASK],
//                    dtag_rdata_m[`L1D_TAG_ARRAY_WAY1_PARITY_MASK],
//                    dtag_rdata_m[`L1D_TAG_ARRAY_WAY2_PARITY_MASK],
//                    dtag_rdata_m[`L1D_TAG_ARRAY_WAY3_PARITY_MASK]}),
//            .q    ({dtag_rdata_parity_g[0],
//                    dtag_rdata_parity_g[1],
//                    dtag_rdata_parity_g[2],
//                    dtag_rdata_parity_g[3]}),
//            .clk  (clk),
//            .se   (se),       .si (),          .so ());

always @ (posedge clk)
begin
dtag_rdata_parity_g[0] <= dtag_rdata_w0_m[(29+1)-1];
dtag_rdata_parity_g[1] <= dtag_rdata_w1_m[(29+1)-1];
dtag_rdata_parity_g[2] <= dtag_rdata_w2_m[(29+1)-1];
dtag_rdata_parity_g[3] <= dtag_rdata_w3_m[(29+1)-1];

end

// generate 8bit parity for all ways before g-flop
// assign  dtag_rdata_w0_8b_parity_m[0] = ^dtag_rdata_w0_m[7:0] ;
// assign  dtag_rdata_w0_8b_parity_m[1] = ^dtag_rdata_w0_m[15:8] ;
// assign  dtag_rdata_w0_8b_parity_m[2] = ^dtag_rdata_w0_m[23:16] ;
// assign  dtag_rdata_w0_8b_parity_m[3] = ^dtag_rdata_w0_m[28:24] ;

// assign  dtag_rdata_w1_8b_parity_m[0] = ^dtag_rdata_w1_m[7:0] ;
// assign  dtag_rdata_w1_8b_parity_m[1] = ^dtag_rdata_w1_m[15:8] ;
// assign  dtag_rdata_w1_8b_parity_m[2] = ^dtag_rdata_w1_m[23:16] ;
// assign  dtag_rdata_w1_8b_parity_m[3] = ^dtag_rdata_w1_m[28:24] ;

// assign  dtag_rdata_w2_8b_parity_m[0] = ^dtag_rdata_w2_m[7:0] ;
// assign  dtag_rdata_w2_8b_parity_m[1] = ^dtag_rdata_w2_m[15:8] ;
// assign  dtag_rdata_w2_8b_parity_m[2] = ^dtag_rdata_w2_m[23:16] ;
// assign  dtag_rdata_w2_8b_parity_m[3] = ^dtag_rdata_w2_m[28:24] ;

// assign  dtag_rdata_w3_8b_parity_m[0] = ^dtag_rdata_w3_m[7:0] ;
// assign  dtag_rdata_w3_8b_parity_m[1] = ^dtag_rdata_w3_m[15:8] ;
// assign  dtag_rdata_w3_8b_parity_m[2] = ^dtag_rdata_w3_m[23:16] ;
// assign  dtag_rdata_w3_8b_parity_m[3] = ^dtag_rdata_w3_m[28:24] ;


  assign  dtag_rdata_w0_8b_parity_m[0] = ^dtag_rdata_w0_m[7:0] ;
  assign  dtag_rdata_w0_8b_parity_m[1] = ^dtag_rdata_w0_m[15:8] ;
  assign  dtag_rdata_w0_8b_parity_m[2] = ^dtag_rdata_w0_m[23:16] ;
  assign  dtag_rdata_w0_8b_parity_m[3] = ^dtag_rdata_w0_m[28:24] ;


  assign  dtag_rdata_w1_8b_parity_m[0] = ^dtag_rdata_w1_m[7:0] ;
  assign  dtag_rdata_w1_8b_parity_m[1] = ^dtag_rdata_w1_m[15:8] ;
  assign  dtag_rdata_w1_8b_parity_m[2] = ^dtag_rdata_w1_m[23:16] ;
  assign  dtag_rdata_w1_8b_parity_m[3] = ^dtag_rdata_w1_m[28:24] ;


  assign  dtag_rdata_w2_8b_parity_m[0] = ^dtag_rdata_w2_m[7:0] ;
  assign  dtag_rdata_w2_8b_parity_m[1] = ^dtag_rdata_w2_m[15:8] ;
  assign  dtag_rdata_w2_8b_parity_m[2] = ^dtag_rdata_w2_m[23:16] ;
  assign  dtag_rdata_w2_8b_parity_m[3] = ^dtag_rdata_w2_m[28:24] ;


  assign  dtag_rdata_w3_8b_parity_m[0] = ^dtag_rdata_w3_m[7:0] ;
  assign  dtag_rdata_w3_8b_parity_m[1] = ^dtag_rdata_w3_m[15:8] ;
  assign  dtag_rdata_w3_8b_parity_m[2] = ^dtag_rdata_w3_m[23:16] ;
  assign  dtag_rdata_w3_8b_parity_m[3] = ^dtag_rdata_w3_m[28:24] ;




// g-flop for 8-bit parity for all 4 ways

// dff_s  #(4) dtag_rdata_w0_8b_parity_g_ff (
//            .din  (dtag_rdata_w0_8b_parity_m[3:0]),
//            .q    (dtag_rdata_w0_8b_parity_g[3:0]),
//            .clk  (clk),
//            .se   (se),       .si (),          .so ());

// dff_s  #(4) dtag_rdata_w1_8b_parity_g_ff (
//            .din  (dtag_rdata_w1_8b_parity_m[3:0]),
//            .q    (dtag_rdata_w1_8b_parity_g[3:0]),
//            .clk  (clk),
//            .se   (se),       .si (),          .so ());

// dff_s  #(4) dtag_rdata_w2_8b_parity_g_ff (
//            .din  (dtag_rdata_w2_8b_parity_m[3:0]),
//            .q    (dtag_rdata_w2_8b_parity_g[3:0]),
//            .clk  (clk),
//            .se   (se),       .si (),          .so ());

// dff_s  #(4) dtag_rdata_w3_8b_parity_g_ff (
//            .din  (dtag_rdata_w3_8b_parity_m[3:0]),
//            .q    (dtag_rdata_w3_8b_parity_g[3:0]),
//            .clk  (clk),
//            .se   (se),       .si (),          .so ());

// assign  lsu_rd_dtag_parity_g[0]  =  ^({dtag_rdata_w0_8b_parity_g[3:0],dtag_rdata_parity_g[0]});
// assign  lsu_rd_dtag_parity_g[1]  =  ^({dtag_rdata_w1_8b_parity_g[3:0],dtag_rdata_parity_g[1]});
// assign  lsu_rd_dtag_parity_g[2]  =  ^({dtag_rdata_w2_8b_parity_g[3:0],dtag_rdata_parity_g[2]});
// assign  lsu_rd_dtag_parity_g[3]  =  ^({dtag_rdata_w3_8b_parity_g[3:0],dtag_rdata_parity_g[3]});


  dff_s  #(4) dtag_rdata_w0_8b_parity_g_ff (
             .din  (dtag_rdata_w0_8b_parity_m[3:0]),
             .q    (dtag_rdata_w0_8b_parity_g[3:0]),
             .clk  (clk),
             .se   (se),       .si (),          .so ());

  assign  lsu_rd_dtag_parity_g[0]  =  ^({dtag_rdata_w0_8b_parity_g[3:0],dtag_rdata_parity_g[0]});


  dff_s  #(4) dtag_rdata_w1_8b_parity_g_ff (
             .din  (dtag_rdata_w1_8b_parity_m[3:0]),
             .q    (dtag_rdata_w1_8b_parity_g[3:0]),
             .clk  (clk),
             .se   (se),       .si (),          .so ());

  assign  lsu_rd_dtag_parity_g[1]  =  ^({dtag_rdata_w1_8b_parity_g[3:0],dtag_rdata_parity_g[1]});


  dff_s  #(4) dtag_rdata_w2_8b_parity_g_ff (
             .din  (dtag_rdata_w2_8b_parity_m[3:0]),
             .q    (dtag_rdata_w2_8b_parity_g[3:0]),
             .clk  (clk),
             .se   (se),       .si (),          .so ());

  assign  lsu_rd_dtag_parity_g[2]  =  ^({dtag_rdata_w2_8b_parity_g[3:0],dtag_rdata_parity_g[2]});


  dff_s  #(4) dtag_rdata_w3_8b_parity_g_ff (
             .din  (dtag_rdata_w3_8b_parity_m[3:0]),
             .q    (dtag_rdata_w3_8b_parity_g[3:0]),
             .clk  (clk),
             .se   (se),       .si (),          .so ());

  assign  lsu_rd_dtag_parity_g[3]  =  ^({dtag_rdata_w3_8b_parity_g[3:0],dtag_rdata_parity_g[3]});





endmodule
