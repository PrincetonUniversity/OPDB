// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *   Description:
 *      This module implements a 16-bit counter to be used by Execution
 *      Drafting
 */

module sparc_ifu_esl_counter
#(
    parameter   COUNT_BIT_WIDTH = 16
)
(
    input                               clk,
    input                               rst_n,

    // Counter control
    input                               step,
    input                               clear,
    input                               set,

    // Counter output
    output reg [COUNT_BIT_WIDTH-1:0]    count_f
);

    //
    // Signal Declarations
    //

    // Counter next state
    reg [COUNT_BIT_WIDTH-1:0]          count_next;

    //
    // Sequential logic
    //
    
    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            count_f <= {COUNT_BIT_WIDTH{1'b0}};
        else
            count_f <= count_next;
    end

    //
    // Combinational logic
    //

    always @ *
    begin
        count_next = count_f;
        if (clear)
            count_next = {COUNT_BIT_WIDTH{1'b0}};
        else if (set)
            count_next = {{(COUNT_BIT_WIDTH-1){1'b0}}, 1'b1};
        else if (step)
            count_next = count_f + {{(COUNT_BIT_WIDTH-1){1'b0}}, 1'b1};
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to HTSM.
 */

module sparc_ifu_esl_htsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    input               clk,
    input               rst_n,

    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_htsm_trigger,
   
    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Pseudo-random bit
    input               pseudo_rand_f,

    // Difference in VA PCs lessthan the threshold
    input               esl_pc_va_diff_lt_thresh_s,

    // The counter reached the configured timeout value
    input               esl_counter_timeout,

    // The LSB of the shift register
    input               esl_shiftreg_lsb,

    // Thread with minimum PC
    input [3:0]         esl_min_pc_va_s,

    // VA PCs equal (including offset)
    input               esl_pcs_va_eql_s,

    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,

    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap PC in bf or f
    input               esl_brtrp_target_pc_bf_f,

    // Outputs to core and ED FSM
    output reg [2:0]    esl_htsm_state_next,
    output reg [3:0]    esl_htsm_fcl_nextthr_bf,
    output reg          esl_htsm_fcl_switch_bf,
    output reg          esl_htsm_fcl_ntr_s,
    output reg          esl_htsm_lfsr_step,
    output reg          esl_htsm_timeout_counter_step,
    output reg          esl_htsm_timeout_counter_clear,
    output reg          esl_htsm_timeout_counter_set,
    output reg          esl_htsm_pc_va_diff_offset_we,
    output reg          esl_htsm_pc_va_diff_offset_clear,
    output reg          esl_htsm_timeout_shiftreg_step,
    output reg          esl_htsm_timeout_shiftreg_set,
    output reg          esl_htsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //
    
    // Register to keep track of which thread we are issuing
    // when sliding thread past each other
    reg esl_htsm_sliding_thread_f;
    reg esl_htsm_sliding_thread_next;

    //
    // Sequential Logic
    //
    
    // Flip-flop to keep track of which thread is sliding
    always @ (posedge clk)
    begin
        if (~rst_n)
            esl_htsm_sliding_thread_f <= 1'b0;
        else
            esl_htsm_sliding_thread_f <= esl_htsm_sliding_thread_next;
    end
    

    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should always be running
        esl_htsm_lfsr_step = 1'b1;

        // Default is to clear the counter
        esl_htsm_timeout_counter_step = 1'b0;
        esl_htsm_timeout_counter_clear = 1'b1;
        esl_htsm_timeout_counter_set = 1'b0;

        // Default is not to set the offset register
        esl_htsm_pc_va_diff_offset_we = 1'b0;
        esl_htsm_pc_va_diff_offset_clear = 1'b0;

        // Default is to set the timeout shift register
        esl_htsm_timeout_shiftreg_step = 1'b0;
        esl_htsm_timeout_shiftreg_set = 1'b1;

        // Default is to keep the same sliding thread
        esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

        // Default to comparing with configured timeout
        esl_htsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_htsm_trigger && (esl_state_f == DIVERGED))
        begin
            // Always compare to configured timeout when in diverged
            esl_htsm_timeout_counter_cmp_config = 1'b1;
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_htsm_state_next = DIVERGED;
                esl_htsm_fcl_nextthr_bf = 4'b0000;
                esl_htsm_fcl_switch_bf = 1'b0;
                esl_htsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave counter alone
                esl_htsm_timeout_counter_step = 1'b0;
                esl_htsm_timeout_counter_clear = 1'b0;
                esl_htsm_timeout_counter_set = 1'b0;

                // Leave the shift register alone
                esl_htsm_timeout_shiftreg_step = 1'b0;
                esl_htsm_timeout_shiftreg_set = 1'b0;

                // Keep same sliding thread
                esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_htsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_htsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                    end
                    else
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'bxxxx;
                    end
                    esl_htsm_fcl_switch_bf = 1'b1;
                    esl_htsm_fcl_ntr_s = 1'b1;

                    // Leave counter alone
                    esl_htsm_timeout_counter_step = 1'b0;
                    esl_htsm_timeout_counter_clear = 1'b0;
                    esl_htsm_timeout_counter_set = 1'b0;

                    // Leave the shift register alone
                    esl_htsm_timeout_shiftreg_step = 1'b0;
                    esl_htsm_timeout_shiftreg_set = 1'b0;

                    // Keep same sliding thread
                    esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_htsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_htsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Clear counter
                        esl_htsm_timeout_counter_step = 1'b0;
                        esl_htsm_timeout_counter_clear = 1'b1;
                        esl_htsm_timeout_counter_set = 1'b0;

                        // Set the shift register back to 1
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Thread 0 becomes sliding thread
                        esl_htsm_sliding_thread_next = 1'b0;
                    end
                    else
                    begin
                        // If the VA PCs + offset are equal, we must go to diverged
                        // different code, issuing thread0, and begin sliding threads
                        // past each other
                        if (esl_pcs_va_eql_s)
                        begin
                            // Go to diverged different code
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;

                            // Select thread 0
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                            
                            // Executed one for thread0 which is where we need
                            // to start, so we will reset this counter here to
                            // start counting for thread 1
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b1;
                            
                            // Shift the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b1;
                            esl_htsm_timeout_shiftreg_set = 1'b0;

                            // Thread 1 is now the sliding thread
                            esl_htsm_sliding_thread_next = 1'b1; 
                        end
                        // Otherwise, do the same as STSM except choose random thread
                        // when beyond the threshold
                        else
                        begin
                            // Always stay in diverged state
                            esl_htsm_state_next = DIVERGED;
                            // Select thread with the minimum VA PC if the difference is less
                            // than a threshold, otherwise alternate
                            if (esl_pc_va_diff_lt_thresh_s)
                            begin
                                // If we have hit the timeout in selecting the minimum PC,
                                // select the maximum PC
                                if (esl_counter_timeout)
                                begin
                                    if (esl_min_pc_va_s == 4'b0001)
                                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                                    else
                                        esl_htsm_fcl_nextthr_bf = 4'b0001;

                                    // Clear the timer
                                    esl_htsm_timeout_counter_step = 1'b0;
                                    esl_htsm_timeout_counter_clear = 1'b1;
                                    esl_htsm_timeout_counter_set = 1'b0;
                                end
                                // Otherwise, select minimum PC and increment timeout
                                else
                                begin
                                    esl_htsm_fcl_nextthr_bf = esl_min_pc_va_s;

                                    // Increment counter
                                    esl_htsm_timeout_counter_step = 1'b1;
                                    esl_htsm_timeout_counter_clear = 1'b0;
                                    esl_htsm_timeout_counter_set = 1'b0;
                                end
                            end
                            else
                            begin
                                // Select random thread
                                if (pseudo_rand_f)
                                    esl_htsm_fcl_nextthr_bf = 4'b0010;
                                else
                                    esl_htsm_fcl_nextthr_bf = 4'b0001;
 
                                // Clear the timer
                                esl_htsm_timeout_counter_step = 1'b0;
                                esl_htsm_timeout_counter_clear = 1'b1;
                                esl_htsm_timeout_counter_set = 1'b0;
                            end
                        end
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Reset the shiftreg
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Keep same sliding thread
                        esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                    end
                end
            end
        end
        else if (esl_htsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Always compare to shift register in this state
            esl_htsm_timeout_counter_cmp_config = 1'b0;
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                esl_htsm_fcl_nextthr_bf = 4'b0000;
                esl_htsm_fcl_switch_bf = 1'b0;
                esl_htsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave the timeout counter alone
                esl_htsm_timeout_counter_step = 1'b0;
                esl_htsm_timeout_counter_clear = 1'b0;
                esl_htsm_timeout_counter_set = 1'b0;

                // Leave the shift register alone
                esl_htsm_timeout_shiftreg_step = 1'b0;
                esl_htsm_timeout_shiftreg_set = 1'b0;

                // Keep same sliding thread
                esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

                // Do not set offset
                esl_htsm_pc_va_diff_offset_we = 1'b0;
                esl_htsm_pc_va_diff_offset_clear = 1'b0;
            end
            // Otherwise, both threads are ready
            else
            begin 
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_htsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'b0010;
                    end
                    else
                    begin
                        esl_htsm_fcl_nextthr_bf = 4'bxxxx;
                    end
                    esl_htsm_fcl_switch_bf = 1'b1;
                    esl_htsm_fcl_ntr_s = 1'b1;

                    // Leave the timeout counter alone
                    esl_htsm_timeout_counter_step = 1'b0;
                    esl_htsm_timeout_counter_clear = 1'b0;
                    esl_htsm_timeout_counter_set = 1'b0;

                    // Leave the shift register alone
                    esl_htsm_timeout_shiftreg_step = 1'b0;
                    esl_htsm_timeout_shiftreg_set = 1'b0;

                    // Keep same sliding thread
                    esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;

                    // Do not set offset
                    esl_htsm_pc_va_diff_offset_we = 1'b0;
                    esl_htsm_pc_va_diff_offset_clear = 1'b0;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged, update offset
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                        begin
                            esl_htsm_state_next = CONVERGED_DRAFT;

                            // Update offset to current difference in VA's
                            esl_htsm_pc_va_diff_offset_we = 1'b1;
                            esl_htsm_pc_va_diff_offset_clear = 1'b0;
                        end
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                        begin
                            esl_htsm_state_next = DIVERGED_DRAFT;
    
                            // Do not update offset
                            esl_htsm_pc_va_diff_offset_we = 1'b0;
                            esl_htsm_pc_va_diff_offset_clear = 1'b0;
                        end

                        // Select thr0 for next cycle
                        esl_htsm_fcl_nextthr_bf = 4'b0001;
                        esl_htsm_fcl_switch_bf = 1'b1;
                        esl_htsm_fcl_ntr_s = 1'b1;

                        // Clear the timeout counter
                        esl_htsm_timeout_counter_step = 1'b0;
                        esl_htsm_timeout_counter_clear = 1'b1;
                        esl_htsm_timeout_counter_set = 1'b0;

                        // Reset the shift register
                        esl_htsm_timeout_shiftreg_step = 1'b0;
                        esl_htsm_timeout_shiftreg_set = 1'b1;

                        // Sliding thread is back to thread 0
                        esl_htsm_sliding_thread_next = 1'b0;
                    end
                    else
                    begin
                        // The LSB of the shift register should only
                        // ever be 1 after the shift register rolls
                        // around and not when we first enter this state
                        // (shiftreg should be 16'b2 entering this state
                        // for the first time). In the case the shiftreg
                        // rolls around, we declare diverged
                        if (esl_shiftreg_lsb)
                        begin
                            esl_htsm_state_next = DIVERGED;
                                
                            // Issue the current sliding thread
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;

                            // Clear the timeout counter
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b1;
                            esl_htsm_timeout_counter_set = 1'b0;

                            // Reset the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b0;
                            esl_htsm_timeout_shiftreg_set = 1'b1;

                            // Sliding thread is back to thread 0
                            esl_htsm_sliding_thread_next = 1'b0;
                        end
                        // Check if the counter reached the shift register value
                        else if (esl_counter_timeout)
                        begin
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                            
                            // If so, issue the sliding thread,
                            // reset shift reg counter, shift
                            // the shift register, and invert
                            // sliding thread
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;

                            // Set the timeout counter
                            esl_htsm_timeout_counter_step = 1'b0;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b1;

                            // Step the shift register
                            esl_htsm_timeout_shiftreg_step = 1'b1;
                            esl_htsm_timeout_shiftreg_set = 1'b1;

                            // Invert sliding thread
                            esl_htsm_sliding_thread_next = ~esl_htsm_sliding_thread_f;
                        end
                        else
                        begin
                            esl_htsm_state_next = DIVERGED_DIFFERENT_CODE_RCFG0;
                            
                            // If not, issue the sliding thread and
                            // increment counter
                            if (esl_htsm_sliding_thread_f)
                                esl_htsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_htsm_fcl_nextthr_bf = 4'b0001;
                            esl_htsm_fcl_switch_bf = 1'b1;
                            esl_htsm_fcl_ntr_s = 1'b1;
                           
                            // Step the timeout counter
                            esl_htsm_timeout_counter_step = 1'b1;
                            esl_htsm_timeout_counter_clear = 1'b0;
                            esl_htsm_timeout_counter_set = 1'b0;
 
                            // Leave the shift register alone
                            esl_htsm_timeout_shiftreg_step = 1'b0;
                            esl_htsm_timeout_shiftreg_set = 1'b0;

                            // Same sliding thread
                            esl_htsm_sliding_thread_next = esl_htsm_sliding_thread_f;
                        end

                        // Do not set the offset register
                        esl_htsm_pc_va_diff_offset_we = 1'b0; 
                        esl_htsm_pc_va_diff_offset_clear = 1'b0;
                    end
                end
            end
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_htsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_htsm_state_next = DIVERGED;
            esl_htsm_fcl_nextthr_bf = 4'b0000;
            esl_htsm_fcl_switch_bf = 1'b0;
            esl_htsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_htsm_state_next = 3'bxx;
            esl_htsm_fcl_nextthr_bf = 4'bxxxx;
            esl_htsm_fcl_switch_bf = 1'bx;
            esl_htsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
//  Description:
//      An LFSR for the Execution Drafting random thread synchronization method.
//      The LFSR provides pseudo-randomness in selecting a random thread to execute.
//      It is a 16-bit LFSR with the following polynomial:
//          x^16 + x^14 + x^13 + x^11 + 1
*/

module sparc_ifu_esl_lfsr 
(
    input               clk,
    input               rst_n,

    // Seeding the LFSR
    input [15:0]        lfsr_seed,
    input               lfsr_ld,

    // Enable signal for LFSR
    input               lfsr_step,

    // LFSR state output
    output reg [15:0]   lfsr_state_f,

    // LFSR bit stream output
    output reg          lfsr_out_f
);

    //
    // Signal Declarations
    //
    
    // LFSR next state
    reg [15:0]          lfsr_state_next;

    //
    // Sequential logic
    //

    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            lfsr_state_f <= 16'b0;
        else
            lfsr_state_f <= lfsr_state_next;
    end
    
    //
    // Combinational Logic
    // 
    
    always @ *
    begin
        // Next state logic
        lfsr_state_next = lfsr_state_f;
        if (rst_n && lfsr_ld)
            lfsr_state_next = lfsr_seed;
        else if (rst_n && lfsr_step)
            lfsr_state_next = {lfsr_state_f[14:0], 
                               lfsr_state_f[15] ^ lfsr_state_f[13] ^ lfsr_state_f[12] ^ lfsr_state_f[10]};

        // Output bitstream comes from the 16th state bit
        lfsr_out_f = lfsr_state_f[15];
    end

endmodule // sparc_esl_lfsr
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to RTSM.
 */

module sparc_ifu_esl_rtsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_rtsm_trigger,

    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s, 

    // Pseudo-random bit
    input               pseudo_rand_f,
  
    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,
 
    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap PC in bf or f
    input               esl_brtrp_target_pc_bf_f,
 
    // Outputs to core and ED FSM
    output reg [2:0]    esl_rtsm_state_next,   
    output reg [3:0]    esl_rtsm_fcl_nextthr_bf,
    output reg          esl_rtsm_fcl_switch_bf,
    output reg          esl_rtsm_fcl_ntr_s,
    output reg          esl_rtsm_lfsr_step,
    output reg          esl_rtsm_timeout_counter_step,
    output reg          esl_rtsm_timeout_counter_clear,
    output reg          esl_rtsm_timeout_counter_set,
    output reg          esl_rtsm_pc_va_diff_offset_we,
    output reg          esl_rtsm_pc_va_diff_offset_clear,
    output reg          esl_rtsm_timeout_shiftreg_step,
    output reg          esl_rtsm_timeout_shiftreg_set,
    output reg          esl_rtsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //

    //
    // Sequential Logic
    //
    
    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should always be running
        esl_rtsm_lfsr_step = 1'b1;

        // Counter should never be running (always clear)
        esl_rtsm_timeout_counter_step = 1'b0;
        esl_rtsm_timeout_counter_clear = 1'b1; 
        esl_rtsm_timeout_counter_set = 1'b0;

        // Never use offset register
        esl_rtsm_pc_va_diff_offset_we = 1'b0;
        esl_rtsm_pc_va_diff_offset_clear = 1'b1;

        // Never use shift register
        esl_rtsm_timeout_shiftreg_step = 1'b0;
        esl_rtsm_timeout_shiftreg_set = 1'b1;

        // Doesn't really matter what we set this to
        // as we never check whether counter times out
        esl_rtsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_rtsm_trigger && (esl_state_f == DIVERGED))
        begin
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_rtsm_state_next = DIVERGED;
                esl_rtsm_fcl_nextthr_bf = 4'b0000;
                esl_rtsm_fcl_switch_bf = 1'b0;
                esl_rtsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_rtsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_rtsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_rtsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_rtsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_rtsm_fcl_nextthr_bf = 4'b0010;
                    end
                    esl_rtsm_fcl_switch_bf = 1'b1;
                    esl_rtsm_fcl_ntr_s = 1'b1;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_rtsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_rtsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_rtsm_fcl_nextthr_bf = 4'b0001;
                        esl_rtsm_fcl_switch_bf = 1'b1;
                        esl_rtsm_fcl_ntr_s = 1'b1;
                    end
                    else
                    begin
                        // Always stay in diverged state
                        esl_rtsm_state_next = DIVERGED;
                        // Select random thread
                        if (pseudo_rand_f)
                            esl_rtsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_rtsm_fcl_nextthr_bf = 4'b0001;
                        esl_rtsm_fcl_switch_bf = 1'b1;
                        esl_rtsm_fcl_ntr_s = 1'b1;
                    end
                end
            end
        end
        else if (esl_rtsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0; 
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_rtsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_rtsm_state_next = DIVERGED;
            esl_rtsm_fcl_nextthr_bf = 4'b0000;
            esl_rtsm_fcl_switch_bf = 1'b0;
            esl_rtsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_rtsm_state_next = 3'bx;
            esl_rtsm_fcl_nextthr_bf = 4'bxxxx;
            esl_rtsm_fcl_switch_bf = 1'bx;
            esl_rtsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *   Description:
 *      This module implements a 49-bit shift register with wrap around
 *      to be used by Execution Drafting
 */

module sparc_ifu_esl_shiftreg
#(
    parameter SHIFT_REG_BIT_WIDTH = 16
)
(
    input                                   clk,
    input                                   rst_n,

    // Counter control
    input                                   step,
    input                                   set,

    // Counter output
    output reg [SHIFT_REG_BIT_WIDTH-1:0]    shift_reg_f
);

    //
    // Signal Declarations
    //

    // Counter next state
    reg [SHIFT_REG_BIT_WIDTH-1:0]          shift_reg_next;

    //
    // Sequential logic
    //
    
    // State flip-flops
    always @ (posedge clk)
    begin
        if (~rst_n)
            shift_reg_f <= {SHIFT_REG_BIT_WIDTH{1'b0}};
        else
            shift_reg_f <= shift_reg_next;
    end

    //
    // Combinational logic
    //

    always @ *
    begin
        shift_reg_next = shift_reg_f;
        if (set)
            shift_reg_next = {{(SHIFT_REG_BIT_WIDTH-1){1'b0}}, 1'b1};
        else if (step)
            shift_reg_next = {shift_reg_f[SHIFT_REG_BIT_WIDTH-2:0], shift_reg_f[SHIFT_REG_BIT_WIDTH-1]};
    end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the portions of the Execution Drafting FSM
 *      that are specific to STSM.
 */

module sparc_ifu_esl_stsm
#(
    parameter DIVERGED = 0,
    parameter DIVERGED_DRAFT = 1,
    parameter CONVERGED = 2,
    parameter CONVERGED_DRAFT = 3,
    parameter DIVERGED_DIFFERENT_CODE_RCFG0 = 4,
    parameter RCFG1 = 5,
    parameter RCFG2 = 6,
    parameter RCFG3 = 7
)
(
    // Trigger for condition where this module
    // makes the thread select decision
    input               esl_stsm_trigger,
   
    // Current state of ESL FSM
    input [2:0]         esl_state_f,

    // Thread ready signals
    input [3:0]         swl_esl_thr_sprdy_or_urdy,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Difference in VA PCs lessthan the threshold
    input               esl_pc_va_diff_lt_thresh_s,

    // The counter reached the timeout value
    input               esl_counter_timeout,

    // Thread with minimum PC
    input [3:0]         esl_min_pc_va_s,

    // Thread in the F stage
    input [3:0]         fcl_esl_thr_f,

    // Information about thread instructions
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,

    // Unresolved branch in pipe
    input               esl_unresolved_br,

    // Branch or trap target PC in bf or f
    input               esl_brtrp_target_pc_bf_f,

    // Outputs to core and ED FSM
    output reg [2:0]    esl_stsm_state_next,
    output reg [3:0]    esl_stsm_fcl_nextthr_bf,
    output reg          esl_stsm_fcl_switch_bf,
    output reg          esl_stsm_fcl_ntr_s,
    output reg          esl_stsm_lfsr_step,
    output reg          esl_stsm_timeout_counter_step,
    output reg          esl_stsm_timeout_counter_clear,
    output reg          esl_stsm_timeout_counter_set,
    output reg          esl_stsm_pc_va_diff_offset_we,
    output reg          esl_stsm_pc_va_diff_offset_clear,
    output reg          esl_stsm_timeout_shiftreg_step,
    output reg          esl_stsm_timeout_shiftreg_set,
    output reg          esl_stsm_timeout_counter_cmp_config
);

    //
    // Signal Declarations
    //

    //
    // Sequential Logic
    //
    
    //
    // Combinational Logic
    //

    always @ *
    begin
        // LFSR should never be running
        esl_stsm_lfsr_step = 1'b0;

        // Default is to clear the counter
        esl_stsm_timeout_counter_step = 1'b0;
        esl_stsm_timeout_counter_clear = 1'b1;
        esl_stsm_timeout_counter_set = 1'b0;

        // Never use offset register
        esl_stsm_pc_va_diff_offset_we = 1'b0;
        esl_stsm_pc_va_diff_offset_clear = 1'b1;

        // Never use the shift register
        esl_stsm_timeout_shiftreg_step = 1'b0;
        esl_stsm_timeout_shiftreg_set = 1'b1;

        // Always compare to configured timeout
        esl_stsm_timeout_counter_cmp_config = 1'b1;

        // Look for trigger in diverged state
        if (esl_stsm_trigger && (esl_state_f == DIVERGED))
        begin
            // If at least one thread is not ready, we will just wait
            // TODO: We may want to change this
            if (!(swl_esl_thr_sprdy_or_urdy[0] && swl_esl_thr_sprdy_or_urdy[1]))
            begin
                esl_stsm_state_next = DIVERGED;
                esl_stsm_fcl_nextthr_bf = 4'b0000;
                esl_stsm_fcl_switch_bf = 1'b0;
                esl_stsm_fcl_ntr_s = 1'b1; // Note: this switches out any running threads

                // Leave counter alone
                esl_stsm_timeout_counter_step = 1'b0;
                esl_stsm_timeout_counter_clear = 1'b0;
                esl_stsm_timeout_counter_set = 1'b0;
            end
            // Otherwise, both threads are ready
            else
            begin
                // If both instructions are not ready, we will just wait
                // TODO: We may want to change this
                if (!(fcl_esl_tinst_vld_s[0] && fcl_esl_tinst_vld_s[1]))
                begin
                    esl_stsm_state_next = DIVERGED;
                    // If both instructions are not ready, alternate fetching threads
                    if (!fcl_esl_tinst_vld_s[0] && !fcl_esl_tinst_vld_s[1])
                    begin
                        if (fcl_esl_thr_f == 4'b0001)
                            esl_stsm_fcl_nextthr_bf = 4'b0010;
                        else
                            esl_stsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr0 instruction is not ready, select it
                    else if(!fcl_esl_tinst_vld_s[0])
                    begin
                        esl_stsm_fcl_nextthr_bf = 4'b0001;
                    end
                    // If only thr1 instruction is not ready, select it
                    else if (!fcl_esl_tinst_vld_s[1])
                    begin
                        esl_stsm_fcl_nextthr_bf = 4'b0010;
                    end
                    esl_stsm_fcl_switch_bf = 1'b1;
                    esl_stsm_fcl_ntr_s = 1'b1;

                    // Leave counter alone
                    esl_stsm_timeout_counter_step = 1'b0;
                    esl_stsm_timeout_counter_clear = 1'b0;
                    esl_stsm_timeout_counter_set = 1'b0;
                end
                // Otherwise, both threads are ready and both instructions are ready                     
                else
                begin
                    // Check if instructions match or opcodes match
                    if (esl_tirs_eql_s || esl_ops_eql_s)
                    begin
                        // If phys address of PCs are equal,
                        // we have converged
                        if (esl_pcs_pa_eql_s && !esl_unresolved_br && !esl_brtrp_target_pc_bf_f)
                            esl_stsm_state_next = CONVERGED_DRAFT;
                        // Otherwise, we will just draft these
                        // instructions and come back to diverged
                        else
                            esl_stsm_state_next = DIVERGED_DRAFT; 

                        // Select thr0 for next cycle
                        esl_stsm_fcl_nextthr_bf = 4'b0001;
                        esl_stsm_fcl_switch_bf = 1'b1;
                        esl_stsm_fcl_ntr_s = 1'b1;

                        // Clear counter
                        esl_stsm_timeout_counter_step = 1'b0;
                        esl_stsm_timeout_counter_clear = 1'b1;
                        esl_stsm_timeout_counter_set = 1'b0;
                    end
                    else
                    begin
                        // Always stay in diverged state
                        esl_stsm_state_next = DIVERGED;
                        // Select thread with the minimum VA PC if the difference is less
                        // than a threshold, otherwise alternate
                        if (esl_pc_va_diff_lt_thresh_s)
                        begin
                            // If we have hit the timeout in selecting the minimum PC,
                            // select the maximum PC
                            if (esl_counter_timeout)
                            begin
                                if (esl_min_pc_va_s == 4'b0001)
                                    esl_stsm_fcl_nextthr_bf = 4'b0010;
                                else
                                    esl_stsm_fcl_nextthr_bf = 4'b0001;

                                // Clear the timer
                                esl_stsm_timeout_counter_step = 1'b0;
                                esl_stsm_timeout_counter_clear = 1'b1;
                                esl_stsm_timeout_counter_set = 1'b0;
                            end
                            // Otherwise, select minimum PC and increment timeout
                            else
                            begin
                                esl_stsm_fcl_nextthr_bf = esl_min_pc_va_s;
                                // Increment counter
                                esl_stsm_timeout_counter_step = 1'b1;
                                esl_stsm_timeout_counter_clear = 1'b0;
                                esl_stsm_timeout_counter_set = 1'b0;
                            end
                        end
                        else
                        begin
                            if (fcl_esl_thr_f == 4'b0001)
                                esl_stsm_fcl_nextthr_bf = 4'b0010;
                            else
                                esl_stsm_fcl_nextthr_bf = 4'b0001;
                            
                            // Clear the timer
                            esl_stsm_timeout_counter_step = 1'b0;
                            esl_stsm_timeout_counter_clear = 1'b1;
                            esl_stsm_timeout_counter_set = 1'b0;
                        end
                        esl_stsm_fcl_switch_bf = 1'b1;
                        esl_stsm_fcl_ntr_s = 1'b1;
                    end
                end
            end     
        end
        else if (esl_stsm_trigger && (esl_state_f == DIVERGED_DIFFERENT_CODE_RCFG0))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG1))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0; 
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG2))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else if (esl_stsm_trigger && (esl_state_f == RCFG3))
        begin
            // Try to recover
            esl_stsm_state_next = DIVERGED;
            esl_stsm_fcl_nextthr_bf = 4'b0000;
            esl_stsm_fcl_switch_bf = 1'b0;
            esl_stsm_fcl_ntr_s = 1'b0;
        end
        else
        begin
            esl_stsm_state_next = 3'bxx;
            esl_stsm_fcl_nextthr_bf = 4'bxxxx;
            esl_stsm_fcl_switch_bf = 1'bx;
            esl_stsm_fcl_ntr_s = 1'bx;
        end
    end

endmodule
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/********************************************************************
 * Author: Sam Payne
 * 
 * Module encapsulates an asynchronus FIFO used for bridging signals
 * across clock domains, parameters allow for different sized modules
 * compatible with wide range of frequencies.
 *
 * * *******************************************************************/



module async_fifo 
#(
	parameter DSIZE = 64,
	parameter ASIZE = 5,
	parameter MEMSIZE = 16 // should be 2 ^ (ASIZE-1)
)
(
	rdata, 
	rempty,
	rclk,
	ren,
	wdata,
	wfull,
	wclk,
	wval,
	wreset,
	rreset
	);

//Inputs and Outputs
output  [DSIZE-1:0] 	rdata;
output			rempty;
output 			wfull;
input	[DSIZE-1:0]	wdata;
input			wval;
input			ren;
input			rclk;
input			wclk;
input 			wreset;
input			rreset;

//Internal Registers
reg	[ASIZE-1:0]	g_wptr;
reg	[ASIZE-1:0]	g_rptr;

reg	[ASIZE-1:0]	g_rsync1, g_rsync2;
reg	[ASIZE-1:0]	g_wsync1, g_wsync2;

//Memory
reg	[DSIZE-1:0] 	fifo[MEMSIZE-1:0];

wire [ASIZE-1:0] b_wptr;
wire [ASIZE-1:0] b_wptr_next;
wire [ASIZE-1:0] g_wptr_next;
wire [ASIZE-1:0] b_rptr;
wire [ASIZE-1:0] b_rptr_next;
wire [ASIZE-1:0] g_rptr_next;

/********************************************************************
COMBINATIONAL LOGIC
********************************************************************/

//convert gray to binary
assign b_wptr[ASIZE-1:0] = ({1'b0, b_wptr[ASIZE-1:1]} ^ g_wptr[ASIZE-1:0]);
assign b_rptr[ASIZE-1:0] = ({1'b0, b_rptr[ASIZE-1:1]} ^ g_rptr[ASIZE-1:0]);

//increment
assign b_wptr_next = b_wptr + 1;
assign b_rptr_next = b_rptr + 1;

//convert binary to gray
assign g_wptr_next[ASIZE-1:0] = {1'b0, b_wptr_next[ASIZE-1:1]} ^ b_wptr_next[ASIZE-1:0];
assign g_rptr_next[ASIZE-1:0] = {1'b0, b_rptr_next[ASIZE-1:1]} ^ b_rptr_next[ASIZE-1:0];

//full and empty signals
assign wfull =  (g_wptr[ASIZE-1]   != g_rsync2[ASIZE-1]  ) && 
		(g_wptr[ASIZE-2]   != g_rsync2[ASIZE-2]  ) &&
		(g_wptr[ASIZE-3:0] == g_rsync2[ASIZE-3:0]) ||
		(wreset || rreset);

assign rempty =  (g_wsync2[ASIZE-1:0] == g_rptr[ASIZE-1:0]) ||
	         (wreset || rreset);

//output values
assign rdata = fifo[b_rptr[ASIZE-2:0]];

/********************************************************************
SEQUENTIAL LOGIC
********************************************************************/

//transfer register values
always @(posedge rclk) begin
	if (rreset) begin
		g_rptr <= 0;
	end
	else if (ren && !rempty) begin
		g_rptr <= g_rptr_next;
	end

	g_wsync1 <= g_wptr;
	g_wsync2 <= g_wsync1;
end

always @(posedge wclk) begin
	if (wreset) begin
		g_wptr <= 0;
	end
	else if (wval && !wfull) begin
		fifo[b_wptr[ASIZE-2:0]] <= wdata;
		g_wptr <= g_wptr_next;
	end

	g_rsync1 <= g_rptr;
	g_rsync2 <= g_rsync1;

	
end

endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs, modified to be synthesizable

module bram_1r1w_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
  input wire MEMCLK,
  input wire RESET_N,
  input wire CEA,
  input wire [ADDR_WIDTH-1:0] AA,
  input wire [ADDR_WIDTH-1:0] AB,

  input wire RDWENA,
  input wire CEB,
  input wire RDWENB,
  input wire [DATA_WIDTH-1:0] BWA,
  input wire [DATA_WIDTH-1:0] DINA,
  output reg [DATA_WIDTH-1:0] DOUTA,
  input wire [DATA_WIDTH-1:0] BWB,
  input wire [DATA_WIDTH-1:0] DINB,
  output wire [DATA_WIDTH-1:0] DOUTB
  // input wire [`BIST_OP_WIDTH-1:0] BIST_COMMAND,
  // input wire [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DIN,
  // output reg [`SRAM_WRAPPER_BUS_WIDTH-1:0] BIST_DOUT,
  // input wire [`BIST_ID_WIDTH-1:0] SRAMID
);

wire                            write_enable_in;
wire                            read_enable_in;

// Temporary storage for write data
reg                             write_enable_in_reg;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG;
reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg   [BITMASK_WIDTH-1:0 ]      WRITE_BIT_MASK_REG;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
// reg   [DATA_WIDTH-1:0    ]      DOUTB_r;

reg                             read_enable_in_reg;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_write_en;
reg                            bram_write_en_muxed;
wire                            bram_read_en;
wire                            bram_write_read_en;
reg  [DATA_WIDTH-1:0    ]      bram_data_write_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_read_out_reg;
reg  [DATA_WIDTH-1:0    ]      bram_data_in;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;
wire  [DATA_WIDTH-1:0    ]      last_wrote_data;
wire                            rw_conflict;
reg                             rw_conflict_r;
wire                            ww_conflict;
reg                             ww_conflict_r;

/* renaming signals */
assign read_enable_in    = CEA & (RDWENA == 1'b1);
assign write_enable_in   = CEB & (RDWENB == 1'b0);
wire [ADDR_WIDTH-1:0    ] READ_ADDRESS = AA;
wire [ADDR_WIDTH-1:0    ] WRITE_ADDRESS = AB;
wire [BITMASK_WIDTH-1:0    ] WRITE_BIT_MASK = BWB;

// Intermediate logic for write processing
always @(posedge MEMCLK) begin
  write_enable_in_reg <= write_enable_in;
  WRITE_ADDRESS_REG   <= WRITE_ADDRESS;
  WRITE_BIT_MASK_REG  <= WRITE_BIT_MASK;
  DIN_r <= DINB;
  read_enable_in_reg  <= read_enable_in;
  bram_data_in_r <= bram_data_in;
  rw_conflict_r  <= rw_conflict;
  ww_conflict_r  <= ww_conflict;
  // DOUTB_r  <= DOUTB;
end

// determining read-write and write-write conflict for data bypassing
assign rw_conflict      = write_enable_in_reg & read_enable_in & (WRITE_ADDRESS_REG == READ_ADDRESS);
assign ww_conflict      = write_enable_in_reg & write_enable_in & (WRITE_ADDRESS_REG == WRITE_ADDRESS);
assign DOUTB = {DATA_WIDTH{1'bx}}; // port B is always used for write

// calculate the correct read and write data after accoutning for conflicts
always @ * begin
  bram_data_in = (DIN_r & WRITE_BIT_MASK_REG);
  if (ww_conflict_r)
    bram_data_in = bram_data_in | (bram_data_in_r & ~WRITE_BIT_MASK_REG);
  else
    bram_data_in = bram_data_in | (bram_data_write_read_out_reg & ~WRITE_BIT_MASK_REG);
  

  // note: DOUT retains value if read enable is not asserted
  // which is why default value is not set for DOUT
  if (read_enable_in_reg) begin
    DOUTA = bram_data_read_out_reg; 
    if (rw_conflict_r) begin
      DOUTA = bram_data_in_r;
    end
  end
end

// synthesizable BRAM
assign bram_write_en      = write_enable_in_reg;
assign bram_read_en         = (read_enable_in) & ~rw_conflict;             // do not read in case of a conflict
assign bram_write_read_en         = (write_enable_in) & ~ww_conflict;             // do not read in case of a conflict

reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_write_read_out_reg;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
    ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_read_en) begin
    bram_data_read_out_reg <= ram[READ_ADDRESS];
  end
  if (bram_write_read_en) begin
    bram_data_write_read_out_reg <= ram[WRITE_ADDRESS];
  end
end
// END BRAM


/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = WRITE_ADDRESS_REG;
      bram_write_en_muxed = bram_write_en;
      bram_data_in_muxed = bram_data_in;
   end
end


endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author:      Alexey Lavrov, Tri Nguyen
// Description: A simple wrapper to infer Xilinx BRAMs for SRAMs

module bram_1rw_wrapper 
#(parameter NAME="", DEPTH=1, ADDR_WIDTH=1, BITMASK_WIDTH=1, DATA_WIDTH=1)
(
    input                         MEMCLK,
    input wire RESET_N,
    input                         CE,
    input   [ADDR_WIDTH-1:0]      A,
    input                         RDWEN,
    input   [BITMASK_WIDTH-1:0]   BW,
    input   [DATA_WIDTH-1:0]      DIN,
    output  [DATA_WIDTH-1:0]      DOUT
);

wire                            write_en;
wire                            read_en;

// Temporary storage for write data
reg                             wen_r;
reg   [ADDR_WIDTH-1:0    ]      A_r;
reg   [BITMASK_WIDTH-1:0 ]      BW_r;
reg   [DATA_WIDTH-1:0    ]      DIN_r;
reg   [DATA_WIDTH-1:0    ]      DOUT_r;

reg                             ren_r;

reg   [DATA_WIDTH-1:0    ]      bram_data_in_r;

wire                            bram_wen;
wire                            bram_ren;
reg  [DATA_WIDTH-1:0    ]      bram_data_out;
wire  [DATA_WIDTH-1:0    ]      bram_data_in;
wire  [DATA_WIDTH-1:0    ]      up_to_date_data;
wire                            rw_conflict;
reg                             rw_conflict_r;



reg   [ADDR_WIDTH-1:0    ]      WRITE_ADDRESS_REG_muxed;
reg                            bram_write_en_muxed;
reg  [DATA_WIDTH-1:0    ]      bram_data_in_muxed;

assign write_en   = CE & (RDWEN == 1'b0);
assign read_en    = CE & (RDWEN == 1'b1);


// Intermediate logic for write processing
always @(posedge MEMCLK) begin
   wen_r <= write_en;
   A_r   <= A;
   BW_r  <= BW;
   DIN_r <= DIN;
end

always @(posedge MEMCLK) begin
  ren_r  <= read_en;
end

always @(posedge MEMCLK)
   bram_data_in_r <= bram_data_in;

always @(posedge MEMCLK)
   rw_conflict_r  <= rw_conflict;

always @(posedge MEMCLK)
  DOUT_r  <= DOUT;

assign bram_data_in = (up_to_date_data & ~BW_r) | (DIN_r & BW_r);

// processing of read in case if it just in the next cycle after read to the same address
assign rw_conflict      = wen_r & CE & (A_r == A);                         // read or write to the same address
assign up_to_date_data  = rw_conflict_r ? bram_data_in_r : bram_data_out;  // delay of mem is 1 cycle
assign bram_ren         = (read_en | write_en) & ~rw_conflict;             // do not read in case of a conflict
                                                                        // to make behaviour of a memory robust
assign bram_wen      = wen_r;

assign DOUT          = ren_r ? up_to_date_data : DOUT_r;

// BRAM
reg [DATA_WIDTH-1:0] ram [DEPTH-1:0];
// reg [%d-1:0] bram_data_out;
always @(posedge MEMCLK) begin
  if (bram_write_en_muxed) begin
      ram[WRITE_ADDRESS_REG_muxed] <= bram_data_in_muxed;
  end
  if (bram_ren) begin
    bram_data_out <= ram[A];
  end
end
// END BRAM

 // undefined by default

/* BIST logic for resetting RAM content to 0s on reset*/
localparam INIT_STATE = 1'd0;
localparam DONE_STATE  = 1'd1;

reg [ADDR_WIDTH-1:0] bist_index;
reg [ADDR_WIDTH-1:0] bist_index_next;
reg init_done;
reg init_done_next;

always @ (posedge MEMCLK)
begin
   if (!RESET_N)
   begin
      bist_index <= 0;
      init_done <= 0;
   end
   else
   begin
      bist_index <= bist_index_next;
      init_done <= init_done_next;
   end
end

always @ *
begin
   bist_index_next = init_done ? bist_index : bist_index + 1;
   init_done_next = ((|(~bist_index)) == 0) | init_done;
end

// MUX for BIST
always @ *
begin
   if (!init_done)
   begin
      WRITE_ADDRESS_REG_muxed = bist_index;
      bram_write_en_muxed = 1'b1;
      bram_data_in_muxed = {DATA_WIDTH{1'b0}};
   end
   else
   begin
      WRITE_ADDRESS_REG_muxed = A_r;
      bram_write_en_muxed = bram_wen;
      bram_data_in_muxed = bram_data_in;
   end
end













endmodule
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : synchronizer.v
//  Created On    : 2014-01-31 12:52:57
//  Last Modified : 2018-11-29 17:02:47
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   :
//==================================================================================================





module synchronizer (
    clk,
    presyncdata,
    syncdata
    );

// synopsys template
parameter SIZE = 1;

input wire clk;
input wire [SIZE-1:0] presyncdata;
output reg [SIZE-1:0] syncdata;













  reg [SIZE-1:0] presyncdata_tmp;



    // bw_u1_syncff_4x u_synchronizer_syncff [SIZE-1:0](.q(presyncdata_tmp),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

    // bw_u1_soff_2x u_synchronizer_ff[SIZE-1:0] (.q(syncdata),
    //                  .so(),
    //                  .ck(clk),
    //                  .d(presyncdata_tmp),
    //                  .sd(),
    //                  .se(1'b0)
    //                  );

always @ (posedge clk)
begin
    presyncdata_tmp <= presyncdata;
    syncdata        <= presyncdata_tmp;
end

endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf16x160.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
 ////////////////////////////////////////////////////////////////////////
// 16 X 160 R1 W1 RF macro
// REad/Write ports can be accessed in PH1 only.
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications





























































































































































































































































































































































































module bw_r_rf16x160(/*AUTOARG*/
   // Outputs
   dout, so_w, so_r,
   // Inputs
   din, rd_adr, wr_adr, read_en, wr_en, rst_tri_en, word_wen,
   byte_wen, rd_clk, wr_clk, se, si_r, si_w, reset_l, sehold
   );

   input [159:0]  din; // data input
   input [3:0]    rd_adr;   // read addr
   input [3:0]    wr_adr;  // write addr
   input          read_en;
   input    wr_en;  //   used in conjunction with
        //  word_wen and byte_wen
   input    rst_tri_en ; // gates off writes during SCAN.
   input [3:0]    word_wen; // word enables ( if you don't use these
          // tie them to Vdd )
   input [19:0]   byte_wen; // byte enables ( if you don't use these
                            // tie them to Vdd )
   input          rd_clk;
   input          wr_clk;
   input          se, si_r, si_w ;
   input    reset_l;
   input    sehold; // hold scan in data.

   output [159:0] dout;
   output         so_w;
   output         so_r;

   // Lint
   wire _unused_ok = &{1'b0,
                      se,
                      si_r,
                      si_w,
                      1'b0};

   wire _unused_output = 1'b0;
   assign so_w = _unused_output;
   assign so_r = _unused_output;

   wire [159:0] bit_en; // write-mask
   // reg [159:0] din_d1;
   reg [3:0] rd_adr_d1;
   reg [3:0] rd_adr_d2;
   reg [3:0] wr_adr_d1;
   reg wr_en_d1;
   reg [3:0] word_wen_d1;
   reg [19:0] byte_wen_d1;
   reg read_en_d1;
   reg read_en_d2;

   // memory
   reg [159:0] inq_ary [15:0];

   // read
   assign dout = inq_ary[rd_adr_d1];

   // write
   always @ (posedge wr_clk)
   begin
      if (!reset_l)
      begin
         // assume flops
         inq_ary[00] <= 160'b0;
         inq_ary[01] <= 160'b0;
         inq_ary[02] <= 160'b0;
         inq_ary[03] <= 160'b0;
         inq_ary[04] <= 160'b0;
         inq_ary[05] <= 160'b0;
         inq_ary[06] <= 160'b0;
         inq_ary[07] <= 160'b0;
         inq_ary[08] <= 160'b0;
         inq_ary[09] <= 160'b0;
         inq_ary[10] <= 160'b0;
         inq_ary[11] <= 160'b0;
         inq_ary[12] <= 160'b0;
         inq_ary[13] <= 160'b0;
         inq_ary[14] <= 160'b0;
         inq_ary[15] <= 160'b0;
      end
      else
      begin
         if (wr_en)
         begin
            inq_ary[wr_adr] <= (din & bit_en) | (inq_ary[wr_adr] & ~bit_en);
         end
      end
   end

   // pipeline crap

   always @ (posedge rd_clk)
   begin
      // din_d1 <= din;
      rd_adr_d1 <= rd_adr;
      rd_adr_d2 <= rd_adr_d1;
      wr_adr_d1 <= wr_adr;
      wr_en_d1 <= wr_en;
      word_wen_d1 <= word_wen;
      byte_wen_d1 <= byte_wen;
      read_en_d1 <= read_en;
      read_en_d2 <= read_en_d1;
   end

   assign bit_en[0]  = word_wen[0] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[1]  = word_wen[1] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[2]  = word_wen[2] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[3]  = word_wen[3] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[4]  = word_wen[0] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[5]  = word_wen[1] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[6]  = word_wen[2] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[7]  = word_wen[3] & byte_wen[0] & ~rst_tri_en;
   assign bit_en[8]  = word_wen[0] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[9]  = word_wen[1] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[10] = word_wen[2] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[11] = word_wen[3] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[12] = word_wen[0] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[13] = word_wen[1] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[14] = word_wen[2] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[15] = word_wen[3] & byte_wen[1] & ~rst_tri_en;
   assign bit_en[16] = word_wen[0] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[17] = word_wen[1] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[18] = word_wen[2] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[19] = word_wen[3] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[20] = word_wen[0] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[21] = word_wen[1] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[22] = word_wen[2] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[23] = word_wen[3] & byte_wen[2] & ~rst_tri_en;
   assign bit_en[24] = word_wen[0] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[25] = word_wen[1] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[26] = word_wen[2] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[27] = word_wen[3] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[28] = word_wen[0] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[29] = word_wen[1] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[30] = word_wen[2] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[31] = word_wen[3] & byte_wen[3] & ~rst_tri_en;
   assign bit_en[32] = word_wen[0] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[33] = word_wen[1] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[34] = word_wen[2] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[35] = word_wen[3] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[36] = word_wen[0] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[37] = word_wen[1] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[38] = word_wen[2] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[39] = word_wen[3] & byte_wen[4] & ~rst_tri_en;
   assign bit_en[40] = word_wen[0] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[41] = word_wen[1] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[42] = word_wen[2] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[43] = word_wen[3] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[44] = word_wen[0] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[45] = word_wen[1] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[46] = word_wen[2] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[47] = word_wen[3] & byte_wen[5] & ~rst_tri_en;
   assign bit_en[48] = word_wen[0] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[49] = word_wen[1] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[50] = word_wen[2] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[51] = word_wen[3] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[52] = word_wen[0] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[53] = word_wen[1] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[54] = word_wen[2] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[55] = word_wen[3] & byte_wen[6] & ~rst_tri_en;
   assign bit_en[56] = word_wen[0] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[57] = word_wen[1] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[58] = word_wen[2] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[59] = word_wen[3] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[60] = word_wen[0] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[61] = word_wen[1] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[62] = word_wen[2] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[63] = word_wen[3] & byte_wen[7] & ~rst_tri_en;
   assign bit_en[64] = word_wen[0] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[65] = word_wen[1] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[66] = word_wen[2] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[67] = word_wen[3] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[68] = word_wen[0] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[69] = word_wen[1] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[70] = word_wen[2] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[71] = word_wen[3] & byte_wen[8] & ~rst_tri_en;
   assign bit_en[72] = word_wen[0] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[73] = word_wen[1] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[74] = word_wen[2] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[75] = word_wen[3] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[76] = word_wen[0] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[77] = word_wen[1] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[78] = word_wen[2] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[79] = word_wen[3] & byte_wen[9] & ~rst_tri_en;
   assign bit_en[80] = word_wen[0] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[81] = word_wen[1] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[82] = word_wen[2] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[83] = word_wen[3] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[84] = word_wen[0] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[85] = word_wen[1] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[86] = word_wen[2] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[87] = word_wen[3] & byte_wen[10] & ~rst_tri_en;
   assign bit_en[88] = word_wen[0] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[89] = word_wen[1] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[90] = word_wen[2] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[91] = word_wen[3] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[92] = word_wen[0] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[93] = word_wen[1] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[94] = word_wen[2] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[95] = word_wen[3] & byte_wen[11] & ~rst_tri_en;
   assign bit_en[96] = word_wen[0] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[97] = word_wen[1] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[98] = word_wen[2] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[99] = word_wen[3] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[100] = word_wen[0] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[101] = word_wen[1] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[102] = word_wen[2] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[103] = word_wen[3] & byte_wen[12] & ~rst_tri_en;
   assign bit_en[104] = word_wen[0] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[105] = word_wen[1] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[106] = word_wen[2] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[107] = word_wen[3] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[108] = word_wen[0] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[109] = word_wen[1] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[110] = word_wen[2] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[111] = word_wen[3] & byte_wen[13] & ~rst_tri_en;
   assign bit_en[112] = word_wen[0] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[113] = word_wen[1] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[114] = word_wen[2] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[115] = word_wen[3] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[116] = word_wen[0] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[117] = word_wen[1] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[118] = word_wen[2] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[119] = word_wen[3] & byte_wen[14] & ~rst_tri_en;
   assign bit_en[120] = word_wen[0] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[121] = word_wen[1] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[122] = word_wen[2] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[123] = word_wen[3] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[124] = word_wen[0] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[125] = word_wen[1] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[126] = word_wen[2] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[127] = word_wen[3] & byte_wen[15] & ~rst_tri_en;
   assign bit_en[128] = word_wen[0] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[129] = word_wen[1] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[130] = word_wen[2] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[131] = word_wen[3] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[132] = word_wen[0] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[133] = word_wen[1] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[134] = word_wen[2] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[135] = word_wen[3] & byte_wen[16] & ~rst_tri_en;
   assign bit_en[136] = word_wen[0] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[137] = word_wen[1] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[138] = word_wen[2] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[139] = word_wen[3] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[140] = word_wen[0] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[141] = word_wen[1] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[142] = word_wen[2] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[143] = word_wen[3] & byte_wen[17] & ~rst_tri_en;
   assign bit_en[144] = word_wen[0] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[145] = word_wen[1] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[146] = word_wen[2] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[147] = word_wen[3] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[148] = word_wen[0] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[149] = word_wen[1] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[150] = word_wen[2] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[151] = word_wen[3] & byte_wen[18] & ~rst_tri_en;
   assign bit_en[152] = word_wen[0] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[153] = word_wen[1] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[154] = word_wen[2] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[155] = word_wen[3] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[156] = word_wen[0] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[157] = word_wen[1] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[158] = word_wen[2] & byte_wen[19] & ~rst_tri_en;
   assign bit_en[159] = word_wen[3] & byte_wen[19] & ~rst_tri_en;

endmodule











// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : jtag.vh
//  Created On    : 2014-01-31 12:52:57
//  Last Modified : 2015-01-28 16:54:05
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   : Parallel JTAG/debug controller defines
//==================================================================================================


/////////////////////////////////
// Chip ID in JTAG
/////////////////////////////////







/////////////////////////////////
// JTAG TAP
/////////////////////////////////
// copied from ctu.h








// `define TAP_CREG_ADDR          6'h08
// `define TAP_CREG_WDATA         6'h09
// `define TAP_CREG_RDATA         6'h0a
// `define TAP_CREG_SCRATCH       6'h0b
// `define TAP_IOB_WR             6'h0c
// `define TAP_IOB_RD             6'h0d
// `define TAP_IOB_WADDR          6'h0e
// `define TAP_IOB_WDATA          6'h0f
// `define TAP_IOB_RADDR          6'h10




// `define TAP_CREG_SCRATCH       6'h0b
// `define TAP_IOB_WR             6'h0c
// `define TAP_IOB_RD             6'h0d
// `define TAP_IOB_WADDR          6'h0e
// `define TAP_IOB_WDATA          6'h0f
// `define TAP_IOB_RADDR          6'h10

// `define TAP_MBIST_SERIAL       6'h14
// `define TAP_MBIST_PARALLEL     6'h15
// `define TAP_MBIST_RESULT       6'h16
// `define TAP_MBIST_ABORT        6'h17

// `define TAP_PLL_BYPASS         6'h18

// `define TAP_CLK_STOP_ID        6'h1a
// `define TAP_CLK_SEL            6'h1b  //mask ff00 for ck src

// `define TAP_SSCAN_T0           6'h1c
// `define TAP_SSCAN_T1           6'h1d
// `define TAP_SSCAN_T2           6'h1e
// `define TAP_SSCAN_T3           6'h1f

// `define TAP_SCAN_PARALLEL      6'h20
// `define TAP_SCAN_SERIAL        6'h21
// `define TAP_SCAN_MTEST_LONG    6'h22
// `define TAP_SCAN_MTEST_SHORT   6'h23
// `define TAP_SCAN_BYPASS_EN     6'h24
// `define TAP_SCAN_NSTEP         6'h25
// `define TAP_SCAN_DUMP          6'h26

// `define TAP_EFC_READ           6'h28 
// `define TAP_EFC_BYPASS_DATA    6'h29 
// `define TAP_EFC_BYPASS         6'h2a 
// `define TAP_EFC_READ_MODE      6'h2b 
// `define TAP_EFC_COL_ADDR       6'h2c
// `define TAP_EFC_ROW_ADDR       6'h2d
// `define TAP_EFC_DEST_SAMPLE    6'h2e





/////////////////////////////////
// CTAP register select defines
/////////////////////////////////

// `define CTAP_DATA_REG_WIDTH 64






/////////////////////////////////
// JTAG instructions
/////////////////////////////////

// header


// lengths of header





// definitions of operations
// `define JTAG_REQ_OP_READ_SHADOWSCAN 8'd1

// `define JTAG_REQ_OP_STALL_CORE 8'd3


// `define JTAG_REQ_OP_WRITE_PC 8'd6
// `define JTAG_REQ_OP_WRITE_THREADSTATE 8'd7
// `define JTAG_REQ_OP_CPX_INTERRUPT 8'd8








// definitions of misc field for read/write rtap











// `define JTAG_RTAP_ID__REG 16'd


// definitions of tileids
// `define CTAP_ID_BROADCAST 6'b111111



// mask of header




// misc is used for stall bit at bit 0

// address reg





// masks in address reg




// data reg



// // From CTAP to RTAP
// // these valid vector assumes 4b bus. so 32b vector would be 128b
// `define CTAP_REQ_VEC_WHOLE_PACKET 32'hffffffff
// // header has first 32b
// `define CTAP_REQ_VEC_HEADER 32'h000000ff
// // half is 64b, includes the addresses
// `define CTAP_REQ_VEC_HALF 32'h0000ffff





// RTAP returns






// RTAP states












// ORAM specifics



/////////////////////////////////
// UCB related
/////////////////////////////////




// CTAP_UCB_TILEID_MASK

// RTAP_INSTRUCTION_MASK
// RTAP_INSTRUCTION_RETURN_SHADOWSCAN
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/






















/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//==================================================================================================
//  Filename      : clk_gating_latch.v
//  Created On    : 2015-01-26 14:10:43
//  Last Modified : 2015-01-26 15:13:40
//  Revision      :
//  Author        : Tri Nguyen
//  Company       : Princeton University
//  Email         : trin@princeton.edu
//
//  Description   : Latch for glitchless clock gating
//==================================================================================================

module clk_gating_latch (
    input wire clk,
    input wire clk_en,
    output wire clk_out
);

wire clk_en_sync;
reg clk_en_sync_latch;

assign clk_out = clk & clk_en_sync_latch;

synchronizer sync(
    .clk            (clk),
    .presyncdata    (clk_en),
    .syncdata       (clk_en_sync)
);

// clk_en_sync_latch changes only on the negative duty of the cycle
always @ (clk or clk_en_sync)
    if (~clk) clk_en_sync_latch = clk_en_sync;

endmodule // clk_gating_latch
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/****************************************************************************
 *
 *   FILE: credit_to_valrdy.v
 *
 *   Modified: Yaosheng Fu
 *   Date: May 2 2014

 ***************************************************************************/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

module credit_to_valrdy (
   clk,
   reset,
   //credit based interface	
   data_in,
   valid_in,
   yummy_in,
            
   //val/rdy interface
   data_out,
   valid_out,
   ready_out
);

   input	 clk;
   input	 reset;
   input [64-1:0]	 data_in;
   input	 valid_in;
   input     ready_out;
    
   output	 yummy_in;
   output	 valid_out;
   output [64-1:0] data_out;
   
   wire	 thanksIn;

   wire valid_out_temp;

   assign valid_out = valid_out_temp;

   network_input_blk_multi_out #(.LOG2_NUMBER_FIFO_ELEMENTS(2)) data(
      .clk(clk),
      .reset(reset),
      .data_in(data_in),
      .valid_in(valid_in),

      .thanks_in(valid_out & ready_out),

      .yummy_out(yummy_in),
      .data_val(data_out),
      .data_val1(/*not used*/),
      .data_avail(valid_out_temp));

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: m1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
// 64 bit nor gate with first 32 bits out

module zznor64_32 ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32



////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate

module zzor36 ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
	     | a[32] | a[33] | a[34] | a[35]); 
   
endmodule // zzor36



////////////////////////////////////////////////////////////////////////////////
// 32 bit or gate

module zzor32 ( z, a );
  input  [31:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	     | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	     | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
	     | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

endmodule // zzor32



////////////////////////////////////////////////////////////////////////////////
// 24 bit nor gate

module zznor24 ( z, a );
  input  [23:0] a;
  output        z;

  assign z =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
	      | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]); 

endmodule // zznor24



////////////////////////////////////////////////////////////////////////////////
// 16 bit nor gate

module zznor16 ( z, a );
  input  [15:0] a;
  output        z;

  assign z =  ~(a[0] | a[1] | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
	      | a[8] | a[9] | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]); 

endmodule // zznor16



////////////////////////////////////////////////////////////////////////////////
// 8 bit or gate

module zzor8 ( z, a );
  input  [7:0] a;
  output       z;

  assign z =  (a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7]); 
   
endmodule // zzor8




////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd13 ( rs1_data, rs2_data, cin, adder_out );

  input  [12:0] rs1_data;   // 1st input operand
  input  [12:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [12:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd13



////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc FPU.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out. 

module zzadd56 ( rs1_data, rs2_data, cin, adder_out );

  input  [55:0] rs1_data;   // 1st input operand
  input  [55:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [55:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd56



////////////////////////////////////////////////////////////////////////////////

module zzadd48 ( rs1_data, rs2_data, cin, adder_out );

  input  [47:0] rs1_data;   // 1st input operand
  input  [47:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [47:0] adder_out;  // result of adder

  assign adder_out = rs1_data + rs2_data + cin;

endmodule // zzadd48



////////////////////////////////////////////////////////////////////////////////
//  This adder is primarily used in the multiplier.
//  The cin to out path is optimized.

module zzadd34c ( rs1_data, rs2_data, cin, adder_out );

  input  [33:0] rs1_data;
  input  [33:0] rs2_data;
  input         cin;

  output [33:0] adder_out;

  assign adder_out = rs1_data + rs2_data + cin;


endmodule // zzadd34c



////////////////////////////////////////////////////////////////////////////////

module zzadd32 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [31:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd32



////////////////////////////////////////////////////////////////////////////////

module zzadd18 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [17:0] rs1_data;   // 1st input operand
  input  [17:0] rs2_data;   // 2nd input operand
  input         cin;        // carry in

  output [17:0] adder_out;  // result of adder
  output 	cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd18



////////////////////////////////////////////////////////////////////////////////

module zzadd8 ( rs1_data, rs2_data, cin, adder_out, cout );

  input  [7:0] rs1_data;   // 1st input operand
  input  [7:0] rs2_data;   // 2nd input operand
  input        cin;        // carry in

  output [7:0] adder_out;  // result of add & decrement
  output       cout;       // carry out

  assign {cout, adder_out} = rs1_data + rs2_data + cin;

endmodule // zzadd8



////////////////////////////////////////////////////////////////////////////////
// Special 4-operand 32b adder used in spu_shamd5
//  Description:        This block implements the 4-operand 32-bit adder for SPU
//			It takes four 32-bit operands. It add them together and
//			output the 32-bit results to adder_out. The overflow of
//			32th bit and higher will be ignored.

module zzadd32op4 ( rs1_data, rs2_data, rs3_data, rs4_data, adder_out );

  input  [31:0] rs1_data;   // 1st input operand
  input  [31:0] rs2_data;   // 2nd input operand
  input  [31:0] rs3_data;   // 3rd input operand
  input  [31:0] rs4_data;   // 4th input operand

  output [31:0] adder_out;  // result of add

  assign adder_out = rs1_data + rs2_data + rs3_data + rs4_data;

endmodule // zzadd32op4


////////////////////////////////////////////////////////////////////////////////
//  Description:	This block implements the adder for the sparc alu.
//  			It takes two operands and a carry bit.  It adds them together
//			and sends the output to adder_out.  It outputs the overflow
//			and carry condition codes for both 64 bit and 32 bit operations.

module zzadd64 ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64



///////////////////////////////////////////////////////////////////////
/*
//      Description: This is the ffu VIS adder.  It can do either
//                              2 16 bit adds or 1 32 bit add.
*/

module zzadd32v (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
   a, b, cin, add32
   ) ;
   input [31:0] a;
   input [31:0] b;
   input        cin;
   input        add32;

   output [31:0] z;

   wire          cout15; // carry out from lower 16 bit add
   wire          cin16; // carry in to the upper 16 bit add
   wire          cout31; // carry out from the upper 16 bit add

   assign        cin16 = (add32)? cout15: cin;

   assign      {cout15, z[15:0]} = a[15:0]+b[15:0]+ cin;
   assign      {cout31, z[31:16]} = a[31:16]+b[31:16]+ cin16;

endmodule // zzadd32v




////////////////////////////////////////////////////////////////////////////////
// 64-bit incrementer

module zzinc64 ( in, out );

  input  [63:0] in;

  output [63:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc64


////////////////////////////////////////////////////////////////////////////////
// 48-bit incrementer

module zzinc48 ( in, out, overflow );

  input  [47:0] in;

  output [47:0] out;      // result of increment
  output        overflow; // overflow

  assign out      = in + 1'b1;
  assign overflow = ~in[47] & out[47];

endmodule // zzinc48


////////////////////////////////////////////////////////////////////////////////
// 32-bit incrementer

module zzinc32 ( in, out );

  input  [31:0] in;

  output [31:0] out;   // result of increment

  assign out = in + 1'b1;

endmodule // zzinc32


////////////////////////////////////////////////////////////////////////////////

module zzecc_exu_chkecc2 ( q,ce, ue, ne, d, p, vld );
   input [63:0] d;
   input [7:0]  p;
   input        vld;
   output [6:0] q;
   output       ce,
                ue,
                ne;

   wire       parity;

   assign     ce = vld & parity;

   assign ue = vld & ~parity & (q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);

   assign ne = ~vld | ~(parity | q[6] | q[5] | q[4] | q[3] | q[2] | q[1] | q[0]);


   assign q[0] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10]
               ^ d[11] ^ d[13] ^ d[15] ^ d[17] ^ d[19] ^ d[21] ^ d[23]
               ^ d[25] ^ d[26] ^ d[28] ^ d[30] ^ d[32] ^ d[34] ^ d[36]
               ^ d[38] ^ d[40] ^ d[42] ^ d[44] ^ d[46] ^ d[48] ^ d[50]
               ^ d[52] ^ d[54] ^ d[56] ^ d[57] ^ d[59] ^ d[61] ^ d[63]
               ^ p[0]  ;

   assign q[1] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[10]
               ^ d[12] ^ d[13] ^ d[16] ^ d[17] ^ d[20] ^ d[21] ^ d[24]
               ^ d[25] ^ d[27] ^ d[28] ^ d[31] ^ d[32] ^ d[35] ^ d[36]
               ^ d[39] ^ d[40] ^ d[43] ^ d[44] ^ d[47] ^ d[48] ^ d[51]
               ^ d[52] ^ d[55] ^ d[56] ^ d[58] ^ d[59] ^ d[62] ^ d[63]
               ^ p[1]  ;

   assign q[2] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[29] ^ d[30] ^ d[31] ^ d[32] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[45] ^ d[46] ^ d[47] ^ d[48] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
               ^ p[2]  ;

   assign q[3] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[10]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38]
               ^ d[39] ^ d[40] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[3]  ;

   assign q[4] = d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17]
               ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23] ^ d[24]
               ^ d[25] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[4]  ;

   assign q[5] = d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31] ^ d[32]
               ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
               ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46]
               ^ d[47] ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53]
               ^ d[54] ^ d[55] ^ d[56] ^ p[5]  ;

   assign q[6] = d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63] ^ p[6] ;

   assign parity = d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
                 ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
                 ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
                 ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
                 ^ d[32] ^ d[33] ^ d[34] ^ d[35] ^ d[36] ^ d[37] ^ d[38] ^ d[39]
                 ^ d[40] ^ d[41] ^ d[42] ^ d[43] ^ d[44] ^ d[45] ^ d[46] ^ d[47]
                 ^ d[48] ^ d[49] ^ d[50] ^ d[51] ^ d[52] ^ d[53] ^ d[54] ^ d[55]
                 ^ d[56] ^ d[57] ^ d[58] ^ d[59] ^ d[60] ^ d[61] ^ d[62] ^ d[63]
                 ^ p[0]  ^ p[1]  ^ p[2]  ^ p[3]  ^ p[4]  ^ p[5]  ^ p[6]  ^ p[7];

endmodule // zzecc_exu_chkecc2



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_24b_gen ( din, dout, parity ) ;

// Input Ports
input  [23:0] din ;

// Output Ports
output [23:0] dout ;
output [5:0]  parity ;

wire   [23:0] dout ;
wire   [5:0]  parity ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire          p30 ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |  |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |  |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |  |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |  |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   |   | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |  |  |* |  |* |* |  |  |* |* |  |* |  |  | * |   | * | * |   | * |   |   | * | * |   |   | * |   | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p30 = din[0]  ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5]  ^
             din[7]  ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^
             din[17] ^ din[18] ^ din[21] ^ din[23] ;

assign dout   = din ;
assign parity = {p30, p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////

module zzecc_sctag_30b_cor ( din, parity, dout, corrected_bit ) ;

// Input Ports
input  [23:0] din ;
input  [4:0]  parity ;

// Output Ports
output [23:0] dout ;
output [4:0]  corrected_bit ;

wire   [23:0] dout ;
wire   [4:0]  corrected_bit ;

// Local Reg and Wires
wire          p1 ;
wire          p2 ;
wire          p4 ;
wire          p8 ;
wire          p16 ;
wire [23:0]   error_bit ;


//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//    |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15 |16 |17 |18 |19 |20 |21 |22 |23 |24 |25 |26 |27 |28 |29 |30 |
//    |P1|P2|D0|P4|D1|D2|D3|P8|D4|D5|D6|D7|D8|D9|D10|P16|D11|D12|D13|D14|D15|D16|D17|D18|D19|D20|D21|D22|D23|P30|
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//P1  |* |  |* |  |* |  |* |  |* |  |* |  |* |  | * |   | * |   | * |   | * |   | * |   | * |   | * |   | * |   |
//P2  |  |* |* |  |  |* |* |  |  |* |* |  |  |* | * |   |   | * | * |   |   | * | * |   |   | * | * |   |   |   |
//P4  |  |  |  |* |* |* |* |  |  |  |  |* |* |* | * |   |   |   |   | * | * | * | * |   |   |   |   | * | * |   |
//P8  |  |  |  |  |  |  |  |* |* |* |* |* |* |* | * |   |   |   |   |   |   |   |   | * | * | * | * | * | * |   |
//P16 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |   | * | * | * | * | * | * | * | * | * | * | * | * | * | * |   |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
//p30 |* |* |* |* |* |* |* |* |* |* |* |* |* |* | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * | * |
//----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


assign p1  = parity[0] ^
             din[0]  ^ din[1]  ^ din[3]  ^ din[4]  ^ din[6]  ^ din[8]  ^
             din[10] ^ din[11] ^ din[13] ^ din[15] ^ din[17] ^ din[19] ^
             din[21] ^ din[23] ;

assign p2  = parity[1] ^
             din[0]  ^ din[2]  ^ din[3]  ^ din[5]  ^ din[6]  ^ din[9]  ^
             din[10] ^ din[12] ^ din[13] ^ din[16] ^ din[17] ^ din[20] ^
             din[21] ;

assign p4  = parity[2] ^
             din[1]  ^ din[2]  ^ din[3]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[14] ^ din[15] ^ din[16] ^ din[17] ^ din[22] ^
             din[23] ;

assign p8  = parity[3] ^
             din[4]  ^ din[5]  ^ din[6]  ^ din[7]  ^ din[8]  ^ din[9]  ^
             din[10] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign p16 = parity[4] ^
             din[11] ^ din[12] ^ din[13] ^ din[14] ^ din[15] ^ din[16] ^
             din[17] ^ din[18] ^ din[19] ^ din[20] ^ din[21] ^ din[22] ^
             din[23] ;

assign  error_bit[0]  = !p16 & !p8 & !p4 &  p2 &  p1 ; // 3
assign  error_bit[1]  = !p16 & !p8 &  p4 & !p2 &  p1 ; // 5
assign  error_bit[2]  = !p16 & !p8 &  p4 &  p2 & !p1 ; // 6
assign  error_bit[3]  = !p16 & !p8 &  p4 &  p2 &  p1 ; // 7
assign  error_bit[4]  = !p16 &  p8 & !p4 & !p2 &  p1 ; // 9
assign  error_bit[5]  = !p16 &  p8 & !p4 &  p2 & !p1 ; // 10
assign  error_bit[6]  = !p16 &  p8 & !p4 &  p2 &  p1 ; // 11
assign  error_bit[7]  = !p16 &  p8 &  p4 & !p2 & !p1 ; // 12
assign  error_bit[8]  = !p16 &  p8 &  p4 & !p2 &  p1 ; // 13
assign  error_bit[9]  = !p16 &  p8 &  p4 &  p2 & !p1 ; // 14
assign  error_bit[10] = !p16 &  p8 &  p4 &  p2 &  p1 ; // 15
assign  error_bit[11] =  p16 & !p8 & !p4 & !p2 &  p1 ; // 17
assign  error_bit[12] =  p16 & !p8 & !p4 &  p2 & !p1 ; // 18
assign  error_bit[13] =  p16 & !p8 & !p4 &  p2 &  p1 ; // 19
assign  error_bit[14] =  p16 & !p8 &  p4 & !p2 & !p1 ; // 20
assign  error_bit[15] =  p16 & !p8 &  p4 & !p2 &  p1 ; // 21
assign  error_bit[16] =  p16 & !p8 &  p4 &  p2 & !p1 ; // 22
assign  error_bit[17] =  p16 & !p8 &  p4 &  p2 &  p1 ; // 23
assign  error_bit[18] =  p16 &  p8 & !p4 & !p2 & !p1 ; // 24
assign  error_bit[19] =  p16 &  p8 & !p4 & !p2 &  p1 ; // 25
assign  error_bit[20] =  p16 &  p8 & !p4 &  p2 & !p1 ; // 26
assign  error_bit[21] =  p16 &  p8 & !p4 &  p2 &  p1 ; // 27
assign  error_bit[22] =  p16 &  p8 &  p4 & !p2 & !p1 ; // 28
assign  error_bit[23] =  p16 &  p8 &  p4 & !p2 &  p1 ; // 29

assign  dout          = din ^ error_bit ;
assign  corrected_bit = {p16, p8, p4, p2, p1} ;

endmodule



////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_ecc39
//Function: Error Detection and Correction
//
//

module zzecc_sctag_ecc39 ( dout, cflag, pflag, parity, din);

   //Output: 32bit corrected data
   output[31:0] dout;
   output [5:0] cflag;
   output 	pflag;
   
   //Input: 32bit data din
   input [31:0] din;
   input [6:0]	parity;

   wire 	c0,c1,c2,c3,c4,c5;
   wire [31:0] 	err_bit_pos;

   //refer to the comments in parity_gen_32b.v for the position description
   
   assign c0= parity[0]^(din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   
   assign c1= parity[1]^(din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   
   assign c2= parity[2]^(din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   
   assign c3= parity[3]^(din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   
   assign c4= parity[4]^(din[11]^din[12])^(din[13]^din[14])^
                    (din[15]^din[16])^(din[17]^din[18])^(din[19]^din[20])^
                    (din[21]^din[22])^(din[23]^din[24])^din[25];

   assign c5= parity[5]^(din[26]^din[27])^(din[28]^din[29])^
		    (din[30]^din[31]);

   //generate total parity flag
   assign pflag= c0 ^
		(( (((parity[1]^parity[2])^(parity[3]^parity[4])) ^
		 ((parity[5]^parity[6])^(din[2]^din[5]))) ^		 
		 (((din[7]^din[9])^(din[12]^din[14])) ^
		 ((din[16]^din[18])^(din[20]^din[22]))) ) ^
		 ((din[24]^din[27])^(din[29]^din[31])) );
   
   assign cflag= {c5,c4,c3,c2,c1,c0};
   
   //6 to 32 decoder
   assign err_bit_pos[0] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[1] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[2] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[3] = (c0)&(c1)&(c2)&(~c3)&(~c4)&(~c5);
   assign err_bit_pos[4] = (c0)&(~c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[5] = (~c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[6] = (c0)&(c1)&(~c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[7] = (~c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[8] = (c0)&(~c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[9] = (~c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[10] = (c0)&(c1)&(c2)&(c3)&(~c4)&(~c5);
   assign err_bit_pos[11] = (c0)&(~c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[12] = (~c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[13] = (c0)&(c1)&(~c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[14] = (~c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[15] = (c0)&(~c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[16] = (~c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[17] = (c0)&(c1)&(c2)&(~c3)&(c4)&(~c5);
   assign err_bit_pos[18] = (~c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[19] = (c0)&(~c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[20] = (~c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[21] = (c0)&(c1)&(~c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[22] = (~c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[23] = (c0)&(~c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[24] = (~c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[25] = (c0)&(c1)&(c2)&(c3)&(c4)&(~c5);
   assign err_bit_pos[26] = (c0)&(~c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[27] = (~c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[28] = (c0)&(c1)&(~c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[29] = (~c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[30] = (c0)&(~c1)&(c2)&(~c3)&(~c4)&(c5);
   assign err_bit_pos[31] = (~c0)&(c1)&(c2)&(~c3)&(~c4)&(c5);

   //correct the error bit, it can only correct one error bit.
   
   assign dout = din ^ err_bit_pos;

endmodule // zzecc_sctag_ecc39


////////////////////////////////////////////////////////////////////////////////
//Module Name: zzecc_sctag_pgen_32b
//Function: Generate 7 parity bits for 32bits input data
//

module zzecc_sctag_pgen_32b ( dout, parity, din);

   //Output: 32bit dout and 7bit parity bit
   output[31:0] dout;
   output [6:0] parity;

   //Input: 32bit data din
   input [31:0] din;

   //input data passing through this module
   assign dout = din ;

   //generate parity bits based on the hamming codes
   //the method to generate parity bit is shown as follows
   //1   2  3  4  5  6  7  8  9 10 11 12 13 14  15  16  17  18  19
   //P1 P2 d0 P4 d1 d2 d3 P8 d4 d5 d6 d7 d8 d9 d10 P16 d11 d12 d13 
   //
   // 20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35 
   //d14 d15 d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 P32 d26 d27 d28
   //
   // 36  37  38       
   //d29 d30 d31
   //For binary numbers B1-B2-B3-B4-B5-B6:
   //B1=1 for (1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,...)
   //B2=1 for (2,3,6,7,10,11,14,15,18,19,22,23,26,27,30,31,34,35,38,39...)
   //B3=1 for (4,5,6,7,12,13,14,15,20,21,22,23,28,29,30,31,36,37,38,39....)
   //B4=1 for (8,9,10,11,12,13,14,15,24,25,26,27,28,29,30,31,40,41,42,....)
   //B5=1 for (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,48,49,...)
   //B6=1 for (32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49...)
   //Parity bit P1,P2,P4,P8,P16,P32 can be generated from the above group of
   //bits B1=1,B2=1,B3=1,B4=1,B5=1,B6=1 respectively.

   //use parity[5:0] to stand for P1,P2,P4,P8,P16,P32
   assign parity[0] = (din[0]^din[1])^(din[3]^din[4])^(din[6]^din[8])
                     ^(din[10]^din[11])^(din[13]^din[15])^(din[17]^din[19])
		     ^(din[21]^din[23])^(din[25]^din[26])^(din[28]^din[30]);
   //
   assign parity[1] = (din[0]^din[2])^(din[3]^din[5])^(din[6]^din[9])
                     ^(din[10]^din[12])^(din[13]^din[16])^(din[17]^din[20])
		     ^(din[21]^din[24])^(din[25]^din[27])^(din[28]^din[31]);
   //
   assign parity[2] = (din[1]^din[2])^(din[3]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[14])^(din[15]^din[16])^(din[17]^din[22])
		     ^(din[23]^din[24])^(din[25]^din[29])^(din[30]^din[31]);
   //
   assign parity[3] = (din[4]^din[5])^(din[6]^din[7])^(din[8]^din[9])
                     ^(din[10]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[4] = (din[11]^din[12])^(din[13]^din[14])^(din[15]^din[16])
                     ^(din[17]^din[18])^(din[19]^din[20])^(din[21]^din[22])
		     ^(din[23]^din[24])^din[25];
   //
   assign parity[5] = (din[26]^din[27])^(din[28]^din[29])^(din[30]^din[31]);

   //the last parity bit is the xor of all 38bits
   //assign parity[6] = (^din)^(^parity[5:0]);
   //it can be further simplified as:
   //din= d0  d1  d2  d3  d4  d5  d6  d7  d8  d9 d10 d11 d12 d13 d14 d15 
   //p0 =  x   x       x   x       x       x       x   x       x       x
   //p1 =  x       x   x       x   x           x   x       x   x
   //p2 =      x   x   x               x   x   x   x               x   x
   //p3 =                  x   x   x   x   x   x   x  
   //p4 =                                              x   x   x   x   x
   //p5 =
   //-------------------------------------------------------------------
   //Total 3   3   3   4   3   3   4   3   4   4   5   3   3   4   3   4 
   //
   //din=d16 d17 d18 d19 d20 d21 d22 d23 d24 d25 d26 d27 d28 d29 d30 d31 
   //p0=       x       x       x       x       x   x       x       x    
   //p1=   x   x           x   x           x   x       x   x           x
   //p2=   x   x                   x   x   x   x               x   x   x
   //p3=           x   x   x   x   x   x   x   x
   //p4=   x   x   x   x   x   x   x   x   x   x
   //p5=                                           x   x   x   x   x   x
   //-------------------------------------------------------------------
   //total 4   5   3   4   4   5   4   5   5   6   3   3   4   3   4   4

   //so total=even number, the corresponding bit will not show up in the
   //final xor tree.
   assign parity[6] =  din[0] ^ din[1]  ^ din[2]  ^ din[4]  ^ din[5] ^ din[7]
		    ^ din[10] ^ din[11] ^ din[12] ^ din[14] ^ din[17]
		    ^ din[18] ^ din[21] ^ din[23] ^ din[24] ^ din[26]
		    ^ din[27] ^ din[29];
   
endmodule // zzecc_sctag_pgen_32b

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree

module zzpar34 ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
	      ^ d[32] ^ d[33]; 

endmodule // zzpar34



////////////////////////////////////////////////////////////////////////////////
// 32 bit parity tree

module zzpar32 ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]; 

endmodule // zzpar32



////////////////////////////////////////////////////////////////////////////////
// 28 bit parity tree

module zzpar28 ( z, d );
   input  [27:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	      ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
	      ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
	      ^ d[24] ^ d[25] ^ d[26] ^ d[27]; 

endmodule // zzpar28



////////////////////////////////////////////////////////////////////////////////
// 16 bit parity tree

module zzpar16 ( z, d );
   input  [15:0] d;
   output        z;

   assign z = d[0] ^ d[1] ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
	    ^ d[8] ^ d[9] ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]; 
   
endmodule // zzpar16



////////////////////////////////////////////////////////////////////////////////
// 8 bit parity tree

module zzpar8 ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8



////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority

module zzpenc64 (/*AUTOARG*/
   // Outputs
   z, 
   // Inputs
  a 
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64

////////////////////////////////////////////////////////////////////////////////
//    4-bit 60x buffers

module zzbufh_60x4 (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [3:0] a;
   output [3:0] z;

   assign z = a;

endmodule //zzbufh_60x4

// LVT modules added below

module zzadd64_lv ( rs1_data, rs2_data, cin, adder_out, cout32, cout64 );

   input [63:0]  rs1_data;   // 1st input operand
   input [63:0]  rs2_data;   // 2nd input operand
   input         cin;        // carry in

   output [63:0] adder_out;  // result of adder
   output        cout32;     // carry out from lower 32 bit add
   output        cout64;     // carry out from 64 bit add

   assign {cout32, adder_out[31:0]}  = rs1_data[31:0]  + rs2_data[31:0]  + cin;
   assign {cout64, adder_out[63:32]} = rs1_data[63:32] + rs2_data[63:32] + cout32;

endmodule // zzadd64_lv

module zzpar8_lv ( z, d );
   input  [7:0] d;
   output       z;

   assign  z =  d[0] ^ d[1] ^ d[2] ^ d[3] ^ d[4] ^ d[5] ^ d[6] ^ d[7]; 

endmodule // zzpar8_lv


module zzpar32_lv ( z, d );
   input  [31:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31];

endmodule // zzpar32_lv



module zznor64_32_lv ( znor64, znor32, a );
  input  [63:0] a;
  output        znor64;
  output        znor32;

  assign znor32 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]); 

  assign znor64 =  ~(a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
		   | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
		   | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
		   | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31] 
		   | a[32] | a[33] | a[34] | a[35] | a[36] | a[37] | a[38] | a[39] 
		   | a[40] | a[41] | a[42] | a[43] | a[44] | a[45] | a[46] | a[47] 
		   | a[48] | a[49] | a[50] | a[51] | a[52] | a[53] | a[54] | a[55] 
		   | a[56] | a[57] | a[58] | a[59] | a[60] | a[61] | a[62] | a[63]);

endmodule // zznor64_32_lv

////////////////////////////////////////////////////////////////////////////////
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority
//    LVT version

module zzpenc64_lv (/*AUTOARG*/
   // Outputs
   z,
   // Inputs
  a
   );

   input [63:0] a;
   output [5:0] z;

   integer      i;
   reg  [5:0]   z;

     always @ (a)
     begin
          z = 6'b0;
          for (i=0;i<64;i=i+1)
               if (a[i])
                      z = i;
     end

endmodule // zzpenc64_lv

////////////////////////////////////////////////////////////////////////////////
// 36 bit or gate
// LVT version

module zzor36_lv ( z, a );
  input  [35:0] a;
  output        z;

  assign z =  (a[0]  | a[1]  | a[2]  | a[3]  | a[4]  | a[5]  | a[6]  | a[7]
             | a[8]  | a[9]  | a[10] | a[11] | a[12] | a[13] | a[14] | a[15]
             | a[16] | a[17] | a[18] | a[19] | a[20] | a[21] | a[22] | a[23]
             | a[24] | a[25] | a[26] | a[27] | a[28] | a[29] | a[30] | a[31]
             | a[32] | a[33] | a[34] | a[35]);

endmodule // zzor36_lv

////////////////////////////////////////////////////////////////////////////////
// 34 bit parity tree
// LVT version

module zzpar34_lv ( z, d );
   input  [33:0] d;
   output        z;

   assign  z =  d[0]  ^ d[1]  ^ d[2]  ^ d[3]  ^ d[4]  ^ d[5]  ^ d[6]  ^ d[7]
              ^ d[8]  ^ d[9]  ^ d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15]
              ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[21] ^ d[22] ^ d[23]
              ^ d[24] ^ d[25] ^ d[26] ^ d[27] ^ d[28] ^ d[29] ^ d[30] ^ d[31]
              ^ d[32] ^ d[33];

endmodule // zzpar34_lv


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: mul64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
/*//////////////////////////////////////////////////////////////////////
//
//  Module Name: mul64
//  Description:        *This block implements the multiplier used in the modular multiplier
//                       unit (MUL) and be shared by sparc EXU and the streaming unit (SPU).
//                       It is also used as the 54x54 multiplier in the FPU.
//                      *It takes two 64-bit unsign data and accumulated operand and do the
//                       64x64 MAC operation at two cycle thruput and 5 cycle latency.
//                      *The mul_valid signal indicate the beginning of a new operation.
//                       It MUST be dis-asserted at the next cycle to have the proper 2-cycle
//                       latency operation in the csa array. If there are two back-to-back
//                       cycle operation, the first operation result will be incorrect.
//                      *Results are avaliable on the 5th cycle of the mul_valid as shows
//
//			*Following inputs should tie to "0" when used as a 64x64 multiplier
//			 - areg 
//			 - accreg 
//			 - x2
//
//                         Cycle-0  | Cycle-1 | Cycle-2 | Cycle-3 | Cycle-4 | Cycle-5
//                       1st        *         |         |         |         |
//                       rs1, rs2   ^         |         |         |         | 1st results
//                       valid=1    | valid=0 |         *         |         | avaliable
//                                1st         | 2nd OP  ^         |         |
//                                setup       | valid=1 |         |         |
//                                            |        2nd        |         |
//                                            |       setup       |         |
//
*/

//PITON_PROTO enables all FPGA related modifications



























































module mul64 (rs1_l, rs2, valid, areg, accreg, x2, out, rclk, si, so, se, mul_rst_l, mul_step);

input  [63:0]  	rs1_l;			// op1
input  [63:0]  	rs2;			// op2
input	       	valid;			// begin of the MUL operation
input  [96:0]  	areg;			// accumulated input for ACCUM
input  [135:129] accreg;		// direct input from ACCUM [135:129]
input	       	x2;			// for op1*op2*2
input	       	rclk, si, se, mul_rst_l, mul_step;
output  	so;
output [135:0] 	out;

wire	       	cyc1, cyc2, cyc3;	// cycle stage of MUL
wire [2:0]	b0, b1, b2,  b3,  b4,  b5,  b6,  b7;
wire [2:0]	b8, b9, b10, b11, b12, b13, b14, b15;
wire	    	b16;
wire [63:0]	op1_l, op1;
wire [81:0]	a0sum, a1sum, a0s, a1s; 
wire [81:4]	a0cout, a1cout, a0c, a1c;
wire		pcoutx2, psumx2;
wire 		x2_c1, x2_c2, x2_c3, x2_c2c3;

wire [98:0]	psum, pcout;
wire [98:30]	pcout_in, pc;
wire [98:31]	psum_in, ps;
wire [96:0]	ary2_cout, addin_cout;
wire [97:0]	ary2_sum,  addin_sum ;
wire		add_cin, addin_cin, add_co31, add_co96;
wire [103:0]	addout;
wire		clk_enb0, clk_enb1;
wire 		rst;
wire		clk;
wire		tm_l;

  assign clk = rclk;
  assign rst = ~mul_rst_l; 
  assign tm_l = ~se;

  clken_buf	ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));

  /////////////////////////////////////////////////////////////////////
  // 	States count
  /////////////////////////////////////////////////////////////////////
  dffr_s  cyc1_dff(.din(valid), .clk(clk_enb0), .q(cyc1), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc2_dff(.din(cyc1),  .clk(clk_enb0), .q(cyc2), .rst(rst), .se(se), .si(), .so());
  dffr_s  cyc3_dff(.din(cyc2),  .clk(clk_enb0), .q(cyc3), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c1_dff(.din(x2),    .clk(clk_enb0), .q(x2_c1), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c2_dff(.din(x2_c1), .clk(clk_enb0), .q(x2_c2), .rst(rst), .se(se), .si(), .so());
  dffr_s  x2c3_dff(.din(x2_c2), .clk(clk_enb0), .q(x2_c3), .rst(rst), .se(se), .si(), .so());

  assign x2_c2c3 =  x2_c2 | x2_c3 ;
	
  /////////////////////////////////////////////////////////////////////
  // 	Enable flops for op1
  /////////////////////////////////////////////////////////////////////
  clken_buf	ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(valid & mul_step)), .tmb_l(tm_l));
  dff_s #(64)  	ffrs1  (.din(rs1_l[63:0]), .clk(clk_enb1), .q(op1_l[63:0]),
			.se(se), .si(), .so());




  assign op1[63:0] = ~op1_l[63:0];

  mul_booth	 booth (.head (valid),
			.b_in (rs2),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (b8),
			.b9   (b9),
			.b10  (b10),
			.b11  (b11),
			.b12  (b12),
			.b13  (b13),
			.b14  (b14),
			.b15  (b15),
			.b16  (b16),
			.clk  (clk), .se(se), .si(), .so(), .mul_step(mul_step), .tm_l(tm_l));
			
  /////////////////////////////////////////////////////////////////////
  // 	Two Array1 inst ary1_a0 & ary1_a1 with the ouput flops 
  /////////////////////////////////////////////////////////////////////
  mul_array1	ary1_a0(.cout (a0cout[81:4]),
			.sum  (a0sum[81:0]),
			.a    (op1),
			.b0   (b0),
			.b1   (b1),
			.b2   (b2),
			.b3   (b3),
			.b4   (b4),
			.b5   (b5),
			.b6   (b6),
			.b7   (b7),
			.b8   (3'b000),
			.head (cyc1),
			.bot  (1'b0)); //array a is never at the bottom of 33-pp rows
 
  dff_s #(78)  a0cot_dff (.din(a0cout[81:4]), .clk(clk_enb0), .q(a0c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a0sum_dff (.din(a0sum[81:0]), .clk(clk_enb0), .q(a0s[81:0]),
			.se(se), .si(), .so());

  mul_array1	ary1_a1(.cout (a1cout[81:4]),
			.sum  (a1sum[81:0]),
			.a    (op1),
			.b0   (b8),
			.b1   (b9),
			.b2   (b10),
			.b3   (b11),
			.b4   (b12),
			.b5   (b13),
			.b6   (b14),
			.b7   (b15),
			.b8   ({1'b0,b16,1'b0}),
			.head (1'b0),	//array b is never at the head of 33-pp rows
			.bot  (cyc2)); 

  dff_s #(78)  a1cot_dff (.din(a1cout[81:4]), .clk(clk_enb0), .q(a1c[81:4]),
			.se(se), .si(), .so());
  dff_s #(82)  a1sum_dff (.din(a1sum[81:0]), .clk(clk_enb0), .q(a1s[81:0]),
			.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Array2 with the reorder output mux-flops
  /////////////////////////////////////////////////////////////////////
  mul_array2 	 array2(.pcoutx2 (pcoutx2),
			.psumx2  (psumx2),
			.pcout 	 (pcout[98:0]),
			.psum    (psum[98:0]), 
			.a0c     (a0c[81:4]),
			.a0s     (a0s[81:0]),
			.a1c     (a1c[81:4]),
			.a1s     (a1s[81:0]),
			.pc	 (pc[98:30]),
			.ps	 (ps[98:31]),
			.areg    (areg[96:0]),
			.bot     (cyc3),
			.x2      (x2_c2c3));
 
  //// Outpput re-order muxes and flops	////
  dp_mux2es #(97)  ary2_cmux (.dout(ary2_cout[96:0]),
                              .in0(pcout[96:0]),
                              .in1({pcout[95:0],pcoutx2}),
                              .sel(x2_c2c3));
  dff_s #(97)  a2cot_dff (.din(ary2_cout[96:0]), .clk(clk_enb0), .q(addin_cout[96:0]), 
              		.se(se), .si(), .so());

  dp_mux2es #(98) ary2_smux (.dout(ary2_sum[97:0]),
                             .in0(psum[97:0]),
                             .in1({psum[96:0],psumx2}),
                             .sel(x2_c2c3));
  dff_s #(98)  a2sum_dff (.din(ary2_sum[97:0]), .clk(clk_enb0), .q(addin_sum[97:0]), 
			.se(se), .si(), .so());

  //// Pseudo sum & cout logic and flops ////
  assign psum_in[98:32]  = psum[98:32] & {67{cyc2}} ;
  assign psum_in[31]     = psum[31] & x2_c2 ;

  assign pcout_in[98:31] = pcout[98:31] & {68{cyc2}} ;
  assign pcout_in[30]    = pcout[30] & x2_c2 ;
  
  dff_s #(68)  psum_dff  (.din(psum_in[98:31]), .clk(clk_enb0), .q(ps[98:31]),
                	.se(se), .si(), .so());
  dff_s #(69)  pcout_dff (.din(pcout_in[98:30]), .clk(clk_enb0), .q(pc[98:30]),
            		.se(se), .si(), .so());

  /////////////////////////////////////////////////////////////////////
  // 	Adder (104-bit) 
  /////////////////////////////////////////////////////////////////////

  assign 	add_cin = add_co31 & cyc3 ;

  assign {add_co31,addout[31:0]} =   {{1'b0},addin_sum[31:0]} 
		     		   + {{1'b0},addin_cout[30:0],addin_cin} ;


  assign {add_co96,addout[96:32]} =  addin_sum[97:32]	
				  + addin_cout[96:31]
				  + {{65'b0},add_co31} ;

  assign 	addout[103:97] =  accreg[135:129] + {{6'b0},add_co96} ;

  /////////////////////////////////////////////////////////////////////
  // 	Pipe adder outputs  
  /////////////////////////////////////////////////////////////////////

  dff_s  	      co31_dff (.din(add_cin), .clk(clk_enb0), .q(addin_cin),
       			.se(se), .si(), .so());

  dff_s #(104)   out_dff (.din(addout[103:0]), .clk(clk_enb0), .q(out[135:32]),
              		.se(se), .si(), .so());

  dff_s #(32)    pip_dff (.din(out[63:32]), .clk(clk_enb0), .q(out[31:0]),
               		.se(se), .si(), .so());

endmodule // mul64




////////////////////////////////////////////////////////////////////////
//	Sub-moudle for mul64
////////////////////////////////////////////////////////////////////////

module mul_array1 ( cout, sum, a, b0, b1, b2, b3, b4, b5, b6, b7, b8,
     bot, head );

input  bot, head;
output [81:4]  cout;
output [81:0]  sum;
input [2:0]  b6;
input [2:0]  b3;
input [2:0]  b8;
input [2:0]  b2;
input [2:0]  b1;
input [2:0]  b7;
input [63:0]  a;
input [2:0]  b0;
input [2:0]  b4;
input [2:0]  b5;

// Buses in the design

wire  [1:0]  b5n;
wire  [1:0]  b2n;
wire  [68:1]  c0;
wire  [69:0]  s1;
wire  [68:1]  c1;
wire  [69:0]  s2;
wire  [68:1]  c2;
wire  [70:4]  s_1;
wire  [69:2]  s0;
wire  [76:10]  s_2;
wire  [70:2]  c_1;
wire  [76:10]  c_2;
wire  [75:11]  co;

mul_negen p1n ( .b(b5[2:0]), .n1(b5n[1]), .n0(b5n[0]));
mul_negen p0n ( .b(b2[2:0]), .n1(b2n[1]), .n0(b2n[0]));
mul_csa42  sc3_71_ ( .c(s_2[71]), .cin(co[70]), .a(c_1[70]),
     .b(c_2[70]), .cout(co[71]), .sum(sum[71]), .d(s1[65]),
     .carry(cout[71]));
mul_csa42  sc3_75_ ( .c(s_2[75]), .cin(co[74]), .a(1'b0),
     .b(c_2[74]), .cout(co[75]), .sum(sum[75]), .d(s1[69]),
     .carry(cout[75]));
mul_csa42  sc3_74_ ( .c(s_2[74]), .cin(co[73]), .a(1'b0),
     .b(c_2[73]), .cout(co[74]), .sum(sum[74]), .d(s1[68]),
     .carry(cout[74]));
mul_csa42  sc3_73_ ( .c(s_2[73]), .cin(co[72]), .a(1'b0),
     .b(c_2[72]), .cout(co[73]), .sum(sum[73]), .d(s1[67]),
     .carry(cout[73]));
mul_csa42  sc3_72_ ( .c(s_2[72]), .cin(co[71]), .a(1'b0),
     .b(c_2[71]), .cout(co[72]), .sum(sum[72]), .d(s1[66]),
     .carry(cout[72]));
mul_csa42  sc3_76_ ( .c(s_2[76]), .cin(co[75]), .a(1'b0),
     .b(c_2[75]), .cout(), .sum(sum[76]), .d(1'b0),
     .carry(cout[76]));
mul_csa42  sc3_70_ ( .c(s_2[70]), .cin(co[69]), .a(c_1[69]),
     .b(c_2[69]), .cout(co[70]), .sum(sum[70]), .d(s_1[70]),
     .carry(cout[70]));
mul_csa42  sc3_69_ ( .c(s_2[69]), .cin(co[68]), .a(c_1[68]),
     .b(c_2[68]), .cout(co[69]), .sum(sum[69]), .d(s_1[69]),
     .carry(cout[69]));
mul_csa42  sc3_68_ ( .c(s_2[68]), .cin(co[67]), .a(c_1[67]),
     .b(c_2[67]), .cout(co[68]), .sum(sum[68]), .d(s_1[68]),
     .carry(cout[68]));
mul_csa42  sc3_67_ ( .c(s_2[67]), .cin(co[66]), .a(c_1[66]),
     .b(c_2[66]), .cout(co[67]), .sum(sum[67]), .d(s_1[67]),
     .carry(cout[67]));
mul_csa42  sc3_66_ ( .c(s_2[66]), .cin(co[65]), .a(c_1[65]),
     .b(c_2[65]), .cout(co[66]), .sum(sum[66]), .d(s_1[66]),
     .carry(cout[66]));
mul_csa42  sc3_65_ ( .c(s_2[65]), .cin(co[64]), .a(c_1[64]),
     .b(c_2[64]), .cout(co[65]), .sum(sum[65]), .d(s_1[65]),
     .carry(cout[65]));
mul_csa42  sc3_64_ ( .c(s_2[64]), .cin(co[63]), .a(c_1[63]),
     .b(c_2[63]), .cout(co[64]), .sum(sum[64]), .d(s_1[64]),
     .carry(cout[64]));
mul_csa42  sc3_63_ ( .c(s_2[63]), .cin(co[62]), .a(c_1[62]),
     .b(c_2[62]), .cout(co[63]), .sum(sum[63]), .d(s_1[63]),
     .carry(cout[63]));
mul_csa42  sc3_62_ ( .c(s_2[62]), .cin(co[61]), .a(c_1[61]),
     .b(c_2[61]), .cout(co[62]), .sum(sum[62]), .d(s_1[62]),
     .carry(cout[62]));
mul_csa42  sc3_61_ ( .c(s_2[61]), .cin(co[60]), .a(c_1[60]),
     .b(c_2[60]), .cout(co[61]), .sum(sum[61]), .d(s_1[61]),
     .carry(cout[61]));
mul_csa42  sc3_60_ ( .c(s_2[60]), .cin(co[59]), .a(c_1[59]),
     .b(c_2[59]), .cout(co[60]), .sum(sum[60]), .d(s_1[60]),
     .carry(cout[60]));
mul_csa42  sc3_59_ ( .c(s_2[59]), .cin(co[58]), .a(c_1[58]),
     .b(c_2[58]), .cout(co[59]), .sum(sum[59]), .d(s_1[59]),
     .carry(cout[59]));
mul_csa42  sc3_58_ ( .c(s_2[58]), .cin(co[57]), .a(c_1[57]),
     .b(c_2[57]), .cout(co[58]), .sum(sum[58]), .d(s_1[58]),
     .carry(cout[58]));
mul_csa42  sc3_57_ ( .c(s_2[57]), .cin(co[56]), .a(c_1[56]),
     .b(c_2[56]), .cout(co[57]), .sum(sum[57]), .d(s_1[57]),
     .carry(cout[57]));
mul_csa42  sc3_56_ ( .c(s_2[56]), .cin(co[55]), .a(c_1[55]),
     .b(c_2[55]), .cout(co[56]), .sum(sum[56]), .d(s_1[56]),
     .carry(cout[56]));
mul_csa42  sc3_55_ ( .c(s_2[55]), .cin(co[54]), .a(c_1[54]),
     .b(c_2[54]), .cout(co[55]), .sum(sum[55]), .d(s_1[55]),
     .carry(cout[55]));
mul_csa42  sc3_54_ ( .c(s_2[54]), .cin(co[53]), .a(c_1[53]),
     .b(c_2[53]), .cout(co[54]), .sum(sum[54]), .d(s_1[54]),
     .carry(cout[54]));
mul_csa42  sc3_53_ ( .c(s_2[53]), .cin(co[52]), .a(c_1[52]),
     .b(c_2[52]), .cout(co[53]), .sum(sum[53]), .d(s_1[53]),
     .carry(cout[53]));
mul_csa42  sc3_52_ ( .c(s_2[52]), .cin(co[51]), .a(c_1[51]),
     .b(c_2[51]), .cout(co[52]), .sum(sum[52]), .d(s_1[52]),
     .carry(cout[52]));
mul_csa42  sc3_51_ ( .c(s_2[51]), .cin(co[50]), .a(c_1[50]),
     .b(c_2[50]), .cout(co[51]), .sum(sum[51]), .d(s_1[51]),
     .carry(cout[51]));
mul_csa42  sc3_50_ ( .c(s_2[50]), .cin(co[49]), .a(c_1[49]),
     .b(c_2[49]), .cout(co[50]), .sum(sum[50]), .d(s_1[50]),
     .carry(cout[50]));
mul_csa42  sc3_49_ ( .c(s_2[49]), .cin(co[48]), .a(c_1[48]),
     .b(c_2[48]), .cout(co[49]), .sum(sum[49]), .d(s_1[49]),
     .carry(cout[49]));
mul_csa42  sc3_48_ ( .c(s_2[48]), .cin(co[47]), .a(c_1[47]),
     .b(c_2[47]), .cout(co[48]), .sum(sum[48]), .d(s_1[48]),
     .carry(cout[48]));
mul_csa42  sc3_47_ ( .c(s_2[47]), .cin(co[46]), .a(c_1[46]),
     .b(c_2[46]), .cout(co[47]), .sum(sum[47]), .d(s_1[47]),
     .carry(cout[47]));
mul_csa42  sc3_46_ ( .c(s_2[46]), .cin(co[45]), .a(c_1[45]),
     .b(c_2[45]), .cout(co[46]), .sum(sum[46]), .d(s_1[46]),
     .carry(cout[46]));
mul_csa42  sc3_45_ ( .c(s_2[45]), .cin(co[44]), .a(c_1[44]),
     .b(c_2[44]), .cout(co[45]), .sum(sum[45]), .d(s_1[45]),
     .carry(cout[45]));
mul_csa42  sc3_44_ ( .c(s_2[44]), .cin(co[43]), .a(c_1[43]),
     .b(c_2[43]), .cout(co[44]), .sum(sum[44]), .d(s_1[44]),
     .carry(cout[44]));
mul_csa42  sc3_43_ ( .c(s_2[43]), .cin(co[42]), .a(c_1[42]),
     .b(c_2[42]), .cout(co[43]), .sum(sum[43]), .d(s_1[43]),
     .carry(cout[43]));
mul_csa42  sc3_42_ ( .c(s_2[42]), .cin(co[41]), .a(c_1[41]),
     .b(c_2[41]), .cout(co[42]), .sum(sum[42]), .d(s_1[42]),
     .carry(cout[42]));
mul_csa42  sc3_41_ ( .c(s_2[41]), .cin(co[40]), .a(c_1[40]),
     .b(c_2[40]), .cout(co[41]), .sum(sum[41]), .d(s_1[41]),
     .carry(cout[41]));
mul_csa42  sc3_40_ ( .c(s_2[40]), .cin(co[39]), .a(c_1[39]),
     .b(c_2[39]), .cout(co[40]), .sum(sum[40]), .d(s_1[40]),
     .carry(cout[40]));
mul_csa42  sc3_39_ ( .c(s_2[39]), .cin(co[38]), .a(c_1[38]),
     .b(c_2[38]), .cout(co[39]), .sum(sum[39]), .d(s_1[39]),
     .carry(cout[39]));
mul_csa42  sc3_38_ ( .c(s_2[38]), .cin(co[37]), .a(c_1[37]),
     .b(c_2[37]), .cout(co[38]), .sum(sum[38]), .d(s_1[38]),
     .carry(cout[38]));
mul_csa42  sc3_37_ ( .c(s_2[37]), .cin(co[36]), .a(c_1[36]),
     .b(c_2[36]), .cout(co[37]), .sum(sum[37]), .d(s_1[37]),
     .carry(cout[37]));
mul_csa42  sc3_36_ ( .c(s_2[36]), .cin(co[35]), .a(c_1[35]),
     .b(c_2[35]), .cout(co[36]), .sum(sum[36]), .d(s_1[36]),
     .carry(cout[36]));
mul_csa42  sc3_35_ ( .c(s_2[35]), .cin(co[34]), .a(c_1[34]),
     .b(c_2[34]), .cout(co[35]), .sum(sum[35]), .d(s_1[35]),
     .carry(cout[35]));
mul_csa42  sc3_34_ ( .c(s_2[34]), .cin(co[33]), .a(c_1[33]),
     .b(c_2[33]), .cout(co[34]), .sum(sum[34]), .d(s_1[34]),
     .carry(cout[34]));
mul_csa42  sc3_33_ ( .c(s_2[33]), .cin(co[32]), .a(c_1[32]),
     .b(c_2[32]), .cout(co[33]), .sum(sum[33]), .d(s_1[33]),
     .carry(cout[33]));
mul_csa42  sc3_32_ ( .c(s_2[32]), .cin(co[31]), .a(c_1[31]),
     .b(c_2[31]), .cout(co[32]), .sum(sum[32]), .d(s_1[32]),
     .carry(cout[32]));
mul_csa42  sc3_31_ ( .c(s_2[31]), .cin(co[30]), .a(c_1[30]),
     .b(c_2[30]), .cout(co[31]), .sum(sum[31]), .d(s_1[31]),
     .carry(cout[31]));
mul_csa42  sc3_30_ ( .c(s_2[30]), .cin(co[29]), .a(c_1[29]),
     .b(c_2[29]), .cout(co[30]), .sum(sum[30]), .d(s_1[30]),
     .carry(cout[30]));
mul_csa42  sc3_29_ ( .c(s_2[29]), .cin(co[28]), .a(c_1[28]),
     .b(c_2[28]), .cout(co[29]), .sum(sum[29]), .d(s_1[29]),
     .carry(cout[29]));
mul_csa42  sc3_28_ ( .c(s_2[28]), .cin(co[27]), .a(c_1[27]),
     .b(c_2[27]), .cout(co[28]), .sum(sum[28]), .d(s_1[28]),
     .carry(cout[28]));
mul_csa42  sc3_27_ ( .c(s_2[27]), .cin(co[26]), .a(c_1[26]),
     .b(c_2[26]), .cout(co[27]), .sum(sum[27]), .d(s_1[27]),
     .carry(cout[27]));
mul_csa42  sc3_26_ ( .c(s_2[26]), .cin(co[25]), .a(c_1[25]),
     .b(c_2[25]), .cout(co[26]), .sum(sum[26]), .d(s_1[26]),
     .carry(cout[26]));
mul_csa42  sc3_25_ ( .c(s_2[25]), .cin(co[24]), .a(c_1[24]),
     .b(c_2[24]), .cout(co[25]), .sum(sum[25]), .d(s_1[25]),
     .carry(cout[25]));
mul_csa42  sc3_24_ ( .c(s_2[24]), .cin(co[23]), .a(c_1[23]),
     .b(c_2[23]), .cout(co[24]), .sum(sum[24]), .d(s_1[24]),
     .carry(cout[24]));
mul_csa42  sc3_23_ ( .c(s_2[23]), .cin(co[22]), .a(c_1[22]),
     .b(c_2[22]), .cout(co[23]), .sum(sum[23]), .d(s_1[23]),
     .carry(cout[23]));
mul_csa42  sc3_22_ ( .c(s_2[22]), .cin(co[21]), .a(c_1[21]),
     .b(c_2[21]), .cout(co[22]), .sum(sum[22]), .d(s_1[22]),
     .carry(cout[22]));
mul_csa42  sc3_21_ ( .c(s_2[21]), .cin(co[20]), .a(c_1[20]),
     .b(c_2[20]), .cout(co[21]), .sum(sum[21]), .d(s_1[21]),
     .carry(cout[21]));
mul_csa42  sc3_20_ ( .c(s_2[20]), .cin(co[19]), .a(c_1[19]),
     .b(c_2[19]), .cout(co[20]), .sum(sum[20]), .d(s_1[20]),
     .carry(cout[20]));
mul_csa42  sc3_19_ ( .c(s_2[19]), .cin(co[18]), .a(c_1[18]),
     .b(c_2[18]), .cout(co[19]), .sum(sum[19]), .d(s_1[19]),
     .carry(cout[19]));
mul_csa42  sc3_18_ ( .c(s_2[18]), .cin(co[17]), .a(c_1[17]),
     .b(c_2[17]), .cout(co[18]), .sum(sum[18]), .d(s_1[18]),
     .carry(cout[18]));
mul_csa42  sc3_17_ ( .c(s_2[17]), .cin(co[16]), .a(c_1[16]),
     .b(c_2[16]), .cout(co[17]), .sum(sum[17]), .d(s_1[17]),
     .carry(cout[17]));
mul_csa42  sc3_16_ ( .c(s_2[16]), .cin(co[15]), .a(c_1[15]),
     .b(c_2[15]), .cout(co[16]), .sum(sum[16]), .d(s_1[16]),
     .carry(cout[16]));
mul_csa42  sc3_15_ ( .c(s_2[15]), .cin(co[14]), .a(c_1[14]),
     .b(c_2[14]), .cout(co[15]), .sum(sum[15]), .d(s_1[15]),
     .carry(cout[15]));
mul_csa42  sc3_14_ ( .c(s_2[14]), .cin(co[13]), .a(c_1[13]),
     .b(c_2[13]), .cout(co[14]), .sum(sum[14]), .d(s_1[14]),
     .carry(cout[14]));
mul_csa42  sc3_13_ ( .c(s_2[13]), .cin(co[12]), .a(c_1[12]),
     .b(c_2[12]), .cout(co[13]), .sum(sum[13]), .d(s_1[13]),
     .carry(cout[13]));
mul_csa42  sc3_12_ ( .c(s_2[12]), .cin(co[11]), .a(c_1[11]),
     .b(c_2[11]), .cout(co[12]), .sum(sum[12]), .d(s_1[12]),
     .carry(cout[12]));
mul_csa42  sc3_11_ ( .c(s_2[11]), .cin(1'b0),
     .a(c_1[10]), .b(c_2[10]), .cout(co[11]), .sum(sum[11]),
     .d(s_1[11]), .carry(cout[11]));
mul_csa32  sc2_2_70_ ( .c(c1[63]), .b(c2[57]), .a(s2[58]),
     .cout(c_2[70]), .sum(s_2[70]));
mul_csa32  sc2_2_69_ ( .c(c1[62]), .b(c2[56]), .a(s2[57]),
     .cout(c_2[69]), .sum(s_2[69]));
mul_csa32  sc2_2_68_ ( .c(c1[61]), .b(c2[55]), .a(s2[56]),
     .cout(c_2[68]), .sum(s_2[68]));
mul_csa32  sc2_2_67_ ( .c(c1[60]), .b(c2[54]), .a(s2[55]),
     .cout(c_2[67]), .sum(s_2[67]));
mul_csa32  sc2_2_66_ ( .c(c1[59]), .b(c2[53]), .a(s2[54]),
     .cout(c_2[66]), .sum(s_2[66]));
mul_csa32  sc2_2_65_ ( .c(c1[58]), .b(c2[52]), .a(s2[53]),
     .cout(c_2[65]), .sum(s_2[65]));
mul_csa32  sc2_2_64_ ( .c(c1[57]), .b(c2[51]), .a(s2[52]),
     .cout(c_2[64]), .sum(s_2[64]));
mul_csa32  sc2_2_63_ ( .c(c1[56]), .b(c2[50]), .a(s2[51]),
     .cout(c_2[63]), .sum(s_2[63]));
mul_csa32  sc2_2_62_ ( .c(c1[55]), .b(c2[49]), .a(s2[50]),
     .cout(c_2[62]), .sum(s_2[62]));
mul_csa32  sc2_2_61_ ( .c(c1[54]), .b(c2[48]), .a(s2[49]),
     .cout(c_2[61]), .sum(s_2[61]));
mul_csa32  sc2_2_60_ ( .c(c1[53]), .b(c2[47]), .a(s2[48]),
     .cout(c_2[60]), .sum(s_2[60]));
mul_csa32  sc2_2_59_ ( .c(c1[52]), .b(c2[46]), .a(s2[47]),
     .cout(c_2[59]), .sum(s_2[59]));
mul_csa32  sc2_2_58_ ( .c(c1[51]), .b(c2[45]), .a(s2[46]),
     .cout(c_2[58]), .sum(s_2[58]));
mul_csa32  sc2_2_57_ ( .c(c1[50]), .b(c2[44]), .a(s2[45]),
     .cout(c_2[57]), .sum(s_2[57]));
mul_csa32  sc2_2_56_ ( .c(c1[49]), .b(c2[43]), .a(s2[44]),
     .cout(c_2[56]), .sum(s_2[56]));
mul_csa32  sc2_2_55_ ( .c(c1[48]), .b(c2[42]), .a(s2[43]),
     .cout(c_2[55]), .sum(s_2[55]));
mul_csa32  sc2_2_54_ ( .c(c1[47]), .b(c2[41]), .a(s2[42]),
     .cout(c_2[54]), .sum(s_2[54]));
mul_csa32  sc2_2_53_ ( .c(c1[46]), .b(c2[40]), .a(s2[41]),
     .cout(c_2[53]), .sum(s_2[53]));
mul_csa32  sc2_2_52_ ( .c(c1[45]), .b(c2[39]), .a(s2[40]),
     .cout(c_2[52]), .sum(s_2[52]));
mul_csa32  sc2_2_51_ ( .c(c1[44]), .b(c2[38]), .a(s2[39]),
     .cout(c_2[51]), .sum(s_2[51]));
mul_csa32  sc2_2_50_ ( .c(c1[43]), .b(c2[37]), .a(s2[38]),
     .cout(c_2[50]), .sum(s_2[50]));
mul_csa32  sc2_2_49_ ( .c(c1[42]), .b(c2[36]), .a(s2[37]),
     .cout(c_2[49]), .sum(s_2[49]));
mul_csa32  sc2_2_48_ ( .c(c1[41]), .b(c2[35]), .a(s2[36]),
     .cout(c_2[48]), .sum(s_2[48]));
mul_csa32  sc2_2_47_ ( .c(c1[40]), .b(c2[34]), .a(s2[35]),
     .cout(c_2[47]), .sum(s_2[47]));
mul_csa32  sc2_2_46_ ( .c(c1[39]), .b(c2[33]), .a(s2[34]),
     .cout(c_2[46]), .sum(s_2[46]));
mul_csa32  sc2_2_45_ ( .c(c1[38]), .b(c2[32]), .a(s2[33]),
     .cout(c_2[45]), .sum(s_2[45]));
mul_csa32  sc2_2_44_ ( .c(c1[37]), .b(c2[31]), .a(s2[32]),
     .cout(c_2[44]), .sum(s_2[44]));
mul_csa32  sc2_2_43_ ( .c(c1[36]), .b(c2[30]), .a(s2[31]),
     .cout(c_2[43]), .sum(s_2[43]));
mul_csa32  sc2_2_42_ ( .c(c1[35]), .b(c2[29]), .a(s2[30]),
     .cout(c_2[42]), .sum(s_2[42]));
mul_csa32  sc2_2_41_ ( .c(c1[34]), .b(c2[28]), .a(s2[29]),
     .cout(c_2[41]), .sum(s_2[41]));
mul_csa32  sc2_2_40_ ( .c(c1[33]), .b(c2[27]), .a(s2[28]),
     .cout(c_2[40]), .sum(s_2[40]));
mul_csa32  sc2_2_39_ ( .c(c1[32]), .b(c2[26]), .a(s2[27]),
     .cout(c_2[39]), .sum(s_2[39]));
mul_csa32  sc2_2_38_ ( .c(c1[31]), .b(c2[25]), .a(s2[26]),
     .cout(c_2[38]), .sum(s_2[38]));
mul_csa32  sc2_2_37_ ( .c(c1[30]), .b(c2[24]), .a(s2[25]),
     .cout(c_2[37]), .sum(s_2[37]));
mul_csa32  sc2_2_36_ ( .c(c1[29]), .b(c2[23]), .a(s2[24]),
     .cout(c_2[36]), .sum(s_2[36]));
mul_csa32  sc2_2_35_ ( .c(c1[28]), .b(c2[22]), .a(s2[23]),
     .cout(c_2[35]), .sum(s_2[35]));
mul_csa32  sc2_2_34_ ( .c(c1[27]), .b(c2[21]), .a(s2[22]),
     .cout(c_2[34]), .sum(s_2[34]));
mul_csa32  sc2_2_33_ ( .c(c1[26]), .b(c2[20]), .a(s2[21]),
     .cout(c_2[33]), .sum(s_2[33]));
mul_csa32  sc2_2_32_ ( .c(c1[25]), .b(c2[19]), .a(s2[20]),
     .cout(c_2[32]), .sum(s_2[32]));
mul_csa32  sc2_2_31_ ( .c(c1[24]), .b(c2[18]), .a(s2[19]),
     .cout(c_2[31]), .sum(s_2[31]));
mul_csa32  sc2_2_30_ ( .c(c1[23]), .b(c2[17]), .a(s2[18]),
     .cout(c_2[30]), .sum(s_2[30]));
mul_csa32  sc2_2_29_ ( .c(c1[22]), .b(c2[16]), .a(s2[17]),
     .cout(c_2[29]), .sum(s_2[29]));
mul_csa32  sc2_2_28_ ( .c(c1[21]), .b(c2[15]), .a(s2[16]),
     .cout(c_2[28]), .sum(s_2[28]));
mul_csa32  sc2_2_27_ ( .c(c1[20]), .b(c2[14]), .a(s2[15]),
     .cout(c_2[27]), .sum(s_2[27]));
mul_csa32  sc2_2_26_ ( .c(c1[19]), .b(c2[13]), .a(s2[14]),
     .cout(c_2[26]), .sum(s_2[26]));
mul_csa32  sc2_2_25_ ( .c(c1[18]), .b(c2[12]), .a(s2[13]),
     .cout(c_2[25]), .sum(s_2[25]));
mul_csa32  sc2_2_24_ ( .c(c1[17]), .b(c2[11]), .a(s2[12]),
     .cout(c_2[24]), .sum(s_2[24]));
mul_csa32  sc2_2_23_ ( .c(c1[16]), .b(c2[10]), .a(s2[11]),
     .cout(c_2[23]), .sum(s_2[23]));
mul_csa32  sc2_2_22_ ( .c(c1[15]), .b(c2[9]), .a(s2[10]),
     .cout(c_2[22]), .sum(s_2[22]));
mul_csa32  sc2_2_21_ ( .c(c1[14]), .b(c2[8]), .a(s2[9]),
     .cout(c_2[21]), .sum(s_2[21]));
mul_csa32  sc2_2_20_ ( .c(c1[13]), .b(c2[7]), .a(s2[8]),
     .cout(c_2[20]), .sum(s_2[20]));
mul_csa32  sc2_2_19_ ( .c(c1[12]), .b(c2[6]), .a(s2[7]),
     .cout(c_2[19]), .sum(s_2[19]));
mul_csa32  sc2_2_18_ ( .c(c1[11]), .b(c2[5]), .a(s2[6]),
     .cout(c_2[18]), .sum(s_2[18]));
mul_csa32  sc2_2_17_ ( .c(c1[10]), .b(c2[4]), .a(s2[5]),
     .cout(c_2[17]), .sum(s_2[17]));
mul_csa32  sc2_2_16_ ( .c(c1[9]), .b(c2[3]), .a(s2[4]),
     .cout(c_2[16]), .sum(s_2[16]));
mul_csa32  sc2_2_15_ ( .c(c1[8]), .b(c2[2]), .a(s2[3]),
     .cout(c_2[15]), .sum(s_2[15]));
mul_csa32  sc2_2_14_ ( .c(c1[7]), .b(c2[1]), .a(s2[2]),
     .cout(c_2[14]), .sum(s_2[14]));
mul_csa32  sc2_2_13_ ( .c(c1[6]), .b(s1[7]), .a(s2[1]),
     .cout(c_2[13]), .sum(s_2[13]));
mul_csa32  sc2_2_12_ ( .c(c1[5]), .b(s1[6]), .a(s2[0]),
     .cout(c_2[12]), .sum(s_2[12]));
mul_csa32  sc2_2_11_ ( .c(c1[4]), .b(s1[5]), .a(b5n[1]),
     .cout(c_2[11]), .sum(s_2[11]));
mul_csa32  sc2_2_10_ ( .c(c1[3]), .b(s1[4]), .a(b5n[0]),
     .cout(c_2[10]), .sum(s_2[10]));
mul_csa32  sc2_2_76_ ( .c(1'b1), .b(c2[63]), .a(s2[64]),
     .cout(c_2[76]), .sum(s_2[76]));
mul_csa32  sc2_2_77_ ( .c(c_2[76]), .b(c2[64]), .a(s2[65]),
     .cout(cout[77]), .sum(sum[77]));
mul_csa32  sc2_1_9_ ( .c(s1[3]), .b(c0[8]), .a(s0[9]), .cout(c_1[9]),
     .sum(s_1[9]));
mul_csa32  sc2_1_8_ ( .c(s1[2]), .b(c0[7]), .a(s0[8]), .cout(c_1[8]),
     .sum(s_1[8]));
mul_csa32  sc2_1_3_ ( .c(c_1[2]), .b(c0[2]), .a(s0[3]),
     .cout(c_1[3]), .sum(sum[3]));
mul_csa32  sc3_10_ ( .c(s_2[10]), .b(s_1[10]), .a(c_1[9]),
     .cout(cout[10]), .sum(sum[10]));
mul_csa32  sc3_9_ ( .c(c1[2]), .sum(sum[9]), .cout(cout[9]),
     .a(c_1[8]), .b(s_1[9]));
mul_csa32  sc3_8_ ( .c(c1[1]), .sum(sum[8]), .cout(cout[8]),
     .a(c_1[7]), .b(s_1[8]));
mul_csa32  sc2_2_71_ ( .c(c1[64]), .b(c2[58]), .a(s2[59]),
     .cout(c_2[71]), .sum(s_2[71]));
mul_csa32  sc2_2_75_ ( .c(c1[68]), .b(c2[62]), .a(s2[63]),
     .cout(c_2[75]), .sum(s_2[75]));
mul_csa32  sc2_2_74_ ( .c(c1[67]), .b(c2[61]), .a(s2[62]),
     .cout(c_2[74]), .sum(s_2[74]));
mul_csa32  sc2_2_73_ ( .c(c1[66]), .b(c2[60]), .a(s2[61]),
     .cout(c_2[73]), .sum(s_2[73]));
mul_csa32  sc2_2_72_ ( .c(c1[65]), .b(c2[59]), .a(s2[60]),
     .cout(c_2[72]), .sum(s_2[72]));
mul_csa32  sc2_1_69_ ( .c(s1[63]), .sum(s_1[69]), .cout(c_1[69]),
     .a(s0[69]), .b(c0[68]));
mul_csa32  sc2_1_68_ ( .c(s1[62]), .sum(s_1[68]), .cout(c_1[68]),
     .a(s0[68]), .b(c0[67]));
mul_csa32  sc2_1_67_ ( .c(s1[61]), .sum(s_1[67]), .cout(c_1[67]),
     .a(s0[67]), .b(c0[66]));
mul_csa32  sc2_1_66_ ( .c(s1[60]), .sum(s_1[66]), .cout(c_1[66]),
     .a(s0[66]), .b(c0[65]));
mul_csa32  sc2_1_65_ ( .c(s1[59]), .sum(s_1[65]), .cout(c_1[65]),
     .a(s0[65]), .b(c0[64]));
mul_csa32  sc2_1_64_ ( .c(s1[58]), .sum(s_1[64]), .cout(c_1[64]),
     .a(s0[64]), .b(c0[63]));
mul_csa32  sc2_1_63_ ( .c(s1[57]), .sum(s_1[63]), .cout(c_1[63]),
     .a(s0[63]), .b(c0[62]));
mul_csa32  sc2_1_62_ ( .c(s1[56]), .sum(s_1[62]), .cout(c_1[62]),
     .a(s0[62]), .b(c0[61]));
mul_csa32  sc2_1_61_ ( .c(s1[55]), .sum(s_1[61]), .cout(c_1[61]),
     .a(s0[61]), .b(c0[60]));
mul_csa32  sc2_1_60_ ( .c(s1[54]), .sum(s_1[60]), .cout(c_1[60]),
     .a(s0[60]), .b(c0[59]));
mul_csa32  sc2_1_59_ ( .c(s1[53]), .sum(s_1[59]), .cout(c_1[59]),
     .a(s0[59]), .b(c0[58]));
mul_csa32  sc2_1_58_ ( .c(s1[52]), .sum(s_1[58]), .cout(c_1[58]),
     .a(s0[58]), .b(c0[57]));
mul_csa32  sc2_1_57_ ( .c(s1[51]), .sum(s_1[57]), .cout(c_1[57]),
     .a(s0[57]), .b(c0[56]));
mul_csa32  sc2_1_56_ ( .c(s1[50]), .sum(s_1[56]), .cout(c_1[56]),
     .a(s0[56]), .b(c0[55]));
mul_csa32  sc2_1_55_ ( .c(s1[49]), .sum(s_1[55]), .cout(c_1[55]),
     .a(s0[55]), .b(c0[54]));
mul_csa32  sc2_1_54_ ( .c(s1[48]), .sum(s_1[54]), .cout(c_1[54]),
     .a(s0[54]), .b(c0[53]));
mul_csa32  sc2_1_53_ ( .c(s1[47]), .sum(s_1[53]), .cout(c_1[53]),
     .a(s0[53]), .b(c0[52]));
mul_csa32  sc2_1_52_ ( .c(s1[46]), .sum(s_1[52]), .cout(c_1[52]),
     .a(s0[52]), .b(c0[51]));
mul_csa32  sc2_1_51_ ( .c(s1[45]), .sum(s_1[51]), .cout(c_1[51]),
     .a(s0[51]), .b(c0[50]));
mul_csa32  sc2_1_50_ ( .c(s1[44]), .sum(s_1[50]), .cout(c_1[50]),
     .a(s0[50]), .b(c0[49]));
mul_csa32  sc2_1_49_ ( .c(s1[43]), .sum(s_1[49]), .cout(c_1[49]),
     .a(s0[49]), .b(c0[48]));
mul_csa32  sc2_1_48_ ( .c(s1[42]), .sum(s_1[48]), .cout(c_1[48]),
     .a(s0[48]), .b(c0[47]));
mul_csa32  sc2_1_47_ ( .c(s1[41]), .sum(s_1[47]), .cout(c_1[47]),
     .a(s0[47]), .b(c0[46]));
mul_csa32  sc2_1_46_ ( .c(s1[40]), .sum(s_1[46]), .cout(c_1[46]),
     .a(s0[46]), .b(c0[45]));
mul_csa32  sc2_1_45_ ( .c(s1[39]), .sum(s_1[45]), .cout(c_1[45]),
     .a(s0[45]), .b(c0[44]));
mul_csa32  sc2_1_44_ ( .c(s1[38]), .sum(s_1[44]), .cout(c_1[44]),
     .a(s0[44]), .b(c0[43]));
mul_csa32  sc2_1_43_ ( .c(s1[37]), .sum(s_1[43]), .cout(c_1[43]),
     .a(s0[43]), .b(c0[42]));
mul_csa32  sc2_1_42_ ( .c(s1[36]), .sum(s_1[42]), .cout(c_1[42]),
     .a(s0[42]), .b(c0[41]));
mul_csa32  sc2_1_41_ ( .c(s1[35]), .sum(s_1[41]), .cout(c_1[41]),
     .a(s0[41]), .b(c0[40]));
mul_csa32  sc2_1_40_ ( .c(s1[34]), .sum(s_1[40]), .cout(c_1[40]),
     .a(s0[40]), .b(c0[39]));
mul_csa32  sc2_1_39_ ( .c(s1[33]), .sum(s_1[39]), .cout(c_1[39]),
     .a(s0[39]), .b(c0[38]));
mul_csa32  sc2_1_38_ ( .c(s1[32]), .sum(s_1[38]), .cout(c_1[38]),
     .a(s0[38]), .b(c0[37]));
mul_csa32  sc2_1_37_ ( .c(s1[31]), .sum(s_1[37]), .cout(c_1[37]),
     .a(s0[37]), .b(c0[36]));
mul_csa32  sc2_1_36_ ( .c(s1[30]), .sum(s_1[36]), .cout(c_1[36]),
     .a(s0[36]), .b(c0[35]));
mul_csa32  sc2_1_35_ ( .c(s1[29]), .sum(s_1[35]), .cout(c_1[35]),
     .a(s0[35]), .b(c0[34]));
mul_csa32  sc2_1_34_ ( .c(s1[28]), .sum(s_1[34]), .cout(c_1[34]),
     .a(s0[34]), .b(c0[33]));
mul_csa32  sc2_1_33_ ( .c(s1[27]), .sum(s_1[33]), .cout(c_1[33]),
     .a(s0[33]), .b(c0[32]));
mul_csa32  sc2_1_32_ ( .c(s1[26]), .sum(s_1[32]), .cout(c_1[32]),
     .a(s0[32]), .b(c0[31]));
mul_csa32  sc2_1_31_ ( .c(s1[25]), .sum(s_1[31]), .cout(c_1[31]),
     .a(s0[31]), .b(c0[30]));
mul_csa32  sc2_1_30_ ( .c(s1[24]), .sum(s_1[30]), .cout(c_1[30]),
     .a(s0[30]), .b(c0[29]));
mul_csa32  sc2_1_29_ ( .c(s1[23]), .sum(s_1[29]), .cout(c_1[29]),
     .a(s0[29]), .b(c0[28]));
mul_csa32  sc2_1_28_ ( .c(s1[22]), .sum(s_1[28]), .cout(c_1[28]),
     .a(s0[28]), .b(c0[27]));
mul_csa32  sc2_1_27_ ( .c(s1[21]), .sum(s_1[27]), .cout(c_1[27]),
     .a(s0[27]), .b(c0[26]));
mul_csa32  sc2_1_26_ ( .c(s1[20]), .sum(s_1[26]), .cout(c_1[26]),
     .a(s0[26]), .b(c0[25]));
mul_csa32  sc2_1_25_ ( .c(s1[19]), .sum(s_1[25]), .cout(c_1[25]),
     .a(s0[25]), .b(c0[24]));
mul_csa32  sc2_1_24_ ( .c(s1[18]), .sum(s_1[24]), .cout(c_1[24]),
     .a(s0[24]), .b(c0[23]));
mul_csa32  sc2_1_23_ ( .c(s1[17]), .sum(s_1[23]), .cout(c_1[23]),
     .a(s0[23]), .b(c0[22]));
mul_csa32  sc2_1_22_ ( .c(s1[16]), .sum(s_1[22]), .cout(c_1[22]),
     .a(s0[22]), .b(c0[21]));
mul_csa32  sc2_1_21_ ( .c(s1[15]), .sum(s_1[21]), .cout(c_1[21]),
     .a(s0[21]), .b(c0[20]));
mul_csa32  sc2_1_20_ ( .c(s1[14]), .sum(s_1[20]), .cout(c_1[20]),
     .a(s0[20]), .b(c0[19]));
mul_csa32  sc2_1_19_ ( .c(s1[13]), .sum(s_1[19]), .cout(c_1[19]),
     .a(s0[19]), .b(c0[18]));
mul_csa32  sc2_1_18_ ( .c(s1[12]), .sum(s_1[18]), .cout(c_1[18]),
     .a(s0[18]), .b(c0[17]));
mul_csa32  sc2_1_17_ ( .c(s1[11]), .sum(s_1[17]), .cout(c_1[17]),
     .a(s0[17]), .b(c0[16]));
mul_csa32  sc2_1_16_ ( .c(s1[10]), .sum(s_1[16]), .cout(c_1[16]),
     .a(s0[16]), .b(c0[15]));
mul_csa32  sc2_1_15_ ( .c(s1[9]), .sum(s_1[15]), .cout(c_1[15]),
     .a(s0[15]), .b(c0[14]));
mul_csa32  sc2_1_14_ ( .c(s1[8]), .sum(s_1[14]), .cout(c_1[14]),
     .a(s0[14]), .b(c0[13]));
mul_csa32  sc2_1_7_ ( .c(s1[1]), .b(c0[6]), .a(s0[7]), .cout(c_1[7]),
     .sum(s_1[7]));
mul_csa32  sc2_1_6_ ( .c(s1[0]), .b(c0[5]), .a(s0[6]), .cout(c_1[6]),
     .sum(s_1[6]));
mul_csa32  sc2_1_5_ ( .c(b2n[1]), .b(c0[4]), .a(s0[5]),
     .cout(c_1[5]), .sum(s_1[5]));
mul_csa32  sc2_1_4_ ( .c(b2n[0]), .b(c0[3]), .a(s0[4]),
     .cout(c_1[4]), .sum(s_1[4]));
mul_ha sc2_1_10_ ( .sum(s_1[10]), .cout(c_1[10]), .a(s0[10]),
     .b(c0[9]));
mul_ha sc3_7_ ( .sum(sum[7]), .cout(cout[7]), .a(c_1[6]),
     .b(s_1[7]));
mul_ha sc3_6_ ( .sum(sum[6]), .cout(cout[6]), .a(c_1[5]),
     .b(s_1[6]));
mul_ha sc3_5_ ( .sum(sum[5]), .cout(cout[5]), .a(c_1[4]),
     .b(s_1[5]));
mul_ha sc3_4_ ( .sum(sum[4]), .cout(cout[4]), .a(c_1[3]),
     .b(s_1[4]));
mul_ha sc2_2_81_ ( .sum(sum[81]), .cout(cout[81]), .a(s2[69]),
     .b(c2[68]));
mul_ha sc2_2_80_ ( .sum(sum[80]), .cout(cout[80]), .a(s2[68]),
     .b(c2[67]));
mul_ha sc2_2_79_ ( .sum(sum[79]), .cout(cout[79]), .a(s2[67]),
     .b(c2[66]));
mul_ha sc2_2_78_ ( .sum(sum[78]), .cout(cout[78]), .a(s2[66]),
     .b(c2[65]));
mul_ha sc2_1_70_ ( .sum(s_1[70]), .cout(c_1[70]),
     .a(1'b1), .b(s1[64]));
mul_ha sc2_1_2_ ( .sum(sum[2]), .cout(c_1[2]), .a(s0[2]), .b(c0[1]));
mul_ha sc2_1_13_ ( .sum(s_1[13]), .cout(c_1[13]), .a(s0[13]),
     .b(c0[12]));
mul_ha sc2_1_12_ ( .sum(s_1[12]), .cout(c_1[12]), .a(s0[12]),
     .b(c0[11]));
mul_ha sc2_1_11_ ( .sum(s_1[11]), .cout(c_1[11]), .a(s0[11]),
     .b(c0[10]));
mul_ppgenrow3 I2 ( .head(1'b0), .bot(bot), .b2(b8[2:0]),
     .b1(b7[2:0]), .b0(b6[2:0]), .a(a[63:0]), .sum(s2[69:0]),
     .cout(c2[68:1]));
mul_ppgenrow3 I1 ( .head(1'b0), .bot(1'b1),
     .b2(b5[2:0]), .b1(b4[2:0]), .b0(b3[2:0]), .a(a[63:0]),
     .sum(s1[69:0]), .cout(c1[68:1]));
mul_ppgenrow3 I0 ( .head(head), .bot(1'b1), .b2(b2[2:0]),
     .b1(b1[2:0]), .b0(b0[2:0]), .a(a[63:0]), .sum({s0[69:2],
     sum[1:0]}), .cout(c0[68:1]));

endmodule // mul_array1

module mul_array2 ( pcout, pcoutx2, psum, psumx2, a0c, a0s, a1c, a1s,
     areg, bot, pc, ps, x2 );

output  pcoutx2, psumx2;
input  bot, x2;
output [98:0]  psum;
output [98:0]  pcout;
input [81:4]  a1c;
input [98:30]  pc;
input [98:31]  ps;
input [81:0]  a0s;
input [96:0]  areg;
input [81:0]  a1s;
input [81:4]  a0c;

// Buses in the design
wire  [81:15]  s3;
wire  [81:15]  c3;
wire  [96:0]  ain;
wire  [67:20]  co;
wire  [82:0]  s1;
wire  [96:0]  c2;
wire  [82:0]  c1;
wire  [96:0]  s2;
wire	      ainx2, s1x2, c1x2;

mul_mux2 sh_82_ ( .d1(areg[83]), .z(ain[82]), .d0(areg[82]), .s(x2));
mul_mux2 sh_68_ ( .d1(areg[69]), .z(ain[68]), .d0(areg[68]), .s(x2));
mul_mux2 sh_67_ ( .d1(areg[68]), .z(ain[67]), .d0(areg[67]), .s(x2));
mul_mux2 sh_66_ ( .d1(areg[67]), .z(ain[66]), .d0(areg[66]), .s(x2));
mul_mux2 sh_65_ ( .d1(areg[66]), .z(ain[65]), .d0(areg[65]), .s(x2));
mul_mux2 sh_64_ ( .d1(areg[65]), .z(ain[64]), .d0(areg[64]), .s(x2));
mul_mux2 sh_63_ ( .d1(areg[64]), .z(ain[63]), .d0(areg[63]), .s(x2));
mul_mux2 sh_62_ ( .d1(areg[63]), .z(ain[62]), .d0(areg[62]), .s(x2));
mul_mux2 sh_61_ ( .d1(areg[62]), .z(ain[61]), .d0(areg[61]), .s(x2));
mul_mux2 sh_60_ ( .d1(areg[61]), .z(ain[60]), .d0(areg[60]), .s(x2));
mul_mux2 sh_59_ ( .d1(areg[60]), .z(ain[59]), .d0(areg[59]), .s(x2));
mul_mux2 sh_58_ ( .d1(areg[59]), .z(ain[58]), .d0(areg[58]), .s(x2));
mul_mux2 sh_57_ ( .d1(areg[58]), .z(ain[57]), .d0(areg[57]), .s(x2));
mul_mux2 sh_56_ ( .d1(areg[57]), .z(ain[56]), .d0(areg[56]), .s(x2));
mul_mux2 sh_55_ ( .d1(areg[56]), .z(ain[55]), .d0(areg[55]), .s(x2));
mul_mux2 sh_54_ ( .d1(areg[55]), .z(ain[54]), .d0(areg[54]), .s(x2));
mul_mux2 sh_53_ ( .d1(areg[54]), .z(ain[53]), .d0(areg[53]), .s(x2));
mul_mux2 sh_52_ ( .d1(areg[53]), .z(ain[52]), .d0(areg[52]), .s(x2));
mul_mux2 sh_51_ ( .d1(areg[52]), .z(ain[51]), .d0(areg[51]), .s(x2));
mul_mux2 sh_50_ ( .d1(areg[51]), .z(ain[50]), .d0(areg[50]), .s(x2));
mul_mux2 sh_49_ ( .d1(areg[50]), .z(ain[49]), .d0(areg[49]), .s(x2));
mul_mux2 sh_48_ ( .d1(areg[49]), .z(ain[48]), .d0(areg[48]), .s(x2));
mul_mux2 sh_47_ ( .d1(areg[48]), .z(ain[47]), .d0(areg[47]), .s(x2));
mul_mux2 sh_46_ ( .d1(areg[47]), .z(ain[46]), .d0(areg[46]), .s(x2));
mul_mux2 sh_45_ ( .d1(areg[46]), .z(ain[45]), .d0(areg[45]), .s(x2));
mul_mux2 sh_44_ ( .d1(areg[45]), .z(ain[44]), .d0(areg[44]), .s(x2));
mul_mux2 sh_43_ ( .d1(areg[44]), .z(ain[43]), .d0(areg[43]), .s(x2));
mul_mux2 sh_42_ ( .d1(areg[43]), .z(ain[42]), .d0(areg[42]), .s(x2));
mul_mux2 sh_41_ ( .d1(areg[42]), .z(ain[41]), .d0(areg[41]), .s(x2));
mul_mux2 sh_40_ ( .d1(areg[41]), .z(ain[40]), .d0(areg[40]), .s(x2));
mul_mux2 sh_39_ ( .d1(areg[40]), .z(ain[39]), .d0(areg[39]), .s(x2));
mul_mux2 sh_38_ ( .d1(areg[39]), .z(ain[38]), .d0(areg[38]), .s(x2));
mul_mux2 sh_37_ ( .d1(areg[38]), .z(ain[37]), .d0(areg[37]), .s(x2));
mul_mux2 sh_36_ ( .d1(areg[37]), .z(ain[36]), .d0(areg[36]), .s(x2));
mul_mux2 sh_35_ ( .d1(areg[36]), .z(ain[35]), .d0(areg[35]), .s(x2));
mul_mux2 sh_34_ ( .d1(areg[35]), .z(ain[34]), .d0(areg[34]), .s(x2));
mul_mux2 sh_33_ ( .d1(areg[34]), .z(ain[33]), .d0(areg[33]), .s(x2));
mul_mux2 sh_32_ ( .d1(areg[33]), .z(ain[32]), .d0(areg[32]), .s(x2));
mul_mux2 sh_31_ ( .d1(areg[32]), .z(ain[31]), .d0(areg[31]), .s(x2));
mul_mux2 sh_30_ ( .d1(areg[31]), .z(ain[30]), .d0(areg[30]), .s(x2));
mul_mux2 sh_29_ ( .d1(areg[30]), .z(ain[29]), .d0(areg[29]), .s(x2));
mul_mux2 sh_28_ ( .d1(areg[29]), .z(ain[28]), .d0(areg[28]), .s(x2));
mul_mux2 sh_27_ ( .d1(areg[28]), .z(ain[27]), .d0(areg[27]), .s(x2));
mul_mux2 sh_26_ ( .d1(areg[27]), .z(ain[26]), .d0(areg[26]), .s(x2));
mul_mux2 sh_25_ ( .d1(areg[26]), .z(ain[25]), .d0(areg[25]), .s(x2));
mul_mux2 sh_24_ ( .d1(areg[25]), .z(ain[24]), .d0(areg[24]), .s(x2));
mul_mux2 sh_23_ ( .d1(areg[24]), .z(ain[23]), .d0(areg[23]), .s(x2));
mul_mux2 sh_22_ ( .d1(areg[23]), .z(ain[22]), .d0(areg[22]), .s(x2));
mul_mux2 sh_21_ ( .d1(areg[22]), .z(ain[21]), .d0(areg[21]), .s(x2));
mul_mux2 sh_20_ ( .d1(areg[21]), .z(ain[20]), .d0(areg[20]), .s(x2));
mul_mux2 sh_96_ ( .d1(1'b0), .z(ain[96]), .d0(areg[96]),
     .s(x2));
mul_mux2 sh_95_ ( .d1(areg[96]), .z(ain[95]), .d0(areg[95]), .s(x2));
mul_mux2 sh_94_ ( .d1(areg[95]), .z(ain[94]), .d0(areg[94]), .s(x2));
mul_mux2 sh_93_ ( .d1(areg[94]), .z(ain[93]), .d0(areg[93]), .s(x2));
mul_mux2 sh_92_ ( .d1(areg[93]), .z(ain[92]), .d0(areg[92]), .s(x2));
mul_mux2 sh_91_ ( .d1(areg[92]), .z(ain[91]), .d0(areg[91]), .s(x2));
mul_mux2 sh_90_ ( .d1(areg[91]), .z(ain[90]), .d0(areg[90]), .s(x2));
mul_mux2 sh_89_ ( .d1(areg[90]), .z(ain[89]), .d0(areg[89]), .s(x2));
mul_mux2 sh_88_ ( .d1(areg[89]), .z(ain[88]), .d0(areg[88]), .s(x2));
mul_mux2 sh_87_ ( .d1(areg[88]), .z(ain[87]), .d0(areg[87]), .s(x2));
mul_mux2 sh_86_ ( .d1(areg[87]), .z(ain[86]), .d0(areg[86]), .s(x2));
mul_mux2 sh_85_ ( .d1(areg[86]), .z(ain[85]), .d0(areg[85]), .s(x2));
mul_mux2 sh_84_ ( .d1(areg[85]), .z(ain[84]), .d0(areg[84]), .s(x2));
mul_mux2 sh_0_ ( .d1(areg[1]), .z(ain[0]), .d0(areg[0]), .s(x2));
mul_mux2 sh_81_ ( .d1(areg[82]), .z(ain[81]), .d0(areg[81]), .s(x2));
mul_mux2 sh_80_ ( .d1(areg[81]), .z(ain[80]), .d0(areg[80]), .s(x2));
mul_mux2 sh_79_ ( .d1(areg[80]), .z(ain[79]), .d0(areg[79]), .s(x2));
mul_mux2 sh_78_ ( .d1(areg[79]), .z(ain[78]), .d0(areg[78]), .s(x2));
mul_mux2 sh_77_ ( .d1(areg[78]), .z(ain[77]), .d0(areg[77]), .s(x2));
mul_mux2 sh_76_ ( .d1(areg[77]), .z(ain[76]), .d0(areg[76]), .s(x2));
mul_mux2 sh_75_ ( .d1(areg[76]), .z(ain[75]), .d0(areg[75]), .s(x2));
mul_mux2 sh_74_ ( .d1(areg[75]), .z(ain[74]), .d0(areg[74]), .s(x2));
mul_mux2 sh_73_ ( .d1(areg[74]), .z(ain[73]), .d0(areg[73]), .s(x2));
mul_mux2 sh_72_ ( .d1(areg[73]), .z(ain[72]), .d0(areg[72]), .s(x2));
mul_mux2 sh_71_ ( .d1(areg[72]), .z(ain[71]), .d0(areg[71]), .s(x2));
mul_mux2 sh_70_ ( .d1(areg[71]), .z(ain[70]), .d0(areg[70]), .s(x2));
mul_mux2 sh_69_ ( .d1(areg[70]), .z(ain[69]), .d0(areg[69]), .s(x2));
mul_mux2 sh_19_ ( .d1(areg[20]), .z(ain[19]), .d0(areg[19]), .s(x2));
mul_mux2 sh_18_ ( .d1(areg[19]), .z(ain[18]), .d0(areg[18]), .s(x2));
mul_mux2 sh_17_ ( .d1(areg[18]), .z(ain[17]), .d0(areg[17]), .s(x2));
mul_mux2 sh_16_ ( .d1(areg[17]), .z(ain[16]), .d0(areg[16]), .s(x2));
mul_mux2 sh_15_ ( .d1(areg[16]), .z(ain[15]), .d0(areg[15]), .s(x2));
mul_mux2 sh_4_ ( .d1(areg[5]), .z(ain[4]), .d0(areg[4]), .s(x2));
mul_mux2 sh_3_ ( .d1(areg[4]), .z(ain[3]), .d0(areg[3]), .s(x2));
mul_mux2 sh_2_ ( .d1(areg[3]), .z(ain[2]), .d0(areg[2]), .s(x2));
mul_mux2 sh_1_ ( .d1(areg[2]), .z(ain[1]), .d0(areg[1]), .s(x2));
mul_mux2 shx2 ( .d1(areg[0]), .z(ainx2), .d0(1'b0),
     .s(x2));
mul_mux2 sh_83_ ( .d1(areg[84]), .z(ain[83]), .d0(areg[83]), .s(x2));
mul_mux2 sh_14_ ( .d1(areg[15]), .z(ain[14]), .d0(areg[14]), .s(x2));
mul_mux2 sh_13_ ( .d1(areg[14]), .z(ain[13]), .d0(areg[13]), .s(x2));
mul_mux2 sh_12_ ( .d1(areg[13]), .z(ain[12]), .d0(areg[12]), .s(x2));
mul_mux2 sh_11_ ( .d1(areg[12]), .z(ain[11]), .d0(areg[11]), .s(x2));
mul_mux2 sh_10_ ( .d1(areg[11]), .z(ain[10]), .d0(areg[10]), .s(x2));
mul_mux2 sh_9_ ( .d1(areg[10]), .z(ain[9]), .d0(areg[9]), .s(x2));
mul_mux2 sh_8_ ( .d1(areg[9]), .z(ain[8]), .d0(areg[8]), .s(x2));
mul_mux2 sh_7_ ( .d1(areg[8]), .z(ain[7]), .d0(areg[7]), .s(x2));
mul_mux2 sh_6_ ( .d1(areg[7]), .z(ain[6]), .d0(areg[6]), .s(x2));
mul_mux2 sh_5_ ( .d1(areg[6]), .z(ain[5]), .d0(areg[5]), .s(x2));
mul_csa42  sc3_68_ ( .cin(co[67]), .d(1'b0),
     .carry(c3[68]), .c(c2[67]), .b(s2[68]), .a(1'b0),
     .cout(), .sum(s3[68]));
mul_csa42  sc3_67_ ( .cin(co[66]), .d(1'b0),
     .carry(c3[67]), .c(c2[66]), .b(s2[67]), .a(s1[67]), .cout(co[67]),
     .sum(s3[67]));
mul_csa42  sc3_66_ ( .cin(co[65]), .d(c1[65]), .carry(c3[66]),
     .c(c2[65]), .b(s2[66]), .a(s1[66]), .cout(co[66]), .sum(s3[66]));
mul_csa42  sc3_65_ ( .cin(co[64]), .d(c1[64]), .carry(c3[65]),
     .c(c2[64]), .b(s2[65]), .a(s1[65]), .cout(co[65]), .sum(s3[65]));
mul_csa42  sc3_64_ ( .cin(co[63]), .d(c1[63]), .carry(c3[64]),
     .c(c2[63]), .b(s2[64]), .a(s1[64]), .cout(co[64]), .sum(s3[64]));
mul_csa42  sc3_63_ ( .cin(co[62]), .d(c1[62]), .carry(c3[63]),
     .c(c2[62]), .b(s2[63]), .a(s1[63]), .cout(co[63]), .sum(s3[63]));
mul_csa42  sc3_62_ ( .cin(co[61]), .d(c1[61]), .carry(c3[62]),
     .c(c2[61]), .b(s2[62]), .a(s1[62]), .cout(co[62]), .sum(s3[62]));
mul_csa42  sc3_61_ ( .cin(co[60]), .d(c1[60]), .carry(c3[61]),
     .c(c2[60]), .b(s2[61]), .a(s1[61]), .cout(co[61]), .sum(s3[61]));
mul_csa42  sc3_60_ ( .cin(co[59]), .d(c1[59]), .carry(c3[60]),
     .c(c2[59]), .b(s2[60]), .a(s1[60]), .cout(co[60]), .sum(s3[60]));
mul_csa42  sc3_59_ ( .cin(co[58]), .d(c1[58]), .carry(c3[59]),
     .c(c2[58]), .b(s2[59]), .a(s1[59]), .cout(co[59]), .sum(s3[59]));
mul_csa42  sc3_58_ ( .cin(co[57]), .d(c1[57]), .carry(c3[58]),
     .c(c2[57]), .b(s2[58]), .a(s1[58]), .cout(co[58]), .sum(s3[58]));
mul_csa42  sc3_57_ ( .cin(co[56]), .d(c1[56]), .carry(c3[57]),
     .c(c2[56]), .b(s2[57]), .a(s1[57]), .cout(co[57]), .sum(s3[57]));
mul_csa42  sc3_56_ ( .cin(co[55]), .d(c1[55]), .carry(c3[56]),
     .c(c2[55]), .b(s2[56]), .a(s1[56]), .cout(co[56]), .sum(s3[56]));
mul_csa42  sc3_55_ ( .cin(co[54]), .d(c1[54]), .carry(c3[55]),
     .c(c2[54]), .b(s2[55]), .a(s1[55]), .cout(co[55]), .sum(s3[55]));
mul_csa42  sc3_54_ ( .cin(co[53]), .d(c1[53]), .carry(c3[54]),
     .c(c2[53]), .b(s2[54]), .a(s1[54]), .cout(co[54]), .sum(s3[54]));
mul_csa42  sc3_53_ ( .cin(co[52]), .d(c1[52]), .carry(c3[53]),
     .c(c2[52]), .b(s2[53]), .a(s1[53]), .cout(co[53]), .sum(s3[53]));
mul_csa42  sc3_52_ ( .cin(co[51]), .d(c1[51]), .carry(c3[52]),
     .c(c2[51]), .b(s2[52]), .a(s1[52]), .cout(co[52]), .sum(s3[52]));
mul_csa42  sc3_51_ ( .cin(co[50]), .d(c1[50]), .carry(c3[51]),
     .c(c2[50]), .b(s2[51]), .a(s1[51]), .cout(co[51]), .sum(s3[51]));
mul_csa42  sc3_50_ ( .cin(co[49]), .d(c1[49]), .carry(c3[50]),
     .c(c2[49]), .b(s2[50]), .a(s1[50]), .cout(co[50]), .sum(s3[50]));
mul_csa42  sc3_49_ ( .cin(co[48]), .d(c1[48]), .carry(c3[49]),
     .c(c2[48]), .b(s2[49]), .a(s1[49]), .cout(co[49]), .sum(s3[49]));
mul_csa42  sc3_48_ ( .cin(co[47]), .d(c1[47]), .carry(c3[48]),
     .c(c2[47]), .b(s2[48]), .a(s1[48]), .cout(co[48]), .sum(s3[48]));
mul_csa42  sc3_47_ ( .cin(co[46]), .d(c1[46]), .carry(c3[47]),
     .c(c2[46]), .b(s2[47]), .a(s1[47]), .cout(co[47]), .sum(s3[47]));
mul_csa42  sc3_46_ ( .cin(co[45]), .d(c1[45]), .carry(c3[46]),
     .c(c2[45]), .b(s2[46]), .a(s1[46]), .cout(co[46]), .sum(s3[46]));
mul_csa42  sc3_45_ ( .cin(co[44]), .d(c1[44]), .carry(c3[45]),
     .c(c2[44]), .b(s2[45]), .a(s1[45]), .cout(co[45]), .sum(s3[45]));
mul_csa42  sc3_44_ ( .cin(co[43]), .d(c1[43]), .carry(c3[44]),
     .c(c2[43]), .b(s2[44]), .a(s1[44]), .cout(co[44]), .sum(s3[44]));
mul_csa42  sc3_43_ ( .cin(co[42]), .d(c1[42]), .carry(c3[43]),
     .c(c2[42]), .b(s2[43]), .a(s1[43]), .cout(co[43]), .sum(s3[43]));
mul_csa42  sc3_42_ ( .cin(co[41]), .d(c1[41]), .carry(c3[42]),
     .c(c2[41]), .b(s2[42]), .a(s1[42]), .cout(co[42]), .sum(s3[42]));
mul_csa42  sc3_41_ ( .cin(co[40]), .d(c1[40]), .carry(c3[41]),
     .c(c2[40]), .b(s2[41]), .a(s1[41]), .cout(co[41]), .sum(s3[41]));
mul_csa42  sc3_40_ ( .cin(co[39]), .d(c1[39]), .carry(c3[40]),
     .c(c2[39]), .b(s2[40]), .a(s1[40]), .cout(co[40]), .sum(s3[40]));
mul_csa42  sc3_39_ ( .cin(co[38]), .d(c1[38]), .carry(c3[39]),
     .c(c2[38]), .b(s2[39]), .a(s1[39]), .cout(co[39]), .sum(s3[39]));
mul_csa42  sc3_38_ ( .cin(co[37]), .d(c1[37]), .carry(c3[38]),
     .c(c2[37]), .b(s2[38]), .a(s1[38]), .cout(co[38]), .sum(s3[38]));
mul_csa42  sc3_37_ ( .cin(co[36]), .d(c1[36]), .carry(c3[37]),
     .c(c2[36]), .b(s2[37]), .a(s1[37]), .cout(co[37]), .sum(s3[37]));
mul_csa42  sc3_36_ ( .cin(co[35]), .d(c1[35]), .carry(c3[36]),
     .c(c2[35]), .b(s2[36]), .a(s1[36]), .cout(co[36]), .sum(s3[36]));
mul_csa42  sc3_35_ ( .cin(co[34]), .d(c1[34]), .carry(c3[35]),
     .c(c2[34]), .b(s2[35]), .a(s1[35]), .cout(co[35]), .sum(s3[35]));
mul_csa42  sc3_34_ ( .cin(co[33]), .d(c1[33]), .carry(c3[34]),
     .c(c2[33]), .b(s2[34]), .a(s1[34]), .cout(co[34]), .sum(s3[34]));
mul_csa42  sc3_33_ ( .cin(co[32]), .d(c1[32]), .carry(c3[33]),
     .c(c2[32]), .b(s2[33]), .a(s1[33]), .cout(co[33]), .sum(s3[33]));
mul_csa42  sc3_32_ ( .cin(co[31]), .d(c1[31]), .carry(c3[32]),
     .c(c2[31]), .b(s2[32]), .a(s1[32]), .cout(co[32]), .sum(s3[32]));
mul_csa42  sc3_31_ ( .cin(co[30]), .d(c1[30]), .carry(c3[31]),
     .c(c2[30]), .b(s2[31]), .a(s1[31]), .cout(co[31]), .sum(s3[31]));
mul_csa42  sc3_30_ ( .cin(co[29]), .d(c1[29]), .carry(c3[30]),
     .c(c2[29]), .b(s2[30]), .a(s1[30]), .cout(co[30]), .sum(s3[30]));
mul_csa42  sc3_29_ ( .cin(co[28]), .d(c1[28]), .carry(c3[29]),
     .c(c2[28]), .b(s2[29]), .a(s1[29]), .cout(co[29]), .sum(s3[29]));
mul_csa42  sc3_28_ ( .cin(co[27]), .d(c1[27]), .carry(c3[28]),
     .c(c2[27]), .b(s2[28]), .a(s1[28]), .cout(co[28]), .sum(s3[28]));
mul_csa42  sc3_27_ ( .cin(co[26]), .d(c1[26]), .carry(c3[27]),
     .c(c2[26]), .b(s2[27]), .a(s1[27]), .cout(co[27]), .sum(s3[27]));
mul_csa42  sc3_26_ ( .cin(co[25]), .d(c1[25]), .carry(c3[26]),
     .c(c2[25]), .b(s2[26]), .a(s1[26]), .cout(co[26]), .sum(s3[26]));
mul_csa42  sc3_25_ ( .cin(co[24]), .d(c1[24]), .carry(c3[25]),
     .c(c2[24]), .b(s2[25]), .a(s1[25]), .cout(co[25]), .sum(s3[25]));
mul_csa42  sc3_24_ ( .cin(co[23]), .d(c1[23]), .carry(c3[24]),
     .c(c2[23]), .b(s2[24]), .a(s1[24]), .cout(co[24]), .sum(s3[24]));
mul_csa42  sc3_23_ ( .cin(co[22]), .d(c1[22]), .carry(c3[23]),
     .c(c2[22]), .b(s2[23]), .a(s1[23]), .cout(co[23]), .sum(s3[23]));
mul_csa42  sc3_22_ ( .cin(co[21]), .d(c1[21]), .carry(c3[22]),
     .c(c2[21]), .b(s2[22]), .a(s1[22]), .cout(co[22]), .sum(s3[22]));
mul_csa42  sc3_21_ ( .cin(co[20]), .d(c1[20]), .carry(c3[21]),
     .c(c2[20]), .b(s2[21]), .a(s1[21]), .cout(co[21]), .sum(s3[21]));
mul_csa42  sc3_20_ ( .cin(1'b0), .d(c1[19]),
     .carry(c3[20]), .c(c2[19]), .b(s2[20]), .a(s1[20]), .cout(co[20]),
     .sum(s3[20]));
mul_csa32  sc4_82_ ( .c(c3[81]), .b(s2[82]), .a(ain[82]),
     .cout(pcout[82]), .sum(psum[82]));
mul_csa32  sc4_68_ ( .c(c3[67]), .b(s3[68]), .a(ain[68]),
     .cout(pcout[68]), .sum(psum[68]));
mul_csa32  sc4_67_ ( .c(c3[66]), .b(s3[67]), .a(ain[67]),
     .cout(pcout[67]), .sum(psum[67]));
mul_csa32  sc4_66_ ( .c(c3[65]), .b(s3[66]), .a(ain[66]),
     .cout(pcout[66]), .sum(psum[66]));
mul_csa32  sc4_65_ ( .c(c3[64]), .b(s3[65]), .a(ain[65]),
     .cout(pcout[65]), .sum(psum[65]));
mul_csa32  sc4_64_ ( .c(c3[63]), .b(s3[64]), .a(ain[64]),
     .cout(pcout[64]), .sum(psum[64]));
mul_csa32  sc4_63_ ( .c(c3[62]), .b(s3[63]), .a(ain[63]),
     .cout(pcout[63]), .sum(psum[63]));
mul_csa32  sc4_62_ ( .c(c3[61]), .b(s3[62]), .a(ain[62]),
     .cout(pcout[62]), .sum(psum[62]));
mul_csa32  sc4_61_ ( .c(c3[60]), .b(s3[61]), .a(ain[61]),
     .cout(pcout[61]), .sum(psum[61]));
mul_csa32  sc4_60_ ( .c(c3[59]), .b(s3[60]), .a(ain[60]),
     .cout(pcout[60]), .sum(psum[60]));
mul_csa32  sc4_59_ ( .c(c3[58]), .b(s3[59]), .a(ain[59]),
     .cout(pcout[59]), .sum(psum[59]));
mul_csa32  sc4_58_ ( .c(c3[57]), .b(s3[58]), .a(ain[58]),
     .cout(pcout[58]), .sum(psum[58]));
mul_csa32  sc4_57_ ( .c(c3[56]), .b(s3[57]), .a(ain[57]),
     .cout(pcout[57]), .sum(psum[57]));
mul_csa32  sc4_56_ ( .c(c3[55]), .b(s3[56]), .a(ain[56]),
     .cout(pcout[56]), .sum(psum[56]));
mul_csa32  sc4_55_ ( .c(c3[54]), .b(s3[55]), .a(ain[55]),
     .cout(pcout[55]), .sum(psum[55]));
mul_csa32  sc4_54_ ( .c(c3[53]), .b(s3[54]), .a(ain[54]),
     .cout(pcout[54]), .sum(psum[54]));
mul_csa32  sc4_53_ ( .c(c3[52]), .b(s3[53]), .a(ain[53]),
     .cout(pcout[53]), .sum(psum[53]));
mul_csa32  sc4_52_ ( .c(c3[51]), .b(s3[52]), .a(ain[52]),
     .cout(pcout[52]), .sum(psum[52]));
mul_csa32  sc4_51_ ( .c(c3[50]), .b(s3[51]), .a(ain[51]),
     .cout(pcout[51]), .sum(psum[51]));
mul_csa32  sc4_50_ ( .c(c3[49]), .b(s3[50]), .a(ain[50]),
     .cout(pcout[50]), .sum(psum[50]));
mul_csa32  sc4_49_ ( .c(c3[48]), .b(s3[49]), .a(ain[49]),
     .cout(pcout[49]), .sum(psum[49]));
mul_csa32  sc4_48_ ( .c(c3[47]), .b(s3[48]), .a(ain[48]),
     .cout(pcout[48]), .sum(psum[48]));
mul_csa32  sc4_47_ ( .c(c3[46]), .b(s3[47]), .a(ain[47]),
     .cout(pcout[47]), .sum(psum[47]));
mul_csa32  sc4_46_ ( .c(c3[45]), .b(s3[46]), .a(ain[46]),
     .cout(pcout[46]), .sum(psum[46]));
mul_csa32  sc4_45_ ( .c(c3[44]), .b(s3[45]), .a(ain[45]),
     .cout(pcout[45]), .sum(psum[45]));
mul_csa32  sc4_44_ ( .c(c3[43]), .b(s3[44]), .a(ain[44]),
     .cout(pcout[44]), .sum(psum[44]));
mul_csa32  sc4_43_ ( .c(c3[42]), .b(s3[43]), .a(ain[43]),
     .cout(pcout[43]), .sum(psum[43]));
mul_csa32  sc4_42_ ( .c(c3[41]), .b(s3[42]), .a(ain[42]),
     .cout(pcout[42]), .sum(psum[42]));
mul_csa32  sc4_41_ ( .c(c3[40]), .b(s3[41]), .a(ain[41]),
     .cout(pcout[41]), .sum(psum[41]));
mul_csa32  sc4_40_ ( .c(c3[39]), .b(s3[40]), .a(ain[40]),
     .cout(pcout[40]), .sum(psum[40]));
mul_csa32  sc4_39_ ( .c(c3[38]), .b(s3[39]), .a(ain[39]),
     .cout(pcout[39]), .sum(psum[39]));
mul_csa32  sc4_38_ ( .c(c3[37]), .b(s3[38]), .a(ain[38]),
     .cout(pcout[38]), .sum(psum[38]));
mul_csa32  sc4_37_ ( .c(c3[36]), .b(s3[37]), .a(ain[37]),
     .cout(pcout[37]), .sum(psum[37]));
mul_csa32  sc4_36_ ( .c(c3[35]), .b(s3[36]), .a(ain[36]),
     .cout(pcout[36]), .sum(psum[36]));
mul_csa32  sc4_35_ ( .c(c3[34]), .b(s3[35]), .a(ain[35]),
     .cout(pcout[35]), .sum(psum[35]));
mul_csa32  sc4_34_ ( .c(c3[33]), .b(s3[34]), .a(ain[34]),
     .cout(pcout[34]), .sum(psum[34]));
mul_csa32  sc4_33_ ( .c(c3[32]), .b(s3[33]), .a(ain[33]),
     .cout(pcout[33]), .sum(psum[33]));
mul_csa32  sc4_32_ ( .c(c3[31]), .b(s3[32]), .a(ain[32]),
     .cout(pcout[32]), .sum(psum[32]));
mul_csa32  sc4_31_ ( .c(c3[30]), .b(s3[31]), .a(ain[31]),
     .cout(pcout[31]), .sum(psum[31]));
mul_csa32  sc4_30_ ( .c(c3[29]), .b(s3[30]), .a(ain[30]),
     .cout(pcout[30]), .sum(psum[30]));
mul_csa32  sc4_29_ ( .c(c3[28]), .b(s3[29]), .a(ain[29]),
     .cout(pcout[29]), .sum(psum[29]));
mul_csa32  sc4_28_ ( .c(c3[27]), .b(s3[28]), .a(ain[28]),
     .cout(pcout[28]), .sum(psum[28]));
mul_csa32  sc4_27_ ( .c(c3[26]), .b(s3[27]), .a(ain[27]),
     .cout(pcout[27]), .sum(psum[27]));
mul_csa32  sc4_26_ ( .c(c3[25]), .b(s3[26]), .a(ain[26]),
     .cout(pcout[26]), .sum(psum[26]));
mul_csa32  sc4_25_ ( .c(c3[24]), .b(s3[25]), .a(ain[25]),
     .cout(pcout[25]), .sum(psum[25]));
mul_csa32  sc4_24_ ( .c(c3[23]), .b(s3[24]), .a(ain[24]),
     .cout(pcout[24]), .sum(psum[24]));
mul_csa32  sc4_23_ ( .c(c3[22]), .b(s3[23]), .a(ain[23]),
     .cout(pcout[23]), .sum(psum[23]));
mul_csa32  sc4_22_ ( .c(c3[21]), .b(s3[22]), .a(ain[22]),
     .cout(pcout[22]), .sum(psum[22]));
mul_csa32  sc4_21_ ( .c(c3[20]), .b(s3[21]), .a(ain[21]),
     .cout(pcout[21]), .sum(psum[21]));
mul_csa32  sc4_20_ ( .c(c3[19]), .b(s3[20]), .a(ain[20]),
     .cout(pcout[20]), .sum(psum[20]));
mul_csa32  sc4_96_ ( .c(c2[95]), .b(s2[96]), .a(ain[96]),
     .cout(pcout[96]), .sum(psum[96]));
mul_csa32  sc4_95_ ( .c(c2[94]), .b(s2[95]), .a(ain[95]),
     .cout(pcout[95]), .sum(psum[95]));
mul_csa32  sc4_94_ ( .c(c2[93]), .b(s2[94]), .a(ain[94]),
     .cout(pcout[94]), .sum(psum[94]));
mul_csa32  sc4_93_ ( .c(c2[92]), .b(s2[93]), .a(ain[93]),
     .cout(pcout[93]), .sum(psum[93]));
mul_csa32  sc4_92_ ( .c(c2[91]), .b(s2[92]), .a(ain[92]),
     .cout(pcout[92]), .sum(psum[92]));
mul_csa32  sc4_91_ ( .c(c2[90]), .b(s2[91]), .a(ain[91]),
     .cout(pcout[91]), .sum(psum[91]));
mul_csa32  sc4_90_ ( .c(c2[89]), .b(s2[90]), .a(ain[90]),
     .cout(pcout[90]), .sum(psum[90]));
mul_csa32  sc4_89_ ( .c(c2[88]), .b(s2[89]), .a(ain[89]),
     .cout(pcout[89]), .sum(psum[89]));
mul_csa32  sc4_88_ ( .c(c2[87]), .b(s2[88]), .a(ain[88]),
     .cout(pcout[88]), .sum(psum[88]));
mul_csa32  sc4_87_ ( .c(c2[86]), .b(s2[87]), .a(ain[87]),
     .cout(pcout[87]), .sum(psum[87]));
mul_csa32  sc4_86_ ( .c(c2[85]), .b(s2[86]), .a(ain[86]),
     .cout(pcout[86]), .sum(psum[86]));
mul_csa32  sc4_85_ ( .c(c2[84]), .b(s2[85]), .a(ain[85]),
     .cout(pcout[85]), .sum(psum[85]));
mul_csa32  sc4_84_ ( .c(c2[83]), .b(s2[84]), .a(ain[84]),
     .cout(pcout[84]), .sum(psum[84]));
mul_csa32  sc4_81_ ( .c(c3[80]), .b(s3[81]), .a(ain[81]),
     .cout(pcout[81]), .sum(psum[81]));
mul_csa32  sc4_80_ ( .c(c3[79]), .b(s3[80]), .a(ain[80]),
     .cout(pcout[80]), .sum(psum[80]));
mul_csa32  sc4_79_ ( .c(c3[78]), .b(s3[79]), .a(ain[79]),
     .cout(pcout[79]), .sum(psum[79]));
mul_csa32  sc4_78_ ( .c(c3[77]), .b(s3[78]), .a(ain[78]),
     .cout(pcout[78]), .sum(psum[78]));
mul_csa32  sc4_77_ ( .c(c3[76]), .b(s3[77]), .a(ain[77]),
     .cout(pcout[77]), .sum(psum[77]));
mul_csa32  sc4_76_ ( .c(c3[75]), .b(s3[76]), .a(ain[76]),
     .cout(pcout[76]), .sum(psum[76]));
mul_csa32  sc4_75_ ( .c(c3[74]), .b(s3[75]), .a(ain[75]),
     .cout(pcout[75]), .sum(psum[75]));
mul_csa32  sc4_74_ ( .c(c3[73]), .b(s3[74]), .a(ain[74]),
     .cout(pcout[74]), .sum(psum[74]));
mul_csa32  sc4_73_ ( .c(c3[72]), .b(s3[73]), .a(ain[73]),
     .cout(pcout[73]), .sum(psum[73]));
mul_csa32  sc4_72_ ( .c(c3[71]), .b(s3[72]), .a(ain[72]),
     .cout(pcout[72]), .sum(psum[72]));
mul_csa32  sc4_71_ ( .c(c3[70]), .b(s3[71]), .a(ain[71]),
     .cout(pcout[71]), .sum(psum[71]));
mul_csa32  sc4_70_ ( .c(c3[69]), .b(s3[70]), .a(ain[70]),
     .cout(pcout[70]), .sum(psum[70]));
mul_csa32  sc4_69_ ( .c(c3[68]), .b(s3[69]), .a(ain[69]),
     .cout(pcout[69]), .sum(psum[69]));
mul_csa32  acc_4_ ( .c(c2[3]), .sum(psum[4]), .cout(pcout[4]),
     .a(ain[4]), .b(s2[4]));
mul_csa32  acc_3_ ( .c(c2[2]), .sum(psum[3]), .cout(pcout[3]),
     .a(ain[3]), .b(s2[3]));
mul_csa32  acc_2_ ( .c(c2[1]), .sum(psum[2]), .cout(pcout[2]),
     .a(ain[2]), .b(s2[2]));
mul_csa32  acc_1_ ( .c(c2[0]), .sum(psum[1]), .cout(pcout[1]),
     .a(ain[1]), .b(s2[1]));
mul_csa32  sc3_97_ ( .c(c2[96]), .sum(psum[97]), .cout(pcout[97]),
     .a(a1s[81]), .b(a1c[80]));
mul_csa32  sc1_19_ ( .c(a1s[3]), .b(pc[50]), .a(ps[51]),
     .cout(c1[19]), .sum(s1[19]));
mul_csa32  sc1_18_ ( .c(a1s[2]), .b(pc[49]), .a(ps[50]),
     .cout(c1[18]), .sum(s1[18]));
mul_csa32  sc1_17_ ( .c(a1s[1]), .b(pc[48]), .a(ps[49]),
     .cout(c1[17]), .sum(s1[17]));
mul_csa32  sc1_16_ ( .c(a1s[0]), .b(pc[47]), .a(ps[48]),
     .cout(c1[16]), .sum(s1[16]));
mul_csa32  sc1_15_ ( .c(1'b0), .b(pc[46]), .a(ps[47]),
     .cout(c1[15]), .sum(s1[15]));
mul_csa32  sc4_83_ ( .c(c2[82]), .b(s2[83]), .a(ain[83]),
     .cout(pcout[83]), .sum(psum[83]));
mul_csa32  sc2_83_ ( .c(c1[82]), .b(a1c[66]), .a(a1s[67]),
     .cout(c2[83]), .sum(s2[83]));
mul_csa32  sc2_19_ ( .c(a0c[18]), .b(a0s[19]), .a(s1[19]),
     .cout(c2[19]), .sum(s2[19]));
mul_csa32  sc2_18_ ( .c(a0c[17]), .b(a0s[18]), .a(s1[18]),
     .cout(c2[18]), .sum(s2[18]));
mul_csa32  sc2_17_ ( .c(a0c[16]), .b(a0s[17]), .a(s1[17]),
     .cout(c2[17]), .sum(s2[17]));
mul_csa32  sc2_16_ ( .c(a0c[15]), .b(a0s[16]), .a(s1[16]),
     .cout(c2[16]), .sum(s2[16]));
mul_csa32  sc2_15_ ( .c(a0c[14]), .b(a0s[15]), .a(s1[15]),
     .cout(c2[15]), .sum(s2[15]));
mul_csa32  sc1_81_ ( .c(a0s[81]), .b(a1c[64]), .a(a1s[65]),
     .cout(c1[81]), .sum(s1[81]));
mul_csa32  sc1_80_ ( .c(a0s[80]), .b(a1c[63]), .a(a1s[64]),
     .cout(c1[80]), .sum(s1[80]));
mul_csa32  sc1_79_ ( .c(a0s[79]), .b(a1c[62]), .a(a1s[63]),
     .cout(c1[79]), .sum(s1[79]));
mul_csa32  sc1_78_ ( .c(a0s[78]), .b(a1c[61]), .a(a1s[62]),
     .cout(c1[78]), .sum(s1[78]));
mul_csa32  sc1_77_ ( .c(a0s[77]), .b(a1c[60]), .a(a1s[61]),
     .cout(c1[77]), .sum(s1[77]));
mul_csa32  sc1_76_ ( .c(a0s[76]), .b(a1c[59]), .a(a1s[60]),
     .cout(c1[76]), .sum(s1[76]));
mul_csa32  sc1_75_ ( .c(a0s[75]), .b(a1c[58]), .a(a1s[59]),
     .cout(c1[75]), .sum(s1[75]));
mul_csa32  sc1_74_ ( .c(a0s[74]), .b(a1c[57]), .a(a1s[58]),
     .cout(c1[74]), .sum(s1[74]));
mul_csa32  sc1_73_ ( .c(a0s[73]), .b(a1c[56]), .a(a1s[57]),
     .cout(c1[73]), .sum(s1[73]));
mul_csa32  sc1_72_ ( .c(a0s[72]), .b(a1c[55]), .a(a1s[56]),
     .cout(c1[72]), .sum(s1[72]));
mul_csa32  sc1_71_ ( .c(a0s[71]), .b(a1c[54]), .a(a1s[55]),
     .cout(c1[71]), .sum(s1[71]));
mul_csa32  sc1_70_ ( .c(a0s[70]), .b(a1c[53]), .a(a1s[54]),
     .cout(c1[70]), .sum(s1[70]));
mul_csa32  sc1_69_ ( .c(a0s[69]), .b(a1c[52]), .a(a1s[53]),
     .cout(c1[69]), .sum(s1[69]));
mul_csa32  sc1_68_ ( .c(a0s[68]), .b(a1c[51]), .a(a1s[52]),
     .cout(c1[68]), .sum(s1[68]));
mul_csa32  sc3_19_ ( .c(c2[18]), .b(c1[18]), .a(s2[19]),
     .cout(c3[19]), .sum(s3[19]));
mul_csa32  sc3_18_ ( .c(c2[17]), .b(c1[17]), .a(s2[18]),
     .cout(c3[18]), .sum(s3[18]));
mul_csa32  sc3_17_ ( .c(c2[16]), .b(c1[16]), .a(s2[17]),
     .cout(c3[17]), .sum(s3[17]));
mul_csa32  sc3_16_ ( .c(c2[15]), .b(c1[15]), .a(s2[16]),
     .cout(c3[16]), .sum(s3[16]));
mul_csa32  sc3_15_ ( .c(c2[14]), .b(c1[14]), .a(s2[15]),
     .cout(c3[15]), .sum(s3[15]));
mul_csa32  sc1_82_ ( .c(a0c[81]), .b(a1c[65]), .a(a1s[66]),
     .cout(c1[82]), .sum(s1[82]));
mul_csa32  acc_14_ ( .c(c2[13]), .sum(psum[14]), .cout(pcout[14]),
     .a(ain[14]), .b(s2[14]));
mul_csa32  acc_13_ ( .c(c2[12]), .sum(psum[13]), .cout(pcout[13]),
     .a(ain[13]), .b(s2[13]));
mul_csa32  acc_12_ ( .c(c2[11]), .sum(psum[12]), .cout(pcout[12]),
     .a(ain[12]), .b(s2[12]));
mul_csa32  acc_11_ ( .c(c2[10]), .sum(psum[11]), .cout(pcout[11]),
     .a(ain[11]), .b(s2[11]));
mul_csa32  acc_10_ ( .c(c2[9]), .sum(psum[10]), .cout(pcout[10]),
     .a(ain[10]), .b(s2[10]));
mul_csa32  acc_9_ ( .c(c2[8]), .sum(psum[9]), .cout(pcout[9]),
     .a(ain[9]), .b(s2[9]));
mul_csa32  acc_8_ ( .c(c2[7]), .sum(psum[8]), .cout(pcout[8]),
     .a(ain[8]), .b(s2[8]));
mul_csa32  acc_7_ ( .c(c2[6]), .sum(psum[7]), .cout(pcout[7]),
     .a(ain[7]), .b(s2[7]));
mul_csa32  acc_6_ ( .c(c2[5]), .sum(psum[6]), .cout(pcout[6]),
     .a(ain[6]), .b(s2[6]));
mul_csa32  acc_5_ ( .c(c2[4]), .sum(psum[5]), .cout(pcout[5]),
     .a(ain[5]), .b(s2[5]));
mul_csa32  sc2_67_ ( .c(a0c[66]), .b(c1[66]), .a(a0s[67]),
     .cout(c2[67]), .sum(s2[67]));
mul_csa32  sc1_14_ ( .c(a0s[14]), .b(pc[45]), .a(ps[46]),
     .cout(c1[14]), .sum(s1[14]));
mul_csa32  sc1_13_ ( .c(a0s[13]), .b(pc[44]), .a(ps[45]),
     .cout(c1[13]), .sum(s1[13]));
mul_csa32  sc1_12_ ( .c(a0s[12]), .b(pc[43]), .a(ps[44]),
     .cout(c1[12]), .sum(s1[12]));
mul_csa32  sc1_11_ ( .c(a0s[11]), .b(pc[42]), .a(ps[43]),
     .cout(c1[11]), .sum(s1[11]));
mul_csa32  sc1_10_ ( .c(a0s[10]), .b(pc[41]), .a(ps[42]),
     .cout(c1[10]), .sum(s1[10]));
mul_csa32  sc1_9_ ( .c(a0s[9]), .b(pc[40]), .a(ps[41]), .cout(c1[9]),
     .sum(s1[9]));
mul_csa32  sc1_8_ ( .c(a0s[8]), .b(pc[39]), .a(ps[40]), .cout(c1[8]),
     .sum(s1[8]));
mul_csa32  sc1_7_ ( .c(a0s[7]), .b(pc[38]), .a(ps[39]), .cout(c1[7]),
     .sum(s1[7]));
mul_csa32  sc1_6_ ( .c(a0s[6]), .b(pc[37]), .a(ps[38]), .cout(c1[6]),
     .sum(s1[6]));
mul_csa32  sc1_5_ ( .c(a0s[5]), .b(pc[36]), .a(ps[37]), .cout(c1[5]),
     .sum(s1[5]));
mul_csa32  sc2_14_ ( .c(a0c[13]), .b(c1[13]), .a(s1[14]),
     .cout(c2[14]), .sum(s2[14]));
mul_csa32  sc2_13_ ( .c(a0c[12]), .b(c1[12]), .a(s1[13]),
     .cout(c2[13]), .sum(s2[13]));
mul_csa32  sc2_12_ ( .c(a0c[11]), .b(c1[11]), .a(s1[12]),
     .cout(c2[12]), .sum(s2[12]));
mul_csa32  sc2_11_ ( .c(a0c[10]), .b(c1[10]), .a(s1[11]),
     .cout(c2[11]), .sum(s2[11]));
mul_csa32  sc2_10_ ( .c(a0c[9]), .b(c1[9]), .a(s1[10]),
     .cout(c2[10]), .sum(s2[10]));
mul_csa32  sc2_9_ ( .c(a0c[8]), .b(c1[8]), .a(s1[9]), .cout(c2[9]),
     .sum(s2[9]));
mul_csa32  sc2_8_ ( .c(a0c[7]), .b(c1[7]), .a(s1[8]), .cout(c2[8]),
     .sum(s2[8]));
mul_csa32  sc2_7_ ( .c(a0c[6]), .b(c1[6]), .a(s1[7]), .cout(c2[7]),
     .sum(s2[7]));
mul_csa32  sc2_6_ ( .c(a0c[5]), .b(c1[5]), .a(s1[6]), .cout(c2[6]),
     .sum(s2[6]));
mul_csa32  sc2_5_ ( .c(a0c[4]), .b(c1[4]), .a(s1[5]), .cout(c2[5]),
     .sum(s2[5]));
mul_csa32  sc2_82_ ( .c(c2[81]), .b(c1[81]), .a(s1[82]),
     .cout(c2[82]), .sum(s2[82]));
mul_csa32  sc1_4_ ( .c(a0s[4]), .b(pc[35]), .a(ps[36]), .cout(c1[4]),
     .sum(s1[4]));
mul_csa32  sc1_3_ ( .c(a0s[3]), .b(pc[34]), .a(ps[35]), .cout(c1[3]),
     .sum(s1[3]));
mul_csa32  sc1_2_ ( .c(a0s[2]), .b(pc[33]), .a(ps[34]), .cout(c1[2]),
     .sum(s1[2]));
mul_csa32  sc1_1_ ( .c(a0s[1]), .b(pc[32]), .a(ps[33]), .cout(c1[1]),
     .sum(s1[1]));
mul_csa32  sc2_66_ ( .c(a0c[65]), .b(a0s[66]), .a(a1c[49]),
     .cout(c2[66]), .sum(s2[66]));
mul_csa32  sc2_65_ ( .c(a0c[64]), .b(a0s[65]), .a(a1c[48]),
     .cout(c2[65]), .sum(s2[65]));
mul_csa32  sc2_64_ ( .c(a0c[63]), .b(a0s[64]), .a(a1c[47]),
     .cout(c2[64]), .sum(s2[64]));
mul_csa32  sc2_63_ ( .c(a0c[62]), .b(a0s[63]), .a(a1c[46]),
     .cout(c2[63]), .sum(s2[63]));
mul_csa32  sc2_62_ ( .c(a0c[61]), .b(a0s[62]), .a(a1c[45]),
     .cout(c2[62]), .sum(s2[62]));
mul_csa32  sc2_61_ ( .c(a0c[60]), .b(a0s[61]), .a(a1c[44]),
     .cout(c2[61]), .sum(s2[61]));
mul_csa32  sc2_60_ ( .c(a0c[59]), .b(a0s[60]), .a(a1c[43]),
     .cout(c2[60]), .sum(s2[60]));
mul_csa32  sc2_59_ ( .c(a0c[58]), .b(a0s[59]), .a(a1c[42]),
     .cout(c2[59]), .sum(s2[59]));
mul_csa32  sc2_58_ ( .c(a0c[57]), .b(a0s[58]), .a(a1c[41]),
     .cout(c2[58]), .sum(s2[58]));
mul_csa32  sc2_57_ ( .c(a0c[56]), .b(a0s[57]), .a(a1c[40]),
     .cout(c2[57]), .sum(s2[57]));
mul_csa32  sc2_56_ ( .c(a0c[55]), .b(a0s[56]), .a(a1c[39]),
     .cout(c2[56]), .sum(s2[56]));
mul_csa32  sc2_55_ ( .c(a0c[54]), .b(a0s[55]), .a(a1c[38]),
     .cout(c2[55]), .sum(s2[55]));
mul_csa32  sc2_54_ ( .c(a0c[53]), .b(a0s[54]), .a(a1c[37]),
     .cout(c2[54]), .sum(s2[54]));
mul_csa32  sc2_53_ ( .c(a0c[52]), .b(a0s[53]), .a(a1c[36]),
     .cout(c2[53]), .sum(s2[53]));
mul_csa32  sc2_52_ ( .c(a0c[51]), .b(a0s[52]), .a(a1c[35]),
     .cout(c2[52]), .sum(s2[52]));
mul_csa32  sc2_51_ ( .c(a0c[50]), .b(a0s[51]), .a(a1c[34]),
     .cout(c2[51]), .sum(s2[51]));
mul_csa32  sc2_50_ ( .c(a0c[49]), .b(a0s[50]), .a(a1c[33]),
     .cout(c2[50]), .sum(s2[50]));
mul_csa32  sc2_49_ ( .c(a0c[48]), .b(a0s[49]), .a(a1c[32]),
     .cout(c2[49]), .sum(s2[49]));
mul_csa32  sc2_48_ ( .c(a0c[47]), .b(a0s[48]), .a(a1c[31]),
     .cout(c2[48]), .sum(s2[48]));
mul_csa32  sc2_47_ ( .c(a0c[46]), .b(a0s[47]), .a(a1c[30]),
     .cout(c2[47]), .sum(s2[47]));
mul_csa32  sc2_46_ ( .c(a0c[45]), .b(a0s[46]), .a(a1c[29]),
     .cout(c2[46]), .sum(s2[46]));
mul_csa32  sc2_45_ ( .c(a0c[44]), .b(a0s[45]), .a(a1c[28]),
     .cout(c2[45]), .sum(s2[45]));
mul_csa32  sc2_44_ ( .c(a0c[43]), .b(a0s[44]), .a(a1c[27]),
     .cout(c2[44]), .sum(s2[44]));
mul_csa32  sc2_43_ ( .c(a0c[42]), .b(a0s[43]), .a(a1c[26]),
     .cout(c2[43]), .sum(s2[43]));
mul_csa32  sc2_42_ ( .c(a0c[41]), .b(a0s[42]), .a(a1c[25]),
     .cout(c2[42]), .sum(s2[42]));
mul_csa32  sc2_41_ ( .c(a0c[40]), .b(a0s[41]), .a(a1c[24]),
     .cout(c2[41]), .sum(s2[41]));
mul_csa32  sc2_40_ ( .c(a0c[39]), .b(a0s[40]), .a(a1c[23]),
     .cout(c2[40]), .sum(s2[40]));
mul_csa32  sc2_39_ ( .c(a0c[38]), .b(a0s[39]), .a(a1c[22]),
     .cout(c2[39]), .sum(s2[39]));
mul_csa32  sc2_38_ ( .c(a0c[37]), .b(a0s[38]), .a(a1c[21]),
     .cout(c2[38]), .sum(s2[38]));
mul_csa32  sc2_37_ ( .c(a0c[36]), .b(a0s[37]), .a(a1c[20]),
     .cout(c2[37]), .sum(s2[37]));
mul_csa32  sc2_36_ ( .c(a0c[35]), .b(a0s[36]), .a(a1c[19]),
     .cout(c2[36]), .sum(s2[36]));
mul_csa32  sc2_35_ ( .c(a0c[34]), .b(a0s[35]), .a(a1c[18]),
     .cout(c2[35]), .sum(s2[35]));
mul_csa32  sc2_34_ ( .c(a0c[33]), .b(a0s[34]), .a(a1c[17]),
     .cout(c2[34]), .sum(s2[34]));
mul_csa32  sc2_33_ ( .c(a0c[32]), .b(a0s[33]), .a(a1c[16]),
     .cout(c2[33]), .sum(s2[33]));
mul_csa32  sc2_32_ ( .c(a0c[31]), .b(a0s[32]), .a(a1c[15]),
     .cout(c2[32]), .sum(s2[32]));
mul_csa32  sc2_31_ ( .c(a0c[30]), .b(a0s[31]), .a(a1c[14]),
     .cout(c2[31]), .sum(s2[31]));
mul_csa32  sc2_30_ ( .c(a0c[29]), .b(a0s[30]), .a(a1c[13]),
     .cout(c2[30]), .sum(s2[30]));
mul_csa32  sc2_29_ ( .c(a0c[28]), .b(a0s[29]), .a(a1c[12]),
     .cout(c2[29]), .sum(s2[29]));
mul_csa32  sc2_28_ ( .c(a0c[27]), .b(a0s[28]), .a(a1c[11]),
     .cout(c2[28]), .sum(s2[28]));
mul_csa32  sc2_27_ ( .c(a0c[26]), .b(a0s[27]), .a(a1c[10]),
     .cout(c2[27]), .sum(s2[27]));
mul_csa32  sc2_26_ ( .c(a0c[25]), .b(a0s[26]), .a(a1c[9]),
     .cout(c2[26]), .sum(s2[26]));
mul_csa32  sc2_25_ ( .c(a0c[24]), .b(a0s[25]), .a(a1c[8]),
     .cout(c2[25]), .sum(s2[25]));
mul_csa32  sc2_24_ ( .c(a0c[23]), .b(a0s[24]), .a(a1c[7]),
     .cout(c2[24]), .sum(s2[24]));
mul_csa32  sc2_23_ ( .c(a0c[22]), .b(a0s[23]), .a(a1c[6]),
     .cout(c2[23]), .sum(s2[23]));
mul_csa32  sc2_22_ ( .c(a0c[21]), .b(a0s[22]), .a(a1c[5]),
     .cout(c2[22]), .sum(s2[22]));
mul_csa32  sc2_21_ ( .c(a0c[20]), .b(a0s[21]), .a(a1c[4]),
     .cout(c2[21]), .sum(s2[21]));
mul_csa32  sc2_20_ ( .c(a0c[19]), .b(a0s[20]), .a(1'b0),
     .cout(c2[20]), .sum(s2[20]));
mul_csa32  sc1_66_ ( .c(a1s[50]), .b(pc[97]), .a(ps[98]),
     .cout(c1[66]), .sum(s1[66]));
mul_csa32  sc1_65_ ( .c(a1s[49]), .b(pc[96]), .a(ps[97]),
     .cout(c1[65]), .sum(s1[65]));
mul_csa32  sc1_64_ ( .c(a1s[48]), .b(pc[95]), .a(ps[96]),
     .cout(c1[64]), .sum(s1[64]));
mul_csa32  sc1_63_ ( .c(a1s[47]), .b(pc[94]), .a(ps[95]),
     .cout(c1[63]), .sum(s1[63]));
mul_csa32  sc1_62_ ( .c(a1s[46]), .b(pc[93]), .a(ps[94]),
     .cout(c1[62]), .sum(s1[62]));
mul_csa32  sc1_61_ ( .c(a1s[45]), .b(pc[92]), .a(ps[93]),
     .cout(c1[61]), .sum(s1[61]));
mul_csa32  sc1_60_ ( .c(a1s[44]), .b(pc[91]), .a(ps[92]),
     .cout(c1[60]), .sum(s1[60]));
mul_csa32  sc1_59_ ( .c(a1s[43]), .b(pc[90]), .a(ps[91]),
     .cout(c1[59]), .sum(s1[59]));
mul_csa32  sc1_58_ ( .c(a1s[42]), .b(pc[89]), .a(ps[90]),
     .cout(c1[58]), .sum(s1[58]));
mul_csa32  sc1_57_ ( .c(a1s[41]), .b(pc[88]), .a(ps[89]),
     .cout(c1[57]), .sum(s1[57]));
mul_csa32  sc1_56_ ( .c(a1s[40]), .b(pc[87]), .a(ps[88]),
     .cout(c1[56]), .sum(s1[56]));
mul_csa32  sc1_55_ ( .c(a1s[39]), .b(pc[86]), .a(ps[87]),
     .cout(c1[55]), .sum(s1[55]));
mul_csa32  sc1_54_ ( .c(a1s[38]), .b(pc[85]), .a(ps[86]),
     .cout(c1[54]), .sum(s1[54]));
mul_csa32  sc1_53_ ( .c(a1s[37]), .b(pc[84]), .a(ps[85]),
     .cout(c1[53]), .sum(s1[53]));
mul_csa32  sc1_52_ ( .c(a1s[36]), .b(pc[83]), .a(ps[84]),
     .cout(c1[52]), .sum(s1[52]));
mul_csa32  sc1_51_ ( .c(a1s[35]), .b(pc[82]), .a(ps[83]),
     .cout(c1[51]), .sum(s1[51]));
mul_csa32  sc1_50_ ( .c(a1s[34]), .b(pc[81]), .a(ps[82]),
     .cout(c1[50]), .sum(s1[50]));
mul_csa32  sc1_49_ ( .c(a1s[33]), .b(pc[80]), .a(ps[81]),
     .cout(c1[49]), .sum(s1[49]));
mul_csa32  sc1_48_ ( .c(a1s[32]), .b(pc[79]), .a(ps[80]),
     .cout(c1[48]), .sum(s1[48]));
mul_csa32  sc1_47_ ( .c(a1s[31]), .b(pc[78]), .a(ps[79]),
     .cout(c1[47]), .sum(s1[47]));
mul_csa32  sc1_46_ ( .c(a1s[30]), .b(pc[77]), .a(ps[78]),
     .cout(c1[46]), .sum(s1[46]));
mul_csa32  sc1_45_ ( .c(a1s[29]), .b(pc[76]), .a(ps[77]),
     .cout(c1[45]), .sum(s1[45]));
mul_csa32  sc1_44_ ( .c(a1s[28]), .b(pc[75]), .a(ps[76]),
     .cout(c1[44]), .sum(s1[44]));
mul_csa32  sc1_43_ ( .c(a1s[27]), .b(pc[74]), .a(ps[75]),
     .cout(c1[43]), .sum(s1[43]));
mul_csa32  sc1_42_ ( .c(a1s[26]), .b(pc[73]), .a(ps[74]),
     .cout(c1[42]), .sum(s1[42]));
mul_csa32  sc1_41_ ( .c(a1s[25]), .b(pc[72]), .a(ps[73]),
     .cout(c1[41]), .sum(s1[41]));
mul_csa32  sc1_40_ ( .c(a1s[24]), .b(pc[71]), .a(ps[72]),
     .cout(c1[40]), .sum(s1[40]));
mul_csa32  sc1_39_ ( .c(a1s[23]), .b(pc[70]), .a(ps[71]),
     .cout(c1[39]), .sum(s1[39]));
mul_csa32  sc1_38_ ( .c(a1s[22]), .b(pc[69]), .a(ps[70]),
     .cout(c1[38]), .sum(s1[38]));
mul_csa32  sc1_37_ ( .c(a1s[21]), .b(pc[68]), .a(ps[69]),
     .cout(c1[37]), .sum(s1[37]));
mul_csa32  sc1_36_ ( .c(a1s[20]), .b(pc[67]), .a(ps[68]),
     .cout(c1[36]), .sum(s1[36]));
mul_csa32  sc1_35_ ( .c(a1s[19]), .b(pc[66]), .a(ps[67]),
     .cout(c1[35]), .sum(s1[35]));
mul_csa32  sc1_34_ ( .c(a1s[18]), .b(pc[65]), .a(ps[66]),
     .cout(c1[34]), .sum(s1[34]));
mul_csa32  sc1_33_ ( .c(a1s[17]), .b(pc[64]), .a(ps[65]),
     .cout(c1[33]), .sum(s1[33]));
mul_csa32  sc1_32_ ( .c(a1s[16]), .b(pc[63]), .a(ps[64]),
     .cout(c1[32]), .sum(s1[32]));
mul_csa32  sc1_31_ ( .c(a1s[15]), .b(pc[62]), .a(ps[63]),
     .cout(c1[31]), .sum(s1[31]));
mul_csa32  sc1_30_ ( .c(a1s[14]), .b(pc[61]), .a(ps[62]),
     .cout(c1[30]), .sum(s1[30]));
mul_csa32  sc1_29_ ( .c(a1s[13]), .b(pc[60]), .a(ps[61]),
     .cout(c1[29]), .sum(s1[29]));
mul_csa32  sc1_28_ ( .c(a1s[12]), .b(pc[59]), .a(ps[60]),
     .cout(c1[28]), .sum(s1[28]));
mul_csa32  sc1_27_ ( .c(a1s[11]), .b(pc[58]), .a(ps[59]),
     .cout(c1[27]), .sum(s1[27]));
mul_csa32  sc1_26_ ( .c(a1s[10]), .b(pc[57]), .a(ps[58]),
     .cout(c1[26]), .sum(s1[26]));
mul_csa32  sc1_25_ ( .c(a1s[9]), .b(pc[56]), .a(ps[57]),
     .cout(c1[25]), .sum(s1[25]));
mul_csa32  sc1_24_ ( .c(a1s[8]), .b(pc[55]), .a(ps[56]),
     .cout(c1[24]), .sum(s1[24]));
mul_csa32  sc1_23_ ( .c(a1s[7]), .b(pc[54]), .a(ps[55]),
     .cout(c1[23]), .sum(s1[23]));
mul_csa32  sc1_22_ ( .c(a1s[6]), .b(pc[53]), .a(ps[54]),
     .cout(c1[22]), .sum(s1[22]));
mul_csa32  sc1_21_ ( .c(a1s[5]), .b(pc[52]), .a(ps[53]),
     .cout(c1[21]), .sum(s1[21]));
mul_csa32  sc1_20_ ( .c(a1s[4]), .b(pc[51]), .a(ps[52]),
     .cout(c1[20]), .sum(s1[20]));
mul_csa32  sc2_81_ ( .c(a0c[80]), .b(c1[80]), .a(s1[81]),
     .cout(c2[81]), .sum(s2[81]));
mul_csa32  sc2_80_ ( .c(a0c[79]), .b(c1[79]), .a(s1[80]),
     .cout(c2[80]), .sum(s2[80]));
mul_csa32  sc2_79_ ( .c(a0c[78]), .b(c1[78]), .a(s1[79]),
     .cout(c2[79]), .sum(s2[79]));
mul_csa32  sc2_78_ ( .c(a0c[77]), .b(c1[77]), .a(s1[78]),
     .cout(c2[78]), .sum(s2[78]));
mul_csa32  sc2_77_ ( .c(a0c[76]), .b(c1[76]), .a(s1[77]),
     .cout(c2[77]), .sum(s2[77]));
mul_csa32  sc2_76_ ( .c(a0c[75]), .b(c1[75]), .a(s1[76]),
     .cout(c2[76]), .sum(s2[76]));
mul_csa32  sc2_75_ ( .c(a0c[74]), .b(c1[74]), .a(s1[75]),
     .cout(c2[75]), .sum(s2[75]));
mul_csa32  sc2_74_ ( .c(a0c[73]), .b(c1[73]), .a(s1[74]),
     .cout(c2[74]), .sum(s2[74]));
mul_csa32  sc2_73_ ( .c(a0c[72]), .b(c1[72]), .a(s1[73]),
     .cout(c2[73]), .sum(s2[73]));
mul_csa32  sc2_72_ ( .c(a0c[71]), .b(c1[71]), .a(s1[72]),
     .cout(c2[72]), .sum(s2[72]));
mul_csa32  sc2_71_ ( .c(a0c[70]), .b(c1[70]), .a(s1[71]),
     .cout(c2[71]), .sum(s2[71]));
mul_csa32  sc2_70_ ( .c(a0c[69]), .b(c1[69]), .a(s1[70]),
     .cout(c2[70]), .sum(s2[70]));
mul_csa32  sc2_69_ ( .c(a0c[68]), .b(c1[68]), .a(s1[69]),
     .cout(c2[69]), .sum(s2[69]));
mul_csa32  sc2_68_ ( .c(a0c[67]), .b(c1[67]), .a(s1[68]),
     .cout(c2[68]), .sum(s2[68]));
mul_csa32  acc_19_ ( .c(c3[18]), .b(s3[19]), .a(ain[19]),
     .cout(pcout[19]), .sum(psum[19]));
mul_csa32  acc_18_ ( .c(c3[17]), .b(s3[18]), .a(ain[18]),
     .cout(pcout[18]), .sum(psum[18]));
mul_csa32  acc_17_ ( .c(c3[16]), .b(s3[17]), .a(ain[17]),
     .cout(pcout[17]), .sum(psum[17]));
mul_csa32  acc_16_ ( .c(c3[15]), .b(s3[16]), .a(ain[16]),
     .cout(pcout[16]), .sum(psum[16]));
mul_csa32  acc_15_ ( .c(1'b0), .b(s3[15]), .a(ain[15]),
     .cout(pcout[15]), .sum(psum[15]));
mul_csa32  sc1_0_ ( .c(a0s[0]), .sum(s1[0]), .cout(c1[0]),
     .a(ps[32]), .b(pc[31]));
mul_csa32  sc1_67_ ( .c(a1c[50]), .b(pc[98]), .a(a1s[51]),
     .cout(c1[67]), .sum(s1[67]));
mul_ha acc_0_ ( .sum(psum[0]), .cout(pcout[0]), .a(ain[0]),
     .b(s2[0]));
mul_ha sc3_98_ ( .sum(psum[98]), .cout(pcout[98]), .a(bot),
     .b(a1c[81]));
mul_ha sc2_96_ ( .b(a1c[79]), .a(a1s[80]), .cout(c2[96]),
     .sum(s2[96]));
mul_ha sc2_95_ ( .b(a1c[78]), .a(a1s[79]), .cout(c2[95]),
     .sum(s2[95]));
mul_ha sc2_94_ ( .b(a1c[77]), .a(a1s[78]), .cout(c2[94]),
     .sum(s2[94]));
mul_ha sc2_93_ ( .b(a1c[76]), .a(a1s[77]), .cout(c2[93]),
     .sum(s2[93]));
mul_ha sc2_92_ ( .b(a1c[75]), .a(a1s[76]), .cout(c2[92]),
     .sum(s2[92]));
mul_ha sc2_91_ ( .b(a1c[74]), .a(a1s[75]), .cout(c2[91]),
     .sum(s2[91]));
mul_ha sc2_90_ ( .b(a1c[73]), .a(a1s[74]), .cout(c2[90]),
     .sum(s2[90]));
mul_ha sc2_89_ ( .b(a1c[72]), .a(a1s[73]), .cout(c2[89]),
     .sum(s2[89]));
mul_ha sc2_88_ ( .b(a1c[71]), .a(a1s[72]), .cout(c2[88]),
     .sum(s2[88]));
mul_ha sc2_87_ ( .b(a1c[70]), .a(a1s[71]), .cout(c2[87]),
     .sum(s2[87]));
mul_ha sc2_86_ ( .b(a1c[69]), .a(a1s[70]), .cout(c2[86]),
     .sum(s2[86]));
mul_ha sc2_85_ ( .b(a1c[68]), .a(a1s[69]), .cout(c2[85]),
     .sum(s2[85]));
mul_ha sc2_84_ ( .b(a1c[67]), .a(a1s[68]), .cout(c2[84]),
     .sum(s2[84]));
mul_ha sc3_81_ ( .b(c2[80]), .a(s2[81]), .cout(c3[81]),
     .sum(s3[81]));
mul_ha sc3_80_ ( .b(c2[79]), .a(s2[80]), .cout(c3[80]),
     .sum(s3[80]));
mul_ha sc3_79_ ( .b(c2[78]), .a(s2[79]), .cout(c3[79]),
     .sum(s3[79]));
mul_ha sc3_78_ ( .b(c2[77]), .a(s2[78]), .cout(c3[78]),
     .sum(s3[78]));
mul_ha sc3_77_ ( .b(c2[76]), .a(s2[77]), .cout(c3[77]),
     .sum(s3[77]));
mul_ha sc3_76_ ( .b(c2[75]), .a(s2[76]), .cout(c3[76]),
     .sum(s3[76]));
mul_ha sc3_75_ ( .b(c2[74]), .a(s2[75]), .cout(c3[75]),
     .sum(s3[75]));
mul_ha sc3_74_ ( .b(c2[73]), .a(s2[74]), .cout(c3[74]),
     .sum(s3[74]));
mul_ha sc3_73_ ( .b(c2[72]), .a(s2[73]), .cout(c3[73]),
     .sum(s3[73]));
mul_ha sc3_72_ ( .b(c2[71]), .a(s2[72]), .cout(c3[72]),
     .sum(s3[72]));
mul_ha sc3_71_ ( .b(c2[70]), .a(s2[71]), .cout(c3[71]),
     .sum(s3[71]));
mul_ha sc3_70_ ( .b(c2[69]), .a(s2[70]), .cout(c3[70]),
     .sum(s3[70]));
mul_ha sc3_69_ ( .b(c2[68]), .a(s2[69]), .cout(c3[69]),
     .sum(s3[69]));
mul_ha accx2 ( .sum(psumx2), .cout(pcoutx2), .a(ainx2), .b(s1x2));
mul_ha sc2_4_ ( .sum(s2[4]), .cout(c2[4]), .a(s1[4]), .b(c1[3]));
mul_ha sc2_3_ ( .sum(s2[3]), .cout(c2[3]), .a(s1[3]), .b(c1[2]));
mul_ha sc2_2_ ( .sum(s2[2]), .cout(c2[2]), .a(s1[2]), .b(c1[1]));
mul_ha sc2_1_ ( .sum(s2[1]), .cout(c2[1]), .a(s1[1]), .b(c1[0]));
mul_ha sc2_0_ ( .sum(s2[0]), .cout(c2[0]), .a(s1[0]), .b(c1x2));
mul_ha sc1x2 ( .sum(s1x2), .cout(c1x2), .a(ps[31]), .b(pc[30]));

endmodule //mul_array2

module mul_csa32 (sum, cout, a, b, c);

output sum, cout;
input a, b, c;

wire x, y0, y1, y2;

assign x = a ^ b;
assign sum = c ^ x;

assign y0 = a & b ;
assign y1 = a & c ;
assign y2 = b & c ;

assign cout = y0 | y1 | y2 ;

endmodule //mul_csa32

module mul_csa42 (sum, carry, cout, a, b, c, d, cin);

output sum, carry, cout;
input a, b, c, d, cin;

wire x, y, z;

assign x = a ^ b;
assign y = c ^ d;
assign z = x ^ y;

assign sum = z ^ cin ;

assign carry = (b & ~z) | (cin & z);

assign cout = (d & ~y) | (a & y);

endmodule // mul_csa42

module mul_ha ( cout, sum, a, b );
output  cout, sum;
input  a, b;

assign sum = a ^ b;
assign cout = a & b ;

endmodule //mul_ha

module mul_negen ( n0, n1, b );
output  n0, n1;
input [2:0]  b;

assign n0 = b[2] & b[1] & ~b[0] ;
assign n1 = b[2] & b[1] & b[0] ;

endmodule //mul_negen

module mul_ppgen3lsb4 (cout, p0_l, p1_l, sum, a, b0, b1 );

output  p0_l, p1_l;
output [3:0]  sum;
output [3:1]  cout;
input [3:0]  a;
input [2:0]  b0;
input [2:0]  b1;

wire b0n, b0n_0, b0n_1, b1n_0, b1n_1;
wire p0_0, p0_1, p0_2, p0_3, p1_2, p1_3;
wire p0_l_0, p0_l_1, p0_l_2, p1_l_2;

assign b0n = b0n_1 | (b0n_0 & p0_0) ;
assign sum[0] = b0n_0 ^ p0_0 ;

mul_negen p0n ( .b(b0[2:0]), .n1(b0n_1), .n0(b0n_0));
mul_negen p1n ( .b(b1[2:0]), .n1(b1n_1), .n0(b1n_0));
mul_csa32  sc1_2_ ( .c(b1n_0), .sum(sum[2]), .cout(cout[2]),
     .a(p0_2), .b(p1_2));
mul_csa32  sc1_3_ ( .c(b1n_1), .sum(sum[3]), .cout(cout[3]),
     .a(p0_3), .b(p1_3));
mul_ha sc1_1_ ( .sum(sum[1]), .cout(cout[1]), .a(p0_1),
     .b(b0n));
mul_ppgen p0_3_ ( .pm1_l(p0_l_2), .p_l(p0_l), .b(b0[2:0]), .a(a[3]),
     .z(p0_3));
mul_ppgen p1_3_ ( .pm1_l(p1_l_2), .p_l(p1_l), .b(b1[2:0]), .a(a[1]),
     .z(p1_3));
mul_ppgen p0_2_ ( .pm1_l(p0_l_1), .p_l(p0_l_2), .b(b0[2:0]),
     .a(a[2]), .z(p0_2));
mul_ppgen p0_1_ ( .pm1_l(p0_l_0), .p_l(p0_l_1), .b(b0[2:0]),
     .a(a[1]), .z(p0_1));
mul_ppgen p0_0_ ( .pm1_l(1'b1), .p_l(p0_l_0),
     .b(b0[2:0]), .a(a[0]), .z(p0_0));
mul_ppgen p1_2_ ( .pm1_l(1'b1), .p_l(p1_l_2),
     .b(b1[2:0]), .a(a[0]), .z(p1_2));

endmodule // mul_ppgen3lsb4

module mul_ppgen3sign ( cout, sum, am1, am2, am3, am4, b0, b1, b2,
     bot, head, p0m1_l, p1m1_l, p2m1_l );
input  am1, am2, am3, am4;
input  bot, head, p0m1_l, p1m1_l, p2m1_l;
output [5:0]  sum;
output [4:0]  cout;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net37, net42, net075, net088, net0117; 
wire net47, net073, net38, net0118, net078, net8, net15, net43, net48, net35;
wire p2_l_67, p2_l_66, p2_l_65, p2_l_64; 
wire p1_l_65, p1_l_64; 

assign sum[5] = bot & net075 ;
assign net0117 = head & net088 ; 
assign net37 = ~net0117 ;
assign net42 = head ^ net088 ;

mul_ppgensign p0_64_ ( .b(b0[2:0]), .z(net47), .p_l(net088),
     .pm1_l(p0m1_l));
mul_ppgensign p2_68_ ( .pm1_l(p2_l_67), .b(b2[2:0]), .z(net073),
     .p_l(net075));
mul_ppgensign p1_66_ ( .pm1_l(p1_l_65), .b(b1[2:0]), .z(net38),
     .p_l(net0118));
mul_ha sc1_68_ ( .b(net073), .a(1'b1), .cout(cout[4]),
     .sum(sum[4]));
mul_ppgen p2_67_ ( .pm1_l(p2_l_66), .b(b2[2:0]), .a(am1), .z(net078),
     .p_l(p2_l_67));
mul_ppgen p2_66_ ( .pm1_l(p2_l_65), .b(b2[2:0]), .a(am2), .z(net8),
     .p_l(p2_l_66));
mul_ppgen p2_65_ ( .pm1_l(p2_l_64), .p_l(p2_l_65), .b(b2[2:0]),
     .a(am3), .z(net15));
mul_ppgen p1_65_ ( .pm1_l(p1_l_64), .p_l(p1_l_65), .b(b1[2:0]),
     .a(am1), .z(net43));
mul_ppgen p1_64_ ( .pm1_l(p1m1_l), .p_l(p1_l_64), .b(b1[2:0]),
     .a(am2), .z(net48));
mul_ppgen p2_64_ ( .pm1_l(p2m1_l), .p_l(p2_l_64), .b(b2[2:0]),
     .a(am4), .z(net35));
mul_csa32  sc1_67_ ( .c(net078), .b(net0117), .a(net0118),
     .cout(cout[3]), .sum(sum[3]));
mul_csa32  sc1_66_ ( .c(net8), .b(net37), .a(net38), .cout(cout[2]),
     .sum(sum[2]));
mul_csa32  sc1_65_ ( .c(net15), .b(net42), .a(net43), .cout(cout[1]),
     .sum(sum[1]));
mul_csa32  sc1_64_ ( .c(net35), .b(net47), .a(net48), .cout(cout[0]),
     .sum(sum[0]));

endmodule //mul_ppgen3sign

module mul_ppgen3 ( cout, p0_l, p1_l, p2_l, sum, am2, am4,
     a, b0, b1, b2, p0m1_l, p1m1_l, p2m1_l );
output  cout, p0_l, p1_l, p2_l, sum;
input  am2, am4;
input  a, p0m1_l, p1m1_l, p2m1_l;
input [2:0]  b0;
input [2:0]  b2;
input [2:0]  b1;

wire net046, net32, net043;

mul_csa32  sc1 ( .a(net046), .b(net32), .cout(cout), .sum(sum),
     .c(net043));
mul_ppgen p2 ( .pm1_l(p2m1_l), .p_l(p2_l), .b(b2[2:0]), .a(am4),
     .z(net043));
mul_ppgen p1 ( .pm1_l(p1m1_l), .p_l(p1_l), .b(b1[2:0]), .a(am2),
     .z(net046));
mul_ppgen p0 ( .pm1_l(p0m1_l), .p_l(p0_l), .b(b0[2:0]), .a(a),
     .z(net32));

endmodule // mul_ppgen3

module mul_ppgenrow3 ( cout, sum, a, b0, b1, b2, bot, head );

output [68:1]  cout;
output [69:0]  sum;
input [63:0]  a;
input [2:0]  b2;
input [2:0]  b0;
input [2:0]  b1;
input  bot, head;

// Buses in the design
wire  [63:4]  p2_l;
wire  [63:3]  p1_l;
wire  [63:3]  p0_l;

mul_ppgen3sign I2 ( .am4(a[60]), .am3(a[61]), .am2(a[62]),
     .am1(a[63]), .p2m1_l(p2_l[63]), .p1m1_l(p1_l[63]),
     .p0m1_l(p0_l[63]), .b2(b2[2:0]), .head(head), .bot(bot),
     .sum(sum[69:64]), .cout(cout[68:64]), .b1(b1[2:0]), .b0(b0[2:0]));
mul_ppgen3 I1_63_ ( .p2_l(p2_l[63]), .b2(b2[2:0]),
     .am2(a[61]), .a(a[63]), .p2m1_l(p2_l[62]),
     .p1m1_l(p1_l[62]), .p0m1_l(p0_l[62]), .am4(a[59]), .sum(sum[63]),
     .cout(cout[63]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[63]),
     .p0_l(p0_l[63]));
mul_ppgen3 I1_62_ ( .p2_l(p2_l[62]), .b2(b2[2:0]), 
     .am2(a[60]), .a(a[62]), .p2m1_l(p2_l[61]),
     .p1m1_l(p1_l[61]), .p0m1_l(p0_l[61]), .am4(a[58]), .sum(sum[62]),
     .cout(cout[62]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[62]),
     .p0_l(p0_l[62]));
mul_ppgen3 I1_61_ ( .p2_l(p2_l[61]), .b2(b2[2:0]), 
     .am2(a[59]), .a(a[61]), .p2m1_l(p2_l[60]),
     .p1m1_l(p1_l[60]), .p0m1_l(p0_l[60]), .am4(a[57]), .sum(sum[61]),
     .cout(cout[61]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[61]),
     .p0_l(p0_l[61]));
mul_ppgen3 I1_60_ ( .p2_l(p2_l[60]), .b2(b2[2:0]), 
     .am2(a[58]), .a(a[60]), .p2m1_l(p2_l[59]),
     .p1m1_l(p1_l[59]), .p0m1_l(p0_l[59]), .am4(a[56]), .sum(sum[60]),
     .cout(cout[60]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[60]),
     .p0_l(p0_l[60]));
mul_ppgen3 I1_59_ ( .p2_l(p2_l[59]), .b2(b2[2:0]), 
     .am2(a[57]), .a(a[59]), .p2m1_l(p2_l[58]),
     .p1m1_l(p1_l[58]), .p0m1_l(p0_l[58]), .am4(a[55]), .sum(sum[59]),
     .cout(cout[59]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[59]),
     .p0_l(p0_l[59]));
mul_ppgen3 I1_58_ ( .p2_l(p2_l[58]), .b2(b2[2:0]), 
     .am2(a[56]), .a(a[58]), .p2m1_l(p2_l[57]),
     .p1m1_l(p1_l[57]), .p0m1_l(p0_l[57]), .am4(a[54]), .sum(sum[58]),
     .cout(cout[58]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[58]),
     .p0_l(p0_l[58]));
mul_ppgen3 I1_57_ ( .p2_l(p2_l[57]), .b2(b2[2:0]), 
     .am2(a[55]), .a(a[57]), .p2m1_l(p2_l[56]),
     .p1m1_l(p1_l[56]), .p0m1_l(p0_l[56]), .am4(a[53]), .sum(sum[57]),
     .cout(cout[57]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[57]),
     .p0_l(p0_l[57]));
mul_ppgen3 I1_56_ ( .p2_l(p2_l[56]), .b2(b2[2:0]), 
     .am2(a[54]), .a(a[56]), .p2m1_l(p2_l[55]),
     .p1m1_l(p1_l[55]), .p0m1_l(p0_l[55]), .am4(a[52]), .sum(sum[56]),
     .cout(cout[56]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[56]),
     .p0_l(p0_l[56]));
mul_ppgen3 I1_55_ ( .p2_l(p2_l[55]), .b2(b2[2:0]), 
     .am2(a[53]), .a(a[55]), .p2m1_l(p2_l[54]),
     .p1m1_l(p1_l[54]), .p0m1_l(p0_l[54]), .am4(a[51]), .sum(sum[55]),
     .cout(cout[55]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[55]),
     .p0_l(p0_l[55]));
mul_ppgen3 I1_54_ ( .p2_l(p2_l[54]), .b2(b2[2:0]), 
     .am2(a[52]), .a(a[54]), .p2m1_l(p2_l[53]),
     .p1m1_l(p1_l[53]), .p0m1_l(p0_l[53]), .am4(a[50]), .sum(sum[54]),
     .cout(cout[54]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[54]),
     .p0_l(p0_l[54]));
mul_ppgen3 I1_53_ ( .p2_l(p2_l[53]), .b2(b2[2:0]), 
     .am2(a[51]), .a(a[53]), .p2m1_l(p2_l[52]),
     .p1m1_l(p1_l[52]), .p0m1_l(p0_l[52]), .am4(a[49]), .sum(sum[53]),
     .cout(cout[53]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[53]),
     .p0_l(p0_l[53]));
mul_ppgen3 I1_52_ ( .p2_l(p2_l[52]), .b2(b2[2:0]), 
     .am2(a[50]), .a(a[52]), .p2m1_l(p2_l[51]),
     .p1m1_l(p1_l[51]), .p0m1_l(p0_l[51]), .am4(a[48]), .sum(sum[52]),
     .cout(cout[52]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[52]),
     .p0_l(p0_l[52]));
mul_ppgen3 I1_51_ ( .p2_l(p2_l[51]), .b2(b2[2:0]), 
     .am2(a[49]), .a(a[51]), .p2m1_l(p2_l[50]),
     .p1m1_l(p1_l[50]), .p0m1_l(p0_l[50]), .am4(a[47]), .sum(sum[51]),
     .cout(cout[51]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[51]),
     .p0_l(p0_l[51]));
mul_ppgen3 I1_50_ ( .p2_l(p2_l[50]), .b2(b2[2:0]), 
     .am2(a[48]), .a(a[50]), .p2m1_l(p2_l[49]),
     .p1m1_l(p1_l[49]), .p0m1_l(p0_l[49]), .am4(a[46]), .sum(sum[50]),
     .cout(cout[50]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[50]),
     .p0_l(p0_l[50]));
mul_ppgen3 I1_49_ ( .p2_l(p2_l[49]), .b2(b2[2:0]), 
     .am2(a[47]), .a(a[49]), .p2m1_l(p2_l[48]),
     .p1m1_l(p1_l[48]), .p0m1_l(p0_l[48]), .am4(a[45]), .sum(sum[49]),
     .cout(cout[49]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[49]),
     .p0_l(p0_l[49]));
mul_ppgen3 I1_48_ ( .p2_l(p2_l[48]), .b2(b2[2:0]), 
     .am2(a[46]), .a(a[48]), .p2m1_l(p2_l[47]),
     .p1m1_l(p1_l[47]), .p0m1_l(p0_l[47]), .am4(a[44]), .sum(sum[48]),
     .cout(cout[48]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[48]),
     .p0_l(p0_l[48]));
mul_ppgen3 I1_47_ ( .p2_l(p2_l[47]), .b2(b2[2:0]), 
     .am2(a[45]), .a(a[47]), .p2m1_l(p2_l[46]),
     .p1m1_l(p1_l[46]), .p0m1_l(p0_l[46]), .am4(a[43]), .sum(sum[47]),
     .cout(cout[47]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[47]),
     .p0_l(p0_l[47]));
mul_ppgen3 I1_46_ ( .p2_l(p2_l[46]), .b2(b2[2:0]), 
     .am2(a[44]), .a(a[46]), .p2m1_l(p2_l[45]),
     .p1m1_l(p1_l[45]), .p0m1_l(p0_l[45]), .am4(a[42]), .sum(sum[46]),
     .cout(cout[46]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[46]),
     .p0_l(p0_l[46]));
mul_ppgen3 I1_45_ ( .p2_l(p2_l[45]), .b2(b2[2:0]), 
     .am2(a[43]), .a(a[45]), .p2m1_l(p2_l[44]),
     .p1m1_l(p1_l[44]), .p0m1_l(p0_l[44]), .am4(a[41]), .sum(sum[45]),
     .cout(cout[45]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[45]),
     .p0_l(p0_l[45]));
mul_ppgen3 I1_44_ ( .p2_l(p2_l[44]), .b2(b2[2:0]), 
     .am2(a[42]), .a(a[44]), .p2m1_l(p2_l[43]),
     .p1m1_l(p1_l[43]), .p0m1_l(p0_l[43]), .am4(a[40]), .sum(sum[44]),
     .cout(cout[44]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[44]),
     .p0_l(p0_l[44]));
mul_ppgen3 I1_43_ ( .p2_l(p2_l[43]), .b2(b2[2:0]), 
     .am2(a[41]), .a(a[43]), .p2m1_l(p2_l[42]),
     .p1m1_l(p1_l[42]), .p0m1_l(p0_l[42]), .am4(a[39]), .sum(sum[43]),
     .cout(cout[43]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[43]),
     .p0_l(p0_l[43]));
mul_ppgen3 I1_42_ ( .p2_l(p2_l[42]), .b2(b2[2:0]), 
     .am2(a[40]), .a(a[42]), .p2m1_l(p2_l[41]),
     .p1m1_l(p1_l[41]), .p0m1_l(p0_l[41]), .am4(a[38]), .sum(sum[42]),
     .cout(cout[42]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[42]),
     .p0_l(p0_l[42]));
mul_ppgen3 I1_41_ ( .p2_l(p2_l[41]), .b2(b2[2:0]), 
     .am2(a[39]), .a(a[41]), .p2m1_l(p2_l[40]),
     .p1m1_l(p1_l[40]), .p0m1_l(p0_l[40]), .am4(a[37]), .sum(sum[41]),
     .cout(cout[41]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[41]),
     .p0_l(p0_l[41]));
mul_ppgen3 I1_40_ ( .p2_l(p2_l[40]), .b2(b2[2:0]), 
     .am2(a[38]), .a(a[40]), .p2m1_l(p2_l[39]),
     .p1m1_l(p1_l[39]), .p0m1_l(p0_l[39]), .am4(a[36]), .sum(sum[40]),
     .cout(cout[40]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[40]),
     .p0_l(p0_l[40]));
mul_ppgen3 I1_39_ ( .p2_l(p2_l[39]), .b2(b2[2:0]), 
     .am2(a[37]), .a(a[39]), .p2m1_l(p2_l[38]),
     .p1m1_l(p1_l[38]), .p0m1_l(p0_l[38]), .am4(a[35]), .sum(sum[39]),
     .cout(cout[39]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[39]),
     .p0_l(p0_l[39]));
mul_ppgen3 I1_38_ ( .p2_l(p2_l[38]), .b2(b2[2:0]), 
     .am2(a[36]), .a(a[38]), .p2m1_l(p2_l[37]),
     .p1m1_l(p1_l[37]), .p0m1_l(p0_l[37]), .am4(a[34]), .sum(sum[38]),
     .cout(cout[38]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[38]),
     .p0_l(p0_l[38]));
mul_ppgen3 I1_37_ ( .p2_l(p2_l[37]), .b2(b2[2:0]), 
     .am2(a[35]), .a(a[37]), .p2m1_l(p2_l[36]),
     .p1m1_l(p1_l[36]), .p0m1_l(p0_l[36]), .am4(a[33]), .sum(sum[37]),
     .cout(cout[37]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[37]),
     .p0_l(p0_l[37]));
mul_ppgen3 I1_36_ ( .p2_l(p2_l[36]), .b2(b2[2:0]), 
     .am2(a[34]), .a(a[36]), .p2m1_l(p2_l[35]),
     .p1m1_l(p1_l[35]), .p0m1_l(p0_l[35]), .am4(a[32]), .sum(sum[36]),
     .cout(cout[36]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[36]),
     .p0_l(p0_l[36]));
mul_ppgen3 I1_35_ ( .p2_l(p2_l[35]), .b2(b2[2:0]), 
     .am2(a[33]), .a(a[35]), .p2m1_l(p2_l[34]),
     .p1m1_l(p1_l[34]), .p0m1_l(p0_l[34]), .am4(a[31]), .sum(sum[35]),
     .cout(cout[35]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[35]),
     .p0_l(p0_l[35]));
mul_ppgen3 I1_34_ ( .p2_l(p2_l[34]), .b2(b2[2:0]), 
     .am2(a[32]), .a(a[34]), .p2m1_l(p2_l[33]),
     .p1m1_l(p1_l[33]), .p0m1_l(p0_l[33]), .am4(a[30]), .sum(sum[34]),
     .cout(cout[34]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[34]),
     .p0_l(p0_l[34]));
mul_ppgen3 I1_33_ ( .p2_l(p2_l[33]), .b2(b2[2:0]), 
     .am2(a[31]), .a(a[33]), .p2m1_l(p2_l[32]),
     .p1m1_l(p1_l[32]), .p0m1_l(p0_l[32]), .am4(a[29]), .sum(sum[33]),
     .cout(cout[33]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[33]),
     .p0_l(p0_l[33]));
mul_ppgen3 I1_32_ ( .p2_l(p2_l[32]), .b2(b2[2:0]), 
     .am2(a[30]), .a(a[32]), .p2m1_l(p2_l[31]),
     .p1m1_l(p1_l[31]), .p0m1_l(p0_l[31]), .am4(a[28]), .sum(sum[32]),
     .cout(cout[32]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[32]),
     .p0_l(p0_l[32]));
mul_ppgen3 I1_31_ ( .p2_l(p2_l[31]), .b2(b2[2:0]), 
     .am2(a[29]), .a(a[31]), .p2m1_l(p2_l[30]),
     .p1m1_l(p1_l[30]), .p0m1_l(p0_l[30]), .am4(a[27]), .sum(sum[31]),
     .cout(cout[31]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[31]),
     .p0_l(p0_l[31]));
mul_ppgen3 I1_30_ ( .p2_l(p2_l[30]), .b2(b2[2:0]), 
     .am2(a[28]), .a(a[30]), .p2m1_l(p2_l[29]),
     .p1m1_l(p1_l[29]), .p0m1_l(p0_l[29]), .am4(a[26]), .sum(sum[30]),
     .cout(cout[30]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[30]),
     .p0_l(p0_l[30]));
mul_ppgen3 I1_29_ ( .p2_l(p2_l[29]), .b2(b2[2:0]), 
     .am2(a[27]), .a(a[29]), .p2m1_l(p2_l[28]),
     .p1m1_l(p1_l[28]), .p0m1_l(p0_l[28]), .am4(a[25]), .sum(sum[29]),
     .cout(cout[29]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[29]),
     .p0_l(p0_l[29]));
mul_ppgen3 I1_28_ ( .p2_l(p2_l[28]), .b2(b2[2:0]), 
     .am2(a[26]), .a(a[28]), .p2m1_l(p2_l[27]),
     .p1m1_l(p1_l[27]), .p0m1_l(p0_l[27]), .am4(a[24]), .sum(sum[28]),
     .cout(cout[28]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[28]),
     .p0_l(p0_l[28]));
mul_ppgen3 I1_27_ ( .p2_l(p2_l[27]), .b2(b2[2:0]), 
     .am2(a[25]), .a(a[27]), .p2m1_l(p2_l[26]),
     .p1m1_l(p1_l[26]), .p0m1_l(p0_l[26]), .am4(a[23]), .sum(sum[27]),
     .cout(cout[27]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[27]),
     .p0_l(p0_l[27]));
mul_ppgen3 I1_26_ ( .p2_l(p2_l[26]), .b2(b2[2:0]), 
     .am2(a[24]), .a(a[26]), .p2m1_l(p2_l[25]),
     .p1m1_l(p1_l[25]), .p0m1_l(p0_l[25]), .am4(a[22]), .sum(sum[26]),
     .cout(cout[26]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[26]),
     .p0_l(p0_l[26]));
mul_ppgen3 I1_25_ ( .p2_l(p2_l[25]), .b2(b2[2:0]), 
     .am2(a[23]), .a(a[25]), .p2m1_l(p2_l[24]),
     .p1m1_l(p1_l[24]), .p0m1_l(p0_l[24]), .am4(a[21]), .sum(sum[25]),
     .cout(cout[25]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[25]),
     .p0_l(p0_l[25]));
mul_ppgen3 I1_24_ ( .p2_l(p2_l[24]), .b2(b2[2:0]), 
     .am2(a[22]), .a(a[24]), .p2m1_l(p2_l[23]),
     .p1m1_l(p1_l[23]), .p0m1_l(p0_l[23]), .am4(a[20]), .sum(sum[24]),
     .cout(cout[24]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[24]),
     .p0_l(p0_l[24]));
mul_ppgen3 I1_23_ ( .p2_l(p2_l[23]), .b2(b2[2:0]), 
     .am2(a[21]), .a(a[23]), .p2m1_l(p2_l[22]),
     .p1m1_l(p1_l[22]), .p0m1_l(p0_l[22]), .am4(a[19]), .sum(sum[23]),
     .cout(cout[23]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[23]),
     .p0_l(p0_l[23]));
mul_ppgen3 I1_22_ ( .p2_l(p2_l[22]), .b2(b2[2:0]), 
     .am2(a[20]), .a(a[22]), .p2m1_l(p2_l[21]),
     .p1m1_l(p1_l[21]), .p0m1_l(p0_l[21]), .am4(a[18]), .sum(sum[22]),
     .cout(cout[22]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[22]),
     .p0_l(p0_l[22]));
mul_ppgen3 I1_21_ ( .p2_l(p2_l[21]), .b2(b2[2:0]), 
     .am2(a[19]), .a(a[21]), .p2m1_l(p2_l[20]),
     .p1m1_l(p1_l[20]), .p0m1_l(p0_l[20]), .am4(a[17]), .sum(sum[21]),
     .cout(cout[21]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[21]),
     .p0_l(p0_l[21]));
mul_ppgen3 I1_20_ ( .p2_l(p2_l[20]), .b2(b2[2:0]), 
     .am2(a[18]), .a(a[20]), .p2m1_l(p2_l[19]),
     .p1m1_l(p1_l[19]), .p0m1_l(p0_l[19]), .am4(a[16]), .sum(sum[20]),
     .cout(cout[20]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[20]),
     .p0_l(p0_l[20]));
mul_ppgen3 I1_19_ ( .p2_l(p2_l[19]), .b2(b2[2:0]), 
     .am2(a[17]), .a(a[19]), .p2m1_l(p2_l[18]),
     .p1m1_l(p1_l[18]), .p0m1_l(p0_l[18]), .am4(a[15]), .sum(sum[19]),
     .cout(cout[19]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[19]),
     .p0_l(p0_l[19]));
mul_ppgen3 I1_18_ ( .p2_l(p2_l[18]), .b2(b2[2:0]), 
     .am2(a[16]), .a(a[18]), .p2m1_l(p2_l[17]),
     .p1m1_l(p1_l[17]), .p0m1_l(p0_l[17]), .am4(a[14]), .sum(sum[18]),
     .cout(cout[18]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[18]),
     .p0_l(p0_l[18]));
mul_ppgen3 I1_17_ ( .p2_l(p2_l[17]), .b2(b2[2:0]), 
     .am2(a[15]), .a(a[17]), .p2m1_l(p2_l[16]),
     .p1m1_l(p1_l[16]), .p0m1_l(p0_l[16]), .am4(a[13]), .sum(sum[17]),
     .cout(cout[17]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[17]),
     .p0_l(p0_l[17]));
mul_ppgen3 I1_16_ ( .p2_l(p2_l[16]), .b2(b2[2:0]), 
     .am2(a[14]), .a(a[16]), .p2m1_l(p2_l[15]),
     .p1m1_l(p1_l[15]), .p0m1_l(p0_l[15]), .am4(a[12]), .sum(sum[16]),
     .cout(cout[16]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[16]),
     .p0_l(p0_l[16]));
mul_ppgen3 I1_15_ ( .p2_l(p2_l[15]), .b2(b2[2:0]), 
     .am2(a[13]), .a(a[15]), .p2m1_l(p2_l[14]),
     .p1m1_l(p1_l[14]), .p0m1_l(p0_l[14]), .am4(a[11]), .sum(sum[15]),
     .cout(cout[15]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[15]),
     .p0_l(p0_l[15]));
mul_ppgen3 I1_14_ ( .p2_l(p2_l[14]), .b2(b2[2:0]), 
     .am2(a[12]), .a(a[14]), .p2m1_l(p2_l[13]),
     .p1m1_l(p1_l[13]), .p0m1_l(p0_l[13]), .am4(a[10]), .sum(sum[14]),
     .cout(cout[14]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[14]),
     .p0_l(p0_l[14]));
mul_ppgen3 I1_13_ ( .p2_l(p2_l[13]), .b2(b2[2:0]), 
     .am2(a[11]), .a(a[13]), .p2m1_l(p2_l[12]),
     .p1m1_l(p1_l[12]), .p0m1_l(p0_l[12]), .am4(a[9]), .sum(sum[13]),
     .cout(cout[13]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[13]),
     .p0_l(p0_l[13]));
mul_ppgen3 I1_12_ ( .p2_l(p2_l[12]), .b2(b2[2:0]), 
     .am2(a[10]), .a(a[12]), .p2m1_l(p2_l[11]),
     .p1m1_l(p1_l[11]), .p0m1_l(p0_l[11]), .am4(a[8]), .sum(sum[12]),
     .cout(cout[12]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[12]),
     .p0_l(p0_l[12]));
mul_ppgen3 I1_11_ ( .p2_l(p2_l[11]), .b2(b2[2:0]), 
     .am2(a[9]), .a(a[11]), .p2m1_l(p2_l[10]),
     .p1m1_l(p1_l[10]), .p0m1_l(p0_l[10]), .am4(a[7]), .sum(sum[11]),
     .cout(cout[11]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[11]),
     .p0_l(p0_l[11]));
mul_ppgen3 I1_10_ ( .p2_l(p2_l[10]), .b2(b2[2:0]), 
     .am2(a[8]), .a(a[10]), .p2m1_l(p2_l[9]),
     .p1m1_l(p1_l[9]), .p0m1_l(p0_l[9]), .am4(a[6]), .sum(sum[10]),
     .cout(cout[10]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[10]),
     .p0_l(p0_l[10]));
mul_ppgen3 I1_9_ ( .p2_l(p2_l[9]), .b2(b2[2:0]), 
     .am2(a[7]), .a(a[9]), .p2m1_l(p2_l[8]),
     .p1m1_l(p1_l[8]), .p0m1_l(p0_l[8]), .am4(a[5]), .sum(sum[9]),
     .cout(cout[9]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[9]),
     .p0_l(p0_l[9]));
mul_ppgen3 I1_8_ ( .p2_l(p2_l[8]), .b2(b2[2:0]), 
     .am2(a[6]), .a(a[8]), .p2m1_l(p2_l[7]),
     .p1m1_l(p1_l[7]), .p0m1_l(p0_l[7]), .am4(a[4]), .sum(sum[8]),
     .cout(cout[8]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[8]),
     .p0_l(p0_l[8]));
mul_ppgen3 I1_7_ ( .p2_l(p2_l[7]), .b2(b2[2:0]), 
     .am2(a[5]), .a(a[7]), .p2m1_l(p2_l[6]),
     .p1m1_l(p1_l[6]), .p0m1_l(p0_l[6]), .am4(a[3]), .sum(sum[7]),
     .cout(cout[7]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[7]),
     .p0_l(p0_l[7]));
mul_ppgen3 I1_6_ ( .p2_l(p2_l[6]), .b2(b2[2:0]), 
     .am2(a[4]), .a(a[6]), .p2m1_l(p2_l[5]),
     .p1m1_l(p1_l[5]), .p0m1_l(p0_l[5]), .am4(a[2]), .sum(sum[6]),
     .cout(cout[6]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[6]),
     .p0_l(p0_l[6]));
mul_ppgen3 I1_5_ ( .p2_l(p2_l[5]), .b2(b2[2:0]), 
     .am2(a[3]), .a(a[5]), .p2m1_l(p2_l[4]),
     .p1m1_l(p1_l[4]), .p0m1_l(p0_l[4]), .am4(a[1]), .sum(sum[5]),
     .cout(cout[5]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[5]),
     .p0_l(p0_l[5]));
mul_ppgen3 I1_4_ ( .p2_l(p2_l[4]), .b2(b2[2:0]), 
     .am2(a[2]), .a(a[4]), .p2m1_l(1'b1),
     .p1m1_l(p1_l[3]), .p0m1_l(p0_l[3]), .am4(a[0]), .sum(sum[4]),
     .cout(cout[4]), .b1(b1[2:0]), .b0(b0[2:0]), .p1_l(p1_l[4]),
     .p0_l(p0_l[4]));
mul_ppgen3lsb4 I0 ( .cout(cout[3:1]), .a(a[3:0]), .sum(sum[3:0]),
     .p1_l(p1_l[3]), .p0_l(p0_l[3]), .b1(b1[2:0]), .b0(b0[2:0]));

endmodule //mul_ppgenrow3

module mul_ppgensign ( p_l, z, b, pm1_l );
output  p_l, z;
input  pm1_l;
input [2:0]  b;

assign p_l = ~(b[1] & b[2]);
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgensign

module mul_ppgen ( p_l, z, a, b, pm1_l );
output  p_l, z;
input  a, pm1_l;
input [2:0]  b;

assign p_l = ~((a ^ b[2]) & b[1]) ;
assign z = b[0] ? ~pm1_l : ~p_l ;

endmodule //mul_ppgen

module mul_mux2 ( z, d0, d1, s );
output  z;
input  d0, d1, s;

assign z = s ? d1 : d0 ;

endmodule // mul_mux2 

module mul_booth(
	head,
        b_in,
        b0, b1, b2, b3, b4, b5, b6, b7,
	b8, b9, b10, b11, b12, b13, b14, b15, b16,
	clk, se, si, so, mul_step, tm_l
	);
input		head;		// begin of the MUL operation
input   [63:0] 	b_in;
input		clk, se, si, mul_step, tm_l;
output  [2:0]  	b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
output 		b16;
output 		so;

wire  [63:31] 	b;
wire [2:0] 	b0_in0, b1_in0,  b2_in0,  b3_in0,  b4_in0,  b5_in0,  b6_in0,  b7_in0 ;
wire [2:0] 	b8_in0, b9_in0, b10_in0, b11_in0, b12_in0, b13_in0, b14_in0, b15_in0 ;
wire [2:0] 	b0_in1, b1_in1,  b2_in1,  b3_in1,  b4_in1,  b5_in1,  b6_in1,  b7_in1 ;
wire [2:0] 	b8_in1, b9_in1, b10_in1, b11_in1, b12_in1, b13_in1, b14_in1, b15_in1 ;
wire 	   	b16_in1;

wire [2:0] 	b0_outmx, b1_outmx, b2_outmx, b3_outmx, b4_outmx, b5_outmx, b6_outmx;
wire [2:0] 	b7_outmx, b8_outmx, b9_outmx, b10_outmx, b11_outmx, b12_outmx, b13_outmx;
wire [2:0] 	b14_outmx, b15_outmx;
wire 	   	b16_outmx;
wire		clk_enb0, clk_enb1;


  mul_bodec 		encode0_a(
				.x  (1'b0),
				.b  (b_in[15:0]),
				.b0 (b0_in0),
				.b1 (b1_in0),
				.b2 (b2_in0),
				.b3 (b3_in0),
				.b4 (b4_in0),
				.b5 (b5_in0),
				.b6 (b6_in0),
				.b7 (b7_in0)
				);
				//remove 16th row since it's never the last row
				//b8_in0 = 3'b010; 
  mul_bodec		encode0_b(
				.x  (b_in[15]),
				.b  (b_in[31:16]),
				.b0 (b8_in0),
				.b1 (b9_in0),
				.b2 (b10_in0),
				.b3 (b11_in0),
				.b4 (b12_in0),
				.b5 (b13_in0),
				.b6 (b14_in0),
				.b7 (b15_in0)
				);
				// remove 32th row since it's never the last row 
				// b16_in0 = 3'b010 ;

  // Pipe picked address [63:31] and hold flop

  clken_buf     ckbuf_0(.clk(clk_enb0), .rclk(clk), .enb_l(~mul_step), .tmb_l(tm_l));
  clken_buf     ckbuf_1(.clk(clk_enb1), .rclk(clk), .enb_l(~(head & mul_step)), .tmb_l(tm_l));

  dff_s 			hld_dff0(.din(b_in[31]), .clk(clk_enb1), .q(b[31]),
                        	.se(se), .si(), .so());
  dff_s #(32) 		hld_dff(.din(b_in[63:32]), .clk(clk_enb1), .q(b[63:32]),
				.se(se), .si(), .so());

  mul_bodec     	encode1_a(
                        	.x  (b[31]),
                        	.b  (b[47:32]),
                        	.b0 (b0_in1),
                        	.b1 (b1_in1),
                        	.b2 (b2_in1),
                        	.b3 (b3_in1),
                        	.b4 (b4_in1),
                        	.b5 (b5_in1),
                        	.b6 (b6_in1),
                        	.b7 (b7_in1)
                        	);
                        	//remove 16th row since it's never the last row
                        	//b8_in1 = 3'b010;
  mul_bodec     	encode1_b(
                        	.x  (b[47]),
                        	.b  (b[63:48]),
                        	.b0 (b8_in1),
                        	.b1 (b9_in1),
                        	.b2 (b10_in1),
                        	.b3 (b11_in1),
                        	.b4 (b12_in1),
                        	.b5 (b13_in1),
                        	.b6 (b14_in1),
                        	.b7 (b15_in1)
                        	);
				assign b16_in1 = b[63] ;

// Select booth encoded b outputs and flop based on the cycle0 and cycle1 

  dp_mux2es #(3)    out_mux0(.dout(b0_outmx[2:0]),
                        .in0(b0_in0[2:0]),
                        .in1(b0_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux1(.dout(b1_outmx[2:0]),
                        .in0(b1_in0[2:0]),
                        .in1(b1_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux2(.dout(b2_outmx[2:0]),
                        .in0(b2_in0[2:0]),
                        .in1(b2_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux3(.dout(b3_outmx[2:0]),
                        .in0(b3_in0[2:0]),
                        .in1(b3_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux4(.dout(b4_outmx[2:0]),
                        .in0(b4_in0[2:0]),
                        .in1(b4_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux5(.dout(b5_outmx[2:0]),
                        .in0(b5_in0[2:0]),
                        .in1(b5_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux6(.dout(b6_outmx[2:0]),
                        .in0(b6_in0[2:0]),
                        .in1(b6_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux7(.dout(b7_outmx[2:0]),
                        .in0(b7_in0[2:0]),
                        .in1(b7_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux8(.dout(b8_outmx[2:0]),
                        .in0(b8_in0[2:0]),
                        .in1(b8_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux9(.dout(b9_outmx[2:0]),
                        .in0(b9_in0[2:0]),
                        .in1(b9_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux10(.dout(b10_outmx[2:0]),
                        .in0(b10_in0[2:0]),
                        .in1(b10_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux11(.dout(b11_outmx[2:0]),
                        .in0(b11_in0[2:0]),
                        .in1(b11_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux12(.dout(b12_outmx[2:0]),
                        .in0(b12_in0[2:0]),
                        .in1(b12_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux13(.dout(b13_outmx[2:0]),
                        .in0(b13_in0[2:0]),
                        .in1(b13_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux14(.dout(b14_outmx[2:0]),
                        .in0(b14_in0[2:0]),
                        .in1(b14_in1[2:0]),
                        .sel(~head));
  dp_mux2es #(3)    out_mux15(.dout(b15_outmx[2:0]),
                        .in0(b15_in0[2:0]),
                        .in1(b15_in1[2:0]),
                        .sel(~head));
  dp_mux2es         out_mux16(.dout(b16_outmx),
                        .in0(1'b0),
                        .in1(b16_in1),
                        .sel(~head));

  dff_s #(3)    out_dff0 (.din(b0_outmx[2:0]), .clk(clk_enb0), .q(b0[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff1 (.din(b1_outmx[2:0]), .clk(clk_enb0), .q(b1[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff2 (.din(b2_outmx[2:0]), .clk(clk_enb0), .q(b2[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff3 (.din(b3_outmx[2:0]), .clk(clk_enb0), .q(b3[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff4 (.din(b4_outmx[2:0]), .clk(clk_enb0), .q(b4[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff5 (.din(b5_outmx[2:0]), .clk(clk_enb0), .q(b5[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff6 (.din(b6_outmx[2:0]), .clk(clk_enb0), .q(b6[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff7 (.din(b7_outmx[2:0]), .clk(clk_enb0), .q(b7[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff8 (.din(b8_outmx[2:0]), .clk(clk_enb0), .q(b8[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff9 (.din(b9_outmx[2:0]), .clk(clk_enb0), .q(b9[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff10 (.din(b10_outmx[2:0]), .clk(clk_enb0), .q(b10[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff11 (.din(b11_outmx[2:0]), .clk(clk_enb0), .q(b11[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff12 (.din(b12_outmx[2:0]), .clk(clk_enb0), .q(b12[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff13 (.din(b13_outmx[2:0]), .clk(clk_enb0), .q(b13[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff14 (.din(b14_outmx[2:0]), .clk(clk_enb0), .q(b14[2:0]),
			.se(se), .si(), .so());
  dff_s #(3)    out_dff15 (.din(b15_outmx[2:0]), .clk(clk_enb0), .q(b15[2:0]),
			.se(se), .si(), .so());
  dff_s 	      out_dff16 (.din(b16_outmx), .clk(clk_enb0), .q(b16),
			.se(se), .si(), .so());
endmodule //mul_booth

module mul_bodec (x, b,  
        b0, b1, b2, b3, b4, b5, b6, b7);

input	x;
input   [15:0] 	b;
output  [2:0] 	b0, b1, b2, b3, b4, b5, b6, b7; 

assign b0[2] = b[1];
assign b0[1] = ~((b[1] & b[0] & x) | (~b[1] & ~b[0] & ~x)) ;
assign b0[0] = (~b[1] & b[0] & x) | (b[1] & ~b[0] & ~x) ;

assign b1[2] = b[3]; 
assign b1[1] = ~((b[3] & b[2] & b[1]) | (~b[3] & ~b[2] & ~b[1])) ;
assign b1[0] = (~b[3] & b[2] & b[1]) | (b[3] & ~b[2] & ~b[1]) ;

assign b2[2] = b[5]; 
assign b2[1] = ~((b[5] & b[4] & b[3]) | (~b[5] & ~b[4] & ~b[3])) ;
assign b2[0] = (~b[5] & b[4] & b[3]) | (b[5] & ~b[4] & ~b[3]) ;

assign b3[2] = b[7] ;
assign b3[1] = ~((b[7] & b[6] & b[5]) | (~b[7] & ~b[6] & ~b[5])) ;
assign b3[0] = (~b[7] & b[6] & b[5]) | (b[7] & ~b[6] & ~b[5]) ;

assign b4[2] = b[9] ;
assign b4[1] = ~((b[9] & b[8] & b[7]) | (~b[9] & ~b[8] & ~b[7])) ;
assign b4[0] = (~b[9] & b[8] & b[7]) | (b[9] & ~b[8] & ~b[7]) ;

assign b5[2] = b[11] ;
assign b5[1] = ~((b[11] & b[10] & b[9]) | (~b[11] & ~b[10] & ~b[9])) ;
assign b5[0] = (~b[11] & b[10] & b[9]) | (b[11] & ~b[10] & ~b[9]) ;

assign b6[2] = b[13] ;
assign b6[1] = ~((b[13] & b[12] & b[11]) | (~b[13] & ~b[12] & ~b[11])) ;
assign b6[0] = (~b[13] & b[12] & b[11]) | (b[13] & ~b[12] & ~b[11]) ;

assign b7[2] = b[15] ;
assign b7[1] = ~((b[15] & b[14] & b[13]) | (~b[15] & ~b[14] & ~b[13])) ;
assign b7[0] = (~b[15] & b[14] & b[13]) | (b[15] & ~b[14] & ~b[13]) ;

endmodule // mul_bodec

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_clib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: swrvr_clib.v
//      Description: Design control behavioural library
*/                 





// POSITVE-EDGE TRIGGERED FLOP with SCAN
module dff_s (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;






always @ (posedge clk)

	q[SIZE-1:0]  <= (se) ? si[SIZE-1:0]  : din[SIZE-1:0] ;

assign so[SIZE-1:0] = q[SIZE-1:0] ;



endmodule // dff_s

// POSITVE-EDGE TRIGGERED FLOP with SCAN for Shadow-scan
module dff_sscan (din, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;










always @ (posedge clk)
  q[SIZE-1:0]  <= din[SIZE-1:0] ;

assign so={SIZE{1'b0}};


endmodule // dff_sscan

// POSITVE-EDGE TRIGGERED FLOP without SCAN
module dff_ns (din, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)

	q[SIZE-1:0]  <= din[SIZE-1:0] ;

endmodule // dff_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET
module dffr_s (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;






// Scan-Enable dominates
always @ (posedge clk)

	q[SIZE-1:0]  <= se ? si[SIZE-1:0] : ((rst) ? {SIZE{1'b0}}  : din[SIZE-1:0] );

assign so[SIZE-1:0] = q[SIZE-1:0] ;


endmodule // dffr_s

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, RESET_L
module dffrl_s (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk or scan clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;






// Reset dominates
always @ (posedge clk)

	q[SIZE-1:0]  <= rst_l ? ((se) ? si[SIZE-1:0]  : din[SIZE-1:0] ) : {SIZE{1'b0}};

assign so[SIZE-1:0] = q[SIZE-1:0] ;


endmodule // dffrl_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, without SCAN
module dffr_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];
   
endmodule // dffr_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, without SCAN
module dffrl_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			clk ;	// clk
input			rst_l ;	// reset

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? din[SIZE-1:0] : {SIZE{1'b0}};

endmodule // dffrl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN and FUNCTIONAL ENABLE
module dffe_s (din, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// en	se	out
//------------------
// x	1	sin ; scan dominates
// 1  	0	din
// 0 	0	q
//






always @ (posedge clk)

	q[SIZE-1:0]  <= (se) ? si[SIZE-1:0]  : ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) ;

assign so[SIZE-1:0] = q[SIZE-1:0] ;


endmodule // dffe_s

// POSITIVE-EDGE TRIGGERED FLOP with enable, without SCAN
module dffe_ns (din, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

always @ (posedge clk)
  q[SIZE-1:0] <= en ? din[SIZE-1:0] : q[SIZE-1:0];

endmodule // dffe_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET, FUNCTIONAL ENABLE, SCAN.
module dffre_s (din, rst, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 1	x	x	0   ; reset dominates
// 0	x	1	sin ; scan dominates
// 0	1  	0	din
// 0 	0 	0	q
//






always @ (posedge clk)

//	q[SIZE-1:0]  <= rst ? {SIZE{1'b0}} : ((se) ? si[SIZE-1:0]  : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) ;
	q[SIZE-1:0]  <= se ? si[SIZE-1:0]  : (rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) ;

assign so[SIZE-1:0] = q[SIZE-1:0] ;



endmodule // dffre_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, FUNCTIONAL ENABLE, SCAN.
module dffrle_s (din, rst_l, en, clk, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk or scan clk

output	[SIZE-1:0]	q ;	// output

input			se ;	// scan-enable
input	[SIZE-1:0]	si ;	// scan-input
output	[SIZE-1:0]	so ;	// scan-output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	se	out
//------------------
// 0	x	x	0   ; reset dominates
// 1	x	1	sin ; scan dominates
// 1	1  	0	din
// 1 	0 	0	q
//






always @ (posedge clk)

//	q[SIZE-1:0]  <= rst_l ? ((se) ? si[SIZE-1:0]  : ((en) ? din[SIZE-1:0] : q[SIZE-1:0])) : {SIZE{1'b0}} ;
	q[SIZE-1:0]  <= se ? si[SIZE-1:0]  : (rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}}) ;

assign so[SIZE-1:0] = q[SIZE-1:0] ;


endmodule // dffrle_s

// POSITIVE-EDGE TRIGGERED FLOP with RESET, ENABLE, without SCAN.
module dffre_ns (din, rst, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 1	x	0   ; reset dominates
// 0	1  	din
// 0 	0 	q
//

// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : ((en) ? din[SIZE-1:0] : q[SIZE-1:0]);

endmodule // dffre_ns

// POSITIVE-EDGE TRIGGERED FLOP with RESET_L, ENABLE, without SCAN.
module dffrle_ns (din, rst_l, en, clk, q);
// synopsys template

parameter SIZE = 1;

input	[SIZE-1:0]	din ;	// data in
input			en ;	// functional enable
input			rst_l ;	// reset
input			clk ;	// clk

output	[SIZE-1:0]	q ;	// output

reg 	[SIZE-1:0]	q ;

// Enable Interpretation. Ultimate interpretation depends on design
// 
// rst	en	out
//------------------
// 0	x	0   ; reset dominates
// 1	1  	din
// 1 	0 	q
//

// synopsys sync_set_reset "rst_l"
always @ (posedge clk)
  q[SIZE-1:0] <= rst_l ? ((en) ? din[SIZE-1:0] : q[SIZE-1:0]) : {SIZE{1'b0}} ;

endmodule // dffrle_ns

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET
module dffr_async (din, clk, rst, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;






// Reset dominates
always @ (posedge clk or posedge rst)
  q[SIZE-1:0]  <= rst ? {SIZE{1'b0}} : ((se) ? si[SIZE-1:0]  : din[SIZE-1:0] );

assign so[SIZE-1:0] = q[SIZE-1:0] ;



endmodule // dffr_async

// POSITIVE-EDGE TRIGGERED FLOP with SCAN, and ASYNC RESET_L
module dffrl_async (din, clk, rst_l, q, se, si, so);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

input                   se ;    // scan-enable
input   [SIZE-1:0]      si ;    // scan-input
output  [SIZE-1:0]      so ;    // scan-output

reg     [SIZE-1:0]      q ;






// Reset dominates
always @ (posedge clk or negedge rst_l)
  q[SIZE-1:0]  <= (!rst_l) ? {SIZE{1'b0}} : ((se) ? si[SIZE-1:0]  : din[SIZE-1:0] );

assign so[SIZE-1:0] = q[SIZE-1:0] ;



endmodule // dffrl_async

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET, without SCAN
//module dffr_async_ns (din, clk, rst, q);
//// synopsys template
//parameter SIZE = 1;
//input   [SIZE-1:0]      din ;   // data in
//input                   clk ;   // clk or scan clk
//input                   rst ;   // reset
//output  [SIZE-1:0]      q ;     // output
//reg     [SIZE-1:0]      q ;
// Reset dominates
//// synopsys async_set_reset "rst"
//always @ (posedge clk or posedge rst)
//        if(rst) q[SIZE-1:0]  <= {SIZE{1'b0}};
//        else if(clk) q[SIZE-1:0]  <= din[SIZE-1:0];
//endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED FLOP with ASYNC RESET_L, without SCAN
module dffrl_async_ns (din, clk, rst_l, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst_l ;   // reset

output  [SIZE-1:0]      q ;     // output

// Reset dominates
// synopsys async_set_reset "rst_l"
 reg [SIZE-1:0] q;   
always @ (posedge clk or negedge rst_l)
  q[SIZE-1:0] <= ~rst_l ?  {SIZE{1'b0}} : ({SIZE{rst_l}} & din[SIZE-1:0]);

//   reg  [SIZE-1:0]   qm, qs, qm_l, qs_l, qm_f, qs_f;
//   wire              s_l;
//   assign            s_l = 1'b1;
//
//   always @ (rst_l or qm)   qm_l = ~(qm & {SIZE{rst_l}});
//   always @ (s_l or qs)   qs_l = ~(qs & {SIZE{s_l}});
//   always @ (s_l or qm_l) qm_f = ~(qm_l & {SIZE{s_l}});
//   always @ (rst_l or qs_l) qs_f = ~(qs_l & {SIZE{rst_l}});
//
//   always @ (clk or din or qm_f)
//      qm <= clk ? qm_f : din;
//
//   always @ (clk or qm_l or qs_f)
//      qs <= clk ? qm_l : qs_f;
//
//   assign q  = ~qs;

endmodule // dffrl_async_ns

// 2:1 MUX WITH DECODED SELECTS
module mux2ds (dout, in0, in1, sel0, sel1) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel0;
input			sel1;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;

// priority encoding takes care of mutex'ing selects.




wire [1:0] sel = {sel1, sel0}; // 0in one_hot
   
always @ (sel0 or sel1 or in0 or in1)

	case ({sel1,sel0}) // synopsys infer_mux
		2'b01 :	dout = in0 ;
		2'b10 : dout = in1 ;
		2'b11 : dout = {SIZE{1'bx}} ;
		2'b00 : dout = {SIZE{1'bx}} ;
			// 2'b00 : // E.g. 4state vs. 2state modelling.
			// begin
			//	`ifdef FOUR_STATE
			//		dout = {SIZE{1'bx}};
			//	`else
			//		begin
			//		dout = {SIZE{1'b0}};
			//		$error();
			//		end
			//	`endif
			// end
		default : dout = {SIZE{1'bx}};
	endcase

endmodule // mux2ds

// 3:1 MUX WITH DECODED SELECTS
module mux3ds (dout, in0, in1, in2, sel0, sel1, sel2) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0;
input			sel1;
input			sel2;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or in0 or in1 or in2)

	case ({sel2,sel1,sel0}) 
		3'b001 : dout = in0 ;
		3'b010 : dout = in1 ;
		3'b100 : dout = in2 ;
		3'b000 : dout = {SIZE{1'bx}} ;
		3'b011 : dout = {SIZE{1'bx}} ;
		3'b101 : dout = {SIZE{1'bx}} ;
		3'b110 : dout = {SIZE{1'bx}} ;
		3'b111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux3ds

// 4:1 MUX WITH DECODED SELECTS
module mux4ds (dout, in0, in1, in2, in3, sel0, sel1, sel2, sel3) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0;
input			sel1;
input			sel2;
input			sel3;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [3:0] sel = {sel3,sel2,sel1,sel0}; // 0in one_hot
   
// priority encoding takes care of mutex'ing selects.
always @ (sel0 or sel1 or sel2 or sel3 or in0 or in1 or in2 or in3)

	case ({sel3,sel2,sel1,sel0}) 
		4'b0001 : dout = in0 ;
		4'b0010 : dout = in1 ;
		4'b0100 : dout = in2 ;
		4'b1000 : dout = in3 ;
		4'b0000 : dout = {SIZE{1'bx}} ;
		4'b0011 : dout = {SIZE{1'bx}} ;
		4'b0101 : dout = {SIZE{1'bx}} ;
		4'b0110 : dout = {SIZE{1'bx}} ;
		4'b0111 : dout = {SIZE{1'bx}} ;
		4'b1001 : dout = {SIZE{1'bx}} ;
		4'b1010 : dout = {SIZE{1'bx}} ;
		4'b1011 : dout = {SIZE{1'bx}} ;
		4'b1100 : dout = {SIZE{1'bx}} ;
		4'b1101 : dout = {SIZE{1'bx}} ;
		4'b1110 : dout = {SIZE{1'bx}} ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}};
			// two state vs four state modelling will be added.
	endcase

endmodule // mux4ds

// SINK FOR UNLOADED INPUT PORTS
module sink (in);
// synopsys template

parameter SIZE = 1;

input [SIZE-1:0] in;

// Alexey
// `ifdef PITON_PROTO
   // As of version 8.2 XST does not remove this module without the
   // following additional dead code

   wire    a;

   assign		a = | in;

// `endif

endmodule //sink

// SOURCE FOR UNDRIVEN OUTPUT PORTS
module source (out) ;
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0] out;
// 
// Once 4state/2state model established
// then enable check.
// `ifdef FOUR_STATE
// leda check for x_or_z_in rhs_of assign turned off
// assign  out = {SIZE{1'bx}};
//`else
assign  out = {SIZE{1'b0}};
//`endif

endmodule //source

// 2:1 MUX WITH PRIORITY ENCODED SELECTS
//module mux2es (dout, in0, in1, sel0, sel1) ;
//
//parameter SIZE = 1;
//
//output 	[SIZE-1:0] 	dout;
//input	[SIZE-1:0]	in0;
//input	[SIZE-1:0]	in1;
//input			sel0;
//input			sel1;
//
//// reg declaration does not imply state being maintained
//// across cycles. Used to construct case statement and
//// always updated by inputs every cycle.
//reg	[SIZE-1:0]	dout ;
//
//// must take into account lack of mutex selects.
//// there is no reason for handling of x and z conditions.
//// This will be dictated by design.
//always @ (sel0 or sel1 or in0 or in1)
//
//	case ({sel1,sel0})
//		2'b1x : dout = in1 ; // 10(in1),11(z) 
//		2'b0x :	dout = in0 ; // 01(in0),00(x)
//	endcase
//
//endmodule // mux2es

// CLK Header for gating off the clock of
// a FF.
// clk - output of the clk header
// rclk - input clk
// enb_l - Active low clock enable
// tmb_l  - Active low clock enable ( in scan mode, this input is !se )

module clken_buf (clk, rclk, enb_l, tmb_l);
output clk;
input  rclk, enb_l, tmb_l;
reg    clken;

  always @ (rclk or enb_l or tmb_l)
    if (!rclk)  //latch opens on rclk low phase
      clken = !enb_l | !tmb_l;
  assign clk = clken & rclk;

endmodule



// The following flops are maintained and used in ENET , MAC IP  ONLY
// -- Mimi X61467

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys sync_set_reset "set_l"
always @ (posedge clk)
  q[SIZE-1:0] <= set_l ? din[SIZE-1:0] : {SIZE{1'b1}};

endmodule // dffsl_ns

// POSITIVE-EDGE TRIGGERED FLOP with SET_L, without SCAN.

module dffsl_async_ns (din, clk, set_l, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   set_l ; // set

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// synopsys async_set_reset "set_l"
always @ (posedge clk or negedge set_l)
  q[SIZE-1:0] <= ~set_l ? {SIZE{1'b1}} : ({SIZE{~set_l}} | din[SIZE-1:0]);

endmodule // dffsl_async_ns

// POSITIVE-EDGE TRIGGERED FLOP WITH SET_H , without SCAN.

module dffr_ns_r1 (din, clk, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (posedge clk)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_ns_r1

// POSITIVE-EDGE TRIGGERED ASYNC RESET_H FLOP , without SCAN.

module dffr_async_ns (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset dominates
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b0}} : din[SIZE-1:0];

endmodule // dffr_async_ns

// POSITIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_r1 (din, clk, rst, q);
// synopsys template

parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clk ;   // clk or scan clk
input                   rst;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Reset to 1
// synopsys async_set_reset "rst"
always @ (posedge clk or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_r1


// NEGATIVE-EDGE TRIGGERED ASYNC SET_H FLOP , without SCAN.

module dffr_async_ns_cl_r1 (din, clkl, rst, q);
// synopsys template
parameter SIZE = 1;

input   [SIZE-1:0]      din ;   // data in
input                   clkl ;  // clk or scan clk
input                   rst ;   // reset

output  [SIZE-1:0]      q ;     // output

reg     [SIZE-1:0]      q ;

// Set to 1
// synopsys sync_set_reset "rst"
always @ (negedge clkl or posedge rst)
  q[SIZE-1:0] <= rst ? {SIZE{1'b1}} : din[SIZE-1:0];

endmodule // dffr_async_ns_cl_r1

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: swrvr_dlib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// DP library

// 2:1 MUX WITH ENCODED SELECT
module dp_mux2es (dout, in0, in1, sel) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input			sel;

reg	[SIZE-1:0]	dout ;

always @ (sel or in0 or in1)

 begin
	   case (sel)
	     1'b1: dout = in1 ; 
	     1'b0: dout = in0;
	     default: 
         begin
            if (in0 == in1) begin
               dout = in0;
            end
            else
              dout = {SIZE{1'bx}};
         end
	   endcase // case(sel)
 end

endmodule // dp_mux2es

// ----------------------------------------------------------------------


// 4:1 MUX WITH DECODED SELECTS
module dp_mux4ds (dout, in0, in1, in2, in3, 
		     sel0_l, sel1_l, sel2_l, sel3_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [3:0] sel = {sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3)

	case ({sel3_l,sel2_l,sel1_l,sel0_l})
		4'b1110 : dout = in0 ;
		4'b1101 : dout = in1 ;
		4'b1011 : dout = in2 ;
		4'b0111 : dout = in3 ;
		4'b1111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux4ds

// ----------------------------------------------------------------------


// 5:1 MUX WITH DECODED SELECTS
module dp_mux5ds (dout, in0, in1, in2, in3,  in4,
		     sel0_l, sel1_l, sel2_l, sel3_l, sel4_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;




   
wire [4:0] sel = {sel4_l,sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or sel4_l or
		in0 or in1 or in2 or in3 or in4)

	case ({sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		5'b11110 : dout = in0 ;
		5'b11101 : dout = in1 ;
		5'b11011 : dout = in2 ;
		5'b10111 : dout = in3 ;
		5'b01111 : dout = in4 ;
		5'b11111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux5ds

// --------------------------------------------------------------------

// 8:1 MUX WITH DECODED SELECTS
module dp_mux8ds (dout, in0, in1, in2, in3, 
			in4, in5, in6, in7,
		     sel0_l, sel1_l, sel2_l, sel3_l,
		     sel4_l, sel5_l, sel6_l, sel7_l) ;
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input	[SIZE-1:0]	in3;
input	[SIZE-1:0]	in4;
input	[SIZE-1:0]	in5;
input	[SIZE-1:0]	in6;
input	[SIZE-1:0]	in7;
input			sel0_l;
input			sel1_l;
input			sel2_l;
input			sel3_l;
input			sel4_l;
input			sel5_l;
input			sel6_l;
input			sel7_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;






wire [7:0] sel = {sel7_l,sel6_l,sel5_l,sel4_l,
                  sel3_l,sel2_l,sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or sel2_l or sel3_l or in0 or in1 or in2 or in3 or
	  sel4_l or sel5_l or sel6_l or sel7_l or in4 or in5 or in6 or in7)

	case ({sel7_l,sel6_l,sel5_l,sel4_l,sel3_l,sel2_l,sel1_l,sel0_l})
		8'b11111110 : dout = in0 ;
		8'b11111101 : dout = in1 ;
		8'b11111011 : dout = in2 ;
		8'b11110111 : dout = in3 ;
		8'b11101111 : dout = in4 ;
		8'b11011111 : dout = in5 ;
		8'b10111111 : dout = in6 ;
		8'b01111111 : dout = in7 ;
		8'b11111111 : dout = {SIZE{1'bx}} ;
		default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux8ds


// ----------------------------------------------------------------------


// 3:1 MUX WITH DECODED SELECTS
module dp_mux3ds (dout, in0, in1, in2, 
		     sel0_l, sel1_l, sel2_l);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in0;
input	[SIZE-1:0]	in1;
input	[SIZE-1:0]	in2;
input			sel0_l;
input			sel1_l;
input			sel2_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg	[SIZE-1:0]	dout ;





wire [2:0] sel = {sel2_l,sel1_l,sel0_l}; // 0in one_cold
   
always @ (sel0_l or sel1_l or sel2_l or in0 or in1 or in2)

	case ({sel2_l,sel1_l,sel0_l})
		3'b110 : dout = in0 ;
		3'b101 : dout = in1 ;
		3'b011 : dout = in2 ;
	        default : dout = {SIZE{1'bx}} ;
	endcase

endmodule // dp_mux3ds

// ----------------------------------------------------------------------


// 2:1 MUX WITH DECODED SELECTS
module dp_mux2ds (dout, in0, in1,
             sel0_l, sel1_l);
// synopsys template

parameter SIZE = 1;

output  [SIZE-1:0]  dout;
input   [SIZE-1:0]  in0;
input   [SIZE-1:0]  in1;
input           sel0_l;
input           sel1_l;

// reg declaration does not imply state being maintained
// across cycles. Used to construct case statement and
// always updated by inputs every cycle.
reg [SIZE-1:0]  dout ;





wire [1:0] sel = {sel1_l,sel0_l}; // 0in one_cold

always @ (sel0_l or sel1_l or in0 or in1)

    case ({sel1_l,sel0_l})
        3'b10 : dout = in0 ;
        3'b01 : dout = in1 ;
            default : dout = {SIZE{1'bx}} ;
    endcase

endmodule // dp_mux3ds

// ---------------------------------------------------------------------


module dp_buffer(dout, in);
// synopsys template

parameter SIZE = 1;

output 	[SIZE-1:0] 	dout;
input	[SIZE-1:0]	in;

assign dout = in;

endmodule // dp_buffer









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: test_stub_scan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
// ____________________________________________________________________________
//
//  test_stub_bist - Test Stub with Scan Support
// ____________________________________________________________________________
//
// Description: DBB interface for test signal generation
// ____________________________________________________________________________

module test_stub_scan (/*AUTOARG*/
// Outputs
mux_drive_disable, mem_write_disable, sehold, se, testmode_l, 
mem_bypass, so_0, so_1, so_2, 
// Inputs
ctu_tst_pre_grst_l, arst_l, global_shift_enable, 
ctu_tst_scan_disable, ctu_tst_scanmode, ctu_tst_macrotest, 
ctu_tst_short_chain, long_chain_so_0, short_chain_so_0, 
long_chain_so_1, short_chain_so_1, long_chain_so_2, short_chain_so_2
);

   input        ctu_tst_pre_grst_l;
   input        arst_l;                // no longer used
   input        global_shift_enable;
   input        ctu_tst_scan_disable;  // redefined as pin_based_scan
   input        ctu_tst_scanmode;
   input 	ctu_tst_macrotest;
   input 	ctu_tst_short_chain;
   input 	long_chain_so_0;
   input 	short_chain_so_0;
   input 	long_chain_so_1;
   input 	short_chain_so_1;
   input 	long_chain_so_2;
   input 	short_chain_so_2;
   
   output 	mux_drive_disable;
   output 	mem_write_disable;
   output 	sehold;
   output 	se;
   output 	testmode_l;
   output 	mem_bypass;
   output 	so_0;
   output 	so_1;
   output 	so_2;

   wire         pin_based_scan;
   wire         short_chain_en;
   wire         short_chain_select;

   // INTERNAL CLUSTER CONNECTIONS
   //
   // Scan Chain Hookup
   // =================
   //
   // Scan chains have two configurations: long and short.
   // The short chain is typically the first tenth of the
   // long chain. The short chain should contain memory
   // collar flops for deep arrays. The CTU determines
   // which configuration is selected. Up to three chains
   // are supported.
   //
   // The scanout connections from the long and short
   // chains connect to the following inputs:
   //
   // long_chain_so_0, short_chain_so_0 (mandatory)
   // long_chain_so_1, short_chain_so_1 (optional)
   // long_chain_so_2, short_chain_so_2 (optional)
   //
   // The test stub outputs should connect directly to the
   // scanout port(s) of the cluster:
   //
   // so_0 (mandatory), so_1 (optional), so_2 (optional)
   //
   //
   // Static Output Signals
   // =====================
   //
   // testmode_l
   //
   // Local testmode control for overriding gated
   // clocks, asynchronous resets, etc. Asserted
   // for all shift-based test modes.
   //
   // mem_bypass
   //
   // Memory bypass control for arrays without output
   // flops. Allows testing of shadow logic. Asserted
   // for scan test; de-asserted for macrotest.
   //
   //
   // Dynamic Output Signals
   // ======================
   //
   // sehold
   //
   // The sehold signal needs to be set for macrotest
   // to allow holding flops in the array collars
   // to retain their shifted data during capture.
   // Inverted version of scan enable during macrotest.
   //
   // mux_drive_disable (for mux/long chain protection)
   //
   // Activate one-hot mux protection circuitry during
   // scan shift and reset. Formerly known as rst_tri_en.
   // Also used by long chain memories with embedded
   // control.
   //
   // mem_write_disable (for short chain protection)
   //
   // Protects contents of short chain memories during
   // shift and POR.
   //
   // se

   assign  mux_drive_disable  = ~ctu_tst_pre_grst_l | short_chain_select | se;
   assign  mem_write_disable  = ~ctu_tst_pre_grst_l | se;
   assign  sehold             = ctu_tst_macrotest & ~se;
   assign  se                 = global_shift_enable;
   assign  testmode_l         = ~ctu_tst_scanmode;
   assign  mem_bypass         = ~ctu_tst_macrotest & ~testmode_l;
   assign  pin_based_scan     = ctu_tst_scan_disable;
   assign  short_chain_en     = ~(pin_based_scan & se);
   assign  short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;
   assign  so_0               = short_chain_select ? short_chain_so_0 : long_chain_so_0;
   assign  so_1               = short_chain_select ? short_chain_so_1 : long_chain_so_1;
   assign  so_2               = short_chain_select ? short_chain_so_2 : long_chain_so_2;
   
endmodule // test_stub_scan
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: u1.behV
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
//
// basic gates {
//
////////////////////////////////////////////////////////////////////////


//bw_u1_inv_0p6x
//
//

module bw_u1_inv_0p6x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1x
//
//

module bw_u1_inv_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_1p4x
//
//

module bw_u1_inv_1p4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_2x
//
//

module bw_u1_inv_2x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_3x
//
//

module bw_u1_inv_3x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_4x
//
//

module bw_u1_inv_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule



//bw_u1_inv_5x
//
//

module bw_u1_inv_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_8x
//
//

module bw_u1_inv_8x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_10x
//
//

module bw_u1_inv_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_15x
//
//

module bw_u1_inv_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_20x
//
//

module bw_u1_inv_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_30x
//
//

module bw_u1_inv_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_inv_40x
//
//

module bw_u1_inv_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_15x
//
//

module bw_u1_invh_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule

//bw_u1_invh_25x
//
//

module bw_u1_invh_25x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_30x
//
//

module bw_u1_invh_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_50x
//
//

module bw_u1_invh_50x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule


//bw_u1_invh_60x
//
//

module bw_u1_invh_60x (
    z,
    a );

    output z;
    input  a;

    assign z = ~( a );

endmodule




//bw_u1_nand2_0p4x
//
//
module bw_u1_nand2_0p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_0p6x
//
//
module bw_u1_nand2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1x
//
//
module bw_u1_nand2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_1p4x
//
//
module bw_u1_nand2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_2x
//
//
module bw_u1_nand2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_3x
//
//
module bw_u1_nand2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_4x
//
//
module bw_u1_nand2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_5x
//
//
module bw_u1_nand2_5x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_7x
//
//
module bw_u1_nand2_7x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_10x
//
//
module bw_u1_nand2_10x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand2_15x
//
//
module bw_u1_nand2_15x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a & b );

endmodule


//bw_u1_nand3_0p4x
//
//
module bw_u1_nand3_0p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule




//bw_u1_nand3_0p6x
//
//
module bw_u1_nand3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a & b & c );

endmodule



//bw_u1_nand3_1x

//
//
module bw_u1_nand3_1x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_1p4x

//
//
module bw_u1_nand3_1p4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_2x

//
//
module bw_u1_nand3_2x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_3x

//
//
module bw_u1_nand3_3x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_4x

//
//
module bw_u1_nand3_4x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_5x

//
//
module bw_u1_nand3_5x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_7x

//
//
module bw_u1_nand3_7x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand3_10x

//
//
module bw_u1_nand3_10x (
    z,
    a,  
    b,  
    c );
    
    output z;
    input  a;
    input  b;
    input  c;
    
    assign z = ~( a & b & c );

endmodule


//bw_u1_nand4_0p6x

//
//
module bw_u1_nand4_0p6x (
    z,
    a,  
    b,  
    c,  
    d );
    
    output z;
    input  a;
    input  b;
    input  c;
    input  d;
    
    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1x
//
//
module bw_u1_nand4_1x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_1p4x
//
//
module bw_u1_nand4_1p4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_2x
//
//
module bw_u1_nand4_2x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_3x
//
//
module bw_u1_nand4_3x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_4x
//
//
module bw_u1_nand4_4x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;

    assign z = ~( a & b & c & d );

endmodule


//bw_u1_nand4_6x
//
//

module bw_u1_nand4_6x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nand4_8x
//
//

module bw_u1_nand4_8x (
    z,
    a,
    b,
    c,
    d );

    output z;
    input  a;
    input  b;
    input  c;
    input  d;


    nand( z, a, b,c,d);

endmodule

//bw_u1_nor2_0p6x
//
//

module bw_u1_nor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1x
//
//

module bw_u1_nor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_1p4x
//
//

module bw_u1_nor2_1p4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_2x
//
//

module bw_u1_nor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_3x
//
//

module bw_u1_nor2_3x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_4x
//
//

module bw_u1_nor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_6x
//
//

module bw_u1_nor2_6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_8x
//
//

module bw_u1_nor2_8x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule


//bw_u1_nor2_12x
//
//

module bw_u1_nor2_12x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a | b );

endmodule




//bw_u1_nor3_0p6x
//
//

module bw_u1_nor3_0p6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1x
//
//

module bw_u1_nor3_1x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_1p4x
//
//

module bw_u1_nor3_1p4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_2x
//
//

module bw_u1_nor3_2x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_3x
//
//

module bw_u1_nor3_3x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_4x
//
//

module bw_u1_nor3_4x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_6x
//
//

module bw_u1_nor3_6x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_nor3_8x
//
//

module bw_u1_nor3_8x (
    z,
    a,
    b,
    c );

    output z;
    input  a;
    input  b;
    input  c;

    assign z = ~( a | b | c );

endmodule


//bw_u1_aoi21_0p4x
//
// 
module bw_u1_aoi21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_1x
//
// 
module bw_u1_aoi21_1x (

    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a  ));

endmodule
//bw_u1_aoi21_2x
//
// 
module bw_u1_aoi21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_4x
//
// 
module bw_u1_aoi21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_8x
//
// 
module bw_u1_aoi21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi21_12x
//
// 
module bw_u1_aoi21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule
//bw_u1_aoi22_0p4x
//
// 
module bw_u1_aoi22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_1x
//
// 
module bw_u1_aoi22_1x (
    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;


    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_2x
//
// 
module bw_u1_aoi22_2x (


    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;
 
    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_4x
//
// 
module bw_u1_aoi22_4x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi22_8x
//
// 
module bw_u1_aoi22_8x (

    z,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( a1 & a2 ) | ( b1 & b2 ));

endmodule
//bw_u1_aoi211_0p3x
//
// 
module bw_u1_aoi211_0p3x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_1x
//
// 
module bw_u1_aoi211_1x (

    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_2x
//
// 
module bw_u1_aoi211_2x (



    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 

    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_4x
//
// 
module bw_u1_aoi211_4x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_aoi211_8x
//
// 
module bw_u1_aoi211_8x (


    z,
    c1,
    c2,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;
 


    assign z = ~(( c1 & c2 ) | (a)| (b));

endmodule

//bw_u1_oai21_0p4x
//
//
module bw_u1_oai21_0p4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_1x
//
//
module bw_u1_oai21_1x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_2x
//
//
module bw_u1_oai21_2x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_4x
//
//
module bw_u1_oai21_4x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_8x
//
//
module bw_u1_oai21_8x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai21_12x
//
//
module bw_u1_oai21_12x (
    z,
    b1,
    b2,
    a );

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 | b2 ) & ( a ));

endmodule



//bw_u1_oai22_0p4x
// 
module bw_u1_oai22_0p4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_1x
// 
module bw_u1_oai22_1x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_2x
// 
module bw_u1_oai22_2x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_4x
// 
module bw_u1_oai22_4x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai22_8x
// 
module bw_u1_oai22_8x (
    z,
    a1,
    a2,
    b1,
    b2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;

    assign z = ~(( a1 | a2 ) & ( b1 | b2 ));

endmodule

//bw_u1_oai211_0p3x
//
//
module bw_u1_oai211_0p3x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_1x
//
//
module bw_u1_oai211_1x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_2x
//
//
module bw_u1_oai211_2x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_4x
//
//
module bw_u1_oai211_4x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_oai211_8x
//
//
module bw_u1_oai211_8x (
    z,
    c1,
    c2,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b));

endmodule

//bw_u1_aoi31_1x
//
// 
module bw_u1_aoi31_1x (


    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_2x
//
// 
module bw_u1_aoi31_2x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_4x
//
// 
module bw_u1_aoi31_4x (
    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi31_8x
//
// 
module bw_u1_aoi31_8x (

    z, 
    b1,
    b2, 
    b3, 
    a );
    
    output z; 
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 & b2&b3 ) | ( a ));

endmodule
//bw_u1_aoi32_1x
//
// 
module bw_u1_aoi32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_2x
//
// 
module bw_u1_aoi32_2x (
    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_4x
//
// 
module bw_u1_aoi32_4x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 

    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi32_8x
//
// 
module bw_u1_aoi32_8x (

    z,
    b1, 
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1; 
    input  b2; 
    input  b3; 
    input  a1;
    input  a2;

 
    assign z = ~(( b1 & b2&b3 ) | ( a1 & a2 ));

endmodule

//bw_u1_aoi33_1x
//
//
module bw_u1_aoi33_1x (




    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_2x
//
//
module bw_u1_aoi33_2x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    

    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_4x
//
//
module bw_u1_aoi33_4x (

       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi33_8x
//
//
module bw_u1_aoi33_8x (
       
    z, 
    b1, 
    b2,  
    b3,  
    a1,  
    a2,  
    a3 );
    
    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;
    


    assign z = ~(( b1 & b2&b3 ) | ( a1&a2&a3 ));

endmodule


//bw_u1_aoi221_1x
//
// 
module bw_u1_aoi221_1x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_2x
//
// 
module bw_u1_aoi221_2x (

    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_4x
//
// 
module bw_u1_aoi221_4x (



    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi221_8x
//
// 
module bw_u1_aoi221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a; 


    assign z = ~(( c1 & c2 ) | (b1&b2)| (a));

endmodule


//bw_u1_aoi222_1x
//
//
module bw_u1_aoi222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_aoi222_2x
//
//
module bw_u1_aoi222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi222_4x
//
//
module bw_u1_aoi222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;

    assign z = ~(( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_aoi311_1x
//
//
module bw_u1_aoi311_1x (

    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_2x
//
//
module bw_u1_aoi311_2x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_4x
//
//
module bw_u1_aoi311_4x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;


    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_aoi311_8x
//
//
module bw_u1_aoi311_8x (
    z,
    c1,
    c2,
    c3,
    b, 
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 & c2& c3 ) | (a)| (b));

endmodule




//bw_u1_oai31_1x
//
//
module bw_u1_oai31_1x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_2x
//
//
module bw_u1_oai31_2x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_4x
//
//
module bw_u1_oai31_4x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai31_8x
//
//
module bw_u1_oai31_8x (
    z,
    b1,
    b2,
    b3,
    a );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a;

    assign z = ~(( b1 | b2|b3 ) & ( a ));

endmodule




//bw_u1_oai32_1x
//
//
module bw_u1_oai32_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_2x
//
//
module bw_u1_oai32_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_4x
//
//
module bw_u1_oai32_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai32_8x
//
//
module bw_u1_oai32_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;

    assign z = ~(( b1 | b2 | b3 ) & ( a1 | a2 ));

endmodule



//bw_u1_oai33_1x
//
//
module bw_u1_oai33_1x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_2x
//
//
module bw_u1_oai33_2x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_4x
//
//
module bw_u1_oai33_4x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai33_8x
//
//
module bw_u1_oai33_8x (
    z,
    b1,
    b2,
    b3,
    a1,
    a2,
    a3 );

    output z;
    input  b1;
    input  b2;
    input  b3;
    input  a1;
    input  a2;
    input  a3;

    assign z = ~(( b1 | b2|b3 ) & ( a1|a2|a3 ));

endmodule


//bw_u1_oai221_1x
//
//
module bw_u1_oai221_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_2x
//
//
module bw_u1_oai221_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_4x
//
//
module bw_u1_oai221_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai221_8x
//
//
module bw_u1_oai221_8x (
    z,
    c1,
    c2,
    b1,
    b2,
    a );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( c1 | c2 ) & ( a ) & (b1|b2));

endmodule

//bw_u1_oai222_1x
//
//
module bw_u1_oai222_1x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_2x
//
//
module bw_u1_oai222_2x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai222_4x
//
//
module bw_u1_oai222_4x (
    z,
    c1,
    c2,
    b1,
    b2,
    a1,
    a2 );

    output z;
    input  c1;
    input  c2;
    input  b1;
    input  b2;
    input  a1;
    input  a2;

    assign z = ~(( c1 | c2 ) & ( a1|a2 ) & (b1|b2));

endmodule


//bw_u1_oai311_1x
//
//
module bw_u1_oai311_1x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_2x
//
//
module bw_u1_oai311_2x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_4x
//
//
module bw_u1_oai311_4x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2 | c3 ) & ( a ) & (b));

endmodule


//bw_u1_oai311_8x
//
//
module bw_u1_oai311_8x (
    z,
    c1,
    c2,
    c3,
    b,
    a );

    output z;
    input  c1;
    input  c2;
    input  c3;
    input  b;
    input  a;

    assign z = ~(( c1 | c2|c3 ) & ( a ) & (b));

endmodule


//bw_u1_muxi21_0p6x



module bw_u1_muxi21_0p6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_1x



module bw_u1_muxi21_1x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule







//bw_u1_muxi21_2x



module bw_u1_muxi21_2x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule


//bw_u1_muxi21_4x



module bw_u1_muxi21_4x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule




//bw_u1_muxi21_6x


module bw_u1_muxi21_6x (z, d0, d1, s);
output z;
input  d0, d1, s;

    assign z = s ? ~d1 : ~d0;
endmodule

//bw_u1_muxi31d_4x
//

module bw_u1_muxi31d_4x (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
        zmuxi31d_prim i0 ( z, d0, d1, d2, s0, s1, s2 );
endmodule

//bw_u1_muxi41d_4x
//

module bw_u1_muxi41d_4x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule

//bw_u1_muxi41d_6x
//

module bw_u1_muxi41d_6x (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
        zmuxi41d_prim i0 ( z, d0, d1, d2, d3, s0, s1, s2, s3 );
endmodule
 

//bw_u1_xor2_0p6x
//
// 
module bw_u1_xor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_1x
//
// 
module bw_u1_xor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_2x
//
// 
module bw_u1_xor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xor2_4x
//
// 
module bw_u1_xor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ( a ^ b );

endmodule
//bw_u1_xnor2_0p6x
//
// 
module bw_u1_xnor2_0p6x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_1x
//
// 
module bw_u1_xnor2_1x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_2x
//
// 
module bw_u1_xnor2_2x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule
//bw_u1_xnor2_4x
//
// 
module bw_u1_xnor2_4x (
    z,
    a,
    b );

    output z;
    input  a;
    input  b;

    assign z = ~( a ^ b );

endmodule

//bw_u1_buf_1x
//

module bw_u1_buf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_buf_5x
//

module bw_u1_buf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_10x
//

module bw_u1_buf_10x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_15x
//

module bw_u1_buf_15x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_20x
//

module bw_u1_buf_20x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_30x
//

module bw_u1_buf_30x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_buf_40x
//

module bw_u1_buf_40x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule


//bw_u1_ao2222_1x
//
//
module bw_u1_ao2222_1x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule


//bw_u1_ao2222_2x
//
//
module bw_u1_ao2222_2x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

//bw_u1_ao2222_4x
//
//
module bw_u1_ao2222_4x (

    z,
    a1,
    a2,
    b1,
    b2,
    c1,
    c2,
    d1,
    d2 );

    output z;
    input  a1;
    input  a2;
    input  b1;
    input  b2;
    input  c1;
    input  c2;
    input  d1;
    input  d2;

    assign z = ((d1&d2) | ( c1 & c2 ) | (b1&b2)| (a1& a2));

endmodule

////////////////////////////////////////////////////////////////////////
//
// flipflops {
//
////////////////////////////////////////////////////////////////////////

//      scanable D-flipflop with scanout

module bw_u1_soff_1x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_2x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

module bw_u1_soff_8x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
        zsoff_prim i0 ( q, so, ck, d, se, sd );
endmodule

//      fast scanable D-flipflop with scanout with inverted Q output

module bw_u1_soffi_4x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule
  
module bw_u1_soffi_8x (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
        zsoffi_prim i0 ( q_l, so, ck, d, se, sd );
endmodule

//      scanable D-flipflop with scanout with 2-to-1 input mux

module bw_u1_soffm2_4x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

module bw_u1_soffm2_8x (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
        zsoffm2_prim i0 ( q, so, ck, d0, d1, s, se, sd );
endmodule

//      scanable D-flipflop with scanout with sync reset-bar

module bw_u1_soffr_2x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule
  
module bw_u1_soffr_4x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

module bw_u1_soffr_8x (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
        zsoffr_prim i0 ( q, so, ck, d, se, sd, r_l );
endmodule

//bw_u1_soffasr_2x

module bw_u1_soffasr_2x (q, so, ck, d, r_l, s_l, se, sd);
output q, so;
input  ck, d, r_l, s_l, se, sd;
        zsoffasr_prim i0 (q, so, ck, d, r_l, s_l, se, sd);
endmodule


//bw_u1_ckbuf_1p5x


module bw_u1_ckbuf_1p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_3x


module bw_u1_ckbuf_3x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_4p5x


module bw_u1_ckbuf_4p5x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_6x


module bw_u1_ckbuf_6x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_7x
//

module bw_u1_ckbuf_7x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule

//bw_u1_ckbuf_8x
//
module bw_u1_ckbuf_8x  (clk, rclk);
output clk;
input  rclk;
        buf (clk, rclk);
endmodule


//bw_u1_ckbuf_11x
//

module bw_u1_ckbuf_11x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_14x
//

module bw_u1_ckbuf_14x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_17x
//

module bw_u1_ckbuf_17x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_19x
//

module bw_u1_ckbuf_19x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule




//bw_u1_ckbuf_22x
//

module bw_u1_ckbuf_22x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_25x
//

module bw_u1_ckbuf_25x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_28x
//

module bw_u1_ckbuf_28x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


//bw_u1_ckbuf_30x
//

module bw_u1_ckbuf_30x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_33x
//

module bw_u1_ckbuf_33x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule

//bw_u1_ckbuf_40x
//

module bw_u1_ckbuf_40x (clk, rclk);
output clk;
input  rclk;

    assign clk = ( rclk );

endmodule


// gated clock buffers


module bw_u1_ckenbuf_6x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

module bw_u1_ckenbuf_14x (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule   

////////////////////////////////////////////////////////////////////////
//
// half cells
//
////////////////////////////////////////////////////////////////////////



module bw_u1_zhinv_0p6x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_1x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_1p4x (z, a);
output z;
input  a;
        not (z, a);
endmodule


module bw_u1_zhinv_2x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_3x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhinv_4x (z, a);
output z;
input  a;
        not (z, a);
endmodule



module bw_u1_zhnand2_0p4x (z, a, b);
output z;
input  a, b;
        nand (z, a, b);
endmodule


module bw_u1_zhnand2_0p6x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_1p4x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_2x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand2_3x (z, a, b);
output z;   
input  a, b;
        nand (z, a, b);
endmodule   


module bw_u1_zhnand3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_1x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule

module bw_u1_zhnand3_2x (z, a, b, c);
output z;
input  a, b, c;
        nand (z, a, b, c);
endmodule


module bw_u1_zhnand4_0p6x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_1x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule

module bw_u1_zhnand4_2x (z, a, b, c, d);
output z;
input  a, b, c, d;
        nand (z, a, b, c, d);
endmodule


        
module bw_u1_zhnor2_0p6x (z, a, b);
output z;
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_1x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule

module bw_u1_zhnor2_2x (z, a, b);
output z;   
input  a, b;
        nor (z, a, b);
endmodule



module bw_u1_zhnor3_0p6x (z, a, b, c);
output z;
input  a, b, c;
        nor (z, a, b, c);
endmodule


module bw_u1_zhaoi21_0p4x (z,b1,b2,a);

    output z;   
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));
    
endmodule



module bw_u1_zhaoi21_1x (z, a, b1, b2);

    output z;
    input  b1;
    input  b2;
    input  a;

    assign z = ~(( b1 & b2 ) | ( a ));

endmodule



module bw_u1_zhoai21_1x (z,b1,b2,a );
    
    output z;
    input  b1;
    input  b2;  
    input  a;
  
    assign z = ~(( b1 | b2 ) & ( a ));
      
endmodule




module bw_u1_zhoai211_0p3x (z, a, b, c1, c2);
    output z; 
    input  c1;  
    input  c2;
    input  b;
    input  a;
      
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





module bw_u1_zhoai211_1x (z, a, b, c1, c2);
output z;
input  a, b, c1, c2;
    assign z = ~(( c1 | c2 ) & ( a ) & (b));
       
endmodule





/////////////// Scan data lock up latch ///////////////

module bw_u1_scanlg_2x (so, sd, ck, se);
output so;
input sd, ck, se;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd or se )
       if (~ck) so_l <= ~(sd & se) ;

endmodule

module bw_u1_scanl_2x (so, sd, ck);
output so;
input sd, ck;

reg so_l;

    assign so = ~so_l;
    always @ ( ck or sd )
       if (~ck) so_l <= ~sd ;

endmodule



////////////////// Synchronizer ////////////////

module bw_u1_syncff_4x (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;

reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r;

endmodule




////////////////////////////////////////////////////////////////////////
//
// non library cells
// 
////////////////////////////////////////////////////////////////////////

// These cells are used only in custom DP macros
// Do not use in any block design without prior permission


module bw_u1_zzeccxor2_5x (z, a, b); 
 output z; 
 input a, b;
    assign z = ( a ^ b );

endmodule



module bw_u1_zzmulcsa42_5x (sum, carry, cout, a, b, c, d, cin);
output sum, carry, cout;
input  a, b, c, d, cin;
wire and_cin_b, or_cin_b, xor_a_c_d, and_or_cin_b_xor_a_c_d;
wire and_a_c, and_a_d, and_c_d;
        assign sum   = cin ^ a ^ b ^ c ^ d;
        assign carry = cin & b | (cin | b) & (a ^ c ^ d);
        assign cout  = a & c | a & d | c & d;
endmodule



module bw_u1_zzmulcsa32_5x (sum, cout, a, b, c);
output sum, cout;
input  a, b, c;
wire and_a_b, and_a_c, and_b_c;
        assign sum  = a ^ b ^ c ;
        assign cout = a & b | a & c | b & c ;
endmodule



module bw_u1_zzmulppmuxi21_2x ( z, d0, d1, s );
output  z;
input  d0, d1, s;
    assign z = s ? ~d1 : ~d0;
endmodule



module bw_u1_zzmulnand2_2x ( z, a, b );
output z;
input  a;
input  b;
    assign z = ~( a & b );
endmodule



// Primitives




module zmuxi31d_prim (z, d0, d1, d2, s0, s1, s2);
output z;
input  d0, d1, d2, s0, s1, s2;
// for Blacktie



wire [2:0] sel = {s0,s1,s2}; // 0in one_hot
reg z;
    always @ (s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s2,d2,s1,d1,s0,d0})
            6'b0?0?10: z = 1'b1;  
            6'b0?0?11: z = 1'b0;  
            6'b0?100?: z = 1'b1;  
            6'b0?110?: z = 1'b0;  
            6'b0?1010: z = 1'b1;  
            6'b0?1111: z = 1'b0;  
            6'b100?0?: z = 1'b1;  
            6'b110?0?: z = 1'b0;  
            6'b100?10: z = 1'b1;  
            6'b110?11: z = 1'b0;  
            6'b10100?: z = 1'b1;  
            6'b11110?: z = 1'b0;  
            6'b101010: z = 1'b1;  
            6'b111111: z = 1'b0;  
            default: z = 1'bx;
        endcase
endmodule







module zmuxi41d_prim (z, d0, d1, d2, d3, s0, s1, s2, s3);
output z;
input  d0, d1, d2, d3, s0, s1, s2, s3;
// for Blacktie



wire [3:0] sel = {s0,s1,s2,s3}; // 0in one_hot
reg z;
    always @ (s3 or d3 or s2 or d2 or s1 or d1 or s0 or d0)
        casez ({s3,d3,s2,d2,s1,d1,s0,d0})
            8'b0?0?0?10: z = 1'b1;
            8'b0?0?0?11: z = 1'b0;
            8'b0?0?100?: z = 1'b1;
            8'b0?0?110?: z = 1'b0;
            8'b0?0?1010: z = 1'b1;
            8'b0?0?1111: z = 1'b0;
            8'b0?100?0?: z = 1'b1;
            8'b0?110?0?: z = 1'b0;
            8'b0?100?10: z = 1'b1;
            8'b0?110?11: z = 1'b0;
            8'b0?10100?: z = 1'b1;
            8'b0?11110?: z = 1'b0;
            8'b0?101010: z = 1'b1;
            8'b0?111111: z = 1'b0;
            8'b100?0?0?: z = 1'b1;
            8'b110?0?0?: z = 1'b0;
            8'b100?0?10: z = 1'b1;
            8'b110?0?11: z = 1'b0;
            8'b100?100?: z = 1'b1;
            8'b110?110?: z = 1'b0;
            8'b100?1010: z = 1'b1;
            8'b110?1111: z = 1'b0;
            8'b10100?0?: z = 1'b1;
            8'b11110?0?: z = 1'b0;
            8'b10100?10: z = 1'b1;
            8'b11110?11: z = 1'b0;
            8'b1010100?: z = 1'b1;
            8'b1111110?: z = 1'b0;
            8'b10101010: z = 1'b1;
            8'b11111111: z = 1'b0;
            default: z = 1'bx;
        endcase   
endmodule



module zsoff_prim (q, so, ck, d, se, sd);
output q, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q  = q_r;
  assign so = q_r ;
endmodule


module zsoffr_prim (q, so, ck, d, se, sd, r_l);
output q, so;
input  ck, d, se, sd, r_l;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (d & r_l) ;
  assign q  = q_r;
  assign so = q_r;
endmodule


module zsoffi_prim (q_l, so, ck, d, se, sd);
output q_l, so;
input  ck, d, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : d;
  assign q_l = ~q_r;
  assign so  = q_r;
endmodule



module zsoffm2_prim (q, so, ck, d0, d1, s, se, sd);
output q, so;
input  ck, d0, d1, s, se, sd;
reg    q_r;
  always @ (posedge ck)
      q_r <= se ? sd : (s ? d1 : d0) ;
  assign q  = q_r;
  assign so = q_r;
endmodule

module zsoffasr_prim (q, so, ck, d, r_l, s_l, se, sd);
  output q, so;
  input ck, d, r_l, s_l, se, sd;

  // asynchronous reset and asynchronous set
  // (priority: r_l > s_l > se > d)
  reg q;
  wire so;

  always @ (posedge ck or negedge r_l or negedge s_l) begin
		if(~r_l) q <= 1'b0;
		else if (~s_l) q <= r_l;
		else if (se) q <= r_l & s_l & sd;
		else q <= r_l & s_l & (~se) & d;
  end

  assign so = q | ~se;

endmodule



module zckenbuf_prim (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
reg    clken;

  always @ (rclk or en_l or tm_l)
    if (!rclk)  //latch opens on rclk low phase
      clken <= ~en_l | ~tm_l;
  assign clk = clken & rclk;

endmodule

module bw_mckbuf_40x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_33x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_30x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_28x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_25x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_22x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_19x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_17x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_14x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_11x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_8x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_7x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_6x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_4p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_3x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

module bw_mckbuf_1p5x (clk, rclk, en);
output clk;
input  rclk;
input  en;

    assign clk = rclk & en ;

endmodule

//bw_u1_minbuf_1x
//

module bw_u1_minbuf_1x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_4x
//

module bw_u1_minbuf_4x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

//bw_u1_minbuf_5x
//

module bw_u1_minbuf_5x (
    z,
    a );

    output z;
    input  a;

    assign z = ( a );

endmodule

module bw_u1_ckenbuf_4p5x  (clk, rclk, en_l, tm_l);
output clk;
input  rclk, en_l, tm_l;
        zckenbuf_prim i0 ( clk, rclk, en_l, tm_l );
endmodule 

// dummy fill modules to get rid of DFT "CAP" property errors (bug 5487)

module bw_u1_fill_1x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_2x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_3x(\vdd! );
input \vdd! ;
endmodule

module bw_u1_fill_4x(\vdd! );
input \vdd! ;
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_in.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:	ucb_bus_in (ucb bus inbound interface block)
//  Description:	This interface block is instaniated by the
//                      UCB modules and IO Bridge to receive packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
			// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// Interface signal list declarations
////////////////////////////////////////////////////////////////////////
module ucb_bus_in (/*AUTOARG*/
   // Outputs
   stall, indata_buf_vld, indata_buf,
   // Inputs
   rst_l, clk, vld, data, stall_a1
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;


////////////////////////////////////////////////////////////////////////
// Signal declarations
////////////////////////////////////////////////////////////////////////
   // Global interface
   input                     rst_l;
   input 		     clk;


   // UCB bus interface
   input 		     vld;
   input [UCB_BUS_WIDTH-1:0] data;
   output 		     stall;


   // Local interface
   output 		     indata_buf_vld;
   output [REG_WIDTH+63:0]   indata_buf;
   input 		     stall_a1; // would this prevent indata_buf to change?


   // Internal signals
   wire 		     vld_d1;
   wire 		     stall_d1;
   wire [UCB_BUS_WIDTH-1:0]  data_d1;
   wire 		     skid_buf0_en;
   wire 		     vld_buf0;
   wire [UCB_BUS_WIDTH-1:0]  data_buf0;
   wire 		     skid_buf1_en;
   wire 		     vld_buf1;
   wire [UCB_BUS_WIDTH-1:0]  data_buf1;
   wire 		     skid_buf0_sel;
   wire 		     skid_buf1_sel;
   wire 		     vld_mux;
   wire [UCB_BUS_WIDTH-1:0]  data_mux;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec_next;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] indata_vec;
   wire [REG_WIDTH+63:0]     indata_buf_next;
   wire 		     indata_vec0_d1;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    * This is to make signals going between IOB and UCB flop-to-flop
    * to improve timing.
    ************************************************************/
   dffrle_ns #(1) vld_d1_ff (.din(vld),
			     .rst_l(rst_l),
			     .en(~stall_d1),
			     .clk(clk),
			     .q(vld_d1));

   dffe_ns #(UCB_BUS_WIDTH) data_d1_ff (.din(data),
					.en(~stall_d1),
					.clk(clk),
					.q(data_d1));

   dffrl_ns #(1) stall_ff (.din(stall_a1),
			   .clk(clk),
			   .rst_l(rst_l),
			   .q(stall));

   dffrl_ns #(1) stall_d1_ff (.din(stall),
			      .clk(clk),
			      .rst_l(rst_l),
			      .q(stall_d1));


   /************************************************************
    * Skid buffer
    * We need a two deep skid buffer to handle stalling.
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   // Buffer 0
   assign 	 skid_buf0_en = stall_a1 & ~stall;

   dffrle_ns #(1) vld_buf0_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf0_en),
			       .clk(clk),
			       .q(vld_buf0));

   dffe_ns #(UCB_BUS_WIDTH) data_buf0_ff (.din(data_d1),
					  .en(skid_buf0_en),
					  .clk(clk),
					  .q(data_buf0));

   // Buffer 1
   dffrl_ns #(1) skid_buf1_en_ff (.din(skid_buf0_en),
				  .clk(clk),
				  .rst_l(rst_l),
				  .q(skid_buf1_en));

   dffrle_ns #(1) vld_buf1_ff (.din(vld_d1),
			       .rst_l(rst_l),
			       .en(skid_buf1_en),
			       .clk(clk),
			       .q(vld_buf1));

   dffe_ns #(UCB_BUS_WIDTH) data_buf1_ff (.din(data_d1),
					  .en(skid_buf1_en),
					  .clk(clk),
					  .q(data_buf1));


   /************************************************************
    * Mux between skid buffer and interface flop
    ************************************************************/
   // Assertion: stall has to be deasserted for more than 1 cycle
   //            ie time between two separate stalls has to be
   //            at least two cycles.  Otherwise, contents from
   //            skid buffer will be lost.

   assign 	 skid_buf0_sel = ~stall_a1 & stall;

   dffrl_ns #(1) skid_buf1_sel_ff (.din(skid_buf0_sel),
				   .clk(clk),
				   .rst_l(rst_l),
				   .q(skid_buf1_sel));

   assign 	 vld_mux = skid_buf0_sel ? vld_buf0 :
		           skid_buf1_sel ? vld_buf1 :
		                           vld_d1;

   assign 	 data_mux = skid_buf0_sel ? data_buf0 :
		            skid_buf1_sel ? data_buf1 :
		                            data_d1;


   /************************************************************
    * Assemble inbound data
    ************************************************************/
   // valid vector
   assign 	 indata_vec_next = {vld_mux,
				    indata_vec[(REG_WIDTH+64)/UCB_BUS_WIDTH-1:1]};
   dffrle_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) indata_vec_ff (.din(indata_vec_next),
							    .en(~stall_a1),
							    .rst_l(rst_l),
							    .clk(clk),
							    .q(indata_vec));

   // data buffer
   assign 	 indata_buf_next = {data_mux,
				    indata_buf[REG_WIDTH+63:UCB_BUS_WIDTH]};
   dffe_ns #(REG_WIDTH+64) indata_buf_ff (.din(indata_buf_next),
					  .en(~stall_a1),
					  .clk(clk),
					  .q(indata_buf));

   // detect a new packet
   dffrle_ns #(1) indata_vec0_d1_ff (.din(indata_vec[0]),
				     .rst_l(rst_l),
				     .en(~stall_a1),
				     .clk(clk),
				     .q(indata_vec0_d1));

   assign        indata_buf_vld = indata_vec[0] & ~indata_vec0_d1;


endmodule // ucb_bus_in
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: ucb_bus_out.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:        ucb_bus_out (ucb bus outbound interface block)
//	Description:	This interface block is instantiated by the
//                      UCB modules and IO Bridge to transmit packets
//                      on the UCB bus.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which
                        // contains the time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module ucb_bus_out (/*AUTOARG*/
   // Outputs
   vld, data, outdata_buf_busy,
   // Inputs
   clk, rst_l, stall, outdata_buf_in, outdata_vec_in, outdata_buf_wr
   );

   // synopsys template

   parameter UCB_BUS_WIDTH = 32;
   parameter REG_WIDTH = 64;            // maximum data bits that needs to
                                        // be sent.  Set to 64 or 128

   // Globals
   input                                clk;
   input 				rst_l;


   // UCB bus interface
   output 				vld;
   output [UCB_BUS_WIDTH-1:0] 		data;
   input 				stall;


   // Local interface
   output 				outdata_buf_busy;  // busy outputting, can't accept data into buffer
   input [REG_WIDTH+63:0] 		outdata_buf_in;
   input [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] outdata_vec_in; // indicating how much data to send
   input 				outdata_buf_wr;


   // Local signals
   wire 				stall_d1;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec;
   wire [(REG_WIDTH+64)/UCB_BUS_WIDTH-1:0] 	outdata_vec_next;
   wire [REG_WIDTH+63:0] 		outdata_buf;
   reg [REG_WIDTH+63:0] 		outdata_buf_next;
   wire 				load_outdata;
   wire 				shift_outdata;


////////////////////////////////////////////////////////////////////////
// Code starts here
////////////////////////////////////////////////////////////////////////
   /************************************************************
    * UCB bus interface flops
    ************************************************************/
   assign 	 vld = outdata_vec[0];
   // assign 	 data = vld ? outdata_buf[UCB_BUS_WIDTH-1:0] : `UCB_BUS_WIDTH'b0;
   assign    data = outdata_buf[UCB_BUS_WIDTH-1:0];

   dffrl_ns #(1) stall_d1_ff (.din(stall),
                              .clk(clk),
                              .rst_l(rst_l),
                              .q(stall_d1));


   /************************************************************
    * Outbound Data
    ************************************************************/
   // accept new data only if there is none being processed
   assign 	 load_outdata = outdata_buf_wr & ~outdata_buf_busy;

   assign 	 outdata_buf_busy = outdata_vec[0] | stall_d1;

   // only shifts when then input vector is a straight valids
   assign 	 shift_outdata = outdata_vec[0] & ~stall_d1;

   assign 	 outdata_vec_next =
		 load_outdata  ? outdata_vec_in:
		 shift_outdata ? outdata_vec >> 1:
	                         outdata_vec;
   dffrl_ns #((REG_WIDTH+64)/UCB_BUS_WIDTH) outdata_vec_ff (.din(outdata_vec_next),
							    .clk(clk),
							    .rst_l(rst_l),
							    .q(outdata_vec));

   // assign 	 outdata_buf_next =
		 // load_outdata  ? outdata_buf_in:
		 // shift_outdata ? (outdata_buf >> UCB_BUS_WIDTH):
	  //                        outdata_buf;
   always @ *
   begin
      if (load_outdata)
         outdata_buf_next = outdata_buf_in;
      else if (shift_outdata)
      begin
         outdata_buf_next = outdata_buf >> UCB_BUS_WIDTH;
         if (outdata_vec[1] == 1'b0)
            outdata_buf_next[UCB_BUS_WIDTH-1:0] = 0;
      end
      else
         outdata_buf_next = outdata_buf; // no shifting
   end

   dff_ns #(REG_WIDTH+64) outdata_buf_ff (.din(outdata_buf_next),
					  .clk(clk),
					  .q(outdata_buf));


endmodule // ucb_bus_out






// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//File: valrdy_to_credit.v (modified from space_avail_top.v)
//
//Modified: Yaosheng Fu
//May 2, 2014
//
//Function: This module keeps track of how many spots are free in the NIB that
//	we are sending to
//
//State: count_f, yummy_out_f, valid_in_f
//
//Instantiates: 
//

module valrdy_to_credit (
            clk,
            reset,
                
            //val/rdy interface
            data_in,
            valid_in,
            ready_in,

			//credit based interface	
            data_out,
            valid_out,
		    yummy_out);

parameter BUFFER_SIZE = 4;
parameter BUFFER_BITS = 3;
   
input clk;
input reset;

 
input [64-1:0]	 data_in;
 input valid_in;			// sending data to the output
 input yummy_out;			// output consumed data

output [64-1:0]  data_out;
 output valid_out;
 output ready_in;		// is there space available?


//This is the state
 reg yummy_out_f;
 reg valid_temp_f;
 reg [BUFFER_BITS-1:0] count_f;

reg is_one_f;
 reg is_two_or_more_f;

//wires
 wire [BUFFER_BITS-1:0] count_plus_1;
 wire [BUFFER_BITS-1:0] count_minus_1;
 wire up;
 wire down;

 wire valid_temp;

//wire regs
  reg [BUFFER_BITS-1:0] count_temp;


//assigns
assign data_out = data_in;
assign valid_temp = valid_in & ready_in;
assign valid_out = valid_temp;

assign count_plus_1 = count_f + 1'b1;
assign count_minus_1 = count_f - 1'b1;
assign ready_in = is_two_or_more_f;
assign up = yummy_out_f & ~valid_temp_f;
assign down = ~yummy_out_f & valid_temp_f;

always @ (count_f or count_plus_1 or count_minus_1 or up or down)
begin
	case (count_f)
	0:
		begin
			if(up)
			begin
				count_temp <= count_plus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	BUFFER_SIZE:
		begin
			if(down)
			begin
				count_temp <= count_minus_1;
			end
			else
			begin
				count_temp <= count_f;
			end
		end
	default:
		begin
			case ({up, down})
				2'b10:	count_temp <= count_plus_1;
				2'b01:	count_temp <= count_minus_1;
				default:	count_temp <= count_f;
			endcase
		end
	endcase
end

//wire top_bits_zero_temp = ~| count_temp[BUFFER_BITS-1:1];
 wire top_bits_zero_temp = count_temp < 3 ? 1 : 0;

always @ (posedge clk)
begin
	if(reset)
	begin
	   count_f <= BUFFER_SIZE;
	   yummy_out_f <= 1'b0;
	   valid_temp_f <= 1'b0;
	   is_one_f <= (BUFFER_SIZE == 1);
	   is_two_or_more_f <= (BUFFER_SIZE >= 2);
	end
	else
	begin
	   count_f <= count_temp;
	   yummy_out_f <= yummy_out;
	   valid_temp_f <= valid_temp;
	   is_one_f         <= top_bits_zero_temp & count_temp[0];
   	   is_two_or_more_f <= ~top_bits_zero_temp;
	end
end

endmodule
      
/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//l15.h
// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




// Uncomment to define USE_GENERIC_SRAM_IMPLEMENTATION to use the old unsynthesizable BRAM
// `define USE_GENERIC_SRAM_IMPLEMENTATION




/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/////////////////////////////////////////////////////////////////////////////////////////////
// 63         50 49      42 41      34 33           30 29      22 21                 0   
// ------------------------------------------------------------------------------------
// |            |          |          |               |          |                    |
// |  Chip ID   |  Dest X  |  Dest Y  |  Final Route  |  Length  |    Header Payload  | 
// |            |          |          |               |          |                    |
// ------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////











 //whether the routing is based on chipid or x y position
 //`define    ROUTING_CHIP_ID
 

 //defines for different topology, only one should be active
 //`define    NETWORK_TOPO_2D_MESH
 //`define    NETWORK_TOPO_3D_MESH
 

// Tile config

// devices.xml





// NoC interface





















// NodeID decomposition








//========================
//Packet format
//=========================

//Header decomposition































// these shifted fields are added for convienience
// HEADER 2







// HEADER 3








//NoC header information










// Width of MSG_ADDR field - you're probably looking for PHY_ADDR_WIDTH


//Coherence information





//Requests from L15 to L2
// Should always make #0 an error








//condition satisfied

//condition not satisfied

//Both SWAP and LDSTUB are the same for L2









//RISC-V AMO requests









//RISC-V AMO L2-internal phase 1









//RISC-V AMO L2-internal phase 2












//Forward requests from L2 to L15







//Memory requests from L2 to DRAM






//Forward acks from L15 to L2







//Memory acks from memory to L2









//Acks from L2 to L15


//TODO



//Only exist within L2





//`define MSG_TYPE_LOAD_REQ           8'd31 if this is enabled, don't use 31





// These should be defined in l2.vh, not the global defines











//Physical address










//Transition data size












//`define HOME_ID_MASK_X          10:10
//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only


// Tri: dynamically adjust these parameters based on how many tiles are available
//  Assumption: 8x8 topology























































//`define DMBR_TAG_WIDTH 4

//Clumpy Shared Memory






////////////////////////////////////////////
// SOME CONFIGURATION REGISTERS DEFINES
////////////////////////////////////////////
// example: read/write to csm_en would be 0xba_0000_0100

// `define ASI_ADDRESS_MASK    `L15_ADDR_TYPE
// `define CONFIG_ASI_ADDRESS  `L15_ADDR_TYPE_WIDTH'hba










// DMBR Config register 1 fields















// DMBR Config register 2 fields



//Home allocation method






//Additional fields for Sharer Domain ID and Logical Sharer ID
//For coherence domain restriction only

































//`define TTE_CSM_WIDTH           64
//`define TTE_CSM                 63:0
//`define TTE_CSM_VALID           63
//`define TTE_CSM_SZL             62:61
//`define TTE_CSM_NFO             60
//`define TTE_CSM_IE              59
//`define TTE_CSM_SOFT2           58:49
//`define TTE_CSM_SZH             48
//`define TTE_CSM_DIAG            47:40
//`define TTE_CSM_RES1            39
//`define TTE_CSM_SDID            38:29
//`define TTE_CSM_HDID            28:19
//`define TTE_CSM_LSID            18:13
//`define TTE_CSM_SOFT            12:8
//`define TTE_CSM_RES2            7
//`define TTE_CSM_LOCK            6
//`define TTE_CSM_CP              5
//`define TTE_CSM_CV              4
//`define TTE_CSM_E               3
//`define TTE_CSM_P               2
//`define TTE_CSM_W               1
//`define TTE_CSM_RES3            0












// Packet format for home id





/////////////////////////////////////
// BIST
/////////////////////////////////////

// the data width from tap to individual sram wrappers



//deprecated































/////////////////////////////////////
// IDs for JTAG-Core interface
/////////////////////////////////////

// 48b for writing the PC reset vector

// 94b for reading the sscan data











// Execution Drafting Synchronization Method Values





// Execution Drafting timeout counter bit width


// Configuration registers












// Execution Drafting configuration register bit positions








// Execution Drafting configuration register default values
// ED disabled, STSM sync method, LFSR seed = 16'b0, LFSR load = 1'b0,
// Counter Timeout = 16'd32



//Clumpy sharer memory configuration registers
























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]






// `define L15_CACHELINE_WIDTH 128

















// devices.xml
// this is used in the ariane SV packages to derive the parameterization

















































// 7

// 7




// 16B cache lines

// 10




// 40 - 4 (16B line) - 7 (index width) = 29

// 11

// 39


// this need to be defined when L1.5 has more sets than L1D
// for correct operations
// `define L15_WMT_EXTENDED_ALIAS


















// `define L15_WMT_ENTRY_0_MASK 1*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_1_MASK 2*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_2_MASK 3*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_3_MASK 4*`L15_WMT_ENTRY_WIDTH-1 -: `L15_WMT_ENTRY_WIDTH
// `define L15_WMT_ENTRY_0_VALID_MASK 1*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_1_VALID_MASK 2*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_2_VALID_MASK 3*`L15_WMT_ENTRY_WIDTH-1
// `define L15_WMT_ENTRY_3_VALID_MASK 4*`L15_WMT_ENTRY_WIDTH-1


  
  


  
  







// LRU array storage
// keeps 6 bits per cache set: 4 "used" bits, 1 each cache line, and 2 bits for wayid round robin (4w)





// source





// MSHR






// controls how many mshr there are
// `define L15_MSHR_COUNT 10
// should be more than the count above when 2^n











// pipeline OPs




// `define L15_MSHR_ALLOCATE_TYPE_WIDTH 2
// `define L15_MSHR_ALLOCATE_TYPE_LD 2'd1
// `define L15_MSHR_ALLOCATE_TYPE_ST 2'd2
// `define L15_MSHR_ALLOCATE_TYPE_IFILL 2'd3









































































































// `define PCX_REQ_SIZE_WIDTH 4


























// define the width of the flattened, native L15 interface, used for ARIANE_RV64 option



























// [L15_DTAG_OP_WIDTH-1:0]































//`define L15_S3_MESI_WRITE_TAGCHECK_WAY_M_IF_LRSC_SET 3'd7






























































// `define L15_NOC1_DUMMY_GEN_NOC1_CREDIT 5'd11










































// L2 shared states


// `define L15_NOC2_ACK_STATE_WIDTH 2
// `define L15_NOC2_ACK_STATE_S 2'd1
// `define L15_NOC2_ACK_STATE_E 2'd2
// `define L15_NOC2_ACK_STATE_M 2'd3

// `define L15_NOC1_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC1_REQTYPE_WRITEBACK_GUARD `MSG_TYPE_WBGUARD_REQ
// `define L15_NOC1_REQTYPE_LD_REQUEST `MSG_TYPE_LOAD_REQ
// `define L15_NOC1_REQTYPE_LD_PREFETCH_REQUEST `MSG_TYPE_PREFETCH_REQ
// `define L15_NOC1_REQTYPE_LD_NC_REQUEST `MSG_TYPE_NC_LOAD_REQ
// `define L15_NOC1_REQTYPE_IFILL_REQUEST `MSG_TYPE_LOAD_REQ
// // `define L15_NOC1_REQTYPE_WRITETHROUGH_REQUEST 6'd4
// `define L15_NOC1_REQTYPE_ST_REQUEST `MSG_TYPE_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_REQUEST `MSG_TYPE_BLK_STORE_REQ
// `define L15_NOC1_REQTYPE_BLK_ST_INIT_REQUEST `MSG_TYPE_BLKINIT_STORE_REQ
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE__REQUEST
// // `define L15_NOC1_REQTYPE_ST_UPGRADE_REQUEST 6
// // `define L15_NOC1_REQTYPE_ST_FILL_REQUEST 6'd6
// `define L15_NOC1_REQTYPE_CAS_REQUEST `MSG_TYPE_CAS_REQ
// `define L15_NOC1_REQTYPE_SWAP_REQUEST `MSG_TYPE_SWAP_REQ

// `define L15_NOC3_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L15_NOC3_REQTYPE_WRITEBACK `MSG_TYPE_WB_REQ
// `define L15_NOC3_REQTYPE_NO_DATA_FWD_ACK `MSG_TYPE_NODATA_ACK
// `define L15_NOC3_REQTYPE_DATA_FWD_ACK `MSG_TYPE_DATA_ACK

// `define L2_REQTYPE_WIDTH `MSG_TYPE_WIDTH
// `define L2_REQTYPE_INVALIDATE 6'd1
// `define L2_REQTYPE_DOWNGRADE 6'd2
// `define L2_REQTYPE_ACKDT_LD_NC 6'd3
// `define L2_REQTYPE_ACKDT_IFILL 6'd4
// `define L2_REQTYPE_ACKDT_LD 6'd5
// `define L2_REQTYPE_ACKDT_ST_IM 6'd6
// `define L2_REQTYPE_ACKDT_ST_SM 6'd7
// `define L2_REQTYPE_ACK_WRITETHROUGH 6'd8
// `define L2_REQTYPE_ACK_ATOMIC 6'd9






































// NOC1 ENCODER











// NOC3 ENCODER










// NOC2 BUFFER





// DMBR
// put this here for now, should be moved to a more appropriate location


// NOC1 CREDIT MANAGEMENT
// becareful, the noc1buffer module assumes these are power of two
// also, please change the corresponding pyv value in noc1buffer.v.pyv























// `define L15_NOC1BUFFER_BLKSTORE_LO  `L15_NOC1BUFFER_PREFETCH_HI + 1
// `define L15_NOC1BUFFER_BLKSTORE_HI  `L15_NOC1BUFFER_BLKSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_BLKINITSTORE_LO  `L15_NOC1BUFFER_BLKSTORE_HI + 1
// `define L15_NOC1BUFFER_BLKINITSTORE_HI  `L15_NOC1BUFFER_BLKINITSTORE_LO + 1 - 1
// `define L15_NOC1BUFFER_DATA_INDEX_LO  `L15_NOC1BUFFER_BLKINITSTORE_HI + 1
































// `define L15_CPUID_ADDRESS 40'h9800000900






////////////////
// CSM
////////////////



// Tri: save space on l15 sram






















//HMC array
































//Special addresses for HMC


//`define L15_ADDR_TYPE_TAG_ACCESS     8'hb4 // later
//`define L15_ADDR_TYPE_STATE_ACCESS   8'hb6 // later
//`define L15_ADDR_TYPE_DIR_ACCESS     8'hb1 // later
//`define L15_ADDR_TYPE_CTRL_REG       8'hb9
//`define L15_ADDR_TYPE_DIS_FLUSH      8'hbc, 8'hbd, 8'hbe, 8'hbf
// `define L15_ADDR_TYPE_HMT_BASE_REG      8'hb7


















// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































// devices.xml



module flat_id_to_xy(
    input  [(6-1):0] flat_id,
    output reg [(8-1):0] x_coord,
    output reg [(8-1):0] y_coord
);

    always @*
    begin
        case (flat_id)
        
//(`NOC_Y_WIDTH+`NOC_X_WIDTH)'d0: 
6'd0: 
begin
    x_coord = 3'd0;
    y_coord = 3'd0;
end

        default:
        begin
            x_coord = 3'dX;
            y_coord = 3'dX;
        end
        endcase
    end
endmodule

/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































module sram_1rw_128x78
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [7-1:0] A,
input wire RDWEN,
input wire [78-1:0] BW,
input wire [78-1:0] DIN,
output wire [78-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [78-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (128),
   .ADDR_WIDTH    (7),
   .BITMASK_WIDTH (78),
   .DATA_WIDTH    (78)
)   sram_1rw_128x78 (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// Author: Tri Nguyen

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE







module sram_l1d_data_piton
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6:0] A,
input wire RDWEN,
input wire [287:0] BW,
input wire [287:0] DIN,
output wire [287:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);
reg [287:0] cache [(256/2)-1:0];

integer i;
initial
begin
   for (i = 0; i < (256/2); i = i + 1)
   begin
      cache[i] = 0;
   end
end



   reg [287:0] dout_f;

   assign DOUT = dout_f;

   always @ (posedge MEMCLK)
   begin
      if (CE)
      begin
         if (RDWEN == 1'b0)
            cache[A] <= (DIN & BW) | (cache[A] & ~BW);
         else
            dout_f <= cache[A];
      end
   end

endmodule



















































































/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































module sram_l1d_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [(6+1)-1:0] A,
input wire RDWEN,
input wire [(33*2)-1:0] BW,
input wire [(33*2)-1:0] DIN,
output wire [(33*2)-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [(33*2)-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         ((256/2)),
   .ADDR_WIDTH    ((6+1)),
   .BITMASK_WIDTH ((33*2)),
   .DATA_WIDTH    ((33*2))
)   sram_l1d_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































module sram_l1i_data
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+2-1:0] A,
input wire RDWEN,
input wire [272-1:0] BW,
input wire [272-1:0] DIN,
output wire [272-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [272-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((8192/32/2))*2),
   .ADDR_WIDTH    (6+2),
   .BITMASK_WIDTH (272),
   .DATA_WIDTH    (272)
)   sram_l1i_data (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule


/*
Copyright (c) 2015 Princeton University
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Princeton University nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// 02/06/2015 14:58:59
// This file is auto-generated
// Author: Tri Nguyen

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













// devices.xml

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































module sram_l1i_tag
(
input wire MEMCLK,
input wire RESET_N,
input wire CE,
input wire [6+1-1:0] A,
input wire RDWEN,
input wire [132-1:0] BW,
input wire [132-1:0] DIN,
output wire [132-1:0] DOUT,
input wire [4-1:0] BIST_COMMAND,
input wire [4-1:0] BIST_DIN,
output reg [4-1:0] BIST_DOUT,
input wire [8-1:0] SRAMID
);


wire [132-1:0] DOUT_bram;
assign DOUT = DOUT_bram;

bram_1rw_wrapper #(
   .NAME          (""             ),
   .DEPTH         (((8192/32/2))),
   .ADDR_WIDTH    (6+1),
   .BITMASK_WIDTH (132),
   .DATA_WIDTH    (132)
)   sram_l1i_tag (
   .MEMCLK        (MEMCLK     ),
   .RESET_N        (RESET_N     ),
   .CE            (CE         ),
   .A             (A          ),
   .RDWEN         (RDWEN      ),
   .BW            (BW         ),
   .DIN           (DIN        ),
   .DOUT          (DOUT_bram       )
);
      






























 

 endmodule

// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module implements the generic portions of the Execution Drafting
 *      FSM.  Anything common to all synchronization methods is implemented
 *      here.  
 *
 *  Note: While the interface to this module supports 4 threads, the logic
 *  only supports 2
 */

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































module sparc_ifu_esl_fsm
(
    input               clk,
    input               rst_n,

    // Configuration bits input
    input               config_esl_en,
    input [1:0]         config_esl_sync_method,

    // Counter timeout configuration value
    input [15:0]        config_esl_counter_timeout,

    // LFSR management signals
    input [15:0]        config_esl_lfsr_seed,
    input               config_esl_lfsr_ld,

    // Thread active signals from FSM
    input [3:0]         swl_esl_thr_active,

    // Thread ready signals from FSM, both non-speculative
    // ready and speculative ready
    input [3:0]         swl_esl_thr_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy_next,

    // Whether to use speculative rdy vector, meaning
    // there is no non-speculative ready thread
    input               swl_esl_use_spec,

    // Instructions valid in S
    input [3:0]         fcl_esl_tinst_vld_s,

    // Thread in F stage
    input [3:0]         fcl_esl_thr_f,

    // Rollback on this cycle
    input               fcl_esl_rb_stg_s,

    // Information about threads in thread select stage
    input               esl_tirs_eql_s,
    input               esl_ops_eql_s,
    input               esl_pcs_pa_eql_s,
    input               esl_ctrl_flow_diverged_late_s,
    input               esl_pcs_pa_page_bndry_s,
    input               esl_any_trap_bf,
    input [3:0]         esl_min_pc_va_s,
    input               esl_pc_va_diff_lt_thresh_s,
    input               esl_pcs_va_eql_s,
    input               esl_unresolved_br,
    input               esl_brtrp_target_pc_bf_f,
    input               swl_esl_icmiss_out,

    // Synchronization output
    output reg [3:0]    esl_fcl_nextthr_bf,
    output reg          esl_fcl_stall_bf,
    output reg          esl_fcl_switch_bf,
    output reg          esl_fdp_sync_pcs_bf,
    output reg          esl_fcl_ntr_s,
    output reg          esl_fdp_issue_prev_inst_next_s,
    output reg          esl_fcl_force_running_s,
    output reg          esl_pc_va_diff_offset_we,
    output reg          esl_pc_va_diff_offset_clear
);

    //
    // Parameter Definitions
    //

    // State definitions
    localparam  DIVERGED = 0;
    localparam  DIVERGED_DRAFT = 1;
    localparam  CONVERGED = 2;
    localparam  CONVERGED_DRAFT = 3;
    localparam  DIVERGED_DIFFERENT_CODE_RCFG0 = 4;
    localparam  RCFG1 = 5;
    localparam  RCFG2 = 6;
    localparam  RCFG3 = 7;

    //
    // Signal Declarations
    //
    
    // LFSR control and output
    reg         esl_lfsr_step;
    wire        pseudo_rand_f;

    // Timeout counter control and output
    reg                                         esl_timeout_counter_step;
    reg                                         esl_timeout_counter_clear;
    reg                                         esl_timeout_counter_set;
    wire [16-1:0]    esl_timeout_counter_count_f;

    // Shift Register control and output
    reg                                         esl_timeout_shiftreg_step;
    reg                                         esl_timeout_shiftreg_set;
    wire [16-1:0]    esl_timeout_shiftreg_f;

    // Control signals for comparator for timeout control.
    // 1'b1 - Compare to configured timeout
    // 1'b0 - Compare to shift register
    reg                                         esl_timeout_counter_cmp_config;

    // Next state output decisions
    wire [2:0]  esl_stsm_state_next;
    wire [2:0]  esl_rtsm_state_next;
    wire [2:0]  esl_htsm_state_next;
    wire [2:0]  esl_rcfg_state_next;

    // Thread select output decisions
    wire [3:0]  esl_stsm_fcl_nextthr_bf;
    wire [3:0]  esl_rtsm_fcl_nextthr_bf;
    wire [3:0]  esl_htsm_fcl_nextthr_bf;
    wire [3:0]  esl_rcfg_fcl_nextthr_bf;

    // Thread switch output decisions
    wire        esl_stsm_fcl_switch_bf;
    wire        esl_rtsm_fcl_switch_bf;
    wire        esl_htsm_fcl_switch_bf;
    wire        esl_rcfg_fcl_switch_bf;

    // Thread switch out/ready output decisions
    wire        esl_stsm_fcl_ntr_s;
    wire        esl_rtsm_fcl_ntr_s;
    wire        esl_htsm_fcl_ntr_s;
    wire        esl_rcfg_fcl_ntr_s;

    // LFSR step outputs
    wire        esl_stsm_lfsr_step;
    wire        esl_rtsm_lfsr_step;
    wire        esl_htsm_lfsr_step;
    wire        esl_rcfg_lfsr_step;

    // Timeout counter step and clear outputs
    wire        esl_stsm_timeout_counter_step;
    wire        esl_stsm_timeout_counter_clear;
    wire        esl_stsm_timeout_counter_set;
    wire        esl_rtsm_timeout_counter_step;
    wire        esl_rtsm_timeout_counter_clear;
    wire        esl_rtsm_timeout_counter_set;
    wire        esl_htsm_timeout_counter_step;
    wire        esl_htsm_timeout_counter_clear;
    wire        esl_htsm_timeout_counter_set;
    wire        esl_rcfg_timeout_counter_step;
    wire        esl_rcfg_timeout_counter_clear;
    wire        esl_rcfg_timeout_counter_set;

    // Shift register step and set outputs
    wire        esl_stsm_timeout_shiftreg_step;
    wire        esl_stsm_timeout_shiftreg_set;
    wire        esl_rtsm_timeout_shiftreg_step;
    wire        esl_rtsm_timeout_shiftreg_set;
    wire        esl_htsm_timeout_shiftreg_step;
    wire        esl_htsm_timeout_shiftreg_set;
    wire        esl_rcfg_timeout_shiftreg_step;
    wire        esl_rcfg_timeout_shiftreg_set;

    // Timeout counter comparison control signal output
    wire        esl_stsm_timeout_counter_cmp_config;
    wire        esl_rtsm_timeout_counter_cmp_config;
    wire        esl_htsm_timeout_counter_cmp_config;
    wire        esl_rcfg_timeout_counter_cmp_config;

    // Counter timeout comparison result
    reg         esl_counter_timeout;

    // Offset register control outputs
    wire        esl_stsm_pc_va_diff_offset_we;
    wire        esl_stsm_pc_va_diff_offset_clear;
    wire        esl_rtsm_pc_va_diff_offset_we;
    wire        esl_rtsm_pc_va_diff_offset_clear;
    wire        esl_htsm_pc_va_diff_offset_we;
    wire        esl_htsm_pc_va_diff_offset_clear;
    wire        esl_rcfg_pc_va_diff_offset_we;
    wire        esl_rcfg_pc_va_diff_offset_clear;

    // State declarations
    reg [2:0]   state_f;
    reg [2:0]   state_prev_f;
    reg [2:0]   state_next;

    // Signals to trigger the sync method submodules
    // that we need a thread select decision from it
    reg         esl_stsm_trigger;
    reg         esl_rtsm_trigger;
    reg         esl_htsm_trigger;
    reg         esl_rcfg_trigger; 

    //
    // Sequential Logic
    //

    // State sequential logic
    always @ (posedge clk)
    begin
        if (~rst_n)
        begin
            state_f <= DIVERGED;
            state_prev_f <= DIVERGED;
        end
        else
        begin
            state_f <= state_next;
            state_prev_f <= state_f;
        end
    end

    //
    // Combinational Logic
    //

    // Next state and output logic
    always @ *
    begin
        // Default values
        state_next = state_f;
        esl_fcl_nextthr_bf = 4'b0000;
        esl_fcl_stall_bf = 1'b0;
        esl_fcl_switch_bf = 1'b0;
        esl_fdp_sync_pcs_bf = 1'b0;
        esl_fcl_ntr_s = 1'b0;
        esl_fdp_issue_prev_inst_next_s = 1'b0;
        esl_fcl_force_running_s = 1'b0;
        esl_stsm_trigger = 1'b0;
        esl_rtsm_trigger = 1'b0;
        esl_htsm_trigger = 1'b0;
        esl_rcfg_trigger = 1'b0;

        // If no threads are active, just idle
        if (swl_esl_thr_active == 4'b0000)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0000;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = 1'b0;
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = 1'b0; 
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // If only thr0 is active, just select it
        else if (swl_esl_thr_active == 4'b0001)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0001;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[0];
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[0];
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // If only thr1 is active, just select it
        else if (swl_esl_thr_active == 4'b0010)
        begin
            state_next = DIVERGED;
            esl_fcl_nextthr_bf = 4'b0010;
            esl_fcl_stall_bf = 1'b0;
            esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
            esl_fdp_sync_pcs_bf = 1'b0;
            esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
            esl_fdp_issue_prev_inst_next_s = 1'b0;
            esl_fcl_force_running_s = 1'b0;
        end
        // Otherwise, if both threads are active - need to synchronize
        else if (swl_esl_thr_active == 4'b0011)
        begin
            case (state_f)
                DIVERGED:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s; 
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                DIVERGED_DRAFT:
                begin
                    // Select thr1 and go back to diverged
                    state_next = DIVERGED;
                    esl_fcl_nextthr_bf = 4'b0010;
                    esl_fcl_stall_bf = 1'b0;
                    esl_fcl_switch_bf = 1'b1;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fcl_ntr_s = 1'b1;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                end
                CONVERGED:
                begin
                    // If we diverge due to a page boundary, a branch,
                    // a trap, or a rollback, start fetching for thr1 
                    // again and go to diverged (should reconverge very
                    // quickly after a rollback)
                    if (esl_pcs_pa_page_bndry_s | esl_ctrl_flow_diverged_late_s | 
                        esl_any_trap_bf | fcl_esl_rb_stg_s)
                    begin
                        state_next = DIVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
                        // BUG FIX: Fixes bug of executing an instruction
                        // twice in this case. The instruction for thread
                        // 0 may have just executed on the previous cycle
                        // if we went from CONVERGED->DIVERGED->CONVERGED
                        // without stalling at all.  Thus, the PC just got
                        // updated and we need to synchronize for one more
                        // cycle.  However, in all other cases we should
                        // not sync the PCs, since they may diverge and
                        // we are asking to fetch for thread 1 on the next
                        // cycle, which causes thread 1's PC to change.
                        // BE CAREFUL CHANGING THIS
                        if (state_prev_f != CONVERGED)
                            esl_fdp_sync_pcs_bf = 1'b1;
                        else
                            esl_fdp_sync_pcs_bf = 1'b0;
                        esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
                        esl_fdp_issue_prev_inst_next_s = 1'b0;
                        esl_fcl_force_running_s = 1'b0;
                    end
                    // If at least one thread is not ready, we will just wait
                    // TODO: We may want to change this
                    else if (!(swl_esl_thr_sprdy_or_urdy[0] && 
                               (swl_esl_thr_sprdy_or_urdy[1] || swl_esl_thr_sprdy_or_urdy_next[1])))
                    begin
                        state_next = CONVERGED;
                        esl_fcl_nextthr_bf = 4'b0000;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = 1'b0;
                        // BUG FIX: In the case an I-cache miss occurs,
                        // we do not want to sync the pcs until we know
                        // we are not going to diverge due to a branch later.
                        // If we have a branch followed by another instruction
                        // that misses in the I-cache, thread1 does not
                        // get info that it also missed in the cache
                        // and may skip the instruction that missed
                        if (swl_esl_icmiss_out && esl_unresolved_br)
                            esl_fdp_sync_pcs_bf = 1'b0;
                        else
                            esl_fdp_sync_pcs_bf = 1'b1;
                        esl_fcl_ntr_s = 1'b1; // Note: This switches out any running thread
                        esl_fdp_issue_prev_inst_next_s = 1'b0;
                        esl_fcl_force_running_s = 1'b0;
                    end
                    // Otherwise, both threads are ready
                    else
                    begin 
                        // If instruction for thr0 is not ready, need to wait
                        if (!fcl_esl_tinst_vld_s[0])
                        begin
                            state_next = CONVERGED;
                            esl_fcl_nextthr_bf = 4'b0001;
                            esl_fcl_stall_bf = 1'b0;
                            esl_fcl_switch_bf = 1'b1;
                            esl_fdp_sync_pcs_bf = 1'b1;
                            esl_fcl_ntr_s = 1'b1;
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                        // Otherwise, both threads are ready and 
                        // thr0 instruction is ready
                        else
                        begin
                            state_next = CONVERGED_DRAFT;
                            esl_fcl_nextthr_bf = 4'b0001;
                            esl_fcl_stall_bf = 1'b0;
                            esl_fcl_switch_bf = 1'b1;
                            esl_fdp_sync_pcs_bf = 1'b1;
                            esl_fcl_ntr_s = 1'b1;
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                    end 
                end
                CONVERGED_DRAFT:
                begin
                    // If we diverge due to a page boundary, a branch,
                    // a trap, or a rollback, start fetching for thr1 
                    // again and go to diverged (should reconverge very
                    // quickly after a rollback)  
                    if (esl_pcs_pa_page_bndry_s | esl_ctrl_flow_diverged_late_s |
                        esl_any_trap_bf | fcl_esl_rb_stg_s)
                    begin
                        state_next = DIVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b0;
                        esl_fcl_switch_bf = swl_esl_thr_sprdy_or_urdy[1];
                        esl_fdp_sync_pcs_bf = 1'b0;
                        esl_fcl_ntr_s = swl_esl_thr_sprdy_or_urdy[1];
                        // BUFIX: If the instruction was rolled back,
                        // then NOP is in the previous instruction
                        // register as the previous instruction
                        // was killed. It may be possible to 
                        // grab that instruction from not being
                        // MUXED to a NOP before the execdraft
                        // replay mux to improve performance, but
                        // leaving this as a TODO
                        // BUG FIX: Trap takes precedence over rollback,
                        // need to still draft in case of trap
                        if (fcl_esl_rb_stg_s && !esl_any_trap_bf)
                        begin
                            esl_fdp_issue_prev_inst_next_s = 1'b0;
                            esl_fcl_force_running_s = 1'b0;
                        end
                        else
                        begin
                            esl_fdp_issue_prev_inst_next_s = 1'b1;
                            esl_fcl_force_running_s = 1'b1;
                        end
                    end
                    // Otherwise, we issue previous instruction for thr1
                    // and do not fetch
                    else
                    begin
                        state_next = CONVERGED;
                        esl_fcl_nextthr_bf = 4'b0010;
                        esl_fcl_stall_bf = 1'b1;
                        esl_fcl_switch_bf = 1'b1;
                        esl_fdp_sync_pcs_bf = 1'b1;
                        esl_fcl_ntr_s = 1'b1;
                        esl_fdp_issue_prev_inst_next_s = 1'b1;
                        esl_fcl_force_running_s = 1'b1;
                    end
                end
                DIVERGED_DIFFERENT_CODE_RCFG0:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase 
                end
                RCFG1:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                RCFG2:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                RCFG3:
                begin
                    // Never stall, sync PCs, issue prev instruction 
                    // next, or force running in diverged case
                    esl_fcl_stall_bf = 1'b0;
                    esl_fdp_sync_pcs_bf = 1'b0;
                    esl_fdp_issue_prev_inst_next_s = 1'b0;
                    esl_fcl_force_running_s = 1'b0;
                    // Trigger configured sync method module
                    // and accept outputs from it
                    case (config_esl_sync_method)
                        2'b00:
                        begin
                            esl_stsm_trigger    = 1'b1;
                            state_next          = esl_stsm_state_next;
                            esl_fcl_nextthr_bf  = esl_stsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_stsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_stsm_fcl_ntr_s;
                        end
                        2'b01:
                        begin
                            esl_rtsm_trigger    = 1'b1;
                            state_next          = esl_rtsm_state_next;
                            esl_fcl_nextthr_bf  = esl_rtsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rtsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rtsm_fcl_ntr_s;
                        end
                        2'b10:
                        begin
                            esl_htsm_trigger    = 1'b1;
                            state_next          = esl_htsm_state_next;
                            esl_fcl_nextthr_bf  = esl_htsm_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_htsm_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_htsm_fcl_ntr_s;
                        end
                        2'b11:
                        begin
                            esl_rcfg_trigger    = 1'b1;
                            state_next          = esl_rcfg_state_next;
                            esl_fcl_nextthr_bf  = esl_rcfg_fcl_nextthr_bf;
                            esl_fcl_switch_bf   = esl_rcfg_fcl_switch_bf;
                            esl_fcl_ntr_s       = esl_rcfg_fcl_ntr_s;
                        end
                        default:
                        begin
                            state_next          = 3'bx;
                            esl_fcl_nextthr_bf  = 4'bx;
                            esl_fcl_switch_bf   = 1'bx;
                            esl_fcl_ntr_s       = 1'bx;
                        end
                    endcase
                end
                default:
                begin
                    state_next = 3'bx;
                    esl_fcl_nextthr_bf = 4'bxxxx;
                    esl_fcl_stall_bf = 1'bx;
                    esl_fcl_switch_bf = 1'bx;
                    esl_fdp_sync_pcs_bf = 1'bx;
                    esl_fcl_ntr_s = 1'bx;
                    esl_fdp_issue_prev_inst_next_s = 1'bx;
                    esl_fcl_force_running_s = 1'bx;
                end 
            endcase
        end
    end

    // Signal multiplexing for signals going into shared submodules (counter, LFSR
    // and offset register)
    always @ *
    begin
        case (config_esl_sync_method)
            2'b00:
            begin
                esl_lfsr_step = esl_stsm_lfsr_step;
                esl_timeout_counter_step = esl_stsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_stsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_stsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_stsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_stsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_stsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_stsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_stsm_timeout_counter_cmp_config;
            end
            2'b01:
            begin
                esl_lfsr_step = esl_rtsm_lfsr_step;
                esl_timeout_counter_step = esl_rtsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_rtsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_rtsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_rtsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_rtsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_rtsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_rtsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_rtsm_timeout_counter_cmp_config;
            end
            2'b10:
            begin
                esl_lfsr_step = esl_htsm_lfsr_step;
                esl_timeout_counter_step = esl_htsm_timeout_counter_step;
                esl_timeout_counter_clear = esl_htsm_timeout_counter_clear;
                esl_timeout_counter_set = esl_htsm_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_htsm_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_htsm_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_htsm_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_htsm_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_htsm_timeout_counter_cmp_config;
            end
            2'b11:
            begin
                esl_lfsr_step = esl_rcfg_lfsr_step;
                esl_timeout_counter_step = esl_rcfg_timeout_counter_step;
                esl_timeout_counter_clear = esl_rcfg_timeout_counter_clear;
                esl_timeout_counter_set = esl_rcfg_timeout_counter_set;
                esl_pc_va_diff_offset_we = esl_rcfg_pc_va_diff_offset_we;
                esl_pc_va_diff_offset_clear = esl_rcfg_pc_va_diff_offset_clear;
                esl_timeout_shiftreg_step = esl_rcfg_timeout_shiftreg_step;
                esl_timeout_shiftreg_set = esl_rcfg_timeout_shiftreg_set;
                esl_timeout_counter_cmp_config = esl_rcfg_timeout_counter_cmp_config;
            end
            default:
            begin
                esl_lfsr_step = 1'bx;
                esl_timeout_counter_step = 1'bx;
                esl_timeout_counter_clear = 1'bx;
                esl_timeout_counter_set = 1'bx;
                esl_pc_va_diff_offset_we = 1'bx;
                esl_pc_va_diff_offset_clear = 1'bx;
                esl_timeout_shiftreg_step = 1'bx;
                esl_timeout_shiftreg_set = 1'bx;
            end
        endcase 
    end

    // Counter threshold comparisons
    always @ *
    begin
        esl_counter_timeout = (esl_timeout_counter_count_f >= 
                              (esl_timeout_counter_cmp_config ? config_esl_counter_timeout 
                                                              : esl_timeout_shiftreg_f));
    end

    //
    // Sub-module instantiations
    //

    // LFSR for pseudo random bits (shared resource)
    sparc_ifu_esl_lfsr lfsr
    (
        .clk (clk),
        .rst_n (rst_n),
        .lfsr_seed (config_esl_lfsr_seed),
        .lfsr_ld (config_esl_lfsr_ld),
        .lfsr_step (config_esl_en & esl_lfsr_step),
        .lfsr_state_f (),
        .lfsr_out_f (pseudo_rand_f)
    );

    // Timeout counter (shared resource)
    sparc_ifu_esl_counter 
    #(
        .COUNT_BIT_WIDTH (16)
    ) cfg_timeout_counter
    (
        .clk (clk),
        .rst_n (rst_n),
        .step (config_esl_en & esl_timeout_counter_step),
        .clear (config_esl_en & esl_timeout_counter_clear),
        .set (config_esl_en & esl_timeout_counter_set),
        .count_f (esl_timeout_counter_count_f)
    );

    // Shift register which sets one of the possible timeouts
    // for above counter (shared resource)
    sparc_ifu_esl_shiftreg 
    #(
        .SHIFT_REG_BIT_WIDTH (16)
    ) timeout_shiftreg
    (
        .clk (clk),
        .rst_n (rst_n),
        .step (config_esl_en & esl_timeout_shiftreg_step),
        .set (config_esl_en & esl_timeout_shiftreg_set),
        .shift_reg_f (esl_timeout_shiftreg_f)
    );

    // STSM synchronization mechanism
    sparc_ifu_esl_stsm 
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) stsm
    (
        .esl_stsm_trigger (esl_stsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_counter_timeout (esl_counter_timeout),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_stsm_state_next (esl_stsm_state_next),
        .esl_stsm_fcl_nextthr_bf (esl_stsm_fcl_nextthr_bf),
        .esl_stsm_fcl_switch_bf (esl_stsm_fcl_switch_bf),
        .esl_stsm_fcl_ntr_s (esl_stsm_fcl_ntr_s),
        .esl_stsm_lfsr_step (esl_stsm_lfsr_step),
        .esl_stsm_timeout_counter_step (esl_stsm_timeout_counter_step),
        .esl_stsm_timeout_counter_clear (esl_stsm_timeout_counter_clear),
        .esl_stsm_timeout_counter_set (esl_stsm_timeout_counter_set),
        .esl_stsm_pc_va_diff_offset_we (esl_stsm_pc_va_diff_offset_we),
        .esl_stsm_pc_va_diff_offset_clear (esl_stsm_pc_va_diff_offset_clear),
        .esl_stsm_timeout_shiftreg_step (esl_stsm_timeout_shiftreg_step),
        .esl_stsm_timeout_shiftreg_set (esl_stsm_timeout_shiftreg_set),
        .esl_stsm_timeout_counter_cmp_config (esl_stsm_timeout_counter_cmp_config)
    );

    // RTSM synchronization mechanism
    sparc_ifu_esl_rtsm 
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) rtsm
    (
        .esl_rtsm_trigger (esl_rtsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .pseudo_rand_f (pseudo_rand_f),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_rtsm_state_next (esl_rtsm_state_next),
        .esl_rtsm_fcl_nextthr_bf (esl_rtsm_fcl_nextthr_bf),
        .esl_rtsm_fcl_switch_bf (esl_rtsm_fcl_switch_bf),
        .esl_rtsm_fcl_ntr_s (esl_rtsm_fcl_ntr_s),
        .esl_rtsm_lfsr_step (esl_rtsm_lfsr_step),
        .esl_rtsm_timeout_counter_step (esl_rtsm_timeout_counter_step),
        .esl_rtsm_timeout_counter_clear (esl_rtsm_timeout_counter_clear),
        .esl_rtsm_timeout_counter_set (esl_rtsm_timeout_counter_set),
        .esl_rtsm_pc_va_diff_offset_we (esl_rtsm_pc_va_diff_offset_we),
        .esl_rtsm_pc_va_diff_offset_clear (esl_rtsm_pc_va_diff_offset_clear),
        .esl_rtsm_timeout_shiftreg_step (esl_rtsm_timeout_shiftreg_step),
        .esl_rtsm_timeout_shiftreg_set (esl_rtsm_timeout_shiftreg_set),
        .esl_rtsm_timeout_counter_cmp_config (esl_rtsm_timeout_counter_cmp_config)
    );

    // HTSM synchronization mechanism
    sparc_ifu_esl_htsm
    #(
        .DIVERGED (DIVERGED),
        .DIVERGED_DRAFT (DIVERGED_DRAFT),
        .CONVERGED (CONVERGED),
        .CONVERGED_DRAFT (CONVERGED_DRAFT),
        .DIVERGED_DIFFERENT_CODE_RCFG0 (DIVERGED_DIFFERENT_CODE_RCFG0),
        .RCFG1 (RCFG1),
        .RCFG2 (RCFG2),
        .RCFG3 (RCFG3)
    ) htsm
    (
        .clk (clk),
        .rst_n (rst_n),
        .esl_htsm_trigger (esl_htsm_trigger),
        .esl_state_f (state_f),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_s),
        .pseudo_rand_f (pseudo_rand_f),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_counter_timeout (esl_counter_timeout),
        .esl_shiftreg_lsb (esl_timeout_shiftreg_f[0]),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .esl_pcs_va_eql_s (esl_pcs_va_eql_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .esl_htsm_state_next (esl_htsm_state_next),
        .esl_htsm_fcl_nextthr_bf (esl_htsm_fcl_nextthr_bf),
        .esl_htsm_fcl_switch_bf (esl_htsm_fcl_switch_bf),
        .esl_htsm_fcl_ntr_s (esl_htsm_fcl_ntr_s),
        .esl_htsm_lfsr_step (esl_htsm_lfsr_step),
        .esl_htsm_timeout_counter_step (esl_htsm_timeout_counter_step),
        .esl_htsm_timeout_counter_clear (esl_htsm_timeout_counter_clear),
        .esl_htsm_timeout_counter_set (esl_htsm_timeout_counter_set),
        .esl_htsm_pc_va_diff_offset_we (esl_htsm_pc_va_diff_offset_we),
        .esl_htsm_pc_va_diff_offset_clear (esl_htsm_pc_va_diff_offset_clear),
        .esl_htsm_timeout_shiftreg_step (esl_htsm_timeout_shiftreg_step),
        .esl_htsm_timeout_shiftreg_set (esl_htsm_timeout_shiftreg_set),
        .esl_htsm_timeout_counter_cmp_config (esl_htsm_timeout_counter_cmp_config)
    );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_frf.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: bw_r_frf
// Description: This is the floating point register file.  It has one R/W port that is
//     78 bits (64 bits data, 14 bits ecc) wide.
*/


// trin 4/18/16: always use nowrapper implementation
//  all others will fail floating point tests



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































module bw_r_frf (/*AUTOARG*/
   // Outputs
   so, frf_dp_data,
   // Inputs
   rclk, si, se, sehold, rst_tri_en, ctl_frf_wen, ctl_frf_ren,
   dp_frf_data, ctl_frf_addr,


   // sram wrapper interface
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data

   ) ;
   input rclk;
   input si;
   input se;
   input sehold;
   input rst_tri_en;
   input [1:0] ctl_frf_wen;
   input ctl_frf_ren;
   input [77:0] dp_frf_data;
   input [6:0]   ctl_frf_addr;

   output so;
   output [77:0] frf_dp_data;

   wire [7:0]    regfile_index;
  //  wire [7:0]   regfile_index_low;
    // wire [7:0] regfile_index_high;
   //
   reg [77:0] frf_dp_data_f;

   assign frf_dp_data = frf_dp_data_f;

  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;

   // reg            rst_tri_en_negedge;
   // wire           ren_d1;
   // wire [6:0]     addr_d1;
   // wire [1:0]     wen_d1;
   // wire [77:0]    write_data_d1;
   // wire [77:0]    sehold_write_data;
   // wire [9:0]     sehold_cntl_data;

   // wire [9:0]     cntl_scan_data;
   // wire [38:0]    write_scan_data_hi;
   // wire [38:0]    write_scan_data_lo;
   // wire [38:0]    read_scan_data_hi;
   // wire [38:0]    read_scan_data_lo;

   // wire           real_se;
   // assign         real_se = se & ~sehold;

   // This is for sas comparisons
   assign        regfile_index[7:0] = {ctl_frf_addr[6:0], 1'b0};

   // assign        regfile_index_low[7:0] = {addr_d1[6:0], 1'b0};
   // assign        regfile_index_high[7:0] = {addr_d1[6:0], 1'b1};

   // assign         sehold_write_data[77:0] = (sehold)? write_data_d1[77:0]: dp_frf_data[77:0];
   // assign sehold_cntl_data[9:0] = (sehold)? {addr_d1[6:0],wen_d1[1:0], ren_d1}:
   //                                          {ctl_frf_addr[6:0],ctl_frf_wen[1:0],ctl_frf_ren};
   // All inputs go through flop
   // dff_s #(39) datain_dff1(.din(sehold_write_data[77:39]), .clk(rclk), .q(write_data_d1[77:39]),
   //                       .se(real_se), .si({cntl_scan_data[0],write_scan_data_lo[38:1]}),
   //                       .so(write_scan_data_hi[38:0]));
   // dff_s #(39) datain_dff2(.din(sehold_write_data[38:0]), .clk(rclk), .q(write_data_d1[38:0]),
   //                       .se(real_se), .si(write_scan_data_hi[38:0]), .so(write_scan_data_lo[38:0]));
   // dff_s #(10) controlin_dff(.din(sehold_cntl_data[9:0]),
   //                         .q({addr_d1[6:0],wen_d1[1:0],ren_d1}),
   //                         .clk(rclk), .se(real_se), .si({si,cntl_scan_data[9:1]}), .so(cntl_scan_data[9:0]));


   wire [77:0] write_mask = {{39{ctl_frf_wen[1]}},{39{ctl_frf_wen[0]}}};
   wire ctl_frf_wens = ctl_frf_wen[1] | ctl_frf_wen[0];

   wire [77:0] read_data;
sram_1rw_128x78 regfile
//sram_configurable_frf regfile
(
  .MEMCLK(rclk),
  .RESET_N(!rst_tri_en),
  .CE(ctl_frf_wens | ctl_frf_ren),
  .A(ctl_frf_addr),
  .DIN(dp_frf_data),
  .BW(write_mask),
  .RDWEN(~ctl_frf_wens),
  .DOUT(read_data),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(8'd5)
);

   always @ (posedge rclk)
   begin
      frf_dp_data_f <= read_data;
   end

   // dff_s #(39) dataout_dff1(.din(read_data[77:39]), .clk(rclk), .q(frf_dp_data[77:39]),
   //                        .se(real_se), .si(read_scan_data_lo[38:0]), .so(read_scan_data_hi[38:0]));
   // dff_s #(39) dataout_dff2(.din(read_data[38:0]), .clk(rclk), .q(frf_dp_data[38:0]),
   //                        .se(real_se), .si({read_scan_data_hi[37:0],write_scan_data_lo[0]}),
   //                        .so(read_scan_data_lo[38:0]));
   // assign so = read_scan_data_hi[38];


   // always @ (negedge rclk) begin
   //    // latch rst_tri_en
   //    rst_tri_en_negedge <= rst_tri_en;
   // end

endmodule // sparc_ffu_frf


































































































































// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_icd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_icd
 //  Description:
 //    The ICD contains the icache data.
 //    32B line size.
 //    Write BW: 16B
 //    Read BW: 16Bx2 (fetdata and topdata), collapsed to 4Bx2
 //    Associativity: 4
 //    Write boundary: 34b (32b inst + parity + predec bit)
 //    NOTES:
 //    1. No clock enable.  Rd/Wr enable is used to trigger the
 //    operation.
 //    2. 2:1 mux on address input.  Selects provided externally.
 //    3. 3:1 mux on data input.   Selects provided and guaranteed
 //    exclusive, externally.
 //
 */


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting






















//PITON_PROTO enables all FPGA related modifications






















































































































































































































































































































































































module bw_r_icd(

    // sram wrapper interface
    sram_icache_w10_rtap_data,
    sram_icache_w32_rtap_data,
    rtap_srams_bist_command,
    rtap_srams_bist_data,


    icd_wsel_fetdata_s1, icd_wsel_topdata_s1, icd_fuse_repair_value,
    icd_fuse_repair_en, so, rclk, se, si, reset_l, sehold, fdp_icd_index_bf,
    ifq_icd_index_bf, fcl_icd_index_sel_ifq_bf, ifq_icd_wrway_bf,
    ifq_icd_worden_bf, ifq_icd_wrdata_i2, fcl_icd_rdreq_bf,
    fcl_icd_wrreq_bf, bist_ic_data, rst_tri_en, ifq_icd_data_sel_old_i2,
    ifq_icd_data_sel_fill_i2, ifq_icd_data_sel_bist_i2, fuse_icd_wren,
    fuse_icd_rid, fuse_icd_repair_value, fuse_icd_repair_en,
    efc_spc_fuse_clk1);

    // sram wrapper interface
    output [4-1:0] sram_icache_w10_rtap_data;
    output [4-1:0] sram_icache_w32_rtap_data;
    input  [4-1:0] rtap_srams_bist_command;
    input  [4-1:0] rtap_srams_bist_data;

    input           rclk;
    input           se;
    input           si;
    input           reset_l;
    input           sehold;
    input   [(6 + 5):2]      fdp_icd_index_bf;
    input   [(6 + 5):2]      ifq_icd_index_bf;
    input           fcl_icd_index_sel_ifq_bf;
    input   [1:0]       ifq_icd_wrway_bf;
    input   [3:0]       ifq_icd_worden_bf;
    input   [135:0]     ifq_icd_wrdata_i2;
    input           fcl_icd_rdreq_bf;
    input           fcl_icd_wrreq_bf;
    input   [7:0]       bist_ic_data;
    input           rst_tri_en;
    input           ifq_icd_data_sel_old_i2;
    input           ifq_icd_data_sel_fill_i2;
    input           ifq_icd_data_sel_bist_i2;
    input           fuse_icd_wren;
    input   [3:0]       fuse_icd_rid;
    input   [7:0]       fuse_icd_repair_value;
    input   [1:0]       fuse_icd_repair_en;
    input           efc_spc_fuse_clk1;
    output  [135:0]     icd_wsel_fetdata_s1;
    output  [135:0]     icd_wsel_topdata_s1;
    output  [7:0]       icd_fuse_repair_value;
    output  [1:0]       icd_fuse_repair_en;
    output          so;

    reg [7:0]       icd_fuse_repair_value;
    reg [1:0]       icd_fuse_repair_en;
    reg [135:0]     fetdata_f;
    reg [135:0]     topdata_f;
    // reg [135:0]     fetdata_sa;
    // reg [135:0]     topdata_sa;
    reg [135:0]     fetdata_s1;
    reg [135:0]     topdata_s1;
    wire            clk;
    wire    [135:0]     next_wrdata_bf;
    reg    [135:0]     wrdata_f;
    wire    [135:0]     bist_data_expand;
    wire [(6 + 5):2]     index_bf;
    reg [(6 + 5):2]      index_f;
    reg [(6 + 5):2]      index_s1;
    // reg [`IC_IDX_HI:0]      wr_index0;
    // reg [`IC_IDX_HI:0]      wr_index1;
    // reg [`IC_IDX_HI:0]      wr_index2;
    // reg [`IC_IDX_HI:0]      wr_index3;
    // reg         rdreq_f;
    // reg         wrreq_f;
    // reg [3:0]       worden_f;
    reg [1:0]       wrway_f;


    assign clk = rclk;
    assign index_bf = (fcl_icd_index_sel_ifq_bf ? ifq_icd_index_bf :
        fdp_icd_index_bf);

    // wire [`IC_IDX_HI:2] top_index = {index_f[`IC_IDX_HI:3] , 1'b1};

    always @ (posedge clk)
    begin
        wrway_f <= ifq_icd_wrway_bf;
        index_f <= index_bf;
        index_s1 <= index_f;
    end

    assign bist_data_expand = 136'b0;
    assign icd_wsel_fetdata_s1 = fetdata_s1;
    assign icd_wsel_topdata_s1 = topdata_s1;

    // mux3ds #(136) icden_mux(
    //     .dout               (next_wrdata_bf),
    //     .in0                (wrdata_f),
    //     .in1                (ifq_icd_wrdata_i2),
    //     .in2                (bist_data_expand),
    //     .sel0               (ifq_icd_data_sel_old_i2),
    //     .sel1               (ifq_icd_data_sel_fill_i2),
    //     .sel2               (ifq_icd_data_sel_bist_i2));
    // dffe_s #(136) wrdata_reg(
    //     .din                (next_wrdata_bf),
    //     .clk                (clk),
    //     .q              (wrdata_f),
    //     .en             ((~sehold)),
    //     .se             (se));

    assign next_wrdata_bf = ifq_icd_data_sel_old_i2 ? wrdata_f :
                            ifq_icd_data_sel_fill_i2 ? ifq_icd_wrdata_i2 : bist_data_expand;

    always @ (posedge clk)
    begin
        wrdata_f <= next_wrdata_bf;
    end

    wire  [543:0] read_data_f;
    wire [543:0] wrdata_expanded_bf;
    reg  [543:0] wrmask_expanded_bf;
    wire [135:0] wrmask_bf;

sram_l1i_data icache_way_10
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[271:0]),
    .BW(wrmask_expanded_bf[271:0]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[271:0]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w10_rtap_data),
    .SRAMID(8'd1)
);


sram_l1i_data icache_way_32
(
    .MEMCLK(rclk),
    .RESET_N(reset_l),
    .CE(fcl_icd_rdreq_bf | fcl_icd_wrreq_bf),
    .A(index_bf[(6 + 5):4]),
    .DIN(wrdata_expanded_bf[543:272]),
    .BW(wrmask_expanded_bf[543:272]),
    .RDWEN(~fcl_icd_wrreq_bf),
    .DOUT(read_data_f[543:272]),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(sram_icache_w32_rtap_data),
    .SRAMID(8'd2)
);


    // reg  [543:0] read_data_s1;
    wire [33:0]     icdata_ary_00_00;
    wire [33:0]     icdata_ary_00_01;
    wire [33:0]     icdata_ary_00_10;
    wire [33:0]     icdata_ary_00_11;
    wire [33:0]     icdata_ary_01_00;
    wire [33:0]     icdata_ary_01_01;
    wire [33:0]     icdata_ary_01_10;
    wire [33:0]     icdata_ary_01_11;
    wire [33:0]     icdata_ary_10_00;
    wire [33:0]     icdata_ary_10_01;
    wire [33:0]     icdata_ary_10_10;
    wire [33:0]     icdata_ary_10_11;
    wire [33:0]     icdata_ary_11_00;
    wire [33:0]     icdata_ary_11_01;
    wire [33:0]     icdata_ary_11_10;
    wire [33:0]     icdata_ary_11_11;
    // reg [135:0]     fetdata_s1;
    // reg [135:0]     topdata_s1;

    assign {icdata_ary_11_00,icdata_ary_11_01,icdata_ary_11_10,icdata_ary_11_11,
            icdata_ary_10_00,icdata_ary_10_01,icdata_ary_10_10,icdata_ary_10_11,
            icdata_ary_01_00,icdata_ary_01_01,icdata_ary_01_10,icdata_ary_01_11,
            icdata_ary_00_00,icdata_ary_00_01,icdata_ary_00_10,icdata_ary_00_11} = read_data_f;

    // way, word

    always @ *
    begin
      case (index_f[3:2])
        2'b00:
        begin
          fetdata_f = {icdata_ary_11_00, icdata_ary_10_00, icdata_ary_01_00, icdata_ary_00_00};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b01:
        begin
          fetdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
          topdata_f = {icdata_ary_11_01, icdata_ary_10_01, icdata_ary_01_01, icdata_ary_00_01};
        end
        2'b10:
        begin
          fetdata_f = {icdata_ary_11_10, icdata_ary_10_10, icdata_ary_01_10, icdata_ary_00_10};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
        2'b11:
        begin
          fetdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
          topdata_f = {icdata_ary_11_11, icdata_ary_10_11, icdata_ary_01_11, icdata_ary_00_11};
        end
      endcase
    end

    // always @ (posedge clk)
    // begin
    // end

    ///WRITE

    assign wrdata_expanded_bf = {4{next_wrdata_bf}};
    assign wrmask_bf = {{34{ifq_icd_worden_bf[0]}},{34{ifq_icd_worden_bf[1]}},{34{ifq_icd_worden_bf[2]}},{34{ifq_icd_worden_bf[3]}}};

    always @ *
    begin
        case (ifq_icd_wrway_bf)
          2'b11:
          begin
            wrmask_expanded_bf = {wrmask_bf, 136'b0, 136'b0, 136'b0};
          end
          2'b10:
          begin
            wrmask_expanded_bf = {136'b0, wrmask_bf, 136'b0, 136'b0};
          end
          2'b01:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, wrmask_bf, 136'b0};
          end
          2'b00:
          begin
            wrmask_expanded_bf = {136'b0, 136'b0, 136'b0, wrmask_bf};
          end
        endcase
    end

    always @ (posedge clk)
    begin
        fetdata_s1 <= fetdata_f;
        topdata_s1 <= topdata_f;
    end


endmodule


 // IBM









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1i_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1i_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

//`include "iop.h"
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1i_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [15:0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [3:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [15:0] debug_data_bmask;
reg [15:0] debug_data_in;
reg [15:0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [15:0] mem [0:((8192/32/2/4))-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [15:0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [15:0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[6-2:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[6-2:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
integer memidx;
reg [15:0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      // mem[0] <= 16'b0;
      // mem[1] <= 16'b0;
      // mem[2] <= 16'b0;
      // mem[3] <= 16'b0;
      // mem[4] <= 16'b0;
      // mem[5] <= 16'b0;
      // mem[6] <= 16'b0;
      // mem[7] <= 16'b0;
      // mem[8] <= 16'b0;
      // mem[9] <= 16'b0;
      // mem[10] <= 16'b0;
      // mem[11] <= 16'b0;
      // mem[12] <= 16'b0;
      // mem[13] <= 16'b0;
      // mem[14] <= 16'b0;
      // mem[15] <= 16'b0;
      // mem[16] <= 16'b0;
      // mem[17] <= 16'b0;
      // mem[18] <= 16'b0;
      // mem[19] <= 16'b0;
      // mem[20] <= 16'b0;
      // mem[21] <= 16'b0;
      // mem[22] <= 16'b0;
      // mem[23] <= 16'b0;
      // mem[24] <= 16'b0;
      // mem[25] <= 16'b0;
      // mem[26] <= 16'b0;
      // mem[27] <= 16'b0;
      // mem[28] <= 16'b0;
      // mem[29] <= 16'b0;
      // mem[30] <= 16'b0;
      // mem[31] <= 16'b0;
      
      // genvar memidx;
      // generate
      // for (memidx = 0; memidx < `IC_VAL_SET_COUNT; memidx = memidx + 1) begin
      //   mem[memidx] <= 16b'0;
      // end
      
      for (memidx = 0; memidx < ((8192/32/2/4)); memidx = memidx + 1) begin
        mem[memidx] <= 16'b0;
      end
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [15:0] read1;
reg [15:0] read2;
reg [15:0] read3;
reg [15:0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[3:0];
      2'b01:
         read3 = read2[7:4];
      2'b10:
         read3 = read2[11:8];
      2'b11:
         read3 = read2[15:12];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0];
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[15:0] = bist_data_reg[15:0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1i_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_scm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Store Buffer of Load/Store Unit (CAM Side)
//		 - Physically divided into CAM and DATA RAMs.
//                              - CAM RAM has a single cam port and a single
//                              port for read/writes. The cam port is for loads,
//                              write for stores, read for test/diagnostic purposes.
//                              rd or write can be simultaneous with cam. can rd and cam
//                              a single entry simultaneously. cannot write and cam
//                              the same entry.
//                              - DATA RAM read occurs for a load raw match in the
//                              stb CAM RAM. DATA RAM write occurs a store. Both
//                              actions are architecturally guaranteed to be
//                              mutex.
//                              - Write occurs simultaneously to both arrays.
//                              - Reads are not necessarily simultaneous and are
//                              controlled by individual read signals.
//                              - Certain bits are maintained outside the array
//                              in the stb's control section, such as the valid
//                              bits.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

//PITON_PROTO enables all FPGA related modifications






module bw_r_scm (/*AUTOARG*/
   // Outputs

    stb_rcsm_ramc,

   stb_rdata_ramc, stb_ld_full_raw, stb_ld_partial_raw,
   stb_cam_hit_ptr, stb_cam_hit, stb_cam_mhit,
   // Inputs

   stb_cam_csm,stb_alt_wr_csm,

   stb_cam_data, stb_alt_wr_data, stb_camwr_data, stb_alt_wsel,
   stb_cam_vld, stb_cam_cm_tid, stb_cam_sqsh_msk, stb_cam_rw_ptr,
   stb_cam_wptr_vld, stb_cam_rptr_vld, stb_cam_rw_tid,
   stb_quad_ld_cam, rclk, rst_tri_en
   ) ;

parameter NUMENTRIES = 32 ;				// number of entries in stb

input	[44:15]		stb_cam_data ;	  // data for compare; disjoint msb
input	[44:15]		stb_alt_wr_data ;	  // data for compare; disjoint msb
input	[14:0]		stb_camwr_data ;  // data for compare/write; common lsb
input			stb_alt_wsel ;
input			stb_cam_vld ;	  // cam is required.
input	[1:0]		stb_cam_cm_tid ;  // thread id for cam operation.
input	[7:0]		stb_cam_sqsh_msk; // mask for squashing cam results.

input 	[2:0]		stb_cam_rw_ptr ;  // wr pointer for single port.
input 	     		stb_cam_wptr_vld ;// write pointer vld
input 	     		stb_cam_rptr_vld ;// write pointer vld
input	[1:0]		stb_cam_rw_tid ;  // thread id for rw.
input 			stb_quad_ld_cam ; // quad-ld cam.

input			rclk ;		  // clock

//input			scan_ena ;	  // no longer required !
//input	[7:0]		adj ;

input			rst_tri_en ;


input   [32:0] stb_cam_csm;
input   [32:0] stb_alt_wr_csm;

output  [32:0] stb_rcsm_ramc;


output	[44:0]		stb_rdata_ramc ;  // rd data from CAM RAM.
// raw output is muxed on a thread basis.
output	[7:0]		stb_ld_full_raw ; // ld with full raw.
output	[7:0]		stb_ld_partial_raw ; // ld with partial raw.
output	[2:0]		stb_cam_hit_ptr ;
output			stb_cam_hit ;	  // any hit in stb
output			stb_cam_mhit ;	  // multiple hits in stb


/*UTOREG*/
// Beginning of automatic regs (for this module's undeclared outputs)
// End of automatics
reg [44:0]		stb_rdata_ramc ;
reg [31:0]		rw_wdline ;
reg [44:0]		stb_ramc [NUMENTRIES-1:0] /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */;
reg [44:0]		ramc_entry ;
reg [36:0]		cam_tag ;
reg [31:0]		ptag_hit ;
reg [7:0]		cam_bmask ;
reg [31:0]		byte_match ;
reg [31:0]		byte_overlap ;
reg [31:0]		ld_full_raw ;
reg [31:0]		ld_partial_raw ;
reg [44:15]		alt_wr_data ;
reg [44:15]		pipe_wr_data ;
reg [14:0]		camwr_data ;
reg			wptr_vld ;
reg			rptr_vld_tmp ;
reg [1:0]	  	cam_tid ;
reg [1:0]	  	cam_vld ;
reg			alt_wsel ;

wire		rptr_vld ;
wire 		ldq ;
wire	[7:0]	sqsh_msk ;
wire 	[7:0]	ld_full_raw_mx ;
wire    [7:0]	ld_partial_raw_mx ;
wire	[7:0]	ptag_hit_mx ;
wire	[7:0]	byte_overlap_mx ;
wire	[7:0]	byte_match_mx ;
wire	[7:0]	cam_hit ;
wire	[44:0]	wdata_ramc ;
wire	[44:0]	cam_data ;
wire	[44:15] wr_data ;

reg	[4:0]	stb_addr;



reg [32:0] stb_rcsm_ramc;
reg [32:0] stb_csm_ramc [NUMENTRIES-1:0];
reg [32:0] pipe_wr_csm;
wire [32:0] wcsm_ramc;
reg [32:0] alt_wr_csm;


integer	i,j,k,l ;


wire	scan_ena ;
assign	scan_ena = 1'b0 ;

//=========================================================================================
//	generate wordlines
//=========================================================================================

assign	sqsh_msk[7:0]	= stb_cam_sqsh_msk[7:0];

// cam_vld and cam_tid_tmp are set-up a phase earlier.
// Comment out - Now setup to posedge.
/*always @(negedge clk)
	begin
		cam_tid_tmp[1:0]	<= stb_cam_cm_tid[1:0] ;
		cam_vld_tmp		<= stb_cam_vld ;
	end */
















always @(posedge rclk)
	begin
		pipe_wr_data[44:15] <= stb_cam_data[44:15];
		alt_wr_data[44:15] <= stb_alt_wr_data[44:15];
		camwr_data[14:0] <= stb_camwr_data[14:0];
		wptr_vld 	<= stb_cam_wptr_vld ;
		rptr_vld_tmp 	<= stb_cam_rptr_vld ;
		cam_tid[1:0]	<= stb_cam_cm_tid[1:0] ;
		//cam_tid[1:0]	<= cam_tid_tmp[1:0] ;
 		//ldq 		<=  stb_quad_ld_cam ; Bug 2870
		alt_wsel 	<= stb_alt_wsel ;


		pipe_wr_csm <= stb_cam_csm;
        alt_wr_csm  <= stb_alt_wr_csm;


                stb_addr	<= {stb_cam_rw_tid[1:0],stb_cam_rw_ptr[2:0]};

	end

assign 	ldq =  stb_quad_ld_cam ;
assign  rptr_vld = rptr_vld_tmp | rst_tri_en ;

//=========================================================================================
//	write or read to/from memory
//=========================================================================================

// For blk-st, select out-of-pipe.
assign	wr_data[44:15] = alt_wsel ?
                alt_wr_data[44:15] : pipe_wr_data[44:15] ;

assign	wdata_ramc[44:0] = {wr_data[44:15],camwr_data[14:0]};

assign wcsm_ramc = alt_wsel ? alt_wr_csm : pipe_wr_csm;




// Write
always @ (negedge rclk)
	begin

	if(wptr_vld) begin
		if(~rst_tri_en) begin
			stb_ramc[stb_addr] <= wdata_ramc[44:0];
            stb_csm_ramc[stb_addr] <= wcsm_ramc;
			stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
            stb_rcsm_ramc <= wcsm_ramc;
                end else begin
			stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
            stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
		end
	end






















// Read

		if(rptr_vld & ~scan_ena) begin
			if (rptr_vld & wptr_vld & ~rst_tri_en) begin
				stb_rdata_ramc[44:0] <=  wdata_ramc[44:0];
                stb_rcsm_ramc <= wcsm_ramc;
			end
			else begin
				stb_rdata_ramc[44:0] <=  stb_ramc[stb_addr];
                stb_rcsm_ramc <= stb_csm_ramc[stb_addr];
			end
		end


















	end

























































//=========================================================================================
//	CAM contents of CAM RAM
//=========================================================================================

// - Generate full/partial raw for incoming load.
// - Output signals need to be qualified with per entry
// vlds before causing any subsequent event, the read of
// the DATA RAM specifically.
// - full_raw & vld will cause rd of DATA RAM.
// - partial_raw & vld will cause ld to follow corresponding
// st on way out to xbar.
// - logic to generate partial and full raws may be done outside
// but that would require an additional signal per entry to
// be output.

// Mapping of cam/write data
//
//	| 	40-3=37b(pa)	| 1b(stquad) 	|	8b(bytemask)	| <- use
//	|	45:9		| 8		|	7:0		| <- input port
//				**^ stquad rm'ed

assign	cam_data[44:0] = {stb_cam_data[44:15],stb_camwr_data[14:0]};

always @ (posedge rclk)
	begin

		for (l=0;l<NUMENTRIES;l=l+1)
				begin
				ramc_entry[44:0] = stb_ramc[l] ;

				cam_tag[36:0] = ramc_entry[44:8] ;
				cam_bmask[7:0] = ramc_entry[7:0] ;
				//stq =	ramc_entry[8] ;			// additional bit -stq

				// Prior to adding stb_quad_ld_cam port.
				/*ptag_hit[l] =
					((cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~stq) | stq)) & stcam_vld_tmp & ~scan_ena ;*/
				// Modification.
				// * remove ramc_entry[8]. Or keep it but it won't be used.
				// * Instead we'll control this from outside.
				ptag_hit[l] =
					(cam_tag[36:1] == cam_data[44:9]) &
						(((cam_tag[0] == cam_data[8]) & ~ldq) | ldq) & stb_cam_vld & ~scan_ena ;
				byte_match[l] = |(cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;
				// Simplification :
				byte_overlap[l] = |(~cam_bmask[7:0] & cam_data[7:0]) & stb_cam_vld & ~scan_ena ;

				end
	end

// Mux the raw signals down to 8b quantities. Squash mask comes mid-way thru cycle.


assign	byte_overlap_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_overlap[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_overlap[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_overlap[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_overlap[31:24] : 8'bxxxx_xxxx ;

assign	byte_match_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? byte_match[7:0] :
		(cam_tid[1:0] == 2'b01) ? byte_match[15:8] :
			(cam_tid[1:0] == 2'b10) ? byte_match[23:16] :
				(cam_tid[1:0] == 2'b11) ? byte_match[31:24] : 8'bxxxx_xxxx ;

assign	ptag_hit_mx[7:0] =
	(cam_tid[1:0] == 2'b00) ? ptag_hit[7:0] :
		(cam_tid[1:0] == 2'b01) ? ptag_hit[15:8] :
			(cam_tid[1:0] == 2'b10) ? ptag_hit[23:16] :
				(cam_tid[1:0] == 2'b11) ? ptag_hit[31:24] : 8'bxxxx_xxxx ;

assign	stb_ld_full_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_ld_partial_raw[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] &  byte_overlap_mx[7:0] & ~sqsh_msk[7:0] ;

assign	cam_hit[7:0] =
	ptag_hit_mx[7:0] & byte_match_mx[7:0] & ~sqsh_msk[7:0] ;
assign	stb_cam_hit = |(cam_hit[7:0]);

// The stb data is meant to be read for single hit full raw case. It may actually be read
// for full raw, partial raw or multiple hit case but the read output will be ignored for
// partial and multiple hit case. Multiple hits will not cause a hazard as the ptr is first
// encoded and then decoded to form the wdline for the stb-data
// Use cam_hit result to void false hits.
assign	stb_cam_hit_ptr[0] 	=  cam_hit[1] | cam_hit[3] | cam_hit[5] | cam_hit[7] ;
assign	stb_cam_hit_ptr[1] 	=  cam_hit[2] | cam_hit[3] | cam_hit[6] | cam_hit[7] ;
assign	stb_cam_hit_ptr[2] 	=  cam_hit[4] | cam_hit[5] | cam_hit[6] | cam_hit[7] ;

//Generating multiple hits
assign  stb_cam_mhit            =  (cam_hit[0]  & cam_hit[1]) | (cam_hit[2] & cam_hit[3])  |
                                   (cam_hit[4]  & cam_hit[5]) | (cam_hit[6] & cam_hit[7])  |
                                   ((cam_hit[0] | cam_hit[1]) & (cam_hit[2] | cam_hit[3])) |
                                   ((cam_hit[4] | cam_hit[5]) & (cam_hit[6] | cam_hit[7])) |
                                   ((|cam_hit[3:0]) & (|cam_hit[7:4]));

//--------------------------------------------------------------
// Error Checking.
//--------------------------------------------------------------

// 1. simultaneous rd/wr on single port - terminate
// 2. simultaneous cam and wr - terminate
// * PUT OUTSIDE OF SRAM RTL, AS RST NOT AVAILABLE. *

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x152b.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    DCache Fill Queue of Load Store Unit.
//                      - Contains invalidates and loads.
//                      - loads will bypass and/or fill dcache.
//                      - Entry at head of queue may have to
//                      be held for multiple passes.
//
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_rf32x152b(dout, so, rd_en, rd_adr, wr_en, wr_adr, din, si, se,
  sehold, rclk, rst_tri_en, reset_l);

  parameter   NUMENTRIES  = 32;

  input [4:0]   rd_adr;
  input     rd_en;
  input     wr_en;
  input [4:0]   wr_adr;
  input [151:0]   din;
  input     rclk;
  input     reset_l;
  input     rst_tri_en;
  input     sehold;
  input     si;
  input     se;
  output  [151:0]   dout;
  // reg [151:0]   dout;
  output      so;

  wire      clk;
  wire      wr_vld;

  reg [151:0]   mem[(NUMENTRIES - 1):0];  /* synthesis syn_ramstyle = block_ram  syn_ramstyle = no_rw_check */
  // reg rd_en_d1;
  reg [4:0]   rd_adr_d1;

  assign clk = rclk;
  assign wr_vld = ((wr_en & (~rst_tri_en)) & reset_l);

  always @(posedge clk) begin
    if (wr_vld) begin
      mem[wr_adr] = din;
    end
    // rd_en_d1 <= rd_en;
    rd_adr_d1 <= rd_adr;
  end

  assign dout = mem[rd_adr_d1];

endmodule

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sram_l1d_val.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  sram_l1d_val
 //  Description:
 //   1r1w array for icache and dcache valid bits.
 //   Modified to conform to naming convention
 //   Added 16 bit wr en
 //   Made bit_wen and din flopped inputs
 //   So all inputs are setup to flops in the stage before memory
 //   access.  The data output is available one cycle later (same
 //   stage as mem access)
 //
 //  IMPORTANT NOTE: This block has to work even in the case where
 //  there is contention between a read and write operation for the
 //  same address.  Based on ease of implementation, the behavior
 //  during contention is defined as follows.
 //    -- write always succeeds
 //    -- read data is (array_data & write_data)
 //       (i.e. old_data & new_data)
 //
 //   So read 0 always succeeds.  read 1 succeeds if the data being
 //   written is also a 1.  Otherwise it fails.
 //
 // new_data = 1, old_data = 0, does not give the expected or
 // predictable result in post layout, so the code has been modified
 // to be
 // old new rd_data
 // --- --- -------
 // 0    0     0
 // 0    1     X
 // 1    0     0
 // 1    1     1
 //
 // **The write still succeeds in ALL cases**
 */

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include "sys.h" // system level definition file which contains the
// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

//`include "iop.h"

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


module sram_l1d_val (/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rclk, se, si, reset_l, sehold, rst_tri_en, rd_adr1, rd_adr2,
   rd_adr1_sel, rd_en, wr_adr, wr_en, bit_wen, din,

   sramid,
   srams_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   );


input        rclk;
input        se;
input        si;
input        reset_l;
input        sehold;          // scan enable hold
input        rst_tri_en;

// 11:5(I);10:4(D)
input [6:0]     rd_adr1 ;     // rd address-1
input [6:0]     rd_adr2 ;     // rd address-2

input        rd_adr1_sel ;  // sel rd addr 1
input        rd_en ;            // rd enable

// 11:7(I);10:6(D)
input [6:2]     wr_adr ;  // wr address

input        wr_en ;        // wr enable
input [(4*2-1):0] bit_wen ;  // write enable with bit select
input        din ;        // write data

output reg [2-1:0]    dout ;    // valid bits for tag compare

output       so;

wire         clk;
assign       clk = rclk;


// sram wrapper interface
output reg [4-1:0] srams_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;
input  [8-1:0] sramid;

// interface to debug module
reg [(4*2-1):0] debug_data_bmask;
reg [(4*2-1):0] debug_data_in;
reg [(4*2-1):0] debug_data_out;
reg [6:0] debug_address;
reg debug_rw;
reg debug_en;

// trin's reimplementation
reg [(4*2-1):0] mem [0:((256/2)/4)-1];
wire rst_all = rst_tri_en | ~reset_l;

reg write_en_x;
reg write_bit_x;
reg [(4*2-1):0] write_mask_x;
reg [6:2] write_address_x;
reg read_en_x;
reg [6:0] read_address_x;
reg debug_en_x;

reg write_en_y;
reg write_bit_y;
reg [(4*2-1):0] write_mask_y;
reg [6:2] write_address_y;
reg read_en_y;
reg [6:0] read_address_y;
reg debug_en_y;

always @ *
begin

   write_en_x = wr_en; 
   write_bit_x = din;
   write_mask_x = bit_wen;
   write_address_x = wr_adr;

   read_en_x = rd_en;
   read_address_x = rd_adr1_sel ? rd_adr1 : rd_adr2;

   if (debug_en)
   begin
      write_en_x = debug_rw == 1'b1; 
      // write_bit_x = debug_data_in;
      write_mask_x = debug_data_in;
      write_address_x = 0;
      write_address_x[6:2] = debug_address[4:0];

      read_en_x = debug_rw == 1'b0;
      read_address_x = 0;
      read_address_x[6:2] = debug_address[4:0];
   end
   debug_en_x = debug_en;

end

always @ (posedge clk)
begin
   write_en_y <= write_en_x;
   write_bit_y <= write_bit_x;
   write_mask_y <= write_mask_x;
   write_address_y <= write_address_x;
   read_en_y <= read_en_x;
   debug_en_y <= debug_en_x;
   read_address_y <= read_address_x;
end

// WRITE
reg [(4*2-1):0] write_data_y;
always @ *
begin
   write_data_y = (mem[write_address_y[6:2]] & ~write_mask_y) | ({16{write_bit_y}} & write_mask_y);
   if (debug_en_y)
      write_data_y = write_mask_y;
end
always @ (posedge clk)
begin
   if (rst_all)
   begin
      mem[0] <= 16'b0;
      mem[1] <= 16'b0;
      mem[2] <= 16'b0;
      mem[3] <= 16'b0;
      mem[4] <= 16'b0;
      mem[5] <= 16'b0;
      mem[6] <= 16'b0;
      mem[7] <= 16'b0;
      mem[8] <= 16'b0;
      mem[9] <= 16'b0;
      mem[10] <= 16'b0;
      mem[11] <= 16'b0;
      mem[12] <= 16'b0;
      mem[13] <= 16'b0;
      mem[14] <= 16'b0;
      mem[15] <= 16'b0;
      mem[16] <= 16'b0;
      mem[17] <= 16'b0;
      mem[18] <= 16'b0;
      mem[19] <= 16'b0;
      mem[20] <= 16'b0;
      mem[21] <= 16'b0;
      mem[22] <= 16'b0;
      mem[23] <= 16'b0;
      mem[24] <= 16'b0;
      mem[25] <= 16'b0;
      mem[26] <= 16'b0;
      mem[27] <= 16'b0;
      mem[28] <= 16'b0;
      mem[29] <= 16'b0;
      mem[30] <= 16'b0;
      mem[31] <= 16'b0;
   end
   else
   begin
      if (write_en_y)
      begin
         mem[write_address_y[6:2]] <= write_data_y;
      end
   end
end

// READ
reg [(4*2-1):0] read1;
reg [(4*2-1):0] read2;
reg [(4*2-1):0] read3;
reg [(4*2-1):0] write_to_0;
always @ *
begin
   read1 = mem[read_address_y[6:2]];

   // write/read conflict
   // basically, final_read = sram_read & write
   read2 = read1;
   write_to_0 = ~{16{write_bit_y}} & write_mask_y;
   if ((read_address_y[6:2] == write_address_y[6:2]) && write_en_y)
      read2 = read1 & ~write_to_0;

   // write_to_0 = 0;
   // if ((read_address_y[`L1D_SET_IDX_HI:2] == write_address_y[`L1D_SET_IDX_HI:2]) && write_en_y)
   //    write_to_0 = write_mask_y;

   // read2 = (~write_to_0 & read1 | write_to_0 & {16{write_bit_y}} & read1);
   debug_data_out = read2;

   case (read_address_y[1:0])
      2'b00:
         read3 = read2[2*1-1 -: 2];
      2'b01:
         read3 = read2[2*2-1 -: 2];
      2'b10:
         read3 = read2[2*3-1 -: 2];
      2'b11:
         read3 = read2[2*4-1 -: 2];
   endcase

   dout = 0;
   if (read_en_y)
      dout = read3;
end


///////////////////////////////////////////////////
// implements the standardized SRAM interface
///////////////////////////////////////////////////
localparam BIST_STATE_INIT = 1'b0;
localparam BIST_STATE_CAPTURE_READ = 1'b1;
localparam BIST_DATA_WIDTH = 16;

reg [15:0] bist_address_reg;
reg [3:0] bist_id_reg;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg;
reg [7:0] bist_bsel_reg;
reg bist_state;

reg [15:0] bist_address_reg_next;
reg [3:0] bist_id_reg_next;
reg [BIST_DATA_WIDTH-1:0] bist_data_reg_next;
reg [7:0] bist_bsel_reg_next;
reg bist_state_next;

// wires
reg bist_en;
reg bist_rdwen;
reg bist_data_capture_read_en;
reg bist_address_shift_en;
reg bist_data_shift_en;
reg bist_bsel_shift_en;
reg bist_id_shift_en;
reg [4-1:0] bist_command;


always @ (posedge clk)
begin
   if (!reset_l)
   begin
      // only resetting important variables
      bist_id_reg <= 0;
      bist_state <= BIST_STATE_INIT;
   end
   else
   begin
      bist_data_reg <= bist_data_reg_next;
      bist_state <= bist_state_next;
      bist_address_reg <= bist_address_reg_next;
      bist_bsel_reg <= bist_bsel_reg_next;
      bist_id_reg <= bist_id_reg_next;
   end
end

always @ *
begin
   bist_data_reg_next = bist_data_reg;
   bist_bsel_reg_next = bist_bsel_reg;
   bist_address_reg_next = bist_address_reg;
   bist_id_reg_next = bist_id_reg;

   if (bist_data_capture_read_en)
   begin
      bist_data_reg_next = debug_data_out[BIST_DATA_WIDTH-1:0]; // trin reconfig
   end

   if (bist_data_shift_en)
   begin
      bist_data_reg_next = {bist_data_reg[BIST_DATA_WIDTH-1 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_address_shift_en)
   begin
      bist_address_reg_next = {bist_address_reg[15 - 4 : 0], rtap_srams_bist_data};
   end

   if (bist_bsel_shift_en)
   begin
      // assuming bus width is 4 and bsel is 8b
      bist_bsel_reg_next = {bist_bsel_reg[3:0], rtap_srams_bist_data[3:0]};
   end

   if (bist_id_shift_en)
   begin
      // assuming bus width is 4 and id is 4b
      bist_id_reg_next = rtap_srams_bist_data[3:0];
   end

   // assign output to be the most significant bits while shifting
   srams_rtap_data = bist_data_reg[BIST_DATA_WIDTH-1 -: 4];
end

// make/validate bist command
always @ *
begin
   // except for id shift, all commands need to have matching sramid to be activated
   bist_command = 0;
   if (bist_id_reg == sramid 
         || rtap_srams_bist_command == 4'd6
         || bist_id_reg == 8'b1111_1111)
      bist_command = rtap_srams_bist_command;
end
// combinational logics for states
always @ *
begin
   bist_state_next = BIST_STATE_INIT;
   // general processing of commands
   bist_data_capture_read_en = 1'b0;
   bist_en = 1'b0;
   bist_rdwen = 1'b0;
   bist_data_shift_en = 1'b0;
   bist_address_shift_en = 1'b0;
   bist_bsel_shift_en = 1'b0;
   bist_id_shift_en = 1'b0;
   case (bist_state)
      BIST_STATE_INIT:
      begin
         bist_state_next = BIST_STATE_INIT;
         if (bist_command == 4'd1)
         begin
            bist_state_next = BIST_STATE_CAPTURE_READ;
         end
      end
      BIST_STATE_CAPTURE_READ:
      begin
         bist_data_capture_read_en = 1'b1;
         bist_state_next = BIST_STATE_INIT;
      end
   endcase
   if (bist_command == 4'd1)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b0;
   end
   if (bist_command == 4'd2)
   begin
      bist_en = 1'b1;
      bist_rdwen = 1'b1;
   end
   if (bist_command == 4'd4)
   begin
      bist_data_shift_en = 1'b1;
   end
   if (bist_command == 4'd5)
   begin
      bist_address_shift_en = 1'b1;
   end
   if (bist_command == 4'd6)
   begin
      bist_id_shift_en = 1'b1;
   end
   if (bist_command == 4'd7)
   begin
      bist_bsel_shift_en = 1'b1;
   end

   // TODO
   debug_en = bist_en;
   debug_rw = bist_rdwen;
   debug_address[6:0] = bist_address_reg[6:0];
   debug_data_in[(4*2-1):0] = bist_data_reg[(4*2-1):0];
   debug_data_bmask = ~(16'b0);
end


endmodule // sram_l1d_val












// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_rf32x80.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//	Description:	Trap Stack Array
//			- Dual-Ported.
//			- Port1 - Write Port; Used by wrpr, trap insertion.
//			Write occurs in W Stage. (M1:M2:W).
//			- Port2 - Read Port; Used by rdpr, done/retry.
//			Read occurs in E Stage.
//			- Arranged as 6(trap-levels/thread) x 4 threads = 24 entries.
//			Trap-level and thread id used to index array.
*/
////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications



















































































































































































































































module bw_r_rf32x80(/*AUTOARG*/
   // Outputs
   dout, so,
   // Inputs
   rd_en, rd_adr, wr_en, nib_wr_en, wr_adr, din,
   si, se, sehold, rclk, rst_tri_en, reset_l);

parameter NUM_TPL = 6 ;         // 6 supported trap levels.
parameter NUM_ENTRIES = 32 ;    // 8 entries per thread

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
input [4:0]   rd_adr;     // read adr.
input         rd_en;      // read pointer
input         wr_en;      // write pointer vld
input [19:0]  nib_wr_en;  // enable write of a byte in tsa.
input [4:0]   wr_adr;     // write adr.
input [79:0] din;         // wr data for tsa.
input         rclk;       // clock
input         reset_l;    // active low reset
input         rst_tri_en; // reset and scan
input         sehold;     // scan hold
input         si;         // scan in
input         se;         // scan enable

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics
output  [79:0] dout ; // rd data for tsa.
output          so ;   // scan out write

   wire [159:0] write_mask; // write-mask
   reg [3:0] rd_adr_d1;
   reg [3:0] rd_adr_d2;
   reg read_en_d1;
   reg read_en_d2;

// for sastasks?
// reg [79:0]      temp_tlvl = 0;

   // memory
   reg [79:0] inq_ary [NUM_ENTRIES-1:0];

   // read
   assign dout = inq_ary[rd_adr_d1];

   // write
   always @ (posedge rclk)
   begin
      if (!reset_l)
      begin
         // assume flops
         inq_ary[00] <= 80'b0;
         inq_ary[01] <= 80'b0;
         inq_ary[02] <= 80'b0;
         inq_ary[03] <= 80'b0;
         inq_ary[04] <= 80'b0;
         inq_ary[05] <= 80'b0;
         inq_ary[06] <= 80'b0;
         inq_ary[07] <= 80'b0;
         inq_ary[08] <= 80'b0;
         inq_ary[09] <= 80'b0;
         inq_ary[10] <= 80'b0;
         inq_ary[11] <= 80'b0;
         inq_ary[12] <= 80'b0;
         inq_ary[13] <= 80'b0;
         inq_ary[14] <= 80'b0;
         inq_ary[15] <= 80'b0;
         inq_ary[16] <= 80'b0;
         inq_ary[17] <= 80'b0;
         inq_ary[18] <= 80'b0;
         inq_ary[19] <= 80'b0;
         inq_ary[20] <= 80'b0;
         inq_ary[21] <= 80'b0;
         inq_ary[22] <= 80'b0;
         inq_ary[23] <= 80'b0;
         inq_ary[24] <= 80'b0;
         inq_ary[25] <= 80'b0;
         inq_ary[26] <= 80'b0;
         inq_ary[27] <= 80'b0;
         inq_ary[28] <= 80'b0;
         inq_ary[29] <= 80'b0;
         inq_ary[30] <= 80'b0;
         inq_ary[31] <= 80'b0;
      end
      else
      begin
         if (wr_en)
         begin
            inq_ary[wr_adr] <= (din & write_mask) | (inq_ary[wr_adr] & ~write_mask);
         end
      end
   end

   // pipeline crap
   always @ (posedge rclk)
   begin
      // din_d1 <= din;
      rd_adr_d1 <= rd_adr;
      rd_adr_d2 <= rd_adr_d1;
      // wr_adr_d1 <= wr_adr;
      // wr_en_d1 <= wr_en;
      // word_wen_d1 <= word_wen;
      // byte_wen_d1 <= byte_wen;
      read_en_d1 <= rd_en;
      read_en_d2 <= read_en_d1;
   end

assign  write_mask[79:0] =
    {{4{nib_wr_en[19]}},
     {4{nib_wr_en[18]}},
     {4{nib_wr_en[17]}},
     {4{nib_wr_en[16]}},
     {4{nib_wr_en[15]}},
     {4{nib_wr_en[14]}},
     {4{nib_wr_en[13]}},
     {4{nib_wr_en[12]}},
     {4{nib_wr_en[11]}},
     {4{nib_wr_en[10]}},
     {4{nib_wr_en[9]}},
     {4{nib_wr_en[8]}},
     {4{nib_wr_en[7]}},
     {4{nib_wr_en[6]}},
     {4{nib_wr_en[5]}},
     {4{nib_wr_en[4]}},
     {4{nib_wr_en[3]}},
     {4{nib_wr_en[2]}},
     {4{nib_wr_en[1]}},
     {4{nib_wr_en[0]}}
    };

endmodule











// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dcd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================


// devices.xml


////////////////////////////////////////////////////////////////////////
/*
//  Module Name:
//  Description:  LSU Data Cache.
//      - Physically-Indexed Physically Tagged (PIPT)
//      - 8KB
//      - 4 way set-associative.
//      - 16B lines
//      - 2:1 column select by choosing either lower
//      or upper half of 16B line.
//      - Parity protected on a byte basis.
//      - Byte enables for byte-wide stores.
//
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
//`include  "sys.h" // system level definition file which contains the
                  // time scale definition

//`include "iop.h"
//`include "fabric.h"











//PITON_PROTO enables all FPGA related modifications






////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module bw_r_dcd ( /*AUTOARG*/
   // Outputs
   so, dcache_rdata_wb, dcache_rparity_wb, dcache_rparity_err_wb,
   dcache_rdata_msb_m,
   // dcache_rdata_msb_w0_m, dcache_rdata_msb_w1_m,
   // dcache_rdata_msb_w2_m, dcache_rdata_msb_w3_m,
   dcd_fuse_repair_value, dcd_fuse_repair_en,
   // Inputs
   dcache_rd_addr_e, dcache_alt_addr_e, dcache_rvld_e, dcache_wvld_e,
   dcache_wdata_e, dcache_wr_rway_e, dcache_byte_wr_en_e,
   dcache_alt_rsel_way_e, dcache_rsel_way_wb, dcache_alt_mx_sel_e,
   si, se, sehold, rst_tri_en, arst_l, rclk, dcache_alt_data_w0_m,
   dcache_arry_data_sel_m, efc_spc_fuse_clk1, fuse_dcd_wren,
   fuse_dcd_rid, fuse_dcd_repair_value, fuse_dcd_repair_en,


   // sram wrapper interface
   sram_dcache_w01_rtap_data,
   sram_dcache_w23_rtap_data,
   rtap_srams_bist_command,
   rtap_srams_bist_data
   ) ;


output [4-1:0] sram_dcache_w01_rtap_data;
output [4-1:0] sram_dcache_w23_rtap_data;
input  [4-1:0] rtap_srams_bist_command;
input  [4-1:0] rtap_srams_bist_data;

input [(6 + 4):3]    dcache_rd_addr_e;     // read cache index [`L1D_ADDRESS_HI:4] + bit [3] offset
input [(6 + 4):3]    dcache_alt_addr_e;    // write/bist/diagnostic read cache index + offset

input           dcache_rvld_e;        // read accesses d$.
input           dcache_wvld_e;        // valid write setup to m-stage.

input [144-1:0]   dcache_wdata_e;       // write data - 16Bx8 + 8b parity.
input [2-1:0]     dcache_wr_rway_e;     // replacement way for load miss/store.
input [15:0]    dcache_byte_wr_en_e;  // 16b byte wr enable for stores.

input [2-1:0]     dcache_alt_rsel_way_e ; // bist/diagnostic read way select
input [2-1:0]     dcache_rsel_way_wb;     // load way select, connect to cache_way_hit
input           dcache_alt_mx_sel_e;

input           si;
input           se;
input           sehold;

output          so;

input   rst_tri_en ;

input           arst_l; // used for redundancy flops - do not reset on wrm reset.

input           rclk;

output reg [63:0]  dcache_rdata_wb;
output reg [7:0]   dcache_rparity_wb;
output reg         dcache_rparity_err_wb;

//=================================
//    dc_fill critical path
//=================================
   input [63:0] dcache_alt_data_w0_m; //from qdp1
   input        dcache_arry_data_sel_m;            //from dctl

   // output [7:0] dcache_rdata_msb_w0_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w1_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w2_m;    //to dcdp
   // output [7:0] dcache_rdata_msb_w3_m;    //to dcdp
  
  wire [7:0] dcache_rdata_msb_w0_m;    //to dcdp


  wire [7:0] dcache_rdata_msb_w1_m;    //to dcdp



   output [8*2-1:0] dcache_rdata_msb_m;    //to dcdp

//-----------------------------------------------------------------------------
// 32KB block fuse inputs
//-----------------------------------------------------------------------------
// efuse non ovl clks
input           efc_spc_fuse_clk1;

input           fuse_dcd_wren;          //redundancy register write enable, qualified
input [2:0]     fuse_dcd_rid;           //redundancy register id
input [7:0]     fuse_dcd_repair_value;  //data in for redundancy register
input [1:0]     fuse_dcd_repair_en;     //enable bits to turn on redundancy
output [7:0]    dcd_fuse_repair_value;  //data out for redundancy register
output [1:0]    dcd_fuse_repair_en;     //enable bits out

// Memory declaration.
wire  [(6 + 4):3]    dcache_rwaddr_e ;
wire  [(6 + 4):3]    dcache_raddr_e ;



// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a;


  wire [144-1:0]   temp_w0a;


  wire [144-1:0]   temp_w1a;



// this particular macro contains 2 ways
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way_mask_e = { {8{dcache_byte_wr_en_e[0]}},
//                             {8{dcache_byte_wr_en_e[1]}},
//                             {8{dcache_byte_wr_en_e[2]}},
//                             {8{dcache_byte_wr_en_e[3]}},
//                             {8{dcache_byte_wr_en_e[4]}},
//                             {8{dcache_byte_wr_en_e[5]}},
//                             {8{dcache_byte_wr_en_e[6]}},
//                             {8{dcache_byte_wr_en_e[7]}},
//                             {8{dcache_byte_wr_en_e[8]}},
//                             {8{dcache_byte_wr_en_e[9]}},
//                             {8{dcache_byte_wr_en_e[10]}},
//                             {8{dcache_byte_wr_en_e[11]}},
//                             {8{dcache_byte_wr_en_e[12]}},
//                             {8{dcache_byte_wr_en_e[13]}},
//                             {8{dcache_byte_wr_en_e[14]}},
//                             {8{dcache_byte_wr_en_e[15]}}
//                           };

// Includes data(128b)+parity(16b).
wire [144-1:0] way_mask_e =
    {{8{dcache_byte_wr_en_e[15]}},{8{dcache_byte_wr_en_e[14]}},{8{dcache_byte_wr_en_e[13]}},
     {8{dcache_byte_wr_en_e[12]}},{8{dcache_byte_wr_en_e[11]}},{8{dcache_byte_wr_en_e[10]}},
     {8{dcache_byte_wr_en_e[9]}}, {8{dcache_byte_wr_en_e[8]}}, {8{dcache_byte_wr_en_e[7]}},
     {8{dcache_byte_wr_en_e[6]}}, {8{dcache_byte_wr_en_e[5]}}, {8{dcache_byte_wr_en_e[4]}},
     {8{dcache_byte_wr_en_e[3]}}, {8{dcache_byte_wr_en_e[2]}}, {8{dcache_byte_wr_en_e[1]}},
     {8{dcache_byte_wr_en_e[0]}}, dcache_byte_wr_en_e[15:0]} ;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way2_write_mask = {144{dcache_wr_rway_e[2]}} & way_mask_e;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0] way3_write_mask = {144{dcache_wr_rway_e[3]}} & way_mask_e;

// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w0a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w1a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w2a_reg;
// wire [`L1D_DATA_ENTRY_WIDTH-1:0]   temp_w3a_reg;

  wire [144-1:0] way0_write_mask = {144{dcache_wr_rway_e[0]}} & way_mask_e;
  wire [144-1:0]   temp_w0a_reg;


  wire [144-1:0] way1_write_mask = {144{dcache_wr_rway_e[1]}} & way_mask_e;
  wire [144-1:0]   temp_w1a_reg;





// !MERGE_L1_DCACHE && SRAM_LSU_DCACHE


sram_l1d_data_piton dcache_way_01
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way1_write_mask, way0_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w1a_reg, temp_w0a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w01_rtap_data),
  .SRAMID(8'd3)
);

sram_l1d_data_piton dcache_way_23
(
  .MEMCLK(rclk),
  .RESET_N(arst_l),
  .CE(dcache_wvld_e | dcache_rvld_e),
  .A(dcache_rwaddr_e[(6 + 4):4]),
  .DIN({dcache_wdata_e, dcache_wdata_e}),
  .BW({way3_write_mask, way2_write_mask}),
  .RDWEN(~dcache_wvld_e),
  .DOUT({temp_w3a_reg, temp_w2a_reg}),

  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(sram_dcache_w23_rtap_data),
  .SRAMID(8'd4)
);










































 // MERGE_L1_DCACHE












































 // SRAM_LSU_DCACHE

reg [(6 + 4):3]    dcache_rwaddr_m ;
reg [(6 + 4):3]    dcache_raddr_m ;
reg           dcache_rvld_m ;
reg           wvld_m ;
reg [144-1:0]   dcache_wdata_m ;
reg [127:0]   rw_wdline ;
reg [2-1:0]     dcache_wr_rway_m ;

// reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.
// reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.
// reg [63:0]    dcache_rdata_w2_wb;   // way2 64b data.
// reg [63:0]    dcache_rdata_w3_wb;   // way3 64b data.
reg [15:0]    byte_wr_enable ;

reg           dcache_alt_mx_sel_m, dcache_alt_mx_sel_wb;
reg [2-1:0]     dcache_alt_rsel_way_m, dcache_alt_rsel_way_wb;


wire            dcache_wvld_m ;
// wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
// wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
// wire  [63:0]    dcache_rdata_w2_m;    // way2 64b data.
// wire  [63:0]    dcache_rdata_w3_m;    // way3 64b data.
// wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
// wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
// wire  [7:0]     dcache_rparity_w2_m;  // way2 8b parity.
// wire  [7:0]     dcache_rparity_w3_m;  // way3 8b parity.

   // wire [7:0]   rd_parity_err_w0_m;
   // wire [7:0]   rd_parity_err_w1_m;
   // wire [7:0]   rd_parity_err_w2_m;
   // wire [7:0]   rd_parity_err_w3_m;


wire  [144-1:0]   way_mask ;
wire  [144-1:0]   way_mask_inv ;

//calculated parity based on read-out data
// wire [7:0]  gen_dcache_parity_w0_m;
// wire [7:0]  gen_dcache_parity_w1_m;
// wire [7:0]  gen_dcache_parity_w2_m;
// wire [7:0]  gen_dcache_parity_w3_m;

   wire     clk;
   assign   clk = rclk;


    wire [7:0]  gen_dcache_parity_w0_m;
    wire [7:0]   rd_parity_err_w0_m;
    wire  [7:0]     dcache_rparity_w0_m;  // way0 8b parity.
    wire  [63:0]    dcache_rdata_w0_m;    // way0 64b data.
    reg [63:0]    dcache_rdata_w0_wb;   // way0 64b data.


    wire [7:0]  gen_dcache_parity_w1_m;
    wire [7:0]   rd_parity_err_w1_m;
    wire  [7:0]     dcache_rparity_w1_m;  // way1 8b parity.
    wire  [63:0]    dcache_rdata_w1_m;    // way1 64b data.
    reg [63:0]    dcache_rdata_w1_wb;   // way1 64b data.



//=========================================================================================
//  Staging
//=========================================================================================

// BIST Rd used fill address port.
assign  dcache_rwaddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

assign  dcache_raddr_e[(6 + 4):3] =
  (dcache_alt_mx_sel_e) ? dcache_alt_addr_e[(6 + 4):3] : dcache_rd_addr_e[(6 + 4):3] ;

always @(posedge clk)
  begin
    dcache_alt_mx_sel_m   <= sehold ? dcache_alt_mx_sel_m : dcache_alt_mx_sel_e;

    dcache_alt_rsel_way_m <= sehold ? dcache_alt_rsel_way_m : dcache_alt_rsel_way_e;

    dcache_rwaddr_m[(6 + 4):3] <= sehold ? dcache_rwaddr_m[(6 + 4):3] : dcache_rwaddr_e[(6 + 4):3] ;

    dcache_raddr_m[(6 + 4):3] <= sehold ? dcache_raddr_m[(6 + 4):3] : dcache_raddr_e[(6 + 4):3] ;

    dcache_rvld_m         <= sehold ? dcache_rvld_m  : dcache_rvld_e ;

    wvld_m                <= sehold ?  wvld_m : dcache_wvld_e ;

    dcache_wdata_m[144-1:0] <= sehold ?  dcache_wdata_m[144-1:0] : dcache_wdata_e[144-1:0] ;

    dcache_wr_rway_m[2-1:0] <= sehold ?  dcache_wr_rway_m[2-1:0] : dcache_wr_rway_e[2-1:0] ;

    byte_wr_enable[15:0]  <= sehold ? byte_wr_enable[15:0] : dcache_byte_wr_en_e[15:0] ;

  end

always @ (posedge clk)
  begin
// JC modified begin
//    dcache_alt_mx_sel_wb <= dcache_alt_mx_sel_m;
//    dcache_alt_rsel_way_wb  <= dcache_alt_rsel_way_m;
    dcache_alt_mx_sel_wb <= sehold ? dcache_alt_mx_sel_wb :dcache_alt_mx_sel_m;
    dcache_alt_rsel_way_wb  <= sehold ? dcache_alt_rsel_way_wb :dcache_alt_rsel_way_m;
// JC modified end
  end

assign  dcache_wvld_m = wvld_m & ~rst_tri_en ;




















 // `ifndef SRAM_LSU_DCACHE

//removed stablizer, zero out without read (for IBM sram too)
// assign  temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w0a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w1a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w2a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;
// assign  temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:0] = dcache_rvld_m? temp_w3a_reg[`L1D_DATA_ENTRY_WIDTH-1:0]: 144'b0;


  assign  temp_w0a[144-1:0] = dcache_rvld_m? temp_w0a_reg[144-1:0]: 144'b0;


  assign  temp_w1a[144-1:0] = dcache_rvld_m? temp_w1a_reg[144-1:0]: 144'b0;



 // `ifndef SRAM_LSU_DCACHE

// Prior to SA, column mux (64(D)+8(P))x4 bits. Assume parity is
// at the end of the 144b line. Entry is wX||Parity

// // Select either upper or lower 64b from each of the 4 ways.
// assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w0a[79:16] ;
// assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w1a[79:16] ;
// assign  dcache_rdata_w2_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w2a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w2a[79:16] ;
// assign  dcache_rdata_w3_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w3a[`L1D_DATA_ENTRY_WIDTH-1:80] : temp_w3a[79:16] ;


  assign  dcache_rdata_w0_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w0a[144-1:80] : temp_w0a[79:16] ;


  assign  dcache_rdata_w1_m[63:0] = ~dcache_rwaddr_m[3] ? temp_w1a[144-1:80] : temp_w1a[79:16] ;



   wire [7:0] dcache_msb_w0_m;
   wire [7:0] dcache_alt_data_w0_msb_m;

//MSB sent out to dcdp in M stage
assign dcache_msb_w0_m[7:0]=
    {dcache_rdata_w0_m[63],
     dcache_rdata_w0_m[55],
     dcache_rdata_w0_m[47],
     dcache_rdata_w0_m[39],
     dcache_rdata_w0_m[31],
     dcache_rdata_w0_m[23],
     dcache_rdata_w0_m[15],
     dcache_rdata_w0_m[07]} ;

assign dcache_alt_data_w0_msb_m [7:0]=
    {dcache_alt_data_w0_m[63],
     dcache_alt_data_w0_m[55],
     dcache_alt_data_w0_m[47],
     dcache_alt_data_w0_m[39],
     dcache_alt_data_w0_m[31],
     dcache_alt_data_w0_m[23],
     dcache_alt_data_w0_m[15],
     dcache_alt_data_w0_m[07]} ;

//2-to-1 mux
assign dcache_rdata_msb_w0_m[7:0] = dcache_arry_data_sel_m ?
                                    dcache_msb_w0_m[7:0] :
                                    dcache_alt_data_w0_msb_m[7:0];

// assign dcache_rdata_msb_w1_m[7:0]=
//     {dcache_rdata_w1_m[63],
//      dcache_rdata_w1_m[55],
//      dcache_rdata_w1_m[47],
//      dcache_rdata_w1_m[39],
//      dcache_rdata_w1_m[31],
//      dcache_rdata_w1_m[23],
//      dcache_rdata_w1_m[15],
//      dcache_rdata_w1_m[07]} ;

// assign dcache_rdata_msb_w2_m[7:0]=
//     {dcache_rdata_w2_m[63],
//      dcache_rdata_w2_m[55],
//      dcache_rdata_w2_m[47],
//      dcache_rdata_w2_m[39],
//      dcache_rdata_w2_m[31],
//      dcache_rdata_w2_m[23],
//      dcache_rdata_w2_m[15],
//      dcache_rdata_w2_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;

// assign dcache_rdata_msb_w3_m[7:0]=
//     {dcache_rdata_w3_m[63],
//      dcache_rdata_w3_m[55],
//      dcache_rdata_w3_m[47],
//      dcache_rdata_w3_m[39],
//      dcache_rdata_w3_m[31],
//      dcache_rdata_w3_m[23],
//      dcache_rdata_w3_m[15],
//      dcache_rdata_w3_m[07]} ;


  assign dcache_rdata_msb_w1_m[7:0]=
    {dcache_rdata_w1_m[63],
     dcache_rdata_w1_m[55],
     dcache_rdata_w1_m[47],
     dcache_rdata_w1_m[39],
     dcache_rdata_w1_m[31],
     dcache_rdata_w1_m[23],
     dcache_rdata_w1_m[15],
     dcache_rdata_w1_m[07]} ;



assign dcache_rdata_msb_m[(8*(0+1))-1 -: 8] = dcache_rdata_msb_w0_m;
assign dcache_rdata_msb_m[(8*(1+1))-1 -: 8] = dcache_rdata_msb_w1_m;


   // wire [63:0] rdata_w0_m;
   // wire [63:0] rdata_w1_m;
   // wire [63:0] rdata_w2_m;
   // wire [63:0] rdata_w3_m;
wire [63:0] rdata_w0_m;
wire [63:0] rdata_w1_m;


//2-to-1 mux
//dcache_alt_mx_sel default 0001 (way 0) when not in MBIST mode (logic in qdp2)
assign rdata_w0_m[63:0] = dcache_arry_data_sel_m ?
                          dcache_rdata_w0_m[63:0] : dcache_alt_data_w0_m[63:0];

// //assign rdata_w0_m[63:0] = dcache_rdata_w0_m[63:0];
// assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];
// assign rdata_w2_m[63:0] = dcache_rdata_w2_m[63:0];
// assign rdata_w3_m[63:0] = dcache_rdata_w3_m[63:0];
   

  assign rdata_w1_m[63:0] = dcache_rdata_w1_m[63:0];



// // Select upper half or lower half of parity.
// assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
// assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
// assign  dcache_rparity_w2_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w2a[15:8] : temp_w2a[7:0] ;
// assign  dcache_rparity_w3_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w3a[15:8] : temp_w3a[7:0] ;

//    reg [7:0] dcache_rparity_w0_wb;
//    reg [7:0] dcache_rparity_w1_wb;
//    reg [7:0] dcache_rparity_w2_wb;
//    reg [7:0] dcache_rparity_w3_wb;

//    reg [7:0] rd_parity_err_w0_wb;
//    reg [7:0] rd_parity_err_w1_wb;
//    reg [7:0] rd_parity_err_w2_wb;
//    reg [7:0] rd_parity_err_w3_wb;


  assign  dcache_rparity_w0_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w0a[15:8] : temp_w0a[7:0] ;
  reg [7:0] dcache_rparity_w0_wb;
  reg [7:0] rd_parity_err_w0_wb;


  assign  dcache_rparity_w1_m[7:0] = ~dcache_rwaddr_m[3] ? temp_w1a[15:8] : temp_w1a[7:0] ;
  reg [7:0] dcache_rparity_w1_wb;
  reg [7:0] rd_parity_err_w1_wb;




// Stage to WB
always  @(posedge clk)
  begin
    // dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
    // dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
    // dcache_rdata_w2_wb[63:0] <= rdata_w2_m[63:0] ;
    // dcache_rdata_w3_wb[63:0] <= rdata_w3_m[63:0] ;

    // dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
    // dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
    // dcache_rparity_w2_wb[7:0] <=  dcache_rparity_w2_m[7:0];
    // dcache_rparity_w3_wb[7:0] <=  dcache_rparity_w3_m[7:0];

    // rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];
    // rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];
    // rd_parity_err_w2_wb [7:0] <= rd_parity_err_w2_m[7:0];
    // rd_parity_err_w3_wb [7:0] <= rd_parity_err_w3_m[7:0];


  dcache_rdata_w0_wb[63:0] <= rdata_w0_m[63:0] ;
  dcache_rparity_w0_wb[7:0] <=  dcache_rparity_w0_m[7:0];
  rd_parity_err_w0_wb [7:0] <= rd_parity_err_w0_m[7:0];


  dcache_rdata_w1_wb[63:0] <= rdata_w1_m[63:0] ;
  dcache_rparity_w1_wb[7:0] <=  dcache_rparity_w1_m[7:0];
  rd_parity_err_w1_wb [7:0] <= rd_parity_err_w1_m[7:0];



  end

//parity calculation and check are done in M stage for 4 way data
   // wire rd_parity_err_w0;
   // wire rd_parity_err_w1;
   // wire rd_parity_err_w2;
   // wire rd_parity_err_w3;

// lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
//                 .data_in        (dcache_rdata_w0_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w0_m[7:0])
//         );

// assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0]) :
//                                                   8'hff;


// lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
//                 .data_in        (dcache_rdata_w1_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w1_m[7:0])
//         );

// assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0]) :
//                                                  8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w2 (
//                 .data_in        (dcache_rdata_w2_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w2_m[7:0])
//         );
// assign rd_parity_err_w2_m[7:0] = dcache_rvld_m ? (dcache_rparity_w2_m[7:0] ^ gen_dcache_parity_w2_m[7:0])  :
//                                                    8'hff;

// lsu_dc_parity_gen #(8,8)  parity_gen_w3 (
//                 .data_in        (dcache_rdata_w3_m[63:0]),
//                 .parity_out     (gen_dcache_parity_w3_m[7:0])
//         );
// assign rd_parity_err_w3_m[7:0] =  dcache_rvld_m ? (dcache_rparity_w3_m[7:0] ^ gen_dcache_parity_w3_m[7:0]) :
//                                                   8'hff;


  wire rd_parity_err_w0;
  lsu_dc_parity_gen #(8,8)  parity_gen_w0 (
                  .data_in        (dcache_rdata_w0_m[63:0]),
                  .parity_out     (gen_dcache_parity_w0_m[7:0])
          );
  assign rd_parity_err_w0_m[7:0] = dcache_rvld_m ? (dcache_rparity_w0_m[7:0] ^ gen_dcache_parity_w0_m[7:0])  :
                                                     8'hff;


  wire rd_parity_err_w1;
  lsu_dc_parity_gen #(8,8)  parity_gen_w1 (
                  .data_in        (dcache_rdata_w1_m[63:0]),
                  .parity_out     (gen_dcache_parity_w1_m[7:0])
          );
  assign rd_parity_err_w1_m[7:0] = dcache_rvld_m ? (dcache_rparity_w1_m[7:0] ^ gen_dcache_parity_w1_m[7:0])  :
                                                     8'hff;



// way select mux on READ
// Select one of four ways from indexed cache set.

wire [2-1:0] dcache_rd_sel_way_wb;
assign dcache_rd_sel_way_wb[2-1:0] = dcache_alt_mx_sel_wb ? dcache_alt_rsel_way_wb[2-1:0] :
                                                          dcache_rsel_way_wb[2-1:0];

// assign  dcache_rdata_wb[63:0]  =
//  (dcache_rd_sel_way_wb[0] ? dcache_rdata_w0_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[1] ? dcache_rdata_w1_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[2] ? dcache_rdata_w2_wb[63:0] : 64'b0) |
//  (dcache_rd_sel_way_wb[3] ? dcache_rdata_w3_wb[63:0] : 64'b0);


always @ *
begin
dcache_rdata_wb[63:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w0_wb[63:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rdata_wb[63:0] = dcache_rdata_wb[63:0] | dcache_rdata_w1_wb[63:0];
end


//parity err in W-stage, cache_way_hit may not be one-hot
// assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);
// assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);
// assign rd_parity_err_w2 =   |(rd_parity_err_w2_wb[7:0]);
// assign rd_parity_err_w3 =   |(rd_parity_err_w3_wb[7:0]);


  assign rd_parity_err_w0 =   |(rd_parity_err_w0_wb[7:0]);


  assign rd_parity_err_w1 =   |(rd_parity_err_w1_wb[7:0]);



// assign dcache_rparity_err_wb = rd_parity_err_w3 & dcache_rd_sel_way_wb[3] |
//                                rd_parity_err_w2 & dcache_rd_sel_way_wb[2] |
//                                rd_parity_err_w1 & dcache_rd_sel_way_wb[1] |
//                                rd_parity_err_w0 & dcache_rd_sel_way_wb[0] ;

always @ *
begin
dcache_rparity_err_wb = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w0;
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_err_wb = dcache_rparity_err_wb | rd_parity_err_w1;
end


//mux4ds #(64) dcache_rdata_wb_mx (
//  .in0  (dcache_rdata_w0_wb[63:0]),
//  .in1  (dcache_rdata_w1_wb[63:0]),
//  .in2  (dcache_rdata_w2_wb[63:0]),
//  .in3  (dcache_rdata_w3_wb[63:0]),
//  .sel0 (dcache_rd_sel_way_wb[0]),
//  .sel1 (dcache_rd_sel_way_wb[1]),
//  .sel2 (dcache_rd_sel_way_wb[2]),
//  .sel3 (dcache_rd_sel_way_wb[3]),
//  .dout (dcache_rdata_wb[63:0])
//);

// dcache_rparity_wb only used by MBIST
//mux4ds #(8) dcache_rparity_wb_mx (
//  .in0 (dcache_rparity_w0_wb[7:0]),
//  .in1 (dcache_rparity_w1_wb[7:0]),
//  .in2 (dcache_rparity_w2_wb[7:0]),
//  .in3 (dcache_rparity_w3_wb[7:0]),
//  .sel0(dcache_alt_rsel_way_wb[0]),
//  .sel1(dcache_alt_rsel_way_wb[1]),
//  .sel2(dcache_alt_rsel_way_wb[2]),
//  .sel3(dcache_alt_rsel_way_wb[3]),
//  .dout(dcache_rparity_wb[7:0])
//);

// assign  dcache_rparity_wb[7:0] =
// ( dcache_rd_sel_way_wb[0] ? dcache_rparity_w0_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[1] ? dcache_rparity_w1_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[2] ? dcache_rparity_w2_wb[7:0] : 8'b0 ) |
// ( dcache_rd_sel_way_wb[3] ? dcache_rparity_w3_wb[7:0] : 8'b0 ) ;
always @ *
begin
dcache_rparity_wb[7:0] = 0;
if (dcache_rd_sel_way_wb[0])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w0_wb[7:0];
if (dcache_rd_sel_way_wb[1])
   dcache_rparity_wb[7:0] = dcache_rparity_wb[7:0] | dcache_rparity_w1_wb[7:0];
end













































 // `ifndef SRAM_LSU_DCACHE // FPGA

endmodule









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_dct.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_dct.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */

// devices.xml



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////









//PITON_PROTO enables all FPGA related modifications






































































































































































module bw_r_dct(
  // rdtag_w0_y, rdtag_w1_y, rdtag_w2_y, 
  rdtag_y, 
  // rdtag_w3_y, 
  so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, 

  wrtag_x, wrtag_y,
  // wrtag_w0_y, wrtag_w1_y, wrtag_w2_y,
  // wrtag_w3_y, wrtag_w0_x, wrtag_w1_x, wrtag_w2_x,
  // wrtag_w3_x, 
  adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [2-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;

  input [33-1:0]    wrtag_y;
  input [33-1:0]    wrtag_x;
  input [2-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [(33*2)-1:0]    rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [2-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [131:0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({2 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // wire [131:0] write_bus_x = {wrtag_x,wrtag_x,wrtag_x,wrtag_x};
  // wire [131:0] write_bus_mask_x = {{33{we[3]}}, {33{we[2]}}, {33{we[1]}}, {33{we[0]}}};

  wire [33*2-1:0] write_bus_x = {2{wrtag_x}};
  wire [33*2-1:0] write_bus_mask_x;
  
  assign write_bus_mask_x[33*(0+1)-1 -: 33] = {33{we[0]}};


  assign write_bus_mask_x[33*(1+1)-1 -: 33] = {33{we[1]}};




  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

  wire  [(33*2)-1:0]    rdtag_y;

sram_l1d_tag cache
(
  .MEMCLK(rclk),
    .RESET_N(reset_l),
  .CE(wrreq_x | rdreq_x),
  .A(index_x),
  .DIN(write_bus_x),
  .BW(write_bus_mask_x),
  .RDWEN(~wrreq_x),
  .DOUT(rdtag_y),

  // .BIST_COMMAND(rtap_srams_bist_command),
  // .BIST_DIN(rtap_srams_bist_data),
  // .BIST_DOUT(sram_dcache_w01_rtap_data),
  // .SRAMID(`BIST_ID_L1_DCACHE_W01)
  .BIST_COMMAND(rtap_srams_bist_command),
  .BIST_DIN(rtap_srams_bist_data),
  .BIST_DOUT(srams_rtap_data),
  .SRAMID(sramid)
);

  // assign rdtag_y = {rdtag_w3_y, rdtag_w2_y, rdtag_w1_y, rdtag_w0_y};




endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_dtlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/

// devices.xml


////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































module bw_r_dtlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   // cache_ptag_w0, cache_ptag_w1, 
   // cache_ptag_w2, cache_ptag_w3, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input    [(33*2)+1-1:0]      cache_ptag;          // way3 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w0;       	// way1 30b(D)/29b(I) tag.
// input  	[29:0]    	cache_ptag_w1;       	// way2 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w2;       	// way0 30b(D)/29b(I) tag.
// input  	[29:0]     	cache_ptag_w3;       	// way3 30b(D)/29b(I) tag.
input	[2-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;

// input    [29:0]      cache_ptag_w0;          // way1 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w1;          // way2 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w2;          // way0 30b(D)/29b(I) tag.
// input    [29:0]      cache_ptag_w3;          // way3 30b(D)/29b(I) tag.

wire cache_ptag_va_10 = cache_ptag[(33*2)];


wire [33-1:0] cache_ptag_w0_tmp = cache_ptag[33*(0+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w0 = {cache_ptag_w0_tmp[(29+1)-2:0],cache_ptag_va_10};


wire [33-1:0] cache_ptag_w1_tmp = cache_ptag[33*(1+1)-1 -: 33];
wire [(29+1)-1:0] cache_ptag_w1 = {cache_ptag_w1_tmp[(29+1)-2:0],cache_ptag_va_10};




input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[2-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[2-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [2-1:0]		cache_set_vld_g;
// reg	[29:0]		cache_ptag_w0_g,cache_ptag_w1_g;
// reg	[29:0]		cache_ptag_w2_g,cache_ptag_w3_g;
reg [29:0]      cache_ptag_w0_g;
reg [29:0]      cache_ptag_w1_g;

reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.


 

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[2-1:0]  	<= cache_set_vld[2-1:0] ;
			// cache_ptag_w0_g[29:0] 	<= cache_ptag_w0[29:0] ;
			// cache_ptag_w1_g[29:0] 	<= cache_ptag_w1[29:0] ;
			// cache_ptag_w2_g[29:0] 	<= cache_ptag_w2[29:0] ;
			// cache_ptag_w3_g[29:0] 	<= cache_ptag_w3[29:0] ;
         
 cache_ptag_w0_g[(29+1)-1:0]   <= cache_ptag_w0[(29+1)-1:0];


 cache_ptag_w1_g[(29+1)-1:0]   <= cache_ptag_w1[(29+1)-1:0];

 
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


// assign	cache_way_hit[0] = 
// 	(cache_ptag_w0_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[0];
// assign	cache_way_hit[1] = 
// 	(cache_ptag_w1_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[1];
// assign	cache_way_hit[2] = 
// 	(cache_ptag_w2_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[2];
// assign	cache_way_hit[3] = 
// 	(cache_ptag_w3_g[29:0] == pgnum_g[29:0]) & cache_set_vld_g[3];


    assign  cache_way_hit[0] = 
       (cache_ptag_w0_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[0];


    assign  cache_way_hit[1] = 
       (cache_ptag_w1_g[(29+1)-1:0] == pgnum_g[(29+1)-1:0]) & cache_set_vld_g[1];



assign	cache_hit = |cache_way_hit[2-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)
	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end



//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: bw_r_ict.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
 //  Module Name:  bw_r_ict.v
 //  Description:
 //    Contains the RTL for the icache and dcache tag blocks.
 //    This is a 1RW 512 entry X 33b macro, with 132b rd and 132b wr,
 //    broken into 4 33b segments with its own write enable.
 //    Address and Control inputs are available the stage before
 //    array access, which is referred to as "_x".  Write data is
 //    available in the same stage as the write to the ram, referred
 //    to as "_y".  Read data is also read out and available in "_y".
 //
 //            X       |      Y
 //     index          |  ram access
 //     index sel      |  write_tag
 //     rd/wr req      |     -> read_tag
 //     way enable     |
 */


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////


// devices.xml












//PITON_PROTO enables all FPGA related modifications














































































































































module bw_r_ict(rdtag_y, so, rclk, se,
  si, reset_l, sehold, rst_tri_en, index0_x, index1_x, index_sel_x,
  dec_wrway_x, rdreq_x, wrreq_x, wrtag_y,
  wrtag_x, adj,

  // sram wrapper interface
  sramid,
  srams_rtap_data,
  rtap_srams_bist_command,
  rtap_srams_bist_data
  );

  input     rclk;
  input     se;
  input     si;
  input     reset_l;
  input     sehold;
  input     rst_tri_en;
  input [6:0]   index0_x;
  input [6:0]   index1_x;
  input     index_sel_x;
  input [2-1:0]   dec_wrway_x;
  input     rdreq_x;
  input     wrreq_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_x;
  input [((39 - (6 + 5))+1)-1:0] wrtag_y;
  input [2-1:0]   adj;


  // sram wrapper interface
  output [4-1:0] srams_rtap_data;
  input  [4-1:0] rtap_srams_bist_command;
  input  [4-1:0] rtap_srams_bist_data;
  input  [8-1:0] sramid;

  output  [((((39 - (6 + 5))+1) * 2)-1):0] rdtag_y;
  output      so;

  wire      clk;
  wire  [6:0]   index_x;
  reg   [6:0]   index_y;
  wire  [2-1:0]   we;
  reg           wrreq_y;
  reg           rdreq_y;

  reg [((((39 - (6 + 5))+1) * 2)-1):0]  rdtag_sa_y; //for error_inject XMR

  assign clk = rclk;
  assign index_x = (index_sel_x ? index1_x : index0_x);
  assign we = ({2 {((wrreq_x & reset_l) & (~rst_tri_en))}} & dec_wrway_x);

  // assign write_bus_x[`IC_PHYS_TAG_WAY0_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY1_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY2_MASK] = wrtag_x;
  // assign write_bus_x[`IC_PHYS_TAG_WAY3_MASK] = wrtag_x;

  always @ (posedge rclk)
  begin
    index_y <= index_x;
    wrreq_y <= wrreq_x;
    rdreq_y <= rdreq_x;
  end

// real SRAM instance
wire [33*2-1 : 0] write_bus_mask_x = {
{33{we[1]}},
{33{we[0]}}

};

  wire [32:0] wrtag_x_phys = wrtag_x;
  wire [33*2-1 : 0] write_bus_x_phys = {2{wrtag_x_phys}};
  // wire [`IC_PHYS_TAG_MASK_ALL] write_bus_x_phys = {wrtag_x_phys, wrtag_x_phys, wrtag_x_phys, wrtag_x_phys};
  wire [33*2-1 : 0] rdtag_y_phys;

  // assign rdtag_y[`IC_TLB_TAG_WAY0_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY0_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY1_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY1_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY2_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY2_MASK];
  // assign rdtag_y[`IC_TLB_TAG_WAY3_MASK] = rdtag_y_phys[`IC_PHYS_TAG_WAY3_MASK];

  // truncate tags from 33 bits to appropriate size
  
  wire [32:0] rdtag_y_phys_WAY0 = rdtag_y_phys[33*1-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*1-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY0[(((39 - (6 + 5))+1)-1):0];
  

  wire [32:0] rdtag_y_phys_WAY1 = rdtag_y_phys[33*2-1 -: 33];
  assign rdtag_y[((39 - (6 + 5))+1)*2-1 -: ((39 - (6 + 5))+1)] = rdtag_y_phys_WAY1[(((39 - (6 + 5))+1)-1):0];
  


  sram_l1i_tag cache
  (
    .MEMCLK(rclk),
      .RESET_N(reset_l),
    .CE(wrreq_x | rdreq_x),
    .A(index_x),
    .DIN(write_bus_x_phys),
    .BW(write_bus_mask_x),
    .RDWEN(~wrreq_x),
    .DOUT(rdtag_y_phys),

    .BIST_COMMAND(rtap_srams_bist_command),
    .BIST_DIN(rtap_srams_bist_data),
    .BIST_DOUT(srams_rtap_data),
    .SRAMID(sramid)
  );

endmodule

 // IBM TAG









// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: bw_r_itlb.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// devices.xml


///////////////////////////////////////////////////////////////////////
/*
//	Description:	Common TLB for Instruction Fetch and Load/Stores
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================







































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications








//this macro will not be used
































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // is default implementation in openpiton







module bw_r_itlb ( /*AUTOARG*/
   // Outputs

   
   tlb_rd_tte_csm, tlb_rd_tte_csm_crit,
   
   tlb_rd_tte_tag, tlb_rd_tte_data, tlb_pgnum, tlb_pgnum_crit, 
   tlb_cam_hit, cache_way_hit, cache_hit, so, 
   // Inputs

   
   tlb_wr_tte_csm_thrid, tlb_wr_tte_csm, tlb_rd_csm_vld, tlb_wr_csm_sel,

   cfg_csm_tlb_state, cfg_csm_tlb_chipid,cfg_csm_tlb_x,
   cfg_csm_tlb_y, cfg_csm_tlb_hdid,cfg_csm_tlb_hd_size,
   cfg_csm_tlb_sdid,cfg_csm_tlb_lsid,
   


   tlb_cam_vld, tlb_cam_key, tlb_cam_pid,  
   tlb_demap_key, tlb_addr_mask_l, tlb_ctxt, 
   tlb_wr_vld, tlb_wr_tte_tag, tlb_wr_tte_data, tlb_rd_tag_vld, 
   tlb_rd_data_vld, tlb_rw_index, tlb_rw_index_vld, tlb_demap, 
   tlb_demap_auto, tlb_demap_all, cache_ptag, 
   cache_set_vld, tlb_bypass_va, 
   tlb_bypass, se, si, hold, adj, arst_l, rst_soft_l, rclk,
   rst_tri_en
   ) ;	


input			tlb_cam_vld ;		// ld/st requires xlation. 
input	[40:0]		tlb_cam_key ;		// cam data for loads/stores;includes vld 
						// CHANGE : add real bit for cam.
input	[2:0]		tlb_cam_pid ;		// NEW: pid for cam. 
input	[40:0]		tlb_demap_key ;		// cam data for demap; includes vlds. 
						// CHANGE : add real bit for demap
input			tlb_addr_mask_l ;	// address masking occurs
input	[12:0]		tlb_ctxt ;		// context for cam xslate/demap. 
input			tlb_wr_vld;		// write to tlb. 
input	[58:0]		tlb_wr_tte_tag;		// CHANGE:tte tag to be written (55+4-1)
						// R(+1b),PID(+3b),G(-1b). 
input	[42:0]		tlb_wr_tte_data;	// tte data to be written.
						// No change(!!!) - G bit becomes spare
input			tlb_rd_tag_vld ;	// read tag
input			tlb_rd_data_vld ;	// read data
input	[5:0]		tlb_rw_index ;		// index to read/write tlb.
input			tlb_rw_index_vld ;	// indexed write else use algorithm.
input			tlb_demap ;		// demap : page/ctxt/all/auto.  
input			tlb_demap_auto ;	// demap is of type auto 
input			tlb_demap_all;		// demap-all operation : encoded separately.
input  	[((((39 - (6 + 5))+1) * 2)-1):0]    	cache_ptag;       	// way1 30b(D)/29b(I) tag.
input	[2-1:0]		cache_set_vld;       	// set vld-4 ways
input	[12:10]		tlb_bypass_va;	   	// bypass va.other va bits from cam-data
input			tlb_bypass;		// bypass tlb xslation

input			se ;			// scan-enable ; unused
input			si ;			// scan data in ; unused
input			hold ;			// scan hold signal
input	[7:0]		adj ;			// self-time adjustment ; unused
input			arst_l ;		// synchronous for tlb ; unused	
input			rst_soft_l ;		// software reset - asi
input			rclk;
input			rst_tri_en ;



input [2-1:0]   cfg_csm_tlb_state;
input [14-1:0]      cfg_csm_tlb_chipid;
input [8-1:0]           cfg_csm_tlb_x;
input [8-1:0]           cfg_csm_tlb_y;
input [10-1:0]        cfg_csm_tlb_hdid;
input [6-1:0]        cfg_csm_tlb_hd_size;
input [10-1:0]        cfg_csm_tlb_sdid;
input [6-1:0]        cfg_csm_tlb_lsid;


input [1:0]         tlb_wr_tte_csm_thrid;
input [32:0]    tlb_wr_tte_csm;
input               tlb_rd_csm_vld;
input               tlb_wr_csm_sel;
output [32:0]   tlb_rd_tte_csm;
output [32:0]   tlb_rd_tte_csm_crit;



output	[58:0]		tlb_rd_tte_tag;		// CHANGE: tte tag read from tlb.
output	[42:0]		tlb_rd_tte_data;	// tte data read from tlb.
// Need two ports for tlb_pgnum - critical and non-critical.
output	[39:10]		tlb_pgnum ;		// bypass or xslated pgnum
output	[39:10]		tlb_pgnum_crit ;	// bypass or xslated pgnum - critical
output			tlb_cam_hit ;		// xlation hits in tlb.
output	[2-1:0]		cache_way_hit;		// tag comparison results.
output			cache_hit;		// tag comparison result - 'or' of above.

//output			tlb_writeable ;		// tlb can be written in current cycle.

output			so ;		// scan data out ; unused

wire	[53:0]		tlb_cam_data ;
wire	[58:0]		wr_tte_tag ;	// CHANGE
wire	[42:0]		wr_tte_data ;
wire	[29:3]		phy_pgnum_m;
wire	[29:0]		pgnum_m;
wire 	[16-1:0]		used ;
wire			tlb_not_writeable ;
wire	[40:25] 	tlb_cam_key_masked ;
wire	[26:0]		tlb_cam_comp_key ;
wire			cam_vld ;
wire			demap_other ;
wire	[2-1:0]   	cache_way_hit ;

reg			tlb_not_writeable_d1 ;
reg			tlb_writeable ;
reg	[58:0]		tte_tag_ram  [16-1:0] ;	// CHANGE
reg	[42:0]		tte_data_ram [16-1:0] ;
reg	[16-1:0]		tlb_entry_vld ;
reg	[16-1:0]		tlb_entry_locked ;
reg	[16-1:0]		ademap_hit ;
reg	[58:0]		rd_tte_tag ;	// CHANGE
reg	[42:0]		rd_tte_data ;	
reg	[58:0]		tlb_rd_tte_tag ; // CHANGE	
reg	[42:0]		tlb_rd_tte_data ;	
reg			cam_vld_tmp ;
reg	[2:0]		cam_pid ;
reg	[53:0]		cam_data ;
reg			demap_auto, demap_other_tmp, demap_all ;
reg	[16-1:0]		mismatch ;
reg	[16-1:0]		cam_hit ;
reg	[16-1:0]		demap_hit ;
reg	[16-1:0]		demap_all_but_locked_hit ;
reg	[16-1:0]		mismatch_va_b47_28 ;
reg	[16-1:0]		mismatch_va_b27_22 ;
reg	[16-1:0]		mismatch_va_b21_16 ;
reg	[16-1:0]		mismatch_va_b15_13 ;
reg	[16-1:0]		mismatch_ctxt ;
reg	[16-1:0]		mismatch_pid ;
reg	[58:0]		tag ;	// CHANGE
reg	[16-1:0]		rw_wdline ;
reg	[16-1:0]		tlb_entry_used ;
reg	[16-1:0]		tlb_entry_replace ;
reg	[16-1:0]		tlb_entry_replace_d2 ;
reg	[29:0]		pgnum_g ;
reg     [2-1:0]		cache_set_vld_g;
reg	[((((39 - (6 + 5))+1) * 2)-1):0]		cache_ptag_g;
reg			wr_vld_tmp;
reg			rd_tag; 
reg			rd_data;
reg			rw_index_vld;
reg	[4-1:0]		rw_index;
reg	[16-1:0]		sat ;



wire	[32:0]		wr_tte_csm ;
reg	    [32:0]		tte_csm_buf [1:0];
reg	    [32:0]		tte_csm_ram [16-1:0];
reg	    [32:0]		rd_tte_csm ;	
reg	    [32:0]		rd_tte_csm_real ;	
reg	    [32:0]		tlb_rd_tte_csm ;	
reg			            rd_csm;
reg                     wr_csm_sel;
reg     [1:0]           wr_tte_csm_thrid;

wire	[29:0] 		vrtl_pgnum_m;
wire			bypass ;

wire			wr_vld ;

//integer	i,j,k,l,m,n,p,r,s,t,u,w;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// Some bits are removed from the tag and data. 
// 'U' must be defined as a '1' on a write.
// 'L' required for demap all function.
// Do not need an internal valid bit for va range 47:22.
// These bits are always valid for a page. 
// 
// TTE STLB_TAG
//
//`define	STLB_TAG_PID_HI		58	: NEW PID - bit2
//`define	STLB_TAG_PID_LO		56	: NEW PID - bit0
//`define	STLB_TAG_R		55	: NEW Real bit
//`define 	STLB_TAG_PARITY		54	// Parity kept in same posn to avoid having
//`define	STLB_TAG_VA_47_28_HI 	53	// to redo interface
//`define	STLB_TAG_VA_47_28_LO 	34
//`define	STLB_TAG_VA_27_22_HI 	33	
//`define	STLB_TAG_VA_27_22_LO 	28
//`define	STLB_TAG_27_22_V	27	
//`define	STLB_TAG_V		26	: valid for entry. Write of 0 resets it.
//`define	STLB_TAG_L		25
//`define	STLB_TAG_U		24	
//`define	STLB_TAG_VA_21_16_HI 	23
//`define	STLB_TAG_VA_21_16_LO  	18
//`define	STLB_TAG_VA_21_16_V  	17	  	
//`define	STLB_TAG_VA_15_13_HI 	16
//`define	STLB_TAG_VA_15_13_LO  	14
//`define	STLB_TAG_VA_15_13_V  	13
//`define	STLB_TAG_CTXT_12_0_HI  	12	// removed Global bit
//`define	STLB_TAG_CTXT_12_0_LO  	0
//// 				Total - 59b
////
//// TTE STLB_DATA
////
//// Soft[12:7] & Soft2[58:50] are removed.
//// Diag[49:41] are removed. Used bit used for Diag[0] on read.
//// CV is included for software correctness.
//// PA<40> is removed as it is not used.
//// G/L present in data even though present in tag : can't read out simultaneously.
//   (Unfortunately this is no longer correct. For data read, tag is also read
//   simultaneously to get valid bit, used bits).
//`define 	STLB_DATA_PARITY  	42 
//`define 	STLB_DATA_PA_39_28_HI 	41	// CHANGE
//`define 	STLB_DATA_PA_39_28_LO 	30
//`define 	STLB_DATA_PA_27_22_HI 	29	// CHANGE
//`define 	STLB_DATA_PA_27_22_LO 	24
//`define 	STLB_DATA_27_22_SEL	23
//`define 	STLB_DATA_PA_21_16_HI 	22	// CHANGE
//`define 	STLB_DATA_PA_21_16_LO 	17
//`define 	STLB_DATA_21_16_SEL	16
//`define 	STLB_DATA_PA_15_13_HI 	15	
//`define 	STLB_DATA_PA_15_13_LO 	13
//`define 	STLB_DATA_15_13_SEL	12
//`define 	STLB_DATA_V  		11	: static, does not get modified.
//`define 	STLB_DATA_NFO  		10
//`define 	STLB_DATA_IE   		9
//`define 	STLB_DATA_L 		8 	: added for read.
//`define 	STLB_DATA_CP 		7 
//`define 	STLB_DATA_CV 		6 
//`define 	STLB_DATA_E  		5 
//`define 	STLB_DATA_P  		4 
//`define 	STLB_DATA_W  		3 
//`define 	STLB_DATA_SPARE_HI  	2	: Global bit has been removed
//`define 	STLB_DATA_SPARE_LO	0  	 
// 				Total - 43b

// Valid bits for key(tlb_cam_key/tlb_demap_key).
// Total - 41b
//`define	CAM_VA_47_28_HI  	40
//`define	CAM_VA_47_28_LO  	21
//`define	CAM_VA_47_28_V  	20	// b47-28 participate in match
//`define	CAM_VA_27_22_HI  	19
//`define	CAM_VA_27_22_LO  	14
//`define	CAM_VA_27_22_V  	13	// b27-22 participate in match
//`define	CAM_VA_21_16_HI  	12
//`define	CAM_VA_21_16_LO  	7
//`define	CAM_VA_21_16_V  	6	// b21-16 participate in match
//`define	CAM_VA_15_13_HI 	5	
//`define	CAM_VA_15_13_LO 	3	
//`define	CAM_VA_15_13_V 	 	2	// b15-13 participate in match
//`define	CAM_CTXT_GK 		1	// Context participates in match
//`define	CAM_REAL_V 		0	// cam/demap applies to real mapping
					

// ctxt port is different from cam key port even though both are
// required for cam. (tlb_ctxt)
// If Gk is set then ctxt will not participate in match.
// Total - 14b




//=========================================================================================
//	What's Left :
//=========================================================================================

// Scan Insertion - scan to be ignored in formal verification for now.

//=========================================================================================
//	Design Notes.
//=========================================================================================

// - Supported Demap Operations - By Page, By Context, All But
// Locked, Autodemap, Invalidate-All i.e., reset. Demap Partition is
// not supported - it is mapped to demap-all by logic. 
// - Interpretation of demap inputs
//	- tlb_demap - this is used to signal demap by page, by ctxt
//	,all, and autodemap. 
//	- tlb_demap_ctxt - If a demap_by_ctxt operation is occuring then
//	this signal and tlb_demap must be active.
//	- tlb_demap_all - demap all operation. If a demap_all operation is
//	occuring, then tlb_demap_all must be asserted with tlb_demap. 
// - Reset is similar to demap-all except that *all* entries
// are invalidated. The action is initiated by software. The reset occurs
// on the negedge and is synchronous with the clk.
// - TTE Tag and Data
// 	- The TTE tag and data can be read together. Each will have its 
//	own bus and the muxing will occur externally. The tag needs to
//	be read on a data request to supply the valid bit.
// 	- The TTE tag and data can be written together.
// - The cam hit is a separate output signal based on the 
// the match signals.
// - Read/Write may occur based on supplied index. If not valid
// then use replacement way determined by algorithm to write.
// - Only write can use replacement way determined by algorithm.
// - Data is formatted appr. on read or write in the MMU. 
// - The TLB will generate a signal which reports whether the 
// tlb can be filled in the current cycle or not.
// **Physical Tag Comparison**
// For I-SIDE, comparison is of 28b, whereas for D-side, comparison is of 29b. The actual
// comparison, due to legacy, is for 30b.
// For the I-TLB, va[11:10] must be hardwired to the same value as the lsb of the 4 tags
// at the port level. Since the itag it only 28b, add two least significant bits to extend it to 30b.
// Similarly, for the dside, va[10] needs to be made same.	
// **Differentiating among Various TLB Operations**
// Valid bits are now associated with the key to allow selective incorporation of
// match results. The 5 valid bits are : v4(b47-28),v3(b27-22),v2(21-16),v1(b15-13)
// and Gk(G bit for auto-demap). The rules of use are :
//	- cam: v4-v1 are set high. G=~cam_real=0/1.
//	- demap_by_page : v4-v1 are set high. G=1. cam_real=0.
// 	- demap_by_ctxt : v4-v1 are low. G=1. cam_real=0
//	- demap_all : v4-v1 are don't-care. G=x. cam_real=x
//	- autodemap : v4-v1 are based on page size of incoming tte. G=~cam_real=0/1.
// Note : Gk is now used only to void a context match on a Real Translation.
// In general, if a valid bit is low then the corresponding va field will not take
// part in the match. Similarly, for the ctxt, if Gk=1, the ctxt will participate
// in the match.
//
// Demap Table (For Satya) :
// Note : To include a context match, Gk must be set to 1.
//--------------------------------------------------------------------------------------------------------
//tlb_demap tlb_demap_all  tlb_ctxt Gk	Vk4 Vk3	Vk2 Vk1 Real	Operation
//--------------------------------------------------------------------------------------------------------
//0		x		x   x	x   x	x   x   0	No demap operation
//1		0		0   1	1   1	1   1	0	Demap by page
//1		0		0   1	1   0	0   0	0/1	256M demap(auto demap)
//1		0		0   0	1   0	0   0	0	256M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	0   0	0/1	4M demap(auto demap)
//1		0		0   0	1   1	0   0	0	4M demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   0	0/1	64k demap(auto demap)
//1		0		0   0	1   1	1   0	0	64k demap(auto demap) (*Illgl*)
//1		0		0   1	1   1	1   1	0/1	8k demap(auto demap)
//1		0		0   0	1   1	1   1	0	8k demap(auto demap) (*Illgl*)
//1		0		1   1	0   0	0   0	0	demap by ctxt
//1		1		x   x	x   x	x   x	0	demap_all
//------------------------------------------------------------------------------------------
//-----
//All other are illegal combinations
//
//=========================================================================================
//	Changes related to Hypervisor/Legacy Compatibility
//=========================================================================================
//
// - Add PID. PID does not effect demap-all. Otherwise it is included in cam, other demap
// operations and auto-demap.
// - Add R. Real translation ignores context. This is controlled externally by Gk.
// - Remove G bit for tte. Input remains in demap-key/cam-key to allow for disabling
//   of context match Real Translation  
// - Final Page Size support - 8KB,64KB,4M,256M
// - SPARC_HPV_EN has been defined to enable new tlb design support. 
// Issues : 
// -Max ptag size is now 28b. Satya, will this help the speed at all. I doubt it !

//=========================================================================================
//	Miscellaneous
//=========================================================================================
   wire clk;
   assign clk = rclk;
   
wire async_reset, sync_reset ;
assign	async_reset = ~arst_l ; 			// hardware
assign	sync_reset = (~rst_soft_l & ~rst_tri_en) ;	// software

wire rw_disable ;
// INNO - wr/rd gated off. Note required as rst_tri_en is
// asserted, but implemented in addition in schematic.
assign	rw_disable = ~arst_l | rst_tri_en ;

//=========================================================================================
// 	Stage Data
//=========================================================================================
// Apply address masking
assign	tlb_cam_key_masked[40:25]
	= {16{tlb_addr_mask_l}} & 
		tlb_cam_key[40:21+4] ;

// Reconstitute cam data CHANGE : add additional bit for real mapping
assign	tlb_cam_data[53:13] = tlb_demap ? 
	tlb_demap_key[40:0] :
	{tlb_cam_key_masked[40:25],tlb_cam_key[21+3:0]} ; 

assign tlb_cam_comp_key[26:0] = 
		tlb_demap ?
			{tlb_demap_key[32:21], tlb_demap_key[19:14],tlb_demap_key[12:7],
			tlb_demap_key[5:3]} :
			{tlb_cam_key_masked[32:25],tlb_cam_key[24:21],
			tlb_cam_key[19:14],tlb_cam_key[12:7],tlb_cam_key[5:3]} ;

assign	tlb_cam_data[12:0] = tlb_ctxt[12:0] ;

// These signals are flow-thru.
assign	wr_tte_tag[58:0] 	= tlb_wr_tte_tag[58:0] ;	// CHANGE
assign	wr_tte_data[42:0] 	= tlb_wr_tte_data[42:0] ;

assign wr_tte_csm = tlb_wr_tte_csm;



// CHANGE(SATYA) - Currently the rw_index/rw_index_vld are shared by both reads
// and writes. However, writes are done in the cycle of broadcast, whereas
// the reads are done a cycle later, as given in the model(incorrect) 
// They have to be treated uniformly. To make the model work, I've assumed the read/write 
// are done in the cycle the valids are broadcast. 
always @ (posedge clk)
	begin
	if (hold)
		begin
		cam_pid[2:0]		<= cam_pid[2:0] ;
		cam_vld_tmp		<= cam_vld_tmp ;
		cam_data[53:0] 		<= cam_data[53:0] ;
		demap_other_tmp		<= demap_other_tmp ;
		demap_auto		<= demap_auto ;
		demap_all		<= demap_all ;
		wr_vld_tmp 		<= wr_vld_tmp ;
		rd_tag 			<= rd_tag ;
		rd_data			<= rd_data ;
		rw_index_vld		<= rw_index_vld ;
		rw_index[4-1:0]		<= rw_index[4-1:0] ; 
            
        
        rd_csm          <= rd_csm;
        wr_csm_sel      <= wr_csm_sel;
        wr_tte_csm_thrid <= wr_tte_csm_thrid;
        
		end
	else
		begin
		cam_pid[2:0]		<= tlb_cam_pid[2:0] ;
		cam_vld_tmp		<= tlb_cam_vld ;
		cam_data[53:0] 		<= tlb_cam_data[53:0] ;
		demap_other_tmp		<= tlb_demap ;
		demap_auto		<= tlb_demap_auto ;
		demap_all		<= tlb_demap_all ;
		wr_vld_tmp 		<= tlb_wr_vld ;
		rd_tag 			<= tlb_rd_tag_vld ;
		rd_data			<= tlb_rd_data_vld ;
		rw_index_vld		<= tlb_rw_index_vld ;
		rw_index[4-1:0]		<= tlb_rw_index[4-1:0] ; 	
		
        
        rd_csm          <= tlb_rd_csm_vld;
        wr_csm_sel      <= tlb_wr_csm_sel;
        wr_tte_csm_thrid <= tlb_wr_tte_csm_thrid;
        
        end

	end

// INNO - gate cam,demap,wr with rst_tri_en.
reg rst_tri_en_lat;

 always        @ (clk)
 rst_tri_en_lat = rst_tri_en;

assign	cam_vld = cam_vld_tmp & ~rst_tri_en_lat ;
assign	demap_other = demap_other_tmp & ~rst_tri_en ;
assign	wr_vld = wr_vld_tmp & ~rst_tri_en ;

//=========================================================================================
//	Generate Write Wordlines
//=========================================================================================

// Based on static rw index	
// This generates the wordlines for a read/write to the tlb based on index. Wordlines for
// the write based on replacement alg. are muxed in later.


always	@ (/*AUTOSENSE*/rd_csm or rd_data or rd_tag or rw_index or rw_index_vld
           or wr_vld_tmp)
	begin
        if ((rw_index[4-1:0] == 0) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[0] = 1'b1;
         end
         else	
         begin
            rw_wdline[0] = 1'b0;
         end
        if ((rw_index[4-1:0] == 1) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[1] = 1'b1;
         end
         else	
         begin
            rw_wdline[1] = 1'b0;
         end
        if ((rw_index[4-1:0] == 2) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[2] = 1'b1;
         end
         else	
         begin
            rw_wdline[2] = 1'b0;
         end
        if ((rw_index[4-1:0] == 3) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[3] = 1'b1;
         end
         else	
         begin
            rw_wdline[3] = 1'b0;
         end
        if ((rw_index[4-1:0] == 4) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[4] = 1'b1;
         end
         else	
         begin
            rw_wdline[4] = 1'b0;
         end
        if ((rw_index[4-1:0] == 5) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[5] = 1'b1;
         end
         else	
         begin
            rw_wdline[5] = 1'b0;
         end
        if ((rw_index[4-1:0] == 6) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[6] = 1'b1;
         end
         else	
         begin
            rw_wdline[6] = 1'b0;
         end
        if ((rw_index[4-1:0] == 7) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[7] = 1'b1;
         end
         else	
         begin
            rw_wdline[7] = 1'b0;
         end
        if ((rw_index[4-1:0] == 8) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[8] = 1'b1;
         end
         else	
         begin
            rw_wdline[8] = 1'b0;
         end
        if ((rw_index[4-1:0] == 9) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[9] = 1'b1;
         end
         else	
         begin
            rw_wdline[9] = 1'b0;
         end
        if ((rw_index[4-1:0] == 10) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[10] = 1'b1;
         end
         else	
         begin
            rw_wdline[10] = 1'b0;
         end
        if ((rw_index[4-1:0] == 11) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[11] = 1'b1;
         end
         else	
         begin
            rw_wdline[11] = 1'b0;
         end
        if ((rw_index[4-1:0] == 12) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[12] = 1'b1;
         end
         else	
         begin
            rw_wdline[12] = 1'b0;
         end
        if ((rw_index[4-1:0] == 13) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[13] = 1'b1;
         end
         else	
         begin
            rw_wdline[13] = 1'b0;
         end
        if ((rw_index[4-1:0] == 14) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[14] = 1'b1;
         end
         else	
         begin
            rw_wdline[14] = 1'b0;
         end
        if ((rw_index[4-1:0] == 15) & ((wr_vld_tmp & rw_index_vld) | rd_tag | rd_data | rd_csm))
         begin
            rw_wdline[15] = 1'b1;
         end
         else	
         begin
            rw_wdline[15] = 1'b0;
         end

					
	end









































































































































//=========================================================================================
//	Write TLB
//=========================================================================================

reg	[58:0]	tmp_tag ;
reg	[42:0]	tmp_data ;


reg [32:0] tmp_csm;



// Currently TLB_TAG and TLB_DATA RAMs are written in the B phase. 
// Used bit is set on write in later code as it is also effected by read of tlb.
always	@ (negedge clk)
	begin
        if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[0] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[0] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[0] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[0] <= wr_tte_tag[24] ;
                        tlb_entry_locked[0] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[0]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[0];
                    tmp_csm = tte_csm_ram[0];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
					tlb_entry_used[0], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[1] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[1] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[1] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[1] <= wr_tte_tag[24] ;
                        tlb_entry_locked[1] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[1]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[1];
                    tmp_csm = tte_csm_ram[1];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
					tlb_entry_used[1], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[2] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[2] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[2] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[2] <= wr_tte_tag[24] ;
                        tlb_entry_locked[2] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[2]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[2];
                    tmp_csm = tte_csm_ram[2];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
					tlb_entry_used[2], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[3] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[3] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[3] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[3] <= wr_tte_tag[24] ;
                        tlb_entry_locked[3] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[3]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[3];
                    tmp_csm = tte_csm_ram[3];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
					tlb_entry_used[3], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[4] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[4] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[4] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[4] <= wr_tte_tag[24] ;
                        tlb_entry_locked[4] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[4]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[4];
                    tmp_csm = tte_csm_ram[4];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
					tlb_entry_used[4], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[5] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[5] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[5] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[5] <= wr_tte_tag[24] ;
                        tlb_entry_locked[5] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[5]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[5];
                    tmp_csm = tte_csm_ram[5];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
					tlb_entry_used[5], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[6] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[6] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[6] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[6] <= wr_tte_tag[24] ;
                        tlb_entry_locked[6] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[6]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[6];
                    tmp_csm = tte_csm_ram[6];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
					tlb_entry_used[6], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[7] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[7] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[7] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[7] <= wr_tte_tag[24] ;
                        tlb_entry_locked[7] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[7]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[7];
                    tmp_csm = tte_csm_ram[7];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
					tlb_entry_used[7], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[8] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[8] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[8] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[8] <= wr_tte_tag[24] ;
                        tlb_entry_locked[8] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[8]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[8];
                    tmp_csm = tte_csm_ram[8];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
					tlb_entry_used[8], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[9] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[9] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[9] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[9] <= wr_tte_tag[24] ;
                        tlb_entry_locked[9] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[9]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[9];
                    tmp_csm = tte_csm_ram[9];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
					tlb_entry_used[9], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[10] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[10] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[10] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[10] <= wr_tte_tag[24] ;
                        tlb_entry_locked[10] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[10]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[10];
                    tmp_csm = tte_csm_ram[10];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
					tlb_entry_used[10], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[11] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[11] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[11] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[11] <= wr_tte_tag[24] ;
                        tlb_entry_locked[11] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[11]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[11];
                    tmp_csm = tte_csm_ram[11];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
					tlb_entry_used[11], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[12] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[12] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[12] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[12] <= wr_tte_tag[24] ;
                        tlb_entry_locked[12] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[12]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[12];
                    tmp_csm = tte_csm_ram[12];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
					tlb_entry_used[12], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[13] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[13] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[13] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[13] <= wr_tte_tag[24] ;
                        tlb_entry_locked[13] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[13]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[13];
                    tmp_csm = tte_csm_ram[13];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
					tlb_entry_used[13], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[14] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[14] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[14] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[14] <= wr_tte_tag[24] ;
                        tlb_entry_locked[14] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[14]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[14];
                    tmp_csm = tte_csm_ram[14];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
					tlb_entry_used[14], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end
        if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & wr_vld_tmp & ~rw_disable)
		    begin
				if (~rst_tri_en)
					begin
                    if (wr_csm_sel)
                    begin
                        tte_csm_buf[wr_tte_csm_thrid] <= wr_tte_csm;
                    end
                    else
                    begin
                        tte_csm_ram[15] <= tte_csm_buf[wr_tte_csm_thrid];
                        tte_tag_ram[15] <= wr_tte_tag[58:0];	// CHANGE
                        tte_data_ram[15] <= wr_tte_data[42:0];
                        //tlb_entry_vld[j] <= wr_tte_tag[`STLB_TAG_V] ;
                        tlb_entry_used[15] <= wr_tte_tag[24] ;
                        tlb_entry_locked[15] = wr_tte_tag[25] ;
                    end
					// write-thru 
					rd_tte_tag[58:0]  <= wr_tte_tag[58:0] ;	// CHANGE 
					rd_tte_data[42:0] <=  wr_tte_data[42:0];
                    rd_tte_csm <= wr_tte_csm;
					end
				else
					begin
					tmp_tag[58:0]=tte_tag_ram[15]; // use non-blocking
					tmp_data[42:0]=tte_data_ram[15];
                    tmp_csm = tte_csm_ram[15];
					// INNO - read wins.
					rd_tte_tag[58:0] <=	
					{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
					tlb_entry_used[15], tmp_tag[23:0]}  ;
					rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
                    rd_tte_csm <= tmp_csm;
					end
			
			end

//=========================================================================================
//	Read STLB
//=========================================================================================

        if (rw_wdline[0] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[0] ;
					tmp_data = tte_data_ram[0] ;
                    tmp_csm = tte_csm_ram[0];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[0],tlb_entry_locked[0], 
						tlb_entry_used[0], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[1] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[1] ;
					tmp_data = tte_data_ram[1] ;
                    tmp_csm = tte_csm_ram[1];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[1],tlb_entry_locked[1], 
						tlb_entry_used[1], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[2] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[2] ;
					tmp_data = tte_data_ram[2] ;
                    tmp_csm = tte_csm_ram[2];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[2],tlb_entry_locked[2], 
						tlb_entry_used[2], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[3] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[3] ;
					tmp_data = tte_data_ram[3] ;
                    tmp_csm = tte_csm_ram[3];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[3],tlb_entry_locked[3], 
						tlb_entry_used[3], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[4] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[4] ;
					tmp_data = tte_data_ram[4] ;
                    tmp_csm = tte_csm_ram[4];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[4],tlb_entry_locked[4], 
						tlb_entry_used[4], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[5] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[5] ;
					tmp_data = tte_data_ram[5] ;
                    tmp_csm = tte_csm_ram[5];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[5],tlb_entry_locked[5], 
						tlb_entry_used[5], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[6] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[6] ;
					tmp_data = tte_data_ram[6] ;
                    tmp_csm = tte_csm_ram[6];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[6],tlb_entry_locked[6], 
						tlb_entry_used[6], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[7] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[7] ;
					tmp_data = tte_data_ram[7] ;
                    tmp_csm = tte_csm_ram[7];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[7],tlb_entry_locked[7], 
						tlb_entry_used[7], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[8] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[8] ;
					tmp_data = tte_data_ram[8] ;
                    tmp_csm = tte_csm_ram[8];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[8],tlb_entry_locked[8], 
						tlb_entry_used[8], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[9] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[9] ;
					tmp_data = tte_data_ram[9] ;
                    tmp_csm = tte_csm_ram[9];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[9],tlb_entry_locked[9], 
						tlb_entry_used[9], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[10] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[10] ;
					tmp_data = tte_data_ram[10] ;
                    tmp_csm = tte_csm_ram[10];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[10],tlb_entry_locked[10], 
						tlb_entry_used[10], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[11] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[11] ;
					tmp_data = tte_data_ram[11] ;
                    tmp_csm = tte_csm_ram[11];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[11],tlb_entry_locked[11], 
						tlb_entry_used[11], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[12] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[12] ;
					tmp_data = tte_data_ram[12] ;
                    tmp_csm = tte_csm_ram[12];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[12],tlb_entry_locked[12], 
						tlb_entry_used[12], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[13] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[13] ;
					tmp_data = tte_data_ram[13] ;
                    tmp_csm = tte_csm_ram[13];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[13],tlb_entry_locked[13], 
						tlb_entry_used[13], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[14] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[14] ;
					tmp_data = tte_data_ram[14] ;
                    tmp_csm = tte_csm_ram[14];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[14],tlb_entry_locked[14], 
						tlb_entry_used[14], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end
        if (rw_wdline[15] & (rd_tag | rd_data | rd_csm) & ~rw_disable)
				begin
					tmp_tag  = tte_tag_ram[15] ;
					tmp_data = tte_data_ram[15] ;
                    tmp_csm = tte_csm_ram[15];
					if (rd_tag)
						rd_tte_tag[58:0] <=	// CHANGE - Bug 2185
						{tmp_tag[58:27], tlb_entry_vld[15],tlb_entry_locked[15], 
						tlb_entry_used[15], tmp_tag[23:0]}  ;
					if (rd_data) begin
						rd_tte_data[42:0] <= {tmp_data[42:12],tmp_data[11:0]} ;
					end
					if (rd_csm) begin
						rd_tte_csm <= tmp_csm ;
					end

				end

		if (cam_vld & ~rw_disable)
  		begin
    			//Checking for no hit and multiple hits
    			sat = {16{1'b0}};
             begin
      				if(cam_hit[0])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[1])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[2])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[3])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[4])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[5])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[6])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[7])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[8])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[9])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[10])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[11])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[12])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[13])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[14])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end
             begin
      				if(cam_hit[15])
      				begin
        				sat = sat + {{(16-1){1'b0}}, 1'b1};
      				end
    			end

			// Only one hit occur read the data
    			if(sat == {{(16-1){1'b0}}, 1'b1})
    			begin
                   begin
                    if (cam_hit[0])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[0] ;
                            rd_tte_csm <= tte_csm_ram[0] ;
                    end
				end
                   begin
                    if (cam_hit[1])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[1] ;
                            rd_tte_csm <= tte_csm_ram[1] ;
                    end
				end
                   begin
                    if (cam_hit[2])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[2] ;
                            rd_tte_csm <= tte_csm_ram[2] ;
                    end
				end
                   begin
                    if (cam_hit[3])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[3] ;
                            rd_tte_csm <= tte_csm_ram[3] ;
                    end
				end
                   begin
                    if (cam_hit[4])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[4] ;
                            rd_tte_csm <= tte_csm_ram[4] ;
                    end
				end
                   begin
                    if (cam_hit[5])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[5] ;
                            rd_tte_csm <= tte_csm_ram[5] ;
                    end
				end
                   begin
                    if (cam_hit[6])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[6] ;
                            rd_tte_csm <= tte_csm_ram[6] ;
                    end
				end
                   begin
                    if (cam_hit[7])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[7] ;
                            rd_tte_csm <= tte_csm_ram[7] ;
                    end
				end
                   begin
                    if (cam_hit[8])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[8] ;
                            rd_tte_csm <= tte_csm_ram[8] ;
                    end
				end
                   begin
                    if (cam_hit[9])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[9] ;
                            rd_tte_csm <= tte_csm_ram[9] ;
                    end
				end
                   begin
                    if (cam_hit[10])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[10] ;
                            rd_tte_csm <= tte_csm_ram[10] ;
                    end
				end
                   begin
                    if (cam_hit[11])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[11] ;
                            rd_tte_csm <= tte_csm_ram[11] ;
                    end
				end
                   begin
                    if (cam_hit[12])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[12] ;
                            rd_tte_csm <= tte_csm_ram[12] ;
                    end
				end
                   begin
                    if (cam_hit[13])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[13] ;
                            rd_tte_csm <= tte_csm_ram[13] ;
                    end
				end
                   begin
                    if (cam_hit[14])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[14] ;
                            rd_tte_csm <= tte_csm_ram[14] ;
                    end
				end
                   begin
                    if (cam_hit[15])
                    begin
                            rd_tte_data[42:0] <= tte_data_ram[15] ;
                            rd_tte_csm <= tte_csm_ram[15] ;
                    end
				end

			end
			else
			begin
				// INNO - just to keep the tool happy.
				// ram cell will not be corrupted.
               begin
					if (cam_hit[0])
                    begin
                        		tte_data_ram[0] <= 43'bx ;
                        		tte_csm_ram[0] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[1])
                    begin
                        		tte_data_ram[1] <= 43'bx ;
                        		tte_csm_ram[1] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[2])
                    begin
                        		tte_data_ram[2] <= 43'bx ;
                        		tte_csm_ram[2] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[3])
                    begin
                        		tte_data_ram[3] <= 43'bx ;
                        		tte_csm_ram[3] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[4])
                    begin
                        		tte_data_ram[4] <= 43'bx ;
                        		tte_csm_ram[4] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[5])
                    begin
                        		tte_data_ram[5] <= 43'bx ;
                        		tte_csm_ram[5] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[6])
                    begin
                        		tte_data_ram[6] <= 43'bx ;
                        		tte_csm_ram[6] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[7])
                    begin
                        		tte_data_ram[7] <= 43'bx ;
                        		tte_csm_ram[7] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[8])
                    begin
                        		tte_data_ram[8] <= 43'bx ;
                        		tte_csm_ram[8] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[9])
                    begin
                        		tte_data_ram[9] <= 43'bx ;
                        		tte_csm_ram[9] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[10])
                    begin
                        		tte_data_ram[10] <= 43'bx ;
                        		tte_csm_ram[10] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[11])
                    begin
                        		tte_data_ram[11] <= 43'bx ;
                        		tte_csm_ram[11] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[12])
                    begin
                        		tte_data_ram[12] <= 43'bx ;
                        		tte_csm_ram[12] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[13])
                    begin
                        		tte_data_ram[13] <= 43'bx ;
                        		tte_csm_ram[13] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[14])
                    begin
                        		tte_data_ram[14] <= 43'bx ;
                        		tte_csm_ram[14] <= {33{1'bx}} ;
                    end
				end
               begin
					if (cam_hit[15])
                    begin
                        		tte_data_ram[15] <= 43'bx ;
                        		tte_csm_ram[15] <= {33{1'bx}} ;
                    end
				end

                rd_tte_data[42:0] <= 43'bx ;
                rd_tte_csm <= {33{1'bx}};
			end
		end

                   begin
                                if (cam_hit[0])
                                        tlb_entry_used[0] <= 1'b1;
                        end
                   begin
                                if (cam_hit[1])
                                        tlb_entry_used[1] <= 1'b1;
                        end
                   begin
                                if (cam_hit[2])
                                        tlb_entry_used[2] <= 1'b1;
                        end
                   begin
                                if (cam_hit[3])
                                        tlb_entry_used[3] <= 1'b1;
                        end
                   begin
                                if (cam_hit[4])
                                        tlb_entry_used[4] <= 1'b1;
                        end
                   begin
                                if (cam_hit[5])
                                        tlb_entry_used[5] <= 1'b1;
                        end
                   begin
                                if (cam_hit[6])
                                        tlb_entry_used[6] <= 1'b1;
                        end
                   begin
                                if (cam_hit[7])
                                        tlb_entry_used[7] <= 1'b1;
                        end
                   begin
                                if (cam_hit[8])
                                        tlb_entry_used[8] <= 1'b1;
                        end
                   begin
                                if (cam_hit[9])
                                        tlb_entry_used[9] <= 1'b1;
                        end
                   begin
                                if (cam_hit[10])
                                        tlb_entry_used[10] <= 1'b1;
                        end
                   begin
                                if (cam_hit[11])
                                        tlb_entry_used[11] <= 1'b1;
                        end
                   begin
                                if (cam_hit[12])
                                        tlb_entry_used[12] <= 1'b1;
                        end
                   begin
                                if (cam_hit[13])
                                        tlb_entry_used[13] <= 1'b1;
                        end
                   begin
                                if (cam_hit[14])
                                        tlb_entry_used[14] <= 1'b1;
                        end
                   begin
                                if (cam_hit[15])
                                        tlb_entry_used[15] <= 1'b1;
                        end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

                //if (tlb_not_writeable)
                if (~tlb_writeable & ~cam_vld & ~wr_vld & ~rd_tag & ~rst_tri_en)
                        begin
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[0] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[0] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[1] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[1] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[2] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[2] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[3] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[3] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[4] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[4] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[5] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[5] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[6] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[6] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[7] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[7] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[8] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[8] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[9] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[9] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[10] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[10] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[11] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[11] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[12] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[12] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[13] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[13] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[14] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[14] <= 1'b0;
                                        end
                           begin
                                                //if (~tlb_entry_locked[t])
                                                if (~tlb_entry_locked[15] & ~cam_vld & ~wr_vld)
                                                        tlb_entry_used[15] <= 1'b0;
                                        end

                        end
	end


always	@ *
begin
    case (cfg_csm_tlb_state)
    2'd0:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                               cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
        end
    end
    2'd1:
    begin
        if (~bypass)
        begin
            rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
        end
        else
        begin
            rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                               cfg_csm_tlb_y};
        end
    end
    2'd2:
    begin
        rd_tte_csm_real = {1'b0, cfg_csm_tlb_hdid, cfg_csm_tlb_hd_size,
                           cfg_csm_tlb_sdid, cfg_csm_tlb_lsid};
    end
    2'd3:
    begin
        rd_tte_csm_real = {1'b1, 2'b0, cfg_csm_tlb_chipid, cfg_csm_tlb_x,
                           cfg_csm_tlb_y};
    end
    default:
    begin
        rd_tte_csm_real = {1'b0, rd_tte_csm[31:0]};
    end
    endcase
end

// Stage to next cycle.
always	@ (posedge clk)
	begin
		tlb_rd_tte_tag[58:0] 	<= rd_tte_tag[58:0] ;	// CHANGE
		tlb_rd_tte_data[42:0] 	<= rd_tte_data[42:0] ;
		tlb_rd_tte_csm 	<= rd_tte_csm_real ;
	end
assign tlb_rd_tte_csm_crit = rd_tte_csm_real;





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//=========================================================================================
//	CAM/DEMAP STLB for xlation
//=========================================================================================

//  no_hit logic does not work because it is set in multiple clock
//  domains and is reset before ever having a chance to be effective
//reg	no_hit ;


// Demap and CAM operation are mutually exclusive.

always  @ ( negedge clk )
	begin
	
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
                                //end
			end
           begin
                        /*if (demap_all)  begin
                                if (demap_auto & demap_other) ademap_hit[n]   =
                                        (~mismatch[n] & demap_all_but_locked_hit[n] & demap_other
                                                & tlb_entry_vld[n]) ;
                                end
                        else    begin */
                                if (demap_auto & demap_other) ademap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
                                //end
			end

	end  // always

always	@ (/*AUTOSENSE*/ /*memory or*/ 
           cam_data or cam_pid or cam_vld or demap_all
           or demap_other or tlb_entry_vld)
	begin
	
		    	begin
			tag[58:0] = tte_tag_ram[0] ;	// CHANGE

			mismatch_va_b47_28[0] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[0] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[0] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[0] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[0] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[0] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[0] =
			(mismatch_va_b47_28[0] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[0] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[0] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[0] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[0] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[0] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[0] = 
			~tag[25] & demap_all ;

			cam_hit[0] 	= 
				~mismatch[0] & cam_vld   & tlb_entry_vld[0] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_all_but_locked_hit[0] & demap_other
                                                & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[0]    =
                                        (~mismatch[0] & demap_other & tlb_entry_vld[0]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[1] ;	// CHANGE

			mismatch_va_b47_28[1] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[1] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[1] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[1] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[1] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[1] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[1] =
			(mismatch_va_b47_28[1] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[1] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[1] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[1] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[1] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[1] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[1] = 
			~tag[25] & demap_all ;

			cam_hit[1] 	= 
				~mismatch[1] & cam_vld   & tlb_entry_vld[1] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_all_but_locked_hit[1] & demap_other
                                                & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[1]    =
                                        (~mismatch[1] & demap_other & tlb_entry_vld[1]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[2] ;	// CHANGE

			mismatch_va_b47_28[2] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[2] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[2] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[2] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[2] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[2] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[2] =
			(mismatch_va_b47_28[2] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[2] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[2] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[2] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[2] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[2] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[2] = 
			~tag[25] & demap_all ;

			cam_hit[2] 	= 
				~mismatch[2] & cam_vld   & tlb_entry_vld[2] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_all_but_locked_hit[2] & demap_other
                                                & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[2]    =
                                        (~mismatch[2] & demap_other & tlb_entry_vld[2]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[3] ;	// CHANGE

			mismatch_va_b47_28[3] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[3] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[3] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[3] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[3] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[3] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[3] =
			(mismatch_va_b47_28[3] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[3] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[3] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[3] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[3] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[3] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[3] = 
			~tag[25] & demap_all ;

			cam_hit[3] 	= 
				~mismatch[3] & cam_vld   & tlb_entry_vld[3] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_all_but_locked_hit[3] & demap_other
                                                & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[3]    =
                                        (~mismatch[3] & demap_other & tlb_entry_vld[3]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[4] ;	// CHANGE

			mismatch_va_b47_28[4] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[4] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[4] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[4] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[4] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[4] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[4] =
			(mismatch_va_b47_28[4] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[4] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[4] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[4] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[4] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[4] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[4] = 
			~tag[25] & demap_all ;

			cam_hit[4] 	= 
				~mismatch[4] & cam_vld   & tlb_entry_vld[4] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_all_but_locked_hit[4] & demap_other
                                                & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[4]    =
                                        (~mismatch[4] & demap_other & tlb_entry_vld[4]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[5] ;	// CHANGE

			mismatch_va_b47_28[5] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[5] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[5] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[5] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[5] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[5] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[5] =
			(mismatch_va_b47_28[5] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[5] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[5] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[5] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[5] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[5] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[5] = 
			~tag[25] & demap_all ;

			cam_hit[5] 	= 
				~mismatch[5] & cam_vld   & tlb_entry_vld[5] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_all_but_locked_hit[5] & demap_other
                                                & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[5]    =
                                        (~mismatch[5] & demap_other & tlb_entry_vld[5]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[6] ;	// CHANGE

			mismatch_va_b47_28[6] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[6] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[6] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[6] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[6] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[6] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[6] =
			(mismatch_va_b47_28[6] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[6] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[6] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[6] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[6] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[6] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[6] = 
			~tag[25] & demap_all ;

			cam_hit[6] 	= 
				~mismatch[6] & cam_vld   & tlb_entry_vld[6] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_all_but_locked_hit[6] & demap_other
                                                & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[6]    =
                                        (~mismatch[6] & demap_other & tlb_entry_vld[6]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[7] ;	// CHANGE

			mismatch_va_b47_28[7] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[7] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[7] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[7] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[7] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[7] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[7] =
			(mismatch_va_b47_28[7] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[7] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[7] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[7] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[7] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[7] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[7] = 
			~tag[25] & demap_all ;

			cam_hit[7] 	= 
				~mismatch[7] & cam_vld   & tlb_entry_vld[7] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_all_but_locked_hit[7] & demap_other
                                                & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[7]    =
                                        (~mismatch[7] & demap_other & tlb_entry_vld[7]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[8] ;	// CHANGE

			mismatch_va_b47_28[8] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[8] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[8] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[8] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[8] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[8] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[8] =
			(mismatch_va_b47_28[8] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[8] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[8] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[8] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[8] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[8] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[8] = 
			~tag[25] & demap_all ;

			cam_hit[8] 	= 
				~mismatch[8] & cam_vld   & tlb_entry_vld[8] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_all_but_locked_hit[8] & demap_other
                                                & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[8]    =
                                        (~mismatch[8] & demap_other & tlb_entry_vld[8]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[9] ;	// CHANGE

			mismatch_va_b47_28[9] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[9] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[9] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[9] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[9] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[9] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[9] =
			(mismatch_va_b47_28[9] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[9] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[9] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[9] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[9] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[9] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[9] = 
			~tag[25] & demap_all ;

			cam_hit[9] 	= 
				~mismatch[9] & cam_vld   & tlb_entry_vld[9] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_all_but_locked_hit[9] & demap_other
                                                & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[9]    =
                                        (~mismatch[9] & demap_other & tlb_entry_vld[9]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[10] ;	// CHANGE

			mismatch_va_b47_28[10] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[10] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[10] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[10] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[10] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[10] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[10] =
			(mismatch_va_b47_28[10] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[10] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[10] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[10] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[10] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[10] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[10] = 
			~tag[25] & demap_all ;

			cam_hit[10] 	= 
				~mismatch[10] & cam_vld   & tlb_entry_vld[10] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_all_but_locked_hit[10] & demap_other
                                                & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[10]    =
                                        (~mismatch[10] & demap_other & tlb_entry_vld[10]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[11] ;	// CHANGE

			mismatch_va_b47_28[11] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[11] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[11] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[11] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[11] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[11] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[11] =
			(mismatch_va_b47_28[11] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[11] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[11] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[11] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[11] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[11] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[11] = 
			~tag[25] & demap_all ;

			cam_hit[11] 	= 
				~mismatch[11] & cam_vld   & tlb_entry_vld[11] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_all_but_locked_hit[11] & demap_other
                                                & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[11]    =
                                        (~mismatch[11] & demap_other & tlb_entry_vld[11]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[12] ;	// CHANGE

			mismatch_va_b47_28[12] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[12] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[12] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[12] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[12] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[12] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[12] =
			(mismatch_va_b47_28[12] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[12] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[12] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[12] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[12] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[12] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[12] = 
			~tag[25] & demap_all ;

			cam_hit[12] 	= 
				~mismatch[12] & cam_vld   & tlb_entry_vld[12] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_all_but_locked_hit[12] & demap_other
                                                & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[12]    =
                                        (~mismatch[12] & demap_other & tlb_entry_vld[12]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[13] ;	// CHANGE

			mismatch_va_b47_28[13] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[13] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[13] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[13] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[13] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[13] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[13] =
			(mismatch_va_b47_28[13] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[13] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[13] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[13] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[13] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[13] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[13] = 
			~tag[25] & demap_all ;

			cam_hit[13] 	= 
				~mismatch[13] & cam_vld   & tlb_entry_vld[13] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_all_but_locked_hit[13] & demap_other
                                                & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[13]    =
                                        (~mismatch[13] & demap_other & tlb_entry_vld[13]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[14] ;	// CHANGE

			mismatch_va_b47_28[14] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[14] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[14] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[14] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[14] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[14] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[14] =
			(mismatch_va_b47_28[14] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[14] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[14] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[14] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[14] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[14] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[14] = 
			~tag[25] & demap_all ;

			cam_hit[14] 	= 
				~mismatch[14] & cam_vld   & tlb_entry_vld[14] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_all_but_locked_hit[14] & demap_other
                                                & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[14]    =
                                        (~mismatch[14] & demap_other & tlb_entry_vld[14]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end
		    	begin
			tag[58:0] = tte_tag_ram[15] ;	// CHANGE

			mismatch_va_b47_28[15] = 
			(tag[53:34] 
			!= cam_data[40+13:21+13]);

			mismatch_va_b27_22[15] = 
			(tag[33:28] 
			!= cam_data[19+13:14+13]);

			mismatch_va_b21_16[15] = 
			(tag[23:18]
			!= cam_data[12+13:7+13]) ;

			mismatch_va_b15_13[15] = 
			(tag[16:14]
			!= cam_data[5+13:3+13]) ;

			mismatch_ctxt[15] = 
			(tag[12:0] 
			!= cam_data[12:0]) ;
			
			mismatch_pid[15] = (tag[58:56] != cam_pid[2:0]) ;

			mismatch[15] =
			(mismatch_va_b47_28[15] & cam_data[20+13]) 				|
			(mismatch_va_b27_22[15] & tag[27] & cam_data[13+13]) 	|
			(mismatch_va_b21_16[15] & tag[17] & cam_data[6+13]) 	|
			(mismatch_va_b15_13[15] & tag[13] & cam_data[2+13]) 	|
			(mismatch_ctxt[15] & ~cam_data[1+13])	|
			// mismatch is request type not equal to entry type. types are real/virtual.
			((tag[55] ^ cam_data[0+13]) & ~demap_all)  	| 
			mismatch_pid[15] ;	// pid always included in mismatch calculations

			demap_all_but_locked_hit[15] = 
			~tag[25] & demap_all ;

			cam_hit[15] 	= 
				~mismatch[15] & cam_vld   & tlb_entry_vld[15] ;

                        if (demap_all)  begin
                                // Satya(10/3) - I've simplified the demap-all equation
                                // Pls confirm that this is okay. Otherwise we will nee
                                // qualifying bits for the pid and r fields.
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_all_but_locked_hit[15] & demap_other
                                                & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-we could get rid of this.
                                end
                        else    begin
                                demap_hit[15]    =
                                        (~mismatch[15] & demap_other & tlb_entry_vld[15]) ;
				// qualification with demap_auto to prevent ademap_hit from
				// being cleared. Satya-this is the only one we need.
                                end
//			no_hit = cam_vld ;
			end

	end  // always

assign	tlb_cam_hit = |cam_hit[16-1:0] ;

// Read on CAM hit occurs on negedge.
/* MOVED TO COMMON ALWAYS BLOCK
always @ (negedge clk)
	begin
		if (|cam_hit[63:0])	
			begin
			for (p=0;p<64;p=p+1)
				if (cam_hit[p])	
				begin
					rd_tte_data[42:0] <= tte_data_ram[p] ;
				end
//				no_hit = 1'b0 ;
			end
//		else	if (no_hit) begin
//			rd_tte_data[42:0] <= {43{1'bx}};
//			no_hit = 1'b0 ;
//			end
	end
*/
// Change tlb_entry_vld handling for multi-threaded tlb writes.
// A write is always preceeded by an autodemap. The intent is to make the result of autodemap
// (clearing of vld bit if hit) invisible until write occurs. In the same cycle that the write
// occurs, the vld bit for an entry will be cleared if there is an autodemap hit. The write
// and admp action may even be to same entry. The write must dominate. There is no need to
// clear the dmp latches after the write/clear has occurred as the subsequent admp will set
// up new state in the latches.

// Define valid bit based on write/demap/reset.

 



always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[0] <= 1'b0 ;
        end
        else if ((demap_hit[0] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[0] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[0]) | (~rw_index_vld & tlb_entry_replace_d2[0])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[0] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[0] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[0] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[1] <= 1'b0 ;
        end
        else if ((demap_hit[1] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[1] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[1]) | (~rw_index_vld & tlb_entry_replace_d2[1])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[1] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[1] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[1] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[2] <= 1'b0 ;
        end
        else if ((demap_hit[2] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[2] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[2]) | (~rw_index_vld & tlb_entry_replace_d2[2])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[2] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[2] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[2] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[3] <= 1'b0 ;
        end
        else if ((demap_hit[3] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[3] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[3]) | (~rw_index_vld & tlb_entry_replace_d2[3])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[3] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[3] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[3] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[4] <= 1'b0 ;
        end
        else if ((demap_hit[4] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[4] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[4]) | (~rw_index_vld & tlb_entry_replace_d2[4])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[4] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[4] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[4] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[5] <= 1'b0 ;
        end
        else if ((demap_hit[5] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[5] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[5]) | (~rw_index_vld & tlb_entry_replace_d2[5])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[5] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[5] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[5] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[6] <= 1'b0 ;
        end
        else if ((demap_hit[6] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[6] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[6]) | (~rw_index_vld & tlb_entry_replace_d2[6])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[6] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[6] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[6] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[7] <= 1'b0 ;
        end
        else if ((demap_hit[7] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[7] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[7]) | (~rw_index_vld & tlb_entry_replace_d2[7])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[7] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[7] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[7] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[8] <= 1'b0 ;
        end
        else if ((demap_hit[8] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[8] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[8]) | (~rw_index_vld & tlb_entry_replace_d2[8])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[8] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[8] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[8] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[9] <= 1'b0 ;
        end
        else if ((demap_hit[9] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[9] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[9]) | (~rw_index_vld & tlb_entry_replace_d2[9])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[9] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[9] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[9] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[10] <= 1'b0 ;
        end
        else if ((demap_hit[10] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[10] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[10]) | (~rw_index_vld & tlb_entry_replace_d2[10])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[10] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[10] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[10] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[11] <= 1'b0 ;
        end
        else if ((demap_hit[11] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[11] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[11]) | (~rw_index_vld & tlb_entry_replace_d2[11])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[11] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[11] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[11] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[12] <= 1'b0 ;
        end
        else if ((demap_hit[12] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[12] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[12]) | (~rw_index_vld & tlb_entry_replace_d2[12])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[12] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[12] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[12] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[13] <= 1'b0 ;
        end
        else if ((demap_hit[13] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[13] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[13]) | (~rw_index_vld & tlb_entry_replace_d2[13])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[13] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[13] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[13] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[14] <= 1'b0 ;
        end
        else if ((demap_hit[14] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[14] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[14]) | (~rw_index_vld & tlb_entry_replace_d2[14])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[14] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[14] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[14] <= 1'b0 ;		
            end
	end
    

always @ (negedge clk)
	begin
        if (async_reset)
        begin
            tlb_entry_vld[15] <= 1'b0 ;
        end
        else if ((demap_hit[15] & ~demap_auto) | sync_reset)   // non-auto-demap, reset
            tlb_entry_vld[15] <= 1'b0 ; 
        else if (((rw_index_vld & rw_wdline[15]) | (~rw_index_vld & tlb_entry_replace_d2[15])) & 
            wr_vld & ~ wr_csm_sel & ~rw_disable)
                tlb_entry_vld[15] <= wr_tte_tag[26] ;	// write
        else	begin
            if (ademap_hit[15] & wr_vld & ~wr_csm_sel)			// autodemap specifically
                tlb_entry_vld[15] <= 1'b0 ;		
            end
	end
    





































































































































































































































































































// async reset.
//always  @ (async_reset) 
//	begin
//	for (l=0;l<64;l=l+1)
//		begin
//	  	tlb_entry_vld[l] <= 1'b0 ;
//		end
//	end

//=========================================================================================
//	TAG COMPARISON
//=========================================================================================

reg [30:0] va_tag_plus ;

// Stage to m
always @(posedge clk)
		begin
		// INNO - add hold to this input
		if (hold)
			va_tag_plus[30:0] <= va_tag_plus[30:0] ;
		else
			va_tag_plus[30:0] 
			<= {tlb_cam_comp_key[26:0],tlb_bypass_va[12:10],tlb_bypass}; 
		end
			
assign vrtl_pgnum_m[29:0] = va_tag_plus[30:1] ;
assign bypass = va_tag_plus[0] ;

// Mux to bypass va or form pa tag based on tte-data.

assign	phy_pgnum_m[29:3] = 
	{rd_tte_data[41:30],
		rd_tte_data[29:24],
			rd_tte_data[22:17],
				rd_tte_data[15:13]};

// Derive the tlb-based physical address.
assign pgnum_m[2:0] = vrtl_pgnum_m[2:0];
assign pgnum_m[5:3] = (~rd_tte_data[12] & ~bypass)
				? phy_pgnum_m[5:3] : vrtl_pgnum_m[5:3] ;
assign pgnum_m[11:6] = (~rd_tte_data[16] & ~bypass)  
				? phy_pgnum_m[11:6] : vrtl_pgnum_m[11:6] ;
assign pgnum_m[17:12] = (~rd_tte_data[23] & ~bypass)
				? phy_pgnum_m[17:12] : vrtl_pgnum_m[17:12] ;
assign pgnum_m[29:18] = ~bypass ? phy_pgnum_m[29:18] : vrtl_pgnum_m[29:18];

// Stage to g
// Flop tags in tlb itself and do comparison immediately after rising edge.
// Similarly stage va/pa tag to g
always @(posedge clk)
		begin
			pgnum_g[29:0] <= pgnum_m[29:0];
			// rm hold on these inputs.
			cache_set_vld_g[2-1:0]  	<= cache_set_vld[2-1:0] ;
			cache_ptag_g[((((39 - (6 + 5))+1) * 2)-1):0] 	<= cache_ptag[((((39 - (6 + 5))+1) * 2)-1):0] ;
		end


// Need to stage by a cycle where used.
assign	tlb_pgnum[39:10] = pgnum_g[29:0] ;
// Same cycle as cam - meant for one load on critical path
assign	tlb_pgnum_crit[39:10] = pgnum_m[29:0] ;


   assign   cache_way_hit[0] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*1-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[0];


   assign   cache_way_hit[1] = 
      (cache_ptag_g[((39 - (6 + 5))+1)*2-2 -: (39 - (6 + 5))] == pgnum_g[29 -: (39 - (6 + 5))]) & cache_set_vld_g[1];



assign	cache_hit = |cache_way_hit[2-1:0];


//=========================================================================================
//	TLB ENTRY REPLACEMENT
//=========================================================================================

// A single Used bit is used to track the replacement state of each entry.
// Only an unused entry can be replaced.
// An Unused entry is :
//			- an invalid entry
//			- a valid entry which has had its Used bit cleared.
//				- on write of a valid entry, the Used bit is set.
//				- The Used bit of a valid entry is cleared if all
//				entries have their Used bits set and the entry itself is not Locked.
// A locked entry should always appear to be Used.
// A single priority-encoder is required to evaluate the used status. Priority is static
// and used entry0 is of the highest priority if unused.

// Timing :
// Used bit gets updated by cam-hit or hit on negedge.
// After Used bit gets updated off negedge, the replacement entry can be generated in
// Phase2. In parallel, it is determined whether all Used bits are set or not. If
// so, then they are cleared on the next negedge with the replacement entry generated
// in the related Phase1 

// Choosing replacement entry
// Replacement entry is integer k

assign	tlb_not_writeable = &used[16-1:0] ;
/*
// Used bit can be set because of write or because of cam-hit.
always @(negedge clk)
	begin
		for (s=0;s<64;s=s+1)
			begin
				if (cam_hit[s]) 
					tlb_entry_used[s] <= 1'b1;			
			end

// Clear on following edge if necessary.
// CHANGE(SATYA) : tlb_entry_used qualified with valid needs to be used to determine
// whether the Used bits are to be cleared. This allows invalid entries created
// by a demap to be used for replacement. Else we will ignore these entries
// for replacement

		if (tlb_not_writeable)
			begin
				for (t=0;t<64;t=t+1)
					begin
						if (~tlb_entry_locked[t])
							tlb_entry_used[t] <= 1'b0;
					end
			end
	end
*/

// Determine whether entry should be squashed.

assign	used[16-1:0] = tlb_entry_used[16-1:0] & tlb_entry_vld[16-1:0] ;

/*assign squash[0] = 1'b0 ;
assign squash[1] = ~used[0] ;
assign squash[2] = |(~used[1:0]) ;
assign squash[3] = |(~used[2:0]) ;
assign squash[4] = |(~used[3:0]) ;
assign squash[5] = |(~used[4:0]) ;
assign squash[6] = |(~used[5:0]) ;
assign squash[7] = |(~used[6:0]) ;
assign squash[8] = |(~used[7:0]) ;
assign squash[9] = |(~used[8:0]) ;
assign squash[10] = |(~used[9:0]) ;
assign squash[11] = |(~used[10:0]) ;
assign squash[12] = |(~used[11:0]) ;
assign squash[13] = |(~used[12:0]) ;
assign squash[14] = |(~used[13:0]) ;
assign squash[15] = |(~used[14:0]) ;
assign squash[16] = |(~used[15:0]) ;
assign squash[17] = |(~used[16:0]) ;
assign squash[18] = |(~used[17:0]) ;
assign squash[19] = |(~used[18:0]) ;
assign squash[20] = |(~used[19:0]) ;
assign squash[21] = |(~used[20:0]) ;
assign squash[22] = |(~used[21:0]) ;
assign squash[23] = |(~used[22:0]) ;
assign squash[24] = |(~used[23:0]) ;
assign squash[25] = |(~used[24:0]) ;
assign squash[26] = |(~used[25:0]) ;
assign squash[27] = |(~used[26:0]) ;
assign squash[28] = |(~used[27:0]) ;
assign squash[29] = |(~used[28:0]) ;
assign squash[30] = |(~used[29:0]) ;
assign squash[31] = |(~used[30:0]) ;
assign squash[32] = |(~used[31:0]) ;
assign squash[33] = |(~used[32:0]) ;
assign squash[34] = |(~used[33:0]) ;
assign squash[35] = |(~used[34:0]) ;
assign squash[36] = |(~used[35:0]) ;
assign squash[37] = |(~used[36:0]) ;
assign squash[38] = |(~used[37:0]) ;
assign squash[39] = |(~used[38:0]) ;
assign squash[40] = |(~used[39:0]) ;
assign squash[41] = |(~used[40:0]) ;
assign squash[42] = |(~used[41:0]) ;
assign squash[43] = |(~used[42:0]) ;
assign squash[44] = |(~used[43:0]) ;
assign squash[45] = |(~used[44:0]) ;
assign squash[46] = |(~used[45:0]) ;
assign squash[47] = |(~used[46:0]) ;
assign squash[48] = |(~used[47:0]) ;
assign squash[49] = |(~used[48:0]) ;
assign squash[50] = |(~used[49:0]) ;
assign squash[51] = |(~used[50:0]) ;
assign squash[52] = |(~used[51:0]) ;
assign squash[53] = |(~used[52:0]) ;
assign squash[54] = |(~used[53:0]) ;
assign squash[55] = |(~used[54:0]) ;
assign squash[56] = |(~used[55:0]) ;
assign squash[57] = |(~used[56:0]) ;
assign squash[58] = |(~used[57:0]) ;
assign squash[59] = |(~used[58:0]) ;
assign squash[60] = |(~used[59:0]) ;
assign squash[61] = |(~used[60:0]) ;
assign squash[62] = |(~used[61:0]) ;
assign squash[63] = |(~used[62:0]) ; */

// Based on updated Used state, generate replacement entry.
// So, replacement entries can be generated on a cycle-by-cycle basis. 
//always @(/*AUTOSENSE*/squash or used)

	reg	[16-1:0]	tlb_entry_replace_d1;
	always @ *
	begin
  	  tlb_entry_replace_d1 = {16{1'b0}};
  	  // Priority is given to entry0

                if(~used[0])
                begin
                  tlb_entry_replace_d1[0] = ~used[0] ;
                end
         

                else if(~used[1])
                begin
                  tlb_entry_replace_d1[1] = ~used[1] ;
                end
         

                else if(~used[2])
                begin
                  tlb_entry_replace_d1[2] = ~used[2] ;
                end
         

                else if(~used[3])
                begin
                  tlb_entry_replace_d1[3] = ~used[3] ;
                end
         

                else if(~used[4])
                begin
                  tlb_entry_replace_d1[4] = ~used[4] ;
                end
         

                else if(~used[5])
                begin
                  tlb_entry_replace_d1[5] = ~used[5] ;
                end
         

                else if(~used[6])
                begin
                  tlb_entry_replace_d1[6] = ~used[6] ;
                end
         

                else if(~used[7])
                begin
                  tlb_entry_replace_d1[7] = ~used[7] ;
                end
         

                else if(~used[8])
                begin
                  tlb_entry_replace_d1[8] = ~used[8] ;
                end
         

                else if(~used[9])
                begin
                  tlb_entry_replace_d1[9] = ~used[9] ;
                end
         

                else if(~used[10])
                begin
                  tlb_entry_replace_d1[10] = ~used[10] ;
                end
         

                else if(~used[11])
                begin
                  tlb_entry_replace_d1[11] = ~used[11] ;
                end
         

                else if(~used[12])
                begin
                  tlb_entry_replace_d1[12] = ~used[12] ;
                end
         

                else if(~used[13])
                begin
                  tlb_entry_replace_d1[13] = ~used[13] ;
                end
         

                else if(~used[14])
                begin
                  tlb_entry_replace_d1[14] = ~used[14] ;
                end
         

                else if(~used[15])
                begin
                  tlb_entry_replace_d1[15] = ~used[15] ;
                end
         

  	  else
      begin
      	     tlb_entry_replace_d1[16-1] = 1'b1;
 	  end
	end
	always @(posedge clk)
	begin
	  // named in this manner to keep arch model happy.
  	  tlb_entry_replace <= tlb_entry_replace_d1 ;
	end
	// INNO - 2 stage delay before update is visible
	always @(posedge clk)
	begin
  	  tlb_entry_replace_d2 <= tlb_entry_replace ;
	end

//=========================================================================================
//	TLB WRITEABLE DETECTION
//=========================================================================================

// 2-cycles later, tlb become writeable
always @(posedge clk)
	begin
		tlb_not_writeable_d1 <= tlb_not_writeable ;
	end

always @(posedge clk)
	begin
		tlb_writeable <= ~tlb_not_writeable_d1 ;
	end

endmodule



// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
 *  Description:
 *      This module encapsulates different Execution Drafting synchronization methods
 *      into one module and multiplexes between them based on configuration bits.  It
 *      also supplies more succinct inputs to the synchronization methods derived from
 *      signals from the IFU and derives the correct outputs to go to the IFU.
 *
 *  Note: While the interface to this module supports 4 threads, the logic only supports 2
 */

module sparc_ifu_esl
(
    input               clk,
    input               rst_n,

    // Configuration bits input
    input               config_esl_en,
    input [1:0]         config_esl_sync_method,

    // LFSR management signals for RTSM
    input [15:0]        config_esl_lfsr_seed,
    input               config_esl_lfsr_ld,

    // Threshold configuration signal for PC difference
    input [49:0]        config_esl_pc_diff_thresh,

    // Counter timeout configuration value
    input [15:0]        config_esl_counter_timeout,

    // Active threads from thread FSMs
    input [3:0]         swl_esl_thr_active,

    // Threads ready from thread FSMs, both
    // non-speculative ready and speculative ready
    input [3:0]         swl_esl_thr_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy,
    input [3:0]         swl_esl_thr_sprdy_or_urdy_next,

    // Use speculative ready vector, meaning no
    // thread is non-speculatively ready
    input               swl_esl_use_spec,

    // Thread in F stage
    input [3:0]         fcl_esl_thr_f,

    // Instructions to be in S2 TIRs next
    input [32:0]        fdp_esl_t0inst_next_s2,

    input [32:0]        fdp_esl_t1inst_next_s2,















    // Physical address of above instructions
    input [39:2]        fdp_esl_t0inst_paddr_next_s2,

    input [39:2]        fdp_esl_t1inst_paddr_next_s2,















    // Virtual address of above instructions
    input [48:0]        fdp_esl_t0pc_next_s2,

    input [48:0]        fdp_esl_t1pc_next_s2,















    // Above instructions valid on the next cycle?
    input [3:0]         fcl_esl_tinst_vld_next_s,

    // Branch taken in E and M stage (taken in M stage if br was taken in previous stage)
    input               fcl_esl_brtaken_e,
    input               fcl_esl_brtaken_m,

    // Threads in E and M
    input [3:0]         fcl_esl_thr_e,
    input [3:0]         fcl_esl_thr_m,

    // Valid instructions in D, E and M
    input               fcl_esl_inst_vld_d,
    input               fcl_esl_inst_vld_e,
    input               fcl_esl_inst_vld_m,

    // Trap on this cycle
    input [3:0]         fcl_esl_thr_trap_bf,

    // Rollback on this cycle
    input               fcl_esl_rb_stg_s,

    // Unresolved branch instructions
    input               dcl_esl_br_inst_d,
    input               dcl_esl_br_inst_e,

    // Whether a branch target pc is in bf of f
    input [3:0]         fdp_esl_brtrp_target_pc_bf_f,

    // Whether there is an outstanding I-cache miss to thr0
    input               swl_esl_icmiss_out,

    // Next thread to fetch for
    output [3:0]        esl_fcl_nextthr_bf,

    // Stall fetch (i.e. should it fetch)
    output              esl_fcl_stall_bf,

    // Whether to switch to esl_fcl_nextthr_bf
    output              esl_fcl_switch_bf,

    // Sync PCs between leader and follower threads
    output              esl_fdp_sync_pcs_bf,

    // If the thread to be issued is ready (i.e. should it be issued)
    output              esl_fcl_ntr_s,

    // Issue previously issued instruction for
    // next thread
    output              esl_fdp_issue_prev_inst_next_s,

    // Output signal to force s2 to be running on next cycle
    output              esl_fcl_force_running_s
);

    //
    // Parameter Definitions
    //

    //
    // Signal Declarations
    //

    // Derived inputs to thread select modules
    reg         esl_tirs_eql_s;
    reg [1:0]   esl_t0inst_next_op1;
    reg [1:0]   esl_t1inst_next_op1;
    reg [2:0]   esl_t0inst_next_op2;
    reg [2:0]   esl_t1inst_next_op2;
    reg [5:0]   esl_t0inst_next_op3;
    reg [5:0]   esl_t1inst_next_op3;
    reg [8:0]   esl_t0inst_next_opf;
    reg [8:0]   esl_t1inst_next_opf;
    reg [2:0]   esl_t0inst_next_br_rcond;
    reg [2:0]   esl_t1inst_next_br_rcond;
    reg [3:0]   esl_t0inst_next_br_cond;
    reg [3:0]   esl_t1inst_next_br_cond;
    reg [4:0]   esl_t0inst_next_fcn;
    reg [4:0]   esl_t1inst_next_fcn;
    reg [5:0]   esl_t0inst_next_opf_low;
    reg [5:0]   esl_t1inst_next_opf_low;
    reg [3:0]   esl_t0inst_next_mv_cond;
    reg [3:0]   esl_t1inst_next_mv_cond;
    reg [2:0]   esl_t0inst_next_mv_rcond;
    reg [2:0]   esl_t1inst_next_mv_rcond;
    reg         esl_t0inst_next_x;
    reg         esl_t1inst_next_x;
    reg [4:0]   esl_t0inst_next_rd;
    reg [4:0]   esl_t1inst_next_rd;
    reg         esl_tirs_op1_eql;
    reg         esl_tirs_op2_eql;
    reg         esl_tirs_op3_eql;
    reg         esl_tirs_opf_eql;
    reg         esl_tirs_br_rcond_eql;
    reg         esl_tirs_br_cond_eql;
    reg         esl_tirs_fcn_eql;
    reg         esl_tirs_opf_low_eql;
    reg         esl_tirs_mv_cond_eql;
    reg         esl_tirs_mv_rcond_eql;
    reg         esl_tirs_x_eql;
    reg         esl_tirs_rd_eql;
    reg         esl_ops_eql_s;
    reg         esl_pcs_pa_eql_s;
    reg         esl_ctrl_flow_diverged_late_s;
    reg         esl_pcs_pa_page_bndry_s;
    reg         esl_any_trap_bf;
    reg [49:0]  esl_pc_va_diff_s;
    reg [49:0]  esl_pc_va_diff_offset_s;
    reg [49:0]  esl_pc_va_diff_abs_s;
    reg [3:0]   esl_min_pc_va_s;
    reg         esl_pc_va_diff_lt_thresh_s;
    reg         esl_pcs_va_eql_s;
    reg         esl_unresolved_br;
    reg         esl_brtrp_target_pc_bf_f;

    // Register that may be updated with PC VA difference
    // for offset calculation
    reg [49:0]  esl_pc_va_diff_offset_f;

    // Control outputs from ESL FSM to offset register
    wire        esl_pc_va_diff_offset_we;
    wire        esl_pc_va_diff_offset_clear;













    //
    // Sequential Logic
    //

    // Register that gets updated with PC VA difference
    // when instructed to do so
    always @ (posedge clk)
    begin
        if (~rst_n | esl_pc_va_diff_offset_clear)
            esl_pc_va_diff_offset_f <= 50'b0;
        else if (esl_pc_va_diff_offset_we)
            esl_pc_va_diff_offset_f <= esl_pc_va_diff_s;
    end

    //
    // Combinational Logic
    //

    // Derive inputs to sub-synchronization modules
    always @ *
    begin
        // Thread instructions equal
        esl_tirs_eql_s = (fdp_esl_t0inst_next_s2 == fdp_esl_t1inst_next_s2);
      
        // Thread instructions opcodes
        esl_t0inst_next_op1 = fdp_esl_t0inst_next_s2[31:30];
        esl_t1inst_next_op1 = fdp_esl_t1inst_next_s2[31:30];
        esl_t0inst_next_op2 = fdp_esl_t0inst_next_s2[24:22];
        esl_t1inst_next_op2 = fdp_esl_t1inst_next_s2[24:22];
        esl_t0inst_next_op3 = fdp_esl_t0inst_next_s2[24:19];
        esl_t1inst_next_op3 = fdp_esl_t1inst_next_s2[24:19];
        esl_t0inst_next_opf = fdp_esl_t0inst_next_s2[13:5];
        esl_t1inst_next_opf = fdp_esl_t1inst_next_s2[13:5];
        esl_t0inst_next_br_rcond = fdp_esl_t0inst_next_s2[27:25];
        esl_t1inst_next_br_rcond = fdp_esl_t1inst_next_s2[27:25];
        esl_t0inst_next_br_cond = fdp_esl_t0inst_next_s2[28:25];
        esl_t1inst_next_br_cond = fdp_esl_t1inst_next_s2[28:25];
        esl_t0inst_next_fcn = fdp_esl_t0inst_next_s2[29:25];
        esl_t1inst_next_fcn = fdp_esl_t1inst_next_s2[29:25];
        esl_t0inst_next_opf_low = fdp_esl_t0inst_next_s2[10:5];
        esl_t1inst_next_opf_low = fdp_esl_t1inst_next_s2[10:5];
        esl_t0inst_next_mv_cond = fdp_esl_t0inst_next_s2[17:14];
        esl_t1inst_next_mv_cond = fdp_esl_t1inst_next_s2[17:14];
        esl_t0inst_next_mv_rcond = fdp_esl_t0inst_next_s2[12:10];
        esl_t1inst_next_mv_rcond = fdp_esl_t1inst_next_s2[12:10];
        esl_t0inst_next_x = fdp_esl_t0inst_next_s2[12];
        esl_t1inst_next_x = fdp_esl_t1inst_next_s2[12];
        esl_t0inst_next_rd = fdp_esl_t0inst_next_s2[29:25];
        esl_t1inst_next_rd = fdp_esl_t1inst_next_s2[29:25];    
    
        // Thread instruction opcodes equal
        esl_tirs_op1_eql = (esl_t0inst_next_op1 == esl_t1inst_next_op1);
        esl_tirs_op2_eql = (esl_t0inst_next_op2 == esl_t1inst_next_op2);
        esl_tirs_op3_eql = (esl_t0inst_next_op3 == esl_t1inst_next_op3);
        esl_tirs_opf_eql = (esl_t0inst_next_opf == esl_t1inst_next_opf);
        esl_tirs_br_rcond_eql = (esl_t0inst_next_br_rcond == esl_t1inst_next_br_rcond);
        esl_tirs_br_cond_eql = (esl_t0inst_next_br_cond == esl_t1inst_next_br_cond);
        esl_tirs_fcn_eql = (esl_t0inst_next_fcn == esl_t1inst_next_fcn);
        esl_tirs_opf_low_eql = (esl_t0inst_next_opf_low == esl_t1inst_next_opf_low);
        esl_tirs_mv_cond_eql = (esl_t0inst_next_mv_cond == esl_t1inst_next_mv_cond);
        esl_tirs_mv_rcond_eql = (esl_t0inst_next_mv_rcond == esl_t1inst_next_mv_rcond);
        esl_tirs_x_eql = (esl_t0inst_next_x == esl_t1inst_next_x);
        esl_tirs_rd_eql = (esl_t0inst_next_rd == esl_t1inst_next_rd);

        // Determine if opcode of two instructions is equal
        // This logic is derived from SPARC V9 instruction formats
        case (esl_t0inst_next_op1)
            2'b00:
            begin
                // Branchs and SETHI, need to check op2
                
                // If branch on integer register with predication, need to
                // check rcond code
                if (esl_t0inst_next_op2 == 3'b011)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql & esl_tirs_br_rcond_eql;
                // If branch on floating-point condition codes or branch on floating
                // point condition codes with prediction or branch on integer
                // condition codes or branch on integer condition codes with
                // prediction, need to check cond code
                else if (esl_t0inst_next_op2 == 3'b110 || esl_t0inst_next_op2 == 3'b101 || 
                         esl_t0inst_next_op2 == 3'b010 || esl_t0inst_next_op2 == 3'b001)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql & esl_tirs_br_cond_eql;
                // Otherwise, just need to check op2
                else
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op2_eql;
            end
            2'b01:
            begin
                // Call instruction, just need to check op1
                esl_ops_eql_s = esl_tirs_op1_eql;
            end
            2'b10:
            begin
                // Arithmetic and Misc. (FP) instructions

                // If Done/Retry, need to check fcn
                if (esl_t0inst_next_op3 == 6'b111110)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                end
                // If floating-point add or subtract or floating-point compare
                // or floating-point to integer conversion or convert between
                // floating point formats or convert integer to floating-point
                // or floating-point move or floating-point muldiv, or floating-point
                // square root or floating-point move on condition or impl. dep., 
                // need to check opf
                else if (esl_t0inst_next_op3 == 6'b110100 || esl_t0inst_next_op3 == 6'b110101 ||
                         esl_t0inst_next_op3 == 6'b110110)
                begin
                    // If floating point move on condition, need to check cond
                    if (esl_t0inst_next_op3 == 6'b110101 &&
                        (esl_t0inst_next_opf_low == 6'b000001 ||
                         esl_t0inst_next_opf_low == 6'b000010 ||
                         esl_t0inst_next_opf_low == 6'b000011))
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_low_eql &
                                        esl_tirs_mv_cond_eql;
                    // If floating point move on integer condition, need to check rcond
                    else if (esl_t0inst_next_op3 == 6'b110101 &&
                        (esl_t0inst_next_opf_low[4:0] == 5'b00101 ||
                         esl_t0inst_next_opf_low[4:0] == 5'b00110 ||
                         esl_t0inst_next_opf_low[4:0] == 5'b00111))
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_low_eql &
                                        esl_tirs_mv_rcond_eql;
                    // Otherwise, just need to check opf
                    else
                        esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_opf_eql;
                end
                // If move on condition, need to check cond
                else if (esl_t0inst_next_op3 == 6'b101100)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_mv_cond_eql;
                end
                // If move on regiser condition, need to check rcond
                else if (esl_t0inst_next_op3 == 6'b101111)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_mv_rcond_eql;
                end
                // If save or restore, need to check fcn
                else if (esl_t0inst_next_op3 == 6'b110001)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                end
                // If a shift type, need to check x
                else if (esl_t0inst_next_op3 == 6'b100101 || esl_t0inst_next_op3 == 6'b100110 ||
                         esl_t0inst_next_op3 == 6'b100111)
                begin    
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_x_eql;
                end
                // If software initiated reset, need to check rd
                else if (esl_t0inst_next_op3 == 6'b110000 && esl_t0inst_next_rd == 5'b01111)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_rd_eql;
                end
                // If trap on integer condition codes, need to check cond
                else if (esl_t0inst_next_op3 == 6'b111010)
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_br_cond_eql;
                end
                // Otherwise, just need to check op3
                else
                begin
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql;
                end
            end
            2'b11:
            begin
                // Loads and Stores, need to check op3
                
                // If load/store floating point state register, need to check rd
                if (esl_t0inst_next_op3 == 6'b100001 || esl_t0inst_next_op3 == 6'b100101)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_rd_eql;
                // If prefetch, need to check fcn
                else if (esl_t0inst_next_op3 == 6'b101101 || esl_t0inst_next_op3 == 6'b111101)
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql & esl_tirs_fcn_eql;
                // Otherwise, just need to check op3
                else
                    esl_ops_eql_s = esl_tirs_op1_eql & esl_tirs_op3_eql;
            end
            default:
                esl_ops_eql_s = 1'bx;
        endcase

        // Thread PC physical addresses equal
        esl_pcs_pa_eql_s = (fdp_esl_t0inst_paddr_next_s2 == fdp_esl_t1inst_paddr_next_s2) &
                           fcl_esl_tinst_vld_next_s[0] & fcl_esl_tinst_vld_next_s[1];

        // Control flow diverged
        esl_ctrl_flow_diverged_late_s = ((fcl_esl_brtaken_e & ~fcl_esl_brtaken_m) |
                                         (~fcl_esl_brtaken_e & fcl_esl_brtaken_m)) &
                                        (fcl_esl_thr_e == 4'b0010) &
                                        (fcl_esl_thr_m == 4'b0001) &
                                        fcl_esl_inst_vld_e & fcl_esl_inst_vld_m;

        // Check if this is the last instruction in a page (i.e. PA mod 8K is 8K - 4)
        esl_pcs_pa_page_bndry_s = ({fdp_esl_t0inst_paddr_next_s2, 2'b0} % 40'd8192) == 40'd8188;

        // Check if any trap occurred
        esl_any_trap_bf = fcl_esl_thr_trap_bf[0] | fcl_esl_thr_trap_bf[1];

        // Difference in PCs
        esl_pc_va_diff_s = ({1'b0, fdp_esl_t0pc_next_s2} - {1'b0, fdp_esl_t1pc_next_s2});

        // Difference in PCs plus offset
        esl_pc_va_diff_offset_s = esl_pc_va_diff_s + esl_pc_va_diff_offset_f;
        
        // Take absolute value of difference
        esl_pc_va_diff_abs_s = esl_pc_va_diff_offset_s;
        if (esl_pc_va_diff_abs_s[49])
            esl_pc_va_diff_abs_s = (~esl_pc_va_diff_abs_s) + 1;

        // Get minimum PC
        if (~esl_pc_va_diff_offset_s[49])
            esl_min_pc_va_s = 4'b0010;
        else
            esl_min_pc_va_s = 4'b0001;

        // Evaluate if difference is less than thresh
        esl_pc_va_diff_lt_thresh_s = (esl_pc_va_diff_abs_s < config_esl_pc_diff_thresh);

        // Evaluate if VA PCs are equal (including offset)
        esl_pcs_va_eql_s = (esl_pc_va_diff_offset_s == 50'b0);

        // Any unresolved branches in pipe?
        esl_unresolved_br = (dcl_esl_br_inst_d & fcl_esl_inst_vld_d) |
                            (dcl_esl_br_inst_e & fcl_esl_inst_vld_e);

        // A branch or trap PC is in bf or f
        esl_brtrp_target_pc_bf_f = |fdp_esl_brtrp_target_pc_bf_f[1:0];
    end

    //
    // Sub-module Instantiations
    //

    // FSM submodule - implements generic FSM logic for all synchronization
    // methods and multiplexes the synchronization method specific portion
    // according to config_esl_sync_method
    sparc_ifu_esl_fsm esl_fsm
    (
        .clk (clk),
        .rst_n (rst_n),
        .config_esl_en (config_esl_en),
        .config_esl_sync_method (config_esl_sync_method),
        .config_esl_counter_timeout (config_esl_counter_timeout),
        .config_esl_lfsr_seed (config_esl_lfsr_seed),
        .config_esl_lfsr_ld (config_esl_lfsr_ld),
        .swl_esl_thr_active (swl_esl_thr_active),
        .swl_esl_thr_urdy (swl_esl_thr_urdy),
        .swl_esl_thr_sprdy_or_urdy (swl_esl_thr_sprdy_or_urdy),
        .swl_esl_thr_sprdy_or_urdy_next (swl_esl_thr_sprdy_or_urdy_next),
        .swl_esl_use_spec (swl_esl_use_spec),
        .fcl_esl_tinst_vld_s (fcl_esl_tinst_vld_next_s),
        .fcl_esl_thr_f (fcl_esl_thr_f),
        .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
        .esl_tirs_eql_s (esl_tirs_eql_s),
        .esl_ops_eql_s (esl_ops_eql_s),
        .esl_pcs_pa_eql_s (esl_pcs_pa_eql_s),
        .esl_ctrl_flow_diverged_late_s (esl_ctrl_flow_diverged_late_s),
        .esl_pcs_pa_page_bndry_s (esl_pcs_pa_page_bndry_s),
        .esl_any_trap_bf (esl_any_trap_bf),
        .esl_min_pc_va_s (esl_min_pc_va_s),
        .esl_pc_va_diff_lt_thresh_s (esl_pc_va_diff_lt_thresh_s),
        .esl_pcs_va_eql_s (esl_pcs_va_eql_s),
        .esl_unresolved_br (esl_unresolved_br),
        .esl_brtrp_target_pc_bf_f (esl_brtrp_target_pc_bf_f),
        .swl_esl_icmiss_out (swl_esl_icmiss_out),
        .esl_fcl_nextthr_bf (esl_fcl_nextthr_bf),
        .esl_fcl_stall_bf (esl_fcl_stall_bf),
        .esl_fcl_switch_bf (esl_fcl_switch_bf),
        .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
        .esl_fcl_ntr_s (esl_fcl_ntr_s),
        .esl_fdp_issue_prev_inst_next_s (esl_fdp_issue_prev_inst_next_s),
        .esl_fcl_force_running_s (esl_fcl_force_running_s),
        .esl_pc_va_diff_offset_we (esl_pc_va_diff_offset_we),
        .esl_pc_va_diff_offset_clear (esl_pc_va_diff_offset_clear)
    );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_rndrob.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_rndrob
//  Description:	
//  Round robin scheduler.  Least priority to the last granted
//  customer.  If no requests, the priority remains the same. 
//
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_rndrob(/*AUTOARG*/
   // Outputs
   grant_vec, so, 
   // Inputs
   clk, reset, se, si, req_vec, advance, rst_tri_enable
   );

   input     clk, reset, se, si;

   input [3:0]  req_vec;
   
   input 	advance;
   input 	rst_tri_enable;
   
   output [3:0] grant_vec;
   
   output 	so;

   wire [3:0] 	next_pv,
		pv,
		gv,
		park_vec;
   
   
   assign 	pv =  advance ? grant_vec : 
	                        park_vec;

   assign 	next_pv[3:1] = pv[3:1] & {3{~reset}};
   assign 	next_pv[0] = pv[0] | reset;
   
   dff_s #4  park_reg(.din  (next_pv),
		    .clk  (clk),
		    .q    (park_vec),
		    .se   (se), .si(), .so());

   // if noone requests, don't advance, otherwise we'll go back to 0
   // and will not be fair to other requestors
   assign gv[0] = park_vec[3] & req_vec[0] |
		  park_vec[2] & ~req_vec[3] & req_vec[0] |
		  park_vec[1] & ~req_vec[2] & ~req_vec[3] & req_vec[0] |
	          ~req_vec[1] & ~req_vec[2] & ~req_vec[3];
   
   assign gv[1] = park_vec[0] & req_vec[1] |
		  park_vec[3] & ~req_vec[0] & req_vec[1] |
		  park_vec[2] & ~req_vec[3] & ~req_vec[0] & req_vec[1] |
	          req_vec[1] & ~req_vec[2] & ~req_vec[3] & ~req_vec[0];

   assign gv[2] = park_vec[1] & req_vec[2] |
		  park_vec[0] & ~req_vec[1] & req_vec[2] |
		  park_vec[3] & ~req_vec[0] & ~req_vec[1] & req_vec[2] |
		  req_vec[2] & ~req_vec[3] & ~req_vec[0] & ~req_vec[1];

   assign gv[3] = park_vec[2] & req_vec[3] |
		  park_vec[1] & ~req_vec[2] & req_vec[3] |
		  park_vec[0] & ~req_vec[1] & ~req_vec[2] & req_vec[3] |
		  req_vec[3] & ~req_vec[0] & ~req_vec[1] & ~req_vec[2];

   assign grant_vec[0] = gv[0] | rst_tri_enable;
   assign grant_vec[3:1] = gv[3:1] & {3{~rst_tri_enable}};
   

endmodule // sparc_ifu_rndrob

   
   
// Copyright (c) 2015 Princeton University
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Wraps the IFU to tie unused signals when no SPU is present

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting












// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































module sparc_ifu_nospu_wrap 
(
    input [2:0] 	  exu_tlu_wsr_data_m,

    output         ifu_exu_addr_mask_d,


    output         ifu_tlu_inst_vld_w,
    output         ifu_tlu_flush_w,
    output         ifu_lsu_alt_space_e,
    output         ifu_tlu_ttype_vld_m,
    output [4:0]   ifu_exu_muldivop_d,
    output [1:0]   ifu_lsu_thrid_s,

    input [58:0]   tlu_itlb_tte_tag_w2,
    input [42:0]   tlu_itlb_tte_data_w2,
    input          tlu_itlb_rw_index_vld_g,
    input [5:0]    tlu_itlb_rw_index_g,
    input [40:0]   tlu_idtlb_dmp_key_g,
    input          tlu_itlb_dmp_all_g,


    input [62:0]           tlu_sscan_data,
    input [15:0]           lsu_sscan_data,


    input                arst_l,
    // input [3:0]          const_cpuid,
    // input [7:0]          const_maskid,
    // input                ctu_tck,
    input [47:0]         exu_ifu_brpc_e,
    input [7:0]          exu_ifu_cc_d,
    input                exu_ifu_ecc_ce_m,
    input                exu_ifu_ecc_ue_m,
    input [7:0]          exu_ifu_err_reg_m,
    input [7:0]          exu_ifu_err_synd_m,
    input                exu_ifu_inj_ack,
    input [3:0]          exu_ifu_longop_done_g,
    input [3:0]          exu_ifu_oddwin_s,
    input                exu_ifu_regn_e,
    input                exu_ifu_regz_e,
    input                exu_ifu_spill_e,
    input                exu_ifu_va_oor_m,
    input [1:0]          ffu_ifu_cc_vld_w2,
    input [7:0]          ffu_ifu_cc_w2,
    input                ffu_ifu_ecc_ce_w2,
    input                ffu_ifu_ecc_ue_w2,
    input [5:0]          ffu_ifu_err_reg_w2,
    input [13:0]         ffu_ifu_err_synd_w2,
    input                ffu_ifu_fpop_done_w2,
    input                ffu_ifu_fst_ce_w,
    input                ffu_ifu_inj_ack,
    input                ffu_ifu_stallreq,
    input [1:0]          ffu_ifu_tid_w2,
    input                gdbginit_l,
    input                grst_l,
    input [3:0]          lsu_ifu_addr_real_l,
    input [17:0]         lsu_ifu_asi_addr,
    input                lsu_ifu_asi_load,
    input [7:0]          lsu_ifu_asi_state,
    input [1:0]          lsu_ifu_asi_thrid,
    input                lsu_ifu_asi_vld,
    input [145-1:130]lsu_ifu_cpxpkt_i1_144_130,
    input [127:0]        lsu_ifu_cpxpkt_i1_127_0,
    input                lsu_ifu_dc_parity_error_w2,
    input                lsu_ifu_dcache_data_perror,
    input                lsu_ifu_dcache_tag_perror,
    input                lsu_ifu_direct_map_l1,
    input                lsu_ifu_dtlb_data_su,
    input                lsu_ifu_dtlb_data_ue,
    input                lsu_ifu_dtlb_tag_ue,
    input [47:4]         lsu_ifu_err_addr,
    input [1:0]          lsu_ifu_error_tid,
    input [3:0]          lsu_ifu_icache_en,
    input [3:0]          lsu_ifu_inj_ack,
    input                lsu_ifu_io_error,
    input                lsu_ifu_l2_corr_error,
    input                lsu_ifu_l2_unc_error,
    input [(6 + 5):5] lsu_ifu_ld_icache_index,
    input [1:0]          lsu_ifu_ld_pcxpkt_tid,
    input                lsu_ifu_ld_pcxpkt_vld,
    input [1:0]          lsu_ifu_ldst_cmplt,
    input                lsu_ifu_ldst_miss_g,
    input                lsu_ifu_ldsta_internal_e,
    input                lsu_ifu_pcxpkt_ack_d,
    input                lsu_ifu_stallreq,
    input [3:0]          lsu_ifu_stbcnt0,
    input [3:0]          lsu_ifu_stbcnt1,
    input [3:0]          lsu_ifu_stbcnt2,
    input [3:0]          lsu_ifu_stbcnt3,
    input [47:0]         lsu_ifu_stxa_data,
    input                lsu_ifu_t0_tlz,
    input                lsu_ifu_t1_tlz,
    input                lsu_ifu_t2_tlz,
    input                lsu_ifu_t3_tlz,
    input [2:0]          lsu_pid_state0,
    input [2:0]          lsu_pid_state1,
    input [2:0]          lsu_pid_state2,
    input [2:0]          lsu_pid_state3,
    input [12:0]         lsu_t0_pctxt_state,
    input [12:0]         lsu_t1_pctxt_state,
    input                rclk,
    input [3:0]          tlu_hpstate_enb,
    input [3:0]          tlu_hpstate_ibe,
    input [3:0]          tlu_hpstate_priv,
    input [1:0]          tlu_idtlb_dmp_thrid_g,
    input                tlu_ifu_flush_pipe_w,
    input [3:0]          tlu_ifu_hintp_vld,
    input [3:0]          tlu_ifu_hwint_i3,
    input                tlu_ifu_nukeint_i2,
    input [1:0]          tlu_ifu_pstate_ie,
    input [3:0]          tlu_ifu_pstate_pef,
    input [1:0]          tlu_ifu_rerr_vld,
    input                tlu_ifu_resumint_i2,
    input                tlu_ifu_rstint_i2,
    input [3:0]          tlu_ifu_rstthr_i2,
    input [1:0]          tlu_ifu_sftint_vld,
    input [1:0]          tlu_ifu_trap_tid_w1,
    input                tlu_ifu_trapnpc_vld_w1,
    input [48:0]         tlu_ifu_trapnpc_w2,
    input                tlu_ifu_trappc_vld_w1,
    input [48:0]         tlu_ifu_trappc_w2,
    input                tlu_itlb_data_rd_g,
    input                tlu_itlb_dmp_actxt_g,
    input                tlu_itlb_dmp_nctxt_g,
    input                tlu_itlb_dmp_vld_g,
    input                tlu_itlb_invalidate_all_g,
    input                tlu_itlb_tag_rd_g,
    input                tlu_itlb_wr_vld_g,
    input [3:0]          tlu_lsu_pstate_am,
    input [3:0]          tlu_lsu_pstate_priv,
    input [3:0]          tlu_lsu_redmode,
    
    input                tlu_itlb_csm_rd_g,
    input [31:0] tlu_itlb_tte_csm_w2,
    input                tlu_itlb_wr_csm_sel_g,

    input [2-1:0]   cfg_ifu_csm_itlb_state,
    input [14-1:0]      cfg_ifu_csm_itlb_chipid,
    input [8-1:0]           cfg_ifu_csm_itlb_x,
    input [8-1:0]           cfg_ifu_csm_itlb_y,
    input [10-1:0]        cfg_ifu_csm_itlb_hdid,
    input [6-1:0]        cfg_ifu_csm_itlb_hd_size,
    input [10-1:0]        cfg_ifu_csm_itlb_sdid,
    input [6-1:0]        cfg_ifu_csm_itlb_lsid,

    


    input                config_dtu_esl_en,
    input [1:0]          config_dtu_esl_sync_method,
    input [15:0]         config_esl_lfsr_seed,
    input                config_esl_lfsr_ld,
    input [49:0]         config_esl_pc_diff_thresh,
    input [15:0]         config_esl_counter_timeout,

    // jtag

    output [2:0]         ifu_exu_aluop_d,
    output               ifu_exu_casa_d,
    output               ifu_exu_dbrinst_d,
    output               ifu_exu_disable_ce_e,
    output               ifu_exu_dontmv_regz0_e,
    output               ifu_exu_dontmv_regz1_e,
    output [7:0]         ifu_exu_ecc_mask,
    output               ifu_exu_enshift_d,
    output               ifu_exu_flushw_e,
    output               ifu_exu_ialign_d,
    output [31:0]        ifu_exu_imm_data_d,
    output               ifu_exu_inj_irferr,
    output               ifu_exu_inst_vld_e,
    output               ifu_exu_inst_vld_w,
    output               ifu_exu_invert_d,
    output               ifu_exu_kill_e,
    output               ifu_exu_muls_d,
    output               ifu_exu_nceen_e,
    output [47:0]        ifu_exu_pc_d,
    output [63:0]        ifu_exu_pcver_e,
    output               ifu_exu_range_check_jlret_d,
    output               ifu_exu_range_check_other_d,
    output [4:0]         ifu_exu_rd_d,
    output               ifu_exu_rd_exusr_e,
    output               ifu_exu_rd_ffusr_e,
    output               ifu_exu_rd_ifusr_e,
    output               ifu_exu_ren1_s,
    output               ifu_exu_ren2_s,
    output               ifu_exu_ren3_s,
    output               ifu_exu_restore_d,
    output               ifu_exu_restored_e,
    output               ifu_exu_return_d,
    output [4:0]         ifu_exu_rs1_s,
    output               ifu_exu_rs1_vld_d,
    output [4:0]         ifu_exu_rs2_s,
    output               ifu_exu_rs2_vld_d,
    output [4:0]         ifu_exu_rs3_s,
    output               ifu_exu_rs3e_vld_d,
    output               ifu_exu_rs3o_vld_d,
    output               ifu_exu_save_d,
    output               ifu_exu_saved_e,
    output               ifu_exu_setcc_d,
    output               ifu_exu_sethi_inst_d,
    output [2:0]         ifu_exu_shiftop_d,
    output               ifu_exu_tagop_d,
    output               ifu_exu_tcc_e,
    output [1:0]         ifu_exu_tid_s2,
    output               ifu_exu_ttype_vld_m,
    output               ifu_exu_tv_d,
    output               ifu_exu_use_rsr_e_l,
    output               ifu_exu_usecin_d,
    output               ifu_exu_useimm_d,
    output               ifu_exu_wen_d,
    output               ifu_exu_wsr_inst_d,
    output [1:0]         ifu_ffu_fcc_num_d,
    output               ifu_ffu_fld_d,
    output               ifu_ffu_fpop1_d,
    output               ifu_ffu_fpop2_d,
    output [8:0]         ifu_ffu_fpopcode_d,
    output [4:0]         ifu_ffu_frd_d,
    output [4:0]         ifu_ffu_frs1_d,
    output [4:0]         ifu_ffu_frs2_d,
    output               ifu_ffu_fst_d,
    output               ifu_ffu_inj_frferr,
    output               ifu_ffu_ldfsr_d,
    output               ifu_ffu_ldst_size_d,
    output               ifu_ffu_ldxfsr_d,
    output               ifu_ffu_mvcnd_m,
    output               ifu_ffu_quad_op_e,
    output               ifu_ffu_stfsr_d,
    output               ifu_ffu_visop_d,
    output               ifu_lsu_alt_space_d,
    output               ifu_lsu_asi_ack,
    output               ifu_lsu_asi_rd_unc,
    output               ifu_lsu_casa_e,
    output [2:0]         ifu_lsu_destid_s,
    output [3:0]         ifu_lsu_error_inj,
    output               ifu_lsu_fwd_data_vld,
    output               ifu_lsu_fwd_wr_ack,
    output               ifu_lsu_ibuf_busy,
    output [7:0]         ifu_lsu_imm_asi_d,
    output               ifu_lsu_imm_asi_vld_d,
    output               ifu_lsu_inv_clear,
    output               ifu_lsu_ld_inst_e,
    output               ifu_lsu_ldst_dbl_e,
    output               ifu_lsu_ldst_fp_e,
    output [1:0]         ifu_lsu_ldst_size_e,
    output               ifu_lsu_ldstub_e,
    output               ifu_lsu_ldxa_data_vld_w2,
    output [63:0]        ifu_lsu_ldxa_data_w2,
    output               ifu_lsu_ldxa_illgl_va_w2,
    output [1:0]         ifu_lsu_ldxa_tid_w2,
    output               ifu_lsu_memref_d,
    output [3:0]         ifu_lsu_nceen,
    output [51:0]        ifu_lsu_pcxpkt_e,
    output               ifu_lsu_pcxreq_d,
    output               ifu_lsu_pref_inst_e,
    output [4:0]         ifu_lsu_rd_e,
    output               ifu_lsu_sign_ext_e,
    output               ifu_lsu_st_inst_e,
    output               ifu_lsu_swap_e,
    output               ifu_lsu_wsr_inst_d,
    output               ifu_mmu_trap_m,
    output               ifu_tlu_alt_space_d,
    output               ifu_tlu_done_inst_d,
    output               ifu_tlu_flsh_inst_e,
    output               ifu_tlu_flush_m,
    output               ifu_tlu_hwint_m,
    output               ifu_tlu_icmiss_e,
    output [8:0]         ifu_tlu_imm_asi_d,
    output               ifu_tlu_immu_miss_m,
    output               ifu_tlu_inst_vld_m,
    output               ifu_tlu_itlb_done,
    output [3:0]         ifu_tlu_l2imiss,
    output               ifu_tlu_mb_inst_e,
    output [48:0]        ifu_tlu_npc_m,
    output [48:0]        ifu_tlu_pc_m,
    output               ifu_tlu_pc_oor_e,
    output               ifu_tlu_priv_violtn_m,
    output               ifu_tlu_retry_inst_d,
    output               ifu_tlu_rsr_inst_d,
    output               ifu_tlu_rstint_m,
    output               ifu_tlu_sftint_m,
    output               ifu_tlu_sir_inst_m,
    output [6:0]         ifu_tlu_sraddr_d,
    output [6:0]         ifu_tlu_sraddr_d_v2,
    output [1:0]         ifu_tlu_thrid_d,
    output [1:0]         ifu_tlu_thrid_e,
    output               ifu_tlu_trap_m,
    output [8:0]         ifu_tlu_ttype_m,

    
    output [32:0]     ifu_lsu_pcxcsm_e,
    

    // jtag debug
    output wire [94-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [47:0] rtap_core_data_47_0,

    // sram interface
    output wire [4-1:0] srams_rtap_data,
    input wire  [4-1:0] rtap_srams_bist_command,
    input wire  [4-1:0] rtap_srams_bist_data
);

// trin: removing useless input/outp
// wire mux_drive_disable = ~grst_l;
// wire mem_write_disable = ~grst_l;
wire mux_drive_disable = 1'b0;
wire mem_write_disable = 1'b0;
wire [3:0]  const_cpuid = 4'b0;
wire [7:0]  const_maskid = 8'b0;           // To ifu of sparc_ifu.v

    sparc_ifu ifu(
                 // scan
                 // .short_si0              (1'bx),
                 // .short_si1              (1'bx),
                 // .short_so0              (),
                 // .short_so1              (),
                 // .si0                    (1'bx),
                 // .so0                    (),
                 
                 .grst_l                 (grst_l),
                 .arst_l                 (arst_l),
                 .gdbginit_l             (gdbginit_l),
                 
                 .lsu_ifu_quad_asi_e    (1'b0),

                 .lsu_ifu_addr_real_l  (lsu_ifu_addr_real_l),
                 
                 .lsu_ifu_dtlb_data_ue  (lsu_ifu_dtlb_data_ue),
                 .lsu_ifu_dtlb_tag_ue   (lsu_ifu_dtlb_tag_ue),
                 .lsu_ifu_dtlb_data_su  (lsu_ifu_dtlb_data_su),

                 .tlu_ifu_hintp_vld       (tlu_ifu_hintp_vld),
                 .tlu_ifu_rerr_vld        ({2'bx, tlu_ifu_rerr_vld}),

                 .lsu_ifu_t0_tlz        (lsu_ifu_t0_tlz),
                 .lsu_ifu_t1_tlz        (lsu_ifu_t1_tlz),
                 .lsu_ifu_t2_tlz        (lsu_ifu_t2_tlz),
                 .lsu_ifu_t3_tlz        (lsu_ifu_t3_tlz),
                 
                 .lsu_ifu_ldst_miss_g   (lsu_ifu_ldst_miss_g),
                 .tlu_ifu_flush_pipe_w  (tlu_ifu_flush_pipe_w),

                 .lsu_idtlb_mrgn        (8'bx),

                 // .mbist_loop_on_address (mbist_loop_on_address),
                 
                 .ifu_tlu_imm_asi_d     (ifu_tlu_imm_asi_d),

                 // bus width difference
                 .lsu_ifu_cpxpkt_i1     ({lsu_ifu_cpxpkt_i1_144_130, 2'bx, lsu_ifu_cpxpkt_i1_127_0}),
                     /*AUTOINST*/
                 // Outputs

                 
                 .ifu_lsu_pcxcsm_e       (ifu_lsu_pcxcsm_e), 
                 
                 .ifu_exu_addr_mask_d   (ifu_exu_addr_mask_d),
                 .ifu_tlu_inst_vld_w    (ifu_tlu_inst_vld_w),
                 .ifu_tlu_flush_w       (ifu_tlu_flush_w),
                 .ifu_lsu_alt_space_e   (ifu_lsu_alt_space_e),
                 .ifu_tlu_ttype_vld_m   (ifu_tlu_ttype_vld_m),
                 .ifu_exu_muldivop_d    (ifu_exu_muldivop_d),
                 .ifu_lsu_thrid_s       (ifu_lsu_thrid_s),
                 // .mbist_write_data      (mbist_write_data),
                 .ifu_exu_aluop_d       (ifu_exu_aluop_d),
                 .ifu_exu_casa_d        (ifu_exu_casa_d),
                 .ifu_exu_dbrinst_d     (ifu_exu_dbrinst_d),
                 .ifu_exu_disable_ce_e  (ifu_exu_disable_ce_e),
                 .ifu_exu_dontmv_regz0_e(ifu_exu_dontmv_regz0_e),
                 .ifu_exu_dontmv_regz1_e(ifu_exu_dontmv_regz1_e),
                 .ifu_exu_ecc_mask      (ifu_exu_ecc_mask),
                 .ifu_exu_enshift_d     (ifu_exu_enshift_d),
                 .ifu_exu_flushw_e      (ifu_exu_flushw_e),
                 .ifu_exu_ialign_d      (ifu_exu_ialign_d),
                 .ifu_exu_imm_data_d    (ifu_exu_imm_data_d),
                 .ifu_exu_inj_irferr    (ifu_exu_inj_irferr),
                 .ifu_exu_inst_vld_e    (ifu_exu_inst_vld_e),
                 .ifu_exu_inst_vld_w    (ifu_exu_inst_vld_w),
                 .ifu_exu_invert_d      (ifu_exu_invert_d),
                 .ifu_exu_kill_e        (ifu_exu_kill_e),
                 .ifu_exu_muls_d        (ifu_exu_muls_d),
                 .ifu_exu_nceen_e       (ifu_exu_nceen_e),
                 .ifu_exu_pc_d          (ifu_exu_pc_d),
                 .ifu_exu_pcver_e       (ifu_exu_pcver_e),
                 .ifu_exu_range_check_jlret_d(ifu_exu_range_check_jlret_d),
                 .ifu_exu_range_check_other_d(ifu_exu_range_check_other_d),
                 .ifu_exu_rd_d          (ifu_exu_rd_d),
                 .ifu_exu_rd_exusr_e    (ifu_exu_rd_exusr_e),
                 .ifu_exu_rd_ffusr_e    (ifu_exu_rd_ffusr_e),
                 .ifu_exu_rd_ifusr_e    (ifu_exu_rd_ifusr_e),
                 .ifu_exu_ren1_s        (ifu_exu_ren1_s),
                 .ifu_exu_ren2_s        (ifu_exu_ren2_s),
                 .ifu_exu_ren3_s        (ifu_exu_ren3_s),
                 .ifu_exu_restore_d     (ifu_exu_restore_d),
                 .ifu_exu_restored_e    (ifu_exu_restored_e),
                 .ifu_exu_return_d      (ifu_exu_return_d),
                 .ifu_exu_rs1_s         (ifu_exu_rs1_s),
                 .ifu_exu_rs1_vld_d     (ifu_exu_rs1_vld_d),
                 .ifu_exu_rs2_s         (ifu_exu_rs2_s),
                 .ifu_exu_rs2_vld_d     (ifu_exu_rs2_vld_d),
                 .ifu_exu_rs3_s         (ifu_exu_rs3_s),
                 .ifu_exu_rs3e_vld_d    (ifu_exu_rs3e_vld_d),
                 .ifu_exu_rs3o_vld_d    (ifu_exu_rs3o_vld_d),
                 .ifu_exu_save_d        (ifu_exu_save_d),
                 .ifu_exu_saved_e       (ifu_exu_saved_e),
                 .ifu_exu_setcc_d       (ifu_exu_setcc_d),
                 .ifu_exu_sethi_inst_d  (ifu_exu_sethi_inst_d),
                 .ifu_exu_shiftop_d     (ifu_exu_shiftop_d),
                 .ifu_exu_tagop_d       (ifu_exu_tagop_d),
                 .ifu_exu_tcc_e         (ifu_exu_tcc_e),
                 .ifu_exu_tid_s2        (ifu_exu_tid_s2),
                 .ifu_exu_ttype_vld_m   (ifu_exu_ttype_vld_m),
                 .ifu_exu_tv_d          (ifu_exu_tv_d),
                 .ifu_exu_use_rsr_e_l   (ifu_exu_use_rsr_e_l),
                 .ifu_exu_usecin_d      (ifu_exu_usecin_d),
                 .ifu_exu_useimm_d      (ifu_exu_useimm_d),
                 .ifu_exu_wen_d         (ifu_exu_wen_d),
                 .ifu_exu_wsr_inst_d    (ifu_exu_wsr_inst_d),
                 .ifu_ffu_fcc_num_d     (ifu_ffu_fcc_num_d),
                 .ifu_ffu_fld_d         (ifu_ffu_fld_d),
                 .ifu_ffu_fpop1_d       (ifu_ffu_fpop1_d),
                 .ifu_ffu_fpop2_d       (ifu_ffu_fpop2_d),
                 .ifu_ffu_fpopcode_d    (ifu_ffu_fpopcode_d),
                 .ifu_ffu_frd_d         (ifu_ffu_frd_d),
                 .ifu_ffu_frs1_d        (ifu_ffu_frs1_d),
                 .ifu_ffu_frs2_d        (ifu_ffu_frs2_d),
                 .ifu_ffu_fst_d         (ifu_ffu_fst_d),
                 .ifu_ffu_inj_frferr    (ifu_ffu_inj_frferr),
                 .ifu_ffu_ldfsr_d       (ifu_ffu_ldfsr_d),
                 .ifu_ffu_ldst_size_d   (ifu_ffu_ldst_size_d),
                 .ifu_ffu_ldxfsr_d      (ifu_ffu_ldxfsr_d),
                 .ifu_ffu_mvcnd_m       (ifu_ffu_mvcnd_m),
                 .ifu_ffu_quad_op_e     (ifu_ffu_quad_op_e),
                 .ifu_ffu_stfsr_d       (ifu_ffu_stfsr_d),
                 .ifu_ffu_visop_d       (ifu_ffu_visop_d),
                 .ifu_lsu_alt_space_d   (ifu_lsu_alt_space_d),
                 .ifu_lsu_asi_ack       (ifu_lsu_asi_ack),
                 .ifu_lsu_asi_rd_unc    (ifu_lsu_asi_rd_unc),
                 .ifu_lsu_casa_e        (ifu_lsu_casa_e),
                 .ifu_lsu_destid_s      (ifu_lsu_destid_s),
                 .ifu_lsu_error_inj     (ifu_lsu_error_inj),
                 .ifu_lsu_fwd_data_vld  (ifu_lsu_fwd_data_vld),
                 .ifu_lsu_fwd_wr_ack    (ifu_lsu_fwd_wr_ack),
                 .ifu_lsu_ibuf_busy     (ifu_lsu_ibuf_busy),
                 .ifu_lsu_imm_asi_d     (ifu_lsu_imm_asi_d),
                 .ifu_lsu_imm_asi_vld_d (ifu_lsu_imm_asi_vld_d),
                 .ifu_lsu_inv_clear     (ifu_lsu_inv_clear),
                 .ifu_lsu_ld_inst_e     (ifu_lsu_ld_inst_e),
                 .ifu_lsu_ldst_dbl_e    (ifu_lsu_ldst_dbl_e),
                 .ifu_lsu_ldst_fp_e     (ifu_lsu_ldst_fp_e),
                 .ifu_lsu_ldst_size_e   (ifu_lsu_ldst_size_e),
                 .ifu_lsu_ldstub_e      (ifu_lsu_ldstub_e),
                 .ifu_lsu_ldxa_data_vld_w2(ifu_lsu_ldxa_data_vld_w2),
                 .ifu_lsu_ldxa_data_w2  (ifu_lsu_ldxa_data_w2),
                 .ifu_lsu_ldxa_illgl_va_w2(ifu_lsu_ldxa_illgl_va_w2),
                 .ifu_lsu_ldxa_tid_w2   (ifu_lsu_ldxa_tid_w2),
                 .ifu_lsu_memref_d      (ifu_lsu_memref_d),
                 .ifu_lsu_nceen         (ifu_lsu_nceen),
                 .ifu_lsu_pcxpkt_e      (ifu_lsu_pcxpkt_e),
                 .ifu_lsu_pcxreq_d      (ifu_lsu_pcxreq_d),
                 .ifu_lsu_pref_inst_e   (ifu_lsu_pref_inst_e),
                 .ifu_lsu_rd_e          (ifu_lsu_rd_e),
                 .ifu_lsu_sign_ext_e    (ifu_lsu_sign_ext_e),
                 .ifu_lsu_st_inst_e     (ifu_lsu_st_inst_e),
                 .ifu_lsu_swap_e        (ifu_lsu_swap_e),
                 .ifu_lsu_wsr_inst_d    (ifu_lsu_wsr_inst_d),
                 .ifu_mmu_trap_m        (ifu_mmu_trap_m),
                 .ifu_spu_inst_vld_w    (),
                 .ifu_spu_nceen         (),
                 .ifu_spu_trap_ack      (),
                 .ifu_tlu_alt_space_d   (ifu_tlu_alt_space_d),
                 .ifu_tlu_done_inst_d   (ifu_tlu_done_inst_d),
                 .ifu_tlu_flsh_inst_e   (ifu_tlu_flsh_inst_e),
                 .ifu_tlu_flush_m       (ifu_tlu_flush_m),
                 .ifu_tlu_hwint_m       (ifu_tlu_hwint_m),
                 .ifu_tlu_icmiss_e      (ifu_tlu_icmiss_e),
                 .ifu_tlu_immu_miss_m   (ifu_tlu_immu_miss_m),
                 .ifu_tlu_inst_vld_m    (ifu_tlu_inst_vld_m),
                 .ifu_tlu_itlb_done     (ifu_tlu_itlb_done),
                 .ifu_tlu_l2imiss       (ifu_tlu_l2imiss),
                 .ifu_tlu_mb_inst_e     (ifu_tlu_mb_inst_e),
                 .ifu_tlu_npc_m         (ifu_tlu_npc_m),
                 .ifu_tlu_pc_m          (ifu_tlu_pc_m),
                 .ifu_tlu_pc_oor_e      (ifu_tlu_pc_oor_e),
                 .ifu_tlu_priv_violtn_m (ifu_tlu_priv_violtn_m),
                 .ifu_tlu_retry_inst_d  (ifu_tlu_retry_inst_d),
                 .ifu_tlu_rsr_inst_d    (ifu_tlu_rsr_inst_d),
                 .ifu_tlu_rstint_m      (ifu_tlu_rstint_m),
                 .ifu_tlu_sftint_m      (ifu_tlu_sftint_m),
                 .ifu_tlu_sir_inst_m    (ifu_tlu_sir_inst_m),
                 .ifu_tlu_sraddr_d      (ifu_tlu_sraddr_d),
                 .ifu_tlu_sraddr_d_v2   (ifu_tlu_sraddr_d_v2),
                 .ifu_tlu_thrid_d       (ifu_tlu_thrid_d),
                 .ifu_tlu_thrid_e       (ifu_tlu_thrid_e),
                 .ifu_tlu_trap_m        (ifu_tlu_trap_m),
                 .ifu_tlu_ttype_m       (ifu_tlu_ttype_m),
                 // Inputs

                 
                 .tlu_itlb_csm_rd_g     (tlu_itlb_csm_rd_g), 
                 .tlu_itlb_tte_csm_w2   ({1'bx, tlu_itlb_tte_csm_w2}),
                 .tlu_itlb_wr_csm_sel_g (tlu_itlb_wr_csm_sel_g), 

                 .cfg_ifu_csm_itlb_state       (cfg_ifu_csm_itlb_state),
                 .cfg_ifu_csm_itlb_chipid      (cfg_ifu_csm_itlb_chipid),
                 .cfg_ifu_csm_itlb_x           (cfg_ifu_csm_itlb_x),
                 .cfg_ifu_csm_itlb_y           (cfg_ifu_csm_itlb_y),
                 .cfg_ifu_csm_itlb_hdid        (cfg_ifu_csm_itlb_hdid),
                 .cfg_ifu_csm_itlb_hd_size     (cfg_ifu_csm_itlb_hd_size),
                 .cfg_ifu_csm_itlb_sdid        (cfg_ifu_csm_itlb_sdid),
                 .cfg_ifu_csm_itlb_lsid        (cfg_ifu_csm_itlb_lsid),

                 
                 .exu_tlu_wsr_data_m    (exu_tlu_wsr_data_m),
                 .lsu_ictag_mrgn        (4'bx),
                 .tlu_itlb_tte_tag_w2   (tlu_itlb_tte_tag_w2),
                 .tlu_itlb_tte_data_w2  (tlu_itlb_tte_data_w2),
                 .tlu_itlb_rw_index_vld_g(tlu_itlb_rw_index_vld_g),
                 .tlu_itlb_rw_index_g   (tlu_itlb_rw_index_g),
                 .tlu_idtlb_dmp_key_g   (tlu_idtlb_dmp_key_g),
                 .tlu_itlb_dmp_all_g    (tlu_itlb_dmp_all_g),
                 .const_cpuid           (const_cpuid),
                 .const_maskid          (const_maskid),
                 // .ctu_tck               (ctu_tck),
                 .exu_ifu_brpc_e        (exu_ifu_brpc_e),
                 .exu_ifu_cc_d          (exu_ifu_cc_d),
                 .exu_ifu_ecc_ce_m      (exu_ifu_ecc_ce_m),
                 .exu_ifu_ecc_ue_m      (exu_ifu_ecc_ue_m),
                 .exu_ifu_err_reg_m     (exu_ifu_err_reg_m),
                 .exu_ifu_err_synd_m    (exu_ifu_err_synd_m),
                 .exu_ifu_inj_ack       (exu_ifu_inj_ack),
                 .exu_ifu_longop_done_g (exu_ifu_longop_done_g),
                 .exu_ifu_oddwin_s      (exu_ifu_oddwin_s),
                 .exu_ifu_regn_e        (exu_ifu_regn_e),
                 .exu_ifu_regz_e        (exu_ifu_regz_e),
                 .exu_ifu_spill_e       (exu_ifu_spill_e),
                 .exu_ifu_va_oor_m      (exu_ifu_va_oor_m),
                 .ffu_ifu_cc_vld_w2     ({2'bx, ffu_ifu_cc_vld_w2}),
                 .ffu_ifu_cc_w2         (ffu_ifu_cc_w2),
                 .ffu_ifu_ecc_ce_w2     (ffu_ifu_ecc_ce_w2),
                 .ffu_ifu_ecc_ue_w2     (ffu_ifu_ecc_ue_w2),
                 .ffu_ifu_err_reg_w2    (ffu_ifu_err_reg_w2),
                 .ffu_ifu_err_synd_w2   (ffu_ifu_err_synd_w2),
                 .ffu_ifu_fpop_done_w2  (ffu_ifu_fpop_done_w2),
                 .ffu_ifu_fst_ce_w      (ffu_ifu_fst_ce_w),
                 .ffu_ifu_inj_ack       (ffu_ifu_inj_ack),
                 .ffu_ifu_stallreq      (ffu_ifu_stallreq),
                 .ffu_ifu_tid_w2        (ffu_ifu_tid_w2),
                 .lsu_ifu_asi_addr      (lsu_ifu_asi_addr),
                 .lsu_ifu_asi_load      (lsu_ifu_asi_load),
                 .lsu_ifu_asi_state     (lsu_ifu_asi_state),
                 .lsu_ifu_asi_thrid     (lsu_ifu_asi_thrid),
                 .lsu_ifu_asi_vld       (lsu_ifu_asi_vld),
                 .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                 .lsu_ifu_dcache_data_perror(lsu_ifu_dcache_data_perror),
                 .lsu_ifu_dcache_tag_perror(lsu_ifu_dcache_tag_perror),
                 .lsu_ifu_direct_map_l1 (lsu_ifu_direct_map_l1),
                 .lsu_ifu_err_addr      (lsu_ifu_err_addr),
                 .lsu_ifu_error_tid     (lsu_ifu_error_tid),
                 .lsu_ifu_icache_en     (lsu_ifu_icache_en),
                 .lsu_ifu_inj_ack       (lsu_ifu_inj_ack),
                 .lsu_ifu_io_error      (lsu_ifu_io_error),
                 .lsu_ifu_l2_corr_error (lsu_ifu_l2_corr_error),
                 .lsu_ifu_l2_unc_error  (lsu_ifu_l2_unc_error),
                 .lsu_ifu_ld_icache_index(lsu_ifu_ld_icache_index),
                 .lsu_ifu_ld_pcxpkt_tid (lsu_ifu_ld_pcxpkt_tid),
                 .lsu_ifu_ld_pcxpkt_vld (lsu_ifu_ld_pcxpkt_vld),
                 .lsu_ifu_ldst_cmplt    ({2'bx, lsu_ifu_ldst_cmplt}),
                 .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                 .lsu_ifu_pcxpkt_ack_d  (lsu_ifu_pcxpkt_ack_d),
                 .lsu_ifu_stallreq      (lsu_ifu_stallreq),
                 .lsu_ifu_stbcnt0       (lsu_ifu_stbcnt0),
                 .lsu_ifu_stbcnt1       (lsu_ifu_stbcnt1),
                 .lsu_ifu_stbcnt2       (lsu_ifu_stbcnt2),
                 .lsu_ifu_stbcnt3       (lsu_ifu_stbcnt3),
                 .lsu_ifu_stxa_data     (lsu_ifu_stxa_data),
                 .lsu_pid_state0        (lsu_pid_state0),
                 .lsu_pid_state1        (lsu_pid_state1),
                 .lsu_pid_state2        (lsu_pid_state2),
                 .lsu_pid_state3        (lsu_pid_state3),
                 .lsu_t0_pctxt_state    (lsu_t0_pctxt_state),
                 .lsu_t1_pctxt_state    (lsu_t1_pctxt_state),
                 .lsu_t2_pctxt_state    (13'bx),
                 .lsu_t3_pctxt_state    (13'bx),
                 // .mbist_bisi_mode       (mbist_bisi_mode),
                 // .mbist_dcache_data_in  (mbist_dcache_data_in),
                 // .mbist_loop_mode       (mbist_loop_mode),
                 // .mbist_start           (mbist_start),
                 // .mbist_stop_on_fail    (mbist_stop_on_fail),
                 // .mbist_stop_on_next_fail(mbist_stop_on_next_fail),
                 // .mbist_userdata_mode   (mbist_userdata_mode),
                 .rclk                  (rclk),
                 .se                    (1'b0),
                 .sehold                (1'b0),
                 .spu_ifu_corr_err_w2   (1'b0),
                 .spu_ifu_err_addr_w2   (36'h000000000),
                 .spu_ifu_int_w2        (1'b0),
                 .spu_ifu_mamem_err_w1  (1'b0),
                 .spu_ifu_ttype_tid_w2  (2'b00),
                 .spu_ifu_ttype_vld_w2  (1'b0),
                 .spu_ifu_ttype_w2      (1'b0),
                 .spu_ifu_unc_err_w1    (1'b0),
                 // .testmode_l            (1'bx),
                 .tlu_hpstate_enb       (tlu_hpstate_enb),
                 .tlu_hpstate_ibe       (tlu_hpstate_ibe),
                 .tlu_hpstate_priv      (tlu_hpstate_priv),
                 .tlu_idtlb_dmp_thrid_g (tlu_idtlb_dmp_thrid_g),
                 .tlu_ifu_hwint_i3      (tlu_ifu_hwint_i3),
                 .tlu_ifu_nukeint_i2    (tlu_ifu_nukeint_i2),
                 .tlu_ifu_pstate_ie     ({2'bx, tlu_ifu_pstate_ie}),
                 .tlu_ifu_pstate_pef    (tlu_ifu_pstate_pef),
                 .tlu_ifu_resumint_i2   (tlu_ifu_resumint_i2),
                 .tlu_ifu_rstint_i2     (tlu_ifu_rstint_i2),
                 .tlu_ifu_rstthr_i2     (tlu_ifu_rstthr_i2),
                 .tlu_ifu_sftint_vld    ({2'bx, tlu_ifu_sftint_vld}),
                 .tlu_ifu_trap_tid_w1   (tlu_ifu_trap_tid_w1),
                 .tlu_ifu_trapnpc_vld_w1(tlu_ifu_trapnpc_vld_w1),
                 .tlu_ifu_trapnpc_w2    (tlu_ifu_trapnpc_w2),
                 .tlu_ifu_trappc_vld_w1 (tlu_ifu_trappc_vld_w1),
                 .tlu_ifu_trappc_w2     (tlu_ifu_trappc_w2),
                 .tlu_itlb_data_rd_g    (tlu_itlb_data_rd_g),
                 .tlu_itlb_dmp_actxt_g  (tlu_itlb_dmp_actxt_g),
                 .tlu_itlb_dmp_nctxt_g  (tlu_itlb_dmp_nctxt_g),
                 .tlu_itlb_dmp_vld_g    (tlu_itlb_dmp_vld_g),
                 .tlu_itlb_invalidate_all_g(tlu_itlb_invalidate_all_g),
                 .tlu_itlb_tag_rd_g     (tlu_itlb_tag_rd_g),
                 .tlu_itlb_wr_vld_g     (tlu_itlb_wr_vld_g),
                 .tlu_lsu_pstate_am     (tlu_lsu_pstate_am),
                 .tlu_lsu_pstate_priv   (tlu_lsu_pstate_priv),
                 .tlu_lsu_redmode       (tlu_lsu_redmode),

                 .mem_write_disable       (mem_write_disable),
                 .mux_drive_disable       (mux_drive_disable),

                 .tlu_sscan_data    (tlu_sscan_data),
                 .lsu_sscan_data    (lsu_sscan_data),

                 // interface to srams
                 .srams_rtap_data (srams_rtap_data),
                 .rtap_srams_bist_command (rtap_srams_bist_command),
                 .rtap_srams_bist_data (rtap_srams_bist_data),

                 .config_dtu_esl_en     (config_dtu_esl_en),
                 .config_dtu_esl_sync_method (config_dtu_esl_sync_method),
                 .config_esl_lfsr_seed (config_esl_lfsr_seed),
                 .config_esl_lfsr_ld (config_esl_lfsr_ld),
                 .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
                 .config_esl_counter_timeout (config_esl_counter_timeout),

    .core_rtap_data          (core_rtap_data),
    .rtap_core_val         (rtap_core_val),
    .rtap_core_threadid         (rtap_core_threadid),
    .rtap_core_id         (rtap_core_id),
    .rtap_core_data         ({{(94-48){1'bx}}, rtap_core_data_47_0})


                 ); 

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Description:
//    The instruction fetch unit (IFU) contains the icache, ifq and
//    fetch dp.
*/

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting












// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module sparc_ifu (/*AUTOARG*/
   // Outputs
   
   ifu_lsu_pcxcsm_e,
   


   // sram wrapper interface
   rtap_srams_bist_command,
   rtap_srams_bist_data,
   srams_rtap_data,
   
   // mbist_icache_fail, mbist_done,
   // mbist_dcache_write, mbist_dcache_word, mbist_dcache_way,
   // mbist_dcache_read, mbist_dcache_index, mbist_dcache_fail,


   ifu_tlu_ttype_m, ifu_tlu_trap_m, ifu_tlu_thrid_e, ifu_tlu_thrid_d,
   ifu_tlu_sraddr_d_v2, ifu_tlu_sraddr_d, ifu_tlu_sir_inst_m,
   ifu_tlu_sftint_m, ifu_tlu_rstint_m, ifu_tlu_rsr_inst_d,
   ifu_tlu_retry_inst_d, ifu_tlu_priv_violtn_m, ifu_tlu_pc_oor_e,
   ifu_tlu_pc_m, ifu_tlu_npc_m, ifu_tlu_mb_inst_e, ifu_tlu_l2imiss,
   ifu_tlu_itlb_done, ifu_tlu_inst_vld_m, ifu_tlu_immu_miss_m,
   ifu_tlu_imm_asi_d, ifu_tlu_icmiss_e, ifu_tlu_hwint_m,
   ifu_tlu_flush_m, ifu_tlu_flsh_inst_e, ifu_tlu_done_inst_d,
   ifu_tlu_alt_space_d, ifu_spu_trap_ack, ifu_spu_nceen,
   ifu_spu_inst_vld_w, ifu_mmu_trap_m, ifu_lsu_wsr_inst_d,
   ifu_lsu_swap_e, ifu_lsu_st_inst_e, ifu_lsu_sign_ext_e,
   ifu_lsu_rd_e, ifu_lsu_pref_inst_e, ifu_lsu_pcxreq_d,
   ifu_lsu_pcxpkt_e, ifu_lsu_nceen, ifu_lsu_memref_d,
   ifu_lsu_ldxa_tid_w2, ifu_lsu_ldxa_illgl_va_w2,
   ifu_lsu_ldxa_data_w2, ifu_lsu_ldxa_data_vld_w2, ifu_lsu_ldstub_e,
   ifu_lsu_ldst_size_e, ifu_lsu_ldst_fp_e, ifu_lsu_ldst_dbl_e,
   ifu_lsu_ld_inst_e, ifu_lsu_inv_clear, ifu_lsu_imm_asi_vld_d,
   ifu_lsu_imm_asi_d, ifu_lsu_ibuf_busy, ifu_lsu_fwd_wr_ack,
   ifu_lsu_fwd_data_vld, ifu_lsu_error_inj, ifu_lsu_destid_s,
   ifu_lsu_casa_e, ifu_lsu_asi_rd_unc, ifu_lsu_asi_ack,
   ifu_lsu_alt_space_d, ifu_ffu_visop_d, ifu_ffu_stfsr_d,
   ifu_ffu_quad_op_e, ifu_ffu_mvcnd_m, ifu_ffu_ldxfsr_d,
   ifu_ffu_ldst_size_d, ifu_ffu_ldfsr_d, ifu_ffu_inj_frferr,
   ifu_ffu_fst_d, ifu_ffu_frs2_d, ifu_ffu_frs1_d, ifu_ffu_frd_d,
   ifu_ffu_fpopcode_d, ifu_ffu_fpop2_d, ifu_ffu_fpop1_d,
   ifu_ffu_fld_d, ifu_ffu_fcc_num_d, ifu_exu_wsr_inst_d,
   ifu_exu_wen_d, ifu_exu_useimm_d, ifu_exu_usecin_d,
   ifu_exu_use_rsr_e_l, ifu_exu_tv_d, ifu_exu_ttype_vld_m,
   ifu_exu_tid_s2, ifu_exu_tcc_e, ifu_exu_tagop_d, ifu_exu_shiftop_d,
   ifu_exu_sethi_inst_d, ifu_exu_setcc_d, ifu_exu_saved_e,
   ifu_exu_save_d, ifu_exu_rs3o_vld_d, ifu_exu_rs3e_vld_d,
   ifu_exu_rs3_s, ifu_exu_rs2_vld_d, ifu_exu_rs2_s,
   ifu_exu_rs1_vld_d, ifu_exu_rs1_s, ifu_exu_return_d,
   ifu_exu_restored_e, ifu_exu_restore_d, ifu_exu_ren3_s,
   ifu_exu_ren2_s, ifu_exu_ren1_s, ifu_exu_rd_ifusr_e,
   ifu_exu_rd_ffusr_e, ifu_exu_rd_exusr_e, ifu_exu_rd_d,
   ifu_exu_range_check_other_d, ifu_exu_range_check_jlret_d,
   ifu_exu_pcver_e, ifu_exu_pc_d, ifu_exu_nceen_e, ifu_exu_muls_d,
   ifu_exu_kill_e, ifu_exu_invert_d, ifu_exu_inst_vld_w,
   ifu_exu_inst_vld_e, ifu_exu_inj_irferr, ifu_exu_imm_data_d,
   ifu_exu_ialign_d, ifu_exu_flushw_e, ifu_exu_enshift_d,
   ifu_exu_ecc_mask, ifu_exu_dontmv_regz1_e, ifu_exu_dontmv_regz0_e,
   ifu_exu_disable_ce_e, ifu_exu_dbrinst_d, ifu_exu_casa_d,
   ifu_exu_aluop_d, ifu_exu_addr_mask_d,
   // so0, short_so0, short_so1,
   ifu_tlu_inst_vld_w, ifu_tlu_flush_w, ifu_lsu_alt_space_e,
   ifu_tlu_ttype_vld_m, ifu_exu_muldivop_d, ifu_lsu_thrid_s,
   // mbist_write_data,
   // Inputs
   
   tlu_itlb_csm_rd_g, tlu_itlb_tte_csm_w2,
   tlu_itlb_wr_csm_sel_g,

   cfg_ifu_csm_itlb_state, cfg_ifu_csm_itlb_chipid,cfg_ifu_csm_itlb_x,
   cfg_ifu_csm_itlb_y, cfg_ifu_csm_itlb_hdid,cfg_ifu_csm_itlb_hd_size,
   cfg_ifu_csm_itlb_sdid,cfg_ifu_csm_itlb_lsid,

   

   tlu_lsu_redmode, tlu_lsu_pstate_priv, tlu_lsu_pstate_am,
   tlu_itlb_wr_vld_g, tlu_itlb_tag_rd_g, tlu_itlb_invalidate_all_g,
   tlu_itlb_dmp_vld_g, tlu_itlb_dmp_nctxt_g, tlu_itlb_dmp_actxt_g,
   tlu_itlb_data_rd_g, tlu_ifu_trappc_w2, tlu_ifu_trappc_vld_w1,
   tlu_ifu_trapnpc_w2, tlu_ifu_trapnpc_vld_w1, tlu_ifu_trap_tid_w1,
   tlu_ifu_sftint_vld, tlu_ifu_rstthr_i2, tlu_ifu_rstint_i2,
   tlu_ifu_resumint_i2, tlu_ifu_rerr_vld, tlu_ifu_pstate_pef,
   tlu_ifu_pstate_ie, tlu_ifu_nukeint_i2, tlu_ifu_hwint_i3,
   tlu_ifu_hintp_vld, tlu_ifu_flush_pipe_w, tlu_idtlb_dmp_thrid_g,
   tlu_hpstate_priv, tlu_hpstate_ibe, tlu_hpstate_enb, 
   // testmode_l,
   spu_ifu_unc_err_w1, spu_ifu_ttype_w2, spu_ifu_ttype_vld_w2,
   spu_ifu_ttype_tid_w2, spu_ifu_mamem_err_w1, spu_ifu_int_w2,
   spu_ifu_err_addr_w2, spu_ifu_corr_err_w2, sehold, se, rclk,

   // mbist_userdata_mode, mbist_stop_on_next_fail, mbist_stop_on_fail,
   // mbist_start, mbist_loop_on_address, mbist_loop_mode,
   // mbist_dcache_data_in, mbist_bisi_mode, 

   lsu_t3_pctxt_state, lsu_t2_pctxt_state, lsu_t1_pctxt_state, lsu_t0_pctxt_state,
   lsu_pid_state3, lsu_pid_state2, lsu_pid_state1, lsu_pid_state0,
   lsu_ifu_t3_tlz, lsu_ifu_t2_tlz, lsu_ifu_t1_tlz, lsu_ifu_t0_tlz,
   lsu_ifu_stxa_data, lsu_ifu_stbcnt3, lsu_ifu_stbcnt2,
   lsu_ifu_stbcnt1, lsu_ifu_stbcnt0, lsu_ifu_stallreq,
   lsu_ifu_quad_asi_e, lsu_ifu_pcxpkt_ack_d,
   lsu_ifu_ldsta_internal_e, lsu_ifu_ldst_miss_g, lsu_ifu_ldst_cmplt,
   lsu_ifu_ld_pcxpkt_vld, lsu_ifu_ld_pcxpkt_tid,
   lsu_ifu_ld_icache_index, lsu_ifu_l2_unc_error,
   lsu_ifu_l2_corr_error, lsu_ifu_io_error, lsu_ifu_inj_ack,
   lsu_ifu_icache_en, lsu_ifu_error_tid, lsu_ifu_err_addr,
   lsu_ifu_dtlb_tag_ue, lsu_ifu_dtlb_data_ue, lsu_ifu_dtlb_data_su,
   lsu_ifu_direct_map_l1, lsu_ifu_dcache_tag_perror,
   lsu_ifu_dcache_data_perror, lsu_ifu_dc_parity_error_w2,
   lsu_ifu_cpxpkt_i1, lsu_ifu_asi_vld, lsu_ifu_asi_thrid,
   lsu_ifu_asi_state, lsu_ifu_asi_load, lsu_ifu_asi_addr,
   lsu_ifu_addr_real_l, grst_l, gdbginit_l, ffu_ifu_tid_w2,
   ffu_ifu_stallreq, ffu_ifu_inj_ack, ffu_ifu_fst_ce_w,
   ffu_ifu_fpop_done_w2, ffu_ifu_err_synd_w2, ffu_ifu_err_reg_w2,
   ffu_ifu_ecc_ue_w2, ffu_ifu_ecc_ce_w2, ffu_ifu_cc_w2,
   ffu_ifu_cc_vld_w2, exu_ifu_va_oor_m, exu_ifu_spill_e,
   exu_ifu_regz_e, exu_ifu_regn_e, exu_ifu_oddwin_s,
   exu_ifu_longop_done_g, exu_ifu_inj_ack, exu_ifu_err_synd_m,
   exu_ifu_err_reg_m, exu_ifu_ecc_ue_m, exu_ifu_ecc_ce_m,
   exu_ifu_cc_d, exu_ifu_brpc_e, 
   // efc_spc_ifuse_dshift,
   // efc_spc_ifuse_data, efc_spc_ifuse_ashift, efc_spc_fuse_clk2,
   // efc_spc_fuse_clk1,
   const_maskid, const_cpuid, arst_l,
   mem_write_disable, mux_drive_disable, exu_tlu_wsr_data_m,
   lsu_ictag_mrgn, lsu_idtlb_mrgn, 
   // si0, short_si0, short_si1,
   tlu_itlb_tte_tag_w2, tlu_itlb_tte_data_w2,
   tlu_itlb_rw_index_vld_g, tlu_itlb_rw_index_g, tlu_idtlb_dmp_key_g,
   tlu_itlb_dmp_all_g, lsu_sscan_data, tlu_sscan_data,
   config_dtu_esl_en, config_dtu_esl_sync_method,
   config_esl_lfsr_seed, config_esl_lfsr_ld, config_esl_pc_diff_thresh,
   config_esl_counter_timeout,

   // trin
   core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data


   );


   input [2:0] 	  exu_tlu_wsr_data_m;
   input [3:0]    lsu_ictag_mrgn;
   input [7:0]    lsu_idtlb_mrgn;

   // eco 5362
   output         ifu_exu_addr_mask_d;


   // scan ports

   // trin: removing scan ports
   // input                si0, short_si0,short_si1;
   // output               so0,short_so0,short_so1;
   wire si0 = 1'b0;
   wire short_si0 = 1'b0;
   wire short_si1 = 1'b0;
   wire so0,short_so0,short_so1;

   output         ifu_tlu_inst_vld_w;	// From fcl of sparc_ifu_fcl.v
   output         ifu_tlu_flush_w;	  // From fcl of sparc_ifu_fcl.v
   output         ifu_lsu_alt_space_e;    // From dec of sparc_ifu_dec.v
   output         ifu_tlu_ttype_vld_m;// From fcl of sparc_ifu_fcl.v
   output [4:0]   ifu_exu_muldivop_d;
   output [1:0]   ifu_lsu_thrid_s;

   // itlb inputs
   input [58:0]   tlu_itlb_tte_tag_w2;
   input [42:0]   tlu_itlb_tte_data_w2;
   input          tlu_itlb_rw_index_vld_g;
   input [5:0]    tlu_itlb_rw_index_g;
   input [40:0]   tlu_idtlb_dmp_key_g;
   input          tlu_itlb_dmp_all_g;

   // sscan rename
   input [15:0]   lsu_sscan_data;
   input [62:0]   tlu_sscan_data;

   // output [7:0]   mbist_write_data;     // From mbist of sparc_ifu_mbist.v

   /*AUTOINPUT*/
   // Beginning of automatic inputs (from unused autoinst inputs)
   input                arst_l;                 // To swl of sparc_ifu_swl.v, ...
   input [3:0]          const_cpuid;            // To swl of sparc_ifu_swl.v, ...
   input [7:0]          const_maskid;           // To fdp of sparc_ifu_fdp.v
   // input                rtap_sscan_se;           // To sscan of sparc_ifu_sscan.v
   // input                ctu_tck;                // To sscan of sparc_ifu_sscan.v

   input [47:0]         exu_ifu_brpc_e;         // To fdp of sparc_ifu_fdp.v
   input [7:0]          exu_ifu_cc_d;           // To dcl of sparc_ifu_dcl.v
   input                exu_ifu_ecc_ce_m;       // To fcl of sparc_ifu_fcl.v, ...
   input                exu_ifu_ecc_ue_m;       // To errctl of sparc_ifu_errctl.v
   input [7:0]          exu_ifu_err_reg_m;      // To errdp of sparc_ifu_errdp.v
   input [7:0]          exu_ifu_err_synd_m;     // To errdp of sparc_ifu_errdp.v
   input                exu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input [3:0]          exu_ifu_longop_done_g;  // To swl of sparc_ifu_swl.v
   input [3:0]          exu_ifu_oddwin_s;       // To fcl of sparc_ifu_fcl.v
   input                exu_ifu_regn_e;         // To dcl of sparc_ifu_dcl.v
   input                exu_ifu_regz_e;         // To fcl of sparc_ifu_fcl.v
   input                exu_ifu_spill_e;        // To swl of sparc_ifu_swl.v
   input                exu_ifu_va_oor_m;       // To fcl of sparc_ifu_fcl.v
   input [3:0]          ffu_ifu_cc_vld_w2;      // To dcl of sparc_ifu_dcl.v
   input [7:0]          ffu_ifu_cc_w2;          // To dcl of sparc_ifu_dcl.v
   input                ffu_ifu_ecc_ce_w2;      // To errctl of sparc_ifu_errctl.v
   input                ffu_ifu_ecc_ue_w2;      // To errctl of sparc_ifu_errctl.v
   input [5:0]          ffu_ifu_err_reg_w2;     // To errdp of sparc_ifu_errdp.v
   input [13:0]         ffu_ifu_err_synd_w2;    // To errdp of sparc_ifu_errdp.v
   input                ffu_ifu_fpop_done_w2;   // To swl of sparc_ifu_swl.v
   input                ffu_ifu_fst_ce_w;       // To swl of sparc_ifu_swl.v, ...
   input                ffu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input                ffu_ifu_stallreq;       // To fcl of sparc_ifu_fcl.v
   input [1:0]          ffu_ifu_tid_w2;         // To swl of sparc_ifu_swl.v, ...
   input                gdbginit_l;             // To swl of sparc_ifu_swl.v, ...
   input                grst_l;                 // To swl of sparc_ifu_swl.v, ...
   input [3:0]          lsu_ifu_addr_real_l;    // To fcl of sparc_ifu_fcl.v
   input [17:0]         lsu_ifu_asi_addr;       // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_asi_load;       // To ifqctl of sparc_ifu_ifqctl.v
   input [7:0]          lsu_ifu_asi_state;      // To ifqctl of sparc_ifu_ifqctl.v
   input [1:0]          lsu_ifu_asi_thrid;      // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_asi_vld;        // To ifqctl of sparc_ifu_ifqctl.v
   input [145-1:0]lsu_ifu_cpxpkt_i1;     // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_dc_parity_error_w2;// To swl of sparc_ifu_swl.v, ...
   input                lsu_ifu_dcache_data_perror;// To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dcache_tag_perror;// To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_direct_map_l1;  // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_dtlb_data_su;   // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dtlb_data_ue;   // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_dtlb_tag_ue;    // To errctl of sparc_ifu_errctl.v
   input [47:4]         lsu_ifu_err_addr;       // To errdp of sparc_ifu_errdp.v
   input [1:0]          lsu_ifu_error_tid;      // To errctl of sparc_ifu_errctl.v
   input [3:0]          lsu_ifu_icache_en;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          lsu_ifu_inj_ack;        // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_io_error;       // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_l2_corr_error;  // To errctl of sparc_ifu_errctl.v
   input                lsu_ifu_l2_unc_error;   // To errctl of sparc_ifu_errctl.v
   input [(6 + 5):5] lsu_ifu_ld_icache_index;// To invctl of sparc_ifu_invctl.v
   input [1:0]          lsu_ifu_ld_pcxpkt_tid;  // To invctl of sparc_ifu_invctl.v
   input                lsu_ifu_ld_pcxpkt_vld;  // To invctl of sparc_ifu_invctl.v
   input [3:0]          lsu_ifu_ldst_cmplt;     // To swl of sparc_ifu_swl.v
   input                lsu_ifu_ldst_miss_g;    // To swl of sparc_ifu_swl.v
   input                lsu_ifu_ldsta_internal_e;// To dec of sparc_ifu_dec.v, ...
   input                lsu_ifu_pcxpkt_ack_d;   // To ifqctl of sparc_ifu_ifqctl.v
   input                lsu_ifu_quad_asi_e;     // To swl of sparc_ifu_swl.v
   input                lsu_ifu_stallreq;       // To fcl of sparc_ifu_fcl.v
   input [3:0]          lsu_ifu_stbcnt0;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt1;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt2;        // To swl of sparc_ifu_swl.v
   input [3:0]          lsu_ifu_stbcnt3;        // To swl of sparc_ifu_swl.v
   input [47:0]         lsu_ifu_stxa_data;      // To ifqdp of sparc_ifu_ifqdp.v
   input                lsu_ifu_t0_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t1_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t2_tlz;         // To fcl of sparc_ifu_fcl.v
   input                lsu_ifu_t3_tlz;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state0;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state1;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state2;         // To fcl of sparc_ifu_fcl.v
   input [2:0]          lsu_pid_state3;         // To fcl of sparc_ifu_fcl.v
   input [12:0]         lsu_t0_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t1_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t2_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   input [12:0]         lsu_t3_pctxt_state;     // To fdp of sparc_ifu_fdp.v
   // input                mbist_bisi_mode;        // To mbist of sparc_ifu_mbist.v
   // input [71:0]         mbist_dcache_data_in;   // To mbist of sparc_ifu_mbist.v
   // input                mbist_loop_mode;        // To mbist of sparc_ifu_mbist.v
   // input                mbist_loop_on_address;  // To mbist of sparc_ifu_mbist.v
   // input                mbist_start;            // To mbist of sparc_ifu_mbist.v
   // input                mbist_stop_on_fail;     // To mbist of sparc_ifu_mbist.v
   // input                mbist_stop_on_next_fail;// To mbist of sparc_ifu_mbist.v
   // input                mbist_userdata_mode;    // To mbist of sparc_ifu_mbist.v
   input                rclk;                   // To dec of sparc_ifu_dec.v, ...
   input                se;                     // To dec of sparc_ifu_dec.v, ...
   input                sehold;                 // To fcl of sparc_ifu_fcl.v, ...
   input                spu_ifu_corr_err_w2;    // To errctl of sparc_ifu_errctl.v
   input [39:4]         spu_ifu_err_addr_w2;    // To errdp of sparc_ifu_errdp.v
   input                spu_ifu_int_w2;         // To errctl of sparc_ifu_errctl.v
   input                spu_ifu_mamem_err_w1;   // To errctl of sparc_ifu_errctl.v
   input [1:0]          spu_ifu_ttype_tid_w2;   // To fcl of sparc_ifu_fcl.v, ...
   input                spu_ifu_ttype_vld_w2;   // To fcl of sparc_ifu_fcl.v
   input                spu_ifu_ttype_w2;       // To fcl of sparc_ifu_fcl.v
   input                spu_ifu_unc_err_w1;     // To errctl of sparc_ifu_errctl.v
   input [3:0]          tlu_hpstate_enb;        // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_hpstate_ibe;        // To swl of sparc_ifu_swl.v
   input [3:0]          tlu_hpstate_priv;       // To fcl of sparc_ifu_fcl.v
   input [1:0]          tlu_idtlb_dmp_thrid_g;  // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_flush_pipe_w;   // To swl of sparc_ifu_swl.v, ...
   input [3:0]          tlu_ifu_hintp_vld;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_hwint_i3;       // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_nukeint_i2;     // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_pstate_ie;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_pstate_pef;     // To swl of sparc_ifu_swl.v
   input [3:0]          tlu_ifu_rerr_vld;       // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_resumint_i2;    // To fcl of sparc_ifu_fcl.v
   input                tlu_ifu_rstint_i2;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_rstthr_i2;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_ifu_sftint_vld;     // To fcl of sparc_ifu_fcl.v
   input [1:0]          tlu_ifu_trap_tid_w1;    // To swl of sparc_ifu_swl.v, ...
   input                tlu_ifu_trapnpc_vld_w1; // To fcl of sparc_ifu_fcl.v
   input [48:0]         tlu_ifu_trapnpc_w2;     // To fdp of sparc_ifu_fdp.v
   input                tlu_ifu_trappc_vld_w1;  // To swl of sparc_ifu_swl.v, ...
   input [48:0]         tlu_ifu_trappc_w2;      // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_data_rd_g;     // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_dmp_actxt_g;   // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_dmp_nctxt_g;   // To fdp of sparc_ifu_fdp.v
   input                tlu_itlb_dmp_vld_g;     // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_invalidate_all_g;// To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_tag_rd_g;      // To fcl of sparc_ifu_fcl.v
   input                tlu_itlb_wr_vld_g;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_lsu_pstate_am;      // To fcl of sparc_ifu_fcl.v
   input [3:0]          tlu_lsu_pstate_priv;    // To fcl of sparc_ifu_fcl.v, ...
   input [3:0]          tlu_lsu_redmode;        // To fcl of sparc_ifu_fcl.v
   // End of automatics
   
   input                tlu_itlb_csm_rd_g;
   input [32:0]     tlu_itlb_tte_csm_w2;
   input                tlu_itlb_wr_csm_sel_g;

   input [2-1:0]   cfg_ifu_csm_itlb_state;
   input [14-1:0]      cfg_ifu_csm_itlb_chipid;
   input [8-1:0]           cfg_ifu_csm_itlb_x;
   input [8-1:0]           cfg_ifu_csm_itlb_y;
   input [10-1:0]        cfg_ifu_csm_itlb_hdid;
   input [6-1:0]        cfg_ifu_csm_itlb_hd_size;
   input [10-1:0]        cfg_ifu_csm_itlb_sdid;
   input [6-1:0]        cfg_ifu_csm_itlb_lsid;

   


   input                config_dtu_esl_en;
   input [1:0]          config_dtu_esl_sync_method;
   input [15:0]         config_esl_lfsr_seed;
   input                config_esl_lfsr_ld;
   input [49:0]         config_esl_pc_diff_thresh;
   input [15:0]         config_esl_counter_timeout;


   /*AUTOOUTPUT*/
   // Beginning of automatic outputs (from unused autoinst outputs)
   output [2:0]         ifu_exu_aluop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_casa_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_dbrinst_d;      // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_disable_ce_e;   // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_dontmv_regz0_e; // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_dontmv_regz1_e; // From dcl of sparc_ifu_dcl.v
   output [7:0]         ifu_exu_ecc_mask;       // From errctl of sparc_ifu_errctl.v
   output               ifu_exu_enshift_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_flushw_e;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_ialign_d;       // From dec of sparc_ifu_dec.v
   output [31:0]        ifu_exu_imm_data_d;     // From imd of sparc_ifu_imd.v
   output               ifu_exu_inj_irferr;     // From errctl of sparc_ifu_errctl.v
   output               ifu_exu_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_inst_vld_w;     // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_invert_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_kill_e;         // From dcl of sparc_ifu_dcl.v
   output               ifu_exu_muls_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_nceen_e;        // From errctl of sparc_ifu_errctl.v
   output [47:0]        ifu_exu_pc_d;           // From fdp of sparc_ifu_fdp.v
   output [63:0]        ifu_exu_pcver_e;        // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_range_check_jlret_d;// From dec of sparc_ifu_dec.v
   output               ifu_exu_range_check_other_d;// From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rd_d;           // From imd of sparc_ifu_imd.v
   output               ifu_exu_rd_exusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rd_ffusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rd_ifusr_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_ren1_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ren2_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ren3_s;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_restore_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_restored_e;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_return_d;       // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs1_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs1_vld_d;      // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs2_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs2_vld_d;      // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_exu_rs3_s;          // From fdp of sparc_ifu_fdp.v
   output               ifu_exu_rs3e_vld_d;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_rs3o_vld_d;     // From dec of sparc_ifu_dec.v
   output               ifu_exu_save_d;         // From dec of sparc_ifu_dec.v
   output               ifu_exu_saved_e;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_setcc_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_sethi_inst_d;   // From dec of sparc_ifu_dec.v
   output [2:0]         ifu_exu_shiftop_d;      // From dec of sparc_ifu_dec.v
   output               ifu_exu_tagop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_exu_tcc_e;          // From dcl of sparc_ifu_dcl.v
   output [1:0]         ifu_exu_tid_s2;         // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_ttype_vld_m;    // From fcl of sparc_ifu_fcl.v
   output               ifu_exu_tv_d;           // From dec of sparc_ifu_dec.v
   output               ifu_exu_use_rsr_e_l;    // From dec of sparc_ifu_dec.v
   output               ifu_exu_usecin_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_useimm_d;       // From dec of sparc_ifu_dec.v
   output               ifu_exu_wen_d;          // From dec of sparc_ifu_dec.v
   output               ifu_exu_wsr_inst_d;     // From dec of sparc_ifu_dec.v
   output [1:0]         ifu_ffu_fcc_num_d;      // From imd of sparc_ifu_imd.v
   output               ifu_ffu_fld_d;          // From dec of sparc_ifu_dec.v
   output               ifu_ffu_fpop1_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_fpop2_d;        // From dec of sparc_ifu_dec.v
   output [8:0]         ifu_ffu_fpopcode_d;     // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frd_d;          // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frs1_d;         // From imd of sparc_ifu_imd.v
   output [4:0]         ifu_ffu_frs2_d;         // From imd of sparc_ifu_imd.v
   output               ifu_ffu_fst_d;          // From dec of sparc_ifu_dec.v
   output               ifu_ffu_inj_frferr;     // From errctl of sparc_ifu_errctl.v
   output               ifu_ffu_ldfsr_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_ldst_size_d;    // From dec of sparc_ifu_dec.v
   output               ifu_ffu_ldxfsr_d;       // From dec of sparc_ifu_dec.v
   output               ifu_ffu_mvcnd_m;        // From dcl of sparc_ifu_dcl.v
   output               ifu_ffu_quad_op_e;      // From dec of sparc_ifu_dec.v
   output               ifu_ffu_stfsr_d;        // From dec of sparc_ifu_dec.v
   output               ifu_ffu_visop_d;        // From dec of sparc_ifu_dec.v
   output               ifu_lsu_alt_space_d;    // From dec of sparc_ifu_dec.v
   output               ifu_lsu_asi_ack;        // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_asi_rd_unc;     // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_casa_e;         // From dec of sparc_ifu_dec.v
   output [2:0]         ifu_lsu_destid_s;       // From ifqctl of sparc_ifu_ifqctl.v
   output [3:0]         ifu_lsu_error_inj;      // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_fwd_data_vld;   // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_fwd_wr_ack;     // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_ibuf_busy;      // From ifqctl of sparc_ifu_ifqctl.v
   output [7:0]         ifu_lsu_imm_asi_d;      // From imd of sparc_ifu_imd.v
   output               ifu_lsu_imm_asi_vld_d;  // From imd of sparc_ifu_imd.v
   output               ifu_lsu_inv_clear;      // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_ld_inst_e;      // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldst_dbl_e;     // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldst_fp_e;      // From dec of sparc_ifu_dec.v
   output [1:0]         ifu_lsu_ldst_size_e;    // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldstub_e;       // From dec of sparc_ifu_dec.v
   output               ifu_lsu_ldxa_data_vld_w2;// From errctl of sparc_ifu_errctl.v
   output [63:0]        ifu_lsu_ldxa_data_w2;   // From errdp of sparc_ifu_errdp.v
   output               ifu_lsu_ldxa_illgl_va_w2;// From ifqctl of sparc_ifu_ifqctl.v
   output [1:0]         ifu_lsu_ldxa_tid_w2;    // From errctl of sparc_ifu_errctl.v
   output               ifu_lsu_memref_d;       // From dec of sparc_ifu_dec.v
   output [3:0]         ifu_lsu_nceen;          // From errctl of sparc_ifu_errctl.v
   output [51:0]        ifu_lsu_pcxpkt_e;       // From ifqdp of sparc_ifu_ifqdp.v
   output               ifu_lsu_pcxreq_d;       // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_lsu_pref_inst_e;    // From dec of sparc_ifu_dec.v
   output [4:0]         ifu_lsu_rd_e;           // From imd of sparc_ifu_imd.v
   output               ifu_lsu_sign_ext_e;     // From dec of sparc_ifu_dec.v
   output               ifu_lsu_st_inst_e;      // From dec of sparc_ifu_dec.v
   output               ifu_lsu_swap_e;         // From dec of sparc_ifu_dec.v
   output               ifu_lsu_wsr_inst_d;     // From dec of sparc_ifu_dec.v
   output               ifu_mmu_trap_m;         // From fcl of sparc_ifu_fcl.v
   output               ifu_spu_inst_vld_w;     // From fcl of sparc_ifu_fcl.v
   output [3:0]         ifu_spu_nceen;          // From errctl of sparc_ifu_errctl.v
   output               ifu_spu_trap_ack;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_alt_space_d;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_done_inst_d;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_flsh_inst_e;    // From dec of sparc_ifu_dec.v
   output               ifu_tlu_flush_m;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_hwint_m;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_icmiss_e;       // From fcl of sparc_ifu_fcl.v
   output [8:0]         ifu_tlu_imm_asi_d;      // From imd of sparc_ifu_imd.v
   output               ifu_tlu_immu_miss_m;    // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_inst_vld_m;     // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_itlb_done;      // From fcl of sparc_ifu_fcl.v
   output [3:0]         ifu_tlu_l2imiss;        // From ifqctl of sparc_ifu_ifqctl.v
   output               ifu_tlu_mb_inst_e;      // From dec of sparc_ifu_dec.v
   output [48:0]        ifu_tlu_npc_m;          // From fdp of sparc_ifu_fdp.v
   output [48:0]        ifu_tlu_pc_m;           // From fdp of sparc_ifu_fdp.v
   output               ifu_tlu_pc_oor_e;       // From fdp of sparc_ifu_fdp.v
   output               ifu_tlu_priv_violtn_m;  // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_retry_inst_d;   // From dec of sparc_ifu_dec.v
   output               ifu_tlu_rsr_inst_d;     // From dec of sparc_ifu_dec.v
   output               ifu_tlu_rstint_m;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_sftint_m;       // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_sir_inst_m;     // From dec of sparc_ifu_dec.v
   output [6:0]         ifu_tlu_sraddr_d;       // From imd of sparc_ifu_imd.v
   output [6:0]         ifu_tlu_sraddr_d_v2;    // From imd of sparc_ifu_imd.v
   output [1:0]         ifu_tlu_thrid_d;        // From fcl of sparc_ifu_fcl.v
   output [1:0]         ifu_tlu_thrid_e;        // From fcl of sparc_ifu_fcl.v
   output               ifu_tlu_trap_m;         // From fcl of sparc_ifu_fcl.v
   output [8:0]         ifu_tlu_ttype_m;        // From fcl of sparc_ifu_fcl.v
   // End of automatics
   
   output [32:0]     ifu_lsu_pcxcsm_e;       // From ifqdp of sparc_ifu_ifqdp.v
   

   /*AUTOWIRE*/
   // Beginning of automatic wires (for undeclared instantiated-module outputs)
   wire                 dcl_fcl_bcregz0_e;      // From dcl of sparc_ifu_dcl.v
   wire                 dcl_fcl_bcregz1_e;      // From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_bcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_bpcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_br_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_broff_sel_call_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immbr_sel_br_d; // From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_movcc_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_movr_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_sethi_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_imd_immdata_sel_simm13_d_l;// From dcl of sparc_ifu_dcl.v
   wire                 dcl_swl_tcc_done_m;     // From dcl of sparc_ifu_dcl.v
   wire                 dcl_esl_br_inst_d;
   wire                 dcl_esl_br_inst_e;
   wire [2:0]           dec_dcl_cctype_d;       // From dec of sparc_ifu_dec.v
   wire                 dec_fcl_rdsr_sel_pc_d;  // From dec of sparc_ifu_dec.v
   wire                 dec_fcl_rdsr_sel_thr_d; // From dec of sparc_ifu_dec.v
   wire                 dec_imd_call_inst_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_allfp_d;        // From dec of sparc_ifu_dec.v
   wire                 dec_swl_br_done_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_div_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_fpop_d;         // From dec of sparc_ifu_dec.v
   wire                 dec_swl_frf_lower_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_frf_upper_d;    // From dec of sparc_ifu_dec.v
   wire                 dec_swl_ld_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_ll_done_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_mul_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_rdsr_sel_thr_d; // From dec of sparc_ifu_dec.v
   wire                 dec_swl_st_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_sta_inst_e;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_std_inst_d;     // From dec of sparc_ifu_dec.v
   wire                 dec_swl_wrt_tcr_w;      // From dec of sparc_ifu_dec.v
   wire                 dec_swl_wrtfprs_w;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_br_inst_d;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_flush_sonly_e;  // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_fpdis_e;        // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_illinst_e;      // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_imask_hit_e;    // From dec of sparc_ifu_dec.v
   wire [3:0]           dtu_fcl_nextthr_bf;     // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_ntr_s;          // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_privop_e;       // From dec of sparc_ifu_dec.v
   wire                 dtu_fcl_retract_d;      // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_rollback_g;     // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_running_s;      // From swl of sparc_ifu_swl.v
   wire                 dtu_fcl_sir_inst_e;     // From dec of sparc_ifu_dec.v
   wire [3:0]           dtu_fcl_thr_active;     // From swl of sparc_ifu_swl.v
   wire [40:0]          dtu_fdp_thrconf_e;      // From swl of sparc_ifu_swl.v
   wire                 dtu_ifq_kill_latest_d;  // From dec of sparc_ifu_dec.v
   wire                 dtu_inst_anull_e;       // From dcl of sparc_ifu_dcl.v
   wire [31:0]          dtu_inst_d;             // From imd of sparc_ifu_imd.v
   wire                 dtu_reset;              // From swl of sparc_ifu_swl.v
   wire                 esl_fcl_stall_bf;       // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_switch_bf;      // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fdp_sync_pcs_bf;    // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_ntr_s;          // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fdp_issue_prev_inst_s; // From swl (esl) of sparc_ifu_swl.v
   wire                 esl_fcl_force_running_s;
   wire                 erb_dtu_ifeterr_d1;     // From errctl of sparc_ifu_errctl.v
   wire [38:0]          erb_dtu_imask;          // From errdp of sparc_ifu_errdp.v
   wire [3:0]           erb_fcl_ce_trapvec;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_ifet_uevec_d1;  // From errctl of sparc_ifu_errctl.v
   wire                 erb_fcl_itlb_ce_d1;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_spu_uetrap;     // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erb_fcl_ue_trapvec;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_ifq_ifeterr_d1;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_ifq_itlberr_s1;     // From errctl of sparc_ifu_errctl.v
   wire                 erb_reset;              // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_asi_thr_l;      // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_err_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_icd_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_itlb_s_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_asisrc_sel_misc_s_l;// From errctl of sparc_ifu_errctl.v
   wire [2-1:0]           erc_erd_asiway_s1_l;    // From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_frf_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_irf_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_itlb_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr0_sel_lsu_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_l1pa_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_l2pa_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_other_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr1_sel_pcd1_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_mx0_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_mx1_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_old_l;// From errctl of sparc_ifu_errctl.v
   wire [3:0]           erc_erd_eadr2_sel_wrt_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_addr_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_en_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_inj_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_errasi_sel_stat_l;// From errctl of sparc_ifu_errctl.v
   wire [1:0]           erc_erd_erren_asidata;  // From errctl of sparc_ifu_errctl.v
   wire [31:0]          erc_erd_errinj_asidata; // From errctl of sparc_ifu_errctl.v
   wire [22:0]          erc_erd_errstat_asidata;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_ld_imask;       // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_ict_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_imask_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_miscasi_sel_other_l;// From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_pgsz_b0;        // From errctl of sparc_ifu_errctl.v
   wire                 erc_erd_pgsz_b1;        // From errctl of sparc_ifu_errctl.v
   wire                 erd_erc_fetpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire                 erd_erc_nirpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire [3:0]           erd_erc_tagpe_s1;       // From errdp of sparc_ifu_errdp.v
   wire [1:0]           erd_erc_tlbd_pe_s1;     // From errdp of sparc_ifu_errdp.v
   wire [1:0]           erd_erc_tlbt_pe_s1;     // From errdp of sparc_ifu_errdp.v
   wire [2:0]           erd_erc_tte_pgsz;       // From errdp of sparc_ifu_errdp.v
   wire                 fcl_dcl_regz_e;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dec_dslot_s;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dec_intr_vld_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_ely_inst_vld_d; // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_hprivmode_d;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_hprivmode_w2;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_inst_vld_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_intr_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_nuke_thr_w;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_privmode_d;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_resum_thr_w;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_rst_thr_w;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_stall_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_sync_intr_d;    // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_dtu_thr_f;          // From fcl of sparc_ifu_fcl.v
   wire                 fcl_dtu_tlzero_d;       // From fcl of sparc_ifu_fcl.v
   wire [1:0]           fcl_erb_asi_tid_f;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_erb_clear_iferr;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_ievld_s1;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_immuevld_s1;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_inst_issue_d;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_inst_vld_d1;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_itlbrd_data_s;  // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_itlbrd_vld_s;   // From fcl of sparc_ifu_fcl.v
   wire                 fcl_erb_tevld_s1;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_curr_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_dmp_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_ctxt_sel_sw_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_dmpthr_l;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_curr_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_nir_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_nop_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_inst_sel_switch_s_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_mask32b_f;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_next_ctxt_bf_l; // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_next_thr_bf_l;  // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcd_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pce_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcf_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nextpcs_sel_pcs_f_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_nirthr_s1_l;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_inc_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_old_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_noswpc_sel_tnpc_l_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_oddwin_s;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_br_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_nosw_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcbf_sel_swpc_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_pcoor_f;        // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_pcoor_vec_f;    // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_rbinst_sel_inste_s;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_pc_e_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_thr_e_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_rdsr_sel_ver_e_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tctxt_sel_prim; // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thr_s1_l;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thr_s2_l;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_npcw_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_old_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_pcf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_thrtnpc_sel_tnpc_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_curr_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_ifq_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_old_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tinst_sel_rb_s_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_brpc_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_old_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_pcp4_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_tpcbf_sel_trap_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_err_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_pcs_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_rb_bf_l;// From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_fdp_trrbpc_sel_trap_bf_l;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_usenir_sel_nir_s1;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_index_sel_ifq_bf;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_rdreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icd_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ict_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icv_rdreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_icv_wrreq_bf;       // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_ifq_canthr;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_grant_bf;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_icache_en_s_l;  // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_icmiss_s1;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_ifq_rdreq_s1;       // From fcl of sparc_ifu_fcl.v
   wire [1:0]           fcl_ifq_thr_s1;         // From fcl of sparc_ifu_fcl.v
   wire                 fcl_imd_oddwin_d;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_flush_w;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_flush_wake_w;   // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_swl_int_activate_i3;// From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_swcvld_s;       // From fcl of sparc_ifu_fcl.v
   wire                 fcl_swl_swout_f;        // From fcl of sparc_ifu_fcl.v
   wire                 fcl_fdp_tlbmiss_s1;     // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_tinst_vld_next_s; // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_brtaken_e;      // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_brtaken_m;      // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_e;          // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_m;          // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_inst_vld_d;
   wire                 fcl_esl_inst_vld_e;     // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_inst_vld_m;     // From fcl of sparc_ifu_fcl.v
   wire [3:0]           fcl_esl_thr_trap_bf;    // From fcl of sparc_ifu_fcl.v
   wire                 fcl_esl_rb_stg_s;  // From fcl of sparc_ifu_fcl.v
   wire [31:0]          fdp_dtu_inst_s;         // From fdp of sparc_ifu_fdp.v
   wire [47:0]          fdp_erb_pc_f;           // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_ibit_s;         // From fdp of sparc_ifu_fdp.v
   wire [5:2]           fdp_fcl_op3_s;          // From fdp of sparc_ifu_fdp.v
   wire [1:0]           fdp_fcl_op_s;           // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_pc_oor_e;       // From fdp of sparc_ifu_fdp.v
   wire [3:0]           fdp_fcl_pc_oor_vec_f;   // From fdp of sparc_ifu_fdp.v
   wire                 fdp_fcl_swc_s2;         // From fdp of sparc_ifu_fdp.v
   wire [32:0]          fdp_esl_t0inst_next_s2; // From fdp of sparc_ifu_fdp.v

   wire [32:0]          fdp_esl_t1inst_next_s2; // From fdp of sparc_ifu_fdp.v














   wire [39:2]          fdp_esl_t0inst_paddr_next_s2; // From fdp of sparc_ifu_fdp.v

   wire [39:2]          fdp_esl_t1inst_paddr_next_s2; // From fdp of sparc_ifu_fdp.v














   wire [48:0]          fdp_esl_t0pc_next_s2;   // From fdp of sparc_ifu_fdp.v

   wire [48:0]          fdp_esl_t1pc_next_s2;   // From fdp of sparc_ifu_fdp.v














   wire [3:0]           fdp_esl_brtrp_target_pc_bf_f;
   wire [(6 + 5):5]          fdp_icv_index_bf;       // From fdp of sparc_ifu_fdp.v

   wire [1:0]           icd_fuse_repair_en;     // From icd of bw_r_icd.v
   assign icd_fuse_repair_en = 2'b0;
   wire [7:0]           icd_fuse_repair_value;  // From icd of bw_r_icd.v
   assign icd_fuse_repair_value = 8'bx;
   wire                 fdp_fcl_jtag_breakpoint_hit;

   wire [135:0]         icd_wsel_fetdata_s1;    // From icd of bw_r_icd.v
   wire [135:0]         icd_wsel_topdata_s1;    // From icd of bw_r_icd.v
   wire [3:0]           icv_itlb_valid_f;       // From icv of sram_l1i_val.v
   wire                 ifc_ifd_addr_sel_asi_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_bist_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_fill_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_addr_sel_old_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_errinv_e;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_filladdr4_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_finst_sel_l;    // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_idx_sel_fwd_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_en_l;    // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_asi_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_fwd_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_inq_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ifqbyp_sel_lsu_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_ld_inq_i1;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_ldmil_sel_new;  // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_milfill_sel_i2_l;// From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifc_ifd_milreq_sel_d_l; // From ifqctl of sparc_ifu_ifqctl.v
   wire [4:2]           ifc_ifd_pcxline_adj_d;  // From ifqctl of sparc_ifu_ifqctl.v
   wire [0:0]           ifc_ifd_repway_s;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_reqvalid_e;     // From ifqctl of sparc_ifu_ifqctl.v
   wire [1:0]           ifc_ifd_thrid_e;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_ifd_uncached_e;     // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_inv_asireq_i2;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifc_inv_ifqadv_i2;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifd_ifc_4bpkt_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_asi_vachklo_i2; // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:2]           ifd_ifc_asiaddr_i2;     // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxce_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxms_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxnc_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [(143 - 140 + 1):0]ifd_ifc_cpxreq_i1;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_cpxreq_nxt;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_cpxthr_nxt;     // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxue_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_cpxvld_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid0;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid1;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid2;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_destid3;        // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_fwd2ic_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset0;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset1;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset2;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifd_ifc_instoffset3;    // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifd_ifc_iobpkt_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_miladdr4_i2;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifd_ifc_milhit_s;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [2:0]           ifd_ifc_newdestid_s;    // From ifqdp of sparc_ifu_ifqdp.v
   wire [4:2]           ifd_ifc_pcxline_d;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [145-1:0]ifd_inv_ifqop_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [0:0]           ifd_inv_wrway_i2;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [39:2]          ifq_fdp_fill_paddr;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifq_dtu_pred_rdy;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifq_dtu_thrrdy;         // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_erraddr_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_erren_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_errinj_i2;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_errstat_i2; // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_asi_imask_i2;   // From ifqctl of sparc_ifu_ifqctl.v
   wire [47:0]          ifq_erb_asidata_i2;     // From ifqdp of sparc_ifu_ifqdp.v
   wire [0:0]           ifq_erb_asiway_f;       // From invctl of sparc_ifu_invctl.v
   wire                 ifq_erb_asiwr_i2;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ce_rep;         // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_fwdrd_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ifet_ce;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_io_ue;          // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_l2_ue;          // From ifqctl of sparc_ifu_ifqctl.v
   wire [1:0]           ifq_erb_l2err_tid;      // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_rdinst_f;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_rdtag_f;        // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_erb_ue_rep;         // From ifqctl of sparc_ifu_ifqctl.v
   wire [(6 + 5):4]  ifq_erb_wrindex_f;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [1:0]           ifq_fcl_asi_tid_bf;     // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_asird_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [3:0]           ifq_fcl_fill_thr;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_flush_sonly_e;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_icd_wrreq_bf;   // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_ictv_wrreq_bf;  // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_invreq_bf;      // From invctl of sparc_ifu_invctl.v
   wire                 ifq_fcl_rdreq_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_stallreq;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_fcl_wrreq_bf;       // From ifqctl of sparc_ifu_ifqctl.v
   wire [32:0]          ifq_fdp_fill_inst;      // From ifqdp of sparc_ifu_ifqdp.v
   wire                 ifq_icd_data_sel_bist_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_icd_data_sel_fill_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire                 ifq_icd_data_sel_old_i2;// From ifqctl of sparc_ifu_ifqctl.v
   wire [(6 + 5):2]  ifq_icd_index_bf;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [3:0]           ifq_icd_worden_bf;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [135:0]         ifq_icd_wrdata_i2;      // From ifqdp of sparc_ifu_ifqdp.v
   wire [0:0]           ifq_icd_wrway_bf;       // From ifqdp of sparc_ifu_ifqdp.v
   wire [2-1:0]           ifq_ict_dec_wrway_bf;   // From invctl of sparc_ifu_invctl.v
   wire                 ifq_icv_wrdata_bf;      // From ifqctl of sparc_ifu_ifqctl.v
   wire [15:0]          ifq_icv_wren_bf;        // From invctl of sparc_ifu_invctl.v
   wire [(6 + 5):5]  ifq_icv_wrindex_bf;     // From invctl of sparc_ifu_invctl.v
   wire                 ifq_swl_stallreq;       // From ifqctl of sparc_ifu_ifqctl.v
   wire                 imd_dcl_abit_d;         // From imd of sparc_ifu_imd.v
   wire [3:0]           imd_dcl_brcond_d;       // From imd of sparc_ifu_imd.v
   wire [7:0]           imd_dcl_mvcond_d;       // From imd of sparc_ifu_imd.v
   wire                 inv_ifc_inv_pending;    // From invctl of sparc_ifu_invctl.v
   // wire [7:0]           mbist_icache_index;     // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_read;      // From mbist of sparc_ifu_mbist.v
   // wire [1:0]           mbist_icache_way;       // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_word;      // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_icache_write;     // From mbist of sparc_ifu_mbist.v
   // wire                 mbist_ifq_run_bist;     // From mbist of sparc_ifu_mbist.v
   wire [3:0]           swl_dcl_thr_d;          // From swl of sparc_ifu_swl.v
   wire [3:0]           swl_dcl_thr_w2;         // From swl of sparc_ifu_swl.v
   wire                 swl_dec_divbusy_e;      // From swl of sparc_ifu_swl.v
   wire                 swl_dec_fp_enable_d;    // From swl of sparc_ifu_swl.v
   wire                 swl_dec_fpbusy_e;       // From swl of sparc_ifu_swl.v
   wire                 swl_dec_ibe_e;          // From swl of sparc_ifu_swl.v
   wire                 swl_dec_mulbusy_e;      // From swl of sparc_ifu_swl.v
   wire [10:0]          swl_sscan_thrstate;     // From swl of sparc_ifu_swl.v
   wire [33:0]          wsel_fdp_fetdata_s1;    // From wseldp of sparc_ifu_wseldp.v
   wire [33:0]          wsel_fdp_topdata_s1;    // From wseldp of sparc_ifu_wseldp.v
   wire                 wsr_fixed_inst_w;       // From dec of sparc_ifu_dec.v
   // End of automatics

   
   wire [32:0]      itlb_ifq_csm_s;
   wire                 fcl_itlb_csm_rd_vld_bf;
   

   // tlb not auto instantiated
   wire           fcl_itlb_invall_f_l;	// From fcl of sparc_ifu_fcl.v

   wire           itlb_fcl_imiss_s_l;     // To fcl of sparc_ifu_fcl.v
   wire           itlb_fcl_tlbmiss_f_l;   // To fcl of sparc_ifu_fcl.v
   wire [2-1:0]     itlb_wsel_waysel_s1;     // To icd of sparc_ifu_icd.v
   wire [39:10]   itlb_ifq_paddr_s;       // To ifqdp of sparc_ifu_ifqdp.v, ...
   wire [42:0]    itlb_rd_tte_data;       // To errdp of sparc_ifu_errdp.v
   wire [58:0]    itlb_rd_tte_tag;        // To errdp of sparc_ifu_errdp.v

   wire           fcl_itlb_addr_mask_l;   // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_bypass_bf; // From fcl of sparc_ifu_fcl.v
   wire [2:0]     fcl_itlb_cam_pid_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_real_bf;   // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_cam_vld_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_data_rd_vld_bf;// From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_dmp_vld_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_dmp_all_bf;    // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_tag_rd_vld_bf; // From fcl of sparc_ifu_fcl.v
   wire           fcl_itlb_wr_vld_bf;     // From fcl of sparc_ifu_fcl.v
   wire [47:2]    fdp_icd_vaddr_bf;       // From fdp of sparc_ifu_fdp.v
   wire [12:0]    fdp_itlb_ctxt_bf;       // From fdp of sparc_ifu_fdp.v
   wire [((((39 - (6 + 5))+1) * 2)-1):0]    ict_itlb_tags_f;        // From ict of bw_r_ict.v

   // sscan rename
   wire [3:0]       ifq_sscan_data;         // From ifqctl of sparc_ifu_ifqctl.v
   // bist rename
   // wire [7:0]       mbist_icache_wdata;


   // rptr bus for bist read of icache
   wire [67:0]      wsel_mbist_icache_data;

   // bus width mismatch
   wire [(39 - (6 + 5)):0] ifq_ict_wrtag_f;        // From ifqdp of sparc_ifu_ifqdp.v
   wire [(39 - (6 + 5)):0] ifq_ict_wrtag_bf;        // Tri: earlier signal for ibm srams

   // scan wires
   wire                scan0_1;
   wire                scan0_2;
   wire                scan0_3;
   wire                scan0_4;
   wire                scan0_5;
   wire                scan0_6;
   wire                scan0_7;
   wire                scan0_8;
   wire                scan0_9;
   wire                scan0_10;
   wire                scan0_11;
   wire                scan0_12;
   wire                scan0_13;

   wire                short_scan1_1;
   wire                short_scan0_1;
   wire                short_scan0_2;
//----------------------------------------------------------------------
// Code start here
//----------------------------------------------------------------------
   // sram wrapper interface
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_icache_w10_rtap_data;
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_itag_rtap_data;
   // output [`SRAM_WRAPPER_BUS_WIDTH-1:0] sram_icache_w32_rtap_data;
   wire [4-1:0] sram_icache_w10_rtap_data;
   wire [4-1:0] sram_itag_rtap_data;
   wire [4-1:0] sram_icache_w32_rtap_data;
   wire [4-1:0] icv_rtap_data;
   input  [4-1:0] rtap_srams_bist_command;
   input  [4-1:0] rtap_srams_bist_data;
   output [4-1:0] srams_rtap_data;

   assign srams_rtap_data = sram_itag_rtap_data
                                 | sram_icache_w10_rtap_data
                                 | sram_icache_w32_rtap_data;
                                 // | icv_rtap_data;

   // jtag interface
   output wire [94-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;
   // assign core_rtap_data = `CORE_JTAG_BUS_WIDTH'd0;

   reg [3:0] ctu_sscan_tid;
   always @ *
   begin
      if (rtap_core_threadid == 2'd0)
         ctu_sscan_tid = 4'b0001;
      else if (rtap_core_threadid == 2'd1)
         ctu_sscan_tid = 4'b0010;
      else if (rtap_core_threadid == 2'd2)
         ctu_sscan_tid = 4'b0100;
      else if (rtap_core_threadid == 2'd3)
         ctu_sscan_tid = 4'b1000;
   end

   // sloppy implementation of overriding icache enable
   reg [3:0] lsu_ifu_icache_en_muxed;
   reg [3:0] lsu_ifu_icache_en_jtag;
   reg [3:0] lsu_ifu_icache_en_jtag_next;
   reg lsu_ifu_icache_en_locked;
   reg lsu_ifu_icache_en_locked_next;
   always @ *
   begin
      lsu_ifu_icache_en_locked_next = lsu_ifu_icache_en_locked;
      lsu_ifu_icache_en_jtag_next = lsu_ifu_icache_en_jtag;
      if (rtap_core_val && rtap_core_id == 4'd8)
      begin
         lsu_ifu_icache_en_locked_next = rtap_core_data[4];
         lsu_ifu_icache_en_jtag_next = rtap_core_data[3:0];
      end

      lsu_ifu_icache_en_muxed = lsu_ifu_icache_en;
      if (lsu_ifu_icache_en_locked)
         lsu_ifu_icache_en_muxed = lsu_ifu_icache_en_jtag;
   end
   always @ (posedge rclk)
   begin
      if (!arst_l)
      begin
         lsu_ifu_icache_en_locked = 1'b0;
         lsu_ifu_icache_en_jtag = 0;
      end
      else
      begin
         lsu_ifu_icache_en_locked = lsu_ifu_icache_en_locked_next;
         lsu_ifu_icache_en_jtag = lsu_ifu_icache_en_jtag_next;
      end
   end

   input          mem_write_disable;
   input          mux_drive_disable;


//   sparc_ifu_dtu dtu(
//		     .thr_config_in_w (exu_tlu_wsr_data_w[2:0]),
//		      /*AUTOINST*/);

   // decode
   sparc_ifu_dec dec(
                     .so                (scan0_1),
                     .si                (si0),
			/*AUTOINST*/
                     // Outputs
                     .ifu_exu_aluop_d   (ifu_exu_aluop_d[2:0]),
                     .ifu_exu_invert_d  (ifu_exu_invert_d),
                     .ifu_exu_useimm_d  (ifu_exu_useimm_d),
                     .ifu_exu_usecin_d  (ifu_exu_usecin_d),
                     .ifu_exu_enshift_d (ifu_exu_enshift_d),
                     .ifu_exu_tagop_d   (ifu_exu_tagop_d),
                     .ifu_exu_tv_d      (ifu_exu_tv_d),
                     .ifu_exu_muls_d    (ifu_exu_muls_d),
                     .ifu_exu_ialign_d  (ifu_exu_ialign_d),
                     .ifu_exu_range_check_jlret_d(ifu_exu_range_check_jlret_d),
                     .ifu_exu_range_check_other_d(ifu_exu_range_check_other_d),
                     .ifu_exu_shiftop_d (ifu_exu_shiftop_d[2:0]),
                     .ifu_exu_muldivop_d(ifu_exu_muldivop_d[4:0]),
                     .ifu_exu_wen_d     (ifu_exu_wen_d),
                     .ifu_exu_setcc_d   (ifu_exu_setcc_d),
                     .ifu_exu_rd_ifusr_e(ifu_exu_rd_ifusr_e),
                     .ifu_exu_rd_exusr_e(ifu_exu_rd_exusr_e),
                     .ifu_exu_rd_ffusr_e(ifu_exu_rd_ffusr_e),
                     .ifu_exu_rs1_vld_d (ifu_exu_rs1_vld_d),
                     .ifu_exu_rs2_vld_d (ifu_exu_rs2_vld_d),
                     .ifu_exu_rs3e_vld_d(ifu_exu_rs3e_vld_d),
                     .ifu_exu_rs3o_vld_d(ifu_exu_rs3o_vld_d),
                     .ifu_exu_use_rsr_e_l(ifu_exu_use_rsr_e_l),
                     .ifu_exu_save_d    (ifu_exu_save_d),
                     .ifu_exu_restore_d (ifu_exu_restore_d),
                     .ifu_exu_return_d  (ifu_exu_return_d),
                     .ifu_exu_flushw_e  (ifu_exu_flushw_e),
                     .ifu_exu_saved_e   (ifu_exu_saved_e),
                     .ifu_exu_restored_e(ifu_exu_restored_e),
                     .ifu_tlu_rsr_inst_d(ifu_tlu_rsr_inst_d),
                     .ifu_lsu_wsr_inst_d(ifu_lsu_wsr_inst_d),
                     .ifu_exu_wsr_inst_d(ifu_exu_wsr_inst_d),
                     .ifu_tlu_done_inst_d(ifu_tlu_done_inst_d),
                     .ifu_tlu_retry_inst_d(ifu_tlu_retry_inst_d),
                     .ifu_lsu_ld_inst_e (ifu_lsu_ld_inst_e),
                     .ifu_lsu_st_inst_e (ifu_lsu_st_inst_e),
                     .ifu_lsu_pref_inst_e(ifu_lsu_pref_inst_e),
                     .ifu_lsu_alt_space_e(ifu_lsu_alt_space_e),
                     .ifu_lsu_alt_space_d(ifu_lsu_alt_space_d),
                     .ifu_tlu_alt_space_d(ifu_tlu_alt_space_d),
                     .ifu_lsu_memref_d  (ifu_lsu_memref_d),
                     .ifu_lsu_sign_ext_e(ifu_lsu_sign_ext_e),
                     .ifu_lsu_ldstub_e  (ifu_lsu_ldstub_e),
                     .ifu_lsu_casa_e    (ifu_lsu_casa_e),
                     .ifu_exu_casa_d    (ifu_exu_casa_d),
                     .ifu_lsu_swap_e    (ifu_lsu_swap_e),
                     .ifu_tlu_mb_inst_e (ifu_tlu_mb_inst_e),
                     .ifu_tlu_sir_inst_m(ifu_tlu_sir_inst_m),
                     .ifu_tlu_flsh_inst_e(ifu_tlu_flsh_inst_e),
                     .ifu_lsu_ldst_dbl_e(ifu_lsu_ldst_dbl_e),
                     .ifu_lsu_ldst_fp_e (ifu_lsu_ldst_fp_e),
                     .ifu_lsu_ldst_size_e(ifu_lsu_ldst_size_e[1:0]),
                     .ifu_ffu_fpop1_d   (ifu_ffu_fpop1_d),
                     .ifu_ffu_visop_d   (ifu_ffu_visop_d),
                     .ifu_ffu_fpop2_d   (ifu_ffu_fpop2_d),
                     .ifu_ffu_fld_d     (ifu_ffu_fld_d),
                     .ifu_ffu_fst_d     (ifu_ffu_fst_d),
                     .ifu_ffu_ldst_size_d(ifu_ffu_ldst_size_d),
                     .ifu_ffu_ldfsr_d   (ifu_ffu_ldfsr_d),
                     .ifu_ffu_ldxfsr_d  (ifu_ffu_ldxfsr_d),
                     .ifu_ffu_stfsr_d   (ifu_ffu_stfsr_d),
                     .ifu_ffu_quad_op_e (ifu_ffu_quad_op_e),
                     .dec_fcl_rdsr_sel_pc_d(dec_fcl_rdsr_sel_pc_d),
                     .dec_fcl_rdsr_sel_thr_d(dec_fcl_rdsr_sel_thr_d),
                     .dec_imd_call_inst_d(dec_imd_call_inst_d),
                     .dtu_fcl_flush_sonly_e(dtu_fcl_flush_sonly_e),
                     .dtu_fcl_illinst_e (dtu_fcl_illinst_e),
                     .dtu_fcl_fpdis_e   (dtu_fcl_fpdis_e),
                     .dtu_fcl_privop_e  (dtu_fcl_privop_e),
                     .dtu_fcl_imask_hit_e(dtu_fcl_imask_hit_e),
                     .dtu_fcl_br_inst_d (dtu_fcl_br_inst_d),
                     .dtu_fcl_sir_inst_e(dtu_fcl_sir_inst_e),
                     .dtu_ifq_kill_latest_d(dtu_ifq_kill_latest_d),
                     .dec_swl_wrt_tcr_w (dec_swl_wrt_tcr_w),
                     .dec_swl_wrtfprs_w (dec_swl_wrtfprs_w),
                     .dec_swl_ll_done_d (dec_swl_ll_done_d),
                     .dec_swl_br_done_d (dec_swl_br_done_d),
                     .dec_swl_rdsr_sel_thr_d(dec_swl_rdsr_sel_thr_d),
                     .dec_swl_ld_inst_d (dec_swl_ld_inst_d),
                     .dec_swl_sta_inst_e(dec_swl_sta_inst_e),
                     .dec_swl_std_inst_d(dec_swl_std_inst_d),
                     .dec_swl_st_inst_d (dec_swl_st_inst_d),
                     .dec_swl_fpop_d    (dec_swl_fpop_d),
                     .dec_swl_allfp_d   (dec_swl_allfp_d),
                     .dec_swl_frf_upper_d(dec_swl_frf_upper_d),
                     .dec_swl_frf_lower_d(dec_swl_frf_lower_d),
                     .dec_swl_div_inst_d(dec_swl_div_inst_d),
                     .dec_swl_mul_inst_d(dec_swl_mul_inst_d),
                     .wsr_fixed_inst_w  (wsr_fixed_inst_w),
                     .ifu_exu_sethi_inst_d(ifu_exu_sethi_inst_d),
                     .dec_dcl_cctype_d  (dec_dcl_cctype_d[2:0]),
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),
                     .dtu_inst_d        (dtu_inst_d[31:0]),
                     .erb_dtu_imask     (erb_dtu_imask[38:0]),
                     .swl_dec_ibe_e     (swl_dec_ibe_e),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                     .fcl_dtu_tlzero_d  (fcl_dtu_tlzero_d),
                     .fcl_dtu_privmode_d(fcl_dtu_privmode_d),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .fcl_dtu_ely_inst_vld_d(fcl_dtu_ely_inst_vld_d),
                     .fcl_dec_intr_vld_d(fcl_dec_intr_vld_d),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dec_dslot_s   (fcl_dec_dslot_s),
                     .swl_dec_mulbusy_e (swl_dec_mulbusy_e),
                     .swl_dec_fpbusy_e  (swl_dec_fpbusy_e),
                     .swl_dec_divbusy_e (swl_dec_divbusy_e),
                     .swl_dec_fp_enable_d(swl_dec_fp_enable_d));


   // Pipeline Control and Switch Logic
   sparc_ifu_swl swl(
                     .so                (scan0_2),
                     .si                (scan0_1),
		                 .thr_config_in_m	(exu_tlu_wsr_data_m[2:0]),
                     .extra_longlat_compl(4'b0),

		                 /*AUTOINST*/
                     // Outputs
                     .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
                     .dtu_reset         (dtu_reset),
                     .swl_dec_mulbusy_e (swl_dec_mulbusy_e),
                     .swl_dec_divbusy_e (swl_dec_divbusy_e),
                     .swl_dec_fpbusy_e  (swl_dec_fpbusy_e),
                     .swl_dec_fp_enable_d(swl_dec_fp_enable_d),
                     .swl_dec_ibe_e     (swl_dec_ibe_e),
                     .dtu_fcl_ntr_s     (dtu_fcl_ntr_s),
                     .dtu_fcl_running_s (dtu_fcl_running_s),
                     .dtu_fcl_rollback_g(dtu_fcl_rollback_g),
                     .dtu_fcl_retract_d (dtu_fcl_retract_d),
                     .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                     .dtu_fcl_nextthr_bf(dtu_fcl_nextthr_bf[3:0]),
                     .swl_dcl_thr_d     (swl_dcl_thr_d[3:0]),
                     .swl_dcl_thr_w2    (swl_dcl_thr_w2[3:0]),
                     .esl_fcl_stall_bf  (esl_fcl_stall_bf),
                     .esl_fcl_switch_bf (esl_fcl_switch_bf),
                     .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
                     .esl_fcl_ntr_s     (esl_fcl_ntr_s),
                     .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),
                     .esl_fcl_force_running_s (esl_fcl_force_running_s),
                     .dtu_fdp_thrconf_e (dtu_fdp_thrconf_e[40:0]),
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),
                     .gdbginit_l        (gdbginit_l),
                     .arst_l            (arst_l),
                     .grst_l            (grst_l),
                     .ctu_sscan_tid     (ctu_sscan_tid[3:0]),
                     .ifq_dtu_thrrdy    (ifq_dtu_thrrdy[3:0]),
                     .ifq_dtu_pred_rdy  (ifq_dtu_pred_rdy[3:0]),
                     .ifu_tlu_inst_vld_w(ifu_tlu_inst_vld_w),
                     .ifu_tlu_ttype_vld_m(ifu_tlu_ttype_vld_m),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_hprivmode_w2(fcl_dtu_hprivmode_w2),
                     .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                     .fcl_swl_flush_w   (fcl_swl_flush_w),
                     .fcl_dtu_sync_intr_d(fcl_dtu_sync_intr_d),
                     .fcl_dtu_nuke_thr_w(fcl_dtu_nuke_thr_w),
                     .fcl_dtu_rst_thr_w (fcl_dtu_rst_thr_w),
                     .fcl_dtu_resum_thr_w(fcl_dtu_resum_thr_w),
                     .fcl_dtu_thr_f     (fcl_dtu_thr_f[3:0]),
                     .tlu_hpstate_ibe   (tlu_hpstate_ibe[3:0]),
                     .lsu_ifu_ldsta_internal_e(lsu_ifu_ldsta_internal_e),
                     .tlu_ifu_trappc_vld_w1(tlu_ifu_trappc_vld_w1),
                     .dec_swl_ll_done_d (dec_swl_ll_done_d),
                     .dec_swl_br_done_d (dec_swl_br_done_d),
                     .dec_swl_rdsr_sel_thr_d(dec_swl_rdsr_sel_thr_d),
                     .dec_swl_std_inst_d(dec_swl_std_inst_d),
                     .dec_swl_sta_inst_e(dec_swl_sta_inst_e),
                     .wsr_fixed_inst_w  (wsr_fixed_inst_w),
                     .dec_swl_ld_inst_d (dec_swl_ld_inst_d),
                     .dec_swl_mul_inst_d(dec_swl_mul_inst_d),
                     .dec_swl_div_inst_d(dec_swl_div_inst_d),
                     .dec_swl_fpop_d    (dec_swl_fpop_d),
                     .dec_swl_allfp_d   (dec_swl_allfp_d),
                     .dec_swl_frf_upper_d(dec_swl_frf_upper_d),
                     .dec_swl_frf_lower_d(dec_swl_frf_lower_d),
                     .dec_swl_wrtfprs_w (dec_swl_wrtfprs_w),
                     .dcl_swl_tcc_done_m(dcl_swl_tcc_done_m),
                     .exu_ifu_longop_done_g(exu_ifu_longop_done_g[3:0]),
                     .exu_ifu_spill_e   (exu_ifu_spill_e),
                     .lsu_ifu_ldst_cmplt(lsu_ifu_ldst_cmplt[3:0]),
                     .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                     .lsu_ifu_stbcnt0   (lsu_ifu_stbcnt0[3:0]),
                     .lsu_ifu_stbcnt1   (lsu_ifu_stbcnt1[3:0]),
                     .lsu_ifu_stbcnt2   (lsu_ifu_stbcnt2[3:0]),
                     .lsu_ifu_stbcnt3   (lsu_ifu_stbcnt3[3:0]),
                     .lsu_ifu_quad_asi_e(lsu_ifu_quad_asi_e),
                     .ffu_ifu_fpop_done_w2(ffu_ifu_fpop_done_w2),
                     .ffu_ifu_tid_w2    (ffu_ifu_tid_w2[1:0]),
                     .ffu_ifu_fst_ce_w  (ffu_ifu_fst_ce_w),
                     .tlu_ifu_trap_tid_w1(tlu_ifu_trap_tid_w1[1:0]),
                     .tlu_ifu_pstate_pef(tlu_ifu_pstate_pef[3:0]),
                     .lsu_ifu_ldst_miss_g(lsu_ifu_ldst_miss_g),
                     .fcl_swl_int_activate_i3(fcl_swl_int_activate_i3[3:0]),
                     .fcl_swl_flush_wake_w(fcl_swl_flush_wake_w),
                     .ifq_swl_stallreq  (ifq_swl_stallreq),
                     .fcl_dtu_stall_bf  (fcl_dtu_stall_bf),
                     .fcl_swl_swout_f   (fcl_swl_swout_f),
                     .fcl_swl_swcvld_s  (fcl_swl_swcvld_s),
                     .fdp_fcl_swc_s2    (fdp_fcl_swc_s2),
                     .fcl_ifq_icmiss_s1 (fcl_ifq_icmiss_s1),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .const_cpuid       (const_cpuid[3:0]),
                     .dec_swl_wrt_tcr_w (dec_swl_wrt_tcr_w),
                     .dec_swl_st_inst_d (dec_swl_st_inst_d),
                     .config_dtu_esl_en (config_dtu_esl_en),
                     .config_dtu_esl_sync_method (config_dtu_esl_sync_method),
                     .config_esl_lfsr_seed (config_esl_lfsr_seed),
                     .config_esl_lfsr_ld (config_esl_lfsr_ld),
                     .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
                     .config_esl_counter_timeout (config_esl_counter_timeout),
                     .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

                     .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














                     .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

                     .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














                     .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

                     .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














                     .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
                     .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
                     .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
                     .fcl_esl_thr_e (fcl_esl_thr_e),
                     .fcl_esl_thr_m (fcl_esl_thr_m),
                     .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
                     .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
                     .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
                     .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
                     .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
                     .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
                     .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
                     .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),


                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)
                     );

   // Branch Logic
   sparc_ifu_dcl  dcl(
                      .so               (scan0_3),
                      .si               (scan0_2),
		                  .dtu_dcl_opf2_d	(dtu_inst_d[7]),
                      .fdp_dcl_op_s     (fdp_dtu_inst_s[31:30]),
                      .fdp_dcl_op3_s    (fdp_dtu_inst_s[24:19]),

		                  /*AUTOINST*/
                      // Outputs
                      .ifu_exu_kill_e   (ifu_exu_kill_e),
                      .ifu_exu_dontmv_regz0_e(ifu_exu_dontmv_regz0_e),
                      .ifu_exu_dontmv_regz1_e(ifu_exu_dontmv_regz1_e),
                      .ifu_exu_tcc_e    (ifu_exu_tcc_e),
                      .ifu_exu_dbrinst_d(ifu_exu_dbrinst_d),
                      .ifu_ffu_mvcnd_m  (ifu_ffu_mvcnd_m),
                      .dcl_fcl_bcregz0_e(dcl_fcl_bcregz0_e),
                      .dcl_fcl_bcregz1_e(dcl_fcl_bcregz1_e),
                      .dtu_inst_anull_e (dtu_inst_anull_e),
                      .dcl_swl_tcc_done_m(dcl_swl_tcc_done_m),
                      .dcl_imd_immdata_sel_simm13_d_l(dcl_imd_immdata_sel_simm13_d_l),
                      .dcl_imd_immdata_sel_movcc_d_l(dcl_imd_immdata_sel_movcc_d_l),
                      .dcl_imd_immdata_sel_sethi_d_l(dcl_imd_immdata_sel_sethi_d_l),
                      .dcl_imd_immdata_sel_movr_d_l(dcl_imd_immdata_sel_movr_d_l),
                      .dcl_imd_broff_sel_call_d_l(dcl_imd_broff_sel_call_d_l),
                      .dcl_imd_broff_sel_br_d_l(dcl_imd_broff_sel_br_d_l),
                      .dcl_imd_broff_sel_bcc_d_l(dcl_imd_broff_sel_bcc_d_l),
                      .dcl_imd_broff_sel_bpcc_d_l(dcl_imd_broff_sel_bpcc_d_l),
                      .dcl_imd_immbr_sel_br_d(dcl_imd_immbr_sel_br_d),
                      .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
                      .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .dtu_reset        (dtu_reset),
                      .exu_ifu_cc_d     (exu_ifu_cc_d[7:0]),
                      .fcl_dcl_regz_e   (fcl_dcl_regz_e),
                      .exu_ifu_regn_e   (exu_ifu_regn_e),
                      .ffu_ifu_cc_w2    (ffu_ifu_cc_w2[7:0]),
                      .ffu_ifu_cc_vld_w2(ffu_ifu_cc_vld_w2[3:0]),
                      .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                      .swl_dcl_thr_d    (swl_dcl_thr_d[3:0]),
                      .swl_dcl_thr_w2   (swl_dcl_thr_w2[3:0]),
                      .imd_dcl_brcond_d (imd_dcl_brcond_d[3:0]),
                      .imd_dcl_mvcond_d (imd_dcl_mvcond_d[7:0]),
                      .imd_dcl_abit_d   (imd_dcl_abit_d),
                      .dec_dcl_cctype_d (dec_dcl_cctype_d[2:0]),
                      .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                      .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                      .ifu_tlu_flush_w  (ifu_tlu_flush_w));

/*   sparc_ifu_imd AUTO_TEMPLATE(
                         .dcl_imd_call_inst_d (dec_imd_call_inst_d),
                         );

*/
   sparc_ifu_imd  imd(
                      .so               (scan0_4),
                      .si               (scan0_3),

                      /*AUTOINST*/
                      // Outputs
                      .ifu_exu_imm_data_d(ifu_exu_imm_data_d[31:0]),
                      .dtu_inst_d       (dtu_inst_d[31:0]),
                      .ifu_exu_rd_d     (ifu_exu_rd_d[4:0]),
                      .ifu_lsu_rd_e     (ifu_lsu_rd_e[4:0]),
                      .ifu_lsu_imm_asi_d(ifu_lsu_imm_asi_d[7:0]),
                      .ifu_tlu_imm_asi_d(ifu_tlu_imm_asi_d[8:0]),
                      .ifu_lsu_imm_asi_vld_d(ifu_lsu_imm_asi_vld_d),
                      .ifu_tlu_sraddr_d (ifu_tlu_sraddr_d[6:0]),
                      .ifu_tlu_sraddr_d_v2(ifu_tlu_sraddr_d_v2[6:0]),
                      .imd_dcl_brcond_d (imd_dcl_brcond_d[3:0]),
                      .imd_dcl_mvcond_d (imd_dcl_mvcond_d[7:0]),
                      .imd_dcl_abit_d   (imd_dcl_abit_d),
                      .ifu_ffu_frs1_d   (ifu_ffu_frs1_d[4:0]),
                      .ifu_ffu_frs2_d   (ifu_ffu_frs2_d[4:0]),
                      .ifu_ffu_frd_d    (ifu_ffu_frd_d[4:0]),
                      .ifu_ffu_fpopcode_d(ifu_ffu_fpopcode_d[8:0]),
                      .ifu_ffu_fcc_num_d(ifu_ffu_fcc_num_d[1:0]),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .fdp_dtu_inst_s   (fdp_dtu_inst_s[31:0]),
                      .fcl_imd_oddwin_d (fcl_imd_oddwin_d),
                      .dcl_imd_immdata_sel_simm13_d_l(dcl_imd_immdata_sel_simm13_d_l),
                      .dcl_imd_immdata_sel_movcc_d_l(dcl_imd_immdata_sel_movcc_d_l),
                      .dcl_imd_immdata_sel_sethi_d_l(dcl_imd_immdata_sel_sethi_d_l),
                      .dcl_imd_immdata_sel_movr_d_l(dcl_imd_immdata_sel_movr_d_l),
                      .dcl_imd_broff_sel_call_d_l(dcl_imd_broff_sel_call_d_l),
                      .dcl_imd_broff_sel_br_d_l(dcl_imd_broff_sel_br_d_l),
                      .dcl_imd_broff_sel_bcc_d_l(dcl_imd_broff_sel_bcc_d_l),
                      .dcl_imd_broff_sel_bpcc_d_l(dcl_imd_broff_sel_bpcc_d_l),
                      .dcl_imd_immbr_sel_br_d(dcl_imd_immbr_sel_br_d),
                      .dcl_imd_call_inst_d(dec_imd_call_inst_d)); // Templated

   sparc_ifu_fdp  fdp(
                      .so               (scan0_5),
                      .si               (scan0_4),
                     .fdp_itlb_ctxt_bf (fdp_itlb_ctxt_bf[12:0]),
                      .fdp_icd_vaddr_bf (fdp_icd_vaddr_bf[47:2]),
                      .icd_fdp_fetdata_s1(wsel_fdp_fetdata_s1[32:0]),
                      .icd_fdp_topdata_s1(wsel_fdp_topdata_s1[32:0]),
                      // eco 5362
                      .fcl_fdp_addr_mask_d(ifu_exu_addr_mask_d),
                      /*AUTOINST*/
                      // Outputs
                      .fdp_icv_index_bf (fdp_icv_index_bf[(6 + 5):5]),
                      .fdp_erb_pc_f     (fdp_erb_pc_f[47:0]),
                      .fdp_dtu_inst_s   (fdp_dtu_inst_s[31:0]),
                      .ifu_exu_pc_d     (ifu_exu_pc_d[47:0]),
                      .ifu_exu_rs1_s    (ifu_exu_rs1_s[4:0]),
                      .ifu_exu_rs2_s    (ifu_exu_rs2_s[4:0]),
                      .ifu_exu_rs3_s    (ifu_exu_rs3_s[4:0]),
                      .ifu_tlu_pc_m     (ifu_tlu_pc_m[48:0]),
                      .ifu_tlu_npc_m    (ifu_tlu_npc_m[48:0]),
                      .ifu_tlu_pc_oor_e (ifu_tlu_pc_oor_e),
                      .ifu_exu_pcver_e  (ifu_exu_pcver_e[63:0]),
                      .fdp_fcl_swc_s2   (fdp_fcl_swc_s2),
                      .fdp_fcl_pc_oor_vec_f(fdp_fcl_pc_oor_vec_f[3:0]),
                      .fdp_fcl_pc_oor_e (fdp_fcl_pc_oor_e),
                      .fdp_fcl_op_s     (fdp_fcl_op_s[1:0]),
                      .fdp_fcl_op3_s    (fdp_fcl_op3_s[5:2]),
                      .fdp_fcl_ibit_s   (fdp_fcl_ibit_s),
                      .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

                      .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














                      .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

                      .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














                      .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

                      .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














                      .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),
                      // Inputs
                      .rclk             (rclk),
                      .se               (se),
                      .const_maskid     (const_maskid[7:0]),
                      .lsu_t0_pctxt_state(lsu_t0_pctxt_state[12:0]),
                      .lsu_t1_pctxt_state(lsu_t1_pctxt_state[12:0]),
                      .lsu_t2_pctxt_state(lsu_t2_pctxt_state[12:0]),
                      .lsu_t3_pctxt_state(lsu_t3_pctxt_state[12:0]),
                      .exu_ifu_brpc_e   (exu_ifu_brpc_e[47:0]),
                      .tlu_ifu_trappc_w2(tlu_ifu_trappc_w2[48:0]),
                      .tlu_ifu_trapnpc_w2(tlu_ifu_trapnpc_w2[48:0]),
                      .tlu_itlb_dmp_nctxt_g(tlu_itlb_dmp_nctxt_g),
                      .tlu_itlb_dmp_actxt_g(tlu_itlb_dmp_actxt_g),
                      .tlu_itlb_tte_tag_w2(tlu_itlb_tte_tag_w2[12:0]),
                      .dtu_fdp_thrconf_e(dtu_fdp_thrconf_e[40:0]),
                      .ifq_fdp_fill_inst(ifq_fdp_fill_inst[32:0]),
                      .fcl_fdp_oddwin_s (fcl_fdp_oddwin_s),
                      .fcl_fdp_pcoor_vec_f(fcl_fdp_pcoor_vec_f[3:0]),
                      .fcl_fdp_pcoor_f  (fcl_fdp_pcoor_f),
                      .fcl_fdp_mask32b_f(fcl_fdp_mask32b_f),
                      .fcl_fdp_tctxt_sel_prim(fcl_fdp_tctxt_sel_prim[3:0]),
                      .fcl_fdp_usenir_sel_nir_s1(fcl_fdp_usenir_sel_nir_s1),
                      .fcl_fdp_rbinst_sel_inste_s(fcl_fdp_rbinst_sel_inste_s[3:0]),
                      .fcl_fdp_thrtnpc_sel_tnpc_l(fcl_fdp_thrtnpc_sel_tnpc_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_npcw_l(fcl_fdp_thrtnpc_sel_npcw_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_pcf_l(fcl_fdp_thrtnpc_sel_pcf_l[3:0]),
                      .fcl_fdp_thrtnpc_sel_old_l(fcl_fdp_thrtnpc_sel_old_l[3:0]),
                      .fcl_fdp_thr_s1_l (fcl_fdp_thr_s1_l[3:0]),
                      .fcl_fdp_next_thr_bf_l(fcl_fdp_next_thr_bf_l[3:0]),
                      .fcl_fdp_next_ctxt_bf_l(fcl_fdp_next_ctxt_bf_l[3:0]),
                      .fcl_fdp_thr_s2_l (fcl_fdp_thr_s2_l[3:0]),
                      .fcl_fdp_nirthr_s1_l(fcl_fdp_nirthr_s1_l[3:0]),
                      .fcl_fdp_tpcbf_sel_pcp4_bf_l(fcl_fdp_tpcbf_sel_pcp4_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_brpc_bf_l(fcl_fdp_tpcbf_sel_brpc_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_trap_bf_l(fcl_fdp_tpcbf_sel_trap_bf_l[3:0]),
                      .fcl_fdp_tpcbf_sel_old_bf_l(fcl_fdp_tpcbf_sel_old_bf_l[3:0]),
                      .fcl_fdp_pcbf_sel_swpc_bf_l(fcl_fdp_pcbf_sel_swpc_bf_l),
                      .fcl_fdp_pcbf_sel_nosw_bf_l(fcl_fdp_pcbf_sel_nosw_bf_l),
                      .fcl_fdp_pcbf_sel_br_bf_l(fcl_fdp_pcbf_sel_br_bf_l),
                      .fcl_fdp_trrbpc_sel_trap_bf_l(fcl_fdp_trrbpc_sel_trap_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_rb_bf_l(fcl_fdp_trrbpc_sel_rb_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_err_bf_l(fcl_fdp_trrbpc_sel_err_bf_l[3:0]),
                      .fcl_fdp_trrbpc_sel_pcs_bf_l(fcl_fdp_trrbpc_sel_pcs_bf_l[3:0]),
                      .fcl_fdp_noswpc_sel_tnpc_l_bf(fcl_fdp_noswpc_sel_tnpc_l_bf),
                      .fcl_fdp_noswpc_sel_old_l_bf(fcl_fdp_noswpc_sel_old_l_bf),
                      .fcl_fdp_noswpc_sel_inc_l_bf(fcl_fdp_noswpc_sel_inc_l_bf),
                      .fcl_fdp_nextpcs_sel_pce_f_l(fcl_fdp_nextpcs_sel_pce_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcd_f_l(fcl_fdp_nextpcs_sel_pcd_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcs_f_l(fcl_fdp_nextpcs_sel_pcs_f_l[3:0]),
                      .fcl_fdp_nextpcs_sel_pcf_f_l(fcl_fdp_nextpcs_sel_pcf_f_l[3:0]),
                      .fcl_fdp_rdsr_sel_pc_e_l(fcl_fdp_rdsr_sel_pc_e_l),
                      .fcl_fdp_rdsr_sel_ver_e_l(fcl_fdp_rdsr_sel_ver_e_l),
                      .fcl_fdp_rdsr_sel_thr_e_l(fcl_fdp_rdsr_sel_thr_e_l),
                      .fcl_fdp_inst_sel_curr_s_l(fcl_fdp_inst_sel_curr_s_l),
                      .fcl_fdp_inst_sel_switch_s_l(fcl_fdp_inst_sel_switch_s_l),
                      .fcl_fdp_inst_sel_nir_s_l(fcl_fdp_inst_sel_nir_s_l),
                      .fcl_fdp_inst_sel_nop_s_l(fcl_fdp_inst_sel_nop_s_l),
                      .fcl_fdp_tinst_sel_curr_s_l(fcl_fdp_tinst_sel_curr_s_l[3:0]),
                      .fcl_fdp_tinst_sel_rb_s_l(fcl_fdp_tinst_sel_rb_s_l[3:0]),
                      .fcl_fdp_tinst_sel_old_s_l(fcl_fdp_tinst_sel_old_s_l[3:0]),
                      .fcl_fdp_tinst_sel_ifq_s_l(fcl_fdp_tinst_sel_ifq_s_l[3:0]),
                      .fcl_fdp_dmpthr_l (fcl_fdp_dmpthr_l[3:0]),
                      .fcl_fdp_ctxt_sel_dmp_bf_l(fcl_fdp_ctxt_sel_dmp_bf_l),
                      .fcl_fdp_ctxt_sel_sw_bf_l(fcl_fdp_ctxt_sel_sw_bf_l),
                      .fcl_fdp_ctxt_sel_curr_bf_l(fcl_fdp_ctxt_sel_curr_bf_l),
                      .itlb_fdp_paddr_s(itlb_ifq_paddr_s[39:10]),
                      .fcl_fdp_tlbmiss_s1 (fcl_fdp_tlbmiss_s1),
                      .ifq_fdp_fill_paddr(ifq_fdp_fill_paddr[39:2]),
                      .config_dtu_esl_en (config_dtu_esl_en),
                      .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
                      .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),

                     .fdp_fcl_jtag_breakpoint_hit(fdp_fcl_jtag_breakpoint_hit),

                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)
                      );

   sparc_ifu_fcl fcl(
                     .so                (short_scan1_1),
                     .si                (short_si1),
                     .rst_tri_en        (mux_drive_disable),

                     // keep around in case we need it later
                     .ifu_reset_l       (),

		                 .fdp_fcl_va2_bf    (fdp_icd_vaddr_bf[2]),
                     .itlb_fcl_priv_s1  (itlb_rd_tte_data[4]),
                     .tlu_fcl_dmp_pid_bf (tlu_itlb_tte_tag_w2[58:56]),
                     .tlu_fcl_dmp_real_bf (tlu_itlb_tte_tag_w2[55]),
                     .itlb_fcl_cp_s1    (itlb_rd_tte_data[7]),
                     // need these here since itlb is not auto inst'ed
		                 .fcl_itlb_invall_f_l(fcl_itlb_invall_f_l),
                     .fcl_itlb_cam_vld_bf(fcl_itlb_cam_vld_bf),
                     .fcl_itlb_cam_bypass_bf(fcl_itlb_cam_bypass_bf),
                     .fcl_itlb_addr_mask_l(fcl_itlb_addr_mask_l),
                     .fcl_itlb_cam_real_bf(fcl_itlb_cam_real_bf),
                     .fcl_itlb_cam_pid_bf(fcl_itlb_cam_pid_bf[2:0]),
                     .fcl_itlb_wr_vld_bf(fcl_itlb_wr_vld_bf),
                     .fcl_itlb_dmp_vld_bf(fcl_itlb_dmp_vld_bf),
                     .fcl_itlb_dmp_all_bf(fcl_itlb_dmp_all_bf),
                     .fcl_itlb_tag_rd_vld_bf(fcl_itlb_tag_rd_vld_bf),
                     .fcl_itlb_data_rd_vld_bf(fcl_itlb_data_rd_vld_bf),

                     // eco 5362
                     .fcl_fdp_addr_mask_d(ifu_exu_addr_mask_d),

		      /*AUTOINST*/
                     // Outputs

                     
                     .fcl_itlb_csm_rd_vld_bf(fcl_itlb_csm_rd_vld_bf),
                     
                     .fcl_icd_rdreq_bf  (fcl_icd_rdreq_bf),
                     .fcl_icv_rdreq_bf  (fcl_icv_rdreq_bf),
                     .fcl_icd_wrreq_bf  (fcl_icd_wrreq_bf),
                     .fcl_ict_wrreq_bf  (fcl_ict_wrreq_bf),
                     .fcl_icv_wrreq_bf  (fcl_icv_wrreq_bf),
                     .fcl_icd_index_sel_ifq_bf(fcl_icd_index_sel_ifq_bf),
                     .fcl_ifq_grant_bf  (fcl_ifq_grant_bf),
                     .fcl_ifq_icmiss_s1 (fcl_ifq_icmiss_s1),
                     .fcl_ifq_rdreq_s1  (fcl_ifq_rdreq_s1),
                     .fcl_ifq_icache_en_s_l(fcl_ifq_icache_en_s_l),
                     .fcl_ifq_thr_s1    (fcl_ifq_thr_s1[1:0]),
                     .fcl_ifq_canthr    (fcl_ifq_canthr[3:0]),
                     .fcl_erb_ievld_s1  (fcl_erb_ievld_s1),
                     .fcl_erb_tevld_s1  (fcl_erb_tevld_s1),
                     .fcl_erb_immuevld_s1(fcl_erb_immuevld_s1),
                     .ifu_lsu_thrid_s   (ifu_lsu_thrid_s[1:0]),
                     .fcl_erb_asi_tid_f (fcl_erb_asi_tid_f[1:0]),
                     .fcl_erb_clear_iferr(fcl_erb_clear_iferr[3:0]),
                     .fcl_erb_itlbrd_vld_s(fcl_erb_itlbrd_vld_s),
                     .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                     .fcl_dec_dslot_s   (fcl_dec_dslot_s),
                     .fcl_dtu_inst_vld_e(fcl_dtu_inst_vld_e),
                     .fcl_dtu_intr_vld_e(fcl_dtu_intr_vld_e),
                     .fcl_dtu_inst_vld_d(fcl_dtu_inst_vld_d),
                     .fcl_dtu_ely_inst_vld_d(fcl_dtu_ely_inst_vld_d),
                     .fcl_dec_intr_vld_d(fcl_dec_intr_vld_d),
                     .fcl_erb_inst_issue_d(fcl_erb_inst_issue_d),
                     .fcl_erb_inst_vld_d1(fcl_erb_inst_vld_d1),
                     .ifu_tlu_inst_vld_m(ifu_tlu_inst_vld_m),
                     .ifu_exu_inst_vld_e(ifu_exu_inst_vld_e),
                     .ifu_exu_inst_vld_w(ifu_exu_inst_vld_w),
                     .ifu_spu_inst_vld_w(ifu_spu_inst_vld_w),
                     .ifu_tlu_inst_vld_w(ifu_tlu_inst_vld_w),
                     .ifu_tlu_flush_w   (ifu_tlu_flush_w),
                     .ifu_tlu_flush_m   (ifu_tlu_flush_m),
                     .fcl_swl_int_activate_i3(fcl_swl_int_activate_i3[3:0]),
                     .fcl_swl_flush_wake_w(fcl_swl_flush_wake_w),
                     .fcl_swl_flush_w   (fcl_swl_flush_w),
                     .fcl_dcl_regz_e    (fcl_dcl_regz_e),
                     .ifu_tlu_thrid_e   (ifu_tlu_thrid_e[1:0]),
                     .ifu_tlu_thrid_d   (ifu_tlu_thrid_d[1:0]),
                     .ifu_tlu_immu_miss_m(ifu_tlu_immu_miss_m),
                     .ifu_tlu_priv_violtn_m(ifu_tlu_priv_violtn_m),
                     .ifu_tlu_icmiss_e  (ifu_tlu_icmiss_e),
                     .ifu_tlu_ttype_vld_m(ifu_tlu_ttype_vld_m),
                     .ifu_exu_ttype_vld_m(ifu_exu_ttype_vld_m),
                     .ifu_mmu_trap_m    (ifu_mmu_trap_m),
                     .ifu_tlu_trap_m    (ifu_tlu_trap_m),
                     .ifu_tlu_ttype_m   (ifu_tlu_ttype_m[8:0]),
                     .ifu_tlu_hwint_m   (ifu_tlu_hwint_m),
                     .ifu_tlu_sftint_m  (ifu_tlu_sftint_m),
                     .ifu_tlu_rstint_m  (ifu_tlu_rstint_m),
                     .fcl_dtu_rst_thr_w (fcl_dtu_rst_thr_w),
                     .fcl_dtu_resum_thr_w(fcl_dtu_resum_thr_w),
                     .ifu_tlu_itlb_done (ifu_tlu_itlb_done),
                     .ifu_spu_trap_ack  (ifu_spu_trap_ack),
                     .ifu_exu_tid_s2    (ifu_exu_tid_s2[1:0]),
                     .ifu_exu_ren1_s    (ifu_exu_ren1_s),
                     .ifu_exu_ren2_s    (ifu_exu_ren2_s),
                     .ifu_exu_ren3_s    (ifu_exu_ren3_s),
                     .ifu_exu_disable_ce_e(ifu_exu_disable_ce_e),
                     .fcl_dtu_sync_intr_d(fcl_dtu_sync_intr_d),
                     .fcl_dtu_tlzero_d  (fcl_dtu_tlzero_d),
                     .fcl_dtu_privmode_d(fcl_dtu_privmode_d),
                     .fcl_dtu_hprivmode_d(fcl_dtu_hprivmode_d),
                     .fcl_dtu_hprivmode_w2(fcl_dtu_hprivmode_w2),
                     .fcl_dtu_nuke_thr_w(fcl_dtu_nuke_thr_w),
                     .fcl_swl_swout_f   (fcl_swl_swout_f),
                     .fcl_dtu_stall_bf  (fcl_dtu_stall_bf),
                     .fcl_swl_swcvld_s  (fcl_swl_swcvld_s),
                     .fcl_dtu_thr_f     (fcl_dtu_thr_f[3:0]),
                     .fcl_imd_oddwin_d  (fcl_imd_oddwin_d),
                     .fcl_fdp_oddwin_s  (fcl_fdp_oddwin_s),
                     .fcl_fdp_pcoor_vec_f(fcl_fdp_pcoor_vec_f[3:0]),
                     .fcl_fdp_pcoor_f   (fcl_fdp_pcoor_f),
                     .fcl_fdp_mask32b_f (fcl_fdp_mask32b_f),
                     .fcl_fdp_tctxt_sel_prim(fcl_fdp_tctxt_sel_prim[3:0]),
                     .fcl_fdp_usenir_sel_nir_s1(fcl_fdp_usenir_sel_nir_s1),
                     .fcl_fdp_rbinst_sel_inste_s(fcl_fdp_rbinst_sel_inste_s[3:0]),
                     .fcl_fdp_thrtnpc_sel_tnpc_l(fcl_fdp_thrtnpc_sel_tnpc_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_npcw_l(fcl_fdp_thrtnpc_sel_npcw_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_pcf_l(fcl_fdp_thrtnpc_sel_pcf_l[3:0]),
                     .fcl_fdp_thrtnpc_sel_old_l(fcl_fdp_thrtnpc_sel_old_l[3:0]),
                     .fcl_fdp_thr_s1_l  (fcl_fdp_thr_s1_l[3:0]),
                     .fcl_fdp_next_thr_bf_l(fcl_fdp_next_thr_bf_l[3:0]),
                     .fcl_fdp_next_ctxt_bf_l(fcl_fdp_next_ctxt_bf_l[3:0]),
                     .fcl_fdp_nirthr_s1_l(fcl_fdp_nirthr_s1_l[3:0]),
                     .fcl_fdp_thr_s2_l  (fcl_fdp_thr_s2_l[3:0]),
                     .fcl_fdp_tpcbf_sel_pcp4_bf_l(fcl_fdp_tpcbf_sel_pcp4_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_brpc_bf_l(fcl_fdp_tpcbf_sel_brpc_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_trap_bf_l(fcl_fdp_tpcbf_sel_trap_bf_l[3:0]),
                     .fcl_fdp_tpcbf_sel_old_bf_l(fcl_fdp_tpcbf_sel_old_bf_l[3:0]),
                     .fcl_fdp_pcbf_sel_nosw_bf_l(fcl_fdp_pcbf_sel_nosw_bf_l),
                     .fcl_fdp_pcbf_sel_swpc_bf_l(fcl_fdp_pcbf_sel_swpc_bf_l),
                     .fcl_fdp_pcbf_sel_br_bf_l(fcl_fdp_pcbf_sel_br_bf_l),
                     .fcl_fdp_trrbpc_sel_trap_bf_l(fcl_fdp_trrbpc_sel_trap_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_rb_bf_l(fcl_fdp_trrbpc_sel_rb_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_err_bf_l(fcl_fdp_trrbpc_sel_err_bf_l[3:0]),
                     .fcl_fdp_trrbpc_sel_pcs_bf_l(fcl_fdp_trrbpc_sel_pcs_bf_l[3:0]),
                     .fcl_fdp_noswpc_sel_tnpc_l_bf(fcl_fdp_noswpc_sel_tnpc_l_bf),
                     .fcl_fdp_noswpc_sel_old_l_bf(fcl_fdp_noswpc_sel_old_l_bf),
                     .fcl_fdp_noswpc_sel_inc_l_bf(fcl_fdp_noswpc_sel_inc_l_bf),
                     .fcl_fdp_nextpcs_sel_pce_f_l(fcl_fdp_nextpcs_sel_pce_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcd_f_l(fcl_fdp_nextpcs_sel_pcd_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcs_f_l(fcl_fdp_nextpcs_sel_pcs_f_l[3:0]),
                     .fcl_fdp_nextpcs_sel_pcf_f_l(fcl_fdp_nextpcs_sel_pcf_f_l[3:0]),
                     .fcl_fdp_inst_sel_curr_s_l(fcl_fdp_inst_sel_curr_s_l),
                     .fcl_fdp_inst_sel_switch_s_l(fcl_fdp_inst_sel_switch_s_l),
                     .fcl_fdp_inst_sel_nir_s_l(fcl_fdp_inst_sel_nir_s_l),
                     .fcl_fdp_inst_sel_nop_s_l(fcl_fdp_inst_sel_nop_s_l),
                     .fcl_fdp_tinst_sel_curr_s_l(fcl_fdp_tinst_sel_curr_s_l[3:0]),
                     .fcl_fdp_tinst_sel_rb_s_l(fcl_fdp_tinst_sel_rb_s_l[3:0]),
                     .fcl_fdp_tinst_sel_old_s_l(fcl_fdp_tinst_sel_old_s_l[3:0]),
                     .fcl_fdp_tinst_sel_ifq_s_l(fcl_fdp_tinst_sel_ifq_s_l[3:0]),
                     .fcl_fdp_dmpthr_l  (fcl_fdp_dmpthr_l[3:0]),
                     .fcl_fdp_ctxt_sel_dmp_bf_l(fcl_fdp_ctxt_sel_dmp_bf_l),
                     .fcl_fdp_ctxt_sel_sw_bf_l(fcl_fdp_ctxt_sel_sw_bf_l),
                     .fcl_fdp_ctxt_sel_curr_bf_l(fcl_fdp_ctxt_sel_curr_bf_l),
                     .fcl_fdp_rdsr_sel_pc_e_l(fcl_fdp_rdsr_sel_pc_e_l),
                     .fcl_fdp_rdsr_sel_thr_e_l(fcl_fdp_rdsr_sel_thr_e_l),
                     .fcl_fdp_rdsr_sel_ver_e_l(fcl_fdp_rdsr_sel_ver_e_l),
                     .fcl_fdp_tlbmiss_s1 (fcl_fdp_tlbmiss_s1),
                     .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
                     .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
                     .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
                     .fcl_esl_thr_e (fcl_esl_thr_e),
                     .fcl_esl_thr_m (fcl_esl_thr_m),
                     .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
                     .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
                     .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
                     .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
                     .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
                     // Inputs
                     
                     .tlu_itlb_csm_rd_g (tlu_itlb_csm_rd_g),
                     
                     .rclk              (rclk),
                     .grst_l            (grst_l),
                     .arst_l            (arst_l),
                     .se                (se),
                     .sehold            (sehold),
                     .tlu_ifu_flush_pipe_w(tlu_ifu_flush_pipe_w),
                     .exu_ifu_va_oor_m  (exu_ifu_va_oor_m),
                     .exu_ifu_oddwin_s  (exu_ifu_oddwin_s[3:0]),
                     .spu_ifu_ttype_tid_w2(spu_ifu_ttype_tid_w2[1:0]),
                     .spu_ifu_ttype_vld_w2(spu_ifu_ttype_vld_w2),
                     .spu_ifu_ttype_w2  (spu_ifu_ttype_w2),
                     .erb_fcl_spu_uetrap(erb_fcl_spu_uetrap[3:0]),
                     .exu_ifu_regz_e    (exu_ifu_regz_e),
                     .dcl_fcl_bcregz0_e (dcl_fcl_bcregz0_e),
                     .dcl_fcl_bcregz1_e (dcl_fcl_bcregz1_e),
                     .dtu_fcl_rollback_g(dtu_fcl_rollback_g),
                     .dtu_fcl_retract_d (dtu_fcl_retract_d),
                     .dtu_fcl_br_inst_d (dtu_fcl_br_inst_d),
                     .dtu_fcl_sir_inst_e(dtu_fcl_sir_inst_e),
                     .dtu_fcl_privop_e  (dtu_fcl_privop_e),
                     .dtu_fcl_fpdis_e   (dtu_fcl_fpdis_e),
                     .dtu_fcl_imask_hit_e(dtu_fcl_imask_hit_e),
                     .dtu_fcl_illinst_e (dtu_fcl_illinst_e),
                     .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                     .dec_fcl_rdsr_sel_pc_d(dec_fcl_rdsr_sel_pc_d),
                     .dec_fcl_rdsr_sel_thr_d(dec_fcl_rdsr_sel_thr_d),
                     .ifq_fcl_wrreq_bf  (ifq_fcl_wrreq_bf),
                     .ifq_fcl_icd_wrreq_bf(ifq_fcl_icd_wrreq_bf),
                     .ifq_fcl_ictv_wrreq_bf(ifq_fcl_ictv_wrreq_bf),
                     .ifq_fcl_rdreq_bf  (ifq_fcl_rdreq_bf),
                     .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                     .ifq_fcl_asird_bf  (ifq_fcl_asird_bf),
                     .ifq_fcl_invreq_bf (ifq_fcl_invreq_bf),
                     .erb_fcl_itlb_ce_d1(erb_fcl_itlb_ce_d1),
                     .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                     .erb_fcl_ifet_uevec_d1(erb_fcl_ifet_uevec_d1[3:0]),
                     .erb_fcl_ue_trapvec(erb_fcl_ue_trapvec[3:0]),
                     .erb_fcl_ce_trapvec(erb_fcl_ce_trapvec[3:0]),
                     .dtu_fcl_nextthr_bf(dtu_fcl_nextthr_bf[3:0]),
                     .dtu_fcl_ntr_s     (dtu_fcl_ntr_s),
                     .dtu_fcl_running_s (dtu_fcl_running_s),
                     .dtu_fcl_flush_sonly_e(dtu_fcl_flush_sonly_e),
                     .fdp_fcl_swc_s2    (fdp_fcl_swc_s2),
                     .itlb_fcl_tlbmiss_f_l(itlb_fcl_tlbmiss_f_l),
                     .itlb_fcl_imiss_s_l(itlb_fcl_imiss_s_l),
                     .fdp_fcl_pc_oor_vec_f(fdp_fcl_pc_oor_vec_f[3:0]),
                     .fdp_fcl_pc_oor_e  (fdp_fcl_pc_oor_e),
                     .fdp_fcl_op_s      (fdp_fcl_op_s[1:0]),
                     .fdp_fcl_op3_s     (fdp_fcl_op3_s[5:2]),
                     .fdp_fcl_ibit_s    (fdp_fcl_ibit_s),
                     .lsu_ifu_stallreq  (lsu_ifu_stallreq),
                     .ffu_ifu_stallreq  (ffu_ifu_stallreq),
                     .ifq_fcl_stallreq  (ifq_fcl_stallreq),
                     .dtu_inst_anull_e  (dtu_inst_anull_e),
                     .ifq_fcl_fill_thr  (ifq_fcl_fill_thr[3:0]),
                     .ifq_fcl_flush_sonly_e(ifq_fcl_flush_sonly_e),
                     .tlu_ifu_trap_tid_w1(tlu_ifu_trap_tid_w1[1:0]),
                     .tlu_ifu_trappc_vld_w1(tlu_ifu_trappc_vld_w1),
                     .tlu_ifu_trapnpc_vld_w1(tlu_ifu_trapnpc_vld_w1),
                     .tlu_lsu_pstate_priv(tlu_lsu_pstate_priv[3:0]),
                     .tlu_lsu_pstate_am (tlu_lsu_pstate_am[3:0]),
                     .tlu_hpstate_priv  (tlu_hpstate_priv[3:0]),
                     .tlu_lsu_redmode   (tlu_lsu_redmode[3:0]),
                     .tlu_hpstate_enb   (tlu_hpstate_enb[3:0]),
                     .lsu_ifu_addr_real_l(lsu_ifu_addr_real_l[3:0]),
                     .lsu_pid_state0    (lsu_pid_state0[2:0]),
                     .lsu_pid_state1    (lsu_pid_state1[2:0]),
                     .lsu_pid_state2    (lsu_pid_state2[2:0]),
                     .lsu_pid_state3    (lsu_pid_state3[2:0]),
                     .lsu_ifu_icache_en (lsu_ifu_icache_en_muxed[3:0]),
                     .lsu_ifu_dc_parity_error_w2(lsu_ifu_dc_parity_error_w2),
                     .lsu_ifu_t0_tlz    (lsu_ifu_t0_tlz),
                     .lsu_ifu_t1_tlz    (lsu_ifu_t1_tlz),
                     .lsu_ifu_t2_tlz    (lsu_ifu_t2_tlz),
                     .lsu_ifu_t3_tlz    (lsu_ifu_t3_tlz),
                     .tlu_ifu_hwint_i3  (tlu_ifu_hwint_i3[3:0]),
                     .tlu_ifu_pstate_ie (tlu_ifu_pstate_ie[3:0]),
                     .tlu_ifu_sftint_vld(tlu_ifu_sftint_vld[3:0]),
                     .tlu_ifu_hintp_vld (tlu_ifu_hintp_vld[3:0]),
                     .tlu_ifu_rerr_vld  (tlu_ifu_rerr_vld[3:0]),
                     .tlu_ifu_rstthr_i2 (tlu_ifu_rstthr_i2[3:0]),
                     .tlu_ifu_rstint_i2 (tlu_ifu_rstint_i2),
                     .tlu_ifu_resumint_i2(tlu_ifu_resumint_i2),
                     .tlu_ifu_nukeint_i2(tlu_ifu_nukeint_i2),
                     .tlu_itlb_wr_vld_g (tlu_itlb_wr_vld_g),
                     .tlu_itlb_dmp_vld_g(tlu_itlb_dmp_vld_g),
                     .tlu_itlb_dmp_all_g(tlu_itlb_dmp_all_g),
                     .tlu_itlb_data_rd_g(tlu_itlb_data_rd_g),
                     .tlu_itlb_tag_rd_g (tlu_itlb_tag_rd_g),
                     .tlu_itlb_invalidate_all_g(tlu_itlb_invalidate_all_g),
                     .tlu_idtlb_dmp_thrid_g(tlu_idtlb_dmp_thrid_g[1:0]),
                     .exu_ifu_ecc_ce_m  (exu_ifu_ecc_ce_m),
                     .ffu_ifu_fst_ce_w  (ffu_ifu_fst_ce_w),
                     .config_dtu_esl_en (config_dtu_esl_en),
                     .esl_fcl_stall_bf  (esl_fcl_stall_bf),
                     .esl_fcl_switch_bf (esl_fcl_switch_bf),
                     .esl_fcl_ntr_s (esl_fcl_ntr_s),
                     .esl_fdp_issue_prev_inst_s (esl_fdp_issue_prev_inst_s),
                     .esl_fcl_force_running_s (esl_fcl_force_running_s),

                     .fdp_fcl_jtag_breakpoint_hit(fdp_fcl_jtag_breakpoint_hit),

                     // .core_rtap_data          (core_rtap_data),
                     .rtap_core_val         (rtap_core_val),
                     .rtap_core_threadid         (rtap_core_threadid),
                     .rtap_core_id         (rtap_core_id),
                     .rtap_core_data         (rtap_core_data)
                     );

//   sparc_ifu_itlb itlb(
//                        .adj    (lsu_idtlb_mrgn[7:0]),
//			                  .reset  (fcl_itlb_invall_bf),
//                        .tlu_itlb_dmp_actxt_g(tlu_itlb_dmp_actxt_g),
//                        .itlb_vaddr_offset_f (fdp_erb_pc_f[`IC_IDX_HI:(`IC_IDX_HI-1)]),
//			                  /*AUTOINST*/
//                        // Outputs
//                        .ifu_lsu_tlb_writeable(ifu_lsu_tlb_writeable),
//                        .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
//                        .itlb_icd_waysel_s1(itlb_icd_waysel_s1[`IC_WAY_ARRAY_MASK]),
//                        .itlb_fcl_imiss_s_l(itlb_fcl_imiss_s_l),
//                        .itlb_fcl_tlbmiss_f_l(itlb_fcl_tlbmiss_f_l),
//                        .itlb_fcl_priv_s1(itlb_fcl_priv_s1),
//                        .itlb_rd_tte_data(itlb_rd_tte_data[42:0]),
//                        .itlb_rd_tte_tag(itlb_rd_tte_tag[58:0]),
//                        .so             (so),
                        // Inputs
//                        .clk            (clk),
//                        .se             (se),
//                        .si             (si),
//                        .fdp_icd_vaddr_bf(fdp_icd_vaddr_bf[47:10]),
//                        .fdp_itlb_ctxt_bf(fdp_itlb_ctxt_bf[12:0]),
//                        .ict_itlb_tags_f(ict_itlb_tags_f[`IC_TAG_ALL_HI:0]),
//                        .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
//                        .fcl_itlb_cam_vld_bf(fcl_itlb_cam_vld_bf),
//                        .fcl_itlb_wr_vld_bf(fcl_itlb_wr_vld_bf),
//                        .fcl_itlb_addr_mask_l(fcl_itlb_addr_mask_l),
//                        .fcl_itlb_dmp_vld_bf(fcl_itlb_dmp_vld_bf),
//                        .fcl_itlb_tag_rd_vld_bf(fcl_itlb_tag_rd_vld_bf),
//                        .fcl_itlb_data_rd_vld_bf(fcl_itlb_data_rd_vld_bf),
//                        .fcl_itlb_cam_real_bf(fcl_itlb_cam_real_bf),
//                        .fcl_itlb_cam_pid_bf(fcl_itlb_cam_pid_bf[2:0]),
//                        .tlu_itlb_tte_tag_w2(tlu_itlb_tte_tag_w2[58:0]),
//                        .tlu_itlb_tte_data_w2(tlu_itlb_tte_data_w2[42:0]),
//                        .tlu_itlb_rw_index_vld_g(tlu_itlb_rw_index_vld_g),
//                        .tlu_itlb_rw_index_g(tlu_itlb_rw_index_g[5:0]),
//                        .tlu_idtlb_dmp_key_g(tlu_idtlb_dmp_key_g[40:0]),
//                        .tlu_itlb_dmp_by_ctxt_g(tlu_itlb_dmp_by_ctxt_g),
//                        .tlu_itlb_dmp_all_g(tlu_itlb_dmp_all_g));

   bw_r_itlb itlb(
		              .tlb_pgnum_crit	(),
		              // Outputs
                       
                       .tlb_rd_tte_csm         (itlb_ifq_csm_s),
                       .tlb_rd_tte_csm_crit    (),
                       

		              .tlb_rd_tte_tag	 (itlb_rd_tte_tag[58:0]),  // 2
		              .tlb_rd_tte_data (itlb_rd_tte_data[42:0]), // 2
		              .tlb_pgnum	     (itlb_ifq_paddr_s[39:10]), // 2
		              .tlb_cam_hit	   (itlb_fcl_tlbmiss_f_l),    // 1
		              .cache_way_hit   (itlb_wsel_waysel_s1[2-1:0]), // 2
		              .cache_hit       (itlb_fcl_imiss_s_l),      // 2
		              .so		(short_scan0_1),

		                  // Inputs
                  
                  .tlb_wr_tte_csm_thrid   (tlu_idtlb_dmp_thrid_g[1:0]),
                  .tlb_wr_tte_csm         (tlu_itlb_tte_csm_w2),
                  .tlb_rd_csm_vld         (fcl_itlb_csm_rd_vld_bf),
                  .tlb_wr_csm_sel         (tlu_itlb_wr_csm_sel_g),

                  .cfg_csm_tlb_state      (cfg_ifu_csm_itlb_state),
                  .cfg_csm_tlb_chipid     (cfg_ifu_csm_itlb_chipid),
                  .cfg_csm_tlb_x          (cfg_ifu_csm_itlb_x),
                  .cfg_csm_tlb_y          (cfg_ifu_csm_itlb_y),
                  .cfg_csm_tlb_hdid       (cfg_ifu_csm_itlb_hdid),
                  .cfg_csm_tlb_hd_size    (cfg_ifu_csm_itlb_hd_size),
                  .cfg_csm_tlb_sdid       (cfg_ifu_csm_itlb_sdid),
                  .cfg_csm_tlb_lsid       (cfg_ifu_csm_itlb_lsid),

                  

                  .rclk          (rclk),
                  .rst_tri_en    (mem_write_disable),
		              .tlb_cam_vld	(fcl_itlb_cam_vld_bf),       // 0

//`ifdef SPARC_HPV_EN
                  .tlb_cam_key   ({fdp_icd_vaddr_bf[47:28],  // 0
                                   1'b1,
                                   fdp_icd_vaddr_bf[27:22],
                                   1'b1,
                                   fdp_icd_vaddr_bf[21:16],
                                   1'b1,
                                   fdp_icd_vaddr_bf[15:13],
                                   1'b1,
                                   fcl_itlb_cam_real_bf,  // g is the same as r
                                   fcl_itlb_cam_real_bf}),// this is the r bit

//`else // !`ifdef SPARC_HPV_EN
//                  .tlb_cam_key ({1'b0, // unused          // 0
//                                 fdp_icd_vaddr_bf[47:35],
//					                       1'b1, // v47_22
//					                       fdp_icd_vaddr_bf[34:22],
//					                       fdp_icd_vaddr_bf[21:20],
//					                       1'b1, // v21_19
//					                       fdp_icd_vaddr_bf[19],
//					                       fdp_icd_vaddr_bf[18:17],
//					                       1'b1, // v18_16
//					                       fdp_icd_vaddr_bf[16],
//					                       fdp_icd_vaddr_bf[15:14],
//					                       1'b1, // v15_13
//					                       fdp_icd_vaddr_bf[13], // global bit
//					                       1'b0}),  // all r's are zero
//
//                  .tlb_cam_real     (fcl_itlb_cam_real_bf),    // 0
//		              .tlb_demap_ctxt 	(tlu_itlb_dmp_by_ctxt_g),  // 0
//`endif

                  .tlb_cam_pid    (fcl_itlb_cam_pid_bf[2:0]),  // 0
		              .tlb_demap_key	(tlu_idtlb_dmp_key_g[40:0]), // 0

		              .tlb_addr_mask_l (fcl_itlb_addr_mask_l),      // 0
		              .tlb_ctxt		     (fdp_itlb_ctxt_bf[12:0]),    // 0

		              .tlb_wr_vld	    (fcl_itlb_wr_vld_bf),         // 0
		              .tlb_wr_tte_tag	(tlu_itlb_tte_tag_w2[58:0]),  // 1
		              .tlb_wr_tte_data(tlu_itlb_tte_data_w2[42:0]), // 1

		              .tlb_rd_tag_vld	 (fcl_itlb_tag_rd_vld_bf),    // 0
		              .tlb_rd_data_vld (fcl_itlb_data_rd_vld_bf),   // 0
		              .tlb_rw_index_vld(tlu_itlb_rw_index_vld_g),   // 0
		              .tlb_rw_index	   (tlu_itlb_rw_index_g[5:0]),  // 0

		              .tlb_demap	    (fcl_itlb_dmp_vld_bf),        // 0
		              .tlb_demap_all	(fcl_itlb_dmp_all_bf),        // 0
                  .tlb_demap_auto (tlu_itlb_dmp_actxt_g),

// trin: since the TLB is configured at fixed 30b per entry, this is the only way to do it
//    until TLB is also parameterized
                    .cache_ptag  (ict_itlb_tags_f),

		              .cache_set_vld	(icv_itlb_valid_f[3:0]),     // 1

		              .tlb_bypass	    (fcl_itlb_cam_bypass_bf),    // 0
		              .tlb_bypass_va	(fdp_icd_vaddr_bf[12:10]),   // 0

		              .si		(short_si0),
		              .se		(se),
                  .hold (sehold),
		              .adj		    (lsu_idtlb_mrgn[7:0]),
                 // tlb expects this to be asynchronous reset!
                  .arst_l     (arst_l),
		              .rst_soft_l (fcl_itlb_invall_f_l));  // 1


   sparc_ifu_wseldp wseldp(
                           .so          (scan0_6),
                           .si          (scan0_5),
                           .wsel_mbist_icache_data(wsel_mbist_icache_data[67:0]),
                           // .wsel_mbist_icache_data(),
                         /*AUTOINST*/
                           // Outputs
                           .wsel_fdp_fetdata_s1(wsel_fdp_fetdata_s1[33:0]),
                           .wsel_fdp_topdata_s1(wsel_fdp_topdata_s1[33:0]),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .icd_wsel_fetdata_s1(icd_wsel_fetdata_s1[135:0]),
                           .icd_wsel_topdata_s1(icd_wsel_topdata_s1[135:0]),
                           .itlb_wsel_waysel_s1(itlb_wsel_waysel_s1[2-1:0]),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[0:0]));


//   sparc_ifu_icd icd
   bw_r_icd icd(
                .so                     (scan0_8),
                .si                     (scan0_7),
			           .fdp_icd_index_bf  (fdp_icd_vaddr_bf[(6 + 5):2]),
                 .ifq_icd_index_bf  ({ifq_icd_index_bf[(6 + 5):2]}),
                 .bist_ic_data      (8'b0),
                 // .bist_ic_data      (mbist_icache_wdata[7:0]),
                 .rst_tri_en        (mem_write_disable),
                 .reset_l           (arst_l),
			           /*AUTOINST*/
                // Outputs
                .icd_wsel_fetdata_s1    (icd_wsel_fetdata_s1[135:0]),
                .icd_wsel_topdata_s1    (icd_wsel_topdata_s1[135:0]),
                .icd_fuse_repair_value  (icd_fuse_repair_value[7:0]),
                .icd_fuse_repair_en     (icd_fuse_repair_en[1:0]),
                // Inputs
                .rclk                   (rclk),
                .se                     (se),
                .sehold                 (sehold),
                .fcl_icd_index_sel_ifq_bf(fcl_icd_index_sel_ifq_bf),
                .ifq_icd_wrway_bf       (ifq_icd_wrway_bf[0:0]),
                .ifq_icd_worden_bf      (ifq_icd_worden_bf[3:0]),
                .ifq_icd_wrdata_i2      (ifq_icd_wrdata_i2[135:0]),
                .fcl_icd_rdreq_bf       (fcl_icd_rdreq_bf),
                .fcl_icd_wrreq_bf       (fcl_icd_wrreq_bf),
                .ifq_icd_data_sel_old_i2(ifq_icd_data_sel_old_i2),
                .ifq_icd_data_sel_fill_i2(ifq_icd_data_sel_fill_i2),
                .ifq_icd_data_sel_bist_i2(ifq_icd_data_sel_bist_i2),
                .fuse_icd_wren          (1'b0),
                .fuse_icd_rid           (4'b0),
                .fuse_icd_repair_value  (8'b0),
                .fuse_icd_repair_en     (2'b0),
                .efc_spc_fuse_clk1      (1'b0),
                // .efc_spc_fuse_clk1      (efc_spc_fuse_clk1),

                // interface to srams
                .sram_icache_w10_rtap_data (sram_icache_w10_rtap_data),
                .sram_icache_w32_rtap_data (sram_icache_w32_rtap_data),
                .rtap_srams_bist_command (rtap_srams_bist_command),
                .rtap_srams_bist_data (rtap_srams_bist_data)
                );

/*   bw_r_ict AUTO_TEMPLATE(
                     // Inputs
                     .adj          (lsu_ictag_mrgn[3:0]),
                     .reset_l      (arst_l),
		                 .index0_x     (fdp_icd_vaddr_bf[`IC_IDX_HI:5]),
                     .index1_x     (ifq_icd_index_bf[`IC_IDX_HI:5]),
                     .index_sel_x  (fcl_icd_index_sel_ifq_bf),
                     .dec_wrway_x  (ifq_ict_dec_wrway_bf[`IC_WAY_ARRAY_MASK]),
                     .wrtag_w0_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w1_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w2_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .wrtag_w3_y   ({4'b0, ifq_ict_wrtag_f[`IC_TAG_SZ:0]}),
                     .rdreq_x      (fcl_icd_rdreq_bf),
                     .wrreq_x      (fcl_ict_wrreq_bf));
 */

   bw_r_ict ict(
                 .so                    (short_scan0_2),
                 .si                    (short_scan0_1),
                 .rdtag_y    (ict_itlb_tags_f),
                 .rst_tri_en        (mem_write_disable),

                     /*AUTOINST*/
                 // Inputs
                 .rclk                  (rclk),
                 .se                    (se),
                 .reset_l               (arst_l),                // Templated
                 .sehold                (sehold),
                 .index0_x              (fdp_icd_vaddr_bf[(6 + 5):5]), // Templated
                 .index1_x              (ifq_icd_index_bf[(6 + 5):5]), // Templated
                 .index_sel_x           (fcl_icd_index_sel_ifq_bf), // Templated
                 .dec_wrway_x           (ifq_ict_dec_wrway_bf[2-1:0]), // Templated
                 .rdreq_x               (fcl_icd_rdreq_bf),      // Templated
                 .wrreq_x               (fcl_ict_wrreq_bf),      // Templated
                 .wrtag_y            (ifq_ict_wrtag_f),// Templated
                 .wrtag_x            (ifq_ict_wrtag_bf),// Templated
                 .adj                   (lsu_ictag_mrgn[3:0]),

                 // debug interface
                 .sramid   (8'd9),
                 .srams_rtap_data   (sram_itag_rtap_data),
                 .rtap_srams_bist_command   (rtap_srams_bist_command),
                 .rtap_srams_bist_data   (rtap_srams_bist_data)
                 );
//     sparc_ifu_icv icv
/*   sram_l1i_val AUTO_TEMPLATE(
                    // Outputs
                    .dout          (icv_itlb_valid_f[3:0]),
                    .so            (short_so0),
                    // Inputs
                    .clk           (clk),
                    .se            (se),
                    .sehold        (sehold),
                    .si            (short_scan0_2),
                    .rst_tri_en        (mem_write_disable),
                    .reset_l       (arst_l),
		                .rd_adr2       (fdp_icv_index_bf[`IC_IDX_HI:5]),
                    .rd_adr1       (ifq_icv_wrindex_bf[`IC_IDX_HI:5]),
                    .wr_adr        (ifq_icv_wrindex_bf[`IC_IDX_HI:7]),
                    .rd_adr1_sel   (fcl_ifq_grant_bf),
                    .din           (ifq_icv_wrdata_bf),
                    .bit_wen       (ifq_icv_wren_bf[15:0]),
                    .rd_en         (fcl_icv_rdreq_bf),
                    .wr_en         (fcl_icv_wrreq_bf));
 */
   sram_l1i_val  icv(/*AUTOINST*/
                     // Outputs
                     .dout              (icv_itlb_valid_f[3:0]), // Templated
                     .so                (short_so0),             // Templated
                     // Inputs
                     .rclk              (rclk),
                     .se                (se),                    // Templated
                     .si                (short_scan0_2),         // Templated
                     .reset_l           (arst_l),                // Templated
                     .sehold            (sehold),                // Templated
                     .rst_tri_en        (mem_write_disable),     // Templated
                     .rd_adr1           (ifq_icv_wrindex_bf[(6 + 5):5]), // Templated
                     .rd_adr2           (fdp_icv_index_bf[(6 + 5):5]), // Templated
                     .rd_adr1_sel       (fcl_ifq_grant_bf),      // Templated
                     .rd_en             (fcl_icv_rdreq_bf),      // Templated
                     .wr_adr            (ifq_icv_wrindex_bf[(6 + 5):7]), // Templated
                     .wr_en             (fcl_icv_wrreq_bf),      // Templated
                     .bit_wen           (ifq_icv_wren_bf[15:0]), // Templated
                     .din               (ifq_icv_wrdata_bf),

                     // debug interface
                     .sramid            (8'd11),
                     .rtap_srams_bist_command   (rtap_srams_bist_command),
                     .rtap_srams_bist_data      (rtap_srams_bist_data),
                     .srams_rtap_data           (icv_rtap_data)
                     );     // Templated
   sparc_ifu_ifqdp ifqdp(
                         .so            (short_so1),
                         .si            (short_scan1_1),
                        .ifq_ict_wrtag_f(ifq_ict_wrtag_f[(39 - (6 + 5)):0]),
                        .ifq_ict_wrtag_bf(ifq_ict_wrtag_bf[(39 - (6 + 5)):0]),
                         .fdp_ifq_paddr_f(fdp_erb_pc_f[9:2]),
                         /*AUTOINST*/
                         // Outputs
                         
                         .ifu_lsu_pcxcsm_e(ifu_lsu_pcxcsm_e),
                         

                         .ifu_lsu_pcxpkt_e(ifu_lsu_pcxpkt_e[51:0]),
                         .ifq_fdp_fill_inst(ifq_fdp_fill_inst[32:0]),
                         .ifq_erb_asidata_i2(ifq_erb_asidata_i2[47:0]),
                         .ifd_inv_ifqop_i2(ifd_inv_ifqop_i2[145-1:0]),
                         .ifq_icd_index_bf(ifq_icd_index_bf[(6 + 5):2]),
                         .ifq_icd_wrdata_i2(ifq_icd_wrdata_i2[135:0]),
                         .ifq_erb_wrindex_f(ifq_erb_wrindex_f[(6 + 5):4]),
                         .ifq_icd_wrway_bf(ifq_icd_wrway_bf[0:0]),
                         .ifd_ifc_milhit_s(ifd_ifc_milhit_s[3:0]),
                         .ifd_ifc_instoffset0(ifd_ifc_instoffset0[1:0]),
                         .ifd_ifc_instoffset1(ifd_ifc_instoffset1[1:0]),
                         .ifd_ifc_instoffset2(ifd_ifc_instoffset2[1:0]),
                         .ifd_ifc_instoffset3(ifd_ifc_instoffset3[1:0]),
                         .ifd_ifc_cpxthr_nxt(ifd_ifc_cpxthr_nxt[1:0]),
                         .ifd_ifc_cpxreq_nxt(ifd_ifc_cpxreq_nxt[3:0]),
                         .ifd_ifc_cpxreq_i1(ifd_ifc_cpxreq_i1[(143 - 140 + 1):0]),
                         .ifd_ifc_destid0(ifd_ifc_destid0[2:0]),
                         .ifd_ifc_destid1(ifd_ifc_destid1[2:0]),
                         .ifd_ifc_destid2(ifd_ifc_destid2[2:0]),
                         .ifd_ifc_destid3(ifd_ifc_destid3[2:0]),
                         .ifd_ifc_newdestid_s(ifd_ifc_newdestid_s[2:0]),
                         .ifd_ifc_pcxline_d(ifd_ifc_pcxline_d[4:2]),
                         .ifd_ifc_asi_vachklo_i2(ifd_ifc_asi_vachklo_i2),
                         .ifd_ifc_cpxvld_i2(ifd_ifc_cpxvld_i2),
                         .ifd_ifc_asiaddr_i2(ifd_ifc_asiaddr_i2[3:2]),
                         .ifd_ifc_iobpkt_i2(ifd_ifc_iobpkt_i2),
                         .ifd_ifc_fwd2ic_i2(ifd_ifc_fwd2ic_i2),
                         .ifd_ifc_4bpkt_i2(ifd_ifc_4bpkt_i2),
                         .ifd_ifc_cpxnc_i2(ifd_ifc_cpxnc_i2),
                         .ifd_ifc_cpxce_i2(ifd_ifc_cpxce_i2),
                         .ifd_ifc_cpxue_i2(ifd_ifc_cpxue_i2),
                         .ifd_ifc_cpxms_i2(ifd_ifc_cpxms_i2),
                         .ifd_ifc_miladdr4_i2(ifd_ifc_miladdr4_i2[3:0]),
                         .ifd_inv_wrway_i2(ifd_inv_wrway_i2[0:0]),
                         .ifq_fdp_fill_paddr(ifq_fdp_fill_paddr[39:2]),
                         // Inputs
                         
                         .itlb_ifq_csm_s (itlb_ifq_csm_s),
                         
                         .rclk          (rclk),
                         .se            (se),
                         .lsu_ifu_cpxpkt_i1(lsu_ifu_cpxpkt_i1[145-1:0]),
                         .lsu_ifu_asi_addr(lsu_ifu_asi_addr[17:0]),
                         .lsu_ifu_stxa_data(lsu_ifu_stxa_data[47:0]),
                         .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
                         .ifc_ifd_reqvalid_e(ifc_ifd_reqvalid_e),
                         .ifc_ifd_filladdr4_i2(ifc_ifd_filladdr4_i2),
                         .ifc_ifd_repway_s(ifc_ifd_repway_s[0:0]),
                         .ifc_ifd_uncached_e(ifc_ifd_uncached_e),
                         .ifc_ifd_thrid_e(ifc_ifd_thrid_e[1:0]),
                         .ifc_ifd_pcxline_adj_d(ifc_ifd_pcxline_adj_d[4:2]),
                         .ifc_ifd_errinv_e(ifc_ifd_errinv_e),
                         .ifc_ifd_ldmil_sel_new(ifc_ifd_ldmil_sel_new[3:0]),
                         .ifc_ifd_ld_inq_i1(ifc_ifd_ld_inq_i1),
                         .ifc_ifd_idx_sel_fwd_i2(ifc_ifd_idx_sel_fwd_i2),
                         .ifc_ifd_milreq_sel_d_l(ifc_ifd_milreq_sel_d_l[3:0]),
                         .ifc_ifd_milfill_sel_i2_l(ifc_ifd_milfill_sel_i2_l[3:0]),
                         .ifc_ifd_finst_sel_l(ifc_ifd_finst_sel_l[3:0]),
                         .ifc_ifd_ifqbyp_sel_fwd_l(ifc_ifd_ifqbyp_sel_fwd_l),
                         .ifc_ifd_ifqbyp_sel_inq_l(ifc_ifd_ifqbyp_sel_inq_l),
                         .ifc_ifd_ifqbyp_sel_asi_l(ifc_ifd_ifqbyp_sel_asi_l),
                         .ifc_ifd_ifqbyp_sel_lsu_l(ifc_ifd_ifqbyp_sel_lsu_l),
                         .ifc_ifd_ifqbyp_en_l(ifc_ifd_ifqbyp_en_l),
                         .ifc_ifd_addr_sel_bist_i2_l(ifc_ifd_addr_sel_bist_i2_l),
                         .ifc_ifd_addr_sel_asi_i2_l(ifc_ifd_addr_sel_asi_i2_l),
                         .ifc_ifd_addr_sel_old_i2_l(ifc_ifd_addr_sel_old_i2_l),
                         .ifc_ifd_addr_sel_fill_i2_l(ifc_ifd_addr_sel_fill_i2_l),
                         .mbist_icache_way(2'b0),
                         .mbist_icache_word(1'b0),
                         .mbist_icache_index(8'b0)
                         );

   sparc_ifu_ifqctl ifqctl(
                           .so          (scan0_9),
                           .si          (scan0_8),
                           .ifd_ifc_cpxvalid_i1(lsu_ifu_cpxpkt_i1[144]),
			   .lsu_ifu_cpxpkt_wayvld_i1 (lsu_ifu_cpxpkt_i1[133]),
                           .ifq_sscan_data(ifq_sscan_data[3:0]),
                           .rst_tri_en  (mux_drive_disable),

                           /*AUTOINST*/
                           // Outputs
                           .ifu_lsu_inv_clear(ifu_lsu_inv_clear),
                           .ifu_lsu_ibuf_busy(ifu_lsu_ibuf_busy),
                           .ifu_lsu_asi_ack(ifu_lsu_asi_ack),
                           .ifu_lsu_ldxa_illgl_va_w2(ifu_lsu_ldxa_illgl_va_w2),
                           .ifu_lsu_fwd_wr_ack(ifu_lsu_fwd_wr_ack),
                           .ifu_lsu_pcxreq_d(ifu_lsu_pcxreq_d),
                           .ifu_lsu_destid_s(ifu_lsu_destid_s[2:0]),
                           .ifu_tlu_l2imiss(ifu_tlu_l2imiss[3:0]),
                           .ifq_fcl_stallreq(ifq_fcl_stallreq),
                           .ifq_swl_stallreq(ifq_swl_stallreq),
                           .ifq_fcl_flush_sonly_e(ifq_fcl_flush_sonly_e),
                           .ifq_fcl_wrreq_bf(ifq_fcl_wrreq_bf),
                           .ifq_fcl_rdreq_bf(ifq_fcl_rdreq_bf),
                           .ifq_fcl_icd_wrreq_bf(ifq_fcl_icd_wrreq_bf),
                           .ifq_fcl_ictv_wrreq_bf(ifq_fcl_ictv_wrreq_bf),
                           .ifq_erb_fwdrd_bf(ifq_erb_fwdrd_bf),
                           .ifq_erb_rdtag_f(ifq_erb_rdtag_f),
                           .ifq_erb_rdinst_f(ifq_erb_rdinst_f),
                           .ifq_erb_asi_erren_i2(ifq_erb_asi_erren_i2),
                           .ifq_erb_asi_errstat_i2(ifq_erb_asi_errstat_i2),
                           .ifq_erb_asi_errinj_i2(ifq_erb_asi_errinj_i2),
                           .ifq_erb_asi_erraddr_i2(ifq_erb_asi_erraddr_i2),
                           .ifq_erb_asi_imask_i2(ifq_erb_asi_imask_i2),
                           .ifq_erb_asiwr_i2(ifq_erb_asiwr_i2),
                           .ifq_fcl_asird_bf(ifq_fcl_asird_bf),
                           .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                           .ifq_erb_ue_rep(ifq_erb_ue_rep),
                           .ifq_erb_ce_rep(ifq_erb_ce_rep),
                           .ifq_erb_l2_ue(ifq_erb_l2_ue),
                           .ifq_erb_io_ue(ifq_erb_io_ue),
                           .ifq_erb_ifet_ce(ifq_erb_ifet_ce),
                           .ifq_erb_l2err_tid(ifq_erb_l2err_tid[1:0]),
                           .ifq_icv_wrdata_bf(ifq_icv_wrdata_bf),
                           .ifq_icd_worden_bf(ifq_icd_worden_bf[3:0]),
                           .ifq_fcl_fill_thr(ifq_fcl_fill_thr[3:0]),
                           .ifq_dtu_thrrdy(ifq_dtu_thrrdy[3:0]),
                           .ifq_dtu_pred_rdy(ifq_dtu_pred_rdy[3:0]),
                           .ifc_ifd_filladdr4_i2(ifc_ifd_filladdr4_i2),
                           .ifc_ifd_reqvalid_e(ifc_ifd_reqvalid_e),
                           .ifc_ifd_idx_sel_fwd_i2(ifc_ifd_idx_sel_fwd_i2),
                           .ifc_ifd_errinv_e(ifc_ifd_errinv_e),
                           .ifc_ifd_uncached_e(ifc_ifd_uncached_e),
                           .ifc_ifd_thrid_e(ifc_ifd_thrid_e[1:0]),
                           .ifc_ifd_pcxline_adj_d(ifc_ifd_pcxline_adj_d[4:2]),
                           .ifc_inv_asireq_i2(ifc_inv_asireq_i2),
                           .ifc_ifd_repway_s(ifc_ifd_repway_s[0:0]),
                           .ifc_ifd_milfill_sel_i2_l(ifc_ifd_milfill_sel_i2_l[3:0]),
                           .ifc_ifd_finst_sel_l(ifc_ifd_finst_sel_l[3:0]),
                           .ifc_ifd_milreq_sel_d_l(ifc_ifd_milreq_sel_d_l[3:0]),
                           .ifc_ifd_ifqbyp_sel_fwd_l(ifc_ifd_ifqbyp_sel_fwd_l),
                           .ifc_ifd_ifqbyp_sel_inq_l(ifc_ifd_ifqbyp_sel_inq_l),
                           .ifc_ifd_ifqbyp_sel_asi_l(ifc_ifd_ifqbyp_sel_asi_l),
                           .ifc_ifd_ifqbyp_sel_lsu_l(ifc_ifd_ifqbyp_sel_lsu_l),
                           .ifc_ifd_ifqbyp_en_l(ifc_ifd_ifqbyp_en_l),
                           .ifc_ifd_addr_sel_bist_i2_l(ifc_ifd_addr_sel_bist_i2_l),
                           .ifc_ifd_addr_sel_asi_i2_l(ifc_ifd_addr_sel_asi_i2_l),
                           .ifc_ifd_addr_sel_old_i2_l(ifc_ifd_addr_sel_old_i2_l),
                           .ifc_ifd_addr_sel_fill_i2_l(ifc_ifd_addr_sel_fill_i2_l),
                           .ifq_icd_data_sel_bist_i2(ifq_icd_data_sel_bist_i2),
                           .ifq_icd_data_sel_fill_i2(ifq_icd_data_sel_fill_i2),
                           .ifq_icd_data_sel_old_i2(ifq_icd_data_sel_old_i2),
                           .ifc_ifd_ldmil_sel_new(ifc_ifd_ldmil_sel_new[3:0]),
                           .ifc_ifd_ld_inq_i1(ifc_ifd_ld_inq_i1),
                           .ifc_inv_ifqadv_i2(ifc_inv_ifqadv_i2),
                           // Inputs
                           .ifd_ifc_milhit_s(ifd_ifc_milhit_s[3:0]),
                           .ifd_ifc_instoffset0(ifd_ifc_instoffset0[1:0]),
                           .ifd_ifc_instoffset1(ifd_ifc_instoffset1[1:0]),
                           .ifd_ifc_instoffset2(ifd_ifc_instoffset2[1:0]),
                           .ifd_ifc_instoffset3(ifd_ifc_instoffset3[1:0]),
                           .ifd_ifc_cpxreq_i1(ifd_ifc_cpxreq_i1[(143 - 140 + 1):0]),
                           .ifd_ifc_cpxreq_nxt(ifd_ifc_cpxreq_nxt[3:0]),
                           .ifd_ifc_cpxthr_nxt(ifd_ifc_cpxthr_nxt[1:0]),
                           .ifd_ifc_cpxvld_i2(ifd_ifc_cpxvld_i2),
                           .ifd_ifc_iobpkt_i2(ifd_ifc_iobpkt_i2),
                           .ifd_ifc_4bpkt_i2(ifd_ifc_4bpkt_i2),
                           .ifd_ifc_cpxnc_i2(ifd_ifc_cpxnc_i2),
                           .ifd_ifc_fwd2ic_i2(ifd_ifc_fwd2ic_i2),
                           .ifd_ifc_cpxce_i2(ifd_ifc_cpxce_i2),
                           .ifd_ifc_cpxue_i2(ifd_ifc_cpxue_i2),
                           .ifd_ifc_cpxms_i2(ifd_ifc_cpxms_i2),
                           .ifd_ifc_miladdr4_i2(ifd_ifc_miladdr4_i2[3:0]),
                           .ifd_ifc_asiaddr_i2(ifd_ifc_asiaddr_i2[3:2]),
                           .ifd_ifc_asi_vachklo_i2(ifd_ifc_asi_vachklo_i2),
                           .ifd_ifc_destid0(ifd_ifc_destid0[2:0]),
                           .ifd_ifc_destid1(ifd_ifc_destid1[2:0]),
                           .ifd_ifc_destid2(ifd_ifc_destid2[2:0]),
                           .ifd_ifc_destid3(ifd_ifc_destid3[2:0]),
                           .ifd_ifc_newdestid_s(ifd_ifc_newdestid_s[2:0]),
                           .ifd_ifc_pcxline_d(ifd_ifc_pcxline_d[4:2]),
                           .inv_ifc_inv_pending(inv_ifc_inv_pending),
                           .fcl_ifq_icmiss_s1(fcl_ifq_icmiss_s1),
                           .fcl_ifq_rdreq_s1(fcl_ifq_rdreq_s1),
                           .fcl_ifq_thr_s1(fcl_ifq_thr_s1[1:0]),
                           .fcl_ifq_canthr(fcl_ifq_canthr[3:0]),
                           .fcl_ifq_grant_bf(fcl_ifq_grant_bf),
                           .dtu_ifq_kill_latest_d(dtu_ifq_kill_latest_d),
                           .erb_ifq_ifeterr_d1(erb_ifq_ifeterr_d1),
                           .erb_ifq_itlberr_s1(erb_ifq_itlberr_s1),
                           .lsu_ifu_pcxpkt_ack_d(lsu_ifu_pcxpkt_ack_d),
                           .lsu_ifu_direct_map_l1(lsu_ifu_direct_map_l1),
                           .lsu_ifu_asi_vld(lsu_ifu_asi_vld),
                           .lsu_ifu_asi_state(lsu_ifu_asi_state[7:0]),
                           .lsu_ifu_asi_load(lsu_ifu_asi_load),
                           .lsu_ifu_asi_thrid(lsu_ifu_asi_thrid[1:0]),
                           .fcl_ifq_icache_en_s_l(fcl_ifq_icache_en_s_l),
                           .mbist_ifq_run_bist(1'b0),
                           .mbist_icache_write(1'b0),
                           .mbist_icache_read(1'b0),
                           .ctu_sscan_tid(ctu_sscan_tid[3:0]),
                           .rclk        (rclk),
                           .se          (se),
                           .gdbginit_l  (gdbginit_l),
                           .arst_l      (arst_l),
                           .grst_l      (grst_l),
                           .sehold      (sehold));

   sparc_ifu_invctl invctl(
                           .so          (scan0_10),
                           .si          (scan0_9),
                           /*AUTOINST*/
                           // Outputs
                           .inv_ifc_inv_pending(inv_ifc_inv_pending),
                           .ifq_icv_wrindex_bf(ifq_icv_wrindex_bf[(6 + 5):5]),
                           .ifq_icv_wren_bf(ifq_icv_wren_bf[15:0]),
                           .ifq_ict_dec_wrway_bf(ifq_ict_dec_wrway_bf[2-1:0]),
                           .ifq_fcl_invreq_bf(ifq_fcl_invreq_bf),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[0:0]),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .const_cpuid (const_cpuid[2:0]),
                           .mbist_icache_write(1'b0),
                           // .mbist_icache_write(mbist_icache_write),
                           .lsu_ifu_ld_icache_index(lsu_ifu_ld_icache_index[(6 + 5):5]),
                           .lsu_ifu_ld_pcxpkt_vld(lsu_ifu_ld_pcxpkt_vld),
                           .lsu_ifu_ld_pcxpkt_tid(lsu_ifu_ld_pcxpkt_tid[1:0]),
                           .ifc_inv_ifqadv_i2(ifc_inv_ifqadv_i2),
                           .ifc_inv_asireq_i2(ifc_inv_asireq_i2),
                           .ifq_icd_index_bf(ifq_icd_index_bf[(6 + 5):5]),
                           .ifd_inv_ifqop_i2(ifd_inv_ifqop_i2[145-1:0]),
                           .ifd_inv_wrway_i2(ifd_inv_wrway_i2[0:0]));


   sparc_ifu_errdp  errdp(
                          .so           (scan0_11),
                          .si           (scan0_10),
                         .ifq_erb_wrtag_f(ifq_ict_wrtag_f[(39 - (6 + 5))-1:0]),
                          .ict_itlb_tags_f(ict_itlb_tags_f),
                          .wsel_erb_asidata_s({wsel_mbist_icache_data[65:64],
                                               wsel_mbist_icache_data[31:0]}),
                          // .wsel_erb_asidata_s(34'b0),

			                    /*AUTOINST*/
                          // Outputs
                          .ifu_lsu_ldxa_data_w2(ifu_lsu_ldxa_data_w2[63:0]),
                          .erb_dtu_imask(erb_dtu_imask[38:0]),
                          .erd_erc_tlbt_pe_s1(erd_erc_tlbt_pe_s1[1:0]),
                          .erd_erc_tlbd_pe_s1(erd_erc_tlbd_pe_s1[1:0]),
                          .erd_erc_tagpe_s1(erd_erc_tagpe_s1[3:0]),
                          .erd_erc_nirpe_s1(erd_erc_nirpe_s1),
                          .erd_erc_fetpe_s1(erd_erc_fetpe_s1),
                          .erd_erc_tte_pgsz(erd_erc_tte_pgsz[2:0]),
                          // Inputs
                          .rclk         (rclk),
                          .se           (se),
                          .erb_reset    (erb_reset),
                          .itlb_rd_tte_data(itlb_rd_tte_data[42:0]),
                          .itlb_rd_tte_tag(itlb_rd_tte_tag[58:0]),
                          .itlb_ifq_paddr_s(itlb_ifq_paddr_s[39:10]),
                          .wsel_fdp_fetdata_s1(wsel_fdp_fetdata_s1[33:0]),
                          .wsel_fdp_topdata_s1(wsel_fdp_topdata_s1[33:0]),
                          .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
                          .lsu_ifu_err_addr(lsu_ifu_err_addr[47:4]),
                          .spu_ifu_err_addr_w2(spu_ifu_err_addr_w2[39:4]),
                          .fdp_erb_pc_f (fdp_erb_pc_f[47:0]),
                          .exu_ifu_err_reg_m(exu_ifu_err_reg_m[7:0]),
                          .exu_ifu_err_synd_m(exu_ifu_err_synd_m[7:0]),
                          .ffu_ifu_err_reg_w2(ffu_ifu_err_reg_w2[5:0]),
                          .ffu_ifu_err_synd_w2(ffu_ifu_err_synd_w2[13:0]),
                          .tlu_itlb_rw_index_g(tlu_itlb_rw_index_g[5:0]),
                          .erc_erd_pgsz_b0(erc_erd_pgsz_b0),
                          .erc_erd_pgsz_b1(erc_erd_pgsz_b1),
                          .erc_erd_erren_asidata(erc_erd_erren_asidata[1:0]),
                          .erc_erd_errstat_asidata(erc_erd_errstat_asidata[22:0]),
                          .erc_erd_errinj_asidata(erc_erd_errinj_asidata[31:0]),
                          .ifq_erb_asidata_i2(ifq_erb_asidata_i2[47:0]),
                          .ifq_erb_wrindex_f(ifq_erb_wrindex_f[(6 + 5):4]),
                          .erc_erd_asiway_s1_l(erc_erd_asiway_s1_l[2-1:0]),
                          .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                          .erc_erd_ld_imask(erc_erd_ld_imask),
                          .erc_erd_asisrc_sel_icd_s_l(erc_erd_asisrc_sel_icd_s_l),
                          .erc_erd_asisrc_sel_misc_s_l(erc_erd_asisrc_sel_misc_s_l),
                          .erc_erd_asisrc_sel_err_s_l(erc_erd_asisrc_sel_err_s_l),
                          .erc_erd_asisrc_sel_itlb_s_l(erc_erd_asisrc_sel_itlb_s_l),
                          .erc_erd_errasi_sel_en_l(erc_erd_errasi_sel_en_l),
                          .erc_erd_errasi_sel_stat_l(erc_erd_errasi_sel_stat_l),
                          .erc_erd_errasi_sel_inj_l(erc_erd_errasi_sel_inj_l),
                          .erc_erd_errasi_sel_addr_l(erc_erd_errasi_sel_addr_l),
                          .erc_erd_miscasi_sel_ict_l(erc_erd_miscasi_sel_ict_l),
                          .erc_erd_miscasi_sel_imask_l(erc_erd_miscasi_sel_imask_l),
                          .erc_erd_miscasi_sel_other_l(erc_erd_miscasi_sel_other_l),
                          .erc_erd_asi_thr_l(erc_erd_asi_thr_l[3:0]),
                          .erc_erd_eadr0_sel_irf_l(erc_erd_eadr0_sel_irf_l[3:0]),
                          .erc_erd_eadr0_sel_itlb_l(erc_erd_eadr0_sel_itlb_l[3:0]),
                          .erc_erd_eadr0_sel_frf_l(erc_erd_eadr0_sel_frf_l[3:0]),
                          .erc_erd_eadr0_sel_lsu_l(erc_erd_eadr0_sel_lsu_l[3:0]),
                          .erc_erd_eadr1_sel_pcd1_l(erc_erd_eadr1_sel_pcd1_l[3:0]),
                          .erc_erd_eadr1_sel_l1pa_l(erc_erd_eadr1_sel_l1pa_l[3:0]),
                          .erc_erd_eadr1_sel_l2pa_l(erc_erd_eadr1_sel_l2pa_l[3:0]),
                          .erc_erd_eadr1_sel_other_l(erc_erd_eadr1_sel_other_l[3:0]),
                          .erc_erd_eadr2_sel_mx1_l(erc_erd_eadr2_sel_mx1_l[3:0]),
                          .erc_erd_eadr2_sel_wrt_l(erc_erd_eadr2_sel_wrt_l[3:0]),
                          .erc_erd_eadr2_sel_mx0_l(erc_erd_eadr2_sel_mx0_l[3:0]),
                          .erc_erd_eadr2_sel_old_l(erc_erd_eadr2_sel_old_l[3:0]));

   sparc_ifu_errctl errctl(
                           .so          (scan0_12),
                           .si          (scan0_11),
                          .ifu_tlu_inst_vld_w(ifu_spu_inst_vld_w),

                           /*AUTOINST*/
                           // Outputs
                           .erc_erd_pgsz_b0(erc_erd_pgsz_b0),
                           .erc_erd_pgsz_b1(erc_erd_pgsz_b1),
                           .ifu_lsu_asi_rd_unc(ifu_lsu_asi_rd_unc),
                           .ifu_lsu_ldxa_tid_w2(ifu_lsu_ldxa_tid_w2[1:0]),
                           .ifu_lsu_ldxa_data_vld_w2(ifu_lsu_ldxa_data_vld_w2),
                           .ifu_lsu_fwd_data_vld(ifu_lsu_fwd_data_vld),
                           .ifu_lsu_error_inj(ifu_lsu_error_inj[3:0]),
                           .ifu_exu_ecc_mask(ifu_exu_ecc_mask[7:0]),
                           .ifu_exu_inj_irferr(ifu_exu_inj_irferr),
                           .ifu_ffu_inj_frferr(ifu_ffu_inj_frferr),
                           .ifu_exu_nceen_e(ifu_exu_nceen_e),
                           .ifu_lsu_nceen(ifu_lsu_nceen[3:0]),
                           .ifu_spu_nceen(ifu_spu_nceen[3:0]),
                           .erb_fcl_spu_uetrap(erb_fcl_spu_uetrap[3:0]),
                           .erb_ifq_itlberr_s1(erb_ifq_itlberr_s1),
                           .erb_ifq_ifeterr_d1(erb_ifq_ifeterr_d1),
                           .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                           .erb_fcl_itlb_ce_d1(erb_fcl_itlb_ce_d1),
                           .erb_fcl_ce_trapvec(erb_fcl_ce_trapvec[3:0]),
                           .erb_fcl_ue_trapvec(erb_fcl_ue_trapvec[3:0]),
                           .erb_fcl_ifet_uevec_d1(erb_fcl_ifet_uevec_d1[3:0]),
                           .erc_erd_errstat_asidata(erc_erd_errstat_asidata[22:0]),
                           .erc_erd_errinj_asidata(erc_erd_errinj_asidata[31:0]),
                           .erc_erd_erren_asidata(erc_erd_erren_asidata[1:0]),
                           .erc_erd_eadr0_sel_irf_l(erc_erd_eadr0_sel_irf_l[3:0]),
                           .erc_erd_eadr0_sel_itlb_l(erc_erd_eadr0_sel_itlb_l[3:0]),
                           .erc_erd_eadr0_sel_frf_l(erc_erd_eadr0_sel_frf_l[3:0]),
                           .erc_erd_eadr0_sel_lsu_l(erc_erd_eadr0_sel_lsu_l[3:0]),
                           .erc_erd_asiway_s1_l(erc_erd_asiway_s1_l[2-1:0]),
                           .erc_erd_eadr1_sel_pcd1_l(erc_erd_eadr1_sel_pcd1_l[3:0]),
                           .erc_erd_eadr1_sel_l1pa_l(erc_erd_eadr1_sel_l1pa_l[3:0]),
                           .erc_erd_eadr1_sel_l2pa_l(erc_erd_eadr1_sel_l2pa_l[3:0]),
                           .erc_erd_eadr1_sel_other_l(erc_erd_eadr1_sel_other_l[3:0]),
                           .erc_erd_eadr2_sel_mx1_l(erc_erd_eadr2_sel_mx1_l[3:0]),
                           .erc_erd_eadr2_sel_wrt_l(erc_erd_eadr2_sel_wrt_l[3:0]),
                           .erc_erd_eadr2_sel_mx0_l(erc_erd_eadr2_sel_mx0_l[3:0]),
                           .erc_erd_eadr2_sel_old_l(erc_erd_eadr2_sel_old_l[3:0]),
                           .erc_erd_asi_thr_l(erc_erd_asi_thr_l[3:0]),
                           .erc_erd_asisrc_sel_icd_s_l(erc_erd_asisrc_sel_icd_s_l),
                           .erc_erd_asisrc_sel_misc_s_l(erc_erd_asisrc_sel_misc_s_l),
                           .erc_erd_asisrc_sel_err_s_l(erc_erd_asisrc_sel_err_s_l),
                           .erc_erd_asisrc_sel_itlb_s_l(erc_erd_asisrc_sel_itlb_s_l),
                           .erc_erd_errasi_sel_en_l(erc_erd_errasi_sel_en_l),
                           .erc_erd_errasi_sel_stat_l(erc_erd_errasi_sel_stat_l),
                           .erc_erd_errasi_sel_inj_l(erc_erd_errasi_sel_inj_l),
                           .erc_erd_errasi_sel_addr_l(erc_erd_errasi_sel_addr_l),
                           .erc_erd_miscasi_sel_ict_l(erc_erd_miscasi_sel_ict_l),
                           .erc_erd_miscasi_sel_imask_l(erc_erd_miscasi_sel_imask_l),
                           .erc_erd_miscasi_sel_other_l(erc_erd_miscasi_sel_other_l),
                           .erc_erd_ld_imask(erc_erd_ld_imask),
                           .erb_reset   (erb_reset),
                           // Inputs
                           .rclk        (rclk),
                           .se          (se),
                           .arst_l      (arst_l),
                           .grst_l      (grst_l),
                           .erd_erc_tte_pgsz(erd_erc_tte_pgsz[2:0]),
                           .icv_itlb_valid_f(icv_itlb_valid_f[3:0]),
                           .fcl_erb_ievld_s1(fcl_erb_ievld_s1),
                           .fcl_erb_tevld_s1(fcl_erb_tevld_s1),
                           .fcl_erb_immuevld_s1(fcl_erb_immuevld_s1),
                           .fcl_erb_inst_issue_d(fcl_erb_inst_issue_d),
                           .fcl_erb_inst_vld_d1(fcl_erb_inst_vld_d1),
                           .ifu_lsu_thrid_s(ifu_lsu_thrid_s[1:0]),
                           .fcl_erb_asi_tid_f(fcl_erb_asi_tid_f[1:0]),
                           .ifq_fcl_asi_tid_bf(ifq_fcl_asi_tid_bf[1:0]),
                           .fcl_erb_clear_iferr(fcl_erb_clear_iferr[3:0]),
                           .fcl_erb_itlbrd_vld_s(fcl_erb_itlbrd_vld_s),
                           .fcl_erb_itlbrd_data_s(fcl_erb_itlbrd_data_s),
                           .erd_erc_tagpe_s1(erd_erc_tagpe_s1[3:0]),
                           .erd_erc_nirpe_s1(erd_erc_nirpe_s1),
                           .erd_erc_fetpe_s1(erd_erc_fetpe_s1),
                           .erd_erc_tlbt_pe_s1(erd_erc_tlbt_pe_s1[1:0]),
                           .erd_erc_tlbd_pe_s1(erd_erc_tlbd_pe_s1[1:0]),
                           .tlu_lsu_pstate_priv(tlu_lsu_pstate_priv[3:0]),
			   .tlu_hpstate_priv  (tlu_hpstate_priv[3:0]),
                           .lsu_ifu_dtlb_data_su(lsu_ifu_dtlb_data_su),
                           .lsu_ifu_dtlb_data_ue(lsu_ifu_dtlb_data_ue),
                           .lsu_ifu_dtlb_tag_ue(lsu_ifu_dtlb_tag_ue),
                           .lsu_ifu_dcache_data_perror(lsu_ifu_dcache_data_perror),
                           .lsu_ifu_dcache_tag_perror(lsu_ifu_dcache_tag_perror),
                           .lsu_ifu_l2_unc_error(lsu_ifu_l2_unc_error),
                           .lsu_ifu_l2_corr_error(lsu_ifu_l2_corr_error),
                           .lsu_ifu_io_error(lsu_ifu_io_error),
                           .lsu_ifu_error_tid(lsu_ifu_error_tid[1:0]),
                           .spu_ifu_unc_err_w1(spu_ifu_unc_err_w1),
                           .spu_ifu_mamem_err_w1(spu_ifu_mamem_err_w1),
                           .spu_ifu_corr_err_w2(spu_ifu_corr_err_w2),
                           .spu_ifu_int_w2(spu_ifu_int_w2),
                           .spu_ifu_ttype_tid_w2(spu_ifu_ttype_tid_w2[1:0]),
                           .lsu_ifu_inj_ack(lsu_ifu_inj_ack[3:0]),
                           .ffu_ifu_ecc_ce_w2(ffu_ifu_ecc_ce_w2),
                           .ffu_ifu_ecc_ue_w2(ffu_ifu_ecc_ue_w2),
                           .ffu_ifu_inj_ack(ffu_ifu_inj_ack),
                           .ffu_ifu_tid_w2(ffu_ifu_tid_w2[1:0]),
                           .exu_ifu_ecc_ce_m(exu_ifu_ecc_ce_m),
                           .exu_ifu_ecc_ue_m(exu_ifu_ecc_ue_m),
                           .exu_ifu_inj_ack(exu_ifu_inj_ack),
                           .ifq_erb_ue_rep(ifq_erb_ue_rep),
                           .ifq_erb_ce_rep(ifq_erb_ce_rep),
                           .ifq_erb_l2_ue(ifq_erb_l2_ue),
                           .ifq_erb_io_ue(ifq_erb_io_ue),
                           .ifq_erb_ifet_ce(ifq_erb_ifet_ce),
                           .ifq_erb_l2err_tid(ifq_erb_l2err_tid[1:0]),
                           .ifq_erb_rdtag_f(ifq_erb_rdtag_f),
                           .ifq_erb_rdinst_f(ifq_erb_rdinst_f),
                           .ifq_erb_asi_erren_i2(ifq_erb_asi_erren_i2),
                           .ifq_erb_asi_errstat_i2(ifq_erb_asi_errstat_i2),
                           .ifq_erb_asi_errinj_i2(ifq_erb_asi_errinj_i2),
                           .ifq_erb_asi_erraddr_i2(ifq_erb_asi_erraddr_i2),
                           .ifq_erb_asi_imask_i2(ifq_erb_asi_imask_i2),
                           .ifq_erb_asiwr_i2(ifq_erb_asiwr_i2),
                           .ifq_fcl_asird_bf(ifq_fcl_asird_bf),
                           .ifq_erb_fwdrd_bf(ifq_erb_fwdrd_bf),
                           .ifq_erb_asidata_i2(ifq_erb_asidata_i2[31:0]),
                           .ifq_erb_asiway_f(ifq_erb_asiway_f[0:0]));

   // BIST Controller
//   sparc_ifu_icd_arr_bist bist(// Outputs
//			       .Test_fdp_icd_index_bf_0 (bist_ic_index[8:0]),
//			       .Test_ifq_icd_wrway_bf_0 (bist_ic_way),
//			       .Test_ifq_icd_wrdata_f_0 ({null_data[135:2],
//							  bist_ic_data[1:0]}),
//			       .Test_fcl_icd_rdreq_bf_0 (bist_ic_read),
//			       .Test_fcl_icd_wrreq_bf_0 (bist_ic_write),
//			       .Test_ifq_icd_worden_bf_0 (bist_ic_worden),
//			       .tselect (),
//			       .tst_done (),
//			       .fail_h (),
//			       .scan_out (),
//			       // Inputs
//			       .clk (clk),
//			       .diag_clk(1'b0),
//			       .rst_l (rst_l),
//			       .test_h (1'b0),
//			       .debugz (1'b0),
//			       .hold_l (1'b1),
//			       .Test_icd_fdp_topdata_s1_0 (icd_fdp_topdata_s1),
//			       .Test_icd_fdp_fetdata_s1_0 (icd_fdp_fetdata_s1));

   // sparc_ifu_mbist mbist(
   //                       .mbist_icache_data_in(wsel_mbist_icache_data[67:0]),
   //                       .mbist_si      (scan0_12),
   //                       .mbist_se      (se),

   //                       .mbist_icache_wdata(mbist_icache_wdata[7:0]),
   //                       .mbist_dcache_wdata(mbist_write_data[7:0]),

   //                       .mbist_so      (scan0_13),
   //                       .rclk           (rclk),

   //                       /*AUTOINST*/
   //                       // Outputs
   //                       .mbist_dcache_read(mbist_dcache_read),
   //                       .mbist_dcache_write(mbist_dcache_write),
   //                       .mbist_dcache_word(mbist_dcache_word),
   //                       .mbist_dcache_index(mbist_dcache_index[6:0]),
   //                       .mbist_dcache_way(mbist_dcache_way[1:0]),
   //                       .mbist_icache_read(mbist_icache_read),
   //                       .mbist_icache_write(mbist_icache_write),
   //                       .mbist_icache_index(mbist_icache_index[7:0]),
   //                       .mbist_icache_word(mbist_icache_word),
   //                       .mbist_icache_way(mbist_icache_way[1:0]),
   //                       .mbist_ifq_run_bist(mbist_ifq_run_bist),
   //                       .mbist_done    (mbist_done),
   //                       .mbist_dcache_fail(mbist_dcache_fail),
   //                       .mbist_icache_fail(mbist_icache_fail),
   //                       // Inputs
   //                       .grst_l        (grst_l),
   //                       .arst_l        (arst_l),
   //                       .mbist_start   (mbist_start),
   //                       .mbist_userdata_mode(mbist_userdata_mode),
   //                       .mbist_bisi_mode(mbist_bisi_mode),
   //                       .mbist_loop_mode(mbist_loop_mode),
   //                       .mbist_loop_on_address(mbist_loop_on_address),
   //                       .mbist_stop_on_fail(mbist_stop_on_fail),
   //                       .mbist_stop_on_next_fail(mbist_stop_on_next_fail),
   //                       .mbist_dcache_data_in(mbist_dcache_data_in[71:0]));


   // sparc_ifu_sscan sscan(
   //                       .so            (so0),
   //                       .si            (scan0_13),
   //                       .ifq_sscan_test_data(ifq_sscan_data[3:0]),
   //                       .lsu_sscan_test_data(lsu_sscan_data[15:0]),
   //                       .tlu_sscan_test_data(tlu_sscan_data[62:0]),
   //                       /*AUTOINST*/
   //                       // Outputs
   //                       .sparc_sscan(sparc_sscan),
   //                       // Inputs
   //                       .rtap_sscan_snap(rtap_sscan_snap),
   //                       .rtap_sscan_se  (rtap_sscan_se),
   //                       .ctu_tck       (ctu_tck),
   //                       .se            (se),
   //                       .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
   //                       .rclk          (rclk));

// trin: we need this module to read out shadow scan; scan chain is removed though.
// `ifdef NO_SCAN
// `else
sparc_ifu_sscan sscan(
   .ifq_sscan_test_data(ifq_sscan_data[3:0]),
   .lsu_sscan_test_data(lsu_sscan_data[15:0]),
   .tlu_sscan_test_data(tlu_sscan_data[62:0]),
   // Inputs
   .swl_sscan_thrstate(swl_sscan_thrstate[10:0]),
   .rclk          (rclk),

   .core_rtap_data          (core_rtap_data),
   .rtap_core_val         (rtap_core_val),
   .rtap_core_threadid         (rtap_core_threadid),
   .rtap_core_id         (rtap_core_id),
   .rtap_core_data         (rtap_core_data)
   );
// `endif   

   // floating outputs
   // sink #(`IC_TAG_UNUSED_SZ) s0(.in (ict_itlb_tags_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s1(.in (ict_itlb_tag1_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s2(.in (ict_itlb_tag2_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(`IC_TAG_UNUSED_SZ) s3(.in (ict_itlb_tag3_f[`IC_PHYS_TAG_SZ-1:(`IC_TAG_SZ+1)]));
   // sink #(2) s4(.in (fuse_icd_rid[5:4]));

endmodule
// Local Variables:
// verilog-library-directories:("." "../../../srams/rtl" "../../../common/rtl")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_cmp35.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_cmp37
//  Description:	
//  37 bit comparator for MIL hit detection
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_cmp35(/*AUTOARG*/
   // Outputs
   hit, 
   // Inputs
   a, b, valid
   );

   input [34:0] a, b;
   input 	valid;
   
   output 	hit;

   reg 		hit;
   wire 	valid;
   wire [34:0] 	a, b;

   always @ (a or b or valid)
     begin
	if ((a==b) & valid)
	  hit = 1'b1;
	else
	  hit = 1'b0;
     end // always @ (a or b or valid)

endmodule // sparc_ifu_cmp35

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_ctr5.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ctr5
//  Description:	
//  5 bit counter for starvation detect
*/

module sparc_ifu_ctr5(/*AUTOARG*/
   // Outputs
   limit, so, 
   // Inputs
   clk, se, si, rst_ctr_l
   );

   input     clk;
   input     se, si;

   input     rst_ctr_l;

   output    limit;
   output    so;
   
   wire [4:0] count,
	      count_nxt,
	      sum;
   
   assign   sum[0] = ~count[0];
   assign   sum[1] = count[1] ^ count[0];
   assign   sum[2] = count[2] ^ (count[1] & count[0]);
   assign   sum[3] = count[3] ^ (count[2] & count[1] & count[0]);
   assign   sum[4] = count[4] ^ (count[3] & count[2] & count[1] & count[0]);
   assign   count_nxt = sum & {5{rst_ctr_l}};

   dff_s #(5) cnt_reg(.din (count_nxt),
		                .q   (count),
		                .clk (clk),
		                .se  (se), .si(), .so());

   // limit set to 24 for now
   assign   limit = count[4] & count[3];
   
   
endmodule
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_dcl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_dcl
//  Description:	
//   The decode control logic block does branch condition evaluation,
//   delay slot management, and appropriate condition code
//   selection.  It also executes the tcc instruction and kills the E
//   stage instruction if a move did not succeed.  The DCL block is
//   also responsible for generating the correct select signals to
//   choose the branch offset and immediate operand.
//
*/
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//












































module sparc_ifu_dcl(/*AUTOARG*/
   // Outputs
   ifu_exu_kill_e, ifu_exu_dontmv_regz0_e, ifu_exu_dontmv_regz1_e, 
   ifu_exu_tcc_e, ifu_exu_dbrinst_d, ifu_ffu_mvcnd_m, 
   dcl_fcl_bcregz0_e, dcl_fcl_bcregz1_e, dtu_inst_anull_e, 
   dcl_swl_tcc_done_m, dcl_imd_immdata_sel_simm13_d_l, 
   dcl_imd_immdata_sel_movcc_d_l, dcl_imd_immdata_sel_sethi_d_l, 
   dcl_imd_immdata_sel_movr_d_l, dcl_imd_broff_sel_call_d_l, 
   dcl_imd_broff_sel_br_d_l, dcl_imd_broff_sel_bcc_d_l, 
   dcl_imd_broff_sel_bpcc_d_l, dcl_imd_immbr_sel_br_d, so,
   dcl_esl_br_inst_d, dcl_esl_br_inst_e,
   // Inputs
   rclk, se, si, dtu_reset, exu_ifu_cc_d, fcl_dcl_regz_e, 
   exu_ifu_regn_e, ffu_ifu_cc_w2, ffu_ifu_cc_vld_w2, 
   tlu_ifu_flush_pipe_w, swl_dcl_thr_d, swl_dcl_thr_w2, 
   imd_dcl_brcond_d, imd_dcl_mvcond_d, fdp_dcl_op_s, fdp_dcl_op3_s, 
   imd_dcl_abit_d, dec_dcl_cctype_d, dtu_dcl_opf2_d, 
   fcl_dtu_inst_vld_e, fcl_dtu_intr_vld_e, ifu_tlu_flush_w
   );

   input    rclk, 
            se, 
            si, 
            dtu_reset;
   
   input [7:0] exu_ifu_cc_d;         // latest CCs from EXU
   
   input       fcl_dcl_regz_e,        // rs1=0
	             exu_ifu_regn_e;        // rs1<0

   input [7:0] ffu_ifu_cc_w2;
   input [3:0] ffu_ifu_cc_vld_w2;

   input       tlu_ifu_flush_pipe_w;
   
   input [3:0] swl_dcl_thr_d,
	             swl_dcl_thr_w2;
   
   input [3:0] imd_dcl_brcond_d;     // branch condition type
   input [7:0] imd_dcl_mvcond_d;     // mov condition type

   input [1:0] fdp_dcl_op_s;
   input [5:0] fdp_dcl_op3_s;
   input       imd_dcl_abit_d;	      // anull bit for cond branch
   input [2:0] dec_dcl_cctype_d;     // which cond codes to use
   input       dtu_dcl_opf2_d;

   input       fcl_dtu_inst_vld_e;
   input       fcl_dtu_intr_vld_e;
   input       ifu_tlu_flush_w;

   output      ifu_exu_kill_e,
		           ifu_exu_dontmv_regz0_e,
		           ifu_exu_dontmv_regz1_e,
		           ifu_exu_tcc_e;
   output      ifu_exu_dbrinst_d;

   output      ifu_ffu_mvcnd_m;
   
   output      dcl_fcl_bcregz0_e,
               dcl_fcl_bcregz1_e;

   output      dtu_inst_anull_e;
   output      dcl_swl_tcc_done_m;

   output      dcl_imd_immdata_sel_simm13_d_l,      // imm data select
	             dcl_imd_immdata_sel_movcc_d_l,
	             dcl_imd_immdata_sel_sethi_d_l,
	             dcl_imd_immdata_sel_movr_d_l;

   output      dcl_imd_broff_sel_call_d_l,      // dir branch offset select
	             dcl_imd_broff_sel_br_d_l,
	             dcl_imd_broff_sel_bcc_d_l,
	             dcl_imd_broff_sel_bpcc_d_l;

   output      dcl_imd_immbr_sel_br_d;
   
   output      so;

   output      dcl_esl_br_inst_d;
   output      dcl_esl_br_inst_e;

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------

   wire [7:0]  cc_breval_e,
	             fp_breval_d;

   wire        abit_e;

   wire        cond_brtaken_e,
	             anull_all,
	             anull_ubr,
	             anull_cbr;

   wire [3:0]  anull_next_e,
               anull_e,
               thr_anull_d;

   wire        inst_anull_d,
               inst_anull_e;

   wire [3:0]  flush_abit;
   wire        all_flush_w,
               all_flush_w2;

   wire        br_always_e;
   
   wire        sel_movcc,
	             sel_movr;

   wire [3:0]  br_cond_e,
	             br_cond_d;
   wire [3:0]  thr_vld_e;
   
   wire [3:0]  ls_brcond_d,
               ls_brcond_e;
   wire [1:0]  ccfp_sel;

   wire [3:0]  cc_e;

   wire [1:0]  curr_fcc_d;

   wire [7:0]  fcc_d;

   wire [7:0]  t0_fcc_d,
	             t1_fcc_d,
	             t2_fcc_d,
	             t3_fcc_d,
	             t0_fcc_nxt,
	             t1_fcc_nxt,
	             t2_fcc_nxt,
	             t3_fcc_nxt;

   wire        use_fcc0_d,
	             use_fcc1_d,
	             use_fcc2_d,
	             use_fcc3_d;

   wire [3:0]  thr_e,
	             thr_dec_d;
//	             fcc_dec_d,
//	             fcc_dec_e;
   
   wire [1:0]  op_d;
   wire [5:0]  op3_d;

   wire        use_xcc_d,
	             ltz_e,
	             cc_eval0,
	             cc_eval1,
	             fp_eval0_d,
	             fp_eval1_d,
	             fp_eval_d,
	             fp_eval_e,
	             r_eval1,
	             r_eval0,
	             ccfp_eval,
	             ccbr_taken_e,
	             mvbr_sel_br_d,
	             cc_mvbr_d,
	             cc_mvbr_e,
	             fpcond_mvbr_d,
	             fpcond_mvbr_e;

   wire        call_inst_e,
               call_inst_d,
	             dbr_inst_d,
	             dbr_inst_e,
	             ibr_inst_d,
	             ibr_inst_e,
	             mov_inst_d,
	             mov_inst_e,
               tcc_done_e,
	             tcc_inst_d,
	             tcc_inst_e;

   wire        clk;
   

   
//----------------------------------------------------------------------
// Code start here 
//----------------------------------------------------------------------
   assign      clk = rclk;
   

   // S Stage Operands
   dff_s #(2) opreg(.din  (fdp_dcl_op_s),
		              .clk  (clk),
		              .q    (op_d),
		              .se   (se), .si(), .so());

   dff_s #(6) op3_reg(.din  (fdp_dcl_op3_s),
		                .clk  (clk),
		                .q    (op3_d),
		                .se   (se), .si(), .so());

   dff_s abite_reg(.din  (imd_dcl_abit_d),
		             .clk  (clk),
		             .q    (abit_e),
		             .se   (se), .si(), .so());

   // need to protect from scan contention
   dff_s #(4) thre_reg(.din (swl_dcl_thr_d),
                     .q   (thr_e),
                     .clk (clk), .se(se), .si(), .so());

   //------------------------------
   // Choose correct immediate data
   //------------------------------
   // movcc if op3 = 101100
   assign dcl_imd_immdata_sel_movcc_d_l = ~(op_d[1] &
					                                  op3_d[5] & ~op3_d[4] & 
                                            op3_d[3] & ~op3_d[0]);

   // movr if op3 = 101111
   //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   // Reduced the number of terms in the eqn to help with timing 
   // path, the result of which is that the immediate data sent to the
   // exu for a FLUSH instruction is INCORRECT!  (It is decoded as a
   // MOVR).  However, since our architecture completely ignores the
   // address of the flush, this should be ok.  Confirmed with Sanjay
   // 03/31/03. (v1.29 -> 1.30)
   // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   assign dcl_imd_immdata_sel_movr_d_l = ~(op_d[1] &
				                                   op3_d[5] & op3_d[3] &
				                                   op3_d[1] & op3_d[0]);
   
   // sethi if op3 = 100xx
   assign dcl_imd_immdata_sel_sethi_d_l = ~(~op_d[1]);

   // everything else
   assign dcl_imd_immdata_sel_simm13_d_l = 
                   	        ~(dcl_imd_immdata_sel_movcc_d_l &
                              dcl_imd_immdata_sel_movr_d_l  &
	                            dcl_imd_immdata_sel_sethi_d_l);

   //------------------------------
   // Choose correct branch offset
   //------------------------------
   // call or ld/store
   assign dcl_imd_broff_sel_call_d_l = ~(op_d[0]);

   // branch on register
   assign dcl_imd_broff_sel_br_d_l = ~(~op_d[0] & 
				                               op3_d[4] & op3_d[3]);
   // branch w/o prediction
   assign dcl_imd_broff_sel_bcc_d_l = ~(~op_d[0] & 
					                              op3_d[4] & ~op3_d[3]);
   // everything else
   assign dcl_imd_broff_sel_bpcc_d_l = ~(~op_d[0] & 
					                               ~op3_d[4]);

   //------------------------------------
   // mark branch/conditional instrctions
   //------------------------------------
   // call
   assign call_inst_d = ~op_d[1] & op_d[0];
   dff_s #(1) call_inste_reg(.din  (call_inst_d),
			                     .clk  (clk),
			                     .q    (call_inst_e),
			                     .se   (se), .si(), .so());

   // call or branch but not nop/sethi
   assign dbr_inst_d = ~op_d[1] & (op_d[0] | op3_d[4] | op3_d[3]);
   
   // Choose between branch offset and immediate operand
   assign dcl_imd_immbr_sel_br_d = dbr_inst_d;

   // tell exu to use pc instead of rs1
   assign ifu_exu_dbrinst_d = ~op_d[1];

   dff_s #(1) dbr_inste_reg(.din  (dbr_inst_d),
			                    .clk  (clk),
			                    .q    (dbr_inst_e),
			                    .se   (se), .si(), .so());

   // jmpl + return
   assign ibr_inst_d = op_d[1] & ~op_d[0] &
		                    op3_d[5] &  op3_d[4] &  op3_d[3] & 
                        ~op3_d[2] & ~op3_d[1];
   dff_s #(1) ibr_inste_reg(.din  (ibr_inst_d),
			                    .clk  (clk),
			                    .q    (ibr_inst_e),
			                    .se   (se), .si(), .so());   

   assign dcl_esl_br_inst_d = dbr_inst_d | ibr_inst_d;
   assign dcl_esl_br_inst_e = dbr_inst_e | ibr_inst_e;
   // mov
   assign mov_inst_d = (op_d[1] & ~op_d[0] &
			                  op3_d[5] & ~op3_d[4] & op3_d[3] & op3_d[2] & 
			                  (~op3_d[1] & ~op3_d[0] | op3_d[1] & op3_d[0]));

   dff_s #(1) mov_inste_reg(.din  (mov_inst_d),
			                    .clk  (clk),
			                    .q    (mov_inst_e),
			                    .se   (se), .si(), .so());
   // tcc
   assign tcc_inst_d = op_d[1] & ~op_d[0] &
		                   op3_d[5] &  op3_d[4] &  op3_d[3] & 
		                   ~op3_d[2] &  op3_d[1] & ~op3_d[0];
   dff_s #(1) tcc_inste_reg(.din  (tcc_inst_d),
			                    .clk  (clk),
			                    .q    (tcc_inst_e),
			                    .se   (se), .si(), .so());

   assign mvbr_sel_br_d = ~op_d[1] & ~op_d[0] |          // br
	                         op3_d[3] & ~op3_d[2] & op3_d[1] & ~op3_d[0]; // tcc
   
   assign cc_mvbr_d = ~(~op_d[1] & ~op_d[0] & op3_d[4] & op3_d[3] |  // bpr
			                  op_d[1] & ~op_d[0] & op3_d[5] & ~op3_d[4] &
			                  op3_d[3] & op3_d[2] & op3_d[1] & op3_d[0] |  // movr
			                  op_d[1] & ~op_d[0] & op3_d[5] & op3_d[4] &
			                  ~op3_d[3] & op3_d[2] & ~op3_d[1] & op3_d[0] &
			                  dtu_dcl_opf2_d);                             // fmovr


   //---------------------------
   // FCC Logic
   //--------------------------
   // choose current fcc
   assign use_fcc0_d = ~dec_dcl_cctype_d[1] & ~dec_dcl_cctype_d[0];
   assign use_fcc1_d = ~dec_dcl_cctype_d[1] &  dec_dcl_cctype_d[0];
   assign use_fcc2_d =  dec_dcl_cctype_d[1] & ~dec_dcl_cctype_d[0];
   assign use_fcc3_d =  dec_dcl_cctype_d[1] &  dec_dcl_cctype_d[0];
   
   mux4ds #(2) fcc_mux(.dout (curr_fcc_d[1:0]),
		                   .in0  (fcc_d[1:0]),
		                   .in1  (fcc_d[3:2]),
		                   .in2  (fcc_d[5:4]),
		                   .in3  (fcc_d[7:6]),
		                   .sel0 (use_fcc0_d),
		                   .sel1 (use_fcc1_d),
		                   .sel2 (use_fcc2_d),
		                   .sel3 (use_fcc3_d));

   // decode to make next step easier
//   assign fcc_dec_d[0] = ~curr_fcc_d[1] & ~curr_fcc_d[0];
//   assign fcc_dec_d[1] = ~curr_fcc_d[1] &  curr_fcc_d[0];
//   assign fcc_dec_d[2] =  curr_fcc_d[1] & ~curr_fcc_d[0];
//   assign fcc_dec_d[3] =  curr_fcc_d[1] &  curr_fcc_d[0];

//   dff #(4) fcce_reg(.din (fcc_dec_d),
//		                 .q   (fcc_dec_e),
//		                 .clk (clk),
//		                 .se  (se), .si(), .so());
   
   
   //------------------
   // CC Logic for BCC
   //------------------
   // Choose appropriate CCs
   //
   // dec_cctype is 3 bits
   // 10X  icc
   // 11X  xcc
   // 000  fcc0
   // 001  fcc1
   // 010  fcc2
   // 011  fcc3
//   assign use_xcc_d = (dec_dcl_cctype_d[2] | op3_d[3]) & dec_dcl_cctype_d[1];
   assign use_xcc_d = dec_dcl_cctype_d[1];   
   assign fpcond_mvbr_d = ~dec_dcl_cctype_d[2] & ~tcc_inst_d;

   dff_s fpbr_reg(.din  (fpcond_mvbr_d),
		            .clk  (clk),
		            .q    (fpcond_mvbr_e),
		            .se   (se), .si(), .so());
   
   // mux between xcc and icc
//   assign cc_d =  use_xcc_d ?  exu_ifu_cc_d[7:4] :      // xcc
//			                         exu_ifu_cc_d[3:0];       // icc
//   dff #(4)  ccreg_e(.din  (cc_d),
//		                 .clk  (clk),
//		                 .q    (cc_e),
//		                 .se   (se),  .si(), .so());

   bw_u1_soffm2_4x UZsize_ccreg0_e(.d0 (exu_ifu_cc_d[0]),
                                   .d1 (exu_ifu_cc_d[4]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[0]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg1_e(.d0 (exu_ifu_cc_d[1]),
                                   .d1 (exu_ifu_cc_d[5]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[1]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg2_e(.d0 (exu_ifu_cc_d[2]),
                                   .d1 (exu_ifu_cc_d[6]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[2]),
                                   .ck (clk), .se(se), .sd(), .so());
   bw_u1_soffm2_4x UZsize_ccreg3_e(.d0 (exu_ifu_cc_d[3]),
                                   .d1 (exu_ifu_cc_d[7]),
                                   .s  (use_xcc_d),
                                   .q  (cc_e[3]),
                                   .ck (clk), .se(se), .sd(), .so());
   
   
   //------------------------------
   // Evaluate Branch
   //------------------------------
   // Select correct branch condition
   assign sel_movcc = ~mvbr_sel_br_d & cc_mvbr_d;
   assign sel_movr = ~mvbr_sel_br_d & ~cc_mvbr_d;
   
   // br_cond is the same as the "cond" field = inst[28:25] for bcc
   mux3ds #(4)  brcond_mux(.dout   (br_cond_d),
			                     .in0    (imd_dcl_brcond_d),  // br or tcc
			                     .in1    (imd_dcl_mvcond_d[7:4]),  // movcc
			                     .in2    (imd_dcl_mvcond_d[3:0]),  // movr
			                     .sel0   (mvbr_sel_br_d),
			                     .sel1   (sel_movcc),
			                     .sel2   (sel_movr));
   
   dff_s #(4)  brcond_e_reg(.din  (br_cond_d),
			                    .clk  (clk),
			                    .q    (br_cond_e),
			                    .se   (se), .si(), .so());

   // Branch Type Decode
   assign ls_brcond_d[0]  =  ~br_cond_d[1] & ~br_cond_d[0];
   assign ls_brcond_d[1]  =  ~br_cond_d[1] &  br_cond_d[0];
   assign ls_brcond_d[2]  =   br_cond_d[1] & ~br_cond_d[0];
   assign ls_brcond_d[3]  =   br_cond_d[1] &  br_cond_d[0];

   dff_s #(4)  lsbrc_e_reg(.din  (ls_brcond_d),
			                   .clk  (clk),
			                   .q    (ls_brcond_e),
			                   .se   (se), .si(), .so());
   
   // Evaluate potential integer CC branches
   assign ltz_e = (cc_e[3] ^ cc_e[1]);

   assign cc_breval_e[0] = 1'b0;                       // BPN
   assign cc_breval_e[1] = cc_e[2];	               // BPE
   assign cc_breval_e[2] = cc_e[2] | ltz_e;        // BPLE
   assign cc_breval_e[3] = ltz_e;                      // BPL
   assign cc_breval_e[4] = cc_e[2] | cc_e[0];  // BPLEU
   assign cc_breval_e[5] = cc_e[0];                // BPCS
   assign cc_breval_e[6] = cc_e[3];                // BPNEG
   assign cc_breval_e[7] = cc_e[1];                // BPVS 

   // mux to choose right condition
   assign cc_eval0 = cc_breval_e[0] & ls_brcond_e[0] |
		                 cc_breval_e[1] & ls_brcond_e[1] |
		                 cc_breval_e[2] & ls_brcond_e[2] |
		                 cc_breval_e[3] & ls_brcond_e[3];

   assign cc_eval1 = cc_breval_e[4] & ls_brcond_e[0] |
		                 cc_breval_e[5] & ls_brcond_e[1] |
		                 cc_breval_e[6] & ls_brcond_e[2] |
		                 cc_breval_e[7] & ls_brcond_e[3];

   // Evaluate FP CC branches in D stage
   assign fp_breval_d[0] = 1'b0;                            // FBN / A
   assign fp_breval_d[1] = (curr_fcc_d[1] | curr_fcc_d[0]); // FBNE / E
   assign fp_breval_d[2] = curr_fcc_d[1] ^ curr_fcc_d[0];   // FBLG / UE
   assign fp_breval_d[3] = curr_fcc_d[0];                   // FBUL / GE
   assign fp_breval_d[4] = ~curr_fcc_d[1] & curr_fcc_d[0];  // FBL / UGE
   assign fp_breval_d[5] = curr_fcc_d[1];                   // FBUG / LE
   assign fp_breval_d[6] = curr_fcc_d[1] & ~curr_fcc_d[0];  // FBG / ULE
   assign fp_breval_d[7] = curr_fcc_d[1] & curr_fcc_d[0];   // FBU / O
   
   assign fp_eval0_d = fp_breval_d[0] & ls_brcond_d[0] |
		                 fp_breval_d[1] & ls_brcond_d[1] |
		                 fp_breval_d[2] & ls_brcond_d[2] |
		                 fp_breval_d[3] & ls_brcond_d[3];

   assign fp_eval1_d = fp_breval_d[4] & ls_brcond_d[0] |
		                 fp_breval_d[5] & ls_brcond_d[1] |
		                 fp_breval_d[6] & ls_brcond_d[2] |
		                 fp_breval_d[7] & ls_brcond_d[3];

   assign fp_eval_d = br_cond_d[2] ? fp_eval1_d :
                                     fp_eval0_d;

   dff_s #(1) fpev_ff(.din (fp_eval_d),
		                .q   (fp_eval_e),
		                .clk (clk),
		                .se  (se), .si(), .so());

   // merge eval0, eval1 and fp condition codes
   assign ccfp_sel[0] = ~fpcond_mvbr_e & ~br_cond_e[2];
   assign ccfp_sel[1] = ~fpcond_mvbr_e &  br_cond_e[2];
//   assign ccfp_sel[2] =  fpcond_mvbr_e & ~br_cond_e[2];
//   assign ccfp_sel[3] =  fpcond_mvbr_e &  br_cond_e[2];
   
   assign ccfp_eval = ccfp_sel[0] & cc_eval0 |
		                  ccfp_sel[1] & cc_eval1 | 
		                  fpcond_mvbr_e & fp_eval_e;
   
   // invert branch condition if this is an inverted br type
//   assign ccbr_taken_e = (ccfp_eval ^ br_cond_e[3]) & cc_mvbr_e;
   assign ccbr_taken_e = ccfp_eval ? (cc_mvbr_e & ~br_cond_e[3]) :
                                       (cc_mvbr_e & br_cond_e[3]);

   assign br_always_e = (~br_cond_e[0] & ~br_cond_e[1] & ~br_cond_e[2] & 
	                       br_cond_e[3] & cc_mvbr_e);

   //--------------
   // For BRZ
   // -------------
   // Calculate Cond Assuming Z=1 And Z=0.  Then Mux
//   assign r_eval1 = ((exu_ifu_regn_e | ~br_cond_e[1] | ~br_cond_e[0]) ^
//		                  br_cond_e[2]) & ~cc_mvbr_e;
   assign r_eval1 = exu_ifu_regn_e ? (~br_cond_e[2] & ~cc_mvbr_e) :
                                       (((br_cond_e[1] & br_cond_e[0]) ^ 
                                         ~br_cond_e[2]) & ~cc_mvbr_e);
   
//   assign r_eval0 = ((exu_ifu_regn_e & br_cond_e[1]) ^
//                      br_cond_e[2]) & ~cc_mvbr_e;
   assign r_eval0 = exu_ifu_regn_e ? ((br_cond_e[1] ^ br_cond_e[2]) & 
                                       ~cc_mvbr_e) :
                                       (br_cond_e[2] & ~cc_mvbr_e);

   dff_s #(1) regcc_ff(.din  (cc_mvbr_d),
		                 .clk  (clk),
		                 .q    (cc_mvbr_e),
		                 .se   (se), .si(), .so());

   // Evaluate Final Branch condition
   // 3:1 mux
//   assign cond_brtaken_e = cc_mvbr_e      ?  ccbr_taken_e :
//		                       exu_ifu_regz_e ?       r_eval1 :
//		                                              r_eval0;
   // 2:1 mux
//   assign cond_brtaken_e = exu_ifu_regz_e ? (r_eval1 | ccbr_taken_e) :
//                                              (r_eval0 | ccbr_taken_e);

   //////// Chandra ////////

   wire   temp0, temp1, cond_brtaken_e_l;

   // limit loading on this signal
//   wire   regz_buf_e;
//   bw_u1_buf_5x UZfix_regz_bf(.a (exu_ifu_regz_e),
//                              .z (regz_buf_e));
   
   assign temp0 = (r_eval0 | ccbr_taken_e);
   assign temp1 = (r_eval1 | ccbr_taken_e);

   bw_u1_muxi21_6x UZsize_cbtmux(.z(cond_brtaken_e_l), 
                                  .d0(temp0), 
                                  .d1(temp1), 
                                  .s(fcl_dcl_regz_e));
   
   bw_u1_inv_20x UZsize_cbtinv(.z(cond_brtaken_e), 
                                .a(cond_brtaken_e_l));

   ////////////////////////

   assign dcl_fcl_bcregz0_e = (temp0 & dbr_inst_e | ibr_inst_e | 
                               call_inst_e) & ~dtu_inst_anull_e;
   assign dcl_fcl_bcregz1_e = (temp1 & dbr_inst_e | ibr_inst_e | 
                               call_inst_e) & ~dtu_inst_anull_e;

//   assign ifu_exu_dontmove_e = mov_inst_e & ~cond_brtaken_e;
   assign ifu_exu_dontmv_regz0_e = ~temp0 & mov_inst_e;
   assign ifu_exu_dontmv_regz1_e = ~temp1 & mov_inst_e;

   // branch condition to FPU
   dff_s #(1) fpcond_ff(.din  (cond_brtaken_e),
		                  .q    (ifu_ffu_mvcnd_m),
		                  .clk  (clk),
		                  .se   (se), .si(), .so());		    

   // branch / move completion and anull signals
//   assign dtu_fcl_brtaken_e = ~dtu_inst_anull_e & 
//	                            (ibr_inst_e | call_inst_e |
//			                         dbr_inst_e & cond_brtaken_e);

   // if mov didn't succeed kill write back and bypass
   // need to check thread as well
//   assign ifu_exu_kill_e = dtu_inst_anull_e | 
//	                   ~fcl_dtu_inst_vld_e;  // don't need this anymore
   assign ifu_exu_kill_e = dtu_inst_anull_e;


   // signal trap if tcc succeeds
   assign ifu_exu_tcc_e = ~dtu_inst_anull_e & tcc_inst_e & ccbr_taken_e & 
                          fcl_dtu_inst_vld_e;

   assign tcc_done_e = ~dtu_inst_anull_e & tcc_inst_e & ~ccbr_taken_e & 
                       fcl_dtu_inst_vld_e;   

   dff_s #(1) tccm_ff(.din (tcc_done_e),
                    .q   (dcl_swl_tcc_done_m),
                    .clk (clk),
                    .se  (se), .si(), .so());
   
   // logic to anull delay slot, if this branch itsel is not anulled
   assign anull_cbr  =  abit_e & dbr_inst_e & ~br_always_e & ~call_inst_e;
   assign anull_ubr  =  abit_e & dbr_inst_e & br_always_e & ~call_inst_e;

   assign anull_all =  anull_ubr  | anull_cbr & ~cond_brtaken_e;

   // check which thread to anull
   assign thr_vld_e = thr_e & {4{fcl_dtu_inst_vld_e}};

   assign all_flush_w = tlu_ifu_flush_pipe_w | ifu_tlu_flush_w;
   dff_s #(1) flshw2_ff(.din (all_flush_w),
                      .q   (all_flush_w2),
                      .clk (clk), .se(se), .si(), .so());

   assign flush_abit = swl_dcl_thr_w2 & {4{all_flush_w2}};
   
   assign anull_next_e = ((~anull_e & {4{anull_all}} & thr_vld_e) |
 	                        (anull_e & ~(thr_e & {4{fcl_dtu_inst_vld_e |
                                                  fcl_dtu_intr_vld_e}}))) & 
                           ~flush_abit;
   
   // anull_e needs to be per thread
   dffr_s #(4) anull_ff(.din  (anull_next_e),
		                  .clk  (clk),
		                  .rst  (dtu_reset),
		                  .q    (anull_e),
		                  .se   (se), .si(), .so());

   // 
//   assign thr_dec_e[0] = swl_dcl_thr_e[0] | rst_tri_enable;
//   assign thr_dec_e[3:1] = swl_dcl_thr_e[3:1] & {3{~rst_tri_enable}};

   assign thr_anull_d = swl_dcl_thr_d & anull_next_e;
   assign inst_anull_d =  (|thr_anull_d[3:0]);
   dff_s #(1) ina_ff(.din (inst_anull_d),
                   .q   (inst_anull_e),
                   .clk (clk), .se (se), .si(), .so());
                   
   assign dtu_inst_anull_e = inst_anull_e;

//   mux4ds dcla_mux(.dout (this_inst_anull_e),  
//		               .in0  (anull_e[0]),
//		               .in1  (anull_e[1]),
//		               .in2  (anull_e[2]),
//		               .in3  (anull_e[3]),
//		               .sel0 (thr_dec_e[0]),
//		               .sel1 (thr_dec_e[1]),
//		               .sel2 (thr_dec_e[2]),
//		               .sel3 (thr_dec_e[3]));
//   assign dtu_inst_anull_e = this_inst_anull_e & fcl_dtu_inst_vld_e;


//--------------------
// Copy of FCC
//--------------------
   // FCC's are maintained in the ffu.  A copy is kept here to run the
   // FP branch instructions.
   
   // load FCC from FFU
   mux2ds #(8)  t0_fcc_mux(.dout (t0_fcc_nxt[7:0]),
			                     .in0  (t0_fcc_d[7:0]),
			                     .in1  (ffu_ifu_cc_w2[7:0]),
			                     .sel0  (~ffu_ifu_cc_vld_w2[0]),
			                     .sel1  (ffu_ifu_cc_vld_w2[0]));
   
   dffr_s #(8) t0_fcc_reg(.din (t0_fcc_nxt[7:0]),
		                    .q   (t0_fcc_d[7:0]),
		                    .rst (dtu_reset),
		                    .clk (clk),  .se  (se), .si(), .so());
 // Use two threads unless this is defined

   mux2ds #(8)  t1_fcc_mux(.dout (t1_fcc_nxt[7:0]),
                                 .in0  (t1_fcc_d[7:0]),
                                 .in1  (ffu_ifu_cc_w2[7:0]),
                                 .sel0  (~ffu_ifu_cc_vld_w2[1]),
                                 .sel1  (ffu_ifu_cc_vld_w2[1]));

   // thread0 fcc registers

   dffr_s #(8) t1_fcc_reg(.din (t1_fcc_nxt[7:0]),
                            .q   (t1_fcc_d[7:0]),
                            .rst (dtu_reset),
                            .clk (clk),  .se  (se), .si(), .so());

   // choose thread
   assign thr_dec_d[0] = swl_dcl_thr_d[0];
   assign thr_dec_d[3:1] = swl_dcl_thr_d[3:1];

   mux2ds #(8) fcc0d_mx(.dout (fcc_d[7:0]),
                            .in0  (t0_fcc_d[7:0]),
                            .in1  (t1_fcc_d[7:0]),
                            .sel0 (thr_dec_d[0]),
                            .sel1 (thr_dec_d[1]));



























































































































 // `ifndef CONFIG_NUM_THREADS
   
endmodule // sparc_ifu_dcl

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_dec.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_dec
//  Description:	
//  The decode block implements the sparc instruction decode ROM
//  It has a purely combinational part and some staging flops
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_dec(/*AUTOARG*/
   // Outputs
   so, ifu_exu_aluop_d, ifu_exu_invert_d, ifu_exu_useimm_d, 
   ifu_exu_usecin_d, ifu_exu_enshift_d, ifu_exu_tagop_d, 
   ifu_exu_tv_d, ifu_exu_muls_d, ifu_exu_ialign_d, 
   ifu_exu_range_check_jlret_d, ifu_exu_range_check_other_d, 
   ifu_exu_shiftop_d, ifu_exu_muldivop_d, ifu_exu_wen_d, 
   ifu_exu_setcc_d, ifu_exu_rd_ifusr_e, ifu_exu_rd_exusr_e, 
   ifu_exu_rd_ffusr_e, ifu_exu_rs1_vld_d, ifu_exu_rs2_vld_d, 
   ifu_exu_rs3e_vld_d, ifu_exu_rs3o_vld_d, ifu_exu_use_rsr_e_l, 
   ifu_exu_save_d, ifu_exu_restore_d, ifu_exu_return_d, 
   ifu_exu_flushw_e, ifu_exu_saved_e, ifu_exu_restored_e, 
   ifu_tlu_rsr_inst_d, ifu_lsu_wsr_inst_d, ifu_exu_wsr_inst_d, 
   ifu_tlu_done_inst_d, ifu_tlu_retry_inst_d, ifu_lsu_ld_inst_e, 
   ifu_lsu_st_inst_e, ifu_lsu_pref_inst_e, ifu_lsu_alt_space_e, 
   ifu_lsu_alt_space_d, ifu_tlu_alt_space_d, ifu_lsu_memref_d, 
   ifu_lsu_sign_ext_e, ifu_lsu_ldstub_e, ifu_lsu_casa_e, 
   ifu_exu_casa_d, ifu_lsu_swap_e, ifu_tlu_mb_inst_e, 
   ifu_tlu_sir_inst_m, ifu_tlu_flsh_inst_e, ifu_lsu_ldst_dbl_e, 
   ifu_lsu_ldst_fp_e, ifu_lsu_ldst_size_e, ifu_ffu_fpop1_d, 
   ifu_ffu_visop_d, ifu_ffu_fpop2_d, ifu_ffu_fld_d, ifu_ffu_fst_d, 
   ifu_ffu_ldst_size_d, ifu_ffu_ldfsr_d, ifu_ffu_ldxfsr_d, 
   ifu_ffu_stfsr_d, ifu_ffu_quad_op_e, dec_fcl_rdsr_sel_pc_d, 
   dec_fcl_rdsr_sel_thr_d, dec_imd_call_inst_d, 
   dtu_fcl_flush_sonly_e, dtu_fcl_illinst_e, dtu_fcl_fpdis_e, 
   dtu_fcl_privop_e, dtu_fcl_imask_hit_e, dtu_fcl_br_inst_d, 
   dtu_fcl_sir_inst_e, dtu_ifq_kill_latest_d, dec_swl_wrt_tcr_w, 
   dec_swl_wrtfprs_w, dec_swl_ll_done_d, dec_swl_br_done_d, 
   dec_swl_rdsr_sel_thr_d, dec_swl_ld_inst_d, dec_swl_sta_inst_e, 
   dec_swl_std_inst_d, dec_swl_st_inst_d, dec_swl_fpop_d, 
   dec_swl_allfp_d, dec_swl_frf_upper_d, dec_swl_frf_lower_d, 
   dec_swl_div_inst_d, dec_swl_mul_inst_d, wsr_fixed_inst_w, 
   ifu_exu_sethi_inst_d, dec_dcl_cctype_d, 
   // Inputs
   rclk, se, si, dtu_inst_d, erb_dtu_imask, swl_dec_ibe_e, 
   dtu_inst_anull_e, lsu_ifu_ldsta_internal_e, fcl_dtu_tlzero_d, 
   fcl_dtu_privmode_d, fcl_dtu_hprivmode_d, fcl_dtu_inst_vld_d, 
   fcl_dtu_ely_inst_vld_d, fcl_dec_intr_vld_d, fcl_dtu_inst_vld_e, 
   fcl_dec_dslot_s, swl_dec_mulbusy_e, swl_dec_fpbusy_e, 
   swl_dec_divbusy_e, swl_dec_fp_enable_d
   );

   input          rclk, 
                  se, 
                  si;
   input [31:0]   dtu_inst_d;	// fed in at Switch (S) stage.
   input [38:0]   erb_dtu_imask;
   input          swl_dec_ibe_e;
   input          dtu_inst_anull_e;
   input          lsu_ifu_ldsta_internal_e;
   input          fcl_dtu_tlzero_d;
   input          fcl_dtu_privmode_d;
   input          fcl_dtu_hprivmode_d;
   input          fcl_dtu_inst_vld_d,
                  fcl_dtu_ely_inst_vld_d,
                  fcl_dec_intr_vld_d,
		              fcl_dtu_inst_vld_e;  // qual with this is not necessary

   input          fcl_dec_dslot_s;

   input          swl_dec_mulbusy_e;
   input          swl_dec_fpbusy_e;
   input          swl_dec_divbusy_e;
   input          swl_dec_fp_enable_d;


   output         so;
   
   // to EXU
   output [2:0]   ifu_exu_aluop_d;// 000 - add/sub
                                  // 001 - and
                                  // 010 - or
                                  // 011 - xor
                                  // 1X0 - movcc
                                  // 1x1 - movr
   output         ifu_exu_invert_d;   // invert rs2 operand
   output         ifu_exu_useimm_d;
   output         ifu_exu_usecin_d;   // use c from icc
   output         ifu_exu_enshift_d;  // turn on shifter

   output         ifu_exu_tagop_d,     
		              ifu_exu_tv_d,     
		              ifu_exu_muls_d,
                  ifu_exu_ialign_d,
		              ifu_exu_range_check_jlret_d,		
		              ifu_exu_range_check_other_d;

   output [2:0] ifu_exu_shiftop_d;  // b2 - 32b(0) or 64b(1)
                                    // b1 - unsigned(0)  or signed(1)
                                    // b0 - left(0) or right(1) shift
   
   output [4:0] ifu_exu_muldivop_d; // b4 - is_mul
                                    // b3 - is_div
                                    // b2 - 64b if 1, 32b if 0
                                    // b1 - signed if 1, unsigned if 0
                                    // b0 - set cc's
   
   output       ifu_exu_wen_d;      // write to rd
   output       ifu_exu_setcc_d;    // b0 - write to icc/xcc

   output       ifu_exu_rd_ifusr_e,
		            ifu_exu_rd_exusr_e,
		            ifu_exu_rd_ffusr_e;

   output       ifu_exu_rs1_vld_d,
		            ifu_exu_rs2_vld_d,
		            ifu_exu_rs3e_vld_d,
		            ifu_exu_rs3o_vld_d;
   
   output       ifu_exu_use_rsr_e_l;
   
   output       ifu_exu_save_d, 
		            ifu_exu_restore_d,
		            ifu_exu_return_d,
		            ifu_exu_flushw_e,
		            ifu_exu_saved_e,
		            ifu_exu_restored_e;

   // to TLU
   output       ifu_tlu_rsr_inst_d,
		            ifu_lsu_wsr_inst_d,
		            ifu_exu_wsr_inst_d,
		            ifu_tlu_done_inst_d,
		            ifu_tlu_retry_inst_d;
   
   // to LSU 
   output       ifu_lsu_ld_inst_e,   // ld inst or atomic
		            ifu_lsu_st_inst_e,   // store or atomic
                ifu_lsu_pref_inst_e,
		            ifu_lsu_alt_space_e, // alt space -- to be removed
		            ifu_lsu_alt_space_d, // never x -- to be removed
		            ifu_tlu_alt_space_d, // sometimes x but faster
		            ifu_lsu_memref_d;    // alerts lsu of upcoming ldst
//		            ifu_lsu_imm_asi_vld_d;

   output       ifu_lsu_sign_ext_e,
		            ifu_lsu_ldstub_e,
		            ifu_lsu_casa_e,
		            ifu_exu_casa_d,
		            ifu_lsu_swap_e;

   output       ifu_tlu_mb_inst_e,
		            ifu_tlu_sir_inst_m,
		            ifu_tlu_flsh_inst_e;

   output       ifu_lsu_ldst_dbl_e,
		            ifu_lsu_ldst_fp_e;
   
   output [1:0] ifu_lsu_ldst_size_e;
   
   // to SPU
//   output 	ifu_spu_scpy_inst_e,
//		ifu_spu_scmp_inst_e;

   // to FFU
   output       ifu_ffu_fpop1_d;
   output       ifu_ffu_visop_d;
   output       ifu_ffu_fpop2_d;
   output       ifu_ffu_fld_d;
   output       ifu_ffu_fst_d;
   output       ifu_ffu_ldst_size_d;
   
   output       ifu_ffu_ldfsr_d,
		            ifu_ffu_ldxfsr_d,
		            ifu_ffu_stfsr_d;
   output       ifu_ffu_quad_op_e;

   // within IFU
   output       dec_fcl_rdsr_sel_pc_d,
		            dec_fcl_rdsr_sel_thr_d;

   output       dec_imd_call_inst_d;

   output       dtu_fcl_flush_sonly_e,
//                dec_fcl_kill4sta_e,
		            dtu_fcl_illinst_e,
		            dtu_fcl_fpdis_e,
		            dtu_fcl_privop_e,
		            dtu_fcl_imask_hit_e,
		            dtu_fcl_br_inst_d,
		            dtu_fcl_sir_inst_e;

   output       dtu_ifq_kill_latest_d;
   
   // within DTU
   output       dec_swl_wrt_tcr_w,
		            dec_swl_wrtfprs_w,
		            dec_swl_ll_done_d,
                dec_swl_br_done_d,
		            dec_swl_rdsr_sel_thr_d,
		            dec_swl_ld_inst_d,
		            dec_swl_sta_inst_e,
		            dec_swl_std_inst_d,
		            dec_swl_st_inst_d,
		            dec_swl_fpop_d,
		            dec_swl_allfp_d,
		            dec_swl_frf_upper_d,
		            dec_swl_frf_lower_d,
		            dec_swl_div_inst_d,
		            dec_swl_mul_inst_d,
		            wsr_fixed_inst_w,
		            ifu_exu_sethi_inst_d;   // can be sethi or no-op

   output [2:0] dec_dcl_cctype_d;       // 0yy - fcc(yy)
                                        // 100 - icc
                                        // 110 - xcc
                                        // 1X1 - illegal inst!
   
   //------------------------------------------------------------
   // Declarations
   //------------------------------------------------------------
   // Internal Signals
   wire [1:0]   op;
   wire [2:0]   op2;
   wire [5:0]   op3;
   wire [8:0]   opf;

   wire         brsethi_inst,  // op types
		            call_inst,
		            arith_inst,
		            mem_inst;
   wire         sethi_or_nop;
   wire [15:0]  op3_lo;        // decode op3[3:0]
   wire [3:0]   op3_hi;        // decode op3[5:4]

   wire         dbr_inst_d, 
		            ibr_inst_d,    // jmpl or return
		            jmpl_inst_d,
		            retn_inst_d,
		            sethi_inst_d;

   wire         rdsr_done_d,
                rdpr_done_d;
   wire         dslot_d;
   
   wire         use_rsr_d_l;
   
   wire         flushw_d,
		            saved_d,
		            restored_d;
   wire         save_retn_done_d;
   wire         privop_d,
		            privop_e,
                hprivop_d,
                hprivop_e,
                valid_hp_rs_d,
                valid_hp_rd_d,
		            inv_reg_access_d,
                rsvchk_fail_d,
		            ill_inst_d,
		            ill_inst_e;

   wire         inst12_5_nonzero_d,
                inst11_8_nonzero_d,
                inst9_5_nonzero_d,
                rs2_nonzero_d;

   wire         state_chg_inst_d,
		            state_chg_inst_e,
		            flush_inst_d;

   wire         cctype_sel_imov,   // select which CC's to use
		            cctype_sel_fmov,
		            cctype_sel_bcc,
		            cctype_sel_bpcc;

   wire         rs1_vld_d,
		            rs2_vld_d,
		            rs3_vld_d,
		            rs4_vld_d;

   wire [4:0]   rs1,
		            rd;
   
   wire         rs1_00,           // decoded rs1
		            rs1_01,
		            rs1_02,
		            rs1_05,
		            rs1_06,
		            rs1_07,
		            rs1_09_0e,
		            rs1_0f,
                rs1_10,
		            rs1_12,
		            rs1_13,
		            rs1_14_15,
		            rs1_16_17,
                rs1_19,
		            rs1_1a,
		            rs1_1b,
		            rs1_1c_1f,
		            rd_00,
		            rd_01,
		            rd_04,
		            rd_05,
		            rd_06,
		            rd_07,
		            rd_09,
		            rd_0f,
                rd_10,
		            rd_11,
		            rd_12,
                rd_13,
                rd_18,
		            rd_1a,
		            rd_1b,
		            rd_1c_1f,
                rd_1f,
		            rs1_1f;

   wire         fcn0;
   
   wire         rd_ifusr_d,
		            rd_ifusr_e,
                rd_ffusr_d,
		            rd_ffusr_e,
		            rd_exusr_d,
		            rd_exusr_e;
   wire         wsr_fixed_inst_e,
		            wsr_fixed_inst_m,
		            wsr_inst_next_e,
		            wsr_fixed_inst_d;

   wire         wrt_tcr_d,
		            wrt_tcr_e,
		            wrt_tcr_qual_e,
		            wrt_tcr_m;
	 
   wire         wrt_fprs_d,
		            wrt_fprs_e,
		            wrt_fprs_qual_e,
		            wrt_fprs_m;
	 
   wire         prefetch,
                impl_prefetch,
                illegal_prefetch,
                noop_prefetch,
                pref_done_d,
                prefetch_d,
                prefetch_e;

   wire [2:0]   lstype_d,
		            lstype_e;
   wire [1:0]   lssize_d;
   wire         ldst_dbl_d,
		            ldst_fp_d,
		            sta_inst_d,
//                kill_for_sta_d,
                sta_nostf_d,
		            sta_inst_e,
                sta_nostf_e,
		            sext_d,
		            ldstub_d,
		            casa_d,
                casa_e,
		            swap_d;

   wire         mb_mask_d,
		            mb_inst_d,
		            mb_inst_e;

   wire         sir_inst_d,
		            sir_inst_e,
//		            kill_sir_d,
		            flag_sir_d,
		            flag_sir_e;
   
   wire         fpld_d,
		            fpop1_d,
                visop_d,
                int_align_d,
		            fpop2_d;
   wire         quad_ffuop_d;

   wire         allfp_d,
		            any_fpinst_d,
		            fpdis_trap_d,
		            fpdis_trap_e,
		            fcc_mov_d,
		            fcc_branch_d;
   
   wire         rs2_hit,
		            opf_hit,
		            ibit_hit,
		            rs1_hit,
		            op3_hit,
		            rd_hit,
		            op_hit,
		            imask_hit,
		            imask_hit_e;

   wire         clk;
   

//----------------------------------------------------------------------
// Code Begins Here
//----------------------------------------------------------------------
   assign       clk = rclk;

   
   assign   op  = dtu_inst_d[31:30];
   assign   op2 = dtu_inst_d[24:22];
   assign   op3 = dtu_inst_d[24:19];
   assign   opf = dtu_inst_d[13:5];

   // decode op
   assign   brsethi_inst = ~op[1] & ~op[0];
   assign   call_inst    = ~op[1] &  op[0];
   assign   arith_inst   =  op[1] & ~op[0];
   assign   mem_inst     =  op[1] &  op[0];

   // partial decode op2
   assign   sethi_or_nop = op2[2] & ~op2[1] & ~op2[0];
   
   // decode op3
   assign   op3_hi[0] = ~op3[5] & ~op3[4];
   assign   op3_hi[1] = ~op3[5] &  op3[4];
   assign   op3_hi[2] =  op3[5] & ~op3[4];
   assign   op3_hi[3] =  op3[5] &  op3[4];
   
   assign   op3_lo[0]  = ~op3[3] & ~op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[1]  = ~op3[3] & ~op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[2]  = ~op3[3] & ~op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[3]  = ~op3[3] & ~op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[4]  = ~op3[3] &  op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[5]  = ~op3[3] &  op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[6]  = ~op3[3] &  op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[7]  = ~op3[3] &  op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[8]  =  op3[3] & ~op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[9]  =  op3[3] & ~op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[10] =  op3[3] & ~op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[11] =  op3[3] & ~op3[2] &  op3[1] &  op3[0];
   assign   op3_lo[12] =  op3[3] &  op3[2] & ~op3[1] & ~op3[0];
   assign   op3_lo[13] =  op3[3] &  op3[2] & ~op3[1] &  op3[0];
   assign   op3_lo[14] =  op3[3] &  op3[2] &  op3[1] & ~op3[0];
   assign   op3_lo[15] =  op3[3] &  op3[2] &  op3[1] &  op3[0];

   //-------------------------
   // Branch and Move Controls
   //-------------------------
   // brtype
   assign dbr_inst_d = brsethi_inst & (op2[1] | op2[0]) |   // regular branch
	                     call_inst;
   assign jmpl_inst_d = arith_inst & op3_hi[3] & op3_lo[8];  // jmpl
   assign retn_inst_d = arith_inst & op3_hi[3] & op3_lo[9];  // retn
   assign ibr_inst_d = jmpl_inst_d | retn_inst_d;
   assign sethi_inst_d = brsethi_inst & sethi_or_nop;
   assign ifu_exu_sethi_inst_d = sethi_inst_d;
   
   assign dec_swl_br_done_d = (dbr_inst_d | jmpl_inst_d); // br compl.
                                                  // retn has separate
                                                  // completion signal
   assign dtu_fcl_br_inst_d = dbr_inst_d | ibr_inst_d;
   assign dec_imd_call_inst_d = call_inst;

   // MV-BR Condition
   assign   cctype_sel_imov  =  op[1] & ~op3[4];
   assign   cctype_sel_fmov  =  op[1] & op3[4];
   assign   cctype_sel_bcc  = ~op[1] &  op2[1];
   assign   cctype_sel_bpcc = ~op[1] & ~op2[1];

   mux4ds  #(3) cctype_mux(.dout  (dec_dcl_cctype_d),
			                   .in0   ({dtu_inst_d[18], dtu_inst_d[12:11]}),
			                   .in1   (dtu_inst_d[13:11]),
			                   // op2[2]=1 for fp branch
			                   .in2   ({~op2[2], 2'b00}),
			                   .in3   ({~op2[2], dtu_inst_d[21:20]}),
			                   .sel0  (cctype_sel_imov),
			                   .sel1  (cctype_sel_fmov),
			                   .sel2  (cctype_sel_bcc),
			                   .sel3  (cctype_sel_bpcc));

   //-------------
   // ALU Controls
   //-------------
   // mov bit
   assign ifu_exu_aluop_d[2] = brsethi_inst & sethi_or_nop |   // sethi
                       	    arith_inst & op3_hi[2] & op3[3];   // mov, rd

   // aluop
   assign ifu_exu_aluop_d[1] = (arith_inst & 
	                              ((op3_hi[3] & (op3_lo[0] |   // wr
                                               op3_lo[2] |   // wrpr
                                               op3_lo[3])) | // wrhpr
				                         (~op3[5] & op3[1]))         // xor, or
                                );
				
   // aluop/mov type
   assign ifu_exu_aluop_d[0] = (arith_inst & 
	                              ((op3_hi[3] & (op3_lo[0] |
                                               op3_lo[2] |
                                               op3_lo[3])) | // wr
				                         (~op3[5] & op3[0])        | // xor, and
				                         (op3_hi[2] & op3_lo[15]))   // movr
                                );
   
   // invert rs2
   assign ifu_exu_invert_d  = arith_inst &
	                      (~op3[5] & op3[2]  |   // sub, andn, orn, xorn
	                       op3_hi[2] & (op3_lo[3] | op3_lo[1])); // tag sub

   assign ifu_exu_usecin_d   = arith_inst & ~op3[5] & op3[3];   // addc, subc

   // tagged ops
   assign ifu_exu_tagop_d = arith_inst & op3_hi[2] & ~op3[3] & ~op3[2] &
	                          fcl_dtu_inst_vld_d;
   assign ifu_exu_tv_d = ifu_exu_tagop_d & op3[1];
   assign ifu_exu_muls_d  = arith_inst & op3_hi[2] & op3_lo[4] & 
	                          ~swl_dec_divbusy_e & fcl_dtu_ely_inst_vld_d;

   // memory for ibr and ldst address range check
   assign ifu_exu_range_check_other_d = mem_inst & ~prefetch; // ld, st, atom
   assign ifu_exu_range_check_jlret_d = arith_inst & op3_hi[3] &    
                                        (op3_lo[8] | op3_lo[9]); // jmpl, retn
   
   //--------------
   // SHFT Controls
   //--------------
   // enable shifter and choose shift output
   // This can be simplified a great deal if MULScc could also be
   // decoded as a shift instruction.
   // 9/26/01: No can do! Mulscc is implemented now
   assign ifu_exu_enshift_d = arith_inst & op3_hi[2] &
                       	       (op3_lo[5] | op3_lo[6] | op3_lo[7]); 
   // unsigned or signed (1 => signed)
   assign ifu_exu_shiftop_d[0] = op3[0];
   // left or right (1 => right)
   assign ifu_exu_shiftop_d[1] = op3[1];
   // shift 32b or 64b (1 => 64)
   assign ifu_exu_shiftop_d[2] = dtu_inst_d[12];   // was sh32_64


   //-------------------
   // Writeback Controls
   //-------------------
   //  write to icc/xcc
   assign ifu_exu_setcc_d = arith_inst & 
	                     (op3_hi[1] & (~op3[3] | ~op3[1] & ~op3[0]) |
	                      op3_hi[2] & (~op3[3] & ~op3[2])); // tagged op
   //  write to rd
   assign ifu_exu_wen_d = ((~rd_00) & brsethi_inst & sethi_or_nop | // sethi
	                         (~rd_00) & arith_inst &  // all single cycle insts
	                         (~op3[5] & ~op3[3]    |     // alu ops
			                      ~op3[5] & op3_lo[8]  |     // addC
			                      ~op3[5] & op3_lo[12] |     // subC
			                      op3_hi[2] &                
			                      (~op3[3] & ~op3_lo[4] |    // shft, tag, ~muls
			                       // need to kill if rd to invalid reg
			                       // all vld regs will retn in W stage
			                       op3_lo[8] & ~rs1_0f | op3_lo[10]  | // rd
                             op3_lo[9] | // rdhpr
			                       op3_lo[12] | op3_lo[15])| // mov
			                      op3_hi[3] &
			                      (op3_lo[8]  |    // jmpl
			                       op3_lo[12] |    // save
			                       op3_lo[13] |    // restore
                             op3_lo[6] & int_align_d)  // vis int align
			                      )           |    
	                         call_inst);
   
   //-----------------
   // MUL/DIV Controls
   //-----------------
   // is mul
   assign dec_swl_mul_inst_d = (arith_inst &
				                        ((op3_hi[0] &
				                          (op3_lo[9]  |      // mulx
				                           op3_lo[10] |      // umul
				                           op3_lo[11])) |    // smul
				                         (op3_hi[1] &        
				                          (op3_lo[10] |      // umulcc
				                           op3_lo[11])))     // smulcc
				                        );

   assign ifu_exu_muldivop_d[4] = dec_swl_mul_inst_d & ~swl_dec_mulbusy_e & 
                                  fcl_dtu_ely_inst_vld_d;
   
   // is div
   assign dec_swl_div_inst_d = (arith_inst &
				                        ((op3_hi[0] &
				                          (op3_lo[13]  |     // udivx
				                           op3_lo[14]  |     // udiv
				                           op3_lo[15]))  |   // sdiv
				                         (op3_hi[2] & 
				                          (op3_lo[13]   |    // sdivx
				                           op3_lo[4]))  |    // muls
				                         (op3_hi[1] &
				                          (op3_lo[14] |      // udivcc
				                           op3_lo[15])))     // sdivcc
				                        );

   assign ifu_exu_muldivop_d[3] = dec_swl_div_inst_d & ~swl_dec_divbusy_e &
				                          op3[3] & fcl_dtu_ely_inst_vld_d; // not muls
   
   // 64b or 32b (1 => 64b)
   assign ifu_exu_muldivop_d[2] = ~op3[1];

   // signed or unsigned (1 => signed)
   assign ifu_exu_muldivop_d[1] = op3_hi[2] |          // sdivx
	                                (op3[1] & op3[0]);   // smul, sdiv
   // set cc as well?
   assign ifu_exu_muldivop_d[0] = op3[4];

   //-------------------------
   // FP controls
   //-------------------------

   // portion of vis that is actually an int instruction
   assign int_align_d = (~opf[8] & ~opf[7] & ~opf[6] & ~opf[5] & 
                         opf[4] & opf[3] & ~opf[2] & ~opf[0]);
   assign ifu_exu_ialign_d = arith_inst & op3_hi[3] & op3_lo[6] &
                             int_align_d & fcl_dtu_inst_vld_d;
   

   assign fpop1_d = arith_inst & op3_hi[3] & op3_lo[4];
   assign fpop2_d = arith_inst & op3_hi[3] & op3_lo[5];
   assign visop_d = arith_inst & op3_hi[3] & op3_lo[6];
   assign fpld_d = mem_inst & op3[5] & ~op3[3] & ~op3[2];

   // FP stores don't switch out and don't block the fpu
   assign dec_swl_fpop_d = (fpop1_d | fpop2_d | fpld_d | visop_d);
   assign allfp_d = (fpop1_d | fpop2_d | fpld_d | visop_d |
	                   mem_inst & op3[5] & ~op3[3] & op3[2]);
   assign dec_swl_allfp_d = allfp_d;

   assign ifu_ffu_ldfsr_d = op3_lo[1] & op3_hi[2] & ~rd[0];
   assign ifu_ffu_ldxfsr_d = op3_lo[1] & op3_hi[2] & rd[0];	  
   assign ifu_ffu_stfsr_d = op3_lo[5] & op3_hi[2];	  

   assign ifu_ffu_fpop1_d = fpop1_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;
   assign ifu_ffu_fpop2_d = fpop2_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;
   assign ifu_ffu_visop_d = visop_d & ~swl_dec_fpbusy_e & 
                            fcl_dtu_ely_inst_vld_d;

   assign ifu_ffu_fld_d =  mem_inst & op3[5] & ~op3[3] & ~op3[2] & 
			                     fcl_dtu_ely_inst_vld_d & ~swl_dec_fpbusy_e;
   
   assign ifu_ffu_fst_d =  mem_inst & op3[5] & ~op3[3] & op3[2] & 
		                       fcl_dtu_ely_inst_vld_d & ~swl_dec_fpbusy_e;

   // ldqf and stqf are not fpops
   assign quad_ffuop_d = (opf[1] & opf[0] & (fpop1_d | fpop2_d) |
	                        fpop1_d & opf[3] & opf[2] & // exc div
	                        ~(~opf[7] & opf[6] & ~opf[5])) &
	                         swl_dec_fp_enable_d & fcl_dtu_inst_vld_d;

   dff_s #(1) qope_ff(.din  (quad_ffuop_d),
		              .q    (ifu_ffu_quad_op_e),
		              .clk  (clk), .se(se), .si(), .so());

   // quiet traps -- flush the pipe but don't take a trap till later
//   assign dec_swl_qtrap_d = mem_inst & op3[5] & op3_lo[6] & fcl_dtu_inst_vld_d;  // stq
//   dff #(1) qtrpe_ff(.din  (dec_swl_qtrap_d),
//		   .q    (dtu_fcl_qtrap_e),
//		   .clk  (clk), .se(se), .si(), .so());

   // FP Enabled check
   assign fcc_branch_d = ~op[1] & ~op[0] & op3[5] & (op3[4] | op3[3]);
   assign fcc_mov_d = op[1] & ~op[0] & op3_hi[2] & op3_lo[12] & 
	                    ~dtu_inst_d[18];
   
   assign any_fpinst_d = allfp_d | fcc_branch_d | fcc_mov_d | 
                         arith_inst & op3_hi[2] & op3_lo[8] & rs1_13 | // rd gsr
                         arith_inst & op3_hi[3] & op3_lo[0] & rd_13;   // wr gsr
   
   assign fpdis_trap_d = any_fpinst_d & ~swl_dec_fp_enable_d & 
                         fcl_dtu_inst_vld_d;
   dff_s #(1) fpdise_ff(.din (fpdis_trap_d),
		                .q   (fpdis_trap_e),
		                .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_fpdis_e = fpdis_trap_e;

   // FRF dirty bits
   // bit 0 is the msb for double and quad
   assign dec_swl_frf_upper_d = rd[0] & (mem_inst & op3_lo[3] |  // fld
					                    fpop1_d & (opf[7] | opf[6] & opf[5]) & 
                                         (opf[3] | ~opf[2]) |
					                    fpop1_d & ~opf[7] & opf[1] & ~opf[0] |
					                    fpop2_d & opf[1] | 
                              visop_d & ~opf[0]);
   
   assign dec_swl_frf_lower_d = ~rd[0] & (mem_inst & op3_lo[3] |  // fld
					                    fpop1_d & (opf[7] | opf[6] & opf[5]) & 
                                          (opf[3] | ~opf[2]) |
					                    fpop1_d & ~opf[7] & opf[1] & ~opf[0] |
					                    fpop2_d & opf[1] | 
                              visop_d & ~opf[0]) |
				                      (fpop2_d & ~opf[1] |  // all sgl ops wrt lower
	                             fpop1_d & opf[7] & ~opf[3] & opf[2] |
                                     //bug 6470 - fdtoi,fstoi,fqtoi
	                             (fpop1_d & (opf[7:6]==2'b11) & (opf[3:2]==2'b00)) |
                                     //bug6470 - end
				                       fpop1_d & ~opf[7] & ~opf[1] & opf[0] |
                               visop_d & opf[0] |
				                       mem_inst & op3_lo[0] & op3[5]);
   
   
   //-------------------------
   // Special Reg R/W Controls
   //-------------------------
   // decode rs1
   assign rs1 = dtu_inst_d[18:14];
   assign rs1_00 = ~rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & ~rs1[0]; // Y
   assign rs1_01 = ~rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & rs1[0]; //
   assign rs1_02 = ~rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0];  // CCR
   assign rs1_05 = ~rs1[4] & ~rs1[3] & rs1[2] & ~rs1[1] & rs1[0]; // PC
   assign rs1_06 = ~rs1[4] & ~rs1[3] & rs1[2] & rs1[1] & ~rs1[0]; // fprs
   assign rs1_07 = ~rs1[4] & ~rs1[3] & rs1[2] & rs1[1] & rs1[0]; //
   assign rs1_0f = ~rs1[4] & rs1[3] & rs1[2] & rs1[1] & rs1[0];   // mem#
   assign rs1_10 = rs1[4] & ~rs1[3] & ~rs1[2] & ~rs1[1] & ~rs1[0];   
   assign rs1_12 = rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0];
   assign rs1_13 = rs1[4] & ~rs1[3] & ~rs1[2] & rs1[1] & rs1[0];
   assign rs1_14_15 = rs1[4] & ~rs1[3] & rs1[2] & ~rs1[1];   
   assign rs1_16_17 = rs1[4] & ~rs1[3] & rs1[2] & rs1[1];
   assign rs1_19 = rs1[4] & rs1[3] & ~rs1[2] & ~rs1[1] & rs1[0];
   assign rs1_1f = rs1[4] & rs1[3] & rs1[2] & rs1[1] & rs1[0];    // 
   assign rs1_1a = rs1[4] & rs1[3] & ~rs1[2] & rs1[1] & ~rs1[0]; // THR
   assign rs1_1b = rs1[4] & rs1[3] & ~rs1[2] & rs1[1] & rs1[0];
   assign rs1_1c_1f = rs1[4] & rs1[3] & rs1[2];
   assign rs1_09_0e = ~rs1[4] & rs1[3] &          // all window mgmt regs
	              (rs1[2] & ~rs1[1] | rs1[1] & ~rs1[0] |
		             rs1[0] & ~rs1[2]);

   // decode rd
   assign rd = dtu_inst_d[29:25];
   assign rd_00 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & ~rd[0]; // mem#
   assign rd_01 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & rd[0]; // 
   assign rd_04 = ~rd[4] & ~rd[3] & rd[2] & ~rd[1] & ~rd[0]; //  tick
   assign rd_05 = ~rd[4] & ~rd[3] & rd[2] & ~rd[1] & rd[0];  //  PC
   assign rd_06 = ~rd[4] & ~rd[3] & rd[2] & rd[1] & ~rd[0]; 
   assign rd_07 = ~rd[4] & ~rd[3] & rd[2] & rd[1] & rd[0]; 
   assign rd_09 = ~rd[4] & rd[3] & ~rd[2] & ~rd[1] & rd[0]; // CWP
   assign rd_0f = ~rd[4] & rd[3] & rd[2] & rd[1] & rd[0];   // not impl
   assign rd_10 = rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & ~rd[0];   // gl
   assign rd_11 = rd[4] & ~rd[3] & ~rd[2] & ~rd[1] & rd[0];   // pic
   assign rd_12 = rd[4] & ~rd[3] & ~rd[2] & rd[1] & ~rd[0];   // not impl
   assign rd_13 = rd[4] & ~rd[3] & ~rd[2] & rd[1] & rd[0];   // GSR
   assign rd_18 = rd[4] & rd[3] & ~rd[2] & ~rd[1] & ~rd[0]; // stick   
   assign rd_1a = rd[4] & rd[3] & ~rd[2] & rd[1] & ~rd[0]; // Thr
   assign rd_1b = rd[4] & rd[3] & ~rd[2] & rd[1] & rd[0];
   assign rd_1c_1f = rd[4] & rd[3] & rd[2];
   assign rd_1f = rd[4] & rd[3] & rd[2] & rd[1] & rd[0];
   
   assign ifu_lsu_wsr_inst_d = arith_inst & fcl_dtu_ely_inst_vld_d & 
	                       op3_hi[3] & (op3_lo[0] | op3_lo[2] | op3_lo[3]);
   assign ifu_exu_wsr_inst_d = ifu_lsu_wsr_inst_d;

   assign ifu_tlu_rsr_inst_d = arith_inst & fcl_dtu_ely_inst_vld_d & 
	                       op3_hi[2] & (op3_lo[8] & ~rs1_0f | // ~membar
                                      op3_lo[9] |           // hpr
					                            op3_lo[10]);          // pr

   assign rdsr_done_d = arith_inst & op3_hi[2] & op3_lo[8] & ~mb_inst_d;
   assign rdpr_done_d = arith_inst & op3_hi[2] & (op3_lo[10] | op3_lo[9]);
   
   // all wrpr's except cwp are fixed length
   // 
   assign wsr_fixed_inst_d = arith_inst & op3_hi[3] & 
                               (op3_lo[2] & ~rd_09 |  // wrpr exc. cwp 
	                              op3_lo[0] & ~rd_1a |  // wr exc. thr
                                op3_lo[3]);           // wrhpr
   
	                     
   dff_s #(1) wre_ff(.din (wsr_fixed_inst_d),
		             .clk (clk),
		             .q   (wsr_fixed_inst_e),
		             .se  (se), .si(), .so());

   assign wsr_inst_next_e = (~dtu_inst_anull_e) & wsr_fixed_inst_e & 
	                          fcl_dtu_inst_vld_e;
   
   dff_s #(1) wrm_ff(.din (wsr_inst_next_e),
		             .clk (clk),
		             .q   (wsr_fixed_inst_m),
		             .se  (se), .si(), .so());

   dff_s #(1) wrw_ff(.din (wsr_fixed_inst_m),
		             .clk (clk),
		             .q   (wsr_fixed_inst_w),
		             .se  (se), .si(), .so());

   assign use_rsr_d_l = ~(ifu_tlu_rsr_inst_d | ibr_inst_d | call_inst);
   
   dff_s #(1) rdsre_ff(.din (use_rsr_d_l),
		               .clk (clk),
		               .q   (ifu_exu_use_rsr_e_l),
		               .se  (se), .si(), .so());

   assign flush_inst_d = fcl_dtu_inst_vld_d & arith_inst & 
	                       op3_hi[3] & op3_lo[11];

   dff_s #(1) flsh_ff(.din (flush_inst_d),
		              .q   (ifu_tlu_flsh_inst_e),
		              .clk (clk),
		              .se  (se), .si(), .so());
   

   // If machine state is changed kill the already fetched instructions
   assign state_chg_inst_d = ifu_lsu_wsr_inst_d | flush_inst_d |
	                           ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d;

   
   dff_s #(1) schg_ff(.din (state_chg_inst_d),
		                .clk (clk),
		                .q   (state_chg_inst_e),
//		               .rst (reset),
		                .se  (se), .si(), .so());

//   assign sta_inst_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d & 
//                       (~op3[5] & ~op3[3] & op3[2] |
//			                  op3[5] & (op3_lo[4] | op3_lo[7]) |
//			                  ~op3[5] & op3_lo[14]);
   assign sta_inst_d = mem_inst & op3[4] & op3[2] & fcl_dtu_inst_vld_d & ~prefetch;

   assign sta_nostf_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d & 
                       (~op3[5] & ~op3[3] & op3[2] |
			                  ~op3[5] & op3_lo[14]);

   dff_s #(1) sta_ff (.din (sta_inst_d),
		              .clk (clk),
		              .q   (sta_inst_e),
		              .se  (se), .si(), .so());

   dff_s #(1) stanf_ff (.din (sta_nostf_d),
		                  .clk (clk),
		                  .q   (sta_nostf_e),
		                  .se  (se), .si(), .so());

  assign dec_swl_sta_inst_e = sta_nostf_e;
 
   // Mov qualification with inst_vld_e to FCL?  Done
   assign dtu_fcl_flush_sonly_e = (sta_inst_e & lsu_ifu_ldsta_internal_e |
                                   state_chg_inst_e);

   dff_s #(1) ds_ff(.din (fcl_dec_dslot_s),
                  .q   (dslot_d),
                  .clk (clk), .se(se), .si(), .so());

   // suppress ifetch if arch state changes in delay slot (if not 
   // suppressed, it may cause in error in the L2 for an unmapped 
   // address). 
//   assign dtu_ifq_kill_latest_d = ifu_lsu_wsr_inst_d | flush_inst_d |
//	                              ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d |  
//                                sta_inst_d;
   assign dtu_ifq_kill_latest_d = (((arith_inst & op3_hi[3] & 
                                     (op3_lo[2] | op3_lo[3] | op3_lo[0]) |// wr
                                     mem_inst & op3[4] & op3[2]) & 
                                    fcl_dtu_ely_inst_vld_d) |
                                   fcl_dec_intr_vld_d) & dslot_d; // in DS

//   assign kill_for_sta_d = mem_inst & op3[4] & op3[2] & 
                           // ~op3[5] &  // sta - excl stf and pref
//                           fcl_dtu_ely_inst_vld_d & dslot_d; // in DS
   
//   dff #(1) kfste_ff(.din (kill_for_sta_d),
//                     .q   (kill_for_sta_e),
//                     .clk (clk), .se(se), .si(), .so());
//   assign dec_fcl_kill4sta_e = kill_for_sta_e;
   
   assign rd_ifusr_d = arith_inst & op3_hi[2] & 
	                     (op3_lo[9] & rs1_06    |  // rdhpr - ver
			                  op3_lo[8] & (rs1_05 |    // rdsr - pc
				                             rs1_1a |    // rdsr - thr
				                             rs1_06))  | // rdsr - fprs
		                     jmpl_inst_d |                    // jmpl
	                     call_inst;                         // call
   
   assign rd_exusr_d = arith_inst & op3_hi[2] &
	        (op3_lo[10] & rs1_09_0e |         // rdpr (wind)
			     op3_lo[8] & (rs1_00 | rs1_02));  // rdsr (y + ccr)

   assign rd_ffusr_d = arith_inst & op3_hi[2] &
			                 op3_lo[8] & rs1_13;  // rdsr (gsr)
   
   dff_s #(1) ifusr_ff(.din  (rd_ifusr_d),
		               .clk  (clk),
		               .q    (rd_ifusr_e),
		               .se   (se), .si(), .so());
   dff_s #(1) ffusr_ff(.din  (rd_ffusr_d),
		               .clk  (clk),
		               .q    (rd_ffusr_e),
		               .se   (se), .si(), .so());
   dff_s #(1) exusr_ff(.din  (rd_exusr_d),
		               .clk  (clk),
		               .q    (rd_exusr_e),
		               .se   (se), .si(), .so());

   // make sure they are exclusive
   assign ifu_exu_rd_ifusr_e = rd_ifusr_e;
   assign ifu_exu_rd_exusr_e = rd_exusr_e;
   assign ifu_exu_rd_ffusr_e = rd_ffusr_e;

   // choose which of IFU special regs should be read
   // call, jmpl or rdpc (05) => pc
   assign dec_fcl_rdsr_sel_pc_d = ~dtu_inst_d[31] | op3_hi[3] | ~rs1[1] & rs1[0];
   // read thread conf (1a) or fprs (06)
   assign dec_fcl_rdsr_sel_thr_d = dtu_inst_d[31] & op3_hi[2] & op3_lo[8] & ~rs1[0];
   // else version reg (rdhpr 06)

   //   dff #(1) rdfprs_ff(.din (rs1[4]),
   //		    .q   (dec_swl_rdsr_sel_thr_e),
   //		    .clk (clk), .se(se), .si(), .so());
   assign dec_swl_rdsr_sel_thr_d = rs1[4];

   assign wrt_tcr_d = arith_inst & fcl_dtu_inst_vld_d & 
	                    op3_hi[3] & op3_lo[0] & rd_1a;

   dff_s #(1) tcre_ff(.din  (wrt_tcr_d),
		                .clk  (clk),
		                .q    (wrt_tcr_e),
		                .se   (se), .si(), .so());

   assign wrt_tcr_qual_e = wrt_tcr_e & (~dtu_inst_anull_e) & 
					                               fcl_dtu_inst_vld_e;

   dff_s #(1) tcrm_ff(.din  (wrt_tcr_qual_e),
		              .clk  (clk),
		              .q    (wrt_tcr_m),
		              .se   (se), .si(), .so());
   
   dff_s #(1) tcrw_ff(.din  (wrt_tcr_m),
		              .clk  (clk),
		              .q    (dec_swl_wrt_tcr_w),
		              .se   (se), .si(), .so());

   // FPRS write
   assign wrt_fprs_d = arith_inst & fcl_dtu_inst_vld_d & 
	                     op3_hi[3] & op3_lo[0] & rd_06;
   dff_s #(1) fprse_ff(.din  (wrt_fprs_d),
		               .clk  (clk),
		               .q    (wrt_fprs_e),
		               .se   (se), .si(), .so());
   assign wrt_fprs_qual_e = wrt_fprs_e & (~dtu_inst_anull_e) & 
					                                 fcl_dtu_inst_vld_e;
   dff_s #(1) fprsm_ff(.din  (wrt_fprs_qual_e),
		               .clk  (clk),
		               .q    (wrt_fprs_m),
		               .se   (se), .si(), .so());
   dff_s #(1) fprsw_ff(.din  (wrt_fprs_m),
		               .clk  (clk),
		               .q    (dec_swl_wrtfprs_w),
		               .se   (se), .si(), .so());

   //----------------
   // RF/RML Controls
   //----------------
   // Reg Valid Signals for doing ECC

   //bug6777 - cas decode is incorrect
   //         ~(op3_hi[3] & dtu_inst_d[22] & mem_inst); // CAS
   assign ifu_exu_useimm_d = ~dtu_inst_d[31] | 
	                      dtu_inst_d[13] & 
	                     ~(op3_hi[3] & dtu_inst_d[22] & ~op3[0] & mem_inst); // CAS

   // alternately try: ~ren2_d | ~23 | ~22
   assign rs1_vld_d = (brsethi_inst & op2[1] & op2[0] |
		                   arith_inst & (~op3[5] |
				                             op3_hi[2] & ~op3[3] |
				                             op3_hi[2] & op3_lo[13] |
				                             op3_hi[2] & op3_lo[15] |
				                             op3_hi[3] & op3_lo[0]  |
				                             op3_hi[3] & op3_lo[2]  |
				                             op3_hi[3] & op3_lo[3]  |
				                             op3_hi[3] & op3_lo[5] & 
                                     ~opf[4] & ~opf[3] & opf[2] |  // fmovr
				                             op3_hi[3] & op3_lo[6] & int_align_d  |
				                             op3_hi[3] & op3[3] & ~op3[2] |
				                             op3_hi[3] & op3[3] & ~op3[1]) |
		                   mem_inst & (~op3[5] |
				                           ~op3[3] |
				                           op3[4] & op3[3] & op3[2]));

   assign ifu_exu_rs1_vld_d = rs1_vld_d;

   assign rs2_vld_d = (arith_inst & (~op3[5] |
				                             op3_hi[2] & (~op3[3] | op3[2]) |
				                             op3_hi[3] & op3_lo[0]  |
				                             op3_hi[3] & op3_lo[2]  |
				                             op3_hi[3] & op3_lo[3]  |
				                             op3_hi[3] & op3_lo[6] & int_align_d  |
				                             op3_hi[3] & op3[3] & ~op3[2] |
				                             op3_hi[3] & op3[3] & ~op3[1]) &
		                               ~dtu_inst_d[13] |
		                   mem_inst & (~op3[5] |
				                           ~op3[3]) & ~dtu_inst_d[13] |
		                   mem_inst & op3_hi[3] & (op3_lo[12] |   // cas
					                                     op3_lo[14]));

   assign ifu_exu_rs2_vld_d = rs2_vld_d;

   assign rs3_vld_d = mem_inst & (~op3[5] & ~op3[3] & op3[2] | // all st
				                          ~op3[5] & op3[3] & op3[2] | // swp,stx,ldstub
				                          op3_hi[3] & (op3_lo[12] |   // cas
					                                     op3_lo[14])) |
                      arith_inst & (op3_hi[2] & (op3_lo[12] | 
                                                 op3_lo[15]));
   
   // for std and stq(=stda) & ~stf
   assign rs4_vld_d = mem_inst & ~op3[5] & op3_lo[7];

   // rs3even = rs4 + rs3 & ~rd[0]
   // rs3odd = rs4 + rs3 & rd[0]
   // needs both to distinguish std
   assign ifu_exu_rs3e_vld_d = rs4_vld_d | rs3_vld_d & ~rd[0];
   assign ifu_exu_rs3o_vld_d = rs4_vld_d | rs3_vld_d & rd[0];

   // RML control signals
   assign ifu_exu_save_d = arith_inst & op3_hi[3] & op3_lo[12] & 
                           fcl_dtu_inst_vld_d;
   assign ifu_exu_restore_d = arith_inst & op3_hi[3] & fcl_dtu_inst_vld_d &
              	        (op3_lo[13] |       // restore
		                     op3_lo[9]);        // return
   assign ifu_exu_return_d = arith_inst & op3_hi[3] & op3_lo[9] & 
                             fcl_dtu_inst_vld_d;   

   assign save_retn_done_d = arith_inst & op3_hi[3] & (op3_lo[12] | op3_lo[9]);
   assign saved_d = arith_inst & op3_hi[3] & op3_lo[1] & ~dtu_inst_d[25] & 
                    fcl_dtu_inst_vld_d;
   assign restored_d = arith_inst & op3_hi[3] & op3_lo[1] & dtu_inst_d[25] & 
                     fcl_dtu_inst_vld_d;
   assign flushw_d = arith_inst & op3_hi[2] & op3_lo[11] & fcl_dtu_inst_vld_d;
   
   dff_s #(1) savd_ff(.din  (saved_d),
		              .clk  (clk),
		              .q    (ifu_exu_saved_e),
		              .se   (se), .si(), .so());
   dff_s #(1) restd_ff(.din  (restored_d),
		               .clk  (clk),
		               .q    (ifu_exu_restored_e),
		               .se   (se), .si(), .so());
   dff_s #(1) flushw_ff(.din  (flushw_d),
		                .clk  (clk),
		                .q    (ifu_exu_flushw_e),
		                .se   (se), .si(), .so());

   //-----------------------
   // TLU Controls and Traps
   //-----------------------
   // Done/Retry
   assign ifu_tlu_done_inst_d = arith_inst & op3_hi[3] & op3_lo[14] &
	                        fcl_dtu_ely_inst_vld_d & 
	                        ~dtu_inst_d[25];   // inst_d[25] = lsb of fcn
   assign ifu_tlu_retry_inst_d = arith_inst & op3_hi[3] & op3_lo[14] & 
	                        fcl_dtu_ely_inst_vld_d & dtu_inst_d[25];

   // SIR
   assign sir_inst_d = arith_inst & op3_hi[3] & op3_lo[0] & 
	               rs1_00 & rd_0f & dtu_inst_d[13];

//   assign kill_sir_d = sir_inst_d & ~(fcl_dtu_privmode_d | fcl_dtu_hprivmode_d);
//bug 6484 - flag sir instrn. to tlu only in hpriv mode
//   assign flag_sir_d = sir_inst_d & (fcl_dtu_privmode_d | fcl_dtu_hprivmode_d);

   assign flag_sir_d = sir_inst_d & fcl_dtu_hprivmode_d;

   dff_s #(1) sire_ff(.din (flag_sir_d),
		              .q   (sir_inst_e),
		              .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_sir_inst_e = sir_inst_e;

//bug 6484 - kill sir instrn. to tlu if bits other than opcode bits cause illegal instrn.
//   assign flag_sir_e = sir_inst_e & fcl_dtu_inst_vld_e & ~dtu_inst_anull_e;

   assign flag_sir_e = sir_inst_e & fcl_dtu_inst_vld_e & ~dtu_inst_anull_e & ~ill_inst_e;

   dff_s #(1) sirm_ff(.din (flag_sir_e),
		              .q   (ifu_tlu_sir_inst_m),
		              .clk (clk), .se(se), .si(), .so());
   

   // Privileged opcode trap
   assign fcn0 = ~rd[4] & ~rd[3] & ~rd[2] & ~rd[1];

	 //op3_lo[0] & rd[4] & ~(rd_12 | rd_13 | 
	 //rd[3] & ~rd_1a |
   //rd_1f)) | 

   assign privop_d = (op3_hi[3] & (op3_lo[14] | // done/retr
				                           op3_lo[2] |         // wrpr
                                   // & (~rd[4] & ~rd_0f | rd_10) |
                                   // op3_lo[3] |         // wrhpr
                                   // & valid_hp_rd_d |  
				                           op3_lo[1] |  // savd,restd
				                           op3_lo[0] & ((rd[4] & ~(rd_11 | rd_12 | rd_13 | rd_1b |
							                                             rd[3] & rd[2])) |
                                                rd_04)) | // wrasr
		                                                   
		                  op3_hi[2] & (op3_lo[10] |        // rdpr
                                   // & (~rs1[4] | rs1_10 | rs1_1f) |
                                   // op3_lo[9] |         // rdhpr
                                   // & valid_hp_rs_d |
				                           op3_lo[8] &           // rdasr & ~mem#
				                           (rs1_10 | rs1_16_17 | // perf + sftint
                                    rs1_19 | rs1_1a))    // stick, thrd stat
		                  ) & arith_inst & ~(fcl_dtu_privmode_d | 
                                         fcl_dtu_hprivmode_d);

   // hp regs 0,1,3 and 5, 6 and 1f are implemented
   // 6 is read only

   assign valid_hp_rd_d = (~rd[4] & ~rd[3] & rd[0] & 
                           (~rd[2] | ~rd[1]) |      // 1,3,5
                           rd_00 | rd_1f );          // 0, 1f
   assign valid_hp_rs_d = (~rs1[4] & ~rs1[3] & rs1[0] & 
                           (~rs1[2] | ~rs1[1]) |
                           rs1_00 | rs1_06 | rs1_1f);
   
   assign hprivop_d = arith_inst & ~fcl_dtu_hprivmode_d & 
                      (op3_hi[3] & op3_lo[3] |      // wrhpr
                       // & valid_hp_rd_d 
                       op3_hi[2] & op3_lo[9] |      // rdhpr
                       // & valid_hp_rs_d 
                       // bug 6484 ----
                       sir_inst_d |
                       //  ----
                       op3_hi[3] & op3_lo[0] & 
                          (rd_04 | rd_18) & fcl_dtu_privmode_d |   // wrsr s/tick
                       op3_hi[3] & op3_lo[2] & 
                          rd_04 & fcl_dtu_privmode_d);             // wrpr
          
   dff_s #(1) prope_ff(.din (privop_d),
		                 .q   (privop_e),
		                 .clk (clk), .se(se), .si(), .so());

   dff_s #(1) hprope_ff(.din (hprivop_d),
		                 .q   (hprivop_e),
		                 .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_privop_e = privop_e & ~hprivop_e;
//   assign dtu_fcl_hprivop_e = hprivop_e & ~dtu_inst_anull_e;   

   // Illegal Instruction Trap
   // when they are accessed.  
   assign inv_reg_access_d = arith_inst & (op3_hi[2] & op3_lo[8] &    // rd asr
					                                 (rs1_01 | rs1_07 |         // 1, 7
                                            ~rs1[4] & rs1[3] & ~rs1_0f |  // 8-E, F=mem#
					                                  rs1_12 | rs1_14_15 |      // 13 is gsr
                                                                   // 14-15 are WO
                                            rs1_1b | 
                                            rs1_1c_1f) |
   
					                                 op3_hi[3] & op3_lo[0] &   // wr asr
					                                 (rd_01 | rd_05 | rd_07 |
                                            ~rd[4] & rd[3] & ~rd_0f | // 8-E, F is sir
					                                  rd_12 | rd_1b | 
                                            rd_1c_1f)
                                           );

   // reserved field checking (more done in ill_inst check below)
   assign inst12_5_nonzero_d = (|dtu_inst_d[12:5]);
   assign inst11_8_nonzero_d = (|dtu_inst_d[11:8]);
   assign inst9_5_nonzero_d = (|dtu_inst_d[9:5]);
   assign rs2_nonzero_d = (|dtu_inst_d[4:0]);

   // rsv check is not complete, but most of the important 
   // holes are covered
   assign rsvchk_fail_d = (arith_inst & ((~op3[5] |  // arith
                                          op3_hi[2] & op3_lo[13] | // sdivx
                                          op3_hi[2] & ~op3[3] & ~op3[2] | // tag
                                          op3_hi[2] & op3_lo[4] |  // mulscc
                                          op3_hi[3] & op3_lo[11] | // flsh
                                          op3_hi[3] & op3[3] & ~op3[1]) & // sav,jmp
                                         ~dtu_inst_d[13] & inst12_5_nonzero_d |
   
                                         op3_hi[2] & (op3[3] & ~op3[2] &  // rd/rdpr
                                                      ~(rs1_0f & 
                                                        dtu_inst_d[13]) | // ~mem#
                                                      op3_lo[11]) &  // flshw
                                         (inst12_5_nonzero_d | 
                                          rs2_nonzero_d | 
                                          dtu_inst_d[13]) |
   
                                         op3_hi[3] & ~op3[3] & ~op3[2] & // wr/pr
                                         ~rd_0f &  // ~sir
                                         ~dtu_inst_d[13] & inst12_5_nonzero_d |
   
				                                 op3_hi[2] & op3_lo[12] &  // movcc
                                         ~dtu_inst_d[13] & 
                                         (inst9_5_nonzero_d | dtu_inst_d[10]) |
   
                                         op3_hi[2] & op3_lo[15] &  // movr
                                         ~dtu_inst_d[13] & 
                                         inst9_5_nonzero_d |

                                         op3_hi[3] & op3_lo[11] &  // flsh
                                         ~rd_00 |

                                         op3_hi[2] & op3_lo[11] &  // flshw
                                         (~rd_00 | ~rs1_00) |

				                                 op3_hi[2] & 
                                         (op3_lo[5] | op3_lo[6] | 
                                          op3_lo[7]) & // shft
                                         (inst11_8_nonzero_d |
                                          dtu_inst_d[7] |
                                          dtu_inst_d[6] |
                                          dtu_inst_d[5] & (~dtu_inst_d[12] |
                                                           ~dtu_inst_d[13]))
                                         ) |
   
		                       mem_inst & (~op3[4] & ~dtu_inst_d[13] &  // ld/st
                                       inst12_5_nonzero_d |
                                       op3_hi[3] & 
                                       (op3_lo[12] | op3_lo[14]) &  // cas
                                       dtu_inst_d[13] & inst12_5_nonzero_d) |
				       
				       ((op[1] & ~op[0]) & (op3[5] & op3[4] & op3[3] & ~op3[2] & ~op3[1] & op3[0]) & |rd) // RETURN(rd != 0), bug 4490

                           );
   


   assign ill_inst_d = (brsethi_inst & (~op2[2] & ~op2[1] & ~op2[0] |  // ill inst
					                              op2[2] & op2[1] & op2[0] | // null
					                              op2[1] & op2[0] &  // wrong bpr cond
					                              (~dtu_inst_d[25] & ~dtu_inst_d[26] |
                                         dtu_inst_d[28]) | // b28 has to be 0
					                              ~op2[2] & ~op2[1] & op2[0] & // bpcc
					                              dtu_inst_d[20]) |
			                  arith_inst & (op3_hi[1] & (op3_lo[9] | op3_lo[13]) |
				                              op3_hi[3] & (op3_lo[15] | // null
						                                       op3_lo[7]) | // impdep2
				                              op3_hi[3] & op3_lo[14] & 
				                              (~fcn0 | fcl_dtu_tlzero_d |
                                       rs2_nonzero_d | inst12_5_nonzero_d |
                                       dtu_inst_d[13] | ~rs1_00) |  // done/retr
				                              op3_hi[2] & op3_lo[12] & // movcc
				                              dtu_inst_d[18] & dtu_inst_d[11] |
				                              op3_hi[2] & op3_lo[15] &  // movr
				                              ~dtu_inst_d[11] & ~dtu_inst_d[10] |
				                              op3_hi[2] & op3_lo[14] | // popc
				                              op3_hi[2] & op3_lo[9] &  //rdhpr
                                      (~valid_hp_rs_d | rs1_01 & fcl_dtu_tlzero_d) |
				                              op3_hi[2] & op3_lo[10] &      // rdpr
				                              (rs1[4] & ~rs1_10 | // not gl
                                       rs1_0f | 
				                               ~rs1[4] & ~rs1[3] & ~rs1[2] & fcl_dtu_tlzero_d) |
				                              op3_hi[2] & op3_lo[8] & 
                                      (rs1_0f & (~rd_00 |
                                                 dtu_inst_d[12] |
                                                 dtu_inst_d[7] |
                                                 inst11_8_nonzero_d)) | // mem#
				                              op3_hi[3] & op3_lo[1] & 
                                      (~fcn0 | ~rs1_00 | rs2_nonzero_d |
                                       inst12_5_nonzero_d |
                                       dtu_inst_d[13]) | // savd, restd
				                              op3_hi[3] & op3_lo[10] & 
                                      (inst11_8_nonzero_d |
                                       dtu_inst_d[7] & 
                                       ~(fcl_dtu_privmode_d |
                                         fcl_dtu_hprivmode_d) |
                                       dtu_inst_d[29] |
                                       ~dtu_inst_d[13] & (dtu_inst_d[6] |
                                                          dtu_inst_d[5])) |// tcc
                                      op3_hi[3] & op3_lo[3] &   // wrhpr
                                      (~valid_hp_rd_d | rd_01 & fcl_dtu_tlzero_d) |
				                              op3_hi[3] & op3_lo[2] &   // wrpr
				                              (rd[4] & ~rd_10 | rd_0f | // gl=0x10
				                               ~rd[4] & ~rd[3] & ~rd[2] & fcl_dtu_tlzero_d) |
				                              op3_hi[3] & op3_lo[0] &  
				                              (rd_0f & ~(rs1_00 & dtu_inst_d[13]))  // sir
                                      ) |
			                  mem_inst & (~op3[5] & op3_lo[12] |
				                            op3[5] & (op3_lo[2] | op3_lo[6]) | // stqf, ldqf
				                            op3[5] & op3[3] & ~op3[2] |
				                            op3_hi[2] & (op3_lo[12] | 
						                                     op3_lo[14] | op3_lo[15]) |
				                            op3_hi[3] & (op3_lo[1] | op3_lo[5] |
						                                     op3_lo[15]) |    //  null
				                            ~op3[5] & op3_lo[3] & rd[0] | // ldd w/ odd rd
				                            op3[5] & op3_lo[1] & ~fcn0 |  // ldfsr
				                            op3[5] & op3_lo[13] & // prefetch
				                              illegal_prefetch |
				                            op3[5] & op3_lo[5] & ~fcn0 | // stfsr
				                            ~op3[5] & op3_lo[7] & rd[0])  | // std w/ odd rd
			                  inv_reg_access_d |
                        rsvchk_fail_d);
   
   dff_s #(1) illinste_ff(.din (ill_inst_d),
		                  .q   (ill_inst_e),
		                  .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_illinst_e = (ill_inst_e | 
//                               imask_hit_e |
                               hprivop_e);
   
				    
   //-------------
   // LSU Controls
   //-------------
   // prefetch
   assign prefetch    = op3_lo[13] & op3[5];

   assign impl_prefetch = ~rd[4] & ~rd[3] & ~rd[2] | // 0-3
                           rd[4] & ~rd[3];           // 10-17 (hex)
   assign noop_prefetch = rd_04 | rd[4] & rd[3];     // 4, 18-1f
      
   assign illegal_prefetch = ~rd[4] & rd[2] & (rd[1] | rd[0]) | // 5-7
                             ~rd[4] & rd[3];                    // 8-f
   
   assign prefetch_d = mem_inst & prefetch & impl_prefetch & 
                       fcl_dtu_inst_vld_d;
   assign pref_done_d = mem_inst & prefetch & noop_prefetch;

   assign dec_swl_ll_done_d = (pref_done_d | rdsr_done_d | rdpr_done_d |
                               save_retn_done_d);

   // alt space
   assign lstype_d[2] = mem_inst & op3[4] & fcl_dtu_inst_vld_d;
   // store
   assign lstype_d[1] = mem_inst & op3[2] & ~prefetch & fcl_dtu_inst_vld_d &
                        ~quad_ffuop_d;
   // load
   assign lstype_d[0] = mem_inst & ~prefetch & fcl_dtu_inst_vld_d &
	                      (~op3[2] | op3[3]) & (~op3_lo[14] | op3[5]) &
                        ~quad_ffuop_d;

   
   // only the stda instruction needs to be flagged
   assign dec_swl_std_inst_d = mem_inst & op3_hi[1] & op3_lo[7] &
	                             fcl_dtu_inst_vld_d;
   
   assign sext_d = op3[3] & ~op3[2]; // load sign extension
   assign ldstub_d = mem_inst & ~op3[5] & op3_lo[13] & fcl_dtu_inst_vld_d;
   assign casa_d = mem_inst & op3[5] & (op3_lo[12] | op3_lo[14]) & 
                                         fcl_dtu_inst_vld_d;
   assign swap_d = mem_inst & op3_lo[15] & fcl_dtu_inst_vld_d;

   // load inst for speculation
   // fp loads are not speculated on
   // ldd is not speculated on
   assign dec_swl_ld_inst_d = mem_inst & ~op3[2] & 
	                            ~op3[5] & ~op3_lo[3];

   // store, atomic or flush inst for stb flow control
   // TBD: no need to full decode this if timing is a problem
   assign dec_swl_st_inst_d = mem_inst & op3[2] |   // st, pref, cas, ldstb
                              arith_inst & op3_hi[3] & op3_lo[11];  // flsh
   
   // size(out) 00-b 01-h 10-w 11-x/q/d
   assign lssize_d[0] =  (op3[1] & ~op3_lo[15]) |   // stx,ld/sth,ld/stq, 
                                                    // ldx, ldd, std, ~swap
			                     op3[5] & (op3_lo[1] | op3_lo[5]) & rd[0]; // ldxfsr
   

   assign lssize_d[1] =  ~(op3[1]^op3[0])      |  // ~ld/st b,h
                          (op3[5] & op3_lo[2]) |  // ld/stq 
                          op3_lo[14]           |  // stx, casx
	                        op3_hi[2] & (op3_lo[1] | op3_lo[5]);  // ldst fsr

   assign ifu_ffu_ldst_size_d = ~(op3[1] & op3[0]); // ldf, stf
//   assign ifu_ffu_ldst_size_d[1] = op3[1] & op3[0];    // lddf, stdf
   

   assign ldst_fp_d   =  op3[5] & ~op3[3] & fcl_dtu_inst_vld_d & 
                         ~swl_dec_fpbusy_e;

   assign ldst_dbl_d  =  (~op3[3] & op3[1] & op3[0] | // ldd(f), std(f)
	                        op3[5] & (op3_lo[2] | op3_lo[6])) &   // ldq, stq
			                     fcl_dtu_inst_vld_d;

   // mem bar
   assign mb_mask_d = dtu_inst_d[1] |   // #storeload
	                    dtu_inst_d[5] |   // #memissue
  	                  dtu_inst_d[6];    // #sync
   
   assign mb_inst_d = arith_inst & op3_hi[2] & op3_lo[8] & 
	                    rs1_0f & rd_00 & fcl_dtu_inst_vld_d & 
	                    dtu_inst_d[13] & mb_mask_d;


   dff_s #(3) lstype_reg(.din (lstype_d),
		                 .clk (clk),
		                 .q   (lstype_e),
		                 .se  (se), .si(), .so());
   dff_s #(2) lssize_reg(.din (lssize_d),
		                 .clk (clk),
		                 .q   (ifu_lsu_ldst_size_e),
		                 .se  (se), .si(), .so());
   dff_s #(1) lsfp_reg(.din (ldst_fp_d),
		               .clk (clk),
		               .q   (ifu_lsu_ldst_fp_e),
		               .se  (se), .si(), .so());
   dff_s #(1) lsdbl_reg(.din (ldst_dbl_d),
		                .clk (clk),
		                .q   (ifu_lsu_ldst_dbl_e),
		                .se  (se), .si(), .so());

   dff_s #(1) sext_reg(.din(sext_d),
                     .clk(clk),
                     .q(ifu_lsu_sign_ext_e),
                     .se(se), .si(), .so());
   dff_s #(1) casa_reg(.din(casa_d),
                     .clk(clk),
                     .q(casa_e),
                     .se(se), .si(), .so());
   dff_s #(1) ldstub_reg(.din(ldstub_d),
                       .clk(clk),
                       .q(ifu_lsu_ldstub_e),
                       .se(se), .si(), .so());
   dff_s #(1) swap_reg(.din(swap_d),
                     .clk(clk),
                     .q(ifu_lsu_swap_e),
                     .se(se), .si(), .so());

   dff_s #(1) pfe_ff(.din (prefetch_d),
                   .q   (prefetch_e),
                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) mb_ff(.din (mb_inst_d),
		            .q   (mb_inst_e),
		            .clk (clk),
                .se(se), .si(), .so());

   assign ifu_lsu_casa_e = casa_e;
   assign ifu_exu_casa_d = casa_d;

//   assign ifu_lsu_ld_inst_e = lstype_e[0] & (~dtu_inst_anull_e) & 
//			                          ~ifu_ffu_quad_op_e & fcl_dtu_inst_vld_e;
//   assign ifu_lsu_st_inst_e = lstype_e[1] & (~dtu_inst_anull_e) & 
//			                          ~ifu_ffu_quad_op_e & fcl_dtu_inst_vld_e;

   assign ifu_lsu_ld_inst_e = lstype_e[0];
   assign ifu_lsu_st_inst_e = lstype_e[1];

   // temporary
//   assign ifu_lsu_alt_space_e = lstype_e[2] & ~dtu_inst_anull_e & 
//	                              fcl_dtu_inst_vld_e;

   assign ifu_lsu_alt_space_e = lstype_e[2];
   assign ifu_lsu_alt_space_d = mem_inst & op3[4] & fcl_dtu_inst_vld_d;
   assign ifu_tlu_alt_space_d = op3[4] & fcl_dtu_ely_inst_vld_d;
//   assign ifu_lsu_imm_asi_vld_d = op3[4] & ~dtu_inst_d[13];
   assign ifu_lsu_memref_d = mem_inst & fcl_dtu_ely_inst_vld_d;
   
   assign ifu_tlu_mb_inst_e = mb_inst_e & ~dtu_inst_anull_e & 
	                            fcl_dtu_inst_vld_e;

   assign ifu_lsu_pref_inst_e = fcl_dtu_inst_vld_e & prefetch_e &
                                ~dtu_inst_anull_e;

   //------------
   // IMASK
   //------------
   assign rs2_hit = (dtu_inst_d[4:0] == erb_dtu_imask[4:0]);
   assign opf_hit = (dtu_inst_d[12:5] == erb_dtu_imask[12:5]);
   assign ibit_hit = (dtu_inst_d[13] == erb_dtu_imask[13]);
   assign rs1_hit = (dtu_inst_d[18:14] == erb_dtu_imask[18:14]);
   assign op3_hit = (dtu_inst_d[24:19] == erb_dtu_imask[24:19]);
   assign rd_hit = (dtu_inst_d[29:25] == erb_dtu_imask[29:25]);
   assign op_hit = (dtu_inst_d[31:30] == erb_dtu_imask[31:30]);

   assign imask_hit = (rs2_hit  | ~erb_dtu_imask[32]) &
                      (opf_hit  | ~erb_dtu_imask[33]) &
                      (ibit_hit | ~erb_dtu_imask[34]) &
                      (rs1_hit  | ~erb_dtu_imask[35]) &
                      (op3_hit  | ~erb_dtu_imask[36]) &
                      (rd_hit   | ~erb_dtu_imask[37]) &
                      (op_hit   | ~erb_dtu_imask[38]) &
                      (|erb_dtu_imask[38:32]) & 
                      fcl_dtu_inst_vld_d;
   
   dff_s #(1) imsk_ff(.din (imask_hit),
		              .q   (imask_hit_e),
		              .clk (clk), .se(se), .si(), .so());
   assign dtu_fcl_imask_hit_e = imask_hit_e & swl_dec_ibe_e;
   

   //-------------
   // SPU Controls
   //-------------

//   assign scpy_inst_d = arith_inst & op3_hi[3] & op3_lo[7] & // use impdep 2
//	                ~dtu_inst_d[13] & dtu_inst_d[12];    // i=0 always
//   assign scmp_inst_d = arith_inst & op3_hi[3] & op3_lo[7] & 
//	                ~dtu_inst_d[13] & ~dtu_inst_d[12];
//
//   dff #(1) scpy_ff (.din (scpy_inst_d),
//		   .clk (clk),
//		   .q   (scpy_inst_e),
//		   .se  (se), .si(), .so());
//
//   assign ifu_spu_scpy_inst_e = scpy_inst_e & ~dtu_inst_anull_e & 
//	                        fcl_dtu_inst_vld_e;
//   
//   dff #(1) scmp_ff (.din (scmp_inst_d),
//		   .q   (scmp_inst_e),
//		   .clk (clk), .se  (se), .si(), .so());
//
//   assign ifu_spu_scmp_inst_e = scmp_inst_e & ~dtu_inst_anull_e & 
//	                        fcl_dtu_inst_vld_e;
//
//
   
endmodule // sparc_ifu_dec

// Local Variables:
// verilog-library-directories:("../rtl" ".")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_errctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_errctl
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module sparc_ifu_errctl(/*AUTOARG*/
   // Outputs
   erc_erd_pgsz_b0, erc_erd_pgsz_b1, ifu_lsu_asi_rd_unc, 
   ifu_lsu_ldxa_tid_w2, ifu_lsu_ldxa_data_vld_w2, 
   ifu_lsu_fwd_data_vld, ifu_lsu_error_inj, ifu_exu_ecc_mask, 
   ifu_exu_inj_irferr, ifu_ffu_inj_frferr, ifu_exu_nceen_e, 
   ifu_lsu_nceen, ifu_spu_nceen, erb_fcl_spu_uetrap, 
   erb_ifq_itlberr_s1, erb_ifq_ifeterr_d1, erb_dtu_ifeterr_d1, 
   erb_fcl_itlb_ce_d1, erb_fcl_ce_trapvec, erb_fcl_ue_trapvec, 
   erb_fcl_ifet_uevec_d1, erc_erd_errstat_asidata, 
   erc_erd_errinj_asidata, erc_erd_erren_asidata, 
   erc_erd_eadr0_sel_irf_l, erc_erd_eadr0_sel_itlb_l, 
   erc_erd_eadr0_sel_frf_l, erc_erd_eadr0_sel_lsu_l, 
   erc_erd_asiway_s1_l, erc_erd_eadr1_sel_pcd1_l, 
   erc_erd_eadr1_sel_l1pa_l, erc_erd_eadr1_sel_l2pa_l, 
   erc_erd_eadr1_sel_other_l, erc_erd_eadr2_sel_mx1_l, 
   erc_erd_eadr2_sel_wrt_l, erc_erd_eadr2_sel_mx0_l, 
   erc_erd_eadr2_sel_old_l, erc_erd_asi_thr_l, 
   erc_erd_asisrc_sel_icd_s_l, erc_erd_asisrc_sel_misc_s_l, 
   erc_erd_asisrc_sel_err_s_l, erc_erd_asisrc_sel_itlb_s_l, 
   erc_erd_errasi_sel_en_l, erc_erd_errasi_sel_stat_l, 
   erc_erd_errasi_sel_inj_l, erc_erd_errasi_sel_addr_l, 
   erc_erd_miscasi_sel_ict_l, erc_erd_miscasi_sel_imask_l, 
   erc_erd_miscasi_sel_other_l, erc_erd_ld_imask, erb_reset, so, 
   // Inputs
   rclk, se, si, arst_l, grst_l, erd_erc_tte_pgsz, icv_itlb_valid_f, 
   fcl_erb_ievld_s1, fcl_erb_tevld_s1, fcl_erb_immuevld_s1, 
   fcl_erb_inst_issue_d, fcl_erb_inst_vld_d1, ifu_tlu_inst_vld_w, 
   ifu_lsu_thrid_s, fcl_erb_asi_tid_f, ifq_fcl_asi_tid_bf, 
   fcl_erb_clear_iferr, fcl_erb_itlbrd_vld_s, fcl_erb_itlbrd_data_s, 
   erd_erc_tagpe_s1, erd_erc_nirpe_s1, erd_erc_fetpe_s1, 
   erd_erc_tlbt_pe_s1, erd_erc_tlbd_pe_s1, tlu_lsu_pstate_priv, tlu_hpstate_priv,
   lsu_ifu_dtlb_data_su, lsu_ifu_dtlb_data_ue, lsu_ifu_dtlb_tag_ue, 
   lsu_ifu_dcache_data_perror, lsu_ifu_dcache_tag_perror, 
   lsu_ifu_l2_unc_error, lsu_ifu_l2_corr_error, lsu_ifu_io_error, 
   lsu_ifu_error_tid, spu_ifu_unc_err_w1, spu_ifu_mamem_err_w1, 
   spu_ifu_corr_err_w2, spu_ifu_int_w2, spu_ifu_ttype_tid_w2, 
   lsu_ifu_inj_ack, ffu_ifu_ecc_ce_w2, ffu_ifu_ecc_ue_w2, 
   ffu_ifu_inj_ack, ffu_ifu_tid_w2, exu_ifu_ecc_ce_m, 
   exu_ifu_ecc_ue_m, exu_ifu_inj_ack, ifq_erb_ue_rep, ifq_erb_ce_rep, 
   ifq_erb_l2_ue, ifq_erb_io_ue, ifq_erb_ifet_ce, ifq_erb_l2err_tid, 
   ifq_erb_rdtag_f, ifq_erb_rdinst_f, ifq_erb_asi_erren_i2, 
   ifq_erb_asi_errstat_i2, ifq_erb_asi_errinj_i2, 
   ifq_erb_asi_erraddr_i2, ifq_erb_asi_imask_i2, ifq_erb_asiwr_i2, 
   ifq_fcl_asird_bf, ifq_erb_fwdrd_bf, ifq_erb_asidata_i2, 
   ifq_erb_asiway_f
   );

   input        rclk, 
                se, 
                si,
                arst_l,
                grst_l;

   input [2:0]  erd_erc_tte_pgsz;

   input [3:0]  icv_itlb_valid_f;

   input        fcl_erb_ievld_s1,
		            fcl_erb_tevld_s1,
		            fcl_erb_immuevld_s1;

   input        fcl_erb_inst_issue_d;
   input        fcl_erb_inst_vld_d1;
   
   input        ifu_tlu_inst_vld_w;

   input [1:0]  ifu_lsu_thrid_s,
		            fcl_erb_asi_tid_f,
		            ifq_fcl_asi_tid_bf;
   
   input [3:0]  fcl_erb_clear_iferr;

   input        fcl_erb_itlbrd_vld_s,
		            fcl_erb_itlbrd_data_s;	
   
   input [3:0]  erd_erc_tagpe_s1;
   input        erd_erc_nirpe_s1,
		            erd_erc_fetpe_s1;
   input [1:0]  erd_erc_tlbt_pe_s1,
		            erd_erc_tlbd_pe_s1;

   input [3:0]  tlu_lsu_pstate_priv;
   input [3:0]  tlu_hpstate_priv;   

   input        lsu_ifu_dtlb_data_su,
		            lsu_ifu_dtlb_data_ue,
		            lsu_ifu_dtlb_tag_ue,
		            lsu_ifu_dcache_data_perror,
		            lsu_ifu_dcache_tag_perror,
		            lsu_ifu_l2_unc_error,
		            lsu_ifu_l2_corr_error,
		            lsu_ifu_io_error;
   input [1:0]  lsu_ifu_error_tid;

   input        spu_ifu_unc_err_w1,  // 1 cycle earlier for timing reasons
                spu_ifu_mamem_err_w1,// 1 cycle earlier for timing reasons
                spu_ifu_corr_err_w2,
                spu_ifu_int_w2;
   
   input [1:0]  spu_ifu_ttype_tid_w2;

   input [3:0]  lsu_ifu_inj_ack;

   input        ffu_ifu_ecc_ce_w2;
   input        ffu_ifu_ecc_ue_w2;
   input        ffu_ifu_inj_ack;
   input [1:0]  ffu_ifu_tid_w2;
   
   input        exu_ifu_ecc_ce_m,
		            exu_ifu_ecc_ue_m;
   input        exu_ifu_inj_ack;
   
   input        ifq_erb_ue_rep;
   input        ifq_erb_ce_rep;
   input        ifq_erb_l2_ue;
   input        ifq_erb_io_ue;
   input        ifq_erb_ifet_ce;
   input [1:0]  ifq_erb_l2err_tid;

   input        ifq_erb_rdtag_f;
   input        ifq_erb_rdinst_f;
   input        ifq_erb_asi_erren_i2;
   input        ifq_erb_asi_errstat_i2;
   input        ifq_erb_asi_errinj_i2;
   input        ifq_erb_asi_erraddr_i2;
   input        ifq_erb_asi_imask_i2;
   input        ifq_erb_asiwr_i2;
   input        ifq_fcl_asird_bf;
   input        ifq_erb_fwdrd_bf;
   input [31:0] ifq_erb_asidata_i2;
   input [1:0]  ifq_erb_asiway_f;

   output       erc_erd_pgsz_b0;
   output       erc_erd_pgsz_b1;

   output       ifu_lsu_asi_rd_unc;
   output [1:0] ifu_lsu_ldxa_tid_w2;
   output       ifu_lsu_ldxa_data_vld_w2;
   output       ifu_lsu_fwd_data_vld;
   output [3:0] ifu_lsu_error_inj;

   output [7:0] ifu_exu_ecc_mask;
   output       ifu_exu_inj_irferr;
   output       ifu_ffu_inj_frferr;
   
   output       ifu_exu_nceen_e;
   output [3:0] ifu_lsu_nceen;
   output [3:0] ifu_spu_nceen;  //  copy going north

   output [3:0] erb_fcl_spu_uetrap;

   output       erb_ifq_itlberr_s1;
   output       erb_ifq_ifeterr_d1;
   output       erb_dtu_ifeterr_d1;
   output       erb_fcl_itlb_ce_d1;
   output [3:0] erb_fcl_ce_trapvec;
   output [3:0] erb_fcl_ue_trapvec;   
   output [3:0] erb_fcl_ifet_uevec_d1;

   output [22:0] erc_erd_errstat_asidata;
   output [31:0] erc_erd_errinj_asidata;
   output [1:0]  erc_erd_erren_asidata; 

   // mux selects
   output [3:0]  erc_erd_eadr0_sel_irf_l,
		             erc_erd_eadr0_sel_itlb_l,
		             erc_erd_eadr0_sel_frf_l,
		             erc_erd_eadr0_sel_lsu_l;

   output [3:0]  erc_erd_asiway_s1_l;
   
   output [3:0]  erc_erd_eadr1_sel_pcd1_l,
		             erc_erd_eadr1_sel_l1pa_l,
		             erc_erd_eadr1_sel_l2pa_l,
		             erc_erd_eadr1_sel_other_l;
   
   output [3:0]  erc_erd_eadr2_sel_mx1_l,
		             erc_erd_eadr2_sel_wrt_l,
		             erc_erd_eadr2_sel_mx0_l,
		             erc_erd_eadr2_sel_old_l;

   output [3:0]  erc_erd_asi_thr_l;

   output        erc_erd_asisrc_sel_icd_s_l,  
		             erc_erd_asisrc_sel_misc_s_l,
		             erc_erd_asisrc_sel_err_s_l,
		             erc_erd_asisrc_sel_itlb_s_l;

   output        erc_erd_errasi_sel_en_l,
		             erc_erd_errasi_sel_stat_l,
		             erc_erd_errasi_sel_inj_l,
		             erc_erd_errasi_sel_addr_l;

   output        erc_erd_miscasi_sel_ict_l,
		             erc_erd_miscasi_sel_imask_l,
		             erc_erd_miscasi_sel_other_l;

   output        erc_erd_ld_imask;
   output        erb_reset,
                 so;

   // Local Signals

   wire          spu_unc_err_w2,
                 spu_mamem_err_w2;
   
   wire          lsu_dtlb_data_su,        
		             lsu_dtlb_data_ue,        
		             lsu_dtlb_tag_ue,         
		             lsu_dcache_data_perror,  
		             lsu_dcache_tag_perror,   
		             lsu_l2_unc_error,        
		             lsu_l2_corr_error,       
		             lsu_io_error;            
   wire [1:0]    lsu_error_tid;           
   
   wire [3:0]    valid_s1;

   wire [1:0]    tid_d,
                 ffu_tid_w3,
                 l2ierr_tid,
                 spu_tid_w2,
                 asi_tid_w2,
		             asi_tid_s1;
   
   wire [3:0]    thr_e,
                 thr_d,
		             thr_d1,
		             thr_m,
		             thr_w,
                 ffu_thr_w3,
		             asi_thr_s,
                 asi_thr_w2,
		             asi_thr_i2,
		             thr_lsu_err,
                 thr_spu_err,
		             thr_l2ie;
   
   wire          itlb_feterr_s1,
		             tlb_feterr_d1,
                 itlb_errtr_s1_l,
                 itlb_errtr_d1_l;
   
   wire          tlb_fet_ce_d1,
		             tlb_fet_ue_d1;
   
   wire [3:0]    alltag_err_s1;
   
   wire          itlb_tagerr_s1,
		             itlb_dataerr_s1,
		             insterr_d1,
                 insterr_s1,
		             insterr_qual_d1,
		             ictagerr_s1,
		             ictagerr_d1,
		             ictagerr_qual_d1;

   wire          asi_daterr_d1,
		             asi_tagerr_d1,
		             asi_rd_err_d1;

   wire          asi_ttevld_s1,
		             asi_tdevld_s1;
   
   wire [3:0]    any_tlbasi_err;

   wire [3:0]    dmdu,
		             dmdu_nxt,
		             dmsu,
		             dmsu_nxt,
		             dmt,
		             dmt_nxt,
		             ddc,
		             ddc_nxt,
		             dtc,
		             dtc_nxt,
		             ldau,
		             ldau_nxt,
		             ncu,
		             ncu_nxt,
                 mau,
                 mau_nxt,
		             any_lsu_err,
		             any_lsu_ue,
		             any_lsu_ce,
                 any_spu_ce,
                 any_spu_ue,
		             imt,
		             imt_nxt,
		             frc,
		             frc_nxt,
		             irc,
		             irc_nxt,
		             fru,
		             fru_nxt,
		             iru,
		             iru_nxt,
		             any_rf_err,
		             any_rf_ce,
		             any_rf_ue,
		             any_irf_err,
		             any_frf_err,
		             idc,
		             idc_nxt,
		             itc,
		             itc_nxt,
		             imdu,
		             imdu_nxt,
		             any_err_vld,
		             any_ue_vld,
//		             any_ce_vld,
		             early_idc,
		             early_idc_nxt,
		             early_itc,
		             early_itc_nxt,
		             early_imdu,
		             early_imdu_nxt,
		             early_ldau,
		             early_ldau_nxt,
		             early_ncu,
		             early_ncu_nxt,
		             early_l2ce,
		             early_l2ce_nxt,
		             any_ifu_ce,
		             any_ifu_ue,
		             any_ifu_err,
		             any_iferr_vld;

   wire [3:0]    meu,
		             meu_nxt,
		             mec,
		             mec_nxt,
		             priv,
		             priv_nxt,
		             early_meu,
		             early_meu_nxt,
		             early_mec,
		             early_mec_nxt,
		             early_priv,
		             early_priv_nxt;

   wire [22:0]   err_stat0,
		             err_stat1,
		             err_stat2,
		             err_stat3;

   wire [3:0]    ifet_ce_vld,
                 ifet_ue_vld;

   wire [3:0]    l2if_unc_err,
		             l2if_corr_err;

   wire [3:0]    ce_trapvec,
		             ue_trapvec,
		             ifu_ce_trap;

   wire          wrt_errinj_i2;
   wire [7:0]    ecc_mask,
		             ecc_mask_nxt;

   wire [1:0]    errinj_ctl,
		             errinj_ctl_nxt;
   wire [5:0]    errinj_vec,
		             errinj_vec_nxt,
		             corr_errinj_vec;
   
//   wire [3:0]    icache_pa_err_d1;

   wire          irf_ce_w,
                 irf_ce_unq,
		             irf_ue_w,
                 irf_ue_unq;

   wire [3:0]    sel_lsu_err,
		             sel_ifuspu_err,
		             sel_rftlb_err;

   wire          clr_err_qual_e,
                 clr_elyff_e,
                 clr_elyff_m,
                 clr_elyff_w;
   
   wire [3:0]    early_err_vec_e,
		             clear_ely_reg_w,
		             mov_ely_reg_w;

   wire [3:0]    clear_iferr_d1;

   wire [1:0]    asi_way_s1;
   wire [3:0]    dec_asiway_s1;

   wire [3:0]    asi_wrt_err_stat,
		             asi_wrt_err_en,
//		             asi_wrt_err_inj,
		             asi_wrt_err_addr;
   
   wire          dmdu_wrt_data,
		             dmsu_wrt_data,
		             imdu_wrt_data,
		             idc_wrt_data,
		             itc_wrt_data,
		             ddc_wrt_data,
		             dtc_wrt_data,
		             imt_wrt_data,
		             dmt_wrt_data,
		             ldau_wrt_data,
		             ncu_wrt_data,
                 mau_wrt_data,
		             fru_wrt_data,
		             frc_wrt_data,
		             iru_wrt_data,
		             irc_wrt_data,
		             meu_wrt_data,
		             mec_wrt_data,
		             priv_wrt_data;

   wire          nceen_wrt_data,
		             ceen_wrt_data;

   wire [3:0]    ceen,
		             ceen_nxt,
		             nceen,
		             nceen_nxt;

   wire          nceen_d;

   wire          rdtag_s,
		             rdinst_s,
		             asi_erren_f,
		             asi_errstat_f,
		             asi_errinj_f,
		             asi_erraddr_f,
		             asi_imask_f,
		             asi_erren_s,
		             asi_errstat_s,
		             asi_errinj_s,
		             asi_erraddr_s,
		             asi_imask_s;

   wire          asird_f,
		             asird_s;
   wire          fwdrd_f,
                 fwdrd_s,
                 asifwd_rd_s,
                 rdinst_f,
                 fwdrd_d;
   
   wire          ldxa_data_vld_s,
                 ldxa_data_vld_d;

   wire          err_asi_s;
   wire          erb_reset_l;

   wire          ffu_ce_w3;
   wire          ffu_ue_w3;   

   wire [3:0] 	 any_lsu_ue_priv_state;
   wire [3:0] 	 any_priv_state;
   
   wire          clk;
   
   
//   
// Code Begins Here
//
   assign        clk = rclk;
   
   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (erb_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign       erb_reset = ~erb_reset_l;


   
   // need to encode page size before sending it back
   assign erc_erd_pgsz_b0 = (erd_erc_tte_pgsz[2] | 
	                            erd_erc_tte_pgsz[1] | 
                              erd_erc_tte_pgsz[0]);

   assign erc_erd_pgsz_b1 = (~erd_erc_tte_pgsz[2] & 
	                           erd_erc_tte_pgsz[1]);
   

   // Don't need this with SPARC_HPV_EN
   // default to tte_lock_d1 = 0
   // 05/30/03: tlb correctible errors disabled.
   // so treat as if lock = 1 and force ue.
//   dff #(1) lk_ff(.din (erd_erc_tte_lock_s1),
//		              .q   (tte_lock_d1),
//		              .clk (clk), .se(se), .si(), .so());

//-----------------------
// Basic pipeline signals
//-----------------------
   // thr_s1 also contains asi tid
   dff_s #(2) tidd_reg(.din (ifu_lsu_thrid_s),
		                 .q   (tid_d),
		                 .clk (clk), .se(se), .si(), .so());

   assign thr_d[0] = ~tid_d[1] & ~tid_d[0];
   assign thr_d[1] = ~tid_d[1] &  tid_d[0];
   assign thr_d[2] =  tid_d[1] & ~tid_d[0];
   assign thr_d[3] =  tid_d[1] &  tid_d[0];

   dff_s #(4) thre_reg(.din (thr_d),
		                 .q   (thr_e),
		                 .clk (clk), .se(se), .si(), .so());
   assign thr_d1 = thr_e;

   dff_s #(4) thrm_reg(.din (thr_e),
		                 .q   (thr_m),
		                 .clk (clk),  .se(se), .si(), .so());
   dff_s #(4) thrw_reg(.din (thr_m),
		                 .q   (thr_w),
		                 .clk (clk),  .se(se), .si(), .so());


//-----------------------------
// lsu flops (added for timing)
//-----------------------------
   // all the lsu signals go to the final mux in the errdp, to help
   // with timing.  This is no longer necessary, in fact it is no
   // longer desired, since we have added the flop below to stage all
   // the lsu signals.  However, the design is not changed, to save
   // the extra effort in physical composition to rip up the errdp.
   dff_s #(10) lspipe_reg(.din ({lsu_ifu_dtlb_data_su,        
                               lsu_ifu_dtlb_data_ue,        
                               lsu_ifu_dtlb_tag_ue,         
                               lsu_ifu_dcache_data_perror,  
                               lsu_ifu_dcache_tag_perror,   
                               lsu_ifu_l2_unc_error,        
                               lsu_ifu_l2_corr_error,       
                               lsu_ifu_io_error,            
                               lsu_ifu_error_tid[1:0]}),
                        .q   ({lsu_dtlb_data_su,        
                               lsu_dtlb_data_ue,        
                               lsu_dtlb_tag_ue,         
                               lsu_dcache_data_perror,  
                               lsu_dcache_tag_perror,   
                               lsu_l2_unc_error,        
                               lsu_l2_corr_error,       
                               lsu_io_error,            
                               lsu_error_tid[1:0]}),
                        .clk (clk), .se(se), .si(), .so());

   assign any_priv_state = tlu_lsu_pstate_priv | tlu_hpstate_priv;
   
   //Bug 6821: added so that lsu ue's errors pickup the delayed priv level
   dff_s #(4) lsu_priv_reg(.din (any_priv_state),
                        .q   (any_lsu_ue_priv_state),
                        .clk (clk), .se(se), .si(), .so());
   
   // thread from lsu
   assign thr_lsu_err[0] = ~lsu_error_tid[1] & ~lsu_error_tid[0];
   assign thr_lsu_err[1] = ~lsu_error_tid[1] &  lsu_error_tid[0];
   assign thr_lsu_err[2] =  lsu_error_tid[1] & ~lsu_error_tid[0];
   assign thr_lsu_err[3] =  lsu_error_tid[1] &  lsu_error_tid[0];

   // thread from spu
   // From Farnad: tid is ready several cycles before everything else.
   // In the ifu, I will assume 1 cycle before
   dff_s #(2) sptid_reg(.din (spu_ifu_ttype_tid_w2),
                      .q   (spu_tid_w2),
                      .clk (clk), .se(se), .so(), .si());
   
   dff_s #(2) spe1_reg(.din ({spu_ifu_unc_err_w1, 
                            spu_ifu_mamem_err_w1}),
                      .q   ({spu_unc_err_w2,
                             spu_mamem_err_w2}),
                      .clk (clk), .se(se), .so(), .si());

   assign thr_spu_err[0] = ~spu_tid_w2[1] & ~spu_tid_w2[0];
   assign thr_spu_err[1] = ~spu_tid_w2[1] &  spu_tid_w2[0];
   assign thr_spu_err[2] =  spu_tid_w2[1] & ~spu_tid_w2[0];
   assign thr_spu_err[3] =  spu_tid_w2[1] &  spu_tid_w2[0];

   // thread from ifq
   dff_s #(2) ifqthr_reg(.din (ifq_erb_l2err_tid),
                       .q   (l2ierr_tid),
                       .clk (clk), .se(se), .so(), .si());
   
   assign thr_l2ie[0] = ~l2ierr_tid[1] & ~l2ierr_tid[0];
   assign thr_l2ie[1] = ~l2ierr_tid[1] &  l2ierr_tid[0];
   assign thr_l2ie[2] =  l2ierr_tid[1] & ~l2ierr_tid[0];
   assign thr_l2ie[3] =  l2ierr_tid[1] &  l2ierr_tid[0];
   
   
//---------------------------------------
// Error Detection -- icache errors
//---------------------------------------
   // itlb inst fetch errors
   assign itlb_feterr_s1 = (erd_erc_tlbd_pe_s1[0] ^ erd_erc_tlbd_pe_s1[1]) & 
			                       fcl_erb_immuevld_s1;
   assign erb_ifq_itlberr_s1 = itlb_feterr_s1 & nceen_d;
   dff_s #(1) itfete_ff(.din (itlb_feterr_s1),
		                  .q   (tlb_feterr_d1),
		                  .clk (clk), .se(se), .si(), .so());

   assign itlb_errtr_s1_l = ~erb_ifq_itlberr_s1;
   dff_s #(1) itume_ff(.din (itlb_errtr_s1_l),
		                 .q   (itlb_errtr_d1_l),
		                 .clk (clk), .se(se), .si(), .so());
   
//   assign tlb_fet_ce_d1 = tlb_feterr_d1 & ~tte_lock_d1;
//   assign tlb_fet_ue_d1 = tlb_feterr_d1 & tte_lock_d1;
   assign tlb_fet_ce_d1 = 1'b0;
   assign tlb_fet_ue_d1 = tlb_feterr_d1;
   

   // instruction errors
//   assign insterr_s1 = (erd_erc_nirpe_s1 | erd_erc_fetpe_s1) & 
//			                   fcl_erb_ievld_s1;
//   dff #(1)  inserr_ff(.din (insterr_s1),
//		                   .q   (insterr_d1),
//		                   .clk (clk), .se(se), .si(), .so());

   assign insterr_s1 = (erd_erc_fetpe_s1 | erd_erc_nirpe_s1) &
                         fcl_erb_ievld_s1;
   
   dff_s #(1)  feterr_ff(.din (insterr_s1),
		                   .q   (insterr_d1),
		                   .clk (clk), .se(se), .si(), .so());
//   dff #(1)  nirerr_ff(.din (erd_erc_nirpe_s1),
//		                   .q   (nirpe_d1),
//		                   .clk (clk), .se(se), .si(), .so());
//   dff #(1)  ievld1_ff(.din (fcl_erb_ievld_s1),
//		                   .q   (ievld_d1),
//		                   .clk (clk), .se(se), .si(), .so());

   assign insterr_qual_d1 = insterr_d1 & ~tlb_feterr_d1;

   // tag errors
   dff_s #(4)  vld_reg(.din (icv_itlb_valid_f),
		                 .q   (valid_s1),
		                 .clk (clk), .se(se), .si(), .so());
   assign alltag_err_s1 = erd_erc_tagpe_s1 & valid_s1;

   assign ictagerr_s1 = (|alltag_err_s1[3:0]) & fcl_erb_tevld_s1;
   dff_s #(1)  itagerr_ff(.din (ictagerr_s1),
		                    .q   (ictagerr_d1),
		                    .clk (clk), .se(se), .si(), .so());

   assign  ictagerr_qual_d1 = ictagerr_d1 & ~insterr_d1 & 
	                            ~tlb_feterr_d1;

   // Corrective action for IFU errors
   // force an imiss if there is a inst/tag parity error
   assign  erb_ifq_ifeterr_d1 = (ictagerr_d1 | insterr_d1) & itlb_errtr_d1_l;

   // moved qualification with inst_vld_d1 to the dtu.
   assign  erb_dtu_ifeterr_d1 = erb_ifq_ifeterr_d1;
   //assign  erb_dtu_ifeterr_d1 = erb_ifq_ifeterr_d1 & fcl_erb_inst_vld_d1;
//   assign  icache_pa_err_d1 = {4{ictagerr_d1 | insterr_d1}} & thr_d1;

   // force a tlbmiss if there is a correctible tlb data parity error
   assign  erb_fcl_itlb_ce_d1 = tlb_fet_ce_d1;

   // take a precise trap if there is an uncorrectible error
   assign  erb_fcl_ifet_uevec_d1 = ({4{tlb_fet_ue_d1 & fcl_erb_inst_vld_d1}} & 
				                            thr_d1  | 
				                            {4{ifq_erb_l2_ue | ifq_erb_io_ue}} & 
				                            thr_l2ie) & nceen;

   // errors in ifetch to l2 or iob
   assign  l2if_unc_err = {4{ifq_erb_l2_ue | ifq_erb_io_ue}} & thr_l2ie;
   assign  l2if_corr_err = {4{ifq_erb_ifet_ce}} & thr_l2ie;
   
   
//-------------------------------------
// Error Detection -- itlb asi errors
//-------------------------------------   
   assign  itlb_tagerr_s1 = (erd_erc_tlbt_pe_s1[0] ^ erd_erc_tlbt_pe_s1[1]) & 
			                        asi_ttevld_s1;
   assign  itlb_dataerr_s1 = (erd_erc_tlbd_pe_s1[0] ^ erd_erc_tlbd_pe_s1[1]) & 
			                         asi_tdevld_s1;

   dff_s #(1) itdate_ff(.din (itlb_dataerr_s1),
		                  .q   (asi_daterr_d1),
		                  .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ittage_ff(.din (itlb_tagerr_s1),
		                  .q   (asi_tagerr_d1),
		                  .clk (clk), .se(se), .si(), .so());

   assign  asi_rd_err_d1 = asi_daterr_d1 | asi_tagerr_d1;
   assign  ifu_lsu_asi_rd_unc = asi_rd_err_d1;
   
   assign  any_tlbasi_err = {4{asi_rd_err_d1}} & asi_thr_w2;


//------------------------------
// RF errors
//------------------------------   
   dff_s #(1) irfu_ff(.din (exu_ifu_ecc_ue_m),
		                .q   (irf_ue_unq),
		                .clk (clk), .se (se), .si(), .so());
   dff_s #(1) irfc_ff(.din (exu_ifu_ecc_ce_m),
		                .q   (irf_ce_unq),
		                .clk (clk), .se (se), .si(), .so());
   assign  irf_ce_w = irf_ce_unq & ifu_tlu_inst_vld_w;
   assign  irf_ue_w = irf_ue_unq & ifu_tlu_inst_vld_w;
   
//------------------
// Error Logging
//------------------
   // List of all logged errors
   // itlbt  u
   // itlbd  u/c
   // ict  c
   // icd  c
   // irf  c/u
   // frf  c/u
   // dtlb d/t u
   // dct  c
   // dcd  c
   // mau  u
   // l2-d u
   // l2-i u
   // dram u -- not any more
   // io   u
   //
   // Errors not logged but causing a trap
   // l2-d c
   // l2-i c
   // l2-s c
   // 

   // latest errors have highest priority
   // lsu is latest and sometimes asynchronous
   // spu has low priority
   // irf/frf are always "current"
   // ifu errors are speculative ("early")
   // All lsu errors are prioritised at the source
   assign  dmdu_nxt =  {4{lsu_dtlb_data_ue & ~erb_reset}} & thr_lsu_err &
		                    ~any_ue_vld |
	                      dmdu & ~({4{dmdu_wrt_data}} & asi_wrt_err_stat);
   // 6310
   assign  dmsu_nxt =  {4{lsu_dtlb_data_su & ~erb_reset}} & thr_lsu_err &
		                   ~any_ue_vld |
	                     dmsu & ~({4{dmsu_wrt_data}} & asi_wrt_err_stat);
   assign  dmt_nxt =  {4{lsu_dtlb_tag_ue & ~erb_reset}} & thr_lsu_err &
		                  ~any_ue_vld |
	                    dmt & ~({4{dmt_wrt_data}} & asi_wrt_err_stat);
   assign  ddc_nxt =  {4{lsu_dcache_data_perror & ~erb_reset}} & thr_lsu_err &
		                  ~any_err_vld |
	                    ddc & ~({4{ddc_wrt_data}} & asi_wrt_err_stat);
   assign  dtc_nxt =  {4{lsu_dcache_tag_perror & ~erb_reset}} & thr_lsu_err &
		                  ~any_err_vld |
	                    dtc & ~({4{dtc_wrt_data}} & asi_wrt_err_stat);

   assign  ldau_nxt = (mov_ely_reg_w & early_ldau | 
	                     {4{lsu_l2_unc_error}} & thr_lsu_err |
	                     {4{spu_unc_err_w2}} & thr_spu_err) &
		                    ~any_ue_vld |
	                     ldau & ~({4{ldau_wrt_data}} & asi_wrt_err_stat);

   assign  ncu_nxt = (mov_ely_reg_w & early_ncu |  
	                    {4{lsu_io_error}} & thr_lsu_err) &
		                   ~any_ue_vld |
 	                   ncu & ~({4{ncu_wrt_data}} & asi_wrt_err_stat);

   assign  any_lsu_ue = thr_lsu_err & {4{lsu_dtlb_data_ue |
                                         lsu_dtlb_data_su |
					                               lsu_dtlb_tag_ue |
					                               lsu_l2_unc_error |
					                               lsu_io_error}};

   assign  any_lsu_ce = thr_lsu_err & 
	                      {4{(lsu_dcache_data_perror |
			                      lsu_dcache_tag_perror |
			                      lsu_l2_corr_error) &
                           ~lsu_dtlb_data_ue & 
                           ~lsu_dtlb_data_su}};

   assign  any_lsu_err = (any_lsu_ue |
			                    thr_lsu_err & {4{lsu_dcache_data_perror |
					                                 lsu_dcache_tag_perror}});

   // MAmem parity error
   assign mau_nxt = {4{spu_mamem_err_w2}} & thr_spu_err & 
                    ~any_ue_vld |
                    mau &  ~({4{mau_wrt_data}} & asi_wrt_err_stat);

   assign any_spu_ce = {4{spu_ifu_corr_err_w2 & ~spu_unc_err_w2}} & thr_spu_err;
   assign any_spu_ue = {4{spu_unc_err_w2 |
                          spu_mamem_err_w2}} & thr_spu_err;
				 
   // tlb asi read error
   assign imt_nxt =  {4{asi_tagerr_d1 & ~erb_reset}} & asi_thr_w2 &
		                 ~any_ue_vld |
	                   imt & ~({4{imt_wrt_data}} & asi_wrt_err_stat);

   dff_s #(2) ffu_err_reg(.din ({ffu_ifu_ecc_ce_w2,
                               ffu_ifu_ecc_ue_w2}),
                        .q   ({ffu_ce_w3,
                               ffu_ue_w3}),
                        .clk (clk), .se(se), .si(), .so());

   dff_s #(2) fptid_reg(.din (ffu_ifu_tid_w2[1:0]),
		                  .q   (ffu_tid_w3[1:0]),
		                  .clk (clk),  .se(se), .si(), .so());

   assign ffu_thr_w3[0] = ~ffu_tid_w3[1] & ~ffu_tid_w3[0];
   assign ffu_thr_w3[1] = ~ffu_tid_w3[1] &  ffu_tid_w3[0];
   assign ffu_thr_w3[2] =  ffu_tid_w3[1] & ~ffu_tid_w3[0];
   assign ffu_thr_w3[3] =  ffu_tid_w3[1] &  ffu_tid_w3[0];
   
   
   // regfile error
   //Bug6420: log frc and irc bits as well when fru and iru are detected simulatneously
   assign frc_nxt =  {4{ffu_ce_w3 & ~erb_reset}} &    
	              ffu_thr_w3 & ~any_err_vld & ~any_lsu_err |
	              frc & ~({4{frc_wrt_data}} & asi_wrt_err_stat);
   
   assign fru_nxt =  {4{ffu_ue_w3 & ~erb_reset}} & ffu_thr_w3 &
		            ~any_ue_vld & ~any_lsu_ue |
	              fru & ~({4{fru_wrt_data}} & asi_wrt_err_stat);

   //Bug6420
   assign irc_nxt =  {4{irf_ce_w & ~erb_reset}} & thr_w &   
		                ~any_err_vld & ~any_lsu_err |
	                  irc & ~({4{irc_wrt_data}} & asi_wrt_err_stat);
   
   assign iru_nxt =  {4{irf_ue_w & ~erb_reset}} & thr_w &
		               ~any_ue_vld & ~any_lsu_ue |
	                 iru & ~({4{iru_wrt_data}} & asi_wrt_err_stat);

   assign any_irf_err = thr_w & {4{irf_ce_w | irf_ue_w}};
   assign any_frf_err = ffu_thr_w3 & {4{ffu_ce_w3 | ffu_ue_w3}};

   //Bug6420
   assign any_rf_ce = thr_w & {4{irf_ce_w}} |
	                    ffu_thr_w3 & {4{ffu_ce_w3}};
   assign any_rf_ue = thr_w & {4{irf_ue_w}} |
	                    ffu_thr_w3 & {4{ffu_ue_w3}};
   assign any_rf_err = any_irf_err | any_frf_err;


   // ifu errors
   assign idc_nxt =  mov_ely_reg_w & ~any_err_vld & early_idc |
	              idc & ~({4{idc_wrt_data}} & asi_wrt_err_stat);
   
   assign itc_nxt =  mov_ely_reg_w & ~any_err_vld & early_itc | 
	             itc & ~({4{itc_wrt_data}} & asi_wrt_err_stat);

   // bug 6310
   assign imdu_nxt =  (mov_ely_reg_w & early_imdu |
		                   {4{asi_daterr_d1 & ~erb_reset}} & asi_thr_w2) &
                        ~any_ue_vld |
	                    imdu & ~({4{imdu_wrt_data}} & asi_wrt_err_stat);
   
//   assign imdc_nxt =  mov_ely_reg_w & ~any_err_vld & early_imdc |
//	                    imdc & ~({4{imdc_wrt_data}} & asi_wrt_err_stat);
   
   dff_s #(64) errvec_reg(.din ({imt_nxt, imdu_nxt, idc_nxt, itc_nxt, 
			                         iru_nxt, irc_nxt, fru_nxt, frc_nxt,
  	                           dmt_nxt, dmdu_nxt, dmsu_nxt, ddc_nxt, dtc_nxt, 
			                         ldau_nxt, ncu_nxt, mau_nxt}),
		                    .q   ({imt, imdu, idc, itc, 
			                         iru, irc, fru, frc,
  	                           dmt, dmdu, dmsu, ddc, dtc, 
			                         ldau, ncu, mau}),
		                    .clk (clk),
		                    .se  (se), .si(), .so());
		      
   assign any_err_vld = imt | imdu | idc | itc | iru | irc | fru | frc |
  	                    dmt | dmdu | dmsu | ddc | dtc | ldau | ncu | mau;

   assign any_ue_vld =  imt | imdu | iru | fru |
  	                    dmt | dmdu | dmsu | ldau | ncu | mau;
   
//   assign any_ce_vld =  imdc | idc | itc | irc | frc |
//  	                dmdc | ddc | dtc;

   // IFU errors
   assign any_ifu_ue = {4{(ifq_erb_l2_ue | ifq_erb_io_ue) & ~erb_reset}} & 
	                     thr_l2ie |
	                     {4{tlb_fet_ue_d1 & ~erb_reset}} & thr_d1;
   
   assign any_ifu_ce = {4{ifq_erb_ifet_ce & ~erb_reset}} & thr_l2ie |
	                     {4{(tlb_fet_ce_d1 | insterr_qual_d1 | 
			                     ictagerr_qual_d1) & ~erb_reset}} & 
                       thr_d1;

   assign any_ifu_err = any_ifu_ce | any_ifu_ue;
   

   assign ifet_ce_vld = early_idc | early_itc | early_l2ce;
   assign ifet_ue_vld = early_imdu | early_ldau | early_ncu;

   // l2ce's are not logged in sparc, so leave them out
   assign any_iferr_vld = ifet_ue_vld | early_idc | early_itc;   

   // Early errors
   assign early_idc_nxt = {4{insterr_qual_d1}} & thr_d1 &
	                  ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                  early_idc & ~clear_iferr_d1 &
	                  ~mov_ely_reg_w;
   
   assign early_itc_nxt =  {4{ictagerr_qual_d1}} & thr_d1 &
		                ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                  early_itc & ~clear_iferr_d1 &
	                  ~mov_ely_reg_w;	  

   assign early_imdu_nxt =  {4{tlb_fet_ue_d1}} & thr_d1 &
		                 ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_imdu & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
	  
//   assign early_imdc_nxt =  {4{tlb_fet_ce_d1}} & thr_d1 &
//		                 ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
//	                   early_imdc & ~clear_iferr_d1 &
//	                   ~mov_ely_reg_w;

   assign early_ldau_nxt = {4{ifq_erb_l2_ue & ~erb_reset}} & thr_l2ie & 
	                   ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_ldau & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
   
   assign early_ncu_nxt = {4{ifq_erb_io_ue & ~erb_reset}} & thr_l2ie & 
	                   ~ifet_ue_vld & ~any_rf_ue & ~any_lsu_ue |
	                   early_ncu & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;

   assign early_l2ce_nxt =  {4{ifq_erb_ifet_ce}} & thr_l2ie &
		                 ~any_iferr_vld & ~any_rf_err & ~any_lsu_err |
	                   early_l2ce & ~clear_iferr_d1 &
	                   ~mov_ely_reg_w;
   
   dffr_s #(24) elyerr_reg(.din ({early_idc_nxt, 
			                          early_itc_nxt, 
			                          early_imdu_nxt,
			                          early_ldau_nxt,
			                          early_ncu_nxt,
			                          early_l2ce_nxt}),
		                     .q   ({early_idc,
			                          early_itc,
			                          early_imdu,
			                          early_ldau,
			                          early_ncu,
			                          early_l2ce}),
		                     .clk (clk),
		                     .rst (erb_reset),
		                     .se  (se), .si(), .so());

   // Multipl errors
   assign meu_nxt = any_ue_vld & (any_lsu_ue | any_rf_ue | any_tlbasi_err |
                                  any_spu_ue |
		                              mov_ely_reg_w & ifet_ue_vld) |
// known bug - wontfix                            
//                                    mov_ely_reg_w & early_meu |
                    meu & ~({4{meu_wrt_data}} & asi_wrt_err_stat);

   assign mec_nxt = any_err_vld & (any_lsu_ce | any_rf_ce |
		                               mov_ely_reg_w & ifet_ce_vld) |
// known bug - wontfix                     
//                     mov_ely_reg_w & early_mec |
	                  mec & ~({4{mec_wrt_data}} & asi_wrt_err_stat);

   //Bug6821
   assign priv_nxt = 	  ~any_err_vld & (any_lsu_ue_priv_state & any_lsu_ue | 
					  any_priv_state & (any_lsu_ce | any_rf_err | any_tlbasi_err) |
					  mov_ely_reg_w & early_priv) |
			  priv & ~({4{priv_wrt_data}} & asi_wrt_err_stat);
   
   dffr_s #(12) me_reg(.din ({meu_nxt, 
			                      mec_nxt, 
			                      priv_nxt}),
		                 .q   ({meu,
			                      mec,
			                      priv}),
		                 .clk (clk),
		                 .rst (erb_reset),
		                 .se  (se), .si(), .so());

   // Early multiple errors
   assign early_meu_nxt = any_ifu_ue & ifet_ue_vld | 
	                  early_meu & ~clear_iferr_d1 & ~mov_ely_reg_w;

   assign early_mec_nxt = any_ifu_ce & any_iferr_vld |
	                  early_mec & ~clear_iferr_d1 & ~mov_ely_reg_w;

   // bug 6155 & 6821
   assign early_priv_nxt = any_priv_state & ~any_iferr_vld & ~any_rf_err & ~any_lsu_err & any_ifu_err |
	                   early_priv & ~clear_iferr_d1 & ~mov_ely_reg_w;
   
   dffr_s #(12) elyme_reg(.din ({early_meu_nxt, 
			                         early_mec_nxt, 
			                         early_priv_nxt}),
		                    .q   ({early_meu,
			                         early_mec,
			                         early_priv}),
		                    .clk (clk),
		                    .rst (erb_reset),
		                    .se  (se), .si(), .so());

   // pipeline progress
   dff_s #(1) clre_ff(.din (fcl_erb_inst_issue_d),
                    .q   (clr_elyff_e),
                    .clk (clk), .se(se), .si(), .so());
   assign early_err_vec_e = (any_iferr_vld | early_l2ce) & thr_e;
   assign clr_err_qual_e = (|early_err_vec_e[3:0]) & clr_elyff_e;
   
   dff_s #(1) clrm_ff(.din (clr_err_qual_e),
                    .q   (clr_elyff_m),
                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) clrw_ff(.din (clr_elyff_m),
                    .q   (clr_elyff_w),
                    .clk (clk), .se(se), .si(), .so());

   // fix for 6142 and 6159
   // delay err reg clear by one cycle to prevent clearing your own errors
   dff_s #(4) clree_reg(.din (fcl_erb_clear_iferr),
                      .q   (clear_iferr_d1),
                      .clk (clk), .se(se), .si(), .so());
   

   assign clear_ely_reg_w = {4{clr_elyff_w}} & thr_w & 
	                          (any_iferr_vld | early_l2ce);  // why again?
   assign mov_ely_reg_w = clear_ely_reg_w & 
                          {4{ifu_tlu_inst_vld_w & ~erb_reset}};


   // asi error status output
   assign err_stat0 = {meu[0], mec[0], priv[0],
		                   3'b100,                    // rw, enc, ma
		                   imdu[0], imt[0], 
		                   dmdu[0], dmt[0],
		                   idc[0], itc[0], ddc[0], dtc[0],
		                   irc[0], iru[0], frc[0], fru[0],
		                   ldau[0], ncu[0],
                       dmsu[0], 1'b0, mau[0]};
   
   assign err_stat1 = {meu[1], mec[1], priv[1],
		                   3'b100,
		                   imdu[1], imt[1], 
		                   dmdu[1], dmt[1],
		                   idc[1], itc[1], ddc[1], dtc[1],
		                   irc[1], iru[1], frc[1], fru[1],
		                   ldau[1], ncu[1],
                       dmsu[1], 1'b0, mau[1]};
   
   assign err_stat2 = {meu[2], mec[2], priv[2],
		                   3'b100,
		                   imdu[2], imt[2], 
		                   dmdu[2], dmt[2],
		                   idc[2], itc[2], ddc[2], dtc[2],
		                   irc[2], iru[2], frc[2], fru[2],
		                   ldau[2], ncu[2],
                       dmsu[2], 1'b0, mau[2]};
   
   assign err_stat3 = {meu[3], mec[3], priv[3],
		                   3'b100,
		                   imdu[3], imt[3], 
		                   dmdu[3], dmt[3],
		                   idc[3], itc[3], ddc[3], dtc[3],
		                   irc[3], iru[3], frc[3], fru[3],
		                   ldau[3], ncu[3],
                       dmsu[3], 1'b0, mau[3]};

   mux4ds #(23) err_stat_asi(.dout (erc_erd_errstat_asidata),
			                       .in0  (err_stat0),
			                       .in1  (err_stat1),
			                       .in2  (err_stat2),
			                       .in3  (err_stat3),
			                       .sel0 (asi_thr_s[0]),
			                       .sel1 (asi_thr_s[1]),
			                       .sel2 (asi_thr_s[2]),
			                       .sel3 (asi_thr_s[3]));

//----------------------------------
// Error Address Selection   
//----------------------------------

   // TBD: Uncorrectible errors have to overwrite correctible errors
   // mux 0
   // FRF errors are mutex with everything else
   // ITLB asi errors are mutex with everything else
   // ASI writes are mutex with everything else
   // only one of these errors could occur at a given time
   assign  erc_erd_eadr0_sel_lsu_l = ~(sel_lsu_err);

   assign  erc_erd_eadr0_sel_irf_l =  ~(~sel_lsu_err & any_irf_err);

   assign  erc_erd_eadr0_sel_itlb_l = ~(~sel_lsu_err & ~any_irf_err & 
					                              any_tlbasi_err);

   assign  erc_erd_eadr0_sel_frf_l = ~(~sel_lsu_err & ~any_irf_err & 
				                               ~any_tlbasi_err);

   // mux 1
   // l1 pa and tlb feterr can be simultaneous
   // TBD: need to reorder and make spu lower priority?
   assign  erc_erd_eadr1_sel_other_l = ~(any_spu_ue);
   
   assign  erc_erd_eadr1_sel_l2pa_l = ~(~any_spu_ue & 
                                        (l2if_unc_err | l2if_corr_err));

   assign  erc_erd_eadr1_sel_pcd1_l = ~(~l2if_unc_err & ~l2if_corr_err & 
					                              ~any_spu_ue & 
                                        thr_d1 & {4{tlb_feterr_d1}});

   assign  erc_erd_eadr1_sel_l1pa_l = ~(~l2if_unc_err & ~l2if_corr_err & 
					                              ({4{~tlb_feterr_d1}} | ~thr_d1) & 
                                        ~any_spu_ue);

//   assign  erc_erd_eadr1_sel_other_l = ~(~l2if_unc_err & ~l2if_corr_err & 
//					                           {4{~tlb_feterr_d1}} & ~icache_pa_err_d1);


   // mux2
   assign sel_lsu_err = ~any_err_vld & any_lsu_err |
	                      ~any_ue_vld & any_lsu_ue;

   assign sel_ifuspu_err = (~any_err_vld & ~any_iferr_vld & any_ifu_err |
                            ~any_ue_vld & any_spu_ue |
			                      ~any_ue_vld & ~ifet_ue_vld & any_ifu_ue);

   assign sel_rftlb_err = ~any_ue_vld & (any_rf_ue |
					                               any_tlbasi_err) |
			                    ~any_err_vld & any_rf_ce;
   
   
   assign  erc_erd_eadr2_sel_wrt_l = ~(asi_wrt_err_addr);

   assign  erc_erd_eadr2_sel_mx0_l = ~(~asi_wrt_err_addr & 
				                               (sel_lsu_err | 
					                              sel_rftlb_err));
   
   assign  erc_erd_eadr2_sel_mx1_l = ~(~sel_lsu_err & 
				                               ~asi_wrt_err_addr &
				                               ~sel_rftlb_err &
				                               sel_ifuspu_err);
   
   assign  erc_erd_eadr2_sel_old_l = ~(~sel_lsu_err & 
				                               ~asi_wrt_err_addr &
				                               ~sel_rftlb_err &
				                               ~sel_ifuspu_err);
   
//-----------------------------
// Error Enable Reg
//-----------------------------
   assign nceen_nxt = asi_wrt_err_en & {4{nceen_wrt_data}} |
	                    ~asi_wrt_err_en & nceen;
   
   assign ceen_nxt = asi_wrt_err_en & {4{ceen_wrt_data}} |
	                   ~asi_wrt_err_en & ceen;

   dffr_s #(8) err_en_reg(.din ({nceen_nxt, ceen_nxt}),
		                    .q   ({nceen, ceen}),
		                    .rst (erb_reset),
		                    .clk (clk), .se(se), .si(), .so());

   assign nceen_d = (thr_d[0] & nceen[0] |
                     thr_d[1] & nceen[1] |
                     thr_d[2] & nceen[2] |
                     thr_d[3] & nceen[3]);
   
   dff_s #(1) nce_ff(.din (nceen_d),
                   .q   (ifu_exu_nceen_e),
                   .clk (clk), .se(se), .si(), .so());

   assign ifu_lsu_nceen = nceen;
   assign ifu_spu_nceen = nceen;

   assign ifu_ce_trap = mov_ely_reg_w & ifet_ce_vld;
   assign ce_trapvec =  (ifu_ce_trap |
			                   any_rf_ce |
			                   {4{ifq_erb_ce_rep}} & thr_l2ie |
                         any_spu_ce |
			                   any_lsu_ce) & ceen;

   dff_s #(4) ceint_reg(.din (ce_trapvec),
		                  .q   (erb_fcl_ce_trapvec),
		                  .clk (clk), .se(se), .si(), .so());

   assign ue_trapvec =  ({4{ifq_erb_ue_rep}} & thr_l2ie |
                         any_spu_ue & {4{spu_ifu_int_w2}}) & nceen;

   assign erb_fcl_spu_uetrap = any_spu_ue & nceen;
   
   dff_s #(4) ueint_reg(.din (ue_trapvec),
		                  .q   (erb_fcl_ue_trapvec),
		                  .clk (clk), .se(se), .si(), .so());


   mux4ds #(2) err_en_asi(.dout (erc_erd_erren_asidata),
			                    .in0  ({nceen[0], ceen[0]}),
			                    .in1  ({nceen[1], ceen[1]}),
			                    .in2  ({nceen[2], ceen[2]}),
			                    .in3  ({nceen[3], ceen[3]}),
			                    .sel0 (asi_thr_s[0]),
			                    .sel1 (asi_thr_s[1]),
			                    .sel2 (asi_thr_s[2]),
			                    .sel3 (asi_thr_s[3]));

//-------------------------
// Error Inject
//-------------------------
   assign wrt_errinj_i2 = (ifq_erb_asi_errinj_i2 & ifq_erb_asiwr_i2);
   assign ecc_mask_nxt =  wrt_errinj_i2 ?  ifq_erb_asidata_i2[7:0] :
                                           ecc_mask[7:0];
   
   assign errinj_ctl_nxt[1:0] = wrt_errinj_i2 ? ifq_erb_asidata_i2[31:30] :
	                                              errinj_ctl[1:0];

   // correct for single shot
   assign errinj_vec_nxt[5:0] = wrt_errinj_i2 ? ifq_erb_asidata_i2[29:24] :
	                              errinj_ctl[0] ? corr_errinj_vec :
	                                              errinj_vec;

   dffr_s #(16) errinj_reg(.din ({errinj_ctl_nxt,
			                          errinj_vec_nxt,
			                          ecc_mask_nxt}),
		                     .q   ({errinj_ctl,
			                          errinj_vec,
			                          ecc_mask}),
		                     .rst (erb_reset),
		                     .clk (clk), .se (se), .si(), .so());
   
   assign ifu_exu_ecc_mask = ecc_mask;
   assign ifu_exu_inj_irferr = errinj_vec[1] & errinj_ctl[1];
   assign ifu_ffu_inj_frferr = errinj_vec[0] & errinj_ctl[1];
   assign ifu_lsu_error_inj[3:0] = errinj_vec[5:2] & {4{errinj_ctl[1]}};

   assign corr_errinj_vec[5:0] = errinj_vec[5:0] & ~{lsu_ifu_inj_ack[3:0], 
						                                         exu_ifu_inj_ack,
						                                         ffu_ifu_inj_ack};
   assign erc_erd_errinj_asidata = {errinj_ctl,
				                            errinj_vec,
				                            16'b0,
				                            ecc_mask};
   
//--------------------------
//  ASI Stuff
//--------------------------

   dff_s #(2) asiways_reg(.din (ifq_erb_asiway_f),
		                    .q   (asi_way_s1),
		                    .clk (clk), .se(se), .si(), .so());

   assign dec_asiway_s1[0] = ~asi_way_s1[1] & ~asi_way_s1[0];
   assign dec_asiway_s1[1] = ~asi_way_s1[1] &  asi_way_s1[0];
   assign dec_asiway_s1[2] =  asi_way_s1[1] & ~asi_way_s1[0];
   assign dec_asiway_s1[3] =  asi_way_s1[1] &  asi_way_s1[0];
   
   assign erc_erd_asiway_s1_l = ~dec_asiway_s1;
   
   assign asi_thr_i2[0] = ~ifq_fcl_asi_tid_bf[1] & ~ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[1] = ~ifq_fcl_asi_tid_bf[1] &  ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[2] =  ifq_fcl_asi_tid_bf[1] & ~ifq_fcl_asi_tid_bf[0];
   assign asi_thr_i2[3] =  ifq_fcl_asi_tid_bf[1] &  ifq_fcl_asi_tid_bf[0];

   dff_s #(2) asi_tids_reg(.din (fcl_erb_asi_tid_f),
			                    .q   (asi_tid_s1),
			                    .clk (clk), .se(se), .si(), .so());
   dff_s #(2) asi_tidw2_reg(.din (asi_tid_s1),
			                    .q   (asi_tid_w2),
			                    .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_tid_w2 = asi_tid_w2;

   assign erc_erd_asi_thr_l = ~asi_thr_s;

   assign asi_thr_s[0] = ~asi_tid_s1[1] & ~asi_tid_s1[0];
   assign asi_thr_s[1] = ~asi_tid_s1[1] &  asi_tid_s1[0];
   assign asi_thr_s[2] =  asi_tid_s1[1] & ~asi_tid_s1[0];
   assign asi_thr_s[3] =  asi_tid_s1[1] &  asi_tid_s1[0];

   assign asi_thr_w2[0] = ~asi_tid_w2[1] & ~asi_tid_w2[0];
   assign asi_thr_w2[1] = ~asi_tid_w2[1] &  asi_tid_w2[0];
   assign asi_thr_w2[2] =  asi_tid_w2[1] & ~asi_tid_w2[0];
   assign asi_thr_w2[3] =  asi_tid_w2[1] &  asi_tid_w2[0];

   
   // F stage flops
   dff_s #(1) asi_en_ff(.din (ifq_erb_asi_erren_i2),
		                  .q   (asi_erren_f),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_stat_ff(.din (ifq_erb_asi_errstat_i2),
		                    .q   (asi_errstat_f),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_addr_ff(.din (ifq_erb_asi_erraddr_i2),
		                    .q   (asi_erraddr_f),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_inj_ff(.din (ifq_erb_asi_errinj_i2),
		                   .q   (asi_errinj_f),
		                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_im_ff(.din (ifq_erb_asi_imask_i2),
		                  .q   (asi_imask_f),
		                  .clk (clk), .se(se), .si(), .so());

   // S stage Flops
   dff_s #(1) asi_ens_ff(.din (asi_erren_f),
		                   .q   (asi_erren_s),
		                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_stats_ff(.din (asi_errstat_f),
		                     .q   (asi_errstat_s),
		                     .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_addrs_ff(.din (asi_erraddr_f),
		                     .q   (asi_erraddr_s),
		                     .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_injs_ff(.din (asi_errinj_f),
		                    .q   (asi_errinj_s),
		                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asi_ims_ff(.din (asi_imask_f),
		                   .q   (asi_imask_s),
		                   .clk (clk), .se(se), .si(), .so());

   // ASI Reads
   // All ASI reads except TLB
   dff_s #(1) asi_rdf_ff(.din (ifq_fcl_asird_bf),
		                   .q   (asird_f),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asi_rds_ff(.din (asird_f),
		                   .q   (asird_s),
		                   .clk (clk), .se(se), .si(), .so());

   // fwd reads
   dff_s #(1) fwd_rdf_ff(.din (ifq_erb_fwdrd_bf),
		                   .q   (fwdrd_f),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) fwd_rds_ff(.din (fwdrd_f),
		                   .q   (fwdrd_s),
		                   .clk (clk), .se(se), .si(), .so());
   dff_s #(1) fwd_rdd_ff(.din (fwdrd_s),
		                   .q   (fwdrd_d),
		                   .clk (clk), .se(se), .si(), .so());

   assign ifu_lsu_fwd_data_vld = fwdrd_d;
   assign asifwd_rd_s = asird_s | fwdrd_s;

   
   // asi reads from icache
   dff_s #(1) ic_rdts_ff(.din (ifq_erb_rdtag_f),
		                   .q   (rdtag_s),
		                   .clk (clk), .se(se), .si(), .so());

   // forward requests also read instruction memory
   assign rdinst_f = fwdrd_f | ifq_erb_rdinst_f;
   
   dff_s #(1) ic_rdds_ff(.din (rdinst_f),
		                   .q   (rdinst_s),
		                   .clk (clk), .se(se), .si(), .so());


//   assign rst_tri_en = 1'b0;

   // pick err asi source
   assign erc_erd_errasi_sel_en_l   = ~asi_erren_s;
   assign erc_erd_errasi_sel_stat_l = ~asi_errstat_s | asi_erren_s;
   assign erc_erd_errasi_sel_inj_l  = ~asi_errinj_s | asi_errstat_s | 
                                       asi_erren_s;
   assign erc_erd_errasi_sel_addr_l =  asi_erren_s | asi_errstat_s | 
	                                     asi_errinj_s;	

   assign err_asi_s = (asi_erren_s | asi_errstat_s | asi_errinj_s | 
	                     asi_erraddr_s);

   // pick other asi source
   assign erc_erd_miscasi_sel_ict_l = ~rdtag_s;
   assign erc_erd_miscasi_sel_imask_l = ~asi_imask_s | rdtag_s;
   assign erc_erd_miscasi_sel_other_l = rdtag_s | asi_imask_s;

   // pick source for final asi loads
   assign erc_erd_asisrc_sel_icd_s_l = ~(asifwd_rd_s & rdinst_s);
   assign erc_erd_asisrc_sel_err_s_l = ~(asifwd_rd_s & ~rdinst_s & err_asi_s);
   assign erc_erd_asisrc_sel_misc_s_l = ~(asifwd_rd_s & ~rdinst_s & ~err_asi_s);
   assign erc_erd_asisrc_sel_itlb_s_l = ~(~asifwd_rd_s);

   // is this asi read valid (for checking parity)
   assign asi_ttevld_s1 = fcl_erb_itlbrd_vld_s & ~fcl_erb_itlbrd_data_s;
   assign asi_tdevld_s1 = fcl_erb_itlbrd_vld_s & fcl_erb_itlbrd_data_s;

   assign ldxa_data_vld_s = fcl_erb_itlbrd_vld_s | asird_s;
//   assign ifu_lsu_ldxa_data_vld_w1 = ldxa_data_vld_s;
   
   dff_s #(1) asirdd_ff(.din (ldxa_data_vld_s),
                      .q   (ldxa_data_vld_d),
                      .clk (clk),
                      .se  (se), .si(), .so());
   
   assign ifu_lsu_ldxa_data_vld_w2 = ldxa_data_vld_d;
   

   // ASI Writes
   assign asi_wrt_err_en = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                 ifq_erb_asi_erren_i2}};
   assign asi_wrt_err_stat = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                   ifq_erb_asi_errstat_i2}};
   // err inj is common to the core
//   assign asi_wrt_err_inj = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
//					                                  ifq_erb_asi_errinj_i2}};
   assign asi_wrt_err_addr = asi_thr_i2 & {4{ifq_erb_asiwr_i2 &
					                                   ifq_erb_asi_erraddr_i2}};   

   assign erc_erd_ld_imask = ifq_erb_asiwr_i2 & ifq_erb_asi_imask_i2;


   // ASI Write Data
   assign  meu_wrt_data  = ifq_erb_asidata_i2[31];
   assign  mec_wrt_data  = ifq_erb_asidata_i2[30];
   assign  priv_wrt_data = ifq_erb_asidata_i2[29];

   assign  imdu_wrt_data = ifq_erb_asidata_i2[25];
   assign  imt_wrt_data  = ifq_erb_asidata_i2[24];
   assign  dmdu_wrt_data = ifq_erb_asidata_i2[23];
   assign  dmt_wrt_data  = ifq_erb_asidata_i2[22];
   assign  idc_wrt_data  = ifq_erb_asidata_i2[21];
   assign  itc_wrt_data  = ifq_erb_asidata_i2[20];
   assign  ddc_wrt_data  = ifq_erb_asidata_i2[19];
   assign  dtc_wrt_data  = ifq_erb_asidata_i2[18];
   assign  irc_wrt_data  = ifq_erb_asidata_i2[17];
   assign  iru_wrt_data  = ifq_erb_asidata_i2[16];
   assign  frc_wrt_data  = ifq_erb_asidata_i2[15];
   assign  fru_wrt_data  = ifq_erb_asidata_i2[14];
   assign  ldau_wrt_data = ifq_erb_asidata_i2[13];
   assign  ncu_wrt_data  = ifq_erb_asidata_i2[12];  
   assign  dmsu_wrt_data = ifq_erb_asidata_i2[11];
   assign  mau_wrt_data  = ifq_erb_asidata_i2[9];
  
   assign nceen_wrt_data = ifq_erb_asidata_i2[1];  
   assign ceen_wrt_data  = ifq_erb_asidata_i2[0];  

   //
   sink s0(.in (ifq_erb_asidata_i2[8]));
   sink s1(.in (ifq_erb_asidata_i2[10]));
   
endmodule
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_fcl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_fcl
//  Description:	
//  The FCL is the fetch control logic.  It controls the PC datapath
//  and the fetch/next instruction datapath.  It also manages access
//  to the icache data, tags, vbits and to the tlb.
//  The FCL starts fetching from the reset PC upon reset.  It is up to
//  the DTU to specify which thread to fetch from.  Only T0 is set to
//  the reset PC.  If the decode unit specifies any other thread, it
//  will fetch from an indeterminate address.
//  The fetch block automatically stalls the machine when an Imiss is
//  detected and there is no thread to switch to.  
// 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting














module sparc_ifu_fcl(/*AUTOARG*/
   // Outputs
   
   fcl_itlb_csm_rd_vld_bf,
   
   fcl_icd_rdreq_bf, fcl_icv_rdreq_bf, fcl_icd_wrreq_bf, 
   fcl_ict_wrreq_bf, fcl_icv_wrreq_bf, fcl_icd_index_sel_ifq_bf, 
   fcl_ifq_grant_bf, fcl_ifq_icmiss_s1, fcl_ifq_rdreq_s1, 
   fcl_ifq_icache_en_s_l, fcl_ifq_thr_s1, fcl_ifq_canthr, 
   fcl_itlb_cam_vld_bf, fcl_itlb_cam_bypass_bf, fcl_itlb_addr_mask_l, 
   fcl_itlb_cam_real_bf, fcl_itlb_cam_pid_bf, fcl_itlb_wr_vld_bf, 
   fcl_itlb_dmp_vld_bf, fcl_itlb_dmp_all_bf, fcl_itlb_tag_rd_vld_bf, 
   fcl_itlb_invall_f_l, fcl_itlb_data_rd_vld_bf, fcl_erb_ievld_s1, 
   fcl_erb_tevld_s1, fcl_erb_immuevld_s1, ifu_lsu_thrid_s, 
   fcl_erb_asi_tid_f, fcl_erb_clear_iferr, fcl_erb_itlbrd_vld_s, 
   fcl_erb_itlbrd_data_s, fcl_dec_dslot_s, fcl_dtu_inst_vld_e, 
   fcl_dtu_intr_vld_e, fcl_dtu_inst_vld_d, fcl_dtu_ely_inst_vld_d, 
   fcl_dec_intr_vld_d, fcl_erb_inst_issue_d, fcl_erb_inst_vld_d1, 
   ifu_tlu_inst_vld_m, ifu_exu_inst_vld_e, ifu_exu_inst_vld_w, 
   ifu_spu_inst_vld_w, ifu_tlu_inst_vld_w, ifu_tlu_flush_w, 
   ifu_tlu_flush_m, fcl_swl_int_activate_i3, fcl_swl_flush_wake_w, 
   fcl_swl_flush_w, fcl_dcl_regz_e, ifu_tlu_thrid_e, ifu_tlu_thrid_d, 
   ifu_tlu_immu_miss_m, ifu_tlu_priv_violtn_m, ifu_tlu_icmiss_e, 
   ifu_tlu_ttype_vld_m, ifu_exu_ttype_vld_m, ifu_mmu_trap_m, 
   ifu_tlu_trap_m, ifu_tlu_ttype_m, ifu_tlu_hwint_m, 
   ifu_tlu_sftint_m, ifu_tlu_rstint_m, fcl_dtu_rst_thr_w, 
   fcl_dtu_resum_thr_w, ifu_tlu_itlb_done, ifu_spu_trap_ack, 
   ifu_exu_tid_s2, ifu_exu_ren1_s, ifu_exu_ren2_s, ifu_exu_ren3_s, 
   ifu_exu_disable_ce_e, fcl_dtu_sync_intr_d, fcl_dtu_tlzero_d, 
   fcl_dtu_privmode_d, fcl_dtu_hprivmode_d, fcl_dtu_hprivmode_w2, 
   fcl_dtu_nuke_thr_w, fcl_swl_swout_f, fcl_dtu_stall_bf, 
   fcl_swl_swcvld_s, fcl_dtu_thr_f, fcl_imd_oddwin_d, 
   fcl_fdp_oddwin_s, fcl_fdp_pcoor_vec_f, fcl_fdp_pcoor_f, 
   fcl_fdp_mask32b_f, fcl_fdp_addr_mask_d, fcl_fdp_tctxt_sel_prim, 
   fcl_fdp_usenir_sel_nir_s1, fcl_fdp_rbinst_sel_inste_s, 
   fcl_fdp_thrtnpc_sel_tnpc_l, fcl_fdp_thrtnpc_sel_npcw_l, 
   fcl_fdp_thrtnpc_sel_pcf_l, fcl_fdp_thrtnpc_sel_old_l, 
   fcl_fdp_thr_s1_l, fcl_fdp_next_thr_bf_l, fcl_fdp_next_ctxt_bf_l, 
   fcl_fdp_nirthr_s1_l, fcl_fdp_thr_s2_l, 
   fcl_fdp_tpcbf_sel_pcp4_bf_l, fcl_fdp_tpcbf_sel_brpc_bf_l, 
   fcl_fdp_tpcbf_sel_trap_bf_l, fcl_fdp_tpcbf_sel_old_bf_l, 
   fcl_fdp_pcbf_sel_nosw_bf_l, fcl_fdp_pcbf_sel_swpc_bf_l, 
   fcl_fdp_pcbf_sel_br_bf_l, fcl_fdp_trrbpc_sel_trap_bf_l, 
   fcl_fdp_trrbpc_sel_rb_bf_l, fcl_fdp_trrbpc_sel_err_bf_l, 
   fcl_fdp_trrbpc_sel_pcs_bf_l, fcl_fdp_noswpc_sel_tnpc_l_bf, 
   fcl_fdp_noswpc_sel_old_l_bf, fcl_fdp_noswpc_sel_inc_l_bf, 
   fcl_fdp_nextpcs_sel_pce_f_l, fcl_fdp_nextpcs_sel_pcd_f_l, 
   fcl_fdp_nextpcs_sel_pcs_f_l, fcl_fdp_nextpcs_sel_pcf_f_l, 
   fcl_fdp_inst_sel_curr_s_l, fcl_fdp_inst_sel_switch_s_l, 
   fcl_fdp_inst_sel_nir_s_l, fcl_fdp_inst_sel_nop_s_l, 
   fcl_fdp_tinst_sel_curr_s_l, fcl_fdp_tinst_sel_rb_s_l, 
   fcl_fdp_tinst_sel_old_s_l, fcl_fdp_tinst_sel_ifq_s_l, 
   fcl_fdp_dmpthr_l, fcl_fdp_ctxt_sel_dmp_bf_l, 
   fcl_fdp_ctxt_sel_sw_bf_l, fcl_fdp_ctxt_sel_curr_bf_l, 
   fcl_fdp_rdsr_sel_pc_e_l, fcl_fdp_rdsr_sel_thr_e_l, 
   fcl_fdp_rdsr_sel_ver_e_l, so, ifu_reset_l, 
   fcl_fdp_tlbmiss_s1, fcl_esl_tinst_vld_next_s,
   fcl_esl_brtaken_e, fcl_esl_brtaken_m, fcl_esl_thr_e, fcl_esl_thr_m,
   fcl_esl_inst_vld_d, fcl_esl_inst_vld_e, fcl_esl_inst_vld_m, 
   fcl_esl_thr_trap_bf, fcl_esl_rb_stg_s,
   // Inputs
   
   tlu_itlb_csm_rd_g,
   
   rclk, grst_l, arst_l, se, sehold, si, rst_tri_en, 
   tlu_ifu_flush_pipe_w, exu_ifu_va_oor_m, exu_ifu_oddwin_s, 
   spu_ifu_ttype_tid_w2, spu_ifu_ttype_vld_w2, spu_ifu_ttype_w2, 
   erb_fcl_spu_uetrap, exu_ifu_regz_e, dcl_fcl_bcregz0_e, 
   dcl_fcl_bcregz1_e, dtu_fcl_rollback_g, dtu_fcl_retract_d, 
   dtu_fcl_br_inst_d, dtu_fcl_sir_inst_e, dtu_fcl_privop_e, 
   dtu_fcl_fpdis_e, dtu_fcl_imask_hit_e, dtu_fcl_illinst_e, 
   dtu_fcl_thr_active, dec_fcl_rdsr_sel_pc_d, dec_fcl_rdsr_sel_thr_d, 
   ifq_fcl_wrreq_bf, ifq_fcl_icd_wrreq_bf, ifq_fcl_ictv_wrreq_bf, 
   ifq_fcl_rdreq_bf, ifq_fcl_asi_tid_bf, ifq_fcl_asird_bf, 
   ifq_fcl_invreq_bf, erb_fcl_itlb_ce_d1, erb_dtu_ifeterr_d1, 
   erb_fcl_ifet_uevec_d1, erb_fcl_ue_trapvec, erb_fcl_ce_trapvec, 
   dtu_fcl_nextthr_bf, dtu_fcl_ntr_s, dtu_fcl_running_s, 
   dtu_fcl_flush_sonly_e, fdp_fcl_swc_s2, fdp_fcl_va2_bf, 
   itlb_fcl_tlbmiss_f_l, itlb_fcl_priv_s1, itlb_fcl_cp_s1, 
   itlb_fcl_imiss_s_l, fdp_fcl_pc_oor_vec_f, fdp_fcl_pc_oor_e, 
   fdp_fcl_op_s, fdp_fcl_op3_s, fdp_fcl_ibit_s, lsu_ifu_stallreq, 
   ffu_ifu_stallreq, ifq_fcl_stallreq, dtu_inst_anull_e, 
   ifq_fcl_fill_thr, ifq_fcl_flush_sonly_e, tlu_ifu_trap_tid_w1, 
   tlu_ifu_trappc_vld_w1, tlu_ifu_trapnpc_vld_w1, 
   tlu_lsu_pstate_priv, tlu_lsu_pstate_am, tlu_hpstate_priv, 
   tlu_lsu_redmode, tlu_hpstate_enb, lsu_ifu_addr_real_l, 
   lsu_pid_state0, lsu_pid_state1, lsu_pid_state2, lsu_pid_state3, 
   lsu_ifu_icache_en, lsu_ifu_dc_parity_error_w2, lsu_ifu_t0_tlz, 
   lsu_ifu_t1_tlz, lsu_ifu_t2_tlz, lsu_ifu_t3_tlz, tlu_ifu_hwint_i3, 
   tlu_ifu_pstate_ie, tlu_ifu_sftint_vld, tlu_ifu_hintp_vld, 
   tlu_ifu_rerr_vld, tlu_ifu_rstthr_i2, tlu_ifu_rstint_i2, 
   tlu_ifu_resumint_i2, tlu_ifu_nukeint_i2, tlu_itlb_wr_vld_g, 
   tlu_itlb_dmp_vld_g, tlu_itlb_dmp_all_g, tlu_itlb_data_rd_g, 
   tlu_itlb_tag_rd_g, tlu_itlb_invalidate_all_g, tlu_fcl_dmp_pid_bf, 
   tlu_fcl_dmp_real_bf, tlu_idtlb_dmp_thrid_g, exu_ifu_ecc_ce_m, 
   ffu_ifu_fst_ce_w, config_dtu_esl_en, esl_fcl_stall_bf, 
   esl_fcl_switch_bf, esl_fcl_ntr_s, esl_fdp_issue_prev_inst_s,
   esl_fcl_force_running_s,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data,
   fdp_fcl_jtag_breakpoint_hit
   );

   input  rclk,
	        grst_l,
          arst_l,
	        se,
          sehold,
	        si;

   input  rst_tri_en;


   input  tlu_ifu_flush_pipe_w;	// flush pipe on a trap
   input  exu_ifu_va_oor_m;
   input [3:0] exu_ifu_oddwin_s;

   input [1:0] spu_ifu_ttype_tid_w2;
   input       spu_ifu_ttype_vld_w2;
   input       spu_ifu_ttype_w2;

   input [3:0] erb_fcl_spu_uetrap;  // use m3
   
//   input       dtu_fcl_brtaken_e;    // branch taken
   input       exu_ifu_regz_e;
   input       dcl_fcl_bcregz0_e,
               dcl_fcl_bcregz1_e;
   
   input       dtu_fcl_rollback_g;
   input       dtu_fcl_retract_d;
   input       dtu_fcl_br_inst_d;
   input       dtu_fcl_sir_inst_e;
   input       dtu_fcl_privop_e,
		           dtu_fcl_fpdis_e,
               dtu_fcl_imask_hit_e,
		           dtu_fcl_illinst_e;
   input [3:0] dtu_fcl_thr_active;

   input       dec_fcl_rdsr_sel_pc_d,
		           dec_fcl_rdsr_sel_thr_d;
   
   input       ifq_fcl_wrreq_bf;
   input       ifq_fcl_icd_wrreq_bf,
		           ifq_fcl_ictv_wrreq_bf,
		           ifq_fcl_rdreq_bf;

   input [1:0] ifq_fcl_asi_tid_bf;
   input       ifq_fcl_asird_bf;
   
   input       ifq_fcl_invreq_bf;

   input       erb_fcl_itlb_ce_d1;
   input       erb_dtu_ifeterr_d1;
   input [3:0] erb_fcl_ifet_uevec_d1,
		           erb_fcl_ue_trapvec,
		           erb_fcl_ce_trapvec;   
   
   input [3:0] dtu_fcl_nextthr_bf;   // thread to switch to
   input       dtu_fcl_ntr_s,        // next thread ready for ex
               dtu_fcl_running_s;

   input       dtu_fcl_flush_sonly_e;
//               dec_fcl_kill4sta_e;

   input       fdp_fcl_swc_s2,       // instruction switch condition
		           fdp_fcl_va2_bf,       // bit 2 of vaddr
		           itlb_fcl_tlbmiss_f_l,  // itlb miss
		           itlb_fcl_priv_s1,     // privileged access page
		           itlb_fcl_cp_s1,       // uncached access page
		           itlb_fcl_imiss_s_l;     // icache miss in s1

   input [3:0] fdp_fcl_pc_oor_vec_f;
   input       fdp_fcl_pc_oor_e;

   input [1:0] fdp_fcl_op_s;
   input [5:2] fdp_fcl_op3_s;
   input       fdp_fcl_ibit_s;

   input       lsu_ifu_stallreq,
	             ffu_ifu_stallreq,
               ifq_fcl_stallreq;
   
   input       dtu_inst_anull_e;

   input [3:0] ifq_fcl_fill_thr;     // fill inst goes to this
                                   	 // thread instruction register
   input       ifq_fcl_flush_sonly_e;

   input [1:0] tlu_ifu_trap_tid_w1;     // thr for which trappc is sent
   input       tlu_ifu_trappc_vld_w1,   // ld pc on trap or done/retry
		           tlu_ifu_trapnpc_vld_w1;  // ld Npc for a retry

   input [3:0] tlu_lsu_pstate_priv;     // may need to flop these three
   input [3:0] tlu_lsu_pstate_am;
   input [3:0] tlu_hpstate_priv;
   input [3:0] tlu_lsu_redmode;
   input [3:0] tlu_hpstate_enb;

   input [3:0] lsu_ifu_addr_real_l;
   input [2:0] lsu_pid_state0,
               lsu_pid_state1,
               lsu_pid_state2,
               lsu_pid_state3;
   input [3:0] lsu_ifu_icache_en;

   input       lsu_ifu_dc_parity_error_w2;
   

//   input       lsu_ifu_flush_ireg;  // not needed any more
   input       lsu_ifu_t0_tlz,
 		           lsu_ifu_t1_tlz,
 		           lsu_ifu_t2_tlz,
 		           lsu_ifu_t3_tlz;

   input [3:0] tlu_ifu_hwint_i3,        // normal interrupt
		           tlu_ifu_pstate_ie,
		           tlu_ifu_sftint_vld,
		           tlu_ifu_hintp_vld,
		           tlu_ifu_rerr_vld,
		           tlu_ifu_rstthr_i2;       // reset or idle interrupt

   input       tlu_ifu_rstint_i2,       // reset to a dead thread
		           tlu_ifu_resumint_i2,
		           tlu_ifu_nukeint_i2;

   input       tlu_itlb_wr_vld_g,
		           tlu_itlb_dmp_vld_g,
               tlu_itlb_dmp_all_g,
		           tlu_itlb_data_rd_g,
		           tlu_itlb_tag_rd_g;
   input       tlu_itlb_invalidate_all_g;

   input [2:0] tlu_fcl_dmp_pid_bf;
   input       tlu_fcl_dmp_real_bf;
   input [1:0] tlu_idtlb_dmp_thrid_g;

   input       exu_ifu_ecc_ce_m;
   input       ffu_ifu_fst_ce_w;
  
   input       config_dtu_esl_en;
   input       esl_fcl_stall_bf;
   input       esl_fcl_switch_bf;
   input       esl_fcl_ntr_s;
   input       esl_fdp_issue_prev_inst_s;
   input       esl_fcl_force_running_s;

   
   input       tlu_itlb_csm_rd_g;
   
   
   // jtag
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data; 
   
   // to icd
   output      fcl_icd_rdreq_bf,
               fcl_icv_rdreq_bf,
		           fcl_icd_wrreq_bf,
		           fcl_ict_wrreq_bf,
		           fcl_icv_wrreq_bf;

   output      fcl_icd_index_sel_ifq_bf;
   output      fcl_ifq_grant_bf;
   
   // to ifq
   output      fcl_ifq_icmiss_s1;  // if icache turned off
   output      fcl_ifq_rdreq_s1;
   output      fcl_ifq_icache_en_s_l;
   
   output [1:0] fcl_ifq_thr_s1;
   output [3:0] fcl_ifq_canthr;     // cancel ifetch to this thread

   // to itlb
   output       fcl_itlb_cam_vld_bf,
                fcl_itlb_cam_bypass_bf,
		            fcl_itlb_addr_mask_l,
                fcl_itlb_cam_real_bf;

   output [2:0] fcl_itlb_cam_pid_bf;
   
   output       fcl_itlb_wr_vld_bf,
		            fcl_itlb_dmp_vld_bf,
                fcl_itlb_dmp_all_bf,
		            fcl_itlb_tag_rd_vld_bf,
		            fcl_itlb_invall_f_l,
		            fcl_itlb_data_rd_vld_bf;
  
   
   output       fcl_itlb_csm_rd_vld_bf;
   
   
   // to erb
   output       fcl_erb_ievld_s1,
		            fcl_erb_tevld_s1,
		            fcl_erb_immuevld_s1;

   output [1:0] ifu_lsu_thrid_s,
		            fcl_erb_asi_tid_f;

   output [3:0] fcl_erb_clear_iferr;
   

   output       fcl_erb_itlbrd_vld_s,
		            fcl_erb_itlbrd_data_s;

   output       fcl_dec_dslot_s;
   output       fcl_dtu_inst_vld_e,
                fcl_dtu_intr_vld_e,
		            fcl_dtu_inst_vld_d,
                fcl_dtu_ely_inst_vld_d,
                fcl_dec_intr_vld_d,
		            fcl_erb_inst_issue_d,
		            fcl_erb_inst_vld_d1,
		            ifu_tlu_inst_vld_m,
//		            ifu_lsu_inst_vld_m,
		            ifu_exu_inst_vld_e,
		            ifu_exu_inst_vld_w,
		            ifu_spu_inst_vld_w,
		            ifu_tlu_inst_vld_w;
   
   output       ifu_tlu_flush_w;
   output       ifu_tlu_flush_m;

   output [3:0] fcl_swl_int_activate_i3;
   output       fcl_swl_flush_wake_w;
   output       fcl_swl_flush_w;

   output       fcl_dcl_regz_e;
   
   // to tlu
   output [1:0] ifu_tlu_thrid_e;
   output [1:0] ifu_tlu_thrid_d;

   output       ifu_tlu_immu_miss_m,
		            ifu_tlu_priv_violtn_m;
	 
   output       ifu_tlu_icmiss_e;
   output       ifu_tlu_ttype_vld_m;
   output       ifu_exu_ttype_vld_m;
   output       ifu_mmu_trap_m;
   output       ifu_tlu_trap_m;
   output [8:0] ifu_tlu_ttype_m;
   
   output       ifu_tlu_hwint_m;
   output       ifu_tlu_sftint_m;
//   output       ifu_tlu_hintp_m;
//   output       ifu_tlu_rerr_m;
   output       ifu_tlu_rstint_m;
   output       fcl_dtu_rst_thr_w;
   output       fcl_dtu_resum_thr_w;

   output       ifu_tlu_itlb_done;

   output       ifu_spu_trap_ack;
   
   // to exu
   output [1:0] ifu_exu_tid_s2;
   output       ifu_exu_ren1_s,
		            ifu_exu_ren2_s,
		            ifu_exu_ren3_s;

   output       ifu_exu_disable_ce_e;  // to exu and ffu
   
   
   // to dtu
   output       fcl_dtu_sync_intr_d;
   output       fcl_dtu_tlzero_d;
   output       fcl_dtu_privmode_d;
   output       fcl_dtu_hprivmode_d;
   output       fcl_dtu_hprivmode_w2;
   output       fcl_dtu_nuke_thr_w;
   output       fcl_swl_swout_f;
   output       fcl_dtu_stall_bf;
//   output       fcl_dtu_switch_s;     // indicates to the DTU that a
                                      // switch took place to next_thr
   output       fcl_swl_swcvld_s;
   output [3:0] fcl_dtu_thr_f;
   output       fcl_imd_oddwin_d;
   
   // to fdp
   output       fcl_fdp_oddwin_s;
   output [3:0] fcl_fdp_pcoor_vec_f;
   output       fcl_fdp_pcoor_f;
   output       fcl_fdp_mask32b_f;
   output       fcl_fdp_addr_mask_d;

   output [3:0] fcl_fdp_tctxt_sel_prim;

   
   // 2:1 mux selects
   output       fcl_fdp_usenir_sel_nir_s1;   // same as usenir_d2
   output [3:0] fcl_fdp_rbinst_sel_inste_s;

   output [3:0] fcl_fdp_thrtnpc_sel_tnpc_l,  // load npc
		            fcl_fdp_thrtnpc_sel_npcw_l,
		            fcl_fdp_thrtnpc_sel_pcf_l,
		            fcl_fdp_thrtnpc_sel_old_l;
   
   output [3:0] fcl_fdp_thr_s1_l;            // s1 thr for thrNIR input mux
   
   // other mux selects   
   output [3:0] fcl_fdp_next_thr_bf_l,  // for thrpc output mux
                fcl_fdp_next_ctxt_bf_l, // for ctxt output mux
		            fcl_fdp_nirthr_s1_l,    // select NIR in s1 stage
		            fcl_fdp_thr_s2_l;       // s2 thr for thr_inst_reg

   output [3:0] fcl_fdp_tpcbf_sel_pcp4_bf_l, // selects for thread PC muxes
		            fcl_fdp_tpcbf_sel_brpc_bf_l,
		            fcl_fdp_tpcbf_sel_trap_bf_l,
		            fcl_fdp_tpcbf_sel_old_bf_l;

   output       fcl_fdp_pcbf_sel_nosw_bf_l,      // F stage pc mux selects
		            fcl_fdp_pcbf_sel_swpc_bf_l,
		            fcl_fdp_pcbf_sel_br_bf_l;

   output [3:0] fcl_fdp_trrbpc_sel_trap_bf_l, 
		            fcl_fdp_trrbpc_sel_rb_bf_l,
		            fcl_fdp_trrbpc_sel_err_bf_l,
		            fcl_fdp_trrbpc_sel_pcs_bf_l;

   output       fcl_fdp_noswpc_sel_tnpc_l_bf,    // next pc select,
		            fcl_fdp_noswpc_sel_old_l_bf,		 // dont need anymore
		            fcl_fdp_noswpc_sel_inc_l_bf;

   output [3:0] fcl_fdp_nextpcs_sel_pce_f_l,  
		            fcl_fdp_nextpcs_sel_pcd_f_l,
		            fcl_fdp_nextpcs_sel_pcs_f_l,  
		            fcl_fdp_nextpcs_sel_pcf_f_l;

   output       fcl_fdp_inst_sel_curr_s_l,   // selects for inst_s2
		            fcl_fdp_inst_sel_switch_s_l,
		            fcl_fdp_inst_sel_nir_s_l,
		            fcl_fdp_inst_sel_nop_s_l;

   output [3:0] fcl_fdp_tinst_sel_curr_s_l,  // selects for tinst regs
		            fcl_fdp_tinst_sel_rb_s_l,		
		            fcl_fdp_tinst_sel_old_s_l,
		            fcl_fdp_tinst_sel_ifq_s_l;

   output [3:0] fcl_fdp_dmpthr_l;

   output       fcl_fdp_ctxt_sel_dmp_bf_l,
		            fcl_fdp_ctxt_sel_sw_bf_l,
		            fcl_fdp_ctxt_sel_curr_bf_l;

   output       fcl_fdp_rdsr_sel_pc_e_l,
                fcl_fdp_rdsr_sel_thr_e_l,
                fcl_fdp_rdsr_sel_ver_e_l;
   
   output       so,
                ifu_reset_l;

   output       fcl_fdp_tlbmiss_s1;   
   output [3:0] fcl_esl_tinst_vld_next_s;
   output       fcl_esl_brtaken_e;
   output       fcl_esl_brtaken_m;
   output [3:0] fcl_esl_thr_e;
   output [3:0] fcl_esl_thr_m;
   output       fcl_esl_inst_vld_d;
   output       fcl_esl_inst_vld_e;
   output       fcl_esl_inst_vld_m;
   output [3:0] fcl_esl_thr_trap_bf;
   output       fcl_esl_rb_stg_s;

   // input       rtap_core_stallreq;
   input       fdp_fcl_jtag_breakpoint_hit;

   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------
   reg [3:0]    fcl_fdp_tpcbf_sel_old_bf_l,
		            fcl_fdp_tpcbf_sel_pcp4_bf_l,
		            fcl_fdp_tpcbf_sel_trap_bf_l,
		            fcl_fdp_tpcbf_sel_brpc_bf_l;
   
   wire         fcl_fdp_inst_sel_nop_s_l,
                fcl_fdp_inst_sel_nir_s_l,
		            fcl_fdp_inst_sel_curr_s_l,
		            fcl_fdp_inst_sel_switch_s_l;
   

   // local signals
   wire         //sw_itlb_on,
                sw_itlb_real,
		            sw_itlb_am,
		            //this_itlb_on,
                this_itlb_real,
		            itlb_on;

   wire [3:0]   xlate_en,
                xlate_en_d1;
   
   wire [2:0]   sw_pid_bf,
                curr_pid_bf;

   wire         pid_sel_sw,
                pid_sel_curr,
                pid_sel_dmp;
   
   wire         itlb_access_gnt,
		            itlb_access_en,
                itlb_write_en,
                ctxt_sel_dmp,
		            itlb_access_done,
                itlb_write_done,
		            itlb_rd_access_done,
		            itlb_rd_access_done_d1,
		            itlb_rd_access_done_d2,
		            itlb_rd_req_bf,
		            itlb_rd_req_f,
		            itlb_data_rd_f,
                itlb_data_rd_s;
   
   wire [1:0]   asi_tid_bf;
   wire [1:0]   spu_tid_w2;
   
   wire         fetch_bf,	// fetch an instruction next cycle
                allow_ifq_access_icd_bf,
                inst_access_bf,
                ia1_bf,
                ia0_bf,
                no_instacc_bf;
   
   wire         cam_vld_bf,
                tlb_invall_bf,
                tlb_invall_f,
//                tlb_invall_req_bf,
                inst_vld_bf;
   
   wire         rdreq_bf,     // read from I$ next cycle
		            rdreq_f;
   
   wire         ic_wrreq_bf;
   
   wire         running_s2,
                valid_s,
		            running_s1,
                ely_running_s1,
		            running_d,
		            running_e,
		            running_m,
    		        inst_vld_f,
		            inst_vld_s,
                inst_vld_s_crit,
		            inst_vld_s1,
		            inst_vld_s2,    // valid bit of S stage
	 	                            // instruction.  If this is 0,
		                            // convert inst to no-op
                    inst_vld_s2_ed,
		            inst_vld_d,
                inst_vld_d_crit,
		            inst_vld_d1,
		            inst_vld_e,
		            inst_vld_qual_e,
		            inst_vld_m,
		            inst_vld_w;

   wire         inst_vld_w_crit;
   
   wire         no_iftrap_m,
                no_iftrap_w;

   wire         stall_f,
		            stall_s1,
		            stall_s1_nxt,
                ely_stall_thisthr_f,
                part_stall_thisthr_f,
		            stall_thisthr_f;
   wire         rdreq_s1;

   wire         usenir_bf,
		            usenir_f,
		            usenir_s1;
   
   wire [3:0]   tinst_vld_s,    // valid bit of thr instr register
		                            // in s stage
		            tinst_vld_nxt;

   wire [3:0]   val_thr_s1,
		            val_thr_f,
                thr_e_v2,
		            val_thr_e;
   
   wire         flush_sonly_qual_e,
                flush_sonly_all_m,
                flush_sonly_qual_m,
                ims_flush_sonly_m,
                ims_flush_sonly_w,
                ims_flush_coll_m,
                ims_flush_coll_w,
                flush_sonly_m;

   wire         flush_pipe_w;
   
   wire         kill_thread_d,
//		            kill_thread_e,
		            kill_thread_m,
                kill_local_m,
                ely_kill_thread_s2,
                ely_kill_thread_m,
		            kill_thread_s2;
   
   wire [3:0]   clear_s_d1,
                flush_thr_w,
                late_flush_w2;

   wire         utrap_flush_w,
                utrap_flush_m,
                flush_pipe_w2;
   
   wire         kill_curr_f,
                kill_curr_d,
                kill_curr_e,
                kill_curr_m;
   
   wire [3:0]   canthr_f,
                canthr_s_early,
		            canthr_s;
   wire         canthr_sw;
   wire         canthr_sm,
                canthr_sd;

   wire         forcemiss_f,   // force an icache miss (if icache is off)
		            forcemiss_s1,
                icmiss_for_perf,
//                ic_miss_sw_s1,
		            ic_miss_s1;    // icache miss (forced or not)

   wire [3:0]   icache_en_d1;

   wire         icache_on_bf,
		            icache_on_f,
		            icache_on_s1,
                uncached_page_s1;
//		            sw_icache_on,
//		            this_icache_on;
   
   wire         imsto_thisthr_s1,
                iferrto_thisthr_d1,
                retract_iferr_d1,
                retract_iferr_qual_d1,
                retract_inst_d,
                retract_iferr_e;
//   wire         intrto_thisthr_d;
//   wire         imsto_nextthr_s1;

   wire         mark4rb_w,
                mark4rb_m,
                mark4rb_e,
                mark4rb_d,
                mark4rb_s;
   
   wire [3:0]   tlbmiss_s2,
		            tlbmiss_d,
		            nir_tlbmiss_vec,
		            nir_tlbmiss_next;

   wire [3:0]   delay_slot_vec,
                delay_slot_vec_nxt;
   
   wire         tlb_cam_miss_f,
                tlb_cam_miss_s1,
                nir_tlbmiss_s1,
		            tlbmiss_s1_crit,
		            tlbmiss_s1;
   
   wire         cam_vld_f,
		            cam_vld_s1;
   
   wire         immu_fault_f,
		            immu_miss_d,
		            immu_miss_crit_d,
		            immu_miss_qual_d,
		            immu_miss_e,
//                immu_miss_qual_e,
                immu_miss_m,
                addr_real_e;
   wire [3:0]   itlb_addr_real_l,
                itlb_addr_real;
   wire [3:0]   pstate_am_d1;
   
   wire         pc_oor_s1,
                pc_oor_s2,
                pc_oor_s,
		            pc_oor_f;
   wire         set_oor_m;
   wire         addr_mask_32b_m;
   
   wire         priv_mode_s1,
                priv_mode_f,
                hpriv_mode_s1,
                hpriv_mode_w,
                hpriv_mode_w2,
                hpriv_mode_f;

   wire         inst_acc_exc_s1,
		            inst_acc_exc_d,
		            inst_acc_exc_e;
   wire [3:0]   inst_acc_vec_s2,
		            inst_acc_vec_d;
   
   wire         priv_violtn_e,
                priv_violtn_m;

   wire         trap_e,
		            trap_m;
   
   wire         ttype_sel_spuma_e,
 		            ttype_sel_spuenc_e,
		            ttype_sel_corr_err_e,
		            ttype_sel_unc_err_e,		
		            ttype_sel_res_err_e,		
		            ttype_sel_hstk_cmp_e,		
		            ttype_sel_pcoor_e,
		            ttype_sel_immu_miss_e, 
		            ttype_sel_real_trans_e, 
		            ttype_sel_icache_err_e,
		            ttype_sel_priv_viol_e, 
		            ttype_sel_privop_e,    
		            ttype_sel_illinst_e,
		            ttype_sel_ibe_e,
		            ttype_sel_sir_e,
		            ttype_sel_fpdis_e;
   
   wire [8:0]   ttype_e;
   
   wire [3:0]   next_nir_privvec,
		            nir_privvec;
   wire         nir_priv_s1,
		            priv_inst_s1;
   
   wire         tlzero_s2;
   wire [3:0]   tlzero_vec_d1;

   wire         nuke_thr_w,
                resum_thr_w,
                rst_thr_w;

   wire [3:0]   spu_thr;
//   wire [3:0]   rst_thr_bf;
   
   wire [3:0]   async_rst_i3,
                async_rst_i4,
		            next_rst_i2,
		            rstint_i2,
		            rstint_i3,
		            resumint_i2,
		            resumint_i3,
                next_resum_i2,
		            nuke_thr_i2,
		            next_nuke_i2,
		            nuke_thr_i3,
		            next_sftint_i2,
                next_hintp_i2,
                next_rerr_i2,
		            next_hwint_i3,
		            sftint_i3,
                hintp_i3,
                rerr_i3,
		            hwint_i4,
		            next_ceint_i2,
		            ceint_i3,
		            next_ueint_i2,
		            ueint_i3,
		            next_spuint0_i2,
		            spuint0_i3,
		            next_spuint1_i2,
		            spuint1_i3;

   wire [3:0]   intr_in_pipe;

   wire [3:0]   hypv_int_en,
                hypv_int_en_d1;
   wire [3:0]   supv_int_en,
                supv_int_en_d1;

   wire [3:0]   ifet_ue_vec_d1,
		            ifet_ue_vec_e;
   wire         ifet_ue_e;

   wire [3:0]   any_intr_vec_f,
                any_intr_vec_s,
                intr_pending_nxt,
                intr_pending_s,
                supv_masked_intr_s,
                hypv_masked_intr_s;

   wire         spuint0_m,
                spuint0_trap_m,
//                spuint0_qual_m,
		            spuint0_e,
		            spuint0_qual_e,
                spuint0_w,
                spuint0_trap_w,
 		            spuint1_m,
                spuint1_trap_m,
//                spuint1_qual_m,
		            spuint1_e,
		            spuint1_qual_e,
                spuint1_w,
                spuint1_trap_w,
                hwint_m,
                hwint_e,
                rstint_m,
//                rstint_qual_m,
                resumint_m,
                resumint_qual_m,
                sftint_m,
                sftint_e,
                sftint_qual_e,
                hintp_e,
                hintp_qual_e,
                hintp_m,
                rerr_e,
                rerr_qual_e,
                rerr_m,
                nuke_thr_m,
                nuke_thr_qual_m,
		            ceint_m,
                ceint_trap_m,
                ceint_trap_w,
//                ceint_qual_m,
                ceint_qual_w,
		            ceint_e,
		            ceint_qual_e,
		            ueint_m,
                ueint_trap_m,
                ueint_trap_w,
//                ueint_qual_m,
                ueint_qual_w,
                ueint_qual_e,
		            ueint_e;

   wire         disr_trap_m,
                rb_intr_m,
                rb_intr_w,
                any_intr_m;
   
   wire         force_intr_s;
   wire         intr_vld_s,
		            intr_vld_d,
		            intr_vld_e,
		            intr_vld_m,
		            intr_vld_w,
                intr_vld_qual_s,
		            intr_vld_qual_d,
		            intr_vld_qual_e,
		            intr_vld_qual_m;
   
   wire         kill_intr_f,
		            kill_intr_d,
		            kill_intr_e;
   
//	 wire         kill_intr_m;
   
   wire         rst_stallreq,
                rst_stallreq_l,
                all_stallreq,
                rst_itlb_stv_l,
                arst_vld_f,
                arst_vld_f_l,
                arst_vld_s,
                arst_vld_s_l,
                async_intr_vld_s,
                itlb_starv_alert,
                rst_sw_bf,
                rst_sw_bf_l,
                sw_for_real_rst_bf,
                rst_stallreq_d0,
		            rst_stallreq_d1,
		            rst_stallreq_d2;

   wire         lsu_stallreq_d1,
                ffu_stallreq_d1;
   
   wire [3:0]   rstint_penc;
   
   wire         usep_bf,
                set_usen_bf,
                usen_iso_bf,
		            usen_bf;
   wire         va2_f;
   wire         ntpc_thisthr;
   
   wire [3:0]   thr_usen_nxt,
 		            thr_usen_bf;
   
   wire         brto_nxtthr_bf_l,  // intermediate signal for icadr sel
//                brto_nxtthr_bf,
//                thr_match_ne_norst,
                sw_match_ne_norst,
                brtaken_buf_e,
                brtaken_unq_e,
                brtaken_e,
                brtaken_m;
   
   wire         switch_bf,   // switch in next cycle unless stall
                switch_qual_bf,
		            switch_s2;  // switch in this cycle
   
   wire         rstt,       // set thr_f to the reset pkt thread
		            swt,        // switch to nextthr_bf
		            samet;      // don't change thread

   wire [3:0]   thr_f_crit,
                thr_f_dec,
                thr_f_flop;

   wire [3:0]   thr_f,      // = thr_s2
		            thr_bf,
		            thr_s1,     // = thr_d
		            thr_s1_next,
                dec_thr_s1_l,
		            thr_d,
		            thr_e,
		            thr_m,
		            thr_w2,
		            thr_w;

   wire         tm_fd_l;
   
   wire         thr_match_fw,
		            thr_match_fw2,
		            thr_match_dw,
		            thr_match_dw2,
		            thr_match_em,
		            thr_match_ew,
		            thr_match_ew2,
		            same_thr_mw2,
		            thr_match_mw,
		            thr_match_fm,
		            thr_match_de,
		            thr_match_dm,
		            thr_match_fe,
		            thr_match_fd,
		            thr_match_fs1,
		            thr_match_nw,
		            thr_match_nd,
		            thr_match_ne;
//		            thr_match_ft;

   wire         rb2_inst_d,
		            rb2_inst_e,
		            rb1_inst_s,
		            rb1_inst_d,
		            rb0_inst_bf,
		            rb0_inst_s,
		            rt2_inst_e,
		            rt1_inst_s,
		            rt1_inst_d,
		            rt0_inst_bf,
		            rt0_inst_s;
   
   wire [3:0]   rb_w2,
                rb_for_iferr_e,
		            rb_froms,
		            rb_frome,
		            rb_fromd;
   
   wire         rb_stg_s,
		            rb_stg_d,
                rb_stg_d_crit,
		            rb_stg_e;
   
   wire         icadr_selbr_l,
//		            icadr_selsw,
//                icadr_selbr,
                icadr_selsw_l;

   wire         sw_or_async_stall;
   
   wire [3:0]   trap_thr;
   
   wire [3:0]   load_tpc,     // thread pc reg input select
		            load_bpc,     // these should be exclusive in normal mode
		            load_pcp4;    // but not during scan shift or reset
   
   wire         irf_ce_w,
		            irf_ce_m,
                any_ce_w,
		            rb_stg_w;

   wire [3:0]   ce_cnt0,
                ce_cnt0_nxt,
                ce_cnt1,
                ce_cnt1_nxt,
                ce_cnt_rst;
   
   wire         ce_val0_d,
                ce_val1_d,
                disable_ce_e,
                disable_ce_d;
   
   wire [3:0]   ntpc_vld,     // use thr_nextpc_f
		            ntpc_vld_nxt;
   
   wire [1:0]   sas_thrid_w;
   
   wire         rdsr_sel_pc_e,
		    		    rdsr_sel_thr_e;

   wire [1:0]   trap_tid_w2;
   wire         trappc_vld_w2, 
                trapnpc_vld_w2;

   wire         fcl_reset,
                fcl_reset_l;

   // some monitor is looking for this signal
//   wire         fcl_swl_flush_wait_w=1'b0;
   wire         clk;
   
   wire [3:0]   nextthr_bf_buf,
                nextthr_final_bf;


//
// Code start here 
//
   assign       clk = rclk;
   
//----------------------------------------------------------------------
// Fetch Unit Controls
//----------------------------------------------------------------------

   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (fcl_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign   fcl_reset = ~fcl_reset_l;
   assign   ifu_reset_l = fcl_reset_l;
   

//-----------------------------------
// TLB Operations
//-----------------------------------

   dff_s #(4) real_reg(.din (lsu_ifu_addr_real_l),
                     .q   (itlb_addr_real_l),
                     .clk (clk), .se(se), .si(), .so());
   assign   itlb_addr_real = ~itlb_addr_real_l;

   // ITLB on signal

//`ifdef SPARC_HPV_EN   
   assign   xlate_en = (~tlu_hpstate_enb & lsu_ifu_addr_real_l |
                        tlu_hpstate_enb & ~tlu_hpstate_priv) & 
                         ~tlu_lsu_redmode;
   
//`else
//   assign   xlate_en = lsu_ifu_addr_real_l;
//`endif

   dff_s #(4) xlate_reg(.din (xlate_en),
                      .q   (xlate_en_d1),
                      .clk (clk), .se(se), .si(), .so());
   
//   assign sw_itlb_on = ((nextthr_bf_buf & xlate_en_d1) == 4'b0) ?
//		                     1'b0 : 1'b1;
//   assign this_itlb_on = ((thr_f & xlate_en_d1) == 4'b0) ?
//			                     1'b0 : 1'b1;
//   assign itlb_on = switch_bf ? sw_itlb_on : this_itlb_on;
   assign itlb_on = (nextthr_final_bf[0] & xlate_en_d1[0] |
                     nextthr_final_bf[1] & xlate_en_d1[1] |
                     nextthr_final_bf[2] & xlate_en_d1[2] |
                     nextthr_final_bf[3] & xlate_en_d1[3]);
   

   // flop xlate_en (done) addr_real and icache_en if timing is 
   // not cutting it

   // Hypervisor signals
   assign sw_itlb_real = ((nextthr_bf_buf & itlb_addr_real) == 4'b0) ?
		                     1'b0 : 1'b1;
   assign this_itlb_real = ((thr_f & itlb_addr_real) == 4'b0) ?
			                     1'b0 : 1'b1;

//   assign fcl_itlb_cam_real_bf = switch_bf ? sw_itlb_real : this_itlb_real;

   mux3ds  creal_mx(.dout (fcl_itlb_cam_real_bf),
                    .in0  (sw_itlb_real),
                    .in1  (this_itlb_real),
                    .in2  (tlu_fcl_dmp_real_bf),
                    .sel0 (pid_sel_sw),
                    .sel1 (pid_sel_curr),
                    .sel2 (pid_sel_dmp));

   // Partition ID
   mux4ds #(3) swpid_mux (.dout (sw_pid_bf[2:0]),
                          .in0  (lsu_pid_state0[2:0]),
                          .in1  (lsu_pid_state1[2:0]),
                          .in2  (lsu_pid_state2[2:0]),
                          .in3  (lsu_pid_state3[2:0]),
                          .sel0 (nextthr_bf_buf[0]),
                          .sel1 (nextthr_bf_buf[1]),
                          .sel2 (nextthr_bf_buf[2]),
                          .sel3 (nextthr_bf_buf[3]));

   mux4ds #(3) currpid_mux (.dout (curr_pid_bf[2:0]),
                            .in0  (lsu_pid_state0[2:0]),
                            .in1  (lsu_pid_state1[2:0]),
                            .in2  (lsu_pid_state2[2:0]),
                            .in3  (lsu_pid_state3[2:0]),
                            .sel0 (thr_f[0]),
                            .sel1 (thr_f[1]),
                            .sel2 (thr_f[2]),
                            .sel3 (thr_f[3]));

//   assign fcl_itlb_cam_pid_bf[2:0] = switch_bf ?  
//                                       sw_pid_bf[2:0] : 
//                                       curr_pid_bf[2:0];

//   assign pid_sel_dmp = tlu_itlb_dmp_actxt_g & ctxt_sel_dmp;
   assign pid_sel_dmp = ctxt_sel_dmp;   
   assign pid_sel_curr = ~pid_sel_dmp & ~switch_bf;
   assign pid_sel_sw = ~pid_sel_dmp & switch_bf;
   mux3ds #(3) ipid_mx(.dout (fcl_itlb_cam_pid_bf[2:0]),
                       .in0  (sw_pid_bf[2:0]),
                       .in1  (curr_pid_bf[2:0]),
                       .in2  (tlu_fcl_dmp_pid_bf[2:0]),
                       .sel0 (pid_sel_sw),
                       .sel1 (pid_sel_curr),
                       .sel2 (pid_sel_dmp));
   
   // ITLB address mask
   dff_s #(4) am_reg(.din (tlu_lsu_pstate_am),
                   .q   (pstate_am_d1),
                   .clk (clk), .se(se), .si(), .so());
   
   assign sw_itlb_am = ((nextthr_bf_buf & pstate_am_d1) == 4'b0) ?
		                     1'b0 : 1'b1;
   assign fcl_itlb_addr_mask_l = switch_bf ? 
                                 ~sw_itlb_am : ~fcl_fdp_mask32b_f;

   dff_s #(4) tlz_reg(.din ({lsu_ifu_t3_tlz,
                           lsu_ifu_t2_tlz,
                           lsu_ifu_t1_tlz,
                           lsu_ifu_t0_tlz}),
                    .q   (tlzero_vec_d1[3:0]),
                    .clk (clk), .se (se), .si(), .so());
                           

   // TLB context select
   assign fcl_fdp_tctxt_sel_prim = tlzero_vec_d1 & itlb_addr_real_l;
//   assign fcl_fdp_tctxt_sel_prim[1] = lsu_ifu_t1_tlz & itlb_addr_real_l[1];
//   assign fcl_fdp_tctxt_sel_prim[2] = lsu_ifu_t2_tlz & itlb_addr_real_l[2];
//   assign fcl_fdp_tctxt_sel_prim[3] = lsu_ifu_t3_tlz & itlb_addr_real_l[3];
   

   // Access to TLB
   // ITLB may be accessed even when icache is off
   assign cam_vld_bf = itlb_on & inst_access_bf;
                        
   assign fcl_itlb_cam_vld_bf = cam_vld_bf;
   assign fcl_itlb_cam_bypass_bf = ~cam_vld_bf;
   
   dff_s #(1) itlb_onf_ff(.din (cam_vld_bf),
		                    .q   (cam_vld_f),
		                    .clk (clk),
		                    .se  (se), .si(), .so());

   dff_s #(1) itlb_ons1_ff(.din (cam_vld_f),
		                     .q   (cam_vld_s1),
		                     .clk (clk),
		                     .se  (se), .si(), .so());

   // allow rd/wr/demap access to tlb
   // itlb access is granted only every other cycle
   // (not enough time to turn the request from mmu around)
//   assign itlb_access_en = ~cam_vld_bf & ~ifq_fcl_asird_bf & 
//                           ~itlb_access_done;
//
//   assign itlb_write_en = ~cam_vld_bf & ~ifq_fcl_asird_bf & 
//                           ~itlb_write_done & 
//                           (~tlu_itlb_dmp_vld_g | itlb_access_done);

// Save some timing   
//   assign itlb_write_en = (~itlb_on | no_instacc_bf) & ~ifq_fcl_asird_bf &
//                          ~itlb_write_done & 
//                          (~tlu_itlb_dmp_vld_g | itlb_access_done);

   assign itlb_write_en = no_instacc_bf & ~ifq_fcl_asird_bf & 
                          ~itlb_write_done &  
                          (~tlu_itlb_dmp_vld_g | itlb_access_done);
   assign itlb_access_en = no_instacc_bf & ~ifq_fcl_asird_bf &
                           ~itlb_access_done;

   // reset tlb
//   dff #(1) itlbrst_ff(.din (tlu_itlb_invalidate_all_g),
//		                   .q   (tlb_invall_req_bf),
//		                   .clk (clk), .se(se), .si(), .so());
//   assign tlb_invall_bf = tlb_invall_req_bf & ~itlb_access_done;
   assign tlb_invall_bf = sehold ? tlb_invall_f :
                           (tlu_itlb_invalidate_all_g & itlb_access_en);
   dff_s #(1) itlbrstf_ff(.din (tlb_invall_bf),
		                    .q   (tlb_invall_f),
		                    .clk (clk), .se(se), .si(), .so());

   assign fcl_itlb_wr_vld_bf = tlu_itlb_wr_vld_g & itlb_write_en;
   assign fcl_itlb_dmp_vld_bf = tlu_itlb_dmp_vld_g & itlb_access_en;
   assign fcl_itlb_dmp_all_bf = tlu_itlb_dmp_all_g & tlu_itlb_dmp_vld_g & 
                                itlb_access_en;

//   assign fcl_itlb_invall_bf = tlb_invall_bf & itlb_access_en | fcl_reset;
   assign fcl_itlb_invall_f_l = ~tlb_invall_f;

   assign fcl_itlb_data_rd_vld_bf = tlu_itlb_data_rd_g & itlb_access_en & 
	                                  ~itlb_rd_access_done_d2 &
                                    ~itlb_rd_access_done_d1;
 
   assign fcl_itlb_tag_rd_vld_bf = tlu_itlb_tag_rd_g & itlb_access_en &
	                                 ~itlb_rd_access_done_d2 &
                                   ~itlb_rd_access_done_d1;

   
   assign fcl_itlb_csm_rd_vld_bf = tlu_itlb_csm_rd_g & itlb_access_en & 
	                                  ~itlb_rd_access_done_d2 &
                                    ~itlb_rd_access_done_d1;
   

   assign rst_itlb_stv_l = ((tlu_itlb_invalidate_all_g |
                             tlu_itlb_dmp_vld_g |
                             tlu_itlb_data_rd_g |
                             
                             tlu_itlb_csm_rd_g  | 
                             
                             tlu_itlb_tag_rd_g) & ~itlb_access_done |
                            tlu_itlb_wr_vld_g & ~itlb_write_done) &
                             ~fcl_reset;

   sparc_ifu_ctr5 starv_ctr(
			                      // Outputs
			                      .limit	(itlb_starv_alert),
			                      .so	(so),
			                      // Inputs
			                      .clk	(clk),
			                      .se	(se),
			                      .si	(si),
			                      .rst_ctr_l (rst_itlb_stv_l));


   assign itlb_rd_req_bf = fcl_itlb_data_rd_vld_bf | fcl_itlb_tag_rd_vld_bf | fcl_itlb_csm_rd_vld_bf;

   // tlb access request
   assign itlb_access_gnt = (fcl_itlb_data_rd_vld_bf |
                             fcl_itlb_csm_rd_vld_bf  | 
			                       fcl_itlb_tag_rd_vld_bf  |
//                             tlb_invall_bf & itlb_access_en |
                             tlb_invall_bf |
                             fcl_itlb_dmp_vld_bf);











   dff_s #(1) tlb_gnt1_ff(.din (itlb_access_gnt),
		                  .q   (itlb_access_done),
		                  .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_rd_ff(.din (itlb_rd_req_bf),
		                .q   (itlb_rd_req_f),
		                .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_wrt1_ff(.din (fcl_itlb_wr_vld_bf),
		                    .q   (itlb_write_done),
		                    .clk (clk), .se  (se), .si(), .so());
   

   // TBD:
   // reads need to wait one more cycle.  Others can ack without this
   // second delay.
   assign itlb_rd_access_done = itlb_rd_req_f & itlb_access_done;
   
   dff_s #(1) tlb_rd1_ff(.din (itlb_rd_access_done),
		                  .q   (itlb_rd_access_done_d1),
		                  .clk (clk), .se  (se), .si(), .so());
   dff_s #(1) tlb_rd2_ff(.din (itlb_rd_access_done_d1),
		                   .q   (itlb_rd_access_done_d2),
		                  .clk (clk), .se  (se), .si(), .so());
   assign ifu_tlu_itlb_done = ~itlb_rd_req_f & itlb_access_done |
                               itlb_write_done | 
	                             itlb_rd_access_done_d2;

   assign fcl_erb_itlbrd_vld_s = itlb_rd_access_done_d1;
   
   assign asi_tid_bf = ifq_fcl_asird_bf ? ifq_fcl_asi_tid_bf :
	                                        tlu_idtlb_dmp_thrid_g;
   
   dff_s #(2) asi_tid_reg(.din (asi_tid_bf),
		                  .q   (fcl_erb_asi_tid_f),
		                  .clk (clk), .se(se), .si(), .so());
   
		    
   // Remember if we read tag or data
   dff_s #(1) tlb_rddf_ff(.din (fcl_itlb_data_rd_vld_bf),
		                  .q   (itlb_data_rd_f),
		                  .clk (clk), .se  (se), .si(), .so());

   dff_s #(1) tlb_rdds_ff(.din (itlb_data_rd_f),
		                  .q   (itlb_data_rd_s),
		                  .clk (clk), .se  (se), .si(), .so());

   // pick itlb ldxa data
   assign fcl_erb_itlbrd_data_s =  itlb_data_rd_s;

   // Demap thread
   assign fcl_fdp_dmpthr_l[0] = ~(~tlu_idtlb_dmp_thrid_g[1] & ~tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[1] = ~(~tlu_idtlb_dmp_thrid_g[1] & tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[2] = ~(tlu_idtlb_dmp_thrid_g[1] & ~tlu_idtlb_dmp_thrid_g[0]);
   assign fcl_fdp_dmpthr_l[3] = ~(tlu_idtlb_dmp_thrid_g[1] & tlu_idtlb_dmp_thrid_g[0]);

   // Select appropriate context for TLB
   // ctxt_sel_dmp is itlb_access_en without the asird signal
   assign ctxt_sel_dmp = no_instacc_bf & ~itlb_access_done;
   assign fcl_fdp_ctxt_sel_dmp_bf_l = ~ctxt_sel_dmp;   
   assign fcl_fdp_ctxt_sel_sw_bf_l = ctxt_sel_dmp | ~switch_bf;
   assign fcl_fdp_ctxt_sel_curr_bf_l = ctxt_sel_dmp | switch_bf;
   
   
//--------------------------
// Fetch Request and Stall
//--------------------------
   
   // Determine if we need can continue fetching next cycle
//   assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq) &
//                   (switch_bf |
//                    ~(part_stall_thisthr_f | fdp_fcl_swc_s2));
//                    ~(stall_thisthr_f | fdp_fcl_swc_s2 | immu_fault_f));

   // mmckeown: Added stall due to execution drafting here
   wire esl_stallreq = config_dtu_esl_en & esl_fcl_stall_bf;
   // trin: add stall signal from jtag (debuggin)
   //  going to flop it so the input doesn't affect the logic timing
   //  and the stall signal doesn't have to be precise anyway

// trin
// always @ *
// begin
//    rtap_lsu_ctlbits_wr_en = 0;
//    if (rtap_core_val && rtap_core_id == `JTAG_CORE_ID_LSU_CONTROL_BITS)
//    begin
//       if (rtap_core_threadid == 2'd0)
//          rtap_lsu_ctlbits_wr_en = 4'b0001;
//       else if (rtap_core_threadid == 2'd1)
//          rtap_lsu_ctlbits_wr_en = 4'b0010;
//       else if (rtap_core_threadid == 2'd2)
//          rtap_lsu_ctlbits_wr_en = 4'b0100;
//       else if (rtap_core_threadid == 2'd3)
//          rtap_lsu_ctlbits_wr_en = 4'b1000;
//    end
//    rtap_lsu_ctlbits_data = rtap_core_data[13:0];
// end

   // reg rtap_core_stallreq_f;
   // always @ (posedge rclk)
   // begin
   //    if (!grst_l)
   //       rtap_core_stallreq_f <= 1'b0;
   //    else
   //       rtap_core_stallreq_f <= rtap_core_stallreq;
   // end
   // assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq & ~rtap_core_stallreq_f) &
   //                     (switch_bf |  // replace with ntr_s?
   //                      ~(part_stall_thisthr_f  
   //                        | fdp_fcl_swc_s2
   //                        )
   //                      );
   // assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq) &
   //                     (switch_bf |  // replace with ntr_s?
   //                      ~(part_stall_thisthr_f  
   //                        | fdp_fcl_swc_s2
   //                        )
   //                      );
   // trin note: thankfully this signal is flopped so long latency of
   // other signals doesn't affect it too much

   reg jtag_breakpoint_stall_en;
   wire jtag_breakpoint_stall;

   always @ (posedge clk)
   begin
      if (!fcl_reset_l)
      begin
         jtag_breakpoint_stall_en <= 1'b0;
      end
      else
      begin
         if (rtap_core_val && rtap_core_id == 4'd7)
            jtag_breakpoint_stall_en <= 1'b1;
      end
   end


   assign jtag_breakpoint_stall = fdp_fcl_jtag_breakpoint_hit & jtag_breakpoint_stall_en;

   assign fetch_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & ~esl_stallreq & ~jtag_breakpoint_stall) &
                       (switch_bf |  // replace with ntr_s?
                        ~(part_stall_thisthr_f  
                          | fdp_fcl_swc_s2
                          )
                        );

   // dtu_fcl_running_s should be a part of this eqn, since it is assumed
   // by the ifill completion prediction logic in the swl
//   assign inst_access_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
//                            (switch_bf & ~usen_iso_bf |
//                             ~switch_bf & ~ely_stall_thisthr_f &
//                             dtu_fcl_running_s & 
//                             ~ely_kill_thread_s2 &
//                             //~fdp_fcl_swc_s2 & // take out for tim reasons
//                             ~usep_bf));

   assign ia0_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
                    (switch_bf |
                     ~ely_stall_thisthr_f &
                     dtu_fcl_running_s & 
                     ~ely_kill_thread_s2 &
                     ~usep_bf));

   assign ia1_bf = (~all_stallreq & ~fcl_reset & ~rst_stallreq & 
                    (~switch_bf & ~ely_stall_thisthr_f &
                     dtu_fcl_running_s & 
                     ~ely_kill_thread_s2 &
                     ~usep_bf));
   

   assign inst_access_bf = usen_iso_bf ? ia1_bf : ia0_bf;
   // needs to work even if usen_iso_bf is X - not nec. 11/06/03
//   dp_mux2es #(1) ia_mx(.dout (inst_access_bf),
//                        .in0  (ia0_bf),
//                        .in1  (ia1_bf),
//                        .sel  (usen_iso_bf));
   
   

//   assign allow_ifq_access_icd_bf = (all_stallreq | rs
//                                     ~switch_bf & 
//                                     (usep_bf | stall_f) |
//                                     switch_bf & usen_bf);
   assign allow_ifq_access_icd_bf = ~inst_access_bf;
   
   // earlier version for critical stuff
   assign no_instacc_bf = all_stallreq | fcl_reset | rst_stallreq |
                          ~dtu_fcl_ntr_s & (ely_stall_thisthr_f | usep_bf);
   
   // check if icache is on
   dff_s #(4) ic_en_reg(.din (lsu_ifu_icache_en),
                      .q   (icache_en_d1),
                      .clk (clk), .se(se), .si(), .so());
   
//   assign sw_icache_on = (nextthr_bf_buf[0] & icache_en_d1[0] |
//                          nextthr_bf_buf[1] & icache_en_d1[1] |
//                          nextthr_bf_buf[2] & icache_en_d1[2] |
//                          nextthr_bf_buf[3] & icache_en_d1[3]);
//   assign this_icache_on = (thr_f[0] & icache_en_d1[0] |
//                            thr_f[1] & icache_en_d1[1] |
//                            thr_f[2] & icache_en_d1[2] |
//                            thr_f[3] & icache_en_d1[3]);
//   assign icache_on_bf = switch_bf ? sw_icache_on : this_icache_on;

   assign icache_on_bf = (nextthr_final_bf[0] & icache_en_d1[0] |
                          nextthr_final_bf[1] & icache_en_d1[1] |
                          nextthr_final_bf[2] & icache_en_d1[2] |
                          nextthr_final_bf[3] & icache_en_d1[3]);

   // remember if icache was turned on
   dff_s #(1) icef_ff(.din (icache_on_bf),
		              .q   (icache_on_f),
		              .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ices_ff(.din (icache_on_f),
		              .q   (icache_on_s1),
		              .clk (clk), .se(se), .si(), .so());

   // check if cp is set
   assign uncached_page_s1 = ~itlb_fcl_cp_s1 & cam_vld_s1;
   assign fcl_ifq_icache_en_s_l = ~icache_on_s1 | uncached_page_s1;
   
   // Read from the icache only if 
   //   we need to fetch AND 
   //   the icache is on AND 
   //   we are not using the NIR 
   assign rdreq_bf = icache_on_bf & inst_access_bf;

   assign fcl_icd_rdreq_bf = rdreq_bf | ifq_fcl_rdreq_bf;

   // split off driver to icv to reduce load
   assign fcl_icv_rdreq_bf = rdreq_bf | ifq_fcl_rdreq_bf;
   
   // Read req pipe
   dffr_s #(1)  rdreq_ff(.din  (rdreq_bf),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (rdreq_f),
		                 .se   (se), .si(), .so());
   // Remember if we fetched in the last cycle
   dff_s #(1)  rdreqs1_ff (.din  (rdreq_f),
		                   .clk  (clk),
		                   .q    (rdreq_s1),
		                   .se   (se), .si(), .so());
   assign fcl_ifq_rdreq_s1 = ~stall_s1;

   // Use NIR pipe
   assign usenir_bf = switch_bf ? usen_bf : usep_bf;
   
   dffr_s #(1)  unf_ff(.din  (usenir_bf),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (usenir_f),
		                 .se   (se), .si(), .so());
   // Remember if we fetched in the last cycle
   dff_s #(1)  uns1_ff (.din  (usenir_f),
		                  .clk  (clk),
		                  .q    (usenir_s1),
		                  .se   (se), .si(), .so());


   // Write signal to icache if no access from pipe
   assign ic_wrreq_bf = allow_ifq_access_icd_bf & ifq_fcl_wrreq_bf;

   assign fcl_icd_wrreq_bf = ic_wrreq_bf | ifq_fcl_icd_wrreq_bf;
   assign fcl_ict_wrreq_bf = ic_wrreq_bf | ifq_fcl_ictv_wrreq_bf;
   assign fcl_icv_wrreq_bf = ic_wrreq_bf | ifq_fcl_ictv_wrreq_bf |
                             ifq_fcl_invreq_bf;

   // synopsys translate_off
   always @ (posedge clk)
   begin
	    if (fcl_icd_rdreq_bf & fcl_icd_wrreq_bf)
	      begin
		 // 0in <fire -message "ERROR: sparc_ifu_fcl: rd and wr req to I$ at the same time"

           
			 $display( "CACHE_CONTENTION", "ERROR: sparc_ifu_fcl: rd and wr req to I$ at the same time");
             $finish();

	      end
   end
   // synopsys translate_on
   

   //-------------------------
   // Valid Instruction Pipe
   //-------------------------
   // F stage
   assign inst_vld_bf = fetch_bf;
   dff_s #(1) inst_vld_ff(.din (inst_vld_bf),
		                  .clk (clk),
		                  .q   (inst_vld_f),
		                  .se  (se), .si(), .so());

   assign stall_f = ~inst_vld_f | kill_curr_f;
   assign stall_thisthr_f = stall_f | imsto_thisthr_s1 | // intrto_thisthr_d |
	                          kill_thread_s2 | rb_stg_s | ~dtu_fcl_running_s | 
                            iferrto_thisthr_d1;

   // mmckeown: stall signal ignoring whether there is a valid instruction in F
   wire stall_ed_s2 = kill_curr_f | imsto_thisthr_s1 | kill_thread_s2 |
                      rb_stg_s | ~dtu_fcl_running_s | iferrto_thisthr_d1;

   assign part_stall_thisthr_f = stall_f | 
                                 imsto_thisthr_s1 |
                                 ~dtu_fcl_running_s | 
                                 ely_kill_thread_s2 |
	                               rb_stg_s;
   
   assign ely_stall_thisthr_f = stall_f | rb_stg_s;
   
   // mmckeown: pipe forward next thread ready in s stage to determine
   //           if thread is ready for ED in S2
   dff_s #(1) inst_vld_s2_ed_f (.din (esl_fcl_force_running_s),
                              .clk (clk),
                              .q (inst_vld_s2_ed),
                              .se (se), .si (), .so ());   

//   assign stall_s1_nxt = stall_thisthr_f | intr_vld_s | tmsto_thisthr_f;
   assign stall_s1_nxt = stall_thisthr_f; //| intr_vld_s;
   
   // S1 stage
   dff_s #(1) stalld_ff(.din (stall_s1_nxt),
		                  .clk (clk),
		                  .q   (stall_s1),
		                  .se  (se), .si(), .so());

   assign inst_vld_s1 = ~stall_s1 & ~ic_miss_s1 & ~kill_curr_d;
   assign val_thr_s1 = thr_s1 & {4{inst_vld_s1}}; // 4b

   // S2 stage
   assign val_thr_f = thr_f & {4{~stall_f & ~rb_stg_s & dtu_fcl_running_s}};
   // mmckeown: Need to add this signal to kill instructions in TIRs when
   //           converged so that they don't get executed when we fall
   //           out of being converged
   wire [3:0] val_thr_s2_ed = thr_f & {4{config_dtu_esl_en & esl_fdp_issue_prev_inst_s}};

   // Tag the S stage thr inst register as containing a valid inst or not
   assign tinst_vld_nxt = (ifq_fcl_fill_thr |  
                           (rb_w2 & ~rb_for_iferr_e) | // set
                                 // mmckeown: This will invalidate
                                 // instructions when drafting
			                     val_thr_s1 & ~(val_thr_f | val_thr_s2_ed) |
                           //			   val_thr_s1 |
			                     tinst_vld_s & ~(val_thr_f | val_thr_s2_ed)) &
			                      ~(clear_s_d1 |
                              {4{erb_dtu_ifeterr_d1 & inst_vld_d1 & 
                                 ~rb_stg_e}} & thr_e);   // reset

   dffr_s #(4) tinst_reg(.din  (tinst_vld_nxt),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .q    (tinst_vld_s),
		                 .se   (se), .si(), .so());
   assign fcl_esl_tinst_vld_next_s = tinst_vld_nxt;

   // Does current thread have valid inst in s2
   // mmckeown: Valid instruction is s2 if we are drafting. This would
   //           not be high when we are drafting otherwise
   assign inst_vld_s2 = ((thr_f_crit & (tinst_vld_s | val_thr_s2_ed)) == 4'b0000) ?
			                    {1'b0} :  {1'b1};          

   assign inst_vld_s = ~switch_s2 & inst_vld_s1 | 
	                      switch_s2 & inst_vld_s2;
   // mmckeown: For instruction in S to be valid, we should have said
   //           so from execution drafting logic
   assign inst_vld_s_crit = ~switch_s2 & ~stall_s1 & ~kill_curr_d | 
	                      switch_s2 & inst_vld_s2;

   assign valid_s = inst_vld_s & ~stall_f &  // f and s2 have same thread
                       dtu_fcl_running_s &
	                     ~(ely_kill_thread_s2 | rb_stg_s);

   // mmckeown: S2 needs to be running if we are replaying something
   //           when converged
   // BUG FIX: Instruction in D needs to be valid when a immu fault (page
   // fault) occurs, so we have to add immu_fault_f into this signal
   assign running_s2 = (inst_vld_s & ~stall_thisthr_f) || 
                       (config_dtu_esl_en && (inst_vld_s2_ed || immu_fault_f) && ~stall_ed_s2);
   
   // D stage
   dff_s #(1) rund_ff(.din (running_s2),
		              .clk (clk),
		              .q   (inst_vld_d),
		              .se  (se), .si(), .so());
   dff_s #(1) eivd_ff(.din (running_s2),
		                .clk (clk),
		                .q   (inst_vld_d_crit),
		                .se  (se), .si(), .so());
   assign fcl_erb_inst_issue_d = inst_vld_d & ~intr_vld_d;
   assign running_d = inst_vld_d & ~kill_thread_d & ~rb_stg_d & 
	                    ~intr_vld_d;
   assign fcl_esl_inst_vld_d = running_d;

   // E stage
   dff_s #(1) rune_ff(.din (running_d),
		              .clk (clk),
		              .q   (inst_vld_e),
		              .se  (se), .si(), .so());

   assign running_e = inst_vld_e & ~dtu_inst_anull_e & 
	                    ~kill_curr_e & ~rb_stg_e &
                      ~(thr_match_em & ifu_tlu_flush_m);
   assign fcl_esl_inst_vld_e = running_e;                   
   assign inst_vld_qual_e = inst_vld_e & ~rb_stg_e;
   assign val_thr_e = thr_e_v2 & {4{inst_vld_qual_e}} & ~late_flush_w2 &
                      ~(thr_w & {4{utrap_flush_w}});
   
   
   // M stage
   dff_s #(1) runm_ff(.din (running_e),
		              .clk (clk),
		              .q   (inst_vld_m),
		              .se  (se), .si(), .so());
   assign running_m = (inst_vld_m | intr_vld_m) & ~kill_thread_m;
   assign fcl_esl_inst_vld_m = running_m;
   
   assign ifu_tlu_inst_vld_m = (inst_vld_m | intr_vld_m) & ~kill_curr_m;
   // less critical
   // assign ifu_lsu_inst_vld_m = ifu_tlu_inst_vld_m;
   
   // W stage
   dff_s #(1) runw_ff(.din (running_m),
		              .q   (inst_vld_w),
		              .clk (clk), .se  (se), .si(), .so());   

   dff_s #(1) iw_ff(.din (running_m),
		              .q   (inst_vld_w_crit),
		              .clk (clk), .se  (se), .si(), .so());   
   
   // synopsys translate_off
//   wire         sas_m,
//		            inst_done_w_for_sas;
   
//   assign sas_m = inst_vld_m & ~kill_thread_m & 
//	                ~(exu_ifu_ecc_ce_m & inst_vld_m & ~trap_m);

//   dff #(1) sasw_ff(.din (sas_m),
//		              .clk (clk),
//		              .q   (inst_done_w_for_sas),
//		              .se  (se), .si(), .so());   
   // synopsys translate_on

   // need to kill branch by E stage, so qual with rb_stg_X
   assign fcl_dtu_inst_vld_e = inst_vld_e & ~rb_stg_e & ~kill_curr_e;
   assign fcl_dtu_intr_vld_e = intr_vld_e & ~rb_stg_e & ~kill_curr_e;
   assign fcl_dtu_inst_vld_d = inst_vld_d & ~kill_curr_d &
	                             ~rb_stg_d_crit & ~immu_miss_crit_d;
   assign fcl_dtu_ely_inst_vld_d = inst_vld_d_crit;
   assign ifu_tlu_inst_vld_w = inst_vld_w;
   assign ifu_exu_inst_vld_w = inst_vld_w_crit;
   assign ifu_spu_inst_vld_w = inst_vld_w;
   assign ifu_exu_inst_vld_e = fcl_dtu_inst_vld_e;
   
   assign flush_sonly_qual_e = dtu_fcl_flush_sonly_e & inst_vld_e &
//                               ~dec_fcl_kill4sta_e &
                               ~rb_stg_e & ~dtu_inst_anull_e & ~kill_curr_e;
   

   dff_s #(1) flshm_ff(.din (flush_sonly_qual_e),
                     .q   (flush_sonly_m),
                     .clk (clk),
                     .se  (se), .si(), .so());

   dff_s #(1) imflshm_ff(.din (ifq_fcl_flush_sonly_e),
                       .q   (ims_flush_sonly_m),
                       .clk (clk),
                       .se  (se), .si(), .so());
   // detect collision between two different types of retractions
   assign ims_flush_coll_m = ims_flush_sonly_m & ~canthr_sm & 
                             retract_iferr_e;
   dff_s #(1) imflshw_ff(.din (ims_flush_coll_m),
                       .q   (ims_flush_sonly_w),
                       .clk (clk),
                       .se  (se), .si(), .so());
   assign ims_flush_coll_w = ims_flush_sonly_w & ~canthr_sw;
   assign flush_sonly_qual_m = (ims_flush_sonly_m & ~canthr_sm & 
                                ~retract_iferr_e |
                                flush_sonly_m & inst_vld_m & ~kill_local_m &
                                ~kill_curr_m);
   assign flush_sonly_all_m = (ims_flush_sonly_m & ~canthr_sm | 
                               flush_sonly_m & inst_vld_m);

//   assign flush_sonly_qual_m = flush_sonly_m & ~canthr_sm;
//   assign qtrap_flush_e = dtu_fcl_qtrap_e & inst_vld_e & ~dtu_inst_anull_e & 
//	                  ~rb_stg_e;
   
//------------------------------   
// Instruction Kill Logic
//------------------------------
   
   // kill_s2 is the same as kill_f
   assign kill_thread_s2 = thr_match_fw & rb_stg_w |
//	                         thr_match_ft & trappc_vld_w2 |
	                         thr_match_fm & (flush_sonly_all_m) |
                           kill_curr_f;
   
   assign ely_kill_thread_s2 = thr_match_fw & utrap_flush_w |
//	                             thr_match_ft & trappc_vld_w2 |
	                             thr_match_fm & (flush_sonly_all_m) |
                               kill_curr_f;
   
   assign kill_thread_d = thr_match_dw & rb_stg_w |
	                        thr_match_dm & (flush_sonly_all_m) |
                          kill_curr_d;

   // M and E still need full qualification with flush pipe   
//   assign kill_thread_e = thr_match_ew & utrap_flush_w | 
//                          thr_match_ew & tlu_ifu_flush_pipe_w | 
//                          kill_curr_e ;
   assign ely_kill_thread_m = thr_match_mw & utrap_flush_w |
//                              mark4rb_m |
                              kill_curr_m;
   assign kill_thread_m = ely_kill_thread_m | 
                          thr_match_mw & tlu_ifu_flush_pipe_w;
   
   assign kill_local_m = thr_match_mw & (utrap_flush_w | intr_vld_w);

   assign flush_pipe_w = rb_stg_w | tlu_ifu_flush_pipe_w;
//   assign part_flush_w = ifu_tlu_flush_w | tlu_ifu_flush_pipe_w;
//   assign kill_nextthr_w = thr_match_nw & flush_pipe_w;
   assign flush_thr_w = thr_w & {4{flush_pipe_w}};
   dff_s #(1) fp_ff(.din (flush_pipe_w),
                  .q   (flush_pipe_w2),
                  .clk (clk), .se(se), .si(), .so());

//   assign clear_s_stage =  thr_e & {4{flush_sonly_qual_e}};
//   assign clear_s_stage =  trap_thr & {4{trappc_vld_w2}} |
//	                         {4{dummy_flush_ireg}} | 
//	                         thr_e & {4{flush_sonly_qual_e}};
                           //  | flush_thr_w 

   assign canthr_f = thr_e & {4{flush_sonly_qual_e}} | 
                     (rb_w2 & ~rb_for_iferr_e) | rb_froms;

//   dff #(4) cls_reg(.din (clear_s_stage),
//		                .q   (clear_s_early),
//		                .clk (clk), .se(se), .si(), .so());

   // ***NOTE***
   // Don't use clear_s_d1 to generate fcl_ifq_canthr, since clear_s_d1 
   // includes ifeterr!
   // first term could be just flush_sonly_m & inst_vld_m & thr_m
   assign clear_s_d1 = thr_m & {4{flush_sonly_all_m}} |
                       late_flush_w2 | 
                       trap_thr & {4{trappc_vld_w2}};

   assign fcl_erb_clear_iferr = thr_m & {4{ims_flush_sonly_m | 
                                           flush_sonly_m}} |
                                late_flush_w2 | 
                                trap_thr & {4{trappc_vld_w2}};


   dff_s #(4) cm_reg(.din (canthr_f),
		               .q   (canthr_s_early),
		               .clk (clk),
		               .se  (se), .si(), .so());

   assign canthr_s = canthr_s_early | late_flush_w2 | 
                     trap_thr & {4{trappc_vld_w2}};          
   
//   assign fcl_ifq_canthr = clear_s_stage | rb_w2 | rb_froms | 
//	                         canthr_s;
   assign fcl_ifq_canthr = canthr_s;

   assign canthr_sm = (canthr_s[0] & thr_m[0] | 
                       canthr_s[1] & thr_m[1] | 
                       canthr_s[2] & thr_m[2] | 
                       canthr_s[3] & thr_m[3]);

   assign canthr_sw = (canthr_s[0] & thr_w[0] | 
                       canthr_s[1] & thr_w[1] | 
                       canthr_s[2] & thr_w[2] | 
                       canthr_s[3] & thr_w[3]);

   assign canthr_sd = (canthr_s[0] & thr_d[0] | 
                       canthr_s[1] & thr_d[1] | 
                       canthr_s[2] & thr_d[2] | 
                       canthr_s[3] & thr_d[3]) |
                        thr_match_dw & utrap_flush_w;

   dff_s #(4) fpw2_reg(.din (flush_thr_w),
                     .q   (late_flush_w2),
                     .clk (clk), .se(se), .si(), .so());

//   assign late_flush_w2 = thr_w2 & {4{flush_pipe_w2}};
   
   assign kill_curr_f = (thr_f_crit[0] & late_flush_w2[0] |
                         thr_f_crit[1] & late_flush_w2[1] |
                         thr_f_crit[2] & late_flush_w2[2] |
                         thr_f_crit[3] & late_flush_w2[3]);
   assign kill_curr_d = (thr_d[0] & late_flush_w2[0] |
                         thr_d[1] & late_flush_w2[1] |
                         thr_d[2] & late_flush_w2[2] |
                         thr_d[3] & late_flush_w2[3]);
   assign kill_curr_e = (thr_e_v2[0] & late_flush_w2[0] |
                         thr_e_v2[1] & late_flush_w2[1] |
                         thr_e_v2[2] & late_flush_w2[2] |
                         thr_e_v2[3] & late_flush_w2[3]) |
                          thr_match_ew & utrap_flush_w;
   
//   assign kill_curr_m = (thr_m[0] & late_flush_w2[0] |
//                         thr_m[1] & late_flush_w2[1] |
//                         thr_m[2] & late_flush_w2[2] |
//                         thr_m[3] & late_flush_w2[3]);
   assign kill_curr_m = same_thr_mw2 & flush_pipe_w2;
   
   //------------------------------
   // track I$ misses
   //------------------------------
   
   // force a miss if a fetch and icache is off
   // forcemiss triggers a fill vld_grequest to L2, so set to zero by default
   assign forcemiss_f = inst_vld_f & ~icache_on_f;
   dffr_s #(1)  miss_ff(.din (forcemiss_f),
		                  .clk (clk),
		                  .rst (fcl_reset),
		                  .q   (forcemiss_s1),
		                  .se  (se), .si(), .so());

   //ooooooooooooooooooooooooooooooooooooooooooooooooooooooo
   // removed imiss_s_l from this signal for timing fix  
   // Perf Hit: 0.2% TPCC, 0.4% JBB
//   assign ic_miss_sw_s1 = (~itlb_fcl_imiss_s_l & rdreq_s1 |
//                             tlb_cam_miss_s1 | 
//                             forcemiss_s1);
//   assign ic_miss_sw_s1 =   tlb_cam_miss_s1 | 
//                            forcemiss_s1;
   //ooooooooooooooooooooooooooooooooooooooooooooooooooooooo
   
   assign ic_miss_s1 =  (~itlb_fcl_imiss_s_l & rdreq_s1 |
			                   forcemiss_s1) & 
                        ~stall_s1 & ~tlbmiss_s1_crit & ~pc_oor_s1 & 
                        ~rb_stg_d_crit & ~canthr_sd;

   assign icmiss_for_perf =  (~itlb_fcl_imiss_s_l & rdreq_s1) & 
                        ~stall_s1 & ~tlbmiss_s1_crit & ~pc_oor_s1 & 
                        ~rb_stg_d & ~canthr_sd;

//   assign fcl_ifq_icmiss_s1 = ic_miss_s1 & ~ely_kill_thread_d;  // use buffer
   assign fcl_ifq_icmiss_s1 = ic_miss_s1;  // use buffer   

   // for perf counters (d1=e)
   dff_s #(1) icmd1_ff(.din (icmiss_for_perf),
                     .q   (ifu_tlu_icmiss_e),
                     .clk (clk), .se(se), .si(), .so());
   
   // I$ miss is always to thr_s1.  Below we check to see if this is
   // the same as thr_f (=thr_s2) which is the "current thread"
//   assign imsto_thisthr_s1 = thr_match_fd & ic_miss_s1;
//   assign imsto_nextthr_s1 = thr_match_nd & (ic_miss_s1 | tlbmiss_s1);

   assign imsto_thisthr_s1 = thr_match_fd & ic_miss_s1;
//   assign imsto_nextthr_s1 = thr_match_nd & (ic_miss_sw_s1);
//   assign intrto_thisthr_d = thr_match_fd & fcl_dtu_sync_intr_d;

   assign iferrto_thisthr_d1 = thr_match_fe & erb_dtu_ifeterr_d1 & 
                               inst_vld_d1;
   

//------------------------------
// track itlb misses
//------------------------------

   // default to hit when camming is turned off
   assign tlb_cam_miss_f = ~itlb_fcl_tlbmiss_f_l & cam_vld_f;
   dff_s #(1) tlbmsf_ff(.din (tlb_cam_miss_f),
		                  .clk (clk),
		                  .q   (tlb_cam_miss_s1),
		                  .se  (se), .si(), .so());
   
   // mmckeown: Need to draft the tlbmiss bit as well
   // when we repeat instruction for follower thread
   wire [3:0] tlbmiss_s2_bf_exec_draft;

   // tlb miss logic
   // va hole has higher priority than immu miss
   assign tlbmiss_s2_bf_exec_draft = (({4{tlbmiss_s1 & ~pc_oor_s1 & ~rb_stg_d}} & thr_s1) |
			                  ({4{erb_fcl_itlb_ce_d1 & inst_vld_d1 & 
                            ~rb_stg_e}} & thr_e &
			                   (~thr_d | {4{~inst_vld_d | ~thr_match_de}})) |
			                  ({4{immu_miss_e}} & rb_frome) |
			                  ({4{immu_miss_d}} & rb_fromd & ~rb_frome) |  // set
			                  tlbmiss_d & (~thr_d | {4{~inst_vld_d}}) & ~rb_w2) & 
			                 ~(clear_s_d1); // reset

   // always pass through thread 0
   assign tlbmiss_s2[0] = tlbmiss_s2_bf_exec_draft[0];

   // need to draft the tlbmiss bit in case thread0 had a tlb miss
   wire exec_draft_replay_tlbmiss_mux_sel = config_dtu_esl_en ? esl_fdp_issue_prev_inst_s : 1'b0;
   dp_mux2es  #(3)  exec_draft_replay_tlbmiss_mux (.dout (tlbmiss_s2[3:1]),
                                                   .in0 (tlbmiss_s2_bf_exec_draft[3:1]),
                                                   .in1 ({3{immu_miss_d}} & thr_f[3:1]),
                                                   .sel(exec_draft_replay_tlbmiss_mux_sel));

//   assign tlbmiss_s2 = (({4{tlbmiss_s1 & ~pc_oor_s1 & ~rb_stg_d}} & thr_s1) |
//			({4{erb_fcl_itlb_ce_d1 & inst_vld_qual_d1}} & thr_e |
//			 tlbmiss_d & (~thr_e | {4{~inst_vld_qual_e}}) & 
//			 ~rb_w2) & ~(clear_s_stage); // reset

   dffr_s #(4) tlbmiss_reg(.din (tlbmiss_s2),
		                     .q   (tlbmiss_d),
		                     .clk (clk),
		                     .rst (fcl_reset),
		                     .se  (se), .si(), .so());

   assign immu_fault_f = (thr_f_crit[0] & (tlbmiss_d[0] | inst_acc_vec_d[0]) |
			                    thr_f_crit[1] & (tlbmiss_d[1] | inst_acc_vec_d[1]) |
			                    thr_f_crit[2] & (tlbmiss_d[2] | inst_acc_vec_d[2]) |
			                    thr_f_crit[3] & (tlbmiss_d[3] | inst_acc_vec_d[3])) &
                           switch_s2|  
			                     // D stage miss
			                     (tlbmiss_s1 | pc_oor_s1) & thr_match_fs1;
	                         // S stage miss

   assign immu_miss_crit_d = (thr_d[0] & tlbmiss_d[0] |
			                        thr_d[1] & tlbmiss_d[1] |
			                        thr_d[2] & tlbmiss_d[2] |
			                        thr_d[3] & tlbmiss_d[3]);
   
   // TBD: move this to the E stage, post RB
   assign immu_miss_d = immu_miss_crit_d & inst_vld_d | 
			                  thr_match_de & erb_fcl_itlb_ce_d1 & inst_vld_d1;

   // don't need to do this, once everyone switches to immu_miss_m
   assign immu_miss_qual_d = immu_miss_d & ~kill_thread_d &
	                            ~(immu_miss_e & thr_match_de & 
                                inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e &
                                ~kill_curr_e);
   
   dff_s immu_misse_ff(.din (immu_miss_qual_d),
		                 .clk (clk),
		                 .q   (immu_miss_e),
		                 .se  (se), .si(), .so());

   
   // flop this and send in M
//   assign ifu_tlu_immu_miss_e = immu_miss_e & ~addr_real_e & 
//                                inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e;
//   assign ifu_tlu_immu_miss_e = 1'b0;
   
//   assign immu_miss_qual_e = immu_miss_e & //~addr_real_e & 
// //                             ~(immu_miss_m & thr_match_em) &
//                             inst_vld_e & ~dtu_inst_anull_e & ~rb_stg_e;

//   dff #(1) immu_msm_ff(.din (immu_miss_qual_e),
   dff_s #(1) immu_msm_ff(.din (immu_miss_e),
                        .q   (immu_miss_m),
                        .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_immu_miss_m = immu_miss_m & inst_vld_m & ~kill_curr_m;

   assign addr_real_e = (itlb_addr_real[0] & thr_e[0] |
                         itlb_addr_real[1] & thr_e[1] |
                         itlb_addr_real[2] & thr_e[2] |
                         itlb_addr_real[3] & thr_e[3]);

   // store tlbmiss state for NIR
   assign nir_tlbmiss_next = ({4{tlb_cam_miss_s1 & ~stall_s1}} & thr_s1 |
			                        nir_tlbmiss_vec & (~thr_s1 | {4{stall_s1}}));

   dffr_s #(4) nirtlbm_reg(.din (nir_tlbmiss_next),
		                   .clk (clk),
		                   .q   (nir_tlbmiss_vec),
		                   .rst (fcl_reset),
		                   .se  (se), .si(), .so());

   assign nir_tlbmiss_s1 = (nir_tlbmiss_vec[0] & thr_s1[0] |
			                      nir_tlbmiss_vec[1] & thr_s1[1] |
			                      nir_tlbmiss_vec[2] & thr_s1[2] |
			                      nir_tlbmiss_vec[3] & thr_s1[3]);

   assign tlbmiss_s1_crit = ~usenir_s1 ? tlb_cam_miss_s1 :
	                                       nir_tlbmiss_s1;

   assign tlbmiss_s1 = tlbmiss_s1_crit & ~stall_s1;
   
   assign fcl_fdp_tlbmiss_s1 = tlbmiss_s1;

//---------------------------------
//  Privilege Mode and VA Hole
//---------------------------------
   assign addr_mask_32b_m = (thr_m[0] & pstate_am_d1[0] |
			                       thr_m[1] & pstate_am_d1[1] |
			                       thr_m[2] & pstate_am_d1[2] |
			                       thr_m[3] & pstate_am_d1[3]);
   
   assign fcl_fdp_mask32b_f = (thr_f[0] & pstate_am_d1[0] |
			                         thr_f[1] & pstate_am_d1[1] |
			                         thr_f[2] & pstate_am_d1[2] |
			                         thr_f[3] & pstate_am_d1[3]);

   dff_s #(1) amd_ff(.din (fcl_fdp_mask32b_f),
		               .q   (fcl_fdp_addr_mask_d),
		               .clk (clk), .se(se), .si(), .so());

   // keep track of whether pc is outside va hole
   assign set_oor_m = exu_ifu_va_oor_m & brtaken_m & ~addr_mask_32b_m;
   assign fcl_fdp_pcoor_vec_f = fdp_fcl_pc_oor_vec_f | {4{set_oor_m}} & thr_m;
   
   assign fcl_fdp_pcoor_f =  (thr_f[0] & fcl_fdp_pcoor_vec_f[0] |
			                        thr_f[1] & fcl_fdp_pcoor_vec_f[1] |
			                        thr_f[2] & fcl_fdp_pcoor_vec_f[2] |
			                        thr_f[3] & fcl_fdp_pcoor_vec_f[3]);
   
   assign pc_oor_f = fcl_fdp_pcoor_f  & ~part_stall_thisthr_f;
   dff_s oors1_ff(.din (pc_oor_f),
		            .q   (pc_oor_s1),
		            .clk (clk), .se(se), .si(), .so());

   // track privilege mode of current page
   assign priv_mode_f = (thr_f[0] & tlu_lsu_pstate_priv[0] |
			                   thr_f[1] & tlu_lsu_pstate_priv[1] |
			                   thr_f[2] & tlu_lsu_pstate_priv[2] |
			                   thr_f[3] & tlu_lsu_pstate_priv[3]);

   dff_s #(1) priv_ff(.din (priv_mode_f),
                    .q   (priv_mode_s1),
                    .clk (clk), .se(se), .si(), .so());
   
   // s1 and d are the same thread
   assign fcl_dtu_privmode_d = priv_mode_s1;

   // hyper privilege
   assign hpriv_mode_f = (thr_f[0] & tlu_hpstate_priv[0] |
			                    thr_f[1] & tlu_hpstate_priv[1] |
			                    thr_f[2] & tlu_hpstate_priv[2] |
			                    thr_f[3] & tlu_hpstate_priv[3]);

   assign hpriv_mode_w = (thr_w[0] & tlu_hpstate_priv[0] |
			                    thr_w[1] & tlu_hpstate_priv[1] |
			                    thr_w[2] & tlu_hpstate_priv[2] |
			                    thr_w[3] & tlu_hpstate_priv[3]);
   
   dff_s #(1) hprivd_ff(.din (hpriv_mode_f),
                     .q   (hpriv_mode_s1),
                     .clk (clk), .se(se), .si(), .so());

   assign fcl_dtu_hprivmode_d = hpriv_mode_s1;

   dff_s #(1) hprivw2_ff(.din (hpriv_mode_w),
                     .q   (hpriv_mode_w2),
                     .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_hprivmode_w2 = hpriv_mode_w2;

   // determine if priv page has been accessed in non priv mode
   // or if we have fallen into the VA hole
   assign inst_acc_exc_s1 = (priv_inst_s1 & ~(priv_mode_s1 | hpriv_mode_s1) & 
			                       ~tlbmiss_s1_crit & cam_vld_s1 | 
			                       pc_oor_s1) & ~stall_s1 & ~rb_stg_d;
   assign pc_oor_s2 = (thr_f[0] & inst_acc_vec_d[0] |
                       thr_f[1] & inst_acc_vec_d[1] |
                       thr_f[2] & inst_acc_vec_d[2] |
                       thr_f[3] & inst_acc_vec_d[3]);
   assign pc_oor_s = (tm_fd_l) ? pc_oor_s2 : pc_oor_s1;
      
   assign inst_acc_vec_s2 = (({4{inst_acc_exc_s1}} & thr_s1) |
			                       ({4{inst_acc_exc_e}} & rb_frome) |
			                       ({4{inst_acc_exc_d}} & rb_fromd & ~rb_frome) |
	                           inst_acc_vec_d & (~thr_d | {4{~inst_vld_d}}) & 
			                       ~rb_w2) &
			                        ~(clear_s_d1);
	 
   dffr_s #(4) instaccd_reg(.din (inst_acc_vec_s2),
			                  .q   (inst_acc_vec_d),
			                  .rst (fcl_reset),
			                  .clk (clk), .se (se), .si(), .so());

   assign inst_acc_exc_d = (thr_d[0] & inst_acc_vec_d[0] |
			                      thr_d[1] & inst_acc_vec_d[1] |
			                      thr_d[2] & inst_acc_vec_d[2] |
			                      thr_d[3] & inst_acc_vec_d[3]);

   dff_s #(1) instacce_ff(.din (inst_acc_exc_d),
		                  .q   (inst_acc_exc_e),
		                  .clk (clk), .se(se), .si(), .so());

   // TLU needs to know if this is a priv violtn
   assign priv_violtn_e = inst_acc_exc_e & ~fdp_fcl_pc_oor_e;
   dff_s #(1) privm_ff(.din (priv_violtn_e),
		               .q   (priv_violtn_m),
		               .clk (clk),  .se  (se), .si(), .so());

   assign ifu_tlu_priv_violtn_m = priv_violtn_m & inst_vld_m & ~kill_curr_m;
   
   // NIR privilege bit
   assign next_nir_privvec = {4{itlb_fcl_priv_s1 & ~stall_s1 & 
                                cam_vld_s1}} & thr_s1 |
	                           nir_privvec & (~thr_s1 | {4{stall_s1}});

   dffr_s #(4) nir_priv_reg(.din (next_nir_privvec),
			                  .q   (nir_privvec),
			                  .rst (fcl_reset),
			                  .clk (clk), .se(se), .si(), .so());
   
   assign nir_priv_s1 = (nir_privvec[0] & thr_s1[0] |
			                   nir_privvec[1] & thr_s1[1] |
			                   nir_privvec[2] & thr_s1[2] |
			                   nir_privvec[3] & thr_s1[3]);
   
   assign priv_inst_s1 = ~usenir_s1 ? (itlb_fcl_priv_s1 & cam_vld_s1) : 
                                        nir_priv_s1;

//-------------------------
// Errors
//-------------------------

   // decide when the errors are valid
   assign running_s1 = ~stall_s1 & ~kill_thread_d & ~rb_stg_d & ~pc_oor_s1 &
	                     ~tlb_cam_miss_s1 & ~retract_inst_d;
//   assign ely_running_s1 = ~stall_s1 & ~rb_stg_d & ~pc_oor_s1 & 
//                           ~tlb_cam_miss_s1 & ~retract_inst_d & ~kill_curr_d;
   assign ely_running_s1 = ~stall_s1 & ~rb_stg_d_crit & ~pc_oor_s1 & 
                           ~tlb_cam_miss_s1 & ~kill_curr_d;
   assign fcl_erb_ievld_s1 = ely_running_s1 & rdreq_s1 & itlb_fcl_imiss_s_l;
   assign fcl_erb_tevld_s1 = ely_running_s1 & rdreq_s1;

   assign fcl_erb_immuevld_s1 = ely_running_s1 & cam_vld_s1;

//   assign fcl_erb_ttevld_s1 = asird_s & rdtag_s;
//   assign fcl_erb_tdevld_s1 = asird_s & ~rdtag_s;
   
   dff_s #(1) d1vld_ff(.din (running_s1),
		                 .q   (inst_vld_d1),
		                 .clk (clk), .se(se), .si(), .so());
//   assign inst_vld_qual_d1 = inst_vld_d1 & ~kill_thread_e & 
//	                           ~flush_sonly_qual_e & ~rb_stg_e;
   assign fcl_erb_inst_vld_d1 = inst_vld_d1;
   

   // ifetch unc. error
   assign ifet_ue_vec_d1 = (erb_fcl_ifet_uevec_d1 |
	                          ifet_ue_vec_e & ~val_thr_e) &   // reset
			                       ~(clear_s_d1);                 // wins

   dffr_s #(4) ifuerr_reg(.din (ifet_ue_vec_d1),
		                  .q   (ifet_ue_vec_e),
		                  .rst (fcl_reset),
		                  .clk (clk), .se(se), .si(), .so());

   assign ifet_ue_e = (ifet_ue_vec_e[0] & thr_e[0] | 
		                   ifet_ue_vec_e[1] & thr_e[1] | 
		                   ifet_ue_vec_e[2] & thr_e[2] | 
		                   ifet_ue_vec_e[3] & thr_e[3]);


//----------------------
// Other I side traps
//----------------------
   // Determine if we are in Trap Level 0
   assign tlzero_s2 = (thr_f[0] & tlzero_vec_d1[0] |
		                   thr_f[1] & tlzero_vec_d1[1] |
		                   thr_f[2] & tlzero_vec_d1[2] |
		                   thr_f[3] & tlzero_vec_d1[3]);
   dff_s #(1) tlzd_ff(.din (tlzero_s2),
		              .q   (fcl_dtu_tlzero_d),
		              .clk (clk), .se(se), .si(), .so());

   // Collect all IFU traps
   assign trap_e = (immu_miss_e | inst_acc_exc_e | dtu_fcl_illinst_e |
		                dtu_fcl_fpdis_e | dtu_fcl_privop_e | ifet_ue_e |
		                dtu_fcl_imask_hit_e | dtu_fcl_sir_inst_e) & 
                     inst_vld_e;

   dff_s trapm_ff(.din (trap_e),
		            .q   (trap_m),
		            .clk (clk),
		            .se  (se), .si(), .so());

   assign no_iftrap_m = ~ifu_tlu_ttype_vld_m;
   dff_s trapw_ff(.din (no_iftrap_m),
		            .q   (no_iftrap_w),
		            .clk (clk),
		            .se  (se), .si(), .so());
   
   // south is very critical
   assign ifu_tlu_ttype_vld_m = (trap_m & inst_vld_m | 
                                 disr_trap_m) & ~kill_curr_m & ~kill_local_m;
   // less critical going east
   assign ifu_exu_ttype_vld_m = trap_m & inst_vld_m;

   // less critical going southwest
   assign ifu_mmu_trap_m = trap_m;

   // less critical going south   
   assign ifu_tlu_trap_m = trap_m;
   
   // trap type priority encode
   // Decreasing priority is
   //   pc out of range           i_acc_exc
   //   immu parity error         i_acc_err
   //   immu miss                 i_acc_mmu_ms
   //   icache/tag parity error   i_acc_err
   //   privilege page            i_acc_exc
   //   privilege opcode          priv_opc
   //   illegal non-fp inst       ill_inst
   //   soft reset                sir
   //   fp disabled               fp_disabled
   //   illegal fp instruction    ill_inst

   // Clean this up!!
   assign ttype_sel_spuma_e = spuint1_qual_e;
   assign ttype_sel_spuenc_e = spuint0_qual_e;
   assign ttype_sel_corr_err_e = ceint_qual_e;
   assign ttype_sel_unc_err_e = ueint_qual_e;
   assign ttype_sel_res_err_e = rerr_qual_e;
   assign ttype_sel_hstk_cmp_e = hintp_qual_e;
   
   assign ttype_sel_pcoor_e = fdp_fcl_pc_oor_e & inst_acc_exc_e;
   assign ttype_sel_icache_err_e = ifet_ue_e; 
   assign ttype_sel_immu_miss_e = ~fdp_fcl_pc_oor_e & immu_miss_e & 
                                  ~addr_real_e;
   assign ttype_sel_real_trans_e = ~fdp_fcl_pc_oor_e & immu_miss_e & 
                                   addr_real_e;    
   assign ttype_sel_priv_viol_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                           inst_acc_exc_e;
   assign ttype_sel_ibe_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                        ~inst_acc_exc_e & dtu_fcl_imask_hit_e;
   assign ttype_sel_privop_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                       ~inst_acc_exc_e & dtu_fcl_privop_e;
   assign ttype_sel_illinst_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                        ~inst_acc_exc_e & dtu_fcl_illinst_e;
   assign ttype_sel_sir_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                    ~inst_acc_exc_e & ~dtu_fcl_illinst_e &
	                     dtu_fcl_sir_inst_e;
   
   assign ttype_sel_fpdis_e = ~fdp_fcl_pc_oor_e & ~immu_miss_e & 
	                      ~inst_acc_exc_e & ~dtu_fcl_illinst_e &
	                       dtu_fcl_fpdis_e;

   // mux in the trap type
   assign ttype_e[8:0] = ttype_sel_unc_err_e    ? 9'h078  :
                   ttype_sel_hstk_cmp_e   ? 9'h05e    :
	                 ttype_sel_spuma_e      ? 9'h074     :
	                 ttype_sel_spuenc_e     ? 9'h070    :
	                 ttype_sel_corr_err_e   ? 9'h063  :
                   ttype_sel_res_err_e    ? 9'h07e :
          
	                 ttype_sel_pcoor_e      ? 9'h008  :
	                 ttype_sel_immu_miss_e  ? 9'h064   :
	                 ttype_sel_real_trans_e ? 9'h03e :
	                 ttype_sel_icache_err_e ? 9'h00a  :
	                 ttype_sel_priv_viol_e  ? 9'h008  :
	                 ttype_sel_ibe_e        ? 9'h076   :
	                 ttype_sel_privop_e     ? 9'h011 :
	                 ttype_sel_illinst_e    ? 9'h010 :
	                 ttype_sel_sir_e        ? 9'h004      :
	                 ttype_sel_fpdis_e      ? 9'h020 :
	                                           9'h1ff;

   dff_s #(9) ttype_reg(.din (ttype_e[8:0]),
		                .q   (ifu_tlu_ttype_m[8:0]),
		                .clk (clk), .se(se), .si(), .so());
	 
//------------------------------
// Interrupts and Resets
//------------------------------
   // Process resets to see if they are sync or async
   assign intr_in_pipe = ({4{intr_vld_d}} & thr_d |
                          {4{intr_vld_e}} & thr_e |
                          {4{intr_vld_m}} & thr_m |
                          {4{intr_vld_w}} & thr_w);

//   assign async_rst_i2 = tlu_ifu_rstthr_i2  & {4{tlu_ifu_rstint_i2}} &
   assign async_rst_i3 = (rstint_i3 | nuke_thr_i3 | resumint_i3) & 
                           ~dtu_fcl_thr_active & ~intr_in_pipe;

   dff_s #(4) asyrst4_reg(.din (async_rst_i3),
                        .q   (async_rst_i4),
                        .clk (clk), .se(se), .si(), .so());
   
   // stall pipe before switching in rst thread
   assign rst_stallreq_d0 = (|async_rst_i4[3:0]);
   assign rst_stallreq = rst_stallreq_d0 | rst_stallreq_d1 | rst_stallreq_d2;

   dff_s #(2) stlreq_reg(.din ({lsu_ifu_stallreq,
                              ffu_ifu_stallreq}),
                       .q   ({lsu_stallreq_d1,
                              ffu_stallreq_d1}),
                       .clk (clk), .se(se), .si(), .so());
   
   assign all_stallreq = ifq_fcl_stallreq | lsu_stallreq_d1 | 
                         ffu_stallreq_d1 | itlb_starv_alert;

   // leave out stall from ifq which goes directly to swl
   assign fcl_dtu_stall_bf = lsu_stallreq_d1 | ffu_stallreq_d1 | 
                             itlb_starv_alert | rst_stallreq;

   // priority encode rst interrupts
   // this could lead to obvious starvation of thr3, the assumption is that
   // idle/resume/reset interrupts do not occur very frequently
   assign rstint_penc[0] = async_rst_i4[0];
   assign rstint_penc[1] = ~async_rst_i4[0] & async_rst_i4[1];
   assign rstint_penc[2] = ~async_rst_i4[0] & ~async_rst_i4[1]  & 
	                          async_rst_i4[2];
   assign rstint_penc[3] = ~async_rst_i4[0] & ~async_rst_i4[1]  & 
	                         ~async_rst_i4[2];

   // BF - switch in rst thread
   dff_s #(1) asyncr1_ff(.din (rst_stallreq_d0),
		                   .q   (rst_stallreq_d1),
		                   .clk (clk), .se(se), .si(), .so());
   assign arst_vld_f_l = ~arst_vld_f;
   assign arst_vld_s_l = ~arst_vld_s;
   bw_u1_nand3_4x UZsize_rstsw_n3(.z (rst_sw_bf_l),
                                  .a (arst_vld_f_l),
                                  .b (arst_vld_s_l),
                                  .c (rst_stallreq_d1));
   assign rst_sw_bf = ~rst_sw_bf_l;

   // double check if asyn intrs are still valid
   assign sw_for_real_rst_bf = rst_sw_bf & rst_stallreq_d0;
   
   // F
   dff_s #(1) asyncr2_ff(.din (sw_for_real_rst_bf),
		                   .q   (rst_stallreq_d2),
		                   .clk (clk), .se(se), .si(), .so());
//   assign arst_vld_f = rst_stallreq_d2 & any_rstnuke_f;
   assign arst_vld_f = rst_stallreq_d2;   

   // hold thread till reset of curr thread is processed
//   assign rst_thr_bf = arst_vld_f ? thr_f : rstint_penc;
   
   // S issue to pipe
   dff_s #(1) rstvlds_ff(.din (arst_vld_f),
		                   .q   (arst_vld_s),
		                   .clk (clk), .se(se), .si(), .so());
   assign async_intr_vld_s = arst_vld_s & ~kill_intr_f; // & any_rstnuke_f 


   //
   // thread wise interrupts
   //
   assign rstint_i2 = {4{tlu_ifu_rstint_i2}} & tlu_ifu_rstthr_i2;
   assign resumint_i2 = {4{tlu_ifu_resumint_i2}} & tlu_ifu_rstthr_i2;
   assign nuke_thr_i2 =  {4{tlu_ifu_nukeint_i2}} & tlu_ifu_rstthr_i2;

   assign next_rst_i2 = rstint_i2 | 
	                      rstint_i3 & (~(thr_w & {4{fcl_dtu_rst_thr_w}}));
   assign next_resum_i2 = resumint_i2 | 
	                        resumint_i3 & (~(thr_w & {4{fcl_dtu_resum_thr_w}})) 
                          & ~rstint_i2;

   assign next_nuke_i2  = (nuke_thr_i2 | nuke_thr_i3) & 
                            (~(thr_w & {4{fcl_dtu_nuke_thr_w}})) & 
	                       ~(rstint_i2 | resumint_i2);

   assign next_sftint_i2 = tlu_ifu_sftint_vld;
   assign next_hwint_i3 = tlu_ifu_hwint_i3;
   assign next_hintp_i2 = tlu_ifu_hintp_vld;
   assign next_rerr_i2 = tlu_ifu_rerr_vld;
   
   assign next_ceint_i2 = erb_fcl_ce_trapvec |
	                        ceint_i3 & (~(thr_w & {4{ceint_qual_w}}));

   assign next_ueint_i2 = erb_fcl_ue_trapvec |
	                        ueint_i3 & (~(thr_w & {4{ueint_qual_w}}));

   // From Farnad: tid is ready several cycles before everything else
   // I will assume 1 cycle before in the ifu
   dff_s #(2) sptid_reg(.din (spu_ifu_ttype_tid_w2),
                      .q   (spu_tid_w2),
                      .clk (clk), .se(se), .so(), .si());
   
   assign spu_thr[0] = ~spu_tid_w2[1] & ~spu_tid_w2[0];
   assign spu_thr[1] = ~spu_tid_w2[1] &  spu_tid_w2[0];
   assign spu_thr[2] =  spu_tid_w2[1] & ~spu_tid_w2[0];
   assign spu_thr[3] =  spu_tid_w2[1] &  spu_tid_w2[0];

   assign next_spuint1_i2 = {4{spu_ifu_ttype_vld_w2 & spu_ifu_ttype_w2}} & 
	                          spu_thr & ~erb_fcl_spu_uetrap |
	                          spuint1_i3 & ~({4{spuint1_w}} & thr_w);

   assign next_spuint0_i2 = {4{spu_ifu_ttype_vld_w2 & ~spu_ifu_ttype_w2}} & 
	                          spu_thr & ~erb_fcl_spu_uetrap |
	                          spuint0_i3 & ~({4{spuint0_w}} & thr_w);


   dffr_s #(4) rst_reg(.din  (next_rst_i2),
		                 .q    (rstint_i3),
		                 .clk  (clk),
		                 .rst  (fcl_reset),
		                 .se   (se), .si(), .so());

   dffr_s #(4) resum_reg(.din  (next_resum_i2),
		                   .q    (resumint_i3),
		                   .clk  (clk),
		                   .rst  (fcl_reset),
		                   .se   (se), .si(), .so());

   dffr_s #(4) nuke_reg(.din  (next_nuke_i2),
		                  .q    (nuke_thr_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk),
		                  .se   (se), .si(), .so());

   dffr_s #(4) sfti_reg(.din  (next_sftint_i2),
		                  .q    (sftint_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) hstki_reg(.din  (next_hintp_i2),
		                  .q    (hintp_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) reri_reg(.din  (next_rerr_i2),
		                  .q    (rerr_i3),
		                  .rst  (fcl_reset),
		                  .clk  (clk), .se   (se), .si(), .so());
   dffr_s #(4) hwi_reg(.din  (next_hwint_i3),
		                 .q    (hwint_i4),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) spui0_reg(.din  (next_spuint0_i2),
		                   .q    (spuint0_i3),
		                   .rst  (fcl_reset),
		                   .clk  (clk), .se   (se), .si(), .so());
   
   dffr_s #(4) spui1_reg(.din  (next_spuint1_i2),
		                   .q    (spuint1_i3),
		                   .rst  (fcl_reset),
		                   .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) cei_reg(.din  (next_ceint_i2),
		                 .q    (ceint_i3),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   dffr_s #(4) uei_reg(.din  (next_ueint_i2),
		                 .q    (ueint_i3),
		                 .rst  (fcl_reset),
		                 .clk  (clk), .se   (se), .si(), .so());

   assign supv_int_en = (~tlu_hpstate_priv | ~tlu_hpstate_enb) & 
                         tlu_ifu_pstate_ie & dtu_fcl_thr_active;
   assign hypv_int_en = ~tlu_hpstate_priv & tlu_hpstate_enb | 
                        tlu_ifu_pstate_ie & dtu_fcl_thr_active;
   
   dff_s #(4) spvie_ff(.din (supv_int_en),
                     .q   (supv_int_en_d1),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(4) hpvie_ff(.din (hypv_int_en),
                     .q   (hypv_int_en_d1),
                     .clk (clk), .se(se), .si(), .so());

   // force an interrupt by putting nop on pipe
   // use this signal instead of hw_int_s to help with crit path
   assign supv_masked_intr_s = (sftint_i3        |
			                          rerr_i3);
   assign hypv_masked_intr_s = (hwint_i4         |
			                          hintp_i3         |
			                          ceint_i3         |
			                          ueint_i3         |
			                          spuint0_i3       |
			                          spuint1_i3);

   assign fcl_swl_int_activate_i3 = hypv_masked_intr_s |
                                    supv_masked_intr_s;

    // keep track of rolled back interrupts
   assign intr_pending_nxt =  (({4{intr_vld_e}} & rb_frome) |
                               ({4{intr_vld_d}} & rb_fromd & ~rb_frome) |
                                intr_pending_s) & ~clear_s_d1;
   
   dffr_s #(4) ipend_reg(.din (intr_pending_nxt),
                       .q   (intr_pending_s),
                       .rst (fcl_reset),
                       .clk (clk), .se(se), .si(), .so());

   assign any_intr_vec_f = (supv_masked_intr_s & supv_int_en_d1 |
                            hypv_masked_intr_s & hypv_int_en_d1 |
                            intr_pending_s    |
			                      rstint_i3         |
                            resumint_i3       |
			                      nuke_thr_i3);

   dff_s #(4) anyints_reg(.din (any_intr_vec_f),
                        .q   (any_intr_vec_s),
                        .clk (clk), .se(se), .si(), .so());
			
   assign force_intr_s = (thr_f_crit[0] & any_intr_vec_s[0] |
                          thr_f_crit[1] & any_intr_vec_s[1] |
                          thr_f_crit[2] & any_intr_vec_s[2] |
                          thr_f_crit[3] & any_intr_vec_s[3]) &
	                         ~kill_intr_f;

   // interrupt and reset signal pipe
   // VA hole trap has higher priority than interrupt
   //   - since the VA hole marker is lost once the intr is taken
   assign intr_vld_s = force_intr_s & (valid_s & ~pc_oor_s | 
                                       async_intr_vld_s);

   assign intr_vld_qual_s = intr_vld_s & ~iferrto_thisthr_d1;
   dff_s #(1) any_intrd_ff(.din (intr_vld_qual_s),
		                     .q   (intr_vld_d),	
		                     .clk (clk),	
		                     .se  (se), .so(), .si());
   assign fcl_dec_intr_vld_d = intr_vld_d;
   assign intr_vld_qual_d = intr_vld_d & ~kill_intr_d & ~kill_thread_d & 
	                           ~rb_stg_d;

   dff_s #(1) intr_vlde_ff(.din (intr_vld_qual_d),
		                   .q   (intr_vld_e),
		                   .clk (clk), .se  (se), .so(), .si());

   assign intr_vld_qual_e = intr_vld_e & ~kill_curr_e & ~rb_stg_e & 
	                    ~kill_intr_e & ~dtu_inst_anull_e &
                      ~(thr_match_em & ifu_tlu_flush_m);
   
   dff_s #(1) intr_vldm_ff(.din (intr_vld_qual_e),
		                   .q   (intr_vld_m),
		                   .clk (clk), .se  (se), .so(), .si());

   assign intr_vld_qual_m = intr_vld_m & ~kill_thread_m & ~mark4rb_m;

   dff_s #(1) intr_vldw_ff(.din (intr_vld_qual_m),
		                   .q   (intr_vld_w),
		                   .clk (clk), .se  (se), .so(), .si());

   // Reset and Idle are prioritized in M.  All others in E
   // reset interrupt
   assign rstint_m = (rstint_i3[0] & thr_m[0] |
			                rstint_i3[1] & thr_m[1] |
			                rstint_i3[2] & thr_m[2] |
			                rstint_i3[3] & thr_m[3]);

   assign ifu_tlu_rstint_m = rstint_m & intr_vld_m & ~kill_local_m & 
                             ~kill_curr_m;
//   assign rstint_qual_m = rstint_m & ~ely_kill_thread_m & intr_vld_m;
   dff_s #(1) rstw_ff(.din (rstint_m),
                    .q   (rst_thr_w),
                    .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_rst_thr_w = rst_thr_w & intr_vld_w;

   // resume interrupt
   assign resumint_m = (resumint_i3[0] & thr_m[0] |
			                  resumint_i3[1] & thr_m[1] |
			                  resumint_i3[2] & thr_m[2] |
			                  resumint_i3[3] & thr_m[3]);
   assign resumint_qual_m = resumint_m & ~rstint_m;
   
   dff_s #(1) resumw_ff(.din (resumint_qual_m),
                      .q   (resum_thr_w),
                      .clk (clk), .se(se), .si(), .so());
   assign fcl_dtu_resum_thr_w = resum_thr_w & intr_vld_w;

   // idle interrupt
   assign nuke_thr_m = (nuke_thr_i3[0] & thr_m[0] |
				                nuke_thr_i3[1] & thr_m[1] |
				                nuke_thr_i3[2] & thr_m[2] |
				                nuke_thr_i3[3] & thr_m[3]);

   assign nuke_thr_qual_m = nuke_thr_m & ~rstint_m & ~resumint_m;

   dff_s #(1) nukw_ff(.din (nuke_thr_qual_m),
                    .q   (nuke_thr_w),
                    .clk (clk),
                    .se  (se), .si(), .so());
   assign fcl_dtu_nuke_thr_w = nuke_thr_w & intr_vld_w;
   
   // uncorrected ecc
   assign ueint_e = (ueint_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                 ueint_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                 ueint_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                 ueint_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign ueint_qual_e = ueint_e & intr_vld_e;

   dff_s #(1) uem_ff (.din (ueint_qual_e),
                    .q   (ueint_m),
                    .clk (clk), .se (se), .si(), .so());
                    
//   assign ueint_m = (ueint_i3[0] & thr_m[0] |
//		                 ueint_i3[1] & thr_m[1] |
//		                 ueint_i3[2] & thr_m[2] |
//		                 ueint_i3[3] & thr_m[3]);
   
   assign ueint_trap_m = ueint_m & intr_vld_m & 
                         ~(rstint_m | resumint_m | nuke_thr_m);
   
//   assign ueint_qual_m = ueint_trap_m & ~ely_kill_thread_m;
   dff_s #(1) ueintw_ff(.din (ueint_trap_m),
                      .q   (ueint_trap_w),
                      .clk (clk), .se(se), .si(), .so());
   assign ueint_qual_w = ueint_trap_w & intr_vld_w;

   // hstk match interrupt
   assign hintp_e = (hintp_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
			               hintp_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
			               hintp_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
			               hintp_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign hintp_qual_e = hintp_e & intr_vld_e & ~ueint_e;

   dff_s #(1) hintpm_ff (.din (hintp_qual_e),
                       .q   (hintp_m),
                       .clk (clk), .se (se), .si(), .so());

//   assign ifu_tlu_hintp_m = hintp_m & ~kill_local_m & intr_vld_m & 
//	                    ~(rstint_m | nuke_thr_m | ueint_m);
   
   // hw int
   assign hwint_e = (hwint_i4[0] & thr_e[0] & hypv_int_en_d1[0] |
			               hwint_i4[1] & thr_e[1] & hypv_int_en_d1[1] |
			               hwint_i4[2] & thr_e[2] & hypv_int_en_d1[2] |
			               hwint_i4[3] & thr_e[3] & hypv_int_en_d1[3]);
   dff_s #(1) hwe_ff(.din (hwint_e),
                   .q   (hwint_m),
                   .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_hwint_m = hwint_m & intr_vld_m & ~kill_local_m &
                     ~kill_curr_m & 
	                   ~(rstint_m | resumint_m | nuke_thr_m | ueint_m | hintp_m);
   

   // spu interrupt
   assign spuint1_e = (spuint1_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                   spuint1_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                   spuint1_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                   spuint1_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign spuint1_qual_e = spuint1_e & intr_vld_e & ~ueint_e & ~hintp_e;

//   assign spuint1_m = (spuint1_i3[0] & thr_m[0] |
//		                   spuint1_i3[1] & thr_m[1] |
//		                   spuint1_i3[2] & thr_m[2] |
//		                   spuint1_i3[3] & thr_m[3]);

   dff_s #(1) spu1m_ff(.din (spuint1_qual_e),
                     .q   (spuint1_m),
                     .clk (clk), .se(se), .si(), .so());

   assign spuint1_trap_m = spuint1_m & intr_vld_m & 
	                    ~(rstint_m | resumint_m | nuke_thr_m | hwint_m);

//   assign spuint1_qual_m = spuint1_trap_m & ~ely_kill_thread_m;
   
   dff_s #(1) spiw1_ff(.din (spuint1_trap_m),
		                 .q   (spuint1_trap_w),
		                 .clk (clk), .se(se), .si(), .so());
   assign spuint1_w = spuint1_trap_w & intr_vld_w;
   
   assign spuint0_e = (spuint0_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                   spuint0_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                   spuint0_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                   spuint0_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   
   assign spuint0_qual_e = spuint0_e & intr_vld_e & ~ueint_e &
			                     ~spuint1_e & ~hintp_e;

//   assign spuint0_m = (spuint0_i3[0] & thr_m[0] |
//		                   spuint0_i3[1] & thr_m[1] |
//		                   spuint0_i3[2] & thr_m[2] |
//		                   spuint0_i3[3] & thr_m[3]);
   dff_s #(1) spu0m_ff(.din (spuint0_qual_e),
                     .q   (spuint0_m),
                     .clk (clk), .se(se), .si(), .so());

   assign spuint0_trap_m = spuint0_m & intr_vld_m &
             	        ~(rstint_m | nuke_thr_m | resumint_m |
		                    hwint_m);
   
//   assign spuint0_qual_m = spuint0_trap_m & ~kill_thread_m;

   dff_s #(1) spiw0_ff(.din (spuint0_trap_m),
		                 .q   (spuint0_trap_w),
		                 .clk (clk), .se(se), .si(), .so());
   assign spuint0_w = spuint0_trap_w & intr_vld_w;
   
//   assign ifu_spu_trap_ack = {spuint1_w, spuint0_w};
   assign ifu_spu_trap_ack = spuint1_w;   
   
   
   // software interrupts
   assign sftint_e = (sftint_i3[0] & thr_e[0] & supv_int_en_d1[0] |
			                sftint_i3[1] & thr_e[1] & supv_int_en_d1[1] |
			                sftint_i3[2] & thr_e[2] & supv_int_en_d1[2] |
			                sftint_i3[3] & thr_e[3] & supv_int_en_d1[3]);

   assign sftint_qual_e = sftint_e & ~spuint0_e & intr_vld_e & 
                          ~ueint_e & ~spuint1_e & ~hintp_e;
   
   dff_s #(1) swm_ff(.din (sftint_qual_e),
                   .q   (sftint_m),
                   .clk (clk), .se(se), .si(), .so());

   // if nothing else, signal sftint!
//   assign ifu_tlu_sftint_m = (sftint_m & 
//	                            ~(rstint_m | nuke_thr_m | hintp_m | resumint_m |
//				                        hwint_m | spuint1_m | spuint0_m | ueint_m) |
//                              ~(ceint_m | rerr_m)) & 
//                               ~kill_local_m & intr_vld_m;

   assign ifu_tlu_sftint_m = (sftint_m & 
	                            ~(rstint_m | nuke_thr_m | hintp_m | resumint_m |
				                        hwint_m | spuint1_m | spuint0_m | ueint_m)) & 
                               ~kill_local_m & ~kill_curr_m & intr_vld_m;
   

   // corrected ecc interrupt
   assign ceint_e = (ceint_i3[0] & thr_e[0] & hypv_int_en_d1[0] |
		                 ceint_i3[1] & thr_e[1] & hypv_int_en_d1[1] |
		                 ceint_i3[2] & thr_e[2] & hypv_int_en_d1[2] |
		                 ceint_i3[3] & thr_e[3] & hypv_int_en_d1[3]);
   assign ceint_qual_e = ceint_e & intr_vld_e & ~ueint_e & 
                          ~spuint1_e & ~spuint0_e & ~hintp_e;

//   assign ceint_m = (ceint_i3[0] & thr_m[0] |
//		                 ceint_i3[1] & thr_m[1] |
//		                 ceint_i3[2] & thr_m[2] |
//		                 ceint_i3[3] & thr_m[3]);
   dff_s #(1) cem_ff(.din (ceint_qual_e),
                   .q   (ceint_m),
                   .clk (clk), .se(se), .si(), .so());
   
   assign ceint_trap_m = ceint_m & intr_vld_m & 
	                 ~(rstint_m | nuke_thr_m | resumint_m |
		                 sftint_m | hwint_m);
   
//   assign ceint_qual_m = ceint_trap_m & ~ely_kill_thread_m;
   dff_s #(1) ceintw_ff(.din (ceint_trap_m),
                      .q   (ceint_trap_w),
                      .clk (clk), .se(se), .si(), .so());
   assign ceint_qual_w = ceint_trap_w & intr_vld_w;

   // resumable error interrupt
   assign rerr_e = (rerr_i3[0] & thr_e[0] & supv_int_en_d1[0] |
		                 rerr_i3[1] & thr_e[1] & supv_int_en_d1[1] |
		                 rerr_i3[2] & thr_e[2] & supv_int_en_d1[2] |
		                 rerr_i3[3] & thr_e[3] & supv_int_en_d1[3]);
   assign rerr_qual_e = rerr_e & intr_vld_e & ~ueint_e & ~ceint_e &
                        ~spuint1_e & ~spuint0_e & ~hintp_e;
   
   dff_s #(1) rem_ff(.din (rerr_qual_e),
                   .q   (rerr_m),
                   .clk (clk), .se(se), .si(), .so());
   
//   assign rerr_m = (rerr_i3[0] & thr_m[0] |
//			              rerr_i3[1] & thr_m[1] |
//			              rerr_i3[2] & thr_m[2] |
//			              rerr_i3[3] & thr_m[3]);

//   assign ifu_tlu_rerr_m = rerr_m & ~kill_local_m & intr_vld_m & 
//	                    ~(rstint_m | nuke_thr_m | ueint_m | ceint_m);

   assign disr_trap_m = (ueint_m | hintp_m | spuint0_m | spuint1_m |
                         ceint_m | rerr_m) & ~rstint_m & ~nuke_thr_m &
                          ~resumint_m & intr_vld_m;

   // check if a scheduled interrupt evaporated...
   assign any_intr_m = (ueint_m | ceint_m | spuint0_m | spuint1_m |
                        hintp_m | rerr_m | sftint_m | hwint_m | 
                        rstint_m | nuke_thr_m | resumint_m);
   
   // ..and rollback if that is the case
   assign rb_intr_m = ~any_intr_m & intr_vld_m;
   dff_s #(1) rbint_ff(.din (rb_intr_m),
                     .q   (rb_intr_w),
                     .clk (clk), .se(se), .si(), .so());

   // use synchronous interrupt signal to switch out thread in swl
//   assign fcl_dtu_sync_intr_d = (intr_vld_d | immu_miss_crit_d) & ~rb_stg_d;
   assign fcl_dtu_sync_intr_d = (intr_vld_d) & ~rb_stg_d_crit;   
   
   // kill the next three interrupts.  After that you are on your own.
//   assign kill_intr_m = ((thr_m & thr_w) == 4'b0) ?
//			                    1'b0 : (intr_vld_w);
   assign kill_intr_e = ((thr_e & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);
   assign kill_intr_d = ((thr_d & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);
   assign kill_intr_f = ((thr_f & thr_w) == 4'b0) ?
			                    1'b0 : (intr_vld_w);

//--------------------------------
// check if we are in a delay slot
//--------------------------------
   // remember if the current instruction is a delay slot
   assign delay_slot_vec_nxt = ({4{dtu_fcl_br_inst_d & inst_vld_d & 
                                   ~rb_stg_d}} & thr_d | // set
                                delay_slot_vec &
                                ~(thr_d & {4{inst_vld_d &
                                             ~rb_stg_d &
                                             ~intr_vld_d}})) &
                                 ~(trap_thr & {4{trappc_vld_w2}});
                                // & ~late_flush_w2;
   // Need to be a little pessimitic: can't clear the delay slot vec
   // after a utrap, since we may still be in the delay slot when we
   // re-execute

   dffr_s #(4) ds_reg(.din (delay_slot_vec_nxt),
                    .q   (delay_slot_vec),
                    .rst (fcl_reset),
                    .clk (clk), .se(se), .si(), .so());
   assign fcl_dec_dslot_s = (delay_slot_vec[0] & thr_f[0] |
                             delay_slot_vec[1] & thr_f[1] |
                             delay_slot_vec[2] & thr_f[2] |
                             delay_slot_vec[3] & thr_f[3]);
   

//------------------------------
// NIR control
//------------------------------
   // use nir if va[2] of previous fetch is a zero (i.e lower word)
   dff_s #(1) va2_ff(.din (fdp_fcl_va2_bf),
		               .clk (clk),
		               .q   (va2_f),
		               .se  (se), .si(), .so());
   
   assign usep_bf = rdreq_f & ~va2_f & ~ntpc_thisthr & ~stall_f;
   assign set_usen_bf = usep_bf & ~ely_stall_thisthr_f & dtu_fcl_running_s;
   
   // need to kill usen if trap or interrupt or flush
   assign thr_usen_nxt = ({4{set_usen_bf}} &  thr_f  |    // set usen
			                    thr_usen_bf  & ~val_thr_f) &    // keep old value
			                     ~((thr_d & {4{dtu_fcl_br_inst_d}})  |
		                         (thr_s1 & {4{ic_miss_s1}})  |
                             (thr_e & {4{erb_dtu_ifeterr_d1 & inst_vld_d1}}) |
			                       (clear_s_d1) |
			                       (ntpc_vld)  |
			                       (rb_w2 | rb_froms));     // reset usen (wins)
                         // & ~dtu_fcl_flush_nir
   
   dffr_s #(4) thr_usen_reg(.din  (thr_usen_nxt),
			                  .clk  (clk),
			                  .q    (thr_usen_bf),
			                  .rst  (fcl_reset),
			                  .se   (se), .si(), .so());
   
   /*
   // Use hand instantiated mux
   bw_u1_ao2222_4x UZsize_usn_mx(.z   (usen_iso_bf)
		                            .a2  (thr_usen_bf[0]),
		                            .b2  (thr_usen_bf[1]),
		                            .c2  (thr_usen_bf[2]),
		                            .d2  (thr_usen_bf[3]),
		                            .a1  (nextthr_bf_buf[0]),
		                            .b1  (nextthr_bf_buf[1]),
		                            .c1  (nextthr_bf_buf[2]),
		                            .d1  (nextthr_bf_buf[3]));

    // isolate from critical path
    bw_u1_buf_5x  UZsize_usn_iso(.z(usen_bf), .a(usen_iso_bf));
    */
                                
   assign usen_iso_bf = (thr_usen_bf[0] & nextthr_bf_buf[0] |
                         thr_usen_bf[1] & nextthr_bf_buf[1] |
                         thr_usen_bf[2] & nextthr_bf_buf[2] |
                         thr_usen_bf[3] & nextthr_bf_buf[3]);
   assign usen_bf = usen_iso_bf;

   
   
//------------------------------
// Switch Control
//------------------------------   
   // Switch IF
   //   1. Another thread is ready OR
   //   2. We hit a switch condition or Imiss and another thread is
   //      speculatively ready
   //   3. No thread is running and another thread is speculatively ready
   //   4. The DTU calls for a thread switch and another thread is ready
   //   (NOTE: if we hit a switch condition or Imiss and no thread is
   //    speculatively or otherwise ready we stall the pipe).
   //
   //   New plan:  switch if another thread is ready or spec ready.
   //

//   assign switch_bf = dtu_fcl_ntr_s;
   // mmckeown: when execution drafting is enabled, this is determined by
   // the switch_bf signal from ESL
   bw_u1_buf_20x UZsize_swbuf(.a (config_dtu_esl_en ? esl_fcl_switch_bf : dtu_fcl_ntr_s),
                              .z (switch_bf));
   
//   assign switch_bf = dtu_fcl_ntr_s & ~imsto_nextthr_s1;
//   assign switch_bf = dtu_fcl_ntr_s & ~(imsto_nextthr_s1 | kill_nextthr_w | 
//                                        intrto_nextthr_d);   
   
//   assign fcl_dtu_switch_s = switch_bf & ~all_stallreq & ~rst_stallreq;
//   assign fcl_dtu_switch_s = switch_bf & ~kill_nextthr_w;

   // TBD: No need to send this anymore, since switch_bf = ntr_s
//   assign fcl_dtu_switch_s = switch_bf;  // sw out curr and sw in next

   assign fcl_swl_swout_f = stall_f;     // sw out curr but don't sw in next
   // Note: need fcl_swl_swout_f and dtu_fcl_running_s to sync swl and
   // fcl at all times.  

   // mmckeown: when execution drafting is enabled, this is determined by
   //           ntr_s, not from the same thing as bf 
   assign switch_qual_bf = (config_dtu_esl_en ? esl_fcl_ntr_s : switch_bf) & ~rst_stallreq;
   dff_s #(1) sw_ff (.din  (switch_qual_bf),
		               .clk  (clk),
		               .q    (switch_s2),
		               .se   (se), .si(), .so());

   dff_s #(1) tmfn_ff (.din  (switch_bf),
		                 .clk  (clk),
		                 .q    (tm_fd_l),
		                 .se   (se), .si(), .so());

   // need to qual with immu_fault to avoid X's
//   assign fcl_dtu_swc_s = fdp_fcl_swc_s2 & inst_vld_s_crit & 
//                          ~immu_fault_f & ~part_stall_thisthr_f;
//   assign fcl_dtu_swc_s = fdp_fcl_swc_s2 & inst_vld_s_crit & 
//                          ~immu_fault_f & ~imsto_thisthr_s1 & ~rb_stg_s;
   assign fcl_swl_swcvld_s = inst_vld_s_crit & ~immu_fault_f & 
                             ~imsto_thisthr_s1 & ~rb_stg_s;
     

//------------------------------   
// Thread pipe
//------------------------------

//`ifdef VERPLEX
//   $constraint nthr_1h4 ($one_hot(dtu_fcl_nextthr_bf[3:0]));
//   $constraint thrf_1h4 ($one_hot(thr_f[3:0]));
//`endif
   
   // Keep track the thread in each pipe stage
   assign rstt = (~fcl_reset & (rst_stallreq_d1 & ~arst_vld_f)) | rst_tri_en;
   assign swt =  (~rst_stallreq_d1 & ~arst_vld_f & switch_bf | fcl_reset) & 
                   ~rst_tri_en;
   assign samet = (~rst_stallreq_d1 & ~switch_bf | arst_vld_f) & 
                    ~fcl_reset & ~rst_tri_en;
   
   mux3ds #(4)  nxttthr_mux(.dout  (thr_bf[3:0]),      
			                      .in0   (thr_f[3:0]),       
			                      .in1   (nextthr_bf_buf[3:0]),
			                      .in2   (rstint_penc[3:0]), 
			                      .sel0  (samet),
			                      .sel1  (swt),
			                      .sel2  (rstt));

   assign thr_match_nw = (thr_w[0] & nextthr_bf_buf[0] | 
			                    thr_w[1] & nextthr_bf_buf[1] | 
			                    thr_w[2] & nextthr_bf_buf[2] | 
			                    thr_w[3] & nextthr_bf_buf[3]);

   assign thr_match_nd = (thr_d[0] & nextthr_bf_buf[0] | 
			                    thr_d[1] & nextthr_bf_buf[1] | 
			                    thr_d[2] & nextthr_bf_buf[2] | 
			                    thr_d[3] & nextthr_bf_buf[3]);

//   assign thr_match_ne = (thr_e[0] & dtu_fcl_nextthr_bf[0] | 
//			                    thr_e[1] & dtu_fcl_nextthr_bf[1] | 
//			                    thr_e[2] & dtu_fcl_nextthr_bf[2] | 
//			                    thr_e[3] & dtu_fcl_nextthr_bf[3]);
   // qualify inst_vld_e in fcl itself

//   bw_u1_ao2222_4x UZsize_tmne(.z  (thr_match_ne),
//                               .a1 (val_thr_e[0]),
//                               .b1 (val_thr_e[1]),
//                               .c1 (val_thr_e[2]),
//                               .d1 (val_thr_e[3]),
//                               .a2 (dtu_fcl_nextthr_bf[0]),
//                               .b2 (dtu_fcl_nextthr_bf[1]),
//                               .c2 (dtu_fcl_nextthr_bf[2]),
//                               .d2 (dtu_fcl_nextthr_bf[3]));

   wire   tmne_10,
          tmne_32;
   bw_u1_aoi22_2x UZsize_tmne10(.z (tmne_10),
                                .a1 (dtu_fcl_nextthr_bf[0]),
                                .b1 (dtu_fcl_nextthr_bf[1]),
                                .a2 (val_thr_e[0]),
                                .b2 (val_thr_e[1]));
   bw_u1_aoi22_2x UZsize_tmne32(.z (tmne_32),
                                .a1 (dtu_fcl_nextthr_bf[2]),
                                .b1 (dtu_fcl_nextthr_bf[3]),
                                .a2 (val_thr_e[2]),
                                .b2 (val_thr_e[3]));
   bw_u1_nand2_4x UZsize_tmne30(.z (thr_match_ne),
                                .a (tmne_10),
                                .b (tmne_32));
   

   dff_s #(4) thrf_reg(.din   (thr_bf),     // thr_f may be 4'b0000 but it has 
		                 .clk   (clk),        // to reset to 4'b0001
		                 .q     (thr_f_flop),
		                 .se    (se),  .si(), .so());

   bw_u1_buf_10x UZsize_tfcrit0(.a (thr_f_flop[0]), .z(thr_f_crit[0]));
   bw_u1_buf_10x UZsize_tfcrit1(.a (thr_f_flop[1]), .z(thr_f_crit[1]));
   bw_u1_buf_10x UZsize_tfcrit2(.a (thr_f_flop[2]), .z(thr_f_crit[2]));
   bw_u1_buf_10x UZsize_tfcrit3(.a (thr_f_flop[3]), .z(thr_f_crit[3]));

   bw_u1_buf_10x UZsize_tfncr0(.a (thr_f_flop[0]), .z(thr_f[0]));
   bw_u1_buf_10x UZsize_tfncr1(.a (thr_f_flop[1]), .z(thr_f[1]));
   bw_u1_buf_10x UZsize_tfncr2(.a (thr_f_flop[2]), .z(thr_f[2]));
   bw_u1_buf_10x UZsize_tfncr3(.a (thr_f_flop[3]), .z(thr_f[3]));

   assign     ifu_exu_tid_s2[1] = thr_f[3] | thr_f[2];
   assign     ifu_exu_tid_s2[0] = thr_f[3] | thr_f[1];
   assign     ifu_lsu_thrid_s = ifu_exu_tid_s2;
   assign     fcl_dtu_thr_f = thr_f;
   
//   assign thr_s1_next = inst_vld_f ? thr_f : thr_s1;
   assign     thr_s1_next[0] = thr_f[0];
   assign     thr_s1_next[1] = ~thr_f[0] & thr_f[1];
   assign     thr_s1_next[2] = ~thr_f[0] & ~thr_f[1] & thr_f[2];
   assign     thr_s1_next[3] = ~thr_f[0] & ~thr_f[1] & ~thr_f[2];
   
//`ifdef VERPLEX
//   $constraint thr_s1_1h4 ($one_hot(thr_s1_next[3:0]));
//`endif
   
   dff_s #(4) thrs1_reg(.din   (thr_s1_next),
		    .clk   (clk),
		    .q     (thr_s1),
		    .se    (se), .si(), .so());
   
   dff_s #(4) thrd_reg(.din    (thr_s1_next), 
                    .clk   (clk),
                    .q     (thr_d),
                    .se    (se), .si(), .so());
   
   assign fcl_ifq_thr_s1[0] = thr_s1[3] | thr_s1[1];
   assign fcl_ifq_thr_s1[1] = thr_s1[3] | thr_s1[2];

   assign ifu_tlu_thrid_d[1] = thr_d[3] | thr_d[2];
   assign ifu_tlu_thrid_d[0] = thr_d[3] | thr_d[1];
   
   assign thr_match_fs1 = (thr_d[0] & thr_f_crit[0] | 
			                     thr_d[1] & thr_f_crit[1] | 
			                     thr_d[2] & thr_f_crit[2] | 
			                     thr_d[3] & thr_f_crit[3]);
   assign thr_match_fd = thr_match_fs1;
   assign thr_match_fe = (thr_e[0] & thr_f[0] | 
			                    thr_e[1] & thr_f[1] | 
			                    thr_e[2] & thr_f[2] | 
			                    thr_e[3] & thr_f[3]);
   assign thr_match_fm = (thr_m[0] & thr_f[0] | 
			                    thr_m[1] & thr_f[1] | 
			                    thr_m[2] & thr_f[2] | 
			                    thr_m[3] & thr_f[3]);
//   assign thr_match_ft = (trap_thr[0] & thr_f[0] | 
//			  trap_thr[1] & thr_f[1] | 
//			  trap_thr[2] & thr_f[2] | 
//			  trap_thr[3] & thr_f[3]);
   
   dffr_s #(4) thre_reg(.din   (thr_d),    
		    .clk   (clk),
		    .rst   (fcl_reset),
		    .q     (thr_e),
		    .se    (se), .si(), .so());
   assign fcl_esl_thr_e = thr_e;

   dffr_s #(4) thre2_reg(.din   (thr_d),    
		    .clk   (clk),
		    .rst   (fcl_reset),
		    .q     (thr_e_v2),
		    .se    (se), .si(), .so());

   assign     ifu_tlu_thrid_e[1] = thr_e[3] | thr_e[2];
   assign     ifu_tlu_thrid_e[0] = thr_e[3] | thr_e[1];

   assign thr_match_de = (thr_d[0] & thr_e[0] | 
			                    thr_d[1] & thr_e[1] | 
			                    thr_d[2] & thr_e[2] | 
			                    thr_d[3] & thr_e[3]);
			  
   assign thr_match_dm = (thr_d[0] & thr_m[0] | 
			                    thr_d[1] & thr_m[1] | 
			                    thr_d[2] & thr_m[2] | 
			                    thr_d[3] & thr_m[3]);

   dff_s #(4) thrm_reg(.din   (thr_e),    
		   .clk   (clk),
		   .q     (thr_m),
		   .se    (se), .si(), .so());
   assign fcl_esl_thr_m = thr_m;

   dff_s #(4) thrw_reg(.din   (thr_m),    
		   .clk   (clk),
		   .q     (thr_w),
		   .se    (se), .si(), .so());

   assign sas_thrid_w[1] = thr_w[3] | thr_w[2];
   assign sas_thrid_w[0] = thr_w[3] | thr_w[1];
   
   assign thr_match_fw = (thr_f[0] & thr_w[0] | 
			                    thr_f[1] & thr_w[1] | 
			                    thr_f[2] & thr_w[2] | 
			                    thr_f[3] & thr_w[3]);
	 
   assign thr_match_fw2 = (thr_f[0] & thr_w2[0] | 
			                     thr_f[1] & thr_w2[1] | 
			                     thr_f[2] & thr_w2[2] | 
			                     thr_f[3] & thr_w2[3]);

   assign thr_match_dw = (thr_d[0] & thr_w[0] | 
			                    thr_d[1] & thr_w[1] | 
			                    thr_d[2] & thr_w[2] | 
			                    thr_d[3] & thr_w[3]);

   assign thr_match_dw2 = (thr_d[0] & thr_w2[0] | 
			                     thr_d[1] & thr_w2[1] | 
			                     thr_d[2] & thr_w2[2] | 
			                     thr_d[3] & thr_w2[3]);
	 
   assign thr_match_em = (thr_e[0] & thr_m[0] | 
			                    thr_e[1] & thr_m[1] | 
			                    thr_e[2] & thr_m[2] | 
			                    thr_e[3] & thr_m[3]);

   assign thr_match_ew = (thr_e_v2[0] & thr_w[0] | 
			                    thr_e_v2[1] & thr_w[1] | 
			                    thr_e_v2[2] & thr_w[2] | 
			                    thr_e_v2[3] & thr_w[3]);

   dff_s #(1) stmw2_ff(.din (thr_match_ew),
                     .q   (same_thr_mw2),
                     .clk (clk), .se (se), .si(), .so());
   
   assign thr_match_ew2 = (thr_e[0] & thr_w2[0] | 
			                     thr_e[1] & thr_w2[1] | 
			                     thr_e[2] & thr_w2[2] | 
			                     thr_e[3] & thr_w2[3]);
	 
   assign thr_match_mw = (thr_m[0] & thr_w[0] | 
			                    thr_m[1] & thr_w[1] | 
			                    thr_m[2] & thr_w[2] | 
			                    thr_m[3] & thr_w[3]);
			  
   dff_s #(4) thrw2_reg(.din   (thr_w),    
		    .clk   (clk),
		    .q     (thr_w2),
		    .se    (se), .si(), .so());
   

//-------------------------
// Rollback
//-------------------------

   // 04/05/02
   // Looks like we made a mistake with rollback.  Should never
   // rollback to S.  In the event of a dmiss or mul contention, just
   // kill all the instructions and rollback to F.  This adds one
   // cycle to the dmiss penalty and to the mul latency if we have to
   // wait, both not a very high price to pay.  This would have saved
   // lots of hours of design and verif time.
   //    
   assign rb2_inst_d = thr_match_dw & inst_vld_d & dtu_fcl_rollback_g;
   assign rb1_inst_s = thr_match_fw & inst_vld_s & dtu_fcl_rollback_g;
   assign rb0_inst_bf = thr_match_nw & switch_bf & dtu_fcl_rollback_g;

//   assign rt1_inst_s = thr_match_fd & inst_vld_s & retract_inst_d;
//   assign rt0_inst_bf = thr_match_nd & dtu_fcl_ntr_s & retract_inst_d;

//   assign retract_iferr_d = thr_match_de & erb_dtu_ifeterr_d1 & inst_vld_d1 &
//                            ~kill_curr_e & fcl_dtu_inst_vld_d;
   assign retract_iferr_d1 = erb_dtu_ifeterr_d1 & inst_vld_d1;

   assign retract_inst_d = retract_iferr_d1 & thr_match_de & 
                           fcl_dtu_inst_vld_d |
                           mark4rb_d | 
                           dtu_fcl_retract_d;

   assign rt1_inst_s = thr_match_fd & inst_vld_s & dtu_fcl_retract_d | 
                       mark4rb_s;
//                     | thr_match_fe & inst_vld_s & retract_iferr_d1;

   // TBD:  This is not necessary since the thread will switch out and
   // stall whatever makes its way to the S stage.
   // NOTE: rb0_inst *is needed* however.
   assign rt0_inst_bf = thr_match_nd & switch_bf & dtu_fcl_retract_d;
//                      | thr_match_ne & dtu_fcl_ntr_s & retract_iferr_d1;

   assign retract_iferr_qual_d1 = retract_iferr_d1 & thr_match_de &
                                  fcl_dtu_inst_vld_d &
                                  ~(dtu_fcl_rollback_g & thr_match_ew);

   dff_s rbe_ff(.din (rb2_inst_d),
	      .q   (rb2_inst_e),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rte_ff(.din (retract_inst_d),
	      .q   (rt2_inst_e),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rbd_ff(.din (rb1_inst_s),
	      .q   (rb1_inst_d),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rtd_ff(.din (rt1_inst_s),
	      .q   (rt1_inst_d),
	      .clk (clk),
	      .se  (se), .si(), .so());
   
   dff_s rbs_ff(.din (rb0_inst_bf),
	      .q   (rb0_inst_s),
	      .clk (clk),
	      .se  (se), .si(), .so());

   // TBD: is this necessary?
   dff_s rts_ff(.din (rt0_inst_bf),
	      .q   (rt0_inst_s),
	      .clk (clk),
	      .se  (se), .si(), .so());

   dff_s rtiferr_ff(.din (retract_iferr_qual_d1),
                  .q   (retract_iferr_e),
                  .clk (clk),
                  .se  (se), .si(), .so());
  
   // mmckeown: Adding this to know if there will be a roll
   // back on this stage, as we need to declare diverged
   // if so, we should reconverge very quickly after a 
   // rollback.
   assign fcl_esl_rb_stg_s = rb_stg_s;

   assign rb_stg_s = (rb0_inst_s | rt0_inst_s) & tm_fd_l |
	                   (rb1_inst_d | rt1_inst_d) & ~tm_fd_l;
   assign rb_stg_d_crit = rb1_inst_d | rt1_inst_d;
   assign rb_stg_e = rb2_inst_e | rt2_inst_e;

   bw_u1_buf_5x UZsize_rbd_buf(.a (rb_stg_d_crit),
                               .z (rb_stg_d));
   
   // determine rollback amount
   assign rb_frome = {4{(rb2_inst_e | rt2_inst_e) & 
                        (inst_vld_e | intr_vld_e)}} & thr_e;
   assign rb_fromd = {4{(rb1_inst_d | rt1_inst_d) & 
                        (inst_vld_d | intr_vld_d)}} & thr_d;
   assign rb_froms = {4{rb_stg_s & inst_vld_s_crit}} & thr_f;   
   assign rb_w2 = rb_frome | rb_fromd;
   assign rb_for_iferr_e = {4{retract_iferr_e}} & thr_e;

//------------------------------   
// Branch Control
//------------------------------
   // final portion of branch evaluation
   wire brtaken_e_l;   
   bw_u1_buf_20x UZsize_bcbf(.z(fcl_dcl_regz_e), 
                             .a(exu_ifu_regz_e));
      
   bw_u1_muxi21_6x UZsize_bcmux(.z(brtaken_e_l), 
                                .d0(dcl_fcl_bcregz0_e), 
                                .d1(dcl_fcl_bcregz1_e), 
                                .s(exu_ifu_regz_e));

   bw_u1_inv_15x UZsize_bcinv(.z(brtaken_e), 
                              .a(brtaken_e_l));

   // Branch is taken in the E stage to thr_e.  Below we check to see
   // if this is the same as the next thread we will switch to

   // isolate non critical section
   bw_u1_buf_5x UZsize_btbuf(.z (brtaken_unq_e),
                             .a (brtaken_e));
   assign brtaken_buf_e = brtaken_unq_e & inst_vld_qual_e & ~kill_curr_e;
   assign fcl_esl_brtaken_e = brtaken_buf_e;

//   assign thr_match_ne_norst = thr_match_ne & ~rst_sw_bf;
//   assign brto_nxtthr_bf  = thr_match_ne & brtaken_e;
   bw_u1_nand2_4x UZsize_btkn_ntl(.a (brtaken_e),
                                  .b (thr_match_ne),
                                  .z (brto_nxtthr_bf_l));

//   bw_u1_inv_8x UZsize_btkn_bf(.a (brto_nxtthr_bf_l),
//                               .z (brto_nxtthr_bf));

   dff_s #(1) br_ff(.din (brtaken_buf_e),
		              .q   (brtaken_m),
		              .clk (clk),
		              .se  (se), .si(), .so());
   assign fcl_esl_brtaken_m = brtaken_m;
   

//----------------------------------------------------------------------
// PC related control
//----------------------------------------------------------------------

   // Choose next IC address
   // IC address is chosen from
   //    1. Next PC assuming no switch 
   //    2. Branch PC if E stage branch is to next thread
   //    3. Saved F stage Thread PC if we switch threads

   assign fcl_icd_index_sel_ifq_bf = allow_ifq_access_icd_bf;
   assign fcl_ifq_grant_bf = allow_ifq_access_icd_bf;

   // Select branch PC
//   assign fcl_fdp_icaddr_sel_br_bf_l = ~(~all_stallreq &
//					                               brto_nxtthr_bf    &
//					                               switch_bf);
//
//   // Select the switch PC from thread PC register
//   assign fcl_fdp_icaddr_sel_swpc_bf_l = ~(~all_stallreq &
//					                                 ~usen_bf &
//					                                 ~brto_nxtthr_bf &
//					                                 switch_bf);
//
//   // Select current thread's next PC or IC write addr (PC/PC+4/I$ wraddr)
//   assign fcl_fdp_icaddr_sel_curr_bf_l = ~(~all_stallreq &
//					                                 ~(stall_f | usep_bf) & 
//					                                 ~switch_bf);
//   
//   assign fcl_fdp_icaddr_sel_ifq_bf_l = ~(all_stallreq |
//					                                (stall_f | usep_bf) & ~switch_bf |
//					                                ~brto_nxtthr_bf & usen_bf &
//					                                (switch_bf | stall_f | usep_bf));
   
   

//   assign sw_or_async_stall = (switch_bf & ~rst_stallreq | rst_sw_bf);
   wire   sw_or_async_stall_l;
   assign rst_stallreq_l = ~rst_stallreq;
   bw_u1_aoi21_4x UZsize_swstl_aoi(.z  (sw_or_async_stall_l),
                                   .a  (rst_sw_bf),
                                   .b1 (switch_bf),
                                   .b2 (rst_stallreq_l));
   assign sw_or_async_stall = ~sw_or_async_stall_l;

//   assign icadr_selbr = sw_or_async_stall & brto_nxtthr_bf;
   assign sw_match_ne_norst = sw_or_async_stall & thr_match_ne;
   bw_u1_nand2_10x UZfix_icad_br(.a (brtaken_e),
                                 .b (sw_match_ne_norst),
                                 .z (icadr_selbr_l));

//   assign icadr_selsw = sw_or_async_stall & ~brto_nxtthr_bf;
   bw_u1_nand2_15x UZfix_icad_sw(.a (brto_nxtthr_bf_l),
                                 .b (sw_or_async_stall),
                                 .z (icadr_selsw_l));
   

   // select next PC
   assign fcl_fdp_pcbf_sel_br_bf_l = icadr_selbr_l;
   assign fcl_fdp_pcbf_sel_swpc_bf_l = icadr_selsw_l ;
   assign fcl_fdp_pcbf_sel_nosw_bf_l = ~sw_or_async_stall_l;

   // Select PC to switch to in the event of a switch
   // No need to protect during scan
   // NOTE: SWL guarantees nextthr_bf is one hot
//   assign fcl_fdp_next_thr_bf_l = rst_stallreq_d1 ? ~rstint_penc :
//                                                    ~dtu_fcl_nextthr_bf;

   wire [3:0] next_thr_bf_l;
   wire       nt_sel_rst;
   assign     nt_sel_rst = rst_stallreq_d1 | rst_tri_en;
   
   bw_u1_muxi21_2x UZfix_nthr_mx0(.z (next_thr_bf_l[0]),
                                  .d0 (dtu_fcl_nextthr_bf[0]),
                                  .d1 (rstint_penc[0]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx1(.z (next_thr_bf_l[1]),
                                  .d0 (dtu_fcl_nextthr_bf[1]),
                                  .d1 (rstint_penc[1]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx2(.z (next_thr_bf_l[2]),
                                  .d0 (dtu_fcl_nextthr_bf[2]),
                                  .d1 (rstint_penc[2]),
                                  .s  (nt_sel_rst));
   bw_u1_muxi21_2x UZfix_nthr_mx3(.z (next_thr_bf_l[3]),
                                  .d0 (dtu_fcl_nextthr_bf[3]),
                                  .d1 (rstint_penc[3]),
                                  .s  (nt_sel_rst));
   assign     fcl_fdp_next_thr_bf_l = next_thr_bf_l;
   

//   assign nextthr_bf_buf = dtu_fcl_nextthr_bf;
   bw_u1_buf_20x UZsize_ntbf0(.a (dtu_fcl_nextthr_bf[0]),
                              .z (nextthr_bf_buf[0]));
   bw_u1_buf_20x UZsize_ntbf1(.a (dtu_fcl_nextthr_bf[1]),
                              .z (nextthr_bf_buf[1]));
   bw_u1_buf_20x UZsize_ntbf2(.a (dtu_fcl_nextthr_bf[2]),
                              .z (nextthr_bf_buf[2]));
   bw_u1_buf_20x UZsize_ntbf3(.a (dtu_fcl_nextthr_bf[3]),
                              .z (nextthr_bf_buf[3]));
   // use 6x
   assign fcl_fdp_next_ctxt_bf_l[2:0] = ~nextthr_bf_buf[2:0] | {3{rst_tri_en}};
   assign fcl_fdp_next_ctxt_bf_l[3] = ~nextthr_bf_buf[3] & ~rst_tri_en;

//   assign nextthr_final_bf = switch_bf ? dtu_fcl_nextthr_bf : thr_f;
   wire [3:0] nextthr_final_bf_l;
   bw_u1_muxi21_2x UZfix_ntfmux0(.z  (nextthr_final_bf_l[0]),
                                .d0 (thr_f[0]),
                                .d1 (dtu_fcl_nextthr_bf[0]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf0(.z (nextthr_final_bf[0]),
                                 .a (nextthr_final_bf_l[0]));

   bw_u1_muxi21_2x UZfix_ntfmux1(.z  (nextthr_final_bf_l[1]),
                                .d0 (thr_f[1]),
                                .d1 (dtu_fcl_nextthr_bf[1]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf1(.z (nextthr_final_bf[1]),
                                 .a (nextthr_final_bf_l[1]));

   bw_u1_muxi21_2x UZfix_ntfmux2(.z  (nextthr_final_bf_l[2]),
                                .d0 (thr_f[2]),
                                .d1 (dtu_fcl_nextthr_bf[2]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf2(.z (nextthr_final_bf[2]),
                                 .a (nextthr_final_bf_l[2]));

   bw_u1_muxi21_2x UZfix_ntfmux3(.z  (nextthr_final_bf_l[3]),
                                .d0 (thr_f[3]),
                                .d1 (dtu_fcl_nextthr_bf[3]),
                                .s  (switch_bf));
   bw_u1_inv_8x UZsize_ntfin_buf3(.z (nextthr_final_bf[3]),
                                 .a (nextthr_final_bf_l[3]));
   
   
   // decode trap thread
   dff_s #(2) ld_trp_reg(.din ({tlu_ifu_trappc_vld_w1,
                              tlu_ifu_trapnpc_vld_w1}),
                       .q   ({trappc_vld_w2,
                              trapnpc_vld_w2}),
                       .clk (clk), .se(se), .si(), .so());

   dff_s #(2) trp_tid_reg(.din (tlu_ifu_trap_tid_w1[1:0]),
                        .q   (trap_tid_w2[1:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign trap_thr[0] = ~trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[1] = ~trap_tid_w2[1] &  trap_tid_w2[0];
   assign trap_thr[2] =  trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[3] =  trap_tid_w2[1] &  trap_tid_w2[0];

   assign load_tpc[3:0] = {4{trappc_vld_w2}} & trap_thr |
	                   rb_w2 |
	                   {4{rb_stg_w | ims_flush_coll_w}} & thr_w |
//                     {4{dec_fcl_kill4sta_e}} & thr_e |
	                   {4{flush_sonly_qual_m}} & thr_m;
   // mmckeown: determine if trap this cycle
   assign fcl_esl_thr_trap_bf = load_tpc;

   assign load_bpc[3:0] = {4{brtaken_buf_e}} & thr_e;
   assign load_pcp4[3:0] = {4{~part_stall_thisthr_f &
                              ~iferrto_thisthr_d1 |
                              arst_vld_f |
                              async_intr_vld_s}}     & thr_f;

   always @ (/*AUTOSENSE*/load_bpc or load_pcp4 or load_tpc)
     begin
//	      if (fcl_reset)
//	        begin // RESET PC is loaded to T0
//	           fcl_fdp_tpcbf_sel_old_bf_l = 4'b0001;
//	           fcl_fdp_tpcbf_sel_pcp4_bf_l = 4'b1110;
//	           fcl_fdp_tpcbf_sel_trap_bf_l = 4'b1111;
//	           fcl_fdp_tpcbf_sel_brpc_bf_l = 4'b1111;
//	        end // if (reset)
//	      else 
//	        begin
	      fcl_fdp_tpcbf_sel_old_bf_l = (load_bpc | load_tpc | load_pcp4);
	      fcl_fdp_tpcbf_sel_brpc_bf_l = ~load_bpc | load_tpc | load_pcp4;
	      fcl_fdp_tpcbf_sel_pcp4_bf_l = ~load_pcp4 | load_tpc;
	      fcl_fdp_tpcbf_sel_trap_bf_l = ~load_tpc;
     end // always @ (...

   // Track correctible errors
   assign irf_ce_m = exu_ifu_ecc_ce_m & ~trap_m & inst_vld_m & ~kill_curr_m;
   dff_s #(1) irfcew_ff(.din (irf_ce_m),
		                .q   (irf_ce_w),
		                .clk (clk), .se(se), .si(), .so());

   // track if ldhit was actually a miss
   // D and S stage are rolled back through the normal D stage retract
   // process.  
   assign mark4rb_d = lsu_ifu_dc_parity_error_w2 & thr_match_dw2 & 
                      (inst_vld_d | intr_vld_d);
   assign mark4rb_s = lsu_ifu_dc_parity_error_w2 & thr_match_fw2 & 
                      (inst_vld_s | intr_vld_s);

   assign mark4rb_e = lsu_ifu_dc_parity_error_w2 & thr_match_ew2 & 
                      (inst_vld_e | intr_vld_e) & 
                        ~dtu_inst_anull_e & ~kill_curr_e;

   dff_s #(2) markrb_reg(.din ({mark4rb_m,
                              mark4rb_e}),
                       .q   ({mark4rb_w,
                              mark4rb_m}),
                       .clk (clk),
                       .se  (se), .si(), .so());
   
   // Rollback from W on irf/frf ce and on a dcache parity error
   assign rb_stg_w = irf_ce_w & inst_vld_w & no_iftrap_w | 
	                   ffu_ifu_fst_ce_w & inst_vld_w & no_iftrap_w |
                     rb_intr_w & intr_vld_w |
                     mark4rb_w |
                     fcl_dtu_resum_thr_w | 
		                 fcl_dtu_nuke_thr_w;

   // flush after hardware micro trap
//   assign ifu_tlu_flush_w = irf_ce_w | fcl_dtu_nuke_thr_w | mark4rb_w |
//                            fcl_dtu_resum_thr_w;
   // very critical
   assign ifu_tlu_flush_m = (exu_ifu_ecc_ce_m & inst_vld_m & ~trap_m |
                             (resumint_m | nuke_thr_m) & 
                             intr_vld_m & ~rstint_m |
                             rb_intr_m | 
                             mark4rb_m);
   assign utrap_flush_m =  ifu_tlu_flush_m & ~kill_local_m;
   dff_s #(1) flw_ff(.din (utrap_flush_m),
                   .q   (utrap_flush_w),
                   .clk (clk), .se(se), .si(), .so());
   assign ifu_tlu_flush_w = utrap_flush_w;
   assign fcl_swl_flush_w =  (irf_ce_w & inst_vld_w & no_iftrap_w | 
                              rb_intr_w & intr_vld_w |
                              mark4rb_w |
                              fcl_dtu_resum_thr_w | 
		                          fcl_dtu_nuke_thr_w);

   // tells swl to flush and then wake up
   assign fcl_swl_flush_wake_w = fcl_swl_flush_w & ~mark4rb_w;
   
   // if the same instruction keeps hitting ce's disable ce detection
   // count how many ce's occur to a given thread
   assign any_ce_w = ffu_ifu_fst_ce_w | irf_ce_w;
   
   assign ce_cnt1_nxt = (({4{any_ce_w & inst_vld_w}} & thr_w & 
                          ce_cnt0) ^ ce_cnt1) & ~ce_cnt_rst;
   assign ce_cnt0_nxt = (({4{any_ce_w & inst_vld_w}} & thr_w) ^ 
                         ce_cnt0) & ~ce_cnt_rst;

   assign ce_cnt_rst = thr_w & {4{inst_vld_w & ~any_ce_w}} | {4{fcl_reset}};

   dff_s #(8) cecnt_reg(.din ({ce_cnt1_nxt, ce_cnt0_nxt}),
                      .q   ({ce_cnt1, ce_cnt0}),
                      .clk (clk),
                      .se(se), .si(), .so());

   // find the count for the current d stage thread
   assign ce_val1_d = (thr_d[0] & ce_cnt1[0] | 
                       thr_d[1] & ce_cnt1[1] | 
                       thr_d[2] & ce_cnt1[2] | 
                       thr_d[3] & ce_cnt1[3]);

   assign ce_val0_d = (thr_d[0] & ce_cnt0[0] | 
                       thr_d[1] & ce_cnt0[1] | 
                       thr_d[2] & ce_cnt0[2] | 
                       thr_d[3] & ce_cnt0[3]);

   // if count hits 3 disable ce's
   assign disable_ce_d = ce_val1_d & ce_val0_d;

   dff_s #(1) disce_ff(.din (disable_ce_d),
                     .q   (disable_ce_e),
                     .clk (clk), .se(se), .si(), .so());
   assign ifu_exu_disable_ce_e = disable_ce_e;
   
   // select error/trap/utrap rollback PC
   assign fcl_fdp_trrbpc_sel_trap_bf_l = 
		                ~({4{trappc_vld_w2}} & trap_thr);

   assign fcl_fdp_trrbpc_sel_err_bf_l = 
                  ({4{trappc_vld_w2}} & trap_thr) |
	                 ~({4{rb_stg_w}} & thr_w);
   
   assign fcl_fdp_trrbpc_sel_rb_bf_l = 
                  ({4{trappc_vld_w2}} & trap_thr) |
		               ({4{rb_stg_w}} & thr_w) |		   
	                ~(rb_frome & rb_fromd);
   
   assign fcl_fdp_trrbpc_sel_pcs_bf_l = 
                 ({4{trappc_vld_w2}} & trap_thr) | 
		               ({4{rb_stg_w}} & thr_w) |		   
	                 (rb_frome & rb_fromd);
   
   // select next S stage Thr PC
   assign fcl_fdp_nextpcs_sel_pce_f_l = ~rb_frome;
   assign fcl_fdp_nextpcs_sel_pcd_f_l = rb_frome | ~rb_fromd;
   assign fcl_fdp_nextpcs_sel_pcf_f_l = rb_frome | rb_fromd |
	                                ~(thr_f & {4{~part_stall_thisthr_f &
                                               ~iferrto_thisthr_d1 |
                                               arst_vld_f |
                                               async_intr_vld_s}});
   assign fcl_fdp_nextpcs_sel_pcs_f_l = rb_frome | rb_fromd | 
	                                (thr_f & {4{~part_stall_thisthr_f &
                                              ~iferrto_thisthr_d1 |
                                              arst_vld_f |
                                              async_intr_vld_s}});
   
   // next S2 stage pc and npc select
   assign thr_f_dec[3:1] = thr_f_crit[3:1] & {3{~rst_tri_en}};
   assign thr_f_dec[0] = thr_f_crit[0] | rst_tri_en;
   assign fcl_fdp_thr_s2_l = ~thr_f_dec;     // thr_f = thr_s2


   // Select NextPC from
   //    1. Trap NextPC (if the tnpc is valid)
   //    2. reset PC
   //    3. incremented PC (PC+4)
   //    4. old PC (in the event of a stall)

   // Load the trap PC to the BF stage NPC.  (The BF stage NPC is used
   // only for storing the next PC from the TLU
   assign fcl_fdp_thrtnpc_sel_tnpc_l = ~({4{trapnpc_vld_w2}} & trap_thr);

   assign fcl_fdp_thrtnpc_sel_npcw_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                       ~({4{rb_stg_w}} & thr_w);

   assign fcl_fdp_thrtnpc_sel_pcf_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                      ({4{rb_stg_w}} & thr_w) |
	                                        (~({4{ims_flush_coll_w}} & thr_w) &
                                           ~({4{flush_sonly_qual_m}} & thr_m));
                                       //   {4{dec_fcl_kill4sta_e}} & thr_e);
   
   assign fcl_fdp_thrtnpc_sel_old_l = ({4{trapnpc_vld_w2}} & trap_thr) |
	                                      ({4{rb_stg_w}} & thr_w) |
	                                      ({4{ims_flush_coll_w}} & thr_w) |
                                        ({4{flush_sonly_qual_m}} & thr_m);
                                         // {4{dec_fcl_kill4sta_e}} & thr_e);
   
   assign ntpc_vld_nxt = fcl_fdp_thrtnpc_sel_old_l | 
	                       ntpc_vld & ({4{(part_stall_thisthr_f |
                                         iferrto_thisthr_d1) & 
                                        ~arst_vld_f &
                                        ~async_intr_vld_s}} | ~thr_f) &
                                  ~({4{trappc_vld_w2}} & trap_thr);
   
   dffr_s #(4) ntpcv_reg(.din  (ntpc_vld_nxt),
		     .clk  (clk),
		     .q    (ntpc_vld),
		     .rst  (fcl_reset),
		     .se   (se), .si(), .so());

   assign ntpc_thisthr = (thr_f[0] & ntpc_vld[0] |
			                    thr_f[1] & ntpc_vld[1] |
			                    thr_f[2] & ntpc_vld[2] |
			                    thr_f[3] & ntpc_vld[3]);

//   assign fcl_fdp_noswpc_sel_rst_l_bf = 1'b1; 
   assign fcl_fdp_noswpc_sel_tnpc_l_bf = ~ntpc_thisthr;
   assign fcl_fdp_noswpc_sel_old_l_bf = ntpc_thisthr | inst_vld_f | arst_vld_f;
   assign fcl_fdp_noswpc_sel_inc_l_bf = ntpc_thisthr | ~inst_vld_f & ~arst_vld_f;
   
   
   // Don't need noswpc_sel_old anymore (this is always 1)
//   always @(/*AUTOSENSE*/ntpc_vld or reset or thr_f)
//     begin
//	      if (reset)
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b0;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;
//	        end
//	      else if ((ntpc_vld & thr_f) != 4'b0000)
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b0;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;	
//	        end // if ((ntpc_vld & thr_f) != 4'b0000)
////	else if (ely_stall_thisthr_f)
////	  begin
////	     fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
////	     fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
////	     fcl_fdp_noswpc_sel_inc_l_bf = 1'b1;
////	     fcl_fdp_noswpc_sel_old_l_bf = 1'b0;	     
////	  end // if (ely_stall_thisthr_f)
//	      else 
//	        begin
//	           fcl_fdp_noswpc_sel_tnpc_l_bf = 1'b1;
//	           fcl_fdp_noswpc_sel_rst_l_bf = 1'b1;	
//	           fcl_fdp_noswpc_sel_inc_l_bf = 1'b0;
//	           fcl_fdp_noswpc_sel_old_l_bf = 1'b1;	
//	        end // else: 
//	      
//     end // always @ (...

   // NOTE: direct branch vs indirect branch select goes from dtu to fdp

//----------------------------------------------------------------------
// Instruction Register Related Control
//----------------------------------------------------------------------

   // use NIR if no read previously
   assign fcl_fdp_usenir_sel_nir_s1 = usenir_s1;


   assign  fcl_fdp_inst_sel_nop_s_l = ~(ely_stall_thisthr_f | 
                                        ~inst_vld_s_crit | 
                                        force_intr_s | 
                                        immu_fault_f);
   
   assign  fcl_fdp_inst_sel_switch_s_l = ~switch_s2 |
                                        (ely_stall_thisthr_f | 
                                         ~inst_vld_s_crit | 
                                         force_intr_s | 
                                         immu_fault_f);

   assign  fcl_fdp_inst_sel_nir_s_l = ~usenir_s1 |
                                        (switch_s2 |
                                         ely_stall_thisthr_f | 
                                         ~inst_vld_s_crit | 
                                         force_intr_s | 
                                         immu_fault_f);
   
   assign  fcl_fdp_inst_sel_curr_s_l = (usenir_s1 |
                                        switch_s2 |
                                        ely_stall_thisthr_f | 
                                        ~inst_vld_s_crit | 
                                        force_intr_s | 
                                        immu_fault_f);
   
   
   // Instruction Output Mux
//   always @ (/*AUTOSENSE*/ely_stall_thisthr_f or force_intr_s
//             or immu_fault_f or inst_vld_s_crit or switch_s2
//             or usenir_s1)
//     begin
//	      if (ely_stall_thisthr_f | ~inst_vld_s_crit | force_intr_s | 
//            immu_fault_f) 
//	        begin // stalled or imiss
//	           fcl_fdp_inst_sel_nop_s_l = 1'b0;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else if (switch_s2) 
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b0;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else if (usenir_s1) 
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b0;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b1;
//	        end
//	      else
//	        begin
//	           fcl_fdp_inst_sel_nop_s_l = 1'b1;
//	           fcl_fdp_inst_sel_switch_s_l = 1'b1;
//	           fcl_fdp_inst_sel_nir_s_l = 1'b1;
//	           fcl_fdp_inst_sel_curr_s_l = 1'b0;
//	        end // else: !if(switch_s2 | stall_s1)
//     end // always @ (...

   // thread IR input muxes
   assign fcl_fdp_tinst_sel_rb_s_l   = ~rb_w2;
   assign fcl_fdp_tinst_sel_ifq_s_l  = rb_w2 | ~ifq_fcl_fill_thr;
   assign fcl_fdp_tinst_sel_curr_s_l = ~val_thr_s1 | rb_w2 | ifq_fcl_fill_thr; 
   assign fcl_fdp_tinst_sel_old_s_l  = val_thr_s1 | rb_w2 | ifq_fcl_fill_thr; 

   // Select rollback instruction
   assign fcl_fdp_rbinst_sel_inste_s = {4{rb2_inst_e | rt2_inst_e}} & 
                                       thr_e;

   // thread NIR input muxes  (2:1 no need to protect)
   assign fcl_fdp_thr_s1_l = ~thr_s1 | {4{stall_s1}};

   // select appropriate NIR
   assign dec_thr_s1_l[0] = ~(thr_s1[0] | rst_tri_en);
   assign dec_thr_s1_l[3:1] = ~(thr_s1[3:1] & {3{~rst_tri_en}});
   
   assign fcl_fdp_nirthr_s1_l = dec_thr_s1_l; 
   

//--------------------
// rdsr data to exu
//--------------------   

   dff_s #(1) pcrsr_ff(.din  (dec_fcl_rdsr_sel_pc_d),
		               .clk  (clk),
		               .q    (rdsr_sel_pc_e),
		               .se   (se), .si(), .so());
   dff_s #(1) thrrsr_ff(.din  (dec_fcl_rdsr_sel_thr_d),
		                .clk  (clk),
		                .q    (rdsr_sel_thr_e),
		                .se   (se), .si(), .so());
   // make sure they are exclusive
   assign fcl_fdp_rdsr_sel_pc_e_l = ~rdsr_sel_pc_e;
   assign fcl_fdp_rdsr_sel_thr_e_l = ~(~rdsr_sel_pc_e & rdsr_sel_thr_e);
   assign fcl_fdp_rdsr_sel_ver_e_l = ~(~rdsr_sel_pc_e & ~rdsr_sel_thr_e);

//--------------------------------------------------------------
// Reg file control
//--------------------------------------------------------------

// Some decode is done here since these signals are in the crit path

   // Regfile enables are only power saving features.  So they don't
   // have to be exact, as long as they are on, a super set of when
   // they need to be on.

   // mmckeown: inst_vld_f not high when doing a replay, so we need
   //           to add this condition

   // Enable rs3 if store or atomic or mov
   assign ifu_exu_ren3_s =  (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed))
                            & fdp_fcl_op_s[1] & fdp_fcl_op3_s[2] &
	                         (fdp_fcl_op_s[0] | fdp_fcl_op3_s[5]);

   // enable rs2 if i=0 and !branch or CAS
   // cas not fully decoded;  i=inst[13];
   assign ifu_exu_ren2_s = (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed)) 
                           & fdp_fcl_op_s[1] &
			               (~fdp_fcl_ibit_s | fdp_fcl_op_s[0] & fdp_fcl_op3_s[5]);

   // rs1 is read if this is not (a branch on cc or no-op/sethi)
   assign ifu_exu_ren1_s = (inst_vld_f | (config_dtu_esl_en & inst_vld_s2_ed)) 
                           & (fdp_fcl_op_s[1] |     // not br/call
			               fdp_fcl_op3_s[4] & fdp_fcl_op3_s[3]);  // BPR

   //-------------------------------------
   // Generate oddwin signal for rs and rd
   //-------------------------------------
   assign fcl_fdp_oddwin_s = (exu_ifu_oddwin_s[0] & thr_f[0] |
                              exu_ifu_oddwin_s[1] & thr_f[1] |
                              exu_ifu_oddwin_s[2] & thr_f[2] |
                              exu_ifu_oddwin_s[3] & thr_f[3]);

   dff_s #(1) oddwin_ff(.din (fcl_fdp_oddwin_s),
		                  .clk (clk),
		                  .q   (fcl_imd_oddwin_d),
		                  .se  (se), .si(), .so());
   

   sink #(2) s0(.in (sas_thrid_w));
endmodule // sparc_ifu_fcl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_fdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_fdp
//  Description:
//    The fdp contains the pc's for all four threads and the PC and
//    nPC for all pipestages register.  The fetcher also contains two
//    adders for doing PC + br_offset and PC + 4.
//    The fdp also holds the last fetched icache data for each thread
//    and the next instruction register, which has the top half of the
//    double instruction bundle which is fetched from the icache.
*/
////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting
















//`define VER_MAXTL      {5'b0, fcl_fdp_hprivmode_e, 2'b10}
//`define VER_IMPL_MASK  24'h002301

//`define VERSION_REG_HPV  {`VER_MANUF, `VER_IMPL_MASK, `VER_MAXGL, 5'b0, fcl_fdp_hprivmode_e, 2'b10, `VER_MAXWIN}

//`define VERSION_REG      {`VER_MANUF, `VER_IMPL_MASK, `VER_MAXGL, 8'h06, `VER_MAXWIN}

//PITON_PROTO enables all FPGA related modifications





module sparc_ifu_fdp(/*AUTOARG*/
   // Outputs
   so, fdp_itlb_ctxt_bf, fdp_icd_vaddr_bf, fdp_icv_index_bf,
   fdp_erb_pc_f, fdp_dtu_inst_s, ifu_exu_pc_d, ifu_exu_rs1_s,
   ifu_exu_rs2_s, ifu_exu_rs3_s, ifu_tlu_pc_m, ifu_tlu_npc_m,
   ifu_tlu_pc_oor_e, ifu_exu_pcver_e, fdp_fcl_swc_s2,
   fdp_fcl_pc_oor_vec_f, fdp_fcl_pc_oor_e, fdp_fcl_op_s,
   fdp_fcl_op3_s, fdp_fcl_ibit_s,
   fdp_esl_t0inst_next_s2,

   fdp_esl_t1inst_next_s2,














   fdp_esl_t0inst_paddr_next_s2,

   fdp_esl_t1inst_paddr_next_s2,














   fdp_esl_t0pc_next_s2,

   fdp_esl_t1pc_next_s2,














   fdp_esl_brtrp_target_pc_bf_f,
   // Inputs
   rclk, se, si, const_maskid, lsu_t0_pctxt_state,
   lsu_t1_pctxt_state, lsu_t2_pctxt_state, lsu_t3_pctxt_state,
   exu_ifu_brpc_e, tlu_ifu_trappc_w2, tlu_ifu_trapnpc_w2,
   tlu_itlb_dmp_nctxt_g, tlu_itlb_dmp_actxt_g, tlu_itlb_tte_tag_w2,
   dtu_fdp_thrconf_e, icd_fdp_fetdata_s1, icd_fdp_topdata_s1,
   ifq_fdp_fill_inst, fcl_fdp_oddwin_s, fcl_fdp_pcoor_vec_f,
   fcl_fdp_pcoor_f, fcl_fdp_mask32b_f, fcl_fdp_addr_mask_d,
   fcl_fdp_tctxt_sel_prim, fcl_fdp_usenir_sel_nir_s1,
   fcl_fdp_rbinst_sel_inste_s, fcl_fdp_thrtnpc_sel_tnpc_l,
   fcl_fdp_thrtnpc_sel_npcw_l, fcl_fdp_thrtnpc_sel_pcf_l,
   fcl_fdp_thrtnpc_sel_old_l, fcl_fdp_thr_s1_l,
   fcl_fdp_next_thr_bf_l, fcl_fdp_next_ctxt_bf_l, fcl_fdp_thr_s2_l,
   fcl_fdp_nirthr_s1_l, fcl_fdp_tpcbf_sel_pcp4_bf_l,
   fcl_fdp_tpcbf_sel_brpc_bf_l, fcl_fdp_tpcbf_sel_trap_bf_l,
   fcl_fdp_tpcbf_sel_old_bf_l, fcl_fdp_pcbf_sel_swpc_bf_l,
   fcl_fdp_pcbf_sel_nosw_bf_l, fcl_fdp_pcbf_sel_br_bf_l,
   fcl_fdp_trrbpc_sel_trap_bf_l, fcl_fdp_trrbpc_sel_rb_bf_l,
   fcl_fdp_trrbpc_sel_err_bf_l, fcl_fdp_trrbpc_sel_pcs_bf_l,
   fcl_fdp_noswpc_sel_tnpc_l_bf, fcl_fdp_noswpc_sel_old_l_bf,
   fcl_fdp_noswpc_sel_inc_l_bf, fcl_fdp_nextpcs_sel_pce_f_l,
   fcl_fdp_nextpcs_sel_pcd_f_l, fcl_fdp_nextpcs_sel_pcs_f_l,
   fcl_fdp_nextpcs_sel_pcf_f_l, fcl_fdp_rdsr_sel_pc_e_l,
   fcl_fdp_rdsr_sel_ver_e_l, fcl_fdp_rdsr_sel_thr_e_l,
   fcl_fdp_inst_sel_curr_s_l, fcl_fdp_inst_sel_switch_s_l,
   fcl_fdp_inst_sel_nir_s_l, fcl_fdp_inst_sel_nop_s_l,
   fcl_fdp_tinst_sel_curr_s_l, fcl_fdp_tinst_sel_rb_s_l,
   fcl_fdp_tinst_sel_old_s_l, fcl_fdp_tinst_sel_ifq_s_l,
   fcl_fdp_dmpthr_l, fcl_fdp_ctxt_sel_dmp_bf_l,
   fcl_fdp_ctxt_sel_sw_bf_l, fcl_fdp_ctxt_sel_curr_bf_l,
   itlb_fdp_paddr_s, fcl_fdp_tlbmiss_s1, ifq_fdp_fill_paddr,
   config_dtu_esl_en, esl_fdp_sync_pcs_bf, esl_fdp_issue_prev_inst_s,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data,

   fdp_fcl_jtag_breakpoint_hit
   );

   input       rclk,
	             se,
	             si;

   input [7:0] const_maskid;

   input [12:0] lsu_t0_pctxt_state,   // primary context
		            lsu_t1_pctxt_state,
		            lsu_t2_pctxt_state,
		            lsu_t3_pctxt_state;

   //   input 	 exu_ifu_va_oor_e;
   input [47:0] exu_ifu_brpc_e;        // br address for dir branch

   input [48:0] tlu_ifu_trappc_w2,     // trap/exception PC
		            tlu_ifu_trapnpc_w2;    // next trap PC

   input        tlu_itlb_dmp_nctxt_g,
		            tlu_itlb_dmp_actxt_g;

   input [12:0] tlu_itlb_tte_tag_w2;

//   input [`IC_IDX_HI:4] ifq_fdp_icindex_bf;   // index + 1 bit for 16B write

   input [40:0]         dtu_fdp_thrconf_e;

   input [32:0]         icd_fdp_fetdata_s1,    // 4 inst + 4 sw bits
		                    icd_fdp_topdata_s1;    // next instruction

   input [32:0]         ifq_fdp_fill_inst;    // icache miss return

   input                fcl_fdp_oddwin_s;
   input [3:0]          fcl_fdp_pcoor_vec_f;
   input                fcl_fdp_pcoor_f;
   input                fcl_fdp_mask32b_f;
   input                fcl_fdp_addr_mask_d;
   input [3:0]          fcl_fdp_tctxt_sel_prim;

   // 2:1 mux selects
   input                fcl_fdp_usenir_sel_nir_s1;   // same as usenir_d2
   input [3:0]          fcl_fdp_rbinst_sel_inste_s;  // rollback 1 or 2

   input [3:0]          fcl_fdp_thrtnpc_sel_tnpc_l,  // load npc
	                      fcl_fdp_thrtnpc_sel_npcw_l,
		                    fcl_fdp_thrtnpc_sel_pcf_l,
	                      fcl_fdp_thrtnpc_sel_old_l;

   input [3:0]          fcl_fdp_thr_s1_l;            // s2 thr (64*5 muxes)

   // other mux selects
   input [3:0]          fcl_fdp_next_thr_bf_l;  // for thrpc output mux
   input [3:0]          fcl_fdp_next_ctxt_bf_l; // for ctxt output mux

   input [3:0]          fcl_fdp_thr_s2_l;       // s2 thr (64*5 muxes)
   input [3:0]          fcl_fdp_nirthr_s1_l;        // same as thr_s1, but protected

   input [3:0]          fcl_fdp_tpcbf_sel_pcp4_bf_l, // selects for thread PC muxes
	                      fcl_fdp_tpcbf_sel_brpc_bf_l,
	                      fcl_fdp_tpcbf_sel_trap_bf_l,
	                      fcl_fdp_tpcbf_sel_old_bf_l;

   input                fcl_fdp_pcbf_sel_swpc_bf_l,
	                      fcl_fdp_pcbf_sel_nosw_bf_l,
	                      fcl_fdp_pcbf_sel_br_bf_l;

   input [3:0]          fcl_fdp_trrbpc_sel_trap_bf_l,
	                      fcl_fdp_trrbpc_sel_rb_bf_l,
	                      fcl_fdp_trrbpc_sel_err_bf_l,
	                      fcl_fdp_trrbpc_sel_pcs_bf_l;

   input                fcl_fdp_noswpc_sel_tnpc_l_bf,    // next pc select from trap,
	                      fcl_fdp_noswpc_sel_old_l_bf,
	                      fcl_fdp_noswpc_sel_inc_l_bf;

   input [3:0]          fcl_fdp_nextpcs_sel_pce_f_l,
	                      fcl_fdp_nextpcs_sel_pcd_f_l,
	                      fcl_fdp_nextpcs_sel_pcs_f_l,
	                      fcl_fdp_nextpcs_sel_pcf_f_l;

   input                fcl_fdp_rdsr_sel_pc_e_l,
	                      fcl_fdp_rdsr_sel_ver_e_l,
	                      fcl_fdp_rdsr_sel_thr_e_l;

   input                fcl_fdp_inst_sel_curr_s_l,       // selects for inst_s2
	                      fcl_fdp_inst_sel_switch_s_l,
	                      fcl_fdp_inst_sel_nir_s_l,
	                      fcl_fdp_inst_sel_nop_s_l;

   input [3:0]          fcl_fdp_tinst_sel_curr_s_l, // selects for tinst regs
	                      fcl_fdp_tinst_sel_rb_s_l,
	                      fcl_fdp_tinst_sel_old_s_l,
	                      fcl_fdp_tinst_sel_ifq_s_l;

   input [3:0]          fcl_fdp_dmpthr_l;

   input                fcl_fdp_ctxt_sel_dmp_bf_l,
	                      fcl_fdp_ctxt_sel_sw_bf_l,
	                      fcl_fdp_ctxt_sel_curr_bf_l;

   input [39:10]        itlb_fdp_paddr_s;
   input                fcl_fdp_tlbmiss_s1;
   input [39:2]         ifq_fdp_fill_paddr;

   input                config_dtu_esl_en;
   input                esl_fdp_issue_prev_inst_s;
   input                esl_fdp_sync_pcs_bf;

   // jtag
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

   output wire fdp_fcl_jtag_breakpoint_hit;

   output               so;
   output [12:0]        fdp_itlb_ctxt_bf;
   output [47:2]        fdp_icd_vaddr_bf;   // 11:2 is index to ic
   output [(6 + 5):5]        fdp_icv_index_bf;
   output [47:0]        fdp_erb_pc_f;
   output [31:0]        fdp_dtu_inst_s;     // 32b inst + switch bit

   output [47:0]        ifu_exu_pc_d;       // PC for rel branch
   output [4:0]         ifu_exu_rs1_s,      // reg file read address
		                    ifu_exu_rs2_s,
		                    ifu_exu_rs3_s;

   output [48:0]        ifu_tlu_pc_m,
		                    ifu_tlu_npc_m;

   output               ifu_tlu_pc_oor_e;

   output [63:0]        ifu_exu_pcver_e;    // PCs to different dests.

   output               fdp_fcl_swc_s2;       // tells whether to switch or not
   output [3:0]         fdp_fcl_pc_oor_vec_f; // PC va hole check
   output               fdp_fcl_pc_oor_e;

   output [1:0]         fdp_fcl_op_s;
   output [5:2]         fdp_fcl_op3_s;
   output               fdp_fcl_ibit_s;

   output [32:0]        fdp_esl_t0inst_next_s2;

   output [32:0]        fdp_esl_t1inst_next_s2;















   output [39:2]        fdp_esl_t0inst_paddr_next_s2;

   output [39:2]        fdp_esl_t1inst_paddr_next_s2;















   output [48:0]        fdp_esl_t0pc_next_s2;

   output [48:0]        fdp_esl_t1pc_next_s2;















   output [3:0]         fdp_esl_brtrp_target_pc_bf_f;

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------

   // local signals

   // Contexts
   wire [12:0] 	curr_ctxt,
		            sw_ctxt,
		            dmp_ctxt,
		            dmp_ctxt_unq,
		            dmp_ctxt1,
		            dmp_ctxt2,
		            t0_ctxt_bf,
		            t1_ctxt_bf,
		            t2_ctxt_bf,
		            t3_ctxt_bf;

   // PCs
   // wire [48:0]  t0pc_f, t1pc_f, t2pc_f, t3pc_f,         // F stage thread PC
   reg  [48:0]  t0pc_f, t1pc_f, t2pc_f, t3pc_f;         // F stage thread PC
		            // t0pc_s, t1pc_s, t2pc_s, t3pc_s,         // S stage thr pc
   wire [48:0]    t0pc_s, t1pc_s, t2pc_s, t3pc_s,         // S stage thr pc
		            t0_next_pcs_f, t1_next_pcs_f, t2_next_pcs_f, t3_next_pcs_f,
                    t1_next_pcs_bf_execdraft_f, t2_next_pcs_bf_execdraft_f,
                    t3_next_pcs_bf_execdraft_f,
		            t0npc_bf, t1npc_bf, t2npc_bf, t3npc_bf, // Next PC in
							                                          // BF stage
                    t1npc_bf_execdraft_bf,
                    t2npc_bf_execdraft_bf,
                    t3npc_bf_execdraft_bf,
		            pc_s, pc_d, pc_e, pc_m, pc_w,
		            npc_s, npc_d, npc_e, npc_m, npc_w,
		            pc_d_adj, npc_d_adj;

   wire [47:0]  pc_bf,
		            swpc_bf,                // PC of next thread if not branch
                pc_f;

   wire [48:0]  nextpc_nosw_bf,         // next pc if no switch
		            am_mask;

   // trap PCs and rollback PCs
   wire [48:0]  t0_trap_rb_pc_bf,
		            t1_trap_rb_pc_bf,
		            t2_trap_rb_pc_bf,
		            t3_trap_rb_pc_bf;

   wire [48:0]  thr_trappc_bf,
		            t0_trapnpc_f,
		            t1_trapnpc_f,
		            t2_trapnpc_f,
		            t3_trapnpc_f,
		            trapnpc0_bf,
		            trapnpc1_bf,
		            trapnpc2_bf,
		            trapnpc3_bf;

   // Branch PCs
   wire [48:0]  pcinc_f;                // incr output
   wire [9:2]   pcinc_s;                // Piped forward incremented PC

   // Instruction Words
   wire [32:0]  inst_s2,                // instruction to switch to in S
                    fdp_inst_bf_execdraft_s,
		            fdp_inst_s,             // instruction to be sent to D
                    fdp_inst_s_prev,
		            t0inst_s1,              // input to thr inst reg in S
		            t1inst_s1,
		            t2inst_s1,
		            t3inst_s1,
		            t0inst_s2,              // thr inst reg output
		            t1inst_s2,
		            t2inst_s2,
		            t3inst_s2;

   // Instruction words paddr
   wire [39:2]  inst_paddr_s2,
                fdp_inst_paddr_s,
                t0inst_paddr_s1,
                t1inst_paddr_s1,
                t2inst_paddr_s1,
                t3inst_paddr_s1,
                t0inst_paddr_s2,
                t1inst_paddr_s2,
                t2inst_paddr_s2,
                t3inst_paddr_s2;

   wire [32:0]  inst_s1;                // fetched instruction in S
   wire [32:0]  inst_s1_bf1;            // buf version of inst_s1

   wire [9:2]   pc_offset_s;            // Pipe forwarded version of pc_f
   wire [39:2]  fetpaddr_s1;            // The physical address of fetched instruction
   wire [39:2]  inst_paddr_s1;          // fetched instruction in S paddr
   wire [39:2]  inst_paddr_s1_bf1;      // buf version of inst_paddr_s1

   wire [32:0]  rb_inst0_s,             // instruction to rollback to
		            rb_inst1_s,             // instruction to rollback to
		            rb_inst2_s,             // instruction to rollback to
		            rb_inst3_s,             // instruction to rollback to
		            inst_d,                 //   rollback 1
		            inst_e;                 //   rollback 2

   // Rollback instructions paddr
   wire [39:2]  rb_inst0_paddr_s,
                rb_inst1_paddr_s,
                rb_inst2_paddr_s,
                rb_inst3_paddr_s,
                inst_paddr_d,
                inst_paddr_e;


   // Next instruction word
   wire [32:0]  nirdata_s1,             // next inst reg contents
		            t0nir,                  // thread NIR reg output
		            t1nir,
		            t2nir,
		            t3nir;

   // NIR physical addresses
   wire [39:2]  toppaddr_s1,
                nirpaddr_s1,
                t0nir_paddr,
                t1nir_paddr,
                t2nir_paddr,
                t3nir_paddr;

   wire         clk;


   //
   // Code start here
   //
   assign       clk = rclk;

//----------------------------------------------------------------------
// Context Reg
//----------------------------------------------------------------------
   assign t0_ctxt_bf = lsu_t0_pctxt_state & {13{fcl_fdp_tctxt_sel_prim[0]}};

 // Use two threads unless this is defined

   assign t1_ctxt_bf = lsu_t1_pctxt_state & {13{fcl_fdp_tctxt_sel_prim[1]}};

   dp_mux2ds #(13) sw_ctxt_mux(.dout (sw_ctxt),
                   .in0  (t0_ctxt_bf),
                   .in1  (t1_ctxt_bf),
                   .sel0_l (fcl_fdp_next_ctxt_bf_l[0]),
                   .sel1_l (fcl_fdp_next_ctxt_bf_l[1]));

   dp_mux2ds #(13) curr_ctxt_mux(.dout (curr_ctxt),
                 .in0  (t0_ctxt_bf),
                 .in1  (t1_ctxt_bf),
                 .sel0_l (fcl_fdp_thr_s2_l[0]),
                 .sel1_l (fcl_fdp_thr_s2_l[1]));

   dp_mux2ds #(13) dmp_ctxt_mux(.dout (dmp_ctxt_unq),
                  .in0  (lsu_t0_pctxt_state),
                  .in1  (lsu_t1_pctxt_state),
                  .sel0_l (fcl_fdp_dmpthr_l[0]),
                  .sel1_l (fcl_fdp_dmpthr_l[1]));







































































































 // `ifndef CONFIG_NUM_THREADS

   assign dmp_ctxt1 = dmp_ctxt_unq & {13{~(tlu_itlb_dmp_nctxt_g |
					                                 tlu_itlb_dmp_actxt_g)}};
//`ifdef SPARC_HPV_EN
   assign dmp_ctxt2 = {tlu_itlb_tte_tag_w2[12:7],tlu_itlb_tte_tag_w2[6:0]} &
	                    {13{tlu_itlb_dmp_actxt_g}};
//`else
//  assign dmp_ctxt2 = {tlu_itlb_tte_tag_w2[13:8],tlu_itlb_tte_tag_w2[6:0]} &
//	                    {13{tlu_itlb_dmp_actxt_g}};
//`endif

   assign dmp_ctxt = dmp_ctxt1 | dmp_ctxt2;

   dp_mux3ds #(13) ctxt_mux (.dout (fdp_itlb_ctxt_bf),
			                     .in0  (curr_ctxt),
			                     .in1  (sw_ctxt),
			                     .in2  (dmp_ctxt),
			                     .sel0_l  (fcl_fdp_ctxt_sel_curr_bf_l),
			                     .sel1_l  (fcl_fdp_ctxt_sel_sw_bf_l),
			                     .sel2_l  (fcl_fdp_ctxt_sel_dmp_bf_l));


// ----------------------------------------------------------------------
// PC datapath
// ----------------------------------------------------------------------

   // pc/thr to exu for rdsr instruction
   // this is the only 64 bit cell in the IFU
   dp_mux3ds #(64) ver_mux(.dout (ifu_exu_pcver_e[63:0]),
			                   .in0  ({{16{pc_e[47]}}, pc_e[47:0]}),
			                   .in1  ({16'h003e,
                                 16'h0023,
                                 const_maskid[7:0],
                                 8'h03,
                                 8'h06,
                                 8'h07}),
			                   .in2  ({12'b0,
                                 dtu_fdp_thrconf_e[40:29],
                                 4'b0,
                                 dtu_fdp_thrconf_e[28:9],
                                 2'b0,
                                 dtu_fdp_thrconf_e[8:3],
                                 5'b0,
                                 dtu_fdp_thrconf_e[2:0]}),
			                   .sel0_l  (fcl_fdp_rdsr_sel_pc_e_l),
			                   .sel1_l  (fcl_fdp_rdsr_sel_ver_e_l),
			                   .sel2_l  (fcl_fdp_rdsr_sel_thr_e_l));

    // mmckeown: track if there is a branch
    // target PC in the F stage for ExecD
    reg [3:0] brtrp_target_pc_bf, brtrp_target_pc_f;
    reg [3:0]          rtap_ifu_pc_wr_en; // moved from below
    assign fdp_esl_brtrp_target_pc_bf_f = brtrp_target_pc_bf | brtrp_target_pc_f;

   // Select the next thread pc (for F stage)
   dp_mux4ds #(49) t0_pcbf_mux(.dout (t0npc_bf),
			                       .in0 ({fcl_fdp_pcoor_vec_f[0], t0pc_f[47:0]}),
			                       .in1 (nextpc_nosw_bf),
			                       .in2 (t0_trap_rb_pc_bf),
			                       .in3 ({1'b0, exu_ifu_brpc_e}),
			                       .sel0_l (fcl_fdp_tpcbf_sel_old_bf_l[0]),
			                       .sel1_l (fcl_fdp_tpcbf_sel_pcp4_bf_l[0]),
			                       .sel2_l (fcl_fdp_tpcbf_sel_trap_bf_l[0]),
			                       .sel3_l (fcl_fdp_tpcbf_sel_brpc_bf_l[0]));

    always @ *
    begin
        if (~fcl_fdp_tpcbf_sel_brpc_bf_l[0] | ~fcl_fdp_tpcbf_sel_trap_bf_l[0])
            brtrp_target_pc_bf[0] = 1'b1;
        else if (~fcl_fdp_tpcbf_sel_old_bf_l[0])
            brtrp_target_pc_bf[0] = brtrp_target_pc_f[0];
        else
            brtrp_target_pc_bf[0] = 1'b0;
    end
    always @ (posedge rclk)
    begin
        if (rtap_ifu_pc_wr_en[0])
            brtrp_target_pc_f[0] <= 1'b1;
        else
            brtrp_target_pc_f[0] <= brtrp_target_pc_bf[0];
    end
   

 // Use two threads unless this is defined

   // mmckeown: adding an extra mux here to synchronize leader and follower pcs
   wire exec_draft_pcf_sync_mux_sel = config_dtu_esl_en ? esl_fdp_sync_pcs_bf : 1'b0;
   dp_mux2es  #(49)  exec_draft_pcf_sync_mux1 (.dout (t1npc_bf),
                                               .in0 (t1npc_bf_execdraft_bf),
                                               .in1 (t0pc_f),
                                               .sel (exec_draft_pcf_sync_mux_sel));

   dp_mux4ds #(49) t1_pcbf_mux(.dout (t1npc_bf_execdraft_bf),
                                   .in0 ({fcl_fdp_pcoor_vec_f[1], t1pc_f[47:0]}),
                                   .in1 (nextpc_nosw_bf),
                                   .in2 (t1_trap_rb_pc_bf),
                                   .in3 ({1'b0, exu_ifu_brpc_e}),
                                   .sel0_l (fcl_fdp_tpcbf_sel_old_bf_l[1]),
                                   .sel1_l (fcl_fdp_tpcbf_sel_pcp4_bf_l[1]),
                                   .sel2_l (fcl_fdp_tpcbf_sel_trap_bf_l[1]),
                                   .sel3_l (fcl_fdp_tpcbf_sel_brpc_bf_l[1]));   
    
    always @ *
    begin
        if (~fcl_fdp_tpcbf_sel_brpc_bf_l[1] | ~fcl_fdp_tpcbf_sel_trap_bf_l[1])
            brtrp_target_pc_bf[1] = 1'b1;
        else if (~fcl_fdp_tpcbf_sel_old_bf_l[1])
            brtrp_target_pc_bf[1] = brtrp_target_pc_f[1];
        else
            brtrp_target_pc_bf[1] = 1'b0;
    end
    always @ (posedge rclk)
    begin
        if (rtap_ifu_pc_wr_en[1])
            brtrp_target_pc_f[1] <= 1'b1;
        else
            brtrp_target_pc_f[1] <= brtrp_target_pc_bf[1];
    end



















































































































































































































 // `ifndef CONFIG_NUM_THREADS

   // // F stage thread PC regs;  use low power thr flop
   // dff_s  #(49)  t0_pcf_reg(.din (t0npc_bf),
			//                   .clk (clk),
			//                   .q   (t0pc_f),
			//                   .se  (se), .si(), .so());

  // trin: modified t0pc_f for jtag overwrites

// reg [3:0]          rtap_ifu_pc_wr_en; mmckeown: moved this up as it is used
// above
reg [47:0]         rtap_ifu_pc_data;
always @ *
begin
  rtap_ifu_pc_wr_en = 0;
  if (rtap_core_val && rtap_core_id == 4'd3)
  begin
     if (rtap_core_threadid == 2'd0)
        rtap_ifu_pc_wr_en = 4'b0001;
     else if (rtap_core_threadid == 2'd1)
        rtap_ifu_pc_wr_en = 4'b0010;
     else if (rtap_core_threadid == 2'd2)
        rtap_ifu_pc_wr_en = 4'b0100;
     else if (rtap_core_threadid == 2'd3)
        rtap_ifu_pc_wr_en = 4'b1000;
  end
  rtap_ifu_pc_data = rtap_core_data[47:0];
end

  always @ (posedge clk)
  begin
    if (rtap_ifu_pc_wr_en[0])
      t0pc_f <= rtap_ifu_pc_data;
    else
      t0pc_f <= t0npc_bf;
  end


 // Use two threads unless this is defined

   // dff_s  #(49)  t1_pcf_reg(.din (t1npc_bf),
   //                            .clk (clk),
   //                            .q   (t1pc_f),
   //                            .se  (se), .si(), .so());

  always @ (posedge clk)
  begin
    if (rtap_ifu_pc_wr_en[1])
      t1pc_f <= rtap_ifu_pc_data;
    else
      t1pc_f <= t1npc_bf;
  end

   assign fdp_fcl_pc_oor_vec_f = {2'b0, t1pc_f[48], t0pc_f[48]};

   // select the pc to be used on a switch -- need to protect
   dp_mux2ds #(48) swpc_mux(.dout (swpc_bf),
                                .in0 (t0pc_f[47:0]),
                                .in1 (t1pc_f[47:0]),
                                .sel0_l (fcl_fdp_next_thr_bf_l[0]),
                                .sel1_l (fcl_fdp_next_thr_bf_l[1]));





























































































































 // `ifndef CONFIG_NUM_THREADS

   // choose between I$ write address and read address
   // need mux only for lower 11 bits (2+3 + ICINDEX_SIZE)
//   dp_mux2es #(48) ifqfdp_mux(.dout (icaddr_nosw_bf[47:0]),
//	     .in0  (nextpc_nosw_bf[47:0]),
//	     .in1  ({{37{1'b0}}, ifq_fdp_icindex_bf, 4'b0}),
//	     .sel  (fcl_fdp_ifqfdp_sel_ifq_bf));  // 1=ifq

   // implements switch and branch
   // can we cut this down to 11 bits? No! tlb needs all 48

//   dp_mux4ds #(48) nxt_icaddr_mux(.dout  (icaddr_bf),
//				                        .in0   (swpc_bf[47:0]),
//				                        .in1   (nextpc_nosw_bf[47:0]),
//				                        .in2   ({8'b0, {`IC_TAG_SZ{1'b0}},
//                                         ifq_fdp_icindex_bf, 4'b0}),
//				                        .in3   (exu_ifu_brpc_e[47:0]),
//				                        .sel0_l (fcl_fdp_icaddr_sel_swpc_bf_l),
//				                        .sel1_l (fcl_fdp_icaddr_sel_curr_bf_l),
//				                        .sel2_l (fcl_fdp_icaddr_sel_ifq_bf_l),
//				                        .sel3_l (fcl_fdp_icaddr_sel_br_bf_l));

//   assign fdp_icd_vaddr_bf = icaddr_bf[47:0];
   // this goes to the itlb, icd and ict on top of fdp
   // this is !!very critical!!
   assign fdp_icd_vaddr_bf = pc_bf[47:2];

   // create separate output for the icv to the left
   assign fdp_icv_index_bf = pc_bf[(6 + 5):5];

   // Place this mux as close to the top (itlb) as possible
   dp_mux3ds #(48) pcbf_mux(.dout  (pc_bf[47:0]),
			  .in0   (swpc_bf[47:0]),
			  .in1   (nextpc_nosw_bf[47:0]),
			  .in2   (exu_ifu_brpc_e[47:0]),
			  .sel0_l (fcl_fdp_pcbf_sel_swpc_bf_l),
			  .sel1_l (fcl_fdp_pcbf_sel_nosw_bf_l),
			  .sel2_l (fcl_fdp_pcbf_sel_br_bf_l));

   dff_s #(48)  pcf_reg(.din  (pc_bf),
		    .clk  (clk),
		    .q    (pc_f),
		    .se   (se), .si(), .so());


// trin: adding basic breakpointing capability on the VA pc
reg [47:0] jtag_breakpoint_pc;

always @ (posedge rclk)
begin
   if (rtap_core_val && rtap_core_id == 4'd7)
   begin
      jtag_breakpoint_pc <= rtap_core_data[47:0];
   end
end


assign fdp_fcl_jtag_breakpoint_hit = (pc_bf[47:0] == jtag_breakpoint_pc[47:0]);

   assign fdp_erb_pc_f = pc_f[47:0];

    // trappc mux (choose trap pc vs rollback/uTrap pc)
   dp_mux4ds #(49) trap_pc0_mux(.dout (t0_trap_rb_pc_bf),
			      .in0  (tlu_ifu_trappc_w2),
			      .in1  (pc_d_adj),
			      .in2  (t0pc_s),
			      .in3  (pc_w),
			      .sel0_l  (fcl_fdp_trrbpc_sel_trap_bf_l[0]),
			      .sel1_l  (fcl_fdp_trrbpc_sel_rb_bf_l[0]),
			      .sel2_l  (fcl_fdp_trrbpc_sel_pcs_bf_l[0]),
			      .sel3_l  (fcl_fdp_trrbpc_sel_err_bf_l[0]));

 // Use two threads unless this is defined

   dp_mux4ds #(49) trap_pc1_mux(.dout (t1_trap_rb_pc_bf),
                  .in0  (tlu_ifu_trappc_w2),
                  .in1  (pc_d_adj),
                  .in2  (t1pc_s),
                  .in3  (pc_w),
                  .sel0_l  (fcl_fdp_trrbpc_sel_trap_bf_l[1]),
                  .sel1_l  (fcl_fdp_trrbpc_sel_rb_bf_l[1]),
                  .sel2_l  (fcl_fdp_trrbpc_sel_pcs_bf_l[1]),
                  .sel3_l  (fcl_fdp_trrbpc_sel_err_bf_l[1]));









































































 // `ifndef CONFIG_NUM_THREADS

   // can reduce this to a 2:1 mux since reset pc is not used any more and
   // pc_f is not needed.
   dp_mux3ds #(49) pcp4_mux(.dout  (nextpc_nosw_bf),
			  .in0   (pcinc_f),
			  .in1   (thr_trappc_bf),
			  .in2   ({fcl_fdp_pcoor_f, pc_f[47:0]}),
			  .sel0_l (fcl_fdp_noswpc_sel_inc_l_bf),
			  .sel1_l (fcl_fdp_noswpc_sel_tnpc_l_bf),
			  .sel2_l (fcl_fdp_noswpc_sel_old_l_bf));


   // next S stage thread pc mux per thread
   // Use advtpcs signal which works for stall (Aug '01)
   // Merged pc_e/pc_d into the eqn to allow for rollback
   dp_mux4ds #(49) t0pcf_mux(.dout (t0_next_pcs_f),
			   .in0  (t0pc_s),
			   .in1  ({fcl_fdp_pcoor_vec_f[0], t0pc_f[47:0]}),
			   .in2  (pc_d_adj),
			   .in3  (pc_e),
			   .sel0_l (fcl_fdp_nextpcs_sel_pcs_f_l[0]),
			   .sel1_l (fcl_fdp_nextpcs_sel_pcf_f_l[0]),
			   .sel2_l (fcl_fdp_nextpcs_sel_pcd_f_l[0]),
			   .sel3_l (fcl_fdp_nextpcs_sel_pce_f_l[0]));

 // Use two threads unless this is defined

   // mmckeown: adding an extra mux here to synchronize leader and follower pcs
   wire exec_draft_pcs_sync_mux_sel = config_dtu_esl_en ? esl_fdp_sync_pcs_bf : 1'b0;
   dp_mux2es  #(49)  exec_draft_pcs_sync_mux1 (.dout (t1_next_pcs_f),
                                               .in0 (t1_next_pcs_bf_execdraft_f),
                                               .in1 (t0pc_s),
                                               .sel (exec_draft_pcs_sync_mux_sel));

   dp_mux4ds #(49) t1pcf_mux(.dout (t1_next_pcs_bf_execdraft_f),
               .in0  (t1pc_s),
               .in1  ({fcl_fdp_pcoor_vec_f[1], t1pc_f[47:0]}),
               .in2  (pc_d_adj),
               .in3  (pc_e),
               .sel0_l (fcl_fdp_nextpcs_sel_pcs_f_l[1]),
               .sel1_l (fcl_fdp_nextpcs_sel_pcf_f_l[1]),
               .sel2_l (fcl_fdp_nextpcs_sel_pcd_f_l[1]),
               .sel3_l (fcl_fdp_nextpcs_sel_pce_f_l[1]));

















































































































 // `ifndef CONFIG_NUM_THREADS

   // S stage thread PC regs;  use low power thr flop
   dff_s  #(49)  t0pcs_reg(.din  (t0_next_pcs_f),
		                   .q    (t0pc_s),
		                   .clk  (clk),  .se(se), .si(), .so());
   assign fdp_esl_t0pc_next_s2 = t0_next_pcs_f;

 // Use two threads unless this is defined

   dff_s  #(49)  t1pcs_reg(.din  (t1_next_pcs_f),
                           .q    (t1pc_s),
                           .clk  (clk),  .se(se), .si(), .so());
   assign fdp_esl_t1pc_next_s2 = t1_next_pcs_bf_execdraft_f;

   // S stage PC mux -- need to protect
   dp_mux2ds #(49) pcs_mux(.dout (pc_s),
             .in0  (t0pc_s),
             .in1  (t1pc_s),
             .sel0_l (fcl_fdp_thr_s2_l[0]),
             .sel1_l (fcl_fdp_thr_s2_l[1]));

   // S stage next PC mux -- need to protect
   dp_mux2ds #(49) npcs_mux(.dout (npc_s),
              .in0  (t0_next_pcs_f),
              .in1  (t1_next_pcs_f),
              .sel0_l (fcl_fdp_thr_s2_l[0]),
              .sel1_l (fcl_fdp_thr_s2_l[1]));



































































































 // `ifndef CONFIG_NUM_THREADS

   // D stage PC and nPC
   dff_s  #(49)  pcd_reg(.din (pc_s),
		                 .q   (pc_d),
		                 .clk (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcd_reg(.din  (npc_s),
		                  .q    (npc_d),
		                  .clk  (clk), .se(se), .si(), .so());

   assign am_mask = {{17{~fcl_fdp_addr_mask_d}}, 32'hffffffff};

   // nand2
   assign pc_d_adj = pc_d & am_mask;
   assign npc_d_adj = npc_d & am_mask;

   assign ifu_exu_pc_d = pc_d_adj[47:0];

   // E stage PC and nPC
   dff_s  #(49)  pce_reg(.din (pc_d_adj),
		                 .q   (pc_e),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s  #(49)  npce_reg(.din  (npc_d_adj),
		                  .q    (npc_e),
		                  .clk (clk), .se(se), .si(), .so());

   assign fdp_fcl_pc_oor_e = pc_e[48];
   assign ifu_tlu_pc_oor_e = pc_e[48];

   // M stage PC and nPC
   dff_s  #(49)  pcm_reg(.din  (pc_e),
		                 .q    (pc_m),
		                 .clk  (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcm_reg(.din (npc_e),
		                  .q   (npc_m),
		                  .clk (clk), .se(se), .si(), .so());
   assign ifu_tlu_pc_m = pc_m[48:0];
   assign ifu_tlu_npc_m = npc_m[48:0];

   // W stage PC and nPC
   dff_s  #(49)  pcw_reg(.din  (pc_m),
		                 .q    (pc_w),
		                 .clk  (clk),  .se(se), .si(), .so());
   dff_s  #(49)  npcw_reg(.din (npc_m),
		                  .q   (npc_w),
		                  .clk (clk), .se(se), .si(), .so());

//   assign ifu_tlu_pc_w = pc_w;
//   assign ifu_tlu_npc_w = npc_w;

   // PC incrementer
   // can we fit the ofl logic on the side of the incrementer?
   assign pcinc_f[1:0] = pc_f[1:0];
   sparc_ifu_incr46 pc_inc(.a     (pc_f[47:2]),
			                     .a_inc (pcinc_f[47:2]),
			                     .ofl   ());   // ofl output not needed

//   assign pcinc_f[48] = inc_ofl & ~fcl_fdp_mask32b_f | fcl_fdp_pcoor_f;
   assign pcinc_f[48] = ~pc_f[47] & pcinc_f[47] & ~fcl_fdp_mask32b_f |
                        fcl_fdp_pcoor_f;

   // Enable for thr trapnpc reg
   dp_mux4ds #(49) t0tnpc_mux(.dout (trapnpc0_bf),
			                        .in0  (tlu_ifu_trapnpc_w2),
			                        .in1  (npc_w),
                              .in2  (t0pc_f),
			                        .in3  (t0_trapnpc_f),
			                        .sel0_l  (fcl_fdp_thrtnpc_sel_tnpc_l[0]),
			                        .sel1_l  (fcl_fdp_thrtnpc_sel_npcw_l[0]),
			                        .sel2_l  (fcl_fdp_thrtnpc_sel_pcf_l[0]),
			                        .sel3_l  (fcl_fdp_thrtnpc_sel_old_l[0]));
 // Use two threads unless this is defined

   dp_mux4ds #(49) t1tnpc_mux(.dout (trapnpc1_bf),
                .in0  (tlu_ifu_trapnpc_w2),
                .in1  (npc_w),
          .in2  (t1pc_f),
                .in3  (t1_trapnpc_f),
                .sel0_l  (fcl_fdp_thrtnpc_sel_tnpc_l[1]),
                .sel1_l  (fcl_fdp_thrtnpc_sel_npcw_l[1]),
          .sel2_l  (fcl_fdp_thrtnpc_sel_pcf_l[1]),
                .sel3_l  (fcl_fdp_thrtnpc_sel_old_l[1]));









































































 // `ifndef CONFIG_NUM_THREADS

   // thread next trap pc reg
   dff_s #(49) t0tnpcf_reg(.din  (trapnpc0_bf),
		                   .q    (t0_trapnpc_f),
		                   .clk  (clk),  .se(se), .si(), .so());
 // Use two threads unless this is defined

   dff_s #(49) t1tnpcf_reg(.din  (trapnpc1_bf),
                           .q    (t1_trapnpc_f),
                           .clk  (clk),  .se(se), .si(), .so());

   dp_mux2ds #(49) nxttpc_mux(.dout (thr_trappc_bf),
                .in0  (t0_trapnpc_f),
                .in1  (t1_trapnpc_f),
                .sel0_l (fcl_fdp_thr_s2_l[0]), // thr_s2 = thr_f
                .sel1_l (fcl_fdp_thr_s2_l[1]));





























































 // `ifndef CONFIG_NUM_THREADS

   // During rst nextpc_nosw_bf = PO_RESET_PC.  All thread PC_f registers,
   // the icaddr_f register and the nextpc register should be loaded
   // with nextpc_nosw_bf during reset.
   // Eventually, we will load the reset_pc from the trap logic unit,
   // which will arrive on the trap_pc bus.


   // TBD in PC datapath:
   // 1.  Add useNIR bit to PCs  -- DONE
   // 2.  Add support for ifq request grant -- DONE
   // 3.  Generate icache read signal (from fcl?) -- DONE
   // 4.  Rollback functionality -- DONE
   // 5.  PC range checks -- DONE
   // 6.  Change PC to 48 bit value -- DONE


//----------------------------------------------------------------------
// Fetched Instruction Datapath
//----------------------------------------------------------------------

// This is logically 33 bits wide.  The NIR and IR datapaths are laid
// side by side, making this a 66bit datapath.  The NIR path is
// potentially a little longer.

// mmckeown
// Added datapath for physical address

   // Pipe forward the PC in F
   dff_s #(8) pc_paddr_s_reg(.din (pc_f[9:2]),
                             .q (pc_offset_s[9:2]),
                             .clk (clk), .se(se), .si(), .so());

   // Physical address of fetched instruction. pgnum comes from itlb, the offset
   // comes from the offset in the PC, and the bottom 2 bits are always 0
   assign fetpaddr_s1[39:2] = {itlb_fdp_paddr_s[39:10] & {30{~fcl_fdp_tlbmiss_s1}},
                               pc_offset_s[9:2]};

   // choose between NIR data and fetched data
   dp_mux2es #(33)  usenir_mux(.dout (inst_s1),
			                       .in0  (icd_fdp_fetdata_s1[32:0]),
			                       .in1  (nirdata_s1),
			                       .sel  (fcl_fdp_usenir_sel_nir_s1));  // 1=nir

   dp_mux2es #(38)  usenir_paddr_mux (.dout(inst_paddr_s1[39:2]),
                                      .in0 (fetpaddr_s1[39:2]),
                                      .in1 (nirpaddr_s1[39:2]),
                                      .sel (fcl_fdp_usenir_sel_nir_s1));

   // mmckeown: latch previous issued instruction in case of
   //           replay for execution drafting
   dff_s #(33) fdp_inst_s_prev_reg (.din (fdp_inst_s),
                                    .q (fdp_inst_s_prev),
                                    .clk (clk), .se (se), .si(), .so());

   // mmckeown: adding an extra mux here to be able to execute the
   //           previous instruction for execution drafting
   wire exec_draft_replay_mux_sel = config_dtu_esl_en ? esl_fdp_issue_prev_inst_s : 1'b0;
   dp_mux2es  #(33)  exec_draft_replay_mux (.dout (fdp_inst_s),
                                            .in0 (fdp_inst_bf_execdraft_s),
                                            .in1 (fdp_inst_s_prev),
                                            .sel(exec_draft_replay_mux_sel));
   // Instruction Output Mux
   // CHANGE: now 4:1
   dp_mux4ds  #(33)  instout_mux(.dout (fdp_inst_bf_execdraft_s),
			                         .in0 (icd_fdp_fetdata_s1[32:0]),
			                         .in1 (inst_s2),
			                         .in2 ({32'h01000000, 1'b0}),
			                         .in3 (nirdata_s1[32:0]),
			                         .sel0_l (fcl_fdp_inst_sel_curr_s_l),
			                         .sel1_l (fcl_fdp_inst_sel_switch_s_l),
			                         .sel2_l (fcl_fdp_inst_sel_nop_s_l),
			                         .sel3_l (fcl_fdp_inst_sel_nir_s_l));

   dp_mux4ds  #(38)  instout_paddr_mux (.dout (fdp_inst_paddr_s[39:2]),
                                        .in0 (fetpaddr_s1[39:2]),
                                        .in1 (inst_paddr_s2[39:2]),
                                        .in2 (38'b0),
                                        .in3 (nirpaddr_s1[39:2]),
                                        .sel0_l (fcl_fdp_inst_sel_curr_s_l),
                                        .sel1_l (fcl_fdp_inst_sel_switch_s_l),
                                        .sel2_l (fcl_fdp_inst_sel_nop_s_l),
                                        .sel3_l (fcl_fdp_inst_sel_nir_s_l));

   assign fdp_fcl_swc_s2 = fdp_inst_s[0];

   assign fdp_fcl_op_s = fdp_inst_s[32:31];
   assign fdp_fcl_op3_s = fdp_inst_s[25:22];
   assign fdp_fcl_ibit_s = fdp_inst_s[14];

   assign fdp_dtu_inst_s = fdp_inst_s[32:1];

   // CHANGE: Random logic to fix timing paths
   // output pin on RHS, as close to IRF as possible
   // 16x drivers
   // nand2-xor-invert
   assign ifu_exu_rs1_s[4] = fdp_inst_s[19] ^
			                       (fdp_inst_s[18] & fcl_fdp_oddwin_s);
   assign ifu_exu_rs1_s[3:0] = fdp_inst_s[18:15];

   assign ifu_exu_rs2_s[4] = (fdp_inst_s[5] ^
			                        (fdp_inst_s[4] & fcl_fdp_oddwin_s));
   assign ifu_exu_rs2_s[3:0] = fdp_inst_s[4:1];

   assign ifu_exu_rs3_s[4] = (fdp_inst_s[30] ^
			                        (fdp_inst_s[29] & fcl_fdp_oddwin_s));
   assign ifu_exu_rs3_s[3:0] = fdp_inst_s[29:26];


   dp_buffer #(33) insts1_buf(inst_s1_bf1, inst_s1[32:0]);

   dp_buffer #(38) inst_paddrs1_buf(inst_paddr_s1_bf1[39:2], inst_paddr_s1[39:2]);

   // Thread instruction muxes
   dp_mux4ds #(33)  t0inst_mux(.dout (t0inst_s1),
			     .in0 (ifq_fdp_fill_inst),
			     .in1 (inst_s1_bf1),
			     .in2 (t0inst_s2),
			     .in3 (rb_inst0_s),
			     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[0]),
			     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[0]),
			     .sel2_l (fcl_fdp_tinst_sel_old_s_l[0]),
			     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[0]));

   dp_mux4ds #(38) t0inst_paddr_mux (.dout (t0inst_paddr_s1[39:2]),
                                     .in0 (ifq_fdp_fill_paddr[39:2]),
                                     .in1 (inst_paddr_s1_bf1[39:2]),
                                     .in2 (t0inst_paddr_s2[39:2]),
                                     .in3 (rb_inst0_paddr_s[39:2]),
                                     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[0]),
                                     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[0]),
                                     .sel2_l (fcl_fdp_tinst_sel_old_s_l[0]),
                                     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[0]));

 // Use two threads unless this is defined

   dp_mux4ds #(33)  t1inst_mux(.dout (t1inst_s1),
                 .in0 (ifq_fdp_fill_inst),
                 .in1 (inst_s1_bf1),
                 .in2 (t1inst_s2),
                 .in3 (rb_inst1_s),
                 .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[1]),
                 .sel1_l (fcl_fdp_tinst_sel_curr_s_l[1]),
                 .sel2_l (fcl_fdp_tinst_sel_old_s_l[1]),
                 .sel3_l (fcl_fdp_tinst_sel_rb_s_l[1]));

   dp_mux4ds #(38) t1inst_paddr_mux (.dout (t1inst_paddr_s1[39:2]),
                                     .in0 (ifq_fdp_fill_paddr[39:2]),
                                     .in1 (inst_paddr_s1_bf1[39:2]),
                                     .in2 (t1inst_paddr_s2[39:2]),
                                     .in3 (rb_inst1_paddr_s[39:2]),
                                     .sel0_l (fcl_fdp_tinst_sel_ifq_s_l[1]),
                                     .sel1_l (fcl_fdp_tinst_sel_curr_s_l[1]),
                                     .sel2_l (fcl_fdp_tinst_sel_old_s_l[1]),
                                     .sel3_l (fcl_fdp_tinst_sel_rb_s_l[1]));





































































































































 // `ifndef CONFIG_NUM_THREADS

   // Thread Instruction Register
   dff_s #(33) t0_inst_reg(.din  (t0inst_s1),
		                   .q    (t0inst_s2),
		                   .clk  (clk),  .se(se), .si(), .so());
   dff_s #(38) t0_inst_paddr_reg (.din (t0inst_paddr_s1[39:2]),
                                  .q (t0inst_paddr_s2[39:2]),
                                  .clk (clk), .se(se), .si(), .so());
   assign fdp_esl_t0inst_next_s2 = t0inst_s1;
   assign fdp_esl_t0inst_paddr_next_s2 = t0inst_paddr_s1;

 // Use two threads unless this is defined

   dff_s #(33) t1_inst_reg(.din  (t1inst_s1),
                           .q    (t1inst_s2),
                           .clk  (clk),  .se(se), .si(), .so());
   dff_s #(38) t1_inst_paddr_reg (.din (t1inst_paddr_s1),
                                  .q (t1inst_paddr_s2),
                                  .clk (clk), .se(se), .si(), .so());
   assign fdp_esl_t1inst_next_s2 = t1inst_s1;
   assign fdp_esl_t1inst_paddr_next_s2 = t1inst_paddr_s1;

   // switch instruction mux -- choose the instruction to switch to
   // fcl keep track of which t*inst_s2 is valid
   dp_mux2ds  #(33) swinst_mux(.dout (inst_s2),
                 .in0  (t0inst_s2),
                 .in1  (t1inst_s2),
                 .sel0_l (fcl_fdp_thr_s2_l[0]),
                 .sel1_l (fcl_fdp_thr_s2_l[1]));

   dp_mux2ds #(38) swinst_paddr_mux (.dout (inst_paddr_s2),
                                     .in0 (t0inst_paddr_s2),
                                     .in1 (t1inst_paddr_s2),
                                     .sel0_l (fcl_fdp_thr_s2_l[0]),
                                     .sel1_l (fcl_fdp_thr_s2_l[1]));




























































































































 // `ifndef CONFIG_NUM_THREADS

   // Rollback instruction
   dff_s #(33) rbinst_d_reg(.din (fdp_inst_s[32:0]),
			                  .q   (inst_d),
			                  .clk (clk),
			                  .se  (se), .si(), .so());
   dff_s #(38) rbinst_paddr_d_reg (.din (fdp_inst_paddr_s[39:2]),
                                   .q (inst_paddr_d),
                                   .clk (clk),
                                   .se (se), .si(), .so());

   dff_s #(33) rbinst_e_reg(.din (inst_d),
			                  .q   (inst_e),
			                  .clk (clk),
			                  .se  (se), .si(), .so());
   dff_s #(38) rbinst_paddr_e_reg (.din (inst_paddr_d),
                                   .q (inst_paddr_e),
                                   .clk (clk),
                                   .se (se), .si(), .so());

   dp_mux2es #(33) rbinst0_mux(.dout (rb_inst0_s),
			                       .in0  (inst_d),
			                       .in1  (inst_e),
			                       .sel  (fcl_fdp_rbinst_sel_inste_s[0]));
   dp_mux2es #(38) rbinst0_paddr_mux (.dout (rb_inst0_paddr_s),
                                      .in0 (inst_paddr_d),
                                      .in1 (inst_paddr_e),
                                      .sel  (fcl_fdp_rbinst_sel_inste_s[0]));

 // Use two threads unless this is defined

   dp_mux2es #(33) rbinst1_mux(.dout (rb_inst1_s),
                                   .in0  (inst_d),
                                   .in1  (inst_e),
                                   .sel  (fcl_fdp_rbinst_sel_inste_s[1]));
   dp_mux2es #(38) rbinst1_paddr_mux (.dout (rb_inst1_paddr_s),
                                      .in0 (inst_paddr_d),
                                      .in1 (inst_paddr_e),
                                      .sel  (fcl_fdp_rbinst_sel_inste_s[1]));



































































 // `ifndef CONFIG_NUM_THREADS

//----------------------------------------------------------------------
// Next Instruction Datapath
//----------------------------------------------------------------------

   // Thread next instruction muxes
//   dp_mux2es #(33) t0nir_mux(.dout (t0nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t0nir),
//			                     .sel (fcl_fdp_thr_s1_l[0]));  // 0=new
//   dp_mux2es #(33) t1nir_mux(.dout (t1nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t1nir),
//			                     .sel (fcl_fdp_thr_s1_l[1]));
//   dp_mux2es #(33) t2nir_mux(.dout (t2nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t2nir),
//			                     .sel (fcl_fdp_thr_s1_l[2]));
//   dp_mux2es #(33) t3nir_mux(.dout (t3nir_in),
//			                     .in0 (icd_fdp_topdata_s1[32:0]),
//			                     .in1 (t3nir),
//			                     .sel (fcl_fdp_thr_s1_l[3]));

   // mmckeown
   // Added datapath for physical address to NIRs

   // Pipe forward the offset of the incremented PC in F
   // (incremented PC because this is the second instruction
   // fetched)
   dff_s #(8) pcinc_s_reg (.din(pcinc_f[9:2]),
                           .q(pcinc_s[9:2]),
                           .clk(clk), .se(se), .si(), .so());

   // Physical address for NIR. pgnum comes from itlb, the offset
   // comes from the offset in the incremented PC (as this is the instruction
   // following the one that was fetched), and the bottom 2 bits are always 0
   assign toppaddr_s1 = {itlb_fdp_paddr_s[39:10] & {30{~fcl_fdp_tlbmiss_s1}}, pcinc_s[9:2]};

   // Thread Next Instruction Register
   wire   clk_nir0;



   bw_u1_ckenbuf_6x  ckennir0(.rclk (rclk),
                              .clk  (clk_nir0),
                              .en_l (fcl_fdp_thr_s1_l[0]),
                              .tm_l (~se));










   dff_s #(33) t0nir_reg(.din  (icd_fdp_topdata_s1[32:0]),
		                   .q    (t0nir),
		                   .clk  (clk_nir0), .se(se), .si(), .so());
   dff_s #(38) t0nir_paddr_reg (.din (toppaddr_s1[39:2]),
                                .q (t0nir_paddr[39:2]),
                                .clk (clk_nir0), .se(se), .si(), .so ());


 // Use two threads unless this is defined

   wire   clk_nir1;



   bw_u1_ckenbuf_6x  ckennir1(.rclk (rclk),
                              .clk  (clk_nir1),
                              .en_l (fcl_fdp_thr_s1_l[1]),
                              .tm_l (~se));









   dff_s #(33) t1nir_reg(.din  (icd_fdp_topdata_s1[32:0]),
                           .q    (t1nir),
                           .clk  (clk_nir1), .se(se), .si(), .so());
   dff_s #(38) t1nir_paddr_reg (.din (toppaddr_s1[39:2]),
                                .q (t1nir_paddr[39:2]),
                                .clk (clk_nir1), .se(se), .si(), .so());


   // Next thread NIR mux  (nir output mux)
   dp_mux2ds  #(33) nextnir_mux(.dout (nirdata_s1),
                                  .in0 (t0nir),
                              .in1 (t1nir),
                                  .sel0_l (fcl_fdp_nirthr_s1_l[0]),
                                  .sel1_l (fcl_fdp_nirthr_s1_l[1]));

   dp_mux2ds  #(38) nextnir_paddr_mux (.dout (nirpaddr_s1),
                                       .in0 (t0nir_paddr),
                                       .in1 (t1nir_paddr),
                                       .sel0_l (fcl_fdp_nirthr_s1_l[0]),
                                       .sel1_l (fcl_fdp_nirthr_s1_l[1]));


























































































































































































































 // `ifndef CONFIG_NUM_THREADS

   // TBD in fetched instruction DP:
   // 1. Rollback -- DONE
   // 2. Icache parity check (increase fet data and top data to 34 bits)

endmodule // sparc_ifu_fdp

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_wseldp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
//////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_wsel
//  Description:	
//     Way selects removed from icache and done here 
*/

module sparc_ifu_wseldp (/*AUTOARG*/
   // Outputs
   wsel_fdp_fetdata_s1, wsel_fdp_topdata_s1, wsel_mbist_icache_data, 
   so, 
   // Inputs
   rclk, se, si, icd_wsel_fetdata_s1, icd_wsel_topdata_s1, 
   itlb_wsel_waysel_s1, ifq_erb_asiway_f
   );

   input          rclk, 
                  se,
                  si;

   input  [135:0] icd_wsel_fetdata_s1,
                  icd_wsel_topdata_s1;

   input [3:0]    itlb_wsel_waysel_s1;
   input [1:0]    ifq_erb_asiway_f;

   output [33:0]  wsel_fdp_fetdata_s1;
   output [33:0]  wsel_fdp_topdata_s1;

   output [67:0]  wsel_mbist_icache_data;

   output         so;
   
   // local signals
   wire [3:0]     dec_asiway_s_l,
                  waysel_buf_s1;
   wire [1:0]     asiway_s;
   
   wire [33:0]    rdc_fetdata_s1,
                  rdc_topdata_s1,
                  erb_asidata_s,                  
                  asi_topdata_s;
   wire           clk;
   
   //
   // Code begins here
   //
   //------------------
   // Control Portion
   //------------------

   assign   clk = rclk;
   
   // flop and decode waysel
   dff_s #(2) asiway_reg(.din (ifq_erb_asiway_f),
                       .q   (asiway_s),
                       .clk (clk), .se(se), .si(), .so());
   assign   dec_asiway_s_l[0] = ~(~asiway_s[1] & ~asiway_s[0]);
   assign   dec_asiway_s_l[1] = ~(~asiway_s[1] &  asiway_s[0]);
   assign   dec_asiway_s_l[2] = ~( asiway_s[1] & ~asiway_s[0]);
   assign   dec_asiway_s_l[3] = ~( asiway_s[1] &  asiway_s[0]);

   //--------------------------
   // Datapath Section
   //--------------------------

   // buffer wayselect from itlb
   // align these buffers with the corresponding pins in itlb
   assign   waysel_buf_s1 = itlb_wsel_waysel_s1;

   // Very Timing Critical Wayselect Muxes
   // !!Cannot be a one-hot mux!!
   // use ao2222
//   bw_u1_ao2222_2x #(34) fetway_mx(.z   (rdc_fetdata_s1[33:0]),
//                                   .a2  (icd_wsel_fetdata_s1[33:0]),
//                                   .b2  (icd_wsel_fetdata_s1[67:34]),
//                                   .c2  (icd_wsel_fetdata_s1[101:68]),
//                                   .d2  (icd_wsel_fetdata_s1[135:102]),
//                                   .a1  (waysel_buf_s1[0]),
//                                   .b1  (waysel_buf_s1[1]),
//                                   .c1  (waysel_buf_s1[2]),
//                                   .d1  (waysel_buf_s1[3]));

//   bw_u1_ao2222_2x #(34) topway_mx(.z   (rdc_topdata_s1[33:0]),
//                                   .a2  (icd_wsel_topdata_s1[33:0]),
//                                   .b2  (icd_wsel_topdata_s1[67:34]),
//                                   .c2  (icd_wsel_topdata_s1[101:68]),
//                                   .d2  (icd_wsel_topdata_s1[135:102]),
//                                   .a1  (waysel_buf_s1[0]),
//                                   .b1  (waysel_buf_s1[1]),
//                                   .c1  (waysel_buf_s1[2]),
//                                   .d1  (waysel_buf_s1[3]));

   assign rdc_fetdata_s1 = icd_wsel_fetdata_s1[33:0] & {34{waysel_buf_s1[0]}} |
                         icd_wsel_fetdata_s1[67:34] & {34{waysel_buf_s1[1]}}  |
                         icd_wsel_fetdata_s1[101:68] & {34{waysel_buf_s1[2]}} |
                         icd_wsel_fetdata_s1[135:102] & {34{waysel_buf_s1[3]}};
   
   assign rdc_topdata_s1 = icd_wsel_topdata_s1[33:0] & {34{waysel_buf_s1[0]}} |
                         icd_wsel_topdata_s1[67:34] & {34{waysel_buf_s1[1]}}  |
                         icd_wsel_topdata_s1[101:68] & {34{waysel_buf_s1[2]}} |
                         icd_wsel_topdata_s1[135:102] & {34{waysel_buf_s1[3]}};

   // buffer and send to fdp
   assign   wsel_fdp_fetdata_s1 = rdc_fetdata_s1;
   assign   wsel_fdp_topdata_s1 = rdc_topdata_s1;
   
   // mux for asi data, not critical
   dp_mux4ds #(34) asid_mx(.dout (erb_asidata_s[33:0]),
                           .in0  (icd_wsel_fetdata_s1[33:0]),
                           .in1  (icd_wsel_fetdata_s1[67:34]),
                           .in2  (icd_wsel_fetdata_s1[101:68]),
                           .in3  (icd_wsel_fetdata_s1[135:102]),
                           .sel0_l (dec_asiway_s_l[0]),
                           .sel1_l (dec_asiway_s_l[1]),
                           .sel2_l (dec_asiway_s_l[2]),
                           .sel3_l (dec_asiway_s_l[3]));

   dp_mux4ds #(34) asitop_mx(.dout (asi_topdata_s[33:0]),
                           .in0  (icd_wsel_topdata_s1[33:0]),
                           .in1  (icd_wsel_topdata_s1[67:34]),
                           .in2  (icd_wsel_topdata_s1[101:68]),
                           .in3  (icd_wsel_topdata_s1[135:102]),
                           .sel0_l (dec_asiway_s_l[0]),
                           .sel1_l (dec_asiway_s_l[1]),
                           .sel2_l (dec_asiway_s_l[2]),
                           .sel3_l (dec_asiway_s_l[3]));

   // buffer before sending to bist/errdp
   assign wsel_mbist_icache_data = {asi_topdata_s[33:32], 
                                    erb_asidata_s[33:32], 
                                    asi_topdata_s[31:0],
                                    erb_asidata_s[31:0]};

// Everything below can be ignored for physical implementation
// monitor for waysel -- moved here from itlb
// Keeping this around for 0-in. cmp level check is in icache_mutex_mon.v

















 
endmodule // sparc_ifu_wseldp

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_sscan.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================

// trin (10/11/14):
// I'm rewriting this so data doesn't have to be shifted out
//  bit by bit

// module sparc_ifu_sscan( ctu_sscan_snap, ctu_sscan_se, lsu_sscan_test_data, 
// tlu_sscan_test_data, swl_sscan_thrstate, ifq_sscan_test_data, sparc_sscan_so, rclk, si, so, se);

// input ctu_sscan_snap;
// // input ctu_sscan_se;
// // input ctu_tck;
// // input si;
// // input se;
// input [10:0] swl_sscan_thrstate;
// input [3:0] ifq_sscan_test_data;
// input [15:0] lsu_sscan_test_data;
// input [62:0] tlu_sscan_test_data;
// input rclk;

// // output sparc_sscan_so;
// // output so;
// output 

//////////////////////////////////////////////////////////////////

// wire snap_f;
// wire [93:0] snap_data, snap_data_f, snap_data_ff;

// `ifdef CONNECT_SHADOW_SCAN
// wire [92:0] sscan_shift_data;
// `endif

////////

// dff_s #(1) snap_inst0(.q(snap_f), .din(ctu_sscan_snap), .clk(rclk), .se(se), .si(), .so());

// assign snap_data = {ifq_sscan_test_data, tlu_sscan_test_data, lsu_sscan_test_data, swl_sscan_thrstate};

// dffe_s #(94) snap_inst1(.q(snap_data_f), .din(snap_data), .clk(rclk), .en(snap_f), .se(se), .si(), .so());

// `ifdef CONNECT_SHADOW_SCAN
// dff_sscan #(94) snap_inst2(.q(snap_data_ff), .din(snap_data_f), .clk(ctu_tck), .se(ctu_sscan_se), 
// 		     .si({sscan_shift_data, 1'b0}),
// 		     .so({sparc_sscan_so, sscan_shift_data}));
// `else
// dff_s #(94) snap_inst2(.q(snap_data_ff), .din(snap_data_f), .clk(ctu_tck), .se(ctu_sscan_se), 
// 		     .si(), .so());

// assign sparc_sscan_so = 1'b0;
// `endif

// sink #(94) s0(.in (snap_data_ff));

module sparc_ifu_sscan(
    input wire [10:0] swl_sscan_thrstate,
    input wire [3:0] ifq_sscan_test_data,
    input wire [15:0] lsu_sscan_test_data,
    input wire [62:0] tlu_sscan_test_data,
    input wire rclk,

    // jtag debug
    output reg [94-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [94-1:0] rtap_core_data
    // output reg [93:0] sparc_sscan
    );

reg [93:0] snap_data;
reg [93:0] snap_data_next;
reg rtap_sscan_snap;
reg rtap_sscan_snap_f;

always @ (posedge rclk)
begin
    snap_data <= snap_data_next;
    rtap_sscan_snap_f <= rtap_sscan_snap;
end

always @ *
begin
    rtap_sscan_snap = 0;
    if (rtap_core_val && rtap_core_id == 4'd5)
        rtap_sscan_snap = 1'b1;

    if (rtap_sscan_snap)
        snap_data_next = {ifq_sscan_test_data, tlu_sscan_test_data, lsu_sscan_test_data, swl_sscan_thrstate};
    else
        snap_data_next = snap_data;

    core_rtap_data = 0;
    if (rtap_sscan_snap_f)
        core_rtap_data = snap_data;
end

endmodule     
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_ifqctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqctl
//  Description:	
//  Contains the control logic for the ifq and mil.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting














module sparc_ifu_ifqctl(/*AUTOARG*/
   // Outputs
   ifu_lsu_inv_clear, ifu_lsu_ibuf_busy, ifu_lsu_asi_ack, 
   ifu_lsu_ldxa_illgl_va_w2, ifu_lsu_fwd_wr_ack, ifu_lsu_pcxreq_d, 
   ifu_lsu_destid_s, ifu_tlu_l2imiss, ifq_fcl_stallreq, 
   ifq_swl_stallreq, ifq_fcl_flush_sonly_e, ifq_fcl_wrreq_bf, 
   ifq_fcl_rdreq_bf, ifq_fcl_icd_wrreq_bf, ifq_fcl_ictv_wrreq_bf, 
   ifq_erb_fwdrd_bf, ifq_erb_rdtag_f, ifq_erb_rdinst_f, 
   ifq_erb_asi_erren_i2, ifq_erb_asi_errstat_i2, 
   ifq_erb_asi_errinj_i2, ifq_erb_asi_erraddr_i2, 
   ifq_erb_asi_imask_i2, ifq_erb_asiwr_i2, ifq_fcl_asird_bf, 
   ifq_fcl_asi_tid_bf, ifq_erb_ue_rep, ifq_erb_ce_rep, ifq_erb_l2_ue, 
   ifq_erb_io_ue, ifq_erb_ifet_ce, ifq_erb_l2err_tid, 
   ifq_icv_wrdata_bf, ifq_icd_worden_bf, ifq_fcl_fill_thr, 
   ifq_dtu_thrrdy, ifq_dtu_pred_rdy, ifc_ifd_filladdr4_i2, 
   ifc_ifd_reqvalid_e, ifc_ifd_idx_sel_fwd_i2, ifc_ifd_errinv_e, 
   ifc_ifd_uncached_e, ifc_ifd_thrid_e, ifc_ifd_pcxline_adj_d, 
   ifc_inv_asireq_i2, ifc_ifd_repway_s, ifq_sscan_data, 
   ifc_ifd_milfill_sel_i2_l, ifc_ifd_finst_sel_l, 
   ifc_ifd_milreq_sel_d_l, ifc_ifd_ifqbyp_sel_fwd_l, 
   ifc_ifd_ifqbyp_sel_inq_l, ifc_ifd_ifqbyp_sel_asi_l, 
   ifc_ifd_ifqbyp_sel_lsu_l, ifc_ifd_ifqbyp_en_l, 
   ifc_ifd_addr_sel_bist_i2_l, ifc_ifd_addr_sel_asi_i2_l, 
   ifc_ifd_addr_sel_old_i2_l, ifc_ifd_addr_sel_fill_i2_l, 
   ifq_icd_data_sel_bist_i2, ifq_icd_data_sel_fill_i2, 
   ifq_icd_data_sel_old_i2, ifc_ifd_ldmil_sel_new, ifc_ifd_ld_inq_i1, 
   ifc_inv_ifqadv_i2, so, 
   // Inputs
   lsu_ifu_cpxpkt_wayvld_i1, ifd_ifc_milhit_s, ifd_ifc_instoffset0, ifd_ifc_instoffset1, 
   ifd_ifc_instoffset2, ifd_ifc_instoffset3, ifd_ifc_cpxvalid_i1, 
   ifd_ifc_cpxreq_i1, ifd_ifc_cpxreq_nxt, ifd_ifc_cpxthr_nxt, 
   ifd_ifc_cpxvld_i2, ifd_ifc_iobpkt_i2, ifd_ifc_4bpkt_i2, 
   ifd_ifc_cpxnc_i2, ifd_ifc_fwd2ic_i2, ifd_ifc_cpxce_i2, 
   ifd_ifc_cpxue_i2, ifd_ifc_cpxms_i2, ifd_ifc_miladdr4_i2, 
   ifd_ifc_asiaddr_i2, ifd_ifc_asi_vachklo_i2, ifd_ifc_destid0, 
   ifd_ifc_destid1, ifd_ifc_destid2, ifd_ifc_destid3, 
   ifd_ifc_newdestid_s, ifd_ifc_pcxline_d, inv_ifc_inv_pending, 
   fcl_ifq_icmiss_s1, fcl_ifq_rdreq_s1, fcl_ifq_thr_s1, 
   fcl_ifq_canthr, fcl_ifq_grant_bf, dtu_ifq_kill_latest_d, 
   erb_ifq_ifeterr_d1, erb_ifq_itlberr_s1, lsu_ifu_pcxpkt_ack_d, 
   lsu_ifu_direct_map_l1, lsu_ifu_asi_vld, lsu_ifu_asi_state, 
   lsu_ifu_asi_load, lsu_ifu_asi_thrid, fcl_ifq_icache_en_s_l, 
   mbist_ifq_run_bist, mbist_icache_write, mbist_icache_read, 
   ctu_sscan_tid, rclk, se, si, gdbginit_l, arst_l, grst_l, 
   rst_tri_en, sehold
   );

   input          lsu_ifu_cpxpkt_wayvld_i1;
   input [3:0]	  ifd_ifc_milhit_s;      // if an Imiss hits in MIL
   input [1:0]    ifd_ifc_instoffset0; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset1; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset2; // to select inst to TIR
   input [1:0]    ifd_ifc_instoffset3; // to select inst to TIR

   input         ifd_ifc_cpxvalid_i1;
   input [(143 - 140 + 1):0] ifd_ifc_cpxreq_i1;

   input [3:0]   ifd_ifc_cpxreq_nxt;
   input [1:0]   ifd_ifc_cpxthr_nxt;
   input         ifd_ifc_cpxvld_i2;
   
   input         ifd_ifc_iobpkt_i2;
   input         ifd_ifc_4bpkt_i2;
   input         ifd_ifc_cpxnc_i2;
   input         ifd_ifc_fwd2ic_i2;
   input         ifd_ifc_cpxce_i2,
		             ifd_ifc_cpxue_i2,
                 ifd_ifc_cpxms_i2;
   
   input [3:0]   ifd_ifc_miladdr4_i2;

   input [3:2]   ifd_ifc_asiaddr_i2;
   input         ifd_ifc_asi_vachklo_i2;

   input [2:0]   ifd_ifc_destid0,
		             ifd_ifc_destid1,
		             ifd_ifc_destid2,
		             ifd_ifc_destid3,
		             ifd_ifc_newdestid_s;
   input [4:2]   ifd_ifc_pcxline_d;
//   input [7:0]   ifd_ifc_mil_repway_s;   

   input         inv_ifc_inv_pending;
   
   input         fcl_ifq_icmiss_s1;   // icache miss
   input         fcl_ifq_rdreq_s1;

   input [1:0]   fcl_ifq_thr_s1;

   input [3:0]   fcl_ifq_canthr;        // cancel the imiss reqs to
                                        // these threads
   input         fcl_ifq_grant_bf;

   input         dtu_ifq_kill_latest_d;
   input         erb_ifq_ifeterr_d1;
   input         erb_ifq_itlberr_s1;
   
   input         lsu_ifu_pcxpkt_ack_d;
   input         lsu_ifu_direct_map_l1;

   input         lsu_ifu_asi_vld;
   input [7:0]   lsu_ifu_asi_state;
   input         lsu_ifu_asi_load;
   input [1:0]   lsu_ifu_asi_thrid;

   input         fcl_ifq_icache_en_s_l;
   
   input         mbist_ifq_run_bist,
                 mbist_icache_write,
		             mbist_icache_read;

   input [3:0]   ctu_sscan_tid;

   input         rclk, 
                 se, 
                 si,
                 gdbginit_l,
                 arst_l,
                 grst_l;

   input         rst_tri_en;
   input         sehold;
   
   // outputs
   output        ifu_lsu_inv_clear;
   output        ifu_lsu_ibuf_busy;
   output        ifu_lsu_asi_ack;
   output        ifu_lsu_ldxa_illgl_va_w2;

   output        ifu_lsu_fwd_wr_ack;
   
   output        ifu_lsu_pcxreq_d;
   output [2:0]  ifu_lsu_destid_s;

   output [3:0]  ifu_tlu_l2imiss;
   
   output        ifq_fcl_stallreq;
   output        ifq_swl_stallreq;
   output        ifq_fcl_flush_sonly_e;
   
   output        ifq_fcl_wrreq_bf;
   output        ifq_fcl_rdreq_bf;
   
   output        ifq_fcl_icd_wrreq_bf,
		             ifq_fcl_ictv_wrreq_bf;
   output        ifq_erb_fwdrd_bf;
   output        ifq_erb_rdtag_f;
   output        ifq_erb_rdinst_f;
   output        ifq_erb_asi_erren_i2;
   output        ifq_erb_asi_errstat_i2;
   output        ifq_erb_asi_errinj_i2;
   output        ifq_erb_asi_erraddr_i2;
   output        ifq_erb_asi_imask_i2;
   output        ifq_erb_asiwr_i2;
   
   output        ifq_fcl_asird_bf;
   output [1:0]  ifq_fcl_asi_tid_bf;

   output        ifq_erb_ue_rep;
   output        ifq_erb_ce_rep;
   output        ifq_erb_l2_ue;
   output        ifq_erb_io_ue;
   output        ifq_erb_ifet_ce;
   output [1:0]  ifq_erb_l2err_tid;

   output        ifq_icv_wrdata_bf;
   output [3:0]  ifq_icd_worden_bf;

   output [3:0]  ifq_fcl_fill_thr;     // should be same stage as 
   // fill_inst
   output [3:0]  ifq_dtu_thrrdy;
   output [3:0]  ifq_dtu_pred_rdy;
   
   output        ifc_ifd_filladdr4_i2;
   output        ifc_ifd_reqvalid_e;
   output        ifc_ifd_idx_sel_fwd_i2;

   output        ifc_ifd_errinv_e;
   output        ifc_ifd_uncached_e;
   output [1:0]  ifc_ifd_thrid_e;
   output [4:2]  ifc_ifd_pcxline_adj_d;

   output        ifc_inv_asireq_i2;

   output [1:0]  ifc_ifd_repway_s;

   output [3:0]  ifq_sscan_data;
   
   // mux selects
   output [3:0]  ifc_ifd_milfill_sel_i2_l;
   output [3:0]  ifc_ifd_finst_sel_l;
   output [3:0]  ifc_ifd_milreq_sel_d_l;
   output        ifc_ifd_ifqbyp_sel_fwd_l, // select next input to ifq pipe
		             ifc_ifd_ifqbyp_sel_inq_l,
		             ifc_ifd_ifqbyp_sel_asi_l,
		             ifc_ifd_ifqbyp_sel_lsu_l;
	 output        ifc_ifd_ifqbyp_en_l;
   
   output        ifc_ifd_addr_sel_bist_i2_l,
		             ifc_ifd_addr_sel_asi_i2_l,
                 ifc_ifd_addr_sel_old_i2_l,
		             ifc_ifd_addr_sel_fill_i2_l;

   output        ifq_icd_data_sel_bist_i2,
		             ifq_icd_data_sel_fill_i2,
		             ifq_icd_data_sel_old_i2;
	 
   // 2:1 mux selects
   output [3:0]  ifc_ifd_ldmil_sel_new;     // mil load enable

   
   output        ifc_ifd_ld_inq_i1;
   
   output        ifc_inv_ifqadv_i2;         // move a new op from ifq
	 // pipe to icache

   output        so;
   
   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------   
   // local signals
   wire [3:0]    thr_s1,      // s1 thread which missed in I$
		             thr_d1,
                 thr_e1,
		             dfthr_f,     // thread currently being filled in I$
                 dfthr_next_i2,
		             dfthr_i2,    // next thread to be filled from CPX
                 milfthr_i2,
		             dpcxthr_s,
		             dpcxthr_d;   // thread being transmitted to lsu

   wire [1:0]    thrid_d,
                 thrid_e;
   
   wire [3:0]    pcx_accept_d;

   wire          req_pending_d,
//		             req_pending_e,
		             req_accept_d,
//                 can_pcx_d,
                 pcxreq_vbit_d;
   
   wire [3:0]    comp_valid_s,
		             mil_valid_s,
                 mil_cancel;

   wire [3:0]    finst_i2,
                 finst0,
                 finst1,
                 finst2,
                 finst3;

   wire [2:0]    milchld0,
		             milchld1,
		             milchld2,
		             milchld3,
		             next_milchld,
		             milchld_d1;
   wire          milchld_vld_f,
		             next_milchld_i2,
		             milchld_vld_i2;

   wire [3:0]    mil0_state,
                 mil1_state,
                 mil2_state,
                 mil3_state;

   wire [2:0]    i2out;         // state machine output in i2 stage
   
   wire          any_milhit_qual_s,     // hit in MIL
                 any_qualhit_or_io_s,
		             icmiss_qual_s,
//		             reqq_empty,    // no pending requests in MIL
		             oldreq_valid,
		             next_wrreq_i2,
		             wrreq_f;
   wire          block_fetch_s1,
                 block_fetch_d1;

   wire [3:0]    mil_thr_ready,
                 all_retry_rdy_e1,
                 all_retry_rdy_m1;
   wire          retry_rdy_final_d1,
                 retry_rdy_e1;

   wire          rst_starv_ctr_l;
   wire          starv_alert;

   wire [3:0]    milhit_vec_s;
   wire          any_milhit_s;

   wire [1:0]    rand_repway_s;
//   wire [1:0]    mil_repway_s;

   wire [3:0]    errthr_d1,
		             err_vec_d1,
		             err_req;
   wire          errinv_d1;

   wire          ifeterr_qual_d1,
                 ifeterr_e1;
   wire          thr_match_d1e1;
   wire          ifqadv_i1;

   wire          ifqadvi2_nxt,
                 ifqadv_i2_ff;
   wire          access_grant_l;

   wire          addrbit4_i2;
   wire          addrbit4_nxt_i2;
   
   wire [3:0]    cpxreq_i2;
   wire [1:0]    cpxthr_i2;
   

   wire          uncached_i2,
                 uncached_s,
                 mil_vld_i2,
                 mil_uncan_i2,
                 mil_nc_i2,
                 mil_nc_e,
                 mil_nc_d,
		             uncached_fill_i2,
		             uncached_f;

   wire [3:0]    mil_nc_vec,
                 mil_nc_vec_nxt;
                 
   
   wire [3:0]    pcxreq_s,          // req bit from MIL
                 pcxreq_qual_s,
//		             newpcxreq_s,       // valid new request from latest miss
//		             oldpcxreq_s,
		             rr_gnt,          // round robin grant signal
		             fill_addr4_i2;    // fill address bit 4 - determines
	 // which 16B of the 32B line gets
	 // written. Assume 0 first then 1

   wire          newreq_valid,    // latest S stage miss creates request.
		             nextreq_valid_s, // if either a new req from i$ or old
				         // req from MIL is made in this cycle.
		             req_valid_d;     // req to LSU is valid

   wire          inq_vld,
		             inq_vld_nxt;

   wire          ic_pkt_i1;
   
//   wire          fill_this16b;

   wire [1:0]    filltid_i2,
		             next_filltid_i2,
		             filltid_f;

   wire          imissrtn_i2,   // input cpx is ifill return
                 imissrtn_next_i2,
                 imissrtn_f,
		             imissrtn_i1;   // pkt in inq is ifill ret

   wire          invalidate_i1;

   wire [3:0]    icmiss_thr_s,
		             icmiss_thr_d;
   wire          icmiss_d1,
                 icmiss_qual_d1;
   wire          canthr_s1,
                 canthr_d1,
                 canthr_s1_del1;
   wire          itlberr_d1;

   wire [2:0]    old_destid_s;

   wire          destid_iob_s,
                 destid_iob_d;

   wire          iosp_d1_l,
                 n763;
   
   wire [3:0]    wrt_tir;

   wire [3:0]    wr_complete_f;
   wire [3:0]    pred_rdy_i2;
   wire [3:0]    fill_retn_thr_i2;

   wire          filladdr4_f;
   
   wire [3:0]    milhit_to_thr_s,
		             icmiss_for_milchk,
                 qualhit_pe_s,
                 qualhit_or_io_s;
//		             milhit_qual_s;

   wire          l2_ue_i2,
		             l2_ce_i2,
		             io_ue_i2;
   wire          l2_miss_i2,
                 l2_miss_f;
//   wire [3:0]    l2ms_thr;
   
   wire          ce_rep_i2,
		             ue_rep_i2;

   wire          fwdreq_i2,
                 fwdreq_i3,
                 fwd_stall,
                 fwdwr_i3,
                 fwdrd_i3;

   wire          cpxnc_i3;

   wire          stallreq_d0,
                 stallreq_d1;

   wire          ifu_asireq_i1,
                 ifu_asireq_i0,
                 byp_sel_asi_l,
                 asird_i1,
		             asireq_i2,
                 asireq_i2_l,
		             asi_load_i1,
		             asi_load_i2,
		             asi_vld_next,
                 asi_vld_i0,
                 asi_vld_qual_i0;
   
   wire [7:0]    asi_state_i1;
   wire          asi_ic_data_i1,
		             asi_ic_data_i2,
		             asi_ic_tag_i1,
		             asi_ic_tag_i2;

   wire          asi_erren_i1,
		             asi_errstat_i1,
		             asi_errinj_i1,
		             asi_erraddr_i1,
		             asi_imask_i1;

   wire          asi_ic_data_unchk_i1,
		             asi_ic_tag_unchk_i1;

   wire          asi_erren_unchk_i1,
		             asi_errstat_unchk_i1,
		             asi_errinj_unchk_i1,
		             asi_erraddr_unchk_i1,
		             asi_imask_unchk_i1;

   wire          illva_i0,
                 illva_i1,
                 illva_i2,
                 illva_f,
                 illva_s,
                 illva_w2;

   wire [3:0]    word_sel_i2;
   wire          bist_op;

   wire          rdinst_bf,
		             rd_tag_bf;
   
   wire          errpkt_i1;
   
   wire          stpkt_i1,
                 strmack_i1,
		             ldpkt_i1,
		             evpkt_i1,
		             errpkt_i2;
   
   wire          icv_wrdata_i2,
		             icv_wbit_i2,
		             icv_wrdata_f;

   wire          rst_way_lfsr;

   wire          inq_wayvld_i1;
   wire          inq_wayvld_i1_nxt;
   wire          ldinv_i1;
   wire          ldinv_i2_nxt;
   wire          ldinv_i2;
	 
   wire          ifq_reset,
                 rnd_reset,
                 ifq_reset_l;
   

   wire          clk;
   
   
//----------------------------------------------------------------------
// Code start here 
//----------------------------------------------------------------------

   assign        clk = rclk;
   

   // reset buffer
   dffrl_async rstff(.din (grst_l),
                     .q   (ifq_reset_l),
                     .clk (clk), .se(se), .si(), .so(),
                     .rst_l (arst_l));

   assign       ifq_reset = ~ifq_reset_l;

   
//---------
// MIL fsm
//---------   
   sparc_ifu_milfsm mil0(
 	                       .ifc_fsm_can_thisthr      (fcl_ifq_canthr[0]),        
                         //	.ifc_fsm_orphan_thisthr (orphan_thr_d1[0]),


	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[0]),    
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[0]),

                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),
	                       .ifc_fsm_imiss_thisthr_s  (icmiss_thr_s[0]),          
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),

	                       .ifc_fsm_hiton_thismil_s  (milhit_to_thr_s[0]),   

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[0]),
                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[0]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

                         .so                       (),

	                       .ifc_fsm_err_thisthr      (errthr_d1[0]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[0]),
		  
	                       .fsm_ifc_wrt_tir          (wrt_tir[0]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[0]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[0]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[0]),
                         .fsm_ifc_milstate         (mil0_state[3:0]),
			
	                       .fsm_ifc_thr_ready        (mil_thr_ready[0]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[0]),
	                       .fsm_ifc_pcxreq           (pcxreq_s[0]),       
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[0]),
	                       .fsm_ifc_milchld          (milchld0[2:0]));
   

   sparc_ifu_milfsm mil1(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[1]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[1]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[1]),   
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[1]),          
      
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[1]),   
	                       .ifc_fsm_imiss_thisthr_s   (icmiss_thr_s[1]),          

	                       .ifc_fsm_pcxaccept_thisthr   (pcx_accept_d[1]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         
                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[1]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[1]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[1]),

	                       .fsm_ifc_wrt_tir          (wrt_tir[1]),
                         .so                       (),	    
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[1]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[1]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[1]), 
	                       .fsm_ifc_mil_valid        (mil_valid_s[1]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[1]),
                         .fsm_ifc_milstate         (mil1_state[3:0]),

	                       .fsm_ifc_pcxreq           (pcxreq_s[1]),       
	                       .fsm_ifc_thr_ready        (mil_thr_ready[1]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[1]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[1]), 
	                       .fsm_ifc_milchld          (milchld1[2:0]));

   sparc_ifu_milfsm mil2(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[2]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[2]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[2]),
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[2]),          
			
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[2]),   
	                       .ifc_fsm_imiss_thisthr_s  (icmiss_thr_s[2]),          

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[2]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         

                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[2]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[2]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[2]),

                         .so                       (),	    
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[2]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[2]),
	                       .fsm_ifc_wrt_tir          (wrt_tir[2]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[2]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[2]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[2]),
                         .fsm_ifc_milstate         (mil2_state[3:0]),
			
	                       .fsm_ifc_pcxreq           (pcxreq_s[2]),       
	                       .fsm_ifc_thr_ready        (mil_thr_ready[2]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[2]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[2]), 
	                       .fsm_ifc_milchld          (milchld2[2:0]));


   sparc_ifu_milfsm mil3(
                         .ifc_fsm_can_thisthr      (fcl_ifq_canthr[3]),        
                         //	   .ifc_fsm_orphan_thisthr   (orphan_thr_d1[3]),     

	                       .ifc_fsm_fill_thisthr_i2  (fill_retn_thr_i2[3]),
	                       .ifc_fsm_wr_complete_f    (wr_complete_f[3]), 
			
                         .ifqadv_i2  (ifc_inv_ifqadv_i2),

                         .ifd_ifc_4bpkt_i2         (ifd_ifc_4bpkt_i2),
	                       .fcl_ifq_thr_s1           (fcl_ifq_thr_s1),             
	                       .ifc_fsm_milhit_s         (any_milhit_qual_s),           
	                       .ifc_fsm_hiton_thismil_s (milhit_to_thr_s[3]),   
	                       .ifc_fsm_imiss_thisthr_s   (icmiss_thr_s[3]),          

	                       .ifc_fsm_pcxaccept_thisthr(pcx_accept_d[3]),     
                         //	   .ifc_fsm_reqq_empty       (reqq_empty),         

                         .ifc_fsm_miladdr4         (ifd_ifc_miladdr4_i2[3]),

	                       .clk                      (clk),
                         .se                       (se),
                         .si                       (si),
	                       .reset                    (ifq_reset),

	                       .ifc_fsm_err_thisthr      (errthr_d1[3]),
			
	                       // outputs	 
                         .fsm_ifc_errreq           (err_req[3]),

                         .so                       (),	
                         //	   .fsm_ifc_cm_pending       (can_miss_pending[3]),
                         //	   .fsm_ifc_delay_mil        (delay_mil[3]),
	                       .fsm_ifc_wrt_tir          (wrt_tir[3]),
	                       .fsm_ifc_comp_valid       (comp_valid_s[3]),
	                       .fsm_ifc_mil_valid        (mil_valid_s[3]),
	                       .fsm_ifc_mil_cancel       (mil_cancel[3]),
                         .fsm_ifc_milstate         (mil3_state[3:0]),
			
	                       .fsm_ifc_pcxreq           (pcxreq_s[3]),           
	                       .fsm_ifc_thr_ready        (mil_thr_ready[3]),
	                       .fsm_ifc_pred_rdy         (pred_rdy_i2[3]),
	                       .fsm_ifc_addrbit4_i2      (fill_addr4_i2[3]),    
	                       .fsm_ifc_milchld          (milchld3[2:0]));


   
//-------------------------------------------
// Fill Return Control (IFU interfac to CPX)
//-------------------------------------------

   // use soffm2 for lower setup
   dffe_s #(4) cpxreq_reg(.din (ifd_ifc_cpxreq_nxt),
                        .q   (cpxreq_i2),
                        .en  (ifqadv_i1),
                        .clk (clk), .se(se), .si(), .so());
   dffe_s #(2) cpxthr_reg(.din (ifd_ifc_cpxthr_nxt),
                        .q   (cpxthr_i2),
                        .en  (ifqadv_i1),
                        .clk (clk), .se(se), .si(), .so());
   

   // Decode CPX request
   assign imissrtn_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0001}) ? 1'b1 : 1'b0;   
   assign imissrtn_i2 = (cpxreq_i2 == 4'b0001) ? ifd_ifc_cpxvld_i2 : 1'b0;

   assign imissrtn_next_i2 = ifc_inv_ifqadv_i2 ? imissrtn_i2 : imissrtn_f;
   
   dff_s #(1) imsf_ff(.din (imissrtn_next_i2),
                    .q   (imissrtn_f),
                    .clk (clk), .se (se), .si(), .so());
   
   // Determine if this is an IFILL RET to one of the threads
   assign fill_retn_thr_i2 = dfthr_i2 & {4{imissrtn_i2}};
   
   // decode current icache fill thread
   assign dfthr_f[0] = ~filltid_f[1] & ~filltid_f[0];
   assign dfthr_f[1] = ~filltid_f[1] &  filltid_f[0];
   assign dfthr_f[2] =  filltid_f[1] & ~filltid_f[0];
   assign dfthr_f[3] =  filltid_f[1] &  filltid_f[0];

//`ifdef IFU_SAT
//   assign ifc_ifd_uncached_s = fcl_ifq_icache_en_s_l;   
//`else   
//`endif

   assign uncached_s = ifd_ifc_newdestid_s[2] | fcl_ifq_icache_en_s_l;

   // timing fix: keep nc bit locally instead of in DP
   assign mil_nc_vec_nxt = ({4{uncached_s & fcl_ifq_rdreq_s1}} & 
                              thr_s1 & ~errthr_d1 |
                              mil_nc_vec & (mil_valid_s |
                                            errthr_d1));

   dff_s #(4) nc_reg(.din (mil_nc_vec_nxt),
                   .q   (mil_nc_vec),
                   .clk (clk), .se(se), .si(), .so());

   assign mil_nc_i2 = (dfthr_i2[0] & mil_nc_vec[0] |
                       dfthr_i2[1] & mil_nc_vec[1] |
                       dfthr_i2[2] & mil_nc_vec[2] |
                       dfthr_i2[3] & mil_nc_vec[3]);

   assign mil_nc_d = (dpcxthr_d[0] & mil_nc_vec[0] |
                      dpcxthr_d[1] & mil_nc_vec[1] |
                      dpcxthr_d[2] & mil_nc_vec[2] |
                      dpcxthr_d[3] & mil_nc_vec[3]);

   dff_s #(1) nce_ff(.din (mil_nc_d),
                   .q   (mil_nc_e),
                   .clk (clk), .se(se), .si(), .so());
   assign ifc_ifd_uncached_e = mil_nc_e;
   
//   assign uncached_fill_i2 = ifd_ifc_uncached_i2 | ifd_ifc_cpxnc_i2;
   assign uncached_fill_i2 = mil_nc_i2 | ifd_ifc_cpxnc_i2;   
   
   // uncached fill -- do not write to icache
   assign uncached_i2 = ifc_inv_ifqadv_i2 ? 
	                          uncached_fill_i2 : uncached_f;

   dff_s unc_ff(.din (uncached_i2),
	            .q   (uncached_f),
	            .clk (clk),
	            .se  (se), .si(), .so());

   // Determine if Icache write is done or 
   // if none is necessary (i.e. if this is a child process or NC)
   assign wr_complete_f = dfthr_f & {4{(wrreq_f & ifc_inv_ifqadv_i2 | 
                                        milchld_vld_f |
				                                uncached_f) & imissrtn_f}};

   // State Machine Outputs
   // One of these has to be chosen for I2 stage operation
   mux4ds #(3)  i2out_mux(.dout  (i2out),
		       .in0   (milchld0),
		       .in1   (milchld1),
		       .in2   (milchld2),
		       .in3   (milchld3),
		       .sel0  (dfthr_i2[0]),
		       .sel1  (dfthr_i2[1]),
		       .sel2  (dfthr_i2[2]),
		       .sel3  (dfthr_i2[3]));

   assign mil_vld_i2 = (mil_valid_s[0] & dfthr_i2[0] |
                        mil_valid_s[1] & dfthr_i2[1] |
                        mil_valid_s[2] & dfthr_i2[2] |
                        mil_valid_s[3] & dfthr_i2[3]);

   assign mil_uncan_i2 = (mil_valid_s[0] & ~mil_cancel[0] & dfthr_i2[0] |
                          mil_valid_s[1] & ~mil_cancel[1] & dfthr_i2[1] |
                          mil_valid_s[2] & ~mil_cancel[2] & dfthr_i2[2] |
                          mil_valid_s[3] & ~mil_cancel[3] & dfthr_i2[3]);

   // Don't make a wrreq if this is a child entry.  However, if this is
   // a child and the parent was cancelled, then go ahead and
   // write... is this really necessary?  Not for functionality.
   // 3/19: parent will write even if cancelled.  So never write child
   assign next_wrreq_i2 = imissrtn_i2 & mil_vld_i2 & ~uncached_fill_i2 &
	                  ~milchld_vld_i2 & ~ifd_ifc_4bpkt_i2; // was: iobpkt_i2

   assign addrbit4_i2 = (milfthr_i2[0] & fill_addr4_i2[0] |
                         milfthr_i2[1] & fill_addr4_i2[1] |
                         milfthr_i2[2] & fill_addr4_i2[2] |
                         milfthr_i2[3] & fill_addr4_i2[3]);

   assign addrbit4_nxt_i2= ifc_inv_ifqadv_i2 ? addrbit4_i2 : filladdr4_f;
   dff_s #(1) ab4_ff(.din (addrbit4_nxt_i2),
                   .q   (filladdr4_f),
                   .clk (clk),
                   .se  (se), .si(), .so());
   
   assign ifc_ifd_filladdr4_i2 = addrbit4_nxt_i2;

   assign next_milchld = ifc_inv_ifqadv_i2 ? 
	                          {(i2out[2] & imissrtn_i2), i2out[1:0]} :
	                          milchld_d1;

   // After the packet is processed, the child entry in the MIL,
   // pointed to by the reg below is processed next (if valid)
   dffr_s #(3)  milchldd_reg(.din  (next_milchld),
			                     .clk  (clk),
			                     .rst  (ifq_reset),
			                     .q    (milchld_d1),
			                     .se   (se), .si(), .so());

   assign milchld_vld_i2 = milchld_d1[2];
   assign next_milchld_i2 = ifc_inv_ifqadv_i2 ? milchld_d1[2] :
	                                              milchld_vld_f;
   
   dffr_s #(1) milchldf_ff(.din  (next_milchld_i2),
		       .q    (milchld_vld_f),
		       .clk  (clk),
		       .rst  (ifq_reset),
		       .se   (se), .si(), .so());

   // need this to avoid x's in the simulation
//   assign cpxthrid_adj_i2 = ifd_ifc_cpxthr_i2 &
//	                          {2{ifd_ifc_cpxreq_i2[`CPX_RQ_SIZE]}};

   // Determine if we should process the child or a new entry
//   assign next_thr_sel_milchld_i2 = ifc_inv_ifqadv_i2 & milchld_vld_i2 & 
//	                            ~errpkt_i2;
//   assign next_thr_sel_milchld_i2 = milchld_vld_i2 & ~errpkt_i2;
   
   
   // if previous mil entry had a child, process that next
//   mux2ds  #(2) filltid_mux(.dout  (filltid_i2),
//		                        .in0   (cpxthrid_adj_i2),
//		                        .in1   (milchld_d1[1:0]),
//		                        .sel0  (~milchld_vld_i2),
//		                        .sel1  (milchld_vld_i2));
   assign filltid_i2 = milchld_vld_i2 ? milchld_d1[1:0] :
                                        cpxthr_i2[1:0];

   // decode fill thread  (either cpx thread or MIL child thread from above)
   // need to qual with valid bit to avoid X's in simulation
//   assign cpxvld_or_milc_i2 = ifd_ifc_cpxreq_i2[`CPX_RQ_SIZE] | milchld_vld_i2;
   assign dfthr_i2[0] = ~filltid_i2[1] & ~filltid_i2[0];
   assign dfthr_i2[1] = ~filltid_i2[1] &  filltid_i2[0];
   assign dfthr_i2[2] =  filltid_i2[1] & ~filltid_i2[0];
   assign dfthr_i2[3] =  filltid_i2[1] &  filltid_i2[0];

   dp_mux2es  #(2)  thren_mux(.dout (next_filltid_i2),
			                        .in0  (filltid_f),
			                        .in1  (filltid_i2),
			                        .sel  (ifc_inv_ifqadv_i2));

   dff_s #(2) wrthr_reg(.din  (next_filltid_i2),
		                  .clk  (clk),
		                  .q    (filltid_f),
		                  .se   (se), .si(), .so());   


   dp_mux2es  #(4)  dthren_mux(.dout (dfthr_next_i2),
			                         .in0  (dfthr_f),
			                         .in1  (dfthr_i2),
			                         .sel  (ifc_inv_ifqadv_i2));
   

   // Early start of threads
   // Do we need a control bit to turn this off?
   // -- do it in SWL
   assign ifq_dtu_pred_rdy =  pred_rdy_i2 & {dfthr_next_i2[3:0]} &
                              {4{imissrtn_next_i2}};

// If timing is a problem resort to:
//   assign ifq_dtu_pred_rdy =  pred_rdy_i2 & {4{ifc_inv_ifqadv_i2}} &
//                              dfthr_i2 & {4{imissrtn_i2}};
   
   

   // pick 16B half cache line which contains the instruction we want
//   assign fill_this16b = ~(ifc_ifd_filladdr4_i2 ^ ifd_ifc_missaddr4_i2);
                         // | ifd_ifc_4bpkt_i2;

   // write to thread instruction register
//   assign ifq_fcl_fill_thr = wrt_tir & {4{fill_this16b | ifd_ifc_4bpkt_i2}};
//   assign ifq_fcl_fill_thr = wrt_tir & {4{fill_this16b}};
   assign ifq_fcl_fill_thr = wrt_tir | thr_d1 & {4{itlberr_d1 & 
                                                   ~canthr_d1 & 
                                                   icmiss_d1 & 
                                                   ~canthr_s1_del1}};

   // Select instruction to send to TIR
   // TBD: Need to find out how the inst from boot PROM is aligned -- Done
   // From kinkee 02/21/03: It is aligned to the correct 4B of the 16B 
   // packet.  The other locations are X.
   assign finst0[0] = ~ifd_ifc_instoffset0[1] & ~ifd_ifc_instoffset0[0];
   assign finst0[1] = ~ifd_ifc_instoffset0[1] &  ifd_ifc_instoffset0[0];
   assign finst0[2] =  ifd_ifc_instoffset0[1] & ~ifd_ifc_instoffset0[0];
   assign finst0[3] =  ifd_ifc_instoffset0[1] &  ifd_ifc_instoffset0[0];

   assign finst1[0] = ~ifd_ifc_instoffset1[1] & ~ifd_ifc_instoffset1[0];
   assign finst1[1] = ~ifd_ifc_instoffset1[1] &  ifd_ifc_instoffset1[0];
   assign finst1[2] =  ifd_ifc_instoffset1[1] & ~ifd_ifc_instoffset1[0];
   assign finst1[3] =  ifd_ifc_instoffset1[1] &  ifd_ifc_instoffset1[0];

   assign finst2[0] = ~ifd_ifc_instoffset2[1] & ~ifd_ifc_instoffset2[0];
   assign finst2[1] = ~ifd_ifc_instoffset2[1] &  ifd_ifc_instoffset2[0];
   assign finst2[2] =  ifd_ifc_instoffset2[1] & ~ifd_ifc_instoffset2[0];
   assign finst2[3] =  ifd_ifc_instoffset2[1] &  ifd_ifc_instoffset2[0];

   assign finst3[0] = ~ifd_ifc_instoffset3[1] & ~ifd_ifc_instoffset3[0];
   assign finst3[1] = ~ifd_ifc_instoffset3[1] &  ifd_ifc_instoffset3[0];
   assign finst3[2] =  ifd_ifc_instoffset3[1] & ~ifd_ifc_instoffset3[0];
   assign finst3[3] =  ifd_ifc_instoffset3[1] &  ifd_ifc_instoffset3[0];

//   mux4ds #(4) finst_mx(.dout (finst_i2),
//                        .in0  (finst0),
//                        .in1  (finst1),
//                        .in2  (finst2),
//                        .in3  (finst3),
//                        .sel0 (dfthr_i2[0]),
//                        .sel1 (dfthr_i2[1]),
//                        .sel2 (dfthr_i2[2]),
//                        .sel3 (dfthr_i2[3]));

   wire [3:0] finst_ev,
              finst_od,
              finst_i2_l;
   wire [1:0] filltid_i2_l;
   bw_u1_inv_10x UZsize_ftid_bf0(.z (filltid_i2_l[0]),
                                 .a (filltid_i2[0]));
   bw_u1_inv_20x UZsize_ftid_bf1(.z (filltid_i2_l[1]),
                                 .a (filltid_i2[1]));
   // use bw_u1_muxi21_4x
   assign finst_ev = filltid_i2_l[1] ? finst0 : finst2;
   assign finst_od = filltid_i2_l[1] ? finst1 : finst3;
   assign finst_i2_l = filltid_i2_l[0] ? (~finst_ev) : (~finst_od);
   assign finst_i2 = ~finst_i2_l;

   assign ifc_ifd_finst_sel_l = ~finst_i2;

   // pick MIL entry corresponding to current thread
   assign milfthr_i2[0] = ~cpxthr_i2[1] & ~cpxthr_i2[0];
   assign milfthr_i2[1] = ~cpxthr_i2[1] &  cpxthr_i2[0];
   assign milfthr_i2[2] =  cpxthr_i2[1] & ~cpxthr_i2[0];
   assign milfthr_i2[3] =  cpxthr_i2[1] &  cpxthr_i2[0];
   assign ifc_ifd_milfill_sel_i2_l = ~milfthr_i2;

   // write request
   // assign ifq_fcl_wrreq_bf = ifc_inv_ifqadv_i2 ? next_wrreq_i2 : wrreq_f;
   // assign ifq_fcl_wrreq_bf = ~ifc_inv_ifqadv_i2 | next_wrreq_i2;
   assign ifq_fcl_wrreq_bf = wrreq_f & ~ifc_inv_ifqadv_i2 | next_wrreq_i2;
   
   dffr_s #(1) wrreq_ff(.din (ifq_fcl_wrreq_bf),
		                  .clk (clk),
		                  .q   (wrreq_f),
		                  .rst (ifq_reset),
		                  .se  (se), .si(), .so());

   // starvation check
   // if a write is not granted for 24 cycles, sound the alarm
   sparc_ifu_ctr5 starv_ctr(
			                      // Outputs
			                      .limit	(starv_alert),
			                      .so	(so),
			                      // Inputs
			                      .clk	(clk),
			                      .se	(se),
			                      .si	(si),
			                      .rst_ctr_l (rst_starv_ctr_l));
   assign rst_starv_ctr_l = ~ifq_reset & wrreq_f;

   // advance in i2 when a write ack is received or if not a fill
   // Can help timing of this signal by doing
   //  ifqadv_nxt = ~ifq_fcl_wrreq_bf | fcl_icd_index_sel_ifq_bf
   assign access_grant_l = ~fcl_ifq_grant_bf;
   bw_u1_nand2_2x UZsize_acc_n2(.z (ifqadvi2_nxt),
                                .a (ifq_fcl_wrreq_bf),
                                .b (access_grant_l));
   dff_s #(1) qadv_ff(.din (ifqadvi2_nxt),
                    .q   (ifqadv_i2_ff),
                    .clk (clk), .se(se), .si(), .so());
   assign ifc_inv_ifqadv_i2 = ifqadv_i2_ff;

   

   // advance in i1 when a write ack is received AND there are no
   // child threads to be taken care of
   assign ifqadv_i1 = (ifc_inv_ifqadv_i2 & ~next_milchld[2] & ~fwd_stall) | 
                        ifq_reset; 

//-----------------------------------
// Errors and Error Packet
//-----------------------------------   

   assign errpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b1100}) ? 1'b1 : 1'b0;
   assign errpkt_i2 = (cpxreq_i2 == 4'b1100) ? ifd_ifc_cpxvld_i2 : 1'b0;

   // Reported Errors are not logged in ERB
   assign ce_rep_i2 = ifd_ifc_cpxce_i2 & ~ifd_ifc_cpxue_i2 & errpkt_i2 &
	                    ifc_inv_ifqadv_i2;
   assign ue_rep_i2 = ifd_ifc_cpxue_i2 & errpkt_i2 & ifc_inv_ifqadv_i2;

   dff_s #(1) cerep_ff(.din (ce_rep_i2),
		                 .q   (ifq_erb_ce_rep),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(1) uerep_ff(.din (ue_rep_i2),
		                 .q   (ifq_erb_ue_rep),
		                 .clk (clk), .se(se), .si(), .so());

//   dff #(2) ertid_reg(.din (filltid_i2),
//		                  .q   (ifq_erb_l2err_tid),
//		                  .clk (clk), .se(se), .si(), .so());
   // send thread id one cycle earlier to help crit path
   assign ifq_erb_l2err_tid = filltid_i2;
   
   // Ifetch Errors are logged in ERB
   assign l2_ce_i2 = ifd_ifc_cpxce_i2 & ~ifd_ifc_cpxue_i2 & imissrtn_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;
   assign l2_ue_i2 = ifd_ifc_cpxue_i2 & imissrtn_i2 & ~ifd_ifc_iobpkt_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;
   assign io_ue_i2 = ifd_ifc_cpxue_i2 & imissrtn_i2 & ifd_ifc_iobpkt_i2 &
	                   ifc_inv_ifqadv_i2 & mil_uncan_i2;

   dff_s #(1) l2ce_ff(.din (l2_ce_i2),
		                .q   (ifq_erb_ifet_ce),
		                .clk (clk), .se(se), .si(), .so());
   dff_s #(1) l2ue_ff(.din (l2_ue_i2),
		                .q   (ifq_erb_l2_ue),
		                .clk (clk), .se(se), .si(), .so());
   dff_s #(1) ioue_ff(.din (io_ue_i2),
		                .q   (ifq_erb_io_ue),
		                .clk (clk), .se(se), .si(), .so());

   assign l2_miss_i2 = ifd_ifc_cpxms_i2 & imissrtn_i2 & ifc_inv_ifqadv_i2;
   dff_s #(1) l2ms_ff(.din (l2_miss_i2),
		                .q   (l2_miss_f),
		                .clk (clk), .se(se), .si(), .so());

   assign ifu_tlu_l2imiss = dfthr_f & {4{l2_miss_f}};
   
//--------------------------------------------
// Miss Request Control (IFU interface to PCX)
//--------------------------------------------

   // decode imiss thread
   assign thr_s1[0] = ~fcl_ifq_thr_s1[0] & ~fcl_ifq_thr_s1[1];
   assign thr_s1[1] =  fcl_ifq_thr_s1[0] & ~fcl_ifq_thr_s1[1];
   assign thr_s1[2] = ~fcl_ifq_thr_s1[0] & fcl_ifq_thr_s1[1];
   assign thr_s1[3] =  fcl_ifq_thr_s1[0] & fcl_ifq_thr_s1[1];

   // signal ic miss to thread MIL state machines
   assign icmiss_thr_s = {4{fcl_ifq_icmiss_s1 & ~block_fetch_s1}} & thr_s1 & 
	                       ~icmiss_thr_d;

//   dff #(4) icmsreg(.din  (icmiss_thr_s),
//		                .clk  (clk),
//		                .q    (icmiss_thr_d),
//		                .se   (se), .si(), .so());

   dff_s #(1) icmsd_ff(.din  (fcl_ifq_icmiss_s1),
		                 .clk  (clk),
		                 .q    (icmiss_d1),
		                 .se   (se), .si(), .so());

   assign icmiss_qual_d1 = icmiss_d1 & ~(thr_match_d1e1 & ifeterr_e1);

   // bug 5926
   assign n763 = ~ifd_ifc_newdestid_s[2];
   dff_s #(1) iosp_ff(.din (n763),
		                .q   (iosp_d1_l),
		                .clk (clk), .se(se), .si(), .so());
   
   assign icmiss_thr_d = {4{icmiss_d1 | erb_ifq_ifeterr_d1 & iosp_d1_l}} & thr_d1 |
                         {4{ifeterr_e1}} & thr_e1;
   
   dff_s #(4) thrdreg(.din  (thr_s1),
		                .clk  (clk),
		                .q    (thr_d1),
		                .se   (se), .si(), .so());

   dff_s #(4) threreg(.din  (thr_d1),
		                .clk  (clk),
		                .q    (thr_e1),
		                .se   (se), .si(), .so());

   dff_s #(1) erre_ff(.din (ifeterr_qual_d1),
                    .q   (ifeterr_e1),
                    .clk (clk), .se(se), .si(), .so());
   assign thr_match_d1e1 =  (thr_d1[0] & thr_e1[0] |
                             thr_d1[1] & thr_e1[1] |
                             thr_d1[2] & thr_e1[2] |
                             thr_d1[3] & thr_e1[3]);

//   assign ifeterr_qual_d1 = ~(thr_match_d1e1 & ifeterr_e1) & ~canthr_d1 & 
//                               erb_ifq_ifeterr_d1;
   assign ifeterr_qual_d1 = ~(thr_match_d1e1 & ifeterr_e1) & 
                               erb_ifq_ifeterr_d1 & iosp_d1_l;
     
   assign errthr_d1 = (thr_d1 & {4{ifeterr_qual_d1 & ~block_fetch_d1}});
   
   // If misses to same thread, (in successive cycles), ignore
   assign ifc_ifd_ldmil_sel_new = (thr_s1 & {4{fcl_ifq_rdreq_s1}} &
				                           ~errthr_d1 & ~mil_valid_s);

   // Check hit in MIL -- a thread cannot hit 
   //   1. its own MIL
   //   2. an MIL that is being filled
   //   3. if it is to an IOB line
   assign qualhit_or_io_s = ifd_ifc_milhit_s & comp_valid_s & 
	                          ~thr_s1 & 
                            ~fill_retn_thr_i2 & 
                            {4{~ifd_ifc_newdestid_s[2]}};

   assign any_qualhit_or_io_s = (qualhit_or_io_s[0] |
		                             qualhit_or_io_s[1] |
		                             qualhit_or_io_s[2] |
		                             qualhit_or_io_s[3]);
   
//   assign milhit_qual_s = ifd_ifc_milhit_s & comp_valid_s & 
//	                        ~thr_s1 & 
//                          ~fill_retn_thr_i2 & 
//                          {4{~ifd_ifc_newdestid_s[2]}};
   
//   assign any_milhit_qual_s = any_qualhit_or_io_s & ~ifd_ifc_newdestid_s[2];
   assign any_milhit_qual_s = any_qualhit_or_io_s;   
   
   // Generate Replacement Way
   // Make sure a req doesn't go out to a different way than 
   // what is pending
   assign milhit_vec_s = ifd_ifc_milhit_s & (mil_valid_s | errthr_d1);
   assign any_milhit_s = (|milhit_vec_s[3:0]);
   
//   assign mil_repway_s = (ifd_ifc_mil_repway_s[7:6] & {2{milhit_vec_s[3]}} | 
//                          ifd_ifc_mil_repway_s[5:4] & {2{milhit_vec_s[2]}} | 
//                          ifd_ifc_mil_repway_s[3:2] & {2{milhit_vec_s[1]}} | 
//                          ifd_ifc_mil_repway_s[1:0] & {2{milhit_vec_s[0]}});

//   assign ifc_ifd_repway_s = any_milhit_s ? mil_repway_s : rand_repway_s;
   assign ifc_ifd_repway_s = rand_repway_s;   

   // pick any way at random
   // reset with dbg_init as well
   sparc_ifu_lfsr5  lfsr(.out (rand_repway_s),
			                   .clk  (clk),
			                   .advance (fcl_ifq_icmiss_s1),
			                   .reset (rst_way_lfsr),
			                   .se (se),
			                   .si (si),
			                   .so (so));

   assign rst_way_lfsr = ifq_reset | lsu_ifu_direct_map_l1 | ~gdbginit_l;

   // check if miss req is valid in a given pipe stage
   assign canthr_s1 = (fcl_ifq_canthr[0] & thr_s1[0] |
                       fcl_ifq_canthr[1] & thr_s1[1] |
                       fcl_ifq_canthr[2] & thr_s1[2] |
                       fcl_ifq_canthr[3] & thr_s1[3]);
   assign canthr_d1 = (fcl_ifq_canthr[0] & thr_d1[0] |
                       fcl_ifq_canthr[1] & thr_d1[1] |
                       fcl_ifq_canthr[2] & thr_d1[2] |
                       fcl_ifq_canthr[3] & thr_d1[3]);
   
   // retry a fetch if the imiss occurs while it is being filled
//   assign block_fetch_s1 = any_milhit_s & 
//                           ~(any_qualhit_or_io_s | ifd_ifc_newdestid_s[2]) |
//                           dtu_ifq_kill_latest_d;
   assign block_fetch_s1 = any_milhit_s & ~ifd_ifc_newdestid_s[2] &
                           ~any_qualhit_or_io_s | 
                           dtu_ifq_kill_latest_d |
                           erb_ifq_itlberr_s1;

   dff_s #(1) bfd_ff(.din (block_fetch_s1),
                   .q   (block_fetch_d1),
                   .clk (clk), .se(se), .si(), .so());

   dff_s #(1) tlbe_ff(.din (erb_ifq_itlberr_s1),
                    .q   (itlberr_d1),
                    .clk (clk), .se(se), .si(), .so());
   
//   assign retry_rdy_s1 = block_fetch_s1 & fcl_ifq_icmiss_s1;
//   dff #(1) retrd_ff(.din (retry_rdy_s1),
//                     .q   (retry_rdy_d1),
//                     .clk (clk), .se(se), .si(), .so());
   
   assign retry_rdy_final_d1 = block_fetch_d1 & (icmiss_qual_d1 | 
                                                 ifeterr_qual_d1);
   dff_s #(1) retre_ff(.din (retry_rdy_final_d1),
                     .q   (retry_rdy_e1),
                     .clk (clk), .se(se), .si(), .so());

   assign all_retry_rdy_e1 = {4{retry_rdy_e1}} & thr_e1;
   dff_s #(4) retrm_reg(.din (all_retry_rdy_e1),
                      .q   (all_retry_rdy_m1),
                     .clk (clk), .se(se), .si(), .so());
   
   assign ifq_dtu_thrrdy = mil_thr_ready | all_retry_rdy_m1;

//   assign retry_fetch_s1 = block_fetch_s1 & fcl_ifq_icmiss_s1 & 
//                           ~canthr_s1;
   dff_s #(1) cans_ff(.din (canthr_s1),
                    .q   (canthr_s1_del1),
                    .clk (clk), .se(se), .si(), .so());

   assign ifq_fcl_flush_sonly_e = (block_fetch_d1 & 
                                   (icmiss_qual_d1 & ~canthr_s1_del1 |
                                    ifeterr_qual_d1) & 
                                   ~canthr_d1 & ~itlberr_d1);

   // Determine which thread's MIL was hit, if at all
   // first check if this really was an imiss
   assign icmiss_for_milchk = thr_s1 & ~icmiss_thr_d & ~errthr_d1;
   assign icmiss_qual_s = (|icmiss_for_milchk[3:0]) & fcl_ifq_icmiss_s1 & 
                          ~dtu_ifq_kill_latest_d & ~erb_ifq_itlberr_s1;

   // since multiple requests can be outstanding when an error is
   // encountered, need to prioritise the mil hits.
   // TBD: there must be a cleaner way to do this!
   assign qualhit_pe_s[0] = qualhit_or_io_s[0];
   assign qualhit_pe_s[1] = ~qualhit_or_io_s[0] & qualhit_or_io_s[1];
   assign qualhit_pe_s[2] = ~qualhit_or_io_s[0] & ~qualhit_or_io_s[1] &
                             qualhit_or_io_s[2];
   assign qualhit_pe_s[3] = ~qualhit_or_io_s[0] & ~qualhit_or_io_s[1] &
                            ~qualhit_or_io_s[2] & qualhit_or_io_s[3];
   
   // A thread cannot hit on an MIL to the IOB
   assign milhit_to_thr_s = qualhit_pe_s & {4{icmiss_qual_s & 
                                                 ~ifd_ifc_newdestid_s[2]}};

   // Make Request to PCX if miss in Icache and MIL
   // determine if we need to send req to L2
//   assign newpcxreq_s = icmiss_for_milchk & ~fcl_ifq_canthr;
//   assign newreq_valid = fcl_ifq_icmiss_s1 & ~dtu_ifq_kill_latest_d & 
//	                       (newpcxreq_s[0] | 
//			                    newpcxreq_s[1] | 
//			                    newpcxreq_s[2] | 
//			                    newpcxreq_s[3]) & 
//                           (~any_milhit_s | ifd_ifc_newdestid_s[2]);

   assign newreq_valid = icmiss_qual_s &
                          (~any_milhit_s | ifd_ifc_newdestid_s[2]);

   // check if there are any old requests outstanding, that are not
   // current in  the D stage. 
   assign pcxreq_qual_s = pcxreq_s & ~(dpcxthr_d & {4{req_valid_d}});
   
//   assign reqq_empty = ~(|pcxreq_qual_s[3:0]);
//   assign oldpcxreq_s = pcxreq_qual_s & rr_gnt & ~fcl_ifq_canthr;
//   assign oldreq_valid = (|oldpcxreq_s);
//   assign oldpcxreq_s = pcxreq_qual_s & rr_gnt;   
   assign oldreq_valid = (|pcxreq_qual_s);
	  
   // Send out PCX request in round robin order if there are other
   // reqests pending.  If the request queue is empty send this req
//   assign nextreq_valid_s = ~reqq_empty | newreq_valid;
   
   assign nextreq_valid_s = oldreq_valid | newreq_valid | req_pending_d;

   assign rnd_reset = ifq_reset | ~gdbginit_l;
   
   // round robin assignment to pcx
   sparc_ifu_rndrob  pcxrndrob(.req_vec   (pcxreq_qual_s),
			                         .grant_vec (rr_gnt),
			                         .advance   (req_accept_d),
			                         .rst_tri_enable (rst_tri_en),
			                         .clk       (clk),
			                         .reset     (rnd_reset),
			                         .se  (se),
			                         .si (si),
			                         .so ());

   // if req queue is empty forward the new request to pcx
   // if not store it in the MIL
   assign dpcxthr_s  = req_pending_d ? dpcxthr_d :
	                     ~oldreq_valid ? thr_s1    : 
	                                     rr_gnt;
   dff_s #(4) pcxthr_ff(.din (dpcxthr_s),
		                  .clk (clk),
		                  .q   (dpcxthr_d),
		                  .se  (se), .si(), .so());

   assign thrid_d[0] = dpcxthr_d[3] | dpcxthr_d[1];
   assign thrid_d[1] = dpcxthr_d[3] | dpcxthr_d[2];
   dff_s #(2) tide_reg(.din (thrid_d),
                     .q   (thrid_e),
                     .clk (clk), .se(se), .si(), .so());
   assign ifc_ifd_thrid_e = thrid_e;
   
   // Determine the destination to which the request is made:
   mux4ds #(3) dest_mux(.dout (old_destid_s),
		                    .in0  (ifd_ifc_destid0[2:0]),
		                    .in1  (ifd_ifc_destid1[2:0]),
		                    .in2  (ifd_ifc_destid2[2:0]),
		                    .in3  (ifd_ifc_destid3[2:0]),
		                    .sel0 (rr_gnt[0]),
		                    .sel1 (rr_gnt[1]),
		                    .sel2 (rr_gnt[2]),
		                    .sel3 (rr_gnt[3]));
   
//   mux2ds #(3) fdest_mux(.dout (destid_s),
//		                     .in0  (ifd_ifc_newdestid_s),
//		                     .in1  (old_destid_s),
//		                     .sel0 (~oldreq_valid),
//		                     .sel1 (oldreq_valid));

//   assign destid_s  = req_pending_d ? ifu_lsu_destid_d    :
//	                    ~oldreq_valid ? ifd_ifc_newdestid_s : 
//	                                    old_destid_s;
   assign ifu_lsu_destid_s = oldreq_valid ? old_destid_s :
                                            ifd_ifc_newdestid_s;

   // remove this
   assign destid_iob_s  = req_pending_d ? destid_iob_d :
                                          ifu_lsu_destid_s[2];
   dff_s #(1) destd_reg(.din (destid_iob_s),
		                  .q   (destid_iob_d),
		                  .clk (clk), .se(se), .si(), .so());

   // If this is going to any L2 bank, zero out the line address 
   // for Rams 
   assign ifc_ifd_pcxline_adj_d[4:2] = ifd_ifc_pcxline_d[4:2] & 
                                       {3{destid_iob_d}};
   
   // advace req 
   dffr_s #(1) pcxreqvd_ff(.din  (nextreq_valid_s),
		                     .clk  (clk),
		                     .rst  (ifq_reset),
		                     .q    (req_valid_d),
		                     .se   (se), .si(), .so());

   assign ifu_lsu_pcxreq_d = req_valid_d;

//   assign req_pending_d = req_valid_d & ~can_pcx_d & ~lsu_ifu_pcxpkt_ack_d;
   assign req_pending_d = req_valid_d & ~(lsu_ifu_pcxpkt_ack_d & ~errinv_d1);
   assign req_accept_d = req_valid_d & lsu_ifu_pcxpkt_ack_d;
//   assign rr_advance_d = req_accept_d & ~errinv_d1

   // Signal to FSM if pcx request has been accepted by LSU
   assign pcx_accept_d = dpcxthr_d & {4{req_accept_d}};
   // Alternate implementation with canthr delayed by a cycle
//   assign pcxreq_vbit_d = req_valid_d & ~can_pcx_d;
//   assign pcx_accept_d = dpcxthr_d & {4{req_accept_d}} & ~fcl_ifq_canthr;

   // check if there was an error to this thread
   assign err_vec_d1 = dpcxthr_d & (errthr_d1 | err_req);
   assign errinv_d1 = (|err_vec_d1[3:0]);

   dff_s #(1) errinv_ff(.din (errinv_d1),
		                  .q   (ifc_ifd_errinv_e),
		                  .clk (clk), .se(se), .si(), .so());
   
   assign pcxreq_vbit_d = req_valid_d;   
   dff_s #(1) pcxreqve_ff(.din  (pcxreq_vbit_d),  // same as ifu_lsu_pcxreq_d
		                    .clk  (clk),
		                    .q    (ifc_ifd_reqvalid_e),
		                    .se   (se), .si(), .so());

//   dff #(1) pcxreqpe_ff(.din  (req_pending_d),
//		                    .clk  (clk),
//		                    .q    (req_pending_e),
//		                    .se   (se), .si(), .so());

   // advance pcx request if there is no prev request pending
   // the data is deliberately held valid for one extra cycle.  this
   // is legacy stuff.  LSU guarantees that the data is picked up
   // minimum 1 cycle after request is made. 
//   assign ifc_ifd_nxtpcx_sel_new_d = ~req_pending_e;
//   assign ifc_ifd_nxtpcx_sel_new_d = 1'b1;   

   // Select which MIL request to send out to PCX
   assign ifc_ifd_milreq_sel_d_l[0] = ~dpcxthr_d[0] & ~rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[1] = ~dpcxthr_d[1] | rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[2] = ~dpcxthr_d[2] | rst_tri_en;
   assign ifc_ifd_milreq_sel_d_l[3] = ~dpcxthr_d[3] | rst_tri_en;


//-----------------------------
// Invalidate Controls
//----------------------------
   assign stpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0100}) ? 1'b1 : 1'b0;
   assign strmack_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0110}) ? 1'b1 : 1'b0;
   assign evpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0011}) ? 1'b1 : 1'b0;
   assign ldpkt_i1 = (ifd_ifc_cpxreq_i1 == {1'b1, 4'b0000}) ? 1'b1 : 1'b0;
   
   assign invalidate_i1 = (stpkt_i1 | strmack_i1 | evpkt_i1 | ldpkt_i1);
   assign ifu_lsu_inv_clear = ~(invalidate_i1 | inv_ifc_inv_pending);
//	 assign ifc_inv_wrreq_i2 = (imissrtn_i2 |
//                              asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                        mbist_icache_write);
   
//   assign wrt_en_wd0_i2 = inv_ifc_word0_inv_i2 & (stpkt_i2 | evpkt_i2) |
//                          ldinv_i2 & ~ifd_ifc_ldaddr5_i2 |
//		                      (imissrtn_i2 |
//                           asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                     mbist_icache_write) & 
//	                       ~ifd_ifc_missaddr5_i2;
//
//   assign wrt_en_wd1_i2 = inv_ifc_word1_inv_i2 & (stpkt_i2 | evpkt_i2) |
//			                      ldinv_i2 & ifd_ifc_ldaddr5_i2 |
//		                        (imissrtn_i2 |
//			                       asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 |
//			                       mbist_icache_write) & 
//	                        ifd_ifc_missaddr5_i2;
   
   // calculate the ICV write data
   assign icv_wbit_i2 = imissrtn_i2 & ifc_ifd_filladdr4_i2 |
	                   asireq_i2 & asi_ic_tag_i2 & ~asi_load_i2 & 
	                   cpxreq_i2[2];
   
   assign icv_wrdata_i2 = ifc_inv_ifqadv_i2 ? icv_wbit_i2 : icv_wrdata_f;
   
//   mux2ds #(2) icv_damux(.dout (icv_wrdata_i2),
//		                     .in0  (icv_wrdata_f),
//		                     .in1  (icv_wbit_i2),
//		                     .sel0 (~ifc_inv_ifqadv_i2),
//		                     .sel1 (ifc_inv_ifqadv_i2));

   dff_s #(1) icv_daff(.din  (icv_wrdata_i2),
		                 .q    (icv_wrdata_f),
		                 .clk  (clk),
		                 .se   (se), .si(), .so());
   assign ifq_icv_wrdata_bf = icv_wrdata_i2;


// Begin ECO7010
   dp_mux2es #(1) wayvld_mux (.dout (inq_wayvld_i1_nxt),        //done
			      .in0 (lsu_ifu_cpxpkt_wayvld_i1),
			      .in1 (inq_wayvld_i1),
			      .sel(inq_vld));

   dff_s #(1) wayvld_ff (.din (inq_wayvld_i1_nxt),             //done
                       .q   (inq_wayvld_i1),
                       .clk (clk), .se(se), .si(), .so());
   
   assign ldinv_i1 = ldpkt_i1 & inq_wayvld_i1;  //done

   dp_mux2es #(1) ldinv_i2_mux (.dout (ldinv_i2_nxt),  //done
			      .in0 (ldinv_i1),
			      .in1 (ldinv_i2),
			      .sel(ifc_ifd_ifqbyp_en_l));

   dff_s #(1) ldinv_i2_ff (.din (ldinv_i2_nxt),   //done
			 .q   (ldinv_i2),
			 .clk (clk), .se(se), .si(), .so());   

//End ECO7010

//------------------------------------------------
// Fwd Request to read/write Icache
//------------------------------------------------
   // is this a fwd req to the L1I?
   assign fwdreq_i2 = (cpxreq_i2 == 4'b1010) ? 
                        (ifd_ifc_fwd2ic_i2 & ifd_ifc_4bpkt_i2 &
                         ifd_ifc_cpxvld_i2) : 1'b0;

   // detect first cycle of fwdpkt and stall
   assign fwd_stall = fwdreq_i2 & ~fwdreq_i3;
   
   dff_s #(1) freq_ff(.din (fwd_stall),
                    .q   (fwdreq_i3),
                    .clk (clk), .se(se), .si(), .so());

   dff_s #(1) cpx3_ff(.din (ifd_ifc_cpxnc_i2),
                    .q   (cpxnc_i3),
                    .clk (clk), .se(se), .si(), .so());

   // NC bit is also R/W_bar bit
   assign fwdrd_i3 = fwdreq_i3 & cpxnc_i3;
   assign fwdwr_i3 = fwdreq_i3 & ~cpxnc_i3;

   // ack back to the LSU to send fwd reply
   assign ifu_lsu_fwd_wr_ack = fwdwr_i3;
   assign ifc_ifd_idx_sel_fwd_i2 = fwdreq_i2;

   // let errctl know a fwd packet is coming
   assign ifq_erb_fwdrd_bf = fwdrd_i3;
   
//----------------------------------
// INQ controls -- now ibuf controls
//----------------------------------

// INQ removed 2/13/02   

   // Is the pkt in the inq a pkt that affects the icache?
   assign ic_pkt_i1 = invalidate_i1 | imissrtn_i1 | errpkt_i1;
   
//   assign inq_vld_nxt = ~inq_vld & ifd_ifc_cpxvalid_i1 & 
//	                      (~ifqadv_i1 | asireq_i1) | 
//	                      inq_vld & ((~ifqadv_i1 | asireq_i1) & ic_pkt_i1 |
//				                             ifd_ifc_cpxvalid_i1);

   // cut this down to 1 aoi gate
   assign inq_vld_nxt = (ifd_ifc_cpxvalid_i1 |
                         inq_vld & ic_pkt_i1) & (~ifqadv_i1 | ifu_asireq_i1);
   
   dffr_s #(1) inqv_ff(.din (inq_vld_nxt),
		                 .q   (inq_vld),
		                 .rst (ifq_reset),
		                 .clk (clk), .se(se), .si(), .so());

   assign ifc_ifd_ifqbyp_en_l = ~(ifqadv_i1 | fwd_stall);
   
   assign ifc_ifd_ifqbyp_sel_fwd_l = ~(fwd_stall & ~ifq_reset);
   assign ifc_ifd_ifqbyp_sel_asi_l = ~(~fwd_stall & ~ifq_reset & 
                                       ifu_asireq_i1);
   assign ifc_ifd_ifqbyp_sel_inq_l = ~(~fwd_stall & ~ifq_reset & 
                                       ~ifu_asireq_i1 & inq_vld);
   assign ifc_ifd_ifqbyp_sel_lsu_l = ~(~fwd_stall & ~ifu_asireq_i1 & 
                                       ~inq_vld | ifq_reset);

   assign byp_sel_asi_l = ~(ifqadv_i1 & ifu_asireq_i1);
   
//   assign ifu_lsu_ibuf_busy = inq_vld & (~ifqadv_i1 | asireq_i1);
//   assign ifc_ifd_ld_inq_i1 = ~inq_vld | ifqadv_i1 & ~asireq_i1;

   assign ifu_lsu_ibuf_busy = inq_vld;
   assign ifc_ifd_ld_inq_i1 = ~inq_vld;

//-----------------------------------------
// ASI access controls
//-----------------------------------------

   // need this to help with timing
   // - asi_vld is asserted only if the asi transaction is to an IFU asi
   //   register AND that register is not in the IMMU.
   // - it is held valid until an ack is signalled .
   // - the ack is not signalled for atleast 2 cycles
   assign asi_vld_next = lsu_ifu_asi_vld & byp_sel_asi_l & 
	                       ~asireq_i2 & ~illva_i2;  // not when ack is sent
   
   dff_s #(1) asiv0_ff(.din (asi_vld_next),
		                .q   (asi_vld_i0),
		                .clk (clk), .se(se), .si(), .so());
   assign asi_vld_qual_i0 = asi_vld_i0 & ~asireq_i2 & ~illva_i2 &
                            byp_sel_asi_l & ~illva_i1 &
                            lsu_ifu_asi_vld;

   dff_s #(8) asi_reg(.din (lsu_ifu_asi_state[7:0]),
		                .q   (asi_state_i1),
		                .clk (clk), .se(se), .si(), .so());

   dff_s #(2) asi_tid_reg(.din (lsu_ifu_asi_thrid[1:0]),
		                    .q   (ifq_fcl_asi_tid_bf[1:0]),
		                    .clk (clk), .se(se), .si(), .so());

//   assign ifu_lsu_asi_ack = ~byp_sel_asi_l;
   // Decided to wait one more cycle before sending the ack.
   assign ifu_lsu_asi_ack = asireq_i2 | illva_i2;   
   
   // ifu ASIs
   // icache data = 0x66
   assign asi_ic_data_unchk_i1 = ~asi_state_i1[7] & 
	        asi_state_i1[6] & 
	        asi_state_i1[5] & 
	        ~asi_state_i1[4] & 
	        ~asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_ic_data_i1 = asi_ic_data_unchk_i1;
   
   // icache tags = 0x67
   // writing to tag also writes to vbits
   assign asi_ic_tag_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_ic_tag_i1 = asi_ic_tag_unchk_i1;

   // error enable 0x4B
   assign asi_erren_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_erren_i1 =  asi_erren_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];
   
   // error status 0x4C
   assign asi_errstat_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      ~asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_errstat_i1 = asi_errstat_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // error addr 0x4D
   assign asi_erraddr_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      asi_state_i1[3] & 
		      asi_state_i1[2] & 
		      ~asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_erraddr_i1 =  asi_erraddr_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // error inject 0x43
   assign asi_errinj_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      asi_state_i1[0];
   assign asi_errinj_i1 =  asi_errinj_unchk_i1 &
          ~ifd_ifc_asi_vachklo_i2 &
          ~ifd_ifc_asiaddr_i2[2];

   // imask 0x42, va=0x8
   assign asi_imask_unchk_i1 = ~asi_state_i1[7] & 
		      asi_state_i1[6] & 
		      ~asi_state_i1[5] & 
		      ~asi_state_i1[4] & 
		      ~asi_state_i1[3] & 
		      ~asi_state_i1[2] & 
		      asi_state_i1[1] & 
		      ~asi_state_i1[0];
   assign asi_imask_i1 = asi_imask_unchk_i1  &
          ~ifd_ifc_asi_vachklo_i2 &
          ifd_ifc_asiaddr_i2[2];  // this is actually va[3]

   // illegal va check
   assign illva_i0 = ((asi_erren_unchk_i1 |
                       asi_errstat_unchk_i1 |
                       asi_errinj_unchk_i1 |
                       asi_erraddr_unchk_i1) & (ifd_ifc_asi_vachklo_i2 |
                                                ifd_ifc_asiaddr_i2[2])) &
                       asi_vld_qual_i0;

   dff_s #(1) illvai1_ff(.din (illva_i0),
                       .q   (illva_i1),
                       .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvabf_ff(.din (illva_i1),
                     .q   (illva_i2),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvaf_ff(.din (illva_i2),
                     .q   (illva_f),
                     .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvas_ff(.din (illva_f),
                      .q   (illva_s),
                      .clk (clk), .se(se), .si(), .so());
   dff_s #(1) illvaw2_ff(.din (illva_s),
                       .q   (illva_w2),
                       .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_illgl_va_w2 = illva_w2;

   dff_s #(1) tagasi_ff(.din (asi_ic_tag_i1),
		                  .q   (asi_ic_tag_i2),
		                  .clk (clk), .se(se), .si(), .so());
   dff_s #(1) datasi_ff(.din (asi_ic_data_i1),
		                  .q   (asi_ic_data_i2),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asieeni2_ff(.din (asi_erren_i1),
		                    .q   (ifq_erb_asi_erren_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asieini2_ff(.din (asi_errinj_i1),
		                    .q   (ifq_erb_asi_errinj_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asiesti2_ff(.din (asi_errstat_i1),
		                    .q   (ifq_erb_asi_errstat_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) asieadi2_ff(.din (asi_erraddr_i1),
		                    .q   (ifq_erb_asi_erraddr_i2),
		                    .clk (clk), .se(se), .si(), .so());
   dff_s #(1) imaski2_ff(.din (asi_imask_i1),
		                   .q   (ifq_erb_asi_imask_i2),
		                   .clk (clk), .se(se), .si(), .so());

   // All IFU asi requests
   assign ifu_asireq_i0 = (asi_ic_tag_i1 | asi_ic_data_i1 | asi_erren_i1 |
		                       asi_errinj_i1 | asi_errstat_i1 | asi_erraddr_i1 |
		                       asi_imask_i1) & asi_vld_qual_i0;

   dff_s #(1) asireq1_ff(.din  (ifu_asireq_i0),
		                   .q    (ifu_asireq_i1),
		                   .clk  (clk), .se(se), .si(), .so());
   
   dff_s #(1) asivld_ff(.din  (byp_sel_asi_l),
		                  .q    (asireq_i2_l),
		                  .clk  (clk), .se(se), .si(), .so());
   assign asireq_i2 = ~asireq_i2_l;
   assign ifc_inv_asireq_i2 = asireq_i2;

   // Stall if we are doing an asi op or fwdreq
  assign stallreq_d0 = (ifu_asireq_i0 | 
                         ~byp_sel_asi_l |
                         fwdreq_i2) | 
                          starv_alert | 
                          mbist_ifq_run_bist |
	                  ldinv_i1 & ~ifqadv_i1 |        //ECO 7010
                  	  ldinv_i2 & ~ifc_inv_ifqadv_i2; //ECO 7010

   dff_s #(1) stal_ff(.din (stallreq_d0),
                    .q   (stallreq_d1),
                    .clk (clk), .se(se), .si(), .so());

   // split into two to save repeater
   assign ifq_fcl_stallreq = stallreq_d1;
   assign ifq_swl_stallreq = stallreq_d1;

   dff_s #(1) asil1_ff(.din (lsu_ifu_asi_load),
		                 .q   (asi_load_i1),
		                 .clk (clk), .se(se), .si(), .so());

   dff_s #(1) asil2_ff(.din (asi_load_i1),
		                 .q   (asi_load_i2),
		                 .clk (clk), .se(se), .si(), .so());

   // insert parity error in data and/or tag
   // Don't need to qualify with asireq and imissrtn...
   //   -- moved this to the DP since the qual is not necessary
//   assign ifc_ifd_insert_pe = (asireq_i2 | imissrtn_i2) & 
//				ifd_ifc_cpxue_i2;

   // decode asi
   // generate word selects
   // can use finst instead of word_sel_i2, but it screws up timing
   
   assign word_sel_i2[0] = ~ifd_ifc_asiaddr_i2[3] & ~ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[1] = ~ifd_ifc_asiaddr_i2[3] &  ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[2] =  ifd_ifc_asiaddr_i2[3] & ~ifd_ifc_asiaddr_i2[2];
   assign word_sel_i2[3] =  ifd_ifc_asiaddr_i2[3] &  ifd_ifc_asiaddr_i2[2];

   // this assumes asi requests are never stalled
   assign ifq_icd_worden_bf = (word_sel_i2 | {4{~asireq_i2 & ~fwdwr_i3  |
//                                                ~ifc_inv_ifqadv_i2 | 
                                                mbist_icache_write}});
// & (mbist_icache_worden | {4{~bist_op}});

   // choose where the ic address should come from
//   assign bist_op = (mbist_icache_read | mbist_icache_write);
   dff_s #(1) bist_run_ff(.din (mbist_ifq_run_bist),
                        .q   (bist_op),
                        .clk (clk), .se(se), .si(), .so());
   
   assign ifc_ifd_addr_sel_bist_i2_l = ~bist_op | sehold;
   assign ifc_ifd_addr_sel_old_i2_l = (bist_op | ifc_inv_ifqadv_i2) & ~sehold;
   assign ifc_ifd_addr_sel_asi_i2_l = bist_op | ~ifc_inv_ifqadv_i2 | 
                                      sehold | ~(asireq_i2 | fwdreq_i3);
   assign ifc_ifd_addr_sel_fill_i2_l = bist_op | ~ifc_inv_ifqadv_i2 | 
                                       sehold | asireq_i2 | fwdreq_i3;

   // choose where the data should come from
   assign ifq_icd_data_sel_bist_i2 = mbist_icache_write & ~sehold;
   assign ifq_icd_data_sel_fill_i2 = ~mbist_icache_write & ifc_inv_ifqadv_i2 &
                                     ~sehold;
   assign ifq_icd_data_sel_old_i2 = ~mbist_icache_write & ~ifc_inv_ifqadv_i2 |
                                     sehold;
   
   // generate icache controls
   assign ifq_fcl_rdreq_bf = asireq_i2 & asi_load_i2 & 
	                           (asi_ic_data_i2 | asi_ic_tag_i2) |
	                           mbist_icache_read |
                             fwdrd_i3;

   assign ifq_fcl_icd_wrreq_bf = asi_ic_data_i2 & asireq_i2 & ~asi_load_i2 |
	                               mbist_icache_write |
                                 fwdwr_i3;

   assign ifq_fcl_ictv_wrreq_bf = asi_ic_tag_i2 & asireq_i2 & ~asi_load_i2;

   assign rd_tag_bf = asi_ic_tag_i2 & asi_load_i2;
   dff_s #(1) asi_srcf_ff(.din (rd_tag_bf),
		               .q   (ifq_erb_rdtag_f),
		               .clk (clk), .se(se), .si(), .so());
   
   assign rdinst_bf = asi_ic_data_i2 & asi_load_i2;
   dff_s #(1) asi_inst_ff(.din (rdinst_bf),
		               .q   (ifq_erb_rdinst_f),
		               .clk (clk), .se(se), .si(), .so());

   assign asird_i1 = asi_load_i1 & (~byp_sel_asi_l | illva_i1);
   dff_s #(1) asirdq_ff(.din (asird_i1),
                      .q   (ifq_fcl_asird_bf),
                      .clk (clk), .se(se), .si(), .so());

   assign ifq_erb_asiwr_i2 = ~asi_load_i2 & asireq_i2;



   // Shadow scan mux
   mux4ds #(4) milss_mux(.dout (ifq_sscan_data[3:0]),
                         .in0  (mil0_state),
                         .in1  (mil1_state),
                         .in2  (mil2_state),
                         .in3  (mil3_state),
                         .sel0 (ctu_sscan_tid[0]),
                         .sel1 (ctu_sscan_tid[1]),
                         .sel2 (ctu_sscan_tid[2]),
                         .sel3 (ctu_sscan_tid[3]));
   

   
endmodule // sparc_ifu_ifqctl

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_ifqdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqdp
//  Description:
//  The IFQ is the icache fill queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.
//
*/

//FPGA_SYN enables all FPGA related modifications





////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module sparc_ifu_ifqdp(/*AUTOARG*/
   // Outputs
   
   ifu_lsu_pcxcsm_e,
   

   so, ifu_lsu_pcxpkt_e, ifq_fdp_fill_inst, ifq_erb_asidata_i2,
   ifd_inv_ifqop_i2, ifq_icd_index_bf, ifq_icd_wrdata_i2,
   ifq_ict_wrtag_f, ifq_ict_wrtag_bf, ifq_erb_wrindex_f, ifq_icd_wrway_bf,
   ifd_ifc_milhit_s, ifd_ifc_instoffset0, ifd_ifc_instoffset1,
   ifd_ifc_instoffset2, ifd_ifc_instoffset3, ifd_ifc_cpxthr_nxt,
   ifd_ifc_cpxreq_nxt, ifd_ifc_cpxreq_i1, ifd_ifc_destid0,
   ifd_ifc_destid1, ifd_ifc_destid2, ifd_ifc_destid3,
   ifd_ifc_newdestid_s, ifd_ifc_pcxline_d, ifd_ifc_asi_vachklo_i2,
   ifd_ifc_cpxvld_i2, ifd_ifc_asiaddr_i2, ifd_ifc_iobpkt_i2,
   ifd_ifc_fwd2ic_i2, ifd_ifc_4bpkt_i2, ifd_ifc_cpxnc_i2,
   ifd_ifc_cpxce_i2, ifd_ifc_cpxue_i2, ifd_ifc_cpxms_i2,
   ifd_ifc_miladdr4_i2, ifd_inv_wrway_i2, ifq_fdp_fill_paddr,
   // Inputs
   
   itlb_ifq_csm_s,
   

   rclk, se, si, lsu_ifu_cpxpkt_i1, lsu_ifu_asi_addr,
   lsu_ifu_stxa_data, itlb_ifq_paddr_s, fdp_ifq_paddr_f,
   ifc_ifd_reqvalid_e, ifc_ifd_filladdr4_i2, ifc_ifd_repway_s,
   ifc_ifd_uncached_e, ifc_ifd_thrid_e, ifc_ifd_pcxline_adj_d,
   ifc_ifd_errinv_e, ifc_ifd_ldmil_sel_new, ifc_ifd_ld_inq_i1,
   ifc_ifd_idx_sel_fwd_i2, ifc_ifd_milreq_sel_d_l,
   ifc_ifd_milfill_sel_i2_l, ifc_ifd_finst_sel_l,
   ifc_ifd_ifqbyp_sel_fwd_l, ifc_ifd_ifqbyp_sel_inq_l,
   ifc_ifd_ifqbyp_sel_asi_l, ifc_ifd_ifqbyp_sel_lsu_l,
   ifc_ifd_ifqbyp_en_l, ifc_ifd_addr_sel_bist_i2_l,
   ifc_ifd_addr_sel_asi_i2_l, ifc_ifd_addr_sel_old_i2_l,
   ifc_ifd_addr_sel_fill_i2_l, mbist_icache_way, mbist_icache_word,
   mbist_icache_index
   );

   input 	 rclk,
           se,
           si;

   input [145-1:0] lsu_ifu_cpxpkt_i1;
   input [17:0]   lsu_ifu_asi_addr;
   input [47:0]   lsu_ifu_stxa_data;

   input [39:10]  itlb_ifq_paddr_s;
   input [9:2]    fdp_ifq_paddr_f;

   // from ifqctl
   input         ifc_ifd_reqvalid_e;
   input         ifc_ifd_filladdr4_i2;
   input [1:0]   ifc_ifd_repway_s;
   input         ifc_ifd_uncached_e;
   input [1:0]   ifc_ifd_thrid_e;
   input [4:2]   ifc_ifd_pcxline_adj_d;

   input         ifc_ifd_errinv_e;

   // 2:1 mux selects
   input [3:0]   ifc_ifd_ldmil_sel_new;  // mil load enable

   input        ifc_ifd_ld_inq_i1;        // ld new cpxreq to in buffer
   input        ifc_ifd_idx_sel_fwd_i2;

   // other mux selects
   input [3:0]  ifc_ifd_milreq_sel_d_l,   // selects outgoing mil_req
		            ifc_ifd_milfill_sel_i2_l; // selects the mil entry just
	 // returned from the fill
	 // port
   input [3:0]  ifc_ifd_finst_sel_l;    // address to load to thr IR

   input        ifc_ifd_ifqbyp_sel_fwd_l, // select next input to process
		            ifc_ifd_ifqbyp_sel_inq_l,
		            ifc_ifd_ifqbyp_sel_asi_l,
		            ifc_ifd_ifqbyp_sel_lsu_l;
	 input        ifc_ifd_ifqbyp_en_l;

   input        ifc_ifd_addr_sel_bist_i2_l,
		            ifc_ifd_addr_sel_asi_i2_l,
                ifc_ifd_addr_sel_old_i2_l,
		            ifc_ifd_addr_sel_fill_i2_l;

   input [1:0]  mbist_icache_way;
   input        mbist_icache_word;
   input [7:0]  mbist_icache_index;
   
   input [32:0]    itlb_ifq_csm_s;

   output [32:0]   ifu_lsu_pcxcsm_e;
   

   output       so;

   output [51:0] ifu_lsu_pcxpkt_e;

   output [32:0] ifq_fdp_fill_inst;
   output [47:0] ifq_erb_asidata_i2;

   output [145-1:0] ifd_inv_ifqop_i2;

   output [(6 + 5):2]  ifq_icd_index_bf;   // index for wr and bist

   output [135:0]         ifq_icd_wrdata_i2;
   output [(39 - (6 + 5)):0]  ifq_ict_wrtag_f;      // fill tag
   output [(39 - (6 + 5)):0]  ifq_ict_wrtag_bf;      // fill tag
//   output [`IC_TAG_SZ-1:0] ifq_erb_wrtag_f;      // tag w/o parity
   output [(6 + 5):4]   ifq_erb_wrindex_f;
   output [1:0]            ifq_icd_wrway_bf;     // fill data way

   output [3:0]           ifd_ifc_milhit_s;     // if an Imiss hits in MIL
//   output [7:0]           ifd_ifc_mil_repway_s;

   output [1:0]           ifd_ifc_instoffset0;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset1;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset2;   // to select inst to TIR
   output [1:0]           ifd_ifc_instoffset3;   // to select inst to TIR

   output [1:0]            ifd_ifc_cpxthr_nxt;
   output [3:0]            ifd_ifc_cpxreq_nxt;    // cpx reqtype + vbit
   output [(143 - 140 + 1):0] ifd_ifc_cpxreq_i1;    // cpx reqtype + vbit


   output [2:0]            ifd_ifc_destid0,
		                       ifd_ifc_destid1,
		                       ifd_ifc_destid2,
		                       ifd_ifc_destid3,
		                       ifd_ifc_newdestid_s;

   output [4:2]            ifd_ifc_pcxline_d;

   output                  ifd_ifc_asi_vachklo_i2;

   output                  ifd_ifc_cpxvld_i2;
   output [3:2]            ifd_ifc_asiaddr_i2;
   output                  ifd_ifc_iobpkt_i2;
   output                  ifd_ifc_fwd2ic_i2;
   output                  ifd_ifc_4bpkt_i2;
   output                  ifd_ifc_cpxnc_i2;
   output                  ifd_ifc_cpxce_i2,
		                       ifd_ifc_cpxue_i2,
                           ifd_ifc_cpxms_i2;

   output [3:0]            ifd_ifc_miladdr4_i2;

   output [1:0]            ifd_inv_wrway_i2;

   output [39:2]           ifq_fdp_fill_paddr;

   //----------------------------------------------------------------------
   // Declarations
   //----------------------------------------------------------------------

   // local signals
   wire [39:0]             imiss_paddr_s;
   wire [9:2]              lcl_paddr_s;

   wire [42:2]             mil_entry0,         // mil entries
		                       mil_entry1,
		                       mil_entry2,
		                       mil_entry3;


   
   wire [32:0]          mil_csm_entry0;
   wire [32:0]          mil_csm_entry1;
   wire [32:0]          mil_csm_entry2;
   wire [32:0]          mil_csm_entry3;
   
    wire [32:0]          mil_csm_pcxreq_d;

   
//   wire [42:2]             mil0_in_s,          // inputs to mil
//		                       mil1_in_s,
//		                       mil2_in_s,
//		                       mil3_in_s;

   wire                    tag_par_s,
		                       tag_par_i2;

   wire [42:2]             newmil_entry_s;

   wire [42:2]             mil_pcxreq_d,        // outgoing request from mil
		                       pcxreq_d,            // mil or direct ic or prev req
		                       pcxreq_e;          // outgoing request to lsu

   wire [42:2]             fill_addr_i2,
		                       fill_addr_adj,
		                       icaddr_i2,
		                       asi_addr_i2,
		                       bist_addr_i2;

   wire [42:4]             wraddr_f;


   wire [145-1:0]   inq_cpxpkt_i1,   // output from inq
//			                     inq_cpxpkt_nxt,
			                     stxa_data_pkt,
                           fwd_data_pkt,
			                     ifqop_i1,
			                     ifqop_i2;        // ifq op currently being processed

   wire [3:0]              swc_i2;

   wire [135:0]            icdata_i2;

   wire [3:0]              parity_i2,
		                       par_i2;

   wire [17:0]             asi_va_i2,
                           asi_va_i1;
   wire [13:2]             asi_fwd_index;
   wire                    clk;


//   wire [`IC_IDX_HI:6]     inv_addr_i2;

   //
   // Code start here
   //

   assign                  clk = rclk;

   //----------------------------------------------------------------------
   // Instruction Miss - Fill Request Datapath
   //----------------------------------------------------------------------

   // new set of flops
   dff_s #(8) pcs_reg(.din (fdp_ifq_paddr_f[9:2]),
                    .q   (lcl_paddr_s[9:2]),
                    .clk (clk), .se(se), .si(), .so());


   // bits 1:0 are floating
   assign  imiss_paddr_s = {itlb_ifq_paddr_s[39:10],
                            lcl_paddr_s[9:2],
                            2'b0};

   // Check for hit in MIL
   // Should we enable the comps to save power? -- timing problem

   // compare only top 35 bits (bot 5 bits are line offset of 32B line)
   sparc_ifu_cmp35 milcmp0 (.hit (ifd_ifc_milhit_s[0]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry0[39:5]),
			                      .valid (1'b1)
			                      );

   sparc_ifu_cmp35 milcmp1 (.hit (ifd_ifc_milhit_s[1]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry1[39:5]),
			                      .valid (1'b1)
			                      );

   sparc_ifu_cmp35 milcmp2 (.hit (ifd_ifc_milhit_s[2]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry2[39:5]),
			                      .valid (1'b1)
			                      );
   sparc_ifu_cmp35 milcmp3 (.hit (ifd_ifc_milhit_s[3]),
			                      .a (imiss_paddr_s[39:5]),
			                      .b (mil_entry3[39:5]),
			                      .valid (1'b1)
			                      );

   // Send replacement way to ctl logic
//   assign  ifd_ifc_mil_repway_s =  {mil_entry3[41:40],
//	                                  mil_entry2[41:40],
//	                                  mil_entry1[41:40],
//	                                  mil_entry0[41:40]};


   // calculate tag parity
   sparc_ifu_par32 tag_par(.in  ({{(32 - (39 - (6 + 5))){1'b0}},
                                  imiss_paddr_s[39:((6 + 5) + 1)]}),
			                     .out (tag_par_s));


   // Missed Instruction List
   // 43    - NOT cacheable
   // 42    - tag parity
   // 41:40 - repl way
   // 39:0  - paddr

   // Prepare Missed Instruction List entry
   assign  newmil_entry_s = {tag_par_s,
			                       ifc_ifd_repway_s,
			                       imiss_paddr_s[39:2]};

   // ldmil_sel is thr_s[3:0] & imiss_s
//   dp_mux2es  #(41)    milin_mux0(.dout (mil0_in_s),
//				                          .in0  (mil_entry0),
//				                          .in1  (newmil_entry_s),
//				                          .sel  (ifc_ifd_ldmil_sel_new[0]));
//   dp_mux2es  #(41)    milin_mux1(.dout (mil1_in_s),
//				                        .in0  (mil_entry1),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[1]));
//   dp_mux2es  #(41)    milin_mux2(.dout (mil2_in_s),
//				                        .in0  (mil_entry2),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[2]));
//   dp_mux2es  #(41)    milin_mux3(.dout (mil3_in_s),
//				                        .in0  (mil_entry3),
//				                        .in1  (newmil_entry_s),
//				                        .sel  (ifc_ifd_ldmil_sel_new[3]));

   wire    clk_mil0;


   bw_u1_ckenbuf_6x  ckenmil0(.rclk (rclk),
                              .clk  (clk_mil0),
                              .en_l (~ifc_ifd_ldmil_sel_new[0]),
                              .tm_l (~se));

   wire    clk_mil1;


   bw_u1_ckenbuf_6x  ckenmil1(.rclk (rclk),
                              .clk  (clk_mil1),
                              .en_l (~ifc_ifd_ldmil_sel_new[1]),
                              .tm_l (~se));

   wire    clk_mil2;


   bw_u1_ckenbuf_6x  ckenmil2(.rclk (rclk),
                              .clk  (clk_mil2),
                              .en_l (~ifc_ifd_ldmil_sel_new[2]),
                              .tm_l (~se));

   wire    clk_mil3;


   bw_u1_ckenbuf_6x  ckenmil3(.rclk (rclk),
                              .clk  (clk_mil3),
                              .en_l (~ifc_ifd_ldmil_sel_new[3]),
                              .tm_l (~se));









   dff_s #(41)   mil0(.din  (newmil_entry_s),
		                .clk  (clk_mil0),
		                .q    (mil_entry0),
		                .se   (se), .si(), .so());








   dff_s #(41)   mil1(.din (newmil_entry_s),
		                .clk (clk_mil1),
		                .q   (mil_entry1),
		                .se  (se), .si(), .so());








   dff_s #(41)   mil2(.din (newmil_entry_s),
		                .clk (clk_mil2),
		                .q   (mil_entry2),
		                .se  (se), .si(), .so());








   dff_s #(41)   mil3(.din (newmil_entry_s),
		                .clk (clk_mil3),
		                .q   (mil_entry3),
		                .se  (se), .si(), .so());











   dff_s #(33)   milcsm0(.din  (itlb_ifq_csm_s),
		                .clk  (clk_mil0),
		                .q    (mil_csm_entry0),
		                .se   (se), .si(), .so());








   dff_s #(33)   milcsm1(.din (itlb_ifq_csm_s),
		                .clk (clk_mil1),
		                .q   (mil_csm_entry1),
		                .se  (se), .si(), .so());








   dff_s #(33)   milcsm2(.din (itlb_ifq_csm_s),
		                .clk (clk_mil2),
		                .q   (mil_csm_entry2),
		                .se  (se), .si(), .so());








   dff_s #(33)   milcsm3(.din (itlb_ifq_csm_s),
		                .clk (clk_mil3),
		                .q   (mil_csm_entry3),
		                .se  (se), .si(), .so());





   assign  ifd_ifc_newdestid_s = {imiss_paddr_s[39],
				                          imiss_paddr_s[7:6]};
   assign  ifd_ifc_destid0 = {mil_entry0[39],
			                        mil_entry0[7:6]};
   assign  ifd_ifc_destid1 = {mil_entry1[39],
			                        mil_entry1[7:6]};
   assign  ifd_ifc_destid2 = {mil_entry2[39],
			                        mil_entry2[7:6]};
   assign  ifd_ifc_destid3 = {mil_entry3[39],
			                        mil_entry3[7:6]};

   assign  ifd_ifc_instoffset0 = mil_entry0[3:2];
   assign  ifd_ifc_instoffset1 = mil_entry1[3:2];
   assign  ifd_ifc_instoffset2 = mil_entry2[3:2];
   assign  ifd_ifc_instoffset3 = mil_entry3[3:2];


   // MIL Request Out mux
   dp_mux4ds  #(41)  milreq_mux (.dout (mil_pcxreq_d),
			                         .in0  ({mil_entry0[42:2]}),
			                         .in1  ({mil_entry1[42:2]}),
			                         .in2  ({mil_entry2[42:2]}),
			                         .in3  ({mil_entry3[42:2]}),
			                         .sel0_l  (ifc_ifd_milreq_sel_d_l[0]),
			                         .sel1_l  (ifc_ifd_milreq_sel_d_l[1]),
			                         .sel2_l  (ifc_ifd_milreq_sel_d_l[2]),
			                         .sel3_l  (ifc_ifd_milreq_sel_d_l[3]));


   dp_mux4ds  #(33)  milreq_csm_mux (.dout (mil_csm_pcxreq_d),
			                         .in0  ({mil_csm_entry0[32:0]}),
			                         .in1  ({mil_csm_entry1[32:0]}),
			                         .in2  ({mil_csm_entry2[32:0]}),
			                         .in3  ({mil_csm_entry3[32:0]}),
			                         .sel0_l  (ifc_ifd_milreq_sel_d_l[0]),
			                         .sel1_l  (ifc_ifd_milreq_sel_d_l[1]),
			                         .sel2_l  (ifc_ifd_milreq_sel_d_l[2]),
			                         .sel3_l  (ifc_ifd_milreq_sel_d_l[3]));




   // Next PCX Request Mux
//   dp_mux3ds  #(44)  nxtpcx_mux (.dout  (pcxreq_d),
//			                         .in0   (mil_pcxreq_d),
//			                         .in1   (44'bx),
//			                         .in2   (pcxreq_e),
//			                         .sel0_l  (ifc_ifd_nxtpcx_sel_new_d_l),
//			                         .sel1_l  (ifc_ifd_nxtpcx_sel_err_d_l),
//			                         .sel2_l  (ifc_ifd_nxtpcx_sel_prev_d_l));


   // TBD: If destid == any L2 bank, need to zero out bit 4 for Rams
   //    -- done
   assign  ifd_ifc_pcxline_d[4:2] = mil_pcxreq_d[4:2];

   assign  pcxreq_d[42:5] = mil_pcxreq_d[42:5];
   assign  pcxreq_d[4:2] = ifc_ifd_pcxline_adj_d[4:2];
//   assign  pcxreq_d[1:0] = mil_pcxreq_d[1:0];  // dont need this

   dff_s #(41) pcxreq_reg (.din  (pcxreq_d),
			                    .clk  (clk),
			                    .q    (pcxreq_e),
			                    .se   (se), .si(), .so());

// CHANGE to regular dff
//   dffe #(44) pcxreq_reg (.din  (pcxreq_d),
//			                    .clk  (clk),
//			                    .q    (pcxreq_e),
//                          .en   (ifc_ifd_nxtpcx_sel_new_d),
//			                    .se   (se), .si(), .so());

   // PCX Req Reg -- req type is 5 bits
   assign   ifu_lsu_pcxpkt_e = {ifc_ifd_reqvalid_e,   // 51    - valid
			                          ifc_ifd_errinv_e,     // 50 - inv all ways
                                ifc_ifd_uncached_e,   // 49 - not cacheable
			                          {5'b10000},          // 48:44 - req type
			                          pcxreq_e[41:40],      // 43:42 - rep way
			                          ifc_ifd_thrid_e[1:0], // 41:40 - thrid
			                          pcxreq_e[39:2],       // 39:2  - word address
			                          2'b0};                // force to zero




dff_s #(33) pcxreq_csm2_reg (.din  (mil_csm_pcxreq_d),
                                         .clk  (clk),
                                         .q    (ifu_lsu_pcxcsm_e),
                                         .se   (se), .si(), .so());




   //----------------------------------------------------------------------
   // Fill Return Address
   //----------------------------------------------------------------------

   // MIL Fill Return Mux
   dp_mux4ds  #(41)  milfill_mux(.dout (fill_addr_i2),
			                         .in0 ( mil_entry0),
			                         .in1 ( mil_entry1),
			                         .in2 ( mil_entry2),
			                         .in3 ( mil_entry3),
			                         .sel0_l (ifc_ifd_milfill_sel_i2_l[0]),
			                         .sel1_l (ifc_ifd_milfill_sel_i2_l[1]),
			                         .sel2_l (ifc_ifd_milfill_sel_i2_l[2]),
			                         .sel3_l (ifc_ifd_milfill_sel_i2_l[3]));

   assign   ifd_ifc_miladdr4_i2[3:0]  = {mil_entry3[4],
                                         mil_entry2[4],
                                         mil_entry1[4],
                                         mil_entry0[4]};

   assign   ifd_ifc_iobpkt_i2 = fill_addr_i2[39];
   assign   fill_addr_adj = {fill_addr_i2[42:5],
			                       ifc_ifd_filladdr4_i2,
			                       fill_addr_i2[3:2]};
   // determine if this is cacheable in I$
   // moved to ifqctl
//   assign   ifd_ifc_uncached_i2 = fill_addr_i2[43];

   // merged with addren mux to save some timing
   dp_mux4ds #(41) icadr_mux(.dout (icaddr_i2),
			                       .in0  (fill_addr_adj),
			                       .in1  (asi_addr_i2),
			                       .in2  (bist_addr_i2),
                             .in3  ({wraddr_f[42:4], 2'b0}),
			                       .sel0_l (ifc_ifd_addr_sel_fill_i2_l),
			                       .sel1_l (ifc_ifd_addr_sel_asi_i2_l),
			                       .sel2_l (ifc_ifd_addr_sel_bist_i2_l),
                             .sel3_l (ifc_ifd_addr_sel_old_i2_l));

   // Paddr for fetch datapath
   assign ifq_fdp_fill_paddr = icaddr_i2[39:2];

   // way, 32B line sel
   assign ifd_inv_wrway_i2 =  icaddr_i2[41:40];

//   dp_mux2es  #(39)  addren_mux(.dout (wraddr_i2),
//			                        .in0  (wraddr_f),
//			                        .in1  (icaddr_i2[42:4]),
//			                        .sel  (ifc_ifd_ifqadv_i2));


   dff_s #(39) wraddr_reg(.din  (icaddr_i2[42:4]),
		                    .clk  (clk),
		                    .q    (wraddr_f[42:4]),
		                    .se   (se), .si(), .so());

   // tag = parity bit + `IC_TAG_SZ bits of address
   assign  ifq_erb_wrindex_f = wraddr_f[(6 + 5):4];
   assign  ifq_ict_wrtag_f = {wraddr_f[42], wraddr_f[39:((6 + 5) + 1)]};
   assign  ifq_ict_wrtag_bf = {icaddr_i2[42], icaddr_i2[39:((6 + 5) + 1)]};

   assign  ifq_icd_index_bf = icaddr_i2[(6 + 5):2];
   assign  ifq_icd_wrway_bf = icaddr_i2[41:40];

   //----------------------------------------------------------------------
   // Fill Return Data
   //----------------------------------------------------------------------
   // IFQ-IBUF
   // inq is the same size as the cpx_width
   // inq is replaced with a single flop, ibuf

   // ibuf enable mux
//   dp_mux2es  #(`CPX_WIDTH)  ifqen_mux(.dout (inq_cpxpkt_nxt),
//				                             .in0 (inq_cpxpkt_i1),
//				                             .in1 (lsu_ifu_cpxpkt_i1),
//				                             .sel (ifc_ifd_ld_inq_i1));

   wire    clk_ibuf1;


   bw_u1_ckenbuf_6x  ckenibuf(.rclk (rclk),
                              .clk  (clk_ibuf1),
                              .en_l (~ifc_ifd_ld_inq_i1),
                              .tm_l (~se));








   dff_s #(145) ibuf(.din (lsu_ifu_cpxpkt_i1),
			                  .q   (inq_cpxpkt_i1),
			                  .clk (clk_ibuf1),
			                  .se  (se), .si(), .so());


   assign  ifd_ifc_cpxreq_i1 = {inq_cpxpkt_i1[144],
			                          inq_cpxpkt_i1[143:140]};

   // ifq operand bypass mux
   // fill pkt is 128d+2w+2t+3iw+1v+1nc+4r = 140
   dp_mux4ds  #(145)  ifq_bypmux(.dout (ifqop_i1),
				                              .in0 (fwd_data_pkt),
				                              .in1 (inq_cpxpkt_i1),
				                              .in2 (stxa_data_pkt),
				                              .in3 (lsu_ifu_cpxpkt_i1),
				                              .sel0_l (ifc_ifd_ifqbyp_sel_fwd_l),
				                              .sel1_l (ifc_ifd_ifqbyp_sel_inq_l),
				                              .sel2_l (ifc_ifd_ifqbyp_sel_asi_l),
				                              .sel3_l (ifc_ifd_ifqbyp_sel_lsu_l));

   wire    clk_ifqop;


   bw_u1_ckenbuf_6x  ckenifop(.rclk (rclk),
                              .clk  (clk_ifqop),
                              .en_l (ifc_ifd_ifqbyp_en_l),
                              .tm_l (~se));








   dff_s #(145)  ifqop_reg(.din (ifqop_i1),
			                        .q   (ifqop_i2),
			                        .clk (clk_ifqop),
			                        .se  (se), .si(), .so());

   assign  ifd_inv_ifqop_i2 = ifqop_i2;

   // switch condition pre decode
   sparc_ifu_swpla  swpla0(.in  (ifqop_i2[31:0]),
			                     .out (swc_i2[0]));
   sparc_ifu_swpla  swpla1(.in  (ifqop_i2[63:32]),
			                     .out (swc_i2[1]));
   sparc_ifu_swpla  swpla2(.in  (ifqop_i2[95:64]),
			                     .out (swc_i2[2]));
   sparc_ifu_swpla  swpla3(.in  (ifqop_i2[127:96]),
			                     .out (swc_i2[3]));

   // Add Parity to each inst.
   sparc_ifu_par32 par0(.in  (ifqop_i2[31:0]),
			                  .out (par_i2[0]));
   sparc_ifu_par32 par1(.in  (ifqop_i2[63:32]),
			                  .out (par_i2[1]));
   sparc_ifu_par32 par2(.in  (ifqop_i2[95:64]),
			                  .out (par_i2[2]));
   sparc_ifu_par32 par3(.in  (ifqop_i2[127:96]),
			                  .out (par_i2[3]));

   // add 8 xor gates in the dp
   //   assign parity_i2 = par_i2 ^ swc_i2 ^ {4{ifc_ifd_insert_pe}};
   //   assign tag_par_i2 = par_i2[0] ^ ifc_ifd_insert_pe;

   // Make the par32 cell above, par33 and include cpxue_i2
   assign   parity_i2 = par_i2 ^ swc_i2 ^ {4{ifd_ifc_cpxue_i2}};
   assign   tag_par_i2 = par_i2[0] ^ ifd_ifc_cpxue_i2;

   // parity, swc, inst[31:0]
   assign   icdata_i2 = {parity_i2[3], ifqop_i2[127:96], swc_i2[3],
		                     parity_i2[2], ifqop_i2[95:64],  swc_i2[2],
		                     parity_i2[1], ifqop_i2[63:32],  swc_i2[1],
		                     parity_i2[0], ifqop_i2[31:0],   swc_i2[0]};

   // write data to icache
   assign ifq_icd_wrdata_i2 = icdata_i2;


   // very critical
   assign ifd_ifc_cpxreq_nxt   = ifqop_i1[143:140];
   assign ifd_ifc_cpxthr_nxt   = ifqop_i1[135:134];

   assign ifd_ifc_cpxvld_i2   = ifqop_i2[144];
   assign ifd_ifc_4bpkt_i2    = ifqop_i2[130];
   assign ifd_ifc_cpxce_i2    = ifqop_i2[137];
   assign ifd_ifc_cpxue_i2    = ifqop_i2[(137 + 1)];
   assign ifd_ifc_cpxms_i2    = ifqop_i2[(137 + 2)];
   assign ifd_ifc_cpxnc_i2    = ifqop_i2[136];
   assign ifd_ifc_fwd2ic_i2   = ifqop_i2[103];

   // instr sel mux to write to thread inst regsiter in S stage
   // instr is always BIG ENDIAN
   dp_mux4ds  #(33)  fillinst_mux(.dout (ifq_fdp_fill_inst),
				                        .in0 (icdata_i2[134:102]),
				                        .in1 (icdata_i2[100:68]),
				                        .in2 (icdata_i2[66:34]),
				                        .in3 (icdata_i2[32:0]),
				                        .sel0_l (ifc_ifd_finst_sel_l[0]),
				                        .sel1_l (ifc_ifd_finst_sel_l[1]),
				                        .sel2_l (ifc_ifd_finst_sel_l[2]),
				                        .sel3_l (ifc_ifd_finst_sel_l[3]));

   // synopsys translate_off
//`ifdef DEFINE_0IN
//`else
//   always @ (ifq_fdp_fill_inst or ifd_ifc_cpxreq_i2)
//     if (((^ifq_fdp_fill_inst[32:0]) == 1'bx) && (ifd_ifc_cpxreq_i2 == `CPX_IFILLPKT))
//       begin
//          $display("ifqdp.v: Imiss Return val = %h\n", ifqop_i2);
//          $display("IFQCPX", "Error: X's detected in Imiss Return Inst %h",
//                 ifq_fdp_fill_inst[31:0]);
//          $finish();
//       end
//`endif
   // synopsys translate_on


   // TBD: 1. inv way in fill pkt -- DONE
   //      2. inv packet -- DONE
   //      3. DFT pkt from TAP -- NO NEED
   //      4. Ld pkt to invalidate i$  -- DONE

   //----------------------------------------------------------------------
   // ASI Access
   //----------------------------------------------------------------------
   // mux stxa pkt into the cpx
   assign  stxa_data_pkt[144] = 1'b0;
   // vbits and parity are muxed into the cpxreq
   assign  stxa_data_pkt[143:140] = {1'b1, lsu_ifu_stxa_data[34:32]};
//   assign  stxa_data_pkt[`CPX_THRFIELD] = lsu_ifu_asi_thrid[1:0];
   assign  stxa_data_pkt[135:134] = 2'b0;
   // use parity to insert error in icache inst or tag
   assign  stxa_data_pkt[(137 + 1)] = lsu_ifu_stxa_data[32];
   assign  stxa_data_pkt[127:0] = {4{lsu_ifu_stxa_data[31:0]}};

   // other bits need to be tied off
   assign  stxa_data_pkt[133:128] = 6'b0;
   assign  stxa_data_pkt[137:136] = 2'b0;
   assign  stxa_data_pkt[139] = 1'b0;

   // format fwd data pkt in a similar way
   assign  fwd_data_pkt[144:(137 + 2)] = ifqop_i2[144:(137 + 2)];
   assign  fwd_data_pkt[(137 + 1)] = ifqop_i2[32];
   assign  fwd_data_pkt[137:128] = ifqop_i2[137:128];
   assign  fwd_data_pkt[127:0] = {4{ifqop_i2[31:0]}};



   dff_s #(16) stxa_ff(.din (lsu_ifu_stxa_data[47:32]),
		                 .q   (ifq_erb_asidata_i2[47:32]),
		                 .clk (clk), .se(se), .si(), .so());
   assign  ifq_erb_asidata_i2[31:0] = ifqop_i2[31:0];

   // va[63:32] is truncated
   // In this architecture we only need va[17:0]
   // rest of the bits ar ehere only for the address range check
   // 12 new muxes (10 for addr, 2 for way)
   // CHANGE: this mux has been moved before the asi_addr_reg, rather
   // than after.
   // Use mux flop soffm2?
   dp_mux2es #(12) asifwd_mx(.dout (asi_fwd_index[13:2]),
                             .in0  ({lsu_ifu_asi_addr[17:16],   // asi way
                                     lsu_ifu_asi_addr[12:3]}),  // asi addr
                             .in1  ({ifqop_i2[81:80],    // fwd rq way
                                     ifqop_i2[76:67]}),  // fwd rq addr
                             .sel  (ifc_ifd_idx_sel_fwd_i2));

   assign asi_va_i1 = {asi_fwd_index[13:12],
                       lsu_ifu_asi_addr[15:13],
                       asi_fwd_index[11:2],
                       lsu_ifu_asi_addr[2:0]};

   dff_s #(18) asi_addr_reg(.din (asi_va_i1[17:0]),  // 15:13 is not used
			                    .q   (asi_va_i2[17:0]),
			                    .clk (clk),
			                    .se  (se), .si(), .so());

   // 16b zero cmp: leave out bit 3!! (imask is 0x8)
   assign  ifd_ifc_asi_vachklo_i2 = (|asi_va_i2[16:4]) | (|asi_va_i2[2:0]);

   // mux in ifqop and asi_va_i2 to create new asi va?
   // asi va is shifted by 1 bit to look like 64b op
   assign    ifd_ifc_asiaddr_i2[3:2] = asi_va_i2[4:3];

   assign    asi_addr_i2 = {tag_par_i2,           // tag parity 42
			                      asi_va_i2[17:16],     // way 41:40
			                      ifqop_i2[27:0],       // tag 39:12
			                      asi_va_i2[12:3]       // index 11:2
                            };

   // bist has to go to icache in the same cycle
   // cannot flop it
   assign    bist_addr_i2 = {1'b0,                    // par
			                       mbist_icache_way[1:0],   // way 41:40
			                       28'b0,                   // tag 39:12
			                       mbist_icache_index[7:0], // index 11:4
                             mbist_icache_word,       // 3
			                       1'b0
			                       };

   // floating signals
   sink #(2) s0(.in (imiss_paddr_s[1:0]));
   sink s1(.in (pcxreq_e[42]));
   sink s2(.in (fill_addr_i2[4]));


endmodule // sparc_ifu_ifqdp



// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_imd.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_imd
//  Description:	
//  Contains the immediate operand datapath.  Has two outputs:  The
//  simm data to the EXU and the branch offset to the IFU.
*/


module sparc_ifu_imd(/*AUTOARG*/
   // Outputs
   ifu_exu_imm_data_d, dtu_inst_d, ifu_exu_rd_d, ifu_lsu_rd_e, 
   ifu_lsu_imm_asi_d, ifu_tlu_imm_asi_d, ifu_lsu_imm_asi_vld_d, ifu_tlu_sraddr_d, 
   ifu_tlu_sraddr_d_v2, imd_dcl_brcond_d, imd_dcl_mvcond_d, 
   imd_dcl_abit_d, so, ifu_ffu_frs1_d, ifu_ffu_frs2_d, ifu_ffu_frd_d, 
   ifu_ffu_fpopcode_d, ifu_ffu_fcc_num_d, 
   // Inputs
   rclk, se, si, fdp_dtu_inst_s, fcl_imd_oddwin_d, 
   dcl_imd_immdata_sel_simm13_d_l, dcl_imd_immdata_sel_movcc_d_l, 
   dcl_imd_immdata_sel_sethi_d_l, dcl_imd_immdata_sel_movr_d_l, 
   dcl_imd_broff_sel_call_d_l, dcl_imd_broff_sel_br_d_l, 
   dcl_imd_broff_sel_bcc_d_l, dcl_imd_broff_sel_bpcc_d_l, 
   dcl_imd_immbr_sel_br_d, dcl_imd_call_inst_d
   );

   input rclk, 
         se, 
         si;

   input [31:0] fdp_dtu_inst_s;          // instruction from fetch

   input        fcl_imd_oddwin_d;       // are we in an even or odd window
   
   input        dcl_imd_immdata_sel_simm13_d_l,  // imm data selects
		            dcl_imd_immdata_sel_movcc_d_l,
		            dcl_imd_immdata_sel_sethi_d_l,
		            dcl_imd_immdata_sel_movr_d_l;
   
   input        dcl_imd_broff_sel_call_d_l,      // dir branch offset select
		            dcl_imd_broff_sel_br_d_l,
		            dcl_imd_broff_sel_bcc_d_l,
		            dcl_imd_broff_sel_bpcc_d_l;

   input        dcl_imd_immbr_sel_br_d;  // use branch offset or simm data
   input        dcl_imd_call_inst_d;
   
   output [31:0] ifu_exu_imm_data_d;      // imm data to EXU
   output [31:0] dtu_inst_d;              // D stage inst to DEC

   output [4:0]  ifu_exu_rd_d,
		             ifu_lsu_rd_e;
   
   output [7:0]  ifu_lsu_imm_asi_d;       // ASI for ldA and stA
   output [8:0]  ifu_tlu_imm_asi_d;       // ASI for ldA and stA
   output        ifu_lsu_imm_asi_vld_d;
   output [6:0]  ifu_tlu_sraddr_d;
   output [6:0]  ifu_tlu_sraddr_d_v2;
   output [3:0]  imd_dcl_brcond_d;
   output [7:0]  imd_dcl_mvcond_d;

   output        imd_dcl_abit_d;         // anull bit for cond branch

   output        so;

   output [4:0]  ifu_ffu_frs1_d,
		             ifu_ffu_frs2_d,
		             ifu_ffu_frd_d;

   output [8:0]  ifu_ffu_fpopcode_d;
   output [1:0]  ifu_ffu_fcc_num_d;
	 

//-----------------------------------
// Declaration of local signals
//----------------------------------
   wire [4:0]  sraddr5;

   wire [31:0] imm_data_d;       // imm data 

   wire [31:0] dtu_inst_d,
		           simm13,
		           simm11,
		           simm10,
		           imm22,
		           dbr16,
		           dbcc22_nopred,
		           dbcc19_pred,
		           dcall,
		           broffset_d;
   
   wire        clk, ifu_lsu_imm_asi_vld_f;
   
   
//----------------------------------------------------------------------
// Code starts here 
//----------------------------------------------------------------------
   assign      clk = rclk;
   
   //--------
   // S Stage
   // Contains mostly random logic to help with decode in D stage
   //--------
   
   // Regfile operations:
   // REMOVED
//   assign ifu_exu_rs1_s = fdp_dtu_inst_s[18:14] ^ 
//			  {{fdp_dtu_inst_s[17] & dcl_imd_oddwin_s},  4'b0000};

//   assign ifu_exu_rs2_s = fdp_dtu_inst_s[4:0] ^ 
//			  {{fdp_dtu_inst_s[3] & dcl_imd_oddwin_s},  4'b0000};

//   assign ifu_exu_rs3_s = fdp_dtu_inst_s[29:25] ^ 
//			  {{fdp_dtu_inst_s[28] & dcl_imd_oddwin_s},  4'b0000};

//   assign imd_dcl_op_s = fdp_dtu_inst_s[31:30];
//   assign imd_dcl_op3_s = fdp_dtu_inst_s[24:19];
   
   //--------
   // D stage
   // Contains the immediate data and branch offset muxes
   //--------
   
   dff_s #(32) inst_d_reg(.din  (fdp_dtu_inst_s),
		      .clk  (clk),
		      .q    (dtu_inst_d),
		      .se   (se), .si(), .so());

   dff_s #(1) ifu_lsu_imm_asi_inst(.din  (fdp_dtu_inst_s[13]),
                      .clk  (clk),
                      .q    (ifu_lsu_imm_asi_vld_f),
                      .se   (se), .si(), .so());

   assign imd_dcl_abit_d = dtu_inst_d[29];

   // imm data select
   // sext12:0 -- add/sub/and/or/xor/taggedOP/jmpl/ld/store/atomic/div/mul/popc
   //             prefetch/return/restore/save/sir/wr/shft/flush
   //  !!!CAS does not use Imm data!!!
   //
   // sext10:0 -- movcc
   // sext9:0  -- movr
   // 21:0,10'b0 -- sethi

   assign simm13 = {{19{dtu_inst_d[12]}},dtu_inst_d[12:0]};
   assign simm11 = {{21{dtu_inst_d[10]}},dtu_inst_d[10:0]};
   assign simm10 = {{22{dtu_inst_d[9]}},dtu_inst_d[9:0]};
   assign imm22  = {dtu_inst_d[21:0], 10'b0};

   dp_mux4ds  #(32) immdata_mux(.dout (imm_data_d),
			  .in0  (simm13),
			  .in1  (simm11),
			  .in2  (simm10),
			  .in3  (imm22),
			  .sel0_l (dcl_imd_immdata_sel_simm13_d_l),
			  .sel1_l (dcl_imd_immdata_sel_movcc_d_l),
			  .sel2_l (dcl_imd_immdata_sel_movr_d_l),
			  .sel3_l (dcl_imd_immdata_sel_sethi_d_l));


   // branch offset select
   assign dbr16 = {{14{dtu_inst_d[21]}}, dtu_inst_d[21:20], 
		   dtu_inst_d[13:0], 2'b0};
   assign dbcc22_nopred = {{8{dtu_inst_d[21]}}, dtu_inst_d[21:0], 2'b0};
   assign dbcc19_pred = {{11{dtu_inst_d[18]}}, dtu_inst_d[18:0], 2'b0};
   assign dcall = {dtu_inst_d[29:0], 2'b0};

   dp_mux4ds  #(32) broffset_mux(.dout   (broffset_d[31:0]),
			   .in0    (dcall[31:0]),          // call
			   .in1    (dbr16[31:0]),          // br on reg
			   .in2    (dbcc22_nopred[31:0]),  // branch w/o pred
			   .in3    (dbcc19_pred[31:0]),    // branch w/ pred
			   .sel0_l (dcl_imd_broff_sel_call_d_l),
			   .sel1_l (dcl_imd_broff_sel_br_d_l),
			   .sel2_l (dcl_imd_broff_sel_bcc_d_l),
			   .sel3_l (dcl_imd_broff_sel_bpcc_d_l));

   dp_mux2es #(32) immbr_mux(.dout (ifu_exu_imm_data_d[31:0]),
			   .in0  (imm_data_d[31:0]),
			   .in1  (broffset_d[31:0]),
			   .sel  (dcl_imd_immbr_sel_br_d));

   // branch/move condition to dcl
   assign imd_dcl_brcond_d = dtu_inst_d[28:25];
   assign imd_dcl_mvcond_d = dtu_inst_d[17:10];

   // if call instruction set rd = 0f (15)
   assign ifu_exu_rd_d[3:0] = dtu_inst_d[28:25] | {4{dcl_imd_call_inst_d}};
   assign ifu_exu_rd_d[4] = (dtu_inst_d[29] & ~dcl_imd_call_inst_d) ^
			      (ifu_exu_rd_d[3] & fcl_imd_oddwin_d);
   
   dff_s #(5) rde_ff(.din (ifu_exu_rd_d[4:0]),
		 .clk (clk),
		 .q   (ifu_lsu_rd_e[4:0]),
		 .se  (se), .si(), .so());

   // read/write pr and read/write sr
   dp_mux2es #(5)  sraddr_mux(.dout (sraddr5[4:0]),
			    .in0  (dtu_inst_d[18:14]),  // rs1 for rdpr
			    .in1  (dtu_inst_d[29:25]),  // rd  for wrpr
			    .sel  (dtu_inst_d[23]));

   assign ifu_tlu_sraddr_d = {dtu_inst_d[19],                     // hpriv
                              {dtu_inst_d[20] & ~dtu_inst_d[19]}, // priv
                              sraddr5[4:0]};
   assign ifu_tlu_sraddr_d_v2 = ifu_tlu_sraddr_d;
   

   // asi fields for stA, ldA
   // same as fpopcode_d

   assign ifu_lsu_imm_asi_d[7:0] = dtu_inst_d[12:5];
   assign ifu_tlu_imm_asi_d[8:0] = dtu_inst_d[13:5];

   assign ifu_lsu_imm_asi_vld_d = ~ifu_lsu_imm_asi_vld_f;
   
   // fp reg fields
   assign ifu_ffu_frd_d = dtu_inst_d[29:25];
   assign ifu_ffu_fcc_num_d = dtu_inst_d[26:25];
   assign ifu_ffu_frs1_d = dtu_inst_d[18:14];
   assign ifu_ffu_fpopcode_d = dtu_inst_d[13:5];
   assign ifu_ffu_frs2_d = dtu_inst_d[4:0];
   
endmodule // sparc_ifu_imd
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_incr46.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Description:	
//  Contains the pc incrementer.
*/

module sparc_ifu_incr46(a, a_inc, ofl);
   input  [45:0]  a;
   output [45:0]  a_inc;
   output 	  ofl;
   
   reg [45:0] 	  a_inc;
   reg 		  ofl;
   
   always @ (a)
     begin
	      a_inc = a + (46'b1);
	      ofl = (~a[45]) & a_inc[45];
     end
   
   
   
endmodule // sparc_ifu_incr46


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: sparc_ifu_invctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_invctl
//  Description:
//  Control logic for handling invalidations to the icache
//
*/

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_invctl(/*AUTOARG*/
   // Outputs
   so, inv_ifc_inv_pending, ifq_icv_wrindex_bf, ifq_icv_wren_bf,
   ifq_ict_dec_wrway_bf, ifq_fcl_invreq_bf, ifq_erb_asiway_f,
   // Inputs
   rclk, se, si, const_cpuid, mbist_icache_write,
   lsu_ifu_ld_icache_index, lsu_ifu_ld_pcxpkt_vld,
   lsu_ifu_ld_pcxpkt_tid, ifc_inv_ifqadv_i2, ifc_inv_asireq_i2,
   ifq_icd_index_bf, ifd_inv_ifqop_i2, ifd_inv_wrway_i2
   );

   input        rclk,
                se,
                si;


   input [2:0]  const_cpuid;
   input        mbist_icache_write;

   input [(6 + 5):5]   lsu_ifu_ld_icache_index;
   input                  lsu_ifu_ld_pcxpkt_vld;
   input [1:0]            lsu_ifu_ld_pcxpkt_tid;

   input                  ifc_inv_ifqadv_i2;
   input                  ifc_inv_asireq_i2;

   input [(6 + 5):5]   ifq_icd_index_bf;
   input [145-1:0] ifd_inv_ifqop_i2;
   input [1:0]            ifd_inv_wrway_i2;


   output                 so;

   output                 inv_ifc_inv_pending;

   output [(6 + 5):5]  ifq_icv_wrindex_bf;
   output [15:0]          ifq_icv_wren_bf;
   output [3:0]           ifq_ict_dec_wrway_bf;
   output                 ifq_fcl_invreq_bf;
   output [1:0]           ifq_erb_asiway_f;


//----------------------------------------------------------------------
//  Local Signals
//----------------------------------------------------------------------

   wire [1:0]  invwd_way_i2;
   wire [1:0]  invwd0_way_i2 = invwd_way_i2;
   wire [1:0]  invwd1_way_i2 = invwd_way_i2;
   wire [1:0]  inv0_way_i2;
   wire [1:0]  inv1_way_i2;

   wire [1:0]  asi_way_f;

   wire        word_inv_i2;
   wire        word0_inv_i2 = word_inv_i2;
   wire        word1_inv_i2 = word_inv_i2;

   wire        ldinv_i2,
               ldpkt_i2,
               evpkt_i2,
               stpkt_i2,
               strmack_i2,
               imissrtn_i2;

   wire        invreq_i2,
               invalidate_i2,
               invalidate_f;

   wire        invall_i2,
               invpa5_i2;
   wire         invall_evict_i2;

   wire [1:0]  cpxthrid_i2;
   wire [3:0]  dcpxthr_i2;

   wire [1:0]  ldinv_way_i2;
   wire [1:0]  w0_way_i2,
               w1_way_i2,
               w0_way_f,
               w1_way_f;

   wire        pick_wr;
   wire        icv_wrreq_i2;

   wire [3:0]  wrt_en_wd_i2,
               wrt_en_wd_bf,
               wrt_en_wd_f;

   wire [3:0]  w0_dec_way_i2,
               w1_dec_way_i2;

   wire [3:0]  dec_wrway;

   wire        icvidx_sel_wr_i2,
               icvidx_sel_ld_i2,
               icvidx_sel_inv_i2;

   wire [15:0] wren_i2;


   wire [(6 + 5):6] inv_addr_i2;
   wire [(6 + 5):5] icaddr_i2;

   wire                missaddr5_i2;
   wire                missaddr6_i2;


   wire [3:0]          ldthr,
                       ldidx_sel_new;

   wire [(6 + 5):5] ldinv_addr_i2,
                       ldindex0,
                       ldindex1,
                       ldindex2,
                       ldindex3,
                       ldindex0_nxt,
                       ldindex1_nxt,
                       ldindex2_nxt,
                       ldindex3_nxt;

   wire                clk;


//
// Code Begins Here
//
   assign              clk = rclk;

   //----------------------------------------------------------------------
   // Extract Invalidate Packet For This Core
   //----------------------------------------------------------------------

   assign word_inv_i2 = ifd_inv_ifqop_i2[1];
   assign invwd_way_i2 = ifd_inv_ifqop_i2[5:2]; // trin: width mismatch okay

   //-----------------------------
   // Decode CPX Packet
   //-----------------------------
   // load
   assign ldpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0000}) ?
                       1'b1 : 1'b0;
   assign ldinv_i2 = ldpkt_i2 & ifd_inv_ifqop_i2[133];
   assign ldinv_way_i2= ifd_inv_ifqop_i2[132:131];

   // ifill
   assign imissrtn_i2 = ({ifd_inv_ifqop_i2[144],
                          ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0001}) ?
                          1'b1 : 1'b0;

   // store ack
   assign stpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0100}) ?
                       1'b1 : 1'b0;
   assign strmack_i2 = ({ifd_inv_ifqop_i2[144],
                         ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0110}) ?
                         1'b1 : 1'b0;
   assign invall_i2 = stpkt_i2 & ifd_inv_ifqop_i2[124] &
                      ifc_inv_ifqadv_i2;
   assign invpa5_i2 = ifd_inv_ifqop_i2[122];

   // evict
   assign evpkt_i2 = ({ifd_inv_ifqop_i2[144],
                       ifd_inv_ifqop_i2[143:140]} == {1'b1, 4'b0011}) ?
                       1'b1 : 1'b0;
   assign invall_evict_i2 = evpkt_i2 & ifd_inv_ifqop_i2[124] &
                      ifc_inv_ifqadv_i2;

   // get thread id and decode
   assign  cpxthrid_i2 = ifd_inv_ifqop_i2[135:134];

   assign  dcpxthr_i2[0] = ~cpxthrid_i2[1] & ~cpxthrid_i2[0];
   assign  dcpxthr_i2[1] = ~cpxthrid_i2[1] &  cpxthrid_i2[0];
   assign  dcpxthr_i2[2] =  cpxthrid_i2[1] & ~cpxthrid_i2[0];
   assign  dcpxthr_i2[3] =  cpxthrid_i2[1] &  cpxthrid_i2[0];

   //-----------------------------------------------
   // Generate Write Way and Write Enables
   //-----------------------------------------------

   // decode way for tags
   assign  dec_wrway[0] = ~ifd_inv_wrway_i2[1] & ~ifd_inv_wrway_i2[0];
   assign  dec_wrway[1] = ~ifd_inv_wrway_i2[1] & ifd_inv_wrway_i2[0];
   assign  dec_wrway[2] = ifd_inv_wrway_i2[1] & ~ifd_inv_wrway_i2[0];
   assign  dec_wrway[3] = ifd_inv_wrway_i2[1] & ifd_inv_wrway_i2[0];

   assign  ifq_ict_dec_wrway_bf = dec_wrway;

   // way for asi
   dff_s #(2) asiwayf_reg(.din (ifd_inv_wrway_i2),
		                    .q   (asi_way_f),
		                    .clk (clk), .se(se), .si(), .so());

   assign  ifq_erb_asiway_f = asi_way_f;


   // Select which index/way to invalidate
   assign icv_wrreq_i2 = imissrtn_i2 | ifc_inv_asireq_i2 | mbist_icache_write;

   assign inv0_way_i2 = ~ifc_inv_ifqadv_i2 ? w0_way_f :
                        ldinv_i2           ? ldinv_way_i2 :
                                             invwd_way_i2;
   assign inv1_way_i2 = ~ifc_inv_ifqadv_i2 ? w1_way_f :
                        ldinv_i2           ? ldinv_way_i2 :
                                             invwd_way_i2;

   assign pick_wr = (imissrtn_i2 | ifc_inv_asireq_i2) & ifc_inv_ifqadv_i2 |
                     mbist_icache_write;
   assign w0_way_i2 = pick_wr ? ifd_inv_wrway_i2 :
                                inv0_way_i2;
   assign w1_way_i2 = pick_wr ? ifd_inv_wrway_i2 :
                                inv1_way_i2;

   dff_s #(4) wrway_reg(.din ({w0_way_i2, w1_way_i2}),
                      .q   ({w0_way_f, w1_way_f}),
                      .clk (clk), .se(se), .si(), .so());

   // determine the way in the ICV we are writing to
//   mux3ds #(2) w0_waymux(.dout  (w0_way_i2),
//		                     .in0   (ifd_inv_wrway_i2[1:0]),
//		                     .in1   (invwd0_way_i2[1:0]),
//		                     .in2   (ldinv_way_i2[1:0]),
//		                     .sel0  (icvidx_sel_wr_i2),
//		                     .sel1  (icvidx_sel_inv_i2),
//		                     .sel2  (icvidx_sel_ld_i2));

//   mux3ds #(2) w1_waymux(.dout  (w1_way_i2),
//		                     .in0   (ifd_inv_wrway_i2[1:0]),
//		                     .in1   (invwd1_way_i2[1:0]),
//		                     .in2   (ldinv_way_i2[1:0]),
//		                     .sel0  (icvidx_sel_wr_i2),
//		                     .sel1  (icvidx_sel_inv_i2),
//		                     .sel2  (icvidx_sel_ld_i2));

   // decode write way
   assign w0_dec_way_i2[0] = ~w0_way_i2[1] & ~w0_way_i2[0];
   assign w0_dec_way_i2[1] = ~w0_way_i2[1] &  w0_way_i2[0];
   assign w0_dec_way_i2[2] =  w0_way_i2[1] & ~w0_way_i2[0];
   assign w0_dec_way_i2[3] =  w0_way_i2[1] &  w0_way_i2[0];

   assign w1_dec_way_i2[0] = ~w1_way_i2[1] & ~w1_way_i2[0];
   assign w1_dec_way_i2[1] = ~w1_way_i2[1] &  w1_way_i2[0];
   assign w1_dec_way_i2[2] =  w1_way_i2[1] & ~w1_way_i2[0];
   assign w1_dec_way_i2[3] =  w1_way_i2[1] &  w1_way_i2[0];


   // determine if valid bit write to top 32B, bot 32B or both
   assign wrt_en_wd_i2[0] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           ~inv_addr_i2[6] |
                          ldinv_i2 & ~ldinv_addr_i2[5] & ~ldinv_addr_i2[6] |
		                      icv_wrreq_i2 & ~missaddr5_i2 & ~missaddr6_i2;

   assign wrt_en_wd_i2[1] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           ~inv_addr_i2[6] |
			                      ldinv_i2 & ldinv_addr_i2[5] & ~ldinv_addr_i2[6] |
		                        icv_wrreq_i2 & missaddr5_i2 & ~missaddr6_i2;

   assign wrt_en_wd_i2[2] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           inv_addr_i2[6] |
                          ldinv_i2 & ~ldinv_addr_i2[5] & ldinv_addr_i2[6] |
		                      icv_wrreq_i2 & ~missaddr5_i2 & missaddr6_i2;

   assign wrt_en_wd_i2[3] = word_inv_i2 & (stpkt_i2 | evpkt_i2 |strmack_i2) &
                                           inv_addr_i2[6] |
			                      ldinv_i2 & ldinv_addr_i2[5] & ldinv_addr_i2[6] |
		                        icv_wrreq_i2 & missaddr5_i2 & missaddr6_i2;

   assign wrt_en_wd_bf = ifc_inv_ifqadv_i2 ? wrt_en_wd_i2 :
                                              wrt_en_wd_f;
   dff_s #(4) wrten_reg(.din (wrt_en_wd_bf),
                      .q   (wrt_en_wd_f),
                      .clk (clk), .se(se), .si(), .so());


   // Final Write Enable to ICV
   assign wren_i2[3:0] = (w0_dec_way_i2 & {4{wrt_en_wd_bf[0]}}) |
                           {4{(invall_i2 | invall_evict_i2) & ~invpa5_i2 & ~inv_addr_i2[6]}};

   assign wren_i2[7:4] = (w1_dec_way_i2 & {4{wrt_en_wd_bf[1]}}) |
                           {4{(invall_i2 | invall_evict_i2) & invpa5_i2 & ~inv_addr_i2[6]}};

   assign wren_i2[11:8] = (w0_dec_way_i2 & {4{wrt_en_wd_bf[2]}}) |
                            {4{(invall_i2 | invall_evict_i2) & ~invpa5_i2 & inv_addr_i2[6]}};

   assign wren_i2[15:12] = (w1_dec_way_i2 & {4{wrt_en_wd_bf[3]}}) |
                             {4{(invall_i2 | invall_evict_i2) & invpa5_i2 & inv_addr_i2[6]}};

   assign ifq_icv_wren_bf = wren_i2;

   // advance the wr way for the ICV array
//   mux2ds #(8) wren_mux(.dout  (next_wren_i2),
//		                    .in0   (wren_f),
//		                    .in1   (wren_i2),
//		                    .sel0  (~ifc_ifd_ifqadv_i2),
//		                    .sel1  (ifc_ifd_ifqadv_i2));

//   assign wren_bf = ifc_inv_ifqadv_i2 ? wren_i2 : wren_f;
//   dff #(8) icv_weff(.din  (wren_bf),
//		                 .q    (wren_f),
//		                 .clk  (clk),
//		                 .se   (se), .si(), .so());

//   assign ifq_icv_wren_bf[7:0] = wren_bf[7:0] & {8{~icvaddr6_i2}};
//   assign ifq_icv_wren_bf[15:8] = wren_bf[7:0] & {8{icvaddr6_i2}};


   //--------------------------
   // Invalidates
   //--------------------------
   assign invalidate_i2 = (stpkt_i2 | evpkt_i2 | strmack_i2) &
			                      (word_inv_i2 |
			                       ifd_inv_ifqop_i2[124]) |  // all ways
			                     ldinv_i2;

   mux2ds #(1) invf_mux(.dout (invreq_i2),
		                    .in0  (invalidate_f),
		                    .in1  (invalidate_i2),
		                    .sel0  (~ifc_inv_ifqadv_i2),
		                    .sel1  (ifc_inv_ifqadv_i2));

   dff_s #(1) invf_ff(.din  (invreq_i2),
		                .q    (invalidate_f),
		                .clk  (clk),
		                .se   (se), .si(), .so());

   // auto invalidate is done during bist
   // no need to qualify bist_write with ifqadv_i2 since bist is done
   // before anything else.
   assign ifq_fcl_invreq_bf = invreq_i2 | mbist_icache_write;

   // don't really need to OR with invalidate_f, since this will be
   // gone in a cycle
//   assign inv_ifc_inv_pending = invalidate_i2 | invalidate_f;
   assign inv_ifc_inv_pending = invalidate_i2;

   //---------------------------------
   // Get the ifill/invalidation index
   //---------------------------------

   // ifill index
   assign icaddr_i2[(6 + 5):5] = ifq_icd_index_bf[(6 + 5):5];
   assign missaddr5_i2 = ifq_icd_index_bf[5];
   assign missaddr6_i2 = ifq_icd_index_bf[6];

   // evict invalidate index
   //   assign    inv_addr_i2 = ifqop_i2[117:112];
   // assign inv_addr_i2 = ifd_inv_ifqop_i2[`CPX_INV_IDX_HI:`CPX_INV_IDX_LO];
   // trin: CPX is modified to accomodate up to 10 bits of icache indexing
   //    or 4096*4w*32B = 512KB
   wire [15:6] inv_addr_i2_full = { ifd_inv_ifqop_i2[27:24],
                          ifd_inv_ifqop_i2[117:112] };
   assign inv_addr_i2[(6 + 5):6] = inv_addr_i2_full[(6 + 5):6];

   // index for invalidates caused by a load
   // store dcache index when a load req is made

   assign ldthr[0] = ~lsu_ifu_ld_pcxpkt_tid[1] & ~lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[1] = ~lsu_ifu_ld_pcxpkt_tid[1] &  lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[2] =  lsu_ifu_ld_pcxpkt_tid[1] & ~lsu_ifu_ld_pcxpkt_tid[0];
   assign ldthr[3] =  lsu_ifu_ld_pcxpkt_tid[1] &  lsu_ifu_ld_pcxpkt_tid[0];

   assign ldidx_sel_new = ldthr & {4{lsu_ifu_ld_pcxpkt_vld}};

//   dp_mux2es  #(`IC_IDX_SZ) t0_ldidx_mux(.dout (ldindex0_nxt),
//			                                   .in0  (ldindex0),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[0]));
   assign ldindex0_nxt = ldidx_sel_new[0] ? lsu_ifu_ld_icache_index :
                                            ldindex0;

//   dp_mux2es  #(`IC_IDX_SZ) t1_ldidx_mux(.dout (ldindex1_nxt),
//			                                   .in0  (ldindex1),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[1]));
   assign ldindex1_nxt = ldidx_sel_new[1] ? lsu_ifu_ld_icache_index :
                                            ldindex1;

//   dp_mux2es  #(`IC_IDX_SZ) t2_ldidx_mux(.dout (ldindex2_nxt),
//			                                   .in0  (ldindex2),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[2]));
   assign ldindex2_nxt = ldidx_sel_new[2] ? lsu_ifu_ld_icache_index :
                                            ldindex2;

//   dp_mux2es  #(`IC_IDX_SZ) t3_ldidx_mux(.dout (ldindex3_nxt),
//			                                   .in0  (ldindex3),
//			                                   .in1  (lsu_ifu_ld_icache_index),
//			                                   .sel  (ldidx_sel_new[3]));
   assign ldindex3_nxt = ldidx_sel_new[3] ? lsu_ifu_ld_icache_index :
                                            ldindex3;


   dff_s #(((6 + 5) - 4))  ldix0_reg(.din (ldindex0_nxt),
		                            .q   (ldindex0),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix1_reg(.din (ldindex1_nxt),
		                            .q   (ldindex1),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix2_reg(.din (ldindex2_nxt),
		                            .q   (ldindex2),
		                            .clk (clk), .se(se), .si(), .so());
   dff_s #(((6 + 5) - 4))  ldix3_reg(.din (ldindex3_nxt),
		                            .q   (ldindex3),
		                            .clk (clk), .se(se), .si(), .so());

   // Pick dcache index corresponding to current thread
   mux4ds #(((6 + 5) - 4)) ldinv_mux(.dout (ldinv_addr_i2),
			                            .in0  (ldindex0),
			                            .in1  (ldindex1),
			                            .in2  (ldindex2),
			                            .in3  (ldindex3),
			                            .sel0 (dcpxthr_i2[0]),
			                            .sel1 (dcpxthr_i2[1]),
			                            .sel2 (dcpxthr_i2[2]),
			                            .sel3 (dcpxthr_i2[3]));

   // Final Mux for Index
   assign icvidx_sel_wr_i2 = imissrtn_i2 | ifc_inv_asireq_i2 |
                             mbist_icache_write | ~ifc_inv_ifqadv_i2;
   assign icvidx_sel_ld_i2 = ldinv_i2 & ifc_inv_ifqadv_i2;
   assign icvidx_sel_inv_i2 = ~imissrtn_i2 & ~ldinv_i2 &
                              ~ifc_inv_asireq_i2 & ifc_inv_ifqadv_i2 &
                              ~mbist_icache_write;

   mux3ds #(((6 + 5) - 4)) icv_idx_mux(
                            .dout  (ifq_icv_wrindex_bf[(6 + 5):5]),
			                      .in0   (icaddr_i2[(6 + 5):5]),
			                      .in1   ({inv_addr_i2[(6 + 5):6], 1'b0}),
			                      .in2   (ldinv_addr_i2[(6 + 5):5]),
			                      .sel0  (icvidx_sel_wr_i2),
			                      .sel1  (icvidx_sel_inv_i2),
			                      .sel2  (icvidx_sel_ld_i2));

   sink #(145) s0(.in (ifd_inv_ifqop_i2));


endmodule // sparc_ifu_invctl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_lfsr5.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lfsr5
//  Description:	
//  The IFQ is the icache input queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_lfsr5 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   advance, clk, se, si, so, reset
   );

   input 	advance;
   
   input 	clk, se, si, so, reset;

   output [1:0] out;

   reg [4:0]    q_next;
   wire [4:0]   q;
   

/*
   always @ (posedge clk)
     begin
	out = $random;
     end // always @ posedge
 */

//   always @ (posedge clk)
//     begin
//	q[4:0] <= q_next[4:0];
//     end

   always @ (/*AUTOSENSE*/advance or q or reset)
     begin
	      if (reset)
	        q_next = 5'b11111;
	      else if (advance)
	        begin
	           // lfsr -- stable at 000000, period of 63
	           q_next[1] = q[0];
	           q_next[2] = q[1];
	           q_next[3] = q[2];
	           q_next[4] = q[3];
	           q_next[0] = q[1] ^ q[4];
	        end
	      else
	        q_next = q;
     end // always @ (...

   assign out = {q[0], q[2]};

   dff_s #(5) lfsr_reg(.din  (q_next),
                     .q    (q),
                     .clk  (clk), .se(se), .si(), .so());
   
endmodule // sparc_ifu_lfsr5

		
	       

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_lru4.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lru4
//  Description:	
//  LRU scheduler.  Least priority to the last granted
//  customer.  If no requests, the priority remains the same. 
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_lru4(/*AUTOARG*/
   // Outputs
   grant_vec, so, 
   // Inputs
   clk, reset, se, si, recent_vec, load_recent, req_vec, spec_vec, 
   use_spec
   );

   input     clk, reset, se, si;

   input [3:0] recent_vec;
   input       load_recent;
   input [3:0] req_vec,
               spec_vec;

   input       use_spec;
   
   output [3:0] grant_vec;
   
   output       so;


   wire [3:0]   used0,  // used0 is mru
		            used1,
		            used2,
		            used3;  // used3 is lru

   wire [3:0]   used23,
                used23_nxt;

   wire [3:0]   used0_buf, 
		            used1_buf,
		            used2_buf,
		            used3_buf; 

   wire [3:0]   sp_used0, 
		            sp_used1,
		            sp_used2,
		            sp_used3; 
   wire [3:0]   nosp_used0, 
		            nosp_used1,
		            nosp_used2,
		            nosp_used3; 

   wire [3:0]   used0_calc,
		            used0_nxt,
 		            used1_calc,
		            used1_nxt,
 		            used2_calc,
		            used2_nxt,
 		            used3_calc,
		            used3_nxt;

   wire         hit1,
		            hit2,
		            hit3;

   wire [3:0]   nospec_grant,
                spec_grant;
   
   wire         reqhit1,
		            reqhit2,
		            reqhit3,
                reqhit23;

   wire         spechit1,
		            spechit2,
		            spechit3,
                spechit23;

   wire         sel_u0,
		            sel_u1,
		            sel_u2,
		            sel_u3;

   wire         sel_su0,
		            sel_su1,
		            sel_su2,
		            sel_su3;

   dp_buffer #(4) use_buf0(.dout(used0_buf),
                      .in  (used0));
   dp_buffer #(4) use_buf1(.dout(used1_buf),
                      .in  (used1));
   dp_buffer #(4) use_buf2(.dout(used2_buf),
                      .in  (used2));
   dp_buffer #(4) use_buf3(.dout(used3_buf),
                      .in  (used3));
   

   // determine lru order for next cycle
//   assign hit0 = (used0_buf[0] & recent_vec[0] |
//		              used0_buf[1] & recent_vec[1] |
//		              used0_buf[2] & recent_vec[2] |
//		              used0_buf[3] & recent_vec[3]) & load_recent;

   assign hit1 = (used1_buf[0] & recent_vec[0] |
		              used1_buf[1] & recent_vec[1] |
		              used1_buf[2] & recent_vec[2] |
		              used1_buf[3] & recent_vec[3]) & load_recent;

   assign hit2 = (used2_buf[0] & recent_vec[0] |
		              used2_buf[1] & recent_vec[1] |
		              used2_buf[2] & recent_vec[2] |
		              used2_buf[3] & recent_vec[3]) & load_recent;

   assign hit3 = (used3_buf[0] & recent_vec[0] |
		              used3_buf[1] & recent_vec[1] |
		              used3_buf[2] & recent_vec[2] |
		              used3_buf[3] & recent_vec[3]) & load_recent;
   

   assign  used0_calc = load_recent          ?  recent_vec : used0_buf;
   assign  used1_calc = (hit3 | hit2 | hit1) ?  used0_buf  : used1_buf;
   assign  used2_calc = (hit3 | hit2)        ?  used1_buf  : used2_buf;
   assign  used3_calc = (hit3)               ?  used2_buf  : used3_buf;

   assign  used0_nxt = reset ? 4'b0001 : used0_calc;
   assign  used1_nxt = reset ? 4'b0010 : used1_calc;
   assign  used2_nxt = reset ? 4'b0100 : used2_calc;
   assign  used3_nxt = reset ? 4'b1000 : used3_calc;

   // use 4X4 matrix to hold lru info
   dff_s #(4) use0_reg(.din (used0_nxt),
		                 .q   (used0),
		                 .clk (clk), .se(se), .si(), .so());
   
   dff_s #(4) use1_reg(.din (used1_nxt),
		                 .q   (used1),
		                 .clk (clk), .se(se), .si(), .so());
   
   dff_s #(4) use2_reg(.din (used2_nxt),
		                 .q   (used2),
		                 .clk (clk), .se(se), .si(), .so());
   
   // used3 is lru
   dff_s #(4) use3_reg(.din (used3_nxt),
		                 .q   (used3),
		                 .clk (clk), .se(se), .si(), .so());

   assign  used23_nxt = used2_nxt | used3_nxt;
   
   dff_s #(4) use23_reg(.din (used23_nxt),
		                 .q   (used23),
		                 .clk (clk), .se(se), .si(), .so());
   

   // grant request based on lru

// save some loading on req_vec by not doing this   
//   assign  reqhit0 = (used0[0] & req_vec[0] |
//		      used0[1] & req_vec[1] |
//		      used0[2] & req_vec[2] |
//		      used0[3] & req_vec[3]);
   
   assign  reqhit1 = (used1[0] & req_vec[0] |
		                  used1[1] & req_vec[1] |
		                  used1[2] & req_vec[2] |
		                  used1[3] & req_vec[3]);
   
   assign  reqhit2 = (used2[0] & req_vec[0] |
		                  used2[1] & req_vec[1] |
		                  used2[2] & req_vec[2] |
		                  used2[3] & req_vec[3]);

   assign  reqhit3 = (used3[0] & req_vec[0] |
		                  used3[1] & req_vec[1] |
		                  used3[2] & req_vec[2] |
		                  used3[3] & req_vec[3]);

   assign  reqhit23 = (used23[0] & req_vec[0] |
		                   used23[1] & req_vec[1] |
		                   used23[2] & req_vec[2] |
		                   used23[3] & req_vec[3]);
   
   assign  sel_u3 = reqhit3;
   assign  sel_u2 = ~reqhit3 & reqhit2;
   assign  sel_u1 = ~reqhit23 & reqhit1;
   assign  sel_u0 = ~reqhit23 & ~reqhit1;
   
   assign  nosp_used0 = used0 & {4{~use_spec}};
   assign  nosp_used1 = used1 & {4{~use_spec}};
   assign  nosp_used2 = used2 & {4{~use_spec}};
   assign  nosp_used3 = used3 & {4{~use_spec}};

   mux4ds #(4) nsgnt_mux(.dout (nospec_grant),
		                     .in0  (nosp_used0),
		                     .in1  (nosp_used1),
		                     .in2  (nosp_used2),
		                     .in3  (nosp_used3),
		                     .sel0 (sel_u0),
		                     .sel1 (sel_u1),
		                     .sel2 (sel_u2),
		                     .sel3 (sel_u3));

   assign  spechit1 = (used1[0] & spec_vec[0] |
		                   used1[1] & spec_vec[1] |
		                   used1[2] & spec_vec[2] |
		                   used1[3] & spec_vec[3]);
   
   assign  spechit2 = (used2[0] & spec_vec[0] |
		                   used2[1] & spec_vec[1] |
		                   used2[2] & spec_vec[2] |
		                   used2[3] & spec_vec[3]);

   assign  spechit3 = (used3[0] & spec_vec[0] |
		                   used3[1] & spec_vec[1] |
		                   used3[2] & spec_vec[2] |
		                   used3[3] & spec_vec[3]);

   assign  spechit23 = (used23[0] & spec_vec[0] |
		                    used23[1] & spec_vec[1] |
		                    used23[2] & spec_vec[2] |
		                    used23[3] & spec_vec[3]);
   
   assign  sel_su3 = spechit3;
   assign  sel_su2 = ~spechit3 & spechit2;
   assign  sel_su1 = ~spechit23 & spechit1;
   assign  sel_su0 = ~spechit23 & ~spechit1;

   assign  sp_used0 = used0 & {4{use_spec}};
   assign  sp_used1 = used1 & {4{use_spec}};
   assign  sp_used2 = used2 & {4{use_spec}};
   assign  sp_used3 = used3 & {4{use_spec}};
   
   mux4ds #(4) sgnt_mux(.dout (spec_grant),
		                  .in0  (sp_used0),
		                  .in1  (sp_used1),
		                  .in2  (sp_used2),
		                  .in3  (sp_used3),
		                  .sel0 (sel_su0),
		                  .sel1 (sel_su1),
		                  .sel2 (sel_su2),
		                  .sel3 (sel_su3));

   assign  grant_vec = spec_grant | nospec_grant;
   

endmodule // sparc_ifu_lru4

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_milfsm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_ifqdp
//  Description:	
//  The IFQ is the icache fill queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













//`define MILFSM_NULL   4'b0000
//`define MILFSM_WAIT   4'b1000
//`define MILFSM_REQ    4'b1100
//`define MILFSM_FILL0  4'b1001
//`define MILFSM_FILL1  4'b1011

//`define MIL_V  3
//`define MIL_R  2
//`define MIL_A  1
//`define MIL_F  0


module sparc_ifu_milfsm(/*AUTOARG*/
   // Outputs
   so, fsm_ifc_errreq, fsm_ifc_wrt_tir, fsm_ifc_comp_valid, 
   fsm_ifc_mil_valid, fsm_ifc_mil_cancel, fsm_ifc_thr_ready, 
   fsm_ifc_pred_rdy, fsm_ifc_pcxreq, fsm_ifc_addrbit4_i2, 
   fsm_ifc_milchld, fsm_ifc_milstate, 
   // Inputs
   ifc_fsm_can_thisthr, ifc_fsm_fill_thisthr_i2, 
   ifc_fsm_wr_complete_f, ifqadv_i2, ifd_ifc_4bpkt_i2, 
   fcl_ifq_thr_s1, ifc_fsm_imiss_thisthr_s, ifc_fsm_milhit_s, 
   ifc_fsm_hiton_thismil_s, ifc_fsm_pcxaccept_thisthr, 
   ifc_fsm_miladdr4, clk, se, si, reset, ifc_fsm_err_thisthr
   );

   input       ifc_fsm_can_thisthr,        
	             ifc_fsm_fill_thisthr_i2;
   
   input       ifc_fsm_wr_complete_f;

   input       ifqadv_i2;

   input       ifd_ifc_4bpkt_i2;
   input [1:0] fcl_ifq_thr_s1;             
   input       ifc_fsm_imiss_thisthr_s;
   input       ifc_fsm_milhit_s;
	 input       ifc_fsm_hiton_thismil_s,
               ifc_fsm_pcxaccept_thisthr;
   input       ifc_fsm_miladdr4;

   input       clk, 
               se, 
               si, 
               reset;

   input       ifc_fsm_err_thisthr;
   

   output      so;

   output      fsm_ifc_errreq;
   output      fsm_ifc_wrt_tir;

   output      fsm_ifc_comp_valid,
	             fsm_ifc_mil_valid,
               fsm_ifc_mil_cancel,
	             fsm_ifc_thr_ready;
   output      fsm_ifc_pred_rdy,
	             fsm_ifc_pcxreq,
	             fsm_ifc_addrbit4_i2;
	 
   output [2:0] fsm_ifc_milchld;

   output [3:0] fsm_ifc_milstate;
	 

//----------------------------------------------------------------------
// Declarations
//----------------------------------------------------------------------


   // local variables
   reg [3:0] 	next_state;

   wire [3:0] 	milstate;

   wire [2:0]   local_milchld;
   
   wire 	milchld_valid;

   wire   fill_this16b;
   

   wire 	cancel_mil,
		      cancel_next;
   wire 	err_pending,
		      err_pending_next;
   
   wire 	valid_d1,
		valid_i2;
   
   wire [2:0] 	next_milchld;


   // Missed Instruction List State Machine
   // 3   - valid
   // 2   - req
   // 1   - addr for fill fill (1/0)
   // 0   - fill
   //
   // 2   - child valid
   // 1:0 - child thr ptr
   //


   always @(/*AUTOSENSE*/err_pending or ifc_fsm_err_thisthr
            or ifc_fsm_fill_thisthr_i2 or ifc_fsm_imiss_thisthr_s
            or ifc_fsm_milhit_s or ifc_fsm_pcxaccept_thisthr
            or ifc_fsm_wr_complete_f or ifd_ifc_4bpkt_i2 or ifqadv_i2
            or milstate)
     begin
	      case (milstate)  //  synopsys parallel_case
	        4'b0000: // null
	          begin
	             //ic_wrreq_i2 = 1'b0;	       
	             //  orphan_chld = 1'b0;
               next_state[1:0] = 2'b0;
               if (ifc_fsm_err_thisthr | ifc_fsm_imiss_thisthr_s)
		             begin
		                next_state[3] = 1'b1;
		                if (ifc_fsm_milhit_s & ~ifc_fsm_err_thisthr) 
		                  next_state[2] = 1'b0;  // MILFSM_WAIT
		                else
		                  next_state[2] = 1'b1;  // MILFSM_REQ;
		             end
	             else
		             next_state = milstate;
	          end // case: begin...
	        
	        4'b1100:  // req
	          begin
	             // ic_wrreq_i2 = 1'b0;		
	             // if canthr=1, the request will not be sent out in this cycle.
               if ((ifc_fsm_pcxaccept_thisthr) &
                   ~(ifc_fsm_err_thisthr | err_pending))
                 // two requests are made when there is an error.
                 // one, with errbit=1 gets back in invalidate response, 
                 // the other, with errbit=0, gets the regular ifill 
                 // return
		             begin
		                // we invalidate the icache on detecting an error
		                // only if this wasn't an MIL hit as well.  If it
		                // was an MIL we would have gone to the wait state
		                // already and it is too late to invalidate the cache
		                next_state = 4'b1000;
                    //		    orphan_chld = 1'b0;		    
		             end
//	             else if ((cancel_mil | ifc_fsm_can_thisthr) & 
//                        ~milchld_valid & ~ifc_fsm_hiton_thismil_s)
//		             begin
//		                next_state = `MILFSM_NULL;
//		             end
	             else
		             begin
		                next_state = milstate;
                    //		    orphan_chld = 1'b0;
		             end 
	          end // case: 4'b1100
          
	        4'b1000: // wait
	          begin
               //	       orphan_chld = 1'b0;
	             if (ifc_fsm_fill_thisthr_i2)
		             begin
		                // ic_wrreq_i2 = 1'b1;
                    if (ifd_ifc_4bpkt_i2 & ifqadv_i2) // 4B ifill from IOB
                      // don't want to advance too quickly and get fasle compl
                      next_state = 4'b0000;
                    else if (~ifd_ifc_4bpkt_i2)
		                  next_state = 4'b1001;
                    else
                      next_state = milstate;
		             end
	             else
		             begin
		                next_state = milstate;
		                //ic_wrreq_i2 = 1'b0;		    
		             end
	          end // case: 4'b1000
	        
	        4'b1001: // fill0
	          begin
               //	       orphan_chld = 1'b0;
               if (ifc_fsm_wr_complete_f)
		             begin
		                next_state = 4'b1011;
		                //ic_wrreq_i2 = 1'b1;
		             end
	             else
		             begin
		                next_state = milstate;
		                //ic_wrreq_i2 = 1'b1;
		             end
	          end // case: 4'b1001
          
	        4'b1011: // fill1
	          // Do we really need this state??  yes, to start thr
	          begin
               //	       orphan_chld = 1'b0;		    
	             if (ifc_fsm_wr_complete_f)
		             begin
		                //ic_wrreq_i2 = 1'b0; 		    
                    //		    if (delay_mil | ifc_fsm_imiss_thisthr_s)
                    //		      next_state = `MILFSM_REQ;
                    //		    else
		                next_state = 4'b0000;
		             end
	             else
		             begin
		                //ic_wrreq_i2 = 1'b1;
		                next_state = milstate;
		             end // else: !if(ifc_fsm_wr_complete_f)
	          end // case: 4'b10001
          
	        default:
	          begin
               // synopsys translate_off
		     // 0in <fire -message "MILSTATE, Error: SPARC/IFU/MILFSM: unknown state!"


               if ($time > (4* 1333))
                 begin
					$display ("MILSTATE", 
                            "Error: SPARC/IFU/MILFSM: unknown state! %b\n",milstate);
                    $finish();
                 end

               // synopsys translate_on               
	             next_state = milstate;
	             //ic_wrreq_i2 = 1'b0;		    
               //	       orphan_chld = 1'b0;	
	          end // case: default
	      endcase // casex(milstate)
     end // always @ (...
   

   // MIL state reg
   dffr_s #(4) milst_reg(.din  (next_state[3:0]),
		                   .q    (milstate[3:0]),
		                   .clk  (clk),
		                   .rst  (reset),
		                   .se   (se), .si(), .so());

   // Cancel - Delay state machine
   // -- not used anymore
   // C D
   // 0 0  - null
   // 1 0  - current thread cancelled but pending from L2
   // 1 1  - one ifill pending from L2, current thread will be sent
   //        out after that.
   
//   assign cancel_next = (ifc_fsm_can_thisthr | 
//			                   cancel_mil) & next_state[`MIL_V];    // reset wins

   assign cancel_next = (ifc_fsm_can_thisthr | cancel_mil) & 
                          (milstate[3] | ifc_fsm_imiss_thisthr_s |
                           ifc_fsm_err_thisthr);    // reset wins

   dffr_s #(1) can_ff(.din  (cancel_next),
		                .q    (cancel_mil),
		                .clk  (clk),
		                .rst  (reset),
		                .se   (se), .si(), .so());

   // track if we need to send out an error request
   assign err_pending_next = (ifc_fsm_err_thisthr & 
	                      (milstate[2] | ~milstate[3]) |
//	                      err_pending & next_state[`MIL_V]) &	
                        err_pending & milstate[3]) &
	                      ~ifc_fsm_pcxaccept_thisthr;
                         // & ~ifc_fsm_can_thisthr;
   
   dffr_s #(1) err_ff(.din (err_pending_next),
		                .q   (err_pending),
		                .clk (clk),
		                .rst (reset), .se(se), .si(), .so());
   assign fsm_ifc_errreq = err_pending;

   // Track secondary hits
   assign next_milchld[2] = ifc_fsm_hiton_thismil_s |    // hit on MIL by
   	                                                     // someone else
              			    fsm_ifc_milchld[2] & milstate[3]; // reset

   assign next_milchld[1:0] = ifc_fsm_hiton_thismil_s ? fcl_ifq_thr_s1 :
			                                                  fsm_ifc_milchld[1:0];

   dffr_s #(3) milchld_reg(.din  (next_milchld),
		                     .clk  (clk),
		                     .rst  (reset),
		                     .q    (local_milchld),
		                     .se   (se), .si(), .so());

   assign fsm_ifc_milchld[2] = local_milchld[2] & milstate[3];
   assign fsm_ifc_milchld[1:0] = local_milchld[1:0];
   
   assign milchld_valid = local_milchld[2] & milstate[3];

//   assign fsm_ifc_addrbit4_i2 = milstate[`MIL_F];
   assign fsm_ifc_addrbit4_i2 = milstate[0] & milstate[3] & 
                                (milstate[1] | ifc_fsm_wr_complete_f); 

   // determine if we want to fill from the first pkt or second pkt
   assign fill_this16b = ~(milstate[0] ^ ifc_fsm_miladdr4) |
                            ifd_ifc_4bpkt_i2;

   // write to thread inst reg (TIR)
//   assign fsm_ifc_wrt_tir =  (next_state[`MIL_F]) & ~cancel_mil & 
//	                     ifc_fsm_fill_thisthr_i2;
   assign fsm_ifc_wrt_tir =  (milstate[3] & ~milstate[2]) & 
			                         ~(cancel_mil | ifc_fsm_can_thisthr) & 
                               ifc_fsm_fill_thisthr_i2 &
                               fill_this16b;
	  
   // write to Icache 
//   assign fsm_ifc_wrreq_i2 = ic_wrreq_i2;
   assign valid_i2 = milstate[3] & ~fsm_ifc_thr_ready;
   
   dff_s vld_ff(.din (valid_i2),
	            .q   (valid_d1),
	            .clk (clk),
	            .se  (se), .si(), .so());

   // signal thread completion
   assign fsm_ifc_thr_ready = milstate[3] & milstate[0] &
	                      milstate[1] & ifc_fsm_wr_complete_f |
	                      ~milstate[3] & valid_d1;

   // predict ready assuming 2nd ifill happens in the next cycle
   assign fsm_ifc_pred_rdy =  milstate[3] & milstate[0] &
                              (ifc_fsm_wr_complete_f |
                               milstate[1]); //  & ifc_fsm_fill_thisthr_i2
   
   // set compare valid for mil hit signal
   assign fsm_ifc_comp_valid = milstate[3] &     // valid entry
	                             ~milstate[0] &    // not f0 or f1
                               ~milchld_valid;        // no chld already

   assign fsm_ifc_mil_valid = milstate[3];
   assign fsm_ifc_mil_cancel = cancel_mil;
   
   // In the request state or if we need to send an error invalidate, 
   // ask for bus from LSU. 
//   assign fsm_ifc_pcxreq = (milstate[`MIL_V] & milstate[`MIL_R] |
//			    err_pending | ifc_fsm_err_thisthr) & 
//	                   ~ifc_fsm_pcxaccept_thisthr & 
//                            (milchld_valid | ~cancel_mil);

//   assign fsm_ifc_pcxreq = (milstate[`MIL_V] & milstate[`MIL_R] & 
//	                          ~ifc_fsm_pcxaccept_thisthr & 
//                            (milchld_valid | ~cancel_mil));

   // removed pcx_accept from critical path
   assign fsm_ifc_pcxreq = milstate[3] & milstate[2];

   assign fsm_ifc_milstate = milstate;

   
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par16.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par16
//  Description:        
//    Generates 34b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par16 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [15:0] in;
   output 	out;

   assign  out = (^in[15:0]);

endmodule // sparc_ifu_par16

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par32.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par32
//  Description:        
//    Generates 32b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par32 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [31:0] in;
   output 	out;

   assign  out = (^in[31:0]);

endmodule // sparc_ifu_par32

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_par34.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_par34
//  Description:        
//    Generates 34b parity.  Odd number of ones => out = 1
*/

module sparc_ifu_par34 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [33:0] in;
   output 	out;

   assign  out = (^in[33:0]);

endmodule // sparc_ifu_par34

   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_swl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_swl
//  Description:	
//  The switch logic manages the 4 threads.  It schedules the next
//  thread to be executed.   
*/
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_swl(/*AUTOARG*/
   // Outputs
   swl_sscan_thrstate, so, dtu_reset, swl_dec_mulbusy_e, 
   swl_dec_divbusy_e, swl_dec_fpbusy_e, swl_dec_fp_enable_d, 
   swl_dec_ibe_e, dtu_fcl_ntr_s, dtu_fcl_running_s, 
   dtu_fcl_rollback_g, dtu_fcl_retract_d, dtu_fcl_thr_active, 
   dtu_fcl_nextthr_bf, swl_dcl_thr_d, swl_dcl_thr_w2, 
   esl_fcl_stall_bf, esl_fcl_switch_bf, esl_fdp_sync_pcs_bf,
   esl_fcl_ntr_s, esl_fdp_issue_prev_inst_s, esl_fcl_force_running_s,
   dtu_fdp_thrconf_e, 
   // Inputs
   rclk, se, si, gdbginit_l, arst_l, grst_l, ctu_sscan_tid, 
   ifq_dtu_thrrdy, ifq_dtu_pred_rdy, ifu_tlu_inst_vld_w, 
   ifu_tlu_ttype_vld_m, fcl_dtu_hprivmode_d, fcl_dtu_hprivmode_w2, 
   tlu_ifu_flush_pipe_w, fcl_swl_flush_w, fcl_dtu_sync_intr_d, 
   fcl_dtu_nuke_thr_w, fcl_dtu_rst_thr_w, fcl_dtu_resum_thr_w, 
   fcl_dtu_thr_f, tlu_hpstate_ibe, lsu_ifu_ldsta_internal_e, 
   tlu_ifu_trappc_vld_w1, dec_swl_ll_done_d, dec_swl_br_done_d, 
   dec_swl_rdsr_sel_thr_d, dec_swl_std_inst_d, dec_swl_sta_inst_e, 
   wsr_fixed_inst_w, dec_swl_ld_inst_d, dec_swl_mul_inst_d, 
   dec_swl_div_inst_d, dec_swl_fpop_d, dec_swl_allfp_d, 
   dec_swl_frf_upper_d, dec_swl_frf_lower_d, dec_swl_wrtfprs_w, 
   dcl_swl_tcc_done_m, exu_ifu_longop_done_g, exu_ifu_spill_e, 
   lsu_ifu_ldst_cmplt, lsu_ifu_dc_parity_error_w2, lsu_ifu_stbcnt0, 
   lsu_ifu_stbcnt1, lsu_ifu_stbcnt2, lsu_ifu_stbcnt3, 
   lsu_ifu_quad_asi_e, ffu_ifu_fpop_done_w2, ffu_ifu_tid_w2, 
   ffu_ifu_fst_ce_w, tlu_ifu_trap_tid_w1, tlu_ifu_pstate_pef, 
   lsu_ifu_ldst_miss_g, fcl_swl_int_activate_i3, 
   fcl_swl_flush_wake_w, ifq_swl_stallreq, fcl_dtu_stall_bf, 
   fcl_swl_swout_f, fcl_swl_swcvld_s, fdp_fcl_swc_s2, 
   fcl_ifq_icmiss_s1, fcl_dtu_inst_vld_e, fcl_dtu_intr_vld_e, 
   fcl_dtu_inst_vld_d, erb_dtu_ifeterr_d1, dtu_inst_anull_e, 
   const_cpuid, thr_config_in_m, dec_swl_wrt_tcr_w, 
   dec_swl_st_inst_d, extra_longlat_compl, config_dtu_esl_en, 
   config_dtu_esl_sync_method, config_esl_lfsr_seed, 
   config_esl_lfsr_ld, config_esl_pc_diff_thresh, config_esl_counter_timeout, 
   fdp_esl_t0inst_next_s2, 

   fdp_esl_t1inst_next_s2, 














   fdp_esl_t0inst_paddr_next_s2,

   fdp_esl_t1inst_paddr_next_s2, 














   fdp_esl_t0pc_next_s2, 

   fdp_esl_t1pc_next_s2,














   fcl_esl_tinst_vld_next_s,
   fcl_esl_brtaken_e, fcl_esl_brtaken_m, fcl_esl_thr_e, fcl_esl_thr_m,
   fcl_esl_inst_vld_d, fcl_esl_inst_vld_e, fcl_esl_inst_vld_m, fcl_esl_thr_trap_bf,
   fcl_esl_rb_stg_s, dcl_esl_br_inst_d, dcl_esl_br_inst_e, fdp_esl_brtrp_target_pc_bf_f,

   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data

   );

   input       rclk, 
               se, 
               si,
               gdbginit_l,
               arst_l,
               grst_l;

   input [3:0] ctu_sscan_tid;   // guaranteed one-hot by ctu

   input [3:0] ifq_dtu_thrrdy;	      // ifq completion signals
   input [3:0] ifq_dtu_pred_rdy;	    // ifq almost done

   input       ifu_tlu_inst_vld_w,    //
	             ifu_tlu_ttype_vld_m;
   input       fcl_dtu_hprivmode_d;
   input       fcl_dtu_hprivmode_w2;
   input       tlu_ifu_flush_pipe_w;  // flush after a trap
   input       fcl_swl_flush_w;
   input       fcl_dtu_sync_intr_d;   // interrupt
   input       fcl_dtu_nuke_thr_w;    // sync suspend
   input       fcl_dtu_rst_thr_w;    // 
   input       fcl_dtu_resum_thr_w;    // 
   input [3:0] fcl_dtu_thr_f;

   input [3:0] tlu_hpstate_ibe;
   
   input       lsu_ifu_ldsta_internal_e,// sta to local reg
	             tlu_ifu_trappc_vld_w1, // trap completion
	             dec_swl_ll_done_d,   // rdsr completion
               dec_swl_br_done_d,
	             dec_swl_rdsr_sel_thr_d,
	             dec_swl_std_inst_d,    //
	             dec_swl_sta_inst_e,    // state change
	             wsr_fixed_inst_w,      // wrspr completion
	             dec_swl_ld_inst_d;     // load hit/compl. speculation

   input       dec_swl_mul_inst_d,
	             dec_swl_div_inst_d;
   input       dec_swl_fpop_d,
	             dec_swl_allfp_d;

   input       dec_swl_frf_upper_d,
	             dec_swl_frf_lower_d,
	             dec_swl_wrtfprs_w;
   
   input       dcl_swl_tcc_done_m;

   input [3:0] exu_ifu_longop_done_g; // save, restore, div, mul compl.
   input       exu_ifu_spill_e;
   input [3:0] lsu_ifu_ldst_cmplt;
   input       lsu_ifu_dc_parity_error_w2;

   input [3:0] lsu_ifu_stbcnt0,
	             lsu_ifu_stbcnt1,
	             lsu_ifu_stbcnt2,
	             lsu_ifu_stbcnt3;

//   input [3:0] lsu_ifu_stq_busy;
   input       lsu_ifu_quad_asi_e;
	 
   input       ffu_ifu_fpop_done_w2;
   input [1:0] ffu_ifu_tid_w2;
   input       ffu_ifu_fst_ce_w;
   
   input [1:0] tlu_ifu_trap_tid_w1;

   input [3:0] tlu_ifu_pstate_pef;

   input       lsu_ifu_ldst_miss_g;   // dcache hit or miss
   
   input [3:0] fcl_swl_int_activate_i3; // wake up thread on interrupt
   input       fcl_swl_flush_wake_w;

   // TBD: with the latest changes fcl_dtu_switch_s = dtu_fcl_ntr_s, so 
   // this input can be removed.
//   input       fcl_dtu_switch_s; // switch out curr, sw in next

   input       ifq_swl_stallreq;

   input       fcl_dtu_stall_bf,
               fcl_swl_swout_f,       // curr thread is stalled
	             fcl_swl_swcvld_s,
               fdp_fcl_swc_s2,        // thread stall condition
	             fcl_ifq_icmiss_s1;     // icache miss
   input       fcl_dtu_inst_vld_e,
               fcl_dtu_intr_vld_e,
	             fcl_dtu_inst_vld_d;

   input       erb_dtu_ifeterr_d1;

   input       dtu_inst_anull_e;      // anull delay slot

   input [3:0] const_cpuid;           // use 4 bits to allow future
                                      // expansion to 16 cores

   input [2:0] thr_config_in_m;       // write data to thread status reg
   input       dec_swl_wrt_tcr_w;     // write signal for thr status reg
   input       dec_swl_st_inst_d;

   input [3:0] extra_longlat_compl;   // spare signal, not used
  
   input       config_dtu_esl_en;       // Configuration for ESL - Enable signal
   input [1:0] config_dtu_esl_sync_method; // Configuration for ESL - Synchronization method

   input [15:0] config_esl_lfsr_seed;   // Configuration for ESL - LFSR seed
   input        config_esl_lfsr_ld;      // Configuration for ESL - LFSR load seed
 
   input [49:0] config_esl_pc_diff_thresh; // Configuration for ESL - STSM PC diff threshold
   input [15:0] config_esl_counter_timeout; // Configuration for ESL - STSM timeout
  
   input [32:0] fdp_esl_t0inst_next_s2;

   input [32:0] fdp_esl_t1inst_next_s2;















   input [39:2] fdp_esl_t0inst_paddr_next_s2;

   input [39:2] fdp_esl_t1inst_paddr_next_s2;















   input [48:0] fdp_esl_t0pc_next_s2;

   input [48:0] fdp_esl_t1pc_next_s2;














   
   input [3:0]  fcl_esl_tinst_vld_next_s;
   input        fcl_esl_brtaken_e;
   input        fcl_esl_brtaken_m;
   input [3:0]  fcl_esl_thr_e;
   input [3:0]  fcl_esl_thr_m;
   input        fcl_esl_inst_vld_d;
   input        fcl_esl_inst_vld_e;
   input        fcl_esl_inst_vld_m;
   input [3:0]  fcl_esl_thr_trap_bf;
   input        fcl_esl_rb_stg_s;

   input        dcl_esl_br_inst_d;
   input        dcl_esl_br_inst_e;

   input [3:0]  fdp_esl_brtrp_target_pc_bf_f;

   // jtag interface
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

   output [10:0] swl_sscan_thrstate;
   output        so;
   
   output      dtu_reset;

   output      swl_dec_mulbusy_e,
	             swl_dec_divbusy_e,
	             swl_dec_fpbusy_e,
	             swl_dec_fp_enable_d;

   output      swl_dec_ibe_e;
   
   // to fcl
   output      dtu_fcl_ntr_s,         // next thread ready
               dtu_fcl_running_s,
	             dtu_fcl_rollback_g,    // rollback on spec
	             dtu_fcl_retract_d;     // rollback on hw hazard

   output [3:0] dtu_fcl_thr_active;   // currently active threads
   
   output [3:0] dtu_fcl_nextthr_bf,   // thread to switch to when ntr=1
		            swl_dcl_thr_d,
		            swl_dcl_thr_w2;

   output       esl_fcl_stall_bf;
   output       esl_fcl_switch_bf;
   output       esl_fdp_sync_pcs_bf;

   output       esl_fcl_ntr_s;
   output       esl_fdp_issue_prev_inst_s;
   output       esl_fcl_force_running_s;

   // to fdp
   output [40:0] dtu_fdp_thrconf_e;   // thread conf for RDSR inst

//----------------------------------------------------------
// Declarations
//----------------------------------------------------------
   // local signals
//   wire [3:0]    count_nxt,
//	               count;
//   wire          proc0;
//   wire          start_on_rst;

   wire [3:0]    lru_fcl_nextthr_bf;   // thread to switch to when ntr=1 from lru
   wire [3:0]    esl_fcl_nextthr_bf;   // thread to switch to when ntr=1 from esl

   wire          esl_fdp_issue_prev_inst_next_s;

   wire [3:0]    swl_esl_thr_urdy;      // Input to ESL for which threads are ready
   wire [3:0]    swl_esl_thr_sprdy;

   wire          swl_esl_icmiss_out;

   wire          ibe_d,
                 ibe_e;

   wire [3:0]    completion,
		             wm_imiss,
		             wm_other,
		             spec_ld_d,
		             issue_spec_ld,
		             ldmiss,
		             ldhit_thr,
		             spec_ld_g,
		             imiss,
		             trap,
                 ldmiss_non_crit,
                 ldmiss_crit,
		             trp_no_retr,
//		             rb_thr_w,
                 rt_st_thr_d,
                 rt_st_thr_e,
		             schedule,
		             int_activate,
		             start_thread,
                 thaw_thread,
		             resum_thread,
		             nuke_thread,
		             rst_thread;

   wire          rollback_g,
                 rb_en_g,
                 rollback_g_l,
                 rollback_w2;
   

   wire          sched_nt;
   
   wire [3:0]    fixedop_done,
		             wsr_done_w3;

   wire          wsr_inst_w2,
                 wsr_inst_w3;
   
   wire          wsr_fixed_qual_w,
                 wsr_fixed_w2;

   wire          llinst_done_e;
   
   wire [3:0]    ll_done_e,
                 branch_done_d,
                 std_tcc_done_m;

   wire          sta_done_e,
		             killed_inst_done_e;
   wire [3:0]    killed_uniop_done_e;

   wire          uniop_d,
		             uniop_e;

//   wire          no_iftrap_m,
//                 no_iftrap_w;

   wire [3:0]    thr_s1,
                 thr_s2,
		             thr_f,
		             thr_d,
		             thr_e,
		             thr_m,
		             thr_w,
                 st_thr_w2,
		             st_thr_w3;

   wire          flush_pipe_w_nxt,
                 flush_all_w,
                 flush_pipe_w2,
                 flush_done_w,
                 fp_flush_done_w2,
                 fp_flush_done_w3,
		             flush_done_w2;

   wire          rbfor_fst_ce_w;
   
   wire [3:0]    flush_wake_w2,
                 fp_flush_wake_w3,
                 halt_thread;
   
   wire          wrt_spec_w,
                 wrt_spec_w2,
                 halt_w,
                 halt_w2,
		             en_spec_d,
		             en_spec_m,
		             en_spec_g,
		             spec_next;
   

   wire          ld_inst_e,
		             ld_inst_next_e,
                 ld_inst_qual_d,
		             ld_inst_m,
		             ld_inst_unq_w,
		             ld_inst_w,
                 ld_inst_w2;
	 
   wire          switch_out,
	               sw_cond_s,
	               swc_d,
	               swc_next_d,
	               swc_e;

   wire          trp_noretr_d;
   
   wire [3:0]    all_stall;

   wire [3:0]    rdy,
	               sprdy_or_urdy,
                   sprdy_or_urdy_next;

   wire          running_s2,
                 atr_s;

   wire [4:0]    thr0_state,
		             thr1_state,
		             thr2_state,
		             thr3_state;

  wire [4:0]    thr0_nstate,
                thr1_nstate,
                thr2_nstate,
                thr3_nstate;

   wire          use_spec;

   wire [3:0]    wrt_tcr_w2;

   wire [1:0]    enc_thr_d;

   wire          rd_thract_d,
		             rd_thract_e;
   wire [51:0]   fmt_thrconf_e,
                 thrconf_out_e,
                 fmt_thrconf_adj;

   wire          hprivmode_e,
                 rdsr_sel_thr_e;
   
   wire [2:0]    rd_tid_spec_e;

   wire [3:0]    mul_busy_d,
		             mul_busy_e,
		             div_busy_d,
		             div_busy_e,
		             fp_busy_d,
		             fp_busy_e;

   wire          true_fpbusy_e,
                 fpbusy_local_e,
                 true_mulbusy_e,
                 true_divbusy_e;

   wire          fbusy_nxt_d,
                 fbusy_crit_e,
                 fbusy_d3,
                 fbusy_d0,
                 fbusy_d1,
                 fbusy_d2,
                 dbusy_d3,
                 dbusy_d0,
                 dbusy_d1,
                 dbusy_d2,
                 mbusy_d3,
                 mbusy_d0,
                 mbusy_d1,
                 mbusy_d2;

   wire [3:0]    mul_wait,
		             mul_wait_nxt,
		             div_wait,
		             div_wait_nxt,
		             fp_wait,
		             fp_wait_nxt;

   wire          mul_wait_any,
		             div_wait_any,
		             fp_wait_any;

   wire [3:0]    mul_wake,
		             div_wake,
		             fp_wake;

   wire [3:0]    exu_lop_done,
		             mul_done,
		             div_done,
		             fp_done;

   wire [3:0]    retr_thr_wakeup;
   wire [3:0]    trap_thrrdy,
		             trap_thr;

   wire [3:0]    fp_thr,
		             fp_thrrdy;

   wire          same_thr_de,
		             same_thr_dg,
                 same_thr_fd,
                 same_thr_fe,
		             same_thr_fm,                 
		             same_thr_fg;


   wire          st_thisthr_e;
   
   wire          st_inst_e,
		             st_inst_qual_d,
		             st_inst_qual_e,
 		             st_inst_m,
 		             st_inst_g;
   
   wire          pipe_st_cnt_ge1,
 		             pipe_st_cnt_ge2,
 		             pipe_st_cnt_ge3;
   
   wire          pipe_st_d,
                 pipe_st_e,
 		             pipe_st_m,
 		             pipe_st_g;

   wire          all_dst_ge1,
 		             all_dst_ge2,
 		             all_dst_ge3,
 		             all_dst_eq4;

   wire          dst_cnt_ge1,
 		             dst_cnt_ge2,
 		             dst_cnt_ge3;
   
   
   wire [3:0]    stbcnt_s,
		             stbcnt_d;

   wire [3:0]    stb_stall,
		             stb_blocked,
		             stb_blocked_d1,
		             st_in_pipe,
		             stb_retry,
		             wm_stbwait,
		             stb_wait_nxt;
   
   wire          switch_store_d,
//		             retract_stall_d,
		             retract_store_e,
                 retract_st_next_d,
		             retract_store_d;

   wire          retract_iferr_d,
                 iferr_s,
                 iferr_d;

   wire          clear_wmo_e;

   wire          sw_st_e,
		             sw_st_m,
		             sw_st_g,
		             sw_st_w2;

   wire          std_inst_e;
//		             stq_inst_e,
//		             stq_inst_m,
//		             stq_inst_w,
//		             stq_inst_w2;
   wire          std_done_e;
   wire          std_done_m;
//   wire [3:0]    stq_busy,
//		             stq_in_pipe,
//		             stq_wait,
//		             stq_wait_next,
//		             stq_done_thr;

   wire [2:0]    fprs0,
		             fprs1,
		             fprs2,
		             fprs3,
		             fprs_d,
		             fprs_e,
		             fprs_wrt_data,
                 thr_config_in_w,
                 thr_config_in_w2,
		             fprs0_nxt,
		             fprs1_nxt,
		             fprs2_nxt,
		             fprs3_nxt;

   wire [1:0]    new_fprs;

   wire [3:0]    fprs_en_s,
		             fpen_vec_s;

   wire          wrt_fprs_w,
                 wrt_fprs_w2;
   
   wire [3:0]    sel_wrt,
		             fprs_sel_set,
		             fprs_sel_wrt,
		             fprs_sel_old;

   wire          fpen_s;

   wire [1:0]    trap_tid_w2;
   wire          trappc_vld_w2;

   wire          dtu_reset_l;
   wire          sched_reset;
   
   wire          clk;
   
   //
   // Code Begins Here
   //

   assign        clk = rclk;
   
   // reset buffer
   dffrl_async rstff(.din (grst_l),
                        .q   (dtu_reset_l),
                        .clk (clk), .se(se), .si(), .so(),
                        .rst_l (arst_l));

   assign       dtu_reset = ~dtu_reset_l;
   

   //---------------------------------------------
   // Start off thread on reset using this counter
   //---------------------------------------------
//   dffr #(4) thrrdy_ctr(.din (count_nxt),
//		                    .clk (clk),
//		                    .q   (count),
//		                    .rst (dtu_reset),
//		                    .se (se), .si(), .so());
//
//   // count_nxt = count + 1, sticky at 8 = 1111
//   assign count_nxt[0] = ~count[0] | count[3];
//   assign count_nxt[1] = (count[1] ^ count[0]) | count[3];
//   assign count_nxt[2] = (count[2] ^ (count[1] & count[0])) | count[3]; 
//   assign count_nxt[3] = (count[3] ^ (count[2] & count[1] & count[0])) |
//	                       count[3]; 
//
//   assign proc0 = (const_cpuid == 4'b0000) ? 1'b1 : 1'b0;
//   assign start_on_rst = (~count[3] & count[2] & count[1] & count[0])
//                          & proc0;

//`ifdef IFU_SAT   
//   // temporary hack to start threads
//   reg [3:0]  auto_start;
//   always @ (posedge clk)
//     auto_start = 4'b0000;
//`endif
   
   //-----------------
   // completion logic
   //-----------------
   sparc_ifu_thrcmpl compl(
                           .reset       (dtu_reset),
			                     /*AUTOINST*/
                           // Outputs
                           .completion  (completion[3:0]),
                           .wm_imiss    (wm_imiss[3:0]),
                           .wm_other    (wm_other[3:0]),
                           .swl_esl_icmiss_out (swl_esl_icmiss_out),
                           // Inputs
                           .clk         (clk),
                           .se          (se),
                           .si          (si),
                           .fcl_ifq_icmiss_s1(fcl_ifq_icmiss_s1),
                           .erb_dtu_ifeterr_d1(erb_dtu_ifeterr_d1),
                           .sw_cond_s   (sw_cond_s),
                           .en_spec_g   (en_spec_g),
                           .atr_s       (atr_s),
                           .dtu_fcl_thr_active(dtu_fcl_thr_active[3:0]),
                           .ifq_dtu_thrrdy(ifq_dtu_thrrdy[3:0]),
                           .ifq_dtu_pred_rdy(ifq_dtu_pred_rdy[3:0]),
                           .exu_lop_done(exu_lop_done[3:0]),
                           .branch_done_d(branch_done_d[3:0]),
                           .fixedop_done(fixedop_done[3:0]),
                           .ldmiss      (ldmiss[3:0]),
                           .spec_ld_d   (spec_ld_d[3:0]),
                           .trap        (trap[3:0]),
                           .retr_thr_wakeup(retr_thr_wakeup[3:0]),
                           .flush_wake_w2(flush_wake_w2[3:0]),
                           .ldhit_thr   (ldhit_thr[3:0]),
                           .spec_ld_g   (spec_ld_g[3:0]),
                           .clear_wmo_e (clear_wmo_e),
                           .wm_stbwait  (wm_stbwait[3:0]),
                           .stb_retry   (stb_retry[3:0]),
                           .rst_thread  (rst_thread[3:0]),
                           .trap_thrrdy (trap_thrrdy[3:0]),
                           .thr_s2      (thr_s2[3:0]),
                           .thr_e       (thr_e[3:0]),
                           .thr_s1      (thr_s1[3:0]),
                           .fp_thrrdy   (fp_thrrdy[3:0]),
                           .lsu_ifu_ldst_cmplt(lsu_ifu_ldst_cmplt[3:0]),
                           .sta_done_e  (sta_done_e),
                           .killed_inst_done_e(killed_inst_done_e));

   //------------
   // Thread Pipe
   //------------
   assign thr_f = fcl_dtu_thr_f;

//   assign thr_dec_f[0] = thr_f[0] | rst_tri_en;
//   assign thr_dec_f[3:1] = thr_f[3:1] & {3{~rst_tri_en}};

//   assign thr_dec_d[0] = thr_d[0] | rst_tri_en;
//   assign thr_dec_d[3:1] = thr_d[3:1] & {3{~rst_tri_en}};


   dff_s #(4) thrd_reg(.din  (thr_f[3:0]),
		   .clk  (clk),
		   .q    (thr_d[3:0]),
		   .se   (se), .si(), .so());

   assign     swl_dcl_thr_d = thr_d;

   dff_s #(4) thre_reg(.din  (thr_d),
		   .clk  (clk),
		   .q    (thr_e),
		   .se   (se), .si(), .so());

   dff_s #(4) thrm_reg(.din  (thr_e),
		   .clk  (clk),
		   .q    (thr_m),
		   .se   (se), .si(), .so());
   dff_s #(4) thrw_reg(.din  (thr_m),
		   .clk  (clk),
		   .q    (thr_w),
		   .se   (se), .si(), .so());

   dff_s #(4) thrw2_reg(.din  (thr_w),
		    .clk  (clk),
		    .q    (st_thr_w2),
		    .se   (se), .si(), .so());

   dff_s #(4) thrw3_reg(.din  (st_thr_w2),
		    .clk  (clk),
		    .q    (st_thr_w3),
		    .se   (se), .si(), .so());

   assign     swl_dcl_thr_w2 = st_thr_w2;

   // send ibe of curr thread to dec
   assign ibe_d = (thr_d[0] & tlu_hpstate_ibe[0] |
                   thr_d[1] & tlu_hpstate_ibe[1] |
                   thr_d[2] & tlu_hpstate_ibe[2] |
                   thr_d[3] & tlu_hpstate_ibe[3]);

   dff_s #(1) ibee_ff(.din (ibe_d),
                    .q   (ibe_e),
                    .clk (clk), .se(se), .si(), .so());
   assign swl_dec_ibe_e = ibe_e;

//----------------------------------------------------------------------
// Track Thread Execution
//----------------------------------------------------------------------

   // track instructions
   dff_s #(1) lle_ff(.din (dec_swl_ll_done_d),
                   .q   (llinst_done_e),
                   .clk (clk), .se (se), .si(), .so());
                   
   assign ll_done_e = thr_e & {4{llinst_done_e & fcl_dtu_inst_vld_e & 
                                 ~exu_ifu_spill_e}};
   assign std_tcc_done_m = thr_m & {4{dcl_swl_tcc_done_m | std_done_m}};

   assign wsr_fixed_qual_w  = wsr_fixed_inst_w & ifu_tlu_inst_vld_w & 
                              ~fcl_swl_flush_w;
   dff_s #(1) wsrw2_ff(.din (wsr_fixed_qual_w),
                     .q   (wsr_fixed_w2),
                     .clk (clk), .se(se), .si(), .so());
                     
   assign wsr_inst_w2  = wsr_fixed_w2 & ~flush_pipe_w2;

   // delay one cycle to allow tlu to finish
   dff_s #(1) wsw3_ff(.din (wsr_inst_w2),
                    .q   (wsr_inst_w3),
                    .clk (clk), .se(se), .si(), .so());

   assign wsr_done_w3 = {4{wsr_inst_w3}} & st_thr_w3;

   assign fixedop_done = (ll_done_e | wsr_done_w3 | std_tcc_done_m |
	                        wrt_tcr_w2 | extra_longlat_compl);

   assign branch_done_d = thr_d & {4{dec_swl_br_done_d & fcl_dtu_inst_vld_d}};

   assign sta_done_e = dec_swl_sta_inst_e & fcl_dtu_inst_vld_e & 
                       ~lsu_ifu_ldsta_internal_e;
   assign ld_inst_qual_d = dec_swl_ld_inst_d & fcl_dtu_inst_vld_d & 
                           ~iferr_d;
   dff_s #(1) lde_ff(.din  (ld_inst_qual_d),
		               .clk  (clk),
		               .q    (ld_inst_e),
		               .se   (se), .si(), .so());
   assign ld_inst_next_e = ld_inst_e;
//                         & ~dtu_inst_anull_e &    
//                           ~(lsu_ifu_ldsta_internal_e & 
//                             ifu_lsu_alt_space_e &
//                             fcl_dtu_inst_vld_e);
   
//   assign ld_inst_internal_e = ~dtu_inst_anull_e & ld_inst_e &
//                               (fcl_dtu_inst_vld_e & 
//                                lsu_ifu_ldsta_internal_e & 
//                                ifu_lsu_alt_space_e);
   
   dff_s #(1) ldm_ff(.din  (ld_inst_next_e),
		               .clk  (clk),
		               .q    (ld_inst_m),
		               .se   (se), .si(), .so());
   dff_s #(1) ldw_ff(.din  (ld_inst_m),
		               .clk  (clk),
		               .q    (ld_inst_unq_w),
		               .se   (se), .si(), .so());
   assign ld_inst_w = ifu_tlu_inst_vld_w & ld_inst_unq_w;
   dff_s #(1) ldw2_ff(.din  (ld_inst_w),
		               .clk  (clk),
		               .q    (ld_inst_w2),
		               .se   (se), .si(), .so());

   // track instruction status
   dff_s #(1) swcd_ff(.din  (sw_cond_s),
		                .clk  (clk),
		                .q    (swc_d),
		                .se   (se), .si(), .so());

   assign swc_next_d = (swc_d & ~dec_swl_br_done_d);
//			                   | fcl_dtu_sync_intr_d;
   
   dff_s #(1) swce_ff(.din  (swc_next_d),
		                .clk  (clk),
		                .q    (swc_e),
		                .se   (se), .si(), .so());

//bug6838,bug6989 - interrupt issued in annulled delay slot resets wm_other mask in e-stage; this
//                  reset causes switch logic to lose a long latency op(div) which set the wm_other mask
//                  in s-stage. Note that the div is issued to FPU. the ifu re-issues the interrupt - 
//                  which results in flush. this kills the long latency op and div is lost
//
//                  fix is to detect interrupt in anulled delay slot followed by long latency op and
//                  not reset the wm_other mask.
//
//       10/07/04 - fix changed to delay setting of wm_other mask from d-cycle to e-cycle. hence
//                  removing the kill in killed_inst_done_e
//
//   assign killed_inst_done_e = (fcl_dtu_inst_vld_e  & swc_e | //sw inst
//                                fcl_dtu_intr_vld_e) &  // any intr
//                                 dtu_inst_anull_e;

   assign killed_inst_done_e = fcl_dtu_inst_vld_e  & swc_e & //sw inst
                                 dtu_inst_anull_e;

   // a uniop is something that stalls all threads (looks like a uni
   // threaded machine)
   assign uniop_d = (dec_swl_allfp_d | //& swl_dec_fp_enable_d  
                     dec_swl_mul_inst_d | dec_swl_div_inst_d) & 
                      fcl_dtu_inst_vld_d;
   dff_s #(1) uniop_ff(.din  (uniop_d),
		                 .clk  (clk),
		                 .q    (uniop_e),
		                 .se   (se), .si(), .so());
   assign killed_uniop_done_e = thr_e & {4{dtu_inst_anull_e & uniop_e & 
                                           fcl_dtu_inst_vld_e |
                                           clear_wmo_e}};

//   assign sched_nt = fcl_dtu_switch_s & ~fcl_dtu_stall_bf;
   assign sched_nt = dtu_fcl_ntr_s & ~(fcl_dtu_stall_bf | ifq_swl_stallreq);   
   assign schedule = dtu_fcl_nextthr_bf & {4{sched_nt}};

   // speculate load hit if it is a load instruction
   // FP loads are not speculated on 
   assign spec_ld_d = thr_d & {4{ld_inst_qual_d & en_spec_d}};
   assign issue_spec_ld = thr_d & {4{ld_inst_qual_d & en_spec_d}} &
                          ~wm_imiss & ~wm_stbwait;

//   assign issue_spec_ld = thr_d & {4{dec_swl_ld_inst_d & en_spec_d & 
//                                     ~fcl_ifq_icmiss_s1}} & ~wm_imiss;
   
   assign spec_ld_g = (thr_w & {4{ld_inst_w & en_spec_g}});
   
   // actual load hit signal and load miss stall
//   assign rollback_g = en_spec_g & ld_inst_w & lsu_ifu_ldst_miss_g;
   // expand to gates:
   assign rb_en_g = en_spec_g & ld_inst_w;
   assign rollback_g_l = ~(lsu_ifu_ldst_miss_g & rb_en_g);
//   bw_u1_nand2_7x UZsize_rbgen(.a (lsu_ifu_ldst_miss_g),
//                               .b (rb_en_g),
//                               .z (rollback_g_l));
   assign rollback_g = ~rollback_g_l;
//   bw_u1_invh_25x UZsize_rbbuf(.a (rollback_g_l),
//                               .z (rollback_g));
   assign dtu_fcl_rollback_g = rollback_g;

   // delay restart of ldhit when en_spec=0 by 1 more cycle?
   
// assign rb_thr_w = thr_w & {4{en_spec_g & ld_inst_w & lsu_ifu_ldst_miss_g}};
// assign spec_ldmiss = rb_thr_w; // to thrcmpl
   
   assign ldhit_thr = (thr_w & {4{ld_inst_w & ~lsu_ifu_ldst_miss_g}} | 
                       thr_e & {4{ld_inst_e & dtu_inst_anull_e}});
   assign ldmiss_crit = thr_w & {4{ld_inst_w & lsu_ifu_ldst_miss_g}};
   assign ldmiss_non_crit = st_thr_w2 & {4{lsu_ifu_dc_parity_error_w2}};
                            // | thr_e & {4{ld_inst_internal_e}} 
                            
   assign ldmiss = ldmiss_crit | ldmiss_non_crit;
   
   assign rt_st_thr_d = thr_d & {4{retract_store_d}};
   assign rt_st_thr_e = thr_e & {4{retract_store_e}};

   dff_s #(1) rbw2_ff(.din (rollback_g),
                    .q   (rollback_w2),
                    .clk (clk), .se(se), .si(), .so());

   // traps and interrupts
   dff_s #(1) ld_trp_reg(.din (tlu_ifu_trappc_vld_w1),
                       .q   (trappc_vld_w2),
                       .clk (clk), .se(se), .si(), .so());

   dff_s #(2) trp_tid_reg(.din (tlu_ifu_trap_tid_w1[1:0]),
                        .q   (trap_tid_w2[1:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign trap_thr[0] = ~trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[1] = ~trap_tid_w2[1] &  trap_tid_w2[0];
   assign trap_thr[2] =  trap_tid_w2[1] & ~trap_tid_w2[0];
   assign trap_thr[3] =  trap_tid_w2[1] &  trap_tid_w2[0];

   assign trap_thrrdy = trap_thr & {4{trappc_vld_w2}};

   // fst processed directly in swl
   assign rbfor_fst_ce_w = ifu_tlu_inst_vld_w & ~tlu_ifu_flush_pipe_w & 
                           ffu_ifu_fst_ce_w & ~fcl_swl_flush_w;

//   dff #(1) fstce_ff(.din (rbfor_fst_ce_w),
//                     .q   (rbfor_fst_ce_w2),
//                     .clk (clk), .se(se), .si(), .so());
   
   assign flush_all_w = tlu_ifu_flush_pipe_w | fcl_swl_flush_w;
//   assign flush_pipe_w_nxt = tlu_ifu_flush_pipe_w & ~fcl_swl_flush_w;
   assign flush_pipe_w_nxt = tlu_ifu_flush_pipe_w & 
                             ~fcl_swl_flush_wake_w;   
   
   dff_s #(1) flpw2_ff(.din (flush_pipe_w_nxt),
                     .q   (flush_pipe_w2),
                     .clk (clk), .se(se), .si(), .so());

//   assign no_iftrap_m = ~ifu_tlu_ttype_vld_m;
//   dff #(1) trpw_ff(.din (no_iftrap_m),
//                    .q   (no_iftrap_w),
//                    .clk (clk), .se(se), .si(), .so());
   
//bug6838,bug6989 - change setting of trap for interrupt from d-cycle to e-cycle
//                  remove  thr_d & {4{fcl_dtu_sync_intr_d & ~iferr_d}} & ~rt_st_thr_e |
   
//   assign trap =  thr_w & {4{flush_all_w}} |
   assign trap =  st_thr_w2 & {4{flush_pipe_w2}} |
                  thr_w & {4{fcl_swl_flush_w}} |
                        thr_e & {4{fcl_dtu_intr_vld_e & ~dtu_inst_anull_e}} |
	                thr_m & {4{ifu_tlu_ttype_vld_m}};

   assign trp_no_retr = st_thr_w2 & {4{flush_pipe_w2 |
                                       lsu_ifu_dc_parity_error_w2 &
                                       ld_inst_w2    | 
                                       rollback_w2}}  |
	                      trap_thr & {4{trappc_vld_w2}} |
                        fp_flush_wake_w3 |
                        thr_w & {4{fcl_swl_flush_w}};
//	                       thr_m    & {4{ifu_tlu_ttype_vld_m}};

   assign trp_noretr_d = (thr_d[0] & trp_no_retr[0] | 
                          thr_d[1] & trp_no_retr[1] | 
                          thr_d[2] & trp_no_retr[2] | 
                          thr_d[3] & trp_no_retr[3]);
   
//   assign flush_done_w = fcl_swl_flush_w & ~fcl_swl_flush_wait_w;
   assign flush_done_w = fcl_swl_flush_wake_w;   
   dff_s #(1) flsh_ff(.din (flush_done_w),
		                .q   (flush_done_w2),
		                .clk (clk), .se(se), .si(), .so());
   assign flush_wake_w2 = {4{flush_done_w2}} & st_thr_w2 | fp_flush_wake_w3;

   // delay FP wakeup by one extra cycle to allow time for IRF CE
   // to be corrected.
   dff_s #(1) fpflsh_ff(.din (rbfor_fst_ce_w),
		                  .q   (fp_flush_done_w2),
		                  .clk (clk), .se(se), .si(), .so());

   dff_s #(1) fpflw_ff(.din (fp_flush_done_w2),
		                 .q   (fp_flush_done_w3),
		                 .clk (clk), .se(se), .si(), .so());
   assign fp_flush_wake_w3 = st_thr_w3 & {4{fp_flush_done_w3}};
   
   // store buffer full
//   assign stbfull_on_curr_thr = stb_stall & thr_f;
//   assign stbfull_thisthr =  stbfull_on_curr_thr[0] |
//	                           stbfull_on_curr_thr[1] |
//	                           stbfull_on_curr_thr[2] |
//	                           stbfull_on_curr_thr[3];

//   assign stbfull_nextthr = ((stb_stall & dtu_fcl_nextthr_bf)
//			                       == 4'b0) ?
//			                        1'b0 : 1'b1;

   // imiss stall condition
   assign thr_s1 = thr_d;
   assign imiss = (thr_s1 & {4{fcl_ifq_icmiss_s1}}) | 
	                  (thr_e & {4{erb_dtu_ifeterr_d1}});  //

   // All Stall conditions
   assign all_stall = imiss | ldmiss_non_crit | trap | stb_stall | 
                      ldmiss_crit;

   // TBD: move to ifu -- done
//   assign ext_stallreq = ifq_dtu_stallreq | lsu_ifu_stallreq | 
//                         ffu_ifu_stallreq;  
                         // | other stall reqs
//   assign cpu_fcl_stallreq = ext_stallreq;
   
   // thread start and stop
//   assign switch_out = fcl_dtu_switch_s | fcl_dtu_stall_bf | fcl_swl_swout_f;
   assign switch_out = dtu_fcl_ntr_s | fcl_dtu_stall_bf | fcl_swl_swout_f |
                       ifq_swl_stallreq;

   // general stall condition
//   assign cpu_fcl_stallreq = ~dtu_fcl_ntr_s & (stbfull_thisthr) |
//                             dtu_fcl_ntr_s & (stbfull_nextthr) |
//	                           ext_stallreq;

   // ldmiss (i.e rollback) and flush_pipe are taken care of in FCL
   assign sw_cond_s = fdp_fcl_swc_s2 & fcl_swl_swcvld_s & ~iferr_s;

   // thread reset and other interrupts
   // added flop for timing reasons

//   assign async_rst_i3 = rst_thread & ~dtu_fcl_thr_active;
//   assign rst_thread   = rstthr_i3 & {4{rstint_i3}};
  // assign nuke_thread  = (rstthr_i3 & {4{nukeint_i3}} & 
//			                    ~dtu_fcl_thr_active) |   // if not active nuke 
			                                             // immediately
//			                     ({4{fcl_dtu_nuke_thr_ms}} & thr_m);
                                                   // else wait for signal

   assign resum_thread = ({4{fcl_dtu_resum_thr_w}} & thr_w);
   assign nuke_thread = ({4{fcl_dtu_nuke_thr_w}} & thr_w);
   assign rst_thread = ({4{fcl_dtu_rst_thr_w}} & thr_w);

   assign int_activate = fcl_swl_int_activate_i3 & ~wm_imiss;

//`ifdef IFU_SAT   
//   assign start_thread = {3'b0, start_on_rst} | auto_start | 
//                         resum_thread & (~wm_imiss | ifq_dtu_thrrdy);
//`else
   assign start_thread = resum_thread & (~wm_imiss | ifq_dtu_thrrdy) & 
                                          (~wm_stbwait | stb_retry);
   assign thaw_thread = resum_thread & (wm_imiss & ~ifq_dtu_thrrdy |
                                        wm_stbwait & ~stb_retry);
   
//`endif
   
   
//----------------------------------------------------------------------
// Thread FSM
//----------------------------------------------------------------------   

//trin
// jtag access
reg [3:0] rtap_ifu_thrfsm_wr_en;
reg [4:0] rtap_ifu_thrfsm_wr_data;

always @ *
begin
   rtap_ifu_thrfsm_wr_en = 0;
   if (rtap_core_val && rtap_core_id == 4'd2)
   begin
      if (rtap_core_threadid == 2'd0)
         rtap_ifu_thrfsm_wr_en = 4'b0001;
      else if (rtap_core_threadid == 2'd1)
         rtap_ifu_thrfsm_wr_en = 4'b0010;
      else if (rtap_core_threadid == 2'd2)
         rtap_ifu_thrfsm_wr_en = 4'b0100;
      else if (rtap_core_threadid == 2'd3)
         rtap_ifu_thrfsm_wr_en = 4'b1000;
   end
   rtap_ifu_thrfsm_wr_data = rtap_core_data[4:0];
end

   sparc_ifu_thrfsm  thrfsm0(
			     // Outputs




			     .so	(so),

			     .thr_state	(thr0_state[4:0]),
                 .thr_nstate (thr0_nstate[4:0]),
			     // Inputs
			     .completion(completion[0]),
			     .schedule	(schedule[0]),
			     .spec_ld	(issue_spec_ld[0]),
			     .ldhit	(ldhit_thr[0]),
			     .switch_out(switch_out),

			     .stall     (all_stall[0]),
			     .sw_cond	(sw_cond_s),

			     .int_activate(int_activate[0]),
			     .start_thread(start_thread[0]),
			     .thaw_thread(thaw_thread[0]),
			     .nuke_thread (nuke_thread[0]),
			     .rst_thread(rst_thread[0]),

			     .halt_thread (halt_thread[0]),
			     
           // jtag interface
           .rtap_ifu_thrfsm_wr_en(rtap_ifu_thrfsm_wr_en[0]),
           .rtap_ifu_thrfsm_wr_data(rtap_ifu_thrfsm_wr_data),

			     .clk	(clk),
			     .se	(se),
			     .si	(si),
			     .reset	(dtu_reset));

   sparc_ifu_thrfsm  thrfsm1(
			     // Outputs




			     .so	(so),

			     .thr_state	(thr1_state[4:0]),
                 .thr_nstate (thr1_nstate[4:0]),
			     // Inputs
			     .completion(completion[1]),
			     .schedule	(schedule[1]),
			     .spec_ld	(issue_spec_ld[1]),
			     .ldhit	(ldhit_thr[1]),
			     .switch_out(switch_out),

			     .stall     (all_stall[1]),
			     .sw_cond	(sw_cond_s),

			     .int_activate(int_activate[1]),
			     .start_thread(start_thread[1]),
			     .thaw_thread(thaw_thread[1]),
			     .nuke_thread (nuke_thread[1]),
			     .rst_thread(rst_thread[1]),

			     .halt_thread (halt_thread[1]),
			     
           // jtag interface
           .rtap_ifu_thrfsm_wr_en(rtap_ifu_thrfsm_wr_en[1]),
           .rtap_ifu_thrfsm_wr_data(rtap_ifu_thrfsm_wr_data),

			     .clk	(clk),
			     .se	(se),
			     .si	(si),
			     .reset	(dtu_reset));
   
// trin: since proc only has 2 threads, disabling the following state machines
 // Use two threads unless this is defined
assign thr2_state[4:0] = 5'b0;
assign thr3_state[4:0] = 5'b0;












































































 // ifdef CONFIG_NUM_THREADS

//----------------------------------------------------------------------
// Schedule Next Thread
//----------------------------------------------------------------------
   // rdy bit from thrfsm
   assign dtu_fcl_thr_active[0] = thr0_state[0];
   assign dtu_fcl_thr_active[1] = thr1_state[0];
   assign dtu_fcl_thr_active[2] = thr2_state[0];
   assign dtu_fcl_thr_active[3] = thr3_state[0];

   assign rdy[0] = thr0_state[3];
   assign rdy[1] = thr1_state[3];
   assign rdy[2] = thr2_state[3];
   assign rdy[3] = thr3_state[3];

   assign sprdy_or_urdy[0] = thr0_state[4];
   assign sprdy_or_urdy[1] = thr1_state[4];
   assign sprdy_or_urdy[2] = thr2_state[4];
   assign sprdy_or_urdy[3] = thr3_state[4];

   assign sprdy_or_urdy_next[0] = thr0_nstate[4];
   assign sprdy_or_urdy_next[1] = thr1_nstate[4];
   assign sprdy_or_urdy_next[2] = thr2_nstate[4];
   assign sprdy_or_urdy_next[3] = thr3_nstate[4]; 

   assign running_s2 = (thr0_state[2] |
			                  thr1_state[2] |
			                  thr2_state[2] |
			                  thr3_state[2]);

   assign dtu_fcl_running_s = running_s2;

   assign thr_s2 =  {thr3_state[2],
			               thr2_state[2],
			               thr1_state[2],
			               thr0_state[2]};

   // Next Thread Ready 
   assign dtu_fcl_ntr_s = config_dtu_esl_en ? esl_fcl_ntr_s 
                                            : (sprdy_or_urdy[0] | sprdy_or_urdy[1] | 
				                               sprdy_or_urdy[2] | sprdy_or_urdy[3]);

   // Any thread ready
   assign atr_s = dtu_fcl_ntr_s | running_s2;

   // decide which scheduler to use
   // timing note: see if use_spec can be generated in previous cycle
   assign use_spec = ~(rdy[3] | rdy[2] | rdy[1] | rdy[0]);

   // Select between thread select decision from LRU and ESL
   assign dtu_fcl_nextthr_bf = config_dtu_esl_en ? esl_fcl_nextthr_bf : lru_fcl_nextthr_bf;

   assign sched_reset = dtu_reset | ~gdbginit_l;
   // schedule ready threads using LRU
   sparc_ifu_lru4 thr_sched(// Outputs
			                      .grant_vec	(lru_fcl_nextthr_bf[3:0]),
			                      .so		(so),
			                      // Inputs
			                      .clk	(clk),
			                      .reset	(sched_reset),
			                      .se		(se),
			                      .si		(si),
			                      .recent_vec	(thr_e[3:0]),
			                      .load_recent(fcl_dtu_inst_vld_e),
			                      .req_vec	(rdy[3:0]),
                            .spec_vec (sprdy_or_urdy[3:0]),
                            .use_spec (use_spec));

   // Pipe forward issue previous instruction control signal
   dff_s #(1) issue_prev_inst_reg (.din (esl_fdp_issue_prev_inst_next_s),
                                   .q (esl_fdp_issue_prev_inst_s),
                                   .clk (clk), .se(se), .si(), .so());

   // Schedule ready threads using Execution Drafting
   sparc_ifu_esl esl_thr_sched
   (
      .clk (clk),
      .rst_n (~sched_reset),
      .config_esl_en (config_dtu_esl_en),
      .config_esl_sync_method (config_dtu_esl_sync_method),
      .config_esl_lfsr_seed (config_esl_lfsr_seed),
      .config_esl_lfsr_ld (config_esl_lfsr_ld),
      .config_esl_pc_diff_thresh (config_esl_pc_diff_thresh),
      .config_esl_counter_timeout (config_esl_counter_timeout),
      .swl_esl_thr_active (dtu_fcl_thr_active),
      .swl_esl_thr_urdy (rdy),
      .swl_esl_thr_sprdy_or_urdy (sprdy_or_urdy),
      .swl_esl_thr_sprdy_or_urdy_next (sprdy_or_urdy_next),
      .swl_esl_use_spec (use_spec),
      .fcl_esl_thr_f (fcl_dtu_thr_f),
      .fdp_esl_t0inst_next_s2 (fdp_esl_t0inst_next_s2),

      .fdp_esl_t1inst_next_s2 (fdp_esl_t1inst_next_s2),














      .fdp_esl_t0inst_paddr_next_s2 (fdp_esl_t0inst_paddr_next_s2),

      .fdp_esl_t1inst_paddr_next_s2 (fdp_esl_t1inst_paddr_next_s2),














      .fdp_esl_t0pc_next_s2 (fdp_esl_t0pc_next_s2),

      .fdp_esl_t1pc_next_s2 (fdp_esl_t1pc_next_s2),














      .fcl_esl_tinst_vld_next_s (fcl_esl_tinst_vld_next_s),
      .fcl_esl_brtaken_e (fcl_esl_brtaken_e),
      .fcl_esl_brtaken_m (fcl_esl_brtaken_m),
      .fcl_esl_thr_e (fcl_esl_thr_e),
      .fcl_esl_thr_m (fcl_esl_thr_m),
      .fcl_esl_inst_vld_d (fcl_esl_inst_vld_d),
      .fcl_esl_inst_vld_e (fcl_esl_inst_vld_e),
      .fcl_esl_inst_vld_m (fcl_esl_inst_vld_m),
      .fcl_esl_thr_trap_bf (fcl_esl_thr_trap_bf),
      .fcl_esl_rb_stg_s (fcl_esl_rb_stg_s),
      .dcl_esl_br_inst_d (dcl_esl_br_inst_d),
      .dcl_esl_br_inst_e (dcl_esl_br_inst_e),
      .fdp_esl_brtrp_target_pc_bf_f (fdp_esl_brtrp_target_pc_bf_f),
      .swl_esl_icmiss_out (swl_esl_icmiss_out),
      .esl_fcl_nextthr_bf (esl_fcl_nextthr_bf),
      .esl_fcl_stall_bf (esl_fcl_stall_bf),
      .esl_fcl_switch_bf (esl_fcl_switch_bf),
      .esl_fdp_sync_pcs_bf (esl_fdp_sync_pcs_bf),
      .esl_fcl_ntr_s (esl_fcl_ntr_s),
      .esl_fdp_issue_prev_inst_next_s (esl_fdp_issue_prev_inst_next_s),
      .esl_fcl_force_running_s (esl_fcl_force_running_s)
   );
      
//----------------------------------------------------------------------
// Thread Status (Config) Register
//----------------------------------------------------------------------
   // Read thread config
   assign enc_thr_d[1] = thr_d[3] | thr_d[2];
   assign enc_thr_d[0] = thr_d[3] | thr_d[1];   

   assign rd_thract_d = (thr0_state[0] & thr_d[0] |
                         thr1_state[0] & thr_d[1] |
                         thr2_state[0] & thr_d[2] |
                         thr3_state[0] & thr_d[3]);

   dff_s #(1) rdthr_ff(.din (rd_thract_d),
		                  .clk (clk),
		                  .q   (rd_thract_e),
		                  .se   (se), .si(), .so());

   dff_s #(3) rdcf_reg(.din ({enc_thr_d, en_spec_d}),
		                 .clk (clk),
		                 .q   (rd_tid_spec_e),
		                 .se   (se), .si(), .so());

   dff_s #(1) hpe_ff(.din (fcl_dtu_hprivmode_d),
		               .clk (clk),
		               .q   (hprivmode_e),
		               .se   (se), .si(), .so());
   dff_s #(1) rdthre_ff(.din (dec_swl_rdsr_sel_thr_d),
		                  .clk (clk),
		                  .q   (rdsr_sel_thr_e),
		                  .se   (se), .si(), .so());

   // TBD: read out all thread state, not just the current thread
   //      Done 9/26/02
   assign fmt_thrconf_e = {wm_stbwait,
                           wm_other,
                           wm_imiss,           // 51:40 - wait mask
                           4'b0,               // 39:36 - rsvd
                           thr0_state,
                           thr1_state,
                           thr2_state,
                           thr3_state,         // 35:16 - thr state
			                     {2'b0},             // 15:14 - rsvd
			                     const_cpuid,        // 13:10 - 4b cpu id
			                     rd_tid_spec_e[2:1], // 9:8 - 2b tid
			                     {5'b0},             // 7:3 - rsvd
			                     rd_tid_spec_e[0],   // 2 - en spec
			                     {1'b0},             // 1 - QOS/rsvd
			                     rd_thract_e};       // 0 - active

//`ifdef SPARC_HPV_EN
   assign fmt_thrconf_adj[51:1] = fmt_thrconf_e[51:1] & {51{hprivmode_e}};
   assign fmt_thrconf_adj[0] = fmt_thrconf_e[0];
//`else
//   assign fmt_thrconf_adj[51:0] = fmt_thrconf_e[51:0];
//`endif

//   assign thrconf_out_e[51:16] = (fmt_thrconf_e[51:16] & 
//                                      {36{hprivmode_e}});
   
//   mux2ds #(52) rdsr_mxe(.dout (thrconf_out_e[51:0]),
//		                     .in0  ({49'b0, fprs_e}),
//		                     .in1  (fmt_thrconf_adj[51:0]),
//		                     .sel0 (~rdsr_sel_thr_e),
//		                     .sel1 (rdsr_sel_thr_e));
   assign thrconf_out_e[51:0] = rdsr_sel_thr_e ? fmt_thrconf_adj[51:0] :
                                                 {49'b0, fprs_e};

   // leave out the zeros before sending to fdp
   assign dtu_fdp_thrconf_e = {thrconf_out_e[51:40], // 40:29
                               thrconf_out_e[35:16], // 28:9
                               thrconf_out_e[13:8],  // 8:3
                               thrconf_out_e[2:0]};

   // shadow scan outputs
   mux4ds #(11) sscan_mx(.dout (swl_sscan_thrstate[10:0]),
                         .in0  ({thr0_state[4:0], 
                                 wm_imiss[0],
                                 wm_other[0],
                                 wm_stbwait[0],
                                 mul_busy_e[0],
                                 div_busy_e[0],
                                 fp_busy_e[0]}),
                         .in1  ({thr1_state[4:0], 
                                 wm_imiss[1],
                                 wm_other[1],
                                 wm_stbwait[1],
                                 mul_busy_e[1],
                                 div_busy_e[1],
                                 fp_busy_e[1]}),
                         .in2  ({thr2_state[4:0], 
                                 wm_imiss[2],
                                 wm_other[2],
                                 wm_stbwait[2],
                                 mul_busy_e[2],
                                 div_busy_e[2],
                                 fp_busy_e[2]}),
                         .in3  ({thr3_state[4:0], 
                                 wm_imiss[3],
                                 wm_other[3],
                                 wm_stbwait[3],
                                 mul_busy_e[3],
                                 div_busy_e[3],
                                 fp_busy_e[3]}),
                         .sel0 (ctu_sscan_tid[0]),
                         .sel1 (ctu_sscan_tid[1]),
                         .sel2 (ctu_sscan_tid[2]),
                         .sel3 (ctu_sscan_tid[3]));
   
   // write to TCR
   assign wrt_spec_w = dec_swl_wrt_tcr_w & ifu_tlu_inst_vld_w & 
                       ~flush_all_w;

   assign spec_next = (wrt_spec_w2 & fcl_dtu_hprivmode_w2) ? 
                             thr_config_in_w2[2] : 
                             en_spec_d;
   
   assign halt_w = wrt_spec_w & ~thr_config_in_w[0];
   
   dff_s #(1) wrsw2_ff(.din (wrt_spec_w),
                     .q   (wrt_spec_w2),
                     .clk (clk), .se(se), .si(), .so());
   
   assign wrt_tcr_w2 = st_thr_w2 & {4{wrt_spec_w2}};
   
   dff_s #(1) hlt_ff(.din (halt_w),
                   .q   (halt_w2),
                   .clk (clk), .se(se), .si(), .so());
   assign halt_thread = st_thr_w2 & {4{halt_w2}};
   
   dffr_s #(1) enspec_ff(.din (spec_next),
		                   .clk (clk),
		                   .q   (en_spec_d),
		                   .rst (dtu_reset),
		                   .se  (se), .si(), .so());
   
   dff_s #(1) enspecm_ff(.din (rd_tid_spec_e[0]),
		                   .clk (clk),
		                   .q   (en_spec_m),
		                   .se  (se), .si(), .so());

   dff_s #(1) enspecw_ff(.din (en_spec_m),
		                   .clk (clk),
		                   .q   (en_spec_g),
		                   .se  (se), .si(), .so());


   //-----------------------------
   // Instruction Flow Control
   //-----------------------------

   // mul and div control (1 each per cpu)
   assign mul_busy_d = ({4{dec_swl_mul_inst_d & ~swl_dec_mulbusy_e &
                           fcl_dtu_inst_vld_d & ~iferr_d}} & thr_d &
//			                  ~rb_thr_w & ~rt_st_thr_e |          // set
                        ~rt_st_thr_e |
			                  mul_busy_e & ~killed_uniop_done_e) & 
			                   ~exu_ifu_longop_done_g & (~trp_no_retr);  // reset wins

   assign div_busy_d = ({4{dec_swl_div_inst_d & ~swl_dec_divbusy_e &
                           fcl_dtu_inst_vld_d & ~iferr_d}} & 
			                  thr_d  & ~rt_st_thr_e |        // set
			                  div_busy_e & ~killed_uniop_done_e) & 
			                   ~exu_ifu_longop_done_g & (~trp_no_retr); // reset wins

   assign fp_busy_d = ({4{dec_swl_allfp_d & // swl_dec_fp_enable_d &
                          fcl_dtu_inst_vld_d &
                          ~fpbusy_local_e & ~iferr_d}} & thr_d & 
		                   ~rt_st_thr_d & ~rt_st_thr_e |
                                  // FP could be a st
		                   fp_busy_e & ~killed_uniop_done_e) &
			                  {4{~ffu_ifu_fpop_done_w2}} & ~trp_no_retr; // reset wins

   dffr_s #(4) mulb_ff(.din (mul_busy_d),
		                 .q   (mul_busy_e),
		                 .clk (clk),
		                 .rst (dtu_reset),
		                 .se  (se), .si(), .so());
   assign true_mulbusy_e = (|mul_busy_e[3:0]);   
   assign mbusy_d0 = true_mulbusy_e & mul_wait_any;
   
   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_mulbusy_e = true_mulbusy_e | mbusy_d3 | mbusy_d1 | mbusy_d2;
   
   dffr_s #(4) divb_ff(.din (div_busy_d),
		                 .q   (div_busy_e),
		                 .clk (clk),
		                 .rst (dtu_reset),
		                 .se  (se), .si(), .so());
   assign true_divbusy_e = (|div_busy_e[3:0]);   
   assign dbusy_d0 = true_divbusy_e & div_wait_any;

   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_divbusy_e = true_divbusy_e | dbusy_d3 | dbusy_d1 | dbusy_d2;

   dffr_s #(4) fpb_ff(.din (fp_busy_d),
		                .q   (fp_busy_e),
		                .clk (clk),
		                .rst (dtu_reset),
		                .se  (se), .si(), .so());
   assign true_fpbusy_e = (|fp_busy_e[3:0]);
   assign fbusy_d0 = true_fpbusy_e & fp_wait_any;
   
   assign fbusy_nxt_d = (|fp_busy_d[3:0]) | fbusy_d0 | fbusy_d1 | fbusy_d2;
   dffr_s #(1) tfbe_ff(.din (fbusy_nxt_d),
                     .q   (fbusy_crit_e),
                     .clk (clk), 
                     .rst (dtu_reset), .se(se), .si(), .so());
   
   // block shared resource for two extra cycles, to allow waiting
   // threads a fair chance at getting it.  
   assign swl_dec_fpbusy_e = fbusy_crit_e;
   assign fpbusy_local_e = true_fpbusy_e | fbusy_d3 | fbusy_d1 | fbusy_d2;

   dff_s #(3) bd1_reg(.din ({mbusy_d0, dbusy_d0, fbusy_d0}),
                    .q   ({mbusy_d1, dbusy_d1, fbusy_d1}),
                    .clk (clk), .se(se), .si(), .so());

   dff_s #(3) bd2_reg(.din ({mbusy_d1, dbusy_d1, fbusy_d1}),
                    .q   ({mbusy_d2, dbusy_d2, fbusy_d2}),
                    .clk (clk), .se(se), .si(), .so());
   
   dff_s #(3) bd3_reg(.din ({mbusy_d2, dbusy_d2, fbusy_d2}),
                    .q   ({mbusy_d3, dbusy_d3, fbusy_d3}),
                    .clk (clk), .se(se), .si(), .so());
   
   // ifetch errors
   // If there was an error in the ifetch call back this instruction
   assign iferr_d = erb_dtu_ifeterr_d1 & same_thr_de;
   assign iferr_s = erb_dtu_ifeterr_d1 & same_thr_fe;
   assign retract_iferr_d =  erb_dtu_ifeterr_d1 & fcl_dtu_inst_vld_d & 
                             same_thr_de;

   // mul_inst is already already qualified with inst_vld
   // so is fpop
   // don't set retract if there is an iferr, since this will cancel
   // the pending imisses!  
   assign dtu_fcl_retract_d = ((dec_swl_mul_inst_d & swl_dec_mulbusy_e | 
			                          dec_swl_div_inst_d & swl_dec_divbusy_e |
			                          dec_swl_allfp_d & fpbusy_local_e) &
                                // & swl_dec_fp_enable_d 
                               fcl_dtu_inst_vld_d |
                               retract_store_d  
//                             |  retract_iferr_d
                               );

   // what does this do???
   // no need to stall after retract since thread is already switched out
//   assign retract_stall_d = (dec_swl_mul_inst_d & swl_dec_mulbusy_e | 
//			                       dec_swl_div_inst_d & swl_dec_divbusy_e |
//			                       dec_swl_allfp_d & swl_dec_fp_enable_d & 
//                             fpbusy_local_e);

   assign mul_wait_nxt = ({4{dec_swl_mul_inst_d & swl_dec_mulbusy_e &
                             fcl_dtu_inst_vld_d & ~iferr_d}} &
			                 thr_d  & ~rt_st_thr_e | mul_done |   // set
			                 mul_wait & ~retr_thr_wakeup  & ~killed_uniop_done_e) & 
			                 (~trp_no_retr);

   dffr_s #(4) mw_ff(.din (mul_wait_nxt[3:0]),
		               .q   (mul_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign mul_wait_any = (|mul_wait[3:0]);
   
   assign div_wait_nxt =  ({4{dec_swl_div_inst_d & swl_dec_divbusy_e &
                              fcl_dtu_inst_vld_d & ~iferr_d}} & 
                        thr_d  & ~rt_st_thr_e | div_done | // set 
			                  div_wait & ~retr_thr_wakeup & ~killed_uniop_done_e) & 
			                  (~trp_no_retr);
   
   dffr_s #(4) dw_ff(.din (div_wait_nxt[3:0]),
		               .q   (div_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign div_wait_any = (|div_wait[3:0]);

   assign fp_wait_nxt =  ({4{dec_swl_allfp_d & // swl_dec_fp_enable_d & 
                             fcl_dtu_inst_vld_d & fpbusy_local_e &
                             ~iferr_d}} &
			                    thr_d  & ~rt_st_thr_d & ~rt_st_thr_e |
                          fp_done |    // set 
			                    fp_wait & ~retr_thr_wakeup & ~killed_uniop_done_e) & 
			                     (~trp_no_retr);
   
   dffr_s #(4) fw_ff(.din (fp_wait_nxt[3:0]),
		               .q   (fp_wait[3:0]),
		               .clk (clk),
		               .rst (dtu_reset),
		               .se(se), .si(), .so());
   assign fp_wait_any = (|fp_wait[3:0]);

   // wake up waiting threads when the unit is no longer busy
   // need to qual with trp_no_retr since trp can occur at the same
   // time as unit becoming unbusy.  
   assign mul_wake = mul_wait & {4{~true_mulbusy_e}} & ~trp_no_retr;
   assign div_wake = div_wait & {4{~true_divbusy_e}} & ~trp_no_retr;
   assign fp_wake  = fp_wait & {4{~true_fpbusy_e}} & ~trp_no_retr;
			      
//   assign retr_thr_wakeup = (mul_wait & {4{~swl_dec_mulbusy_e}} |
//	                     div_wait & {4{~swl_dec_divbusy_e}} | 
//	                     fp_wait & {4{~fpbusy_local_e}} | 
//			     wm_stbwait & stb_retry);

   assign retr_thr_wakeup = mul_wake | div_wake | fp_wake;
//	                  |  (wm_stbwait & stb_retry & ~wm_other);
   
   assign fp_thr[0] = ~ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
   assign fp_thr[1] = ~ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];
   assign fp_thr[2] =  ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
   assign fp_thr[3] =  ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];

   // Delay mul div completion to prevent one thread from hogging mul and div
   assign mul_done = exu_ifu_longop_done_g & mul_busy_e & {4{mul_wait_any}};
   assign div_done = exu_ifu_longop_done_g & div_busy_e & {4{div_wait_any}};
   assign fp_done = fp_thr & {4{ffu_ifu_fpop_done_w2}} & {4{fp_wait_any}};   

   assign fp_thrrdy = fp_thr & {4{ffu_ifu_fpop_done_w2}} & {4{~fp_wait_any}};
   
   // don't complete if another mul/div is waiting
   assign exu_lop_done = (exu_ifu_longop_done_g & 
			                    (~mul_busy_e | {4{~mul_wait_any}}) &
			                    (~div_busy_e | {4{~div_wait_any}}));

   // TBD:
   // 1.  Put in similar wakeup sequence for fp completion -- done
   // 2.  Is it worth doing a round robin wakeup when a deadlock problem
   //     exists even in that case? -- no need with lru scheduler

   
   //--------------------------
   // Store buffer flow control
   //--------------------------
   // store pipe
   assign st_inst_qual_d = dec_swl_st_inst_d & fcl_dtu_inst_vld_d;
   dff_s ste_ff(.din (st_inst_qual_d),
	            .q   (st_inst_e),
	            .clk (clk),
	            .se  (se), .si(), .so());
   assign st_inst_qual_e = st_inst_e & ~dtu_inst_anull_e;

   dff_s stm_ff(.din (st_inst_qual_e),
	            .q   (st_inst_m),
	            .clk (clk),
	            .se  (se), .si(), .so());
   dff_s stg_ff(.din (st_inst_m),
	            .q   (st_inst_g),
	            .clk (clk),
	            .se  (se), .si(), .so());

//   assign st_inst_qual_g = st_inst_g & ifu_tlu_inst_vld_w;
//   dff stw2_ff(.din (st_inst_qual_g),
//	             .q   (st_inst_w2),
//	             .clk (clk),
//               .se  (se), .si(), .so());

   // determine which of the above thread is to the D thread
   assign same_thr_de = (thr_d[0] & thr_e[0] |
			                   thr_d[1] & thr_e[1] |
			                   thr_d[2] & thr_e[2] |
			                   thr_d[3] & thr_e[3]);
   assign same_thr_dg = (thr_d[0] & thr_w[0] |
			                   thr_d[1] & thr_w[1] |
			                   thr_d[2] & thr_w[2] |
			                   thr_d[3] & thr_w[3]);

   assign same_thr_fd = (thr_f[0] & thr_d[0] |
			                   thr_f[1] & thr_d[1] |
			                   thr_f[2] & thr_d[2] |
			                   thr_f[3] & thr_d[3]);
   assign same_thr_fe = (thr_f[0] & thr_e[0] |
			                   thr_f[1] & thr_e[1] |
			                   thr_f[2] & thr_e[2] |
			                   thr_f[3] & thr_e[3]);
   assign same_thr_fm = (thr_f[0] & thr_m[0] |
			                   thr_f[1] & thr_m[1] |
			                   thr_f[2] & thr_m[2] |
			                   thr_f[3] & thr_m[3]);
   assign same_thr_fg = (thr_f[0] & thr_w[0] |
			                   thr_f[1] & thr_w[1] |
			                   thr_f[2] & thr_w[2] |
			                   thr_f[3] & thr_w[3]);

   assign pipe_st_e = same_thr_fe & st_inst_e;
   assign pipe_st_m = same_thr_fm & st_inst_m;
   assign pipe_st_g = same_thr_fg & st_inst_g;
   assign pipe_st_d = same_thr_fd & st_inst_qual_d;

   dff_s #(1) pste_ff(.din (pipe_st_d),
                    .q   (st_thisthr_e),
                    .clk (clk), .se(se), .si(), .so());

   // count the number of stores in the pipe to this thread (0-4)
   assign pipe_st_cnt_ge1 = pipe_st_e | pipe_st_m | pipe_st_g;
//	                          pipe_st_w2;

   assign pipe_st_cnt_ge2 = (pipe_st_e & pipe_st_m |
			                       pipe_st_e & pipe_st_g |
                             pipe_st_m & pipe_st_g);

//   assign pipe_st_cnt_ge2 = (pipe_st_e & pipe_st_m |
//			                       pipe_st_e & pipe_st_g |
//			                       pipe_st_e & pipe_st_w2 |
//			                       pipe_st_m & pipe_st_g |
//			                       pipe_st_m & pipe_st_w2 |
//	                           pipe_st_g & pipe_st_w2);

   assign pipe_st_cnt_ge3 = (pipe_st_e & pipe_st_m & pipe_st_g);
//			                       pipe_st_e & pipe_st_m & pipe_st_w2 |
//			                       pipe_st_e & pipe_st_g & pipe_st_w2 |
//			                       pipe_st_m & pipe_st_g & pipe_st_w2);

//   assign pipe_st_cnt_eq4 = pipe_st_e & pipe_st_m & pipe_st_g & 
//	                          pipe_st_w2;

   dff_s #(3) pstc_reg(.din ({pipe_st_cnt_ge1,
                            pipe_st_cnt_ge2,
                            pipe_st_cnt_ge3}),
                     .q   ({dst_cnt_ge1,
                            dst_cnt_ge2,
                            dst_cnt_ge3}),
                     .clk (clk), .se(se), .si(), .so());
   
   // get the number of taken store buffer entries to this thread
   mux4ds #(4) stbcnt_mux(.dout (stbcnt_s),
			                    .in0  (lsu_ifu_stbcnt0),
			                    .in1  (lsu_ifu_stbcnt1),
			                    .in2  (lsu_ifu_stbcnt2),
			                    .in3  (lsu_ifu_stbcnt3),
			                    .sel0 (thr_f[0]),
			                    .sel1 (thr_f[1]),
			                    .sel2 (thr_f[2]),
			                    .sel3 (thr_f[3]));

   dff_s #(4) stbd_reg(.din (stbcnt_s),
		                 .q   (stbcnt_d),
		                 .clk (clk),
		                 .se  (se), .si(), .so());

   assign all_dst_ge1 = dst_cnt_ge1 | st_thisthr_e;
   assign all_dst_ge2 = dst_cnt_ge1 & st_thisthr_e | dst_cnt_ge2;
   assign all_dst_ge3 = dst_cnt_ge2 & st_thisthr_e | dst_cnt_ge3;
   assign all_dst_eq4 = dst_cnt_ge3 & st_thisthr_e;

   // switch if taken entries + stores in pipe >= 8
   assign switch_store_d = stbcnt_d[3] & fcl_dtu_inst_vld_d | // 8
	            dec_swl_st_inst_d & fcl_dtu_inst_vld_d & 
	            (stbcnt_d[2] & stbcnt_d[1] & stbcnt_d[0] | // 7
		           stbcnt_d[2] & stbcnt_d[1] & all_dst_ge1 | // 6 + 1
		           stbcnt_d[2] & stbcnt_d[0] & all_dst_ge2 | // 5 + 2
		           stbcnt_d[2]               & all_dst_ge3 | // 4 + 3
		           stbcnt_d[1] & stbcnt_d[0] & all_dst_eq4); // 3 + 4

   assign stb_stall = {4{switch_store_d}} & thr_d;
   assign stb_blocked = {lsu_ifu_stbcnt3[3], lsu_ifu_stbcnt2[3],
			                   lsu_ifu_stbcnt1[3], lsu_ifu_stbcnt0[3]};

   dff_s #(4) stbb_reg(.din (stb_blocked),
		                 .q   (stb_blocked_d1),
		                 .clk (clk), .se(se), .si(), .so());
   
   // retract this thread if taken entries + stores in pipe >= 9
   assign retract_store_d = dec_swl_st_inst_d & fcl_dtu_inst_vld_d &
	        (stbcnt_d[3] | // 8
	         stbcnt_d[2] & stbcnt_d[1] & stbcnt_d[0] & all_dst_ge1 | // 7 + 1
	         stbcnt_d[2] & stbcnt_d[1] & all_dst_ge2 |  // 6 + 2
	         stbcnt_d[2] & stbcnt_d[0] & all_dst_ge3 |  // 5 + 3
	         stbcnt_d[2] & all_dst_eq4);                // 4 + 4

   // remember if we retracted a store so that we can clear wmo in 
   // the next cycle
   assign retract_st_next_d = (retract_store_d | retract_iferr_d) & 
                              ~(same_thr_dg & rollback_g) & 
                              ~trp_noretr_d;
   
   dff_s #(1) retr_se(.din (retract_st_next_d),
		                .q   (retract_store_e),
		                .clk (clk), .se (se), .si(), .so());

   // clear wmo if you set it already
   assign clear_wmo_e = retract_store_e & (swc_d & same_thr_de | swc_e);
// assign clear_wmo_e = retract_store_e;   


   // mark a switched out thread for wakeup
//   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d & ~rb_thr_w |   // set
//			                    wm_stbwait & ~stb_retry 
//  			                ~(thr_d & {4{swc_d}}) & 
//			                    ~(thr_e & {4{dec_swl_sta_inst_e & 
//				                               lsu_ifu_ldsta_internal_e}})   // reset
//			                    ) & ~trp_no_retr;  // this reset wins

//   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d & ~rb_thr_w |   // set
//			                    wm_stbwait & ~stb_retry) & ~trp_no_retr;

   assign stb_wait_nxt = ({4{switch_store_d}} & thr_d |   // set
			                    wm_stbwait & ~stb_retry);
   
   dffr_s #(4) stbw_reg(.din (stb_wait_nxt),
		                  .q   (wm_stbwait),
		                  .clk (clk),
		                  .rst (dtu_reset),
		                  .se  (se), .si(), .so());

   // count to 4 and retry 
   dff_s stbrete_ff(.din (switch_store_d),
		              .q   (sw_st_e),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretm_ff(.din (sw_st_e),
		              .q   (sw_st_m),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretg_ff(.din (sw_st_m),
		              .q   (sw_st_g),
		              .clk (clk),
		              .se  (se), .si(), .so());
   dff_s stbretw2_ff(.din (sw_st_g),
		               .q   (sw_st_w2),
		               .clk (clk),
		               .se  (se), .si(), .so());
//   assign stb_retry = {4{sw_st_w2}} & st_thr_w2 & ~stb_blocked;

   assign st_in_pipe = ({4{sw_st_e}} & thr_e |
			                  {4{sw_st_m}} & thr_m |
			                  {4{sw_st_g}} & thr_w |
			                  {4{sw_st_w2}} & st_thr_w2);

   // don't really need to AND with wm_stbwait with current logic, but
   // for future use, this is left as is 
   assign stb_retry = ~stb_blocked_d1 & ~st_in_pipe & wm_stbwait;


   //
   // Quad Stores
   //
   dff_s #(1) stde_ff(.din (dec_swl_std_inst_d),
		                .q   (std_inst_e),
		                .clk (clk), .se(se), .si(), .so());

//   assign stq_inst_e = std_inst_e & lsu_ifu_quad_asi_e & fcl_dtu_inst_vld_e;
   assign std_done_e = std_inst_e & ~lsu_ifu_quad_asi_e & fcl_dtu_inst_vld_e;
   dff_s #(1) stdm_ff(.din (std_done_e),
		                .q   (std_done_m),
		                .clk (clk), .se(se), .si(), .so());
   
//   dff #(1) stqm_ff(.din (stq_inst_e),
//		                .q   (stq_inst_m),
//		                .clk (clk), .se(se), .si(), .so());
//   dff #(1) stqw_ff(.din (stq_inst_m),
//		                .q   (stq_inst_w),
//		                .clk (clk), .se(se), .si(), .so());
//   dff #(1) stqw2_ff(.din (stq_inst_w),
//		                 .q   (stq_inst_w2),
//		                 .clk (clk), .se(se), .si(), .so());

//   assign stq_in_pipe = ({4{stq_inst_m}} & thr_m |
//			                   {4{stq_inst_w}} & thr_w |
//			                   {4{stq_inst_w2}} & st_thr_w2);

//   assign stq_busy = (stq_in_pipe | lsu_ifu_stq_busy);
//   assign stq_wait_next = thr_e & {4{stq_inst_e}} | 
//                 			    stq_wait & stq_busy;
   
//   dffr #(4) stqwait_reg(.din (stq_wait_next),
//		                     .q   (stq_wait),
//		                     .rst (dtu_reset),
//		                     .clk (clk), .se(se), .si(), .so());
//
//   assign stq_done_thr = stq_wait & ~stq_busy | thr_m & {4{std_done_m}};
   
   
   //-----------------------------
   // FPRS
   //-----------------------------
   dff_s #(3) wrtd_w_reg(.din (thr_config_in_m[2:0]),
                        .q   (thr_config_in_w[2:0]),
                        .clk (clk), .se(se), .si(), .so());

   dff_s #(3) wrtd_w2_reg(.din (thr_config_in_w[2:0]),
                        .q   (thr_config_in_w2[2:0]),
                        .clk (clk), .se(se), .si(), .so());
   
   assign fprs_wrt_data = thr_config_in_w2;
   mux3ds #(3) fprs_mx0(.dout (fprs0_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs0),
		                    .in2  ({fprs0[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[0]),
		                    .sel1 (fprs_sel_old[0]),
		                    .sel2 (fprs_sel_set[0]));
   mux3ds #(3) fprs_mx1(.dout (fprs1_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs1),
		                    .in2  ({fprs1[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[1]),
		                    .sel1 (fprs_sel_old[1]),
		                    .sel2 (fprs_sel_set[1]));
   mux3ds #(3) fprs_mx2(.dout (fprs2_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs2),
		                    .in2  ({fprs2[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[2]),
		                    .sel1 (fprs_sel_old[2]),
		                    .sel2 (fprs_sel_set[2]));
   mux3ds #(3) fprs_mx3(.dout (fprs3_nxt),
		                    .in0  (fprs_wrt_data),
		                    .in1  (fprs3),
		                    .in2  ({fprs3[2], new_fprs[1:0]}),
		                    .sel0 (fprs_sel_wrt[3]),
		                    .sel1 (fprs_sel_old[3]),
		                    .sel2 (fprs_sel_set[3]));

   // make resettable for now.  Eventually change to non-reset
   // Done
   dff_s #(3) t0_fprs(.din (fprs0_nxt),
		                 .q   (fprs0),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t1_fprs(.din (fprs1_nxt),
		                 .q   (fprs1),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t2_fprs(.din (fprs2_nxt),
		                 .q   (fprs2),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());
   dff_s #(3) t3_fprs(.din (fprs3_nxt),
		                 .q   (fprs3),
//		                 .rst (dtu_reset),
		                 .clk (clk), .se(se), .si(), .so());

   assign fprs_en_s = {fprs3[2],fprs2[2],fprs1[2],fprs0[2]};
   assign fpen_vec_s = (tlu_ifu_pstate_pef & fprs_en_s & thr_f);
   assign fpen_s = (|fpen_vec_s[3:0]);
   dff_s #(1) fpend_ff(.din (fpen_s),
		                 .q   (swl_dec_fp_enable_d),
		                 .clk (clk), .se(se), .si(), .so());

   // unprotected since synopsys does not use one hot mux
   mux4ds #(3) curr_fprs_mx(.dout (fprs_d),
			                      .in0  (fprs0),
			                      .in1  (fprs1),
			                      .in2  (fprs2),
			                      .in3  (fprs3),
			                      .sel0 (thr_d[0]),
			                      .sel1 (thr_d[1]),
			                      .sel2 (thr_d[2]),
			                      .sel3 (thr_d[3]));

   dff_s #(3) fprse_reg(.din (fprs_d),
		                  .q   (fprs_e),
		                  .clk (clk), .se(se), .si(), .so());

   assign new_fprs[1] = dec_swl_frf_upper_d | fprs_d[1];
   assign new_fprs[0] = dec_swl_frf_lower_d | fprs_d[0];

   // writes to fprs are done by software
   assign wrt_fprs_w = ifu_tlu_inst_vld_w & dec_swl_wrtfprs_w &
			                 ~flush_all_w;

   dff_s #(1) fpwr_ff(.din (wrt_fprs_w),
                    .q   (wrt_fprs_w2),
                    .clk (clk), .se(se), .si(), .so());
   
   assign sel_wrt = st_thr_w2 & {4{wrt_fprs_w2}};
   assign fprs_sel_set = thr_d & {4{dec_swl_fpop_d & swl_dec_fp_enable_d &
                                    fcl_dtu_inst_vld_d}};
   assign fprs_sel_wrt = ~fprs_sel_set & sel_wrt;
   assign fprs_sel_old = ~sel_wrt & ~fprs_sel_set;

   sink #(52) s0(.in (thrconf_out_e));
   
   
endmodule // sparc_ifu_swl

// Local Variables:
// verilog-library-directories:("../../rtl" ".")
// End:
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_swpla.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_lfsr5
//  Description:	
//  The IFQ is the icache input queue.  This communicates between the
//  IFU and the outside world.  It handles icache misses and
//  invalidate requests from the crossbar.  
*/
////////////////////////////////////////////////////////////////////////

module sparc_ifu_swpla(/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [31:0]  in;
   output 	 out;

   wire [31:0] 	 in;
   reg 		 out;
   

   always @ (in)
     begin
	      if (in[31:30] == 2'b01)            // call
	        out = 1'b1;
	      else if (in[31:30] == 2'b00)       // branch, sethi, nop
	        begin
	           if (in[24:22] == 3'b100) // nop/sethi
	             out = 1'b0;
	           else // branch
	             out = 1'b1;
	        end // if (in[31:30] == 2'b00)
	      else if (in[31:30] == 2'b10)        // arith, shift, mem#, mov
	        begin
	           if (in[24:23] == 2'b11)  // wrpr, vis, save, jmpl
	             out = 1'b1;
	           else if (in[24] == 1'b0) // arith
	             begin
		              if (in[22] == 1'b0) // alu op
		                out = 1'b0;
		              else if ((in[22] == 1'b1) && (in[20:19] == 2'b00))
		                // subc or addc
		                out = 1'b0;
		              else // mul, div
		                out = 1'b1;
	             end // if (in[24] == 1'b0)
	           else // if (in[24:23] == 2'b10)  shft, mov, rdpr, tag
	             begin
		              if (in[22:19] == 4'h4) // mulscc
		                out = 1'b1;
		              else if (in[22] == 1'b0)  // shft, tag
		                out = 1'b0;
		              else if  ((in[22:19] == 4'hc) ||  (in[22:19] == 4'hf)) // mov
		                out = 1'b0;
//		              else if (in[22:19] == 4'ha)  // rdpr
//		                out = 1'b0;
		              else // rdsr, mem#, popc, flushw, rdpr
		                out = 1'b1;
	             end // if ((in[24] == 1'b1) && (in[23] == 1'b0))
	        end // if (in[31:30] == 2'b10)
	      else // ld st
	        begin
//	           if (in[24] & in[22] & in[21] & ~in[20] & in[19]) // prefetch
//	             out = 1'b0;
             if (in[24] | in[23] | ~in[21]) // fp, alt space or ld
	             out = 1'b1;
//	           else if (in[24]) // FP and CAS
//	             out = 1'b1;
//	           else if (in[23] & in[20] & in[19]) // stda
//	             out = 1'b1;
	           else if ((~in[23]) && (in[22:19] == 4'he))  // stx
	             out = 1'b0;
	           else if (in[22:21] == 2'b01) // other st
	             out = 1'b0;
	           else // other atomic
	             out = 1'b1;
	        end // else: !if(in[31:30] == 2'b10)
     end // always @ (in)

   sink #(32) s0(.in (in));
   
endmodule // sparc_ifu_swpla


// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_thrcmpl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_thrcmpl
//  Description:	
//  The thread completion block processes the completion signals fomr
//  the different cpu blocks and generates a unified completion
//  signal. 
*/

module sparc_ifu_thrcmpl(/*AUTOARG*/
   // Outputs
   completion, wm_imiss, wm_other, swl_esl_icmiss_out,
   // Inputs
   clk, se, si, reset, fcl_ifq_icmiss_s1, erb_dtu_ifeterr_d1, 
   sw_cond_s, en_spec_g, atr_s, dtu_fcl_thr_active, ifq_dtu_thrrdy, 
   ifq_dtu_pred_rdy, exu_lop_done, branch_done_d, fixedop_done, 
   ldmiss, spec_ld_d, trap, retr_thr_wakeup, flush_wake_w2, 
   ldhit_thr, spec_ld_g, clear_wmo_e, wm_stbwait, stb_retry, 
   rst_thread, trap_thrrdy, thr_s2, thr_e, thr_s1, fp_thrrdy, 
   lsu_ifu_ldst_cmplt, sta_done_e, killed_inst_done_e
   );

   input     clk, se, si, reset;

   input     fcl_ifq_icmiss_s1;
   input     erb_dtu_ifeterr_d1;
   
   input     sw_cond_s;
   input     en_spec_g;
   input     atr_s;

   input [3:0] dtu_fcl_thr_active;
   input [3:0] ifq_dtu_thrrdy,         // I$ miss completion
               ifq_dtu_pred_rdy,
		           exu_lop_done,  // mul, div, wrpr, sav, rest
               branch_done_d,
		           fixedop_done;           // br, rdsr, wrs/pr, 
   input [3:0] ldmiss,
		           spec_ld_d,
		           trap,
		           retr_thr_wakeup,
		           flush_wake_w2,
		           ldhit_thr,
		           spec_ld_g;

   input       clear_wmo_e;
   input [3:0] wm_stbwait,
               stb_retry;

   input [3:0] rst_thread,
		           trap_thrrdy;

   input [3:0] thr_s2,
		           thr_e,
		           thr_s1;
   
   input [3:0] fp_thrrdy;

   input [3:0] lsu_ifu_ldst_cmplt;	   // sta local, ld and atomic done
   
   input       sta_done_e,
		           killed_inst_done_e;        // long lat op was killed
   
   // .. Other completion signals needed
   // 1. STA completion from LSU -- real mem done 10/03, local TBD
   // 2. Atomic completion  -- done
   // 3. membar completion (lsu) -- done
   // 4. flush completion (lsu)
   // 5. FP op completion (ffu)
   // 

   output [3:0] completion;
   output [3:0] wm_imiss;
   output [3:0] wm_other;
   output       swl_esl_icmiss_out;

   // local signals
   wire [3:0]   wm_imiss,
		            wm_other,
		            wmi_nxt,
		            wmo_nxt;

   wire [3:0]   clr_wmo_thr_e;
   
   wire [3:0]   ldst_thrrdy,
		            ld_thrrdy,
		            sta_thrrdy,
		            killed_thrrdy,
		            fp_thrrdy,
                pred_ifq_rdy,
                imiss_thrrdy,
		            other_thrrdy;
   //   wire [3:0] 	can_imiss;
   
   //---------------------------------------------------------------------- 
   // Code begins here
   //----------------------------------------------------------------------
   
   // Thread completion
   // Since an imiss can overlap with anything else, have to make sure
   // the imiss condition has been cleared.
   // Imiss itself has to make sure ALL OTHER conditions have been
   // cleared.  In this code, I am not checking for branches being
   // cleared, since Imiss is assumed to take much longer than a branch.
   // -- may not be a valid assumption, since milhits could be faster

//   assign  can_imiss = fcl_ifq_canthr;
                        // & (wm_imiss | ({4{fcl_ifq_icmiss_s1}} & thr_s1));
   
   dffr_s #(4) wmi_ff(.din (wmi_nxt),
		              .clk (clk),
		              .q   (wm_imiss),
		              .rst (reset),
		              .se  (se), .si(), .so());

   dffr_s #(4) wmo_ff(.din (wmo_nxt),
		              .clk (clk),
		              .q   (wm_other),
		              .rst (reset),
		              .se  (se), .si(), .so());

   assign  wmi_nxt = ({4{fcl_ifq_icmiss_s1}} & thr_s1) | // set
		                   ({4{erb_dtu_ifeterr_d1}} & thr_e) |
			                   (wm_imiss & ~imiss_thrrdy);    // reset

   // clear wm_other when we have a retracted store
   assign  clr_wmo_thr_e = {4{clear_wmo_e}} & thr_e;

   assign  wmo_nxt = (({4{sw_cond_s}} & thr_s2 & ~clr_wmo_thr_e) | 
		                  trap | ldmiss) & dtu_fcl_thr_active | 
                      rst_thread |  // set
		                  wm_other & dtu_fcl_thr_active &
		                  ~(other_thrrdy | spec_ld_d | clr_wmo_thr_e); // reset

   // A load hit signal is always for the load which is being filled
   // to the RF.  If speculation is enabled, the load would have
   // completed even before the hit signal.  So need to suppress the
   // completions signal.

   // load miss, st buf hit, ld/st alternate completion
   assign ldst_thrrdy = lsu_ifu_ldst_cmplt & ~spec_ld_g;   
   assign ld_thrrdy = ldhit_thr & {4{~en_spec_g}};
   assign sta_thrrdy = thr_e & {4{sta_done_e}};
   assign killed_thrrdy = thr_e & {4{killed_inst_done_e}};

   // everthing else
   assign other_thrrdy = (ldst_thrrdy     |     // ld, sta local, atomic
                          branch_done_d   |     // br
	                        ld_thrrdy       |     // load hit without spec
	                        exu_lop_done    |     // mul, div, win mgmt
	                        fixedop_done    |     // rdsr, wrspr
	                        killed_thrrdy   |     // ll op was anulled
    	                    retr_thr_wakeup |     // retract cond compl
	                        flush_wake_w2   |     // wake up after ecc 
	                        fp_thrrdy       |     // fp completion
	                        sta_thrrdy      |     // sta to real memory
                	        trap_thrrdy);         // trap

   // Imiss predicted ready
   assign pred_ifq_rdy = ifq_dtu_pred_rdy & {4{~atr_s}} & dtu_fcl_thr_active;
   assign imiss_thrrdy = pred_ifq_rdy | ifq_dtu_thrrdy;

   assign swl_esl_icmiss_out = (wm_imiss[0] & ~imiss_thrrdy[0]) | wmi_nxt[0];
   
//   assign completion = imiss_thrrdy & (~(wm_other | wm_stbwait) |
//					                               other_thrrdy) |       //see C1
//		                   other_thrrdy & (~(wm_imiss | wmi_nxt));

//   assign completion = (imiss_thrrdy & ~(wm_other | wm_stbwait) |
//		                    other_thrrdy & ~(wm_stbwait | wm_imiss) |
//                        stb_retry & ~(wm_other | wm_imiss) |
//                        imiss_thrrdy & other_thrrdy & ~wm_stbwait |
//                        imiss_thrrdy & stb_retry & ~wm_other |
//                        stb_retry & other_thrrdy & ~wm_imiss);

   assign completion = ((imiss_thrrdy | ~wm_imiss) &
                        (other_thrrdy | ~wm_other) &
                        (stb_retry | ~wm_stbwait) &
                        (wm_imiss | wm_other | wm_stbwait));

   // C1: should we do ~(wm_other | wmo_nxt)??
   // When an imiss is pending, we cannot be doing another fetch, so I
   // don't think so.  It seems nice and symmetric to put it in
   // though, unfortunately this results in a timing problem on swc_s 
   // and trap
   
endmodule // sparc_ifu_thrcmpl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_thrfsm.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_swlthrfsm
//  Description:	
//  The switch logithrfsm contains the thread state machine.  
*/

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_thrfsm(/*AUTOARG*/
   // Outputs
   so, thr_state, thr_nstate,
   // Inputs
   completion, schedule, spec_ld, ldhit, stall, int_activate, 
   start_thread, thaw_thread, nuke_thread, rst_thread, switch_out, 
   halt_thread, sw_cond, clk, se, si, reset,
   // jtag interface
   rtap_ifu_thrfsm_wr_en, rtap_ifu_thrfsm_wr_data
   );

   // thread specific input
   input  completion,   // the op this thread was waiting for is complete
	        schedule,     // this thread was just switched in
	        spec_ld,      // speculative switch in
	        ldhit,        // speculation was correct
	        stall,        // stall thread for ldmiss, imiss or trap
	        int_activate, // activate this thread
          halt_thread,
	        start_thread,    // wake up this thread from dead state
	        nuke_thread,
          thaw_thread,
	        rst_thread;      // reset this thread

   // common inputs
   input  switch_out,   // this thread was just switched out
	        sw_cond;	// wait until completion signal is received

   input       clk, se, si, reset;

   // jtag interface
   input rtap_ifu_thrfsm_wr_en;
   input [4:0] rtap_ifu_thrfsm_wr_data;

   output      so;

   output reg [4:0] thr_state;
   output     [4:0] thr_nstate;

   // local signals
   reg [4:0]    next_state;

   assign thr_nstate = next_state;
   
   //
   // Code Begins Here
   //


//   assign       spec_rdy     = thr_state[`TCR_READY];

   always @ (/*AUTOSENSE*/ completion
             or halt_thread or int_activate or ldhit or nuke_thread
             or rst_thread or schedule or spec_ld or stall
             or start_thread or sw_cond or switch_out or thaw_thread 
             or thr_state)
     begin
	      case (thr_state[4:0])
          5'b00000:  // 5'b00000
	          begin
	             if (rst_thread | thaw_thread)
		             next_state = 5'b00001;
	             else if (start_thread)    
		             next_state = 5'b11001;
	             else  // all other interrupts ignored
		             next_state = thr_state[4:0];
	          end

	        5'b00010:  // 5'b00010
	          begin
	             if (nuke_thread)
		             next_state = 5'b00000;
	             else if (rst_thread | thaw_thread)
		             next_state = 5'b00001;
	             else if (int_activate | start_thread) 
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end
	        
	        5'b11001:       // 5'b11001
	          begin
	             if (stall)     
		             // trap also kills inst_s2 and nir
		             // Ldmiss should not happen in this state
		             next_state = 5'b00001;
	             else if (schedule)
		             next_state = 5'b00101;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_RDY

	        5'b00101:       // 5'b00101
	          begin
	             if (stall | sw_cond)
		             // trap also kills inst_s2 and nir
		             // ldmiss should not happen in this state		 
		             next_state = 5'b00001;
	             else if (switch_out)
	               // on an interrupt or thread stall, the fcl has to
	               // switch out the thread and inform the fsm 
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_RUN

	        5'b00001:       // 5'b00001
	          begin
	             if (nuke_thread) 
		             next_state = 5'b00000;
	             else if (halt_thread) // exclusive with above
		             next_state = 5'b00010;
	             else if (stall) // excl. with above
		             next_state = 5'b00001;
	             else if (spec_ld) // exclusive with above
		             next_state = 5'b10011;
	             else if (completion & ~halt_thread)
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_WAIT
	        
	        5'b10011:       // 5'b10011
	          begin
	             if (stall)
		             next_state = 5'b00001;
	             else if (schedule & ~ldhit) // exclusive
		             next_state = 5'b00111;
	             else if (schedule & ldhit)  // exclusive
		             next_state = 5'b00101;
	             else if (ldhit)
		             next_state = 5'b11001;
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_SPEC_RDY

	        5'b00111:       // 5'b00111
	          begin
	             if (stall | sw_cond)
		             next_state = 5'b00001;
	             else if ((ldhit) & switch_out)
		             next_state = 5'b11001;
	             else if ((ldhit) & ~switch_out)
		             next_state = 5'b00101;
	             else if (~(ldhit) & switch_out)
		             next_state = 5'b10011;
	             // on an interrupt or thread stall, the fcl has to
	             // switch out the thread and inform the fsm 
	             else
		             next_state = thr_state[4:0];
	          end // case: `THRFSM_SPEC_RUN

//VCS coverage off
	        default:
	          begin
               // synopsys translate_off
		     // 0in <fire -message "thrfsm.v: Error! Invalid State"

           
	             $display("ILLEGAL_THR_STATE", "thrfsm.v: Error! Invalid State %b\n", thr_state);
                 $finish();
		     
               // synopsys translate_on
	             if (rst_thread)
		             next_state = 5'b00001;
	             else if (nuke_thread)
		             next_state = 5'b00000;		 
	             else 
		             next_state = thr_state[4:0];
	          end
//VCS coverage on
	      endcase // casex({thr_state[4:0]})
     end // always @ (...

   // trin: modifying for thread state overwrite
   // // thread config register (tcr)
   // dffr_s #(5) tcr(.din  (next_state),
	  //            .clk  (clk),
	  //            .q    (thr_state),
	  //            .rst  (reset),
	  //            .se   (se), .so(), .si());

   // flop jtag inputs to not affect timing
   always @ (posedge clk)
   begin
      if (reset)
      begin
         thr_state <= 5'b00000;
      end
      else
      begin
         if (rtap_ifu_thrfsm_wr_en)
            thr_state <= rtap_ifu_thrfsm_wr_data;
         else
            thr_state <= next_state;
      end
   end


endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_ifu_errdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:  sparc_ifu_errdp
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////

// devices.xml


// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: ifu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
////////////////////////////////////////////////////////////////////////
/*
//
//  Module Name: ifu.h
//  Description:	
//  All ifu defines
*/

//--------------------------------------------
// Icache Values in IFU::ICD/ICV/ICT/FDP/IFQDP
//--------------------------------------------

// devices.xml








// `IC_WAY_MASK

// Set Values
// !!IMPORTANT!! a change to IC_LINE_SZ will mean a change to the code as
//   well.  Unfortunately this has not been properly parametrized.
//   Changing the IC_LINE_SZ param alone is *not* enough.
// `define IC_LINE_SZ  32



// !!IMPORTANT!! a change to IC_TAG_HI will mean a change to the code as
//   well.  Changing the IC_TAG_HI param alone is *not* enough to
//   change the PA range. 
// highest bit of PA


// Derived Values
// IC_IDX_HI = log(icache_size/4ways) - 1
// 11


// 4095
// `define IC_ARR_HI (`IC_SZ/`IC_NUM_WAY - 1)

// number of entries - 1 = 511

// 128 - 1

// 32


// 12


// 28

// `define IC_TAG_MASK_ALL ((`IC_TLB_TAG_SZ * `IC_NUM_WAY)-1):0


// 4

// `define IC_PARITY_PADDING (32 - `IC_TAG_SZ - 1)




// 7


// tags for all 4 ways + parity
// 116
// `define IC_TAG_ALL   ((`IC_TAG_SZ * `IC_NUM_WAY) + 4)

// 115
// `define IC_TAG_ALL_HI   ((`IC_TAG_SZ * `IC_NUM_WAY) + 3)

// physical implementation defines














// TLB
// `define IC_TLB_TAG_SZ 30
// tag + 1 bit parity



























//----------------------------------------------------------------------
// For thread scheduler in IFU::DTU::SWL
//----------------------------------------------------------------------
// thread states:  (thr_state[4:0])









// thread configuration register bit fields







//----------------------------------------------------------------------
// For MIL fsm in IFU::IFQ
//----------------------------------------------------------------------











//---------------------------------------------------
// Interrupt Block
//---------------------------------------------------







//-------------------------------------
// IFQ
//-------------------------------------
// valid bit plus ifill













//`ifdef SPARC_L2_64B


//`else
//`define BANK_ID_HI 8
//`define BANK_ID_LO 7
//`endif

//`define CPX_INV_PA_HI  116
//`define CPX_INV_PA_LO  112







//----------------------------------------
// IFU Traps
//----------------------------------------
// precise















// disrupting













module sparc_ifu_errdp(/*AUTOARG*/
   // Outputs
   so, ifu_lsu_ldxa_data_w2, erb_dtu_imask, erd_erc_tlbt_pe_s1, 
   erd_erc_tlbd_pe_s1, erd_erc_tagpe_s1, erd_erc_nirpe_s1, 
   erd_erc_fetpe_s1, erd_erc_tte_pgsz, 
   // Inputs
   rclk, se, si, erb_reset, itlb_rd_tte_data, itlb_rd_tte_tag, 
   itlb_ifq_paddr_s, wsel_fdp_fetdata_s1, wsel_fdp_topdata_s1, 
   wsel_erb_asidata_s, ict_itlb_tags_f, icv_itlb_valid_f, 
   lsu_ifu_err_addr, spu_ifu_err_addr_w2, fdp_erb_pc_f, 
   exu_ifu_err_reg_m, exu_ifu_err_synd_m, ffu_ifu_err_reg_w2, 
   ffu_ifu_err_synd_w2, tlu_itlb_rw_index_g, erc_erd_pgsz_b0, 
   erc_erd_pgsz_b1, erc_erd_erren_asidata, erc_erd_errstat_asidata, 
   erc_erd_errinj_asidata, ifq_erb_asidata_i2, ifq_erb_wrtag_f, 
   ifq_erb_wrindex_f, erc_erd_asiway_s1_l, fcl_erb_itlbrd_data_s, 
   erc_erd_ld_imask, erc_erd_asisrc_sel_icd_s_l, 
   erc_erd_asisrc_sel_misc_s_l, erc_erd_asisrc_sel_err_s_l, 
   erc_erd_asisrc_sel_itlb_s_l, erc_erd_errasi_sel_en_l, 
   erc_erd_errasi_sel_stat_l, erc_erd_errasi_sel_inj_l, 
   erc_erd_errasi_sel_addr_l, erc_erd_miscasi_sel_ict_l, 
   erc_erd_miscasi_sel_imask_l, erc_erd_miscasi_sel_other_l, 
   erc_erd_asi_thr_l, erc_erd_eadr0_sel_irf_l, 
   erc_erd_eadr0_sel_itlb_l, erc_erd_eadr0_sel_frf_l, 
   erc_erd_eadr0_sel_lsu_l, erc_erd_eadr1_sel_pcd1_l, 
   erc_erd_eadr1_sel_l1pa_l, erc_erd_eadr1_sel_l2pa_l, 
   erc_erd_eadr1_sel_other_l, erc_erd_eadr2_sel_mx1_l, 
   erc_erd_eadr2_sel_wrt_l, erc_erd_eadr2_sel_mx0_l, 
   erc_erd_eadr2_sel_old_l
   );

   input       rclk, 
               se, 
               si, 
               erb_reset;

   input [42:0] itlb_rd_tte_data;   // this is in s1
   input [58:0] itlb_rd_tte_tag;    // this is in s1
   input [39:10] itlb_ifq_paddr_s;
   input [33:0] wsel_fdp_fetdata_s1,    
		            wsel_fdp_topdata_s1;
   input [33:0] wsel_erb_asidata_s;
   
   input [((((39 - (6 + 5))+1) * 2)-1):0] ict_itlb_tags_f;
   input [3:0]              icv_itlb_valid_f;

   input [47:4]  lsu_ifu_err_addr;
   input [39:4]  spu_ifu_err_addr_w2;
   input [47:0]  fdp_erb_pc_f;
   
   input [7:0]   exu_ifu_err_reg_m;
   input [7:0]   exu_ifu_err_synd_m;
   input [5:0]   ffu_ifu_err_reg_w2;
   input [13:0]  ffu_ifu_err_synd_w2;
   input [5:0]   tlu_itlb_rw_index_g;

   input         erc_erd_pgsz_b0,
                 erc_erd_pgsz_b1;

   input [1:0]   erc_erd_erren_asidata;
   input [22:0]  erc_erd_errstat_asidata;
   input [31:0]  erc_erd_errinj_asidata;   
   input [47:0]  ifq_erb_asidata_i2;

   input [(39 - (6 + 5))-1:0] ifq_erb_wrtag_f;
   input [(6 + 5):4]   ifq_erb_wrindex_f;
   
   // mux selects
   input [3:0]  erc_erd_asiway_s1_l;
   input        fcl_erb_itlbrd_data_s;
   input        erc_erd_ld_imask;
   
   input        erc_erd_asisrc_sel_icd_s_l,  
		            erc_erd_asisrc_sel_misc_s_l,
		            erc_erd_asisrc_sel_err_s_l,
		            erc_erd_asisrc_sel_itlb_s_l;

   input        erc_erd_errasi_sel_en_l,
		            erc_erd_errasi_sel_stat_l,
		            erc_erd_errasi_sel_inj_l,
		            erc_erd_errasi_sel_addr_l;

   input        erc_erd_miscasi_sel_ict_l,
		            erc_erd_miscasi_sel_imask_l,
		            erc_erd_miscasi_sel_other_l;

   input [3:0]  erc_erd_asi_thr_l;   
	 
   input [3:0]  erc_erd_eadr0_sel_irf_l,
		            erc_erd_eadr0_sel_itlb_l,
		            erc_erd_eadr0_sel_frf_l,
		            erc_erd_eadr0_sel_lsu_l;
   
   input [3:0]  erc_erd_eadr1_sel_pcd1_l,
		            erc_erd_eadr1_sel_l1pa_l,
		            erc_erd_eadr1_sel_l2pa_l,
		            erc_erd_eadr1_sel_other_l;
   
   input [3:0]  erc_erd_eadr2_sel_mx1_l,
		            erc_erd_eadr2_sel_wrt_l,
		            erc_erd_eadr2_sel_mx0_l,
		            erc_erd_eadr2_sel_old_l;

   
   output       so;
   output [63:0] ifu_lsu_ldxa_data_w2;
   output [38:0] erb_dtu_imask;
//   output [9:0]  erb_ifq_paddr_s;
   
   output [1:0]  erd_erc_tlbt_pe_s1,
		             erd_erc_tlbd_pe_s1;
   output [3:0]  erd_erc_tagpe_s1;
   output        erd_erc_nirpe_s1,
		             erd_erc_fetpe_s1;

   output [2:0]  erd_erc_tte_pgsz;


//   
// local signals   
//

   wire [47:4]   lsu_err_addr;
   
   wire [((((39 - (6 + 5))+1) * 2)-1):0]  ictags_s1;
   wire [3:0]               icv_data_s1;
   reg  [34:0]              tag_asi_data;

   wire [47:4]              t0_eadr_mx0_out,
		                        t1_eadr_mx0_out,
		                        t2_eadr_mx0_out,
		                        t3_eadr_mx0_out,
 		                        t0_eadr_mx1_out,
		                        t1_eadr_mx1_out,
		                        t2_eadr_mx1_out,
		                        t3_eadr_mx1_out;
   
   wire [47:4]              t0_err_addr_nxt,
		                        t0_err_addr,
	 	                        t1_err_addr_nxt,
		                        t1_err_addr,
		                        t2_err_addr_nxt,
		                        t2_err_addr,
		                        t3_err_addr_nxt,
		                        t3_err_addr;
   
   wire [47:4]              err_addr_asidata;
	 
   wire [63:0]              formatted_tte_data,
		                        formatted_tte_tag,
		                        tlb_asi_data,
		                        misc_asi_data,
		                        err_asi_data,
                            ldxa_data_s,
                            ldxa_data_d;
   
   wire [39:4]              paddr_s1,
		                        paddr_d1;
   
   wire [39:4]              ifet_addr_f;
   
   wire [47:0]              pc_s1;
   wire [47:4]              pc_d1;
   wire [7:0]               irfaddr_w,
                            irfsynd_w;
   wire                     irfaddr_4_w;
   wire [5:0]               itlb_asi_index;

   wire [38:0]              imask_next;

   wire                     clk;
   
   
//
// Code Begins Here
//
   assign                   clk = rclk;
   
//-------------
// Tags
//-------------   
   dff_s #(((39 - (6 + 5))+1) * 2) tags_reg(.din (ict_itlb_tags_f),
		                           .q   (ictags_s1),
		                           .clk (clk),
		                           .se  (se), .si(), .so());

   dff_s #(4) vbits_reg(.din (icv_itlb_valid_f[3:0]),
		                  .q   (icv_data_s1),
		                  .clk (clk), .se(se), .si(), .so());

   // // check parity
   // sparc_ifu_par32  tag_par0(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY0_MASK]}),
			//                        .out (erd_erc_tagpe_s1[0]));
   // sparc_ifu_par32  tag_par1(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY1_MASK]}),
			//                        .out (erd_erc_tagpe_s1[1]));
   // sparc_ifu_par32  tag_par2(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY2_MASK]}),
			//                        .out (erd_erc_tagpe_s1[2]));
   // sparc_ifu_par32  tag_par3(.in  ({{`IC_TLB_PARITY_PADDING{1'b0}}, ictags_s1[`IC_TLB_TAG_WAY3_MASK]}),
			//                        .out (erd_erc_tagpe_s1[3]));












   
      sparc_ifu_par32  tag_par0(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*1-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[0]));
   

      sparc_ifu_par32  tag_par1(.in  ({{(32-((39 - (6 + 5))+1)){1'b0}}, ictags_s1[((39 - (6 + 5))+1)*2-1 -: ((39 - (6 + 5))+1)]}),
                              .out (erd_erc_tagpe_s1[1]));
   



   // dp_mux4ds #(32) asitag_mux(.dout (tag_asi_data[31:0]),
			//  .in0  ({icv_data_s1[0], 1'b0, ictags_s1[28], 1'b0, ictags_s1[27:0]}),
			//  .in1  ({icv_data_s1[1], 1'b0, ictags_s1[57], 1'b0, ictags_s1[56:29]}),
			//  .in2  ({icv_data_s1[2], 1'b0, ictags_s1[86], 1'b0, ictags_s1[85:58]}),
			//  .in3  ({icv_data_s1[3], 1'b0, ictags_s1[115], 1'b0, ictags_s1[114:87]}),   
			 // .sel0_l (erc_erd_asiway_s1_l[0]),
			 // .sel1_l (erc_erd_asiway_s1_l[1]),
			 // .sel2_l (erc_erd_asiway_s1_l[2]),
			 // .sel3_l (erc_erd_asiway_s1_l[3]));

wire [((39 - (6 + 5))+2)-1:0] icv_data_s10 = {icv_data_s1[0], ictags_s1[((39 - (6 + 5))+1)*(0+1)-1], ictags_s1[((39 - (6 + 5))+1)*(0+1)-2 -: (39 - (6 + 5))]};
wire [((39 - (6 + 5))+2)-1:0] icv_data_s11 = {icv_data_s1[1], ictags_s1[((39 - (6 + 5))+1)*(1+1)-1], ictags_s1[((39 - (6 + 5))+1)*(1+1)-2 -: (39 - (6 + 5))]};


always @ *
begin
tag_asi_data = 0;

         if (erc_erd_asiway_s1_l[0] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s10[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s10[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s10[(39 - (6 + 5))+1];
         end
      

         else if (erc_erd_asiway_s1_l[1] == 1'b0)
         begin
            tag_asi_data[((39 - (6 + 5))-1):0] = icv_data_s11[((39 - (6 + 5))-1):0];
            tag_asi_data[32] = icv_data_s11[(39 - (6 + 5))];
            tag_asi_data[34] = icv_data_s11[(39 - (6 + 5))+1];
         end
      

end


//------------------
// Data
//------------------
   // parity check on instruction
   // This may have to be done in the next stage (at least partially)
   
   sparc_ifu_par34 nir_par(.in  (wsel_fdp_topdata_s1[33:0]),
			                     .out (erd_erc_nirpe_s1));
   sparc_ifu_par34 inst_par(.in  (wsel_fdp_fetdata_s1[33:0]),
			                      .out (erd_erc_fetpe_s1));

//----------------------------------------------------------------------
// TLB read data
//----------------------------------------------------------------------

//`ifdef SPARC_HPV_EN
   // don't include v(26) and u(24) bits in parity   
   sparc_ifu_par32 tt_tag_par0(.in  ({itlb_rd_tte_tag[33:27],
				                              itlb_rd_tte_tag[25],
				                              itlb_rd_tte_tag[23:0]}),
			                         .out (erd_erc_tlbt_pe_s1[0]));
//`else
//   // don't include v(28) and u(26) bits in parity
//   sparc_ifu_par32 tt_tag_par0(.in  ({itlb_rd_tte_tag[33:29],
//				                              itlb_rd_tte_tag[27],
//				                              itlb_rd_tte_tag[25:0]}),
//			                         .out (erd_erc_tlbt_pe_s1[0]));
//`endif // !`ifdef SPARC_HPV_EN
   
   
   sparc_ifu_par32 tt_tag_par1(.in  ({7'b0, itlb_rd_tte_tag[58:34]}),
			                         .out (erd_erc_tlbt_pe_s1[1]));
   
   sparc_ifu_par32 tt_data_par0(.in  (itlb_rd_tte_data[31:0]),
				                        .out (erd_erc_tlbd_pe_s1[0]));
   sparc_ifu_par16 tt_data_par1(.in  ({5'b0, itlb_rd_tte_data[42:32]}),
				                        .out (erd_erc_tlbd_pe_s1[1]));

//   assign erd_erc_tte_lock_s1 = itlb_rd_tte_data[`STLB_DATA_L];

   
//`ifdef	SPARC_HPV_EN
   assign erd_erc_tte_pgsz[2:0] = {itlb_rd_tte_data[23],
				                           itlb_rd_tte_data[16],
				                           itlb_rd_tte_data[12]};

   assign formatted_tte_tag[63:0] =
          {
//           `ifdef SUN4V_TAG_RD
           // implement this!
           itlb_rd_tte_tag[58:55],
//           `else
//         {4{itlb_rd_tte_tag[53]}},                                     // 4b
//           `endif

           itlb_rd_tte_tag[54],     // Parity                 1b
           itlb_rd_tte_tag[27], // mxsel2 - b27:22 vld    1b
           itlb_rd_tte_tag[17], // mxsel1 - b21:16 vld    1b
           itlb_rd_tte_tag[13], // mxsel0 - b15:13 vld    1b

           {8{itlb_rd_tte_tag[53]}},                                     // 8b
           itlb_rd_tte_tag[53:34], // 20b
           itlb_rd_tte_tag[33:28], // 6b
           itlb_rd_tte_tag[23:18], // 6b
           itlb_rd_tte_tag[16:14], // 3b
           itlb_rd_tte_tag[12:0]// 13b
           } ;
//`else
//   assign erd_erc_tte_pgsz[2:0] = {itlb_rd_tte_data[`STLB_DATA_21_19_SEL],
//				                           itlb_rd_tte_data[`STLB_DATA_18_16_SEL],
//				                           itlb_rd_tte_data[`STLB_DATA_15_13_SEL]};
//
//   assign formatted_tte_tag[63:0] =
//          {
//           {16{itlb_rd_tte_tag[54]}},                                    // 16b
//           itlb_rd_tte_tag[`STLB_TAG_VA_47_22_HI:`STLB_TAG_VA_47_22_LO], // 26b
//           itlb_rd_tte_tag[`STLB_TAG_VA_21_20_HI:`STLB_TAG_VA_21_20_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_19],
//           itlb_rd_tte_tag[`STLB_TAG_VA_18_17_HI:`STLB_TAG_VA_18_17_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_16],
//           itlb_rd_tte_tag[`STLB_TAG_VA_15_14_HI:`STLB_TAG_VA_15_14_LO], // 3b
//           itlb_rd_tte_tag[`STLB_TAG_VA_13],
//           itlb_rd_tte_tag[`STLB_TAG_CTXT_12_7_HI:`STLB_TAG_CTXT_12_7_LO],//13b
//           itlb_rd_tte_tag[`STLB_TAG_CTXT_6_0_HI:`STLB_TAG_CTXT_6_0_LO]
//           } ;
//`endif // !`ifdef SPARC_HPV_EN
   

//`ifdef	SPARC_HPV_EN
   assign formatted_tte_data[63:0] =
          {      
           itlb_rd_tte_tag[26],           // V    (1b)
           erc_erd_pgsz_b1,                        // pg SZ msb 4m or 512k
           erc_erd_pgsz_b0,                        // pg sz lsb 4m or 64k
           itlb_rd_tte_data[10],       // NFO  (1b)
           itlb_rd_tte_data[9],        // IE   (1b)
           10'b0,                                  // soft2 
           itlb_rd_tte_data[23], // pgsz b2
           itlb_rd_tte_tag[24],

           itlb_rd_tte_data[42],      // Parity   (1b)
           itlb_rd_tte_data[23],   // mxsel2_l (1b)
           itlb_rd_tte_data[16],   // mxsel1_l (1b)
           itlb_rd_tte_data[12],   // mxsel0_l (1b)
  
           2'b0,                                   // unused diag 2b
           1'b0,                                   // ?? PA   (28b)
           itlb_rd_tte_data[41:30],
           itlb_rd_tte_data[29:24],
           itlb_rd_tte_data[22:17],
           itlb_rd_tte_data[15:13],
           6'b0,                                   // ?? 12-7 (6b)
           itlb_rd_tte_data[8],         // L    (1b)
           itlb_rd_tte_data[7],        // CP   (1b)
           itlb_rd_tte_data[6],        // CV   (1b)
           itlb_rd_tte_data[5],         // E    (1b)
           itlb_rd_tte_data[4],         // P    (1b)
           itlb_rd_tte_data[3],         // W    (1b)
	         1'b0
        } ;
//`else // !`ifdef SPARC_HPV_EN
//
//   assign formatted_tte_data[63:0] =
//          {      
//           itlb_rd_tte_tag[`STLB_TAG_V],           // V    (1b)
//           erc_erd_pgsz_b1,                        // pg SZ msb 4m or 512k
//           erc_erd_pgsz_b0,                        // pg sz lsb 4m or 64k
//           itlb_rd_tte_data[`STLB_DATA_NFO],       // NFO  (1b)
//           itlb_rd_tte_data[`STLB_DATA_IE],        // IE   (1b)
//           9'b0,                                   // soft2 58-42 (17b)
//           8'b0,                                   // diag 8b
//	         itlb_rd_tte_tag[`STLB_TAG_U],           // U    (1b)
//           1'b0,                                   // ?? PA   (28b)
//           itlb_rd_tte_data[`STLB_DATA_PA_39_22_HI:`STLB_DATA_PA_39_22_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_21_19_HI:`STLB_DATA_PA_21_19_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_18_16_HI:`STLB_DATA_PA_18_16_LO],
//           itlb_rd_tte_data[`STLB_DATA_PA_15_13_HI:`STLB_DATA_PA_15_13_LO],
//           6'b0,                                   // ?? 12-7 (6b)
//           itlb_rd_tte_data[`STLB_DATA_L],         // L    (1b)
//           itlb_rd_tte_data[`STLB_DATA_CP],        // CP   (1b)
//           itlb_rd_tte_data[`STLB_DATA_CV],        // CV   (1b)
//           itlb_rd_tte_data[`STLB_DATA_E],         // E    (1b)
//           itlb_rd_tte_data[`STLB_DATA_P],         // P    (1b)
//           itlb_rd_tte_data[`STLB_DATA_W],         // W    (1b)
//           itlb_rd_tte_data[`STLB_DATA_G]          // G    (1b)
//        } ;
//`endif // !`ifdef SPARC_HPV_EN
   
   

   // mux in all asi values
   dp_mux2es #(64) itlbrd_mux(.dout (tlb_asi_data[63:0]),
			    .in0  (formatted_tte_tag[63:0]),
			    .in1  (formatted_tte_data[63:0]),
			    .sel  (fcl_erb_itlbrd_data_s));

   dp_mux4ds #(64) err_mux(.dout (err_asi_data[63:0]),
			 .in0  ({62'b0, erc_erd_erren_asidata}),
			 .in1  ({32'b0, erc_erd_errstat_asidata, 9'b0}),
			 .in2  ({32'b0, erc_erd_errinj_asidata}),
			 .in3  ({16'b0, err_addr_asidata, 4'b0}),
			 .sel0_l (erc_erd_errasi_sel_en_l),
			 .sel1_l (erc_erd_errasi_sel_stat_l),
			 .sel2_l (erc_erd_errasi_sel_inj_l),
			 .sel3_l (erc_erd_errasi_sel_addr_l));

   dp_mux3ds #(64) misc_asi_mux(.dout (misc_asi_data[63:0]),
			      .in0  ({29'b0, 
				            tag_asi_data[34:0]}),
			      .in1  ({25'b0, erb_dtu_imask}),
			      .in2  (64'b0),
			      .sel0_l (erc_erd_miscasi_sel_ict_l),
			      .sel1_l (erc_erd_miscasi_sel_imask_l),
			      .sel2_l (erc_erd_miscasi_sel_other_l));

   // Final asi data
   // May need to add a flop to this mux output before sending it to the LSU
   dp_mux4ds #(64) final_asi_mux(.dout (ldxa_data_s),
			       .in0  (tlb_asi_data[63:0]),
			       .in1  (err_asi_data),
			       .in2  (misc_asi_data),
			       .in3  ({30'b0,
				             wsel_erb_asidata_s[0],
				             wsel_erb_asidata_s[33:1]}), 
			       .sel0_l (erc_erd_asisrc_sel_itlb_s_l),
			       .sel1_l (erc_erd_asisrc_sel_err_s_l),
			       .sel2_l (erc_erd_asisrc_sel_misc_s_l),
			       .sel3_l (erc_erd_asisrc_sel_icd_s_l));

   dff_s #(64) ldxa_reg(.din (ldxa_data_s),
                      .q   (ldxa_data_d),
                      .clk (clk), .se(se), .si(), .so());
   assign ifu_lsu_ldxa_data_w2 = ldxa_data_d;

				   
//----------------------------------------
// Error Address
//----------------------------------------   

   assign ifet_addr_f = {ifq_erb_wrtag_f[(39 - (6 + 5))-1:0], 
                         ifq_erb_wrindex_f[(6 + 5):4]};

   // pc of latest access
   dff_s #(48) pcs1_reg(.din (fdp_erb_pc_f[47:0]),
		                  .q   (pc_s1[47:0]),
		                  .clk (clk), .se(se), .si(), .so());
   
   // Physical address
   assign paddr_s1[39:10] = itlb_ifq_paddr_s[39:10];
   assign paddr_s1[9:4]   = pc_s1[9:4];
   dff_s #(36) padd_reg(.din (paddr_s1[39:4]),
		                  .q   (paddr_d1[39:4]),
		                  .clk (clk), .se(se), .si(), .so());

//   assign erb_ifq_paddr_s[9:0] = pc_s1[9:0];

   // stage PC one more cycle
   dff_s #(44) pcd1_reg(.din (pc_s1[47:4]),
		                  .q   (pc_d1[47:4]),
		                  .clk (clk), .se(se), .si(), .so());

   // IRF address
   dff_s #(16) irf_reg(.din ({exu_ifu_err_reg_m[7:0],
                            exu_ifu_err_synd_m[7:0]}),
		                 .q   ({irfaddr_w[7:5], 
                            irfaddr_4_w,
                            irfaddr_w[3:0],
                            irfsynd_w[7:0]}),
		                 .clk (clk), .se(se), .si(), .so());

   // fix for bug 5594
   // nand2 + xnor
   assign irfaddr_w[4] = irfaddr_4_w ^ (irfaddr_w[5] & irfaddr_w[3]);

   // itlb asi address
   dff_s #(6) itlbidx_reg(.din (tlu_itlb_rw_index_g),
                        .q   (itlb_asi_index),
                        .clk (clk), .se(se), .si(), .so());


   // lsu error address
   dff_s #(44) lsadr_reg(.din (lsu_ifu_err_addr),
                       .q   (lsu_err_addr),
                       .clk (clk), .se(se), .si(), .so());

	  
   // mux in the different error addresses
   // thread 0
   dp_mux4ds #(44) t0_eadr_mx0(.dout  (t0_eadr_mx0_out),
			     .in0   ({24'b0, irfsynd_w[7:0], 4'b0, irfaddr_w[7:0]}),
			     .in1   ({38'b0, itlb_asi_index}),
			     .in2   ({17'b0, ffu_ifu_err_synd_w2[13:7], 
                    1'b0, ffu_ifu_err_synd_w2[6:0], 
                    6'b0, ffu_ifu_err_reg_w2[5:0]}),
			     .in3   (lsu_err_addr),
			     .sel0_l (erc_erd_eadr0_sel_irf_l[0]),
			     .sel1_l (erc_erd_eadr0_sel_itlb_l[0]),
			     .sel2_l (erc_erd_eadr0_sel_frf_l[0]),
			     .sel3_l (erc_erd_eadr0_sel_lsu_l[0]));

   dp_mux4ds #(44) t0_eadr_mx1(.dout  (t0_eadr_mx1_out),
			     .in0   (pc_d1[47:4]),
			     .in1   ({8'b0, paddr_d1[39:4]}),
			     .in2   ({8'b0, ifet_addr_f}),
			     .in3   ({8'b0, spu_ifu_err_addr_w2[39:4]}),
			     .sel0_l (erc_erd_eadr1_sel_pcd1_l[0]),
			     .sel1_l (erc_erd_eadr1_sel_l1pa_l[0]),
			     .sel2_l (erc_erd_eadr1_sel_l2pa_l[0]),
			     .sel3_l (erc_erd_eadr1_sel_other_l[0]));

   dp_mux4ds #(44) t0_eadr_mx2(.dout  (t0_err_addr_nxt),
			     .in0   (t0_eadr_mx0_out),
			     .in1   (t0_eadr_mx1_out),
			     .in2   (ifq_erb_asidata_i2[47:4]),
			     .in3   (t0_err_addr),
			     .sel0_l (erc_erd_eadr2_sel_mx0_l[0]),
			     .sel1_l (erc_erd_eadr2_sel_mx1_l[0]),
			     .sel2_l (erc_erd_eadr2_sel_wrt_l[0]),
			     .sel3_l (erc_erd_eadr2_sel_old_l[0]));

   dff_s #(44) t0_eadr_reg(.din (t0_err_addr_nxt),
		       .q   (t0_err_addr),
		       .clk (clk), .se(se), .si(), .so());

 // Use two threads unless this is defined

   // thread 1
   dp_mux4ds #(44) t1_eadr_mx0(.dout  (t1_eadr_mx0_out),
                 .in0   ({24'b0, irfsynd_w[7:0], 4'b0, irfaddr_w[7:0]}),
                 .in1   ({38'b0, itlb_asi_index}),
                 .in2   ({17'b0, ffu_ifu_err_synd_w2[13:7],
                    1'b0, ffu_ifu_err_synd_w2[6:0],
                    6'b0, ffu_ifu_err_reg_w2[5:0]}),
                 .in3   (lsu_err_addr),
                 .sel0_l (erc_erd_eadr0_sel_irf_l[1]),
                 .sel1_l (erc_erd_eadr0_sel_itlb_l[1]),
                 .sel2_l (erc_erd_eadr0_sel_frf_l[1]),
                 .sel3_l (erc_erd_eadr0_sel_lsu_l[1]));

   dp_mux4ds #(44) t1_eadr_mx1(.dout  (t1_eadr_mx1_out),
                 .in0   (pc_d1[47:4]),
                 .in1   ({8'b0, paddr_d1[39:4]}),
                 .in2   ({8'b0, ifet_addr_f}),
                 .in3   ({8'b0, spu_ifu_err_addr_w2[39:4]}),
//               .in3   ({44'b0}),
                 .sel0_l (erc_erd_eadr1_sel_pcd1_l[1]),
                 .sel1_l (erc_erd_eadr1_sel_l1pa_l[1]),
                 .sel2_l (erc_erd_eadr1_sel_l2pa_l[1]),
                 .sel3_l (erc_erd_eadr1_sel_other_l[1]));

   dp_mux4ds #(44) t1_eadr_mx2(.dout  (t1_err_addr_nxt),
                 .in0   (t1_eadr_mx0_out),
                 .in1   (t1_eadr_mx1_out),
                 .in2   (ifq_erb_asidata_i2[47:4]),
                 .in3   (t1_err_addr),
                 .sel0_l (erc_erd_eadr2_sel_mx0_l[1]),
                 .sel1_l (erc_erd_eadr2_sel_mx1_l[1]),
                 .sel2_l (erc_erd_eadr2_sel_wrt_l[1]),
                 .sel3_l (erc_erd_eadr2_sel_old_l[1]));

   dff_s #(44) t1_eadr_reg(.din (t1_err_addr_nxt),
               .q   (t1_err_addr),
               .clk (clk), .se(se), .si(), .so());

   // asi read
   dp_mux2ds #(44) asi_eadr_mx(.dout (err_addr_asidata),
                 .in0  (t0_err_addr),
                 .in1  (t1_err_addr),
                 .sel0_l (erc_erd_asi_thr_l[0]),
                 .sel1_l (erc_erd_asi_thr_l[1]));
















































































































































































































































































 // `ifndef CONFIG_NUM_THREADS
   
   // Instruction Mask
   dp_mux2es #(39) imask_en_mux(.dout (imask_next),
			      .in0  (erb_dtu_imask),
			      .in1  (ifq_erb_asidata_i2[38:0]),
			      .sel  (erc_erd_ld_imask));

   // need to reset top 7 bits only
   dffr_s #(39) imask_reg(.din (imask_next),
		      .q   (erb_dtu_imask),
		      .rst (erb_reset),
		      .clk (clk), .se(se), .si(), .so());

   sink #(4) s0(.in (pc_s1[3:0]));
   
endmodule // sparc_ifu_erb

// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_tlu_intctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_tlu_intctl
//  Description:        
//    Contains the code for receiving interrupts from the crossbar,
//    and sending interrupts out to other processors through the corssbar.
//    The interrupt receive register (INRR, asi=0x49/VA=0),  incoming
//    vector register (INVR, asi=0x7f/VA=0x40), and interrupt vector
//    dispatch register (INDR, asi=0x77/VA=0) are implemented in this
//    block.  This block also initiates thread reset/wake up when a
//    reset packet is received.  
//
*/

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



// from intdp.v for now


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


module sparc_tlu_intctl(/*AUTOARG*/
   // Outputs
   so, int_rst_l, tlu_ifu_hwint_i3, tlu_ifu_rstthr_i2, tlu_ifu_rstint_i2, 
   tlu_ifu_nukeint_i2, tlu_ifu_resumint_i2, tlu_ifu_pstate_ie, 
   int_tlu_longop_done,  inc_ind_ld_int_i1, inc_indr_req_valid, 
   inc_ind_rstthr_i1, // inc_ind_asi_thr, inc_ind_asi_wr_inrr, 
   // inc_ind_asi_rd_invr, inc_ind_asi_inrr, inc_ind_asi_wr_indr, 
   inc_ind_indr_grant, inc_ind_thr_m, tlu_lsu_int_ld_ill_va_w2,
   inc_indr_req_thrid, tlu_asi_data_nf_vld_w2, tlu_asi_rdata_mxsel_g, 
   // Inputs
   // modified to abide to the Niagara reset methodology 
   // clk, se, si, reset, const_cpuid, lsu_tlu_cpx_vld, lsu_tlu_cpx_req, 
   rclk, se, sehold, si, rst_tri_en, arst_l, grst_l, const_cpuid,  
   lsu_tlu_cpx_vld, lsu_tlu_cpx_req, lsu_tlu_pcxpkt_ack, tlu_ld_data_vld_g, 
   ind_inc_thrid_i1, ind_inc_type_i1, tlu_int_asi_vld, tlu_int_asi_load, 
   tlu_int_asi_store, tlu_int_asi_thrid, tlu_int_asi_state, tlu_int_tid_m, 
   tlu_int_pstate_ie, int_pending_i2_l, // indr_inc_rst_pkt, tlu_int_redmode,  
   tlu_asi_queue_rd_vld_g, tlu_va_ill_g); // tlu_flush_all_w2

//
// modified to abide to the Niagara reset methodology 
//   input            clk, se, si, reset;
   input            rclk, se, si;
   input            arst_l, grst_l;  
   input            sehold; 
   input            rst_tri_en; 
   input [3:0] 	    const_cpuid;

   input 	    lsu_tlu_cpx_vld;    // cpx from lsu
   input [3:0] 	    lsu_tlu_cpx_req;    // cpx req type
   // the flush bit is included in lsu_tlu_cpx_vld
   // input 	    lsu_tlu_cpx_nc;
   input 	    lsu_tlu_pcxpkt_ack;
   
// removed unused pins
// input [`INT_THR_HI:0] lsu_tlu_st_rs3_data_g;
// input 	    lsu_tlu_pmode;
// input [3:0] 	tlu_int_sftint_pend;
   
   input [4:0] 	ind_inc_thrid_i1; // connect to lsu_tlu_intpkt[12:8]
   input [1:0]	ind_inc_type_i1;  // connect to lsu_tlu_intpkt[16]

   input 	    tlu_int_asi_vld;
   input 	    tlu_int_asi_load;  // read enable
   input 	    tlu_int_asi_store; // write enable
   input [1:0] 	tlu_int_asi_thrid; // thread making asi request
   input [7:0] 	tlu_int_asi_state; // asi to be read/written
   // input        tlu_scpd_rd_vld_g; // rdata vld from scratchpad
   // removed no longer necessary 
   // input        tlu_va_all_zero_g; // va address - all zero 
   input        tlu_va_ill_g;      // illega va range 
   input        tlu_asi_queue_rd_vld_g; // rdata vld from asi queues
   input        tlu_ld_data_vld_g; // rdata vld from asi queues
   // input        tlu_flush_all_w2;  // flush pipe from tcl 

   input [1:0] 	tlu_int_tid_m;
   
   input [3:0] 	tlu_int_pstate_ie;
   // input [3:0] 	tlu_int_redmode;
   
   // from int_dp
   input [3:0] 	    int_pending_i2_l;   // uncleared interrupt
   // input 	    indr_inc_rst_pkt;
   // added for timing
   // input [1:0]	lsu_tlu_rst_pkt;

   output 	    int_rst_l, so;

   // to ifu
   output [3:0]     tlu_ifu_hwint_i3;   // interrupt
   output [3:0]     tlu_ifu_rstthr_i2;  // reset, nuke or resume
   output 	    tlu_ifu_rstint_i2;  // reset msg
   output           tlu_ifu_nukeint_i2; // idle/suspend message
   output 	    tlu_ifu_resumint_i2;// resume message
   output [3:0]	    tlu_ifu_pstate_ie;
   
   output [3:0]     int_tlu_longop_done;
// 
// removed - IFU will derive the signal locally
//   output [3:0]     tlu_ifu_int_activate_i3;// wake up signal for thread
   
   // to int_dp
   output [3:0]     inc_ind_ld_int_i1;          // ld new interrupt
   output [3:0]     inc_ind_rstthr_i1;          // ld new rst vector
   
   // convert the signal back to non-inverting version for grape
   // output [3:0]     inc_ind_asi_thr_l;          // choose asi op thread
   // output [3:0]     inc_ind_asi_thr;          // choose asi op thread
   // output [3:0]     inc_ind_asi_wr_inrr;        // write to INRR (per thread)
   // output [3:0]     inc_ind_asi_wr_indr;        // write to INDR
   // output [3:0]     inc_ind_asi_rd_invr;        // read INVR and 
                                                // reset corr. bit in INRR
   // obsolete output
   // output 	    inc_ind_asi_inrr;           // choose which reg to read
   // convert the signal back to non-inverting version for grape
   // output [3:0]     inc_ind_indr_grant_l;       // move on to next pcx pkt
   output [3:0]     inc_ind_indr_grant;       // move on to next pcx pkt
   // convert the signal back to non-inverting version for grape
   // output [3:0]     inc_ind_thr_m_l;            // M stage thread
   output [3:0]     inc_ind_thr_m;            // M stage thread
   
   // pcx pkt fields
   output 	    inc_indr_req_valid;     // valid bit for PCX int pkt
   output [1:0] inc_indr_req_thrid;     // thread sending pcx int pkt

   // to tlu
   // output tlu_lsu_int_ldxa_vld_w2;  // valid asi data from int or scpd 
   output tlu_asi_data_nf_vld_w2;  // valid asi data from int or scpd 
   output tlu_lsu_int_ld_ill_va_w2; // illega va range - load  
   // to intdp
   output [3:0] tlu_asi_rdata_mxsel_g; // mux selects to the asi rdata

   // local signals
   // wire indr_inc_rst_pkt;
   wire inc_ind_asi_inrr;           // choose which reg to read
   wire	int_tlu_asi_data_vld_g, int_tlu_asi_data_vld_w2;
   wire	int_ld_ill_va_g, int_ld_ill_va_w2;
   wire hw_int_i1,
		rst_int_i1,
		nuke_int_i1,
		resum_int_i1;

   wire [3:0] 	    int_thr_i1,
		    rstthr_i1,
		    asi_thr;

   wire [3:0] 	    int_pending_i2;
// 		    int_activate_i2;
   
   wire 	    asi_write, 
		    asi_read,
		    asi_invr,
		    asi_indr;
   
   wire [3:0] 	    indr_vld,
		    indr_rst,
		    indr_vld_next,
		    indr_grant;

   // added for bug 3945
   wire [3:0] indr_req_vec;
   wire indr_req_valid_disable;

   // wire [3:0] 	    int_or_redrst;
   wire [3:0] 	    intd_done;

   // wire 	    red_thread, valid_dest;
   wire 	    local_rst;  // local reset 
   wire 	    local_rst_l;  // local reset 
   wire 	    clk;        // local clk 
   

   //
   // Code Starts Here
   //
   //=========================================================================================
   //	reset
   //=========================================================================================

   dffrl_async dffrl_local_rst_l(
       .din  (grst_l),
       .clk  (clk),
       .rst_l(arst_l),
       .q    (local_rst_l),
       .se   (se),
       .si   (),
       .so   ()
   ); 
   assign local_rst = ~local_rst_l;
   assign int_rst_l = local_rst_l;

   // create local clk
   assign clk = rclk; 

   //-------------------------------------
   // Basic Operation
   //-------------------------------------
   sink s1(const_cpuid[3]);

   assign  tlu_ifu_pstate_ie = tlu_int_pstate_ie;

   // process cpx interrupt type
   // int = 00
   // the flush bit from cpx packet is now included in the
   // lsu_tlu_cpx_vld qualification
   assign  hw_int_i1 = (lsu_tlu_cpx_vld &
			// (lsu_tlu_cpx_req == `INT_RET) & ~lsu_tlu_cpx_nc &
			(lsu_tlu_cpx_req == 4'b0111) & 
			(ind_inc_thrid_i1[4:2] == const_cpuid[2:0])) ?
			 ~ind_inc_type_i1[1] & ~ind_inc_type_i1[0] :
	                 1'b0;
   //reset = 01
   // the flush bit from cpx packet is now included in the
   // lsu_tlu_cpx_vld qualification
   assign  rst_int_i1 = (lsu_tlu_cpx_vld &
			 // (lsu_tlu_cpx_req == `INT_RET) && ~lsu_tlu_cpx_nc &
			 (lsu_tlu_cpx_req == 4'b0111) &
			 (ind_inc_thrid_i1[4:2] == const_cpuid[2:0])) ?
			  ~ind_inc_type_i1[1] & ind_inc_type_i1[0] :
	                  1'b0;
   // idle/nuke = 10
   // the flush bit from cpx packet is now included in the
   // lsu_tlu_cpx_vld qualification
   assign  nuke_int_i1 = (lsu_tlu_cpx_vld &
			   // (lsu_tlu_cpx_req == `INT_RET) & ~lsu_tlu_cpx_nc &
			   (lsu_tlu_cpx_req == 4'b0111) & 
			   (ind_inc_thrid_i1[4:2] == const_cpuid[2:0])) ?
			    ind_inc_type_i1[1] & ~ind_inc_type_i1[0] :
	                    1'b0;
   // resume = 11
   // the flush bit from cpx packet is now included in the
   // lsu_tlu_cpx_vld qualification
   assign  resum_int_i1 = (lsu_tlu_cpx_vld &
			   // (lsu_tlu_cpx_req == `INT_RET) & ~lsu_tlu_cpx_nc &
			   (lsu_tlu_cpx_req == 4'b0111) & 
			   (ind_inc_thrid_i1[4:2] == const_cpuid[2:0])) ?
			    ind_inc_type_i1[1] & ind_inc_type_i1[0] :
	                    1'b0;

   dffr_s #1  rstint_ff(.din  (rst_int_i1),
		      .q    (tlu_ifu_rstint_i2),
		      .clk  (clk),
//
// modified to abide to the Niagara reset methodology 
//		      .rst  (reset),
		      .rst  (local_rst),
		      .se   (se), .si(), .so());
   
   dffr_s #1  nukint_ff(.din  (nuke_int_i1),
		      .q    (tlu_ifu_nukeint_i2),
		      .clk  (clk),
//
// modified to abide to the Niagara reset methodology 
//		      .rst  (reset),
		      .rst  (local_rst),
		      .se   (se), .si(), .so());
   
   dffr_s #1  resint_ff(.din  (resum_int_i1),
		      .q    (tlu_ifu_resumint_i2),
		      .clk  (clk),
//
// modified to abide to the Niagara reset methodology 
//		      .rst  (reset),
		      .rst  (local_rst),
		      .se   (se), .si(), .so());
   
   // decode int thread id
   assign  int_thr_i1[0] = ~ind_inc_thrid_i1[1] & ~ind_inc_thrid_i1[0];
   assign  int_thr_i1[1] = ~ind_inc_thrid_i1[1] &  ind_inc_thrid_i1[0];
   assign  int_thr_i1[2] =  ind_inc_thrid_i1[1] & ~ind_inc_thrid_i1[0];
   assign  int_thr_i1[3] =  ind_inc_thrid_i1[1] &  ind_inc_thrid_i1[0];

   assign  inc_ind_ld_int_i1 = {4{hw_int_i1}} & int_thr_i1;
   assign  inc_ind_rstthr_i1 = {4{rst_int_i1}} & int_thr_i1;
   assign  rstthr_i1 = {4{rst_int_i1 | nuke_int_i1 | resum_int_i1}} 
	                & int_thr_i1;

   // decode thr_m
   // convert the signal back to non-inverting version for grape
   /*
   assign  inc_ind_thr_m_l[0] = ~(~tlu_int_tid_m[1] & ~tlu_int_tid_m[0]);
   assign  inc_ind_thr_m_l[1] = ~(~tlu_int_tid_m[1] &  tlu_int_tid_m[0]);
   assign  inc_ind_thr_m_l[2] = ~( tlu_int_tid_m[1] & ~tlu_int_tid_m[0]);
   assign  inc_ind_thr_m_l[3] = ~( tlu_int_tid_m[1] &  tlu_int_tid_m[0]);
   */

   assign  inc_ind_thr_m[0] = ~tlu_int_tid_m[1] & ~tlu_int_tid_m[0];
   assign  inc_ind_thr_m[1] = ~tlu_int_tid_m[1] &  tlu_int_tid_m[0];
   assign  inc_ind_thr_m[2] =  tlu_int_tid_m[1] & ~tlu_int_tid_m[0];
   assign  inc_ind_thr_m[3] =  tlu_int_tid_m[1] &  tlu_int_tid_m[0];
   

   // Interrupt continues to be signalled even 1 cycle after read is
   // done.  This should not be a problem, since the lsu will probably
   // burn one cycle to complete the read by forwarding it to the reg
   // file.  Otherwise, just burn another cycle in the IFU before
   // starting the thread (this is also done right now).

   assign  int_pending_i2 = ~int_pending_i2_l;

   // removed IFU will derive the siganl locally
   /*
   assign  int_activate_i2 = ~int_pending_i2_l | tlu_int_sftint_pend;
   // send message to SWL to wake up thread if it is halted
   dff_s #4 act_signal_reg(.din (int_activate_i2[3:0]),
			 .q   (tlu_ifu_int_activate_i3[3:0]),
			 .clk (clk),
			 .se  (se), .si(), .so());
   */
   
   // ask IFU to schedule interrupt
   dff_s #4 int_signal_reg(.din (int_pending_i2[3:0]),
			 .q   (tlu_ifu_hwint_i3[3:0]),
			 .clk (clk),
			 .se  (se), .si(), .so());

   dff_s #4 rst_signal_reg(.din (rstthr_i1[3:0]),
			 .q   (tlu_ifu_rstthr_i2[3:0]),
			 .clk (clk),
			 .se  (se), .si(), .so());


   //----------------------------------
   // ASI Registers
   //----------------------------------
   //ASI_INTR_RECEIVE: 0x72
   //ASI_UDB_INTR_W: 0x73
   //ASI_UDB_INTR_R: 0x74
   //ASI_MESSAGE_MASK: 0x7D

   // decode asi thread
   assign  asi_thr[0] = ~tlu_int_asi_thrid[1] & ~tlu_int_asi_thrid[0];
   assign  asi_thr[1] = ~tlu_int_asi_thrid[1] &  tlu_int_asi_thrid[0];
   assign  asi_thr[2] =  tlu_int_asi_thrid[1] & ~tlu_int_asi_thrid[0];
   assign  asi_thr[3] =  tlu_int_asi_thrid[1] &  tlu_int_asi_thrid[0];

   // convert the signal back to non-inverting version for grape
   // assign  inc_ind_asi_thr_l = ~asi_thr;
   // assign  inc_ind_asi_thr = asi_thr;
   
   // read or write op
   assign  asi_write = tlu_int_asi_vld & tlu_int_asi_store;
   assign  asi_read = tlu_int_asi_vld & tlu_int_asi_load;

   // decode asi target
   // ASI_INTR_RECEIVE
   assign inc_ind_asi_inrr = ~tlu_int_asi_state[7] &
	      tlu_int_asi_state[6]  &
	      tlu_int_asi_state[5] &
	      tlu_int_asi_state[4] &
	      ~tlu_int_asi_state[3]  &
	      ~tlu_int_asi_state[2] &
	      tlu_int_asi_state[1] &
	      ~tlu_int_asi_state[0];      // 0x72

   // need to also check if VA=0x40
   // what else is mapped to this asi?
   // ASI_UDB_INTR_R
   assign asi_invr = ~tlu_int_asi_state[7] &
	      tlu_int_asi_state[6]  &
	      tlu_int_asi_state[5]  &
	      tlu_int_asi_state[4]  &
	      ~tlu_int_asi_state[3]  &
	      tlu_int_asi_state[2]  &
	      ~tlu_int_asi_state[1]  &
	      ~tlu_int_asi_state[0];      // 0x74

   // VA<63:19>=0 is not checked
   // ASI_UDB_INTR_W
   assign asi_indr = ~tlu_int_asi_state[7] &
	      tlu_int_asi_state[6]  &
	      tlu_int_asi_state[5]  &
	      tlu_int_asi_state[4]  &
	      ~tlu_int_asi_state[3] &
	      ~tlu_int_asi_state[2]  &
	      tlu_int_asi_state[1]  &
	      tlu_int_asi_state[0];      // 0x73
   /*	       
   // ASI_MESSAGE_MASK_REG
   // not implemented any more
   assign  inc_ind_asi_wr_inrr = asi_thr & {4{inc_ind_asi_inrr & asi_write}};
   assign  inc_ind_asi_wr_indr = asi_thr & {4{asi_indr & asi_write}};
   assign  inc_ind_asi_rd_invr = asi_thr & {4{asi_invr & asi_read}};

   assign  red_thread = (tlu_int_redmode[0] & asi_thr[0] |
			 tlu_int_redmode[1] & asi_thr[1] |
			 tlu_int_redmode[2] & asi_thr[2] |
			 tlu_int_redmode[3] & asi_thr[3]);
   */
   // modified for bug 2109 
   // modified for one-hot mux problem and support of macro test
   // 
   assign tlu_asi_rdata_mxsel_g[0] = 
              asi_invr & ~(rst_tri_en | sehold); 
   assign tlu_asi_rdata_mxsel_g[1] = 
              inc_ind_asi_inrr & ~(rst_tri_en | asi_invr | sehold);
   assign tlu_asi_rdata_mxsel_g[2] = 
              ~((|tlu_asi_rdata_mxsel_g[1:0]) | tlu_asi_rdata_mxsel_g[3]);
   assign tlu_asi_rdata_mxsel_g[3] = 
              tlu_asi_queue_rd_vld_g & ~(rst_tri_en | asi_invr | sehold |
              inc_ind_asi_inrr); 
   // 
   assign int_tlu_asi_data_vld_g = 
          ((asi_invr | inc_ind_asi_inrr) & asi_read) | tlu_ld_data_vld_g; 
            

   dffr_s dffr_int_tlu_asi_data_vld_w2 (
    .din (int_tlu_asi_data_vld_g),
    .q   (int_tlu_asi_data_vld_w2),
    .clk (clk),
    .rst (local_rst),
    .se  (1'b0),       
    .si  (),          
    .so  ()
);

// modified for timing
// assign tlu_lsu_int_ldxa_vld_w2 = 
//            int_tlu_asi_data_vld_w2 & ~tlu_flush_all_w2;

assign tlu_asi_data_nf_vld_w2 = 
            int_tlu_asi_data_vld_w2; 
   // 
   // illegal va range
   //
   /*
   assign int_ld_ill_va_g = 
          ((asi_invr | inc_ind_asi_inrr) & asi_read &
            ~tlu_va_all_zero_g) | tlu_va_ill_g; 
   */
   assign int_ld_ill_va_g = tlu_va_ill_g; 

   dffr_s dffr_tlu_lsu_int_ld_ill_va_w2 (
    .din (int_ld_ill_va_g),
    // .q   (tlu_lsu_int_ld_ill_va_w2),
    .q   (int_ld_ill_va_w2),
    .clk (clk),
    .rst (local_rst),
    .se  (1'b0),       
    .si  (),          
    .so  ()
);

assign tlu_lsu_int_ld_ill_va_w2 = int_ld_ill_va_w2;
   // Write to INDR
   // Can send reset pkt's only in red mode
   // modified for timing
   // modified for bug3170
   /*
   assign int_or_redrst[3:0] = 
              ({4{~indr_inc_rst_pkt}} | tlu_int_redmode[3:0]) & 
			    asi_thr[3:0];

   assign indr_vld_next[3:0] = 
              inc_ind_asi_wr_indr[3:0] & int_or_redrst[3:0] |  // set
	          indr_vld[3:0] & ~indr_rst[3:0];         // reset
   // 
   // original code
   assign indr_vld_next[3] = 
              (asi_indr & asi_write & asi_thr[3] & 
              (~(|lsu_tlu_rst_pkt[1:0]) | tlu_int_redmode[3])) |
              (indr_vld[3] & ~indr_rst[3]); 

   assign indr_vld_next[2] = 
              (asi_indr & asi_write & asi_thr[2] & 
              (~(|lsu_tlu_rst_pkt[1:0]) | tlu_int_redmode[2])) |
              (indr_vld[2] & ~indr_rst[2]); 

   assign indr_vld_next[1] = 
              (asi_indr & asi_write & asi_thr[1] & 
              (~(|lsu_tlu_rst_pkt[1:0]) | tlu_int_redmode[1])) |
              (indr_vld[1] & ~indr_rst[1]); 

   assign indr_vld_next[0] = 
              (asi_indr & asi_write & asi_thr[0] & 
              (~(|lsu_tlu_rst_pkt[1:0]) | tlu_int_redmode[0])) |
              (indr_vld[0] & ~indr_rst[0]); 
   */
   assign indr_vld_next[3] = 
              (asi_indr & asi_write & asi_thr[3]) |
              (indr_vld[3] & ~indr_rst[3]); 

   assign indr_vld_next[2] = 
              (asi_indr & asi_write & asi_thr[2]) |
              (indr_vld[2] & ~indr_rst[2]); 

   assign indr_vld_next[1] = 
              (asi_indr & asi_write & asi_thr[1]) |
              (indr_vld[1] & ~indr_rst[1]); 

   assign indr_vld_next[0] = 
              (asi_indr & asi_write & asi_thr[0]) |
              (indr_vld[0] & ~indr_rst[0]); 

   dff_s #4 indr_vld_reg(.din (indr_vld_next[3:0]),
		       .q   (indr_vld[3:0]),
		       .clk (clk),
		       .se  (se), .si(), .so());
   // 
   // modified for bug 3945
   dffr_s dffr_indr_req_valid_disable(
       .din (|indr_vld[3:0]),
	   .q   (indr_req_valid_disable),
	   .clk (clk),
	   .rst  (local_rst | lsu_tlu_pcxpkt_ack), 
	   .se  (se), 
       .si(), 
       .so());

   dffe_s #(4) dffe_indr_req_vec(
       .din (indr_vld_next[3:0]),
	   .q   (indr_req_vec[3:0]),
       .en  (~indr_req_valid_disable),
	   .clk (clk),
	   .se  (se), 
       .si(), 
       .so());
   
   // Round robin scheduler for indr request to pcx
   sparc_ifu_rndrob  indr_sched(
       // .req_vec (indr_vld[3:0]),
       .req_vec (indr_req_vec[3:0]),
	   .advance (lsu_tlu_pcxpkt_ack),
	   .rst_tri_enable (rst_tri_en),
	   .clk (clk),
	   .reset  (local_rst),
	   .se  (se),
	   .si (si),
	   .grant_vec (indr_grant[3:0]),
	   .so ());

// convert the signal back to non-inverting version for grape
// modified to fix one-hot indetermination
     assign  inc_ind_indr_grant[0] = 
                 ~(|inc_ind_indr_grant[3:1]);
     assign  inc_ind_indr_grant[1] = 
                 indr_grant[1]; 
     assign  inc_ind_indr_grant[2] = 
                 indr_grant[2] & ~indr_grant[1];
     assign  inc_ind_indr_grant[3] = 
                 indr_grant[3] & ~(|inc_ind_indr_grant[2:1]);
//
   assign  indr_rst[3:0] = 
               {4{local_rst}} | (indr_grant[3:0] & {4{lsu_tlu_pcxpkt_ack}});
   assign  intd_done[3:0] = 
               (indr_grant[3:0] & indr_vld[3:0] & {4{lsu_tlu_pcxpkt_ack}});

   dffr_s #(4) intd_reg(
       .din (intd_done[3:0]),
	   .q   (int_tlu_longop_done[3:0]),
	   .clk (clk),
	   .rst  (local_rst),
	   .se  (se), 
       .si(), 
       .so());

   // INDR pcx request control signals
   // modified for bug 3945
   // assign  inc_indr_req_valid = (|indr_vld[3:0]) & ~lsu_tlu_pcxpkt_ack;
   assign  inc_indr_req_valid = indr_req_valid_disable;
   assign  inc_indr_req_thrid[1] = indr_grant[3] | indr_grant[2];
   assign  inc_indr_req_thrid[0] = indr_grant[3] | indr_grant[1];
   
endmodule // sparc_tlu_intctl
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_tlu_intdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_tlu_intdp
//  Description:        
//    Contains the code for receiving interrupts from the crossbar,
//    and sending interrupts out to other processors through the corssbar.
//    The interrupt receive register (INRR, asi=0x49/VA=0),  incoming
//    vector register (INVR, asi=0x7f/VA=0x40), and interrupt vector
//    dispatch register (INDR, asi=0x77/VA=0) are implemented in this
//    block.  This block also initiates thread reset/wake up when a
//    reset packet is received.  
//
*/

////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: iop.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
//-*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
//  Description:	Global header file that contain definitions that 
//                      are common/shared at the IOP chip level
*/
////////////////////////////////////////////////////////////////////////


// Address Map Defines
// ===================




// CMP space



// IOP space




                               //`define ENET_ING_CSR     8'h84
                               //`define ENET_EGR_CMD_CSR 8'h85















// L2 space



// More IOP space





//Cache Crossbar Width and Field Defines
//======================================













































//bits 133:128 are shared by different fields
//for different packet types.
























//`define CPX_INV_PA_HI   116
//`define CPX_INV_PA_LO   112






// cache invalidation format
// `define CPX_INV_DCACHE_WORD0_VAL 0
// `define CPX_INV_ICACHE_WORD0_VAL 1
// `define CPX_INV_WORD0_WAY 5:2
// `define CPX_INV_DCACHE_WORD0_VAL 6
// `define CPX_INV_ICACHE_WORD0_VAL 7
// `define CPX_INV_WORD0_WAY 11:8
// `define CPX_INV_DCACHE_WORD0_VAL 12
// // `define CPX_INV_ICACHE_WORD0_VAL 13
// `define CPX_INV_WORD0_WAY 17:14
// `define CPX_INV_DCACHE_WORD0_VAL 18
// // `define CPX_INV_ICACHE_WORD0_VAL 19
// `define CPX_INV_WORD0_WAY 23:20




// 4 extra bits for bigger icache/dcache
// up to 512KB l1 icache, 256KB l1 dcache

































//Pico defines













//End cache crossbar defines


// Number of COS supported by EECU 



// 
// BSC bus sizes
// =============
//

// General




// CTags













// reinstated temporarily




// CoS






// L2$ Bank



// L2$ Req













// L2$ Ack








// Enet Egress Command Unit














// Enet Egress Packet Unit













// This is cleaved in between Egress Datapath Ack's








// Enet Egress Datapath
















// In-Order / Ordered Queue: EEPU
// Tag is: TLEN, SOF, EOF, QID = 15






// Nack + Tag Info + CTag




// ENET Ingress Queue Management Req












// ENET Ingress Queue Management Ack








// Enet Ingress Packet Unit












// ENET Ingress Packet Unit Ack







// In-Order / Ordered Queue: PCI
// Tag is: CTAG





// PCI-X Request











// PCI_X Acknowledge











//
// BSC array sizes
//================
//












// ECC syndrome bits per memory element




//
// BSC Port Definitions
// ====================
//
// Bits 7 to 4 of curr_port_id








// Number of ports of each type


// Bits needed to represent above


// How wide the linked list pointers are
// 60b for no payload (2CoS)
// 80b for payload (2CoS)

//`define BSC_OBJ_PTR   80
//`define BSC_HD1_HI    69
//`define BSC_HD1_LO    60
//`define BSC_TL1_HI    59
//`define BSC_TL1_LO    50
//`define BSC_CT1_HI    49
//`define BSC_CT1_LO    40
//`define BSC_HD0_HI    29
//`define BSC_HD0_LO    20
//`define BSC_TL0_HI    19
//`define BSC_TL0_LO    10
//`define BSC_CT0_HI     9
//`define BSC_CT0_LO     0


































// I2C STATES in DRAMctl







//
// IOB defines
// ===========
//



















//`define IOB_INT_STAT_WIDTH   32
//`define IOB_INT_STAT_HI      31
//`define IOB_INT_STAT_LO       0

















































// fixme - double check address mapping
// CREG in `IOB_INT_CSR space










// CREG in `IOB_MAN_CSR space





































// Address map for TAP access of SPARC ASI













//
// CIOP UCB Bus Width
// ==================
//
//`define IOB_EECU_WIDTH       16  // ethernet egress command
//`define EECU_IOB_WIDTH       16

//`define IOB_NRAM_WIDTH       16  // NRAM (RLDRAM previously)
//`define NRAM_IOB_WIDTH        4




//`define IOB_ENET_ING_WIDTH   32  // ethernet ingress
//`define ENET_ING_IOB_WIDTH    8

//`define IOB_ENET_EGR_WIDTH    4  // ethernet egress
//`define ENET_EGR_IOB_WIDTH    4

//`define IOB_ENET_MAC_WIDTH    4  // ethernet MAC
//`define ENET_MAC_IOB_WIDTH    4




//`define IOB_BSC_WIDTH         4  // BSC
//`define BSC_IOB_WIDTH         4







//`define IOB_CLSP_WIDTH        4  // clk spine unit
//`define CLSP_IOB_WIDTH        4





//
// CIOP UCB Buf ID Type
// ====================
//



//
// Interrupt Device ID
// ===================
//
// Caution: DUMMY_DEV_ID has to be 9 bit wide
//          for fields to line up properly in the IOB.



//
// Soft Error related definitions 
// ==============================
//



//
// CMP clock
// =========
//




//
// NRAM/IO Interface
// =================
//










//
// NRAM/ENET Interface
// ===================
//







//
// IO/FCRAM Interface
// ==================
//






//
// PCI Interface
// ==================
// Load/store size encodings
// -------------------------
// Size encoding
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 100 - quad






//
// JBI<->SCTAG Interface
// =======================
// Outbound Header Format



























// Inbound Header Format




















//
// JBI->IOB Mondo Header Format
// ============================
//














// JBI->IOB Mondo Bus Width/Cycle
// ==============================
// Cycle  1 Header[15:8]
// Cycle  2 Header[ 7:0]
// Cycle  3 J_AD[127:120]
// Cycle  4 J_AD[119:112]
// .....
// Cycle 18 J_AD[  7:  0]



////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes

//
// modved defines to tlu.h
/*
`define INT_VEC_HI 5
`define INT_VEC_LO 0
`define INT_THR_HI  12
`define INT_THR_LO   8
`define INT_TYPE_HI 17
`define INT_TYPE_LO 16
*/

module sparc_tlu_intdp (/*AUTOARG*/
   // Outputs
   int_pending_i2_l, ind_inc_thrid_i1, // indr_inc_rst_pkt, 
   ind_inc_type_i1, tlu_lsu_int_ldxa_data_w2, int_tlu_rstid_m, 
   tlu_lsu_pcxpkt, so, 
   // Inputs
   //
   // modified to abide to the Niagara reset methodology 
   // clk, se, si, reset, lsu_tlu_intpkt, lsu_tlu_st_rs3_data_g, 
   rclk, se, si, tlu_rst_l, lsu_tlu_st_rs3_data_g, // lsu_tlu_intpkt, 
   inc_ind_ld_int_i1, inc_ind_rstthr_i1, inc_ind_asi_thr, 
   inc_ind_asi_wr_indr, inc_ind_indr_grant, // inc_ind_asi_inrr, 
   inc_ind_thr_m, inc_ind_asi_wr_inrr, inc_ind_asi_rd_invr, 
   inc_indr_req_valid, inc_indr_req_thrid, tlu_asi_rdata_mxsel_g,
   tlu_asi_queue_rdata_g, tlu_scpd_asi_rdata_g, lsu_ind_intpkt_id,
   lsu_ind_intpkt_type, lsu_ind_intpkt_thr 
   );

   //
   // modified to abide to the Niagara reset methodology 
   // input      clk, se, si, reset;
   input      rclk, se, si, tlu_rst_l;

   // from lsu
   // input [17:0]  lsu_tlu_intpkt;   // int pkt from cpx
   input [63:0]  lsu_tlu_st_rs3_data_g;     // write data for int regs

   // select lines from int_ctl
   input [3:0] 	 inc_ind_ld_int_i1;            // ld ext interrupt to inrr
   input [3:0] 	 inc_ind_rstthr_i1;
   
   // changing the select from inverting to non-inverting for grape
   // input [3:0] 	 inc_ind_asi_thr_l;            // thread issuing asi command
   input [3:0] 	 inc_ind_asi_thr;            // thread issuing asi command
   input [3:0] 	 inc_ind_asi_wr_indr;          // write INDR
   // convert the signal to non-inverting version for grape
   // input [3:0] 	 inc_ind_indr_grant_l;         // transmit INDR to PCX
   input [3:0] 	 inc_ind_indr_grant;         // transmit INDR to PCX
   // obsolete input
   // input 	 inc_ind_asi_inrr;             // read INRR
   // convert the signal to non-inverting version for grape
   // input [3:0]	 inc_ind_thr_m_l;
   input [3:0]	 inc_ind_thr_m;
   
   // other controls
   input [3:0] 	 inc_ind_asi_wr_inrr;  // write INRR
   input [3:0] 	 inc_ind_asi_rd_invr;  // read INVR (reset corr bit in INRR)
   
   // indr request
   input 	 inc_indr_req_valid;   // valid value in INDR, i.e make req
   input [1:0] 	 inc_indr_req_thrid;   // thread making request
   //
   // asi rdata mux select
   input [3:0] tlu_asi_rdata_mxsel_g;
   // asi data from other blocks
   input [64-1:0] tlu_scpd_asi_rdata_g;
   input [8-1:0]   tlu_asi_queue_rdata_g;
   input [4:0]  lsu_ind_intpkt_thr;
   input [1:0]  lsu_ind_intpkt_type;
   input [5:0]  lsu_ind_intpkt_id;

   // to int ctl
   output [3:0]  int_pending_i2_l;     // interrupt still pending
   // output 	 indr_inc_rst_pkt;

   output [4:0]  ind_inc_thrid_i1;
   output [1:0]  ind_inc_type_i1;
   
   // to outside world
   output [63:0] tlu_lsu_int_ldxa_data_w2; // read data from asi regs 
   output [5:0]  int_tlu_rstid_m;
   
   output [25:0] tlu_lsu_pcxpkt;       // pcxpkt for inter processor int
   
   output 	 so;

   // local signals
   //
   // added to abide to the Niagara reset methodology 
   wire local_rst; // local reset signal 
   //
   wire [63:0] int_tlu_asi_data;     // read data from int regs
   // interrupt and reset id
   wire [5:0] 	 int_id_i1;
   wire [5:0] 	 t0_rstid_i2,
		 t1_rstid_i2,
		 t2_rstid_i2,
		 t3_rstid_i2,
		 next_t0_rstid_i1,
		 next_t1_rstid_i1,
		 next_t2_rstid_i1,
		 next_t3_rstid_i1;

   // Interrupt receive register
   wire [63:0]	 inrr_dec_i1,
		 inrr_rd_data_i2;

   wire [63:0] 	 t0_inrr_i2,
 		 t1_inrr_i2,
		 t2_inrr_i2,
		 t3_inrr_i2,
		 t0_inrr_aw_i2,
		 t1_inrr_aw_i2,
		 t2_inrr_aw_i2,
		 t3_inrr_aw_i2,
		 t0_inrr_arw_i1,
		 t1_inrr_arw_i1,
		 t2_inrr_arw_i1,
		 t3_inrr_arw_i1,
		 next_t0_inrr_i1,
		 next_t1_inrr_i1,
		 next_t2_inrr_i1,
		 next_t3_inrr_i1;
   
   wire [63:0] 	 new_t0_inrr_i1,
		 new_t1_inrr_i1,
		 new_t2_inrr_i1,
		 new_t3_inrr_i1;

   // clear interrupt through asi
   wire [63:0]   t0_asi_wr_data,
		 t1_asi_wr_data,
		 t2_asi_wr_data,
		 t3_asi_wr_data;

   // interrupt vector
   wire [5:0] 	 t0_invr_i3,
 		 t1_invr_i3,
 		 t2_invr_i3,
 		 t3_invr_i3,
    		 t0_invr_i2,
 		 t1_invr_i2,
 		 t2_invr_i2,
 		 t3_invr_i2;
   wire [5:0] 	 invr_rd_data_i3;

   // highest priority interrupt
   wire [63:0] 	 pe_ivec_i3,
		 t0_pe_ivec_i3,
		 t1_pe_ivec_i3,
		 t2_pe_ivec_i3,
		 t3_pe_ivec_i3;

   // interrupt dispatch
   // removed the obsolete bits 
   // wire [12:0] 	 indr_wr_pkt;
   wire [10:0] 	 indr_wr_pkt;

   // removed the obsolete bits 
   // wire [12:0] 	 indr_pcxpkt,
   wire [10:0] 	 indr_pcxpkt,
		 t0_indr,
		 t1_indr,
		 t2_indr,
		 t3_indr,
		 t0_indr_next,
		 t1_indr_next,
		 t2_indr_next,
		 t3_indr_next;
   // 
   // local clock
   wire clk;

   //
   // Code Starts Here
   //
   //----------------------------------------------------------------------
   // creating local clock
   //----------------------------------------------------------------------
   assign clk = rclk;

   //----------------------------------------------------------------------
   // Interrupt Receive
   //----------------------------------------------------------------------
   //
   // create local reset signal
   assign local_rst = ~tlu_rst_l;
   
   // I1 Stage
   // decode interrupt vector
   // modified due to interface clean-up
   /*
   assign  int_id_i1 = lsu_tlu_intpkt[`INT_VEC_HI:`INT_VEC_LO];
   assign  ind_inc_type_i1 = lsu_tlu_intpkt[`INT_TYPE_HI:`INT_TYPE_LO];
   assign  ind_inc_thrid_i1 = lsu_tlu_intpkt[`INT_THR_HI:`INT_THR_LO];
   */
   assign  int_id_i1[5:0]        = lsu_ind_intpkt_id[5:0];
   assign  ind_inc_type_i1[1:0]  = lsu_ind_intpkt_type[1:0];
   assign  ind_inc_thrid_i1[4:0] = lsu_ind_intpkt_thr[4:0];

   // rstid enable mux
   dp_mux2es #6 rid_mux0(.dout  (next_t0_rstid_i1[5:0]),
			 .in0   (t0_rstid_i2[5:0]),
			 .in1   (int_id_i1[5:0]),
			 .sel   (inc_ind_rstthr_i1[0]));

 // Use two threads unless this is defined

   dp_mux2es #6 rid_mux1(.dout  (next_t1_rstid_i1[5:0]),
             .in0   (t1_rstid_i2[5:0]),
             .in1   (int_id_i1[5:0]),
             .sel   (inc_ind_rstthr_i1[1]));

   // rst id flops
   dff_s #6 rid0_reg(.din (next_t0_rstid_i1[5:0]),
           .q   (t0_rstid_i2[5:0]),
           .clk (clk),
           .se  (se), .si(), .so());
   dff_s #6 rid1_reg(.din (next_t1_rstid_i1[5:0]),
           .q   (t1_rstid_i2[5:0]),
           .clk (clk),
           .se  (se), .si(), .so());

   dp_mux2ds #6 tlurid_mux(.dout (int_tlu_rstid_m[5:0]),
               .in0  (t0_rstid_i2[5:0]),
               .in1  (t1_rstid_i2[5:0]),
               .sel0_l (~inc_ind_thr_m[0]),
               .sel1_l (~inc_ind_thr_m[1]));







































































































































 // `ifndef CONFIG_NUM_THREADS

   sparc_tlu_dec64 iv_dec(.in  (int_id_i1[5:0]),
			  .out (inrr_dec_i1[63:0]));

   // merge decoded interrupt vector with inrr
   assign  new_t0_inrr_i1 = inrr_dec_i1 | t0_inrr_arw_i1;
   assign  new_t1_inrr_i1 = inrr_dec_i1 | t1_inrr_arw_i1;
   assign  new_t2_inrr_i1 = inrr_dec_i1 | t2_inrr_arw_i1;
   assign  new_t3_inrr_i1 = inrr_dec_i1 | t3_inrr_arw_i1;

   // enable mux to load new interrupt to INRR
   dp_mux2es #64 inrr_en_mux0(.dout  (next_t0_inrr_i1[63:0]),
			  .in0   (t0_inrr_arw_i1[63:0]),
			  .in1   (new_t0_inrr_i1[63:0]),
			  .sel   (inc_ind_ld_int_i1[0]));
 // Use two threads unless this is defined

   dp_mux2es #64 inrr_en_mux1(.dout  (next_t1_inrr_i1[63:0]),
              .in0   (t1_inrr_arw_i1[63:0]),
              .in1   (new_t1_inrr_i1[63:0]),
              .sel   (inc_ind_ld_int_i1[1]));

   // interrupt receive register (INRR)
   // change to dff -- software will reset before IE turns on
   dffr_s #64 t0_inrr (.din (next_t0_inrr_i1[63:0]),
             .q   (t0_inrr_i2[63:0]),
             .clk (clk),
   //
   // modified to abide to the Niagara reset methodology
   //            .rst (reset),
             .rst (local_rst),
             .se  (se), .si(), .so());
   dffr_s #64 t1_inrr (.din (next_t1_inrr_i1[63:0]),
             .q   (t1_inrr_i2[63:0]),
             .clk (clk),
   //
   // modified to abide to the Niagara reset methodology
   //            .rst (reset),
             .rst (local_rst),
             .se  (se), .si(), .so());

   dp_mux2ds #64 inrr_rd_mux(.dout (inrr_rd_data_i2[63:0]),
             .in0  (t0_inrr_i2[63:0]),
             .in1  (t1_inrr_i2[63:0]),
             .sel0_l (~inc_ind_asi_thr[0]),
             .sel1_l (~inc_ind_asi_thr[1]));
























































































































































































 // `ifndef CONFIG_NUM_THREADS
		     
   // signal interrupt pending
   sparc_tlu_zcmp64  zcmp0(.in  (t0_inrr_i2[63:0]),
			   .zero (int_pending_i2_l[0]));

 // Use two threads unless this is defined

   sparc_tlu_zcmp64  zcmp1(.in  (t1_inrr_i2[63:0]),
               .zero (int_pending_i2_l[1]));

   // write data -- only zeros may be written to the INRR.  An attempt
   // to write 1 is ignored.
   // Force to all 1 if no write
   assign  t0_asi_wr_data = ~(~lsu_tlu_st_rs3_data_g &
                  {64{inc_ind_asi_wr_inrr[0]}});
   assign  t1_asi_wr_data = ~(~lsu_tlu_st_rs3_data_g &
                  {64{inc_ind_asi_wr_inrr[1]}});

   assign  t0_inrr_aw_i2 = t0_inrr_i2 & t0_asi_wr_data;
   assign  t1_inrr_aw_i2 = t1_inrr_i2 & t1_asi_wr_data;

   // priority encode INRR to 6 bits to get INVR
   // b63 has the highest priority
   sparc_tlu_penc64 t0_invr_penc(.in  (t0_inrr_i2[63:0]),
                 .out (t0_invr_i2[5:0]));
   sparc_tlu_penc64 t1_invr_penc(.in  (t1_inrr_i2[63:0]),
                 .out (t1_invr_i2[5:0]));

   // Interrupt Vector Register (INVR)
   // Cannot write to INVR
   dff_s #6 t0_invr (.din (t0_invr_i2[5:0]),
           .q   (t0_invr_i3[5:0]),
           .clk (clk),
           .se  (se), .si(), .so());
   dff_s #6 t1_invr (.din (t1_invr_i2[5:0]),
           .q   (t1_invr_i3[5:0]),
           .clk (clk),
           .se  (se), .si(), .so());

   dp_mux2ds #6 invr_rd_mux(.dout (invr_rd_data_i3[5:0]),
                .in0  (t0_invr_i3[5:0]),
                .in1  (t1_invr_i3[5:0]),
                .sel0_l (~inc_ind_asi_thr[0]),
                .sel1_l (~inc_ind_asi_thr[1]));










































































































































































































 // `ifndef CONFIG_NUM_THREADS
   
   //
   // modified for bug 2109
   // asi rd data mux
   dp_mux4ds #(64) asi_rd_mux(
			   .in0  ({58'b0, invr_rd_data_i3[5:0]}),
			   .in1  (inrr_rd_data_i2[63:0]),
			   .in2  (tlu_scpd_asi_rdata_g[64-1:0]),
			   .in3  ({50'b0, tlu_asi_queue_rdata_g[8-1:0],6'b0}),
			   .sel0_l (~tlu_asi_rdata_mxsel_g[0]),
			   .sel1_l (~tlu_asi_rdata_mxsel_g[1]),
			   .sel2_l (~tlu_asi_rdata_mxsel_g[2]),
			   .sel3_l (~tlu_asi_rdata_mxsel_g[3]),
               .dout (int_tlu_asi_data[63:0]));

   dff_s #(64) dff_tlu_lsu_int_ldxa_data_w2 (
        .din (int_tlu_asi_data[63:0]),
		.q   (tlu_lsu_int_ldxa_data_w2[63:0]),
		.clk (clk),
		.se  (se), 
        .si(), 
        .so());
   
   sparc_tlu_dec64 inrr_pe_dec(.in  (invr_rd_data_i3[5:0]),
			       .out (pe_ivec_i3[63:0]));

   // when INVR is read, zero out the corresponding bit in INRR
   assign  t0_pe_ivec_i3 = pe_ivec_i3 & {64{inc_ind_asi_rd_invr[0]}};
   assign  t1_pe_ivec_i3 = pe_ivec_i3 & {64{inc_ind_asi_rd_invr[1]}};
   assign  t2_pe_ivec_i3 = pe_ivec_i3 & {64{inc_ind_asi_rd_invr[2]}};
   assign  t3_pe_ivec_i3 = pe_ivec_i3 & {64{inc_ind_asi_rd_invr[3]}};

   assign  t0_inrr_arw_i1 = t0_inrr_aw_i2 & ~t0_pe_ivec_i3;
   assign  t1_inrr_arw_i1 = t1_inrr_aw_i2 & ~t1_pe_ivec_i3;
   assign  t2_inrr_arw_i1 = t2_inrr_aw_i2 & ~t2_pe_ivec_i3;
   assign  t3_inrr_arw_i1 = t3_inrr_aw_i2 & ~t3_pe_ivec_i3;

   //----------------------------------------------------------------------
   // Interrupt Dispatch
   //----------------------------------------------------------------------
   // modified to remove the unused bits
   //
   // assign  indr_wr_pkt = {lsu_tlu_st_rs3_data_g[`INT_TYPE_HI:`INT_TYPE_LO], 
   assign  indr_wr_pkt = {lsu_tlu_st_rs3_data_g[12:8], 
			  lsu_tlu_st_rs3_data_g[5:0]};
   // 
   // removed for timing 
   // assign  indr_inc_rst_pkt = lsu_tlu_st_rs3_data_g[`INT_TYPE_HI] |
   // 	                      lsu_tlu_st_rs3_data_g[`INT_TYPE_LO];
   
   dp_mux2es  #11   t0_indr_mux(.dout (t0_indr_next[10:0]),
				.in0  (t0_indr[10:0]),
				.in1  (indr_wr_pkt[10:0]),
				.sel  (inc_ind_asi_wr_indr[0]));
 // Use two threads unless this is defined

   dp_mux2es  #11   t1_indr_mux(.dout (t1_indr_next[10:0]),
                .in0  (t1_indr[10:0]),
                .in1  (indr_wr_pkt[10:0]),
                .sel  (inc_ind_asi_wr_indr[1]));

   dff_s #11 t0_indr_reg(.din (t0_indr_next[10:0]),
           .q   (t0_indr[10:0]),
           .clk (clk),
           .se  (se), .si(), .so());
   dff_s #11 t1_indr_reg(.din (t1_indr_next[10:0]),
           .q   (t1_indr[10:0]),
           .clk (clk),
           .se  (se), .si(), .so());

   dp_mux2ds #11 int_dsp_mux(.dout (indr_pcxpkt[10:0]),
                 .in0  (t0_indr[10:0]),
                 .in1  (t1_indr[10:0]),
                 .sel0_l (~inc_ind_indr_grant[0]),
                 .sel1_l (~inc_ind_indr_grant[1]));































































































































 // `ifndef CONFIG_NUM_THREADS   
   
   assign  tlu_lsu_pcxpkt[25:0] = {inc_indr_req_valid,  // 25
				   {5'b01001},               // 24:20
				   inc_indr_req_thrid[1:0], // 19:18
//				   indr_pcxpkt[12:11],  -- cannot send rst
				   {2'b00},             // 17:16
				   3'b0,                // 15:13 rsvd
				   indr_pcxpkt[10:6],   // 12:8
				   2'b0,                // 7:6   rsvd
				   indr_pcxpkt[5:0]};   // 5:0
   
   // TBD:
   // 1. disable sending of reset/nuke/resum packets from indr -- DONE 1/6
   
endmodule
   
   
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_tlu_zcmp64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_tlu_zcmp64
//  Description:    
//    64b zero compare
*/

module sparc_tlu_zcmp64(/*AUTOARG*/
   // Outputs
   zero, 
   // Inputs
   in
   );

   input [63:0] in;

   output      zero;

   reg 	       zero;

   always @ (in)
     begin
	if (in == 64'b0)
	  zero = 1'b1;
	else
	  zero = 1'b0;
     end
   

endmodule // sparc_tlu_dec64

	
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: tlu.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name:
//	Description:	Trap Logic and Memory Management Unit (TLU) :
//			- Contains :
//				- Trap Stack Array (TSA)
//				- Trap Control Logic (TCL)
//				- Mmu internal Register Array (MRA)
//				- Mmu Control Logic (MCL)
//
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
			// time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module tlu (/*AUTOARG*/
            short_si0,short_si1,short_so0,short_so1,si0,si1,so0,so1,
   tlu_sftint_vld, tlu_hintp_vld, tlu_rerr_vld, tlu_lsu_tl_zero,
   tlu_lsu_stxa_ack, tlu_lsu_redmode_rst_d1, // tlu_lsu_async_ack_w2,
   tlu_lsu_pstate_priv, tlu_lsu_pstate_cle, tlu_lsu_pstate_am, tlu_lsu_tid_m,
   tlu_lsu_pcxpkt, tlu_lsu_ldxa_tid_w2, tlu_lsu_stxa_ack_tid, tlu_lsu_redmode,
   tlu_lsu_asi_update_m, tlu_lsu_asi_m,
   tlu_itlb_wr_vld_g, tlu_itlb_tte_tag_w2, tlu_itlb_tte_data_w2,
   tlu_itlb_tag_rd_g, tlu_itlb_rw_index_vld_g, tlu_itlb_rw_index_g,
   tlu_itlb_dmp_actxt_g, tlu_itlb_invalidate_all_g, tlu_itlb_dmp_vld_g,
   tlu_itlb_dmp_all_g, tlu_itlb_dmp_nctxt_g, tlu_ifu_trapnpc_w2,
   tlu_sscan_test_data, // tlu_sscan_pc,
   tlu_itlb_data_rd_g, tlu_ifu_trappc_vld_w1, tlu_ifu_trappc_w2,
   tlu_ifu_trapnpc_vld_w1, tlu_ifu_trap_tid_w1, tlu_ifu_rstthr_i2,
   tlu_ifu_rstint_i2, tlu_ifu_resumint_i2, tlu_ifu_pstate_pef,
   tlu_ifu_pstate_ie, tlu_ifu_nukeint_i2, // tlu_ifu_int_activate_i3,
   tlu_ifu_hwint_i3, tlu_idtlb_dmp_thrid_g, tlu_idtlb_dmp_key_g,
   tlu_exu_cwpccr_update_m, tlu_exu_cwp_retry_m,
   tlu_exu_cwp_m, tlu_exu_ccr_m, tlu_exu_agp_swap, tlu_exu_agp,
   tlu_dtlb_tte_tag_w2, tlu_dtlb_tte_data_w2,
   tlu_dtlb_tag_rd_g, tlu_dtlb_rw_index_vld_g, tlu_dtlb_rw_index_g,
   tlu_dtlb_invalidate_all_g, tlu_dtlb_dmp_vld_g, tlu_exu_rsr_data_m,
   tlu_dtlb_dmp_sctxt_g, tlu_dtlb_dmp_pctxt_g, tlu_dtlb_dmp_nctxt_g,
   tlu_dtlb_dmp_all_g, tlu_dtlb_dmp_actxt_g, tlu_dtlb_data_rd_g,
   tlu_lsu_int_ldxa_vld_w2, tlu_lsu_ldxa_async_data_vld, // tlu_ifu_flush_pipe_w,
   ifu_lsu_error_inj, tlu_exu_agp_tid, tlu_hpstate_priv, tlu_hpstate_ibe,
   tlu_hpstate_enb, tlu_early_flush_pipe_w, tlu_exu_early_flush_pipe_w,
   tlu_early_flush_pipe2_w, tlu_lsu_int_ldxa_data_w2, tlu_lsu_int_ld_ill_va_w2,
   tlu_exu_priv_trap_m, tlu_exu_pic_onebelow_m, tlu_exu_pic_twobelow_m,
   lsu_exu_ldxa_m, lsu_exu_ldxa_data_g, tlu_dsfsr_flt_vld, tlu_lsu_priv_trap_m,

   
   tlu_dtlb_csm_rd_g, tlu_itlb_csm_rd_g, tlu_dtlb_tte_csm_w2, tlu_itlb_tte_csm_w2,
   tlu_itlb_wr_csm_sel_g, tlu_dtlb_wr_csm_sel_g,
   
   // tlu_lsu_priv_trap_w,
   // Inputs
   se, arst_l, grst_l, sehold,
   // mem_write_disable, // rst_tri_en,
   // mux_drive_disable,
   lsu_tlu_wtchpt_trp_g, ifu_tlu_flush_fd3_w,
   lsu_tlu_ttype_vld_m2, ifu_tlu_flush_fd_w, ifu_tlu_flush_fd2_w,
   lsu_tlu_ttype_m2, lsu_tlu_tlb_st_inst_m, // lsu_tlu_tte_ebit_g,
   lsu_tlu_tlb_ldst_va_m, lsu_tlu_tlb_ld_inst_m, lsu_tlu_tlb_dmp_va_m,
   lsu_tlu_tlb_asi_state_m, lsu_tlu_tlb_access_tid_m, ifu_tlu_flush_m,
   lsu_tlu_st_rs3_data_g, lsu_tlu_early_flush_w, lsu_tlu_early_flush2_w,
   lsu_tlu_priv_action_g, lsu_tlu_pcxpkt_ack, // lsu_tlu_priv_violtn_g,
   lsu_tlu_pctxt_m, lsu_tlu_async_ttype_vld_g, // lsu_tlu_nonalt_ldst_m,
   lsu_tlu_misalign_addr_ldst_atm_m, lsu_tlu_intpkt,
   lsu_tlu_async_ttype_g, lsu_tlu_rs3_data_g, lsu_tlu_defr_trp_taken_g,
   lsu_tlu_dtlb_done, lsu_tlu_dside_ctxt_m, // lsu_tlu_flt_ld_nfo_pg_g,
   lsu_tlu_dmmu_miss_g, lsu_tlu_daccess_prot_g, // lsu_tlu_derr_tid_g,
   lsu_tlu_daccess_excptn_g, lsu_tlu_cpx_vld, ifu_tlu_pc_oor_e,
   lsu_tlu_cpx_req, ifu_tlu_inst_vld_m_bf1, ifu_mmu_trap_m, ifu_tlu_trap_m,
   lsu_asi_state, lsu_asi_reg3, lsu_asi_reg2, lsu_tlu_async_tid_g,
   lsu_asi_reg1, lsu_asi_reg0, ifu_tlu_ttype_vld_m, ifu_tlu_ttype_m,
   ifu_tlu_thrid_d, ifu_tlu_swint_m, ifu_tlu_sir_inst_m, ifu_tlu_l2imiss,
   ifu_tlu_rstint_m, ifu_tlu_retry_inst_d, ifu_tlu_priv_violtn_m, ifu_tlu_pc_m,
   ifu_tlu_npc_m, ifu_tlu_immu_miss_m, ifu_tlu_itlb_done,  ifu_tlu_inst_vld_m,
   ifu_tlu_hwint_m, ifu_lsu_imm_asi_d, ifu_lsu_imm_asi_vld_d, ifu_tlu_done_inst_d,
   ifu_lsu_st_inst_e, ifu_lsu_memref_d, ifu_lsu_ld_inst_e, ffu_tlu_trap_ue,
   ffu_tlu_trap_other, ffu_tlu_trap_ieee754, ffu_tlu_ill_inst_m, ffu_ifu_tid_w2,
   exu_tlu_va_oor_jl_ret_m, exu_tlu_ttype_vld_m, exu_tlu_ttype_m, exu_tlu_va_oor_m,
   exu_tlu_spill_tid, exu_tlu_spill, exu_tlu_spill_other, exu_tlu_spill_wtype,
   exu_tlu_misalign_addr_jmpl_rtn_m, exu_tlu_cwp_retry, exu_mmu_early_va_e,
   exu_tlu_cwp_cmplt_tid, // exu_tlu_spill_ttype,  exu_tlu_cwp_fastcmplt_w,
   exu_tlu_cwp_cmplt, exu_tlu_cwp3, exu_tlu_cwp2, exu_tlu_cwp1,
   exu_tlu_cwp0, exu_tlu_ccr3_w, exu_tlu_ccr2_w, lsu_tlu_ldst_va_m,
   exu_tlu_ccr1_w, exu_tlu_ccr0_w, exu_lsu_ldst_va_e, const_cpuid,
   rclk, ifu_tlu_sraddr_d, ifu_tlu_rsr_inst_d, // ifu_tlu_wsr_inst_d,
   exu_tlu_wsr_data_m,  lsu_tlu_rsr_data_e, ifu_tlu_sraddr_d_v2,
   ifu_lsu_alt_space_e, lsu_tlu_squash_va_oor_m, ifu_tlu_imiss_e,
   lsu_tlu_dcache_miss_w2, lsu_tlu_l2_dmiss, lsu_tlu_stb_full_w2,
   ffu_tlu_fpu_tid, ffu_tlu_fpu_cmplt, spu_tlu_rsrv_illgl_m,
   lsu_pid_state0, lsu_pid_state1, lsu_pid_state2, lsu_pid_state3,
   lsu_tlu_nucleus_ctxt_m,lsu_tlu_tte_pg_sz_g, exu_tlu_ue_trap_m,
   lsu_ifu_inj_ack, ifu_tlu_alt_space_d, // lsu_tlu_ill_inst_m,
   ifu_lsu_thrid_s,lsu_dsfsr_din_g,lsu_dmmu_sfsr_trp_wr,lsu_mmu_flush_pipe_w,
   exu_lsu_priority_trap_m, lsu_tlu_wsr_inst_e, lsu_mmu_defr_trp_taken_g,

   // trin
   core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data
   );

// trin
output wire [94-1:0] core_rtap_data;
input wire rtap_core_val;
input wire [1:0] rtap_core_threadid;
input wire [4-1:0]  rtap_core_id;
input wire [94-1:0] rtap_core_data;
assign core_rtap_data = 94'd0;

reg [3:0] ctu_sscan_tid;
always @ *
begin
   if (rtap_core_threadid == 2'd0)
      ctu_sscan_tid = 4'b0001;
   else if (rtap_core_threadid == 2'd1)
      ctu_sscan_tid = 4'b0010;
   else if (rtap_core_threadid == 2'd2)
      ctu_sscan_tid = 4'b0100;
   else if (rtap_core_threadid == 2'd3)
      ctu_sscan_tid = 4'b1000;
end

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
//
// input			clk;			// To tlu_int of sparc_tlu_int.v, ...
input			rclk;			// To tlu_int of sparc_tlu_int.v, ...
input [3:0]		const_cpuid;		// To tlu_int of sparc_tlu_int.v, ...
input [48-1:0] exu_lsu_ldst_va_e;	// To mmu_dp of tlu_mmu_dp.v
input [10-1:0] lsu_tlu_ldst_va_m;	// To mmu_dp of tlu_mmu_dp.v
input [7:0]     exu_mmu_early_va_e;     // From exu of sparc_exu.v
input [7:0]		exu_tlu_ccr0_w;		// To tdp of tlu_tdp.v
input [7:0]		exu_tlu_ccr1_w;		// To tdp of tlu_tdp.v
input [7:0]		exu_tlu_ccr2_w;		// To tdp of tlu_tdp.v
input [7:0]		exu_tlu_ccr3_w;		// To tdp of tlu_tdp.v
// modified due to timing
// input [2:0]		exu_tlu_cwp0_w;		// To tdp of tlu_tdp.v
// input [2:0]		exu_tlu_cwp1_w;		// To tdp of tlu_tdp.v
// input [2:0]		exu_tlu_cwp2_w;		// To tdp of tlu_tdp.v
// input [2:0]		exu_tlu_cwp3_w;		// To tdp of tlu_tdp.v
input [2:0]		exu_tlu_cwp0;		// To tdp of tlu_tdp.v
input [2:0]		exu_tlu_cwp1;		// To tdp of tlu_tdp.v
input [2:0]		exu_tlu_cwp2;		// To tdp of tlu_tdp.v
input [2:0]		exu_tlu_cwp3;		// To tdp of tlu_tdp.v
input			exu_tlu_cwp_cmplt;	// To tcl of tlu_tcl.v
input [1:0]		exu_tlu_cwp_cmplt_tid;	// To tcl of tlu_tcl.v
// input			exu_tlu_cwp_fastcmplt_w;// To tcl of tlu_tcl.v
input			exu_tlu_cwp_retry;	// To tcl of tlu_tcl.v
input			exu_tlu_misalign_addr_jmpl_rtn_m;// To tcl of tlu_tcl.v
input			exu_tlu_spill;		// To tcl of tlu_tcl.v
input [1:0]		exu_tlu_spill_tid;	// To tcl of tlu_tcl.v
// derive the spill_ttype from spill_other and spill_wtype
// input [8:0]		exu_tlu_spill_ttype;	// To tcl of tlu_tcl.v
input           exu_tlu_spill_other;    // From exu of sparc_exu.v
input [2:0]     exu_tlu_spill_wtype;    // From exu of sparc_exu.v
input [8:0]		exu_tlu_ttype_m;	// To tcl of tlu_tcl.v
input			exu_tlu_ttype_vld_m;	// To tcl of tlu_tcl.v
input			exu_tlu_ue_trap_m;// To tcl of tlu_tcl.v
input			exu_tlu_va_oor_jl_ret_m;// To tcl of tlu_tcl.v
input			exu_tlu_va_oor_m;	// To tcl of tlu_tcl.v
input			ffu_tlu_ill_inst_m;	// new trap from ffu
input [1:0]		ffu_ifu_tid_w2;		// To tcl of tlu_tcl.v
input			ffu_tlu_trap_ieee754;	// To tcl of tlu_tcl.v
input			ffu_tlu_trap_other;	// To tcl of tlu_tcl.v
input			ffu_tlu_trap_ue;	// To tcl of tlu_tcl.v
input			ifu_lsu_ld_inst_e;	// To mmu_ctl of tlu_mmu_ctl.v
input			ifu_lsu_memref_d;	// To tcl of tlu_tcl.v
input			ifu_lsu_st_inst_e;	// To mmu_ctl of tlu_mmu_ctl.v
input			ifu_tlu_done_inst_d;	// To tcl of tlu_tcl.v
// input			ifu_tlu_flsh_inst_e;	// To tcl of tlu_tcl.v
input			ifu_tlu_flush_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_flush_fd_w;	// To tcl of tlu_tcl.v
input			ifu_tlu_flush_fd2_w;	// To tcl of tlu_tcl.v
input			ifu_tlu_flush_fd3_w;	// To tcl of tlu_tcl.v
input			lsu_tlu_early_flush_w;	// To tcl of tlu_tcl.v
input			lsu_tlu_early_flush2_w;	// To tcl of tlu_tcl.v
input			ifu_tlu_hwint_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_immu_miss_m;	// To tcl of tlu_tcl.v, ...
input			ifu_tlu_pc_oor_e;	// To tcl of tlu_tcl.v
input [4-1:0] ifu_tlu_l2imiss;	// To tcl of tlu_tcl.v, ...
input			ifu_tlu_inst_vld_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_inst_vld_m_bf1;	// To tcl of tlu_tcl.v
input			ifu_tlu_itlb_done;	// To mmu_ctl of tlu_mmu_ctl.v
// input [1:0]		ifu_tlu_ldst_size_e;	// To mmu_ctl of tlu_mmu_ctl.v
// modified for bug 3017
input [48:0]		ifu_tlu_npc_m;		// To tdp of tlu_tdp.v
input [48:0]		ifu_tlu_pc_m;		// To tdp of tlu_tdp.v
// input [47:0]		ifu_tlu_npc_m;		// To tdp of tlu_tdp.v
// input [47:0]		ifu_tlu_pc_m;		// To tdp of tlu_tdp.v
input			ifu_tlu_priv_violtn_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_retry_inst_d;	// To tcl of tlu_tcl.v
input			ifu_tlu_rstint_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_sir_inst_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_swint_m;	// To tcl of tlu_tcl.v
input [1:0]		ifu_tlu_thrid_d;	// To tcl of tlu_tcl.v
input [1:0]		ifu_lsu_thrid_s;	// To tcl of tlu_tcl.v
input [8:0]		ifu_tlu_ttype_m;	// To tcl of tlu_tcl.v
input			ifu_tlu_ttype_vld_m;	// To tcl of tlu_tcl.v
input			ifu_mmu_trap_m;	    // To tcl of tlu_tcl.v
input			ifu_tlu_trap_m;	    // To tcl of tlu_tcl.v
input [7:0]		lsu_asi_reg0;		// To tdp of tlu_tdp.v
input [7:0]		lsu_asi_reg1;		// To tdp of tlu_tdp.v
input [7:0]		lsu_asi_reg2;		// To tdp of tlu_tdp.v
input [7:0]		lsu_asi_reg3;		// To tdp of tlu_tdp.v
input [8-1:0] lsu_asi_state;		// To tcl of tlu_tcl.v, ...
// added asynchronize trap to handle correctable dmmu parity error
input           lsu_tlu_async_ttype_vld_g; // lsu asynchronous trap valid
input           lsu_tlu_defr_trp_taken_g; // lsu asynchronous trap valid
input           lsu_mmu_defr_trp_taken_g; // lsu asynchronous trap valid
input [6:0]     lsu_tlu_async_ttype_g;  // lsu asynchronous trap type
input [1:0]     lsu_tlu_async_tid_g; // asynchronous trap - thread
input [3:0]		lsu_tlu_cpx_req;	// To tlu_int of sparc_tlu_int.v
input			lsu_tlu_cpx_vld;	// To tlu_int of sparc_tlu_int.v
// input [2:0]		lsu_tlu_ctxt_sel_m;	// To tcl of tlu_tcl.v
input			lsu_tlu_daccess_excptn_g;// To tcl of tlu_tcl.v, ...
input			lsu_tlu_daccess_prot_g;	// To tcl of tlu_tcl.v, ...
// input [1:0]		lsu_tlu_derr_tid_g;	// To tcl of tlu_tcl.v
input			lsu_tlu_dmmu_miss_g;	// To tcl of tlu_tcl.v, ...
input [12:0]	lsu_tlu_dside_ctxt_m;	// To mmu_dp of tlu_mmu_dp.v
input			lsu_tlu_dtlb_done;	// To mmu_ctl of tlu_mmu_ctl.v
// input			lsu_tlu_flt_ld_nfo_pg_g;// To tcl of tlu_tcl.v
// input			lsu_tlu_illegal_asi_action_g;// To tcl of tlu_tcl.v
input [17:0]	lsu_tlu_intpkt;		// To tlu_int of sparc_tlu_int.v
// modified for shadow scan
// input [3:0] lsu_tlu_iobrdge_pc_sel;
input			lsu_tlu_misalign_addr_ldst_atm_m;// To tcl of tlu_tcl.v
// input			lsu_tlu_nonalt_ldst_m;	// To tcl of tlu_tcl.v
input [12:0]	lsu_tlu_pctxt_m;	// To mmu_dp of tlu_mmu_dp.v
input			lsu_tlu_pcxpkt_ack;	// To tlu_int of sparc_tlu_int.v
input			lsu_tlu_priv_action_g;	// To tcl of tlu_tcl.v
// input			lsu_tlu_priv_violtn_g;	// To tcl of tlu_tcl.v
// input			lsu_tlu_spec_access_epage_g;// To tcl of tlu_tcl.v
input [63:0]	lsu_tlu_st_rs3_data_g;	// To tlu_int of sparc_tlu_int.v, ...
input [63:0]	lsu_tlu_rs3_data_g;	// To tlu_int of sparc_tlu_int.v, ...
// added for timing
input [1:0]		lsu_tlu_tlb_access_tid_m;// To mmu_ctl of tlu_mmu_ctl.v
input [7:0]		lsu_tlu_tlb_asi_state_m;// To mmu_ctl of tlu_mmu_ctl.v
input [47:13]	lsu_tlu_tlb_dmp_va_m;	// To mmu_dp of tlu_mmu_dp.v
input			lsu_tlu_tlb_ld_inst_m;	// To mmu_ctl of tlu_mmu_ctl.v
input [(6 + 4):0]	lsu_tlu_tlb_ldst_va_m;	// To mmu_ctl of tlu_mmu_ctl.v
input			lsu_tlu_tlb_st_inst_m;	// To mmu_ctl of tlu_mmu_ctl.v
// input			lsu_tlu_tte_ebit_g;	// To tcl of tlu_tcl.v
input [8:0]		lsu_tlu_ttype_m2;	// To tcl of tlu_tcl.v
// removed unused bits
// input [1:0]	lsu_tlu_ttype_tid_m2;	// To tcl of tlu_tcl.v
input			lsu_tlu_ttype_vld_m2;	// To tcl of tlu_tcl.v
// input			lsu_tlu_uncache_atomic_g;// To tcl of tlu_tcl.v
// input			lsu_tlu_write_op_m;	// To tcl of tlu_tcl.v
input			lsu_tlu_wtchpt_trp_g;	// To tcl of tlu_tcl.v
// input		lsu_tlu_xslating_ldst_m;// To tcl of tlu_tcl.v
// input		reset;			// To mmu_ctl of tlu_mmu_ctl.v
// input		rst_l;			// To tcl of tlu_tcl.v, ...
input			grst_l;			// To tcl of tlu_tcl.v, ...
input			arst_l;			// To tcl of tlu_tcl.v, ...
// input			rst_tri_en;	// To tcl of tlu_tcl.v, ...
// input			mem_write_disable;	// To tcl of tlu_tcl.v, ...
// input			mux_drive_disable;	// To tcl of tlu_tcl.v, ...
wire mux_drive_disable = ~grst_l;
wire mem_write_disable = ~grst_l;
// input			testmode_l;	// To tcl of tlu_tcl.v, ...
input			sehold;			// To tlu_int of sparc_tlu_int.v, ...
input			se;			// To tlu_int of sparc_tlu_int.v, ...
input			si0,si1,short_si0,short_si1;			// To tlu_int of sparc_tlu_int.v, ...
// End of automatics
// Read/Write Privileged State Register Access.
input  	[7-1:0] ifu_tlu_sraddr_d;      // addr of sr(st/pr)
input  	[7-1:0] ifu_tlu_sraddr_d_v2;   // addr of sr(st/pr)
input           ifu_tlu_rsr_inst_d ;	// valid rd sr(st/pr)
// modified for timing
// input           ifu_tlu_wsr_inst_d ;	// valid wr sr(st/pr)
input           lsu_tlu_wsr_inst_e ;	// valid wr sr(st/pr)
input  	[63:0]  exu_tlu_wsr_data_m ;    // pr/st data to irf.

// input   [1:0]   ifu_tlu_thrid_e ;   	// Thread id.
input	[7:0]	lsu_tlu_rsr_data_e ;	// sr/pr rd data from lsu.

input			ifu_lsu_alt_space_e;	// alt-space access
input		    ifu_tlu_alt_space_d;	// alt-space access - d stage
input           lsu_tlu_squash_va_oor_m;// squash va_oor for mem-op.
// input           lsu_tlu_ill_inst_m;     // new illegal instru from spu via lsu
//
// new interfaces to the pib
input			ifu_tlu_imiss_e;	    // icache misses -- New interface
input [3:0]		lsu_tlu_dcache_miss_w2;	// dcache miss -- new interface
input [3:0]		lsu_tlu_l2_dmiss;	    // l2 misses -- new interface
input [3:0]		lsu_tlu_stb_full_w2;	// store buffer full -- new interface
input [1:0]		ffu_tlu_fpu_tid;	    // ThrdID for the FF instr_cmplt -- new
input       	ffu_tlu_fpu_cmplt;	    // FF instru complete -- new
//
// New trap from SPU
// removed for timing fix
input       	spu_tlu_rsrv_illgl_m;	// illegal instruction from SPU
input  [2:0]   	lsu_pid_state0 ;        // pid thread0 ; global use
input  [2:0]   	lsu_pid_state1 ;        // pid thread1 ; global use
input  [2:0]   	lsu_pid_state2 ;        // pid thread2 ; global use
input  [2:0]   	lsu_pid_state3 ;        // pid thread3 ; global use
// input [48:0] ifu_tlu_pc_w;

input           lsu_tlu_nucleus_ctxt_m ;// access is nucleus context
input  [2:0]    lsu_tlu_tte_pg_sz_g ;   // page-size of tte
input	[3:0]	ifu_lsu_error_inj ;	// inject parity error into tlb
input   [8:0]   ifu_lsu_imm_asi_d;      // asi state value from imm
input           ifu_lsu_imm_asi_vld_d;  // valid asi state value from imm

input	[23:0]	lsu_dsfsr_din_g ;	// now from lsu instead of tlu_tcl
input	[3:0]	lsu_dmmu_sfsr_trp_wr ;	// now from lsu instead of tlu_tcl

input		lsu_mmu_flush_pipe_w ; // full trap

input		exu_lsu_priority_trap_m ;//fill,ue


// output [5:0] int_tlu_rstid_i2;	// From tlu_int of sparc_tlu_int.v
/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
output [63:0]	tlu_lsu_int_ldxa_data_w2; // From tlu_int of sparc_tlu_int.v
output			tlu_lsu_int_ld_ill_va_w2; // From tlu_int of sparc_tlu_int.v
output			tlu_lsu_int_ldxa_vld_w2; // From tlu_int of sparc_tlu_int.v
output			so0,so1,short_so0,short_so1;			// From tlu_int of sparc_tlu_int.v, ...
output			tlu_dtlb_data_rd_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_actxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_all_g;	// From mmu_ctl of tlu_mmu_ctl.v
//output		tlu_dtlb_dmp_by_ctxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_nctxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_pctxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_sctxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_dmp_vld_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_invalidate_all_g;// From mmu_ctl of tlu_mmu_ctl.v
output [5:0]	tlu_dtlb_rw_index_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_rw_index_vld_g;// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_dtlb_tag_rd_g;	// From mmu_ctl of tlu_mmu_ctl.v
output [42:0]	tlu_dtlb_tte_data_w2;	// From mmu_dp of tlu_mmu_dp.v
output [58:0]	tlu_dtlb_tte_tag_w2;	// From mmu_dp of tlu_mmu_dp.v
output[3:0]		lsu_ifu_inj_ack ;	// ack for tlb error injection.
//
// width modified for hypervisor support
// output [2:0]	tlu_exu_agp;		// From tcl of tlu_tcl.v
output [2-1:0] tlu_exu_agp;		// From tcl of tlu_tcl.v
output			tlu_exu_agp_swap;	// From tcl of tlu_tcl.v
output [1:0]    tlu_exu_agp_tid;        // From tcl of tlu_tcl.v
output [7:0]	tlu_exu_ccr_m;		// From tcl of tlu_tcl.v
output [2:0]	tlu_exu_cwp_m;		// From tcl of tlu_tcl.v
output			tlu_exu_cwp_retry_m;	// From tcl of tlu_tcl.v
output			tlu_exu_cwpccr_update_m;// From tcl of tlu_tcl.v
// tlu_exu_rsr_data_e being replaced by tlu_exu_rsr_data_m
// the bus will become obsolete
// output [`TLU_ASR_DATA_WIDTH-1:0] tlu_exu_rsr_data_e;     // From tdp of tlu_tdp.v
output [64-1:0] tlu_exu_rsr_data_m;     // From tdp of tlu_tdp.v
output [40:0]	tlu_idtlb_dmp_key_g;	// From mmu_dp of tlu_mmu_dp.v
output [1:0]	tlu_idtlb_dmp_thrid_g;	// From mmu_ctl of tlu_mmu_ctl.v
output [3:0]	tlu_ifu_hwint_i3;	// From tlu_int of sparc_tlu_int.v
// removed - ifu will derive the signal internally
// output [3:0]	tlu_ifu_int_activate_i3;// From tlu_int of sparc_tlu_int.v
output			tlu_ifu_nukeint_i2;	// From tlu_int of sparc_tlu_int.v
output [3:0]	tlu_ifu_pstate_ie;	// From tlu_int of sparc_tlu_int.v
output [3:0]	tlu_ifu_pstate_pef;	// From tdp of tlu_tdp.v
output			tlu_ifu_resumint_i2;	// From tlu_int of sparc_tlu_int.v
output			tlu_ifu_rstint_i2;	// From tlu_int of sparc_tlu_int.v
output [3:0]	tlu_ifu_rstthr_i2;	// From tlu_int of sparc_tlu_int.v
output [1:0]	tlu_ifu_trap_tid_w1;	// From tcl of tlu_tcl.v
output			tlu_ifu_trapnpc_vld_w1;	// From tdp of tlu_tdp.v
output [48:0]	tlu_ifu_trapnpc_w2;	// From tdp of tlu_tdp.v
output [48:0]	tlu_ifu_trappc_w2;	// From tdp of tlu_tdp.v
// output [47:0]	tlu_ifu_trapnpc_w2;	// From tdp of tlu_tdp.v
// output [47:0]	tlu_ifu_trappc_w2;	// From tdp of tlu_tdp.v
output			tlu_ifu_trappc_vld_w1;	// From tcl of tlu_tcl.v
output			tlu_itlb_data_rd_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_dmp_actxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_dmp_all_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_dmp_nctxt_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_dmp_vld_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_invalidate_all_g;// From mmu_ctl of tlu_mmu_ctl.v
output [5:0]	tlu_itlb_rw_index_g;	// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_rw_index_vld_g;// From mmu_ctl of tlu_mmu_ctl.v
output			tlu_itlb_tag_rd_g;	// From mmu_ctl of tlu_mmu_ctl.v
output [42:0]	tlu_itlb_tte_data_w2;	// From mmu_dp of tlu_mmu_dp.v
output [58:0]	tlu_itlb_tte_tag_w2;	// From mmu_dp of tlu_mmu_dp.v
output			tlu_itlb_wr_vld_g;	// From mmu_ctl of tlu_mmu_ctl.v
output [7:0]	tlu_lsu_asi_m;		// From tcl of tlu_tcl.v
output			tlu_lsu_asi_update_m;	// From tcl of tlu_tcl.v


output          tlu_dtlb_csm_rd_g;
output          tlu_itlb_csm_rd_g;
output [32:0] tlu_dtlb_tte_csm_w2;
output [32:0] tlu_itlb_tte_csm_w2;
output      	tlu_itlb_wr_csm_sel_g;
output      	tlu_dtlb_wr_csm_sel_g;


// replaced by shadow scan signals
output [62:0]	tlu_sscan_test_data;// From tdp of tlu_tdp.v
// output [47:0]	tlu_sscan_pc;// From tdp of tlu_tdp.v
// output [63:0]	tlu_lsu_ldxa_data_w2;	// From mmu_dp of tlu_mmu_dp.v
output [1:0]	tlu_lsu_ldxa_tid_w2;	// From mmu_ctl of tlu_mmu_ctl.v
output [25:0]	tlu_lsu_pcxpkt;		// From tlu_int of sparc_tlu_int.v
output [3:0]	tlu_lsu_pstate_am;	// From tcl of tlu_tcl.v
output [3:0]	tlu_lsu_pstate_cle;	// From tdp of tlu_tdp.v
output [3:0]	tlu_lsu_pstate_priv;	// From tdp of tlu_tdp.v
output [3:0]	tlu_lsu_redmode;	// From tcl of tlu_tcl.v
// output [3:0]	tlu_lsu_redmode_rst;	// From tcl of tlu_tcl.v
output [3:0]	tlu_lsu_redmode_rst_d1;	// From tcl of tlu_tcl.v
// output [`TLU_THRD_NUM-1:0] tlu_lsu_async_ack_w2;	// From tcl of tlu_tcl.v
output			tlu_lsu_stxa_ack;	// From mmu_ctl of tlu_mmu_ctl.v
output [1:0]	tlu_lsu_stxa_ack_tid;	// From mmu_ctl of tlu_mmu_ctl.v
output [1:0]	tlu_lsu_tid_m;		// From tcl of tlu_tcl.v
output [4-1:0] tlu_lsu_tl_zero;	// From tcl of tlu_tcl.v
output [4-1:0] tlu_sftint_vld; // From tcl of tlu_tcl.v
output [4-1:0] tlu_hintp_vld;  // From tcl of tlu_tcl.v
output [4-1:0] tlu_rerr_vld;  // From tcl of tlu_tcl.v
// End of automatics
   // Outputs
// End of automatics
// output tlu_ifu_flush_pipe_w;	// From tcl of tlu_tcl.v
output tlu_early_flush_pipe_w;	// From tcl of tlu_tcl.v
output tlu_early_flush_pipe2_w;	// From tcl of tlu_tcl.v
output tlu_exu_early_flush_pipe_w;	// From tcl of tlu_tcl.v
output tlu_lsu_ldxa_async_data_vld ; // tlu_lsu_ldxa_data_vld is for async op.
output [4-1:0] tlu_hpstate_priv;
output [4-1:0] tlu_hpstate_enb;
// added for hpstate.ibe ECO
output [4-1:0] tlu_hpstate_ibe;
output tlu_exu_priv_trap_m; // local traps send to exu
output tlu_lsu_priv_trap_m; // local traps send to exu
// output tlu_lsu_priv_trap_w; // local traps send to exu
output tlu_exu_pic_onebelow_m; // local traps send to exu
output tlu_exu_pic_twobelow_m; // local traps send to exu
//
// added for MMU performance enhancement
output		lsu_exu_ldxa_m ;
output	[63:0]	lsu_exu_ldxa_data_g ;
// Added to shift dsfsr logic from tlu to lsu.
output	[3:0]	tlu_dsfsr_flt_vld;	// From mmu_dp of tlu_mmu_dp.v


//
// added to abide to the Niagara reset methodology
wire            tlu_rst;   // local active high reset - from tlu_tcl
wire            rclk;      // temprary clock name
wire [63:0]		tlu_pib_rsr_data_e;	// From tdp of tlu_tdp.v
// wire            tlu_rst_l; // local active high reset - from tlu_tcl
wire            int_rst_l; // local active high reset - from tlu_tcl
// wire            pib_rst_l; // local active high reset - from tlu_tcl
wire [1:0]		tlu_incr_tick;		// From tcl of tlu_tcl.v
wire [1:0]		tlu_tckctr_in;		// From tcl of tlu_tcl.v
// wire [60:0]		tlu_tick_incr_dout;	// To tdp of tlu_tdp.v
wire [61:0]		tlu_incr64_dout;	// To tdp of tlu_tdp.v
wire [61:0]		tlu_tick_incr_din;	// From tdp of tlu_tdp.v
wire			tlu_tick_ctl_din;		// To tlu_int of sparc_tlu_int.v
// modified for bug 3017
wire [48:0]		tlu_restore_pc_w1;
wire [48:0]		tlu_restore_npc_w1;
wire [48:0]		tlu_pc_new_w;
wire [48:0]		tlu_npc_new_w;
wire [33:0]		tlu_partial_trap_pc_w1;
wire [1:0]		tlu_int_tid_m;		// To tlu_int of sparc_tlu_int.v
//wire [3:0]		tlu_sftint_vld;		// From tcl of tlu_tcl.v
wire			tlu_asi_write_g;	// From hyperv of tlu_hyperv.v
wire			tlu_tte_real_g ;	// tte is real
wire [4-1:0] tlu_hpstate_tlz;
wire [8-1:0] tlu_asi_state_e;
// modified due to memory macro swap
//
// wire [`TSA_MEM_WIDTH-1:0]		tsa_dout;
wire [80-1:0] tsa0_dout;
wire [80-1:0] tsa1_dout;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
wire [64-1:0]		tlu_wsr_data_w;	// From tdp of tlu_tdp.v
wire			dmmu_any_sfsr_wr;	// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		dmmu_sfar_wr_en_l;	// From mmu_ctl of tlu_mmu_ctl.v
// wire [3:0]		dmmu_sfsr_trp_wr;	// From tcl of tlu_tcl.v
wire [3:0]		dmmu_sfsr_wr_en_l;	// From mmu_ctl of tlu_mmu_ctl.v
wire			immu_any_sfsr_wr;	// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		immu_sfsr_trp_wr;	// From tcl of tlu_tcl.v
wire [3:0]		immu_sfsr_wr_en_l;	// From mmu_ctl of tlu_mmu_ctl.v
wire [5:0]		int_tlu_rstid_m;	// From tlu_int of sparc_tlu_int.v
wire			itlb_wr_vld_g;		// From mmu_ctl of tlu_mmu_ctl.v
wire [7:0]		lsu_tlu_rsr_data_mod_e;	// From tcl of tlu_tcl.v
wire [19:0]		mra_byte_wen;		// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		mra_rd_ptr;		// From mmu_ctl of tlu_mmu_ctl.v
wire			mra_rd_vld;		// From mmu_ctl of tlu_mmu_ctl.v
wire [159:10]		mra_rdata;		// From mra of tlu_mra.v
wire [155:0]		mra_wdata;		// From mmu_dp of tlu_mmu_dp.v
wire [3:0]		mra_wr_ptr;		// From mmu_ctl of tlu_mmu_ctl.v
wire			mra_wr_vld;		// From mmu_ctl of tlu_mmu_ctl.v
wire [2:0]		tag_access_wdata_sel;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlb_access_rst_l;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlu_addr_msk_g;		// From tcl of tlu_tcl.v
wire			tlu_admp_key_sel;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlu_clr_sftint_l_g;	// From tcl of tlu_tcl.v
wire [4:0]		tlu_dmp_key_vld_g;	// From mmu_ctl of tlu_mmu_ctl.v
wire [2:0]      tlu_true_pc_sel_w;
wire [48:0]     ifu_npc_w;
wire [3:0]		tlu_dsfsr_flt_vld;	// From mmu_dp of tlu_mmu_dp.v
wire [47:13]	tlu_dtag_access_w2;	// From mmu_dp of tlu_mmu_dp.v
wire [3:0]		tlu_dtsb_size_w2;	// From mmu_dp of tlu_mmu_dp.v
wire			tlu_dtsb_split_w2;	// From mmu_dp of tlu_mmu_dp.v
wire [1:0]		tlu_agp_tid_w2;	    // From tcl of tlu_tcl.v
wire [9-1:0] tlu_final_offset_w1;	// From tcl of tlu_tcl.v
wire [9-1:0] tlu_final_ttype_w2;	// From tcl of tlu_tcl.v
wire			tlu_full_flush_pipe_w2;	// From tcl of tlu_tcl.v
wire            tlu_tcc_inst_w;	// From tcl of tlu_tcl.v
wire			tlu_local_flush_w;	// From tcl of tlu_tcl.v
wire [47:0]		tlu_idtsb_8k_ptr;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlu_asi_data_nf_vld_w2;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlu_inst_vld_nq_m;		// From tcl of tlu_tcl.v
wire			tlu_int_asi_load;	// From mmu_ctl of tlu_mmu_ctl.v
wire [1:0]		tlu_int_asi_thrid;	// From mmu_ctl of tlu_mmu_ctl.v
wire			tlu_int_asi_vld;	// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		tlu_int_pstate_ie;	// From tdp of tlu_tdp.v
wire [3:0]		tlu_int_redmode;	// From tdp of tlu_tdp.v
wire [23:0]		tlu_isfsr_din_g;	// From tcl of tlu_tcl.v
wire [3:0]		tlu_isfsr_flt_vld;	// From mmu_dp of tlu_mmu_dp.v
//wire [47:13]		tlu_itsb_base_w2;	// From mmu_dp of tlu_mmu_dp.v
wire [3:0]		tlu_itsb_size_w2;	// From mmu_dp of tlu_mmu_dp.v
wire			tlu_itsb_split_w2;	// From mmu_dp of tlu_mmu_dp.v
wire [3:0]		tlu_ldxa_l1mx1_sel;	// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		tlu_ldxa_l1mx2_sel;	// From mmu_ctl of tlu_mmu_ctl.v
wire [2:0]		tlu_ldxa_l2mx1_sel;	// From mmu_ctl of tlu_mmu_ctl.v
// wire			tlu_mmu_sync_data_excp_g;// From mmu_ctl of tlu_mmu_ctl.v
wire [3:0]		tlu_pil;		// From tcl of tlu_tcl.v
wire			tlu_tlb_tag_invrt_parity ;
wire			tlu_tlb_data_invrt_parity ;
wire                  tlu_sun4r_tte_g ;       // sun4r vs. sun4v tte
//
// modified for bug 1767
/*
wire [1:0]		tlu_pstate0_mmodel;	// From tdp of tlu_tdp.v
wire [1:0]		tlu_pstate1_mmodel;	// From tdp of tlu_tdp.v
wire [1:0]		tlu_pstate2_mmodel;	// From tdp of tlu_tdp.v
wire [1:0]		tlu_pstate3_mmodel;	// From tdp of tlu_tdp.v
wire [`TLU_THRD_NUM-1:0] tlu_pstate_tle;		// From tdp of tlu_tdp.v
wire [`TLU_THRD_NUM-1:0] tlu_pstate_cle;		// From tdp of tlu_tdp.v
*/
wire [4-1:0] tlu_pstate_am;		// From tdp of tlu_tdp.v
wire [1:0]		tlu_pstate_din_sel0;	// From tcl of tlu_tcl.v
wire [1:0]		tlu_pstate_din_sel1;	// From tcl of tlu_tcl.v
wire [1:0]		tlu_pstate_din_sel2;	// From tcl of tlu_tcl.v
wire [1:0]		tlu_pstate_din_sel3;	// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_pstate_priv;	// From tdp of tlu_tdp.v
// wire			tlu_retry_inst_m;	// From tcl of tlu_tcl.v
//
// modified for hypervisor support and bug 1767
/*
wire			tlu_select_alt_global;	// From tcl of tlu_tcl.v
wire			tlu_select_int_global;	// From tcl of tlu_tcl.v
wire			tlu_select_mmu_global;	// From tcl of tlu_tcl.v
wire [1:0]		tlu_select_mmodel;	// From tcl of tlu_tcl.v
wire			tlu_select_tle;		// From tcl of tlu_tcl.v
*/
wire			tlu_select_redmode;	// From tcl of tlu_tcl.v
// wire			tlu_select_tba_g;	// From tcl of tlu_tcl.v
wire			tlu_select_tba_w2;	// From tcl of tlu_tcl.v
wire			tdp_select_tba_w2;	// From tcl of tlu_tcl.v
// wire			tlu_self_boot_rst_g;	// From tcl of tlu_tcl.v
// wire			tlu_self_boot_rst_w2;	// From tcl of tlu_tcl.v
wire			tlu_set_sftint_l_g;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_sftint_en_l_g;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_sftint_mx_sel;	// From tcl of tlu_tcl.v
wire [3:0]		tlu_sftint_id;		// From tdp of tlu_tdp.v
// wire [3:0]		tlu_sftint_lvl14_int;	// From tcl of tlu_tcl.v
wire [3:0]		tlu_sftint_penc_sel;	// From tcl of tlu_tcl.v
wire [3:0]		tlu_slxa_thrd_sel;	// From mmu_ctl of tlu_mmu_ctl.v
wire [2:0]		tlu_tag_access_ctxt_sel_m;// From tcl of tlu_tcl.v
//wire			tlu_tag_access_nctxt_g;	// From mmu_dp of tlu_mmu_dp.v
wire [4-1:0] tlu_tba_en_l;		// From tcl of tlu_tcl.v
wire [4-1:0] tlu_thrd_rsel_e;	// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_thrd_rsel_g;	// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_thrd_wsel_g;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_thrd_wsel_w2;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_thread_wsel_g;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_thread_inst_vld_g;	// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_thread_inst_vld_w2;	// From tcl of tlu_tcl.v
wire			tlu_tick_en_l;		// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_tick_int;		// From tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] tlu_stick_int;		// From tcl of tlu_tcl.v
// wire			tlu_tick_match;		// From tdp of tlu_tdp.v
wire			tlu_tick_npt;		// From tcl of tlu_tcl.v
wire [4-1:0] tlu_tickcmp_en_l;	// From tcl of tlu_tcl.v
// wire			tlu_tickcmp_intdis;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_tickcmp_sel;	// From tcl of tlu_tcl.v
// wire			tlu_tl_gt_0_g;		// From tcl of tlu_tcl.v
wire			tlu_tl_gt_0_w2;		// From tcl of tlu_tcl.v
wire [2:0]		tlu_trp_lvl;		// From tcl of tlu_tcl.v
wire [2:0]		tlu_tte_tag_g;		// From mmu_ctl of tlu_mmu_ctl.v
wire [2:0]		tlu_tte_wr_pid_g;	// From mmu_ctl of tlu_mmu_ctl.v
// wire [`TLU_THRD_NUM-1:0] tlu_update_pc_l_m;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_update_pc_l_w;	// From tcl of tlu_tcl.v
wire [4-1:0] tlu_trap_cwp_en;	// From tcl of tlu_tcl.v
wire tlu_cwp_no_change_m;	// From tcl of tlu_tcl.v
// modified due to timing
// wire [3:0]		tlu_update_pstate_l_g;	// From tcl of tlu_tcl.v
wire [3:0]		tlu_update_pstate_l_w2;	// From tcl of tlu_tcl.v
wire			tlu_wr_sftint_l_g;	// From tcl of tlu_tcl.v
// wire			tlu_wsr_inst_g;		// From tcl of tlu_tcl.v
wire			tlu_wsr_inst_nq_g;		// From tcl of tlu_tcl.v
// wire			tlu_wr_tsa_inst_g;	// From tcl of tlu_tcl.v
wire			tlu_wr_tsa_inst_w2;	// From tcl of tlu_tcl.v
wire			tsa_npc_en;		// From tcl of tlu_tcl.v
wire			tsa_pc_en;		// From tcl of tlu_tcl.v
wire [1:0]		tsa_rd_tid;		// From tcl of tlu_tcl.v
wire [2:0]		tsa_rd_tpl;		// From tcl of tlu_tcl.v
wire			tsa_rd_vld_e;   // From tcl of tlu_tcl.v
wire			tsa_rd_en;		// From tcl of tlu_tcl.v
// wire [`TLU_TSA_WIDTH-1:0]		tsa_rdata;		// From tsa of tlu_tsa.v
wire			tsa_tstate_en;		// From tcl of tlu_tcl.v
wire			tsa_htstate_en;		// From tlu_hyperv of tlu_hyperv.v
wire			tsa_ttype_en;		// From tcl of tlu_tcl.v
wire [136-1:0]		tsa_wdata;		// From tdp of tlu_tdp.v
wire [1:0]		tsa_wr_tid;		// From tcl of tlu_tcl.v
wire [2:0]		tsa_wr_tpl;		// From tcl of tlu_tcl.v
// modified due to tsa memory swap
wire [1:0]		tsa_wr_vld;		// From tcl of tlu_tcl.v
wire			tlu_htstate_rw_d;  // From tlu_hyperv of tlu_hyperv.v
wire			tlu_htstate_rw_g;  // From tlu_hyperv of tlu_hyperv.v
// modified due to rsr mux recode
// wire			tlu_htba_mx2_sel;  // From tlu_hyperv of tlu_hyperv.v
wire			tlu_htickcmp_rw_e; // From tlu_hyperv of tlu_hyperv.v
// End of automatics
wire [8-1:0] tlu_asi_queue_rdata_g;
wire tlu_asi_queue_rd_vld_g;
wire tlu_ld_data_vld_g;
wire tlu_va_ill_g;
// wire tlu_va_all_zero_g;
//
// modified for timing fixes
// wire [3:0]		pib_priv_act_trap ;
wire [3:0]		pib_priv_act_trap_m ;
// wire [`QUE_TRAP_SEL_WIDTH-1:0] tlu_que_trap_sel_m;
wire [5:0] tlu_ctxt_cfg_w2;	// To mmu_ctl of tlu_mmu_ctl.v
wire [4-1:0] pib_picl_wrap;		// To tcl of tlu_tcl.v
wire [4-1:0] pib_pich_wrap;		// To tcl of tlu_tcl.v
wire [4-1:0] pich_wrap_flg;		// To tcl of tlu_tcl.v
wire [4-1:0] pich_onebelow_flg;		// To tcl of tlu_tcl.v
wire [4-1:0] pich_twobelow_flg;		// To tcl of tlu_tcl.v
wire tlu_pic_onebelow_e;		// To tcl of tlu_tcl.v
wire tlu_pic_twobelow_e;		// To tcl of tlu_tcl.v
wire tlu_pic_wrap_e;		// To tcl of tlu_tcl.v
//
// modified for bug 5436: Niagara 2.0
wire [4-1:0] tlu_pcr_ut;		// To tcl of tlu_tcl.v
wire [4-1:0] tlu_pcr_st;		// To tcl of tlu_tcl.v
// wire tlu_pcr_ut_e;		// To tcl of tlu_tcl.v
// wire tlu_pcr_st_e;		// To tcl of tlu_tcl.v
wire tlu_pic_cnt_en_m;		// To tcl of tlu_tcl.v
// wire [`TLU_THRD_NUM-1:0] pich_threebelow_flg;	// To tcl of tlu_tcl.v
//
// added for hypervisor support
wire [2-1:0] tlu_dnrtry_global_g;
// wire tlu_htick_match;
// wire tlu_stick_match;
wire tlu_trap_hpstate_enb;
wire [4-1:0] local_hpstate_priv;
wire [4-1:0] tcl_hpstate_priv;
wire [4-1:0] local_hpstate_enb;
wire [4-1:0] tcl_hpstate_enb;
wire [4-1:0] local_pstate_priv;
wire [4-1:0] local_pstate_ie;

wire [2-1:0] tlu_gl_lvl0;
wire [2-1:0] tlu_gl_lvl1;
wire [2-1:0] tlu_gl_lvl2;
wire [2-1:0] tlu_gl_lvl3;
// wire [`TLU_THRD_NUM-1:0] tlu_hintp_en_l_g;
wire [4-1:0] tlu_htba_en_l;
wire [4-1:0] tlu_htickcmp_en_l;
// wire [`TLU_THRD_NUM-1:0] tlu_set_hintp_g;
wire [4-1:0] tlu_set_hintp_sel_g;
wire [4-1:0] tlu_stickcmp_en_l;
// modified for timing
// wire [`TLU_THRD_NUM-1:0] tlu_update_hpstate_l_g;
wire [4-1:0] tlu_update_hpstate_l_w2;
wire [4-1:0] tlu_wr_hintp_g;
wire [4-1:0] tlu_cpu_mondo_cmp;
wire [4-1:0] tlu_dev_mondo_cmp;
wire [4-1:0] tlu_resum_err_cmp;
wire [4-1:0] tlu_hintp;
wire [1:0] tlu_hpstate_din_sel0;
wire [1:0] tlu_hpstate_din_sel1;
wire [1:0] tlu_hpstate_din_sel2;
wire [1:0] tlu_hpstate_din_sel3;
wire [4:0] tlu_hyperv_rdpr_sel;
wire [2:0] tlu_rdpr_mx1_sel;
wire [2:0] tlu_rdpr_mx2_sel;
wire [1:0] tlu_rdpr_mx3_sel;
wire [1:0] tlu_rdpr_mx4_sel;
wire [2:0] tlu_rdpr_mx5_sel;
wire [2:0] tlu_rdpr_mx6_sel;
wire [3:0] tlu_rdpr_mx7_sel;
// modified for timing
// wire tlu_ibrkpt_trap_g;
wire tlu_ibrkpt_trap_w2;
// wire tlu_select_htba_g;
// wire tlu_select_htba_w2;
wire [2:0] tlu_pc_mxsel_w2;
// wire       tlu_stickcmp_intdis;
wire       tlu_htickcmp_intdis;
// wire       tlu_gl_rw_g;
wire       tlu_gl_rw_m;
wire [4-1:0] tlu_por_rstint_g;
// modified due to timing
// wire tlu_thrd0_traps, tlu_thrd1_traps;
// wire tlu_thrd2_traps, tlu_thrd3_traps;
wire [4-1:0] tlu_thrd_traps_w2;
wire tlu_dnrtry0_inst_g, tlu_dnrtry1_inst_g;
wire tlu_dnrtry2_inst_g, tlu_dnrtry3_inst_g;
wire tlu_scpd_rd_vld_m; // tlu_scpd_rd_vld_g;
wire tlu_scpd_wr_vld_g;
wire tlu_hscpd_dacc_excpt_m;
wire tlu_qtail_dacc_excpt_m;
wire [5-1:0]  tlu_scpd_rd_addr_m;
wire [5-1:0]  tlu_scpd_wr_addr_g;
wire [79:0] tlu_scpd_asi_rdata_g;
//
// added for the change of hierarchy to promote sparc_tlu_intdp and
// sparc_tlu_intctl onto the tlu level
// wire			inc_ind_asi_inrr;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		tlu_asi_rdata_mxsel_g;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_asi_rd_invr;	// From intctl of sparc_tlu_intctl.v
// wire [3:0]		inc_ind_asi_thr;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		tlu_local_thrid_g;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_asi_wr_indr;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_asi_wr_inrr;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_indr_grant;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_ld_int_i1;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_rstthr_i1;	// From intctl of sparc_tlu_intctl.v
wire [3:0]		inc_ind_thr_m;	// From intctl of sparc_tlu_intctl.v
wire [1:0]		inc_indr_req_thrid;	// From intctl of sparc_tlu_intctl.v
wire			inc_indr_req_valid;	// From intctl of sparc_tlu_intctl.v
wire [4:0]		ind_inc_thrid_i1;	// From intdp of sparc_tlu_intdp.v
wire [1:0]		ind_inc_type_i1;	// From intdp of sparc_tlu_intdp.v
// wire			indr_inc_rst_pkt;	// From intdp of sparc_tlu_intdp.v
wire [3:0]		int_pending_i2_l;	// From intdp of sparc_tlu_intdp.v
// hypervisor lite indicator
// wire [`TLU_THRD_NUM-1:0] tlu_hyper_lite;

wire [12:0]		tlu_tag_access_ctxt_g ;
wire			tlu_lng_ltncy_en_l ;
wire			tlu_tsb_rd_ps0_sel ;
wire [47:13]		tlu_tsb_base_w2_d1 ;

wire            tlu_restore_pc_sel_w1;
wire            tlu_itag_acc_sel_g;
wire            tlu_tlb_access_en_l_d1;

   // scan chain wires
   wire         scan1_1;
   wire         scan1_2;
   wire         scan1_3;
   wire         scan0_1;
   wire         short_scan0_1;
   wire         short_scan0_2;
   wire         short_scan0_3;
   wire         short_scan0_4;
   wire         short_scan0_5;
   wire         short_scan0_6;
//=====================================================================================
// DUMMY WIRES FOR VLINT. TO BE FILTERED OUT.
wire [9:0]		dummy_mra_rdata;

//=====================================================================================


/*
sparc_tlu_int  AUTO_TEMPLATE (
		       .tlu_int_asi_state(lsu_asi_state[`TLU_ASI_STATE_WIDTH-1:0]),
		       .lsu_tlu_pmode	(1'b1),

		       .int_tlu_longop_done());
*/
//
// modified the hierarchy to bring sparc_tlu_intdp and sparc_tlu_intctl
// to the tlu level - eliminating sparc_tlu_int
/*
sparc_tlu_int tlu_int (
		       .tlu_int_asi_state(lsu_asi_state[`TLU_ASI_STATE_WIDTH-1:0]),
		       .lsu_tlu_pmode	(1'b1),	// enable partition mode

		       .int_tlu_longop_done(),  // use to switch in thread
		       // .tlu_int_asi_store(tlu_int_asi_store),
		       // Outputs
		       .int_scpd_asi_data(int_scpd_asi_data[63:0]),
		       .int_scpd_asi_data_vld(int_scpd_asi_data_vld),
		       .int_tlu_rstid_m	(int_tlu_rstid_m[5:0]),
		       .so		(so),
		       .tlu_ifu_hwint_i3(tlu_ifu_hwint_i3[3:0]),
		       // .tlu_ifu_int_activate_i3(tlu_ifu_int_activate_i3[3:0]),
		       .tlu_ifu_nukeint_i2(tlu_ifu_nukeint_i2),
		       .tlu_ifu_pstate_ie(tlu_ifu_pstate_ie[3:0]),
		       .tlu_ifu_resumint_i2(tlu_ifu_resumint_i2),
		       .tlu_ifu_rstint_i2(tlu_ifu_rstint_i2),
		       .tlu_ifu_rstthr_i2(tlu_ifu_rstthr_i2[3:0]),
		       .tlu_lsu_pcxpkt	(tlu_lsu_pcxpkt[25:0]),
		       // Inputs
		       .lsu_tlu_st_rs3_data_g(lsu_tlu_rs3_data_g[63:0]),
		       .clk		(rclk),
		       .const_cpuid	(const_cpuid[3:0]),
		       .lsu_tlu_cpx_req	(lsu_tlu_cpx_req[3:0]),
		       .lsu_tlu_cpx_vld	(lsu_tlu_cpx_vld),
		       .lsu_tlu_intpkt	(lsu_tlu_intpkt[17:0]),
		       .lsu_tlu_pcxpkt_ack(lsu_tlu_pcxpkt_ack),
		       .tlu_rst_l	(tlu_rst_l),
		       .se		(se),
		       .si		(si),
		       .tlu_int_asi_load(tlu_int_asi_load),
		       .tlu_int_asi_thrid(tlu_int_asi_thrid[1:0]),
		       .tlu_int_asi_vld	(tlu_int_asi_vld),
		       .tlu_int_pstate_ie(tlu_int_pstate_ie[3:0]),
		       .tlu_int_redmode	(tlu_int_redmode[3:0]),
		       .tlu_int_sftint_pend(tlu_int_sftint_pend[3:0]),
		       .tlu_int_tid_m	(tlu_int_tid_m[1:0]));
*/
sparc_tlu_intdp  intdp(
			  .lsu_ind_intpkt_id(lsu_tlu_intpkt[5:0]),
			  .lsu_ind_intpkt_type(lsu_tlu_intpkt[17:16]),
			  .lsu_ind_intpkt_thr(lsu_tlu_intpkt[12:8]),
			  .so		(scan1_1),
			  .si		(si1),
              /*AUTOINST*/
			  // Outputs
			  .int_pending_i2_l(int_pending_i2_l[3:0]),
			  .ind_inc_thrid_i1(ind_inc_thrid_i1[4:0]),
			  .ind_inc_type_i1(ind_inc_type_i1[1:0]),
			  .int_tlu_rstid_m(int_tlu_rstid_m[5:0]),
			  .tlu_lsu_pcxpkt(tlu_lsu_pcxpkt[25:0]),
			  .tlu_lsu_int_ldxa_data_w2(tlu_lsu_int_ldxa_data_w2[63:0]),
			  // Inputs
			  .rclk		(rclk),
			  .se		(se),
			  .tlu_rst_l(int_rst_l),
			  .lsu_tlu_st_rs3_data_g(lsu_tlu_rs3_data_g[63:0]),
			  .tlu_asi_rdata_mxsel_g(tlu_asi_rdata_mxsel_g[3:0]),
              .tlu_scpd_asi_rdata_g(tlu_scpd_asi_rdata_g[64-1:0]),
              .tlu_asi_queue_rdata_g(tlu_asi_queue_rdata_g[8-1:0]),
			  .inc_ind_ld_int_i1(inc_ind_ld_int_i1[3:0]),
			  .inc_ind_rstthr_i1(inc_ind_rstthr_i1[3:0]),
			  .inc_ind_asi_thr(tlu_local_thrid_g[4-1:0]),
			  .inc_ind_asi_wr_indr(inc_ind_asi_wr_indr[3:0]),
			  .inc_ind_indr_grant(inc_ind_indr_grant[3:0]),
			  .inc_ind_thr_m(inc_ind_thr_m[3:0]),
			  .inc_ind_asi_wr_inrr(inc_ind_asi_wr_inrr[3:0]),
			  .inc_ind_asi_rd_invr(inc_ind_asi_rd_invr[3:0]),
			  .inc_indr_req_valid(inc_indr_req_valid),
			  .inc_indr_req_thrid(inc_indr_req_thrid[1:0]));

sparc_tlu_intctl  intctl(
			    .so		(scan0_1),
			    .si		(si0),
			    .tlu_int_asi_store(tlu_asi_write_g),
			    /*AUTOINST*/
			    // Outputs
			    .tlu_ifu_hwint_i3(tlu_ifu_hwint_i3[3:0]),
			    .tlu_ifu_rstthr_i2(tlu_ifu_rstthr_i2[3:0]),
			    .tlu_ifu_rstint_i2(tlu_ifu_rstint_i2),
			    .tlu_ifu_nukeint_i2(tlu_ifu_nukeint_i2),
			    .tlu_ifu_resumint_i2(tlu_ifu_resumint_i2),
			    .tlu_ifu_pstate_ie(tlu_ifu_pstate_ie[3:0]),
		        .int_tlu_longop_done(),
			    .inc_ind_ld_int_i1(inc_ind_ld_int_i1[3:0]),
			    .inc_ind_rstthr_i1(inc_ind_rstthr_i1[3:0]),
			    .inc_ind_indr_grant(inc_ind_indr_grant[3:0]),
			    .inc_ind_thr_m(inc_ind_thr_m[3:0]),
			    .inc_indr_req_valid(inc_indr_req_valid),
			    .inc_indr_req_thrid(inc_indr_req_thrid[1:0]),
			    .tlu_asi_data_nf_vld_w2(tlu_asi_data_nf_vld_w2),
			    .tlu_lsu_int_ld_ill_va_w2(tlu_lsu_int_ld_ill_va_w2),
			    .tlu_asi_rdata_mxsel_g(tlu_asi_rdata_mxsel_g[3:0]),
			    .int_rst_l (int_rst_l),
			    // Inputs
			    .rclk	(rclk),
			    .se		(se),
			    .sehold	(sehold),
		        .grst_l	(grst_l),
		        .arst_l	(arst_l),
			    .rst_tri_en	(mux_drive_disable),
			    .const_cpuid(const_cpuid[3:0]),
			    .lsu_tlu_cpx_vld(lsu_tlu_cpx_vld),
			    .lsu_tlu_cpx_req(lsu_tlu_cpx_req[3:0]),
			    .lsu_tlu_pcxpkt_ack(lsu_tlu_pcxpkt_ack),
			    .ind_inc_thrid_i1(ind_inc_thrid_i1[4:0]),
			    .ind_inc_type_i1(ind_inc_type_i1[1:0]),
			    .tlu_int_asi_vld(tlu_int_asi_vld),
			    .tlu_int_asi_load(tlu_int_asi_load),
			    .tlu_int_asi_thrid(tlu_int_asi_thrid[1:0]),
		        .tlu_int_asi_state(lsu_asi_state[7:0]),
			    .tlu_int_tid_m(tlu_int_tid_m[1:0]),
			    .tlu_int_pstate_ie(tlu_int_pstate_ie[3:0]),
			    .tlu_asi_queue_rd_vld_g(tlu_asi_queue_rd_vld_g),
			    .tlu_ld_data_vld_g(tlu_ld_data_vld_g),
			    .tlu_va_ill_g(tlu_va_ill_g),
			    .int_pending_i2_l(int_pending_i2_l[3:0]));

tlu_misctl misctl (
         // output
         .tlu_exu_pic_onebelow_m  (tlu_exu_pic_onebelow_m),
         .tlu_exu_pic_twobelow_m  (tlu_exu_pic_twobelow_m),
	     .tlu_exu_cwp_m		  (tlu_exu_cwp_m[3-1:0]),
	     .tlu_exu_ccr_m		  (tlu_exu_ccr_m[8-1:0]),
	     .tlu_lsu_asi_m		  (tlu_lsu_asi_m[8-1:0]),
         .tlu_cwp_no_change_m (tlu_cwp_no_change_m),
         .tlu_sscan_misctl_data  (tlu_sscan_test_data[59:51]),
         .tlu_ifu_trappc_w2     (tlu_ifu_trappc_w2[48:0]),
         .tlu_ifu_trapnpc_w2    (tlu_ifu_trapnpc_w2[48:0]),
         .tlu_pc_new_w          (tlu_pc_new_w[48:0]),
         .tlu_npc_new_w         (tlu_npc_new_w[48:0]),
         .so (short_so0),
         // inputs
	     .ctu_sscan_tid      (ctu_sscan_tid[4-1:0]),
	     .ifu_tlu_pc_m		 (ifu_tlu_pc_m[48:0]),
	     // .ifu_tlu_npc_m		 (ifu_tlu_npc_m[48:0]),
	     .ifu_npc_w		     (ifu_npc_w[48:0]),
	     .exu_tlu_cwp0		 (exu_tlu_cwp0[3-1:0]),
	     .exu_tlu_cwp1		 (exu_tlu_cwp1[3-1:0]),
	     .exu_tlu_cwp2		 (exu_tlu_cwp2[3-1:0]),
	     .exu_tlu_cwp3		 (exu_tlu_cwp3[3-1:0]),
	     .tlu_partial_trap_pc_w1 (tlu_partial_trap_pc_w1[33:0]),
         .tlu_restore_pc_w1      (tlu_restore_pc_w1[48:0]),
         .tlu_restore_npc_w1     (tlu_restore_npc_w1[48:0]),
	     .tlu_final_ttype_w2     (tlu_final_ttype_w2[9-1:0]),
	     .tlu_final_offset_w1    (tlu_final_offset_w1[9-1:0]),
	     .tlu_restore_pc_sel_w1	 (tlu_restore_pc_sel_w1),
	     // .tlu_retry_inst_m	     (tlu_retry_inst_m),
	     // .tlu_done_inst_m	     (tlu_done_inst_m),
	     // .tlu_dnrtry_inst_m_l    (tlu_dnrtry_inst_m_l),
	     .tlu_true_pc_sel_w   (tlu_true_pc_sel_w[2:0]),
	     .tsa_wr_tid   (tsa_wr_tid[1:0]),
	     .tsa1_wr_vld  (tsa_wr_vld[1]),
	     .tsa_ttype_en (tsa_ttype_en),
	     .tsa_rd_vld_e (tsa_rd_vld_e),
	     // .tsa_rd_vld   (tsa_rd_vld),
	     .tsa0_rdata_cwp	 (tsa0_dout[2:0]),
	     .tsa0_rdata_pstate	 (tsa0_dout[10:3]),
	     .tsa0_rdata_asi	 (tsa0_dout[18:11]),
	     .tsa0_rdata_ccr	 (tsa0_dout[26:19]),
	     .tsa0_rdata_gl		 (tsa0_dout[28:27]),
	     .tsa0_rdata_pc		 (tsa0_dout[78:32]),
	     .tsa1_rdata_ttype	 (tsa1_dout[8:0]),
	     .tsa1_rdata_npc	 (tsa1_dout[58:12]),
	     .tsa1_rdata_htstate (tsa1_dout[63:60]),
	     .tlu_thrd_rsel_e	 (tlu_thrd_rsel_e[4-1:0]),
         // experiement
         .tlu_pic_onebelow_e (tlu_pic_onebelow_e),
         .tlu_pic_twobelow_e (tlu_pic_twobelow_e),
         .tlu_pic_cnt_en_m   (tlu_pic_cnt_en_m),
         // .pich_onebelow_flg (pich_onebelow_flg[`TLU_THRD_NUM-1:0]),
         // .pich_twobelow_flg (pich_twobelow_flg[`TLU_THRD_NUM-1:0]),
         // .pich_threebelow_flg (pich_threebelow_flg[`TLU_THRD_NUM-1:0]),
	     // .tlu_thread_inst_vld_w2	(tlu_thread_inst_vld_w2[`TLU_THRD_NUM-1:0]),
         //
	     .tlu_rst			(tlu_rst),
         .se (se),
         .si (short_scan0_6),
	     .rclk      (rclk));

tlu_tcl tcl (
         .so (short_so1),
         .si (short_si1),
	     .tlu_wsr_data_b63_w	(tlu_wsr_data_w[64-1]),
	 .tlu_itag_acc_sel_g (tlu_itag_acc_sel_g),
         .pib_priv_act_trap_m   (pib_priv_act_trap_m[3:0]),
         .spu_tlu_rsrv_illgl_m  (spu_tlu_rsrv_illgl_m),
         .tlu_cpu_mondo_cmp (tlu_cpu_mondo_cmp[4-1:0]),
         .tlu_dev_mondo_cmp (tlu_dev_mondo_cmp[4-1:0]),
         .tlu_resum_err_cmp (tlu_resum_err_cmp[4-1:0]),
         .tlu_hintp         (tlu_hintp),
         .pich_wrap_flg     (pich_wrap_flg[4-1:0]),
         .pich_onebelow_flg (pich_onebelow_flg[4-1:0]),
         .pich_twobelow_flg (pich_twobelow_flg[4-1:0]),
          // modified for bug 5436: Niagara 2.0
	     .tlu_pcr_ut	    (tlu_pcr_ut[4-1:0]),
	     .tlu_pcr_st	    (tlu_pcr_st[4-1:0]),
	     // .tlu_pcr_ut_e	    (tlu_pcr_ut_e),
	     // .tlu_pcr_st_e	    (tlu_pcr_st_e),
         .tlu_pic_cnt_en_m  (tlu_pic_cnt_en_m),
         .tlu_pic_wrap_e    (tlu_pic_wrap_e),
         // .pich_threebelow_flg (pich_threebelow_flg[`TLU_THRD_NUM-1:0]),
         .pib_picl_wrap (pib_picl_wrap[4-1:0]),
	     .tlu_local_flush_w	(tlu_local_flush_w),
	     .tlu_restore_pc_sel_w1	(tlu_restore_pc_sel_w1),
	     .tlu_final_offset_w1 (tlu_final_offset_w1[9-1:0]),
	     // Outputs
         .pib_pich_wrap (pib_pich_wrap[4-1:0]),
         .tlu_ibrkpt_trap_w2     (tlu_ibrkpt_trap_w2),
	     .tlu_early_flush_pipe_w	(tlu_early_flush_pipe_w),
	     .tlu_early_flush_pipe2_w	(tlu_early_flush_pipe2_w),
	     .tlu_exu_early_flush_pipe_w	(tlu_exu_early_flush_pipe_w),
	     .tlu_ifu_trappc_vld_w1	(tlu_ifu_trappc_vld_w1),
	     .tlu_ifu_trapnpc_vld_w1	(tlu_ifu_trapnpc_vld_w1),
	     .tlu_ifu_trap_tid_w1	(tlu_ifu_trap_tid_w1[1:0]),
         .tlu_trap_hpstate_enb  (tlu_trap_hpstate_enb),
         .tlu_exu_priv_trap_m  (tlu_exu_priv_trap_m),
         .tlu_lsu_priv_trap_m  (tlu_lsu_priv_trap_m),
         // .tlu_lsu_priv_trap_w  (tlu_lsu_priv_trap_w),
         // .tlu_exu_pic_onebelow_m  (tlu_exu_pic_onebelow_m),
         // .tlu_exu_pic_twobelow_m  (tlu_exu_pic_twobelow_m),
	     .tsa_wr_tpl		(tsa_wr_tpl[2:0]),
	     .tsa_rd_tid		(tsa_rd_tid[1:0]),
	     .tsa_rd_tpl		(tsa_rd_tpl[2:0]),
	     .tsa_wr_tid		(tsa_wr_tid[1:0]),
	     .tsa_wr_vld		(tsa_wr_vld[1:0]),
	     .tsa_rd_vld_e		(tsa_rd_vld_e),
	     .tsa_rd_en		    (tsa_rd_en),
	     .tlu_lsu_tl_zero		(tlu_lsu_tl_zero[3:0]),
	     .tlu_full_flush_pipe_w2 (tlu_full_flush_pipe_w2),
		 .tlu_exu_agp_tid	(tlu_exu_agp_tid[1:0]),
	     .tlu_agp_tid_w2	(tlu_agp_tid_w2[1:0]),
	     .tlu_tcc_inst_w    (tlu_tcc_inst_w),
	     .tsa_pc_en			(tsa_pc_en),
	     .tsa_npc_en		(tsa_npc_en),
	     .tsa_tstate_en		(tsa_tstate_en),
	     .tsa_ttype_en		(tsa_ttype_en),
	     .tsa_htstate_en	(tsa_htstate_en),
	     .tlu_tl_gt_0_w2		(tlu_tl_gt_0_w2),
	     // .tlu_retry_inst_m		(tlu_retry_inst_m),
	     // .tlu_done_inst_m		(tlu_done_inst_m),
	     // .tlu_dnrtry_inst_m_l		(tlu_dnrtry_inst_m_l),
	     .tlu_true_pc_sel_w   (tlu_true_pc_sel_w[2:0]),
	     .tlu_tick_en_l		(tlu_tick_en_l),
	     .tlu_tickcmp_en_l		(tlu_tickcmp_en_l[4-1:0]),
	     .tlu_tba_en_l		(tlu_tba_en_l[4-1:0]),
	     .tlu_thrd_wsel_w2		(tlu_thrd_wsel_w2[4-1:0]),
	     .tlu_thread_wsel_g		(tlu_thread_wsel_g[4-1:0]),
	     .tlu_final_ttype_w2		(tlu_final_ttype_w2[9-1:0]),
	     .tlu_thread_inst_vld_g	(tlu_thread_inst_vld_g[4-1:0]),
	     // .tlu_thread_inst_vld_w2	(tlu_thread_inst_vld_w2[`TLU_THRD_NUM-1:0]),
	     .tlu_update_pc_l_w		(tlu_update_pc_l_w[4-1:0]),
	     .tlu_select_redmode	(tlu_select_redmode),
	     .tlu_pstate_din_sel0	(tlu_pstate_din_sel0[1:0]),
	     .tlu_pstate_din_sel1	(tlu_pstate_din_sel1[1:0]),
	     .tlu_pstate_din_sel2	(tlu_pstate_din_sel2[1:0]),
	     .tlu_pstate_din_sel3	(tlu_pstate_din_sel3[1:0]),
	     .tlu_update_pstate_l_w2	(tlu_update_pstate_l_w2[3:0]),
	     .tlu_trp_lvl		(tlu_trp_lvl[2:0]),
	     .tlu_pil			(tlu_pil[3:0]),
	     .tlu_wsr_inst_nq_g		(tlu_wsr_inst_nq_g),
	     .tlu_wr_tsa_inst_w2		(tlu_wr_tsa_inst_w2),
	     .tlu_exu_cwp_retry_m	(tlu_exu_cwp_retry_m),
	     .tlu_exu_cwpccr_update_m	(tlu_exu_cwpccr_update_m),
	     .tlu_lsu_asi_update_m	(tlu_lsu_asi_update_m),
	     .tlu_lsu_tid_m		(tlu_lsu_tid_m[1:0]),
	     .tlu_select_tba_w2		(tlu_select_tba_w2),
	     .tdp_select_tba_w2		(tdp_select_tba_w2),
	     .tlu_set_sftint_l_g	(tlu_set_sftint_l_g),
	     .tlu_clr_sftint_l_g	(tlu_clr_sftint_l_g),
	     .tlu_wr_sftint_l_g		(tlu_wr_sftint_l_g),
	     .tlu_sftint_en_l_g		(tlu_sftint_en_l_g[4-1:0]),
	     .tlu_sftint_mx_sel		(tlu_sftint_mx_sel[4-1:0]),
	     .tlu_sftint_penc_sel	(tlu_sftint_penc_sel[4-1:0]),
	     .tlu_sftint_vld		(tlu_sftint_vld[4-1:0]),
	     .tlu_hintp_vld		    (tlu_hintp_vld[4-1:0]),
	     .tlu_rerr_vld		    (tlu_rerr_vld[4-1:0]),
	     .tlu_int_tid_m		    (tlu_int_tid_m[1:0]),
	     .tlu_incr_tick		    (tlu_incr_tick[1:0]),
	     .tlu_tckctr_in		    (tlu_tckctr_in[1:0]),
	     .tlu_tickcmp_sel		(tlu_tickcmp_sel[4-1:0]),
	     .immu_sfsr_trp_wr		(immu_sfsr_trp_wr[3:0]),
	     .tlu_isfsr_din_g		(tlu_isfsr_din_g[23:0]),
	     .tlu_tick_npt		    (tlu_tick_npt),
	     .tlu_thrd_rsel_e		(tlu_thrd_rsel_e[3:0]),
	     .tlu_inst_vld_nq_m		(tlu_inst_vld_nq_m),
	     .tlu_lsu_pstate_am		(tlu_lsu_pstate_am[3:0]),
         .tlu_hyperv_rdpr_sel   (tlu_hyperv_rdpr_sel[4:0]),
	     .tlu_rdpr_mx1_sel		(tlu_rdpr_mx1_sel[2:0]),
	     .tlu_rdpr_mx2_sel		(tlu_rdpr_mx2_sel[2:0]),
	     .tlu_rdpr_mx3_sel		(tlu_rdpr_mx3_sel[1:0]),
	     .tlu_rdpr_mx4_sel		(tlu_rdpr_mx4_sel[1:0]),
	     .tlu_rdpr_mx5_sel		(tlu_rdpr_mx5_sel[2:0]),
	     .tlu_rdpr_mx6_sel		(tlu_rdpr_mx6_sel[2:0]),
	     .tlu_rdpr_mx7_sel		(tlu_rdpr_mx7_sel[3:0]),
	     .tlu_lsu_redmode_rst_d1 (tlu_lsu_redmode_rst_d1[3:0]),
	     .lsu_tlu_rsr_data_mod_e	(lsu_tlu_rsr_data_mod_e[7:0]),
	     .tlu_addr_msk_g		(tlu_addr_msk_g),
         .tlu_stickcmp_en_l (tlu_stickcmp_en_l[4-1:0]),
         .tlu_htickcmp_en_l (tlu_htickcmp_en_l[4-1:0]),
         .tlu_htstate_rw_d (tlu_htstate_rw_d),
         .tlu_htstate_rw_g (tlu_htstate_rw_g),
         .tlu_dnrtry0_inst_g (tlu_dnrtry0_inst_g),
         .tlu_dnrtry1_inst_g (tlu_dnrtry1_inst_g),
         .tlu_dnrtry2_inst_g (tlu_dnrtry2_inst_g),
         .tlu_dnrtry3_inst_g (tlu_dnrtry3_inst_g),
         .tlu_thrd_traps_w2 (tlu_thrd_traps_w2[4-1:0]),
         .tlu_tick_ctl_din (tlu_tick_ctl_din),
         .tlu_por_rstint_g (tlu_por_rstint_g[4-1:0]),
         .tlu_pc_mxsel_w2 (tlu_pc_mxsel_w2),
	     .ifu_npc_w		    (ifu_npc_w[48:0]),
	     .tlu_rst			(tlu_rst),
	     // .tlu_rst_l			(tlu_rst_l),
         .tlu_sscan_tcl_data (tlu_sscan_test_data[62:60]),
	     // Inputs
	     .ifu_tlu_npc_m		    (ifu_tlu_npc_m[48:0]),
	     .ifu_tlu_pc_oor_e		(ifu_tlu_pc_oor_e),
         .lsu_tlu_early_flush_w (lsu_tlu_early_flush_w),
         .ifu_tlu_flush_fd_w    (ifu_tlu_flush_fd2_w),
	     .ifu_tlu_sraddr_d		(ifu_tlu_sraddr_d[7-1:0]),
	     .ifu_tlu_rsr_inst_d	(ifu_tlu_rsr_inst_d),
	     .lsu_tlu_wsr_inst_e	(lsu_tlu_wsr_inst_e),
	     .tlu_wsr_data_w	    (tlu_wsr_data_w[3:0]),
	     .lsu_tlu_ttype_m2		(lsu_tlu_ttype_m2[8:0]),
	     .lsu_tlu_ttype_vld_m2	(lsu_tlu_ttype_vld_m2),
	     .ifu_tlu_done_inst_d	(ifu_tlu_done_inst_d),
	     .ifu_tlu_retry_inst_d	(ifu_tlu_retry_inst_d),
	     .ifu_tlu_ttype_m		(ifu_tlu_ttype_m[8:0]),
	     .ifu_tlu_ttype_vld_m	(ifu_tlu_ttype_vld_m),
	     .ifu_tlu_trap_m	    (ifu_tlu_trap_m),
	     .exu_tlu_ttype_m		(exu_tlu_ttype_m[8:0]),
	     .exu_tlu_ttype_vld_m	(exu_tlu_ttype_vld_m),
	     .exu_tlu_ue_trap_m	(exu_tlu_ue_trap_m),
	     .exu_tlu_spill		(exu_tlu_spill),
	     .exu_tlu_spill_tid		(exu_tlu_spill_tid[1:0]),
         .exu_tlu_spill_other   (exu_tlu_spill_other),
         .exu_tlu_spill_wtype   (exu_tlu_spill_wtype),
	     .exu_tlu_va_oor_m		(exu_tlu_va_oor_m),
	     .exu_tlu_va_oor_jl_ret_m	(exu_tlu_va_oor_jl_ret_m),
         .tlu_cwp_no_change_m   (tlu_cwp_no_change_m),
         .tlu_trap_cwp_en   (tlu_trap_cwp_en[4-1:0]),
	     .ifu_tlu_sir_inst_m	(ifu_tlu_sir_inst_m),
	     .ifu_tlu_inst_vld_m	(ifu_tlu_inst_vld_m),
	     .ifu_tlu_thrid_d		(ifu_tlu_thrid_d[1:0]),
         .lsu_tlu_async_ttype_vld_g (lsu_tlu_async_ttype_vld_g),
         .lsu_tlu_defr_trp_taken_g (lsu_tlu_defr_trp_taken_g),
         .lsu_tlu_async_ttype_g (lsu_tlu_async_ttype_g),
         .lsu_tlu_async_tid_g (lsu_tlu_async_tid_g[1:0]),
	     .ifu_tlu_immu_miss_m	(ifu_tlu_immu_miss_m),
	     .exu_tlu_cwp_cmplt		(exu_tlu_cwp_cmplt),
	     .exu_tlu_cwp_retry		(exu_tlu_cwp_retry),
	     .exu_tlu_cwp_cmplt_tid	(exu_tlu_cwp_cmplt_tid[1:0]),
	     .ifu_tlu_rstint_m		(ifu_tlu_rstint_m),
	     .ifu_tlu_hwint_m		(ifu_tlu_hwint_m),
	     .ifu_tlu_swint_m		(ifu_tlu_swint_m),
	     .int_tlu_rstid_m		(int_tlu_rstid_m[5:0]),
	     .tlu_int_pstate_ie		(local_pstate_ie[3:0]),
	     .tlu_int_redmode		(tlu_int_redmode[3:0]),
	     .tlu_sftint_id		(tlu_sftint_id[3:0]),
	     .lsu_tlu_misalign_addr_ldst_atm_m(lsu_tlu_misalign_addr_ldst_atm_m),
	     .exu_tlu_misalign_addr_jmpl_rtn_m(exu_tlu_misalign_addr_jmpl_rtn_m),
	     .lsu_tlu_priv_action_g	(lsu_tlu_priv_action_g),
	     .lsu_tlu_wtchpt_trp_g	(lsu_tlu_wtchpt_trp_g),
	     .ifu_tlu_priv_violtn_m	(ifu_tlu_priv_violtn_m),
	     .ifu_lsu_memref_d		(ifu_lsu_memref_d),
	     .tlu_pstate_priv		(local_pstate_priv[4-1:0]),
	     .tlu_pstate_am		(tlu_pstate_am[3:0]),
	     .tlu_isfsr_flt_vld		(tlu_isfsr_flt_vld[3:0]),
	     .ffu_tlu_trap_ieee754	(ffu_tlu_trap_ieee754),
	     .ffu_tlu_trap_other	(ffu_tlu_trap_other),
	     .ffu_tlu_trap_ue	    (ffu_tlu_trap_ue),
	     .ffu_ifu_tid_w2		(ffu_ifu_tid_w2[1:0]),
	     .ffu_tlu_ill_inst_m		(ffu_tlu_ill_inst_m), // new trap from ffu
	     .lsu_tlu_rsr_data_e	(lsu_tlu_rsr_data_e[7:0]),
	     .lsu_tlu_squash_va_oor_m	(lsu_tlu_squash_va_oor_m),
	     .tlu_hpstate_priv (tcl_hpstate_priv[4-1:0]),
         .tlu_hscpd_dacc_excpt_m(tlu_hscpd_dacc_excpt_m),
         .tlu_qtail_dacc_excpt_m(tlu_qtail_dacc_excpt_m),
         .tlu_htickcmp_rw_e (tlu_htickcmp_rw_e),
         // .tlu_gl_rw_g (tlu_gl_rw_g),
         .tlu_gl_rw_m (tlu_gl_rw_m),
         .tlu_hpstate_enb  (tcl_hpstate_enb[4-1:0]),
         .tlu_hpstate_tlz  (tlu_hpstate_tlz[4-1:0]),
	     .ctu_sscan_tid    (ctu_sscan_tid[4-1:0]),
         .se         (se),
	     .rclk		 (rclk),
	     .grst_l	 (grst_l),
	     .arst_l	 (arst_l),
	     .rst_tri_en (mux_drive_disable));

tlu_tdp tdp (
	     .so			(scan1_2),
	     .si			(scan1_1),
	     .tsa_rdata	    ({tsa1_dout[63:60],
                         // tsa0_dout[`TSA0_TPC_HI:`TSA0_TPC_LO],
                         // tsa1_dout[`TSA1_TNPC_HI:`TSA1_TNPC_LO],
                         tsa0_dout[78-1:32],
                         tsa1_dout[58-1:12],
                         tsa0_dout[28:0],
                         tsa1_dout[8:0]}),
	     .lsu_tlu_rsr_data_e (lsu_tlu_rsr_data_mod_e[7:0]),
         .ifu_lsu_imm_asi_d           (ifu_lsu_imm_asi_d[7:0]),
         .ifu_lsu_imm_asi_vld_d       (ifu_lsu_imm_asi_vld_d),
	     .tlu_lsu_redmode		(tlu_lsu_redmode[3:0]),
         .tlu_exu_rsr_data_m    (tlu_exu_rsr_data_m[64-1:0]),
         /*AUTOINST*/
	     // Outputs
         // modified for bug 3017
         .tlu_restore_pc_w1 (tlu_restore_pc_w1[48:0]),
         .tlu_restore_npc_w1 (tlu_restore_npc_w1[48:0]),
	     .tlu_partial_trap_pc_w1 (tlu_partial_trap_pc_w1[33:0]),
	     .tlu_pib_rsr_data_e	(tlu_pib_rsr_data_e[63:0]),
         .tlu_asi_state_e       (tlu_asi_state_e[8-1:0]),
	     .tsa_wdata			    (tsa_wdata[136-1:0]),
	     .tlu_int_pstate_ie		(tlu_int_pstate_ie[3:0]),
	     .local_pstate_ie	    (local_pstate_ie[3:0]),
	     .tlu_ifu_pstate_pef	(tlu_ifu_pstate_pef[3:0]),
	     .tlu_lsu_pstate_cle	(tlu_lsu_pstate_cle[3:0]),
	     .tlu_lsu_pstate_priv	(tlu_lsu_pstate_priv[3:0]),
	     .tlu_int_redmode		(tlu_int_redmode[3:0]),
	     .local_pstate_priv		(local_pstate_priv[4-1:0]),
	     .tlu_pstate_am		(tlu_pstate_am[3:0]),
	     .tlu_sftint_id		(tlu_sftint_id[3:0]),
	     .tlu_tick_incr_din		(tlu_tick_incr_din[61:0]),
	     .tlu_sscan_test_data  (tlu_sscan_test_data[51-1:0]),
         .tlu_dnrtry_global_g  (tlu_dnrtry_global_g[2-1:0]),
         .tlu_hpstate_enb  (tlu_hpstate_enb[4-1:0]),
         .local_hpstate_enb  (local_hpstate_enb[4-1:0]),
         .tcl_hpstate_enb  (tcl_hpstate_enb[4-1:0]),
         .tlu_hpstate_tlz  (tlu_hpstate_tlz[4-1:0]),
         .tlu_hpstate_priv  (tlu_hpstate_priv[4-1:0]),
         .local_hpstate_priv  (local_hpstate_priv[4-1:0]),
         .tcl_hpstate_priv  (tcl_hpstate_priv[4-1:0]),
         .tlu_hpstate_ibe  (tlu_hpstate_ibe[4-1:0]),
         .tlu_hintp        (tlu_hintp),
	     // Inputs
         .tlu_ibrkpt_trap_w2 (tlu_ibrkpt_trap_w2),
         .pib_picl_wrap      (pib_picl_wrap[4-1:0]),
         .pib_pich_wrap      (pib_pich_wrap[4-1:0]),
         .tlu_por_rstint_g  (tlu_por_rstint_g[4-1:0]),
	     .rclk			    (rclk),
	     .tlu_rst			(tlu_rst),
         .tlu_trap_hpstate_enb  (tlu_trap_hpstate_enb),
	     .tlu_thrd_wsel_w2		(tlu_thrd_wsel_w2[4-1:0]),
	     .tlu_final_ttype_w2		(tlu_final_ttype_w2[9-1:0]),
	     .tlu_pstate_din_sel0	(tlu_pstate_din_sel0[1:0]),
	     .tlu_pstate_din_sel1	(tlu_pstate_din_sel1[1:0]),
	     .tlu_pstate_din_sel2	(tlu_pstate_din_sel2[1:0]),
	     .tlu_pstate_din_sel3	(tlu_pstate_din_sel3[1:0]),
	     .tlu_wr_tsa_inst_w2		(tlu_wr_tsa_inst_w2),
	     .lsu_asi_reg0		(lsu_asi_reg0[7:0]),
	     .lsu_asi_reg1		(lsu_asi_reg1[7:0]),
	     .lsu_asi_reg2		(lsu_asi_reg2[7:0]),
	     .lsu_asi_reg3		(lsu_asi_reg3[7:0]),
	     .tlu_tickcmp_sel		(tlu_tickcmp_sel[4-1:0]),
	     .exu_tlu_ccr0_w		(exu_tlu_ccr0_w[7:0]),
	     .exu_tlu_ccr1_w		(exu_tlu_ccr1_w[7:0]),
	     .exu_tlu_ccr2_w		(exu_tlu_ccr2_w[7:0]),
	     .exu_tlu_ccr3_w		(exu_tlu_ccr3_w[7:0]),
	     .exu_tlu_cwp0		(exu_tlu_cwp0[2:0]),
	     .exu_tlu_cwp1		(exu_tlu_cwp1[2:0]),
	     .exu_tlu_cwp2		(exu_tlu_cwp2[2:0]),
	     .exu_tlu_cwp3		(exu_tlu_cwp3[2:0]),
         .tlu_trap_cwp_en   (tlu_trap_cwp_en[4-1:0]),
         // modified for bug 3017
	     // .ifu_tlu_pc_m		(ifu_tlu_pc_m[48:0]),
	     // .ifu_tlu_npc_m		(ifu_tlu_npc_m[48:0]),
         .tlu_pc_new_w          (tlu_pc_new_w[48:0]),
         .tlu_npc_new_w         (tlu_npc_new_w[48:0]),
	     .tlu_sftint_en_l_g		(tlu_sftint_en_l_g[4-1:0]),
	     .tlu_sftint_mx_sel		(tlu_sftint_mx_sel[4-1:0]),
	     .tlu_set_sftint_l_g	(tlu_set_sftint_l_g),
	     .tlu_clr_sftint_l_g	(tlu_clr_sftint_l_g),
	     .tlu_wr_sftint_l_g		(tlu_wr_sftint_l_g),
	     .tlu_sftint_penc_sel	(tlu_sftint_penc_sel[3:0]),
	     .tlu_tba_en_l		(tlu_tba_en_l[3:0]),
	     .tlu_tick_en_l		(tlu_tick_en_l),
	     .tlu_tickcmp_en_l		(tlu_tickcmp_en_l[3:0]),
	     // .tlu_done_inst_m		(tlu_done_inst_m),
	     // .tlu_dnrtry_inst_m		(tlu_dnrtry_inst_m),
	     // .tlu_dnrtry_inst_m_l		(tlu_dnrtry_inst_m_l),
	     .tlu_update_pc_l_w		(tlu_update_pc_l_w[3:0]),
	     .tlu_tl_gt_0_w2		(tlu_tl_gt_0_w2),
	     .tlu_select_tba_w2		(tdp_select_tba_w2),
	     .tlu_select_redmode	(tlu_select_redmode),
	     .tlu_update_pstate_l_w2	(tlu_update_pstate_l_w2[3:0]),
	     .tlu_pil			(tlu_pil[3:0]),
	     .tlu_trp_lvl		(tlu_trp_lvl[2:0]),
	     .tlu_tick_npt		    (tlu_tick_npt),
	     .tlu_thrd_rsel_e		(tlu_thrd_rsel_e[3:0]),
	     .tlu_tick_incr_dout	(tlu_incr64_dout[60:0]),
	     .tlu_rdpr_mx1_sel		(tlu_rdpr_mx1_sel[2:0]),
	     .tlu_rdpr_mx2_sel		(tlu_rdpr_mx2_sel[2:0]),
	     .tlu_rdpr_mx3_sel		(tlu_rdpr_mx3_sel[1:0]),
	     .tlu_rdpr_mx4_sel		(tlu_rdpr_mx4_sel[1:0]),
	     .tlu_rdpr_mx5_sel		(tlu_rdpr_mx5_sel[2:0]),
	     .tlu_rdpr_mx6_sel		(tlu_rdpr_mx6_sel[2:0]),
	     .tlu_rdpr_mx7_sel		(tlu_rdpr_mx7_sel[3:0]),
	     .ctu_sscan_tid          (ctu_sscan_tid[4-1:0]),
         .tlu_gl_lvl0  (tlu_gl_lvl0[2-1:0]),
         .tlu_gl_lvl1  (tlu_gl_lvl1[2-1:0]),
         .tlu_gl_lvl2  (tlu_gl_lvl2[2-1:0]),
         .tlu_gl_lvl3  (tlu_gl_lvl3[2-1:0]),
         .tlu_hpstate_din_sel0  (tlu_hpstate_din_sel0[1:0]),
         .tlu_hpstate_din_sel1  (tlu_hpstate_din_sel1[1:0]),
         .tlu_hpstate_din_sel2  (tlu_hpstate_din_sel2[1:0]),
         .tlu_hpstate_din_sel3  (tlu_hpstate_din_sel3[1:0]),
         .tlu_htba_en_l  (tlu_htba_en_l[4-1:0]),
         .tlu_htickcmp_en_l  (tlu_htickcmp_en_l[4-1:0]),
         .tlu_htickcmp_intdis  (tlu_htickcmp_intdis),
         .tlu_pc_mxsel_w2 (tlu_pc_mxsel_w2),
         .tlu_set_hintp_sel_g  (tlu_set_hintp_sel_g[4-1:0]),
         .tlu_stickcmp_en_l  (tlu_stickcmp_en_l[4-1:0]),
         .tlu_update_hpstate_l_w2  (tlu_update_hpstate_l_w2[4-1:0]),
         .tlu_wr_hintp_g  (tlu_wr_hintp_g[4-1:0]),
         .tlu_wsr_data_w        (tlu_wsr_data_w[64-1:0]),
	     .se			(se),

         // trin: setting reset vector from jtag
                   // .core_rtap_data          (core_rtap_data),
                   .rtap_core_val         (rtap_core_val),
                   .rtap_core_threadid         (rtap_core_threadid),
                   .rtap_core_id         (rtap_core_id),
                   .rtap_core_data         (rtap_core_data)

           );

// modified for Niagara SRAMs methodology

bw_r_rf32x80 tsa0 (
	     // Outputs
	     .dout 	     (tsa0_dout[80-1:0]),
         .so         (short_scan0_1),
	     // Inputs
	     .wr_adr     ({tsa_wr_tid[1:0],tsa_wr_tpl[2:0]}),
	     .wr_en		 (tsa_wr_vld[0]),
	     .nib_wr_en	 ({{12{tsa_pc_en}},
                      { 8{tsa_tstate_en}}}),
	     .rd_adr	 ({tsa_rd_tid[1:0],tsa_rd_tpl[2:0]}),
	     .rd_en		 (tsa_rd_en),
	     .din		 ({1'b0, tsa_wdata[131:85],
                       3'b0, tsa_wdata[37:9]}),
         .reset_l    (arst_l),
         .rst_tri_en (mem_write_disable),
         .sehold     (sehold),
         .se         (se),
         .si         (short_si0),
         .rclk	     (rclk));

bw_r_rf32x80 tsa1 (
	     // Outputs
	     .dout 	     (tsa1_dout[80-1:0]),
         .so         (short_scan0_2),
	     // Inputs
	     .wr_adr     ({tsa_wr_tid[1:0],tsa_wr_tpl[2:0]}),
	     .wr_en		 (tsa_wr_vld[1]),
	     .nib_wr_en	 ({ 4'h0, // unused
                      { 1{tsa_htstate_en}},
                      {12{tsa_npc_en}},
                      { 3{tsa_ttype_en}}}),
	     .rd_adr	 ({tsa_rd_tid[1:0],tsa_rd_tpl[2:0]}),
	     .rd_en		 (tsa_rd_en),
	     .din		 ({16'h0000, // unused bits
                       tsa_wdata[135:132],
                       1'b0, tsa_wdata[84:38],
                       3'b0, tsa_wdata[8:0]}),
         .reset_l    (arst_l),
         .rst_tri_en (mem_write_disable),
         .sehold     (sehold),
         .se         (se),
         .si         (short_scan0_1),
         .rclk	     (rclk));

// replaced with softmacro from the library
tlu_incr64	tick_incr64 (
                  .out  ({tlu_incr64_dout[61:0], tlu_tckctr_in[1:0]}),
                  .in   ({tlu_tick_incr_din[61:0], tlu_incr_tick[1:0]})
);
/*
zzinc64 tick_incr64 (
                  .out  ({tlu_incr64_dout[61:0], tlu_tckctr_in[1:0]}),
                  .in   ({tlu_tick_incr_din[61:0], tlu_incr_tick[1:0]})
);
*/

tlu_mmu_ctl mmu_ctl (
		                 .so		(so0),
                     .si(scan0_1),
		     .lsu_tlu_st_rs3_data_b12t0_g(lsu_tlu_st_rs3_data_g[12:0]),
		     .lsu_tlu_st_rs3_data_b48_g(lsu_tlu_st_rs3_data_g[48]),
		     //.lsu_tlu_st_rs3_data_b10t8_g(lsu_tlu_st_rs3_data_g[10:8]),
	     	     .tlu_sun4r_tte_g	(tlu_sun4r_tte_g),
		     .ifu_tlu_flush_m	(ifu_tlu_flush_m),
		     .tlu_mmu_early_flush_pipe_w (tlu_exu_early_flush_pipe_w),
		     .lsu_mmu_early_flush_w (lsu_tlu_early_flush_w),
		     .lsu_mmu_flush_pipe_w (lsu_mmu_flush_pipe_w),
		     .dmmu_sfsr_trp_wr	(lsu_dmmu_sfsr_trp_wr[3:0]),
		     .rst_tri_en	(mux_drive_disable),
	     	     .ifu_tlu_priv_violtn_m	(ifu_tlu_priv_violtn_m),
		     // MMU_ASI_RD_CHANGE
		     .lsu_exu_ldxa_m	(lsu_exu_ldxa_m),
	     	     .ifu_lsu_memref_d	(ifu_lsu_memref_d),
		     .ifu_lsu_imm_asi_d	(ifu_lsu_imm_asi_d[8:0]),
		     .ifu_lsu_thrid_s	(ifu_lsu_thrid_s[1:0]),
	     	     .lsu_asi_reg0	(lsu_asi_reg0[7:0]),
	             .lsu_asi_reg1	(lsu_asi_reg1[7:0]),
	             .lsu_asi_reg2	(lsu_asi_reg2[7:0]),
	             .lsu_asi_reg3	(lsu_asi_reg3[7:0]),
		     .tlu_lng_ltncy_en_l(tlu_lng_ltncy_en_l),
		     .tlu_tsb_rd_ps0_sel (tlu_tsb_rd_ps0_sel),
		     .tlu_tsb_base_w2_d1 (tlu_tsb_base_w2_d1[47:13]),
	     	     .tlu_lsu_pstate_am	(tlu_lsu_pstate_am[3:0]),
	     	     .exu_tlu_va_oor_m	(exu_tlu_va_oor_m),
	     	     .exu_tlu_va_oor_jl_ret_m	(exu_tlu_va_oor_jl_ret_m),
	     	     .tlu_lsu_tl_zero	(tlu_lsu_tl_zero[3:0]),
         	     .lsu_mmu_defr_trp_taken_g (lsu_mmu_defr_trp_taken_g),
		     /*AUTOINST*/
		     // Outputs

             
              .tlu_dtlb_csm_rd_g    (tlu_dtlb_csm_rd_g),
              .tlu_itlb_csm_rd_g    (tlu_itlb_csm_rd_g),
              .tlu_itlb_wr_csm_sel_g(tlu_itlb_wr_csm_sel_g),
              .tlu_dtlb_wr_csm_sel_g(tlu_dtlb_wr_csm_sel_g),
             
		     .tlu_tlb_access_en_l_d1 (tlu_tlb_access_en_l_d1),
		     .mra_byte_wen	(mra_byte_wen[19:0]),
	     	     .tlu_tag_access_ctxt_sel_m	(tlu_tag_access_ctxt_sel_m[2:0]),
  		     .tlu_tlb_tag_invrt_parity(tlu_tlb_tag_invrt_parity),
  		     .tlu_tlb_data_invrt_parity(tlu_tlb_data_invrt_parity),
  		     .lsu_ifu_inj_ack	(lsu_ifu_inj_ack[3:0]),
		     .dmmu_any_sfsr_wr	(dmmu_any_sfsr_wr),
		     .dmmu_sfsr_wr_en_l	(dmmu_sfsr_wr_en_l[3:0]),
		     .dmmu_sfar_wr_en_l	(dmmu_sfar_wr_en_l[3:0]),
		     .immu_any_sfsr_wr	(immu_any_sfsr_wr),
		     .immu_sfsr_wr_en_l	(immu_sfsr_wr_en_l[3:0]),
		     .tlu_tte_tag_g	(tlu_tte_tag_g[2:0]),
		     .tlu_dtlb_rw_index_vld_g(tlu_dtlb_rw_index_vld_g),
		     .tlu_dtlb_rw_index_g(tlu_dtlb_rw_index_g[5:0]),
		     .tlu_dtlb_data_rd_g(tlu_dtlb_data_rd_g),
		     .tlu_dtlb_tag_rd_g	(tlu_dtlb_tag_rd_g),
		     .tlu_itlb_rw_index_vld_g(tlu_itlb_rw_index_vld_g),
		     .tlu_itlb_wr_vld_g	(tlu_itlb_wr_vld_g),
		     .itlb_wr_vld_g	(itlb_wr_vld_g),
		     .tlu_itlb_rw_index_g(tlu_itlb_rw_index_g[5:0]),
		     .tlu_itlb_data_rd_g(tlu_itlb_data_rd_g),
		     .tlu_itlb_tag_rd_g	(tlu_itlb_tag_rd_g),
		     .tlu_idtsb_8k_ptr	(tlu_idtsb_8k_ptr[47:0]),
		     .tlu_dtlb_invalidate_all_g(tlu_dtlb_invalidate_all_g),
		     .tlu_itlb_invalidate_all_g(tlu_itlb_invalidate_all_g),
		     .tlu_slxa_thrd_sel	(tlu_slxa_thrd_sel[3:0]),
		     .tlu_lsu_ldxa_tid_w2(tlu_lsu_ldxa_tid_w2[1:0]),
		     .tlu_itlb_dmp_vld_g(tlu_itlb_dmp_vld_g),
		     .tlu_itlb_dmp_all_g(tlu_itlb_dmp_all_g),
		     .tlu_itlb_dmp_actxt_g(tlu_itlb_dmp_actxt_g),
		     .tlu_itlb_dmp_nctxt_g(tlu_itlb_dmp_nctxt_g),
		     .tlu_dtlb_dmp_vld_g(tlu_dtlb_dmp_vld_g),
		     //.tlu_dtlb_dmp_by_ctxt_g(tlu_dtlb_dmp_by_ctxt_g),
		     .tlu_dtlb_dmp_all_g(tlu_dtlb_dmp_all_g),
		     .tlu_dtlb_dmp_pctxt_g(tlu_dtlb_dmp_pctxt_g),
		     .tlu_dtlb_dmp_sctxt_g(tlu_dtlb_dmp_sctxt_g),
		     .tlu_dtlb_dmp_nctxt_g(tlu_dtlb_dmp_nctxt_g),
		     .tlu_dtlb_dmp_actxt_g(tlu_dtlb_dmp_actxt_g),
		     .tlu_idtlb_dmp_thrid_g(tlu_idtlb_dmp_thrid_g[1:0]),
		     .tlu_dmp_key_vld_g	(tlu_dmp_key_vld_g[4:0]),
		     .tlu_int_asi_load	(tlu_int_asi_load),
		     .tlu_int_asi_store	(), // Tri: seems to be not used
           // .tlu_int_asi_store (tlu_int_asi_store),
		     .tlu_int_asi_thrid	(tlu_int_asi_thrid[1:0]),
		     .tlu_int_asi_vld	(tlu_int_asi_vld),
		     .tlb_access_rst_l	(tlb_access_rst_l),
		     .tlu_lsu_stxa_ack	(tlu_lsu_stxa_ack),
		     .tlu_lsu_stxa_ack_tid(tlu_lsu_stxa_ack_tid[1:0]),
		     .mra_wr_ptr	(mra_wr_ptr[3:0]),
		     .mra_rd_ptr	(mra_rd_ptr[3:0]),
		     .mra_wr_vld	(mra_wr_vld),
		     .mra_rd_vld	(mra_rd_vld),
		     .tag_access_wdata_sel(tag_access_wdata_sel[2:0]),
		     .tlu_admp_key_sel	(tlu_admp_key_sel),
		     // .tlu_mmu_sync_data_excp_g(tlu_mmu_sync_data_excp_g),
		     .tlu_tte_wr_pid_g	(tlu_tte_wr_pid_g[2:0]),
		     .tlu_lsu_ldxa_async_data_vld(tlu_lsu_ldxa_async_data_vld),
		     .tlu_tte_real_g	(tlu_tte_real_g),
		     .tlu_ldxa_l1mx1_sel(tlu_ldxa_l1mx1_sel[3:0]),
		     .tlu_ldxa_l1mx2_sel(tlu_ldxa_l1mx2_sel[3:0]),
		     .tlu_ldxa_l2mx1_sel(tlu_ldxa_l2mx1_sel[2:0]),
		     // Inputs
		     .tlu_itag_acc_sel_g (tlu_itag_acc_sel_g),
         	     .sehold     	(sehold),
         	     .spu_tlu_rsrv_illgl_m  (1'b0),
		     .ifu_mmu_trap_m	(ifu_mmu_trap_m),
		     .ffu_tlu_ill_inst_m(ffu_tlu_ill_inst_m),
	             .ifu_tlu_inst_vld_m (ifu_tlu_inst_vld_m_bf1),
		     .exu_lsu_priority_trap_m(exu_lsu_priority_trap_m),
		     .exu_mmu_early_va_e (exu_mmu_early_va_e[7:0]),
		     .tlu_tag_access_ctxt_g (tlu_tag_access_ctxt_g[12:0]),
  		     .ifu_lsu_error_inj	(ifu_lsu_error_inj[3:0]),
		     .lsu_tlu_nucleus_ctxt_m (lsu_tlu_nucleus_ctxt_m),
		     .lsu_tlu_tte_pg_sz_g (lsu_tlu_tte_pg_sz_g[2:0]),
		     .ifu_lsu_ld_inst_e	(ifu_lsu_ld_inst_e),
		     .ifu_lsu_st_inst_e	(ifu_lsu_st_inst_e),
		     .lsu_tlu_dmmu_miss_g(lsu_tlu_dmmu_miss_g),
		     .tlu_dtsb_split_w2	(tlu_dtsb_split_w2),
		     .tlu_dtsb_size_w2	(tlu_dtsb_size_w2[3:0]),
		     .tlu_dtag_access_w2(tlu_dtag_access_w2[47:13]),
		     .tlu_itsb_split_w2	(tlu_itsb_split_w2),
		     .tlu_itsb_size_w2	(tlu_itsb_size_w2[3:0]),
		     .tlu_ctxt_cfg_w2	(tlu_ctxt_cfg_w2[5:0]),
		     //.tlu_tag_access_nctxt_g(tlu_tag_access_nctxt_g),
		     .lsu_tlu_st_rs3_data_g(lsu_tlu_st_rs3_data_g[62:61]),
		     .ifu_tlu_immu_miss_m(ifu_tlu_immu_miss_m),
		     // .ifu_tlu_thrid_e	(ifu_tlu_thrid_e[1:0]),
		     .ifu_lsu_alt_space_e(ifu_lsu_alt_space_e),
		     .ifu_tlu_alt_space_d(ifu_tlu_alt_space_d),
		     .lsu_tlu_dtlb_done	(lsu_tlu_dtlb_done),
		     .ifu_tlu_itlb_done	(ifu_tlu_itlb_done),
		     .lsu_tlu_tlb_asi_state_m(lsu_tlu_tlb_asi_state_m[7:0]),
		     .lsu_tlu_tlb_ldst_va_m(lsu_tlu_tlb_ldst_va_m[(6 + 4):0]),
		     .lsu_tlu_tlb_ld_inst_m(lsu_tlu_tlb_ld_inst_m),
		     .lsu_tlu_tlb_st_inst_m(lsu_tlu_tlb_st_inst_m),
		     .lsu_tlu_tlb_access_tid_m(lsu_tlu_tlb_access_tid_m[1:0]),
		     .immu_sfsr_trp_wr	(immu_sfsr_trp_wr[3:0]),
		     .lsu_tlu_daccess_excptn_g(lsu_tlu_daccess_excptn_g),
		     .lsu_tlu_daccess_prot_g(lsu_tlu_daccess_prot_g),
		     .lsu_pid_state0	(lsu_pid_state0[2:0]),
		     .lsu_pid_state1	(lsu_pid_state1[2:0]),
		     .lsu_pid_state2	(lsu_pid_state2[2:0]),
		     .lsu_pid_state3	(lsu_pid_state3[2:0]),
		     .rclk		(rclk),
		     .se		(se),
		     .grst_l		(grst_l),
		     .arst_l		(arst_l),

           // Tri: adding dummy signal declaration to get rid of vcs warnings
           .immu_tsb_rd_en(), // unused output,
           .tlu_itlb_dmp_pctxt_g()
           );
/*
tlu_mmu_dp AUTO_TEMPLATE ();
*/


tlu_mmu_dp mmu_dp (
           .so (short_scan0_3),
           .si (short_scan0_2),
		   .ifu_tlu_pc_m	(ifu_tlu_pc_m[47:13]),
		   .lsu_exu_ldxa_data_g	(lsu_exu_ldxa_data_g[63:0]),
		   .tlu_dsfsr_din_g	(lsu_dsfsr_din_g[23:0]),
		   // MMU_ASI_RD_CHANGE
		   .tlu_lng_ltncy_en_l(tlu_lng_ltncy_en_l),
		   .tlu_tsb_rd_ps0_sel (tlu_tsb_rd_ps0_sel),
		   .tlu_tsb_base_w2_d1 (tlu_tsb_base_w2_d1[47:13]),
		   /*AUTOINST*/
		   // Outputs

            
            .tlu_dtlb_tte_csm_w2    (tlu_dtlb_tte_csm_w2),
            .tlu_itlb_tte_csm_w2    (tlu_itlb_tte_csm_w2),
            
		   .tlu_tag_access_ctxt_g (tlu_tag_access_ctxt_g[12:0]),
		   .tlu_ctxt_cfg_w2	(tlu_ctxt_cfg_w2[5:0]),
		   .tlu_dtsb_split_w2	(tlu_dtsb_split_w2),
		   .tlu_dtsb_size_w2	(tlu_dtsb_size_w2[3:0]),
		   .tlu_dtag_access_w2	(tlu_dtag_access_w2[47:13]),
		   .tlu_itsb_split_w2	(tlu_itsb_split_w2),
		   .tlu_itsb_size_w2	(tlu_itsb_size_w2[3:0]),
		   .tlu_itlb_tte_tag_w2	(tlu_itlb_tte_tag_w2[58:0]),
		   .tlu_itlb_tte_data_w2(tlu_itlb_tte_data_w2[42:0]),
		   .tlu_dtlb_tte_tag_w2	(tlu_dtlb_tte_tag_w2[58:0]),
		   .tlu_dtlb_tte_data_w2(tlu_dtlb_tte_data_w2[42:0]),
		   // .tlu_lsu_ldxa_data_w2(tlu_lsu_ldxa_data_w2[63:0]),
		   .tlu_idtlb_dmp_key_g	(tlu_idtlb_dmp_key_g[40:0]),
		   .tlu_dsfsr_flt_vld	(tlu_dsfsr_flt_vld[3:0]),
		   .tlu_isfsr_flt_vld	(tlu_isfsr_flt_vld[3:0]),
		   //.tlu_tag_access_nctxt_g(tlu_tag_access_nctxt_g),
		   .mra_wdata		(mra_wdata[155:0]),
		   // Inputs

            
            .lsu_tlu_st_rs3_data_g  (lsu_tlu_st_rs3_data_g),
            
		   .tlu_tlb_access_en_l_d1 (tlu_tlb_access_en_l_d1),
	           .tlu_sun4r_tte_g	(tlu_sun4r_tte_g),
  		   .tlu_tlb_tag_invrt_parity(tlu_tlb_tag_invrt_parity),
  		   .tlu_tlb_data_invrt_parity(tlu_tlb_data_invrt_parity),
		   .tlu_addr_msk_g	(tlu_addr_msk_g),
		   .dmmu_any_sfsr_wr	(dmmu_any_sfsr_wr),
		   .dmmu_sfsr_wr_en_l	(dmmu_sfsr_wr_en_l[3:0]),
		   .immu_any_sfsr_wr	(immu_any_sfsr_wr),
		   .immu_sfsr_wr_en_l	(immu_sfsr_wr_en_l[3:0]),
		   .lsu_tlu_dside_ctxt_m(lsu_tlu_dside_ctxt_m[12:0]),
		   .lsu_tlu_pctxt_m	(lsu_tlu_pctxt_m[12:0]),
		   .tlu_tag_access_ctxt_sel_m(tlu_tag_access_ctxt_sel_m[2:0]),
		   .lsu_tlu_st_rs3_data_b63t59_g(lsu_tlu_st_rs3_data_g[63:59]),
		   .lsu_tlu_st_rs3_data_b47t0_g(lsu_tlu_st_rs3_data_g[47:0]),
		   .exu_lsu_ldst_va_e	(exu_lsu_ldst_va_e[48-1:0]),
		   .tlu_idtsb_8k_ptr	(tlu_idtsb_8k_ptr[47:0]),
		   .lsu_tlu_tlb_dmp_va_m(lsu_tlu_tlb_dmp_va_m[47:13]),
		   .tlu_slxa_thrd_sel	(tlu_slxa_thrd_sel[3:0]),
		   .tlu_tte_tag_g	(tlu_tte_tag_g[2:0]),
		   .tlu_dmp_key_vld_g	(tlu_dmp_key_vld_g[4:0]),
		   .tlb_access_rst_l	(tlb_access_rst_l),
		   .tag_access_wdata_sel(tag_access_wdata_sel[2:0]),
		   .mra_rdata		(mra_rdata[159:10]),
		   .tlu_admp_key_sel	(tlu_admp_key_sel),
		   .tlu_isfsr_din_g	(tlu_isfsr_din_g[23:0]),
		   .tlu_tte_wr_pid_g	(tlu_tte_wr_pid_g[2:0]),
		   .tlu_tte_real_g	(tlu_tte_real_g),
		   .tlu_ldxa_l1mx1_sel	(tlu_ldxa_l1mx1_sel[3:0]),
		   .tlu_ldxa_l1mx2_sel	(tlu_ldxa_l1mx2_sel[3:0]),
		   .tlu_ldxa_l2mx1_sel	(tlu_ldxa_l2mx1_sel[2:0]),
		   .rclk		(rclk),
		   .arst_l		(arst_l),
		   .grst_l		(grst_l),
            .se (se),
		   .dmmu_sfar_wr_en_l	(dmmu_sfar_wr_en_l[3:0]));
        //   .rst_l		(tlu_rst_l));

tlu_hyperv tlu_hyperv (/*AUTOINST*/
         .so(scan1_3),
         .si(scan1_2),
	     .grst_l	 (grst_l),
	     .arst_l	 (arst_l),
	     .rst_tri_en (mux_drive_disable),
         // output
         // modified for timing
         // .tlu_gl_rw_g (tlu_gl_rw_g),
         .tlu_gl_rw_m (tlu_gl_rw_m),
         .tlu_gl_lvl0 (tlu_gl_lvl0[2-1:0]),
         .tlu_gl_lvl1 (tlu_gl_lvl1[2-1:0]),
         .tlu_gl_lvl2 (tlu_gl_lvl2[2-1:0]),
         .tlu_gl_lvl3 (tlu_gl_lvl3[2-1:0]),
         .tlu_hpstate_din_sel0 (tlu_hpstate_din_sel0[1:0]),
         .tlu_hpstate_din_sel1 (tlu_hpstate_din_sel1[1:0]),
         .tlu_hpstate_din_sel2 (tlu_hpstate_din_sel2[1:0]),
         .tlu_hpstate_din_sel3 (tlu_hpstate_din_sel3[1:0]),
         .tlu_htickcmp_rw_e (tlu_htickcmp_rw_e),
         // .tlu_update_hpstate_l_g (tlu_update_hpstate_l_g[`TLU_THRD_NUM-1:0]),
         .tlu_update_hpstate_l_w2 (tlu_update_hpstate_l_w2[4-1:0]),
         // .tlu_htickcmp_en_l (tlu_htickcmp_en_l[`TLU_THRD_NUM-1:0]),
         .tlu_htickcmp_intdis (tlu_htickcmp_intdis),
         // .tlu_hintp_en_l_g (tlu_hintp_en_l_g[`TLU_THRD_NUM-1:0]),
         .tlu_wr_hintp_g (tlu_wr_hintp_g[4-1:0]),
         // .tlu_set_hintp_g (tlu_set_hintp_g[`TLU_THRD_NUM-1:0]),
         .tlu_set_hintp_sel_g (tlu_set_hintp_sel_g[4-1:0]),
         .tlu_htba_en_l (tlu_htba_en_l[4-1:0]),
         // .tlu_hyper_lite (tlu_hyper_lite[`TLU_THRD_NUM-1:0]),
         .tlu_hscpd_dacc_excpt_m (tlu_hscpd_dacc_excpt_m),
         .tlu_qtail_dacc_excpt_m (tlu_qtail_dacc_excpt_m),
         .tlu_scpd_rd_vld_m (tlu_scpd_rd_vld_m),
         // .tlu_scpd_rd_vld_g (tlu_scpd_rd_vld_g),
         .tlu_scpd_wr_vld_g (tlu_scpd_wr_vld_g),
         .tlu_scpd_rd_addr_m (tlu_scpd_rd_addr_m[5-1:0]),
         .tlu_scpd_wr_addr_g (tlu_scpd_wr_addr_g[5-1:0]),
         .tlu_asi_queue_rdata_g(tlu_asi_queue_rdata_g[8-1:0]),
         .tlu_ld_data_vld_g(tlu_ld_data_vld_g),
         .tlu_asi_queue_rd_vld_g(tlu_asi_queue_rd_vld_g),
		 // .tlu_va_all_zero_g(tlu_va_all_zero_g),
		 .tlu_va_ill_g(tlu_va_ill_g),
         .tlu_htstate_rw_d (tlu_htstate_rw_d),
         .tlu_htstate_rw_g (tlu_htstate_rw_g),
	     // .tlu_htba_mx2_sel (tlu_htba_mx2_sel),
         // .tlu_rdpr_mx5_sel (tlu_rdpr_mx5_sel[3:0]),
         .tlu_hyperv_rdpr_sel (tlu_hyperv_rdpr_sel[4:0]),
         // .tlu_rdpr_mx5_active (tlu_rdpr_mx5_active),
	     .tlu_exu_agp (tlu_exu_agp[2-1:0]),
	     .tlu_exu_agp_swap (tlu_exu_agp_swap),
         .tlu_cpu_mondo_cmp (tlu_cpu_mondo_cmp[4-1:0]),
         .tlu_dev_mondo_cmp (tlu_dev_mondo_cmp[4-1:0]),
         .tlu_resum_err_cmp (tlu_resum_err_cmp[4-1:0]),
	     // .tlu_exu_agp_tid	(tlu_exu_agp_tid[1:0]),
		 .tlu_asi_write_g	(tlu_asi_write_g),
		.inc_ind_asi_wr_inrr(inc_ind_asi_wr_inrr[4-1:0]),
		.inc_ind_asi_wr_indr(inc_ind_asi_wr_indr[4-1:0]),
		.inc_ind_asi_rd_invr(inc_ind_asi_rd_invr[4-1:0]),
		.tlu_local_thrid_g(tlu_local_thrid_g[4-1:0]),
         // input
         .tlu_por_rstint_g (tlu_por_rstint_g[4-1:0]),
         // .tlu_wsr_inst_g (tlu_wsr_inst_g),
         .tlu_wsr_inst_nq_g (tlu_wsr_inst_nq_g),
         // .ifu_tlu_thrid_e (ifu_tlu_thrid_e[1:0]),
         .ifu_tlu_thrid_d (ifu_tlu_thrid_d[1:0]),
         .ifu_tlu_sraddr_d (ifu_tlu_sraddr_d_v2[7-1:0]),
         .tlu_wsr_data_w_global (tlu_wsr_data_w[4-1:0]),
         .tlu_dnrtry_global_g (tlu_dnrtry_global_g[2-1:0]),
         .tlu_dnrtry0_inst_g (tlu_dnrtry0_inst_g),
         .tlu_dnrtry1_inst_g (tlu_dnrtry1_inst_g),
         .tlu_dnrtry2_inst_g (tlu_dnrtry2_inst_g),
         .tlu_dnrtry3_inst_g (tlu_dnrtry3_inst_g),
         // modified due to timing
         // .tlu_thrd0_traps (tlu_thrd0_traps),
         // .tlu_thrd1_traps (tlu_thrd1_traps),
         // .tlu_thrd2_traps (tlu_thrd2_traps),
         // .tlu_thrd3_traps (tlu_thrd3_traps),
         // .tlu_select_tba_g (tlu_select_tba_g),
         .tlu_thrd_traps_w2 (tlu_thrd_traps_w2[4-1:0]),
         .tlu_select_tba_w2 (tlu_select_tba_w2),
         .tlu_tick_ctl_din (tlu_tick_ctl_din),
         // .tlu_htick_match (tlu_htick_match),
         .tlu_tickcmp_sel (tlu_tickcmp_sel[4-1:0]),
         .tlu_pstate_priv (local_pstate_priv[4-1:0]),
         .tlu_hpstate_priv (local_hpstate_priv[4-1:0]),
         .tlu_hpstate_enb (local_hpstate_enb[4-1:0]),
         .ifu_lsu_alt_space_e (ifu_lsu_alt_space_e),
         .ifu_lsu_ld_inst_e (ifu_lsu_ld_inst_e),
         .ifu_lsu_st_inst_e (ifu_lsu_st_inst_e),
         .tlu_asi_state_e (tlu_asi_state_e[8-1:0]),
         // new signal to replace ifu_tlu_flush_w
         // .ifu_tlu_flush_w (ifu_tlu_flush_w),
		 // .tlu_flush_pipe_w (tlu_flush_pipe_w),
		 // .tlu_flush_all_w (tlu_flush_all_w),
         .lsu_tlu_early_flush_w (lsu_tlu_early_flush2_w),
	     .tlu_local_flush_w	(tlu_local_flush_w),
		 .tlu_lsu_int_ldxa_vld_w2(tlu_lsu_int_ldxa_vld_w2),
		 .tlu_asi_data_nf_vld_w2 (tlu_asi_data_nf_vld_w2),
         .ifu_tlu_flush_fd_w      (ifu_tlu_flush_fd_w),
		 .tlu_inst_vld_m  (tlu_inst_vld_nq_m),
         // .exu_lsu_ldst_va_e (exu_lsu_ldst_va_e[`TLU_ASI_VA_WIDTH-1:0]),
         .lsu_tlu_ldst_va_m (lsu_tlu_ldst_va_m[10-1:0]),
         .tlu_asi_queue_data_g (lsu_tlu_rs3_data_g[13:6]),
	     // .tlu_exu_agp_tid	   (tlu_exu_agp_tid[1:0]),
	     // .tlu_agp_tid_g	   (tlu_agp_tid_g[1:0]),
	     .tlu_agp_tid_w2	   (tlu_agp_tid_w2[1:0]),
         .se(se),
         // .tlu_rst_l (tlu_rst_l),
         // .clk (clk));
         .rclk (rclk));

/*
bw_r_rf16x160 AUTO_TEMPLATE (
		.word_wen	(4'b1111),
	        .rd_clk		(rclk),
	        .wr_clk		(rclk),
		.reset_l	(arst_l),
		.din		({mra_wdata[155:0],4'b0000}),
		//.si		(),
		.si_r		(),
		.si_w		(),
		.se		(se),
		.sehold		(sehold),
		//.so		());
		.so_r		(),
		.so_w		());
*/
bw_r_rf16x160 mra (/*AUTOINST*/
		// Outputs
		.dout		({mra_rdata[159:10],dummy_mra_rdata[9:0]}),
		//.so		(),
		.so_r		(short_scan0_4),
		.so_w		(short_scan0_5),
		// Inputs
	        .rd_clk		(rclk),
	        .wr_clk		(rclk),
		.din		({mra_wdata[155:0],4'b0000}),
		.rst_tri_en	(mem_write_disable),
		.word_wen	(4'b1111),
		.byte_wen	(mra_byte_wen[19:0]),
	     	.wr_adr 	(mra_wr_ptr[3:0]),
	     	.rd_adr		(mra_rd_ptr[3:0]),
	     	.wr_en		(mra_wr_vld),
	     	.read_en	(mra_rd_vld),
		.reset_l	(arst_l),
		.sehold		(sehold),
		//.si		(),
		.si_w		(short_scan0_4),
		.si_r		(short_scan0_3),
		.se		(se));


//tlu_mra mra (/*AUTOINST*/
//	     // Outputs
//	     .mra_rdata			(mra_rdata[155:0]),
//	     // Inputs
//	     .mra_wr_ptr		(mra_wr_ptr[3:0]),
//	     .mra_rd_ptr		(mra_rd_ptr[3:0]),
//	     .mra_wr_vld		(mra_wr_vld),
//	     .mra_rd_vld		(mra_rd_vld),
//	     .mra_field1_en		(mra_field1_en),
//	     .mra_field2_en		(mra_field2_en),
//	     .mra_field3_en		(mra_field3_en),
//	     .mra_field4_en		(mra_field4_en),
//	     .mra_wdata			(mra_wdata[155:0]),
//	     .clk			(rclk));

/*
tlu_pib AUTO_TEMPLATE (
		.ifu_tlu_imiss_m	    (ifu_tlu_imiss_m),
		.lsu_tlu_dcache_miss_w2	(lsu_tlu_dcache_miss_w2[3:0]),
		.lsu_tlu_l2_dmiss	    (lsu_tlu_l2_dmiss[3:0]),
		.lsu_tlu_stb_full_w2	(lsu_tlu_stb_full_w2[3:0]));
        .ffu_tlu_fpu_tid        (ffu_tlu_fpu_tid[1:0]),
        .ffu_tlu_fpu_cmplt      (ffu_tlu_fpu_cmplt),
        // .pib_pic_wrap           (pib_pic_wrap[3:0]),
        .pib_picl_wrap           (pib_picl_wrap[`TLU_THRD_NUM-1:0]),
        .pich_wrap_flg           (pich_wrap_flg[`TLU_THRD_NUM-1:0]),
        .pich_onebelow_flg       (pich_onebelow_flg[`TLU_THRD_NUM-1:0]),
        .pich_twobelow_flg       (pich_twobelow_flg[`TLU_THRD_NUM-1:0]),
        .tlu_pic_onebelow_e      (tlu_pic_onebelow_e),
        .tlu_pic_twobelow_e      (tlu_pic_twobelow_e),
        .tlu_pic_wrap_e          (tlu_pic_wrap_e),
        // modified for bug 5436: Niagara 2.0
	    .tlu_pcr_ut	    (tlu_pcr_ut[`TLU_THRD_NUM-1:0]),
	    .tlu_pcr_st	    (tlu_pcr_st[`TLU_THRD_NUM-1:0]),
        //.tlu_pcr_ut_e            (tlu_pcr_ut_e),
        //.tlu_pcr_st_e            (tlu_pcr_st_e),
        // .pich_threebelow_flg     (pich_threebelow_flg[`TLU_THRD_NUM-1:0]),
        // modified for timing fixes
        // .pib_priv_act_trap      (pib_priv_act_trap[3:0]),
        .pib_priv_act_trap_m    (pib_priv_act_trap_m[3:0]),
*/
tlu_pib tlu_pib (/*AUTOINST*/
                 .so (so1),
                 .si (scan1_3),
	             .grst_l	(grst_l),
	             .arst_l	(arst_l),
                 .ifu_tlu_imiss_e       (ifu_tlu_imiss_e),
                 .ifu_tlu_immu_miss_m   (ifu_tlu_immu_miss_m),
                 .tlu_hpstate_enb  (local_hpstate_enb[4-1:0]),
                 .ifu_tlu_l2imiss       (ifu_tlu_l2imiss[4-1:0]),
	             .tlu_thread_inst_vld_g	(tlu_thread_inst_vld_g[4-1:0]),
                 .ifu_tlu_thrid_d       (ifu_tlu_thrid_d[1:0]),
                 .exu_tlu_wsr_data_m    (exu_tlu_wsr_data_m[64-1:0]),
                 .tlu_full_flush_pipe_w2 (tlu_full_flush_pipe_w2),
                 .tlu_tcc_inst_w         (tlu_tcc_inst_w),
                 .ifu_tlu_flush_fd_w      (ifu_tlu_flush_fd3_w),
                 .ifu_tlu_sraddr_d      (ifu_tlu_sraddr_d_v2[7-1:0]),
                 .ifu_tlu_rsr_inst_d    (ifu_tlu_rsr_inst_d),
                 // .ifu_tlu_wsr_inst_d    (ifu_tlu_wsr_inst_d),
                 .lsu_tlu_wsr_inst_e    (lsu_tlu_wsr_inst_e),
	             .tlu_wsr_inst_nq_g		(tlu_wsr_inst_nq_g),
                 .tlu_pib_rsr_data_e    (tlu_pib_rsr_data_e[64-1:0]),
                 .tlu_pstate_priv       (local_pstate_priv[4-1:0]),
	             .tlu_hpstate_priv      (local_hpstate_priv[4-1:0]),
	             .tlu_thread_wsel_g		(tlu_thread_wsel_g[4-1:0]),
                 .ffu_tlu_fpu_tid       (ffu_tlu_fpu_tid[1:0]),
                 .ffu_tlu_fpu_cmplt     (ffu_tlu_fpu_cmplt),
                 .lsu_tlu_dmmu_miss_g   (lsu_tlu_dmmu_miss_g),
                 .lsu_tlu_dcache_miss_w2(lsu_tlu_dcache_miss_w2[4-1:0]),
                 .lsu_tlu_l2_dmiss       (lsu_tlu_l2_dmiss[4-1:0]),
                 .lsu_tlu_stb_full_w2   (lsu_tlu_stb_full_w2[4-1:0]),
                 .tlu_wsr_data_w        (tlu_wsr_data_w[64-1:0]),
                 // modified for timing fixes
        	     // .pib_priv_act_trap     (pib_priv_act_trap[`TLU_THRD_NUM-1:0]),
        	     .pib_priv_act_trap_m   (pib_priv_act_trap_m[4-1:0]),
                 // .pib_pic_wrap        (pib_pic_wrap[`TLU_THRD_NUM-1:0]),
                 .pib_picl_wrap          (pib_picl_wrap[4-1:0]),
                 .pich_wrap_flg          (pich_wrap_flg[4-1:0]),
                 .pich_onebelow_flg      (pich_onebelow_flg[4-1:0]),
                 .pich_twobelow_flg      (pich_twobelow_flg[4-1:0]),
                 .tlu_pic_onebelow_e     (tlu_pic_onebelow_e),
                 .tlu_pic_twobelow_e     (tlu_pic_twobelow_e),
                 // modified for bug 5436: Niagara 2.0
	             .tlu_pcr_ut	    (tlu_pcr_ut[4-1:0]),
	             .tlu_pcr_st	    (tlu_pcr_st[4-1:0]),
                 //.tlu_pcr_ut_e            (tlu_pcr_ut_e),
                 //.tlu_pcr_st_e            (tlu_pcr_st_e),
                 .tlu_pic_wrap_e         (tlu_pic_wrap_e),
                 // .pich_threebelow_flg      (pich_threebelow_flg[`TLU_THRD_NUM-1:0]),
                 // .tlu_que_trap_sel_m  (tlu_que_trap_sel_m[`QUE_TRAP_SEL_WIDTH-1:0]),
                 // .tlu_exu_rsr_data_e  (tlu_exu_rsr_data_e[`TLU_ASR_DATA_WIDTH-1:0]),
//
// reset was removed to abide to the Niagara reset methodology
//               .reset (reset),
                 .se (se),
                 // .tlu_rst_l  			(tlu_rst_l),
                 // .rst_tri_en  			(mux_drive_disable),
                 .rclk					(rclk) );

// modified due to Niagara SRAM methodology
/*
tlu_scpd tlu_scpd (
                 .lsu_tlu_st_rs3_data_g (lsu_tlu_rs3_data_g[`TLU_SCPD_DATA_WIDTH-1:0]),
                 .tlu_scpd_rd_vld_m     (tlu_scpd_rd_vld_m),
                 .tlu_scpd_wr_vld_g     (tlu_scpd_wr_vld_g),
                 .tlu_scpd_rd_addr_m    (tlu_scpd_rd_addr_m[`SCPD_RW_ADDR_WIDTH-1:0]),
                 .tlu_scpd_wr_addr_g    (tlu_scpd_wr_addr_g[`SCPD_RW_ADDR_WIDTH-1:0]),
//
// reset was removed to abide to the Niagara reset methodology
//               .reset (reset),
                 .tlu_rst  				(tlu_rst),
                 .clk					(rclk),
                 .tlu_scpd_asi_rdata_g  (tlu_scpd_asi_rdata_g[`TLU_SCPD_DATA_WIDTH-1:0]));
//
*/
bw_r_rf32x80 tlu_scpd (
                 // output
                 .dout    (tlu_scpd_asi_rdata_g[79:0]),
                 .so      (short_scan0_6),
                 // intput
                 .din     ({{16{1'b0}}, // unused inputs
                            lsu_tlu_rs3_data_g[64-1:0]}),
                 .rd_en   (tlu_scpd_rd_vld_m),
                 .wr_en   (tlu_scpd_wr_vld_g),
                 .rd_adr  (tlu_scpd_rd_addr_m[5-1:0]),
                 .wr_adr  (tlu_scpd_wr_addr_g[5-1:0]),
                 .nib_wr_en (20'hfffff),
                 .reset_l (arst_l),
                 .rst_tri_en (mem_write_disable),
                 .sehold  (sehold),
                 .se      (se),
                 .si      (short_scan0_5),
                 //.clk	  (clk));
                 .rclk	  (rclk));
endmodule
// Local Variables:
// verilog-library-directories:("." "../../../srams/rtl")
// End:
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_addern_32.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    parameterized adder macro
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module	tlu_addern_32 (din, incr, sum);
// synopsys template

parameter ADDER_DATA_WIDTH = 33;
parameter INCR_DATA_WIDTH  =  1;
parameter UPPER_DATA_WIDTH =  ADDER_DATA_WIDTH - INCR_DATA_WIDTH;

input	[ADDER_DATA_WIDTH-1:0]	din;
input	[INCR_DATA_WIDTH-1:0]   incr;
output	[ADDER_DATA_WIDTH-1:0]	sum;
//
////////////////////////////////////////////////////////////////////////
// local signal declaraiont
////////////////////////////////////////////////////////////////////////

assign	sum[ADDER_DATA_WIDTH-1:0] =
            din[ADDER_DATA_WIDTH-1:0] + {{UPPER_DATA_WIDTH{1'b0}},incr[INCR_DATA_WIDTH-1:0]};

endmodule // tlu_addern_32
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_hyperv.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Block that contain most of the Hypervisor support
//                      additions 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module	tlu_hyperv (/*AUTOARG*/
    // outputs
    tlu_htickcmp_rw_e, tlu_gl_rw_m, tlu_hpstate_din_sel0, tlu_hpstate_din_sel1,
    tlu_hpstate_din_sel2, tlu_hpstate_din_sel3, tlu_update_hpstate_l_w2,
    tlu_htickcmp_intdis, tlu_gl_lvl0, tlu_gl_lvl1, tlu_gl_lvl2, tlu_gl_lvl3, 
    tlu_htstate_rw_d, tlu_wr_hintp_g, tlu_htstate_rw_g, tlu_set_hintp_sel_g, 
    tlu_htba_en_l, tlu_scpd_wr_addr_g, tlu_scpd_wr_vld_g, tlu_scpd_rd_vld_m, 
    tlu_scpd_rd_addr_m, tlu_hscpd_dacc_excpt_m, tlu_hyperv_rdpr_sel, 
    tlu_exu_agp_swap, tlu_exu_agp, tlu_cpu_mondo_cmp, tlu_dev_mondo_cmp, 
    tlu_resum_err_cmp, tlu_asi_queue_rd_vld_g, tlu_asi_queue_data_g, tlu_ld_data_vld_g, 
    tlu_va_ill_g, tlu_asi_queue_rdata_g, tlu_qtail_dacc_excpt_m, tlu_asi_write_g, so, 
    inc_ind_asi_wr_indr, inc_ind_asi_wr_inrr, inc_ind_asi_rd_invr, tlu_local_thrid_g, 
    // inputs
    ifu_tlu_thrid_d, ifu_tlu_sraddr_d, tlu_wsr_data_w_global, tlu_tickcmp_sel, 
    tlu_thrd_traps_w2, tlu_wsr_inst_nq_g, tlu_dnrtry0_inst_g, tlu_dnrtry1_inst_g, 
    tlu_dnrtry2_inst_g, tlu_dnrtry3_inst_g, tlu_dnrtry_global_g, tlu_tick_ctl_din, 
    tlu_pstate_priv, tlu_select_tba_w2, tlu_hpstate_priv, tlu_hpstate_enb, 
    tlu_asi_state_e, ifu_lsu_alt_space_e, ifu_lsu_ld_inst_e, ifu_lsu_st_inst_e, 
    lsu_tlu_early_flush_w, tlu_por_rstint_g, tlu_agp_tid_w2, // exu_lsu_ldst_va_e, 
    tlu_local_flush_w, ifu_tlu_flush_fd_w, tlu_inst_vld_m, tlu_lsu_int_ldxa_vld_w2,
    tlu_asi_data_nf_vld_w2, lsu_tlu_ldst_va_m, arst_l, grst_l, rst_tri_en, 
    si, se, rclk);

//=================================================
// output
//=================================================
// mux select to tdp to access the hyper-privileged ASR registers
output tlu_htickcmp_rw_e;
output tlu_gl_rw_m;
// output tlu_gl_rw_g;

// global switch indicator - used to be in tlu_tcl
output [1:0] tlu_exu_agp; 
// output [1:0] tlu_exu_agp_tid;  
output tlu_exu_agp_swap; 
//
// global register outputs
output [2-1:0] tlu_gl_lvl0; // global register value t0 
output [2-1:0] tlu_gl_lvl1; // global register value t1 
output [2-1:0] tlu_gl_lvl2; // global register value t2 
output [2-1:0] tlu_gl_lvl3; // global register value t3 

// mux selects to choose source of data to store in the hpstate regs 
output [1:0] tlu_hpstate_din_sel0;
output [1:0] tlu_hpstate_din_sel1;
output [1:0] tlu_hpstate_din_sel2;
output [1:0] tlu_hpstate_din_sel3;
//
// mux selects to read out the ASR registers
// output [3:0] tlu_rdpr_mx5_sel; 
output [4:0] tlu_hyperv_rdpr_sel; 
// signal indicating mx5 is used
// output       tlu_rdpr_mx5_active; 
//
// hpstate write enable
// modified for timing
// output [`TLU_THRD_NUM-1:0] tlu_update_hpstate_l_g;
output [4-1:0] tlu_update_hpstate_l_w2;
//
// htick compare reg write enable 
// output [`TLU_THRD_NUM-1:0] htickcmp_intdis_en;
// htick compare interrupt disable
output tlu_htickcmp_intdis;

//  clock enable for hintp regs.
// output [`TLU_THRD_NUM-1:0] tlu_hintp_en_l_g;
// wr control for hintp regs.
output [4-1:0] tlu_wr_hintp_g;         
// set control for hintp regs.
// output [`TLU_THRD_NUM-1:0] tlu_set_hintp_g;
output [4-1:0] tlu_set_hintp_sel_g;
//
// update enable for the htba registers 
output [4-1:0] tlu_htba_en_l;
// 
// hypervisor lite indicator
// output [`TLU_THRD_NUM-1:0] tlu_hyper_lite;
// 
// hyper-privileged scratch-pad data access exception 
output tlu_hscpd_dacc_excpt_m;
//
// store instruction to alt space
output tlu_asi_write_g;
output [4-1:0] inc_ind_asi_wr_indr;
output [4-1:0] inc_ind_asi_wr_inrr;
output [4-1:0] inc_ind_asi_rd_invr;
output [4-1:0] tlu_local_thrid_g;

// read and write valids for the scratch-pad 
output tlu_scpd_rd_vld_m, tlu_scpd_wr_vld_g;
output [5-1:0] tlu_scpd_wr_addr_g;
output [5-1:0] tlu_scpd_rd_addr_m;
//
// decode of the htstate register write/read
output tlu_htstate_rw_d; 
output tlu_htstate_rw_g; 
// 
// select for rdpr read in tlu_tdp
// output tlu_htba_rsr_sel; 
// 
// 
output [4-1:0] tlu_cpu_mondo_cmp; 
output [4-1:0] tlu_dev_mondo_cmp; 
output [4-1:0] tlu_resum_err_cmp; 
output tlu_qtail_dacc_excpt_m; 
//
// asi queue rdata output
output [8-1:0] tlu_asi_queue_rdata_g;
output tlu_asi_queue_rd_vld_g;
output tlu_ld_data_vld_g;
// output tlu_scpd_rd_vld_g;
output tlu_va_ill_g;
// output tlu_va_all_zero_g;
output tlu_lsu_int_ldxa_vld_w2;
//
// global nets
output so;

//=================================================
// input
//=================================================
// non-thread specific por reset indicator
// modified for timing
// input [1:0] ifu_tlu_thrid_e; 
input [1:0] ifu_tlu_thrid_d; 
// 
// staged write asr instruction
// modified for timing 
// input tlu_wsr_inst_g;
input tlu_wsr_inst_nq_g;

// non-threaded por instruciton 
input [4-1:0] tlu_por_rstint_g;
// 
// addr of sr(st/pr)
input [7-1:0] ifu_tlu_sraddr_d;      
//
// staged pr/st data from irf.
input [4-1:0] tlu_wsr_data_w_global; 

// restored global value for done/retry instructions 
input [2-1:0] tlu_dnrtry_global_g;

// thread specific done and retry signals
input tlu_dnrtry0_inst_g, tlu_dnrtry1_inst_g;
input tlu_dnrtry2_inst_g, tlu_dnrtry3_inst_g;
// 
// thread specific trap assetion signals
// modified due to timing
// input tlu_thrd0_traps, tlu_thrd1_traps;
// input tlu_thrd2_traps, tlu_thrd3_traps;
input [4-1:0] tlu_thrd_traps_w2; 
// 
// indicating whether the trap is supervisor or hypervisor 
// added for bug 2889
// modified due to timing
// input tlu_select_tba_g; 
input tlu_select_tba_w2; 
//
input tlu_tick_ctl_din;
// htick compare match
// input tlu_htick_match;	
//
// select src for tickcmp 
input [4-1:0] tlu_tickcmp_sel;   
// 
// pstate - supervisor privilege  
input [4-1:0] tlu_pstate_priv;   
// hpstate - hypervisor privilege  
input [4-1:0] tlu_hpstate_priv;   
// hpstate - hypervisor lite enb  
input [4-1:0] tlu_hpstate_enb;   
// thread id for the agp that needs swap
// modified for timing
// input [1:0] tlu_agp_tid_g;
input [1:0] tlu_agp_tid_w2;
// ASI addresses and valid bits for decode to 
// access the ASI registers
input 	    ifu_lsu_alt_space_e; // valid bit for the ASI data
input 	    ifu_lsu_ld_inst_e;  // read enable
input 	    ifu_lsu_st_inst_e;  // write enable
// replaced due to timing violations
// input 	    tlu_nlsu_flush_w;   // trap flush 
input 	    tlu_local_flush_w;   // trap flush 
input 	    ifu_tlu_flush_fd_w;   // trap flush 
input 	    lsu_tlu_early_flush_w;   // trap flush 
input 	    tlu_asi_data_nf_vld_w2;   // trap flush 
input 	    tlu_inst_vld_m;     // instruciton valid 
//
// asi to be read/written
input [8-1:0] tlu_asi_state_e;  
// input [`TLU_ASI_VA_WIDTH-1:0] exu_lsu_ldst_va_e;  
input [10-1:0] lsu_tlu_ldst_va_m; 
// head and tail pointers
input [8-1:0] tlu_asi_queue_data_g;

//reset
// input tlu_rst_l;  // unit reset
input grst_l ;  // unit reset
input arst_l ;  // unit reset
input rst_tri_en ;  // unit reset
//clk
input rclk;
//
// global nets
input si, se;

/*AUTOOUTPUT*/
//
// staged thread id
wire [1:0] thrid_e, thrid_m, thrid_g;
// decoded thread id
wire [4-1:0] thread_sel_id_e; 
wire [4-1:0] thread_sel_id_m; 
wire [4-1:0] thread_sel_id_g; 
wire [4-1:0] thread_sel_id_w2; 
// 
// flush due to "early traps"
wire 	    local_flush_all_w;   // trap flush 
wire 	    local_flush_all_w2;   // trap flush 
//
// por indicators generations 
wire por_rstint0_g, por_rstint1_g;
wire por_rstint2_g, por_rstint3_g;
//
// GL register definitions - one GL register/thread
wire [2-1:0] gl_lvl0, gl_lvl1, gl_lvl2, gl_lvl3;  
// updated value of the GL registers 
wire [2-1:0] gl_lvl0_new, gl_lvl1_new;  
wire [2-1:0] gl_lvl2_new, gl_lvl3_new;  
wire [2-1:0] gl_lvl0_update_g, gl_lvl1_update_g;  
wire [2-1:0] gl_lvl2_update_g, gl_lvl3_update_g;  
wire [2-1:0] gl_lvl0_update_w2, gl_lvl1_update_w2;  
wire [2-1:0] gl_lvl2_update_w2, gl_lvl3_update_w2;  
wire [2-1:0] wsr_gl_lvl0_data, wsr_gl_lvl1_data;  
wire [2-1:0] wsr_gl_lvl2_data, wsr_gl_lvl3_data;  
wire [2-1:0] dnrtry_gl_lvl0_data, dnrtry_gl_lvl1_data;  
wire [2-1:0] dnrtry_gl_lvl2_data, dnrtry_gl_lvl3_data;  
// value to be incremented for the GL registers
// modified due to timing
// wire gl0_incr_sel, gl1_incr_sel, gl2_incr_sel, gl3_incr_sel; 
// wire[1:0] gl_lvl0_incr, gl_lvl1_incr, gl_lvl2_incr, gl_lvl3_incr; 
// indicators to signal gl is at certain pre-defined values 
// added for timing
wire [4-1:0] gl_incr_sel_w2; 
wire [4-1:0] gl_update_sel_g; 
wire [4-1:0] gl_update_sel_w2; 
wire [4-1:0] gl_priv_max_sel_w2; 
wire gl_lvl0_at_maxgl, gl_lvl1_at_maxgl; 
wire gl_lvl2_at_maxgl, gl_lvl3_at_maxgl;
wire gl_lvl0_at_maxstl, gl_lvl1_at_maxstl;
wire gl_lvl2_at_maxstl, gl_lvl3_at_maxstl;
// gl write enables  
wire gl0_en, gl1_en, gl2_en, gl3_en; 
wire [4-1:0] dnrtry_inst_w2;
// maxgl control
wire [4-1:0] maxstl_gl_dnrtry_sel;
wire [4-1:0] maxstl_gl_wr_sel;
wire [4-1:0] maxgl_gl_wr_sel;
// decoded thread info for agp swap
// wire [`TLU_THRD_NUM-1:0] agp_thrid;
wire [4-1:0] agp_thrid_w2;
// modified for for timing fix
// wire agp_swap; 
// wire [1:0] agp_new; 
wire wsr_inst_g, wsr_inst_w2; 
wire agp_swap_w2, agp_swap_w3; 
wire [1:0] agp_new_w2, agp_new_w3; 
//
// hyper-privileged ASR registers
wire [4-1:0] tlu_wr_hintp_g;         
wire htba_rw_d, hpstate_rw_d, htstate_rw_d, hintp_rw_d; 
wire htickcmp_rw_d, gl_rw_d; 
wire htba_rw_e, hpstate_rw_e, htstate_rw_e, hintp_rw_e; 
wire htickcmp_rw_e, gl_rw_e;
wire htba_rw_m, hpstate_rw_m, htstate_rw_m, hintp_rw_m; 
wire htickcmp_rw_m, gl_rw_m; 
wire htba_rw_g, hpstate_rw_g, htstate_rw_g, hintp_rw_g; 
wire htickcmp_rw_g, gl_rw_g;
wire [4-1:0] htickcmp_intdis_en;
wire hpstate_rw_w2;
//
// hyper-lite mode indicator
wire [4-1:0] tlu_hyper_lite;
// 
// contorls to update the hpstate registers
// wire update_hpstate0_g, update_hpstate1_g;
// wire update_hpstate2_g, update_hpstate3_g;
wire [4-1:0] update_hpstate_g; 
wire [4-1:0] update_hpstate_w2; 
//
// htick interrupt disable control
wire htick_intdis0, htick_intdis1;
wire htick_intdis2, htick_intdis3;
//
// local addr of sr(st/pr) 
wire [7-3:0] sraddr;

// ASI_QUEUE for hyper visor
// thread 0
wire [8-1:0] cpu_mondo0_head;
wire [8-1:0] cpu_mondo0_tail;
wire [8-1:0] dev_mondo0_head;
wire [8-1:0] dev_mondo0_tail;
wire [8-1:0] resum_err0_head;
wire [8-1:0] resum_err0_tail;
wire [8-1:0] nresum_err0_head;
wire [8-1:0] nresum_err0_tail;
// thread 1
wire [8-1:0] cpu_mondo1_head;
wire [8-1:0] cpu_mondo1_tail;
wire [8-1:0] dev_mondo1_head;
wire [8-1:0] dev_mondo1_tail;
wire [8-1:0] resum_err1_head;
wire [8-1:0] resum_err1_tail;
wire [8-1:0] nresum_err1_head;
wire [8-1:0] nresum_err1_tail;
// thread 2
wire [8-1:0] cpu_mondo2_head;
wire [8-1:0] cpu_mondo2_tail;
wire [8-1:0] dev_mondo2_head;
wire [8-1:0] dev_mondo2_tail;
wire [8-1:0] resum_err2_head;
wire [8-1:0] resum_err2_tail;
wire [8-1:0] nresum_err2_head;
wire [8-1:0] nresum_err2_tail;
// thread 3
wire [8-1:0] cpu_mondo3_head;
wire [8-1:0] cpu_mondo3_tail;
wire [8-1:0] dev_mondo3_head;
wire [8-1:0] dev_mondo3_tail;
wire [8-1:0] resum_err3_head;
wire [8-1:0] resum_err3_tail;
wire [8-1:0] nresum_err3_head;
wire [8-1:0] nresum_err3_tail;
//
// read asi data from the asi queues
wire [8-1:0] cpu_mondo_hd_rdata;
wire [8-1:0] cpu_mondo_ta_rdata;
wire [8-1:0] dev_mondo_hd_rdata;
wire [8-1:0] dev_mondo_ta_rdata;
wire [8-1:0] resum_err_hd_rdata;
wire [8-1:0] resum_err_ta_rdata;
wire [8-1:0] nresum_err_hd_rdata;
wire [8-1:0] nresum_err_ta_rdata;
wire [8-1:0] asi_queue_rdata1_g;
wire [8-1:0] asi_queue_rdata2_g;
wire asi_qrdata_mx_sel2;
//
// head and tail comparison results
// modified due to timing violations
// wire cpu_mondo_head_rw_e,  cpu_mondo_tail_rw_e;
// wire dev_mondo_head_rw_e,  dev_mondo_tail_rw_e;
// wire resum_err_head_rw_e,  resum_err_tail_rw_e;
// wire nresum_err_head_rw_e, nresum_err_tail_rw_e;
//
wire cpu_mondo_head_rw_m,  cpu_mondo_tail_rw_m;
wire dev_mondo_head_rw_m,  dev_mondo_tail_rw_m;
wire resum_err_head_rw_m,  resum_err_tail_rw_m;
wire nresum_err_head_rw_m, nresum_err_tail_rw_m;
//
wire cpu_mondo_head_rw_g,  cpu_mondo_tail_rw_g;
wire dev_mondo_head_rw_g,  dev_mondo_tail_rw_g;
wire resum_err_head_rw_g,  resum_err_tail_rw_g;
wire nresum_err_head_rw_g, nresum_err_tail_rw_g;
// creating one-hot selects
// wire cpu_mondo_hd_onehot_g, cpu_mondo_ta_onehot_g;
// wire dev_mondo_hd_onehot_g, dev_mondo_ta_onehot_g;
// wire resum_err_hd_onehot_g, resum_err_ta_onehot_g;
// wire nresum_err_hd_onehot_g, nresum_err_ta_onehot_g;
// read 
wire [4-1:0] cpu_mondo_head_rd_g;
wire cpu_mondo_hd_rd_g;
wire [4-1:0] cpu_mondo_tail_rd_g;
wire cpu_mondo_ta_rd_g;
wire [4-1:0] dev_mondo_head_rd_g;
wire dev_mondo_hd_rd_g;
wire [4-1:0] dev_mondo_tail_rd_g;
wire dev_mondo_ta_rd_g;
wire [4-1:0] resum_err_head_rd_g;
wire resum_err_hd_rd_g;
wire [4-1:0] resum_err_tail_rd_g;
wire resum_err_ta_rd_g;
wire [4-1:0] nresum_err_head_rd_g; 
wire nresum_err_hd_rd_g; 
wire [4-1:0] nresum_err_tail_rd_g;
wire nresum_err_ta_rd_g;
wire [3:0] asi_qrdata_mx1_sel;
wire [3:0] asi_qrdata_mx2_sel;
// write 
wire [4-1:0] cpu_mondo_head_wr_g;
wire [4-1:0] cpu_mondo_tail_wr_g;
wire [4-1:0] dev_mondo_head_wr_g;
wire [4-1:0] dev_mondo_tail_wr_g;
wire [4-1:0] resum_err_head_wr_g;
wire [4-1:0] resum_err_tail_wr_g;
wire [4-1:0] nresum_err_head_wr_g; 
wire [4-1:0] nresum_err_tail_wr_g;
// 
// ASI va address
// modified due to timing fix
// wire [`TLU_ASI_VA_WIDTH-1:0] tlu_ldst_va_e;
wire [10-1:0] tlu_ldst_va_m;
//
// ASI read or write enables
wire asi_queue_write_e;
wire asi_queue_read_e;
wire asi_queue_write_pq_m; 
wire asi_queue_read_pq_m;
wire asi_queue_write_m; 
wire asi_queue_read_m;
wire asi_queue_write_uf_g; 
// wire asi_queue_read_uf_g;
wire asi_queue_write_g; 
wire asi_queue_read_g;
//
// decoded ASI addresses 
// ASI QUE
wire asi_queue_rw_e, asi_queue_rw_m, asi_queue_rw_g;
wire asi_inrr_rw_e, asi_inrr_rw_m, asi_inrr_rw_g; 
wire asi_indr_rw_e, asi_indr_rw_m, asi_indr_rw_g; 
wire asi_invr_rw_e, asi_invr_rw_m, asi_invr_rw_g; 
// supervisor scratch-pad asi state
wire asi_scpd_rw_e, asi_scpd_rw_m; 
// hypervisor scratch-pad asi state
wire asi_hscpd_rw_e, asi_hscpd_rw_m; 
wire asi_scpd_rw_vld_m, asi_scpd_rw_vld_g; 
// legal va addresses
// modified due to timing
// wire que_legal_va_e;
wire que_legal_va_m;
// modified due to timing
// illegal va range indicator
// wire que_ill_va_e, 
wire que_ill_va_m, que_ill_va_g;
// modified due to timing
// wire scpd_ill_va_e, 
wire scpd_ill_va_m, scpd_ill_va_g;
// alignment checking
wire va_not_baligned_m; 
// no longer necessary
// wire va_all_zero_e, va_all_zero_m, va_all_zero_g;
// write operation to queue tails 
wire qtail_write_m;
//
// data_access_exception for hyper-privileged scratch-pad
wire hscpd_data_acc_excpt_m;
wire hscpd_data_acc_excpt_pq_m;
// write to hypervisor scratch-pad using 0x20 ASI state
wire hscpd_priv_asi_acc_m;
// access hypervisor scratchpad va addresses
wire hscpd_va_rw_m; 
//
// relevant portion of the va address for the scratch-pad 
// modified due to timing fix
// wire [`TLU_ASI_SCPD_VA_HI:0]       scpd_addr_va_e;
wire [3-1:0] scpd_addr_va_m;
wire [3-1:0] scpd_addr_va_g;
//
// load instruction data valid
wire asi_ld_addr_vld_m, asi_ld_addr_vld_g;

// privilege or hyper-privileged address indicators
wire asr_hyperp, asr_priv;
//
// local reset
wire local_rst_l; 
wire local_rst; 
// local clk
wire clk; 

////////////////////////////////////////////////////////////////////////
// local reset
////////////////////////////////////////////////////////////////////////

dffrl_async dffrl_local_rst_l(
    .din  (grst_l),
    .clk  (clk),
    .rst_l(arst_l),
    .q    (local_rst_l),
    .se   (se),
    .si   (),
    .so   ()
); 

assign local_rst = ~local_rst_l;

////////////////////////////////////////////////////////////////////////
// local clock
////////////////////////////////////////////////////////////////////////

assign clk = rclk; 

////////////////////////////////////////////////////////////////////////
// Hyper-lite mode indicator
////////////////////////////////////////////////////////////////////////

assign tlu_hyper_lite[0] = 
           tlu_hpstate_priv[0]| (~tlu_hpstate_enb[0] & tlu_pstate_priv[0]); 
assign tlu_hyper_lite[1] = 
           tlu_hpstate_priv[1]| (~tlu_hpstate_enb[1] & tlu_pstate_priv[1]); 
assign tlu_hyper_lite[2] = 
           tlu_hpstate_priv[2]| (~tlu_hpstate_enb[2] & tlu_pstate_priv[2]); 
assign tlu_hyper_lite[3] = 
           tlu_hpstate_priv[3]| (~tlu_hpstate_enb[3] & tlu_pstate_priv[3]); 

////////////////////////////////////////////////////////////////////////
// Thread ID staging and decoding 
////////////////////////////////////////////////////////////////////////
//
assign	thread_sel_id_e[0] = ~thrid_e[1] & ~thrid_e[0];
assign	thread_sel_id_e[1] = ~thrid_e[1] &  thrid_e[0];
assign	thread_sel_id_e[2] =  thrid_e[1] & ~thrid_e[0];
assign	thread_sel_id_e[3] =  thrid_e[1] &  thrid_e[0];

dff_s #(4) dff_thread_sel_id_m (
    .din (thread_sel_id_e[4-1:0]),
    .q   (thread_sel_id_m[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(4) dff_thread_id_sel_g (
    .din (thread_sel_id_m[4-1:0]),
    .q   (thread_sel_id_g[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(4) dff_thread_id_sel_w2 (
    .din (thread_sel_id_g[4-1:0]),
    .q   (thread_sel_id_w2[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_thrid_e (
    .din (ifu_tlu_thrid_d[1:0]),
    .q   (thrid_e[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_thrid_m (
    .din (thrid_e[1:0]),
    .q   (thrid_m[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_thrid_g (
    .din (thrid_m[1:0]),
    .q   (thrid_g[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// modified due to rte failure
assign tlu_local_thrid_g[0] = ~(|thrid_g[1:0]); 
assign tlu_local_thrid_g[1] = ~thrid_g[1] &  thrid_g[0]; 
assign tlu_local_thrid_g[2] =  thrid_g[1] & ~thrid_g[0]; 
assign tlu_local_thrid_g[3] =  (&thrid_g[1:0]); 

/*
assign tlu_local_thrid_g[`TLU_THRD_NUM-1:0] = 
           thread_sel_id_g[`TLU_THRD_NUM-1:0];
*/

////////////////////////////////////////////////////////////////////////
// POR indicator generation 
////////////////////////////////////////////////////////////////////////
//
// modified for bug 1945
/*
assign	por_rstint0_g = tlu_por_rstint_g & thread_sel_id_g[0];
assign	por_rstint1_g = tlu_por_rstint_g & thread_sel_id_g[1];
assign	por_rstint2_g = tlu_por_rstint_g & thread_sel_id_g[2];
assign	por_rstint3_g = tlu_por_rstint_g & thread_sel_id_g[3];
*/
assign	por_rstint0_g = tlu_por_rstint_g[0];
assign	por_rstint1_g = tlu_por_rstint_g[1];
assign	por_rstint2_g = tlu_por_rstint_g[2];
assign	por_rstint3_g = tlu_por_rstint_g[3];

////////////////////////////////////////////////////////////////////////
// Hyper-privileged ASR decodes 
////////////////////////////////////////////////////////////////////////
//
// flush signal - modified for timing
// assign  local_flush_all_w = tlu_nlsu_flush_w | lsu_tlu_early_flush_w;
assign  local_flush_all_w = 
            tlu_local_flush_w | lsu_tlu_early_flush_w | ifu_tlu_flush_fd_w;

dffr_s dffr_local_flush_all_w2 (
    .din (local_flush_all_w),
    .q   (local_flush_all_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

// added for timing
assign tlu_lsu_int_ldxa_vld_w2 = 
           tlu_asi_data_nf_vld_w2 & ~local_flush_all_w2;

assign  asr_hyperp = ifu_tlu_sraddr_d[7-1];
assign  asr_priv   = ifu_tlu_sraddr_d[7-2];

assign	sraddr[7-3:0]	=	
            ifu_tlu_sraddr_d[7-3:0];

// hypervisor tick compare - 0x1f - hyper-priviledged
assign htickcmp_rw_d = sraddr[4] & sraddr[3] & sraddr[2] & sraddr[1] & sraddr[0] &
			           asr_hyperp;
//
// hypervisor processor state - 0x00 - hyper-priviledged
assign hpstate_rw_d = ~sraddr[4] & ~sraddr[3] & ~sraddr[2] & ~sraddr[1] & ~sraddr[0] &
			           asr_hyperp;
// 
// hypervisor trap state - 0x01 - hyper-priviledged
assign htstate_rw_d = ~sraddr[4] & ~sraddr[3] & ~sraddr[2] & ~sraddr[1] & sraddr[0] &
			           asr_hyperp;

assign tlu_htstate_rw_d = htstate_rw_d;
// 
// hypervisor interrupt pending - 0x03 - hyper-priviledged
assign hintp_rw_d = ~sraddr[4] & ~sraddr[3] & ~sraddr[2] & sraddr[1] & sraddr[0] &
			         asr_hyperp;
// 
// hypervisor trap base address - 0x05 - hyper-priviledged
assign htba_rw_d = ~sraddr[4] & ~sraddr[3] & sraddr[2] & ~sraddr[1] & sraddr[0] &
			       asr_hyperp;	

// global register - 0x10 - privileged
assign gl_rw_d = sraddr[4] & ~sraddr[3] & ~sraddr[2] & ~sraddr[1] & ~sraddr[0] &
			     asr_priv;
//
// staging of the ASR decoded controls
// staging from d to e stage
dff_s dff_htba_rw_d_e (
    .din (htba_rw_d),
    .q   (htba_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hpstate_rw_d_e (
    .din (hpstate_rw_d),
    .q   (hpstate_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htstate_rw_d_e (
    .din (htstate_rw_d),
    .q   (htstate_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hintp_rw_e (
    .din (hintp_rw_d),
    .q   (hintp_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htickcmp_rw_d_e (
    .din (htickcmp_rw_d),
    .q   (htickcmp_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_gl_rw_d_e (
    .din (gl_rw_d),
    .q   (gl_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// staging from e to m stage
dff_s dff_htba_rw_m_m (
    .din (htba_rw_e),
    .q   (htba_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hpstate_rw_m_m (
    .din (hpstate_rw_e),
    .q   (hpstate_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htstate_rw_m_m (
    .din (htstate_rw_e),
    .q   (htstate_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hintp_rw_m_m (
    .din (hintp_rw_e),
    .q   (hintp_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htickcmp_rw_m_m (
    .din (htickcmp_rw_e),
    .q   (htickcmp_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_gl_rw_m_m (
    .din (gl_rw_e),
    .q   (gl_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// staging from e to g stage
dff_s dff_gl_rw_m_g (
    .din (gl_rw_m),
    .q   (gl_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hpstate_rw_m_g (
    .din (hpstate_rw_m),
    .q   (hpstate_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htickcmp_rw_m_g (
    .din (htickcmp_rw_m),
    .q   (htickcmp_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htba_rw_m_g (
    .din (htba_rw_m),
    .q   (htba_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_hintp_rw_g (
    .din (hintp_rw_m),
    .q   (hintp_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_htstate_rw_m_g (
    .din (htstate_rw_m),
    .q   (htstate_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// stage to w2
dff_s dff_hpstate_rw_m_w2 (
    .din (hpstate_rw_g),
    .q   (hpstate_rw_w2),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// constructing the mux select to access the 
// hyper-privileged ASR registers
//
assign tlu_htickcmp_rw_e = htickcmp_rw_e;
assign tlu_htstate_rw_g = htstate_rw_g;
// 
// using htba_rw_e as one of the selects for rdpr read in tlu_tdp
// assign tlu_htba_rsr_sel = htba_rw_e;
//
// construciton mux selects for tlu_rdpr_mx5 in tlu_tdp to read out
// the ASR information
//
assign	tlu_hyperv_rdpr_sel[0] = gl_rw_e; 
assign	tlu_hyperv_rdpr_sel[1] = hintp_rw_e; 
assign	tlu_hyperv_rdpr_sel[2] = hpstate_rw_e; 
assign	tlu_hyperv_rdpr_sel[3] = htstate_rw_e; 
assign	tlu_hyperv_rdpr_sel[4] = htba_rw_e; 
// assign  tlu_rdpr_mx5_active = |(tlu_rdpr_mx5_sel[3:0]);
//
// buffer gl_rw_g for agp_tid_sel in tlu_tcl
// modified for timing 
// assign tlu_gl_rw_g = gl_rw_g;
assign tlu_gl_rw_m = gl_rw_m;

////////////////////////////////////////////////////////////////////////
// GL register controls 
////////////////////////////////////////////////////////////////////////

dffr_s #(4)  dffr_gl_update_sel_w2 (
    .din (gl_update_sel_g[4-1:0]), 
    .q   (gl_update_sel_w2[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

dffr_s #(4) dffr_dnrtry_inst_w2 (
    .din ({tlu_dnrtry3_inst_g, tlu_dnrtry2_inst_g,
           tlu_dnrtry1_inst_g,tlu_dnrtry0_inst_g}),
    .q   (dnrtry_inst_w2[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);
//
// added for timing 
assign wsr_inst_g = tlu_wsr_inst_nq_g & ~ifu_tlu_flush_fd_w;

dffr_s dffr_wsr_inst_w2 (
    .din (wsr_inst_g),
    .q   (wsr_inst_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

// THREAD0

assign gl_lvl0_at_maxgl  = (gl_lvl0[2-1:0] == 2'b11);
assign gl_lvl0_at_maxstl = (gl_lvl0[2-1:0] == 2'b10);
// 
// generate the control to prevent writing beyond maxstl or maxgl

assign maxstl_gl_wr_sel[0] = 
           ~tlu_hyper_lite[0] & 
           (tlu_wsr_data_w_global[4-1:0] > {1'b0,3'b010}); 
assign maxstl_gl_wr_sel[1] = 
           ~tlu_hyper_lite[1] & 
           (tlu_wsr_data_w_global[4-1:0] > {1'b0,3'b010}); 
assign maxstl_gl_wr_sel[2] = 
           ~tlu_hyper_lite[2] & 
           (tlu_wsr_data_w_global[4-1:0] > {1'b0,3'b010});
assign maxstl_gl_wr_sel[3] = 
           ~tlu_hyper_lite[3] & 
           (tlu_wsr_data_w_global[4-1:0] > {1'b0,3'b010}); 
//
// added for bug 79252 
assign maxstl_gl_dnrtry_sel[0] = 
           ~tlu_hyper_lite[0] & 
           (&tlu_dnrtry_global_g[2-1:0]);
assign maxstl_gl_dnrtry_sel[1] = 
           ~tlu_hyper_lite[1] & 
           (&tlu_dnrtry_global_g[2-1:0]);
assign maxstl_gl_dnrtry_sel[2] = 
           ~tlu_hyper_lite[2] & 
           (&tlu_dnrtry_global_g[2-1:0]);
assign maxstl_gl_dnrtry_sel[3] = 
           ~tlu_hyper_lite[3] & 
           (&tlu_dnrtry_global_g[2-1:0]); 
//
// added for bug 79252
assign dnrtry_gl_lvl0_data[2-1:0] = 
            (maxstl_gl_dnrtry_sel[0])? 2'b10:
            tlu_dnrtry_global_g[2-1:0];
assign dnrtry_gl_lvl1_data[2-1:0] = 
            (maxstl_gl_dnrtry_sel[1])? 2'b10:
            tlu_dnrtry_global_g[2-1:0];
assign dnrtry_gl_lvl2_data[2-1:0] = 
            (maxstl_gl_dnrtry_sel[2])? 2'b10:
            tlu_dnrtry_global_g[2-1:0];
assign dnrtry_gl_lvl3_data[2-1:0] = 
            (maxstl_gl_dnrtry_sel[3])? 2'b10:
            tlu_dnrtry_global_g[2-1:0];

// 
// maxgl cap
assign maxgl_gl_wr_sel[0] = 
           tlu_hyper_lite[0] & 
           (tlu_wsr_data_w_global[4-1:0] > 4'b0011); 
assign maxgl_gl_wr_sel[1] = 
           tlu_hyper_lite[1] & 
           (tlu_wsr_data_w_global[4-1:0] > 4'b0011); 
assign maxgl_gl_wr_sel[2] = 
           tlu_hyper_lite[2] & 
           (tlu_wsr_data_w_global[4-1:0] > 4'b0011); 
assign maxgl_gl_wr_sel[3] = 
           tlu_hyper_lite[3] & 
           (tlu_wsr_data_w_global[4-1:0] > 4'b0011); 
//
// trap level to be incremented if thread not at MAXGL and not in redmode
// modified for bug 2889
// modified due to timing
/*
assign gl0_incr_sel = 
           tlu_thrd0_traps & (~(gl_lvl0_at_maxgl | tlu_select_tba_g) |  
           (~gl_lvl0_at_maxstl & tlu_select_tba_g));
           
assign gl_lvl0_incr[1:0] = {1'b0, gl0_incr_sel};

assign gl0_en = (gl_rw_g & wsr_inst_g & thread_sel_id_g[0]) | 
			     gl0_incr_sel | local_rst |	por_rstint0_g   | 
                 tlu_dnrtry0_inst_g;  

assign gl_lvl0_new[`TSA_GLOBAL_WIDTH-1:0] = 
	        (gl_rw_g & wsr_inst_g & thread_sel_id_g[0]) ? 
			 wsr_gl_lvl0_data[`TSA_GLOBAL_WIDTH-1:0] : 
	       ((local_rst | por_rstint0_g) ? `MAXGL_GL :
		   ((tlu_dnrtry0_inst_g) ? 
			 tlu_dnrtry_global_g[`TSA_GLOBAL_WIDTH-1:0] :     // done/retry restore
			 gl_lvl0[`TSA_GLOBAL_WIDTH-1:0] + gl_lvl0_incr[1:0])); // trap increments
*/
// modified for bug 79252 
assign wsr_gl_lvl0_data[2-1:0] = 
            (maxstl_gl_wr_sel[0])? 2'b10:
           ((maxgl_gl_wr_sel[0]) ? 2'b11 : 
            tlu_wsr_data_w_global[2-1:0]);
assign gl_lvl0_update_g[2-1:0] = 
	        (gl_rw_g & wsr_inst_g & thread_sel_id_g[0]) ? 
			 wsr_gl_lvl0_data[2-1:0] : 
	       ((local_rst | por_rstint0_g) ? 2'b11 :
			 dnrtry_gl_lvl0_data[2-1:0]);     // done/retry restore
			 // tlu_dnrtry_global_g[`TSA_GLOBAL_WIDTH-1:0]);     // done/retry restore

dffe_s #(2) dffe_gl_lvl0_update_w2 (
     .din (gl_lvl0_update_g[2-1:0]), 
     .q   (gl_lvl0_update_w2[2-1:0]),
     .en  (gl_update_sel_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// modified for bug3468 and bug3505
assign gl_incr_sel_w2[0] = 
            tlu_thrd_traps_w2[0] & ~(gl_lvl0_at_maxgl | 
           (gl_lvl0_at_maxstl & tlu_select_tba_w2));
//            tlu_thrd_traps_w2[0] & (~(gl_lvl0_at_maxgl | tlu_select_tba_w2) |  
assign gl_update_sel_g[0] = 
           (gl_rw_g & wsr_inst_g & thread_sel_id_g[0]) | 
			local_rst |	por_rstint0_g | tlu_dnrtry0_inst_g;  
//
// modified for bug3468
assign gl_priv_max_sel_w2[0] =
           (gl_lvl0_at_maxgl & tlu_select_tba_w2) & tlu_thrd_traps_w2[0];
assign gl0_en = 
           gl_incr_sel_w2[0] | gl_update_sel_w2[0] | gl_priv_max_sel_w2[0]; 
// assign gl0_en = gl_incr_sel_w2[0] | gl_update_sel_w2[0]; 

assign gl_lvl0_new[2-1:0] = 
           (gl_update_sel_w2[0]) ? gl_lvl0_update_w2:
           (~gl_update_sel_w2[0] & gl_priv_max_sel_w2[0]) ? 
            2'b10: 
            gl_lvl0[2-1:0] + 2'b01;

// Reset required as processor will start out at gl=1 after reset.
/****************************
   to fix bug 6028 manually in the gate netlist, the following needs
   to be a mux_flop with recirculating path from q to d0 input. But
   to make it resetable, need to brake this recirculating path and
   insert an AND gate such that local_rst_l is ANDed with the q output.

dffe_s #(`TSA_GLOBAL_WIDTH) dffe_gl0 (
     .din (gl_lvl0_new[`TSA_GLOBAL_WIDTH-1:0]), 
     .q   (gl_lvl0[`TSA_GLOBAL_WIDTH-1:0]),
     .en  (gl0_en), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
******************************/

wire [1:0] gl_lvl0_or_rst, gl_lvl0_or_rst_or_new;

assign gl_lvl0_or_rst[1:0] = gl_lvl0[1:0] & {2{~local_rst}};

assign gl_lvl0_or_rst_or_new[1:0] = (gl0_en&~local_rst) ? gl_lvl0_new[1:0] : gl_lvl0_or_rst[1:0];

dff_s    #(2) dffe_gl0 (
        .din(gl_lvl0_or_rst_or_new[1:0]) ,
        .q(gl_lvl0[1:0]),
        .clk (clk), .se(se), .si(), .so());

/******************************/


assign tlu_gl_lvl0[2-1:0] = gl_lvl0[2-1:0];

 // Use two threads unless this is defined

// THREAD1

assign gl_lvl1_at_maxgl  = (gl_lvl1[2-1:0] == 2'b11);
assign gl_lvl1_at_maxstl = (gl_lvl1[2-1:0] == 2'b10);
//
// trap level to be incremented if thread not at MAXGL and not in redmode
// modified for bug 2889
// modified due to timing
/*
assign gl1_incr_sel =
           tlu_thrd1_traps & (~(gl_lvl1_at_maxgl | tlu_select_tba_g) |
           (~gl_lvl1_at_maxstl & tlu_select_tba_g));

assign gl_lvl1_incr[1:0] = {1'b0, gl1_incr_sel};

assign gl1_en = (gl_rw_g & wsr_inst_g & thread_sel_id_g[1]) |
                 gl1_incr_sel | local_rst | por_rstint1_g   |
                 tlu_dnrtry1_inst_g;

assign gl_lvl1_new[`TSA_GLOBAL_WIDTH-1:0] =
            (gl_rw_g & wsr_inst_g & thread_sel_id_g[1])?
             wsr_gl_lvl1_data[`TSA_GLOBAL_WIDTH-1:0] :
           ((local_rst | por_rstint1_g) ? `MAXGL_GL :
           ((tlu_dnrtry1_inst_g) ?
             dnrtry_gl_lvl1_data[`TSA_GLOBAL_WIDTH-1:0] :     // done/retry restore
             // tlu_dnrtry_global_g[`TSA_GLOBAL_WIDTH-1:0] :     // done/retry restore
             gl_lvl1[`TSA_GLOBAL_WIDTH-1:0] + gl_lvl1_incr[1:0])); // trap increments

*/
assign wsr_gl_lvl1_data[2-1:0] =
            (maxstl_gl_wr_sel[1])? 2'b10:
           ((maxgl_gl_wr_sel[1]) ? 2'b11 :
            tlu_wsr_data_w_global[2-1:0]);
assign gl_lvl1_update_g[2-1:0] =
            (gl_rw_g & wsr_inst_g & thread_sel_id_g[1]) ?
             wsr_gl_lvl1_data[2-1:0] :
           ((local_rst | por_rstint1_g) ? 2'b11 :
             dnrtry_gl_lvl1_data[2-1:0]);     // done/retry restore
             // tlu_dnrtry_global_g[`TSA_GLOBAL_WIDTH-1:0]);     // done/retry restore

dffe_s #(2) dffe_gl_lvl1_update_w2 (
     .din (gl_lvl1_update_g[2-1:0]),
     .q   (gl_lvl1_update_w2[2-1:0]),
     .en  (gl_update_sel_g[1]),
     .clk (clk),
     .se  (se),
     .si  (),
     .so  ()
);

//
// modified for bug3468 and bug3505
assign gl_incr_sel_w2[1] =
            tlu_thrd_traps_w2[1] & ~(gl_lvl1_at_maxgl |
           (gl_lvl1_at_maxstl & tlu_select_tba_w2));
//            tlu_thrd_traps_w2[1] & (~(gl_lvl1_at_maxgl | tlu_select_tba_w2) |
assign gl_update_sel_g[1] =
           (gl_rw_g & wsr_inst_g & thread_sel_id_g[1]) |
            local_rst | por_rstint1_g | tlu_dnrtry1_inst_g;
//
// modified for bug3468
assign gl_priv_max_sel_w2[1] =
           (gl_lvl1_at_maxgl & tlu_select_tba_w2) & tlu_thrd_traps_w2[1];
//
assign gl1_en =
           gl_incr_sel_w2[1] | gl_update_sel_w2[1] | gl_priv_max_sel_w2[1];
// assign gl1_en = gl_incr_sel_w2[1] | gl_update_sel_w2[1];

assign gl_lvl1_new[2-1:0] =
           (gl_update_sel_w2[1]) ? gl_lvl1_update_w2:
           (~gl_update_sel_w2[1] & gl_priv_max_sel_w2[1]) ?
            2'b10:
            gl_lvl1[2-1:0] + 2'b01;

// Reset required as processor will start out at gl=1 after reset.
/****************************
   to fix bug 6028 manually in the gate netlist, the following needs
   to be a mux_flop with recirculating path from q to d0 input. But
   to make it resetable, need to brake this recirculating path and
   insert an AND gate such that local_rst_l is ANDed with the q output.
dffe_s #(`TSA_GLOBAL_WIDTH) dffe_gl1 (
     .din (gl_lvl1_new[`TSA_GLOBAL_WIDTH-1:0]),
     .q   (gl_lvl1[`TSA_GLOBAL_WIDTH-1:0]),
     .en  (gl1_en),
     .clk (clk),
     .se  (se),
     .si  (),
     .so  ()
);
******************************/

wire [1:0] gl_lvl1_or_rst, gl_lvl1_or_rst_or_new;

assign gl_lvl1_or_rst[1:0] = gl_lvl1[1:0] & {2{~local_rst}};

assign gl_lvl1_or_rst_or_new[1:0] = (gl1_en&~local_rst) ? gl_lvl1_new[1:0] : gl_lvl1_or_rst[1:0];

dff_s    #(2) dffe_gl1 (
        .din(gl_lvl1_or_rst_or_new[1:0]) ,
        .q(gl_lvl1[1:0]),
        .clk (clk), .se(se), .si(), .so());

/******************************/


assign tlu_gl_lvl1[2-1:0] = gl_lvl1[2-1:0];







































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS
   
////////////////////////////////////////////////////////////////////////
// Global swap 
////////////////////////////////////////////////////////////////////////
// modified due to timing
/*
assign agp_thrid[0] = ~tlu_agp_tid_g[0] & ~tlu_agp_tid_g[1] & gl0_en; 
assign agp_thrid[1] =  tlu_agp_tid_g[0] & ~tlu_agp_tid_g[1] & gl1_en; 
assign agp_thrid[2] = ~tlu_agp_tid_g[0] &  tlu_agp_tid_g[1] & gl2_en; 
assign agp_thrid[3] =  tlu_agp_tid_g[0] &  tlu_agp_tid_g[1] & gl3_en; 

assign agp_swap = 
           (agp_thrid[0])? 
               |(gl_lvl0_new[1:0] ^ gl_lvl0[1:0]): 
               ((agp_thrid[1])? 
                     |(gl_lvl1_new[1:0] ^ gl_lvl1[1:0]): 
                     ((agp_thrid[2])? 
                         |(gl_lvl2_new[1:0] ^ gl_lvl2[1:0]): 
                         ((agp_thrid[3])? 
                            |(gl_lvl3_new[1:0] ^ gl_lvl3[1:0]):1'b0)));

assign agp_new[1:0] = 
           (agp_thrid[1])? gl_lvl1_new[1:0] :
               ((agp_thrid[2])? gl_lvl2_new[1:0] :
                   ((agp_thrid[3])? gl_lvl3_new[1:0] : 
                        gl_lvl0_new[1:0])); 

dffr_s dffr_tlu_exu_agp_swap (
    .din (agp_swap),
    .q   (tlu_exu_agp_swap),
    .clk (clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_tlu_exu_agp (
    .din (agp_new[1:0]),
    .q   (tlu_exu_agp[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_tlu_exu_agp_tid (
    .din (tlu_agp_tid_g[1:0]),
    .q   (tlu_exu_agp_tid[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/

assign agp_thrid_w2[0] = ~tlu_agp_tid_w2[0] & ~tlu_agp_tid_w2[1] & gl0_en; 

 // Use two threads unless this is defined

   assign agp_thrid_w2[1] =  tlu_agp_tid_w2[0] & ~tlu_agp_tid_w2[1] & gl1_en;
   assign agp_thrid_w2[2] =  1'b0;
   assign agp_thrid_w2[3] =  1'b0;
   assign agp_swap_w2 =
           (agp_thrid_w2[0])?
               |(gl_lvl0_new[1:0] ^ gl_lvl0[1:0]):
               ((agp_thrid_w2[1])?
                     |(gl_lvl1_new[1:0] ^ gl_lvl1[1:0]): 1'b0);
   dffr_s dffr_agp_swap_w3 (
    .din (agp_swap_w2),
    .q   (agp_swap_w3),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

   assign agp_new_w2[1:0] =
           (agp_thrid_w2[1])? gl_lvl1_new[1:0] :
                        gl_lvl0_new[1:0];






























































































































 // `ifndef CONFIG_NUM_THREADS

//
// added for timing fixes
dff_s #(2) dff_agp_new_w3 (
    .din (agp_new_w2[1:0]),
    .q   (agp_new_w3[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
assign tlu_exu_agp_swap = agp_swap_w3;
assign tlu_exu_agp[1:0] = agp_new_w3[1:0];

////////////////////////////////////////////////////////////////////////
// HPSTATE register controls 
////////////////////////////////////////////////////////////////////////
//
// added for timing
dffr_s #(4) dffr_update_hpstate_w2 (
    .din (update_hpstate_g[4-1:0]),
    .q   (update_hpstate_w2[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// thread 0
assign tlu_hpstate_din_sel0[0] = dnrtry_inst_w2[0] & ~rst_tri_en; 
assign tlu_hpstate_din_sel0[1] = (hpstate_rw_w2 & wsr_inst_w2) & 
                                 ~rst_tri_en                   & 
                                 ~tlu_hpstate_din_sel0[0]      &  
                                  thread_sel_id_w2[0];
//
// generating write enables to update the hpstate registers
// modified for timing 
/*
assign tlu_hpstate_din_sel0[0] = tlu_dnrtry0_inst_g; 
assign tlu_hpstate_din_sel0[1] = (hpstate_rw_g & wsr_inst_g) & 
                                 ~tlu_hpstate_din_sel0[0]        &  
                                  thread_sel_id_g[0];
assign update_hpstate0_g =  tlu_thrd0_traps | tlu_dnrtry0_inst_g | 
		                  ((hpstate_rw_g & wsr_inst_g) & 
                            thread_sel_id_g[0]);

assign tlu_update_hpstate_l_g[0] = ~(update_hpstate0_g | local_rst);
*/
assign update_hpstate_g[0] =  
           tlu_dnrtry0_inst_g | ((hpstate_rw_g & wsr_inst_g) & 
           thread_sel_id_g[0]);

assign tlu_update_hpstate_l_w2[0] = 
           ~(update_hpstate_w2[0] | local_rst | tlu_thrd_traps_w2[0]);
//
// thread 1
assign tlu_hpstate_din_sel1[0] = dnrtry_inst_w2[1] & ~rst_tri_en;
assign tlu_hpstate_din_sel1[1] = (hpstate_rw_w2 & wsr_inst_w2) & 
                                 ~rst_tri_en                   & 
                                 ~tlu_hpstate_din_sel1[0]      &  
                                  thread_sel_id_w2[1];
//
// generating write enables to update the hpstate registers
// modified for timing 
/*
assign tlu_hpstate_din_sel1[0] = tlu_dnrtry1_inst_g; 
assign tlu_hpstate_din_sel1[1] = (hpstate_rw_g & wsr_inst_g) & 
                                 ~tlu_hpstate_din_sel1[0]        &  
                                  thread_sel_id_g[1];
assign update_hpstate1_g =  tlu_thrd1_traps | tlu_dnrtry1_inst_g |
		                  ((hpstate_rw_g & wsr_inst_g) & 
                            thread_sel_id_g[1]);

assign tlu_update_hpstate_l_g[1] = ~(update_hpstate1_g | local_rst);
*/
assign update_hpstate_g[1] =  
           tlu_dnrtry1_inst_g | ((hpstate_rw_g & wsr_inst_g) & 
           thread_sel_id_g[1]);

assign tlu_update_hpstate_l_w2[1] = 
           ~(update_hpstate_w2[1] | local_rst | tlu_thrd_traps_w2[1]);
//
// thread 2
assign tlu_hpstate_din_sel2[0] = dnrtry_inst_w2[2] & ~rst_tri_en;
assign tlu_hpstate_din_sel2[1] = (hpstate_rw_w2 & wsr_inst_w2) & 
                                 ~rst_tri_en                   & 
                                 ~tlu_hpstate_din_sel2[0]      &  
                                  thread_sel_id_w2[2];
//
// generating write enables to update the hpstate registers
// modified for timing
/*
assign tlu_hpstate_din_sel2[0] = tlu_dnrtry2_inst_g; 
assign tlu_hpstate_din_sel2[1] = (hpstate_rw_g & wsr_inst_g) & 
                                 ~tlu_hpstate_din_sel2[0]        &  
                                  thread_sel_id_g[2];
assign update_hpstate2_g =  tlu_thrd2_traps | tlu_dnrtry2_inst_g | 
		                  ((hpstate_rw_g & wsr_inst_g) & 
                            thread_sel_id_g[2]);

assign tlu_update_hpstate_l_g[2] = ~(update_hpstate2_g | local_rst);
*/
assign update_hpstate_g[2] =  
           tlu_dnrtry2_inst_g | ((hpstate_rw_g & wsr_inst_g) & 
           thread_sel_id_g[2]);

assign tlu_update_hpstate_l_w2[2] = 
           ~(update_hpstate_w2[2] | local_rst | tlu_thrd_traps_w2[2]);
//
// thread 3
assign tlu_hpstate_din_sel3[0] = dnrtry_inst_w2[3] & ~rst_tri_en;
assign tlu_hpstate_din_sel3[1] = (hpstate_rw_w2 & wsr_inst_w2) & 
                                 ~tlu_hpstate_din_sel3[0]      &  
                                 ~rst_tri_en                   & 
                                  thread_sel_id_w2[3];
//
// generating write enables to update the hpstate registers
// modified for timing
/*
assign tlu_hpstate_din_sel3[0] = tlu_dnrtry3_inst_g; 
assign tlu_hpstate_din_sel3[1] = (hpstate_rw_g & wsr_inst_g) & 
                                 ~tlu_hpstate_din_sel3[0]        &  
                                  thread_sel_id_g[3];
assign update_hpstate3_g =  tlu_thrd3_traps | tlu_dnrtry3_inst_g | 
		                  ((hpstate_rw_g & wsr_inst_g) & 
                            thread_sel_id_g[3]);

assign tlu_update_hpstate_l_g[3] = ~(update_hpstate3_g | local_rst);
*/
assign update_hpstate_g[3] =  
           tlu_dnrtry3_inst_g | ((hpstate_rw_g & wsr_inst_g) & 
           thread_sel_id_g[3]);

assign tlu_update_hpstate_l_w2[3] = 
           ~(update_hpstate_w2[3] | local_rst | tlu_thrd_traps_w2[3]);

////////////////////////////////////////////////////////////////////////
// HTICKCMP register controls 
////////////////////////////////////////////////////////////////////////
// thread 0
assign htickcmp_intdis_en[0] = 
           (htickcmp_rw_g & wsr_inst_g & thread_sel_id_g[0]) | 
            local_rst | por_rstint0_g;
// 
// HTICK_CMP.INT_DIS
dffe_s dffe_hintdis0  (
     .din (tlu_tick_ctl_din), 
     .q   (htick_intdis0),
     .en  (htickcmp_intdis_en[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),
     .so ()
);

// thread 1
assign htickcmp_intdis_en[1] = 
           (htickcmp_rw_g & wsr_inst_g & thread_sel_id_g[1]) |
			local_rst | por_rstint1_g;
// 
// HTICK_CMP.INT_DIS
dffe_s dffe_hintdis1  (
     .din (tlu_tick_ctl_din), 
     .q   (htick_intdis1),
     .en  (htickcmp_intdis_en[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),
     .so ()
);

// thread 2
assign htickcmp_intdis_en[2] = 
           (htickcmp_rw_g & wsr_inst_g & thread_sel_id_g[2]) |
			local_rst | por_rstint2_g;
// 
// HTICK_CMP.INT_DIS
dffe_s dffe_hintdis2  (
     .din (tlu_tick_ctl_din), 
     .q   (htick_intdis2),
     .en  (htickcmp_intdis_en[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),
     .so ()
);

// thread 3
assign htickcmp_intdis_en[3] = 
           (htickcmp_rw_g & wsr_inst_g & thread_sel_id_g[3]) |
			local_rst | por_rstint3_g;
// HTICK_CMP.INT_DIS
//
dffe_s dffe_hintdis3  (
     .din (tlu_tick_ctl_din), 
     .q   (htick_intdis3),
     .en  (htickcmp_intdis_en[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),
     .so ()
);
//
// generating for the non-thread specific htick_cmp
// interrupt disable
assign tlu_htickcmp_intdis =
	       (thread_sel_id_e[0] & htick_intdis0) | (thread_sel_id_e[1] & htick_intdis1) |
		   (thread_sel_id_e[2] & htick_intdis2) | (thread_sel_id_e[3] & htick_intdis3);

////////////////////////////////////////////////////////////////////////
// HINTP register controls 
////////////////////////////////////////////////////////////////////////
// thread 0 
// 
// modified for timing
// assign tlu_set_hintp_g[0] = 
//            (~htick_intdis0 & tlu_tickcmp_sel[0])? tlu_htick_match: 1'b0;
assign tlu_set_hintp_sel_g[0] = ~htick_intdis0 & tlu_tickcmp_sel[0];
// modified for bug 4886
assign tlu_wr_hintp_g[0] = 
           (hintp_rw_g & wsr_inst_g & thread_sel_id_g[0]) | local_rst; 
//
// modified for timing - moved to tlu_tdp
// assign tlu_hintp_en_l_g[0] = 
// 	      ~(tlu_set_hintp_g[0] | tlu_wr_hintp_g[0]);
//
// thread 1 
//
// modified for timing
// assign tlu_set_hintp_g[1] = 
//            (~htick_intdis1 & tlu_tickcmp_sel[1])? tlu_htick_match: 1'b0;
assign tlu_set_hintp_sel_g[1] = ~htick_intdis1 & tlu_tickcmp_sel[1];
assign tlu_wr_hintp_g[1] = 
           (hintp_rw_g & wsr_inst_g & thread_sel_id_g[1]) | local_rst; 
//
// modified for timing - moved to tlu_tdp
// assign tlu_hintp_en_l_g[1] = 
//	      ~(tlu_set_hintp_g[1] | tlu_wr_hintp_g[1]);
//
// thread 2 
// 
// modified for timing 
// assign tlu_set_hintp_g[2] = 
//            (~htick_intdis2 & tlu_tickcmp_sel[2])? tlu_htick_match: 1'b0;
assign tlu_set_hintp_sel_g[2] = ~htick_intdis2 & tlu_tickcmp_sel[2];
assign tlu_wr_hintp_g[2] = 
           (hintp_rw_g & wsr_inst_g & thread_sel_id_g[2]) | local_rst; 
//
// modified for timing - moved to tlu_tdp
// assign tlu_hintp_en_l_g[2] = 
// 	      ~(tlu_set_hintp_g[2] | tlu_wr_hintp_g[2]);
//
// thread 3 
//
// modified for timing
// assign tlu_set_hintp_g[3] = 
//            (~htick_intdis3 & tlu_tickcmp_sel[3])? tlu_htick_match: 1'b0;
assign tlu_set_hintp_sel_g[3] = ~htick_intdis3 & tlu_tickcmp_sel[3];
assign tlu_wr_hintp_g[3] = 
           (hintp_rw_g & wsr_inst_g & thread_sel_id_g[3]) | local_rst; 
//
// modified for timing - moved to tlu_tdp
// assign tlu_hintp_en_l_g[3] = 
// 	      ~(tlu_set_hintp_g[3] | tlu_wr_hintp_g[3]);

////////////////////////////////////////////////////////////////////////
// HTBA register controls 
////////////////////////////////////////////////////////////////////////

assign tlu_htba_en_l[0]	= ~(htba_rw_g & wsr_inst_g & thread_sel_id_g[0]);
assign tlu_htba_en_l[1]	= ~(htba_rw_g & wsr_inst_g & thread_sel_id_g[1]);
assign tlu_htba_en_l[2]	= ~(htba_rw_g & wsr_inst_g & thread_sel_id_g[2]);
assign tlu_htba_en_l[3]	= ~(htba_rw_g & wsr_inst_g & thread_sel_id_g[3]);

////////////////////////////////////////////////////////////////////////
// ASI QUEUE register controls and data 
////////////////////////////////////////////////////////////////////////
// ASI read or write op
//
assign asi_queue_write_e = ifu_lsu_alt_space_e & ifu_lsu_st_inst_e;
assign asi_queue_read_e  = ifu_lsu_alt_space_e & ifu_lsu_ld_inst_e;
// 
// qualify the asi write and read controls
assign asi_queue_write_m = tlu_inst_vld_m & asi_queue_write_pq_m;
assign asi_queue_read_m  = tlu_inst_vld_m & asi_queue_read_pq_m;
//
// modified due to timing violations
// assign asi_queue_write_g = 
//      ~(tlu_flush_pipe_w | ifu_tlu_flush_w) & asi_queue_write_uf_g;
assign asi_queue_write_g = 
           ~local_flush_all_w & asi_queue_write_uf_g;
assign tlu_asi_write_g = asi_queue_write_g;

// assign asi_queue_read_g  = 
//     ~(tlu_flush_pipe_w | ifu_tlu_flush_w) & asi_queue_read_uf_g;
//
// staging the asi controls
dffr_s #(2) dffr_asi_ctl_m (
    .din ({asi_queue_write_e, asi_queue_read_e}),
    .q   ({asi_queue_write_pq_m, asi_queue_read_pq_m}),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s #(2) dffr_asi_ctl_g (
    .din ({asi_queue_write_m, asi_queue_read_m}),
    .q   ({asi_queue_write_uf_g, asi_queue_read_g}),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// ASI address decode 
// decoding the ASI state 0x25 for the ASI_QUEUES
assign asi_queue_rw_e = 
          (ifu_lsu_alt_space_e)? 
          (tlu_asi_state_e[8-1:0]==8'h25):
           1'b0;
//
// staging the asi controls
dffr_s dffr_asi_queue_rw_m (
    .din (asi_queue_rw_e),
    .q   (asi_queue_rw_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_asi_queue_rw_g (
    .din (asi_queue_rw_m),
    .q   (asi_queue_rw_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// modified due to timing violations
/*
// assign tlu_ldst_va_e[`TLU_ASI_VA_WIDTH-1:0] = 
//          exu_lsu_ldst_va_e[`TLU_ASI_VA_WIDTH-1:0];  
dff_s #(`TLU_ASI_VA_WIDTH) dff_tlu_ldst_va_m (
    .din (exu_lsu_ldst_va_e[`TLU_ASI_VA_WIDTH-1:0]),
    .q   (tlu_ldst_va_m[`TLU_ASI_VA_WIDTH-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// modified for timing
assign que_legal_va_e = 
           cpu_mondo_head_rw_e  | cpu_mondo_tail_rw_e |
           dev_mondo_head_rw_e  | dev_mondo_tail_rw_e |
           resum_err_head_rw_e  | resum_err_tail_rw_e |
           nresum_err_head_rw_e | nresum_err_tail_rw_e; 

assign que_ill_va_e = 
           (ifu_lsu_alt_space_e)?
           (((|exu_lsu_ldst_va_e[`ASI_VA_WIDTH-1:`TLU_ASI_QUE_VA_HI+1]) |
           (|exu_lsu_ldst_va_e[`TLU_ASI_QUE_VA_LO-1:0]) | ~que_legal_va_e) & 
            asi_queue_pq_rw_e): 1'b0; 
*/
assign tlu_ldst_va_m[10-1:0] = 
           lsu_tlu_ldst_va_m[10-1:0];

assign que_legal_va_m = 
           cpu_mondo_head_rw_m  | cpu_mondo_tail_rw_m |
           dev_mondo_head_rw_m  | dev_mondo_tail_rw_m |
           resum_err_head_rw_m  | resum_err_tail_rw_m |
           nresum_err_head_rw_m | nresum_err_tail_rw_m; 

//
// illegal range check for queue va 
assign que_ill_va_m = 
           (asi_queue_rw_m)? ~que_legal_va_m : 1'b0;
//
// staged illegal va range 
//
dffr_s dffr_que_ill_va_g (
    .din (que_ill_va_m),
    .q   (que_ill_va_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// added for timing - interrupt register decodes
// interrupt receiver registers
assign asi_inrr_rw_e = 
          (ifu_lsu_alt_space_e)? 
          (tlu_asi_state_e[8-1:0]==8'h72):
           1'b0;

dffr_s dffr_asi_inrr_rw_m (
    .din (asi_inrr_rw_e),
    .q   (asi_inrr_rw_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_asi_inrr_rw_g (
    .din (asi_inrr_rw_m),
    .q   (asi_inrr_rw_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign inc_ind_asi_wr_inrr[0] = 
           (asi_inrr_rw_g & asi_queue_write_uf_g   & 
           ~local_flush_all_w & thread_sel_id_g[0]);
assign inc_ind_asi_wr_inrr[1] = 
           (asi_inrr_rw_g & asi_queue_write_uf_g   & 
           ~local_flush_all_w & thread_sel_id_g[1]);
assign inc_ind_asi_wr_inrr[2] = 
           (asi_inrr_rw_g & asi_queue_write_uf_g   & 
           ~local_flush_all_w & thread_sel_id_g[2]);
assign inc_ind_asi_wr_inrr[3] = 
           (asi_inrr_rw_g & asi_queue_write_uf_g   & 
           ~local_flush_all_w & thread_sel_id_g[3]);
//
// interrupt dispatch registers
assign asi_indr_rw_e = 
          (ifu_lsu_alt_space_e)? 
          (tlu_asi_state_e[8-1:0]==8'h73):
           1'b0;

dffr_s dffr_asi_indr_rw_m (
    .din (asi_indr_rw_e),
    .q   (asi_indr_rw_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_asi_indr_rw_g (
    .din (asi_indr_rw_m),
    .q   (asi_indr_rw_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign inc_ind_asi_wr_indr[0] = 
           asi_indr_rw_g & ~local_flush_all_w & asi_queue_write_uf_g & 
           thread_sel_id_g[0];
assign inc_ind_asi_wr_indr[1] = 
           asi_indr_rw_g & ~local_flush_all_w & asi_queue_write_uf_g & 
           thread_sel_id_g[1];
assign inc_ind_asi_wr_indr[2] = 
           asi_indr_rw_g & ~local_flush_all_w & asi_queue_write_uf_g & 
           thread_sel_id_g[2];
assign inc_ind_asi_wr_indr[3] = 
           asi_indr_rw_g & ~local_flush_all_w & asi_queue_write_uf_g & 
           thread_sel_id_g[3];

//
// interrupt vector registers
assign asi_invr_rw_e = 
          (ifu_lsu_alt_space_e)? 
          (tlu_asi_state_e[8-1:0]==8'h74):
           1'b0;

dffr_s dffr_asi_invr_rw_m (
    .din (asi_invr_rw_e),
    .q   (asi_invr_rw_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_asi_invr_rw_g (
    .din (asi_invr_rw_m),
    .q   (asi_invr_rw_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign inc_ind_asi_rd_invr[0] = 
           (asi_invr_rw_g & asi_queue_read_g & 
           ~local_flush_all_w & thread_sel_id_g[0]);
assign inc_ind_asi_rd_invr[1] = 
           (asi_invr_rw_g & asi_queue_read_g & 
           ~local_flush_all_w & thread_sel_id_g[1]);
assign inc_ind_asi_rd_invr[2] = 
           (asi_invr_rw_g & asi_queue_read_g & 
           ~local_flush_all_w & thread_sel_id_g[2]);
assign inc_ind_asi_rd_invr[3] = 
           (asi_invr_rw_g & asi_queue_read_g & 
           ~local_flush_all_w & thread_sel_id_g[3]);
//
// timing changes: all va e stage signals have been moved to m-stage
// decoding the VA portion of the ASI address
// cpu_mondo_head: 0x3c0
assign cpu_mondo_head_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3c0);
//
// cpu_mondo_tail: 0x3c8
assign cpu_mondo_tail_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3c8);
//
// dev_mondo_head: 0x3d0
assign dev_mondo_head_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3d0);
//
// dev_mondo_tail: 0x3d8
assign dev_mondo_tail_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3d8);
//
// resum_err_head: 0x3e0
assign resum_err_head_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3e0);
//
// resum_err_tail: 0x3e8
assign resum_err_tail_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3e8);
//
// nresum_err_head: 0x3f0
assign nresum_err_head_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3f0);
//
// nresum_err_tail: 0x3f8
assign nresum_err_tail_rw_m = 
          (tlu_ldst_va_m[10-1:0]==10'h3f8);
//
// timing change: replaced by flopped tlu_ldst_va_m decodes
// staging the ASI queue rw decodes
// cpu_mondo_head
/*
dff_s dff_cpu_mondo_head_rw_m (
     .din (cpu_mondo_head_rw_e), 
     .q   (cpu_mondo_head_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_dev_mondo_head_rw_m (
     .din (dev_mondo_head_rw_e), 
     .q   (dev_mondo_head_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_resum_err_head_rw_m (
     .din (resum_err_head_rw_e), 
     .q   (resum_err_head_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_nresum_err_head_rw_m (
     .din (nresum_err_head_rw_e), 
     .q   (nresum_err_head_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_cpu_mondo_tail_rw_m (
     .din (cpu_mondo_tail_rw_e), 
     .q   (cpu_mondo_tail_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_dev_mondo_tail_rw_m (
     .din (dev_mondo_tail_rw_e), 
     .q   (dev_mondo_tail_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_resum_err_tail_rw_m (
     .din (resum_err_tail_rw_e), 
     .q   (resum_err_tail_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dff_s dff_nresum_err_tail_rw_m (
     .din (nresum_err_tail_rw_e), 
     .q   (nresum_err_tail_rw_m),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// illegal range check
dffr_s dffr_que_ill_va_m (
    .din (que_ill_va_e),
    .q   (que_ill_va_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/

// staging the ASI queue rw decodes
// cpu_mondo_head
dff_s dff_cpu_mondo_head_rw_g (
     .din (cpu_mondo_head_rw_m), 
     .q   (cpu_mondo_head_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// dev_mondo_head
dff_s dff_dev_mondo_head_rw_g (
     .din (dev_mondo_head_rw_m), 
     .q   (dev_mondo_head_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// resum_err_head
dff_s dff_resum_err_head_rw_g (
     .din (resum_err_head_rw_m), 
     .q   (resum_err_head_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// nresum_err_head
dff_s dff_nresum_err_head_rw_g (
     .din (nresum_err_head_rw_m), 
     .q   (nresum_err_head_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
// 
// cpu_mondo_tail
//
dff_s dff_cpu_mondo_tail_rw_g (
     .din (cpu_mondo_tail_rw_m), 
     .q   (cpu_mondo_tail_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// dev_mondo_tail
//
dff_s dff_dev_mondo_tail_rw_g (
     .din (dev_mondo_tail_rw_m), 
     .q   (dev_mondo_tail_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// resum_err_tail
//
dff_s dff_resum_err_tail_rw_g (
     .din (resum_err_tail_rw_m), 
     .q   (resum_err_tail_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// nresum_err_tail
//
dff_s dff_nresum_err_tail_rw_g (
     .din (nresum_err_tail_rw_m), 
     .q   (nresum_err_tail_rw_g),
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
// 
// generating thread specific read and write enables  
//
// cpu_mondo_head read
// assign cpu_mondo_head_rd_g[0] = 
//            asi_queue_read_g & cpu_mondo_head_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign cpu_mondo_head_rd_g[0] = 
           ~(|cpu_mondo_head_rd_g[3:1]);
assign cpu_mondo_head_rd_g[1] = 
           asi_queue_read_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign cpu_mondo_head_rd_g[2] = 
           asi_queue_read_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign cpu_mondo_head_rd_g[3] = 
           asi_queue_read_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign cpu_mondo_hd_rd_g = 
           asi_queue_read_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g;
// 
// cpu_mondo_head write 
//
assign cpu_mondo_head_wr_g[0] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[0];
assign cpu_mondo_head_wr_g[1] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[1];
assign cpu_mondo_head_wr_g[2] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[2];
assign cpu_mondo_head_wr_g[3] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[3];
//
// cpu_mondo_tail read
// assign cpu_mondo_tail_rd_g[0] = 
//            asi_queue_read_g & cpu_mondo_tail_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign cpu_mondo_tail_rd_g[0] = 
           ~(|cpu_mondo_tail_rd_g[3:1]);
assign cpu_mondo_tail_rd_g[1] = 
           asi_queue_read_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign cpu_mondo_tail_rd_g[2] = 
           asi_queue_read_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign cpu_mondo_tail_rd_g[3] = 
           asi_queue_read_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign cpu_mondo_ta_rd_g = 
           asi_queue_read_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g;
// 
// cpu_mondo_tail write 
// 
assign cpu_mondo_tail_wr_g[0] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[0];
assign cpu_mondo_tail_wr_g[1] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[1];
assign cpu_mondo_tail_wr_g[2] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[2];
assign cpu_mondo_tail_wr_g[3] = 
           ~local_flush_all_w & asi_queue_write_uf_g & cpu_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[3];
//
// dev_mondo_head read
// assign dev_mondo_head_rd_g[0] = 
//            asi_queue_read_g & dev_mondo_head_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign dev_mondo_head_rd_g[0] = 
           ~(|dev_mondo_head_rd_g[3:1]);
assign dev_mondo_head_rd_g[1] = 
           asi_queue_read_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign dev_mondo_head_rd_g[2] = 
           asi_queue_read_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign dev_mondo_head_rd_g[3] = 
           asi_queue_read_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign dev_mondo_hd_rd_g = 
           asi_queue_read_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g;
// 
// dev_mondo_head write 
//
assign dev_mondo_head_wr_g[0] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[0];
assign dev_mondo_head_wr_g[1] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[1];
assign dev_mondo_head_wr_g[2] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[2];
assign dev_mondo_head_wr_g[3] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_head_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[3];
//
// dev_mondo_tail read
// assign dev_mondo_tail_rd_g[0] = 
//            asi_queue_read_g & dev_mondo_tail_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign dev_mondo_tail_rd_g[0] = 
           ~(|dev_mondo_tail_rd_g[3:1]);
assign dev_mondo_tail_rd_g[1] = 
           asi_queue_read_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign dev_mondo_tail_rd_g[2] = 
           asi_queue_read_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign dev_mondo_tail_rd_g[3] = 
           asi_queue_read_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign dev_mondo_ta_rd_g = 
           asi_queue_read_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g;
// 
// dev_mondo_tail write 
// 
assign dev_mondo_tail_wr_g[0] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[0];
assign dev_mondo_tail_wr_g[1] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[1];
assign dev_mondo_tail_wr_g[2] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[2];
assign dev_mondo_tail_wr_g[3] = 
           ~local_flush_all_w & asi_queue_write_uf_g & dev_mondo_tail_rw_g & 
           asi_queue_rw_g & thread_sel_id_g[3];
//
// resum_err_head read
// assign resum_err_head_rd_g[0] = 
//            asi_queue_read_g & resum_err_head_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign resum_err_head_rd_g[0] = 
           ~(|resum_err_head_rd_g[3:1]);
assign resum_err_head_rd_g[1] = 
           asi_queue_read_g & resum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign resum_err_head_rd_g[2] = 
           asi_queue_read_g & resum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign resum_err_head_rd_g[3] = 
           asi_queue_read_g & resum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign resum_err_hd_rd_g = 
           asi_queue_read_g & resum_err_head_rw_g & 
           asi_queue_rw_g;
// 
// resum_err_head write 
//
assign resum_err_head_wr_g[0] = 
           asi_queue_write_g & resum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[0];
assign resum_err_head_wr_g[1] = 
           asi_queue_write_g & resum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[1];
assign resum_err_head_wr_g[2] = 
           asi_queue_write_g & resum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[2];
assign resum_err_head_wr_g[3] = 
           asi_queue_write_g & resum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[3];
//
// resum_err_tail read
// assign resum_err_tail_rd_g[0] = 
//            asi_queue_read_g & resum_err_tail_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign resum_err_tail_rd_g[0] = 
           ~(|resum_err_tail_rd_g[3:1]);
assign resum_err_tail_rd_g[1] = 
           asi_queue_read_g & resum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign resum_err_tail_rd_g[2] = 
           asi_queue_read_g & resum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign resum_err_tail_rd_g[3] = 
           asi_queue_read_g & resum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign resum_err_ta_rd_g = 
           asi_queue_read_g & resum_err_tail_rw_g & 
           asi_queue_rw_g;
// 
// resum_err_tail write 
// 
assign resum_err_tail_wr_g[0] = 
           asi_queue_write_g & resum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[0];
assign resum_err_tail_wr_g[1] = 
           asi_queue_write_g & resum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[1];
assign resum_err_tail_wr_g[2] = 
           asi_queue_write_g & resum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[2];
assign resum_err_tail_wr_g[3] = 
           asi_queue_write_g & resum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[3];
//
// nresum_err_head read
// assign nresum_err_head_rd_g[0] = 
//            asi_queue_read_g & nresum_err_head_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign nresum_err_head_rd_g[0] = 
           ~(|nresum_err_head_rd_g[3:1]);
assign nresum_err_head_rd_g[1] = 
           asi_queue_read_g & nresum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign nresum_err_head_rd_g[2] = 
           asi_queue_read_g & nresum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign nresum_err_head_rd_g[3] = 
           asi_queue_read_g & nresum_err_head_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign nresum_err_hd_rd_g = 
           asi_queue_read_g & nresum_err_head_rw_g & 
           asi_queue_rw_g;
// 
// nresum_err_head write 
//
assign nresum_err_head_wr_g[0] = 
           asi_queue_write_g & nresum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[0];
assign nresum_err_head_wr_g[1] = 
           asi_queue_write_g & nresum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[1];
assign nresum_err_head_wr_g[2] = 
           asi_queue_write_g & nresum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[2];
assign nresum_err_head_wr_g[3] = 
           asi_queue_write_g & nresum_err_head_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[3];
//
// nresum_err_tail read
// assign nresum_err_tail_rd_g[0] = 
//            asi_queue_read_g & nresum_err_tail_rw_g & 
//            asi_queue_rw_g   & thread_sel_id_g[0];
assign nresum_err_tail_rd_g[0] = 
           ~(|nresum_err_tail_rd_g[3:1]);
assign nresum_err_tail_rd_g[1] = 
           asi_queue_read_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[1];
assign nresum_err_tail_rd_g[2] = 
           asi_queue_read_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[2];
assign nresum_err_tail_rd_g[3] = 
           asi_queue_read_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g   & thread_sel_id_g[3];
//
// non-thread specific read
assign nresum_err_ta_rd_g = 
           asi_queue_read_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g;
// 
// nresum_err_tail write 
// 
assign nresum_err_tail_wr_g[0] = 
           asi_queue_write_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[0];
assign nresum_err_tail_wr_g[1] = 
           asi_queue_write_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[1];
assign nresum_err_tail_wr_g[2] = 
           asi_queue_write_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[2];
assign nresum_err_tail_wr_g[3] = 
           asi_queue_write_g & nresum_err_tail_rw_g & 
           asi_queue_rw_g    & thread_sel_id_g[3];
//
// storing the head and pointers for the queues
// thread 0
//
dffe_s #(8) dffe_cpu_mondo0_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo0_head[8-1:0]),
     .en  (cpu_mondo_head_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_cpu_mondo0_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo0_tail[8-1:0]),
     .en  (cpu_mondo_tail_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo0_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo0_head[8-1:0]),
     .en  (dev_mondo_head_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo0_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo0_tail[8-1:0]),
     .en  (dev_mondo_tail_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err0_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err0_head[8-1:0]),
     .en  (resum_err_head_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err0_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err0_tail[8-1:0]),
     .en  (resum_err_tail_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err0_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err0_head[8-1:0]),
     .en  (nresum_err_head_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err0_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err0_tail[8-1:0]),
     .en  (nresum_err_tail_wr_g[0]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// thread 1
//
dffe_s #(8) dffe_cpu_mondo1_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo1_head[8-1:0]),
     .en  (cpu_mondo_head_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_cpu_mondo1_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo1_tail[8-1:0]),
     .en  (cpu_mondo_tail_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo1_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo1_head[8-1:0]),
     .en  (dev_mondo_head_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo1_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo1_tail[8-1:0]),
     .en  (dev_mondo_tail_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err1_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err1_head[8-1:0]),
     .en  (resum_err_head_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err1_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err1_tail[8-1:0]),
     .en  (resum_err_tail_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err1_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err1_head[8-1:0]),
     .en  (nresum_err_head_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err1_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err1_tail[8-1:0]),
     .en  (nresum_err_tail_wr_g[1]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// thread 2
//
dffe_s #(8) dffe_cpu_mondo2_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo2_head[8-1:0]),
     .en  (cpu_mondo_head_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_cpu_mondo2_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo2_tail[8-1:0]),
     .en  (cpu_mondo_tail_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo2_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo2_head[8-1:0]),
     .en  (dev_mondo_head_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo2_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo2_tail[8-1:0]),
     .en  (dev_mondo_tail_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err2_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err2_head[8-1:0]),
     .en  (resum_err_head_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err2_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err2_tail[8-1:0]),
     .en  (resum_err_tail_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err2_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err2_head[8-1:0]),
     .en  (nresum_err_head_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err2_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err2_tail[8-1:0]),
     .en  (nresum_err_tail_wr_g[2]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// thread 3
//
dffe_s #(8) dffe_cpu_mondo3_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo3_head[8-1:0]),
     .en  (cpu_mondo_head_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_cpu_mondo3_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (cpu_mondo3_tail[8-1:0]),
     .en  (cpu_mondo_tail_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo3_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo3_head[8-1:0]),
     .en  (dev_mondo_head_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_dev_mondo3_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (dev_mondo3_tail[8-1:0]),
     .en  (dev_mondo_tail_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err3_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err3_head[8-1:0]),
     .en  (resum_err_head_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_resum_err3_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (resum_err3_tail[8-1:0]),
     .en  (resum_err_tail_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err3_head (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err3_head[8-1:0]),
     .en  (nresum_err_head_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);

dffe_s #(8) dffe_nresum_err3_tail (
     .din (tlu_asi_queue_data_g[8-1:0]), 
     .q   (nresum_err3_tail[8-1:0]),
     .en  (nresum_err_tail_wr_g[3]), 
     .clk (clk),
     .se  (se),       
     .si  (),          
     .so  ()
);
//
// reading out the asi queues 
// 
// added for bug2332
// assign cpu_mondo_hd_onehot_g = 
//            ~(|cpu_mondo_head_rd_g[3:1]);
// cpu_mondo_head
mux4ds #(8) mx_cpu_mondo_head (
    .in0  (cpu_mondo0_head[8-1:0]),
    .in1  (cpu_mondo1_head[8-1:0]),
    .in2  (cpu_mondo2_head[8-1:0]),
    .in3  (cpu_mondo3_head[8-1:0]),
    .sel0 (cpu_mondo_head_rd_g[0]),
    .sel1 (cpu_mondo_head_rd_g[1]),
    .sel2 (cpu_mondo_head_rd_g[2]),
    .sel3 (cpu_mondo_head_rd_g[3]),
    .dout (cpu_mondo_hd_rdata[8-1:0])
); 
//
// added for bug2332
// assign cpu_mondo_ta_onehot_g = 
//            ~(|cpu_mondo_tail_rd_g[3:1]);
// cpu_mondo_tail
mux4ds #(8) mx_cpu_mondo_tail (
    .in0  (cpu_mondo0_tail[8-1:0]),
    .in1  (cpu_mondo1_tail[8-1:0]),
    .in2  (cpu_mondo2_tail[8-1:0]),
    .in3  (cpu_mondo3_tail[8-1:0]),
    .sel0 (cpu_mondo_tail_rd_g[0]),
    .sel1 (cpu_mondo_tail_rd_g[1]),
    .sel2 (cpu_mondo_tail_rd_g[2]),
    .sel3 (cpu_mondo_tail_rd_g[3]),
    .dout (cpu_mondo_ta_rdata[8-1:0])
); 
//
// added for bug2332
// assign dev_mondo_hd_onehot_g = 
//            ~(|dev_mondo_head_rd_g[3:1]);
// dev_mondo_head
mux4ds #(8) mx_dev_mondo_head (
    .in0  (dev_mondo0_head[8-1:0]),
    .in1  (dev_mondo1_head[8-1:0]),
    .in2  (dev_mondo2_head[8-1:0]),
    .in3  (dev_mondo3_head[8-1:0]),
    .sel0 (dev_mondo_head_rd_g[0]),
    .sel1 (dev_mondo_head_rd_g[1]),
    .sel2 (dev_mondo_head_rd_g[2]),
    .sel3 (dev_mondo_head_rd_g[3]),
    .dout (dev_mondo_hd_rdata[8-1:0])
); 
//
// added for bug2332
// assign dev_mondo_ta_onehot_g = 
//            ~(|dev_mondo_tail_rd_g[3:1]);
// dev_mondo_tail
mux4ds #(8) mx_dev_mondo_tail (
    .in0  (dev_mondo0_tail[8-1:0]),
    .in1  (dev_mondo1_tail[8-1:0]),
    .in2  (dev_mondo2_tail[8-1:0]),
    .in3  (dev_mondo3_tail[8-1:0]),
    .sel0 (dev_mondo_tail_rd_g[0]),
    .sel1 (dev_mondo_tail_rd_g[1]),
    .sel2 (dev_mondo_tail_rd_g[2]),
    .sel3 (dev_mondo_tail_rd_g[3]),
    .dout (dev_mondo_ta_rdata[8-1:0])
); 
//
// added for bug2332
// assign resum_err_hd_onehot_g = 
//            ~(|resum_err_head_rd_g[3:1]);
// resum_err_head
mux4ds #(8) mx_resum_err_head (
    .in0  (resum_err0_head[8-1:0]),
    .in1  (resum_err1_head[8-1:0]),
    .in2  (resum_err2_head[8-1:0]),
    .in3  (resum_err3_head[8-1:0]),
    .sel0 (resum_err_head_rd_g[0]),
    .sel1 (resum_err_head_rd_g[1]),
    .sel2 (resum_err_head_rd_g[2]),
    .sel3 (resum_err_head_rd_g[3]),
    .dout (resum_err_hd_rdata[8-1:0])
); 
//
// added for bug2332
// assign resum_err_ta_onehot_g = 
//            ~(|resum_err_tail_rd_g[3:1]);
// resum_err_tail
mux4ds #(8) mx_resum_err_tail (
    .in0  (resum_err0_tail[8-1:0]),
    .in1  (resum_err1_tail[8-1:0]),
    .in2  (resum_err2_tail[8-1:0]),
    .in3  (resum_err3_tail[8-1:0]),
    .sel0 (resum_err_tail_rd_g[0]),
    .sel1 (resum_err_tail_rd_g[1]),
    .sel2 (resum_err_tail_rd_g[2]),
    .sel3 (resum_err_tail_rd_g[3]),
    .dout (resum_err_ta_rdata[8-1:0])
); 
//
// added for bug2332
// assign nresum_err_hd_onehot_g = 
//            ~(|nresum_err_head_rd_g[3:1]);
// nresum_err_head
mux4ds #(8) mx_nresum_err_head (
    .in0  (nresum_err0_head[8-1:0]),
    .in1  (nresum_err1_head[8-1:0]),
    .in2  (nresum_err2_head[8-1:0]),
    .in3  (nresum_err3_head[8-1:0]),
    .sel0 (nresum_err_head_rd_g[0]),
    .sel1 (nresum_err_head_rd_g[1]),
    .sel2 (nresum_err_head_rd_g[2]),
    .sel3 (nresum_err_head_rd_g[3]),
    .dout (nresum_err_hd_rdata[8-1:0])
); 
//
// added for bug2332
// assign nresum_err_ta_onehot_g = 
//            ~(|nresum_err_tail_rd_g[3:1]);
// nresum_err_tail
mux4ds #(8) mx_nresum_err_tail (
    .in0  (nresum_err0_tail[8-1:0]),
    .in1  (nresum_err1_tail[8-1:0]),
    .in2  (nresum_err2_tail[8-1:0]),
    .in3  (nresum_err3_tail[8-1:0]),
    .sel0 (nresum_err_tail_rd_g[0]),
    .sel1 (nresum_err_tail_rd_g[1]),
    .sel2 (nresum_err_tail_rd_g[2]),
    .sel3 (nresum_err_tail_rd_g[3]),
    .dout (nresum_err_ta_rdata[8-1:0])
); 
// 
// added for bug 2332
assign asi_qrdata_mx1_sel[0] = cpu_mondo_hd_rd_g | 
                               ~(|asi_qrdata_mx1_sel[3:1]);
assign asi_qrdata_mx1_sel[1] = cpu_mondo_ta_rd_g;
assign asi_qrdata_mx1_sel[2] = dev_mondo_hd_rd_g;
assign asi_qrdata_mx1_sel[3] = dev_mondo_ta_rd_g;
// 
// selecting between the eight queues
mux4ds #(8) mx1_asi_queue_rdata (
    .in0  (cpu_mondo_hd_rdata[8-1:0]),
    .in1  (cpu_mondo_ta_rdata[8-1:0]),
    .in2  (dev_mondo_hd_rdata[8-1:0]),
    .in3  (dev_mondo_ta_rdata[8-1:0]),
    .sel0 (asi_qrdata_mx1_sel[0]),
    .sel1 (asi_qrdata_mx1_sel[1]),
    .sel2 (asi_qrdata_mx1_sel[2]),
    .sel3 (asi_qrdata_mx1_sel[3]),
    .dout (asi_queue_rdata1_g[8-1:0])
);
// 
// added for bug 2332
assign asi_qrdata_mx2_sel[0] = resum_err_hd_rd_g | 
                               ~(|asi_qrdata_mx2_sel[3:1]);
assign asi_qrdata_mx2_sel[1] = resum_err_ta_rd_g;
assign asi_qrdata_mx2_sel[2] = nresum_err_hd_rd_g;
assign asi_qrdata_mx2_sel[3] = nresum_err_ta_rd_g;

mux4ds #(8) mx2_asi_queue_rdata (
    .in0  (resum_err_hd_rdata[8-1:0]),
    .in1  (resum_err_ta_rdata[8-1:0]),
    .in2  (nresum_err_hd_rdata[8-1:0]),
    .in3  (nresum_err_ta_rdata[8-1:0]),
    .sel0 (asi_qrdata_mx2_sel[0]),
    .sel1 (asi_qrdata_mx2_sel[1]),
    .sel2 (asi_qrdata_mx2_sel[2]),
    .sel3 (asi_qrdata_mx2_sel[3]),
    .dout (asi_queue_rdata2_g[8-1:0])
);
//
// constructing the select for the final asi queue rdata output
assign asi_qrdata_mx_sel2 = 
           resum_err_hd_rd_g  | resum_err_ta_rd_g |  
           nresum_err_hd_rd_g | nresum_err_ta_rd_g;   
//
mux2ds #(8) mx_tlu_asi_queue_rdata (
    .in0  (asi_queue_rdata2_g[8-1:0]),
    .in1  (asi_queue_rdata1_g[8-1:0]),
    .sel0 (asi_qrdata_mx_sel2),
    .sel1 (~asi_qrdata_mx_sel2),
    .dout (tlu_asi_queue_rdata_g[8-1:0])
);
//
// forming the valid signal for the asi queue rdata
assign tlu_asi_queue_rd_vld_g =
       asi_qrdata_mx_sel2 | cpu_mondo_hd_rd_g | cpu_mondo_ta_rd_g |
       dev_mondo_hd_rd_g  | dev_mondo_ta_rd_g; 

assign tlu_ld_data_vld_g = asi_ld_addr_vld_g; 

////////////////////////////////////////////////////////////////////////
// SCPD and HSCPD control logic
////////////////////////////////////////////////////////////////////////
//
// privileged scratch pad access
assign asi_scpd_rw_e = 
           ifu_lsu_alt_space_e & 
          (tlu_asi_state_e[8-1:0]==8'h20);

// hyprivileged scratch pad access
assign asi_hscpd_rw_e = 
           ifu_lsu_alt_space_e & 
          (tlu_asi_state_e[8-1:0]==8'h4f);
//
// staged the scpd/hscpd rw ctls
dffr_s #(2) dffr_asi_scpd_rw_ctls (
    .din ({asi_hscpd_rw_e, asi_scpd_rw_e}),
    .q   ({asi_hscpd_rw_m, asi_scpd_rw_m}),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// address generation
//
// modified due to timing fix  
/*
 assign scpd_addr_va_e[`SCPD_ASI_VA_ADDR_WIDTH-1:0] = 
            tlu_ldst_va_e[`TLU_ASI_SCPD_VA_HI:`TLU_ASI_SCPD_VA_LO];

 staged the shifted va address
 modified due to timing fix

dff_s #(`SCPD_ASI_VA_ADDR_WIDTH) dff_scpd_addr_va_m (
    .din (scpd_addr_va_e[`SCPD_ASI_VA_ADDR_WIDTH-1:0]),
    .q   (scpd_addr_va_m[`SCPD_ASI_VA_ADDR_WIDTH-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/

assign scpd_addr_va_m[3-1:0] = 
            tlu_ldst_va_m[5:3];

dff_s #(3) dff_scpd_addr_va_g (
    .din (scpd_addr_va_m[3-1:0]),
    .q   (scpd_addr_va_g[3-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_scpd_rd_addr_m[5-1:0] = 
           {thrid_m[1:0], scpd_addr_va_m[3-1:0]}; 

assign tlu_scpd_wr_addr_g[5-1:0] = 
           {thrid_g[1:0], scpd_addr_va_g[3-1:0]}; 
//
// illegal range check for scratch-pd va 
// modified due to timing
/*
assign scpd_ill_va_e = 
           (ifu_lsu_alt_space_e)?
           ((asi_scpd_rw_e | asi_hscpd_rw_e) & 
           ((|exu_lsu_ldst_va_e[`ASI_VA_WIDTH-1:`TLU_ASI_SCPD_VA_HI+1]) |
            (|exu_lsu_ldst_va_e[`TLU_ASI_SCPD_VA_LO-1:0]))) :
            1'b0;
// staged illegal va range 
dffr_s dffr_scpd_ill_va_m (
    .din (scpd_ill_va_e),
    .q   (scpd_ill_va_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
//
assign va_not_baligned_m = (|tlu_ldst_va_m[3-1:0]); 
assign scpd_ill_va_m = 
           (asi_scpd_rw_m | asi_hscpd_rw_m) & 
            va_not_baligned_m;
       
// 
dffr_s dffr_scpd_ill_va_g (
    .din (scpd_ill_va_m),
    .q   (scpd_ill_va_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// generating read and write valid 
assign asi_scpd_rw_vld_m = 
            (asi_scpd_rw_m | asi_hscpd_rw_m) & 
           ~(hscpd_data_acc_excpt_m | va_not_baligned_m);

dffr_s dffr_asi_scpd_rw_vld_g (
    .din (asi_scpd_rw_vld_m),
    .q   (asi_scpd_rw_vld_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_scpd_wr_vld_g = 
           asi_queue_write_g & asi_scpd_rw_vld_g; 
//
// control to the memory macro for the read
// modified due to timing 
assign tlu_scpd_rd_vld_m = 
           // asi_queue_read_m & asi_scpd_rw_vld_m; 
           asi_queue_read_pq_m & asi_scpd_rw_vld_m; 
//
// control to the int block for the selection of read data 
// replaced by queue vld
// assign tlu_scpd_rd_vld_g = 
//            asi_queue_read_g & asi_scpd_rw_vld_g; 

// decoding for hypervisor only scratch-pad
assign hscpd_va_rw_m = 
          ((scpd_addr_va_m[3-1:0] == 
            3'h4) | 
           (scpd_addr_va_m[3-1:0] == 
            3'h5));  

////////////////////////////////////////////////////////////////////////
// Potential trap indicators 
////////////////////////////////////////////////////////////////////////
// possible traps are: 
// 1) head ptr <> tail ptr (with the exception of nresum_err_queue)
// 2) write to tail by supervisor - data_access_exception 

//
// write to hypervisor scratch-pad using 0x20 ASI state

assign hscpd_priv_asi_acc_m = 
       hscpd_va_rw_m & asi_scpd_rw_m; 

// modified due to timing - moved the inst_vld qualification to tlu_tcl
assign hscpd_data_acc_excpt_pq_m = 
           hscpd_priv_asi_acc_m & 
           (asi_queue_write_pq_m | asi_queue_read_pq_m);
/*
           hscpd_priv_asi_acc_m & 
           // (asi_queue_write_m | asi_queue_read_m)  &
           (asi_queue_write_pq_m | asi_queue_read_pq_m) &
           ((thread_sel_id_m[0] & ~tlu_hyper_lite[0]) |
            (thread_sel_id_m[1] & ~tlu_hyper_lite[1]) |
            (thread_sel_id_m[2] & ~tlu_hyper_lite[2]) |
            (thread_sel_id_m[3] & ~tlu_hyper_lite[3])); 
*/
//
// data_access_exception to access the hyper-privileged scratch-pad 

assign tlu_hscpd_dacc_excpt_m = hscpd_data_acc_excpt_pq_m;
//
// revised for bug 3586

assign hscpd_data_acc_excpt_m = 
           hscpd_data_acc_excpt_pq_m & 
           ((thread_sel_id_m[0] & ~tlu_hyper_lite[0]) |
            (thread_sel_id_m[1] & ~tlu_hyper_lite[1]) |
            (thread_sel_id_m[2] & ~tlu_hyper_lite[2]) |
            (thread_sel_id_m[3] & ~tlu_hyper_lite[3])); 

// illegal va range indicator
assign tlu_va_ill_g = 
           (que_ill_va_g | scpd_ill_va_g) & asi_queue_read_g; 

// load instruction valid - scpd or asi queue 
assign asi_ld_addr_vld_m  = 
             asi_queue_read_m & (asi_queue_rw_m | 
           ((asi_hscpd_rw_m | asi_scpd_rw_m) & 
            ~hscpd_data_acc_excpt_m));

// staging the ld address valid 
dffr_s dffr_asi_ld_addr_vld_g (
    .din (asi_ld_addr_vld_m),
    .q   (asi_ld_addr_vld_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// redefined va illegal checking - the following code is 
// no longer necessary
// zero va range detector
/* 
assign va_all_zero_e = 
            (~(|exu_lsu_ldst_va_e[`ASI_VA_WIDTH-1:0])) &
             asi_queue_read_g;
//
// staged illegal va range 
dffr_s dffr_va_all_zero_m (
    .din (va_all_zero_e),
    .q   (va_all_zero_m),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
dffr_s dffr_va_all_zero_g (
    .din (va_all_zero_m),
    .q   (va_all_zero_g),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_va_all_zero_g = va_all_zero_g; 
*/

////////////////////////////////////////////////////////////////////////
// queue traps - head ptr <> tail ptr
////////////////////////////////////////////////////////////////////////
// note: these traps are level-sensitive
//
// thread 0

assign tlu_cpu_mondo_cmp[0] = 
           (|(cpu_mondo0_head[8-1:0] ^
              cpu_mondo0_tail[8-1:0]));
assign tlu_dev_mondo_cmp[0]= 
           (|(dev_mondo0_head[8-1:0] ^
              dev_mondo0_tail[8-1:0]));
assign tlu_resum_err_cmp[0] = 
           (|(resum_err0_head[8-1:0] ^ 
              resum_err0_tail[8-1:0]));
// thread 1

assign tlu_cpu_mondo_cmp[1] = 
           (|(cpu_mondo1_head[8-1:0] ^
              cpu_mondo1_tail[8-1:0]));
assign tlu_dev_mondo_cmp[1]= 
           (|(dev_mondo1_head[8-1:0] ^
              dev_mondo1_tail[8-1:0]));
assign tlu_resum_err_cmp[1] = 
           (|(resum_err1_head[8-1:0] ^ 
              resum_err1_tail[8-1:0]));
//
// thread 2

assign tlu_cpu_mondo_cmp[2] = 
           (|(cpu_mondo2_head[8-1:0] ^
              cpu_mondo2_tail[8-1:0]));
assign tlu_dev_mondo_cmp[2]= 
           (|(dev_mondo2_head[8-1:0] ^
              dev_mondo2_tail[8-1:0]));
assign tlu_resum_err_cmp[2] = 
           (|(resum_err2_head[8-1:0] ^ 
              resum_err2_tail[8-1:0]));
// thread 3

assign tlu_cpu_mondo_cmp[3] = 
           (|(cpu_mondo3_head[8-1:0] ^
              cpu_mondo3_tail[8-1:0]));
assign tlu_dev_mondo_cmp[3]= 
           (|(dev_mondo3_head[8-1:0] ^
              dev_mondo3_tail[8-1:0]));
assign tlu_resum_err_cmp[3] = 
           (|(resum_err3_head[8-1:0] ^ 
              resum_err3_tail[8-1:0]));

// write to tail by supervisor
// modified due to timing - moved the inst_vld qualification to tlu_tcl
assign qtail_write_m = 
           (nresum_err_tail_rw_m | resum_err_tail_rw_m  | 
            cpu_mondo_tail_rw_m  | dev_mondo_tail_rw_m) &
            asi_queue_write_pq_m & asi_queue_rw_m;
            // asi_queue_write_m & asi_queue_rw_m;

//
// modified for timing - qualification moved to tcl
assign tlu_qtail_dacc_excpt_m = qtail_write_m;
/*
           ((thread_sel_id_m[0] & que_trap_en[0] & tlu_pstate_priv[0])  |
            (thread_sel_id_m[1] & que_trap_en[1] & tlu_pstate_priv[1])  |
            (thread_sel_id_m[2] & que_trap_en[2] & tlu_pstate_priv[2])  |
            (thread_sel_id_m[3] & que_trap_en[3] & tlu_pstate_priv[3])) & 
             qtail_write_m;
*/
              
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_incr64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    64b incr macro
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module tlu_incr64 ( in, out );

  input  [63:0] in;

  output [63:0] out;   // result of increment

  assign out = in + 64'h01;

endmodule // tlu_incr64
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_misctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Block that contain most of miscellaneous 
//                      control and datapath components 
//                      to alleviate tdp and tcp congestions 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module	tlu_misctl (/*AUTOARG*/
    // outputs
    tlu_exu_cwp_m, tlu_exu_ccr_m, tlu_lsu_asi_m, tlu_cwp_no_change_m, 
    tlu_sscan_misctl_data, tlu_ifu_trappc_w2, tlu_ifu_trapnpc_w2, 
    tlu_pc_new_w, tlu_npc_new_w, so, 
    // PIC experiment
    tlu_exu_pic_onebelow_m, tlu_exu_pic_twobelow_m, 
    // inputs
    ctu_sscan_tid, ifu_tlu_pc_m, exu_tlu_cwp0, exu_tlu_cwp1, exu_tlu_cwp2, 
    exu_tlu_cwp3, tlu_final_ttype_w2, tsa_wr_tid, tlu_true_pc_sel_w, 
    tsa1_wr_vld, tsa_ttype_en, tsa_rd_vld_e, tsa0_rdata_cwp, tsa0_rdata_pstate,
    tsa0_rdata_asi, tsa0_rdata_ccr, tsa0_rdata_gl, tsa0_rdata_pc, tsa1_rdata_ttype, 
    tsa1_rdata_npc, tsa1_rdata_htstate, tlu_thrd_rsel_e, tlu_final_offset_w1, 
    tlu_partial_trap_pc_w1,  tlu_restore_pc_w1, tlu_restore_npc_w1, 
    ifu_npc_w, tlu_restore_pc_sel_w1, tlu_pic_cnt_en_m, tlu_pic_onebelow_e,
    tlu_pic_twobelow_e, tlu_rst, si, se, rclk);
    // pich_threebelow_flg, pich_twobelow_flg, pich_onebelow_flg, 

//=================================================
// output
//=================================================
output [8-1:0] tlu_exu_ccr_m; // restored ccr
output [3-1:0] tlu_exu_cwp_m; // restored cwp
output [8-1:0] tlu_lsu_asi_m; // restored asi
output tlu_cwp_no_change_m; // cwp change indicator
//
// sscan output
output [9-1:0] tlu_sscan_misctl_data;
//
// trap pc and npc
output [48:0] tlu_ifu_trappc_w2, tlu_ifu_trapnpc_w2; 
output [48:0] tlu_pc_new_w, tlu_npc_new_w; 
// global nets
output so;
// PIC experiment
output       tlu_exu_pic_onebelow_m; // local traps send to exu 
output       tlu_exu_pic_twobelow_m; // local traps send to exu 

//=================================================
// input
//=================================================
// sscan related inputs
input [4-1:0] ctu_sscan_tid;
input [9-1:0] tlu_final_ttype_w2;
input [1:0] tsa_wr_tid;	
input tsa1_wr_vld, tsa_rd_vld_e; 
input tsa_ttype_en; 
// 
// current cwp value from exu
input [2:0]  exu_tlu_cwp0;  // cwp - thread0
input [2:0]  exu_tlu_cwp1;  // cwp - thread1
input [2:0]  exu_tlu_cwp2;  // cwp - thread2
input [2:0]  exu_tlu_cwp3;  // cwp - thread3
// 
// componets from trap stack arrays (tsas)
input [3-1:0] tsa0_rdata_cwp;
input [8-1:0] tsa0_rdata_pstate;
input [8-1:0] tsa0_rdata_ccr;
input [8-1:0] tsa0_rdata_asi;
input [2-1:0] tsa0_rdata_gl;
input [46:0] tsa0_rdata_pc;
input [9-1:0] tsa1_rdata_ttype;
input [46:0] tsa1_rdata_npc;
input [4-1:0] tsa1_rdata_htstate;
//
// trap pc calculations signals
input [48:0] ifu_tlu_pc_m;	  // pc
// input [48:0] ifu_tlu_npc_m;   // npc
input [9-1:0] tlu_final_offset_w1;
input [33:0] tlu_partial_trap_pc_w1;
input [48:0] tlu_restore_pc_w1;
input [48:0] tlu_restore_npc_w1;
// input [48:0] ifu_pc_w;
input [48:0] ifu_npc_w;
input tlu_restore_pc_sel_w1; 
//
// modified due to timing fix
input [2:0] tlu_true_pc_sel_w;
// input tlu_retry_inst_m;
// input tlu_done_inst_m;
// input tlu_dnrtry_inst_m_l;
//
input [4-1:0] tlu_thrd_rsel_e;
// global nets
input si, se;
//
//clk
input rclk;
//
// PIC trap experiment 
// input [`TLU_THRD_NUM-1:0] tlu_thread_inst_vld_w2; // valid inst for a thread
// input [`TLU_THRD_NUM-1:0] pich_threebelow_flg;
// input [`TLU_THRD_NUM-1:0] pich_twobelow_flg;
// input [`TLU_THRD_NUM-1:0] pich_onebelow_flg;
input tlu_pic_onebelow_e;
input tlu_pic_twobelow_e;
input tlu_pic_cnt_en_m;
input tlu_rst;

//=================================================
// local wires
//=================================================
// local clock
wire clk;
//
// staged thread id
wire [4-1:0] thrd_sel_m;
wire [4-1:0] tsa_wsel_thrd_w2;
// 
// staged tsa_controls
wire tsa_rd_vld_m; // tsa_rd_vld_e,  
// 
// components from tsas
// tsa0
wire [8-1:0] tsa0_asi_m;
wire [3-1:0] tsa0_cwp_m;
wire [8-1:0] tsa0_ccr_m;
wire [8-1:0] tsa0_pstate_m;
wire [2-1:0] tsa0_gl_m;
wire [46:0] tsa0_pc_m;
// tsa1
wire [9-1:0]   tsa1_ttype_m;
wire [4-1:0] tsa1_htstate_m;
wire [46:0] tsa1_npc_m;
//
// modified for timing
// wire [48:0] pc_new_m, npc_new_m;
wire [48:0] pc_new_w, npc_new_w, ifu_pc_w;
wire [46:0] tsa0_pc_w, tsa1_npc_w;
// 
// sscan related signals 
wire [4-1:0] sscan_tid_sel; 
wire [4-1:0] sscan_ttype_en;
wire [4-1:0] sscan_tt_rd_sel;
wire [4-1:0] sscan_tt_wr_sel;
wire [9-1:0] sscan_tt0_data;
wire [9-1:0] sscan_tt1_data;
wire [9-1:0] sscan_tt2_data;
wire [9-1:0] sscan_tt3_data;
wire [9-1:0] sscan_tt0_din;
wire [9-1:0] sscan_tt1_din;
wire [9-1:0] sscan_tt2_din;
wire [9-1:0] sscan_tt3_din;
wire [9-1:0] misctl_sscan_test_data;
//
// cwp logic 
wire cwp_no_change_m;
wire [3-1:0] cwp_xor_m, trap_old_cwp_m; 
wire [48:0] normal_trap_pc_w1, normal_trap_npc_w1; 
wire [48:0] trap_pc_w1, trap_npc_w1; 
wire [48:0] trap_pc_w2, trap_npc_w2; 
//
// PIC experiment
wire tlu_pic_onebelow_m, tlu_pic_twobelow_m; 
// wire [`TLU_THRD_NUM-1:0] pic_onebelow_e, pic_twobelow_e; 
wire local_rst;
// 
//=========================================================================================
// local clock
//=========================================================================================

assign clk = rclk; 

//=========================================================================================
//	TSA data capture
//=========================================================================================

dff_s #(8) dff_tsa0_ccr_m (
    .din (tsa0_rdata_ccr[8-1:0]),
    .q   (tsa0_ccr_m[8-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(3) dff_tsa0_cwp_m (
    .din (tsa0_rdata_cwp[3-1:0]),
    .q   (tsa0_cwp_m[3-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(8) dff_lsu_asi_m (
    .din (tsa0_rdata_asi[8-1:0]),
    .q   (tsa0_asi_m[8-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
    );

dff_s #(8) dff_tsa0_pstate_m (
    .din (tsa0_rdata_pstate[8-1:0]),
    .q   (tsa0_pstate_m[8-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(2) dff_tsa0_gl_m (
    .din (tsa0_rdata_gl[2-1:0]),
    .q   (tsa0_gl_m[2-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(47) dff_tsa0_pc_m (
    .din (tsa0_rdata_pc[46:0]),
    .q   (tsa0_pc_m[46:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(9) dff_tsa1_ttype_m (
    .din (tsa1_rdata_ttype[9-1:0]), 
	.q   (tsa1_ttype_m[9-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(4) dff_tsa1_htstate_m (
    .din (tsa1_rdata_htstate[4-1:0]), 
	.q   (tsa1_htstate_m[4-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(47) dff_tsa1_npc_m (
    .din (tsa1_rdata_npc[46:0]),
    .q   (tsa1_npc_m[46:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
//=========================================================================================
//	CWP/CCR restoration
//=========================================================================================

assign tlu_exu_ccr_m[8-1:0] = 
           tsa0_ccr_m[8-1:0];
assign tlu_exu_cwp_m[3-1:0] = 
           tsa0_cwp_m[3-1:0];
assign tlu_lsu_asi_m[8-1:0] = 
           tsa0_asi_m[8-1:0];

// modified/added for timing violations
// moved the logic from exu to tlu due to timing violations

dff_s #(4) dff_thrd_sel_m (
    .din (tlu_thrd_rsel_e[4-1:0]),
	.q   (thrd_sel_m[4-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

mux4ds #(3) mux_trap_old_cwp_m(
    .in0(exu_tlu_cwp0[3-1:0]),
    .in1(exu_tlu_cwp1[3-1:0]), 
    .in2(exu_tlu_cwp2[3-1:0]),
    .in3(exu_tlu_cwp3[3-1:0]),
    .sel0(thrd_sel_m[0]),
    .sel1(thrd_sel_m[1]),
    .sel2(thrd_sel_m[2]),
    .sel3(thrd_sel_m[3]),
    .dout(trap_old_cwp_m[3-1:0])
);

assign cwp_xor_m[3-1:0] = 
           trap_old_cwp_m[3-1:0] ^ tlu_exu_cwp_m[3-1:0];

assign cwp_no_change_m = ~|(cwp_xor_m[3-1:0]); 

assign tlu_cwp_no_change_m = cwp_no_change_m;

//=========================================================================================
//	Generate TTYPE SSCAN data 
//=========================================================================================
//
// staging the tsa_rd_vld signal
// moved to tlu_tcl for timing 
/* 
dff_s dff_tsa_rd_vld_e ( 
    .din (tsa_rd_vld),
	.q   (tsa_rd_vld_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
*/

dff_s dff_tsa_rd_vld_m (
    .din (tsa_rd_vld_e),
	.q   (tsa_rd_vld_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	tsa_wsel_thrd_w2[0] = ~tsa_wr_tid[1] & ~tsa_wr_tid[0];
assign	tsa_wsel_thrd_w2[1] = ~tsa_wr_tid[1] &  tsa_wr_tid[0];
assign	tsa_wsel_thrd_w2[2]=   tsa_wr_tid[1] & ~tsa_wr_tid[0];
assign	tsa_wsel_thrd_w2[3] =  tsa_wr_tid[1] &  tsa_wr_tid[0];

// generating write indicators of ttype to the tsa
assign sscan_tt_wr_sel[0] = 
           tsa_ttype_en & tsa1_wr_vld & tsa_wsel_thrd_w2[0]; 
assign sscan_tt_wr_sel[1] = 
           tsa_ttype_en & tsa1_wr_vld & tsa_wsel_thrd_w2[1]; 
assign sscan_tt_wr_sel[2] = 
           tsa_ttype_en & tsa1_wr_vld & tsa_wsel_thrd_w2[2]; 
assign sscan_tt_wr_sel[3] = 
           tsa_ttype_en & tsa1_wr_vld & tsa_wsel_thrd_w2[3];
//
// generating read indicators of ttype from the tsa
assign sscan_tt_rd_sel[0] = 
           tsa_rd_vld_m & thrd_sel_m[0]; 
assign sscan_tt_rd_sel[1] = 
           tsa_rd_vld_m & thrd_sel_m[1]; 
assign sscan_tt_rd_sel[2] = 
           tsa_rd_vld_m & thrd_sel_m[2]; 
assign sscan_tt_rd_sel[3] = 
           tsa_rd_vld_m & thrd_sel_m[3]; 

assign sscan_ttype_en[0] = 
           sscan_tt_rd_sel[0] | sscan_tt_wr_sel[0]; 
assign sscan_ttype_en[1] = 
           sscan_tt_rd_sel[1] | sscan_tt_wr_sel[1]; 
assign sscan_ttype_en[2] = 
           sscan_tt_rd_sel[2] | sscan_tt_wr_sel[2]; 
assign sscan_ttype_en[3] = 
           sscan_tt_rd_sel[3] | sscan_tt_wr_sel[3]; 
//
assign sscan_tt0_din[9-1:0] = 
           (sscan_tt_wr_sel[0]) ? 
            tlu_final_ttype_w2[9-1:0] :
            tsa1_ttype_m[9-1:0];  
assign sscan_tt1_din[9-1:0] = 
           (sscan_tt_wr_sel[1]) ? 
            tlu_final_ttype_w2[9-1:0] :
            tsa1_ttype_m[9-1:0];  
assign sscan_tt2_din[9-1:0] = 
           (sscan_tt_wr_sel[2]) ? 
            tlu_final_ttype_w2[9-1:0] :
            tsa1_ttype_m[9-1:0];  
assign sscan_tt3_din[9-1:0] = 
           (sscan_tt_wr_sel[3]) ? 
            tlu_final_ttype_w2[9-1:0] :
            tsa1_ttype_m[9-1:0];  
//
dffe_s #(9) dffe_sscan_tt0_data (
    .din (sscan_tt0_din[9-1:0]), 
    .q   (sscan_tt0_data[9-1:0]),
    .en  (sscan_ttype_en[0]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(9) dffe_sscan_tt1_data (
    .din (sscan_tt1_din[9-1:0]), 
    .q   (sscan_tt1_data[9-1:0]),
    .en  (sscan_ttype_en[1]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(9) dffe_sscan_tt2_data (
    .din (sscan_tt2_din[9-1:0]), 
    .q   (sscan_tt2_data[9-1:0]),
    .en  (sscan_ttype_en[2]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(9) dffe_sscan_tt3_data (
    .din (sscan_tt3_din[9-1:0]), 
    .q   (sscan_tt3_data[9-1:0]),
    .en  (sscan_ttype_en[3]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign sscan_tid_sel[4-1:0] = 
           ctu_sscan_tid[4-1:0]; 

mux4ds #(9) mx_sscan_test_data (
       .in0  (sscan_tt0_data[9-1:0]),
       .in1  (sscan_tt1_data[9-1:0]),
       .in2  (sscan_tt2_data[9-1:0]),
       .in3  (sscan_tt3_data[9-1:0]),
       .sel0 (sscan_tid_sel[0]),
       .sel1 (sscan_tid_sel[1]),
       .sel2 (sscan_tid_sel[2]),
       .sel3 (sscan_tid_sel[3]),
       .dout (misctl_sscan_test_data[9-1:0])
); 

assign tlu_sscan_misctl_data[9-1:0] = 
           misctl_sscan_test_data[9-1:0]; 
//
// code moved from tlu_tcl - trap pc delivery logic
// 
assign	normal_trap_pc_w1[48:0] = 
            {1'b0, tlu_partial_trap_pc_w1[33:0],
             tlu_final_offset_w1[9-1:0], 5'b00000};
assign	normal_trap_npc_w1[48:0] = 
            {1'b0, tlu_partial_trap_pc_w1[33:0],
             tlu_final_offset_w1[9-1:0], 5'b00100};
//
// code moved from tlu_tdp
mux2ds #(49) mx_trap_pc_w1 (
       .in0  (normal_trap_pc_w1[48:0]), 
       .in1  (tlu_restore_pc_w1[48:0]),
       .sel0 (~tlu_restore_pc_sel_w1),  
       .sel1 (tlu_restore_pc_sel_w1),
       .dout (trap_pc_w1[48:0])
);           
//
dff_s #(49) dff_trap_pc_w2 (
    .din (trap_pc_w1[48:0]), 	
    .q   (trap_pc_w2[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_ifu_trappc_w2[48:0] = trap_pc_w2[48:0];

mux2ds #(49) mx_trap_npc_w1 (
       .in0  (normal_trap_npc_w1[48:0]), 
       .in1  (tlu_restore_npc_w1[48:0]),
       .sel0 (~tlu_restore_pc_sel_w1),  
       .sel1 (tlu_restore_pc_sel_w1),
       .dout (trap_npc_w1[48:0])
);           
//
dff_s #(49) dff_trap_npc_w2 (
    .din (trap_npc_w1[48:0]), 	
    .q   (trap_npc_w2[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_ifu_trapnpc_w2[48:0] = trap_npc_w2[48:0];

//--------------------------------------------------------------------------------
// Recovery PC and NPC selection 
//--------------------------------------------------------------------------------
// On done, npc will become pc. 
// modified for timing
//
dff_s #(47) dff_tsa0_pc_w (
    .din (tsa0_pc_m[46:0]), 	
    .q   (tsa0_pc_w[46:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(49) dff_ifu_pc_w (
    .din (ifu_tlu_pc_m[48:0]), 	
    .q   (ifu_pc_w[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux3ds #(49) mux_pc_new_w (
       .in0  ({tsa0_pc_w[46:0], 2'b00}), 	
	   .in1  ({tsa1_npc_w[46:0], 2'b00}),
	   .in2  (ifu_pc_w[48:0]),
       .sel0 (tlu_true_pc_sel_w[0]),  	
	   .sel1 (tlu_true_pc_sel_w[1]),
	   .sel2 (tlu_true_pc_sel_w[2]),
       .dout (pc_new_w[48:0])
); 

assign tlu_pc_new_w[48:0] = pc_new_w[48:0];

//
// On done, npc will become pc. 
// On done, npc will stay npc. The valid to the IFU will
// not be signaled along with npc for a done. 
// modified for timing
dff_s #(47) dff_tsa1_npc_w (
    .din (tsa1_npc_m[46:0]), 	
    .q   (tsa1_npc_w[46:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds #(49) mux_npc_new_w (
       .in0  ({tsa1_npc_w[46:0],2'b00}), 	
       .in1  (ifu_npc_w[48:0]),
       .sel0 (~tlu_true_pc_sel_w[2]),  	
       .sel1 (tlu_true_pc_sel_w[2]),
       .dout (npc_new_w[48:0])
); 

assign tlu_npc_new_w[48:0] = npc_new_w[48:0];

//--------------------------------------------------------------------------------
// PIC trap experiment 
//--------------------------------------------------------------------------------

// added for bug 4785
assign local_rst = tlu_rst;

dffr_s dffr_tlu_exu_pic_onebelow_m (
   .din (tlu_pic_onebelow_e),
   .q   (tlu_pic_onebelow_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

dffr_s dffr_tlu_exu_pic_twobelow_m (
   .din (tlu_pic_twobelow_e),
   .q   (tlu_pic_twobelow_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign tlu_exu_pic_onebelow_m = 
           tlu_pic_onebelow_m & tlu_pic_cnt_en_m;

assign tlu_exu_pic_twobelow_m = 
           tlu_pic_twobelow_m & tlu_pic_cnt_en_m;

/*
assign pic_onebelow_e[0] = 
       tlu_thread_inst_vld_w2[0]? pich_twobelow_flg[0]: pich_onebelow_flg[0];
assign pic_onebelow_e[1] = 
       tlu_thread_inst_vld_w2[1]? pich_twobelow_flg[1]: pich_onebelow_flg[1];
assign pic_onebelow_e[2] = 
       tlu_thread_inst_vld_w2[2]? pich_twobelow_flg[2]: pich_onebelow_flg[2];
assign pic_onebelow_e[3] = 
       tlu_thread_inst_vld_w2[3]? pich_twobelow_flg[3]: pich_onebelow_flg[3];

assign tlu_pic_onebelow_e = 
           (tlu_thrd_rsel_e[0]) ? pic_onebelow_e[0]:
           (tlu_thrd_rsel_e[1]) ? pic_onebelow_e[1]:
           (tlu_thrd_rsel_e[2]) ? pic_onebelow_e[2]:
            pic_onebelow_e[3];

assign pic_twobelow_e[0] = 
       tlu_thread_inst_vld_w2[0]? pich_threebelow_flg[0]: pich_twobelow_flg[0];
assign pic_twobelow_e[1] = 
       tlu_thread_inst_vld_w2[1]? pich_threebelow_flg[1]: pich_twobelow_flg[1];
assign pic_twobelow_e[2] = 
       tlu_thread_inst_vld_w2[2]? pich_threebelow_flg[2]: pich_twobelow_flg[2];
assign pic_twobelow_e[3] = 
       tlu_thread_inst_vld_w2[3]? pich_threebelow_flg[3]: pich_twobelow_flg[3];

assign tlu_pic_twobelow_e = 
           (tlu_thrd_rsel_e[0]) ? pic_twobelow_e[0]:
           (tlu_thrd_rsel_e[1]) ? pic_twobelow_e[1]:
           (tlu_thrd_rsel_e[2]) ? pic_twobelow_e[2]:
            pic_twobelow_e[3];
*/

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_mmu_ctl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	MMU Control - I & D.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================






































































































































































































































































































































































































































































































































































































////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module tlu_mmu_ctl ( /*AUTOARG*/
   // Outputs
   dmmu_any_sfsr_wr, dmmu_sfsr_wr_en_l, dmmu_sfar_wr_en_l, 
   immu_any_sfsr_wr, immu_sfsr_wr_en_l, immu_tsb_rd_en, tlu_tte_tag_g, 
   tlu_dtlb_rw_index_vld_g,  tlu_dtlb_rw_index_g, 
   tlu_dtlb_data_rd_g, tlu_dtlb_tag_rd_g, tlu_itlb_rw_index_vld_g, 
   tlu_itlb_wr_vld_g, itlb_wr_vld_g, tlu_itlb_rw_index_g, 
   tlu_itlb_data_rd_g, tlu_itlb_tag_rd_g, tlu_idtsb_8k_ptr, 
   tlu_dtlb_invalidate_all_g, tlu_itlb_invalidate_all_g, tlu_slxa_thrd_sel, 
   tlu_lsu_ldxa_tid_w2, tlu_itlb_dmp_vld_g, 
   tlu_itlb_dmp_all_g, tlu_itlb_dmp_pctxt_g, tlu_itlb_dmp_actxt_g, 
   tlu_itlb_dmp_nctxt_g, tlu_dtlb_dmp_vld_g, tlu_dtlb_dmp_all_g, 
   tlu_dtlb_dmp_pctxt_g, tlu_dtlb_dmp_sctxt_g, tlu_dtlb_dmp_nctxt_g, 
   tlu_dtlb_dmp_actxt_g, tlu_idtlb_dmp_thrid_g, tlu_dmp_key_vld_g, 
   tlu_int_asi_load, tlu_int_asi_store, tlu_int_asi_thrid, 
   tlu_int_asi_vld, tlb_access_rst_l, 
   tlu_lsu_stxa_ack, tlu_lsu_stxa_ack_tid, mra_wr_ptr, mra_rd_ptr, 
   mra_wr_vld, mra_rd_vld, tag_access_wdata_sel, 
   tlu_admp_key_sel, mra_byte_wen,
   tlu_tte_wr_pid_g, tlu_lsu_ldxa_async_data_vld, tlu_tte_real_g, 
   tlu_ldxa_l1mx1_sel, tlu_ldxa_l1mx2_sel, tlu_ldxa_l2mx1_sel, 
   lsu_ifu_inj_ack, tlu_tlb_tag_invrt_parity,  tlu_tlb_data_invrt_parity, 
   tlu_sun4r_tte_g, so, lsu_exu_ldxa_m, tlu_lng_ltncy_en_l, 
   tlu_tag_access_ctxt_sel_m, tlu_tsb_rd_ps0_sel, tlu_tlb_access_en_l_d1,

   tlu_dtlb_csm_rd_g,tlu_itlb_csm_rd_g, 
   tlu_itlb_wr_csm_sel_g, tlu_dtlb_wr_csm_sel_g,

   // Inputs
   ifu_lsu_ld_inst_e, ifu_lsu_st_inst_e, spu_tlu_rsrv_illgl_m,
   lsu_tlu_dmmu_miss_g, 
   tlu_dtsb_split_w2, tlu_dtsb_size_w2, tlu_dtag_access_w2, tlu_itsb_split_w2, 
   tlu_itsb_size_w2, tlu_ctxt_cfg_w2, lsu_tlu_st_rs3_data_g, 
   lsu_tlu_st_rs3_data_b48_g, lsu_tlu_st_rs3_data_b12t0_g, 
   ifu_tlu_immu_miss_m, ifu_lsu_thrid_s, 
   ifu_lsu_alt_space_e, lsu_tlu_dtlb_done, 
   ifu_tlu_itlb_done, lsu_tlu_tlb_asi_state_m, lsu_tlu_tlb_ldst_va_m, 
   lsu_tlu_tlb_ld_inst_m, lsu_tlu_tlb_st_inst_m, 
   lsu_tlu_tlb_access_tid_m, dmmu_sfsr_trp_wr, 
   immu_sfsr_trp_wr, lsu_tlu_daccess_excptn_g, 
   lsu_tlu_daccess_prot_g, 
   lsu_pid_state0, lsu_pid_state1, lsu_pid_state2, lsu_pid_state3, 
   lsu_tlu_nucleus_ctxt_m, lsu_tlu_tte_pg_sz_g, ifu_lsu_error_inj, 
   ifu_tlu_alt_space_d, ifu_lsu_imm_asi_d, 
   ifu_lsu_memref_d, lsu_asi_reg0, lsu_asi_reg1, lsu_asi_reg2, 
   lsu_asi_reg3, exu_mmu_early_va_e, rclk, arst_l, grst_l,
   si,se,ifu_tlu_flush_m,tlu_mmu_early_flush_pipe_w,lsu_mmu_early_flush_w,
   tlu_tag_access_ctxt_g, tlu_lsu_tl_zero, 
   exu_tlu_va_oor_jl_ret_m, exu_tlu_va_oor_m, tlu_lsu_pstate_am, tlu_tsb_base_w2_d1,
   lsu_mmu_flush_pipe_w, ifu_tlu_inst_vld_m, ifu_mmu_trap_m, ffu_tlu_ill_inst_m,
   exu_lsu_priority_trap_m, sehold, rst_tri_en, tlu_itag_acc_sel_g, lsu_mmu_defr_trp_taken_g,
   ifu_tlu_priv_violtn_m 
   ) ;	


/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics

input                   ifu_lsu_ld_inst_e;      // inst_is_load (src-decode)
input                   ifu_lsu_st_inst_e;      // inst is store (src-decode)
input                   lsu_tlu_dmmu_miss_g ;   // ld/st misses in dtlb.
input			spu_tlu_rsrv_illgl_m ; 

input			tlu_itag_acc_sel_g ;
input			lsu_mmu_defr_trp_taken_g ;

// The timing on these signals can be changed to any earlier stage.
// For both SPARC_HPV_EN and non-SPARC_HPV_EN - tsb,tag-access 
// dtsb maps to ps0. itsb maps to ps1.
input  [47:13]         	tlu_tsb_base_w2_d1 ;
//input  [47:13]         	tlu_dtsb_base_w2 ;
input                  	tlu_dtsb_split_w2 ;
input  [3:0]           	tlu_dtsb_size_w2 ;       
input  [47:13]         	tlu_dtag_access_w2 ;  	// used to represent both i/d.
//input  [47:13]         	tlu_itsb_base_w2 ;
input                  	tlu_itsb_split_w2 ;
input  [3:0]           	tlu_itsb_size_w2 ;       

// For SPARC_HPV_EN - BEGIN
input  [5:0] 		tlu_ctxt_cfg_w2 ;	// i/d context zero/non-zero config.
//input  			tlu_tag_access_nctxt_g ;// tag-access contains nucleus context.
// For SPARC_HPV_EN - END

input   [62:61]         lsu_tlu_st_rs3_data_g ;	    // Page Size (1,0) bits of TTE
input            	lsu_tlu_st_rs3_data_b48_g ; // Page Size (2)   bits of TTE
//input   [2:0]           lsu_tlu_st_rs3_data_b10t8_g ; // ps1 of ctxt-cfg
input   [12:0]          lsu_tlu_st_rs3_data_b12t0_g ; 
//input   [2:0]           lsu_tlu_st_rs3_data_b2t0_g ; // sun4v tte size
input			ifu_tlu_immu_miss_m ;
input   [1:0]           ifu_lsu_thrid_s ;   	// Thread id.
input			ifu_lsu_alt_space_e ;	// alt-space access
input                   lsu_tlu_dtlb_done ; // dtlb rd/wr/dmp complete
input            	ifu_tlu_itlb_done ; // itlb rd/wr/dmp complete
//input			int_tlu_asi_data_vld ;	// asi return vld for int blk
//input			int_tlu_ldxa_illgl_va ;	// int asi has illgl va
input  [7:0]           	lsu_tlu_tlb_asi_state_m ;
input  [(6 + 4):0]           lsu_tlu_tlb_ldst_va_m ;
input                  	lsu_tlu_tlb_ld_inst_m ;
input                  	lsu_tlu_tlb_st_inst_m ;
input  [1:0]           	lsu_tlu_tlb_access_tid_m ;
input		   	ifu_tlu_flush_m ;
input		   	tlu_mmu_early_flush_pipe_w ;
input		   	lsu_mmu_early_flush_w ;
input  	[3:0]   	dmmu_sfsr_trp_wr ;
input  	[3:0]   	immu_sfsr_trp_wr ;  
//input          		tlu_inst_vld_m ;        // qualified inst vld
input			lsu_tlu_daccess_excptn_g ; // data access exception 
input			lsu_tlu_daccess_prot_g ;// data access protection
						// obsolete with SPARC_HPV_EN !!!
//input           	lsu_tlu_asi_rd_unc ;    // uncorrectable error for tlb rd
input  	[2:0]   	lsu_pid_state0 ;        // pid thread0 ; global use
input  	[2:0]   	lsu_pid_state1 ;        // pid thread1 ; global use
input  	[2:0]   	lsu_pid_state2 ;        // pid thread2 ; global use
input  	[2:0]   	lsu_pid_state3 ;        // pid thread3 ; global use

input			lsu_tlu_nucleus_ctxt_m ;// access is nucleus context
input 	[2:0] 		lsu_tlu_tte_pg_sz_g ;	// page-size of tte 

input   [3:0]           ifu_lsu_error_inj ;     // inject parity error into tlb

// BEGIN - MMU_ASI_RD_CHANGE
// !! early va required.
input			ifu_tlu_alt_space_d ;	// alt space access - new;_e exists
//input			ifu_lsu_imm_asi_vld_d ; // imm asi is vld - current
input	[8:0]		ifu_lsu_imm_asi_d ;	// imm asi - current
input                   ifu_lsu_memref_d;	// ld/st - prefer ld_inst_e;
input   [7:0]   	lsu_asi_reg0 ;          // asi state - thread0
input   [7:0]   	lsu_asi_reg1 ;          // asi state - thread1
input   [7:0]   	lsu_asi_reg2 ;          // asi state - thread2
input   [7:0]   	lsu_asi_reg3 ;          // asi state - thread3
//input	[1:0]		ifu_tlu_thrid_d ;       // thread id
input 	[7:0]  		exu_mmu_early_va_e;	// early va from exu
// END - MMU_ASI_RD_CHANGE

input [12:0]          tlu_tag_access_ctxt_g ;

input [3:0] tlu_lsu_tl_zero;   // trap level is zero.
//input           exu_tlu_ttype_vld_m;    // exu src ttype vld
input           exu_tlu_va_oor_jl_ret_m;
input           exu_tlu_va_oor_m;
input [3:0] tlu_lsu_pstate_am; 

input		lsu_mmu_flush_pipe_w ;
input		ifu_tlu_inst_vld_m ;
input		ifu_mmu_trap_m ; 
input		ffu_tlu_ill_inst_m ;
input		exu_lsu_priority_trap_m ; // fill/ue
input		ifu_tlu_priv_violtn_m ;

input		rclk ;
input		arst_l, grst_l;
input		si,se;
input		sehold ;
input		rst_tri_en ;

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics

output			dmmu_any_sfsr_wr ;
output	[3:0]		dmmu_sfsr_wr_en_l ; 
output	[3:0]		dmmu_sfar_wr_en_l ;
//output	[3:0]		dmmu_tsb_wr_en ;
//output	[3:0]		dmmu_tsb_rd_en ;
//output	[3:0]		dmmu_tag_access_wr_en ;
//output	[3:0]		dmmu_tag_access_rd_en ;
//output			dmmu_tag_read_en ; 

output			immu_any_sfsr_wr ; 
output	[3:0]		immu_sfsr_wr_en_l ; 
//output	[3:0]		immu_tsb_wr_en ;
output	[3:0]		immu_tsb_rd_en ;
//output	[3:0]		immu_tag_access_wr_en ;
//output	[3:0]		immu_tag_access_rd_en ;
//output			immu_tag_read_en ; 

// tlb/itlb related control can potentially be
// made g-stage.
output  [2:0]          	tlu_tte_tag_g ;
output			tlu_dtlb_rw_index_vld_g ;
output	[5:0]		tlu_dtlb_rw_index_g ;
output			tlu_dtlb_data_rd_g ;
output			tlu_dtlb_tag_rd_g ;
output			tlu_itlb_rw_index_vld_g ;
output			tlu_itlb_wr_vld_g ;
output			itlb_wr_vld_g ;
output	[5:0]		tlu_itlb_rw_index_g ;
output			tlu_itlb_data_rd_g ;
output			tlu_itlb_tag_rd_g ;
output	[47:0]		tlu_idtsb_8k_ptr ;	// maps to ps0/ps1 ptr. require only 1.

output			tlu_dtlb_csm_rd_g ;
output			tlu_itlb_csm_rd_g ;
output      	tlu_itlb_wr_csm_sel_g; 
output      	tlu_dtlb_wr_csm_sel_g; 


output			tlu_dtlb_invalidate_all_g ;
output			tlu_itlb_invalidate_all_g ;

output  [3:0]           tlu_slxa_thrd_sel ;

output	[1:0]		tlu_lsu_ldxa_tid_w2 ;

output			tlu_itlb_dmp_vld_g ;
output			tlu_itlb_dmp_all_g ;
output			tlu_itlb_dmp_pctxt_g ;
output			tlu_itlb_dmp_actxt_g ;
output			tlu_itlb_dmp_nctxt_g ;
output			tlu_dtlb_dmp_vld_g ;
output			tlu_dtlb_dmp_all_g ;
output			tlu_dtlb_dmp_pctxt_g ;
output			tlu_dtlb_dmp_sctxt_g ;
output			tlu_dtlb_dmp_nctxt_g ;
output			tlu_dtlb_dmp_actxt_g ;
output	[1:0]		tlu_idtlb_dmp_thrid_g ;
output  [4:0]           tlu_dmp_key_vld_g ;
output                	tlu_int_asi_load; 
output                	tlu_int_asi_store; 
output 	[1:0]          	tlu_int_asi_thrid;
output                	tlu_int_asi_vld; 
//output			tlb_access_en_l ;
output			tlb_access_rst_l ;
output			tlu_lsu_stxa_ack ;	   // write to tlb is complete.
output	 [1:0]		tlu_lsu_stxa_ack_tid ;
output   [3:0]          mra_wr_ptr ;    // wr ptr for mra
output   [3:0]          mra_rd_ptr ;    // thrd id for rd.
output                  mra_wr_vld ;    // write pointer vld
output                  mra_rd_vld ;    // read vld
output	 [19:0]		mra_byte_wen ;
output	 [2:0]		tag_access_wdata_sel ;
output			tlu_admp_key_sel ;
//output			tlu_mmu_sync_data_excp_g ;	// sync asi related data excp
//output			tlu_lsu_dtlb_rd_unc ;		// unc error for tlb rd

//output   [3:0]          tlu_dldxa_mx2_sel ;		// obsolete for SPARC_HPV_EN
//output   [2:0]          tlu_dldxa_mx3_sel ;		// obsolete for SPARC_HPV_EN
//output   [2:0]          tlu_dldxa_fmx_sel ;		// obsolete for SPARC_HPV_EN
//output   [3:0]          tlu_ildxa_mx1_sel ;		// obsolete for SPARC_HPV_EN
//output   [2:0]          tlu_ildxa_fmx_sel ;		// obsolete for SPARC_HPV_EN

output	 [2:0]		tlu_tte_wr_pid_g ;	// thread selected pid
output                  tlu_lsu_ldxa_async_data_vld ;   // tlu_lsu_ldxa_data_vld is for async op.

output   		tlu_tte_real_g ;                // tte is real

output  [3:0]   	tlu_ldxa_l1mx1_sel ;    // mmu ldxa level1 mx1 sel
output  [3:0]   	tlu_ldxa_l1mx2_sel ;    // mmu ldxa level1 mx2 sel
output  [2:0]   	tlu_ldxa_l2mx1_sel ;    // mmu ldxa level2 mx1 sel

output  [3:0]           lsu_ifu_inj_ack ;       // ack for tlb error injection.
output			tlu_tlb_tag_invrt_parity ;	// invert parity on write tag.
output			tlu_tlb_data_invrt_parity ;	// invert parity on write data.

output			tlu_sun4r_tte_g ;	// sun4r vs. sun4v tte.

output			lsu_exu_ldxa_m ;

output			tlu_lng_ltncy_en_l ;

output	[2:0]		tlu_tag_access_ctxt_sel_m ;

output			tlu_tsb_rd_ps0_sel ;

output			tlu_tlb_access_en_l_d1 ;

output			so ;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

reg			dmmu_invalidate_all_en_m ;
reg			immu_invalidate_all_en_m ;
reg 	dmmu_decode_asi58_e ;
reg 	immu_decode_asi50_e ;
reg	dmmu_8k_ptr_e,dmmu_64k_ptr_e,dmmu_direct_ptr_e ;
reg	immu_8k_ptr_e,immu_64k_ptr_e;
reg	dmmu_zctxt_ps0_tsb_e, dmmu_zctxt_ps1_tsb_e ;
reg	dmmu_nzctxt_ps0_tsb_e, dmmu_nzctxt_ps1_tsb_e ;
reg	dmmu_zctxt_cfg_e, dmmu_nzctxt_cfg_e ;
reg	immu_zctxt_ps0_tsb_e, immu_zctxt_ps1_tsb_e ;
reg	immu_nzctxt_ps0_tsb_e, immu_nzctxt_ps1_tsb_e ;
reg	immu_zctxt_cfg_e, immu_nzctxt_cfg_e ;


reg			dmmu_csm_in_en_m,dmmu_csm_access_en_m;
wire		dmmu_csm_in_wr_en, dmmu_csm_access_wr_en ; 
wire		dmmu_csm_access_rd_en ;
wire		immu_csm_in_wr_en, immu_csm_access_wr_en ;
wire	    itlb_csm_rd_pend;
wire	    dtlb_csm_rd_pend;
wire		dmmu_csm_in_en, dmmu_csm_access_en ; 
wire	    immu_csm_in_en, immu_csm_access_en ; 

reg			dmmu_data_in_en_m,dmmu_data_access_en_m;
reg			dmmu_tag_read_en_m,dmmu_demap_en_m;

wire			sehold_d1 ;
wire			tlb_access_en_l ;
wire			dmmu_sync_illgl_va_g ;
wire			dmmu_async_supported_asi,dmmu_async_illgl_va_g ; 	
wire			immu_sync_illgl_va_g ;
wire			immu_async_supported_asi,immu_async_illgl_va_g ;
wire			ld_inst_m,st_inst_m ;
wire			ld_inst_g,st_inst_g ;
wire [3:0] 		tsb_size ;
wire			tsb_split ;
//wire [47:13]		tsb_base ;
wire [47:13]		tag_access ;
/*wire 	tsb_sz_8k_b0_mx1_out,tsb_sz_8k_b1_mx1_out,tsb_sz_8k_b2_mx1_out,tsb_sz_8k_b3_mx1_out;
wire 	tsb_sz_8k_b4_mx1_out,tsb_sz_8k_b5_mx1_out,tsb_sz_8k_b6_mx1_out,tsb_sz_8k_b7_mx1_out;
wire 	tsb_sz_8k_b0_mx2_out,tsb_sz_8k_b1_mx2_out,tsb_sz_8k_b2_mx2_out,tsb_sz_8k_b3_mx2_out;
wire 	tsb_sz_8k_b4_mx2_out,tsb_sz_8k_b5_mx2_out,tsb_sz_8k_b6_mx2_out,tsb_sz_8k_b7_mx2_out;
wire 	tsb_sz_8k_b0_mx3_out,tsb_sz_8k_b1_mx3_out,tsb_sz_8k_b2_mx3_out,tsb_sz_8k_b3_mx3_out;
wire 	tsb_sz_8k_b4_mx3_out,tsb_sz_8k_b5_mx3_out,tsb_sz_8k_b6_mx3_out,tsb_sz_8k_b7_mx3_out;
wire 	tsb_sz_64k_b0_mx1_out,tsb_sz_64k_b1_mx1_out,tsb_sz_64k_b2_mx1_out,tsb_sz_64k_b3_mx1_out;
wire 	tsb_sz_64k_b4_mx1_out,tsb_sz_64k_b5_mx1_out,tsb_sz_64k_b6_mx1_out,tsb_sz_64k_b7_mx1_out;
wire 	tsb_sz_64k_b0_mx2_out,tsb_sz_64k_b1_mx2_out,tsb_sz_64k_b2_mx2_out,tsb_sz_64k_b3_mx2_out;
wire 	tsb_sz_64k_b4_mx2_out,tsb_sz_64k_b5_mx2_out,tsb_sz_64k_b6_mx2_out ;
wire 	tsb_sz_64k_b0_mx3_out,tsb_sz_64k_b1_mx3_out,tsb_sz_64k_b2_mx3_out,tsb_sz_64k_b3_mx3_out;
wire 	tsb_sz_64k_b4_mx3_out ;*/
wire	dtlb_rw_index_vld_g,dtlb_wr_vld_g ;
wire		dmmu_data_in_wr_en, dmmu_data_access_wr_en ; 
wire		dmmu_tag_read_rd_en, dmmu_data_access_rd_en ;
wire		immu_data_in_wr_en, immu_data_access_wr_en ;
wire		immu_data_access_rd_en, immu_tag_read_rd_en ;
wire		itlb_rw_index_vld_g,itlb_wr_vld_g;
wire		tlu_ldxa_data_vld ;
wire	tlu_dldxa_data_vld ;
wire	[1:0]	thrid_d,thrid_e,thrid_m,thrid_g ;
wire		thread0_sel_g, thread1_sel_g ;
wire		thread2_sel_g, thread3_sel_g ;
wire		alt_space_m, alt_space_g ;
wire		immu_miss_g;
wire		ddemap_by_page,ddemap_by_ctxt,ddemap_all;
wire		idemap_by_page,idemap_by_ctxt,idemap_all;
wire		demap_pctxt,demap_sctxt,demap_nctxt ;
//wire		lsu_tlu_page_ebit_g ;
wire		ddemap_vld, idemap_vld ;
wire	[2:0]   tlu_tte_tag_g ;
wire		demap_resrv ;
wire	itlb_wr_pend,itlb_data_rd_pend,itlb_tag_rd_pend ;
wire	dtlb_wr_pend,dtlb_data_rd_pend,dtlb_tag_rd_pend ;
wire	tlb_access_en ;
wire	tlb_access_rst ;
wire	dmra_wr_g, imra_wr_g ;
wire			dmmu_data_in_en, dmmu_data_access_en, dmmu_tag_read_en, dmmu_demap_en ; 
wire			immu_data_in_en, immu_data_access_en, immu_tag_read_en, immu_demap_en ; 
wire	immu_invalidate_all_en,dmmu_invalidate_all_en ;
wire	tlb_wr_vld_g ;
wire	tlb_admp_en, tlb_admp_rst, tlb_wr_rst ;
wire	tlb_admp_mode,tlb_write_mode ;
wire	tlb_ldst_inst_m ;
wire 	tlb_admp_mode_d1 ;
wire	itlb_wr_vld_unmsked,dtlb_wr_vld_unmsked;
wire	idemap_pend, ddemap_pend ;
wire	itlb_tag_rd_en, dtlb_tag_rd_en ;
wire	[3:0]	dsfsr_asi_wr_en ;
wire	[3:0]	isfsr_asi_wr_en ;
wire	[(6 + 4):3]	tlb_ldst_va_g ;
wire		tlb_ld_inst_g,tlb_st_inst_g ;
wire		tlb_ld_inst_unflushed,tlb_st_inst_unflushed ;
wire	[1:0]	tlb_access_tid_g ;
wire		inst_vld_g ;
wire	st_inst_unflushed, ld_inst_unflushed ;
wire	imra_lng_lat_rd,dmra_lng_lat_rd ;
wire	iside_mra_access_rd, iside_mra_access_wr ;
wire	[1:0]	mra_raccess_tid ;
//wire	dmmu_sync_rd_only_asi_g ;
//wire	immu_sync_rd_only_asi_g ;
wire	dptr0_pg64k_en,dptr1_pg64k_en,dptr2_pg64k_en,dptr3_pg64k_en;
wire	dptr0_pg64k_vld,dptr1_pg64k_vld,dptr2_pg64k_vld,dptr3_pg64k_vld;
//wire 	dmmu_direct_ptr_rd_en ;
wire    tlu_dtlb_rd_done ;
wire	dmmu_ctxt_cfg_en, immu_ctxt_cfg_en ;
//wire	dmmu_ctxt_cfg_rd_en ;
wire	dacc_prot_ps1_match ;
wire	tacc_nctxt, itacc_nctxt, dtacc_nctxt ;	// for in-pipe access
wire	tacc_anctxt, itacc_anctxt, dtacc_anctxt ;// for async access
wire	thread0_async_g,thread1_async_g,thread2_async_g ;
wire	sun4r_tte_g ;
wire	dmmu_decode_asi58_m, immu_decode_asi50_m ;
wire	dmmu_zctxt_ps0_tsb_m, dmmu_zctxt_ps1_tsb_m,
	dmmu_nzctxt_ps0_tsb_m, dmmu_nzctxt_ps1_tsb_m,
	dmmu_zctxt_cfg_m, dmmu_nzctxt_cfg_m,
	immu_zctxt_ps0_tsb_m, immu_zctxt_ps1_tsb_m,
	immu_nzctxt_ps0_tsb_m, immu_nzctxt_ps1_tsb_m,
	immu_zctxt_cfg_m, immu_nzctxt_cfg_m ;
wire	dmmu_sync_fsr_en, dmmu_sync_far_en,
	dmmu_zctxt_ps0_tsb_en, dmmu_zctxt_ps1_tsb_en,
	dmmu_nzctxt_ps0_tsb_en, dmmu_nzctxt_ps1_tsb_en,
	dmmu_zctxt_cfg_en, dmmu_nzctxt_cfg_en,
	immu_sync_fsr_en,
	immu_zctxt_ps0_tsb_en, immu_zctxt_ps1_tsb_en,
	immu_nzctxt_ps0_tsb_en, immu_nzctxt_ps1_tsb_en,
	immu_zctxt_cfg_en, immu_nzctxt_cfg_en ;
wire	dmmu_tag_target_en_m,dmmu_tag_access_en_m;
wire	immu_tag_target_en_m,immu_tag_access_en_m;
wire	dmmu_tag_access_en;
wire	immu_tag_access_en;
wire	dmmu_8k_ptr_en_m,dmmu_64k_ptr_en_m,dmmu_direct_ptr_en_m ;
wire	immu_8k_ptr_en_m,immu_64k_ptr_en_m ;
wire	dmmu_sync_fsr_en_m, dmmu_sync_far_en_m,
	dmmu_zctxt_ps0_tsb_en_m, dmmu_zctxt_ps1_tsb_en_m,
	dmmu_nzctxt_ps0_tsb_en_m, dmmu_nzctxt_ps1_tsb_en_m,
	dmmu_zctxt_cfg_en_m, dmmu_nzctxt_cfg_en_m,
	immu_sync_fsr_en_m,
	immu_zctxt_ps0_tsb_en_m, immu_zctxt_ps1_tsb_en_m,
	immu_nzctxt_ps0_tsb_en_m, immu_nzctxt_ps1_tsb_en_m,
	immu_zctxt_cfg_en_m, immu_nzctxt_cfg_en_m ;
wire	thread0_d,thread1_d,thread2_d,thread3_d;
wire 	thread0_e, thread1_e, thread2_e, thread3_e ;
wire [7:0]	asi_state_d, asi_state_e ;
wire	memref_e,memref_m ;
wire [7:0] early_va_m ;
wire	idmra_rd_d ;
wire idmra_nzctxt_rd_d ;
wire idmra_fault_rd_d ;
wire	dmmu_tsb_en_m, dmmu_ctxt_cfg_en_m ; 
wire	immu_tsb_en_m, immu_ctxt_cfg_en_m ; 
wire	tlu_ildxa_data_vld ;
wire	dmmu_direct_8kptr_sel_g ;	// direct ptr should select 8k ptr

	wire	dmmu_tsb_en ;
	wire	immu_tsb_en ;

wire	mra_field1_en, mra_field2_en ; 
wire	mra_field3_en, mra_field4_en ; 


//=========================================================================================
//      RESET/CLK
//=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Early Flush Generation
//=========================================================================================




wire	ifu_tlu_flush_w ;
dff_s  #(1) stg_w (
        .din    (ifu_tlu_flush_m),
        .q      (ifu_tlu_flush_w),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

wire	local_flush_w ;

assign	local_flush_w = 
	ifu_tlu_flush_w 		|	// ifu flush 
	lsu_mmu_defr_trp_taken_g	|	// defr trp 
	tlu_mmu_early_flush_pipe_w 	| 	// tlu flush
	lsu_mmu_early_flush_w 		;	// lsu early flush

wire    flush_w_inst_vld_m ;
assign  flush_w_inst_vld_m =
        ifu_tlu_inst_vld_m &
        ~(lsu_mmu_flush_pipe_w & (thrid_m[1:0] == thrid_g[1:0])) ; // really lsu_flush_pipe_w

dff_s  stgw_ivld (
        .din    (flush_w_inst_vld_m),
        .q      (inst_vld_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Bug 4183
wire	priority_squash_m, priority_squash_g ;
assign	priority_squash_m = 
ifu_mmu_trap_m | ffu_tlu_ill_inst_m | exu_lsu_priority_trap_m |  spu_tlu_rsrv_illgl_m ; 

wire	trp_vld_m,trp_vld_g ;
assign	trp_vld_m = flush_w_inst_vld_m & ~priority_squash_m ;

dff_s  #(2) sqshstgw (
        .din    ({priority_squash_m,trp_vld_m}),
        .q      ({priority_squash_g,trp_vld_g}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

//=========================================================================================
//	Staging
//=========================================================================================

dff_s  #(2) stg_d (
        .din    (ifu_lsu_thrid_s[1:0]),
        .q      (thrid_d[1:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dff_s  #(2) stg_e (
        .din    (thrid_d[1:0]),
        .q      (thrid_e[1:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dff_s  #(5) stg_m (
        .din    ({ifu_lsu_ld_inst_e,ifu_lsu_st_inst_e,
		thrid_e[1:0],ifu_lsu_alt_space_e}),
        .q      ({ld_inst_m,st_inst_m,thrid_m[1:0],alt_space_m}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dff_s  #(6) stg_g (
        .din    ({ld_inst_m,st_inst_m,thrid_m[1:0],alt_space_m,ifu_tlu_immu_miss_m}),
        .q      ({ld_inst_unflushed,st_inst_unflushed,thrid_g[1:0],alt_space_g,immu_miss_g}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

// reads are terminated for illegal va case.
assign	ld_inst_g = ld_inst_unflushed & inst_vld_g & ~local_flush_w ;
//assign	ld_inst_g = ld_inst_unflushed & inst_vld_g & ~(dmmu_sync_illgl_va_g | immu_sync_illgl_va_g) & ;
// writes are terminated for illegal va case.
assign	st_inst_g = st_inst_unflushed & inst_vld_g & ~local_flush_w & 
			~(dmmu_sync_illgl_va_g | immu_sync_illgl_va_g) ;
//assign	st_inst_g = st_inst_unflushed & inst_vld_g & ~(dmmu_sync_illgl_va_g | immu_sync_illgl_va_g);

assign	thread0_sel_g =  ~thrid_g[1] & ~thrid_g[0] ;
assign	thread1_sel_g =  ~thrid_g[1] &  thrid_g[0] ;
assign	thread2_sel_g =   thrid_g[1] & ~thrid_g[0] ;
assign	thread3_sel_g =   thrid_g[1] &  thrid_g[0] ;

assign tlu_slxa_thrd_sel[0] = ~thrid_m[1] & ~thrid_m[0] ;
assign tlu_slxa_thrd_sel[1] = ~thrid_m[1] &  thrid_m[0] ;
assign tlu_slxa_thrd_sel[2] =  thrid_m[1] & ~thrid_m[0] ;
assign tlu_slxa_thrd_sel[3] =  thrid_m[1] &  thrid_m[0] ;

/*dff stgivld_g (
        .din    (tlu_inst_vld_m),
        .q      (inst_vld_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

//=========================================================================================
//	ASI RD DP MUX SELECT
//=========================================================================================

// qualification with vld not required as this dp is used by synchronous ops only
// Need to be made non zero-hot in functional mode

// Decode of bits va[5:4] to distinguish reads.  
wire va_54_eq_0,va_54_eq_1,va_54_eq_2,va_54_eq_3 ;
wire	[2:0]	ldxa_l1mx1_sel_d1 ;
assign va_54_eq_0 = (~early_va_m[5] & ~early_va_m[4]) ;
assign va_54_eq_1 = (~early_va_m[5] &  early_va_m[4]) ;
assign va_54_eq_2 = ( early_va_m[5] & ~early_va_m[4]) ;
assign va_54_eq_3 = ( early_va_m[5] &  early_va_m[4]) ;

// i/d tag-target
// Extend for MacroTest Control.
assign	tlu_ldxa_l1mx1_sel[0] = 
((((dmmu_decode_asi58_m | immu_decode_asi50_m) & va_54_eq_0) & ~sehold_d1) | rst_tri_en) |  
(ldxa_l1mx1_sel_d1[0] & sehold_d1) ;
assign	tlu_ldxa_l1mx1_sel[1] = 
((dmmu_zctxt_ps0_tsb_e | dmmu_nzctxt_ps0_tsb_e | 
immu_zctxt_ps0_tsb_e | immu_nzctxt_ps0_tsb_e) & ~sehold_d1 & ~rst_tri_en) | 
(ldxa_l1mx1_sel_d1[1] & sehold_d1) ;
assign	tlu_ldxa_l1mx1_sel[2] = 
((dmmu_zctxt_ps1_tsb_e | dmmu_nzctxt_ps1_tsb_e |
immu_zctxt_ps1_tsb_e | immu_nzctxt_ps1_tsb_e) & ~sehold_d1 & ~rst_tri_en) |
(ldxa_l1mx1_sel_d1[2] & sehold_d1) ;



// Extend flops to hold selects for MacroTest of MRA.
wire [2:0] ldxa_l1mx1_sel_out ;
dff_s #(3)   l1mx1s_stgd1(
        .din    (tlu_ldxa_l1mx1_sel[2:0]), 
	.q  	(ldxa_l1mx1_sel_out[2:0]),
        .clk 	(clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// scan protection.
assign	ldxa_l1mx1_sel_d1[0] = ldxa_l1mx1_sel_out[0] ;
assign	ldxa_l1mx1_sel_d1[1] = ldxa_l1mx1_sel_out[1] & ~rst_tri_en ;
assign	ldxa_l1mx1_sel_d1[2] = ldxa_l1mx1_sel_out[2] & ~rst_tri_en ;

wire	sehold_out ;
dff_s #(1)   seh_d1 (
        .din    (sehold), 
	.q  	(sehold_out),
        .clk 	(clk),
        .se     (1'b0),       	.si (),          .so ()
        );

assign	sehold_d1 = sehold_out & ~rst_tri_en ;

// i/d tag-access
assign	tlu_ldxa_l1mx1_sel[3] =  ~|tlu_ldxa_l1mx1_sel[2:1];
wire    ldxa_l1mx1_sel3;
// * read timing change.
assign	ldxa_l1mx1_sel3 = 
(dmmu_decode_asi58_m | immu_decode_asi50_m) & va_54_eq_3 & ~rst_tri_en ;

// d sync-fsr
// * read timing change.
wire	dmmu_sync_fsr_m_sel,dmmu_sync_far_m_sel,immu_sync_fsr_m_sel;
assign	dmmu_sync_fsr_m_sel	= (dmmu_decode_asi58_m & va_54_eq_1) | rst_tri_en ;
assign	dmmu_sync_far_m_sel	= (dmmu_decode_asi58_m & va_54_eq_2) & ~rst_tri_en ;
assign	immu_sync_fsr_m_sel	= (immu_decode_asi50_m & va_54_eq_1) & ~rst_tri_en ;
assign	tlu_ldxa_l1mx2_sel[0] = dmmu_sync_fsr_m_sel ;
// d sync-far
// * read timing change.
assign	tlu_ldxa_l1mx2_sel[1] = dmmu_sync_far_m_sel ;
// i sync-fsr
assign	tlu_ldxa_l1mx2_sel[2] = immu_sync_fsr_m_sel ;
assign	tlu_ldxa_l1mx2_sel[3] = ~|tlu_ldxa_l1mx2_sel[2:0];
wire    ldxa_l1mx2_sel3;
assign	ldxa_l1mx2_sel3 = (dmmu_zctxt_cfg_m | dmmu_nzctxt_cfg_m |
			  immu_zctxt_cfg_m | immu_nzctxt_cfg_m) & ~rst_tri_en ;

assign	tlu_ldxa_l2mx1_sel[0] = 
|{ldxa_l1mx1_sel3,ldxa_l1mx1_sel_d1[2:1],(tlu_ldxa_l1mx1_sel[0] & ~rst_tri_en)} ;
assign	tlu_ldxa_l2mx1_sel[1] = |{ldxa_l1mx2_sel3,tlu_ldxa_l1mx2_sel[2:0]} ;
assign	tlu_ldxa_l2mx1_sel[2] = ~|tlu_ldxa_l2mx1_sel[1:0];

//=========================================================================================
//	MRA RD/WRITE
//=========================================================================================

wire	[3:0]	isfsr_trp_wr ;
wire	flush_mmuasi_wr ;
assign	flush_mmuasi_wr = ifu_tlu_flush_w | lsu_mmu_defr_trp_taken_g ; // Bug 5196
assign	isfsr_trp_wr[0] = immu_sfsr_trp_wr[0] & ~flush_mmuasi_wr ;
assign	isfsr_trp_wr[1] = immu_sfsr_trp_wr[1] & ~flush_mmuasi_wr ;
assign	isfsr_trp_wr[2] = immu_sfsr_trp_wr[2] & ~flush_mmuasi_wr ;
assign	isfsr_trp_wr[3] = immu_sfsr_trp_wr[3] & ~flush_mmuasi_wr ;

wire  tag_access_nctxt_g ;

wire immu_miss_vld_g ;
assign immu_miss_vld_g = immu_miss_g & inst_vld_g ;

// fast-asi read takes precedence over long-latency rd. Can long-latency read get
// starved out ?? Assume memref_d is never x.

assign	dmra_lng_lat_rd = ((dmmu_data_in_en | dmmu_data_access_en | dmmu_csm_in_en | dmmu_csm_access_en) 
                        & tlb_st_inst_g & ~ifu_lsu_memref_d) ;
assign	imra_lng_lat_rd = ((immu_data_in_en | immu_data_access_en | immu_csm_in_en | immu_csm_access_en) 
                        & tlb_st_inst_g & ~ifu_lsu_memref_d) ;




//assign	dmra_lng_lat_rd = ((dmmu_data_in_en | dmmu_data_access_en) & tlb_st_inst_g) ;
//assign	imra_lng_lat_rd = ((immu_data_in_en | immu_data_access_en) & tlb_st_inst_g) ;

wire  dmra_ldst,imra_ldst ;
assign        dmra_ldst = dmmu_tag_access_en | dmmu_tsb_en | dmmu_ctxt_cfg_en ; 
assign        imra_ldst = immu_tag_access_en | immu_tsb_en | immu_ctxt_cfg_en ; 

// sync_far_en no longer written/read
assign	dmra_wr_g = 
	(dmra_ldst & st_inst_g) |
	(lsu_tlu_dmmu_miss_g | lsu_tlu_daccess_excptn_g | lsu_tlu_daccess_prot_g) 
	& trp_vld_g & ~flush_mmuasi_wr ;
	//(lsu_tlu_dmmu_miss_g | lsu_tlu_daccess_excptn_g | lsu_tlu_daccess_prot_g) & inst_vld_g ;
	// Bug 4183
wire	isfsr_trap ;
assign	isfsr_trap = |isfsr_trp_wr[3:0] ;
assign	imra_wr_g = 
	(imra_ldst & st_inst_g) |
	//((immu_tag_access_en | immu_tsb_en | immu_ctxt_cfg_en) & st_inst_g) | 
	(immu_miss_vld_g & ~flush_mmuasi_wr) | isfsr_trap ;

wire	dmra_rw_d ;
assign	iside_mra_access_rd = ((~dmra_rw_d) & ~(imra_lng_lat_rd | dmra_lng_lat_rd))  | imra_lng_lat_rd ;
assign	iside_mra_access_wr = imra_wr_g ;

assign	mra_raccess_tid[1:0] = (dmra_lng_lat_rd | imra_lng_lat_rd) ? tlb_access_tid_g[1:0] : thrid_d[1:0] ;

wire idside_nzctxt_accwr_early_m,idside_nzctxt_accwr_early_g  ;
assign	idside_nzctxt_accwr_early_m =
	((dmmu_nzctxt_cfg_en_m 	 | immu_nzctxt_cfg_en_m     |
	dmmu_nzctxt_ps0_tsb_en_m | immu_nzctxt_ps0_tsb_en_m |
	dmmu_nzctxt_ps1_tsb_en_m | immu_nzctxt_ps1_tsb_en_m) & st_inst_m) ; // tsb/cfg asi wr

dff_s ctacc_stgg (
        .din    (idside_nzctxt_accwr_early_m),
        .q      (idside_nzctxt_accwr_early_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );
	
//wire	idside_nzctxt_access ;
wire	idside_nzctxt_access_rd,idside_nzctxt_access_wr ;
wire	st_wr_g ;

assign	idside_nzctxt_access_wr = 
	((dmmu_tag_access_en	| immu_tag_access_en) 	// tag-access asi write
		& st_inst_unflushed & ~tag_access_nctxt_g)	 |
	((lsu_tlu_daccess_excptn_g | lsu_tlu_daccess_prot_g | lsu_tlu_dmmu_miss_g |
	immu_miss_g | (isfsr_trap))		// tag-access exception write 
		& inst_vld_g & ~tag_access_nctxt_g)	 |
	(idside_nzctxt_accwr_early_g & st_wr_g) ; // Bug 4828
	//((dmmu_nzctxt_cfg_en 	| immu_nzctxt_cfg_en 	 |
	//dmmu_nzctxt_ps0_tsb_en 	| immu_nzctxt_ps0_tsb_en |
	//dmmu_nzctxt_ps1_tsb_en 	| immu_nzctxt_ps1_tsb_en) & st_inst_unflushed) ; // tsb/cfg asi wr
assign	idside_nzctxt_access_rd = 
	(idmra_nzctxt_rd_d) 		 |  // => nzctxt rd with decode
	(idmra_fault_rd_d & ~tacc_nctxt) |  // => fault-based rd
	((dmra_lng_lat_rd | imra_lng_lat_rd) & ~tacc_anctxt) ;
// access non zero context levels
		
assign	mra_wr_ptr[3:0]	= {thrid_g[1:0],idside_nzctxt_access_wr,iside_mra_access_wr};	
assign	mra_rd_ptr[3:0]	= {mra_raccess_tid[1:0],idside_nzctxt_access_rd,iside_mra_access_rd};	

assign	mra_wr_vld = dmra_wr_g | imra_wr_g ;
assign	mra_rd_vld = idmra_rd_d | dmra_lng_lat_rd | imra_lng_lat_rd ;

assign	dmmu_ctxt_cfg_en = dmmu_zctxt_cfg_en | dmmu_nzctxt_cfg_en ;
assign	immu_ctxt_cfg_en = immu_zctxt_cfg_en | immu_nzctxt_cfg_en ;
//assign	dmmu_ctxt_cfg_rd_en = (dmmu_zctxt_cfg_en | dmmu_nzctxt_cfg_en) & ld_inst_g ;
//assign	immu_ctxt_cfg_rd_en = (immu_zctxt_cfg_en | immu_nzctxt_cfg_en) & ld_inst_g ;

// Change - with 8 tsbs per thread, tsb can be in any of the 3 fields
// of a line in the mra.
wire	mra_itag_acc_en,mra_dtag_acc_en ;
// Be careful about loading on trap conditions.
assign st_wr_g = st_inst_unflushed & ~local_flush_w ;
assign	mra_itag_acc_en = 
	(immu_tag_access_en & st_wr_g) | immu_miss_g | (isfsr_trap) ;
assign	mra_dtag_acc_en = 
	(dmmu_tag_access_en & st_wr_g) | lsu_tlu_dmmu_miss_g | lsu_tlu_daccess_excptn_g | 
	lsu_tlu_daccess_prot_g ;
assign	mra_field1_en 	= (dmmu_zctxt_ps0_tsb_en  | immu_zctxt_ps0_tsb_en |
			  dmmu_nzctxt_ps0_tsb_en | immu_nzctxt_ps0_tsb_en) & st_wr_g ;
			  // dmmu_nzctxt_ps0_tsb_en | immu_nzctxt_ps0_tsb_en) & st_inst_unflushed ; Bug 3378
assign	mra_field2_en 	= (dmmu_zctxt_ps1_tsb_en  | immu_zctxt_ps1_tsb_en |
			  dmmu_nzctxt_ps1_tsb_en | immu_nzctxt_ps1_tsb_en) & st_wr_g ;
assign	mra_field3_en	= mra_itag_acc_en | mra_dtag_acc_en ;
assign	mra_field4_en 	= (dmmu_ctxt_cfg_en | immu_ctxt_cfg_en) & st_wr_g ;
			  
// for use of rf16x160
assign	mra_byte_wen[19:14] = {6{mra_field1_en}} ;
assign	mra_byte_wen[13:8]  = {6{mra_field2_en}} ;
assign	mra_byte_wen[7:2]  =  {6{mra_field3_en}} ;
assign	mra_byte_wen[1:0]  =  {2{mra_field4_en}} ;

// active-low selects
// Need to add inst_access_excp to the sel !!!
// Prioritized between the two sels.
assign        tag_access_wdata_sel[0] = 
      ~(tag_access_wdata_sel[1] | tag_access_wdata_sel[2]) | rst_tri_en ;
//assign        tag_access_wdata_sel[1] = (immu_miss_g | isfsr_trap) & ~rst_tri_en ; // Timing
assign        tag_access_wdata_sel[1] = tlu_itag_acc_sel_g & ~rst_tri_en ;
assign        tag_access_wdata_sel[2] = (dmra_ldst | imra_ldst) & st_wr_g & ~rst_tri_en ; 
					// Bug 4728

wire  [12:0]  tag_access_wdata_ctxt ;
assign        tag_access_wdata_ctxt[12:0] = 
       tag_access_wdata_sel[2] ? lsu_tlu_st_rs3_data_b12t0_g[12:0] : tlu_tag_access_ctxt_g[12:0] ;

assign  tag_access_nctxt_g = (tag_access_wdata_ctxt[12:0] == 13'd0) ;
 
//=========================================================================================
//	Tag-Access Context Per thread
//=========================================================================================

// Mark ctxt field in tag-access register as being nucleus or non-nucleus.
// State will not be ~rst_l as use is expected to be preceeded by write.

wire	[3:0]	itacc_ctxt_en, dtacc_ctxt_en ;
wire		itacc_nctxt0,itacc_nctxt1,itacc_nctxt2,itacc_nctxt3;
wire		dtacc_nctxt0,dtacc_nctxt1,dtacc_nctxt2,dtacc_nctxt3;
assign	itacc_ctxt_en[0] = thread0_sel_g & mra_itag_acc_en & mra_wr_vld ;
assign	itacc_ctxt_en[1] = thread1_sel_g & mra_itag_acc_en & mra_wr_vld ;
assign	itacc_ctxt_en[2] = thread2_sel_g & mra_itag_acc_en & mra_wr_vld ;
assign	itacc_ctxt_en[3] = thread3_sel_g & mra_itag_acc_en & mra_wr_vld ;
assign	dtacc_ctxt_en[0] = thread0_sel_g & mra_dtag_acc_en & mra_wr_vld ;
assign	dtacc_ctxt_en[1] = thread1_sel_g & mra_dtag_acc_en & mra_wr_vld ;
assign	dtacc_ctxt_en[2] = thread2_sel_g & mra_dtag_acc_en & mra_wr_vld ;
assign	dtacc_ctxt_en[3] = thread3_sel_g & mra_dtag_acc_en & mra_wr_vld ;

// Thread0
dffe_s   itacc_ctxt0 (
        .din    (tag_access_nctxt_g), .q  (itacc_nctxt0),
        .en 	(itacc_ctxt_en[0]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

dffe_s   dtacc_ctxt0 (
        .din    (tag_access_nctxt_g), .q  (dtacc_nctxt0),
        .en 	(dtacc_ctxt_en[0]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread1
dffe_s   itacc_ctxt1 (
        .din    (tag_access_nctxt_g), .q  (itacc_nctxt1),
        .en 	(itacc_ctxt_en[1]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

dffe_s   dtacc_ctxt1 (
        .din    (tag_access_nctxt_g), .q  (dtacc_nctxt1),
        .en 	(dtacc_ctxt_en[1]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread2
dffe_s   itacc_ctxt2 (
        .din    (tag_access_nctxt_g), .q  (itacc_nctxt2),
        .en 	(itacc_ctxt_en[2]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

dffe_s   dtacc_ctxt2 (
        .din    (tag_access_nctxt_g), .q  (dtacc_nctxt2),
        .en 	(dtacc_ctxt_en[2]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread3
dffe_s   itacc_ctxt3 (
        .din    (tag_access_nctxt_g), .q  (itacc_nctxt3),
        .en 	(itacc_ctxt_en[3]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

dffe_s   dtacc_ctxt3 (
        .din    (tag_access_nctxt_g), .q  (dtacc_nctxt3),
        .en 	(dtacc_ctxt_en[3]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// In-pipe Access
assign	itacc_nctxt =
	thread0_d ? itacc_nctxt0 :
		thread1_d ? itacc_nctxt1 :
			thread2_d ? itacc_nctxt2 : itacc_nctxt3 ;
assign	dtacc_nctxt =
	thread0_d ? dtacc_nctxt0 :
		thread1_d ? dtacc_nctxt1 :
			thread2_d ? dtacc_nctxt2 : dtacc_nctxt3 ;
assign	tacc_nctxt =
	iside_mra_access_rd ? itacc_nctxt : dtacc_nctxt ;

// Asynchronous Access
assign	itacc_anctxt =
	thread0_async_g ? itacc_nctxt0 :
		thread1_async_g ? itacc_nctxt1 :
			thread2_async_g ? itacc_nctxt2 : itacc_nctxt3 ;
assign	dtacc_anctxt =
	thread0_async_g ? dtacc_nctxt0 :
		thread1_async_g ? dtacc_nctxt1 :
			thread2_async_g ? dtacc_nctxt2 : dtacc_nctxt3 ;

assign	tacc_anctxt =
	imra_lng_lat_rd ? itacc_anctxt : dtacc_anctxt ;

//=========================================================================================
//	Interrupt Control
//=========================================================================================

assign	tlu_int_asi_load =  ld_inst_g & alt_space_g ;
assign	tlu_int_asi_store =  st_inst_g & alt_space_g ;
assign	tlu_int_asi_thrid[1:0] = thrid_g[1:0] ;
assign	tlu_int_asi_vld = alt_space_g ;

//=========================================================================================
//	ASI Error Condition
//=========================================================================================

// Supported asi but illegal_va. ldxa must signal this occurrence when returning data
// to LSU.
// The decode can be shared with the statement below (grape)
// SPARC_HPV_EN - Needs to change once asi assignments are available !!!
// Bug 2201 : pid and va_wtchpt decoded in lsu (asi 58)
/*wire lsu_asi58_g ;
assign lsu_asi58_g = 
	((tlu_ldst_va_g[8:0] == 9'h080) |	// pid
	(tlu_ldst_va_g[8:0] == 9'h038)) ;	// va-wtchpt
assign	dmmu_sync_supported_asi = 
	(((lsu_asi_state[7:0] == 8'h58) & ~lsu_asi58_g) |
	(lsu_asi_state[7:0] == 8'h59) |
	(lsu_asi_state[7:0] == 8'h5A) |
	(lsu_asi_state[7:0] == 8'h5B)) & alt_space_g  ;*/


wire    dmmu_inv_all_asi ;
assign dmmu_inv_all_asi = 
({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h60,8'h08}) ;

wire	dmmu_async_supported_asi_m ;
assign	dmmu_async_supported_asi_m = 
	((lsu_tlu_tlb_asi_state_m[7:0] == 8'h5C) |
	//dmmu_inv_all_asi |
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h60) | // Bug 4901
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h5D) |
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h5E) |

    (lsu_tlu_tlb_asi_state_m[7:0] == 8'h0F) |
    (lsu_tlu_tlb_asi_state_m[7:0] == 8'h13) |

	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h5F)) & tlb_ldst_inst_m ;

dff_s stgg_dasi (
        .din    (dmmu_async_supported_asi_m),
        .q      (dmmu_async_supported_asi),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	dmmu_async_illgl_va_g =
	dmmu_async_supported_asi & 
	~(dmmu_data_in_en | 
	dmmu_invalidate_all_en | immu_invalidate_all_en | // Bug 4901
	dmmu_data_access_en |

    dmmu_csm_in_en | dmmu_csm_access_en | 
 
	dmmu_tag_read_en | dmmu_demap_en) ;

/*assign	immu_sync_supported_asi = 
	((lsu_asi_state[7:0] == 8'h50) |
	(lsu_asi_state[7:0] == 8'h51) |
	(lsu_asi_state[7:0] == 8'h52)) & alt_space_g ;

assign	immu_sync_illgl_va_g =
	immu_sync_supported_asi & ~(immu_tag_target_en | immu_sync_fsr_en | immu_tsb_en | 
	immu_tag_access_en | immu_8k_ptr_en | immu_64k_ptr_en | immu_ctxt_cfg_en) ;*/

wire    immu_inv_all_asi ;
assign immu_inv_all_asi = 
({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h60,8'h00}) ;

wire	immu_async_supported_asi_m ;
assign	immu_async_supported_asi_m = 
	((lsu_tlu_tlb_asi_state_m[7:0] == 8'h54) |
	//immu_inv_all_asi |
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h60) | // Bug 4901
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h55) |
	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h56) |

    (lsu_tlu_tlb_asi_state_m[7:0] == 8'h0E) |
    (lsu_tlu_tlb_asi_state_m[7:0] == 8'h12) |

	(lsu_tlu_tlb_asi_state_m[7:0] == 8'h57)) & tlb_ldst_inst_m  ;

dff_s stgg_iasi (
        .din    (immu_async_supported_asi_m),
        .q      (immu_async_supported_asi),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	immu_async_illgl_va_g =
	immu_async_supported_asi & 
	~(immu_data_in_en |

    immu_csm_in_en | immu_csm_access_en | 
 
	immu_data_access_en | immu_tag_read_en | immu_demap_en | 
	immu_invalidate_all_en | dmmu_invalidate_all_en) ; // Bug 4901

//=========================================================================================
//	IN-PIPE ASI RD SUPPORT
//=========================================================================================


assign  thread0_d = ~thrid_d[1] & ~thrid_d[0] ;
assign  thread1_d = ~thrid_d[1] &  thrid_d[0] ;
assign  thread2_d =  thrid_d[1] & ~thrid_d[0] ;
assign  thread3_d =  thrid_d[1] &  thrid_d[0] ;

wire    [7:0]   asi_reg0_d1 ;
dff_s #(8) stgd1_asi0 (
        .din    (lsu_asi_reg0[7:0]),
        .q      (asi_reg0_d1[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire    [7:0]   asi_reg1_d1 ;
dff_s #(8) stgd1_asi1 (
        .din    (lsu_asi_reg1[7:0]),
        .q      (asi_reg1_d1[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire    [7:0]   asi_reg2_d1 ;
dff_s #(8) stgd1_asi2 (
        .din    (lsu_asi_reg2[7:0]),
        .q      (asi_reg2_d1[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire    [7:0]   asi_reg3_d1 ;
dff_s #(8) stgd1_asi3 (
        .din    (lsu_asi_reg3[7:0]),
        .q      (asi_reg3_d1[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire    [7:0]   asi_reg_state ;
assign  asi_reg_state[7:0] =
        (thread0_d ? asi_reg0_d1[7:0] : 
          (thread1_d ? asi_reg1_d1[7:0] : 
            (thread2_d ? asi_reg2_d1[7:0] : 
              asi_reg3_d1[7:0]))) ;

wire    imm_asi_vld_d ;
assign  imm_asi_vld_d = ~ifu_lsu_imm_asi_d[8] ;

// Use of asi delayed by a cycle.
assign  asi_state_d[7:0] = imm_asi_vld_d ? 
      ifu_lsu_imm_asi_d[7:0] : asi_reg_state[7:0] ;

dff_s #(8) stgd1_asi (
        .din    (asi_state_d[7:0]),
        .q      (asi_state_e[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// bit8 is unused.
dff_s #(8) stgd1_eva (
        .din    (exu_mmu_early_va_e[7:0]),
        .q      (early_va_m[7:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire alt_space_e;
dff_s #(6) stgd1_mref (
        .din    ({ifu_lsu_memref_d,thread0_d,thread1_d,thread2_d,thread3_d,ifu_tlu_alt_space_d}),
        .q      ({memref_e,thread0_e, thread1_e, thread2_e, thread3_e,alt_space_e}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s #(1) stgm_mref (
        .din    (memref_e),
        .q      (memref_m),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


// qualification with memref_d to cut down on number of speculative reads
// decode can be shared with corresponding enables
// gates can be shared.

// Establish that mra *could* be read by sync events. full decode would
// cause critical path.
assign	idmra_rd_d =
	//((asi_state_d[6:4] == 3'h6)  | // specifically tag-access.
	((asi_state_d[6:4] == 3'h5)  |
	 (asi_state_d[6:4] == 3'h3)) & ifu_tlu_alt_space_d & ifu_lsu_memref_d ;

// need to decode 58,59,5a,5B,31,32,39,3A,33,3B
// use lower hex. need to distinguish 1 & 2 between both accesses.
assign	dmra_rw_d =
	(asi_state_d[3:0] == 4'b1000)   | // 8	
	(((asi_state_d[3:0] == 4'b0001)  | // 1	
	(asi_state_d[3:0] == 4'b0010)) & asi_state_d[5])  | // 2 ;1 & 2 need distinction between I&D	
	(asi_state_d[3:0] == 4'b1001)   | // 9	
	(asi_state_d[3:0] == 4'b1010)   | // A	
	(asi_state_d[2:0] == 3'b011)   ; // partial B	
	

// Read requires that ctxt of access be chosen.
// ctxt_cfg,ps0_tsb,ps1_tsb require decode for ctxt.
// tag_access,ps0-ptr,ps1-ptr,direct-ptr,tag-target require lookup of logged ctxt. 
// ** Solution here is to exclude zctxt asi rds from equation.

assign idmra_nzctxt_rd_d =
	(asi_state_d[7:4] == 4'h3) &	// common
		((asi_state_d[3:0] == 4'h9) |	// dmmu_nzctxt_ps0_tsb
		(asi_state_d[3:0] == 4'hA) |	// dmmu_nzctxt_ps1_tsb
		(asi_state_d[3:0] == 4'hB) |	// dmmu_nzctxt_cfg
		(asi_state_d[3:0] == 4'hD) |	// immu_nzctxt_ps0_tsb
		(asi_state_d[3:0] == 4'hE) |	// immu_nzctxt_ps1_tsb
		(asi_state_d[3:0] == 4'hF)) & 	// immu_nzctxt_cfg
		ifu_tlu_alt_space_d & ifu_lsu_memref_d ;

// Fault based reads
assign	idmra_fault_rd_d =
	(asi_state_d[7:4] == 4'h5) &	// common
		((asi_state_d[3:0] == 4'h8) |	// dmmu_tag_access/target; va ignored
		(asi_state_d[3:0] == 4'h9) |	// dmmu_ps0_ptr
		(asi_state_d[3:0] == 4'hA) |	// dmmu_ps1_ptr
		(asi_state_d[3:0] == 4'hB) |	// direct_ptr
		(asi_state_d[3:0] == 4'h0) |	// immu_tag_access/target ; va ignored
		(asi_state_d[3:0] == 4'h1) |	// immu_ps0_ptr
		(asi_state_d[3:0] == 4'h2)) & 	// immu_ps1_ptr
		ifu_tlu_alt_space_d & ifu_lsu_memref_d ;


// Note - tag_access needs to be included.
always	@ (/*AUTOSENSE*/alt_space_e or asi_state_e or memref_e)
	begin	
		// DMMU
		dmmu_decode_asi58_e =
		 ({asi_state_e[7:0]} == {8'h58}) & alt_space_e & memref_e ; 	
		dmmu_8k_ptr_e =
		 ({asi_state_e[7:0]} == {8'h59}) & alt_space_e & memref_e ; 	
		dmmu_64k_ptr_e =
		 ({asi_state_e[7:0]} == {8'h5A}) & alt_space_e & memref_e ; 	
		dmmu_direct_ptr_e =
		 ({asi_state_e[7:0]} == {8'h5B}) & alt_space_e & memref_e ; 	
		dmmu_zctxt_ps0_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h31}) & alt_space_e & memref_e ; 	
		dmmu_zctxt_ps1_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h32}) & alt_space_e & memref_e ; 	
		dmmu_nzctxt_ps0_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h39}) & alt_space_e & memref_e ; 	
		dmmu_nzctxt_ps1_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h3A}) & alt_space_e & memref_e ; 	
		dmmu_zctxt_cfg_e = 
		 ({asi_state_e[7:0]} == {8'h33}) & alt_space_e & memref_e ; 	
		dmmu_nzctxt_cfg_e = 
		 ({asi_state_e[7:0]} == {8'h3B}) & alt_space_e & memref_e ; 	
		// IMMU
		immu_decode_asi50_e =
		 ({asi_state_e[7:0]} == {8'h50}) & alt_space_e & memref_e ; 	
		immu_8k_ptr_e =
		 ({asi_state_e[7:0]} == {8'h51}) & alt_space_e & memref_e ; 	
		immu_64k_ptr_e =
		 ({asi_state_e[7:0]} == {8'h52}) & alt_space_e & memref_e ; 	
		immu_zctxt_ps0_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h35}) & alt_space_e & memref_e ; 	
		immu_zctxt_ps1_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h36}) & alt_space_e & memref_e ; 	
		immu_nzctxt_ps0_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h3D}) & alt_space_e & memref_e ; 	
		immu_nzctxt_ps1_tsb_e = 
		 ({asi_state_e[7:0]} == {8'h3E}) & alt_space_e & memref_e ; 	
		immu_zctxt_cfg_e = 
		 ({asi_state_e[7:0]} == {8'h37}) & alt_space_e & memref_e ; 	
		immu_nzctxt_cfg_e = 
		 ({asi_state_e[7:0]} == {8'h3F}) & alt_space_e & memref_e ; 	
	end

wire immu_64k_ptr_m,immu_8k_ptr_m,dmmu_direct_ptr_m,dmmu_64k_ptr_m,
dmmu_8k_ptr_m ;
dff_s  #(19) fastasi_m (
        .din    ({dmmu_8k_ptr_e,dmmu_64k_ptr_e,dmmu_direct_ptr_e,
		dmmu_decode_asi58_e, immu_decode_asi50_e,
		dmmu_zctxt_ps0_tsb_e, dmmu_zctxt_ps1_tsb_e,
		dmmu_nzctxt_ps0_tsb_e, dmmu_nzctxt_ps1_tsb_e,
		dmmu_zctxt_cfg_e, dmmu_nzctxt_cfg_e,
		immu_zctxt_ps0_tsb_e, immu_zctxt_ps1_tsb_e,
		immu_nzctxt_ps0_tsb_e, immu_nzctxt_ps1_tsb_e,
		immu_zctxt_cfg_e, immu_nzctxt_cfg_e,
		immu_8k_ptr_e,immu_64k_ptr_e}),
        .q      ({dmmu_8k_ptr_m,dmmu_64k_ptr_m,dmmu_direct_ptr_m,
		dmmu_decode_asi58_m, immu_decode_asi50_m,
		dmmu_zctxt_ps0_tsb_m, dmmu_zctxt_ps1_tsb_m,
		dmmu_nzctxt_ps0_tsb_m, dmmu_nzctxt_ps1_tsb_m,
		dmmu_zctxt_cfg_m, dmmu_nzctxt_cfg_m,
		immu_zctxt_ps0_tsb_m, immu_zctxt_ps1_tsb_m,
		immu_nzctxt_ps0_tsb_m, immu_nzctxt_ps1_tsb_m,
		immu_zctxt_cfg_m, immu_nzctxt_cfg_m,
		immu_8k_ptr_m,immu_64k_ptr_m}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

assign	dmmu_tag_target_en_m = dmmu_decode_asi58_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_tag_access_en_m = dmmu_decode_asi58_m & (early_va_m[7:0] == 8'h30) ;
assign	dmmu_sync_fsr_en_m = dmmu_decode_asi58_m & (early_va_m[7:0] == 8'h18) ;
assign	dmmu_sync_far_en_m = dmmu_decode_asi58_m & (early_va_m[7:0] == 8'h20) ;
assign	dmmu_zctxt_ps0_tsb_en_m = dmmu_zctxt_ps0_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_zctxt_ps1_tsb_en_m = dmmu_zctxt_ps1_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_nzctxt_ps0_tsb_en_m = dmmu_nzctxt_ps0_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_nzctxt_ps1_tsb_en_m = dmmu_nzctxt_ps1_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_zctxt_cfg_en_m = dmmu_zctxt_cfg_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_nzctxt_cfg_en_m = dmmu_nzctxt_cfg_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_8k_ptr_en_m = dmmu_8k_ptr_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_64k_ptr_en_m = dmmu_64k_ptr_m & (early_va_m[7:0] == 8'h00) ;
assign	dmmu_direct_ptr_en_m = dmmu_direct_ptr_m & (early_va_m[7:0] == 8'h00) ;



// Calculation of dmmu illgl-va

wire	dmmu_sync_supported_asi_e ;
wire	dmmu_sync_supported_asi_m ;
assign	dmmu_sync_supported_asi_e =
	(dmmu_decode_asi58_e | dmmu_zctxt_ps0_tsb_e | dmmu_zctxt_ps1_tsb_e |
	dmmu_nzctxt_ps0_tsb_e | dmmu_nzctxt_ps1_tsb_e | dmmu_zctxt_cfg_e |
	dmmu_nzctxt_cfg_e | dmmu_8k_ptr_e | dmmu_64k_ptr_e | dmmu_direct_ptr_e);

dff_s stgm_dsynca (
        .din    (dmmu_sync_supported_asi_e),
        .q      (dmmu_sync_supported_asi_m),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	dmmu_sync_illgl_va_m ;
assign	dmmu_sync_illgl_va_m = dmmu_sync_supported_asi_m & ~(dmmu_tag_target_en_m |
	dmmu_tag_access_en_m | dmmu_sync_fsr_en_m | dmmu_sync_far_en_m | dmmu_tsb_en_m |
	dmmu_ctxt_cfg_en_m | dmmu_8k_ptr_en_m | dmmu_64k_ptr_en_m | dmmu_direct_ptr_en_m);

assign	dmmu_tsb_en_m = 
	dmmu_zctxt_ps0_tsb_en_m  | dmmu_zctxt_ps1_tsb_en_m |
	dmmu_nzctxt_ps0_tsb_en_m | dmmu_nzctxt_ps1_tsb_en_m ;
assign	dmmu_ctxt_cfg_en_m = dmmu_zctxt_cfg_en_m | dmmu_nzctxt_cfg_en_m ;

assign	immu_tag_target_en_m = immu_decode_asi50_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_tag_access_en_m = immu_decode_asi50_m & (early_va_m[7:0] == 8'h30) ;
assign	immu_sync_fsr_en_m = immu_decode_asi50_m & (early_va_m[7:0] == 8'h18) ;
assign	immu_zctxt_ps0_tsb_en_m = immu_zctxt_ps0_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_zctxt_ps1_tsb_en_m = immu_zctxt_ps1_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_nzctxt_ps0_tsb_en_m = immu_nzctxt_ps0_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_nzctxt_ps1_tsb_en_m = immu_nzctxt_ps1_tsb_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_zctxt_cfg_en_m = immu_zctxt_cfg_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_nzctxt_cfg_en_m = immu_nzctxt_cfg_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_8k_ptr_en_m = immu_8k_ptr_m & (early_va_m[7:0] == 8'h00) ;
assign	immu_64k_ptr_en_m = immu_64k_ptr_m & (early_va_m[7:0] == 8'h00) ;


assign	immu_tsb_en_m = 
	immu_zctxt_ps0_tsb_en_m  | immu_zctxt_ps1_tsb_en_m |
	immu_nzctxt_ps0_tsb_en_m | immu_nzctxt_ps1_tsb_en_m ;
assign	immu_ctxt_cfg_en_m = immu_zctxt_cfg_en_m | immu_nzctxt_cfg_en_m ;


// Calculation of immu illgl-va

wire	immu_sync_supported_asi_e ;
wire	immu_sync_supported_asi_m ;
assign	immu_sync_supported_asi_e =
	(immu_decode_asi50_e | immu_zctxt_ps0_tsb_e | immu_zctxt_ps1_tsb_e |
	immu_nzctxt_ps0_tsb_e | immu_nzctxt_ps1_tsb_e | immu_zctxt_cfg_e |
	immu_nzctxt_cfg_e | immu_8k_ptr_e | immu_64k_ptr_e);

dff_s stgm_isynca (
        .din    (immu_sync_supported_asi_e),
        .q      (immu_sync_supported_asi_m),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	immu_sync_illgl_va_m ;
assign	immu_sync_illgl_va_m = immu_sync_supported_asi_m & ~(immu_tag_target_en_m |
	immu_tag_access_en_m | immu_sync_fsr_en_m | immu_tsb_en_m | immu_ctxt_cfg_en_m |
	immu_8k_ptr_en_m | immu_64k_ptr_en_m);

dff_s #(2) stgg_illgl (
        .din    ({immu_sync_illgl_va_m,dmmu_sync_illgl_va_m}),
        .q      ({immu_sync_illgl_va_g,dmmu_sync_illgl_va_g}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Staged to g for writes
dff_s  #(17) fastasi_g (
        .din    ({dmmu_tag_access_en_m,
		dmmu_sync_fsr_en_m, dmmu_sync_far_en_m,
		dmmu_zctxt_ps0_tsb_en_m, dmmu_zctxt_ps1_tsb_en_m,
		dmmu_nzctxt_ps0_tsb_en_m, dmmu_nzctxt_ps1_tsb_en_m,
		dmmu_zctxt_cfg_en_m, dmmu_nzctxt_cfg_en_m,
        	immu_tag_access_en_m,
		immu_sync_fsr_en_m,
		immu_zctxt_ps0_tsb_en_m, immu_zctxt_ps1_tsb_en_m,
		immu_nzctxt_ps0_tsb_en_m, immu_nzctxt_ps1_tsb_en_m,
		immu_zctxt_cfg_en_m, immu_nzctxt_cfg_en_m}),
        .q      ({dmmu_tag_access_en,
		dmmu_sync_fsr_en, dmmu_sync_far_en,
		dmmu_zctxt_ps0_tsb_en, dmmu_zctxt_ps1_tsb_en,
		dmmu_nzctxt_ps0_tsb_en, dmmu_nzctxt_ps1_tsb_en,
		dmmu_zctxt_cfg_en, dmmu_nzctxt_cfg_en,
        	immu_tag_access_en,
		immu_sync_fsr_en,
		immu_zctxt_ps0_tsb_en, immu_zctxt_ps1_tsb_en,
		immu_nzctxt_ps0_tsb_en, immu_nzctxt_ps1_tsb_en,
		immu_zctxt_cfg_en, immu_nzctxt_cfg_en}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  


//=========================================================================================
//	MMU ASI Decode - D-Side
//=========================================================================================


// Assumption is that only 9 bits of VA are required.
// Comparison for asi-state and va is to be done uniformly in w2.

// This will have to change because of tsb mapping to mra.
	assign	dmmu_tsb_en = 
			dmmu_zctxt_ps0_tsb_en  | dmmu_zctxt_ps1_tsb_en |
			dmmu_nzctxt_ps0_tsb_en | dmmu_nzctxt_ps1_tsb_en ;

assign	tlb_ldst_inst_m = lsu_tlu_tlb_ld_inst_m | lsu_tlu_tlb_st_inst_m ;

// M-stage decoding for long-latency tlb accesses
always	@ (/*AUTOSENSE*/dmmu_inv_all_asi or lsu_tlu_tlb_asi_state_m
           or lsu_tlu_tlb_ldst_va_m[7:0] or tlb_ldst_inst_m)
	begin
		dmmu_data_in_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h5C,8'h00}) & tlb_ldst_inst_m ;
		dmmu_invalidate_all_en_m =
		 dmmu_inv_all_asi & tlb_ldst_inst_m ;
		 //({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h60,8'h08}) & tlb_ldst_inst_m ;
		// Address specifies tlb entry.
		dmmu_data_access_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h5D}) & 	tlb_ldst_inst_m ;
		// Address specifies tlb entry.
		dmmu_tag_read_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h5E}) & 	tlb_ldst_inst_m ;
		dmmu_demap_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h5F}) &  tlb_ldst_inst_m ;

        
        dmmu_csm_in_en_m = 
		 ({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h0F,8'h00}) & tlb_ldst_inst_m ;
        dmmu_csm_access_en_m = 
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h13}) & 	tlb_ldst_inst_m ;
        
	end

// Stage to g.
// Make dff->dffre. This required to avoid conflict between fast-asi and lng-latency
// rds of mra. Specifically, data-in/data_access need to be staged, along with
// support information.

wire lng_ltncy_en_d1 ;
assign	tlu_lng_ltncy_en_l = ~lng_ltncy_en_d1 | sehold ;
wire	lng_ltncy_en ;
dff_s stgd1_lltncyen (
        .din    (lng_ltncy_en),
        .q      (lng_ltncy_en_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	lng_ltncy_en = (lsu_tlu_tlb_st_inst_m | lsu_tlu_tlb_ld_inst_m) ;
wire	lng_ltncy_rst ;


assign	lng_ltncy_rst = 
	tlb_ld_inst_unflushed |		// all reads processed immediately
	(tlb_st_inst_unflushed & 	// all writes not requiring mra processed immediately
		~(dmmu_data_in_en | dmmu_data_access_en | immu_data_in_en | immu_data_access_en |
          dmmu_csm_in_en  | dmmu_csm_access_en | immu_csm_in_en | immu_csm_access_en)) |
	dmra_lng_lat_rd | imra_lng_lat_rd | // lng-ltncy rds - delay until bubble available.
	((tlb_ld_inst_unflushed | tlb_st_inst_unflushed) &  // rst w/o use if illgl-va
			(dmmu_async_illgl_va_g | immu_async_illgl_va_g)) |
	~rst_l ;












dffe_s  #((6 + 4)) dtlbacc_stgg (
        .din    ({lsu_tlu_tlb_ldst_va_m[(6 + 4):3], lsu_tlu_tlb_access_tid_m[1:0]}),
        .q      ({tlb_ldst_va_g[(6 + 4):3],tlb_access_tid_g[1:0]}),
        .clk    (clk),
	.en	(lng_ltncy_en),
        .se     (1'b0),       .si (),          .so ()
        );  


dffre_s  #(9) dtlbaccr_stgg (
        .din    ({dmmu_csm_in_en_m,dmmu_csm_access_en_m,dmmu_data_in_en_m,dmmu_data_access_en_m,
        dmmu_tag_read_en_m,dmmu_demap_en_m,dmmu_invalidate_all_en_m,
		lsu_tlu_tlb_ld_inst_m,lsu_tlu_tlb_st_inst_m}),
        .q      ({dmmu_csm_in_en, dmmu_csm_access_en,dmmu_data_in_en,dmmu_data_access_en,dmmu_tag_read_en,
		dmmu_demap_en,dmmu_invalidate_all_en,
		tlb_ld_inst_unflushed,tlb_st_inst_unflushed}),
        .clk    (clk),
	.rst	(lng_ltncy_rst),	.en	(lng_ltncy_en),
        .se     (1'b0),       .si (),          .so ()
        );  















assign	tlb_st_inst_g = tlb_st_inst_unflushed & ~(dmmu_async_illgl_va_g | immu_async_illgl_va_g) ;
assign	tlb_ld_inst_g = tlb_ld_inst_unflushed & ~(dmmu_async_illgl_va_g | immu_async_illgl_va_g) ;

assign	dsfsr_asi_wr_en[0] = dmmu_sync_fsr_en & st_inst_g & thread0_sel_g ;
assign	dsfsr_asi_wr_en[1] = dmmu_sync_fsr_en & st_inst_g & thread1_sel_g ;
assign	dsfsr_asi_wr_en[2] = dmmu_sync_fsr_en & st_inst_g & thread2_sel_g ;
assign	dsfsr_asi_wr_en[3] = dmmu_sync_fsr_en & st_inst_g & thread3_sel_g ;

assign	dmmu_any_sfsr_wr = dmmu_sync_fsr_en & st_inst_g ; //|(dsfsr_asi_wr_en[3:0]);

assign	dmmu_sfsr_wr_en_l[3:0] = 
~(dsfsr_asi_wr_en[3:0] | (dmmu_sfsr_trp_wr[3:0] & {4{~priority_squash_g}})) ; // Bug 4183

assign	dmmu_sfar_wr_en_l[0] = 
~((dmmu_sync_far_en & st_inst_g & thread0_sel_g) | 
(dmmu_sfsr_trp_wr[0] & ~priority_squash_g)) ; // Bug 4183
assign	dmmu_sfar_wr_en_l[1] = 
~((dmmu_sync_far_en & st_inst_g & thread1_sel_g) | 
(dmmu_sfsr_trp_wr[1] & ~priority_squash_g)) ; 
assign	dmmu_sfar_wr_en_l[2] = 
~((dmmu_sync_far_en & st_inst_g & thread2_sel_g) | 
(dmmu_sfsr_trp_wr[2] & ~priority_squash_g)) ; 
assign	dmmu_sfar_wr_en_l[3] = 
~((dmmu_sync_far_en & st_inst_g & thread3_sel_g) | 
(dmmu_sfsr_trp_wr[3] & ~priority_squash_g)) ; 



assign	dmmu_csm_in_wr_en = dmmu_csm_in_en & tlb_st_inst_g ;	// Write-Only.
assign	dmmu_csm_access_wr_en = dmmu_csm_access_en & tlb_st_inst_g ;
// non-threaded as shared resource
assign	dmmu_csm_access_rd_en = dmmu_csm_access_en & tlb_ld_inst_g ;

assign	dmmu_data_in_wr_en = dmmu_data_in_en & tlb_st_inst_g ;	// Write-Only.
assign	dmmu_data_access_wr_en = dmmu_data_access_en & tlb_st_inst_g ;
// non-threaded as shared resource
assign	dmmu_data_access_rd_en = dmmu_data_access_en & tlb_ld_inst_g ;

// take exception for write case.
assign	dmmu_tag_read_rd_en = dmmu_tag_read_en & tlb_ld_inst_g ;



assign	dtlb_rw_index_vld_g = dmmu_data_access_rd_en | dmmu_data_access_wr_en | dmmu_tag_read_rd_en |
                              dmmu_csm_access_rd_en | dmmu_csm_access_wr_en;
// terminate write if tlb full and signal exception.
assign	dtlb_wr_vld_g = (dmmu_data_in_wr_en | dmmu_data_access_wr_en | dmmu_csm_in_wr_en | dmmu_csm_access_wr_en) 
                        & ~ifu_lsu_memref_d ;







wire dtlb_wr_csm_sel_g;
wire dtlb_wr_csm_sel_pend;
assign dtlb_wr_csm_sel_g = dmmu_csm_in_wr_en | dmmu_csm_access_wr_en;
dffre_s  #(1) stgw2_dtlbcsm (
        .din    (dtlb_wr_csm_sel_g),
        .q    	(dtlb_wr_csm_sel_pend),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  


wire		dtlb_rw_index_vld_pend ;
wire [5:0]	dtlb_rw_index_pend ;

dffre_s  #(1) stgw2_dtlbctl (
        .din    (dtlb_rw_index_vld_g),
        .q    	(dtlb_rw_index_vld_pend),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dffre_s  #(6) stgw2_dtlbidx (
        .din    (tlb_ldst_va_g[8:3]),
        .q    	(dtlb_rw_index_pend[5:0]),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

wire	tlb_rd_mode, tlb_rd_mode_d1 ;
assign	tlb_rd_mode = 
		tlu_itlb_tag_rd_g | tlu_itlb_data_rd_g |	// i-side read
		tlu_dtlb_tag_rd_g | tlu_dtlb_data_rd_g ;	// d-side read

dff_s stgd1_rmode (
        .din    (tlb_rd_mode),
        .q      (tlb_rd_mode_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	dtlb_done_d1 ;	
dff_s stgd1_ddone (
        .din    (lsu_tlu_dtlb_done),
        .q      (dtlb_done_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	itlb_done_d1 ;	
dff_s stgd1_idone (
        .din    (ifu_tlu_itlb_done),
        .q      (itlb_done_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Advanced by a cycle.
assign	tlu_dtlb_rw_index_vld_g  = dtlb_rw_index_vld_g | dtlb_rw_index_vld_pend ;
//assign	tlu_dtlb_rw_index_vld_g  = dtlb_rw_index_vld_g | (dtlb_rw_index_vld_pend & ~dtlb_done_d1) ; //Bug3974
//assign	tlu_dtlb_rw_index_vld_g  = dtlb_rw_index_vld_g | (dtlb_rw_index_vld_pend & ~lsu_tlu_dtlb_done) ;
assign	tlu_dtlb_rw_index_g[5:0] = (tlb_ldst_va_g[8:3] & {6{~(tlb_admp_mode | tlb_write_mode | tlb_rd_mode_d1)}})  | 
					dtlb_rw_index_pend[5:0]  ;

assign	tlu_dtlb_wr_csm_sel_g = (dtlb_wr_csm_sel_g & {~(tlb_admp_mode | tlb_write_mode | tlb_rd_mode_d1)})  | 
					dtlb_wr_csm_sel_pend ;


// Exception on reserved field.
assign	demap_pctxt = ~tlb_ldst_va_g[5] & ~tlb_ldst_va_g[4] ;
assign	demap_sctxt = ~tlb_ldst_va_g[5] &  tlb_ldst_va_g[4] ;
assign	demap_nctxt =  tlb_ldst_va_g[5] & ~tlb_ldst_va_g[4] ;
// reserved ctxt causes demap to be ignored.
// reserved dmp type causes demap to be ignored.
assign	demap_resrv =  	(tlb_ldst_va_g[5] &  tlb_ldst_va_g[4]) 		// ctxt
			| (tlb_ldst_va_g[7] &  tlb_ldst_va_g[6]) ;	// type

assign	ddemap_by_page  = dmmu_demap_en & ~tlb_ldst_va_g[7] & ~tlb_ldst_va_g[6] ;
assign	ddemap_by_ctxt  = dmmu_demap_en & ~tlb_ldst_va_g[7] &  tlb_ldst_va_g[6] ;
assign	ddemap_all      = dmmu_demap_en &  tlb_ldst_va_g[7] & ~tlb_ldst_va_g[6] ;

// assumption is that demap_all is unaffected by presence of reserved ctxt as it
// does not use ctxt.
assign	ddemap_vld  	= ((ddemap_by_page | ddemap_by_ctxt) & ~demap_resrv) | 
				ddemap_all ;

//wire		dtlb_dmp_by_ctxt_pend ;
wire		dtlb_dmp_all_pend ;
wire		dtlb_dmp_pctxt_pend ;
wire		dtlb_dmp_sctxt_pend ;
wire		dtlb_dmp_nctxt_pend ;
wire	[1:0]	idtlb_dmp_thrid_pend ;
wire	[1:0]	ldst_asi_tid ;
wire		dmmu_inv_all_g, dmmu_inv_all_pend ;

assign	dmmu_inv_all_g = dmmu_invalidate_all_en & tlb_st_inst_g ;

// Demap/Invalidate
dffre_s  #(5) stgw2_dtlbdmp (
        .din    ({ddemap_all,demap_pctxt,demap_sctxt,demap_nctxt,dmmu_inv_all_g}),
        .q    	({dtlb_dmp_all_pend,dtlb_dmp_pctxt_pend,dtlb_dmp_sctxt_pend, 
		dtlb_dmp_nctxt_pend,dmmu_inv_all_pend }),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

// Bug 3905 - rm from above flop.
assign	idtlb_dmp_thrid_pend[1:0] = tlb_access_tid_g[1:0] ;

assign	ldst_asi_tid[1:0] = 
	(lsu_tlu_dtlb_done | dmmu_async_illgl_va_g | immu_async_illgl_va_g)  ?  
	idtlb_dmp_thrid_pend[1:0] : thrid_g[1:0] ;

// Thread for tlb
dff_s  #(4) stg_w2 (
        .din    ({ldst_asi_tid[1:0],idtlb_dmp_thrid_pend[1:0]}),
        .q      ({tlu_lsu_ldxa_tid_w2[1:0],tlu_lsu_stxa_ack_tid[1:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

assign	tlu_dtlb_invalidate_all_g = dmmu_inv_all_g | (dmmu_inv_all_pend & ~dtlb_done_d1) ;
//assign	tlu_dtlb_invalidate_all_g = dmmu_inv_all_g | (dmmu_inv_all_pend & ~lsu_tlu_dtlb_done) ;

// Timing Change : Delay by a cycle to match vlds.
wire  pre_dtlb_dmp_all, pre_dtlb_dmp_pctxt ;
wire pre_dtlb_dmp_sctxt, pre_dtlb_dmp_nctxt, pre_dtlb_dmp_actxt ;
//assign	pre_dtlb_dmp_by_ctxt = (ddemap_by_ctxt | dtlb_dmp_by_ctxt_pend) & ~tlu_admp_key_sel  ;
assign	pre_dtlb_dmp_all = (ddemap_all | dtlb_dmp_all_pend) & ~tlu_admp_key_sel ;
assign	pre_dtlb_dmp_pctxt = (dtlb_dmp_pctxt_pend) & ~tlu_admp_key_sel ;
assign	pre_dtlb_dmp_sctxt = (dtlb_dmp_sctxt_pend) & ~tlu_admp_key_sel ;
assign	pre_dtlb_dmp_nctxt = (dtlb_dmp_nctxt_pend) & ~tlu_admp_key_sel ;
assign	pre_dtlb_dmp_actxt = tlu_admp_key_sel ;

dff_s  #(5) dmp_stgd1 (
        .din    ({pre_dtlb_dmp_all, pre_dtlb_dmp_pctxt,
		pre_dtlb_dmp_sctxt, pre_dtlb_dmp_nctxt, pre_dtlb_dmp_actxt}),
        .q      ({tlu_dtlb_dmp_all_g,tlu_dtlb_dmp_pctxt_g,
		tlu_dtlb_dmp_sctxt_g,tlu_dtlb_dmp_nctxt_g,tlu_dtlb_dmp_actxt_g}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

assign	tlu_idtlb_dmp_thrid_g = tlb_access_tid_g[1:0] | idtlb_dmp_thrid_pend[1:0] ;


//=========================================================================================
//	MMU ASI Decode - I-Side
//=========================================================================================

// Assumption is that only 9 bits of VA are required.
// Comparison for asi-state and va is to be done uniformly in w2.

	assign	immu_tsb_en =
			immu_zctxt_ps0_tsb_en  | immu_zctxt_ps1_tsb_en |
			immu_nzctxt_ps0_tsb_en | immu_nzctxt_ps1_tsb_en ;

reg immu_csm_in_en_m, immu_csm_access_en_m;

reg	immu_data_in_en_m,immu_data_access_en_m,immu_tag_read_en_m,immu_demap_en_m;

// M-stage decoding for long-latency tlb accesses
always	@ (/*AUTOSENSE*/immu_inv_all_asi or lsu_tlu_tlb_asi_state_m
           or lsu_tlu_tlb_ldst_va_m[7:0] or tlb_ldst_inst_m)
	begin
		immu_data_in_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h54,8'h00}) & tlb_ldst_inst_m ;  	
		// Address specifies tlb entry.
		immu_invalidate_all_en_m =
		 immu_inv_all_asi & tlb_ldst_inst_m ;
		 //({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h60,8'h00}) & tlb_ldst_inst_m ;
		immu_data_access_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h55}) & tlb_ldst_inst_m ; 	
		// Address specifies tlb entry.
		immu_tag_read_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h56}) & tlb_ldst_inst_m ; 	
		immu_demap_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h57}) & tlb_ldst_inst_m ; 
        
		immu_csm_in_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0],lsu_tlu_tlb_ldst_va_m[7:0]} == {8'h0E,8'h00}) & tlb_ldst_inst_m ;  	
		immu_csm_access_en_m =
		 ({lsu_tlu_tlb_asi_state_m[7:0]} == {8'h12}) & tlb_ldst_inst_m ; 	
        	
	end

// Stage to g.
// Convert to dffre to resolve conflict between fast-asi and lng-ltncy reads.


dffre_s #(7) itlbacc_stgg (
        .din    ({immu_csm_in_en_m,immu_csm_access_en_m,immu_data_in_en_m,immu_data_access_en_m,
                  immu_tag_read_en_m,immu_demap_en_m,immu_invalidate_all_en_m}),
        .q      ({immu_csm_in_en, immu_csm_access_en,immu_data_in_en,immu_data_access_en,
                  immu_tag_read_en,immu_demap_en,immu_invalidate_all_en}),
        .clk    (clk),
	.rst	(lng_ltncy_rst), 	.en	(lng_ltncy_en),
        .se     (1'b0),       .si (),          .so ()
        );  










assign	isfsr_asi_wr_en[0] = immu_sync_fsr_en & st_inst_g & thread0_sel_g ;
assign	isfsr_asi_wr_en[1] = immu_sync_fsr_en & st_inst_g & thread1_sel_g ;
assign	isfsr_asi_wr_en[2] = immu_sync_fsr_en & st_inst_g & thread2_sel_g ;
assign	isfsr_asi_wr_en[3] = immu_sync_fsr_en & st_inst_g & thread3_sel_g ;

assign	immu_any_sfsr_wr = immu_sync_fsr_en & st_inst_g ; //|(isfsr_asi_wr_en[3:0]);

assign	immu_sfsr_wr_en_l[3:0] = ~(isfsr_trp_wr[3:0] | isfsr_asi_wr_en[3:0]) ;

assign	immu_tsb_rd_en[0] = immu_tsb_en & ld_inst_g & thread0_sel_g ;
assign	immu_tsb_rd_en[1] = immu_tsb_en & ld_inst_g & thread1_sel_g ;
assign	immu_tsb_rd_en[2] = immu_tsb_en & ld_inst_g & thread2_sel_g ;
assign	immu_tsb_rd_en[3] = immu_tsb_en & ld_inst_g & thread3_sel_g ;

assign	immu_data_in_wr_en = immu_data_in_en & tlb_st_inst_g ;	// Write-Only.
assign	immu_data_access_wr_en = immu_data_access_en & tlb_st_inst_g ;
assign	immu_data_access_rd_en = immu_data_access_en & tlb_ld_inst_g ;


wire immu_csm_access_rd_en;
assign	immu_csm_in_wr_en = immu_csm_in_en & tlb_st_inst_g ;	// Write-Only.
assign	immu_csm_access_wr_en = immu_csm_access_en & tlb_st_inst_g ;
assign	immu_csm_access_rd_en = immu_csm_access_en & tlb_ld_inst_g ;


assign	immu_tag_read_rd_en = immu_tag_read_en & tlb_ld_inst_g ;


assign	itlb_rw_index_vld_g = immu_csm_access_rd_en | immu_csm_access_wr_en | 
                              immu_data_access_rd_en | immu_data_access_wr_en | immu_tag_read_rd_en ;
// terminate write if tlb full and signal exception.
assign	itlb_wr_vld_g = (immu_csm_in_wr_en | immu_csm_access_wr_en |
                         immu_data_in_wr_en | immu_data_access_wr_en) & ~ifu_lsu_memref_d ;







wire itlb_wr_csm_sel_g;
wire itlb_wr_csm_sel_pend;
assign itlb_wr_csm_sel_g = immu_csm_in_wr_en | immu_csm_access_wr_en;
dffre_s  #(1) stgw2_itlbcsm (
        .din    (itlb_wr_csm_sel_g),
        .q    	(itlb_wr_csm_sel_pend),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  




wire	itlb_rw_index_vld_pend ;

dffre_s #(1)  stgw2_itlbctl (
        .din    (itlb_rw_index_vld_g),
        .q    	(itlb_rw_index_vld_pend),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	tlu_itlb_rw_index_vld_g  = itlb_rw_index_vld_g | (itlb_rw_index_vld_pend & ~itlb_done_d1) ;
assign	tlu_itlb_rw_index_g[5:0] = tlu_dtlb_rw_index_g[5:0] ;


assign	tlu_itlb_wr_csm_sel_g = (itlb_wr_csm_sel_g & {~(tlb_admp_mode | tlb_write_mode | tlb_rd_mode_d1)})  | 
					itlb_wr_csm_sel_pend ;


assign	idemap_by_page  = immu_demap_en & ~tlb_ldst_va_g[7] & ~tlb_ldst_va_g[6] ;
assign	idemap_by_ctxt  = immu_demap_en & ~tlb_ldst_va_g[7] &  tlb_ldst_va_g[6] ;
assign	idemap_all      = immu_demap_en &  tlb_ldst_va_g[7] & ~tlb_ldst_va_g[6] ;

// assumption is that demap_all is unaffected by presence of reserved ctxt as it
// does not use ctxt.
assign	idemap_vld  	= ((idemap_by_page | idemap_by_ctxt) & ~(demap_resrv | demap_sctxt)) | 
				idemap_all ;

wire	itlb_dmp_by_ctxt_pend ;
wire	itlb_dmp_all_pend ;
wire	immu_inv_all_g, immu_inv_all_pend ;

assign	immu_inv_all_g = immu_invalidate_all_en & tlb_st_inst_g ;

// Demap
dffre_s  #(3) stgw2_itlbdmp (
        .din    ({idemap_by_ctxt,idemap_all,immu_inv_all_g}),
        .q    	({itlb_dmp_by_ctxt_pend, itlb_dmp_all_pend,immu_inv_all_pend}),
	.rst	(tlb_access_rst),	.en	(tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	tlu_itlb_dmp_all_g = (idemap_all | itlb_dmp_all_pend) & ~tlu_admp_key_sel ;

assign	tlu_itlb_invalidate_all_g = immu_inv_all_g | (immu_inv_all_pend & ~itlb_done_d1) ;
assign	tlu_itlb_dmp_pctxt_g = tlu_dtlb_dmp_pctxt_g ;  

// Timing Change - delay by 1-cycle to match vld.
wire	pre_itlb_dmp_actxt ;
assign	pre_itlb_dmp_actxt = tlu_admp_key_sel ;
dff_s  #(1) preidmp_d1 (
        .din    (pre_itlb_dmp_actxt),
        .q    	(tlu_itlb_dmp_actxt_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	tlu_itlb_dmp_nctxt_g = tlu_dtlb_dmp_nctxt_g ;  


// Adapt key vlds to autodemap.
// Note that sense of global bit has changed. Otherwise vlds remain same.
assign	tlu_dmp_key_vld_g[4:0] = 
	(ddemap_by_ctxt | idemap_by_ctxt) ? 5'b00000 : 			// demap-ctxt - include only ctxt 
			(ddemap_all | idemap_all) ? 5'b00001 : 		// demap-all - do not include va or ctxt
			// Bug 3129		5'b11110 ;	        // else include both va and ctxt
				tlb_ldst_va_g[9] ? 5'b11111 :           // include va and NO ctxt;dmp-pg-real
                                                       5'b11110 ;       // include both va and ctxt; dmp-pg

// real tte for demap and write. both are indicated in bit 9 of va.
// demap_by_ctxt will not effect real translations.
assign	tlu_tte_real_g = tlb_ldst_va_g[9] & ~(ddemap_by_ctxt | idemap_by_ctxt) ;

//=========================================================================================
//	EXCEPTIONS
//=========================================================================================

// Now generated in LSU.

// These are all related to asi use.
/*assign	tlu_mmu_sync_data_excp_g = 
	(immu_sync_rd_only_asi_g | dmmu_sync_rd_only_asi_g) & st_inst_unflushed & inst_vld_g  ;*/

//=========================================================================================
//	TAG/DATA RD/WR/DMP HANDSHAKE
//=========================================================================================

// RD/WR HANDSHAKE
// Need to add autodemap capability.

// Assume mutually exclusive by construction.


assign	tlb_access_en = itlb_wr_vld_g | immu_data_access_rd_en | immu_tag_read_rd_en | immu_csm_access_rd_en |
			dtlb_wr_vld_g | dmmu_data_access_rd_en | dmmu_tag_read_rd_en | dmmu_csm_access_rd_en |
			idemap_vld    | ddemap_vld | immu_inv_all_g | dmmu_inv_all_g ;





assign	tlb_access_en_l = ~tlb_access_en ;
assign	tlb_access_rst = ~rst_l | ((lsu_tlu_dtlb_done | ifu_tlu_itlb_done) & ~(tlb_admp_mode | tlb_admp_mode_d1)) ; 
assign 	tlb_access_rst_l = ~tlb_access_rst ;	

wire	tlb_access_en_l_d1 ;
dff_s  #(1) stgd1_tlbacc (
        .din    (tlb_access_en_l),
        .q      (tlb_access_en_l_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

assign	tlu_tlb_access_en_l_d1 = tlb_access_en_l_d1 | sehold ;


assign	itlb_tag_rd_en = immu_tag_read_rd_en | immu_data_access_rd_en | immu_csm_access_rd_en;	
assign	dtlb_tag_rd_en = dmmu_tag_read_rd_en | dmmu_data_access_rd_en | dmmu_csm_access_rd_en;	







dffre_s #(10)  tlb_access (
        .din    ({immu_csm_access_rd_en, dmmu_csm_access_rd_en,itlb_wr_vld_g,immu_data_access_rd_en,itlb_tag_rd_en,
        	dtlb_wr_vld_g,dmmu_data_access_rd_en,dtlb_tag_rd_en,
		idemap_vld, ddemap_vld}),
        .q    	({itlb_csm_rd_pend,dtlb_csm_rd_pend,itlb_wr_pend,itlb_data_rd_pend,itlb_tag_rd_pend,
        	dtlb_wr_pend,dtlb_data_rd_pend,dtlb_tag_rd_pend,
		idemap_pend, ddemap_pend}),
        .rst    (tlb_access_rst),	.en     (tlb_access_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );















assign  tlu_dtlb_rd_done  = lsu_tlu_dtlb_done & (dtlb_data_rd_pend | dtlb_csm_rd_pend | dtlb_tag_rd_pend) ;



//assign  itlb_rd_done  = ifu_tlu_itlb_done & (itlb_data_rd_pend | itlb_tag_rd_pend) ;


// w2 should be renamed to g at some time !!!
// Write may take one extra cycle to get initiated !!!
assign	itlb_wr_vld_unmsked = (itlb_wr_vld_g | (itlb_wr_pend & ~itlb_done_d1)) ;
wire    pre_itlb_wr_vld_g ;
assign pre_itlb_wr_vld_g = (itlb_wr_pend & ~itlb_done_d1) & tlb_write_mode ;
//assign pre_itlb_wr_vld_g = itlb_wr_vld_unmsked & tlb_write_mode ;
// name kept as _g for now to avoid interface change.

assign	tlu_itlb_wr_vld_g = pre_itlb_wr_vld_g ;
/*dff  #(1) iwvld_d1 (
        .din    (pre_itlb_wr_vld_g),
        .q    	(tlu_itlb_wr_vld_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        ); */


assign	tlu_itlb_csm_rd_g = immu_csm_access_rd_en | (itlb_csm_rd_pend & ~itlb_done_d1) ;

assign	tlu_itlb_data_rd_g = immu_data_access_rd_en | (itlb_data_rd_pend & ~itlb_done_d1) ;
assign	tlu_itlb_tag_rd_g = (immu_tag_read_rd_en | immu_data_access_rd_en) | (itlb_tag_rd_pend & ~itlb_done_d1) ;

assign	dtlb_wr_vld_unmsked = (dtlb_wr_vld_g | (dtlb_wr_pend & ~dtlb_done_d1)) ;
wire    pre_dtlb_wr_vld_g ;
assign pre_dtlb_wr_vld_g = (dtlb_wr_pend & ~dtlb_done_d1) & tlb_write_mode ;
// name kept as _g for now to avoid interface change.

//assign	tlu_dtlb_wr_vld_g = pre_dtlb_wr_vld_g ;

assign	tlu_dtlb_csm_rd_g = dmmu_csm_access_rd_en | (dtlb_csm_rd_pend & ~dtlb_done_d1) ;

assign	tlu_dtlb_data_rd_g = dmmu_data_access_rd_en | (dtlb_data_rd_pend & ~dtlb_done_d1) ;
assign	tlu_dtlb_tag_rd_g = (dmmu_tag_read_rd_en | dmmu_data_access_rd_en) | (dtlb_tag_rd_pend & ~dtlb_done_d1) ;

// Delay by a cycle - rd for long-latency matches fast-asi.
// Both occur on a posedge.

wire	dtlb_dmp_vld_g,itlb_dmp_vld_g;
assign	dtlb_dmp_vld_g = 
		// qual with dtlb-done may not be needed. Taken into account in ddemap_pend.
		(ddemap_pend & ~dtlb_done_d1) | 
		(dtlb_wr_vld_unmsked & tlb_admp_mode) ;
assign	itlb_dmp_vld_g = 
		(idemap_pend & ~itlb_done_d1) |
		(itlb_wr_vld_unmsked & tlb_admp_mode) ; 
// dmp_vld should be w2. kept as _g for now to avoid
// interface change.
wire	dtlb_dmp_vld_d1,itlb_dmp_vld_d1 ;
dff_s  #(2) dmpvld_d1 (
        .din    ({dtlb_dmp_vld_g,itlb_dmp_vld_g}),
        .q    	({dtlb_dmp_vld_d1,itlb_dmp_vld_d1}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );
assign	tlu_dtlb_dmp_vld_g = dtlb_dmp_vld_d1 & ~dtlb_done_d1 ;
assign	tlu_itlb_dmp_vld_g = itlb_dmp_vld_d1 & ~itlb_done_d1 ;

wire	stxa_ack ;

// Assume mutually exclusive.
// Third term is meant to complete demap with reserved ctxt.
assign	stxa_ack = 
	(((itlb_wr_pend | dtlb_wr_pend) & ~(tlb_admp_mode | tlb_admp_mode_d1)) 	| 
	idemap_pend | ddemap_pend | immu_inv_all_pend | dmmu_inv_all_pend) & (lsu_tlu_dtlb_done | ifu_tlu_itlb_done) 	|
	(demap_resrv & tlb_st_inst_g & 
		((immu_demap_en & ~idemap_all)  | (dmmu_demap_en & ~ddemap_all))) | //5053
	(demap_sctxt & tlb_st_inst_g & (immu_demap_en & ~idemap_all)) | // Bug5053				  
						// iside should not use sctxt
	// lng-latency store needs to signal cmplt to lsu even with illegal va
	(tlb_st_inst_unflushed & (dmmu_async_illgl_va_g | immu_async_illgl_va_g)) ;

dff_s  #(1) stack_d1 (
        .din    (stxa_ack),
        .q    	(tlu_lsu_stxa_ack),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================
//	AUTODEMAP
//=========================================================================================


assign	tlb_wr_vld_g = itlb_wr_vld_unmsked | dtlb_wr_vld_unmsked ;

assign	tlb_admp_en   = tlb_wr_vld_g & ~tlb_admp_mode & ~tlb_write_mode ;
assign	tlb_admp_rst  = ~rst_l | 
	(((itlb_wr_pend | dtlb_wr_pend) & (lsu_tlu_dtlb_done | ifu_tlu_itlb_done)) & tlb_admp_mode) ;
assign	tlb_wr_rst  = ~rst_l | 
	(((itlb_wr_pend | dtlb_wr_pend) & (lsu_tlu_dtlb_done | ifu_tlu_itlb_done)) 
			& tlb_write_mode & ~tlb_admp_mode_d1) ;

assign	tlu_admp_key_sel = (dtlb_wr_vld_g | itlb_wr_vld_g) | tlb_admp_mode ;

// 1st Phase - Autodemap
dffre_s  #(1) dmp1_ff (
        .din    (tlb_wr_vld_g),
        .q    	(tlb_admp_mode),
	.rst	(tlb_admp_rst),	.en	(tlb_admp_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );


// this is temporary - IFU is spuriously sourcing extra done signal.
dff_s  #(1) admp_d1 (
        .din    (tlb_admp_mode),
        .q    	(tlb_admp_mode_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// 2nd Phase - Follow-up with Write
dffre_s  #(1) dmp2_ff (
        .din    (tlb_admp_rst),
        .q    	(tlb_write_mode),
	.rst	(tlb_wr_rst),	.en	(tlb_admp_rst),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire    tlu_ldxa_async_data_vld ;
assign  tlu_ldxa_async_data_vld =
        tlu_dtlb_rd_done                |
        (tlb_ld_inst_unflushed & (dmmu_async_illgl_va_g | immu_async_illgl_va_g)) ;

assign	tlu_dldxa_data_vld = 
// ** need to qualify with inst_vld in LSU
	((dmmu_tag_target_en_m 	|
	 dmmu_8k_ptr_en_m 	| 
	 dmmu_64k_ptr_en_m 	|
	 dmmu_direct_ptr_en_m   |
	 dmmu_tsb_en_m		|
	 dmmu_tag_access_en_m   |
         dmmu_sync_fsr_en_m     |
         dmmu_sync_far_en_m     |
         dmmu_ctxt_cfg_en_m) & ld_inst_m) ;
	//tlu_dtlb_rd_done		| // complete thru lsu
	// for sync/async lng-latency ldxa with illegal va
	// MMU_ASI
	//(ld_inst_g & dmmu_sync_illgl_va_g) |
	//(tlb_ld_inst_unflushed & dmmu_async_illgl_va_g) ;

assign	tlu_ildxa_data_vld = 
// ** need to qualify with inst_vld in LSU
	((immu_tag_target_en_m  	| 
	 immu_8k_ptr_en_m  	 	| 
	 immu_64k_ptr_en_m 		|
 	 immu_tsb_en_m                  |
         immu_tag_access_en_m           |
         immu_sync_fsr_en_m             |
         immu_ctxt_cfg_en_m) & ld_inst_m)  ;
	// for sync/async lng-latency ldxa with illegal va
 	// MMU_ASI
	//(ld_inst_g & immu_sync_illgl_va_g) |
	//(tlb_ld_inst_unflushed & immu_async_illgl_va_g) ;

assign  tlu_ldxa_data_vld = tlu_ildxa_data_vld | tlu_dldxa_data_vld ;

 	// Flush needs to be removed.
	assign	lsu_exu_ldxa_m = tlu_ldxa_data_vld & ~(dmmu_sync_illgl_va_m | immu_sync_illgl_va_m);

dff_s #(1) stg_asyncdvld (
        .din    (tlu_ldxa_async_data_vld),
        .q    	(tlu_lsu_ldxa_async_data_vld),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================
//	SFSR/SFAR Control
//=========================================================================================

// In tcl

//=========================================================================================
//	PS0 and PS1 Ptr Registers (NEW !!!!)
//=========================================================================================

// If N=TSB_Size, P=Page_Size, then
// Ptr = TSB_Base<63:13+N> | VA<21+N+3xP:13+3xP> | 0000	if TSB not split
// Ptr = TSB_Base<63:14+N> | 0 | VA<21+N+3xP:13+3xP> | 0000 if TSB split
// Assume P=0(8K),1(64K),3(4M),5(256M).
// Note that Nmax=11 even though N=0..15, for 256M page. This is because VA cannot exceed 47 for ms bit.
// Otherwise entire range of N can be covered by all 3 remaining page-size.

// Timing :
//
//	|   D-stage  |	E-stage	| M-stage | W-stage    |	
//	| Read setup | Read +	| Logic + | Latched in |
//	| to mra     | Logic	| xmit	  | LSU. Select|	
//	|	     |		|	  | for wr-back|	
//

// TSB Size Logic - Form 8 bits for 8k and 64k Ptr regs respectively.

// Macrotest support for logic in shadow of mra scan collar.
// Scan only. Scan value valid in 2nd cycle of macrotest.
wire	mtest_rdps0_sel ;
dff_s  #(1) rps0d_d1 (
        .din    (1'b0),
        .q      (mtest_rdps0_sel),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

wire	tsb_rd_ps0_sel ;
assign	tlu_tsb_rd_ps0_sel = tsb_rd_ps0_sel ;
assign	tsb_rd_ps0_sel = 
			((dmmu_8k_ptr_e | immu_8k_ptr_e | 
			// really _m stage.
			dmmu_direct_8kptr_sel_g) & ~sehold_d1) | // direct-ptr selects ps0
			(mtest_rdps0_sel & sehold_d1) ;

// Choose between zero and non-zero context
assign	tsb_size[3:0]	=  
	tsb_rd_ps0_sel ? tlu_dtsb_size_w2[3:0] : tlu_itsb_size_w2[3:0] ;
assign	tsb_split	= 
	tsb_rd_ps0_sel ? tlu_dtsb_split_w2 : tlu_itsb_split_w2 ;
// Mux'ed and staged in mmu_dp.
assign	tag_access[47:13] = tlu_dtag_access_w2[47:13] ;
wire	[2:0]	page_size,tsb_page_size_g ;
assign	page_size[2:0] = tsb_page_size_g[2:0] ;

// Currently, all the logic is done in one stage. This will have to
// be rearranged once the read of the mra is advanced. 

wire	pg8k,pg64k,pg4M;
assign	pg8k  	= ~page_size[2] & ~page_size[1] & ~page_size[0] ; // 000
assign	pg64k 	= ~page_size[2] & ~page_size[1] &  page_size[0] ; // 001
assign	pg4M    = ~page_size[2] &  page_size[1] &  page_size[0] ; // 011
//assign	pg256M  =  page_size[2] & ~page_size[1] &  page_size[0] ; // 101

// Mux tag-access <36:13>,<39:13>,<45:22>,<51:28> based on page-size.
// Notebook contains greater detail of mapping of base,tag-access to ptr.
wire	[23:0]	va ; 
assign	va[23:0] = pg8k ? tag_access[36:13] : 
			pg64k ? tag_access[39:16] :	
				pg4M ? tag_access[45:22] :	
					 	{{5{tag_access[47]}},tag_access[46:28]} ;// 256M	
					 	//{4'b0000,tag_access[47:28]} ;	// 256M	// Bug3727

// The ptr address is broken up into 3 regions :
// ptr<3:0>=4'b0000,		     : constant
// ptr<12:4>=va<8:0>		     : va from tag-access only 	
// ptr<27:13>=va<23:9>/base<27:13>/0/1 : va from tag-access OR tsb base address OR '0/1' (split).
// ptr<28>=base<28>/0/1		     : tsb base address OR '0' (split).
// ptr<47:29>=base<47:29>	     : tsb base address. 

// Assuming N=0..15. Could be reduced to N=11.
// Need to take exception for unused page size and value of N not compatible with selected page-size.

wire [28:13] ptr ;
wire	ps1;
assign ps1 = ~tsb_rd_ps0_sel ;
 
// This is an obvious flop boundary break. 

wire	[3:0] tsb_size_d1 ;
wire	tsb_split_d1 ;
wire	[47:13] tsb_base_d1 ;
wire	ps1_d1 ;
wire	[23:0] 	va_d1 ;

dff_s  #(4) tsbsize_stgd1 (
        .din    (tsb_size[3:0]),
        .q      (tsb_size_d1[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

dff_s  #(1) tsbsplit_stgd1 (
        .din    (tsb_split),
        .q      (tsb_split_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

assign	tsb_base_d1[47:13] = tlu_tsb_base_w2_d1[47:13] ;

dff_s  #(1) ps1_stgd1 (
        .din    (ps1),
        .q      (ps1_d1),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

dff_s  #(24) va_stgd1 (
        .din    (va[23:0]),
        .q      (va_d1[23:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
) ;

// These equations have to be optimized.
assign	ptr[28] = ((tsb_size_d1==4'd15) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[28] ;
assign	ptr[27] = (tsb_size_d1==4'd15) ? va_d1[23] : ((tsb_size_d1==4'd14) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[27] ;
assign	ptr[26] = (tsb_size_d1>=4'd14) ? va_d1[22] : ((tsb_size_d1==4'd13) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[26] ;
assign	ptr[25] = (tsb_size_d1>=4'd13) ? va_d1[21] : ((tsb_size_d1==4'd12) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[25] ;
assign	ptr[24] = (tsb_size_d1>=4'd12) ? va_d1[20] : ((tsb_size_d1==4'd11) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[24] ;
assign	ptr[23] = (tsb_size_d1>=4'd11) ? va_d1[19] : ((tsb_size_d1==4'd10) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[23] ;
assign	ptr[22] = (tsb_size_d1>=4'd10) ? va_d1[18] : ((tsb_size_d1==4'd9) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[22] ;
assign	ptr[21] = (tsb_size_d1>=4'd9) ? va_d1[17] : ((tsb_size_d1==4'd8) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[21] ;
assign	ptr[20] = (tsb_size_d1>=4'd8) ? va_d1[16] : ((tsb_size_d1==4'd7) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[20] ;
assign	ptr[19] = (tsb_size_d1>=4'd7) ? va_d1[15] : ((tsb_size_d1==4'd6) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[19] ;
assign	ptr[18] = (tsb_size_d1>=4'd6) ? va_d1[14] : ((tsb_size_d1==4'd5) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[18] ;
assign	ptr[17] = (tsb_size_d1>=4'd5) ? va_d1[13] : ((tsb_size_d1==4'd4) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[17] ;
assign	ptr[16] = (tsb_size_d1>=4'd4) ? va_d1[12] : ((tsb_size_d1==4'd3) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[16] ;
assign	ptr[15] = (tsb_size_d1>=4'd3) ? va_d1[11] : ((tsb_size_d1==4'd2) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[15] ;
assign	ptr[14] = (tsb_size_d1>=4'd2) ? va_d1[10] : ((tsb_size_d1==4'd1) & tsb_split_d1) ? ps1_d1 : tsb_base_d1[14] ;
assign	ptr[13] = (tsb_size_d1>=4'd1) ? va_d1[9] :  tsb_split_d1 ? ps1_d1 : tsb_base_d1[13] ;

// TSB 8K Ptr. This maps to tsb ps0 ptr !!!
// This is mapped to either PS0 or PS1 ptr. Do not need to send
// 8k and 64K ptrs to mmu_dp.
// Direct ptr needs to be accounted for.
assign	tlu_idtsb_8k_ptr[47:0] = 
	{tsb_base_d1[47:29],
	ptr[28:13],
	va_d1[8:0],
	4'b0000};

//=========================================================================================
//	Establishing Context for Ptr Read
//=========================================================================================

// Context of Ptr Read determined by context within d/i tag-access register. 
// Markers per thread will be maintained to determine whether any subsequent 
// ptr access is made in nucleus or non-nucleus context.
// Note i and d tag-access can be merged within tlu_mmu_dp.v

// write of tag-access ctxt needs to be setup in M for subsequent read of MRA in M.

assign	tsb_page_size_g[2:0] = tsb_rd_ps0_sel ? tlu_ctxt_cfg_w2[2:0] : tlu_ctxt_cfg_w2[5:3] ; 

// Listening Flops for Macrotest of mra.
dff_s #(6) ctxtcfg_listen (
        .din    (tlu_ctxt_cfg_w2[5:0]),
        .q      (),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );



//=========================================================================================
//	Direct Ptr State
//=========================================================================================

// For new ptr support, if page-size of tte matches that of ps1 then
// direct-ptr maps to ps1-ptr else ps0-ptr.

wire	daccess_prot_qual ;
assign	daccess_prot_qual = 
lsu_tlu_daccess_prot_g & ~lsu_tlu_daccess_excptn_g & 
inst_vld_g & ~(priority_squash_g | flush_mmuasi_wr) ;

// For SPARC_HPV_EN, 64k represents ps1 ptr.
assign	dptr0_pg64k_en = daccess_prot_qual & thread0_sel_g ;
assign	dptr1_pg64k_en = daccess_prot_qual & thread1_sel_g ;
assign	dptr2_pg64k_en = daccess_prot_qual & thread2_sel_g ;
assign	dptr3_pg64k_en = daccess_prot_qual & thread3_sel_g ;

// For SPARC_HPV_EN this means ps0 sel. This should be an internal
// wire with SPARC_HPV_EN
assign	dmmu_direct_8kptr_sel_g  = 
	dmmu_direct_ptr_e & ((thread0_e & ~dptr0_pg64k_vld) |
				(thread1_e & ~dptr1_pg64k_vld) |
				(thread2_e & ~dptr2_pg64k_vld) |
				(thread3_e & ~dptr3_pg64k_vld));
wire	dptr_state_din ;
	assign dptr_state_din = dacc_prot_ps1_match ;

dffre_s  #(1) dptrstate_0 (
        .din    (dptr_state_din),
        .q    	(dptr0_pg64k_vld),
	.rst	(~rst_l),	.en	(dptr0_pg64k_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dffre_s  #(1) dptrstate_1 (
        .din    (dptr_state_din),
        .q    	(dptr1_pg64k_vld),
	.rst	(~rst_l),	.en	(dptr1_pg64k_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dffre_s  #(1) dptrstate_2 (
        .din    (dptr_state_din),
        .q    	(dptr2_pg64k_vld),
	.rst	(~rst_l),	.en	(dptr2_pg64k_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

dffre_s  #(1) dptrstate_3 (
        .din    (dptr_state_din),
        .q    	(dptr3_pg64k_vld),
	.rst	(~rst_l),	.en	(dptr3_pg64k_en),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );  

//=========================================================================================
//	PS1 PAGE SIZE FOR DMMU
//=========================================================================================

// Maintain ps1 page-size for dmmu zero/non-zero ctxt. This is required to compare
// against the page-size of the tte on a data-access-protection to set-up the
// direct-pointer. Note that the real copy is in the mra.

wire [2:0] zctxt_cfg0_ps1,zctxt_cfg1_ps1,zctxt_cfg2_ps1,zctxt_cfg3_ps1;
wire [2:0] nzctxt_cfg0_ps1,nzctxt_cfg1_ps1,nzctxt_cfg2_ps1,nzctxt_cfg3_ps1;
wire [3:0] dzctxt_cfg_wr_en ;
wire [3:0] dnzctxt_cfg_wr_en ;

assign	dzctxt_cfg_wr_en[3] = dmmu_zctxt_cfg_en & st_inst_g & thread3_sel_g ;
assign	dzctxt_cfg_wr_en[2] = dmmu_zctxt_cfg_en & st_inst_g & thread2_sel_g ;
assign	dzctxt_cfg_wr_en[1] = dmmu_zctxt_cfg_en & st_inst_g & thread1_sel_g ;
assign	dzctxt_cfg_wr_en[0] = dmmu_zctxt_cfg_en & st_inst_g & thread0_sel_g ;

assign	dnzctxt_cfg_wr_en[3] = dmmu_nzctxt_cfg_en & st_inst_g & thread3_sel_g ;
assign	dnzctxt_cfg_wr_en[2] = dmmu_nzctxt_cfg_en & st_inst_g & thread2_sel_g ;
assign	dnzctxt_cfg_wr_en[1] = dmmu_nzctxt_cfg_en & st_inst_g & thread1_sel_g ;
assign	dnzctxt_cfg_wr_en[0] = dmmu_nzctxt_cfg_en & st_inst_g & thread0_sel_g ;

// Thread0
// Zero-Ctxt Cfg PS1
dffe_s #(3)   zctxtps1_0 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(zctxt_cfg0_ps1[2:0]),
        .en 	(dzctxt_cfg_wr_en[0]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Non-Zero-Ctxt Cfg PS1
dffe_s #(3)   nzctxtps1_0 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(nzctxt_cfg0_ps1[2:0]),
        .en 	(dnzctxt_cfg_wr_en[0]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread1
// Zero-Ctxt Cfg PS1
dffe_s #(3)   zctxtps1_1 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(zctxt_cfg1_ps1[2:0]),
        .en 	(dzctxt_cfg_wr_en[1]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Non-Zero-Ctxt Cfg PS1
dffe_s #(3)   nzctxtps1_1 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(nzctxt_cfg1_ps1[2:0]),
        .en 	(dnzctxt_cfg_wr_en[1]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread2
// Zero-Ctxt Cfg PS1
dffe_s #(3)   zctxtps1_2 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(zctxt_cfg2_ps1[2:0]),
        .en 	(dzctxt_cfg_wr_en[2]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Non-Zero-Ctxt Cfg PS1
dffe_s #(3)   nzctxtps1_2 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(nzctxt_cfg2_ps1[2:0]),
        .en 	(dnzctxt_cfg_wr_en[2]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Thread3
// Zero-Ctxt Cfg PS1
dffe_s #(3)   zctxtps1_3 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(zctxt_cfg3_ps1[2:0]),
        .en 	(dzctxt_cfg_wr_en[3]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );

// Non-Zero-Ctxt Cfg PS1
dffe_s #(3)   nzctxtps1_3 (
        .din    (lsu_tlu_st_rs3_data_b12t0_g[10:8]), 
	.q  	(nzctxt_cfg3_ps1[2:0]),
        .en 	(dnzctxt_cfg_wr_en[3]), 	.clk (clk),
        .se     (1'b0),       	.si (),          .so ()
        );


wire [2:0] zctxt_cfg_ps1,nzctxt_cfg_ps1 ;

assign	zctxt_cfg_ps1[2:0] =
	thread0_sel_g ? zctxt_cfg0_ps1[2:0] :
		thread1_sel_g ? zctxt_cfg1_ps1[2:0] :
			thread2_sel_g ? zctxt_cfg2_ps1[2:0] :
						zctxt_cfg3_ps1[2:0] ;

assign	nzctxt_cfg_ps1[2:0] =
	thread0_sel_g ? nzctxt_cfg0_ps1[2:0] :
		thread1_sel_g ? nzctxt_cfg1_ps1[2:0] :
			thread2_sel_g ? nzctxt_cfg2_ps1[2:0] :
						nzctxt_cfg3_ps1[2:0] ;
wire	nucleus_ctxt_g ;
dff_s nctxt_stgg(
        .din    (lsu_tlu_nucleus_ctxt_m),
        .q      (nucleus_ctxt_g),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	ctxt_cfg_ps1 ;
assign	ctxt_cfg_ps1[2:0] = 
	nucleus_ctxt_g ? zctxt_cfg_ps1[2:0] : nzctxt_cfg_ps1[2:0] ;

assign	dacc_prot_ps1_match
	= (lsu_tlu_tte_pg_sz_g[2:0] == ctxt_cfg_ps1[2:0]) ;

//=========================================================================================
//	CTXT SEL
//=========================================================================================

wire	thread_tl_zero_e,thread_tl_zero_m ;
assign thread_tl_zero_e =
        thread0_e ? tlu_lsu_tl_zero[0] :
                thread1_e ? tlu_lsu_tl_zero[1] :
                        thread2_e ? tlu_lsu_tl_zero[2] : tlu_lsu_tl_zero[3];

dff_s tlz_stgm(
        .din    (thread_tl_zero_e),
        .q      (thread_tl_zero_m),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

// Generate selects for ctxt to be written to tag_access
// iside trap meant to cover immu_miss and inst_access_excp
// modified for hypervisor support
// assign       iside_trap = exu_tlu_ttype_vld_m | immu_va_oor_brnchetc_m | exu_tlu_va_oor_jl_ret_m;

wire	pstate_am_e,pstate_am_m;
assign  pstate_am_e =
        (thread0_e & tlu_lsu_pstate_am[0]) |
        (thread1_e & tlu_lsu_pstate_am[1]) |
        (thread2_e & tlu_lsu_pstate_am[2]) |
        (thread3_e & tlu_lsu_pstate_am[3]);

dff_s pam_stgm(
        .din    (pstate_am_e),
        .q      (pstate_am_m),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	immu_va_oor_brnchetc_m ;
assign  immu_va_oor_brnchetc_m
        = exu_tlu_va_oor_m & ~pstate_am_m & ~memref_m;

wire iside_trap ;
assign  iside_trap =
            ifu_tlu_immu_miss_m | // exu_tlu_ttype_vld_m : Rm along with Bug 5346
            immu_va_oor_brnchetc_m | exu_tlu_va_oor_jl_ret_m |
	    ifu_tlu_priv_violtn_m ; // Bug 5346.
assign  tlu_tag_access_ctxt_sel_m[0] = iside_trap &  thread_tl_zero_m;
assign  tlu_tag_access_ctxt_sel_m[1] = iside_trap & ~thread_tl_zero_m;
assign  tlu_tag_access_ctxt_sel_m[2] = ~iside_trap;


//=========================================================================================
//	TLB Write Data
//=========================================================================================

wire	[2:0]	pg_size ;
wire		page_8k, page_64k, page_4m ;
wire		va_15_13_vld, va_21_16_vld, va_27_22_vld ;

assign sun4r_tte_g = ~tlb_ldst_va_g[10] ; // trin todo; might be the top bit? ask yaosheng

assign tlu_sun4r_tte_g = sun4r_tte_g ;

assign 	pg_size[2:0] 	=  
	sun4r_tte_g ? {lsu_tlu_st_rs3_data_b48_g,lsu_tlu_st_rs3_data_g[62:61]} :
			{lsu_tlu_st_rs3_data_b12t0_g[2:0]} ;

assign	page_8k		= ~pg_size[2] & ~pg_size[1] & ~pg_size[0] ;	
assign	page_64k	= ~pg_size[2] & ~pg_size[1] &  pg_size[0] ;	
assign	page_4m		= ~pg_size[2] &  pg_size[1] &  pg_size[0] ;	
//assign	page_256m	=  pg_size[2] & ~pg_size[1] &  pg_size[0] ;	

assign	va_15_13_vld 	= page_8k ; 
assign	va_21_16_vld 	= page_8k | page_64k  ; 
assign	va_27_22_vld 	= page_8k | page_64k | page_4m ; 

assign	tlu_tte_tag_g[2:0] = {va_27_22_vld,va_21_16_vld,va_15_13_vld} ;
	
assign	thread0_async_g = ~tlb_access_tid_g[1] & ~tlb_access_tid_g[0] ;
assign	thread1_async_g = ~tlb_access_tid_g[1] &  tlb_access_tid_g[0] ;
assign	thread2_async_g =  tlb_access_tid_g[1] & ~tlb_access_tid_g[0] ;
//assign	thread3_async_g =  tlb_access_tid_g[1] &  tlb_access_tid_g[0] ; // to be used in instanced mux

assign	tlu_tte_wr_pid_g[2:0] =
	thread0_async_g ? lsu_pid_state0[2:0] : 
		thread1_async_g ? lsu_pid_state1[2:0] : 
			thread2_async_g ? lsu_pid_state2[2:0] : lsu_pid_state3[2:0] ;

// Error Injection :
// Error injection is one-shot. It will occur for either dmmu or immu. The ifu
// is informed once the error injection is accomplished.

wire	i_tag_invrt_par,d_tag_invrt_par ;
wire	i_data_invrt_par,d_data_invrt_par ;
assign tlu_tlb_tag_invrt_parity = i_tag_invrt_par | d_tag_invrt_par ;
assign i_tag_invrt_par = (ifu_lsu_error_inj[2] & (immu_data_in_en | immu_data_access_en)) ;
assign d_tag_invrt_par = (ifu_lsu_error_inj[0] & (dmmu_data_in_en | dmmu_data_access_en)) ;
assign tlu_tlb_data_invrt_parity = i_data_invrt_par | d_data_invrt_par ;
assign i_data_invrt_par = (ifu_lsu_error_inj[3] & (immu_data_in_en | immu_data_access_en)) ;
assign d_data_invrt_par = (ifu_lsu_error_inj[1] & (dmmu_data_in_en | dmmu_data_access_en)) ;

wire tlb_wr_vld ;
assign tlb_wr_vld = dtlb_wr_vld_g | itlb_wr_vld_g ;
wire [3:0] err_inj_ack ;
assign	err_inj_ack[0] = tlb_wr_vld & d_tag_invrt_par ;
assign	err_inj_ack[1] = tlb_wr_vld & d_data_invrt_par ;
assign	err_inj_ack[2] = tlb_wr_vld & i_tag_invrt_par ;
assign	err_inj_ack[3] = tlb_wr_vld & i_data_invrt_par ;

dff_s #(4) err_inj (
        .din    (err_inj_ack[3:0]),
        .q      (lsu_ifu_inj_ack[3:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_mmu_dp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	MMU Datapath - I & D.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
					// time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes



// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================





































































































































































































































































































































































































































































































































































































//PITON_PROTO enables all FPGA related modifications





module tlu_mmu_dp ( /*AUTOARG*/
   // Outputs

   
   tlu_itlb_tte_csm_w2, tlu_dtlb_tte_csm_w2, 
   
   tlu_dtsb_split_w2, tlu_dtsb_size_w2, tlu_dtag_access_w2,
   tlu_itsb_split_w2, tlu_itsb_size_w2,
   tlu_itlb_tte_tag_w2, tlu_itlb_tte_data_w2, tlu_dtlb_tte_tag_w2, 
   tlu_dtlb_tte_data_w2, tlu_idtlb_dmp_key_g, tlu_dsfsr_flt_vld, 
   tlu_isfsr_flt_vld, mra_wdata, tlu_ctxt_cfg_w2, tlu_tag_access_ctxt_g, 
   lsu_exu_ldxa_data_g, so, tlu_tsb_base_w2_d1,
   // Inputs

   
   lsu_tlu_st_rs3_data_g, 
   
   tlu_addr_msk_g, dmmu_any_sfsr_wr, dmmu_sfsr_wr_en_l, dmmu_sfar_wr_en_l, 
   immu_any_sfsr_wr, immu_sfsr_wr_en_l, tlu_lng_ltncy_en_l,
   lsu_tlu_dside_ctxt_m, lsu_tlu_pctxt_m, tlu_tag_access_ctxt_sel_m, 
   lsu_tlu_st_rs3_data_b63t59_g, lsu_tlu_st_rs3_data_b47t0_g,
   exu_lsu_ldst_va_e, tlu_idtsb_8k_ptr,lsu_tlu_tlb_dmp_va_m, ifu_tlu_pc_m, 
   tlu_slxa_thrd_sel, 
   tlu_tte_tag_g, tlu_dmp_key_vld_g, tlb_access_rst_l, 
   tag_access_wdata_sel, mra_rdata, tlu_admp_key_sel, 
   tlu_isfsr_din_g, tlu_dsfsr_din_g, 
   tlu_tte_wr_pid_g, tlu_tte_real_g, tlu_ldxa_l1mx1_sel, 
   tlu_ldxa_l1mx2_sel, tlu_ldxa_l2mx1_sel, rclk, grst_l, arst_l,
   tlu_tlb_tag_invrt_parity, tlu_tlb_data_invrt_parity, tlu_sun4r_tte_g,
   tlu_tsb_rd_ps0_sel, si, se, tlu_tlb_access_en_l_d1
   ) ;	

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics

input			tlu_addr_msk_g ;	// address masking active for thread in pipe.
input			dmmu_any_sfsr_wr ; 
input	[3:0]		dmmu_sfsr_wr_en_l ; 
input	[3:0]		dmmu_sfar_wr_en_l ; 
input                   immu_any_sfsr_wr ;
input   [3:0]           immu_sfsr_wr_en_l ;
input  	[12:0]          lsu_tlu_dside_ctxt_m ;
input  	[12:0]          lsu_tlu_pctxt_m ;
input	[2:0]		tlu_tag_access_ctxt_sel_m ;	
// rs3_data split for vlint purposes.
input	[63:59]		lsu_tlu_st_rs3_data_b63t59_g ;
input	[47:0]		lsu_tlu_st_rs3_data_b47t0_g ;

input	[63:0]		lsu_tlu_st_rs3_data_g ;

input	[47:0]		exu_lsu_ldst_va_e ;
input   [47:0]          tlu_idtsb_8k_ptr ;
input   [47:13]         lsu_tlu_tlb_dmp_va_m ;
input	[47:13]		ifu_tlu_pc_m ;
input	[3:0]		tlu_slxa_thrd_sel ;
//input 	[63:0]        	int_tlu_asi_data;
//input			int_tlu_asi_data_vld;
input	[2:0]		tlu_tte_tag_g ;
input	[4:0]		tlu_dmp_key_vld_g ;
//input			tlb_access_en_l ;
input			tlu_tlb_access_en_l_d1 ;
input			tlb_access_rst_l ;

input	[2:0]		tag_access_wdata_sel ;
input	[155:6]		mra_rdata ;

input			tlu_admp_key_sel ;

input 	[23:0]   	tlu_isfsr_din_g ;
input 	[23:0]   	tlu_dsfsr_din_g ;

input   [2:0]          	tlu_tte_wr_pid_g ;      // thread selected pid
input			tlu_tte_real_g ;	// tte is real		

input	[3:0]		tlu_ldxa_l1mx1_sel ;	// mmu ldxa level1 mx1 sel
input	[3:0]		tlu_ldxa_l1mx2_sel ;	// mmu ldxa level1 mx2 sel
input	[2:0]		tlu_ldxa_l2mx1_sel ;	// mmu ldxa level2 mx1 sel
input			tlu_tlb_tag_invrt_parity ;	// invert parity for tag write
input			tlu_tlb_data_invrt_parity ;	// invert parity for data write
input                  	tlu_sun4r_tte_g ;       // sun4r vs. sun4v tte.

input                  tlu_lng_ltncy_en_l ;

input                  tlu_tsb_rd_ps0_sel ;

input                 rclk ;
input                 arst_l ;
input                 grst_l ;
input                 si ;
input                 se ;

output                        so ;

//output  [47:13]         tlu_dtsb_base_w2 ;	// represents ps0
output                  tlu_dtsb_split_w2 ;
output  [3:0]           tlu_dtsb_size_w2 ;
output  [47:13]        	tlu_dtag_access_w2 ;	// used to represent both i/d.
//output  [47:13]         tlu_itsb_base_w2 ;	// represents ps1
output                  tlu_itsb_split_w2 ;
output  [3:0]           tlu_itsb_size_w2 ;
//output  [32:13]        	tlu_itag_access_w2 ;	// to be obsoleted.
output	[58:0]		tlu_itlb_tte_tag_w2 ;
output	[42:0]		tlu_itlb_tte_data_w2 ;
output	[58:0]		tlu_dtlb_tte_tag_w2 ;
output	[42:0]		tlu_dtlb_tte_data_w2 ;


output [32:0]  tlu_itlb_tte_csm_w2;
output [32:0]  tlu_dtlb_tte_csm_w2;

//output	[63:0]		tlu_lsu_ldxa_data_w2 ;
output  [5:0]           tlu_ctxt_cfg_w2 ;       // i/d context zero/non-zero config.
output	[40:0]		tlu_idtlb_dmp_key_g ;


output	[3:0]		tlu_dsfsr_flt_vld ;
output	[3:0]		tlu_isfsr_flt_vld ;

output	[12:0]		tlu_tag_access_ctxt_g ;
output	[63:0]		lsu_exu_ldxa_data_g ;

output	[47:13]		tlu_tsb_base_w2_d1 ;

///output	tlu_tag_access_nctxt_g ;		// tag-access contains nucleus context.

output	[155:0]		mra_wdata ;

wire    [47:0] 		ldst_va_m,ldst_va_g ;
// st_rs3_data partitioned for vlint.
//wire	[63:0]		st_rs3_data_g ;
wire	[63:59]		st_rs3_data_b63t59_g ;
wire	[39:8]		st_rs3_data_b39t8_g ;
wire	[6:1]		st_rs3_data_b6t1_g ;
wire	[63:0]		tag_target ;
wire   	[47:13]        	dtag_access_w2 ;
wire	[23:0]		dsfsr,isfsr ;
wire	[23:0]		dsfsr0,isfsr0 ;
wire	[23:0]		dsfsr1,isfsr1 ;
wire	[23:0]		dsfsr2,isfsr2 ;
wire	[23:0]		dsfsr3,isfsr3 ;
wire	[47:0]		dsfar ;
wire	[47:0]		dsfar0,dsfar1 ;
wire	[47:0]		dsfar2,dsfar3 ;
wire	[23:0]		dsfsr_din ;
wire	[23:0]		isfsr_din ;
//wire	[39:22] 	tte_relocated_pa ;
wire	[40:0]		dmp_key ;
wire	[47:0] 		tag_access_w2 ;
wire	[41:0]		idtte_data_w2 ;	
wire			tlb_access0_clk, tlb_access1_clk ;
wire	[40:0]		idtlb_dmp_key_pend ; 
wire	[47:0]		tag_access_wdata ;
wire	[12:0]		tag_access_ctxt_m,tag_access_ctxt_g ;
// buses split for vlint purposes.
wire 	[58:55] 	idtte_tag_b58t55_g ;
wire 	[53:0] 		idtte_tag_b53t0_g ;
wire 	[58:55] 	idtte_tag_b58t55_w2 ;
wire 	[53:0] 		idtte_tag_b53t0_w2 ;
wire 	[41:0] 		idtte_data_g ;
wire    [47:13]         tlb_dmp_va_g ;
wire	[47:0]	ldxa_l1mx1_dout_e ;
wire	[47:0]	ldxa_l1mx1_dout_m ;



wire	[32:0]		idtte_csm_g ;
wire	[32:0]		idtte_csm_w2 ;

 //=========================================================================================
 //    RESET/CLK
 //=========================================================================================
 
    wire       clk;
    assign     clk = rclk;
 
    wire       rst_l;
    
    dffrl_async rstff(.din (grst_l),
                      .q   (rst_l),
                      .clk (clk), .se(se), .si(), .so(),
                      .rst_l (arst_l));


//=========================================================================================
//	Staging
//=========================================================================================

// Stage
wire [47:13] pc_g ;	
dff_s  #(35) stg_w (
        .din    (ifu_tlu_pc_m[47:13]),
        .q      (pc_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//assign	pc_g[47:13] = ifu_tlu_pc_w[47:13] ;

// Stage va
dff_s  #(48) stg_m (
        .din    (exu_lsu_ldst_va_e[47:0]),
        .q      (ldst_va_m[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(48) stg_g (
        .din    (ldst_va_m[47:0]),
        .q      (ldst_va_g[47:0]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

dff_s  #(35) dstg_g (
        .din    (lsu_tlu_tlb_dmp_va_m[47:13]),
        .q      (tlb_dmp_va_g[47:13]),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

//=========================================================================================

wire [4:0] tlu_dmp_key_vld_d1 ;
wire [47:13] tlb_dmp_va_d1 ;
dff_s  #(40) dstg_d1 (
        .din    ({tlb_dmp_va_g[47:13],tlu_dmp_key_vld_g[4:0]}),
        .q      ({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0]}),
        .clk    (clk),
        .se     (1'b0),       .si (),          .so ()
        );

wire	[2:0]	tlu_tte_tag_d1,tlu_tte_wr_pid_d1 ;
wire		tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1 ;
wire	[47:13] dmp_va_d1 ;
wire	[5:0]	dmp_key_vld_d1 ;
dp_mux2es #(41)	dmp_key_sel (
     		.in0	({tlb_dmp_va_d1[47:13],tlu_dmp_key_vld_d1[4:0],tlu_tte_real_d1}),
    		.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],tlu_tte_real_d1,tlu_tte_real_d1}),
    		//.in1	({tag_access_w2[47:13],1'b1,tlu_tte_tag_d1[2:0],1'b0,tlu_tte_real_d1}), // Bug 3754
		.sel	(tlu_admp_key_sel),
	      	.dout	({dmp_va_d1[47:13],dmp_key_vld_d1[5:0]})
	);

assign  dmp_key[40:0] =
        {
        dmp_va_d1[47:28],        // (20b)
        dmp_key_vld_d1[5],       // (1b)
        dmp_va_d1[27:22],        // (6b)
        dmp_key_vld_d1[4],       // (1b)
        dmp_va_d1[21:16],        // (6b)
        dmp_key_vld_d1[3],       // (1b)
        dmp_va_d1[15:13],        // (3b)
        dmp_key_vld_d1[2],       // (1b)
        dmp_key_vld_d1[1],       // (1b)
        dmp_key_vld_d1[0]        // (1b)
        } ;


//wire	tlb_access_en_l_d1 ;
wire    tlb_access2_clk ;




clken_buf clkbf_dmpky (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access2_clk)
                ) ;



// Advance by a cycle. Do not have to reset state.


















dffrl_s  #(41) stg_w2 (
        .din    (dmp_key[40:0]),
        .q      (idtlb_dmp_key_pend[40:0]),
        .rst_l  (tlb_access_rst_l),
        .clk    (tlb_access2_clk),
        .se     (1'b0),       .si (),          .so ()
        );



assign  tlu_idtlb_dmp_key_g[40:0] = idtlb_dmp_key_pend[40:0] ;


//=========================================================================================
//	WR DATA FOR MRA
//=========================================================================================

// Format for each entry of MRA on a per thread basis.
// Current :
//	| 	dtsb(48b)	|	dtag_access(48b)	|	dsfar(48b)	|	
//	| 	itsb(48b)	|	itag_access(48b)	|			|	
// New(Hyp,Legacy) : 8 tsb per thread instead of 2. dsfar removed.
// -This allows tag-access to be lined up with simultaneous reads of tsb
// -zero-ctxt and non-zero-ctxt tag-access will have to be distinguished either
// by doing a zero-detect on the lower 13b of the write-data or using a disinct asi.
//	| 	zcps0_dtsb(48b)	|	zcps1_dtsb(48b)	| 	zctxt_dtag_acc(48b) | dzctxt_cfg(6b) |
//	| 	zcps0_itsb(48b)	|	zcps1_itsb(48b)	| 	zctxt_itag_acc(48b) | izctxt_cfg(6b) |
//	|       nzcps0_dtsb(48b)|	nzcps1_dtsb(48b)| 	nzctxt_dtag_acc(48b)| dnzctxt_cfg(6b)|
//	| 	nzcps0_itsb(48b)|	nzcps1_itsb(48b)| 	nzctxt_itag_acc(48b)| inzctxt_cfg(6b)|

mux3ds #(13)	tag_acc_ctxtmx(
    		.in0	(lsu_tlu_pctxt_m[12:0]), // iside selects primary ctxt
    		.in1	(13'd0),		 // iside selects nucleus ctxt
     		.in2	(lsu_tlu_dside_ctxt_m[12:0]), // otherwise select dside ctxt
		.sel0	(tlu_tag_access_ctxt_sel_m[0]),
		.sel1	(tlu_tag_access_ctxt_sel_m[1]),
		.sel2	(tlu_tag_access_ctxt_sel_m[2]),
	      	.dout	(tag_access_ctxt_m[12:0])
	);

/*assign	tag_access_ctxt_m[12:0] =
	tlu_tag_access_ctxt_sel_m[0] ?	lsu_tlu_pctxt_m[12:0] :		// iside selects primary ctxt
		tlu_tag_access_ctxt_sel_m[1] ?	13'd0  : 		// iside selects nucleus ctxt
			tlu_tag_access_ctxt_sel_m[2] ? lsu_tlu_dside_ctxt_m[12:0] : 13'bx_xxxx_xxxx_xxxx ; 			// otherwise select dside ctxt
*/

dff_s  #(13) ctxt_stgg (
        .din    (tag_access_ctxt_m[12:0]),
        .q    	(tag_access_ctxt_g[12:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

// pstate.am masking
wire	[15:0]	ldst_va_masked_g ;
assign	ldst_va_masked_g[15:0] = ldst_va_g[47:32] & {16{~tlu_addr_msk_g}} ;

mux3ds #(48)	dtag_access_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:13],tag_access_ctxt_g[12:0]}), // dside hardware
    		.in1	({pc_g[47:13],tag_access_ctxt_g[12:0]}), // iside hardware
     		.in2	(lsu_tlu_st_rs3_data_b47t0_g[47:0]),	// stxa,tsb write as an example.
		.sel0	(tag_access_wdata_sel[0]),
		.sel1	(tag_access_wdata_sel[1]),
		.sel2	(tag_access_wdata_sel[2]),
	      	.dout	(tag_access_wdata[47:0])
	);

// Determine whether context is nucleus or not.
//assign tlu_tag_access_nctxt_g = (tag_access_wdata[12:0] == 13'd0) ;
assign        tlu_tag_access_ctxt_g[12:0] = tag_access_ctxt_g[12:0] ;

wire	[47:0]	dsfar_wdata ;
dp_mux2es #(48)	dsfar_dsel(
    		.in0	({ldst_va_masked_g[15:0],ldst_va_g[31:0]}), // dsfar;trap
    		.in1	(lsu_tlu_st_rs3_data_b47t0_g[47:0]), // asi write
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfar_wdata[47:0])
	);

// Warning for Grape Mapper - the number of bits may have to be changed to
// map implementation.
assign	mra_wdata[155:0] = 
	// Bug 4676 - tsb rsrved field
	{lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0,	
		lsu_tlu_st_rs3_data_b47t0_g[3:0],	//ps0 zctxt,nzctxt tsb
	 lsu_tlu_st_rs3_data_b47t0_g[47:12],8'd0, 	
	 	lsu_tlu_st_rs3_data_b47t0_g[3:0], 	//ps1 zctxt,nzctxt tsb
	 tag_access_wdata[47:0],		//i/d tag-access
	 lsu_tlu_st_rs3_data_b47t0_g[10:8], 	//ps1 page size
	 lsu_tlu_st_rs3_data_b47t0_g[2:0], 	//ps0 page size
	 6'd0};


//=========================================================================================
//	D-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
assign	dtag_access_w2[47:13] = mra_rdata[59:12+13] ;

// Can this be shared with the i-side ?
assign	tlu_dtag_access_w2[47:13] = dtag_access_w2[47:13] ;


//=========================================================================================
//	I-TAG ACCESS
//=========================================================================================

// 4 registers for the 4 threads.
// 35b of VA || 13b Ctxt.
// ** Ctxt is to be read as zero if there is no context associated with the access **
// VA will be sing-extended based on bit 47. 

// Update in w2.
// SPARC_HPV_EN - This needs to be obsoleted. Common tag-access will be superimposed
// on dta_access bus.

//assign	itag_access_w2[32:13] = mra_rdata[`MRA_TACCESS_HI-15:`MRA_TACCESS_LO+13] ;
//assign	itag_access_w2[47:0] = mra_rdata[`MRA_TACCESS_HI:`MRA_TACCESS_LO] ;

//assign	tlu_itag_access_w2[32:13] = itag_access_w2[32:13] ;


//=========================================================================================
//	D-TAG TARGET
//=========================================================================================

// Tag Target is based on currently selected thread.

// Thread0,1,2,3
assign tag_target[63:0] =
	{3'b000,
	ldxa_l1mx1_dout_m[12:0],	// Context
	//tag_access_w2[12:0],		// Context
	6'b000000,
	{16{ldxa_l1mx1_dout_m[47]}},	// Sign-extend VA[47]
	//{16{tag_access_w2[47]}},	// Sign-extend VA[47]
	ldxa_l1mx1_dout_m[47:22]};	// VA // Bug 3975.
	//tag_access_w2[47:22]};	// VA

//=========================================================================================
//	D-TSB
//=========================================================================================

// Note : on interface, dtsb represents ps0 tsbs, itsb represents ps1 tsbs. 

wire 	[47:0] 	tsb_ps0, tsb_ps1 ;
assign	tsb_ps0[47:0] = mra_rdata[155:108] ;
assign	tsb_ps1[47:0] = mra_rdata[107:60] ;

assign	tlu_dtsb_split_w2 = tsb_ps0[12] ;
// SPARC_HPV_EN - extend tsb_size by 1b.
assign	tlu_dtsb_size_w2[3:0] = tsb_ps0[3:0] ;

//=========================================================================================
//	CTXT CONFIG
//=========================================================================================

wire	[5:0]	ptr_ctxt_cfg ;
assign	tlu_ctxt_cfg_w2[5:0] =	mra_rdata[11:6] ;

dff_s  #(6) pctxt_stgm (
        .din    (mra_rdata[11:6]),
        .q    	(ptr_ctxt_cfg[5:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//=========================================================================================
//	I-TSB
//=========================================================================================

assign	tlu_itsb_split_w2 = tsb_ps1[12] ;
assign	tlu_itsb_size_w2[3:0] = tsb_ps1[3:0] ;

//=========================================================================================
//	STAGE TSB BASE FOR USE IN PTR CALCULATION
//=========================================================================================

wire	[47:13]	tsb_base ;
assign  tsb_base[47:13] =
        tlu_tsb_rd_ps0_sel ? tsb_ps0[47:13] : tsb_ps1[47:13] ;
        //tlu_tsb_rd_ps0_sel ? dtsb[47:13] : itsb[47:13] ;

dff_s  #(35) tsbbase_stgm (
        .din    (tsb_base[47:13]),
        .q    	(tlu_tsb_base_w2_d1[47:13]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//=========================================================================================
//	8K and 64K Ptr
//=========================================================================================

// In MMU Control.

//=========================================================================================
//	Direct Ptr
//=========================================================================================

//=========================================================================================
//	I-/D TLB Fill : TTE Tag and Data.
//=========================================================================================


// TTE Tag is formed from Tag Access.
// TTE Data is formed from rs3_data for store.

// Timing needs to be fixed !!! Partition mode will add one more cycle
// to path. tlb write will occur in w3.

// partitioned for vlint purposes.
//assign	st_rs3_data_g[63:0] = lsu_tlu_st_rs3_data_g[63:0] ; 
assign	st_rs3_data_b63t59_g[63:59] = lsu_tlu_st_rs3_data_b63t59_g[63:59] ; 
assign	st_rs3_data_b39t8_g[39:8] = lsu_tlu_st_rs3_data_b47t0_g[39:8] ; 
assign	st_rs3_data_b6t1_g[6:1] = lsu_tlu_st_rs3_data_b47t0_g[6:1] ; 

assign	tag_access_w2[47:0] = mra_rdata[59:12] ;

wire idtte_tag_vld_g,idtte_tag_vld_d1 ;
assign	idtte_tag_vld_g =
	st_rs3_data_b63t59_g[63] ;
wire idtte_tag_lock_g,idtte_tag_lock_d1 ;
assign	idtte_tag_lock_g =
	tlu_sun4r_tte_g ? st_rs3_data_b6t1_g[6] : st_rs3_data_b63t59_g[61] ;





wire tlb_access3_clk;
clken_buf clkbf_idttetg (
                .rclk   (clk),
                .enb_l  (tlu_lng_ltncy_en_l),
                .tmb_l  (~se),
                .clk    (tlb_access3_clk)
                ) ;    



// Stage some bits to match posedge rd for lng-lat reads of mra.




















dff_s  #(10) stgd1_idttetg (
        .din    ({idtte_tag_vld_g,idtte_tag_lock_g,tlu_tte_tag_g[2:0],
		tlu_tte_wr_pid_g[2:0],tlu_tte_real_g,tlu_tlb_tag_invrt_parity}),
        .q      ({idtte_tag_vld_d1,idtte_tag_lock_d1,tlu_tte_tag_d1[2:0],
		tlu_tte_wr_pid_d1[2:0],tlu_tte_real_d1,tlu_tlb_tag_invrt_parity_d1}),
        .clk 	(tlb_access3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



// assumption is that tag_access_w2 gets delayed by a cycle because
// the rd is now posedge.
assign idtte_tag_b53t0_g[53:0] =
	{tag_access_w2[47:22],		// VA_tag	(26b)
	tlu_tte_tag_d1[2],		// 27:22 are valid (1b)
	idtte_tag_vld_d1,		// V 		(1b) can be 0 or 1
	idtte_tag_lock_d1,		// L 		(1b) 
	1'b1,				// U		(1b) : must be set on write
	tag_access_w2[21:16],		// VA_tag	(6b)
	tlu_tte_tag_d1[1],		// 21:16 are valid (1b)
	tag_access_w2[15:13],		// VA_tag	(3b)
	tlu_tte_tag_d1[0],		// 15:13 are valid (1b)
	tag_access_w2[12:0] 		// Ctxt b12:0 	(13b)
			};		

assign	idtte_tag_b58t55_g[58:55] = {tlu_tte_wr_pid_d1[2:0],tlu_tte_real_d1};
// V and U bit omitted from tag as it can change once in tlb
// assign	idtte_tag_g[54] = 
// tlu_tlb_tag_invrt_parity_d1^(^{idtte_tag_g[58:55],idtte_tag_g[53:27],idtte_tag_g[25],idtte_tag_g[23:0]}) ;

// Additional page size bit does not have to be included. EP ? 
// SUN4R TTE
wire	[41:0]	idtte_data_sun4r_g ;
assign idtte_data_sun4r_g[41:0] =
	{st_rs3_data_b39t8_g[39:22],	// PA		(18b)
	~tlu_tte_tag_g[2],		// 27:20 - mx sel (1b) : active-low
	st_rs3_data_b39t8_g[21:16],	// PA 		(6b)
	~tlu_tte_tag_g[1],		// 21:16 - mx sel (1b) : active-low
	st_rs3_data_b39t8_g[15:13],	// PA 		(3b)
	~tlu_tte_tag_g[0],		// 15:13 - mx sel (1b) : active-low
	st_rs3_data_b63t59_g[63],	// V		(1b)
	st_rs3_data_b63t59_g[60],	// NFO 		(1b)
	st_rs3_data_b63t59_g[59],	// IE 		(1b)
	st_rs3_data_b6t1_g[6],		// L		(1b)
	st_rs3_data_b6t1_g[5:4],	// CP/CV	(2b)
	st_rs3_data_b6t1_g[3],		// E		(1b)
	st_rs3_data_b6t1_g[2],		// P		(1b)
	st_rs3_data_b6t1_g[1],		// W		(1b)
	3'b000};			// Spare	(3b)
// SUN4V TTE
wire	[41:0]	idtte_data_sun4v_g ;
assign idtte_data_sun4v_g[41:0] =
	{st_rs3_data_b39t8_g[39:22],	// PA		(18b)
	~tlu_tte_tag_g[2],		// 27:20 - mx sel (1b) : active-low
	st_rs3_data_b39t8_g[21:16],	// PA 		(6b)
	~tlu_tte_tag_g[1],		// 21:16 - mx sel (1b) : active-low
	st_rs3_data_b39t8_g[15:13],	// PA 		(3b)
	~tlu_tte_tag_g[0],		// 15:13 - mx sel (1b) : active-low
	st_rs3_data_b63t59_g[63],	// V		(1b) // 4->63. Bug 2977
	st_rs3_data_b63t59_g[62],	// NFO 		(1b) // 10->62
	st_rs3_data_b39t8_g[12],	// IE 		(1b)
	st_rs3_data_b63t59_g[61],	// L 		(1b)
	//1'b0,				//// L(none)	(1b)
	st_rs3_data_b39t8_g[10:9],	// CP/CV	(2b) // 9:8 -> 10:9
	st_rs3_data_b39t8_g[11],	// E		(1b)
	st_rs3_data_b39t8_g[8],		// P		(1b) // 7->8
	st_rs3_data_b6t1_g[6],		// W		(1b) // 5->6
	3'b000};			// Spare	(3b)
assign	idtte_data_g[41:0] =
	tlu_sun4r_tte_g ? idtte_data_sun4r_g[41:0] : idtte_data_sun4v_g[41:0];


//CSM_CHANGE
assign idtte_csm_g[32:0] = {lsu_tlu_st_rs3_data_g[31:22],
                                lsu_tlu_st_rs3_data_g[21:16],
                                lsu_tlu_st_rs3_data_g[15:6],
                                lsu_tlu_st_rs3_data_g[5:0]};


// Generate Parity for tte data. Match to DP Macro.
//assign idtte_data_g[42] = tlu_tlb_data_invrt_parity^(^idtte_data_g[41:0]) ;

/*dff  #(1) stgd1_tlbacc (
        .din    (tlb_access_en_l),
        .q    	(tlb_access_en_l_d1),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        );*/

// flopping of tte-tag is delayed by a cycle,tte-data
// is not. wr-vld will match tte-tag.




clken_buf clkbf_ttetg (
                .rclk   (clk),
                .enb_l  (tlu_tlb_access_en_l_d1),
                .tmb_l  (~se),
                .clk    (tlb_access0_clk)
                ) ;    



// Ship for write to TLB. Doesn't have to be resettable.
// Shorten by a bit, as parity will be generated based on output.
// Instead of removing the bit, use it for parity-invrt bit
// in section below.
/*dff  #(59) stgw2_ttetg (
        .din    (idtte_tag_g[58:0]),
        .q      (idtte_tag_w2[58:0]),
        .clk 	(tlb_access0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); */

















dff_s  #(58) stgw2_ttetg (
        .din    ({idtte_tag_b58t55_g[58:55],idtte_tag_b53t0_g[53:0]}),
        .q      ({idtte_tag_b58t55_w2[58:55],idtte_tag_b53t0_w2[53:0]}),
        .clk 	(tlb_access0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 







clken_buf clkbf_ttedt (
                .rclk   (clk),
                .enb_l  (tlu_lng_ltncy_en_l),
                //.enb_l  (tlb_access_en_l),
                .tmb_l  (~se),
                .clk    (tlb_access1_clk)
                ) ;    



// Shorten by a bit, as parity will be generated based on output.
// Instead of removing the bit, use it for parity-invrt bit
// in section below.
/*dff  #(43) stgw2_ttedt (
        .din    (idtte_data_g[42:0]),
        .q    	(idtte_data_w2[42:0]),
        .clk 	(tlb_access1_clk),
        .se     (1'b0),       .si (),          .so ()
        );*/ 

















dff_s  #(42) stgw2_ttedt (
        .din    (idtte_data_g[41:0]),
        .q    	(idtte_data_w2[41:0]),
        .clk 	(tlb_access1_clk),
        .se     (1'b0),       .si (),          .so ()
        );




















dff_s  #(33) stgw2_csm_ttedt (
        .din    (idtte_csm_g),
        .q    	(idtte_csm_w2),
        .clk 	(tlb_access1_clk),
        .se     (1'b0),       .si (),          .so ()
        );





wire	parity_tag,parity_data ;
wire	parity_tag_d1,parity_data_d1 ;
assign tlu_dtlb_tte_tag_w2[58:0] = {idtte_tag_b58t55_w2[58:55],parity_tag_d1,idtte_tag_b53t0_w2[53:0]} ;
assign tlu_itlb_tte_tag_w2[58:0] = {idtte_tag_b58t55_w2[58:55],parity_tag_d1,idtte_tag_b53t0_w2[53:0]} ;
assign tlu_dtlb_tte_data_w2[42:0] = {parity_data_d1,idtte_data_w2[41:0]} ;
assign tlu_itlb_tte_data_w2[42:0] = {parity_data_d1,idtte_data_w2[41:0]} ;


assign tlu_itlb_tte_csm_w2[32:0] = idtte_csm_w2;
assign tlu_dtlb_tte_csm_w2[32:0] = idtte_csm_w2;


//=========================================================================================
//	PARITY GEN FOR TTE TAG & DATA
//=========================================================================================

// Timing Change : Since parity is not required until the write, and the write
// is preceeded by a auto-demap, the parity generation can be hidden in the
// cycle of auto-demap.

wire	tlu_tlb_tag_invrt_parity_d2,tlu_tlb_data_invrt_parity_d1 ;

















dff_s  #(1) stgw2_ttetgpar (
        .din    (tlu_tlb_tag_invrt_parity_d1),
        .q      (tlu_tlb_tag_invrt_parity_d2),
        .clk 	(tlb_access0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



















dff_s  #(1) stgw2_ttedtpar (
        .din    (tlu_tlb_data_invrt_parity),
        .q    	(tlu_tlb_data_invrt_parity_d1),
        .clk 	(tlb_access1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	parity_tag =
tlu_tlb_tag_invrt_parity_d2^(^{idtte_tag_b58t55_w2[58:55],
	idtte_tag_b53t0_w2[53:27],idtte_tag_b53t0_w2[25],idtte_tag_b53t0_w2[23:0]}) ;
assign parity_data = tlu_tlb_data_invrt_parity_d1^(^idtte_data_w2[41:0]) ;
//assign	idtte_tag_w2[54] = 
//tlu_tlb_tag_invrt_parity_d2^(^{idtte_tag_w2[58:55],idtte_tag_w2[53:27],idtte_tag_w2[25],idtte_tag_w2[23:0]}) ;
//assign idtte_data_w2[42] = tlu_tlb_data_invrt_parity_d1^(^idtte_data_w2[41:0]) ;

dff_s  #(2) stg_partd (
        .din    ({parity_tag,parity_data}),
        .q      ({parity_tag_d1,parity_data_d1}),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

//=========================================================================================
//	D-SFAR
//=========================================================================================

// dsfar is written into mra for pre SPARC_HPV_EN changes. It will be written into flops
// for SPARC_HPV_EN. 

wire	[47:0]		dsfar_din ;
    
assign	dsfar_din[47:0] = dsfar_wdata[47:0] ;

wire	dsfar0_clk ;




clken_buf clkbf_dsfar0 (
                .rclk   (clk),
                .enb_l  (dmmu_sfar_wr_en_l[0]),
                .tmb_l  (~se),
                .clk    (dsfar0_clk)
                ) ;    



// Thread0
















dff_s  #(48) dsfar0_ff (
        .din    (dsfar_din[47:0]),
        .q      (dsfar0[47:0]),
        .clk 	(dsfar0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 




wire	dsfar1_clk ;




clken_buf clkbf_dsfar1 (
                .rclk   (clk),
                .enb_l  (dmmu_sfar_wr_en_l[1]),
                .tmb_l  (~se),
                .clk    (dsfar1_clk)
                ) ;    



// Thread1
















dff_s  #(48) dsfar1_ff (
        .din    (dsfar_din[47:0]),
        .q      (dsfar1[47:0]),
        .clk 	(dsfar1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



wire	dsfar2_clk ;




clken_buf clkbf_dsfar2 (
                .rclk   (clk),
                .enb_l  (dmmu_sfar_wr_en_l[2]),
                .tmb_l  (~se),
                .clk    (dsfar2_clk)
                ) ;    



// Thread2
















dff_s  #(48) dsfar2_ff (
        .din    (dsfar_din[47:0]),
        .q      (dsfar2[47:0]),
        .clk 	(dsfar2_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 




wire	dsfar3_clk ;




clken_buf clkbf_dsfar3 (
                .rclk   (clk),
                .enb_l  (dmmu_sfar_wr_en_l[3]),
                .tmb_l  (~se),
                .clk    (dsfar3_clk)
                ) ;    



// Thread3
















dff_s  #(48) dsfar3_ff (
        .din    (dsfar_din[47:0]),
        .q      (dsfar3[47:0]),
        .clk 	(dsfar3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



mux4ds #(48) dsfar_mx(
        .in0(dsfar0[47:0]),
        .in1(dsfar1[47:0]),
        .in2(dsfar2[47:0]),
        .in3(dsfar3[47:0]),
	.sel0 (tlu_slxa_thrd_sel[0]),
	.sel1 (tlu_slxa_thrd_sel[1]),
	.sel2 (tlu_slxa_thrd_sel[2]),
	.sel3 (tlu_slxa_thrd_sel[3]),
        .dout(dsfar[47:0])
);


//=========================================================================================
//	D-SFSR
//=========================================================================================


dp_mux2es #(24)	dsfsr_wdsel(
        	.in0    (tlu_dsfsr_din_g[23:0]),
     		.in1	({lsu_tlu_st_rs3_data_b47t0_g[23:16],	// stxa
     			 2'b00,lsu_tlu_st_rs3_data_b47t0_g[13:0]}),
     		// .in1	(lsu_tlu_st_rs3_data_b47t0_g[23:0]),	// Bug 4283
		.sel	(dmmu_any_sfsr_wr),
	      	.dout	(dsfsr_din[23:0])
	);

wire	dsfsr0_clk ;




clken_buf clkbf_dsfsr0 (
                .rclk   (clk),
                .enb_l  (dmmu_sfsr_wr_en_l[0]),
                .tmb_l  (~se),
                .clk    (dsfsr0_clk)
                ) ;    



// Thread0
















dff_s  #(23) dsfsr0_ff (
        .din    (dsfsr_din[23:1]),
        .q      (dsfsr0[23:1]),
        .clk 	(dsfsr0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 





















dffrl_s  #(1) dsfsr0vld_ff (
        .din    (dsfsr_din[0]),
        .q      (dsfsr0[0]),
        .rst_l	(rst_l),
	.clk 	(dsfsr0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_dsfsr_flt_vld[0] = dsfsr0[0] ;

wire	dsfsr1_clk ;




clken_buf clkbf_dsfsr1 (
                .rclk   (clk),
                .enb_l  (dmmu_sfsr_wr_en_l[1]),
                .tmb_l  (~se),
                .clk    (dsfsr1_clk)
                ) ;    



// Thread1
















dff_s  #(23) dsfsr1_ff (
        .din    (dsfsr_din[23:1]),
        .q      (dsfsr1[23:1]),
        .clk 	(dsfsr1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 





















dffrl_s  #(1) dsfsr1vld_ff (
        .din    (dsfsr_din[0]),
        .q      (dsfsr1[0]),
        .rst_l	(rst_l),
	.clk 	(dsfsr1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_dsfsr_flt_vld[1] = dsfsr1[0] ;

wire	dsfsr2_clk ;




clken_buf clkbf_dsfsr2 (
                .rclk   (clk),
                .enb_l  (dmmu_sfsr_wr_en_l[2]),
                .tmb_l  (~se),
                .clk    (dsfsr2_clk)
                ) ;    



// Thread2
















dff_s  #(23) dsfsr2_ff (
        .din    (dsfsr_din[23:1]),
        .q      (dsfsr2[23:1]),
        .clk 	(dsfsr2_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 





















dffrl_s  #(1) dsfsr2vld_ff (
        .din    (dsfsr_din[0]),
        .q      (dsfsr2[0]),
        .rst_l	(rst_l),
	.clk 	(dsfsr2_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_dsfsr_flt_vld[2] = dsfsr2[0] ;

wire	dsfsr3_clk ;




clken_buf clkbf_dsfsr3 (
                .rclk   (clk),
                .enb_l  (dmmu_sfsr_wr_en_l[3]),
                .tmb_l  (~se),
                .clk    (dsfsr3_clk)
                ) ;    



// Thread3
















dff_s  #(23) dsfsr3_ff (
        .din    (dsfsr_din[23:1]),
        .q      (dsfsr3[23:1]),
        .clk 	(dsfsr3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 





















dffrl_s  #(1) dsfsr3vld_ff (
        .din    (dsfsr_din[0]),
        .q      (dsfsr3[0]),
        .rst_l	(rst_l),
	.clk 	(dsfsr3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_dsfsr_flt_vld[3] = dsfsr3[0] ;

dp_mux4ds #(24)	dsfsr_msel(
     		.in0	(dsfsr0[23:0]),
     		.in1	(dsfsr1[23:0]),
     		.in2	(dsfsr2[23:0]),
     		.in3	(dsfsr3[23:0]),
		.sel0_l	(~tlu_slxa_thrd_sel[0]),
		.sel1_l	(~tlu_slxa_thrd_sel[1]),
		.sel2_l	(~tlu_slxa_thrd_sel[2]),
		.sel3_l	(~tlu_slxa_thrd_sel[3]),
	      	.dout	(dsfsr[23:0])
	);

//=========================================================================================
//	I-SFSR
//=========================================================================================

// Should be able to reduce the width of these regs !!!


dp_mux2es #(24)	isfsr_wdsel(
        	.in0    (tlu_isfsr_din_g[23:0]),
     		.in1	({lsu_tlu_st_rs3_data_b47t0_g[23:16],	// stxa
     			 2'b00,lsu_tlu_st_rs3_data_b47t0_g[13:0]}),	
     		//.in1	(lsu_tlu_st_rs3_data_b47t0_g[23:0]),	// Bug 4283
		.sel	(immu_any_sfsr_wr),
	      	.dout	(isfsr_din[23:0])
	);

wire	isfsr0_clk ;




clken_buf clkbf_isfsr0 (
                .rclk   (clk),
                .enb_l  (immu_sfsr_wr_en_l[0]),
                .tmb_l  (~se),
                .clk    (isfsr0_clk)
                ) ;    



// Thread0
















dff_s  #(23) isfsr0_ff (
        .din    (isfsr_din[23:1]),
        .q      (isfsr0[23:1]),
        .clk 	(isfsr0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



// Chandra - This has changed.
















dffrl_s  #(1) isfsrvld0_ff (
        .din    (isfsr_din[0]),
        .q      (isfsr0[0]),
        .rst_l	(rst_l),      .clk 	(isfsr0_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_isfsr_flt_vld[0] = isfsr0[0] ;

wire	isfsr1_clk ;




clken_buf clkbf_isfsr1 (
                .rclk   (clk),
                .enb_l  (immu_sfsr_wr_en_l[1]),
                .tmb_l  (~se),
                .clk    (isfsr1_clk)
                ) ;    



// Thread1
















dff_s  #(23) isfsr1_ff (
        .din    (isfsr_din[23:1]),
        .q      (isfsr1[23:1]),
        .clk 	(isfsr1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



// Chandra - This has changed.
















dffrl_s  #(1) isfsrvld1_ff (
        .din    (isfsr_din[0]),
        .q      (isfsr1[0]),
        .rst_l	(rst_l),		.clk 	(isfsr1_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_isfsr_flt_vld[1] = isfsr1[0] ;

wire	isfsr2_clk ;




clken_buf clkbf_isfsr2 (
                .rclk   (clk),
                .enb_l  (immu_sfsr_wr_en_l[2]),
                .tmb_l  (~se),
                .clk    (isfsr2_clk)
                ) ;    



// Thread2
















dff_s  #(23) isfsr2_ff (
        .din    (isfsr_din[23:1]),
        .q      (isfsr2[23:1]),
        .clk 	(isfsr2_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



// Chandra - This has changed.
















dffrl_s  #(1) isfsrvld2_ff (
        .din    (isfsr_din[0]),
        .q      (isfsr2[0]),
        .rst_l	(rst_l),	.clk 	(isfsr2_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_isfsr_flt_vld[2] = isfsr2[0] ;

wire	isfsr3_clk ;




clken_buf clkbf_isfsr3 (
                .rclk   (clk),
                .enb_l  (immu_sfsr_wr_en_l[3]),
                .tmb_l  (~se),
                .clk    (isfsr3_clk)
                ) ;    



// Thread3
















dff_s  #(23) isfsr3_ff (
        .din    (isfsr_din[23:1]),
        .q      (isfsr3[23:1]),
        .clk 	(isfsr3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



// Chandra - This has changed.
















dffrl_s  #(1) isfsrvld3_ff (
        .din    (isfsr_din[0]),
        .q      (isfsr3[0]),
        .rst_l	(rst_l),	.clk 	(isfsr3_clk),
        .se     (1'b0),       .si (),          .so ()
        ); 



assign	tlu_isfsr_flt_vld[3] = isfsr3[0] ;

dp_mux4ds #(24)	isfsr_msel(
     		.in0	(isfsr0[23:0]),
     		.in1	(isfsr1[23:0]),
     		.in2	(isfsr2[23:0]),
     		.in3	(isfsr3[23:0]),
		.sel0_l	(~tlu_slxa_thrd_sel[0]),
		.sel1_l	(~tlu_slxa_thrd_sel[1]),
		.sel2_l	(~tlu_slxa_thrd_sel[2]),
		.sel3_l	(~tlu_slxa_thrd_sel[3]),
	      	.dout	(isfsr[23:0])
	);

//=========================================================================================
//	D-SFAR
//=========================================================================================
/*
`ifdef SPARC_HPV_EN
`else
assign	dsfar[47:0] = mra_rdata[`MRA_DSFAR_HI:`MRA_DSFAR_LO];
`endif
*/

//=========================================================================================
//	Muxing for ldxa read
//=========================================================================================

// Note - collapse dtsb/itsb into one leg of the mux. Similar for
// dtag_access/itag_access.
// read of zcps1_itsb,zcps1_dtsb collapsed into read of dtsb.
// read of nzcps0_dtsb,nzcps0_itsb collapsed into read of dtag_access.
// read of nzcps1_dtsb,nzcps1_itsb collapsed into read of dsfar.

// use rs3 to return data.

//*****************************************************************
//	SPARC_HPV_EN 
//*****************************************************************

// Warning for Grape Mapper : Be careful about loading on replicated
// msb.

// First Level, Mux 1
// This is done in Estage to save on flops.
// !!! The sels except b0 are also Estage !!! b0 is delayed by a cycle.
mux3ds #(48) ldxa_l1mx1_e(
        	.in0(tsb_ps0[47:0]), // becomes ps0 tsb with SPARC_HPV_EN
        	.in1(tsb_ps1[47:0]), // becomes ps1 tsb with SPARC_HPV_EN
        	.in2(tag_access_w2[47:0]),
		.sel0(tlu_ldxa_l1mx1_sel[1]),
		.sel1(tlu_ldxa_l1mx1_sel[2]),
		.sel2(tlu_ldxa_l1mx1_sel[3]),
		.dout(ldxa_l1mx1_dout_e[47:0])
);

// New
dff_s  #(48) l1mx1_ff (
        .din    (ldxa_l1mx1_dout_e[47:0]),
        .q      (ldxa_l1mx1_dout_m[47:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

wire [63:0] ldxa_l1mx1_dout_final ;

// New
assign	ldxa_l1mx1_dout_final[63:0] =
		// Note : this bit of the mx sel is stage delayed relative to the others.
		tlu_ldxa_l1mx1_sel[0] ? 
		tag_target[63:0] : // tag_target.
		{{16{ldxa_l1mx1_dout_m[47]}},ldxa_l1mx1_dout_m[47:0]} ; // tsb_ps0/ps1,tag_access

/*mux4ds #(64) ldxa_l1mx1(
     		.in0(tag_target[63:0]),
        	.in1({{16{tsb_ps0[47]}},tsb_ps0[47:0]}), // becomes ps0 tsb with SPARC_HPV_EN
        	.in2({{16{tsb_ps1[47]}},tsb_ps1[47:0]}), // becomes ps1 tsb with SPARC_HPV_EN
        	.in3({{16{tag_access_w2[47]}},tag_access_w2[47:0]}),
		.sel0(tlu_ldxa_l1mx1_sel[0]),
		.sel1(tlu_ldxa_l1mx1_sel[1]),
		.sel2(tlu_ldxa_l1mx1_sel[2]),
		.sel3(tlu_ldxa_l1mx1_sel[3]),
		.dout(ldxa_l1mx1_dout[63:0])
);*/

wire	[47:0]	ldxa_l1mx2_dout ;
// First Level, Mux 2 - This is done in M stage.
mux4ds #(48) ldxa_l1mx2(
        	.in0({24'd0,dsfsr[23:0]}),
        	.in1(dsfar[47:0]),
        	.in2({24'd0,isfsr[23:0]}),
     		.in3({37'd0,ptr_ctxt_cfg[5:3],5'd0,ptr_ctxt_cfg[2:0]}),
		.sel0(tlu_ldxa_l1mx2_sel[0]),
		.sel1(tlu_ldxa_l1mx2_sel[1]),
		.sel2(tlu_ldxa_l1mx2_sel[2]),
		.sel3(tlu_ldxa_l1mx2_sel[3]),
		.dout(ldxa_l1mx2_dout[47:0])
);

wire	[63:0]	tlu_ldxa_data_m ;
mux3ds #(64)	ldxa_fmx (
    		.in0	(ldxa_l1mx1_dout_final[63:0]),
    		//.in0	(ldxa_l1mx1_dout[63:0]),
    		.in1	({{16{ldxa_l1mx2_dout[47]}},ldxa_l1mx2_dout[47:0]}),
     		.in2	({{16{tlu_idtsb_8k_ptr[47]}},tlu_idtsb_8k_ptr[47:0]}),
		.sel0	(tlu_ldxa_l2mx1_sel[0]),
		.sel1	(tlu_ldxa_l2mx1_sel[1]),
		.sel2	(tlu_ldxa_l2mx1_sel[2]),
	      	.dout	(tlu_ldxa_data_m[63:0])
	      	//.dout	(tlu_ldxa_data_e[63:0])
	);

dff_s  #(64) stgg_eldxa (
        .din    (tlu_ldxa_data_m[63:0]),
        .q    	(lsu_exu_ldxa_data_g[63:0]),
        .clk 	(clk),
        .se     (1'b0),       .si (),          .so ()
        ); 

endmodule


// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Wraps the TLU and ties unused inputs

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes

// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//==================================================================================================
//  Filename      : define.h
//  Created On    : 2014-02-20
//  Last Modified : 2018-11-16 17:14:11
//  Revision      :
//  Author        : Yaosheng Fu
//  Company       : Princeton University
//  Email         : yfu@princeton.edu
//
//  Description   : main header file defining global architecture parameters
//
//
//==================================================================================================




































































































































































































































































































































































































































































































































































































// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: lsu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/

// devices.xml






// 1:0


// 128

// 32


// 10

// 7


// 6:0



// 29 + 1 parity





// 144




















//`define STB_PCX_WY_HI   107
//`define STB_PCX_WY_LO   106



















































































// TLB Tag and Data Format
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	


// I-TLB version - lsu_tlb only.
























// // Invalidate Format
// //addr<5:4>=00
// `define CPX_A00_C0_LO	0
// `define CPX_A00_C0_HI	3
// `define CPX_A00_C1_LO	4
// `define CPX_A00_C1_HI	7
// `define CPX_A00_C2_LO	8
// `define CPX_A00_C2_HI	11
// `define CPX_A00_C3_LO	12
// `define CPX_A00_C3_HI	15
// `define CPX_A00_C4_LO	16
// `define CPX_A00_C4_HI	19
// `define CPX_A00_C5_LO	20
// `define CPX_A00_C5_HI	23
// `define CPX_A00_C6_LO	24
// `define CPX_A00_C6_HI	27
// `define CPX_A00_C7_LO	28
// `define CPX_A00_C7_HI	31

// //addr<5:4>=01
// `define CPX_A01_C0_LO	32
// `define CPX_A01_C0_HI	34
// `define CPX_A01_C1_LO	35
// `define CPX_A01_C1_HI	37
// `define CPX_A01_C2_LO	38
// `define CPX_A01_C2_HI	40
// `define CPX_A01_C3_LO	41
// `define CPX_A01_C3_HI	43
// `define CPX_A01_C4_LO	44
// `define CPX_A01_C4_HI	46
// `define CPX_A01_C5_LO	47
// `define CPX_A01_C5_HI	49
// `define CPX_A01_C6_LO	50
// `define CPX_A01_C6_HI	52
// `define CPX_A01_C7_LO	53
// `define CPX_A01_C7_HI	55

// //addr<5:4>=10
// `define CPX_A10_C0_LO	56
// `define CPX_A10_C0_HI	59
// `define CPX_A10_C1_LO	60
// `define CPX_A10_C1_HI	63
// `define CPX_A10_C2_LO	64
// `define CPX_A10_C2_HI	67
// `define CPX_A10_C3_LO	68
// `define CPX_A10_C3_HI	71
// `define CPX_A10_C4_LO	72
// `define CPX_A10_C4_HI	75
// `define CPX_A10_C5_LO	76
// `define CPX_A10_C5_HI	79
// `define CPX_A10_C6_LO	80
// `define CPX_A10_C6_HI	83
// `define CPX_A10_C7_LO	84
// `define CPX_A10_C7_HI	87

// //addr<5:4>=11
// `define CPX_A11_C0_LO	88
// `define CPX_A11_C0_HI	90
// `define CPX_A11_C1_LO	91
// `define CPX_A11_C1_HI	93
// `define CPX_A11_C2_LO	94
// `define CPX_A11_C2_HI	96
// `define CPX_A11_C3_LO	97
// `define CPX_A11_C3_HI	99
// `define CPX_A11_C4_LO	100
// `define CPX_A11_C4_HI	102
// `define CPX_A11_C5_LO	103
// `define CPX_A11_C5_HI	105
// `define CPX_A11_C6_LO	106
// `define CPX_A11_C6_HI	108
// `define CPX_A11_C7_LO	109
// `define CPX_A11_C7_HI	111

// cpuid - 4b



// CPUany, addr<5:4>=00,10
// `define CPX_AX0_INV_DVLD 0
// `define CPX_AX0_INV_IVLD 1
// `define CPX_AX0_INV_WY_LO 2
// `define CPX_AX0_INV_WY_HI 3

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// CPUany, addr<5:4>=01,11
// `define CPX_AX1_INV_DVLD 0
// `define CPX_AX1_INV_WY_LO 1
// `define CPX_AX1_INV_WY_HI 2

// DTAG parity error Invalidate




// CPX BINIT STORE


module tlu_nospu_wrap
(
    input           rclk,
    input [2:0]     const_cpuid,
    input [48-1:0] exu_lsu_ldst_va_e,
    input [10-1:0] lsu_tlu_ldst_va_m,
    input [7:0]     exu_mmu_early_va_e,
    input [7:0]     exu_tlu_ccr0_w,
    input [7:0]     exu_tlu_ccr1_w,





    input [2:0]     exu_tlu_cwp0,
    input [2:0]     exu_tlu_cwp1,
    input [2:0]     exu_tlu_cwp2,
    input [2:0]     exu_tlu_cwp3,
    input           exu_tlu_cwp_cmplt ,
    input [1:0]     exu_tlu_cwp_cmplt_tid,
    input           exu_tlu_cwp_retry,
    input           exu_tlu_misalign_addr_jmpl_rtn_m,
    input           exu_tlu_spill,
    input [1:0]     exu_tlu_spill_tid,
    input           exu_tlu_spill_other,
    input [2:0]     exu_tlu_spill_wtype,
    input [8:0]     exu_tlu_ttype_m,
    input           exu_tlu_ttype_vld_m,
    input           exu_tlu_va_oor_jl_ret_m,
    input           exu_tlu_va_oor_m,
    input           ffu_tlu_ill_inst_m,
    input [1:0]     ffu_ifu_tid_w2,
    input           ffu_tlu_trap_ieee754,
    input           ffu_tlu_trap_other,
    input           ffu_tlu_trap_ue,
    input           ifu_lsu_ld_inst_e,
    input           ifu_lsu_memref_d,
    input           ifu_lsu_st_inst_e,
    input           ifu_tlu_done_inst_d,
    input           ifu_tlu_flush_m,
    input           ifu_tlu_flush_fd_w,
    input           ifu_tlu_flush_fd2_w,
    input           ifu_tlu_flush_fd3_w,
    input           lsu_tlu_early_flush_w,
    input           lsu_tlu_early_flush2_w,
    input           ifu_tlu_hwint_m,
    input           ifu_tlu_immu_miss_m,
    input           ifu_tlu_pc_oor_e,
    input [4-1:0] ifu_tlu_l2imiss,
    input           ifu_tlu_inst_vld_m,
    // input           ifu_tlu_inst_vld_m_bf1,
    input           ifu_tlu_itlb_done,
    input [48:0]        ifu_tlu_npc_m,
    input [48:0]        ifu_tlu_pc_m,
    input           ifu_tlu_priv_violtn_m,
    input           ifu_tlu_retry_inst_d,
    input           ifu_tlu_rstint_m,
    input           ifu_tlu_sir_inst_m,
    input           ifu_tlu_swint_m,
    input [1:0]     ifu_tlu_thrid_d,
    input [1:0]     ifu_lsu_thrid_s,
    input [8:0]     ifu_tlu_ttype_m,
    input           ifu_tlu_ttype_vld_m,
    input           ifu_mmu_trap_m,
    input           ifu_tlu_trap_m,
    input [7:0]     lsu_asi_reg0,
    input [7:0]     lsu_asi_reg1,
    input [7:0]     lsu_asi_reg2,
    input [7:0]     lsu_asi_reg3,
    input [8-1:0] lsu_asi_state,
    input           lsu_tlu_async_ttype_vld_g,
    input           lsu_tlu_defr_trp_taken_g,
    input           lsu_mmu_defr_trp_taken_g,
    input [6:0]     lsu_tlu_async_ttype_g,
    input [1:0]     lsu_tlu_async_tid_g,
    input [3:0]     lsu_tlu_cpx_req,
    input           lsu_tlu_cpx_vld,
    input           lsu_tlu_daccess_excptn_g,
    input           lsu_tlu_daccess_prot_g,
    input           lsu_tlu_dmmu_miss_g,
    input [12:0]    lsu_tlu_dside_ctxt_m,
    input           lsu_tlu_dtlb_done,
    input [17:16]   lsu_tlu_intpkt_17_16,
    input [12:8]    lsu_tlu_intpkt_12_8,
    input [5:0]     lsu_tlu_intpkt_5_0,
    input           lsu_tlu_misalign_addr_ldst_atm_m,
    input [12:0]    lsu_tlu_pctxt_m,
    input           lsu_tlu_pcxpkt_ack,
    input           lsu_tlu_priv_action_g,
    input [63:59]   lsu_tlu_st_rs3_data_g_63_59,
    input [48:0]    lsu_tlu_st_rs3_data_g_48_0,
    input [63:0]    lsu_tlu_rs3_data_g,
    input [1:0]     lsu_tlu_tlb_access_tid_m,
    input [7:0]     lsu_tlu_tlb_asi_state_m,
    input [47:13]   lsu_tlu_tlb_dmp_va_m,
    input           lsu_tlu_tlb_ld_inst_m,
    input [(6 + 4):0]    lsu_tlu_tlb_ldst_va_m,
    input           lsu_tlu_tlb_st_inst_m,
    input [8:0]     lsu_tlu_ttype_m2,
    input           lsu_tlu_ttype_vld_m2,
    input           lsu_tlu_wtchpt_trp_g,
    input           grst_l,
    input           arst_l,
    // input           mem_write_disable,
    // input           mux_drive_disable,
    input   [7-1:0] ifu_tlu_sraddr_d,
    input   [7-1:0] ifu_tlu_sraddr_d_v2,
    input           ifu_tlu_rsr_inst_d,
    input           lsu_tlu_wsr_inst_e ,
    input   [63:0]  exu_tlu_wsr_data_m ,
    input   [7:0]   lsu_tlu_rsr_data_e ,
    input           ifu_lsu_alt_space_e,
    input           ifu_tlu_alt_space_d,
    input           lsu_tlu_squash_va_oor_m,
    input           ifu_tlu_imiss_e,
    input [3:0]     lsu_tlu_dcache_miss_w2,
    input [3:0]     lsu_tlu_l2_dmiss,
    input [3:0]     lsu_tlu_stb_full_w2,
    input [1:0]     ffu_tlu_fpu_tid,
    input           ffu_tlu_fpu_cmplt,
    input  [2:0]    lsu_pid_state0,
    input  [2:0]    lsu_pid_state1,
    input  [2:0]    lsu_pid_state2,
    input  [2:0]    lsu_pid_state3,
    input           lsu_tlu_nucleus_ctxt_m,
    input  [2:0]    lsu_tlu_tte_pg_sz_g,
    input   [3:0]   ifu_lsu_error_inj,
    input   [8:0]   ifu_lsu_imm_asi_d,
    input           ifu_lsu_imm_asi_vld_d,
    input   [23:0]  lsu_dsfsr_din_g ,
    input   [3:0]   lsu_dmmu_sfsr_trp_wr,
    input       lsu_mmu_flush_pipe_w,
    input       exu_lsu_priority_trap_m,

    // jtag debug
    // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data,
    input wire rtap_core_val,
    input wire [1:0] rtap_core_threadid,
    input wire [4-1:0]  rtap_core_id,
    input wire [33:0] rtap_core_data_33_0,

    output [63:0]   tlu_lsu_int_ldxa_data_w2,
    output          tlu_lsu_int_ld_ill_va_w2,
    output          tlu_lsu_int_ldxa_vld_w2,
    output          tlu_dtlb_data_rd_g ,
    output          tlu_dtlb_dmp_actxt_g,
    output          tlu_dtlb_dmp_all_g,
    output          tlu_dtlb_dmp_nctxt_g,
    output          tlu_dtlb_dmp_pctxt_g,
    output          tlu_dtlb_dmp_sctxt_g,
    output          tlu_dtlb_dmp_vld_g,
    output          tlu_dtlb_invalidate_all_g,
    output [5:0]    tlu_dtlb_rw_index_g,
    output          tlu_dtlb_rw_index_vld_g,
    output          tlu_dtlb_tag_rd_g,
    output [42:0]   tlu_dtlb_tte_data_w2,
    output [58:0]   tlu_dtlb_tte_tag_w2,
    output[3:0]     lsu_ifu_inj_ack,
    output [2-1:0] tlu_exu_agp,
    output          tlu_exu_agp_swap,
    output [1:0]    tlu_exu_agp_tid,
    output [7:0]    tlu_exu_ccr_m,
    output [2:0]    tlu_exu_cwp_m,
    output          tlu_exu_cwp_retry_m,
    output          tlu_exu_cwpccr_update_m,
    output [64-1:0] tlu_exu_rsr_data_m,
    output [40:0]   tlu_idtlb_dmp_key_g,
    output [1:0]    tlu_idtlb_dmp_thrid_g,
    output [3:0]    tlu_ifu_hwint_i3,
    output          tlu_ifu_nukeint_i2,
    output [3:0]    tlu_ifu_pstate_ie,
    output [3:0]    tlu_ifu_pstate_pef,
    output          tlu_ifu_resumint_i2,
    output          tlu_ifu_rstint_i2,
    output [3:0]    tlu_ifu_rstthr_i2,
    output [1:0]    tlu_ifu_trap_tid_w1,
    output          tlu_ifu_trapnpc_vld_w1,
    output [48:0]   tlu_ifu_trapnpc_w2,
    output [48:0]   tlu_ifu_trappc_w2,
    output          tlu_ifu_trappc_vld_w1,
    output          tlu_itlb_data_rd_g,
    output          tlu_itlb_dmp_actxt_g,
    output          tlu_itlb_dmp_all_g,
    output          tlu_itlb_dmp_nctxt_g,
    output          tlu_itlb_dmp_vld_g,
    output          tlu_itlb_invalidate_all_g,
    output [5:0]    tlu_itlb_rw_index_g,
    output          tlu_itlb_rw_index_vld_g,
    output          tlu_itlb_tag_rd_g,
    output [42:0]   tlu_itlb_tte_data_w2,
    output [58:0]   tlu_itlb_tte_tag_w2,
    output          tlu_itlb_wr_vld_g,
    output [7:0]    tlu_lsu_asi_m,
    output          tlu_lsu_asi_update_m,

    output          tlu_dtlb_csm_rd_g,
    output          tlu_itlb_csm_rd_g,
    output [32:0] tlu_dtlb_tte_csm_w2,
    output [32:0] tlu_itlb_tte_csm_w2,
    output          tlu_itlb_wr_csm_sel_g,
    output          tlu_dtlb_wr_csm_sel_g,

    output [62:0]   tlu_sscan_test_data,
    output [1:0]    tlu_lsu_ldxa_tid_w2,
    output [25:0]   tlu_lsu_pcxpkt,
    output [3:0]    tlu_lsu_pstate_am,
    output [3:0]    tlu_lsu_pstate_cle,
    output [3:0]    tlu_lsu_pstate_priv,
    output [3:0]    tlu_lsu_redmode,
    output [3:0]    tlu_lsu_redmode_rst_d1,
    output          tlu_lsu_stxa_ack,
    output [1:0]    tlu_lsu_stxa_ack_tid,
    output [1:0]    tlu_lsu_tid_m,
    output [4-1:0] tlu_lsu_tl_zero,
    output [4-1:0] tlu_sftint_vld,
    output [4-1:0] tlu_hintp_vld,
    output [4-1:0] tlu_rerr_vld,
    output tlu_early_flush_pipe_w,
    output tlu_early_flush_pipe2_w,
    output tlu_exu_early_flush_pipe_w,
    output tlu_lsu_ldxa_async_data_vld,
    output [4-1:0] tlu_hpstate_priv,
    output [4-1:0] tlu_hpstate_enb,
    output [4-1:0] tlu_hpstate_ibe,
    output tlu_exu_priv_trap_m,
    output tlu_lsu_priv_trap_m,
    output tlu_exu_pic_onebelow_m,
    output tlu_exu_pic_twobelow_m,
    output      lsu_exu_ldxa_m ,
    output  [63:0]  lsu_exu_ldxa_data_g,
    output  [3:0]   tlu_dsfsr_flt_vld
);
    wire [63:0] lsu_tlu_st_rs3_data_g = {lsu_tlu_st_rs3_data_g_63_59, 10'bx, lsu_tlu_st_rs3_data_g_48_0};
    wire [17:0] lsu_tlu_intpkt = {lsu_tlu_intpkt_17_16, 3'bx, lsu_tlu_intpkt_12_8, 2'bx, lsu_tlu_intpkt_5_0};
wire [94-1:0] core_rtap_data;
wire ifu_tlu_inst_vld_m_bf1 = ifu_tlu_inst_vld_m; // trin: exactly the same signal; for synthesis

    tlu tlu(
          .short_si0              (),
          .short_si1              (),
          .short_so0              (),
          .short_so1              (),
          .si0 (),
          .si1 (),
          .so0 (),
          .so1 (),
          .grst_l                (grst_l),
          .arst_l                (arst_l),
          .tlu_sftint_vld		    (tlu_sftint_vld),
          .ifu_tlu_swint_m		    (ifu_tlu_swint_m),
          .exu_tlu_cwp0                (exu_tlu_cwp0),
          .exu_tlu_cwp1                (exu_tlu_cwp1),
          .exu_tlu_cwp2                (exu_tlu_cwp2),
          .exu_tlu_cwp3                (exu_tlu_cwp3),
          .exu_tlu_ue_trap_m           (1'b0),
          .spu_tlu_rsrv_illgl_m        (1'b0),
          .ifu_lsu_imm_asi_d           (ifu_lsu_imm_asi_d),
          .ifu_tlu_imiss_e       (ifu_tlu_imiss_e),
          .ifu_tlu_thrid_d             (ifu_tlu_thrid_d),
          .lsu_tlu_st_rs3_data_g       (lsu_tlu_st_rs3_data_g),
          .lsu_tlu_async_ttype_g       (lsu_tlu_async_ttype_g),
          .lsu_tlu_async_tid_g         (lsu_tlu_async_tid_g),
          .lsu_tlu_async_ttype_vld_g   (lsu_tlu_async_ttype_vld_g),

          .tlu_dtlb_csm_rd_g           (tlu_dtlb_csm_rd_g),
          .tlu_itlb_csm_rd_g           (tlu_itlb_csm_rd_g),
          .tlu_dtlb_tte_csm_w2         (tlu_dtlb_tte_csm_w2),
          .tlu_itlb_tte_csm_w2         (tlu_itlb_tte_csm_w2),
          .tlu_itlb_wr_csm_sel_g       (tlu_itlb_wr_csm_sel_g),
          .tlu_dtlb_wr_csm_sel_g       (tlu_dtlb_wr_csm_sel_g),

          .tlu_lsu_int_ldxa_data_w2    (tlu_lsu_int_ldxa_data_w2),
          .tlu_lsu_int_ld_ill_va_w2    (tlu_lsu_int_ld_ill_va_w2),
          .tlu_lsu_int_ldxa_vld_w2     (tlu_lsu_int_ldxa_vld_w2),
          .tlu_dtlb_data_rd_g          (tlu_dtlb_data_rd_g),
          .tlu_dtlb_dmp_actxt_g        (tlu_dtlb_dmp_actxt_g),
          .tlu_dtlb_dmp_all_g          (tlu_dtlb_dmp_all_g),
          .tlu_dtlb_dmp_nctxt_g        (tlu_dtlb_dmp_nctxt_g),
          .tlu_dtlb_dmp_pctxt_g        (tlu_dtlb_dmp_pctxt_g),
          .tlu_dtlb_dmp_sctxt_g        (tlu_dtlb_dmp_sctxt_g),
          .tlu_dtlb_dmp_vld_g          (tlu_dtlb_dmp_vld_g),
          .tlu_dtlb_invalidate_all_g   (tlu_dtlb_invalidate_all_g),
          .tlu_dtlb_rw_index_g         (tlu_dtlb_rw_index_g),
          .tlu_dtlb_rw_index_vld_g     (tlu_dtlb_rw_index_vld_g),
          .tlu_dtlb_tag_rd_g           (tlu_dtlb_tag_rd_g),
          .tlu_dtlb_tte_data_w2        (tlu_dtlb_tte_data_w2),
          .tlu_dtlb_tte_tag_w2         (tlu_dtlb_tte_tag_w2),
          .lsu_ifu_inj_ack             (lsu_ifu_inj_ack),
          .tlu_exu_agp                 (tlu_exu_agp),
          .tlu_exu_agp_swap            (tlu_exu_agp_swap),
          .tlu_exu_agp_tid             (tlu_exu_agp_tid),
          .tlu_exu_ccr_m               (tlu_exu_ccr_m),
          .tlu_exu_cwp_m               (tlu_exu_cwp_m),
          .tlu_exu_cwp_retry_m         (tlu_exu_cwp_retry_m),
          .tlu_exu_cwpccr_update_m     (tlu_exu_cwpccr_update_m),
          .tlu_exu_rsr_data_m          (tlu_exu_rsr_data_m),
          .tlu_idtlb_dmp_key_g         (tlu_idtlb_dmp_key_g),
          .tlu_idtlb_dmp_thrid_g       (tlu_idtlb_dmp_thrid_g),
          .tlu_ifu_hwint_i3            (tlu_ifu_hwint_i3),
          .tlu_ifu_nukeint_i2          (tlu_ifu_nukeint_i2),
          .tlu_ifu_pstate_ie           (tlu_ifu_pstate_ie),
          .tlu_ifu_pstate_pef          (tlu_ifu_pstate_pef),
          .tlu_ifu_resumint_i2         (tlu_ifu_resumint_i2),
          .tlu_ifu_rstint_i2           (tlu_ifu_rstint_i2),
          .tlu_ifu_rstthr_i2           (tlu_ifu_rstthr_i2),
          .tlu_ifu_trap_tid_w1         (tlu_ifu_trap_tid_w1),
          .tlu_ifu_trapnpc_vld_w1      (tlu_ifu_trapnpc_vld_w1),
          .tlu_ifu_trapnpc_w2          (tlu_ifu_trapnpc_w2),
          .tlu_ifu_trappc_w2           (tlu_ifu_trappc_w2),
          .tlu_ifu_trappc_vld_w1       (tlu_ifu_trappc_vld_w1),
          .tlu_itlb_data_rd_g          (tlu_itlb_data_rd_g),
          .tlu_itlb_dmp_actxt_g        (tlu_itlb_dmp_actxt_g),
          .tlu_itlb_dmp_all_g          (tlu_itlb_dmp_all_g),
          .tlu_itlb_dmp_nctxt_g        (tlu_itlb_dmp_nctxt_g),
          .tlu_itlb_dmp_vld_g          (tlu_itlb_dmp_vld_g),
          .tlu_itlb_invalidate_all_g   (tlu_itlb_invalidate_all_g),
          .tlu_itlb_rw_index_g         (tlu_itlb_rw_index_g),
          .tlu_itlb_rw_index_vld_g     (tlu_itlb_rw_index_vld_g),
          .tlu_itlb_tag_rd_g           (tlu_itlb_tag_rd_g),
          .tlu_itlb_tte_data_w2        (tlu_itlb_tte_data_w2),
          .tlu_itlb_tte_tag_w2         (tlu_itlb_tte_tag_w2),
          .tlu_itlb_wr_vld_g           (tlu_itlb_wr_vld_g),
          .tlu_lsu_asi_m               (tlu_lsu_asi_m),
          .tlu_lsu_asi_update_m        (tlu_lsu_asi_update_m),
          .tlu_sscan_test_data         (tlu_sscan_test_data),
          .tlu_lsu_ldxa_tid_w2         (tlu_lsu_ldxa_tid_w2),
          .tlu_lsu_pcxpkt              (tlu_lsu_pcxpkt),
          .tlu_lsu_pstate_am           (tlu_lsu_pstate_am),
          .tlu_lsu_pstate_cle          (tlu_lsu_pstate_cle),
          .tlu_lsu_pstate_priv         (tlu_lsu_pstate_priv),
          .tlu_lsu_redmode             (tlu_lsu_redmode),
          .tlu_lsu_redmode_rst_d1      (tlu_lsu_redmode_rst_d1),
          .tlu_lsu_stxa_ack            (tlu_lsu_stxa_ack),
          .tlu_lsu_stxa_ack_tid        (tlu_lsu_stxa_ack_tid),
          .tlu_lsu_tid_m               (tlu_lsu_tid_m),
          .tlu_lsu_tl_zero             (tlu_lsu_tl_zero),
          .tlu_hintp_vld               (tlu_hintp_vld),
          .tlu_rerr_vld                (tlu_rerr_vld),
          .tlu_early_flush_pipe_w      (tlu_early_flush_pipe_w),
          .tlu_early_flush_pipe2_w     (tlu_early_flush_pipe2_w),
          .tlu_exu_early_flush_pipe_w  (tlu_exu_early_flush_pipe_w),
          .tlu_lsu_ldxa_async_data_vld (tlu_lsu_ldxa_async_data_vld),
          .tlu_hpstate_priv            (tlu_hpstate_priv),
          .tlu_hpstate_enb             (tlu_hpstate_enb),
          .tlu_hpstate_ibe             (tlu_hpstate_ibe),
          .tlu_exu_priv_trap_m         (tlu_exu_priv_trap_m),
          .tlu_lsu_priv_trap_m         (tlu_lsu_priv_trap_m),
          .tlu_exu_pic_onebelow_m      (tlu_exu_pic_onebelow_m),
          .tlu_exu_pic_twobelow_m      (tlu_exu_pic_twobelow_m),
          .lsu_exu_ldxa_m              (lsu_exu_ldxa_m),
          .lsu_exu_ldxa_data_g         (lsu_exu_ldxa_data_g),
          .tlu_dsfsr_flt_vld           (tlu_dsfsr_flt_vld),
          .rclk                        (rclk),
          .const_cpuid                 ({1'bx, const_cpuid}),
          .exu_lsu_ldst_va_e           (exu_lsu_ldst_va_e),
          .lsu_tlu_ldst_va_m           (lsu_tlu_ldst_va_m),
          .exu_mmu_early_va_e          (exu_mmu_early_va_e),
          .exu_tlu_ccr0_w              (exu_tlu_ccr0_w),
          .exu_tlu_ccr1_w              (exu_tlu_ccr1_w),

          .exu_tlu_ccr2_w              (8'bx),
          .exu_tlu_ccr3_w              (8'bx),




          .exu_tlu_cwp_cmplt           (exu_tlu_cwp_cmplt),
          .exu_tlu_cwp_cmplt_tid       (exu_tlu_cwp_cmplt_tid),
          .exu_tlu_cwp_retry           (exu_tlu_cwp_retry),
          .exu_tlu_misalign_addr_jmpl_rtn_m(exu_tlu_misalign_addr_jmpl_rtn_m),
          .exu_tlu_spill               (exu_tlu_spill),
          .exu_tlu_spill_tid           (exu_tlu_spill_tid),
          .exu_tlu_spill_other         (exu_tlu_spill_other),
          .exu_tlu_spill_wtype         (exu_tlu_spill_wtype),
          .exu_tlu_ttype_m             (exu_tlu_ttype_m),
          .exu_tlu_ttype_vld_m         (exu_tlu_ttype_vld_m),
          .exu_tlu_va_oor_jl_ret_m     (exu_tlu_va_oor_jl_ret_m),
          .exu_tlu_va_oor_m            (exu_tlu_va_oor_m),
          .ffu_tlu_ill_inst_m          (ffu_tlu_ill_inst_m),
          .ffu_ifu_tid_w2              (ffu_ifu_tid_w2),
          .ffu_tlu_trap_ieee754        (ffu_tlu_trap_ieee754),
          .ffu_tlu_trap_other          (ffu_tlu_trap_other),
          .ffu_tlu_trap_ue             (ffu_tlu_trap_ue),
          .ifu_lsu_ld_inst_e           (ifu_lsu_ld_inst_e),
          .ifu_lsu_memref_d            (ifu_lsu_memref_d),
          .ifu_lsu_st_inst_e           (ifu_lsu_st_inst_e),
          .ifu_tlu_done_inst_d         (ifu_tlu_done_inst_d),
          .ifu_tlu_flush_m             (ifu_tlu_flush_m),
          .ifu_tlu_flush_fd_w          (ifu_tlu_flush_fd_w),
          .ifu_tlu_flush_fd2_w         (ifu_tlu_flush_fd2_w),
          .ifu_tlu_flush_fd3_w         (ifu_tlu_flush_fd3_w),
          .lsu_tlu_early_flush_w       (lsu_tlu_early_flush_w),
          .lsu_tlu_early_flush2_w      (lsu_tlu_early_flush2_w),
          .ifu_tlu_hwint_m             (ifu_tlu_hwint_m),
          .ifu_tlu_immu_miss_m         (ifu_tlu_immu_miss_m),
          .ifu_tlu_pc_oor_e            (ifu_tlu_pc_oor_e),
          .ifu_tlu_l2imiss             (ifu_tlu_l2imiss),
          .ifu_tlu_inst_vld_m          (ifu_tlu_inst_vld_m),
          .ifu_tlu_inst_vld_m_bf1      (ifu_tlu_inst_vld_m_bf1),
          .ifu_tlu_itlb_done           (ifu_tlu_itlb_done),
          .ifu_tlu_npc_m               (ifu_tlu_npc_m),
          .ifu_tlu_pc_m                (ifu_tlu_pc_m),
          .ifu_tlu_priv_violtn_m       (ifu_tlu_priv_violtn_m),
          .ifu_tlu_retry_inst_d        (ifu_tlu_retry_inst_d),
          .ifu_tlu_rstint_m            (ifu_tlu_rstint_m),
          .ifu_tlu_sir_inst_m          (ifu_tlu_sir_inst_m),
          .ifu_lsu_thrid_s             (ifu_lsu_thrid_s),
          .ifu_tlu_ttype_m             (ifu_tlu_ttype_m),
          .ifu_tlu_ttype_vld_m         (ifu_tlu_ttype_vld_m),
          .ifu_mmu_trap_m              (ifu_mmu_trap_m),
          .ifu_tlu_trap_m              (ifu_tlu_trap_m),
          .lsu_asi_reg0                (lsu_asi_reg0),
          .lsu_asi_reg1                (lsu_asi_reg1),
          .lsu_asi_reg2                (lsu_asi_reg2),
          .lsu_asi_reg3                (lsu_asi_reg3),
          .lsu_asi_state               (lsu_asi_state),
          .lsu_tlu_defr_trp_taken_g    (lsu_tlu_defr_trp_taken_g),
          .lsu_mmu_defr_trp_taken_g    (lsu_mmu_defr_trp_taken_g),
          .lsu_tlu_cpx_req             (lsu_tlu_cpx_req),
          .lsu_tlu_cpx_vld             (lsu_tlu_cpx_vld),
          .lsu_tlu_daccess_excptn_g    (lsu_tlu_daccess_excptn_g),
          .lsu_tlu_daccess_prot_g      (lsu_tlu_daccess_prot_g),
          .lsu_tlu_dmmu_miss_g         (lsu_tlu_dmmu_miss_g),
          .lsu_tlu_dside_ctxt_m        (lsu_tlu_dside_ctxt_m),
          .lsu_tlu_dtlb_done           (lsu_tlu_dtlb_done),
          .lsu_tlu_intpkt              (lsu_tlu_intpkt),
          .lsu_tlu_misalign_addr_ldst_atm_m(lsu_tlu_misalign_addr_ldst_atm_m),
          .lsu_tlu_pctxt_m             (lsu_tlu_pctxt_m),
          .lsu_tlu_pcxpkt_ack          (lsu_tlu_pcxpkt_ack),
          .lsu_tlu_priv_action_g       (lsu_tlu_priv_action_g),
          .lsu_tlu_rs3_data_g          (lsu_tlu_rs3_data_g),
          .lsu_tlu_tlb_access_tid_m    (lsu_tlu_tlb_access_tid_m),
          .lsu_tlu_tlb_asi_state_m     (lsu_tlu_tlb_asi_state_m),
          .lsu_tlu_tlb_dmp_va_m        (lsu_tlu_tlb_dmp_va_m),
          .lsu_tlu_tlb_ld_inst_m       (lsu_tlu_tlb_ld_inst_m),
          .lsu_tlu_tlb_ldst_va_m       (lsu_tlu_tlb_ldst_va_m),
          .lsu_tlu_tlb_st_inst_m       (lsu_tlu_tlb_st_inst_m),
          .lsu_tlu_ttype_m2            (lsu_tlu_ttype_m2),
          .lsu_tlu_ttype_vld_m2        (lsu_tlu_ttype_vld_m2),
          .lsu_tlu_wtchpt_trp_g        (lsu_tlu_wtchpt_trp_g),
          // .mem_write_disable           (mem_write_disable),
          // .mux_drive_disable           (mux_drive_disable),
          .sehold                      (1'b0),
          .se                          (1'b0),
          .ifu_tlu_sraddr_d            (ifu_tlu_sraddr_d),
          .ifu_tlu_sraddr_d_v2         (ifu_tlu_sraddr_d_v2),
          .ifu_tlu_rsr_inst_d          (ifu_tlu_rsr_inst_d),
          .lsu_tlu_wsr_inst_e          (lsu_tlu_wsr_inst_e),
          .exu_tlu_wsr_data_m          (exu_tlu_wsr_data_m),
          .lsu_tlu_rsr_data_e          (lsu_tlu_rsr_data_e),
          .ifu_lsu_alt_space_e         (ifu_lsu_alt_space_e),
          .ifu_tlu_alt_space_d         (ifu_tlu_alt_space_d),
          .lsu_tlu_squash_va_oor_m     (lsu_tlu_squash_va_oor_m),
          .lsu_tlu_dcache_miss_w2      (lsu_tlu_dcache_miss_w2),
          .lsu_tlu_l2_dmiss            (lsu_tlu_l2_dmiss),
          .lsu_tlu_stb_full_w2         (lsu_tlu_stb_full_w2),
          .ffu_tlu_fpu_tid             (ffu_tlu_fpu_tid),
          .ffu_tlu_fpu_cmplt           (ffu_tlu_fpu_cmplt),
          .lsu_pid_state0              (lsu_pid_state0),
          .lsu_pid_state1              (lsu_pid_state1),
          .lsu_pid_state2              (lsu_pid_state2),
          .lsu_pid_state3              (lsu_pid_state3),
          .lsu_tlu_nucleus_ctxt_m      (lsu_tlu_nucleus_ctxt_m),
          .lsu_tlu_tte_pg_sz_g         (lsu_tlu_tte_pg_sz_g),
          .ifu_lsu_error_inj           (ifu_lsu_error_inj),
          .ifu_lsu_imm_asi_vld_d       (ifu_lsu_imm_asi_vld_d),
          .lsu_dsfsr_din_g             (lsu_dsfsr_din_g),
          .lsu_dmmu_sfsr_trp_wr        (lsu_dmmu_sfsr_trp_wr),
          .lsu_mmu_flush_pipe_w        (lsu_mmu_flush_pipe_w),
          .exu_lsu_priority_trap_m     (exu_lsu_priority_trap_m),

    .core_rtap_data          (core_rtap_data),
    .rtap_core_val         (rtap_core_val),
    .rtap_core_threadid         (rtap_core_threadid),
    .rtap_core_id         (rtap_core_id),
    .rtap_core_data         ({{(94 - 34){1'bx}}, rtap_core_data_33_0})
          );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_pib.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Performance Instrumentation Block 
//                      Performance monitoring 2 of the 9 possible events
//                      can be tracked per thread
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module	tlu_pib (/*AUTOARG*/
                 // input
                 ifu_tlu_imiss_e, ifu_tlu_immu_miss_m, ifu_tlu_thrid_d,
                 ifu_tlu_sraddr_d, ifu_tlu_rsr_inst_d, // ifu_tlu_wsr_inst_d, 
                 ifu_tlu_l2imiss, tlu_tcc_inst_w, lsu_tlu_wsr_inst_e, 
                 ffu_tlu_fpu_tid, ffu_tlu_fpu_cmplt, 
                 lsu_tlu_dmmu_miss_g, lsu_tlu_dcache_miss_w2, lsu_tlu_l2_dmiss,
                 lsu_tlu_stb_full_w2, exu_tlu_wsr_data_m, // tlu_tickcmp_sel, 
                 tlu_hpstate_priv, tlu_thread_inst_vld_g, tlu_wsr_inst_nq_g, 
                 tlu_full_flush_pipe_w2,  tlu_pstate_priv, tlu_thread_wsel_g, 
                 tlu_pib_rsr_data_e, tlu_hpstate_enb, ifu_tlu_flush_fd_w, 
//
// reset was modified to abide to the Niagara reset methodology 
                 rclk, arst_l, grst_l, si, se, // tlu_rst_l, rst_tri_en, 
                 // output

// tlu_pcr_ut_e, tlu_pcr_st_e,
                 pib_picl_wrap, pich_wrap_flg, pich_onebelow_flg, pich_twobelow_flg, 
                 tlu_pic_onebelow_e, tlu_pic_twobelow_e, pib_priv_act_trap_m, 
                 tlu_wsr_data_w, tlu_pcr_ut, tlu_pcr_st, tlu_pic_wrap_e, so);

// Input section
// Events generated by IFU
input	     ifu_tlu_imiss_e;	   // icache misses -- New interface  
input		 ifu_tlu_immu_miss_m;  // itlb misses 
input [1:0]	 ifu_tlu_thrid_d;	   //  thread id For instruction complete
input [4-1:0] tlu_thread_inst_vld_g; // For instruction complete
input [4-1:0] tlu_thread_wsel_g;  // thread of instruction fetched 
input [4-1:0] ifu_tlu_l2imiss; // l2 imiss -- new interface 

// ASR register read/write requests
input [7-1:0] ifu_tlu_sraddr_d;      
input ifu_tlu_rsr_inst_d; // valid rd sr(st/pr)
// input ifu_tlu_wsr_inst_d; // valid wr sr(st/pr)
input lsu_tlu_wsr_inst_e; // valid wr sr(st/pr)
// input tlu_wsr_inst_g; // valid wr sr(st/pr)
// modified for timing
input tlu_wsr_inst_nq_g; // valid wr sr(st/pr)
input [64-1:0] exu_tlu_wsr_data_m; // pr/st data to irf.
// modified due to timing
// input [`TLU_ASR_DATA_WIDTH-1:0] tlu_pib_rsr_data_e; // this was the tlu_exu_rsr_data_e 

// LSU generated events - also include L2 miss
input [4-1:0] lsu_tlu_dcache_miss_w2; // dcache miss -- new interface 
input [4-1:0] lsu_tlu_l2_dmiss;	     // l2 dmisses -- new interface 
input [4-1:0] lsu_tlu_stb_full_w2;	 // store buffer full -- new interface 
input lsu_tlu_dmmu_miss_g;	 // dtlb misses 
// FFU generated events - also include L2 miss
input [1:0] ffu_tlu_fpu_tid;   // ThrdID for the FF instr_cmplt -- new 
input       ffu_tlu_fpu_cmplt; // FF instru complete -- new 
// TLU information for event filtering
//
input [4-1:0] tlu_pstate_priv; // supervisor privilege information 
input [4-1:0] tlu_hpstate_priv;// hypervisor privilege information
input [4-1:0] tlu_hpstate_enb; // hyperlite enabling 
input tlu_tcc_inst_w; // For instruction complete 
input tlu_full_flush_pipe_w2; // For instruction complete 
input ifu_tlu_flush_fd_w; // For instruction complete 
// Global signals
input rclk;			
//
// reset was modified to abide to the Niagara reset methodology 
// input			reset;		
// input tlu_rst_l;		
input		grst_l;				// global reset - active log
input		arst_l;				// global reset - active log
input		si;				    // global scan-in 
input		se;				    // global scan-out 
// input		rst_tri_en;			// global reset - active log

// output section
// modified to make inst vld overflow trap precies
// output [`TLU_THRD_NUM-1:0] pib_pic_wrap;     // pic register wrap transition 
// output pib_rst_l;				// local unit reset - active low
output [4-1:0] pib_picl_wrap;       // pic register wrap transition 
output [4-1:0] pich_wrap_flg;       // pic register wrap transition 
output [4-1:0] pich_onebelow_flg;   // pic register wrap transition 
output [4-1:0] pich_twobelow_flg;   // pic register wrap transition 
// output [`TLU_THRD_NUM-1:0] pich_threebelow_flg; // pic register wrap transition 
// modified due to timing fixes
output [64-1:0] tlu_pib_rsr_data_e; // rsr data register data 
output tlu_pic_onebelow_e, tlu_pic_twobelow_e, tlu_pic_wrap_e; 
//
// modified for bug 5436 - Niagara 2.0
output [4-1:0] tlu_pcr_ut;   
output [4-1:0] tlu_pcr_st;   
wire tlu_pcr_ut_e, tlu_pcr_st_e; 


// 
// output [`TLU_THRD_NUM-1:0] pib_priv_act_trap;  // access privilege violation for pics 
output [4-1:0] pib_priv_act_trap_m;  // access privilege violation for pics 
// output [`TLU_ASR_DATA_WIDTH-1:0] tlu_exu_rsr_data_e; // Add in the final muxing of pib asr data 
output [64-1:0] tlu_wsr_data_w;     // flopped version of exu_tlu_wsr_data_m 
// output [47:0] tlu_ifu_trappc_w2;  // temporary for timing 
// output [47:0] tlu_ifu_trapnpc_w2; // temporary for timing 
output   so;				    // global scan-out 

//==============================================================================
// Local signal defines 
//==============================================================================
// decoded address for pcr and pic
wire pcr_rw_e, pcr_rw_m, pcr_rw_g; // pcr_rw_d, 
wire pic_priv_rw_e, pic_priv_rw_m, pic_priv_rw_g; // pic_priv_rw_d,  
wire pic_npriv_rw_e, pic_npriv_rw_m, pic_npriv_rw_g;// pic_npriv_rw_d, 
//
// read/write to pcr, evq and pic 
wire [4-1:0] wsr_thread_inst_g; 
wire [4-1:0] update_picl_sel, update_picl_wrap_en;
wire [4-1:0] picl_cnt_wrap_datain;
wire [4-1:0] update_pich_sel, update_pich_wrap_en;
wire [4-1:0] pich_cnt_wrap_datain;
wire [4-1:0] update_evq_sel;
wire [4-1:0] wsr_pcr_sel; 
wire [4-1:0] wsr_pic_sel; 
wire [4-1:0] update_pich_ovf; 
wire [4-1:0] update_picl_ovf; 
wire [4-1:0] inst_vld_w2; 
wire tcc_inst_w2;
// 
// added for bug 2919
wire [4-1:0] pic_update_ctl; 
wire [1:0] pic_update_sel_ctr; 
wire [1:0] pic_update_sel_incr; 
//
// modified for timing
// wire [`TLU_ASR_ADDR_WIDTH-1:0] pib_sraddr_d;      
wire [7-1:0] pib_sraddr_e;      
wire tlu_rsr_inst_e, tlu_wsr_inst_e;      
//
// picl masks
wire [8-1:0] picl_mask0, picl_mask1, picl_mask2, picl_mask3;
wire [8-1:0] picl_event0, picl_event1, picl_event2, picl_event3;
// added for bug2332
// wire incr_pich_onehot;
// pic counters
wire [4-1:0] incr_pich; 
wire [4-1:0] pich_mux_sel; 
wire [4-1:0] pich_cnt_wrap; 
wire [4-1:0] picl_cnt_wrap; 
wire [4-2:0] thread_rsel_d; 
wire [4-2:0] thread_rsel_e;
wire [4-1:0] pic_onebelow_e, pic_twobelow_e, pic_wrap_e; 
wire [33-1:0] picl_cnt0, picl_cnt1, picl_cnt2, picl_cnt3; 
wire [33-1:0] picl_cnt_din, picl_cnt_sum;
wire [33-1:0] picl_wsr_data; 
wire [33-1:0] update_picl0_data, update_picl1_data; 
wire [33-1:0] update_picl2_data, update_picl3_data; 
wire [33-1:0] pich_cnt0, pich_cnt1, pich_cnt2, pich_cnt3; 
wire [33-1:0] pich_cnt_din, pich_cnt_sum; 
wire [33-1:0] pich_wsr_data;
wire [33-1:0] update_pich0_data, update_pich1_data; 
wire [33-1:0] update_pich2_data, update_pich3_data; 
wire [64-1:0] pic_rdata_e;
wire [64-1:0] pcr_rdata_e;
wire [8-1:0] pcr_reg_rdata_e;
wire [8-1:0] pcr_wdata_in;
wire [4-1:0] picl_ovf_wdata_in;
wire [4-1:0] pich_ovf_wdata_in;
// experiment
wire [4-1:0] pich_fourbelow_din;
wire [4-1:0] pich_fourbelow_flg;
// wire [`TLU_THRD_NUM-1:0] pich_threebelow_flg;
// modified due to timing
// wire [2:0] rsr_data_sel_e;
wire [1:0] rsr_data_sel_e;
// picl evqs 
wire [3-1:0] picl_evq0, picl_evq1, picl_evq2, picl_evq3;
wire [3-1:0] picl_evq0_sum, picl_evq1_sum; 
wire [3-1:0] picl_evq2_sum, picl_evq3_sum; 
wire [3-1:0] update_evq0_data, update_evq1_data; 
wire [3-1:0] update_evq2_data, update_evq3_data; 
wire [3-1:0] picl_evq_din; 
wire [3-1:0] picl_evq0_din, picl_evq1_din; 
wire [3-1:0] picl_evq2_din, picl_evq3_din; 
wire [4-1:0] incr_evq_din, incr_evq;
// pcr registers
wire [8-1:0] pcr0, pcr1, pcr2, pcr3; 
// 
wire local_rst; // local active high reset
wire local_rst_l; // local active high reset
// counting enable indicator 
wire [4-1:0] pic_cnt_en, pic_cnt_en_w2;
//
// staged icache and itlb misses
wire imiss_m, imiss_g;
wire immu_miss_g;
//
// threaded icache, itlb, and dtlb misses
wire [4-1:0] imiss_thread_g;
wire [4-1:0] immu_miss_thread_g;
wire [4-1:0] dmmu_miss_thread_g;
wire [4-1:0] fpu_cmplt_thread;
//
// clock rename
wire clk; 

//==============================================================================
// Code starts here
//==============================================================================
//	reset

dffrl_async dffrl_local_rst_l(
    .din  (grst_l),
    .clk  (clk),
    .rst_l(arst_l),
    .q    (local_rst_l),
    .se   (se),
    .si   (),
    .so   ()
); 

assign local_rst = ~local_rst_l;
// assign pib_rst_l = local_rst_l;
// assign local_rst = ~tlu_rst_l;
//
// rename clock 
assign clk = rclk;

//
// privilege action trap due to user access of pic register when
// PRIV bit is set in pcr
// modified for timing fixes
/*
assign pib_priv_act_trap = (pic_npriv_rw_g ) & 
           ((pcr0[`PIB_PCR_PRIV]  & tlu_thread_inst_vld_g[0]) & 
             ~tlu_pstate_priv[0]) |
           ((pcr1[`PIB_PCR_PRIV]  & tlu_thread_inst_vld_g[1]) & 
             ~tlu_pstate_priv[1]) |
           ((pcr2[`PIB_PCR_PRIV]  & tlu_thread_inst_vld_g[2]) & 
             ~tlu_pstate_priv[2]) |
           ((pcr3[`PIB_PCR_PRIV]  & tlu_thread_inst_vld_g[3]) & 
             ~tlu_pstate_priv[3]);
*/
assign pib_priv_act_trap_m[0] = pic_npriv_rw_m & pcr0[0]; 
assign pib_priv_act_trap_m[1] = pic_npriv_rw_m & pcr1[0]; 
assign pib_priv_act_trap_m[2] = pic_npriv_rw_m & pcr2[0]; 
assign pib_priv_act_trap_m[3] = pic_npriv_rw_m & pcr3[0]; 
             
//
// staging the exu_tlu_wsr_data_w signal for timing
//
dff_s #(64) dff_tlu_wsr_data_w (
    .din (exu_tlu_wsr_data_m[64-1:0]), 
    .q   (tlu_wsr_data_w[64-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
//================================
// address decode for PCR and PICs 
//================================
// added and modified for timing
// assign pib_sraddr_d[`TLU_ASR_ADDR_WIDTH-1:0] =
//            ifu_tlu_sraddr_d[`TLU_ASR_ADDR_WIDTH-1:0]; 

dff_s #(7) dff_pib_sraddr_e (
    .din (ifu_tlu_sraddr_d[7-1:0]),
    .q   (pib_sraddr_e[7-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_tlu_rsr_inst_e (
    .din (ifu_tlu_rsr_inst_d),
    .q   (tlu_rsr_inst_e),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// modified for timing
/*
dffr_s dffr_tlu_wsr_inst_e (
    .din (ifu_tlu_wsr_inst_d),
    .q   (tlu_wsr_inst_e),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
assign tlu_wsr_inst_e = lsu_tlu_wsr_inst_e;
//
assign pcr_rw_e = 
           (pib_sraddr_e[7-1:0] == 7'b0010000); 
assign pic_priv_rw_e = 
           (pib_sraddr_e[7-1:0] == 7'b0110001);
assign pic_npriv_rw_e = 
           (pib_sraddr_e[7-1:0] == 7'b0010001) &
           (tlu_rsr_inst_e | tlu_wsr_inst_e);
//
// staging of the ASR decoded controls
//
// staging from d to e stage
// deleted for timing
/*
dff_s dff_pcr_rw_d_e (
    .din (pcr_rw_d),
    .q   (pcr_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_priv_rw_d_e (
    .din (pic_priv_rw_d),
    .q   (pic_priv_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_npriv_rw_d_e (
    .din (pic_npriv_rw_d),
    .q   (pic_npriv_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
//
// staging from e to m stage
dff_s dff_pcr_rw_e_m (
    .din (pcr_rw_e),
    .q   (pcr_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_priv_rw_e_m (
    .din (pic_priv_rw_e),
    .q   (pic_priv_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_npriv_rw_e_m (
    .din (pic_npriv_rw_e),
    .q   (pic_npriv_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_imiss_e_m (
    .din (ifu_tlu_imiss_e),
    .q   (imiss_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// staging from m to g stage
dff_s dff_pcr_rw_m_g (
    .din (pcr_rw_m),
    .q   (pcr_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_priv_rw_m_g (
    .din (pic_priv_rw_m),
    .q   (pic_priv_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_npriv_rw_m_g (
    .din (pic_npriv_rw_m),
    .q   (pic_npriv_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_imiss_m_g (
    .din (imiss_m),
    .q   (imiss_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_immu_miss_m_g (
    .din (ifu_tlu_immu_miss_m),
    .q   (immu_miss_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
//=========================
// update for PCR registers   
//=========================
//
assign wsr_thread_inst_g[0] = 
           tlu_wsr_inst_nq_g & ~ifu_tlu_flush_fd_w & tlu_thread_wsel_g[0];
assign wsr_thread_inst_g[1] = 
           tlu_wsr_inst_nq_g & ~ifu_tlu_flush_fd_w & tlu_thread_wsel_g[1];
assign wsr_thread_inst_g[2] = 
           tlu_wsr_inst_nq_g & ~ifu_tlu_flush_fd_w & tlu_thread_wsel_g[2];
assign wsr_thread_inst_g[3] = 
           tlu_wsr_inst_nq_g & ~ifu_tlu_flush_fd_w & tlu_thread_wsel_g[3];
// 
// extracting the relevant bits from the wsr data bus
assign pcr_wdata_in = 
    {tlu_wsr_data_w[9:8],
     tlu_wsr_data_w[6:4],
     tlu_wsr_data_w[2:0]};
//
// thread 0
assign wsr_pcr_sel[0] = wsr_thread_inst_g[0] & pcr_rw_g; 

assign update_picl_ovf[0] = 
           (wsr_thread_inst_g[0] & pcr_rw_g) |
           (picl_cnt_wrap[0] ^ picl_cnt0[33-1]);

assign update_pich_ovf[0] = 
           (wsr_thread_inst_g[0] & pcr_rw_g) |
           (pich_cnt_wrap[0] ^ pich_cnt0[33-1]);
//
// modified for bug 2291
dffre_s #(8-2) dffre_pcr0 (
 //   .din (tlu_wsr_data_w[`PIB_PCR_WIDTH-1:0]),
    .din (pcr_wdata_in[8-3:0]),
    .q   (pcr0[8-3:0]),
    .rst (local_rst),
    .en  (wsr_pcr_sel[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr0_picl_ovf (
	.in0(pcr_wdata_in[6]),  
	.in1(picl_cnt_wrap[0] ^ picl_cnt0[33-1]),
	.sel0(wsr_pcr_sel[0]),
	.sel1(~wsr_pcr_sel[0]),
	.dout(picl_ovf_wdata_in[0])
);

// added for the new bug 2588
dffre_s dffre_pcr0_picl_ovf (
    .din (picl_ovf_wdata_in[0]),
    .q   (pcr0[6]),
    .clk (clk),
    .en  (update_picl_ovf[0]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr0_pich_ovf (
	.in0(pcr_wdata_in[7]),  
	.in1(pich_cnt_wrap[0] ^ pich_cnt0[33-1]),
	.sel0(wsr_pcr_sel[0]),
	.sel1(~wsr_pcr_sel[0]),
	.dout(pich_ovf_wdata_in[0])
);

dffre_s dffre_pcr0_pich_ovf (
    .din (pich_ovf_wdata_in[0]),
    .q   (pcr0[7]),
    .clk (clk),
    .en  (update_pich_ovf[0]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// thread 1

assign wsr_pcr_sel[1] = wsr_thread_inst_g[1] & pcr_rw_g; 

assign update_picl_ovf[1] = 
           (wsr_thread_inst_g[1] & pcr_rw_g) |
           (picl_cnt_wrap[1] ^ picl_cnt1[33-1]);

assign update_pich_ovf[1] = 
           (wsr_thread_inst_g[1] & pcr_rw_g) |
           (pich_cnt_wrap[1] ^ pich_cnt1[33-1]);

dffre_s #(8-2) dffre_pcr1 (
 //   .din (tlu_wsr_data_w[`PIB_PCR_WIDTH-1:0]),
    .din (pcr_wdata_in[8-3:0]),
    .q   (pcr1[8-3:0]),
    .rst (local_rst),
    .en  (wsr_pcr_sel[1]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr1_picl_ovf (
	.in0(pcr_wdata_in[6]),  
	.in1(picl_cnt_wrap[1] ^ picl_cnt1[33-1]),
	.sel0(wsr_pcr_sel[1]),
	.sel1(~wsr_pcr_sel[1]),
	.dout(picl_ovf_wdata_in[1])
);
// added for the new bug 2588
dffre_s dffre_pcr1_picl_ovf (
    .din (picl_ovf_wdata_in[1]),
    .q   (pcr1[6]),
    .clk (clk),
    .en  (update_picl_ovf[1]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr1_pich_ovf (
	.in0(pcr_wdata_in[7]),  
	.in1(pich_cnt_wrap[1] ^ pich_cnt1[33-1]),
	.sel0(wsr_pcr_sel[1]),
	.sel1(~wsr_pcr_sel[1]),
	.dout(pich_ovf_wdata_in[1])
);

dffre_s dffre_pcr1_pich_ovf (
    .din (pich_ovf_wdata_in[1]),
    .q   (pcr1[7]),
    .clk (clk),
    .en  (update_pich_ovf[1]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// thread 2

assign wsr_pcr_sel[2] = wsr_thread_inst_g[2] & pcr_rw_g; 

assign update_picl_ovf[2] = 
           (wsr_thread_inst_g[2] & pcr_rw_g) |
           (picl_cnt_wrap[2] ^ picl_cnt2[33-1]);

assign update_pich_ovf[2] = 
           (wsr_thread_inst_g[2] & pcr_rw_g) |
           (pich_cnt_wrap[2] ^ pich_cnt2[33-1]);

dffre_s #(8-2) dffre_pcr2 (
 //   .din (tlu_wsr_data_w[`PIB_PCR_WIDTH-1:0]),
    .din (pcr_wdata_in[8-3:0]),
    .q   (pcr2[8-3:0]),
    .rst (local_rst),
    .en  (wsr_pcr_sel[2]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr2_picl_ovf (
	.in0(pcr_wdata_in[6]),  
	.in1(picl_cnt_wrap[2] ^ picl_cnt2[33-1]),
	.sel0(wsr_pcr_sel[2]),
	.sel1(~wsr_pcr_sel[2]),
	.dout(picl_ovf_wdata_in[2])
);

// added for the new bug 2588
dffre_s dffre_pcr2_picl_ovf (
    .din (picl_ovf_wdata_in[2]),
    .q   (pcr2[6]),
    .clk (clk),
    .en  (update_picl_ovf[2]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr2_pich_ovf (
	.in0(pcr_wdata_in[7]),  
	.in1(pich_cnt_wrap[2] ^ pich_cnt2[33-1]),
	.sel0(wsr_pcr_sel[2]),
	.sel1(~wsr_pcr_sel[2]),
	.dout(pich_ovf_wdata_in[2])
);

dffre_s dffre_pcr2_pich_ovf (
    .din (pich_ovf_wdata_in[2]),
    .q   (pcr2[7]),
    .clk (clk),
    .en  (update_pich_ovf[2]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// thread 3

assign wsr_pcr_sel[3] = wsr_thread_inst_g[3] & pcr_rw_g; 

assign update_picl_ovf[3] = 
           (wsr_thread_inst_g[3] & pcr_rw_g) |
           (picl_cnt_wrap[3] ^ picl_cnt3[33-1]);

assign update_pich_ovf[3] = 
           (wsr_thread_inst_g[3] & pcr_rw_g) |
           (pich_cnt_wrap[3] ^ pich_cnt3[33-1]);

dffre_s #(8-2) dffre_pcr3 (
 //   .din (tlu_wsr_data_w[`PIB_PCR_WIDTH-1:0]),
    .din (pcr_wdata_in[8-3:0]),
    .q   (pcr3[8-3:0]),
    .rst (local_rst),
    .en  (wsr_pcr_sel[3]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr3_picl_ovf (
	.in0(pcr_wdata_in[6]),  
	.in1(picl_cnt_wrap[3] ^ picl_cnt3[33-1]),
	.sel0(wsr_pcr_sel[3]),
	.sel1(~wsr_pcr_sel[3]),
	.dout(picl_ovf_wdata_in[3])
);

// added for the new bug 2588
dffre_s dffre_pcr3_picl_ovf (
    .din (picl_ovf_wdata_in[3]),
    .q   (pcr3[6]),
    .clk (clk),
    .en  (update_picl_ovf[3]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

mux2ds mux_pcr3_pich_ovf (
	.in0(pcr_wdata_in[7]),  
	.in1(pich_cnt_wrap[3] ^ pich_cnt3[33-1]),
	.sel0(wsr_pcr_sel[3]),
	.sel1(~wsr_pcr_sel[3]),
	.dout(pich_ovf_wdata_in[3])
);

dffre_s dffre_pcr3_pich_ovf (
    .din (pich_ovf_wdata_in[3]),
    .q   (pcr3[7]),
    .clk (clk),
    .en  (update_pich_ovf[3]),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
//====================
// threading of events 
//====================
//
// icache misses
assign imiss_thread_g[0] = imiss_g & tlu_thread_wsel_g[0];
assign imiss_thread_g[1] = imiss_g & tlu_thread_wsel_g[1];
assign imiss_thread_g[2] = imiss_g & tlu_thread_wsel_g[2];
assign imiss_thread_g[3] = imiss_g & tlu_thread_wsel_g[3];
//
// itlb misses
assign immu_miss_thread_g[0] = immu_miss_g & tlu_thread_wsel_g[0];
assign immu_miss_thread_g[1] = immu_miss_g & tlu_thread_wsel_g[1];
assign immu_miss_thread_g[2] = immu_miss_g & tlu_thread_wsel_g[2];
assign immu_miss_thread_g[3] = immu_miss_g & tlu_thread_wsel_g[3];
//
// dtlb misses
assign dmmu_miss_thread_g[0] = lsu_tlu_dmmu_miss_g & tlu_thread_wsel_g[0];
assign dmmu_miss_thread_g[1] = lsu_tlu_dmmu_miss_g & tlu_thread_wsel_g[1];
assign dmmu_miss_thread_g[2] = lsu_tlu_dmmu_miss_g & tlu_thread_wsel_g[2];
assign dmmu_miss_thread_g[3] = lsu_tlu_dmmu_miss_g & tlu_thread_wsel_g[3];
//
// itlb misses
assign fpu_cmplt_thread[0] = 
           ffu_tlu_fpu_cmplt & (~ffu_tlu_fpu_tid[0] & ~ffu_tlu_fpu_tid[1]); 
assign fpu_cmplt_thread[1] = 
           ffu_tlu_fpu_cmplt & (ffu_tlu_fpu_tid[0]  & ~ffu_tlu_fpu_tid[1]); 
assign fpu_cmplt_thread[2] = 
           ffu_tlu_fpu_cmplt & (~ffu_tlu_fpu_tid[0] &  ffu_tlu_fpu_tid[1]); 
assign fpu_cmplt_thread[3] = 
           ffu_tlu_fpu_cmplt & (ffu_tlu_fpu_tid[0]  &  ffu_tlu_fpu_tid[1]); 

//====================
// assigning of events 
//====================
//
// thread 0
assign picl_event0[0]   = lsu_tlu_stb_full_w2[0]; 
assign picl_event0[1]   = fpu_cmplt_thread[0]; 
assign picl_event0[2]   = imiss_thread_g[0]; 
assign picl_event0[3]   = lsu_tlu_dcache_miss_w2[0]; 
assign picl_event0[4] = immu_miss_thread_g[0]; 
assign picl_event0[5] = dmmu_miss_thread_g[0]; 
assign picl_event0[6]  = ifu_tlu_l2imiss[0]; 
assign picl_event0[7]  = lsu_tlu_l2_dmiss[0]; 
//
// thread 1
assign picl_event1[0]   = lsu_tlu_stb_full_w2[1]; 
assign picl_event1[1]   = fpu_cmplt_thread[1]; 
assign picl_event1[2]   = imiss_thread_g[1]; 
assign picl_event1[3]   = lsu_tlu_dcache_miss_w2[1]; 
assign picl_event1[4] = immu_miss_thread_g[1]; 
assign picl_event1[5] = dmmu_miss_thread_g[1]; 
assign picl_event1[6]  = ifu_tlu_l2imiss[1]; 
assign picl_event1[7]  = lsu_tlu_l2_dmiss[1]; 
//
// thread 2
assign picl_event2[0]   = lsu_tlu_stb_full_w2[2]; 
assign picl_event2[1]   = fpu_cmplt_thread[2]; 
assign picl_event2[2]   = imiss_thread_g[2]; 
assign picl_event2[3]   = lsu_tlu_dcache_miss_w2[2]; 
assign picl_event2[4] = immu_miss_thread_g[2]; 
assign picl_event2[5] = dmmu_miss_thread_g[2]; 
assign picl_event2[6]  = ifu_tlu_l2imiss[2]; 
assign picl_event2[7]  = lsu_tlu_l2_dmiss[2]; 
//
// thread 3
assign picl_event3[0]   = lsu_tlu_stb_full_w2[3]; 
assign picl_event3[1]   = fpu_cmplt_thread[3]; 
assign picl_event3[2]   = imiss_thread_g[3]; 
assign picl_event3[3]   = lsu_tlu_dcache_miss_w2[3]; 
assign picl_event3[4] = immu_miss_thread_g[3]; 
assign picl_event3[5] = dmmu_miss_thread_g[3]; 
assign picl_event3[6]  = ifu_tlu_l2imiss[3]; 
assign picl_event3[7]  = lsu_tlu_l2_dmiss[3]; 

//======================
// decode for PIC events   
//======================
// 
// thread 0

assign pic_cnt_en[0] = 
            (~tlu_hpstate_priv[0] & ~tlu_pstate_priv[0] & pcr0[2])   | 
            (~tlu_hpstate_enb[0]  & tlu_hpstate_priv[0] & pcr0[1])   |
            (tlu_hpstate_enb[0]   & tlu_pstate_priv[0]  & ~tlu_hpstate_priv[0] & 
             pcr0[1]); 
//
// picl mask decodes
assign picl_mask0[0] =  
           ((pcr0[5:3] == 3'b000) &
             pic_cnt_en[0]);
assign picl_mask0[1] =  
           ((pcr0[5:3] == 3'b001) &
             pic_cnt_en[0]);
assign picl_mask0[2] =  
           ((pcr0[5:3] == 3'b010) &
             pic_cnt_en[0]);
assign picl_mask0[3] =  
           ((pcr0[5:3] == 3'b011) &
             pic_cnt_en[0]);
assign picl_mask0[4] =  
           ((pcr0[5:3] == 3'b100) &
             pic_cnt_en[0]);
assign picl_mask0[5] =  
           ((pcr0[5:3] == 3'b101) &
             pic_cnt_en[0]);
assign picl_mask0[6] =  
           ((pcr0[5:3] == 3'b110) &
             pic_cnt_en[0]);
assign picl_mask0[7] =  
           ((pcr0[5:3] == 3'b111) &
             pic_cnt_en[0]);
// 
// thread 1

assign pic_cnt_en[1] = 
            (~tlu_hpstate_priv[1] & ~tlu_pstate_priv[1] & pcr1[2])   | 
            (~tlu_hpstate_enb[1]  & tlu_hpstate_priv[1] & pcr1[1])   |
            (tlu_hpstate_enb[1]   & tlu_pstate_priv[1]  & ~tlu_hpstate_priv[1] & 
             pcr1[1]); 
//
// picl mask decodes
assign picl_mask1[0] =  
           ((pcr1[5:3] == 3'b000) &
             pic_cnt_en[1]);
assign picl_mask1[1] =  
           ((pcr1[5:3] == 3'b001) &
             pic_cnt_en[1]);
assign picl_mask1[2] =  
           ((pcr1[5:3] == 3'b010) &
             pic_cnt_en[1]);
assign picl_mask1[3] =  
           ((pcr1[5:3] == 3'b011) &
             pic_cnt_en[1]);
assign picl_mask1[4] =  
           ((pcr1[5:3] == 3'b100) &
             pic_cnt_en[1]);
assign picl_mask1[5] =  
           ((pcr1[5:3] == 3'b101) &
             pic_cnt_en[1]);
assign picl_mask1[6] =  
           ((pcr1[5:3] == 3'b110) &
             pic_cnt_en[1]);
assign picl_mask1[7] =  
           ((pcr1[5:3] == 3'b111) &
             pic_cnt_en[1]);
// 
// thread 2

assign pic_cnt_en[2] = 
            (~tlu_hpstate_priv[2] & ~tlu_pstate_priv[2] & pcr2[2])   | 
            (~tlu_hpstate_enb[2]  & tlu_hpstate_priv[2] & pcr2[1])   |
            (tlu_hpstate_enb[2]   & tlu_pstate_priv[2]  & ~tlu_hpstate_priv[2] & 
             pcr2[1]); 
//
// picl mask decodes
assign picl_mask2[0] =  
           ((pcr2[5:3] == 3'b000) &
             pic_cnt_en[2]);
assign picl_mask2[1] =  
           ((pcr2[5:3] == 3'b001) &
             pic_cnt_en[2]);
assign picl_mask2[2] =  
           ((pcr2[5:3] == 3'b010) &
             pic_cnt_en[2]);
assign picl_mask2[3] =  
           ((pcr2[5:3] == 3'b011) &
             pic_cnt_en[2]);
assign picl_mask2[4] =  
           ((pcr2[5:3] == 3'b100) &
             pic_cnt_en[2]);
assign picl_mask2[5] =  
           ((pcr2[5:3] == 3'b101) &
             pic_cnt_en[2]);
assign picl_mask2[6] =  
           ((pcr2[5:3] == 3'b110) &
             pic_cnt_en[2]);
assign picl_mask2[7] =  
           ((pcr2[5:3] == 3'b111) &
             pic_cnt_en[2]);
// 
// thread 3

assign pic_cnt_en[3] = 
            (~tlu_hpstate_priv[3] & ~tlu_pstate_priv[3] & pcr3[2])   | 
            (~tlu_hpstate_enb[3]  & tlu_hpstate_priv[3] & pcr3[1])   |
            (tlu_hpstate_enb[3]   & tlu_pstate_priv[3]  & ~tlu_hpstate_priv[3] & 
             pcr3[1]); 
//
// added for timing
dff_s #(4) dff_pic_cnt_en_w2 (
    .din (pic_cnt_en[4-1:0]),
    .q   (pic_cnt_en_w2[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// picl mask decodes
assign picl_mask3[0] =  
           ((pcr3[5:3] == 3'b000) &
             pic_cnt_en[3]);
assign picl_mask3[1] =  
           ((pcr3[5:3] == 3'b001) &
             pic_cnt_en[3]);
assign picl_mask3[2] =  
           ((pcr3[5:3] == 3'b010) &
             pic_cnt_en[3]);
assign picl_mask3[3] =  
           ((pcr3[5:3] == 3'b011) &
             pic_cnt_en[3]);
assign picl_mask3[4] =  
           ((pcr3[5:3] == 3'b100) &
             pic_cnt_en[3]);
assign picl_mask3[5] =  
           ((pcr3[5:3] == 3'b101) &
             pic_cnt_en[3]);
assign picl_mask3[6] =  
           ((pcr3[5:3] == 3'b110) &
             pic_cnt_en[3]);
assign picl_mask3[7] =  
           ((pcr3[5:3] == 3'b111) &
             pic_cnt_en[3]);

//==================================================================
// update the picls - could be sperated into a dp block if needed 
//==================================================================
// added for bug 2919
// rrobin scheduler to choose thread to update
dffr_s #(2) dffr_pic_update_sel_ctr (
    .din (pic_update_sel_incr[1:0]),
    .q   (pic_update_sel_ctr[1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign pic_update_sel_incr[1:0] = 
           pic_update_sel_ctr[1:0] + 2'b01;

assign pic_update_ctl[0] = 
           ~|(pic_update_sel_incr[1:0]); 
assign pic_update_ctl[1] = 
           ~pic_update_sel_incr[1] &  pic_update_sel_incr[0]; 
assign pic_update_ctl[2] = 
           pic_update_sel_incr[1]  & ~pic_update_sel_incr[0]; 
assign pic_update_ctl[3] = 
           &(pic_update_sel_incr[1:0]); 
// 
// EVQs for PICL
//
// masking events for increment for picl evq update
assign incr_evq_din[0] = 
           (|(picl_mask0[8-1:0] & 
             picl_event0[8-1:0]));
assign incr_evq_din[1] = 
           (|(picl_mask1[8-1:0] & 
             picl_event1[8-1:0]));
assign incr_evq_din[2] = 
           (|(picl_mask2[8-1:0] & 
             picl_event2[8-1:0]));
assign incr_evq_din[3] = 
           (|(picl_mask3[8-1:0] & 
             picl_event3[8-1:0])); 
//
// added due to timing 
dff_s #(4) dff_incr_evq (
    .din (incr_evq_din[4-1:0]),
    .q   (incr_evq[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// constructing controls to update the picl_evq
assign update_evq_sel[0] = (local_rst | pic_update_ctl[0] | incr_evq[0]); 
assign update_evq_sel[1] = (local_rst | pic_update_ctl[1] | incr_evq[1]); 
assign update_evq_sel[2] = (local_rst | pic_update_ctl[2] | incr_evq[2]); 
assign update_evq_sel[3] = (local_rst | pic_update_ctl[3] | incr_evq[3]); 
//
// increment evq count for each thread
// thread 0
tlu_addern_32 #(3,1) picl_evq0_adder (
    .din  (picl_evq0[3-1:0]),
    .incr (1'b1),
    .sum  (picl_evq0_sum[3-1:0])
) ;

mux2ds #(3) mux_update_evq0_data (
       .in0  ({3{1'b0}}),
       .in1  (picl_evq0_sum[3-1:0]),
       .sel0 (local_rst | pic_update_ctl[0]),
       .sel1 (~(local_rst | pic_update_ctl[0])),
       .dout (update_evq0_data[3-1:0])
);

dffe_s #(3) dff_picl_evq0 (
    .din (update_evq0_data[3-1:0]),
    .q   (picl_evq0[3-1:0]),
    .clk (clk),
    .en  (update_evq_sel[0]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 1
tlu_addern_32 #(3,1) picl_evq1_adder (
    .din  (picl_evq1[3-1:0]),
    .incr (1'b1),
    .sum  (picl_evq1_sum[3-1:0])
) ;

mux2ds #(3) mux_update_evq1_data (
       .in0  ({3{1'b0}}),
       .in1  (picl_evq1_sum[3-1:0]),
       .sel0 (local_rst | pic_update_ctl[1]),
       .sel1 (~(local_rst | pic_update_ctl[1])),
       .dout (update_evq1_data[3-1:0])
);

dffe_s #(3) dff_picl_evq1 (
    .din (update_evq1_data[3-1:0]),
    .q   (picl_evq1[3-1:0]),
    .clk (clk),
    .en  (update_evq_sel[1]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 2
tlu_addern_32 #(3,1) picl_evq2_adder (
    .din  (picl_evq2[3-1:0]),
    .incr (1'b1),
    .sum  (picl_evq2_sum[3-1:0])
) ;

mux2ds #(3) mux_update_evq2_data (
       .in0  ({3{1'b0}}),
       .in1  (picl_evq2_sum[3-1:0]),
       .sel0 (local_rst | pic_update_ctl[2]),
       .sel1 (~(local_rst | pic_update_ctl[2])),
       .dout (update_evq2_data[3-1:0])
);

dffe_s #(3) dff_picl_evq2 (
    .din (update_evq2_data[3-1:0]),
    .q   (picl_evq2[3-1:0]),
    .clk (clk),
    .en  (update_evq_sel[2]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 3
tlu_addern_32 #(3,1) picl_evq3_adder (
    .din  (picl_evq3[3-1:0]),
    .incr (1'b1),
    .sum  (picl_evq3_sum[3-1:0])
) ;

mux2ds #(3) mux_update_evq3_data (
       .in0  ({3{1'b0}}),
       .in1  (picl_evq3_sum[3-1:0]),
       .sel0 (local_rst | pic_update_ctl[3]),
       .sel1 (~(local_rst | pic_update_ctl[3])),
       .dout (update_evq3_data[3-1:0])
);

dffe_s #(3) dff_picl_evq3 (
    .din (update_evq3_data[3-1:0]),
    .q   (picl_evq3[3-1:0]),
    .clk (clk),
    .en  (update_evq_sel[3]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// selelcting the thread for incrementing for picl
//
mux4ds #(33) mux_picl_cnt_din (
       .in0  (picl_cnt0[33-1:0]),
       .in1  (picl_cnt1[33-1:0]),
       .in2  (picl_cnt2[33-1:0]),
       .in3  (picl_cnt3[33-1:0]),
       .sel0 (pic_update_ctl[0]),
       .sel1 (pic_update_ctl[1]),
       .sel2 (pic_update_ctl[2]),
       .sel3 (pic_update_ctl[3]),
       .dout (picl_cnt_din[33-1:0])
);
//
// selecting the correct input for incrementing the picl
// thread0
mux2ds #(3) mux_picl_evq0_din (
       .in0  (picl_evq0_sum[3-1:0]),
       .in1  (picl_evq0[3-1:0]),
       .sel0 (incr_evq[0]),
       .sel1 (~incr_evq[0]),
       .dout (picl_evq0_din[3-1:0])
);
//
// thread1
mux2ds #(3) mux_picl_evq1_din (
       .in0  (picl_evq1_sum[3-1:0]),
       .in1  (picl_evq1[3-1:0]),
       .sel0 (incr_evq[1]),
       .sel1 (~incr_evq[1]),
       .dout (picl_evq1_din[3-1:0])
);
//
// thread2
mux2ds #(3) mux_picl_evq2_din (
       .in0  (picl_evq2_sum[3-1:0]),
       .in1  (picl_evq2[3-1:0]),
       .sel0 (incr_evq[2]),
       .sel1 (~incr_evq[2]),
       .dout (picl_evq2_din[3-1:0])
);
//
// thread3
mux2ds #(3) mux_picl_evq3_din (
       .in0  (picl_evq3_sum[3-1:0]),
       .in1  (picl_evq3[3-1:0]),
       .sel0 (incr_evq[3]),
       .sel1 (~incr_evq[3]),
       .dout (picl_evq3_din[3-1:0])
);

//
mux4ds #(3) mux_picl_evq_din (
       .in0  (picl_evq0_din[3-1:0]),
       .in1  (picl_evq1_din[3-1:0]),
       .in2  (picl_evq2_din[3-1:0]),
       .in3  (picl_evq3_din[3-1:0]),
       .sel0 (pic_update_ctl[0]),
       .sel1 (pic_update_ctl[1]),
       .sel2 (pic_update_ctl[2]),
       .sel3 (pic_update_ctl[3]),
       .dout (picl_evq_din[3-1:0])
);
//
// picl incrementor  - shared between four threads
//
tlu_addern_32 #(33,3) picl_adder (
    .din  (picl_cnt_din[33-1:0]),
    .incr (picl_evq_din[3-1:0]),
    .sum  (picl_cnt_sum[33-1:0])
) ;
//
// construction mux selects for picl update

assign wsr_pic_sel[0] = wsr_thread_inst_g[0] & (pic_npriv_rw_g | pic_priv_rw_g);
assign wsr_pic_sel[1] = wsr_thread_inst_g[1] & (pic_npriv_rw_g | pic_priv_rw_g);
assign wsr_pic_sel[2] = wsr_thread_inst_g[2] & (pic_npriv_rw_g | pic_priv_rw_g);
assign wsr_pic_sel[3] = wsr_thread_inst_g[3] & (pic_npriv_rw_g | pic_priv_rw_g);

assign update_picl_sel[0] = (local_rst | pic_update_ctl[0] | wsr_pic_sel[0]); 
assign update_picl_sel[1] = (local_rst | pic_update_ctl[1] | wsr_pic_sel[1]); 
assign update_picl_sel[2] = (local_rst | pic_update_ctl[2] | wsr_pic_sel[2]); 
assign update_picl_sel[3] = (local_rst | pic_update_ctl[3] | wsr_pic_sel[3]); 

// constructing the selects to choose to update the pich wrap - added for bug 2588 
assign update_picl_wrap_en[0] = 
           update_picl_sel[0] | wsr_pcr_sel[0]; 
assign update_picl_wrap_en[1] = 
           update_picl_sel[1] | wsr_pcr_sel[1]; 
assign update_picl_wrap_en[2] = 
           update_picl_sel[2] | wsr_pcr_sel[2]; 
assign update_picl_wrap_en[3] = 
           update_picl_sel[3] | wsr_pcr_sel[3]; 
//
// extracting the wsr_data information to update the picls
//
assign picl_wsr_data = {1'b0, tlu_wsr_data_w[31:0]}; 
//
// selecting the data for picl update
// thread 0 
mux3ds #(33) mux_update_picl0_data (
       .in0  ({33{1'b0}}),
       .in1  (picl_wsr_data[33-1:0]),
       .in2  (picl_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[0] & ~local_rst),
       .sel2 (~(wsr_pic_sel[0] | local_rst)),
       .dout (update_picl0_data[33-1:0])
);

dffe_s #(33) dff_picl_cnt0 (
    .din (update_picl0_data[33-1:0]),
    .q   (picl_cnt0[33-1:0]),
    .clk (clk),
    .en  (update_picl_sel[0]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 1
mux3ds #(33) mux_update_picl1_data (
       .in0  ({33{1'b0}}),
       .in1  (picl_wsr_data[33-1:0]),
       .in2  (picl_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[1] & ~local_rst),
       .sel2 (~(wsr_pic_sel[1] | local_rst)),
       .dout (update_picl1_data[33-1:0])
);

dffe_s #(33) dff_picl_cnt1 (
    .din (update_picl1_data[33-1:0]),
    .q   (picl_cnt1[33-1:0]),
    .clk (clk),
    .en  (update_picl_sel[1]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 2
mux3ds #(33) mux_update_picl2_data (
       .in0  ({33{1'b0}}),
       .in1  (picl_wsr_data[33-1:0]),
       .in2  (picl_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[2] & ~local_rst),
       .sel2 (~(wsr_pic_sel[2] | local_rst)),
       .dout (update_picl2_data[33-1:0])
);

dffe_s #(33) dff_picl_cnt2 (
    .din (update_picl2_data[33-1:0]),
    .q   (picl_cnt2[33-1:0]),
    .clk (clk),
    .en  (update_picl_sel[2]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 3
mux3ds #(33) mux_update_picl3_data (
       .in0  ({33{1'b0}}),
       .in1  (picl_wsr_data[33-1:0]),
       .in2  (picl_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[3] & ~local_rst),
       .sel2 (~(wsr_pic_sel[3] | local_rst)),
       .dout (update_picl3_data[33-1:0])
);

dffe_s #(33) dff_picl_cnt3 (
    .din (update_picl3_data[33-1:0]),
    .q   (picl_cnt3[33-1:0]),
    .clk (clk),
    .en  (update_picl_sel[3]),
    .se  (se),       
    .si  (),          
    .so  ()
);

//==================================================================
// update the pichs - could be sperated into a dp block if needed 
//==================================================================
//
dffr_s #(4) dffr_inst_vld_w2 (
    .din (tlu_thread_inst_vld_g[4-1:0]),
    .q   (inst_vld_w2[4-1:0]),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// added for bug 4395
dffr_s dffr_tcc_inst_w2 (
    .din (tlu_tcc_inst_w),
    .q   (tcc_inst_w2),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// modified for bug 4478
assign incr_pich[0] = pic_cnt_en_w2[0] & inst_vld_w2[0] & 
                      (~tlu_full_flush_pipe_w2 | tcc_inst_w2); 
assign incr_pich[1] = pic_cnt_en_w2[1] & inst_vld_w2[1] & 
                      (~tlu_full_flush_pipe_w2 | tcc_inst_w2);
assign incr_pich[2] = pic_cnt_en_w2[2] & inst_vld_w2[2] & 
                      (~tlu_full_flush_pipe_w2 | tcc_inst_w2);
assign incr_pich[3] = pic_cnt_en_w2[3] & inst_vld_w2[3] & 
                      (~tlu_full_flush_pipe_w2 | tcc_inst_w2);

assign pich_mux_sel[0] = pic_cnt_en_w2[0] & inst_vld_w2[0]; 
assign pich_mux_sel[1] = pic_cnt_en_w2[1] & inst_vld_w2[1];
assign pich_mux_sel[2] = pic_cnt_en_w2[2] & inst_vld_w2[2];
assign pich_mux_sel[3] = pic_cnt_en_w2[3] & inst_vld_w2[3];

// added for to make inst count overflow trap precise.
// added for bug 4314
assign pich_wrap_flg[0] = 
           (pich_cnt_wrap[0] ^ pich_cnt0[33-1]) & pic_cnt_en_w2[0]; 
assign pich_wrap_flg[1] = 
           (pich_cnt_wrap[1] ^ pich_cnt1[33-1]) & pic_cnt_en_w2[1];
assign pich_wrap_flg[2] = 
           (pich_cnt_wrap[2] ^ pich_cnt2[33-1]) & pic_cnt_en_w2[2];
assign pich_wrap_flg[3] = 
           (pich_cnt_wrap[3] ^ pich_cnt3[33-1]) & pic_cnt_en_w2[3];

// modified for bug 4270
// pic experiment
assign pich_fourbelow_din[0] = 
           (&pich_cnt0[33-2:2]) & pic_cnt_en_w2[0];
assign pich_fourbelow_din[1] = 
           (&pich_cnt1[33-2:2]) & pic_cnt_en_w2[1];
assign pich_fourbelow_din[2] = 
           (&pich_cnt2[33-2:2]) & pic_cnt_en_w2[2];
assign pich_fourbelow_din[3] = 
           (&pich_cnt3[33-2:2]) & pic_cnt_en_w2[3];
//
dff_s #(4) dff_pich_fourbelow_flg (
    .din (pich_fourbelow_din[4-1:0]),
    .q   (pich_fourbelow_flg[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// modified for bug 4270
assign pich_onebelow_flg[0] = 
       (pich_fourbelow_flg[0] & pich_cnt0[1] & pich_cnt0[0]) & pic_cnt_en_w2[0]; 
assign pich_onebelow_flg[1] = 
       (pich_fourbelow_flg[1] & pich_cnt1[1] & pich_cnt1[0]) & pic_cnt_en_w2[1]; 
assign pich_onebelow_flg[2] = 
       (pich_fourbelow_flg[2] & pich_cnt2[1] & pich_cnt2[0]) & pic_cnt_en_w2[2]; 
assign pich_onebelow_flg[3] = 
       (pich_fourbelow_flg[3] & pich_cnt3[1] & pich_cnt3[0]) & pic_cnt_en_w2[3]; 
// 
assign pich_twobelow_flg[0] = 
       (pich_fourbelow_flg[0] & pich_cnt0[1] & ~pich_cnt0[0]) & pic_cnt_en_w2[0]; 
assign pich_twobelow_flg[1] = 
       (pich_fourbelow_flg[1] & pich_cnt1[1] & ~pich_cnt1[0]) & pic_cnt_en_w2[1]; 
assign pich_twobelow_flg[2] = 
       (pich_fourbelow_flg[2] & pich_cnt2[1] & ~pich_cnt2[0]) & pic_cnt_en_w2[2]; 
assign pich_twobelow_flg[3] = 
       (pich_fourbelow_flg[3] & pich_cnt3[1] & ~pich_cnt3[0]) & pic_cnt_en_w2[3]; 
//
/*
assign pich_threebelow_flg[0] = 
       (pich_fourbelow_flg[0] & ~pich_cnt0[1] & pich_cnt0[0]) & pic_cnt_en_w2[0]; 
assign pich_threebelow_flg[1] = 
       (pich_fourbelow_flg[1] & ~pich_cnt1[1] & pich_cnt1[0]) & pic_cnt_en_w2[1]; 
assign pich_threebelow_flg[2] = 
       (pich_fourbelow_flg[2] & ~pich_cnt2[1] & pich_cnt2[0]) & pic_cnt_en_w2[2]; 
assign pich_threebelow_flg[3] = 
       (pich_fourbelow_flg[3] & ~pich_cnt3[1] & pich_cnt3[0]) & pic_cnt_en_w2[3]; 
*/
//
// added for bug 4836 
assign pic_twobelow_e[0] = 
       pich_mux_sel[0]? (pich_fourbelow_flg[0] & ~pich_cnt0[1] & pich_cnt0[0]):
       (pich_fourbelow_flg[0] & pich_cnt0[1] & ~pich_cnt0[0]);
assign pic_twobelow_e[1] = 
       pich_mux_sel[1]? (pich_fourbelow_flg[1] & ~pich_cnt1[1] & pich_cnt1[0]):
       (pich_fourbelow_flg[1] & pich_cnt1[1] & ~pich_cnt1[0]);
assign pic_twobelow_e[2] = 
       pich_mux_sel[2]? (pich_fourbelow_flg[2] & ~pich_cnt2[1] & pich_cnt2[0]):
       (pich_fourbelow_flg[2] & pich_cnt2[1] & ~pich_cnt2[0]);
assign pic_twobelow_e[3] = 
       pich_mux_sel[3]? (pich_fourbelow_flg[3] & ~pich_cnt3[1] & pich_cnt3[0]):
       (pich_fourbelow_flg[3] & pich_cnt3[1] & ~pich_cnt3[0]);

assign tlu_pic_twobelow_e = 
           (thread_rsel_e[0]) ? pic_twobelow_e[0]:
           (thread_rsel_e[1]) ? pic_twobelow_e[1]:
           (thread_rsel_e[2]) ? pic_twobelow_e[2]:
            pic_twobelow_e[3];
//
assign pic_onebelow_e[0] = 
       pich_mux_sel[0]? (pich_fourbelow_flg[0] & pich_cnt0[1] & ~pich_cnt0[0]):
       (pich_fourbelow_flg[0] & pich_cnt0[1] & pich_cnt0[0]);
assign pic_onebelow_e[1] = 
       pich_mux_sel[1]? (pich_fourbelow_flg[1] & pich_cnt1[1] & ~pich_cnt1[0]):
       (pich_fourbelow_flg[1] & pich_cnt1[1] & pich_cnt1[0]);
assign pic_onebelow_e[2] = 
       pich_mux_sel[2]? (pich_fourbelow_flg[2] & pich_cnt2[1] & ~pich_cnt2[0]):
       (pich_fourbelow_flg[2] & pich_cnt2[1] & pich_cnt2[0]);
assign pic_onebelow_e[3] = 
       pich_mux_sel[3]? (pich_fourbelow_flg[3] & pich_cnt3[1] & ~pich_cnt3[0]):
       (pich_fourbelow_flg[3] & pich_cnt3[1] & pich_cnt3[0]);

assign tlu_pic_onebelow_e = 
           (thread_rsel_e[0]) ? pic_onebelow_e[0]:
           (thread_rsel_e[1]) ? pic_onebelow_e[1]:
           (thread_rsel_e[2]) ? pic_onebelow_e[2]:
            pic_onebelow_e[3];
//
assign pic_wrap_e[0] = 
       pich_mux_sel[0]? (pich_fourbelow_flg[0] & pich_cnt0[1] & pich_cnt0[0]):
       (pich_cnt_wrap[0] ^ pich_cnt0[33-1]);
assign pic_wrap_e[1] = 
       pich_mux_sel[1]? (pich_fourbelow_flg[1] & pich_cnt1[1] & pich_cnt1[0]):
       (pich_cnt_wrap[1] ^ pich_cnt1[33-1]);
assign pic_wrap_e[2] = 
       pich_mux_sel[2]? (pich_fourbelow_flg[2] & pich_cnt2[1] & pich_cnt2[0]):
       (pich_cnt_wrap[2] ^ pich_cnt2[33-1]);
assign pic_wrap_e[3] = 
       pich_mux_sel[3]? (pich_fourbelow_flg[3] & pich_cnt3[1] & pich_cnt3[0]):
       (pich_cnt_wrap[3] ^ pich_cnt3[33-1]);

assign tlu_pic_wrap_e = 
           (thread_rsel_e[0]) ? pic_wrap_e[0]:
           (thread_rsel_e[1]) ? pic_wrap_e[1]:
           (thread_rsel_e[2]) ? pic_wrap_e[2]:
            pic_wrap_e[3];
//
//
// modified for bug 5436: Niagara 2.0
assign tlu_pcr_ut[0] = pcr0[2];
assign tlu_pcr_ut[1] = pcr1[2];
assign tlu_pcr_ut[2] = pcr2[2];
assign tlu_pcr_ut[3] = pcr3[2];
//
assign tlu_pcr_st[0] = pcr0[1];
assign tlu_pcr_st[1] = pcr1[1];
assign tlu_pcr_st[2] = pcr2[1];
assign tlu_pcr_st[3] = pcr3[1];

assign tlu_pcr_ut_e = 
           (thread_rsel_e[0]) ? pcr0[2]: 
           (thread_rsel_e[1]) ? pcr1[2]: 
           (thread_rsel_e[2]) ? pcr2[2]:
            pcr3[2]; 

assign tlu_pcr_st_e = 
           (thread_rsel_e[0]) ? pcr0[1]:
           (thread_rsel_e[1]) ? pcr1[1]:
           (thread_rsel_e[2]) ? pcr2[1]:
            pcr3[1];

       
// reporting over-flow trap - needed to be precise, therefore
// bypassing tlb-miss traps 
// 
// selelcting the thread for incrementing for pich
// added for bug2332
//
// one-hot mux change
assign pich_cnt_din[33-1:0] =
       (pich_mux_sel[1])? pich_cnt1[33-1:0]:
       (pich_mux_sel[2])? pich_cnt2[33-1:0]:
       (pich_mux_sel[3])? pich_cnt3[33-1:0]:
       pich_cnt0[33-1:0];
/*
assign incr_pich_onehot = ~(|incr_pich[3:1]) | rst_tri_en;
mux4ds #(`PIB_PIC_CNT_WIDTH) mux_pich_cnt_din (
       .in0  (pich_cnt0[`PIB_PIC_CNT_WIDTH-1:0]),
       .in1  (pich_cnt1[`PIB_PIC_CNT_WIDTH-1:0]),
       .in2  (pich_cnt2[`PIB_PIC_CNT_WIDTH-1:0]),
       .in3  (pich_cnt3[`PIB_PIC_CNT_WIDTH-1:0]),
       .sel0 (incr_pich_onehot),
       .sel1 (incr_pich[1] & ~rst_tri_en),
       .sel2 (incr_pich[2] & ~rst_tri_en),
       .sel3 (incr_pich[3] & ~rst_tri_en),
       .dout (pich_cnt_din[`PIB_PIC_CNT_WIDTH-1:0])
);
*/
//
// pich incrementor  - shared between four threads
//
tlu_addern_32 #(33,1) pich_adder (
    .din  (pich_cnt_din[33-1:0]),
    .incr (1'b1),
    .sum  (pich_cnt_sum[33-1:0])
) ;
//
// extracting the wsr_data information to update the picls
//
assign pich_wsr_data = {1'b0, tlu_wsr_data_w[63:32]}; 

// constructing the selects to choose to update the pich 
assign update_pich_sel[0] = (local_rst | incr_pich[0] | wsr_pic_sel[0]); 
assign update_pich_sel[1] = (local_rst | incr_pich[1] | wsr_pic_sel[1]); 
assign update_pich_sel[2] = (local_rst | incr_pich[2] | wsr_pic_sel[2]); 
assign update_pich_sel[3] = (local_rst | incr_pich[3] | wsr_pic_sel[3]); 

// constructing the selects to choose to update the pich wrap 
assign update_pich_wrap_en[0] = 
           update_pich_sel[0] | wsr_pcr_sel[0]; 
assign update_pich_wrap_en[1] = 
           update_pich_sel[1] | wsr_pcr_sel[1]; 
assign update_pich_wrap_en[2] = 
           update_pich_sel[2] | wsr_pcr_sel[2]; 
assign update_pich_wrap_en[3] = 
           update_pich_sel[3] | wsr_pcr_sel[3]; 
//
// selecting the data for pich update
// thread 0 
mux3ds #(33) mux_update_pich0_data (
       .in0  ({33{1'b0}}),
       .in1  (pich_wsr_data[33-1:0]),
       .in2  (pich_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[0] & ~local_rst),
       .sel2 (~(wsr_pic_sel[0] | local_rst)),
       .dout (update_pich0_data[33-1:0])
);

dffe_s #(33) dff_pich_cnt0 (
    .din (update_pich0_data[33-1:0]),
    .q   (pich_cnt0[33-1:0]),
    .clk (clk),
    .en  (update_pich_sel[0]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 1 
mux3ds #(33) mux_update_pich1_data (
       .in0  ({33{1'b0}}),
       .in1  (pich_wsr_data[33-1:0]),
       .in2  (pich_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[1] & ~local_rst),
       .sel2 (~(wsr_pic_sel[1] | local_rst)), 
       .dout (update_pich1_data[33-1:0])
);

dffe_s #(33) dff_pich_cnt1 (
    .din (update_pich1_data[33-1:0]),
    .q   (pich_cnt1[33-1:0]),
    .clk (clk),
    .en  (update_pich_sel[1]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 2 
mux3ds #(33) mux_update_pich2_data (
       .in0  ({33{1'b0}}),
       .in1  (pich_wsr_data[33-1:0]),
       .in2  (pich_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[2] & ~local_rst),
       .sel2 (~(wsr_pic_sel[2] | local_rst)),
       .dout (update_pich2_data[33-1:0])
);

dffe_s #(33) dff_pich_cnt2 (
    .din (update_pich2_data[33-1:0]),
    .q   (pich_cnt2[33-1:0]),
    .clk (clk),
    .en  (update_pich_sel[2]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 3
mux3ds #(33) mux_update_pich3_data (
       .in0  ({33{1'b0}}),
       .in1  (pich_wsr_data[33-1:0]),
       .in2  (pich_cnt_sum[33-1:0]),
       .sel0 (local_rst),
       .sel1 (wsr_pic_sel[3] & ~local_rst),
       .sel2 (~(wsr_pic_sel[3] | local_rst)),
       .dout (update_pich3_data[33-1:0])
);

dffe_s #(33) dff_pich_cnt3 (
    .din (update_pich3_data[33-1:0]),
    .q   (pich_cnt3[33-1:0]),
    .clk (clk),
    .en  (update_pich_sel[3]),
    .se  (se),       
    .si  (),          
    .so  ()
);

//==========================
// reading the PCRs and PICs 
//==========================
// decoding the thread information for rsr instruction from IFU
// modified due to timing
/*
assign thread_rsel_e[0] = ~(|ifu_tlu_thrid_e[1:0]);
assign thread_rsel_e[1] = ~ifu_tlu_thrid_e[1] &  ifu_tlu_thrid_e[0];
assign thread_rsel_e[2] =  ifu_tlu_thrid_e[1] & ~ifu_tlu_thrid_e[0];
assign thread_rsel_e[3] =  (&ifu_tlu_thrid_e[1:0]);
*/
assign thread_rsel_d[0] = ~(|ifu_tlu_thrid_d[1:0]);
assign thread_rsel_d[1] = ~ifu_tlu_thrid_d[1] &  ifu_tlu_thrid_d[0];
assign thread_rsel_d[2] =  ifu_tlu_thrid_d[1] & ~ifu_tlu_thrid_d[0];
// assign thread_rsel_d[3] =  (&ifu_tlu_thrid_d[1:0]);
//
dff_s #(4-1) dff_thread_rsel_e (
    .din (thread_rsel_d[4-2:0]),
    .q   (thread_rsel_e[4-2:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// selecting the correct pic for rdpr
// modified to avoid rte failure
assign pic_rdata_e[64-1:0] = 
       (thread_rsel_e[0])?
       {pich_cnt0[33-2:0], picl_cnt0[33-2:0]}:
       (thread_rsel_e[1])?
       {pich_cnt1[33-2:0], picl_cnt1[33-2:0]}:
       (thread_rsel_e[2])?
       {pich_cnt2[33-2:0], picl_cnt2[33-2:0]}:
       {pich_cnt3[33-2:0], picl_cnt3[33-2:0]};
/*
mux4ds #(`TLU_ASR_DATA_WIDTH) mux_pic_rdata (
        .in0    ({pich_cnt0[`PIB_PIC_CNT_WIDTH-2:0], picl_cnt0[`PIB_PIC_CNT_WIDTH-2:0]}),
        .in1    ({pich_cnt1[`PIB_PIC_CNT_WIDTH-2:0], picl_cnt1[`PIB_PIC_CNT_WIDTH-2:0]}),
        .in2    ({pich_cnt2[`PIB_PIC_CNT_WIDTH-2:0], picl_cnt2[`PIB_PIC_CNT_WIDTH-2:0]}),
        .in3    ({pich_cnt3[`PIB_PIC_CNT_WIDTH-2:0], picl_cnt3[`PIB_PIC_CNT_WIDTH-2:0]}),
        .sel0   (thread_rsel_e[0]),
        .sel1   (thread_rsel_e[1]),
        .sel2   (thread_rsel_e[2]),
        .sel3   (thread_rsel_e[3]),
        .dout   (pic_rdata_e[`TLU_ASR_DATA_WIDTH-1:0])
);

// selecting the correct pcr for rdpr
// modified for bug 2391
mux4ds #(`TLU_ASR_DATA_WIDTH) mux_pcr_rdata (
        .in0    ({58'b0,pcr0[`PIB_PCR_WIDTH-1:0]}), 
        .in1    ({58'b0,pcr1[`PIB_PCR_WIDTH-1:0]}),
        .in2    ({58'b0,pcr2[`PIB_PCR_WIDTH-1:0]}),
        .in3    ({58'b0,pcr3[`PIB_PCR_WIDTH-1:0]}),
        .sel0   (thread_rsel_e[0]),
        .sel1   (thread_rsel_e[1]),
        .sel2   (thread_rsel_e[2]),
        .sel3   (thread_rsel_e[3]),
        .dout   (pcr_rdata_e[`TLU_ASR_DATA_WIDTH-1:0])
);

mux4ds #(`PIB_PCR_WIDTH) mux_pcr_rdata (
        .in0    (pcr0[`PIB_PCR_WIDTH-1:0]), 
        .in1    (pcr1[`PIB_PCR_WIDTH-1:0]),
        .in2    (pcr2[`PIB_PCR_WIDTH-1:0]),
        .in3    (pcr3[`PIB_PCR_WIDTH-1:0]),
        .sel0   (thread_rsel_e[0]),
        .sel1   (thread_rsel_e[1]),
        .sel2   (thread_rsel_e[2]),
        .sel3   (thread_rsel_e[3]),
        .dout   (pcr_reg_rdata_e[`PIB_PCR_WIDTH-1:0])
);
*/

assign pcr_reg_rdata_e[8-1:0] =
       (thread_rsel_e[0])? pcr0[8-1:0]:
       (thread_rsel_e[1])? pcr1[8-1:0]:
       (thread_rsel_e[2])? pcr2[8-1:0]:
       pcr3[8-1:0];

assign pcr_rdata_e[64-1:0] =
           {54'b0, // rsvd bits 
            pcr_reg_rdata_e[7:6], 
            1'b0,  // rsvd bit
            pcr_reg_rdata_e[5:3], 
            1'b0,  // rsvd bit
            pcr_reg_rdata_e[2:0]}; 

// constructing the mux select for the output mux for rsr inst
assign rsr_data_sel_e[0] = pcr_rw_e;
assign rsr_data_sel_e[1] = ~pcr_rw_e; 

// modified due to timing 
// assign rsr_data_sel_e[1] = ~pcr_rw_e & (pic_npriv_rw_e | pic_priv_rw_e);
// assign rsr_data_sel_e[2] = ~(|rsr_data_sel_e[1:0]);
/*
mux3ds #(`TLU_ASR_DATA_WIDTH) mux_exu_rsr_data_e (
	.in0(pcr_rdata_e[`TLU_ASR_DATA_WIDTH-1:0]),  
	.in1(pic_rdata_e[`TLU_ASR_DATA_WIDTH-1:0]),
	.in2(tlu_pib_rsr_data_e[`TLU_ASR_DATA_WIDTH-1:0]),
	.sel0(rsr_data_sel_e[0]),
	.sel1(rsr_data_sel_e[1]),
	.sel2(rsr_data_sel_e[2]),
	.dout(tlu_exu_rsr_data_e[`TLU_ASR_DATA_WIDTH-1:0])
);
*/
mux2ds #(64) mux_tlu_pib_rsr_data_e (
	.in0(pcr_rdata_e[64-1:0]),  
	.in1(pic_rdata_e[64-1:0]),
	.sel0(rsr_data_sel_e[0]),
	.sel1(rsr_data_sel_e[1]),
	.dout(tlu_pib_rsr_data_e[64-1:0])
);
//==========================
// over_flow trap 
//==========================
// staged the wrap bit for comparison
//
// thread 0 - modified for bug 3937
mux2ds mux_picl_cnt_wrap_datain_0 (
	.in0(picl_cnt0[33-1] ^ pcr_wdata_in[6]),
	.in1(picl_cnt0[33-1]),
	.sel0(wsr_pcr_sel[0]),
	.sel1(~wsr_pcr_sel[0]),
	.dout(picl_cnt_wrap_datain[0])
);

mux2ds mux_pich_cnt_wrap_datain_0 (
	.in0(pich_cnt0[33-1] ^ pcr_wdata_in[7]),
	.in1(pich_cnt0[33-1]),
	.sel0(wsr_pcr_sel[0]),
	.sel1(~wsr_pcr_sel[0]),
	.dout(pich_cnt_wrap_datain[0])
);
/*
assign picl_cnt_wrap_datain[0] = 
           (picl_cnt0[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CL_OVF]);

assign pich_cnt_wrap_datain[0] = 
           (pich_cnt0[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CH_OVF]);
*/

dffre_s dffre_picl0_wrap (
    .din (picl_cnt_wrap_datain[0]),
    .q   (picl_cnt_wrap[0]),
    .clk (clk),
    .en  (update_picl_wrap_en[0]),
    .rst (local_rst | wsr_pic_sel[0]),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_pich0_wrap (
    .din (pich_cnt_wrap_datain[0]),
    .q   (pich_cnt_wrap[0]),
    .clk (clk),
    .en  (update_pich_wrap_en[0]),
    .rst (local_rst | wsr_pic_sel[0]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 1 - modified for bug 3937
mux2ds mux_picl_cnt_wrap_datain_1 (
	.in0(picl_cnt1[33-1] ^ pcr_wdata_in[6]),
	.in1(picl_cnt1[33-1]),
	.sel0(wsr_pcr_sel[1]),
	.sel1(~wsr_pcr_sel[1]),
	.dout(picl_cnt_wrap_datain[1])
);

mux2ds mux_pich_cnt_wrap_datain_1 (
	.in0(pich_cnt1[33-1] ^ pcr_wdata_in[7]),
	.in1(pich_cnt1[33-1]),
	.sel0(wsr_pcr_sel[1]),
	.sel1(~wsr_pcr_sel[1]),
	.dout(pich_cnt_wrap_datain[1])
);
/*
assign picl_cnt_wrap_datain[1] = 
           (picl_cnt1[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CL_OVF]); 

assign pich_cnt_wrap_datain[1] = 
           (pich_cnt1[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CH_OVF]); 
*/

dffre_s dffre_picl1_wrap (
    .din (picl_cnt_wrap_datain[1]),
    .q   (picl_cnt_wrap[1]),
    .clk (clk),
    .en  (update_picl_wrap_en[1]),
    .rst (local_rst | wsr_pic_sel[1]),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_pich1_wrap (
    .din (pich_cnt_wrap_datain[1]),
    .q   (pich_cnt_wrap[1]),
    .clk (clk),
    .en  (update_pich_wrap_en[1]),
    .rst (local_rst | wsr_pic_sel[1]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 2 - modified for bug 3937
mux2ds mux_picl_cnt_wrap_datain_2 (
	.in0(picl_cnt2[33-1] ^ pcr_wdata_in[6]),
	.in1(picl_cnt2[33-1]),
	.sel0(wsr_pcr_sel[2]),
	.sel1(~wsr_pcr_sel[2]),
	.dout(picl_cnt_wrap_datain[2])
);

mux2ds mux_pich_cnt_wrap_datain_2 (
	.in0(pich_cnt2[33-1] ^ pcr_wdata_in[7]),
	.in1(pich_cnt2[33-1]),
	.sel0(wsr_pcr_sel[2]),
	.sel1(~wsr_pcr_sel[2]),
	.dout(pich_cnt_wrap_datain[2])
);
/*
assign picl_cnt_wrap_datain[2] = 
           (picl_cnt2[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CL_OVF]); 

assign pich_cnt_wrap_datain[2] = 
           (pich_cnt2[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CH_OVF]); 
*/

dffre_s dffre_picl2_wrap (
    .din (picl_cnt_wrap_datain[2]),
    .q   (picl_cnt_wrap[2]),
    .clk (clk),
    .en  (update_picl_wrap_en[2]),
    .rst (local_rst | wsr_pic_sel[2]),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_pich2_wrap (
    .din (pich_cnt_wrap_datain[2]),
    .q   (pich_cnt_wrap[2]),
    .clk (clk),
    .en  (update_pich_wrap_en[2]),
    .rst (local_rst | wsr_pic_sel[2]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// thread 3 - modified for bug 3937
mux2ds mux_picl_cnt_wrap_datain_3 (
	.in0(picl_cnt3[33-1] ^ pcr_wdata_in[6]),
	.in1(picl_cnt3[33-1]),
	.sel0(wsr_pcr_sel[3]),
	.sel1(~wsr_pcr_sel[3]),
	.dout(picl_cnt_wrap_datain[3])
);

mux2ds mux_pich_cnt_wrap_datain_3 (
	.in0(pich_cnt3[33-1] ^ pcr_wdata_in[7]),
	.in1(pich_cnt3[33-1]),
	.sel0(wsr_pcr_sel[3]),
	.sel1(~wsr_pcr_sel[3]),
	.dout(pich_cnt_wrap_datain[3])
);
/*
assign picl_cnt_wrap_datain[3] = 
           (picl_cnt3[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CL_OVF]);

assign pich_cnt_wrap_datain[3] = 
           (pich_cnt3[`PIB_PIC_CNT_WIDTH-1] ^ pcr_wdata_in[`PIB_PCR_CH_OVF]); 
*/

dffre_s dffre_picl3_wrap (
    .din (picl_cnt_wrap_datain[3]),
    .q   (picl_cnt_wrap[3]),
    .clk (clk),
    .en  (update_picl_wrap_en[3]),
    .rst (local_rst | wsr_pic_sel[3]),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_pich3_wrap (
    .din (pich_cnt_wrap_datain[3]),
    .q   (pich_cnt_wrap[3]),
    .clk (clk),
    .en  (update_pich_wrap_en[3]),
    .rst (local_rst | wsr_pic_sel[3]),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// generating the over-flow (0->1) to be set in sftint[15]
assign pib_picl_wrap[0] = 
         ((picl_cnt_wrap[0] ^ picl_cnt0[33-1]) & incr_evq[0]);  
assign pib_picl_wrap[1] = 
         ((picl_cnt_wrap[1] ^ picl_cnt1[33-1]) & incr_evq[1]);  
assign pib_picl_wrap[2] = 
         ((picl_cnt_wrap[2] ^ picl_cnt2[33-1]) & incr_evq[2]);  
assign pib_picl_wrap[3] = 
         ((picl_cnt_wrap[3] ^ picl_cnt3[33-1]) & incr_evq[3]);  
//
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_prencoder16.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Datapath Priority Encoder 16b
//				- 15b multihot vector as input
//				- 15b 1-hit vector as output
//				- Can use some std length such as 16b
//				- msb is given highest priority
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                        // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////

module	tlu_prencoder16 (din, dout);

input	[14:0]	din  ;
output	[3:0]	dout ;

wire	[14:0]	onehot ;

assign	onehot[14] = din[14] ;
assign	onehot[13] = din[13] & ~din[14] ;
assign	onehot[12] = din[12] & ~(|din[14:13]) ;
assign	onehot[11] = din[11] & ~(|din[14:12]) ;
assign	onehot[10] = din[10] & ~(|din[14:11]) ;
assign	onehot[9]  = din[9]  & ~(|din[14:10]) ;
assign	onehot[8]  = din[8]  & ~(|din[14:9]) ;
assign	onehot[7]  = din[7]  & ~(|din[14:8]) ;
assign	onehot[6]  = din[6]  & ~(|din[14:7]) ;
assign	onehot[5]  = din[5]  & ~(|din[14:6]) ;
assign	onehot[4]  = din[4]  & ~(|din[14:5]) ;
assign	onehot[3]  = din[3]  & ~(|din[14:4]) ;
assign	onehot[2]  = din[2]  & ~(|din[14:3]) ;
assign	onehot[1]  = din[1]  & ~(|din[14:2]) ;
assign	onehot[0]  = din[0]  & ~(|din[14:1]) ;
//assign	onehot[0]  = din[0]  & ~(|din[15:1]) ;

assign	dout[3]  =  |onehot[14:7] ;
assign	dout[2]  = (|onehot[6:3]) | (|onehot[14:11]) ;
assign	dout[1]  = (|onehot[2:1]) | (|onehot[6:5]) |
		   (|onehot[10:9]) | (|onehot[14:13]) ;
assign	dout[0]  =  onehot[0] | onehot[2] | onehot[4] | onehot[6] |
		    onehot[8] | onehot[10] | onehot[12] | onehot[14] ;

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_rrobin_picker.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//      Description:    Round-Robin Picker for 4 eventss.
//			Differs from lsu'v rrobin picker by the
//			fact that there is no default 1-hot event.
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the
                                        // time scale definition

module tlu_rrobin_picker (/*AUTOARG*/
   // Outputs
   pick_one_hot, 
   // Inputs
   events, tlu_rst_l, clk
   );

input 	[3:0]	events ;		// multi-hot; events that could be chosen
// this siganl was modified to abide to the Niagara reset methodology
input		tlu_rst_l ;			// reset - active low
input		clk ;

output	[3:0]	pick_one_hot ;  // one-hot; events that must be chosen
//
// this signal was added to abide to the Niagara reset methodology
wire	tlu_rst ;	

// This section was modified to abide to the Niagara synthesis methodology
//
// reg	[3:0]	pick_status ;	
wire	pick_status_reset ;	
wire	[3:0]	pick_status_in ;	
wire	[3:0]	pick_status ;	

wire	events_unpicked ;
wire	[3:0]	pe_mask ;

//
// this signal was added to abide to the Niagara reset methodology
assign tlu_rst = ~tlu_rst_l;

assign	events_unpicked = |(events[3:0] & ~pick_status[3:0]) ;
			// term replicated.

// priority encode mask
assign	pe_mask[3:0] =
		events_unpicked ? 
		(events[3:0] & ~pick_status[3:0]) : 	// choose from eventss that have not picked.
		events[3:0] ;				// else all eventss on equal terms

assign	pick_one_hot[0] = 
		pe_mask[0] ;
		//pe_mask[0] | ~(|pe_mask[3:0]);		// none requesting then 0 is forced hot
assign	pick_one_hot[1] = 
		pe_mask[1] & ~pe_mask[0] ;
assign	pick_one_hot[2] = 
		pe_mask[2] & ~(|pe_mask[1:0]) ;
assign	pick_one_hot[3] = 
		pe_mask[3] & ~(|pe_mask[2:0]) ;

// This section was modified to abide to the Niagara synthesis methodology
//
// Define Pick Status
//always	@ (posedge clk)
//	begin
//		if ((&(pick_status[3:0] | pick_one_hot[3:0])) | tlu_rst) 
//			pick_status[3:0] <= 4'b0000 ;	// clear pick_status
//		else
//			pick_status[3:0] <= pick_status[3:0] | pick_one_hot[3:0] ;
//					// term replicated
//	end

assign pick_status_reset = (&(pick_status[3:0] | pick_one_hot[3:0])) | tlu_rst;
assign pick_status_in    = pick_status[3:0] | pick_one_hot[3:0]; 

dffr_s #(4)  dffre_pick_status  (
        .din (pick_status_in[3:0]), .q (pick_status[3:0]),
        .rst (pick_status_reset), .clk (clk),
        .se  (1'b0),  .si  (),       .so ()
        );

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_tcl.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////
/*
//	Description:	Trap Control Logic
*/

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


module tlu_tcl (/*AUTOARG*/
   // Outputs
   tlu_ifu_trappc_vld_w1, tlu_ifu_trapnpc_vld_w1, tlu_ifu_trap_tid_w1, 
   tlu_trap_hpstate_enb, tsa_wr_tpl, tsa_rd_tid, tsa_rd_tpl, tsa_rd_en, 
   tsa_wr_tid, tsa_wr_vld, tsa_rd_vld_e, tlu_lsu_tl_zero, tlu_restore_pc_sel_w1, 
   tlu_early_flush_pipe_w, tlu_early_flush_pipe2_w, tlu_exu_early_flush_pipe_w, 
   tlu_agp_tid_w2, tsa_tstate_en, tsa_ttype_en, tlu_tl_gt_0_w2, 
   tlu_exu_agp_tid, tlu_true_pc_sel_w, // tlu_retry_inst_m, tlu_done_inst_m, 
   tlu_tick_en_l, tlu_tickcmp_en_l, tlu_stickcmp_en_l, tlu_local_flush_w, 
   tlu_tba_en_l, tlu_thrd_wsel_w2, tlu_thread_wsel_g, tlu_final_ttype_w2,
   tlu_thread_inst_vld_g, tlu_update_pc_l_w, tlu_htickcmp_en_l,
   tsa_pc_en, tsa_npc_en, tlu_hyperv_rdpr_sel, tlu_wsr_inst_nq_g,
   tlu_exu_priv_trap_m, tlu_ibrkpt_trap_w2, tlu_full_flush_pipe_w2,  
   tlu_pstate_din_sel0, tlu_pstate_din_sel1, tlu_pstate_din_sel2, 
   tlu_pstate_din_sel3, tlu_update_pstate_l_w2, tlu_trp_lvl, 
   tlu_pil, tlu_wr_tsa_inst_w2, tlu_trap_cwp_en, // tlu_lsu_priv_trap_w,
   tlu_exu_cwp_retry_m, tlu_exu_cwpccr_update_m, tlu_lsu_priv_trap_m,
   tlu_lsu_asi_update_m, tlu_lsu_tid_m, tlu_pc_mxsel_w2, // tlu_lsu_asi_m,
   tlu_select_tba_w2, tdp_select_tba_w2, tlu_set_sftint_l_g, 
   tlu_clr_sftint_l_g, tlu_wr_sftint_l_g, tlu_sftint_mx_sel, tlu_itag_acc_sel_g, 
   tlu_sftint_en_l_g, tlu_sftint_penc_sel, tlu_sftint_vld, tlu_int_tid_m, 
   tlu_tickcmp_sel, tlu_incr_tick, immu_sfsr_trp_wr, tlu_select_redmode,
   tlu_isfsr_din_g, // tlu_dsfsr_din_g, tlu_tag_access_ctxt_sel_m, 
   tlu_tick_npt, tlu_thrd_rsel_e, tlu_inst_vld_nq_m, tlu_pic_cnt_en_m,  
   tlu_rdpr_mx1_sel, tlu_rdpr_mx2_sel, tlu_rdpr_mx3_sel, tlu_rdpr_mx4_sel, 
   tlu_rdpr_mx5_sel, tlu_rdpr_mx6_sel, tlu_rdpr_mx7_sel, tlu_lsu_pstate_am,
   tlu_lsu_redmode_rst_d1, lsu_tlu_rsr_data_mod_e, tlu_addr_msk_g, 
   // added for hypervisor support
   tlu_dnrtry0_inst_g, tlu_dnrtry1_inst_g, tlu_dnrtry2_inst_g, tlu_dnrtry3_inst_g,
   tlu_thrd_traps_w2, tlu_tick_ctl_din, tsa_htstate_en, tlu_por_rstint_g,
   tlu_hintp_vld, tlu_rerr_vld, tlu_final_offset_w1, // tlu_ifu_trapnpc_w2, 
   so, tlu_sscan_tcl_data, tlu_rst, // tlu_ifu_trappc_w2, tlu_rst_l, 
   // Inputs
   ifu_tlu_sraddr_d, ifu_tlu_rsr_inst_d, lsu_tlu_early_flush_w, ifu_tlu_pc_oor_e,
   tlu_wsr_data_b63_w, tlu_wsr_data_w, lsu_tlu_ttype_m2, ifu_tlu_flush_fd_w, 
   lsu_tlu_ttype_vld_m2, ifu_tlu_done_inst_d, ifu_tlu_retry_inst_d, ifu_tlu_ttype_m, 
   ifu_tlu_ttype_vld_m, exu_tlu_ttype_m, exu_tlu_ttype_vld_m, exu_tlu_spill, 
   exu_tlu_spill_other, exu_tlu_spill_wtype, exu_tlu_va_oor_m, exu_tlu_spill_tid,
   ifu_tlu_sir_inst_m, ifu_tlu_inst_vld_m, ifu_tlu_thrid_d, tlu_tckctr_in, 
   ifu_tlu_immu_miss_m, exu_tlu_va_oor_jl_ret_m, ifu_tlu_trap_m, lsu_tlu_wsr_inst_e,  
   exu_tlu_cwp_cmplt, exu_tlu_cwp_retry, exu_tlu_cwp_cmplt_tid, exu_tlu_ue_trap_m, 
   ifu_tlu_rstint_m, ifu_tlu_hwint_m, ifu_tlu_swint_m, pich_wrap_flg, tlu_pic_wrap_e, 
   pich_onebelow_flg, pich_twobelow_flg, pib_picl_wrap, pib_pich_wrap, tlu_tcc_inst_w, 
   int_tlu_rstid_m, tlu_int_pstate_ie, tlu_int_redmode, ifu_npc_w, tlu_pcr_ut, 
   tlu_sftint_id, lsu_tlu_async_ttype_vld_g, lsu_tlu_defr_trp_taken_g, tlu_pcr_st,
   lsu_tlu_misalign_addr_ldst_atm_m, exu_tlu_misalign_addr_jmpl_rtn_m, 
   lsu_tlu_async_tid_g, lsu_tlu_priv_action_g, lsu_tlu_async_ttype_g, lsu_tlu_wtchpt_trp_g, 
   ifu_tlu_priv_violtn_m, ifu_lsu_memref_d, tlu_pstate_priv, tlu_isfsr_flt_vld, 
   tlu_pstate_am, ffu_tlu_trap_ieee754, ffu_tlu_trap_other, ffu_tlu_trap_ue,
   ffu_ifu_tid_w2, ffu_tlu_ill_inst_m, ifu_tlu_npc_m,  // ifu_tlu_pc_m, 
   lsu_tlu_rsr_data_e, lsu_tlu_squash_va_oor_m, // tlu_restore_npc_w1,
   spu_tlu_rsrv_illgl_m, // exu_tlu_cwp0, exu_tlu_cwp1, exu_tlu_cwp2, exu_tlu_cwp3, 
   //
   // added for hypervisor support
   tlu_hpstate_priv, tlu_htstate_rw_d, tlu_htstate_rw_g, tlu_cwp_no_change_m, 
   tlu_hscpd_dacc_excpt_m, tlu_htickcmp_rw_e, tlu_gl_rw_m, // tlu_gl_rw_g, 
   tlu_hpstate_enb, tlu_cpu_mondo_cmp, tlu_dev_mondo_cmp,
   tlu_resum_err_cmp, tlu_hintp, tlu_hpstate_tlz, tlu_qtail_dacc_excpt_m, 
   pib_priv_act_trap_m, rclk, arst_l, grst_l, si, se, rst_tri_en, ctu_sscan_tid
   );	

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
input [7-1:0] ifu_tlu_sraddr_d;      // addr of sr(st/pr)
input       ifu_tlu_rsr_inst_d;    // valid rd sr(st/pr)
// input       ifu_tlu_wsr_inst_d;    // valid wr sr(st/pr)
input       lsu_tlu_wsr_inst_e;    // valid wr sr(st/pr)
input   	tlu_wsr_data_b63_w;    // b63 of wsr data
// input   	tlu_wsr_data_b16_w;    // b16 of wsr data
input [3:0] tlu_wsr_data_w;    // pr/st data to irf.
input [8:0]	lsu_tlu_ttype_m2;	// trap type in m2.
input		lsu_tlu_ttype_vld_m2;	// trap is signaled.
// added asynchronize trap to handle correctable dmmu parity errors
input       lsu_tlu_defr_trp_taken_g; // lsu asynchronous trap valid
input       lsu_tlu_async_ttype_vld_g; // lsu asynchronous trap valid
input [6:0] lsu_tlu_async_ttype_g;  // lsu asynchronous trap type 
input [1:0] lsu_tlu_async_tid_g; // asynchronous trap - thread
// Removed unused bits 
// input	[1:0]	lsu_tlu_ttype_tid_m2;	// trapping thread
input		ifu_tlu_done_inst_d;  	// done is valid
input		ifu_tlu_retry_inst_d;  // retry is valid

input [8:0]	ifu_tlu_ttype_m;	// trap type in m2.
input		ifu_tlu_ttype_vld_m;	// trap is signaled.
input		ifu_tlu_trap_m;	    // trap is signaled.
// modified for timing
input	    ifu_tlu_flush_fd_w;	    // instruction flush signal 
// input		ifu_tlu_flush_m;	    // instruction flush signal 
input		lsu_tlu_early_flush_w;	// early flush with tlb from LSU 

input [8:0]	exu_tlu_ttype_m;	// exu src ttype
input		exu_tlu_ttype_vld_m;	// exu src ttype vld
input		exu_tlu_ue_trap_m;	// exu ue ecc trap indicator 
//
// added for timing
/*
input [2:0]  exu_tlu_cwp0;  // cwp - thread0
input [2:0]  exu_tlu_cwp1;  // cwp - thread1
input [2:0]  exu_tlu_cwp2;  // cwp - thread2
input [2:0]  exu_tlu_cwp3;  // cwp - thread3
*/
//
input		exu_tlu_spill;		// spill trap
input [1:0]	exu_tlu_spill_tid;	// spill trap - thrid
input       exu_tlu_spill_other;    // From exu of sparc_exu.v
input [2:0] exu_tlu_spill_wtype;    // From exu of sparc_exu.v
input		exu_tlu_va_oor_m;	// ??? - to be used in sfsr
input		exu_tlu_va_oor_jl_ret_m; // ??? - to be used in sfsr
input		ifu_tlu_sir_inst_m; 	// sir instruction executed

input       ifu_tlu_inst_vld_m;    // inst in w-stage of pipe.
input       ifu_tlu_pc_oor_e;    // inst in w-stage of pipe.
input [1:0] ifu_tlu_thrid_d;   	// Thread id.
// input       lsu_tlu_dmmu_miss_g;   // ld/st misses in dtlb.
//
// modified the stage for timing 
//input     ifu_tlu_immu_miss_e;   // i-side page fault
input       ifu_tlu_immu_miss_m;   // i-side page fault

input       exu_tlu_cwp_cmplt;
input       exu_tlu_cwp_retry;
input [1:0] exu_tlu_cwp_cmplt_tid;
input       tlu_cwp_no_change_m;
// input       exu_tlu_cwp_fastcmplt_w;
// input moved to tlu_misctl
// input [2:0]	tsa_rdata_cwp;
// input [`TSA_TTYPE_WIDTH-1:0]	tsa_rdata_ttype;
// input [7:0]	tsa_rdata_ccr;
// input [7:0]	tsa_rdata_asi;

input		ifu_tlu_rstint_m;	// reset interrupt
input		ifu_tlu_hwint_m;	// hw interrupt
input		ifu_tlu_swint_m;	// sw interrupt
input [5:0]	int_tlu_rstid_m;	// reset type
input [4-1:0] tlu_int_pstate_ie;      // interrupt enable
input [4-1:0] tlu_int_redmode;        // redmode
// input  [`TLU_THRD_NUM-1:0]	const_cpuid;

input [4-1:0] tlu_sftint_id;
input [4-1:0] pich_wrap_flg;
input [4-1:0] pich_onebelow_flg;
input [4-1:0] pich_twobelow_flg;
input [4-1:0] pib_picl_wrap;
// modified for bug 5436: Niagara 2.0
input [4-1:0] tlu_pcr_ut;
input [4-1:0] tlu_pcr_st;
// input tlu_pic_wrap_e, tlu_pcr_ut_e, tlu_pcr_st_e;
input tlu_pic_wrap_e;

// input		tlu_tick_match;	// match between tick and tick-cmp 
// input		tlu_stick_match;	// match between tick and stick-cmp 
// input  [`TLU_THRD_NUM-1:0] pib_pic_wrap; // overflow for the pic registers - lvl15 int 
// modified for timing support
// input  [`TLU_THRD_NUM-1:0] pib_priv_act_trap; // access priv violation of the pics 
input  [4-1:0] pib_priv_act_trap_m; // access priv violation of the pics 

input		lsu_tlu_misalign_addr_ldst_atm_m;// misaligned addr - ld,st,atomic 
input		exu_tlu_misalign_addr_jmpl_rtn_m;// misaligned addr - jmpl or return addr
// input		lsu_tlu_priv_violtn_g;		// privileged violation trap
input		lsu_tlu_priv_action_g;		// privileged action trap
input		lsu_tlu_wtchpt_trp_g;		// watchpt trap has occurred.

input		ifu_tlu_priv_violtn_m;
input		ifu_lsu_memref_d;
input [3:0] tlu_pstate_priv;
input [3:0] tlu_pstate_am;
input [3:0]	tlu_isfsr_flt_vld;
input		ffu_tlu_trap_ieee754;
input		ffu_tlu_trap_other;
input		ffu_tlu_trap_ue;
input		ffu_tlu_ill_inst_m; // illegal instruction trap from ffu		
input [1:0]	ffu_ifu_tid_w2;
input [7:0]	lsu_tlu_rsr_data_e;
input       lsu_tlu_squash_va_oor_m;  // squash va_oor for mem-op.
input       spu_tlu_rsrv_illgl_m;    // illegal instruction trap from spu 
input       tlu_htstate_rw_d;
input       tlu_htstate_rw_g;
input       tlu_htickcmp_rw_e;
// input       tlu_gl_rw_g;
input       tlu_gl_rw_m;
input [4-1:0] tlu_hpstate_priv;
input [4-1:0] tlu_hpstate_enb;
input [4-1:0] tlu_hpstate_tlz;
input [4-1:0] tlu_cpu_mondo_cmp;
input [4-1:0] tlu_dev_mondo_cmp;
input [4-1:0] tlu_resum_err_cmp;
input [4-1:0] tlu_hintp;
// input [48:0] ifu_tlu_pc_m;
input [48:0] ifu_tlu_npc_m;
// input [33:0] tlu_partial_trap_pc_w1;
// modified for bug 3017
// logic moved to tlu_misctl
input tlu_hscpd_dacc_excpt_m;
input tlu_qtail_dacc_excpt_m;
// added for timing
input [4:0] tlu_hyperv_rdpr_sel;
input [1:0]	tlu_tckctr_in;
input		rclk; // clock
// sscan tid
input [4-1:0] ctu_sscan_tid;
//
// modified to abide to the niagara reset methodology
input		grst_l;				// global reset - active log
input		arst_l;				// global reset - active log
input		rst_tri_en;			// global reset - active log
input		si;				    // global scan-in 
input		se;				    // global scan-out 

/*autooutput*/
// beginning of automatic outputs (from unused autoinst outputs)
// end of automatics
output	  	 tlu_ifu_trappc_vld_w1;	// trap pc or pc on retry.
output	  	 tlu_ifu_trapnpc_vld_w1;// trap pc or pc on retry.
output [1:0] tlu_ifu_trap_tid_w1;	// thread id.
output	     tlu_trap_hpstate_enb;	
output	     tlu_restore_pc_sel_w1;	
output [4-1:0] pib_pich_wrap;
output tlu_tcc_inst_w;

output [2:0] tsa_wr_tpl;		// trap level for wr.
output [1:0] tsa_rd_tid;		// thread id for wr.
output [2:0] tsa_rd_tpl;		// trap level for rd.
output [1:0] tsa_wr_tid;		// thread id for rd.
output [1:0] tsa_wr_vld;		// write pointer vld
// modified for timing
output 		 tsa_rd_vld_e;		// read pointer
output 		 tsa_rd_en;		    // read pointer
output [3:0] tlu_lsu_tl_zero;	// trap level is zero.
// output		 tlu_ifu_flush_pipe_w;  // exception related flush
// output		 tlu_flush_pipe_w;  	// exception related flush - local copy
// added for timing 
// output		 tlu_flush_all_w2;  	// exception related flush - local copy
// output		 tlu_flush_all_w;  	// exception related flush - local copy
output		 tlu_local_flush_w;  	// exception related flush - local copy
output		 tlu_early_flush_pipe_w;  	// exception related flush - local copy
output		 tlu_early_flush_pipe2_w;  	// exception related flush - local copy
output		 tlu_exu_early_flush_pipe_w;  	// exception related flush - to exu
output		 tlu_full_flush_pipe_w2;  	    // exception related flush - to exu
// output  [2:0]   tlu_exu_agp;            // alternate global pointer
// output          tlu_exu_agp_swap;       // switch globals
// modified due to timing
// output [1:0] tlu_agp_tid_g;        // thread that agp refers to
output [1:0] tlu_agp_tid_w2;        // thread that agp refers to
output [1:0] tlu_exu_agp_tid;        // thread that agp refers to
output		 tsa_pc_en;		// enable write of pc in tsa.
output	     tsa_npc_en;		// enable write of npc in tsa.
output	     tsa_tstate_en;		// enable write of tstate in tsa.
output	     tsa_htstate_en;	// enable write of htstate in tsa.
output	     tsa_ttype_en;		// enable write of ttype in tsa.
// modified due to timing
// output       tlu_tl_gt_0_g;     // trp lvl gt then 0
output       tlu_tl_gt_0_w2;     // trp lvl gt then 0
// modified for timing
output [2:0] tlu_true_pc_sel_w;
// output       tlu_retry_inst_m;  // valid retry inst
// output       tlu_done_inst_m;   // valid done inst
// output       tlu_dnrtry_inst_m_l; // valid done/retry inst - g
output       tlu_tick_en_l;     // tick reg write enable
output [4-1:0]  tlu_tickcmp_en_l;  // tick compare reg write enable
output [4-1:0]  tlu_stickcmp_en_l; // stick compare reg write enable
output [4-1:0]  tlu_htickcmp_en_l; // update htickcmp register 
output [4-1:0]  tlu_tba_en_l;      // tba reg write enable
output [4-1:0]  tlu_thrd_wsel_w2;   // thread requiring tsa write.
output [4-1:0]  tlu_thread_wsel_g; // thread for instruction fetched 
output [9-1:0] tlu_final_ttype_w2;  // selected ttype - w2
// output   tlu_async_trap_taken_g; // async trap taken
output [4-1:0]  tlu_thread_inst_vld_g; // valid inst for a thread
// output [`TLU_THRD_NUM-1:0]  tlu_thread_inst_vld_w2; // valid inst for a thread
// output [`TLU_THRD_NUM-1:0]  tlu_update_pc_l_m; // update pc or npc for a thread
output [4-1:0]  tlu_update_pc_l_w; // update pc or npc for a thread
// output [`TLU_THRD_NUM-1:0]  tlu_thrd_rsel_g; // thread requiring tsa read
// modified for bug 1767
// output         	tlu_select_tle;	// tle/cle value on trap 
// output [1:0]   tlu_select_mmodel;	// mem. model on trap
output 	  	tlu_select_redmode;	// redmode setting on trap
// Modified for bug 1575
//
// output   [2:0]  tlu_pstate_din_sel;    // sel source of tsa wdata
output [1:0] tlu_pstate_din_sel0;    // sel source of tsa wdata
output [1:0] tlu_pstate_din_sel1;    // sel source of tsa wdata
output [1:0] tlu_pstate_din_sel2;    // sel source of tsa wdata
output [1:0] tlu_pstate_din_sel3;    // sel source of tsa wdata
//
// modified due to timing
// output [3:0] tlu_update_pstate_l_g; // pstate write enable
output [3:0] tlu_update_pstate_l_w2; // pstate write enable
output [2:0] tlu_trp_lvl;    // trp lvl - mx'ed
output [3:0] tlu_pil;		  // pil - mx'ed
// output       tlu_wsr_inst_g; // write state inst
// 
// added for timing
output       tlu_wsr_inst_nq_g; // write state inst
// output       tlu_wr_tsa_inst_g; // write state inst
output       tlu_wr_tsa_inst_w2; // write state inst
output       tlu_exu_priv_trap_m; // local traps send to exu 
output       tlu_lsu_priv_trap_m; // local traps send to lsu 
// output       tlu_lsu_priv_trap_w; // local traps send to lsu 
// experiment
output       tlu_pic_cnt_en_m; // local traps send to exu 
// output       tlu_exu_pic_onebelow_m; // local traps send to exu 
// output       tlu_exu_pic_twobelow_m; // local traps send to exu 
output       tlu_exu_cwp_retry_m;
output       tlu_exu_cwpccr_update_m;
// output moved to tlu_misctl
// output [2:0] tlu_exu_cwp_m;
// output [7:0] tlu_exu_ccr_m;
// output [7:0] tlu_lsu_asi_m;		// asi from stack
// added for bug3499
output [4-1:0] tlu_trap_cwp_en;

output       tlu_lsu_asi_update_m; // update asi
output [1:0] tlu_lsu_tid_m;		// thread for asi update

// output	 tlu_assist_boot_rst_g; // use rstvaddr all zeroes
// modified due to timing
// output		 tlu_self_boot_rst_g;	// use rstvaddr all ones
// output		 tlu_select_tba_g;	// use tba
// output		 tlu_select_htba_g;	// use htba
// modified for one-hot mux problem
// output		 tlu_self_boot_rst_w2;	// use rstvaddr all ones
// output		 tlu_select_htba_w2;	// use htba
output [2:0] tlu_pc_mxsel_w2;
output		 tlu_select_tba_w2;	// use tba
output		 tdp_select_tba_w2;	// use tba
//
output		 tlu_set_sftint_l_g;	// set sftint
output		 tlu_clr_sftint_l_g;	// clr sftint
output		 tlu_wr_sftint_l_g;	// wr to sftin (asr 16)
output [4-1:0] tlu_sftint_en_l_g; // wr en sftint regs.
output [4-1:0] tlu_sftint_mx_sel; // mux sel sftint regs.
//
// removed due to sftint recode
// output	[3:0]	tlu_sftint_lvl14_int;	// level 14 sft interrupt

output [3:0] tlu_sftint_penc_sel;	// select appr. thread for pr. encd.
output [3:0] tlu_sftint_vld;	// a sftint is valid for a thread	
output [1:0] tlu_int_tid_m;		// thread id
output [1:0] tlu_incr_tick;         // increment tick reg
output [3:0] tlu_tickcmp_sel;       // select src for tickcmp

output [3:0]  immu_sfsr_trp_wr;
output tlu_itag_acc_sel_g;

output [23:0] tlu_isfsr_din_g;
//
// removed due to sftint code cleanup
output		 tlu_tick_npt;		// npt bit of tick
output [3:0] tlu_thrd_rsel_e;	// read select for threaded regs

output		 tlu_inst_vld_nq_m;	// not qualified inst vld

output [3:0] tlu_lsu_pstate_am;	// ship to lsu

output [2:0] tlu_rdpr_mx1_sel;
output [2:0] tlu_rdpr_mx2_sel;
output [1:0] tlu_rdpr_mx3_sel;
output [1:0] tlu_rdpr_mx4_sel; 
output [2:0] tlu_rdpr_mx5_sel; 
output [2:0] tlu_rdpr_mx6_sel;
output [3:0] tlu_rdpr_mx7_sel;
//
output [9-1:0] tlu_final_offset_w1;
// output   [3:0]   tlu_lsu_redmode;       	// redmode
// output [3:0] tlu_lsu_redmode_rst;
// output [`TLU_THRD_NUM-1:0] tlu_lsu_async_ack_w2;
output [3:0] tlu_lsu_redmode_rst_d1;
output [7:0] lsu_tlu_rsr_data_mod_e;
output       tlu_addr_msk_g;        // address masking active for thread in pipe.
//
// added for hypervisor support
// modified for timing
// output tlu_thrd0_traps, tlu_thrd1_traps;
// output tlu_thrd2_traps, tlu_thrd3_traps;
output [4-1:0] tlu_thrd_traps_w2; 
output tlu_dnrtry0_inst_g, tlu_dnrtry1_inst_g;
output tlu_dnrtry2_inst_g, tlu_dnrtry3_inst_g;
// output tlu_ibrkpt_trap_g; 
output tlu_ibrkpt_trap_w2; 
output tlu_tick_ctl_din;
output [4-1:0] tlu_por_rstint_g;
output [4-1:0] tlu_hintp_vld;  // From tcl of tlu_tcl.v
output [4-1:0] tlu_rerr_vld;  // From tcl of tlu_tcl.v
// modified for bug 3017
// moved to tlu_misctl
output [48:0] ifu_npc_w; //ifu_pc_w, 
// 
// shadow scan data from tcl tl and ttype
output [3-1:0] tlu_sscan_tcl_data;

//
// added to abide to the niagara reset methodology
output tlu_rst;     // local unit reset - active high
// output tlu_rst_l;	// local unit reset - active low
output so;			// global scan-out 

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics

// this signal were added to abide to the niagara reset methodology
wire local_rst;
wire local_rst_l;
wire tlu_rst_l;	// local unit reset - active low

wire [1:0]  tlu_exu_tid_m;
wire [3:0]	pstate_rmode;

// wire select_tba_g;	// use tba
wire local_select_tba_w2;	// use tba
wire [1:0] select_tba_element_w2;	// use tba
// wire select_htba_g;	// use htba
//
// added for early flush timing fix
// wire tlu_early_flush_pipe_m; 
wire local_early_flush_pipe_w; 
wire local_early_flush_pipe2_w; 
wire local_early_flush_pipe3_w; 
wire local_early_flush_pipe4_w; 
wire lsu_ttype_vld_w, lsu_ttype_vld_w2; 
wire tlu_flush_all_w; 
wire tlu_ifu_flush_pipe_w;  // exception related flush
wire tlu_flush_pipe_w;  // exception related flush
wire tlu_flush_all_w2; 
// wire tlu_wr_tsa_inst_g; // write state inst
wire tlu_self_boot_rst_g, tlu_self_boot_rst_w2;	
wire dnrtry_inst_g; 
wire dnrtry0_inst_g, dnrtry1_inst_g;
wire dnrtry2_inst_g, dnrtry3_inst_g;
wire [4-1:0] dnrtry_inst_w2; 
wire thrd0_traps,thrd1_traps;
wire thrd2_traps,thrd3_traps;
// wire [`TLU_THRD_NUM-1:0] async_trap_ack_g;
// wire [`TLU_THRD_NUM-1:0] async_trap_ack_w2;
wire [2:0]	trp_lvl0,trp_lvl0_new;
wire [2:0]	trp_lvl1,trp_lvl1_new;
wire [2:0]	trp_lvl2,trp_lvl2_new;
wire [2:0]	trp_lvl3,trp_lvl3_new;
wire tl0_en, tl0_gt_0;
wire tl1_en, tl1_gt_0;
wire tl2_en, tl2_gt_0;
wire tl3_en, tl3_gt_0;
wire [1:0] agp_tid_g, agp_tid_w2, agp_tid_w3; // thread that agp refers to
// wire tlu_pic_onebelow_e, tlu_pic_twobelow_e; 
// experiment
wire pich_wrap_flg_m, tlu_pich_wrap_flg_m; // pich_wrap_flg_e, 
wire tlu_picl_wrap_flg_m; // pich_wrap_flg_e, 
// modified for bug 5436 - Niagara 2.0
wire [4-1:0] pic_cnt_en;
wire pic_cnt_en_e, pic_cnt_en_m, pic_cnt_en_w, pic_cnt_en_w2; 
// wire pic_trap_en_e; 
//wire pcr_ut_e, pcr_st_e; 
// wire [`TLU_THRD_NUM-1:0] pich_exu_wrap_e;
// wire pic_hpstate_enb_e, pic_hpstate_priv_e, pic_pstate_priv_e; 
//
wire [4-1:0] tlz_thread_set, tlz_thread_data;
wire [4-1:0] tlz_thread;
wire [4-1:0] tlz_trap_m, tlz_exu_trap_m;
wire [4-1:0] tlz_trap_nq_g, tlz_trap_g; 
wire [4-1:0] ifu_thrd_flush_w; 
wire [4-1:0] tlu_none_priv; 
wire cpu_mondo_trap_g, dev_mondo_trap_g; 
wire cpu_mondo_trap_w2, dev_mondo_trap_w2; 
wire [4-1:0] tlu_cpu_mondo_trap; 
wire [4-1:0] tlu_dev_mondo_trap; 
wire [4-1:0] tlu_resum_err_trap; 
wire [4-1:0] tlu_hyper_lite;
wire [3:0] local_rdpr_mx6_sel; 
wire [3:0] local_rdpr_mx5_sel; 
wire [2:0] local_rdpr_mx4_sel; 
wire [2:0] local_rdpr_mx3_sel;
wire [3:0] local_rdpr_mx2_sel;
wire [3:0] local_rdpr_mx1_sel;
wire tlu_none_priv_m;
wire ibrkpt_trap_m, ibrkpt_trap_g, ibrkpt_trap_w2;
wire va_oor_jl_ret_g;
wire done_inst_m_tmp;
wire retry_inst_m_tmp;
wire done_inst_w2;
wire retry_inst_w2;
wire [2:0] true_pc_sel_m, true_pc_sel_w; 
// wire dsfsr_flt_vld_g;
wire done_inst_e, retry_inst_e;
wire done_inst_m, retry_inst_m;
wire exu_done_inst_m, exu_retry_inst_m;
// logic moved to misctl
// wire cwp_no_change_m;
// wire [2:0] cwp_xor_m, trap_old_cwp_m; 
wire done_inst_g, retry_inst_g;
wire [1:0] thrid_d, thrid_e, thrid_m, thrid_g;
wire [1:0] thrid_w2; 
//
// added for tsa_wr_tid bug
//
// wire thread0_wtrp_g, thread1_wtrp_g, thread2_wtrp_g, thread3_wtrp_g;
wire thread0_wtrp_w2, thread1_wtrp_w2, thread2_wtrp_w2, thread3_wtrp_w2;
wire thread0_wsel_g, thread1_wsel_g, thread2_wsel_g, thread3_wsel_g;
wire thread0_wsel_w2, thread1_wsel_w2, thread2_wsel_w2, thread3_wsel_w2;
wire thread0_rsel_dec_g,thread1_rsel_dec_g;
wire thread2_rsel_dec_g,thread3_rsel_dec_g;
wire thread0_rsel_d, thread1_rsel_d, thread2_rsel_d, thread3_rsel_d;
wire thread0_rsel_m, thread1_rsel_m, thread2_rsel_m, thread3_rsel_m;
wire thread0_stg_m, thread1_stg_m, thread2_stg_m, thread3_stg_m; 
wire thread0_stg_m_buf, thread1_stg_m_buf, thread2_stg_m_buf, thread3_stg_m_buf; 
wire thread0_rsel_g, thread1_rsel_g, thread2_rsel_g, thread3_rsel_g;
wire thread0_rsel_e, thread1_rsel_e, thread2_rsel_e, thread3_rsel_e;
wire inst_vld_w2, inst_vld_g, inst_vld_m, inst_vld_nf_g;
wire [4-1:0] thread_inst_vld_g; 
wire [4-1:0] thread_inst_vld_w2; 
// wire tlu_inst_vld_m;	// qualified inst vld
wire exu_ttype_vld_g, ifu_ttype_vld_g, exu_ue_trap_g;
wire [8:0]	exu_ttype_g, ifu_ttype_tmp_g, ifu_ttype_g;
wire [8:0]	exu_spill_ttype; 
// added for timing fix
wire    spu_ill_inst_m ;      // illegal instruction trap from spu 
wire    spu_ill_inst_uf_g ;      // illegal instruction trap from spu 
wire    spu_ill_inst_g ;      // illegal instruction trap from spu 
wire    pib_priv_act_trap_g ;   // privilege action trap from pib 
wire    pib_priv_act_trap_uf_g ;   // privilege action trap from pib 
wire    pib_priv_act_early_trap_m ; // privilege action trap from pib 
wire    ffu_ill_inst_uf_g ;   // illegal instruction trap from ffu - unflushed 
wire    ffu_ill_inst_g ;      // illegal instruction trap from ffu 
wire    ffu_higher_pri_g ;      // illegal instruction trap from ffu 
wire    exu_higher_pri_g ;      // UE ECC trap from exu 
// wire    lsu_ill_inst_uf_g ;   // illegal instruction trap from lsu - unflushed
// wire    lsu_ill_inst_g ;      // illegal instruction trap from lsu 
// wire [`TLU_THRD_NUM-1:0] lsu_defr_thrd_g; 
wire    lsu_defr_trap_g, lsu_defr_trap_w2 ;     // deferred trap from lsu 
wire    local_lsu_async_ttype_vld_w; // deferred trap from lsu 
// wire    local_lsu_defr_trp_taken_g; // deferred trap from lsu 
wire [4-1:0] lsu_defr_trp_taken_w2; 
// wire    lsu_tlu_defr_trp_taken_w2 ;  // deferred trap from lsu - signled in g for w2
                                     // trap need to sync up with lsu_tlu_async_ttype_vld_g  
wire    htrap_ill_inst_m ;      // illegal instruction trap from htrap 
wire    htrap_ill_inst_uf_g ;   // illegal instruction trap from htrap - unflushed
wire    htrap_ill_inst_g ;      // illegal instruction trap from htrap 

wire	[7-1:0] sraddr;
wire	[7-1:0] sraddr2;
// modified due to timing
// wire		wsr_inst_d;
wire        asr_hyperp, asr_priv;
wire		tpc_rw_d, tnpc_rw_d, tstate_rw_d, ttype_rw_d;
wire		tick_rw_d, tickcmp_rw_d, tick_npriv_r_d;
wire	    pcr_rsr_d, pic_rsr_d;	
wire	    pcr_rsr_e, pic_rsr_e;	
wire        tlu_gl_rw_g;
//
// added for hypervisor support
wire maxtl_wr_sel;
wire [3:0] maxstl_wr_sel;
wire [2:0] wsr_trp_lvl0_data_w, wsr_trp_lvl1_data_w;
wire [2:0] wsr_trp_lvl2_data_w, wsr_trp_lvl3_data_w;
wire [2:0] wsr_trp_lvl0_data_w2, wsr_trp_lvl1_data_w2;
wire [2:0] wsr_trp_lvl2_data_w2, wsr_trp_lvl3_data_w2;
wire	   stick_rw_d, stickcmp_rw_d, stickcmp_rw_e; 
wire	   stickcmp_rw_m, stickcmp_rw_g; 
// wire [3:0] stickcmp_int;       // interrupt caused by stick_ticktmp 
// wire [3:0] stick_intclr;  // use to clear the stick_int bit

wire tba_rw_d, pstate_rw_d, pil_rw_d, tl_rw_d; 
wire tsa_wr_tid_sel_g, tsa_wr_tid_sel_tim_g, tsa_wr_tid_sel_w2;
wire immu_miss_g;
wire trap_taken_g, trap_taken_w2;
wire [1:0] trap_tid_g;
// wire [1:0] tsa_wr_tid_g;
wire [1:0] pend_trap_tid_g, pend_trap_tid_w2;
wire [9-1:0] final_ttype_w2; 
wire [9-1:0] tba_ttype_w1;
wire [9-1:0] final_offset_w1; 
wire tsa_rd_vld;
// modified for bug 3017
// logic moved to tlu_misctl
// wire [48:0] normal_trap_pc_w1, normal_trap_npc_w1; 
// wire [48:0] trap_pc_w1, trap_npc_w1; 
// wire [48:0] trap_pc_w2, trap_npc_w2; 
// wire tsa_rd_vld_e, tsa_rd_vld_m;
wire [4-1:0] sscan_tid_sel; 
// logic moved to tlu_misctl
/*
wire [`TLU_THRD_NUM-1:0] sscan_ttype_en;
wire [`TLU_THRD_NUM-1:0] sscan_tt_rd_sel;
wire [`TLU_THRD_NUM-1:0] sscan_tt_wr_sel;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt0_data;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt1_data;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt2_data;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt3_data;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt0_din;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt1_din;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt2_din;
wire [`TSA_TTYPE_WIDTH-1:0] sscan_tt3_din;
wire [`TSA_TTYPE_WIDTH-1:0] tsa_rdata_ttype_m;
*/
wire [3-1:0] tcl_sscan_test_data;
wire tba_ttype_sel_w2;
wire [3:0] final_ttype_sel_g, final_ttype_sel_w2;
// modified due to one-hot mux bug
wire [1:0] final_offset_en_g, final_offset_en_w1; 
wire [2:0] final_offset_sel_w1; 
wire restore_pc_sel_g, restore_pc_sel_w1;
// removed for timing
// wire [`TSA_TTYPE_WIDTH-1:0] sync_ttype_g;
// added to support lsu dferred traps
wire		priority_trap_sel0, priority_trap_sel1, priority_trap_sel2;
wire		sync_trap_taken_g, sync_trap_taken_w2;
// added for timing fix
wire		sync_trap_taken_m ;
wire		ifu_ttype_early_vld_m ;
// wire  [3:0]   tickcmp_int;       // interrupt caused by tick_ticktmp 
wire	   fp_trap_thrd0,fp_trap_thrd1,fp_trap_thrd2,fp_trap_thrd3;
wire [9-1:0] ffu_async_ttype;
wire	   spill_thrd0,spill_thrd1,spill_thrd2,spill_thrd3;
wire [4-1:0] trap_cwp_enb; 
wire [4-1:0] lsu_async_vld_en_g, lsu_async_vld_en_w2; 
wire	   dmmu_async_thrd0, dmmu_async_thrd1; 
wire       dmmu_async_thrd2, dmmu_async_thrd3;
wire [9-1:0] dmmu_async_ttype;
wire	   pend_to_thrd0_en, pend_to_thrd1_en;
wire	   pend_to_thrd2_en, pend_to_thrd3_en;
wire	   pend_to_thrd0_reset, pend_to_thrd1_reset;
wire	   pend_to_thrd2_reset, pend_to_thrd3_reset;
wire tlu_pich_cnt_hld;
wire [4-1:0] pich_cnt_hld_rst_g;
wire [4-1:0] pich_cnt_hld_rst_w2;
wire [4-1:0] pend_pich_cnt_hld;
wire [4-1:0] pend_pich_cnt_hld_q;
wire [4-1:0] pend_pich_cnt_hld_noqual;
wire [4-1:0] pend_pich_cnt_hld_early;
wire [4-1:0] pend_pich_cnt_adj;
wire [4-1:0] cwp_en_thrd_reset; 
// wire	   pend_to_thrd0_taken, pend_to_thrd1_taken;
// wire	   pend_to_thrd2_taken, pend_to_thrd3_taken;
wire [9-1:0] pend_ttype0,pend_ttype1,pend_ttype2,pend_ttype3;
wire	   pending_trap0,pending_trap1,pending_trap2,pending_trap3;
wire [9-1:0] pending_ttype0,pending_ttype1,pending_ttype2,pending_ttype3;
wire [9-1:0] pending_ttype, pending_ttype_w2;
//
// Added for bug 1575
wire agp_tid_sel;	
// modified due to timing
// wire update_pstate0_g,update_pstate1_g;
// wire update_pstate2_g,update_pstate3_g;
// wire [`TLU_THRD_NUM-1:0] update_pstate_g;,
wire [4-1:0] update_pstate_w2;
wire thrd0_traps_w2, thrd1_traps_w2;
wire thrd2_traps_w2, thrd3_traps_w2;
wire ifu_ttype_vld_tmp_g;
//
// added for timing, move qualification from ifu to tlu
wire	   ifu_ttype_vld_m;
wire	   cwp_cmplt0,cwp_cmplt1,cwp_cmplt2,cwp_cmplt3;
wire	   cwp_cmplt_w2, cwp_cmplt_g;
wire	   cwp_cmplt_rtry_w2, cwp_cmplt_rtry_g;
wire	   cwp_fastcmplt_w2;
wire	   cwp_cmplt0_pending, cwp_cmplt1_pending;
wire	   cwp_cmplt2_pending, cwp_cmplt3_pending;
wire	   cwp_retry0,cwp_retry1,cwp_retry2,cwp_retry3;
wire	   pending_thrd0_event_taken, pending_thrd1_event_taken;
wire	   pending_thrd2_event_taken, pending_thrd3_event_taken;
// wire	   pending_thrd0_event_taken_w2, pending_thrd1_event_taken_w2;
// wire	   pending_thrd2_event_taken_w2, pending_thrd3_event_taken_w2;
wire	   cwp_fastcmplt_m, cwp_fastcmplt_uq_g, cwp_fastcmplt_g;
wire	   pending_dntry0_taken, pending_dntry1_taken; 
wire	   pending_dntry2_taken, pending_dntry3_taken;
wire	   rstint_g,hwint_g,swint_g;
wire [2:0] early_ttype_sel;
// wire [2:0] rst_ttype_sel;
wire [1:0] rst_ttype_sel;
wire rst_hwint_sel_w2;
// modified for timing
// wire [3:0] rst_hwdr_ttype_sel;
wire rst_hwdr_ttype_sel_w2;
wire	   onehot_pending_ttype_sel;
wire	   early_priv_traps_g, exu_hyper_traps_g; 
wire	   exu_pib_priv_act_trap_m; 
wire [4-1:0] pib_wrap_m; 
wire [4-1:0] pib_pich_wrap_m; 
wire pib_wrap_trap_nq_g, pib_wrap_trap_g, pib_wrap_trap_m;
wire [4-1:0] pib_trap_en;
wire [4-1:0] picl_wrap_pend;
//
// added for timing; moved qualification from IFU to TLU
wire	   ifu_rstint_m,ifu_hwint_m,ifu_swint_m; // swint_nq_g;
wire	   sftint_penc_update; 
wire	   sftint_user_update_g, sftint_user_update_w2; 
wire	   penc_sel_user_update; 
wire [5:0] rstid_g;
wire	   trp_lvl0_incr_w2, trp_lvl1_incr_w2;
wire	   trp_lvl2_incr_w2, trp_lvl3_incr_w2;
wire	rstint_taken,hwint_taken,swint_taken;
// wire	swint_thrd0_taken, swint_thrd1_taken;
// wire	swint_thrd2_taken, swint_thrd3_taken;
wire    sirint_taken;
// wire [`TLU_THRD_NUM-2:0] swint_thrd_g;
wire [4-2:0] sftint_penc_thrd;
wire	por_rstint_g, xir_rstint_g; 
wire	por_rstint0_g, por_rstint1_g;
wire	por_rstint2_g, por_rstint3_g;
wire    por_rstint_w2; 
wire	por_rstint0_w2, por_rstint1_w2;
wire	por_rstint2_w2, por_rstint3_w2;
wire	trp_lvl0_at_maxtl,trp_lvl1_at_maxtl;
wire	trp_lvl2_at_maxtl,trp_lvl3_at_maxtl;
wire	internal_wdr;
wire [4-1:0] internal_wdr_trap;
// added for hypervispor support
wire [4-1:0] pil_cmp_en;
wire [4-1:0] sftint_only_vld;
wire [4-1:0] tlu_int_sftint_pend;
wire [4-1:0] sftint_pend_wait;
wire [4-1:0] sftint_wait_rst;
//
wire [3:0] true_pil0, true_pil1;
wire [3:0] true_pil2, true_pil3;
wire pil0_en,pil1_en,pil2_en,pil3_en;
wire set_sftint_d, clr_sftint_d, sftint_rg_rw_d;
// modified for timing and bug 5117 
wire [6:0] final_swint_id_w2;
// wire [6:0] final_swint_id;
// wire [6:0] final_swint0_id, final_swint1_id;
// wire [6:0] final_swint2_id, final_swint3_id;
// modified for bug 3705
// wire [6:0] tlz_swint_ttype;
// wire [6:0] hwint_swint_ttype;
wire [6:0] wrap_tlz_ttype;
wire [3:0] sftint0_id,sftint1_id,sftint2_id,sftint3_id;
wire [3:0] sftint_id_w2;
// wire [6:0] sftint_ttype; 
wire done_inst_g_tmp, retry_inst_g_tmp;
wire immu_va_oor_brnchetc_m;
wire pstate_am;// pstate_priv pstate_priv_g;
wire memref_e, memref_m;
wire [2:0] isfsr_ftype_sel;
wire [6:0] isfsr_ftype_m,isfsr_ftype_g;
wire	   isfsr_flt_vld_m,isfsr_flt_vld_g;
wire	   isfsr_trp_wr_m,isfsr_trp_wr_g;
wire	   itag_acc_sel_g;
// wire	   flsh_inst_m, flsh_inst_g;
// wire	   pstate_cle;
// wire [2:0] dsfsr_asi_sel_m, dsfsr_asi_sel_g;
// wire [1:0] dsfsr_asi_sel_m, // dsfsr_asi_sel_g;
wire dmmu_va_oor_m, dmmu_va_oor_g;
// wire ldst_xslate_g;
// wire [2:0]	dsfsr_ctxt_sel;
// wire dsfsr_wr_op_g;
// wire dsfsr_flt_vld_m;
//
// logic moved to lsu_expctl due to timing
/*
wire dsfsr_ftype_zero;
wire [1:0]	dsfsr_ctxt_g, 
wire [7:0]	dsfsr_asi_g;
// wire [6:0]	dsfsr_ftype_g, dsfsr_pe_ftype_g;
wire dsfsr_side_effect_g;
wire dsfsr_trp_wr_g;
*/
wire [1:0] isfsr_ctxt_g;
wire [4-1:0] tick_en;
wire local_sync_trap_m, local_sync_trap_g;
wire dside_sync_trap_g, early_dside_trap_g;
wire true_hscpd_dacc_excpt_m;
wire true_qtail_dacc_excpt_m;
// wire lsu_higher_priority;
// wire dside_higher_priority;
wire [9-1:0] local_sync_ttype_g;
wire local_higher_ttype_flg;
// wire [`TSA_TTYPE_WIDTH-1:0]	dside_sync_ttype_pre_g;
// wire [`TSA_TTYPE_WIDTH-1:0]	dside_sync_ttype_g;
wire [9-1:0]	early_sync_ttype_g, early_sync_ttype_w2;
wire [9-1:0]	adj_lsu_ttype_w2;
wire [9-1:0]	lsu_tlu_ttype_w2;
// wire [`TSA_TTYPE_WIDTH-3:0]	lsu_tlu_async_ttype_w2;
// wire [`TSA_TTYPE_WIDTH-3:0]	rst_ttype_g; 
wire [9-3:0]	rst_hwint_ttype_g, rst_hwint_ttype_w2; 
wire [9-3:0]	rst_ttype_w2, rst_hwdr_ttype_w2;
wire [9-1:0]	early_ttype_g;
wire trp_lvl0_at_maxtlless1,trp_lvl1_at_maxtlless1;
wire trp_lvl2_at_maxtlless1,trp_lvl3_at_maxtlless1;
wire trp_lvl_at_maxtlless1;
wire [4-1:0] tpl_maxless1;
wire redmode_insertion, redmode_insertion_w2;
wire [4-1:0] tlu_lsu_redmode_rst;
wire trap_to_redmode;
wire pending_thrd_event_taken;
// added or modified for timing
wire [4-2:0]  thrd_rsel_g;
wire [4-2:0]  thrd_rsel_w2;
wire va_oor_inst_acc_excp_g; // qualified va_oor_jl_ret trap 
wire va_oor_data_acc_excp_g, va_oor_data_acc_excp_w2; // qualified exu_tlu_va_oor_m trap 
wire sir_inst_g;
wire [4-1:0]	pending_trap_sel;
//
// modified to support lsu_deferred traps; modified for timing
wire reset_sel_g, reset_sel_w2;
wire [2:0] reset_id_g;
wire tick_npt0,tick_npt1,tick_npt2,tick_npt3;
wire tick_ctl_din;
// modified due to early_flush_pipe timing fix
// wire tlu_tick_npt_priv_act;
wire	tick_npt_priv_act_g;
wire	tick_npt_priv_act_m;
wire	exu_tick_npt_priv_act_m;
//
// moved the tick_indis and stick_intdis logic to tlu_tdp
// wire tick_intdis0,tick_intdis1,tick_intdis2,tick_intdis3;
// wire stick_intdis0,stick_intdis1,stick_intdis2,stick_intdis3;
// wire [`TLU_THRD_NUM-1:0]	tick_intrpt;
// wire [`TLU_THRD_NUM-1:0]	tick_intclr;  // use to clear the tick_int bit
// wire wsr_tick_intclr_g;  // clear the tick_int through asr write
// wire wsr_tick_intset_g;  // set the tick_int through asr write 
// add and/or modified for hypervisor support
// wire [1:0] cwp_cmplt_tid_w2, cwp_cmplt_tid_g;
// wire	wsr_illeg_globals_g;  // mutual exclusiveness of the pstate globals 
// wire wsr_stick_intclr_g;  // clear the stick_int through asr write
// wire wsr_stick_intset_g;  // set the stick_int through asr write 
// wire [`TLU_THRD_NUM-1:0] stick_intrpt;
// wire [`TLU_THRD_NUM-1:0] stick_int_en, stick_int_din;
// wire [`TLU_THRD_NUM-1:0] tick_int_en, tick_int_din;
// 
// wire [1:0] cwp_cmplt_tid_g;
wire [1:0] true_trap_tid_g;
wire [1:0] early_trap_tid_g;
wire [1:0] true_trap_tid_w2;
wire trp_lvl_zero;
wire misalign_addr_jmpl_rtn_g,misalign_addr_ldst_atm_g;
wire tt_init_en;
wire [4-1:0] tt_init_rst;
wire [4-1:0] tt_unwritten;
wire ttype_written;
wire ttype_unwritten_sel;
wire reset_d1;
wire thread_tl_zero;
// wire iside_trap;
wire [7:0] isfsr_asi_g;
wire thread_tl_zero_m,thread_tl_zero_g;
wire tlu_trap_to_hyper_g, tlu_trap_to_hyper_w2;
// wire hyper_wdr_trap;
wire hyper_wdr_early_trap_g, hyper_wdr_early_trap_w2, hyper_wdr_trap_w2;
wire tlu_priv_traps_w2;
wire [2:0] tlu_early_priv_element_g;
wire [2:0] tlu_early_priv_element_w2; 
wire [4-1:0] trp_lvl_gte_maxstl;
wire [4-1:0] trp_lvl_at_maxstl;

// This section was modified to abide to the Niagara synthesis methodology
//
//reg	tpc_rw_e, tpc_rw_m, tpc_rw_g;
//reg	tnpc_rw_e, tnpc_rw_m, tnpc_rw_g;
//reg	tstate_rw_e, tstate_rw_m, tstate_rw_g, tstate_rw_w2;
//reg	ttype_rw_e, ttype_rw_m, ttype_rw_g, ttype_rw_w2;
//reg	tick_rw_e, tick_rw_m, tick_rw_g;
//reg	tick_npriv_r_e, tick_npriv_r_m, tick_npriv_r_g;
//reg	tickcmp_rw_e, tickcmp_rw_m, tickcmp_rw_g;
//reg	tba_rw_e, tba_rw_m, tba_rw_g;
//reg	pstate_rw_e, pstate_rw_m, pstate_rw_g;
//reg	pil_rw_e, pil_rw_m, pil_rw_g;
//reg	tl_rw_e, tl_rw_m, tl_rw_g;
//reg	wsr_inst_e, wsr_inst_m, wsr_inst_g_unflushed; 
//reg	set_sftint_e, clr_sftint_e, sftint_rg_rw_e;
//reg	set_sftint_m, clr_sftint_m, sftint_rg_rw_m;
//reg	set_sftint_g, clr_sftint_g, sftint_rg_rw_g;
//
wire	tpc_rw_e, tpc_rw_m, tpc_rw_g, tpc_rw_w2;
wire	tnpc_rw_e, tnpc_rw_m, tnpc_rw_g, tnpc_rw_w2;
wire	tstate_rw_e, tstate_rw_m, tstate_rw_g, tstate_rw_w2;
wire	ttype_rw_e, ttype_rw_m, ttype_rw_g, ttype_rw_w2;
wire	htstate_rw_w2;  
wire	tick_rw_e, tick_rw_m, tick_rw_g;
wire	tick_npriv_r_e, tick_npriv_r_m, tick_npriv_r_g;
wire	tickcmp_rw_e, tickcmp_rw_m, tickcmp_rw_g;
wire	tba_rw_e, tba_rw_m, tba_rw_g;
wire	pstate_rw_e, pstate_rw_m, pstate_rw_g, pstate_rw_w2;
wire	pil_rw_e, pil_rw_m, pil_rw_g;
wire	tl_rw_e, tl_rw_m, tl_rw_g, tl_rw_w2;
wire	htickcmp_rw_m, htickcmp_rw_g;
wire	wsr_inst_e, wsr_inst_m, wsr_inst_g_unflushed; 
wire	set_sftint_e, clr_sftint_e, sftint_rg_rw_e;
wire	set_sftint_m, clr_sftint_m, sftint_rg_rw_m;
wire	set_sftint_g, clr_sftint_g, sftint_rg_rw_g;
//
wire wsr_inst_g, wsr_inst_w2; 
wire inst_ifu_flush_w;
wire inst_ifu_flush2_w;
wire clk;

//=========================================================================================
//=========================================================================================
//=========================================================================================

wire [3:0] tlu_pstate_priv_buf;

assign tlu_pstate_priv_buf[3:0] = tlu_pstate_priv[3:0];

//=========================================================================================
//=========================================================================================
//=========================================================================================
//	reset
//=========================================================================================

dffrl_async dffrl_local_rst_l(
    .din  (grst_l),
    .clk  (clk),
    .rst_l(arst_l),
    .q    (local_rst_l),
    .se   (se),
    .si   (),
    .so   ()
); 

assign tlu_rst = ~tlu_rst_l;
assign local_rst = ~tlu_rst_l;
assign tlu_rst_l = local_rst_l;

//=========================================================================================
//	Rename
//=========================================================================================

// assign	tlu_lsu_redmode[3:0] = tlu_int_redmode[3:0];
assign clk = rclk;

//=========================================================================================
//	Misc. TDP Control
//=========================================================================================
//
// modified for bug 5436: Niagara 2.0
/*
assign pcr_ut_e = 
           (tlu_thrd_rsel_e[0]) ? tlu_pcr_ut[0]: 
           (tlu_thrd_rsel_e[1]) ? tlu_pcr_ut[1]: 
           (tlu_thrd_rsel_e[2]) ? tlu_pcr_ut[2]:
            tlu_pcr_ut[3]; 

assign pcr_st_e = 
           (tlu_thrd_rsel_e[0]) ? tlu_pcr_st[0]:
           (tlu_thrd_rsel_e[1]) ? tlu_pcr_st[1]:
           (tlu_thrd_rsel_e[2]) ? tlu_pcr_st[2]:
            tlu_pcr_st[3];
*/

assign	tlu_thread_inst_vld_g[0] = 
            inst_vld_g & thread0_rsel_g & ~pend_pich_cnt_hld[0];
assign	tlu_thread_inst_vld_g[1] = 
            inst_vld_g & thread1_rsel_g & ~pend_pich_cnt_hld[1];
assign	tlu_thread_inst_vld_g[2] = 
            inst_vld_g & thread2_rsel_g & ~pend_pich_cnt_hld[2];
assign	tlu_thread_inst_vld_g[3] = 
            inst_vld_g & thread3_rsel_g & ~pend_pich_cnt_hld[3];

assign	thread_inst_vld_w2[0] = inst_vld_w2 & thread0_wsel_w2;
assign	thread_inst_vld_w2[1] = inst_vld_w2 & thread1_wsel_w2;
assign	thread_inst_vld_w2[2] = inst_vld_w2 & thread2_wsel_w2;
assign	thread_inst_vld_w2[3] = inst_vld_w2 & thread3_wsel_w2;

assign	thread_inst_vld_g[0] = inst_vld_g & thread0_rsel_g;
assign	thread_inst_vld_g[1] = inst_vld_g & thread1_rsel_g;
assign	thread_inst_vld_g[2] = inst_vld_g & thread2_rsel_g;
assign	thread_inst_vld_g[3] = inst_vld_g & thread3_rsel_g;

// added for timing
//
assign	tlu_trp_lvl[2:0] =
		thread0_rsel_e ? trp_lvl0[2:0] :
			thread1_rsel_e ? trp_lvl1[2:0] :
				thread2_rsel_e ? trp_lvl2[2:0] :
					thread3_rsel_e ? trp_lvl3[2:0] : 3'bxxx;

assign	tlu_pil[3:0] =
		thread0_rsel_e ? true_pil0[3:0] :
			thread1_rsel_e ? true_pil1[3:0] :
				thread2_rsel_e ? true_pil2[3:0] :
					thread3_rsel_e ? true_pil3[3:0] : 4'bxxx;

assign tlu_tba_en_l[0] = ~(tba_rw_g & wsr_inst_g & thread0_wsel_g);
assign tlu_tba_en_l[1] = ~(tba_rw_g & wsr_inst_g & thread1_wsel_g);
assign tlu_tba_en_l[2] = ~(tba_rw_g & wsr_inst_g & thread2_wsel_g);
assign tlu_tba_en_l[3] = ~(tba_rw_g & wsr_inst_g & thread3_wsel_g);


assign	tlu_tick_en_l	=	~(tick_rw_g & wsr_inst_g);
// the logic equations can be made common (grape)
// reset may not have to be factored in !!!
assign	tick_en[0] = (tick_rw_g & wsr_inst_g & thread0_wsel_g) | local_rst | por_rstint0_g;
assign	tick_en[1] = (tick_rw_g & wsr_inst_g & thread1_wsel_g) | local_rst | por_rstint1_g;
assign	tick_en[2] = (tick_rw_g & wsr_inst_g & thread2_wsel_g) | local_rst | por_rstint2_g;
assign	tick_en[3] = (tick_rw_g & wsr_inst_g & thread3_wsel_g) | local_rst | por_rstint3_g;

// modified for bug 4763
assign	tlu_tickcmp_en_l[0] =	~((tickcmp_rw_g & wsr_inst_g & thread0_wsel_g)); 
assign	tlu_tickcmp_en_l[1] =	~((tickcmp_rw_g & wsr_inst_g & thread1_wsel_g));
assign	tlu_tickcmp_en_l[2] =	~((tickcmp_rw_g & wsr_inst_g & thread2_wsel_g));
assign	tlu_tickcmp_en_l[3] =	~((tickcmp_rw_g & wsr_inst_g & thread3_wsel_g));
//
// modified for bug 4763
assign	tlu_stickcmp_en_l[0] =	~((stickcmp_rw_g & wsr_inst_g & thread0_wsel_g));
assign	tlu_stickcmp_en_l[1] =	~((stickcmp_rw_g & wsr_inst_g & thread1_wsel_g));
assign	tlu_stickcmp_en_l[2] =	~((stickcmp_rw_g & wsr_inst_g & thread2_wsel_g));
assign	tlu_stickcmp_en_l[3] =	~((stickcmp_rw_g & wsr_inst_g & thread3_wsel_g));
//
// modified for bug 4763
assign	tlu_htickcmp_en_l[0] =	~((htickcmp_rw_g & wsr_inst_g & thread0_wsel_g));
assign	tlu_htickcmp_en_l[1] =	~((htickcmp_rw_g & wsr_inst_g & thread1_wsel_g));
assign	tlu_htickcmp_en_l[2] =	~((htickcmp_rw_g & wsr_inst_g & thread2_wsel_g));
assign	tlu_htickcmp_en_l[3] =	~((htickcmp_rw_g & wsr_inst_g & thread3_wsel_g));

// modified for bug 1266 and 1264
dff_s dff_stgg_va_oor_jl_ret_g (
    .din (exu_tlu_va_oor_jl_ret_m), 
	.q   (va_oor_jl_ret_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// This may have to be changed as all lsu traps may not use mmu globals 
// ffu traps may have to be factored in once round-robin selection in place.
// factor in ldst related mem-address exceptions. 
//
// modified for bug 1264 and 1266
// prioritize the exu_tlu_va_oor_jl_ret_m trap; if no higher traps are happening initiate the trap
//
assign va_oor_inst_acc_excp_g = 
      va_oor_jl_ret_g & inst_vld_g & 
     ~(exu_ttype_vld_g | ifu_ttype_vld_g | lsu_tlu_priv_action_g | local_sync_trap_g);
//
// added for bug 1316 
// prioritize the exu_tlu_va_oor_jl_ret_m trap; if no higher traps are happening initiate the trap
// modified for bug 3464 and bug 4873 
assign va_oor_data_acc_excp_g = 
       (dmmu_va_oor_g & inst_vld_g) & ~(exu_ttype_vld_g | ifu_ttype_vld_g | 
        lsu_tlu_priv_action_g | misalign_addr_ldst_atm_g | lsu_tlu_wtchpt_trp_g); 
//
// added for timing 
dffr_s dffr_va_oor_data_acc_excp_w2 (
    .din (va_oor_data_acc_excp_g),
    .q   (va_oor_data_acc_excp_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// exu should qualify with priv bit. Assume ttype vld is asserted.
dff_s #(1) dff_stgg_sir_g (
    .din (ifu_tlu_sir_inst_m), 
	.q   (sir_inst_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	pstate_rmode[3:0] = tlu_int_redmode[3:0];

wire	intrpt_taken;
// recoded for bug 2644
// assign	intrpt_taken = rstint_taken | hwint_taken | swint_taken;  
assign	intrpt_taken = 
            rstint_taken | hwint_taken | sirint_taken;  
//
// modified for bug 4906
assign trp_lvl_at_maxtlless1 = 
           tpl_maxless1[0] | tpl_maxless1[1] | tpl_maxless1[2] | tpl_maxless1[3];
assign tpl_maxless1[0] =
           (trp_lvl0_at_maxtlless1 | pstate_rmode[0]) & thrd0_traps;
assign tpl_maxless1[1] =
           (trp_lvl1_at_maxtlless1 | pstate_rmode[1]) & thrd1_traps;
assign tpl_maxless1[2] =
           (trp_lvl2_at_maxtlless1 | pstate_rmode[2]) & thrd2_traps;
assign tpl_maxless1[3] =
           (trp_lvl3_at_maxtlless1 | pstate_rmode[3]) & thrd3_traps;

// thread enters redstate
// modified for bug 3919
// assign	trap_to_redmode = trp_lvl_at_maxtlless1 & ~intrpt_taken; 
assign	trap_to_redmode = trp_lvl_at_maxtlless1 & ~(rstint_taken | sirint_taken); 

assign	tlu_lsu_redmode_rst[0]	= 
	        ((rstint_taken |  sirint_taken) & thread0_rsel_g) | 
              tpl_maxless1[0] | internal_wdr_trap[0] | local_rst ;
assign	tlu_lsu_redmode_rst[1]	= 
	        ((rstint_taken |  sirint_taken) & thread1_rsel_g) | 
              tpl_maxless1[1] | internal_wdr_trap[1] | local_rst ;
assign	tlu_lsu_redmode_rst[2]	= 
	        ((rstint_taken |  sirint_taken) & thread2_rsel_g) | 
              tpl_maxless1[2] | internal_wdr_trap[2] | local_rst ;
assign	tlu_lsu_redmode_rst[3]	= 
	        ((rstint_taken |  sirint_taken) & thread3_rsel_g) | 
              tpl_maxless1[3] | internal_wdr_trap[3] | local_rst ;

dff_s #(4) dff_tlu_lsu_redmode_rst_d1 (
    .din (tlu_lsu_redmode_rst[4-1:0]),
	.q   (tlu_lsu_redmode_rst_d1[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign	redmode_insertion =
	local_rst | rstint_taken | trap_to_redmode | internal_wdr | sirint_taken;
//	sir_inst_g;					// sigm inst in priv mode
//
// added for timing
dff_s dff_redmode_insertion_w2 (
    .din (redmode_insertion),
	.q   (redmode_insertion_w2),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign	tlu_select_redmode =  redmode_insertion_w2;

// added for bug 2808
assign ibrkpt_trap_m = 
           (ifu_tlu_ttype_m[8:0]== 9'h076) & ifu_tlu_ttype_vld_m;  

dffr_s dffr_ibrkpt_trap_g (
   .din (ibrkpt_trap_m),
   .q   (ibrkpt_trap_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

dffr_s dffr_ibrkpt_trap_w2 (
   .din (ibrkpt_trap_g),
   .q   (ibrkpt_trap_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

// assign tlu_ibrkpt_trap_g = ibrkpt_trap_g;
assign tlu_ibrkpt_trap_w2 = ibrkpt_trap_w2;

// modified for bug 1575
// assign	tlu_pstate_din_sel[2]	= ~(tlu_pstate_din_sel[0] | tlu_pstate_din_sel[1]);

// the selection pstate by thread
// modified for the hypervisory support

assign	tlu_pstate_din_sel0[0]	= dnrtry_inst_w2[0] & ~rst_tri_en; 
assign	tlu_pstate_din_sel0[1]	= (pstate_rw_w2 & wsr_inst_w2) & ~rst_tri_en & 
                                 ~tlu_pstate_din_sel0[0] & thread0_wsel_w2;

assign	tlu_pstate_din_sel1[0]	= dnrtry_inst_w2[1] & ~rst_tri_en;
assign	tlu_pstate_din_sel1[1]	= (pstate_rw_w2 & wsr_inst_w2) & ~rst_tri_en & 
                                 ~tlu_pstate_din_sel1[0] & thread1_wsel_w2;

assign	tlu_pstate_din_sel2[0]	= dnrtry_inst_w2[2] & ~rst_tri_en; 
assign	tlu_pstate_din_sel2[1]	= (pstate_rw_w2 & wsr_inst_w2) & ~rst_tri_en & 
                                 ~tlu_pstate_din_sel2[0] & thread2_wsel_w2;

assign	tlu_pstate_din_sel3[0]	= dnrtry_inst_w2[3] & ~rst_tri_en;
assign	tlu_pstate_din_sel3[1]	= (pstate_rw_w2 & wsr_inst_w2) & ~rst_tri_en & 
                                 ~tlu_pstate_din_sel3[0] & thread3_wsel_w2;

assign	restore_pc_sel_g = (dnrtry_inst_g & cwp_fastcmplt_g) | cwp_cmplt_g; 
//
dffr_s dffr_restore_pc_sel_w1 (
   .din (restore_pc_sel_g),
   .q   (restore_pc_sel_w1),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign	tlu_restore_pc_sel_w1 = restore_pc_sel_w1; 
//
// modified for the hypervisor support and timing

assign	update_pstate_w2[0] = 
		thrd0_traps_w2 | dnrtry_inst_w2[0] | 
		((pstate_rw_w2 & wsr_inst_w2) & thread0_wsel_w2);
assign	update_pstate_w2[1] = 
		thrd1_traps_w2 | dnrtry_inst_w2[1] | 
		((pstate_rw_w2 & wsr_inst_w2) & thread1_wsel_w2);
assign	update_pstate_w2[2] = 
		thrd2_traps_w2 | dnrtry_inst_w2[2] | 
		((pstate_rw_w2 & wsr_inst_w2) & thread2_wsel_w2);
assign	update_pstate_w2[3] = 
		thrd3_traps_w2 | dnrtry_inst_w2[3] | 
		((pstate_rw_w2 & wsr_inst_w2) & thread3_wsel_w2);

// recoded for timing
// modified for bug 4284
assign	tlu_update_pc_l_w[0] = 	~(inst_vld_g & thread0_rsel_g);
assign	tlu_update_pc_l_w[1] = 	~(inst_vld_g & thread1_rsel_g);
assign	tlu_update_pc_l_w[2] = 	~(inst_vld_g & thread2_rsel_g);
assign	tlu_update_pc_l_w[3] = 	~(inst_vld_g & thread3_rsel_g);
//
// modified for timing 
assign tlu_thrd_wsel_w2[4-1:0] = 
           {thread3_wtrp_w2, thread2_wtrp_w2, thread1_wtrp_w2, thread0_wtrp_w2};

//wire	pending_thrd_event_taken_w2;
assign	pending_thrd_event_taken = 
	pending_thrd0_event_taken | pending_thrd1_event_taken |
	pending_thrd2_event_taken | pending_thrd3_event_taken;
//
// modified due to timing
assign	tlu_tl_gt_0_w2 =
		thrd_rsel_w2[0] ? tl0_gt_0 :
			(thrd_rsel_w2[1] ? tl1_gt_0 :
				(thrd_rsel_w2[2] ? tl2_gt_0 : tl3_gt_0)); 

assign	thrd_rsel_g[0] = 	(thread0_rsel_g & ~pending_thrd_event_taken) | pending_thrd0_event_taken;
assign	thrd_rsel_g[1] = 	(thread1_rsel_g & ~pending_thrd_event_taken) | pending_thrd1_event_taken;
assign	thrd_rsel_g[2] = 	(thread2_rsel_g & ~pending_thrd_event_taken) | pending_thrd2_event_taken;

dff_s #(4-1) dff_thrd_rsel_w2 (
    .din (thrd_rsel_g[4-2:0]),
    .q   (thrd_rsel_w2[4-2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified for the tsa_wdata bug (tlu_tdp)
//
// assign tlu_wr_tsa_inst_g = tsa_wr_tid_sel_g;
//
// added for timing
assign tlu_wr_tsa_inst_w2 = 
           (wsr_inst_w2 & (tstate_rw_w2 | tpc_rw_w2 | tnpc_rw_w2  | 
            ttype_rw_w2 | htstate_rw_w2)) & ~sync_trap_taken_w2; 

// assign tlu_wsr_inst_g = wsr_inst_g;
// 
// modified for timing
/*
assign tlu_update_pstate_l_g[0] = ~(update_pstate_g[0] | local_rst);
assign tlu_update_pstate_l_g[1] = ~(update_pstate_g[1] | local_rst);
assign tlu_update_pstate_l_g[2] = ~(update_pstate_g[2] | local_rst);
assign tlu_update_pstate_l_g[3] = ~(update_pstate_g[3] | local_rst);
*/
assign tlu_update_pstate_l_w2[0] = ~(update_pstate_w2[0] | local_rst);
assign tlu_update_pstate_l_w2[1] = ~(update_pstate_w2[1] | local_rst);
assign tlu_update_pstate_l_w2[2] = ~(update_pstate_w2[2] | local_rst);
assign tlu_update_pstate_l_w2[3] = ~(update_pstate_w2[3] | local_rst);

//=========================================================================================
// rdpr mux selects - recoded due to timing
//=========================================================================================
// modified for bug 1352 - added the non-privedged term in the read select
//
// modified for bug 1859
// assign	tlu_rdpr_mx1_sel[0] = tpc_rw_e; 
// assign	tlu_rdpr_mx1_sel[1] = tnpc_rw_e;
// assign	tlu_rdpr_mx1_sel[2] = tick_rw_e | tick_npriv_r_e;
// assign	tlu_rdpr_mx1_sel[3] = tickcmp_rw_e;
// assign	tlu_rdpr_mx2_sel[0] = tstate_rw_e; 
// assign	tlu_rdpr_mx2_sel[1] = tba_rw_e;
// assign	tlu_rdpr_mx2_sel[2] = sftint_rg_rw_e;
// assign	tlu_rdpr_mx3_sel[0] = ttype_rw_e; 
// assign	tlu_rdpr_mx3_sel[2] = tl_rw_e;
// assign	tlu_rdpr_mx3_sel[3] = pil_rw_e;
// assign	tlu_rdpr_mx4_sel[0] = (|tlu_rdpr_mx2_sel[`RDPR_MX2_SEL_WIDTH-1:0]) | tlu_htba_mx2_sel; 
// assign	tlu_rdpr_mx4_sel[1] = (ttype_rw_e & ttype_written) | pstate_rw_e | tl_rw_e | pil_rw_e;
// assign	tlu_rdpr_mx4_sel[2] =  tlu_rdpr_mx5_active;  
// assign	tlu_rdpr_mx6_sel[0] = (|tlu_rdpr_mx1_sel[3:0]); 
// assign	tlu_rdpr_mx6_sel[1] =  stickcmp_rw_e;  
// assign	tlu_rdpr_mx6_sel[2] =  tlu_htickcmp_rw_e; 
// assign	tlu_rdpr_mx7_sel[0] = |(tlu_rdpr_mx4_sel[2:0]);
// assign	tlu_rdpr_mx7_sel[1] = |(tlu_rdpr_mx6_sel[2:0]); 
// assign	tlu_rdpr_mx7_sel[2] = ttype_unwritten_sel;

assign	local_rdpr_mx1_sel[0] = tick_rw_e | tick_npriv_r_e;
assign	local_rdpr_mx1_sel[1] = tickcmp_rw_e;
assign	local_rdpr_mx1_sel[2] = stickcmp_rw_e;  
assign	local_rdpr_mx1_sel[3] = tlu_htickcmp_rw_e; 
//
assign	tlu_rdpr_mx1_sel[0] = local_rdpr_mx1_sel[1] & ~rst_tri_en; 
assign	tlu_rdpr_mx1_sel[1] = local_rdpr_mx1_sel[2] & ~rst_tri_en;
assign	tlu_rdpr_mx1_sel[2] = local_rdpr_mx1_sel[3] & ~rst_tri_en; 
//
assign	local_rdpr_mx2_sel[0] = tlu_hyperv_rdpr_sel[0];
assign	local_rdpr_mx2_sel[1] = tlu_hyperv_rdpr_sel[1];
assign	local_rdpr_mx2_sel[2] = tl_rw_e;
assign	local_rdpr_mx2_sel[3] = pil_rw_e;
//
assign	tlu_rdpr_mx2_sel[0] = local_rdpr_mx2_sel[1] & ~rst_tri_en;
assign	tlu_rdpr_mx2_sel[1] = local_rdpr_mx2_sel[2] & ~rst_tri_en;
assign	tlu_rdpr_mx2_sel[2] = local_rdpr_mx2_sel[3] & ~rst_tri_en; 
//
assign	local_rdpr_mx3_sel[0] = sftint_rg_rw_e;
assign	local_rdpr_mx3_sel[1] = pstate_rw_e;
assign	local_rdpr_mx3_sel[2] = tlu_hyperv_rdpr_sel[2];
//
assign	tlu_rdpr_mx3_sel[0] = local_rdpr_mx3_sel[1] & ~rst_tri_en; 
assign	tlu_rdpr_mx3_sel[1] = local_rdpr_mx3_sel[2] & ~rst_tri_en; 
//
assign	local_rdpr_mx4_sel[0] = tpc_rw_e; 
assign	local_rdpr_mx4_sel[1] = tnpc_rw_e;
assign	local_rdpr_mx4_sel[2] = tstate_rw_e; 
//
assign	tlu_rdpr_mx4_sel[0] = local_rdpr_mx4_sel[1] & ~rst_tri_en;
assign	tlu_rdpr_mx4_sel[1] = local_rdpr_mx4_sel[2] & ~rst_tri_en;
//
// modified for rte failures
assign  local_rdpr_mx5_sel[0] = tba_rw_e;
assign	local_rdpr_mx5_sel[1] = tlu_hyperv_rdpr_sel[4] & ~rst_tri_en;
assign	local_rdpr_mx5_sel[2] = (|local_rdpr_mx1_sel[3:0]) & ~rst_tri_en;
assign	local_rdpr_mx5_sel[3] = (pcr_rsr_e | pic_rsr_e) & ~rst_tri_en;
//
assign  tlu_rdpr_mx5_sel[0] = local_rdpr_mx5_sel[1];
assign	tlu_rdpr_mx5_sel[1] = local_rdpr_mx5_sel[2];
assign	tlu_rdpr_mx5_sel[2] = local_rdpr_mx5_sel[3]; 
//
assign	tlu_rdpr_mx6_sel[0] = local_rdpr_mx6_sel[1]; 
assign	tlu_rdpr_mx6_sel[1] = local_rdpr_mx6_sel[2];
assign	tlu_rdpr_mx6_sel[2] = local_rdpr_mx6_sel[3];
// 
assign	local_rdpr_mx6_sel[0] = ttype_rw_e; 
assign	local_rdpr_mx6_sel[1] = tlu_hyperv_rdpr_sel[3] & ~rst_tri_en;
assign	local_rdpr_mx6_sel[2] = (|local_rdpr_mx2_sel[3:0]) & ~rst_tri_en;
assign	local_rdpr_mx6_sel[3] = (|local_rdpr_mx3_sel[2:0]) & ~rst_tri_en;
//
assign	tlu_rdpr_mx7_sel[0] = (|local_rdpr_mx4_sel[2:0]) & ~rst_tri_en; 
assign	tlu_rdpr_mx7_sel[1] = (|local_rdpr_mx5_sel[3:0]) & ~rst_tri_en; 
assign	tlu_rdpr_mx7_sel[2] = (|local_rdpr_mx6_sel[3:0]) & ~rst_tri_en; 
assign	tlu_rdpr_mx7_sel[3] = ~(|tlu_rdpr_mx7_sel[2:0]); 

//=========================================================================================

assign	ttype_written = (thread0_rsel_e & ~tt_unwritten[0]) |
			(thread1_rsel_e & ~tt_unwritten[1]) |
			(thread2_rsel_e & ~tt_unwritten[2]) |
			(thread3_rsel_e & ~tt_unwritten[3]);

assign	ttype_unwritten_sel = ttype_rw_e & ~ttype_written;

//
// constructing the mux select for rdpr 7 in tdp
//

//=========================================================================================

dff_s #(2) dff_stgdntry_m (
    .din ({done_inst_e,retry_inst_e}), 
	.q   ({done_inst_m_tmp,retry_inst_m_tmp}),
    .clk (clk),
    .se  (se),       
    .si  (),
    .so  ()
);

wire	trap_on_dnrtry_m; 
// priv opcode, illegal inst trap on done/retry.
assign	trap_on_dnrtry_m =  ifu_ttype_vld_m ;

// qualification done with previous instruction's flush pipe 
// the inst_vld may have to be sent earlier to avoid the critical path.
// modified for bug 4074 and 4561
assign	done_inst_m  = 
            done_inst_m_tmp  & ~(((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
            tlu_ifu_flush_pipe_w) | trap_on_dnrtry_m);
/*
            done_inst_m_tmp  & ~(((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
            tlu_ifu_flush_pipe_w) | ((thrid_w2[1:0] == tlu_exu_tid_m[1:0]) &
            lsu_defr_trap_g) | trap_on_dnrtry_m);
*/
assign	retry_inst_m = 
            retry_inst_m_tmp & ~(((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
            tlu_ifu_flush_pipe_w) | trap_on_dnrtry_m);
/*
            retry_inst_m_tmp & ~(((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
            tlu_ifu_flush_pipe_w) | ((thrid_w2[1:0] == tlu_exu_tid_m[1:0]) &
            lsu_defr_trap_g) | trap_on_dnrtry_m);
*/
/*
// logic moved to tlu_misctl
// modified/added for timing violations
// moved the logic from exu to tlu due to timing violations

mux4ds #(3) mux_trap_old_cwp_m(
    .in0(exu_tlu_cwp0[2:0]),
    .in1(exu_tlu_cwp1[2:0]), 
    .in2(exu_tlu_cwp2[2:0]),
    .in3(exu_tlu_cwp3[2:0]),
    .sel0(thread0_rsel_m),
    .sel1(thread1_rsel_m),
    .sel2(thread2_rsel_m),
    .sel3(thread3_rsel_m),
    .dout(trap_old_cwp_m[2:0])
);

assign cwp_xor_m[2:0] = trap_old_cwp_m[2:0] ^ tlu_exu_cwp_m[2:0];

assign cwp_no_change_m = ~|(cwp_xor_m[2:0]); 
*/
assign cwp_fastcmplt_m = 
           tlu_exu_cwpccr_update_m & tlu_cwp_no_change_m;

dffr_s dffr_cwp_fastcmplt_uq_g (
    .din (cwp_fastcmplt_m),
	.q   (cwp_fastcmplt_uq_g),
    .clk (clk),
    .rst (local_rst),
    .se  (se),
    .si  (),
    .so  ()
);

// assign	tlu_exu_cwpccr_update_m = done_inst_m | retry_inst_m;
assign	tlu_exu_cwpccr_update_m = exu_done_inst_m | exu_retry_inst_m;

assign exu_done_inst_m  = 
           done_inst_m_tmp; // & ~(ifu_tlu_ttype_vld_m & ifu_tlu_inst_vld_m); 
assign exu_retry_inst_m = 
           retry_inst_m_tmp;// & ~(ifu_tlu_ttype_vld_m & ifu_tlu_inst_vld_m);

//
// modified due timing problems 
// assign	tlu_exu_cwp_retry_m = retry_inst_m; 
assign	tlu_exu_cwp_retry_m = exu_retry_inst_m; 

// qualify with flush ?
// modified for timing and bug4658 
// modified for timing and added the omitted tlz trap qualification

assign	true_pc_sel_m[0] =  
            retry_inst_m_tmp & ~ifu_tlu_trap_m & ifu_tlu_inst_vld_m &
            ~(pib_wrap_trap_m | (|tlz_trap_m[4-1:0])); 
assign	true_pc_sel_m[1]  = 
            done_inst_m_tmp  & ~ifu_tlu_trap_m & ifu_tlu_inst_vld_m &
            ~(pib_wrap_trap_m | (|tlz_trap_m[4-1:0])) ; 

assign	true_pc_sel_m[2]  = ~(|true_pc_sel_m[1:0]);

dffr_s #(3) dff_true_pc_sel_w (
    .din (true_pc_sel_m[2:0]), 	
    .q   (true_pc_sel_w[2:0]),
    .clk (clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(49) dff_ifu_npc_w (
    .din (ifu_tlu_npc_m[48:0]), 	
    .q   (ifu_npc_w[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_true_pc_sel_w[2:0] = true_pc_sel_w[2:0];

dff_s #(2) dff_stgdntry_g (
    .din ({done_inst_m,retry_inst_m}),
	.q   ({done_inst_g_tmp,retry_inst_g_tmp}),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	done_inst_g = done_inst_g_tmp & inst_vld_g;
assign	retry_inst_g = retry_inst_g_tmp & inst_vld_g;

//assign	tlu_retry_inst_g = retry_inst_g;
//assign	tlu_done_inst_g  = done_inst_g;
// 
// threaded dnrtry_inst_g signal
// modified for timing 
//
assign	dnrtry0_inst_g = (done_inst_g | retry_inst_g) & 
                        ~(inst_ifu_flush2_w | local_early_flush_pipe_w) & 
                          thread0_rsel_g;

assign	dnrtry1_inst_g = (done_inst_g | retry_inst_g) & 
                        ~(inst_ifu_flush2_w | local_early_flush_pipe_w) & 
                          thread1_rsel_g;

assign	dnrtry2_inst_g = (done_inst_g | retry_inst_g) & 
                        ~(inst_ifu_flush2_w | local_early_flush_pipe_w) & 
                          thread2_rsel_g;

assign	dnrtry3_inst_g = (done_inst_g | retry_inst_g) & 
                        ~(inst_ifu_flush2_w | local_early_flush_pipe_w) & 
                          thread3_rsel_g;
//
// added for timing
dffr_s #(4) dffr_dnrtry_inst_w2 (
    .din ({dnrtry3_inst_g,dnrtry2_inst_g,dnrtry1_inst_g,dnrtry0_inst_g}),
    .q   (dnrtry_inst_w2[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign  tlu_dnrtry0_inst_g = dnrtry0_inst_g;
assign  tlu_dnrtry1_inst_g = dnrtry1_inst_g;
assign  tlu_dnrtry2_inst_g = dnrtry2_inst_g;
assign  tlu_dnrtry3_inst_g = dnrtry3_inst_g;

// flush needed for done/retry with tl=0
// modified for timing
// assign	dnrtry_inst_g = (done_inst_g | retry_inst_g) & ~tlu_flush_pipe_w;
// 
assign	dnrtry_inst_g = (done_inst_g | retry_inst_g) & 
                       ~(inst_ifu_flush_w | local_early_flush_pipe_w);
dff_s #(2) dff_stgdntry_e (
    .din ({ifu_tlu_done_inst_d,ifu_tlu_retry_inst_d}), 
	.q   ({done_inst_e,retry_inst_e}),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	thrid_d[1:0] = ifu_tlu_thrid_d[1:0];

assign	thread0_rsel_d = ~thrid_d[1] & ~thrid_d[0];
assign	thread1_rsel_d = ~thrid_d[1] &  thrid_d[0];
assign	thread2_rsel_d =  thrid_d[1] & ~thrid_d[0];
assign	thread3_rsel_d =  thrid_d[1] &  thrid_d[0];

//
// modified due to rte failure 
dff_s #(2) dff_thrid_e (
    .din (thrid_d[1:0]),
	.q   (thrid_e[1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(2) dff_thrid_m (
    .din (thrid_e[1:0]),
    .q   (thrid_m[1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(2) dff_thrid_g (
    .din (thrid_m[1:0]),
    .q   (thrid_g[1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	thread0_rsel_e = ~(|thrid_e[1:0]); 
assign	thread1_rsel_e = ~thrid_e[1] &  thrid_e[0]; 
assign	thread2_rsel_e =  thrid_e[1] & ~thrid_e[0]; 
assign	thread3_rsel_e =  (&thrid_e[1:0]);

assign	tlu_thrd_rsel_e[0] = thread0_rsel_e; 
assign	tlu_thrd_rsel_e[1] = thread1_rsel_e;
assign	tlu_thrd_rsel_e[2] = thread2_rsel_e;
assign	tlu_thrd_rsel_e[3] = thread3_rsel_e;
//
// added for timing
dff_s #(4) dff_thread_stg_m (
    .din ({thread3_rsel_e, thread2_rsel_e, thread1_rsel_e, thread0_rsel_e}),
    .q   ({thread3_stg_m, thread2_stg_m, thread1_stg_m, thread0_stg_m}),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign thread0_stg_m_buf = thread0_stg_m;
assign thread1_stg_m_buf = thread1_stg_m;
assign thread2_stg_m_buf = thread2_stg_m;
assign thread3_stg_m_buf = thread3_stg_m;

assign	thread0_rsel_m = ~(|thrid_m[1:0]); 
assign	thread1_rsel_m = ~thrid_m[1] &  thrid_m[0]; 
assign	thread2_rsel_m =  thrid_m[1] & ~thrid_m[0]; 
assign	thread3_rsel_m =  (&thrid_m[1:0]);

assign	thread0_rsel_dec_g = ~(|thrid_g[1:0]); 
assign	thread1_rsel_dec_g = ~thrid_g[1] &  thrid_g[0]; 
assign	thread2_rsel_dec_g =  thrid_g[1] & ~thrid_g[0]; 
assign	thread3_rsel_dec_g =  (&thrid_g[1:0]);

dff_s #(4) dff_thread_rsel_g (
    .din ({thread3_rsel_m, thread2_rsel_m, thread1_rsel_m, thread0_rsel_m}),
    .q   ({thread3_rsel_g, thread2_rsel_g, thread1_rsel_g, thread0_rsel_g}),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(4) dff_thread_wsel_g (
    .din ({thread3_rsel_m, thread2_rsel_m, thread1_rsel_m, thread0_rsel_m}),
    .q   ({thread3_wsel_g, thread2_wsel_g, thread1_wsel_g, thread0_wsel_g}),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// timing -fix: load redistribution
/*
assign	thread0_rsel_g = thread0_rsel_dec_g; 
assign	thread1_rsel_g = thread1_rsel_dec_g; 
assign	thread2_rsel_g = thread2_rsel_dec_g; 
assign	thread3_rsel_g = thread3_rsel_dec_g; 
*/
// 

dff_s #(2) dff_stgdntry_w2 (
    .din ({done_inst_g,retry_inst_g}),
	.q   ({done_inst_w2,retry_inst_w2}),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified for bug 4561
assign inst_vld_m = 
           ifu_tlu_inst_vld_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
           (tlu_flush_pipe_w | inst_ifu_flush_w)); 
/*
assign inst_vld_m = 
           ifu_tlu_inst_vld_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
           (tlu_flush_pipe_w | inst_ifu_flush_w)) & ~((thrid_w2[1:0] == tlu_exu_tid_m[1:0]) & 
            lsu_defr_trap_g);
*/
//

assign tlu_inst_vld_nq_m = 
           ifu_tlu_inst_vld_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
           tlu_flush_all_w);

dff_s dff_stgivld_g (
    .din (inst_vld_m),
    .q   (inst_vld_nf_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified for timing
/*
dffr_s dffr_inst_ifu_flush_w (
    .din (ifu_tlu_flush_m),
	.q   (inst_ifu_flush_w),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
assign inst_ifu_flush_w  = ifu_tlu_flush_fd_w;
assign inst_ifu_flush2_w = ifu_tlu_flush_fd_w;

// added for bug 2133
assign inst_vld_g = 
       inst_vld_nf_g & ~(inst_ifu_flush_w | lsu_tlu_defr_trp_taken_g);
       // modified for bug 4561
       // inst_vld_nf_g & ~(inst_ifu_flush_w | lsu_tlu_defr_trp_taken_g | 
       // ((thrid_w2[1:0] == thrid_g[1:0]) & lsu_defr_trap_g));

dff_s dff_stgivld_w2 (
    .din (inst_vld_g),
	.q   (inst_vld_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified due to timing
// assign	cwp_fastcmplt_g = cwp_fastcmplt_w & inst_vld_g;
assign	cwp_fastcmplt_g = cwp_fastcmplt_uq_g & inst_vld_g;

dff_s dff_stgfcmplt_w2 (
    .din (cwp_fastcmplt_g),
	.q   (cwp_fastcmplt_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// The stage name assignment may have to be changed !!
// done/retry qualified with inst_vld as it could be flushed.
assign	tlu_ifu_trappc_vld_w1 	=	((retry_inst_w2 | done_inst_w2) & inst_vld_w2 & cwp_fastcmplt_w2) | 
					thrd0_traps_w2 | thrd1_traps_w2 |
					thrd2_traps_w2 | thrd3_traps_w2 | cwp_cmplt_w2;	   
					//thrd2_traps_w2 | thrd3_traps_w2) & inst_vld_w2 | cwp_cmplt_w2;	   
assign	tlu_ifu_trapnpc_vld_w1 	= 	(retry_inst_w2 & inst_vld_w2 & cwp_fastcmplt_w2) |
					thrd0_traps_w2 | thrd1_traps_w2 |
					thrd2_traps_w2 | thrd3_traps_w2 | cwp_cmplt_rtry_w2;
					//) & inst_vld_w2 | cwp_cmplt_w2;	   
//
// modified for hypervisor support
// assign	tlu_ifu_trap_tid_w1[1:0]=	cwp_cmplt_w2 ? cwp_cmplt_tid_w2[1:0] : trap_tid_w2[1:0];
//
// recoded for timing
// assign	true_trap_tid_g[1:0] = cwp_cmplt_g ? cwp_cmplt_tid_g[1:0] : trap_tid_g[1:0];
// modified for bug 4091 and 4491
/*
assign early_trap_tid_g[1:0] = 
	       (((hwint_g | pib_wrap_trap_g| local_early_flush_pipe_w) & 
              ~(ifu_tlu_flush_fd_w | local_lsu_defr_trp_taken_g)) | 
           (dnrtry_inst_g & cwp_fastcmplt_g) | rstint_g) ? thrid_g[1:0] : pend_trap_tid_g[1:0]; 
*/
assign early_trap_tid_g[1:0] = 
	       (((hwint_g | pib_wrap_trap_g| local_early_flush_pipe_w) & ~ifu_tlu_flush_fd_w) | 
           (dnrtry_inst_g & cwp_fastcmplt_g) | rstint_g) ? thrid_g[1:0] : pend_trap_tid_g[1:0]; 
//
// modified for bug 4561
assign	true_trap_tid_g[1:0] = 
             // (lsu_defr_trap_g) ? thrid_w2[1:0]  : 
             (dside_sync_trap_g | lsu_defr_trap_g) ? thrid_g[1:0] :
              early_trap_tid_g[1:0];

dff_s #(2) dff_true_trap_tid_w2 (
    .din (true_trap_tid_g[1:0]),
    .q   (true_trap_tid_w2[1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
assign tlu_ifu_trap_tid_w1[1:0] = true_trap_tid_w2[1:0];

// determine the mode of operation for the trapped thread
// modified for timing 
/*
assign tlu_trap_hpstate_enb = 
           (~(|true_trap_tid_g[1:0]))? tlu_hpstate_enb[0]:
               ((~true_trap_tid_g[1] & true_trap_tid_g[0])? tlu_hpstate_enb[1]:
                   ((true_trap_tid_g[1] & ~true_trap_tid_g[0])? tlu_hpstate_enb[2]: 
                       tlu_hpstate_enb[3]));
*/
assign tlu_trap_hpstate_enb = 
           (~(|true_trap_tid_w2[1:0]))? tlu_hpstate_enb[0]:
               ((~true_trap_tid_w2[1] & true_trap_tid_w2[0])? tlu_hpstate_enb[1]:
                   ((true_trap_tid_w2[1] & ~true_trap_tid_w2[0])? tlu_hpstate_enb[2]: 
                       tlu_hpstate_enb[3]));

//=========================================================================================
//	Local Exceptions within TLU/MMU
//=========================================================================================

// These are to be merged with lsu reported exceptions.
// 
// modified due to early_flush timing fix
// assign	local_sync_trap_g = tlu_mmu_sync_data_excp_g;
// 
// modified for hypervisor support
// modified for timing 
assign	local_sync_trap_m =  
               (true_hscpd_dacc_excpt_m | true_qtail_dacc_excpt_m) & inst_vld_m;
// 
// added for dsfsr bug
assign	tlu_lsu_priv_trap_m =  
               (true_hscpd_dacc_excpt_m | true_qtail_dacc_excpt_m); 
//
/*
// added for timing
dffr_s dffr_tlu_lsu_priv_trap_w  (
    .din (tlu_lsu_priv_trap_m),
    .q   (tlu_lsu_priv_trap_w),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
*/
// added for timing 
// modified for bug 3618
assign true_hscpd_dacc_excpt_m = 
           tlu_hscpd_dacc_excpt_m &
           ((thread0_stg_m_buf & ~tlu_hyper_lite[0]) |
            (thread1_stg_m_buf & ~tlu_hyper_lite[1]) |
            (thread2_stg_m_buf & ~tlu_hyper_lite[2]) |
            (thread3_stg_m_buf & ~tlu_hyper_lite[3])); 

assign true_qtail_dacc_excpt_m = 
           ((thread0_stg_m_buf & tlu_hpstate_enb[0] &  ~tlu_hpstate_priv[0] & 
             tlu_pstate_priv_buf[0])  |
            (thread1_stg_m_buf & tlu_hpstate_enb[1] &  ~tlu_hpstate_priv[1] & 
             tlu_pstate_priv_buf[1])  |
            (thread2_stg_m_buf & tlu_hpstate_enb[2] &  ~tlu_hpstate_priv[2] & 
             tlu_pstate_priv_buf[2])  |
            (thread3_stg_m_buf & tlu_hpstate_enb[3] &  ~tlu_hpstate_priv[3] & 
             tlu_pstate_priv_buf[3])) & tlu_qtail_dacc_excpt_m;

dffr_s dffr_local_sync_trap_g  (
    .din (local_sync_trap_m),
    .q   (local_sync_trap_g),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
//	Queuing traps
//=========================================================================================

// For current instr, prioritize traps across pipe. There are 3 synchronous sources :
// ifu,exu,lsu. Assume ifu traps have highest priority so compare has to be done
// only between exu and lsu traps.

// added for timing; moved qualification from IFU to TLU
assign	ifu_rstint_m = 
        ifu_tlu_rstint_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
        tlu_flush_all_w) & inst_vld_m;
assign	ifu_hwint_m = 
        ifu_tlu_hwint_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
        tlu_flush_all_w) & inst_vld_m;
assign	ifu_swint_m = 
        ifu_tlu_swint_m & ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & 
        tlu_flush_all_w) & inst_vld_m;

// generate the thread specific ifu flush signal - added for bug 2133
assign ifu_thrd_flush_w[0] = inst_ifu_flush2_w & thread0_rsel_dec_g;  
assign ifu_thrd_flush_w[1] = inst_ifu_flush2_w & thread1_rsel_dec_g;  
assign ifu_thrd_flush_w[2] = inst_ifu_flush2_w & thread2_rsel_dec_g;  
assign ifu_thrd_flush_w[3] = inst_ifu_flush2_w & thread3_rsel_dec_g;  


// INTERRUPT
dff_s #(9) dff_stgint_g (
   .din ({ifu_rstint_m,ifu_hwint_m,ifu_swint_m,int_tlu_rstid_m[5:0]}),
   .q   ({rstint_g,hwint_g,swint_g,rstid_g[5:0]}),
   .clk	(clk),
   .se  (se),
   .si  (),
   .so  ()
);

// Determine type of reset. Type of reset determines what state gets updated.
// This is the same as wrm reset !!! Can we then turn off writes to TNPC, TPC ???
assign	por_rstint_g = ((rstid_g[5:0] == 6'h01) & rstint_g);
assign	por_rstint0_g = por_rstint_g & thread0_rsel_g;
assign	por_rstint1_g = por_rstint_g & thread1_rsel_g;
assign	por_rstint2_g = por_rstint_g & thread2_rsel_g;
assign	por_rstint3_g = por_rstint_g & thread3_rsel_g;
// 
// added for bug 4749 
assign	xir_rstint_g = ((rstid_g[5:0] == 6'h03) & rstint_g);

dff_s dff_por_rstint_w2 (
    .din (por_rstint_g),
	.q   (por_rstint_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	por_rstint0_w2 = por_rstint_w2 & thread0_wsel_w2;
assign	por_rstint1_w2 = por_rstint_w2 & thread1_wsel_w2;
assign	por_rstint2_w2 = por_rstint_w2 & thread2_wsel_w2;
assign	por_rstint3_w2 = por_rstint_w2 & thread3_wsel_w2;

assign	tlu_por_rstint_g[0]  = por_rstint0_g;
assign	tlu_por_rstint_g[1]  = por_rstint1_g;
assign	tlu_por_rstint_g[2]  = por_rstint2_g;
assign	tlu_por_rstint_g[3]  = por_rstint3_g;

assign 	rstint_taken = rstint_g & inst_vld_g; 

// hwint needs to be requalified with pstate.ie. IFU will replay hwint in
// case dropped. IFU needs to source thread id in the form of ifu_tlu_thrid_d.
assign 	hwint_taken = hwint_g & inst_vld_g; 
//
// modified for bug 5127
// assign 	sirint_taken = sir_inst_g & inst_vld_g; 
assign 	sirint_taken = 
            sir_inst_g & inst_vld_g  & ~(pib_wrap_trap_nq_g | 
            lsu_tlu_defr_trp_taken_g | (|tlz_trap_g[4-1:0])); 

assign 	swint_taken = swint_g & inst_vld_g; 

/*
assign	swint_thrd0_taken = swint_taken & thread0_rsel_g & tlu_int_pstate_ie[0];
assign	swint_thrd1_taken = swint_taken & thread1_rsel_g & tlu_int_pstate_ie[1];
assign	swint_thrd2_taken = swint_taken & thread2_rsel_g & tlu_int_pstate_ie[2];
assign	swint_thrd3_taken = swint_taken & thread3_rsel_g & tlu_int_pstate_ie[3];
//
//modified for hypervisor support
assign	swint_id[3:0]	=
	swint_thrd0_taken ? sftint0_id[3:0] :
		swint_thrd1_taken ? sftint1_id[3:0] :
			swint_thrd2_taken ? sftint2_id[3:0] :
				swint_thrd3_taken ? sftint3_id[3:0] :
					4'bxxxx;
*/
//
//added for timing 
dffr_s #(4) dffr_tlu_cpu_mondo_trap (
    .din (tlu_cpu_mondo_cmp[4-1:0]),
    .q   (tlu_cpu_mondo_trap[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
dffr_s #(4) dffr_tlu_dev_mondo_trap (
    .din (tlu_dev_mondo_cmp[4-1:0]),
    .q   (tlu_dev_mondo_trap[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s #(4) dffr_tlu_resum_err_trap (
    .din (tlu_resum_err_cmp[4-1:0]),
    .q   (tlu_resum_err_trap[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
assign cpu_mondo_trap_g =
       (thread0_wsel_g)? tlu_cpu_mondo_trap[0]:
       (thread1_wsel_g)? tlu_cpu_mondo_trap[1]:
       (thread2_wsel_g)? tlu_cpu_mondo_trap[2]:
       tlu_cpu_mondo_trap[3];

assign dev_mondo_trap_g =
       (thread0_wsel_g)? tlu_dev_mondo_trap[0]:
       (thread1_wsel_g)? tlu_dev_mondo_trap[1]:
       (thread2_wsel_g)? tlu_dev_mondo_trap[2]:
       tlu_dev_mondo_trap[3];

assign sftint_id_w2[3:0] =
       (thread0_wsel_w2)? sftint0_id[3:0]:
       (thread1_wsel_w2)? sftint1_id[3:0]: 
       (thread2_wsel_w2)? sftint2_id[3:0]:
        sftint3_id[3:0];

dffr_s dffr_cpu_mondo_trap_w2 (
    .din (cpu_mondo_trap_g),
    .q   (cpu_mondo_trap_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_dev_mondo_trap_w2 (
    .din (dev_mondo_trap_g),
    .q   (dev_mondo_trap_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign final_swint_id_w2[6:0] =
       (cpu_mondo_trap_w2)? 7'h7c :
       (dev_mondo_trap_w2)? 7'h7d :
        {3'b100, sftint_id_w2[3:0]};

// recoded for timing for bug 5117
/*
assign final_swint0_id[6:0] =
	tlu_cpu_mondo_trap[0] ? `CPU_MONDO_TRAP : 
		((tlu_dev_mondo_trap[0] & ~tlu_cpu_mondo_trap[0]) ? `DEV_MONDO_TRAP :
		      {3'b100, sftint0_id[3:0]});	

assign final_swint1_id[6:0] =
	tlu_cpu_mondo_trap[1] ? `CPU_MONDO_TRAP : 
		((tlu_dev_mondo_trap[1] & ~tlu_cpu_mondo_trap[1]) ? `DEV_MONDO_TRAP :
		      {3'b100, sftint1_id[3:0]});	

assign final_swint2_id[6:0] =
	tlu_cpu_mondo_trap[2] ? `CPU_MONDO_TRAP : 
		((tlu_dev_mondo_trap[2] & ~tlu_cpu_mondo_trap[2]) ? `DEV_MONDO_TRAP :
		      {3'b100, sftint2_id[3:0]});	

assign final_swint3_id[6:0] =
	tlu_cpu_mondo_trap[3] ? `CPU_MONDO_TRAP : 
		((tlu_dev_mondo_trap[3] & ~tlu_cpu_mondo_trap[3]) ? `DEV_MONDO_TRAP :
		      {3'b100, sftint3_id[3:0]});	

assign final_swint_id[6:0]	=
	swint_thrd0_taken ? final_swint0_id[6:0] :
		swint_thrd1_taken ? final_swint1_id[6:0] :
			swint_thrd2_taken ? final_swint2_id[6:0] :
				swint_thrd3_taken ? final_swint3_id[6:0] :
					7'bxxxxxxx;
*/

// Assume rstid(interrupt/reset vector) is the same as trap type.
// Need to confirm !!!!
// sftware sir is generated by ifu decode.
// ttype for internal wdr is tt of trap itself.

// sir inst at maxtl can result entry to error state and thus wdr
// modified for bug 4749 and 4906
assign internal_wdr_trap[0] = 
           (thrd0_traps & trp_lvl0_at_maxtl) & 
          ~((por_rstint_g | xir_rstint_g) & thread0_rsel_g);
assign internal_wdr_trap[1] = 
           (thrd1_traps & trp_lvl1_at_maxtl) & 
          ~((por_rstint_g | xir_rstint_g) & thread1_rsel_g);
assign internal_wdr_trap[2] = 
           (thrd2_traps & trp_lvl2_at_maxtl) & 
          ~((por_rstint_g | xir_rstint_g) & thread2_rsel_g);
assign internal_wdr_trap[3] = 
           (thrd3_traps & trp_lvl3_at_maxtl) & 
          ~((por_rstint_g | xir_rstint_g) & thread3_rsel_g);

assign internal_wdr = 
           internal_wdr_trap[0] | internal_wdr_trap[1] |
           internal_wdr_trap[2] | internal_wdr_trap[3];
/*
assign	internal_wdr = 
		((thrd0_traps & trp_lvl0_at_maxtl) |
		(thrd1_traps & trp_lvl1_at_maxtl) |
		(thrd2_traps & trp_lvl2_at_maxtl) |
		(thrd3_traps & trp_lvl3_at_maxtl)) & 
       ~(por_rstint_g | xir_rstint_g);
*/
//
// modified for bug 4640 and bug5127 
assign 	tlu_self_boot_rst_g = 
              rstint_g | internal_wdr | (sir_inst_g & 
              ~(lsu_defr_trap_g | pib_wrap_trap_g | 
               (|tlz_trap_g[4-1:0]))) | trap_to_redmode;
              // (rstint_g | internal_wdr | (sir_inst_g & ~lsu_defr_trap_g) |
               
//
// added for timing; moved qualification from IFU to TLU
// modified for bug 4561
assign	ifu_ttype_vld_m = 
            ifu_tlu_ttype_vld_m & 
            ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & tlu_flush_pipe_w);
/*
assign	ifu_ttype_vld_m = 
            ifu_tlu_ttype_vld_m & 
            ~((thrid_g[1:0] == tlu_exu_tid_m[1:0]) & tlu_flush_pipe_w) & 
            ~((thrid_w2[1:0] == tlu_exu_tid_m[1:0]) & lsu_defr_trap_g);
*/

// REGULAR TRAP
dff_s #(20) dff_stgeftt_g (
    .din ({exu_tlu_ttype_m[8:0],exu_tlu_ttype_vld_m,ifu_tlu_ttype_m[8:0],ifu_ttype_vld_m}), 
    .q   ({exu_ttype_g[8:0],exu_ttype_vld_g,ifu_ttype_tmp_g[8:0],ifu_ttype_vld_tmp_g}), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// added for bug 1293
// added spu_tlu_rsrv_illgl_m2 to account for the new illeg_instr from spu
//
// modified for the hypervisor support - wsr_illeg_globals_g is no longer necessary
// modified for pib support and timing fixes 
/*
assign ifu_ttype_g[8:0] = //((wsr_illeg_globals_g | spu_tlu_rsrv_illgl_m2) & 
                          (spu_tlu_rsrv_illgl_m2 & 
                         ~(ifu_ttype_tmp_g & (ifu_ttype_tmp_g < 9'h012)) &
                         ~immu_miss_g) ? 
                           9'h010 :
                          ((tlu_tick_npt_priv_act) ? 9'h037 : 
                          ifu_ttype_tmp_g); 
*/
//
// determine whether the processor is in user mode
assign tlu_none_priv[0] = ~(tlu_hpstate_priv[0] | tlu_pstate_priv_buf[0]);
assign tlu_none_priv[1] = ~(tlu_hpstate_priv[1] | tlu_pstate_priv_buf[1]);
assign tlu_none_priv[2] = ~(tlu_hpstate_priv[2] | tlu_pstate_priv_buf[2]);
assign tlu_none_priv[3] = ~(tlu_hpstate_priv[3] | tlu_pstate_priv_buf[3]);

assign tlu_hyper_lite[0] = 
           tlu_hpstate_priv[0]| (~tlu_hpstate_enb[0] & tlu_pstate_priv_buf[0]); 
assign tlu_hyper_lite[1] = 
           tlu_hpstate_priv[1]| (~tlu_hpstate_enb[1] & tlu_pstate_priv_buf[1]); 
assign tlu_hyper_lite[2] = 
           tlu_hpstate_priv[2]| (~tlu_hpstate_enb[2] & tlu_pstate_priv_buf[2]); 
assign tlu_hyper_lite[3] = 
           tlu_hpstate_priv[3]| (~tlu_hpstate_enb[3] & tlu_pstate_priv_buf[3]); 
//
// htrap instruction illegal instruction trap  
// this trap is taken only in hypervisor mode and not in hyper-lite
// mode
assign tlu_none_priv_m = 
          (tlu_none_priv[0] & tlu_hpstate_enb[0] & thread0_rsel_m) |
          (tlu_none_priv[1] & tlu_hpstate_enb[1] & thread1_rsel_m) |
          (tlu_none_priv[2] & tlu_hpstate_enb[2] & thread2_rsel_m) |
          (tlu_none_priv[3] & tlu_hpstate_enb[3] & thread3_rsel_m);

assign htrap_ill_inst_m = 
    (exu_tlu_ttype_vld_m &  exu_tlu_ttype_m[8] & 
     exu_tlu_ttype_m[7]) &  tlu_none_priv_m;

dffr_s dffr_htrap_ill_inst_uf_g (
   .din (htrap_ill_inst_m),
   .q   (htrap_ill_inst_uf_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign htrap_ill_inst_g = htrap_ill_inst_uf_g & ~inst_ifu_flush_w;
// 
// added for timing fix
assign spu_ill_inst_m = spu_tlu_rsrv_illgl_m & inst_vld_m;

dffr_s dffr_spu_ill_inst_uf_g (
   .din (spu_ill_inst_m),
   // modified for bug 2133
   // .q   (spu_ill_inst_g),
   .q   (spu_ill_inst_uf_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);


// 
// added for bug 2133
// modified at Farnad's request for bug 3599
// modified back to the old behavior (pre bug 3599) due to bug 4698
assign spu_ill_inst_g = 
//             spu_ill_inst_uf_g & ~(inst_ifu_flush_w); 
// fix for bug 5863. Only a stxa to asi=40 with opcode-rsvd should cause an illgl_va
           spu_ill_inst_uf_g & ~(inst_ifu_flush_w | lsu_tlu_early_flush_w);

assign ffu_higher_pri_g = 
           ffu_ill_inst_g & (ifu_ttype_vld_tmp_g & (ifu_ttype_tmp_g == 9'h020));

//
assign ifu_ttype_g[8:0] = (((spu_ill_inst_g  | ffu_ill_inst_g | htrap_ill_inst_g) & 
                         ~(ifu_ttype_vld_tmp_g   & (ifu_ttype_tmp_g < 9'h012)) &
                         ~immu_miss_g) | ffu_higher_pri_g) ? 
                           9'h010 :
                          ((tick_npt_priv_act_g | 
                           (pib_priv_act_trap_g & ~ifu_ttype_vld_tmp_g)) ? 9'h037 : 
                           ifu_ttype_tmp_g); 
//
// added for timing fix
assign pib_priv_act_early_trap_m = 
           ((pib_priv_act_trap_m[0] & inst_vld_m & thread0_rsel_m) & 
             ~(tlu_pstate_priv_buf[0] | tlu_hpstate_priv[0])) |
           ((pib_priv_act_trap_m[1] & inst_vld_m & thread1_rsel_m) & 
             ~(tlu_pstate_priv_buf[1] | tlu_hpstate_priv[1])) |
           ((pib_priv_act_trap_m[2] & inst_vld_m & thread2_rsel_m) & 
             ~(tlu_pstate_priv_buf[2] | tlu_hpstate_priv[2])) |
           ((pib_priv_act_trap_m[3] & inst_vld_m & thread3_rsel_m) & 
             ~(tlu_pstate_priv_buf[3] | tlu_hpstate_priv[3]));
//


// recoded the following for timing:
/*
assign exu_pib_priv_act_trap_m = 
           ((pib_priv_act_trap_m[0] & thread0_rsel_m) & 
             ~(tlu_pstate_priv[0] | tlu_hpstate_priv[0])) |
           ((pib_priv_act_trap_m[1] & thread1_rsel_m) & 
             ~(tlu_pstate_priv[1] | tlu_hpstate_priv[1])) |
           ((pib_priv_act_trap_m[2] & thread2_rsel_m) & 
             ~(tlu_pstate_priv[2] | tlu_hpstate_priv[2])) |
           ((pib_priv_act_trap_m[3] & thread3_rsel_m) & 
             ~(tlu_pstate_priv[3] | tlu_hpstate_priv[3]));
*/

wire [3:0] pib_priv_act_trap_thrd_qual_m;
wire [3:0] pib_priv_act_trap_thrd_hpstatepriv_qual_m;
wire [3:0] pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m;

assign  pib_priv_act_trap_thrd_qual_m[0] = pib_priv_act_trap_m[0] & thread0_rsel_m ;
assign  pib_priv_act_trap_thrd_qual_m[1] = pib_priv_act_trap_m[1] & thread1_rsel_m ;
assign  pib_priv_act_trap_thrd_qual_m[2] = pib_priv_act_trap_m[2] & thread2_rsel_m ;
assign  pib_priv_act_trap_thrd_qual_m[3] = pib_priv_act_trap_m[3] & thread3_rsel_m ;

assign pib_priv_act_trap_thrd_hpstatepriv_qual_m[0] = pib_priv_act_trap_thrd_qual_m[0] & ~tlu_hpstate_priv[0];
assign pib_priv_act_trap_thrd_hpstatepriv_qual_m[1] = pib_priv_act_trap_thrd_qual_m[1] & ~tlu_hpstate_priv[1];
assign pib_priv_act_trap_thrd_hpstatepriv_qual_m[2] = pib_priv_act_trap_thrd_qual_m[2] & ~tlu_hpstate_priv[2];
assign pib_priv_act_trap_thrd_hpstatepriv_qual_m[3] = pib_priv_act_trap_thrd_qual_m[3] & ~tlu_hpstate_priv[3];

assign pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m[0] = pib_priv_act_trap_thrd_hpstatepriv_qual_m[0] &
								~tlu_pstate_priv[0];
assign pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m[1] = pib_priv_act_trap_thrd_hpstatepriv_qual_m[1] &
								~tlu_pstate_priv[1];
assign pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m[2] = pib_priv_act_trap_thrd_hpstatepriv_qual_m[2] &
								~tlu_pstate_priv[2];
assign pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m[3] = pib_priv_act_trap_thrd_hpstatepriv_qual_m[3] &
								~tlu_pstate_priv[3];

assign exu_pib_priv_act_trap_m = (|pib_priv_act_trap_thrd_hpstatepriv_pstatepriv_m[3:0]);


// 
// added for make pib overflow trap precise
assign pib_trap_en[0] = tlu_int_pstate_ie[0] & (true_pil0[3:0] < 4'hf);
assign pib_trap_en[1] = tlu_int_pstate_ie[1] & (true_pil1[3:0] < 4'hf);
assign pib_trap_en[2] = tlu_int_pstate_ie[2] & (true_pil2[3:0] < 4'hf);
assign pib_trap_en[3] = tlu_int_pstate_ie[3] & (true_pil3[3:0] < 4'hf);
//
// added for bug 5017
dffr_s dffr_picl_wrap_pend_0 (
    .din (pib_picl_wrap[0]),
    .q   (picl_wrap_pend[0]),
    .rst (local_rst | (thread_inst_vld_w2[0] & ~pib_picl_wrap[0] & ~tlu_full_flush_pipe_w2)), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffr_s dffr_picl_wrap_pend_1 (
    .din (pib_picl_wrap[1]),
    .q   (picl_wrap_pend[1]),
    .rst (local_rst | (thread_inst_vld_w2[1] & ~pib_picl_wrap[1] & ~tlu_full_flush_pipe_w2)), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffr_s dffr_picl_wrap_pend_2 (
    .din (pib_picl_wrap[2]),
    .q   (picl_wrap_pend[2]),
    .rst (local_rst | (thread_inst_vld_w2[2] & ~pib_picl_wrap[2] & ~tlu_full_flush_pipe_w2)), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffr_s dffr_picl_wrap_pend_3 (
    .din (pib_picl_wrap[3]),
    .q   (picl_wrap_pend[3]),
    .rst (local_rst | (thread_inst_vld_w2[3] & ~pib_picl_wrap[3] & ~tlu_full_flush_pipe_w2)), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_picl_wrap_flg_m = 
       (picl_wrap_pend[0] & thread0_stg_m_buf) | 
       (picl_wrap_pend[1] & thread1_stg_m_buf) | 
       (picl_wrap_pend[2] & thread2_stg_m_buf) | 
       (picl_wrap_pend[3] & thread3_stg_m_buf);

// modified for bug 4086, 4206, 4246 and 4314
// modified for bug 5033, 5083 and 5017
// modified for bug 5436 - Niagara 2.0

// changed pend_pich_cnt_hld to pend_pich_cnt_hld_noqual as per bug5436(reopened 9/17/04).
assign pib_wrap_m[0] = 
           // (pib_picl_wrap[0] |
           ((picl_wrap_pend[0] & thread0_rsel_m) |
           (pich_wrap_flg[0] & inst_vld_m & thread0_rsel_m) |
           (pich_onebelow_flg[0] & (inst_vld_m & thread0_rsel_m) & 
           ((inst_vld_g & thread0_rsel_g) | (inst_vld_w2 & thread0_wsel_w2))) |
           (pich_twobelow_flg[0] & (inst_vld_m & thread0_rsel_m) & 
           (inst_vld_g & thread0_rsel_g) & (inst_vld_w2 & thread0_wsel_w2))) &
            pib_trap_en[0] & ~(tlu_flush_pipe_w & thread0_rsel_g) & ~pend_pich_cnt_hld_noqual[0];
assign pib_wrap_m[1] = 
           // (pib_picl_wrap[1] |
           ((picl_wrap_pend[1] & thread1_rsel_m) |
           (pich_wrap_flg[1] & inst_vld_m & thread1_rsel_m) |
           (pich_onebelow_flg[1] & (inst_vld_m & thread1_rsel_m) & 
           ((inst_vld_g & thread1_rsel_g) | (inst_vld_w2 & thread1_wsel_w2))) |
           (pich_twobelow_flg[1] & (inst_vld_m & thread1_rsel_m) & 
           (inst_vld_g & thread1_rsel_g) & (inst_vld_w2 & thread1_wsel_w2))) &   
            pib_trap_en[1] & ~(tlu_flush_pipe_w & thread1_rsel_g) & ~pend_pich_cnt_hld_noqual[1];
assign pib_wrap_m[2] = 
           // (pib_picl_wrap[2] |
           ((picl_wrap_pend[2] & thread2_rsel_m) |
           (pich_wrap_flg[2] & inst_vld_m & thread2_rsel_m) |
           (pich_onebelow_flg[2] & (inst_vld_m & thread2_rsel_m) & 
           ((inst_vld_g & thread2_rsel_g) | (inst_vld_w2 & thread2_wsel_w2))) |
           (pich_twobelow_flg[2] & (inst_vld_m & thread2_rsel_m) & 
           (inst_vld_g & thread2_rsel_g) & (inst_vld_w2 & thread2_wsel_w2))) &   
            pib_trap_en[2] & ~(tlu_flush_pipe_w & thread2_rsel_g) & ~pend_pich_cnt_hld_noqual[2];
assign pib_wrap_m[3] = 
           // (pib_picl_wrap[3] |
           ((picl_wrap_pend[3] & thread3_rsel_m) |
           (pich_wrap_flg[3] & inst_vld_m & thread3_rsel_m) |
           (pich_onebelow_flg[3] & (inst_vld_m & thread3_rsel_m) & 
           ((inst_vld_g & thread3_rsel_g) | (inst_vld_w2 & thread3_wsel_w2))) |
           (pich_twobelow_flg[3] & (inst_vld_m & thread3_rsel_m) & 
           (inst_vld_g & thread3_rsel_g) & (inst_vld_w2 & thread3_wsel_w2))) &   
            pib_trap_en[3] & ~(tlu_flush_pipe_w & thread3_rsel_g) & ~pend_pich_cnt_hld_noqual[3];

// modified for timing and bug 4314 and 5017
// added for bug 5436 - Niagara 2.0

// removed qualification with ~pend_pich_cnt_hld from the following logics and pushed
// the qulaification to G stage only for software interupt bit15 setting. The above 
// logic stay the same and no precise trap will be taken in the case of b2b valid
// instruction as indicated in bug5436(reopened 9/16/04) 
assign pib_pich_wrap_m[0] = 
           // (pib_picl_wrap[0] |
           ((picl_wrap_pend[0] & thread0_rsel_m) |
           (pich_wrap_flg[0] & inst_vld_m & thread0_rsel_m) |
           (pich_onebelow_flg[0] & (inst_vld_m & thread0_rsel_m) & 
           ((inst_vld_g & thread0_rsel_g) | (inst_vld_w2 & thread0_wsel_w2))) |
           (pich_twobelow_flg[0] & (inst_vld_m & thread0_rsel_m) & 
           (inst_vld_g & thread0_rsel_g) & (inst_vld_w2 & thread0_wsel_w2))) &
           ~(tlu_flush_pipe_w & thread0_rsel_g) ;
assign pib_pich_wrap_m[1] = 
           // (pib_picl_wrap[1] |
           ((picl_wrap_pend[1] & thread1_rsel_m) |
           (pich_wrap_flg[1] & inst_vld_m & thread1_rsel_m) |
           (pich_onebelow_flg[1] & (inst_vld_m & thread1_rsel_m) & 
           ((inst_vld_g & thread1_rsel_g) | (inst_vld_w2 & thread1_wsel_w2))) |
           (pich_twobelow_flg[1] & (inst_vld_m & thread1_rsel_m) & 
           (inst_vld_g & thread1_rsel_g) & (inst_vld_w2 & thread1_wsel_w2))) &   
           ~(tlu_flush_pipe_w & thread1_rsel_g) ;
assign pib_pich_wrap_m[2] = 
           // (pib_picl_wrap[2] |
           ((picl_wrap_pend[2] & thread2_rsel_m) |
           (pich_wrap_flg[2] & inst_vld_m & thread2_rsel_m) |
           (pich_onebelow_flg[2] & (inst_vld_m & thread2_rsel_m) & 
           ((inst_vld_g & thread2_rsel_g) | (inst_vld_w2 & thread2_wsel_w2))) |
           (pich_twobelow_flg[2] & (inst_vld_m & thread2_rsel_m) & 
           (inst_vld_g & thread2_rsel_g) & (inst_vld_w2 & thread2_wsel_w2))) &   
           ~(tlu_flush_pipe_w & thread2_rsel_g) ;
assign pib_pich_wrap_m[3] = 
           // (pib_picl_wrap[3] |
           ((picl_wrap_pend[3] & thread3_rsel_m) |
           (pich_wrap_flg[3] & inst_vld_m & thread3_rsel_m) |
           (pich_onebelow_flg[3] & (inst_vld_m & thread3_rsel_m) & 
           ((inst_vld_g & thread3_rsel_g) | (inst_vld_w2 & thread3_wsel_w2))) |
           (pich_twobelow_flg[3] & (inst_vld_m & thread3_rsel_m) & 
           (inst_vld_g & thread3_rsel_g) & (inst_vld_w2 & thread3_wsel_w2))) &   
           ~(tlu_flush_pipe_w & thread3_rsel_g) ;
/*
assign pib_wrap_m[0] = 
           (pib_picl_wrap[0] |
           (pich_wrap_flg[0] & inst_vld_m & thread0_rsel_m) |
           (pich_onebelow_flg[0] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread0_rsel_m & (thread0_wsel_w2 | thread0_rsel_g)) | 
           (pich_twobelow_flg[0] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread0_rsel_g & thread0_rsel_m & thread0_wsel_w2)) & pib_trap_en[0] & 
            ~(tlu_flush_pipe_w & thread0_rsel_g);
assign pib_wrap_m[1] = 
           (pib_picl_wrap[1] |
           (pich_wrap_flg[1] & inst_vld_m & thread1_rsel_m) |
           (pich_onebelow_flg[1] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread1_rsel_m & (thread1_wsel_w2 | thread1_rsel_g)) | 
           (pich_twobelow_flg[1] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread1_rsel_g & thread1_rsel_m & thread1_wsel_w2)) & pib_trap_en[1] &
            ~(tlu_flush_pipe_w & thread1_rsel_g);
assign pib_wrap_m[2] = 
           (pib_picl_wrap[2] |
           (pich_wrap_flg[2] & inst_vld_m & thread2_rsel_m) |
           (pich_onebelow_flg[2] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread2_rsel_m & (thread2_wsel_w2 | thread2_rsel_g)) | 
           (pich_twobelow_flg[2] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread2_rsel_g & thread2_rsel_m & thread2_wsel_w2)) & pib_trap_en[2] &
            ~(tlu_flush_pipe_w & thread2_rsel_g);
assign pib_wrap_m[3] = 
           (pib_picl_wrap[3] |
           (pich_wrap_flg[3] & inst_vld_m & thread3_rsel_m) |
           (pich_onebelow_flg[3] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread3_rsel_m & (thread3_wsel_w2 | thread3_rsel_g)) | 
           (pich_twobelow_flg[3] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread3_rsel_g & thread3_rsel_m & thread3_wsel_w2)) & pib_trap_en[3] &
            ~(tlu_flush_pipe_w & thread3_rsel_g);

// modified for timing and bug 4314 
assign pib_pich_wrap_m[0] = 
           (pib_picl_wrap[0] |
           (pich_wrap_flg[0] & inst_vld_m & thread0_rsel_m) |
           (pich_onebelow_flg[0] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread0_rsel_m & (thread0_wsel_w2 | thread0_rsel_g)) | 
           (pich_twobelow_flg[0] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread0_rsel_g & thread0_rsel_m & thread0_wsel_w2)) & 
            ~(tlu_flush_pipe_w & thread0_rsel_g);
assign pib_pich_wrap_m[1] = 
           (pib_picl_wrap[1] |
           (pich_wrap_flg[1] & inst_vld_m & thread1_rsel_m) |
           (pich_onebelow_flg[1] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread1_rsel_m & (thread1_wsel_w2 | thread1_rsel_g)) | 
           (pich_twobelow_flg[1] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread1_rsel_g & thread1_rsel_m & thread1_wsel_w2)) & 
            ~(tlu_flush_pipe_w & thread1_rsel_g);
assign pib_pich_wrap_m[2] = 
           (pib_picl_wrap[2] |
           (pich_wrap_flg[2] & inst_vld_m & thread2_rsel_m) |
           (pich_onebelow_flg[2] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread2_rsel_m & (thread2_wsel_w2 | thread2_rsel_g)) | 
           (pich_twobelow_flg[2] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread2_rsel_g & thread2_rsel_m & thread2_wsel_w2)) & 
            ~(tlu_flush_pipe_w & thread2_rsel_g);
assign pib_pich_wrap_m[3] = 
           (pib_picl_wrap[3] |
           (pich_wrap_flg[3] & inst_vld_m & thread3_rsel_m) |
           (pich_onebelow_flg[3] & inst_vld_m & (inst_vld_g | inst_vld_w2) & 
           thread3_rsel_m & (thread3_wsel_w2 | thread3_rsel_g)) | 
           (pich_twobelow_flg[3] & inst_vld_m & inst_vld_g  & inst_vld_w2 & 
            thread3_rsel_g & thread3_rsel_m & thread3_wsel_w2)) & 
            ~(tlu_flush_pipe_w & thread3_rsel_g);
//
*/


wire [3:0] pib_pich_wrap_q;

dffr_s #(4) dffr_pib_pich_wrap (
   .din (pib_pich_wrap_m[4-1:0]),
   .q   (pib_pich_wrap_q[4-1:0]),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

// added for the bug 5436 reopened on 9/16/2004 by Samy. The following pushes
// the qualification by hold signal to G stage.So sofint bit15 is set for signaling
// software a overflow has occurred. But the preciese trap will not be taken.
assign pib_pich_wrap[3:0] = pib_pich_wrap_q[3:0] & {4{~pend_pich_cnt_hld}};


// 
// experiment
/*
assign pich_exu_wrap_e[0] = 
       tlu_thread_inst_vld_w2[0]? pich_onebelow_flg[0]: pich_wrap_flg[0]; 
assign pich_exu_wrap_e[1] = 
       tlu_thread_inst_vld_w2[1]? pich_onebelow_flg[1]: pich_wrap_flg[1];
assign pich_exu_wrap_e[2] = 
       tlu_thread_inst_vld_w2[2]? pich_onebelow_flg[2]: pich_wrap_flg[2];
assign pich_exu_wrap_e[3] = 
       tlu_thread_inst_vld_w2[3]? pich_onebelow_flg[3]: pich_wrap_flg[3]; 

assign pich_wrap_flg_e = 
           (tlu_thrd_rsel_e[0]) ? pich_exu_wrap_e[0]:
           (tlu_thrd_rsel_e[1]) ? pich_exu_wrap_e[1]:
           (tlu_thrd_rsel_e[2]) ? pich_exu_wrap_e[2]:
            pich_exu_wrap_e[3];
*/

dffr_s dffr_pich_wrap_flg_m (
   .din (tlu_pic_wrap_e),
   .q   (pich_wrap_flg_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
//
// modified for bug 5436 - Niagara 2.0
assign tlu_pich_wrap_flg_m = 
           pich_wrap_flg_m & tlu_pic_cnt_en_m; 
/*
assign pic_hpstate_priv_e = 
           (tlu_thrd_rsel_e[0]) ? tlu_hpstate_priv[0]:
           (tlu_thrd_rsel_e[1]) ? tlu_hpstate_priv[1]:
           (tlu_thrd_rsel_e[2]) ? tlu_hpstate_priv[2]:
            tlu_hpstate_priv[3];

assign pic_pstate_priv_e = 
           (tlu_thrd_rsel_e[0]) ? tlu_pstate_priv_buf[0]:
           (tlu_thrd_rsel_e[1]) ? tlu_pstate_priv_buf[1]:
           (tlu_thrd_rsel_e[2]) ? tlu_pstate_priv_buf[2]:
            tlu_pstate_priv_buf[3];

assign pic_hpstate_enb_e = 
           (tlu_thrd_rsel_e[0]) ? tlu_hpstate_enb[0]:
           (tlu_thrd_rsel_e[1]) ? tlu_hpstate_enb[1]:
           (tlu_thrd_rsel_e[2]) ? tlu_hpstate_enb[2]:
            tlu_hpstate_enb[3];

assign pic_trap_en_e = 
           (tlu_thrd_rsel_e[0]) ? pib_trap_en[0]:
           (tlu_thrd_rsel_e[1]) ? pib_trap_en[1]:
           (tlu_thrd_rsel_e[2]) ? pib_trap_en[2]:
            pib_trap_en[3];
*/

// modified for bug 5436 - Niagara 2.0

assign pic_cnt_en[0] = 
            ((~tlu_hpstate_priv[0] & ~tlu_pstate_priv_buf[0] & tlu_pcr_ut[0]) | 
             (~tlu_hpstate_enb[0]  & tlu_hpstate_priv[0] & tlu_pcr_st[0]) |
             (tlu_hpstate_enb[0]   & tlu_pstate_priv_buf[0]  & ~tlu_hpstate_priv[0] & 
 //tlu_pcr_st[0])) & pib_trap_en[0]; 
              tlu_pcr_st[0])) ; 
assign pic_cnt_en[1] = 
            ((~tlu_hpstate_priv[1] & ~tlu_pstate_priv_buf[1] & tlu_pcr_ut[1]) | 
             (~tlu_hpstate_enb[1]  & tlu_hpstate_priv[1] & tlu_pcr_st[1]) |
             (tlu_hpstate_enb[1]   & tlu_pstate_priv_buf[1]  & ~tlu_hpstate_priv[1] & 
 //tlu_pcr_st[1])) & pib_trap_en[1]; 
              tlu_pcr_st[1])) ; 
assign pic_cnt_en[2] = 
            ((~tlu_hpstate_priv[2] & ~tlu_pstate_priv_buf[2] & tlu_pcr_ut[2]) | 
             (~tlu_hpstate_enb[2]  & tlu_hpstate_priv[2] & tlu_pcr_st[2]) |
             (tlu_hpstate_enb[2]   & tlu_pstate_priv_buf[2]  & ~tlu_hpstate_priv[2] & 
 //tlu_pcr_st[2])) & pib_trap_en[2]; 
              tlu_pcr_st[2])) ; 
assign pic_cnt_en[3] = 
            ((~tlu_hpstate_priv[3] & ~tlu_pstate_priv_buf[3] & tlu_pcr_ut[3]) | 
             (~tlu_hpstate_enb[3]  & tlu_hpstate_priv[3] & tlu_pcr_st[3]) |
             (tlu_hpstate_enb[3]   & tlu_pstate_priv_buf[3]  & ~tlu_hpstate_priv[3] & 
 //tlu_pcr_st[3])) & pib_trap_en[3]; 
              tlu_pcr_st[3])) ; 

assign pic_cnt_en_e = 
           (tlu_thrd_rsel_e[0]) ? pic_cnt_en[0]:
           (tlu_thrd_rsel_e[1]) ? pic_cnt_en[1]:
           (tlu_thrd_rsel_e[2]) ? pic_cnt_en[2]:
            pic_cnt_en[3];


/*
assign pic_cnt_en_e = 
            ((~pic_hpstate_priv_e & ~pic_pstate_priv_e & pcr_ut_e) | 
             (~pic_hpstate_enb_e  & pic_hpstate_priv_e & pcr_st_e) |
             (pic_hpstate_enb_e   & pic_pstate_priv_e  & ~pic_hpstate_priv_e & 
              pcr_st_e)) & pic_trap_en_e; 
*/

dffr_s dffr_tlu_pic_cnt_en_m (
   .din (pic_cnt_en_e),
   .q   (pic_cnt_en_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

/**** replaced the following with and-or for better synthesis interms of timing 
assign tlu_pich_cnt_hld =
       (thread0_rsel_m) ? pend_pich_cnt_hld[0]: 
       (thread1_rsel_m) ? pend_pich_cnt_hld[1]:
       (thread2_rsel_m) ? pend_pich_cnt_hld[2]:
        pend_pich_cnt_hld[3]; 
************/


assign tlu_pich_cnt_hld = (thread0_stg_m & pend_pich_cnt_hld_early[0]) |
			  (thread1_stg_m & pend_pich_cnt_hld_early[1]) |
			  (thread2_stg_m & pend_pich_cnt_hld_early[2]) |
			  (thread3_stg_m & pend_pich_cnt_hld_early[3]) ;


// added the follwoing since we still want to qualify with pib_trap_en for the trap signal going
// to exu, i.e. tlu_pic_cnt_en_m is used to generate tlu_exu_pic_onebelow_m in tlu_misctl.v 
wire pic_trap_en_e =
           (tlu_thrd_rsel_e[0]) ? pib_trap_en[0]:
           (tlu_thrd_rsel_e[1]) ? pib_trap_en[1]:
           (tlu_thrd_rsel_e[2]) ? pib_trap_en[2]:
            pib_trap_en[3];

wire pic_trap_en_m;

dffr_s dffr_pic_trap_en_m (
   .din (pic_trap_en_e),
   .q   (pic_trap_en_m),
   .rst (local_rst), .clk (clk), .se  (se), .si  (), .so  ());

wire tlu_pic_cnt_en_m_prequal = pic_cnt_en_m & pic_trap_en_m;

assign tlu_pic_cnt_en_m = tlu_pic_cnt_en_m_prequal & ~tlu_pich_cnt_hld;

//
// added for bug 5436 - Niagara 2.0
dffr_s dffr_pic_cnt_en_w (
   .din (pic_cnt_en_m),
   .q   (pic_cnt_en_w),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

dffr_s dffr_pic_cnt_en_w2 (
   .din (pic_cnt_en_w),
   .q   (pic_cnt_en_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

/*
// added for bug 4785
assign tlu_pic_onebelow_e = 
           (thread0_rsel_e) ? pich_onebelow_flg[0] :
           (thread1_rsel_e) ? pich_onebelow_flg[1] :
           (thread2_rsel_e) ? pich_onebelow_flg[2] :
           pich_onebelow_flg[3];

dffr_s dffr_tlu_exu_pic_onebelow_m (
   .din (tlu_pic_onebelow_e),
   .q   (tlu_exu_pic_onebelow_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign tlu_pic_twobelow_e = 
           (thread0_rsel_e) ? pich_twobelow_flg[0] :
           (thread1_rsel_e) ? pich_twobelow_flg[1] :
           (thread2_rsel_e) ? pich_twobelow_flg[2] :
           pich_twobelow_flg[3];

dffr_s dffr_tlu_exu_pic_twobelow_m (
   .din (tlu_pic_twobelow_e),
   .q   (tlu_exu_pic_twobelow_m),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
*/
//
// added for bug 4395
dffr_s dffr_tlu_tcc_inst_w (
    .din (exu_tlu_ttype_m[8]),
    .q   (tlu_tcc_inst_w),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);
//
assign pib_wrap_trap_m = (|pib_wrap_m[4-1:0]);
//
// modified for bug 4342
// pib wrap precise trap 
dffr_s dffr_pib_wrap_trap_nq_g (
   .din (pib_wrap_trap_m),
   .q   (pib_wrap_trap_nq_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

// modified for bug 4916
assign pib_wrap_trap_g = 
           pib_wrap_trap_nq_g & ~lsu_tlu_defr_trp_taken_g; 
//
// modified for bug 2955
assign tlu_exu_priv_trap_m = 
           exu_pib_priv_act_trap_m | exu_tick_npt_priv_act_m |
           (|tlz_exu_trap_m[4-1:0]) | tlu_pich_wrap_flg_m |
           tlu_picl_wrap_flg_m;
// 
// illegal instruction from ffu
dffr_s dffr_ffu_ill_inst_uf_g (
   .din (ffu_tlu_ill_inst_m),
   .q   (ffu_ill_inst_uf_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign ffu_ill_inst_g = ffu_ill_inst_uf_g & ~inst_ifu_flush_w;
/*
dffr_s dffr_lsu_ill_inst_uf_g (
   .din (lsu_tlu_ill_inst_m),
   .q   (lsu_ill_inst_uf_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign lsu_ill_inst_g = lsu_ill_inst_uf_g & ~inst_ifu_flush_w;
//
*/
// added for bug 4074 and modified for bug 4715
/*
dffr_s dffr_lsu_tlu_defr_trp_taken_w2 (
   .din (lsu_tlu_defr_trp_taken_g),
   .q   (lsu_tlu_defr_trp_taken_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
*/

assign lsu_defr_trp_taken_w2[0] = lsu_defr_trap_w2 & thread0_wsel_w2; 
assign lsu_defr_trp_taken_w2[1] = lsu_defr_trap_w2 & thread1_wsel_w2; 
assign lsu_defr_trp_taken_w2[2] = lsu_defr_trap_w2 & thread2_wsel_w2; 
assign lsu_defr_trp_taken_w2[3] = lsu_defr_trap_w2 & thread3_wsel_w2; 


// added for the lsu deferred trap - bug 3060
// modified for bug 4074, 4561 and 4916
assign lsu_defr_trap_g = lsu_tlu_defr_trp_taken_g & ~ifu_tlu_flush_fd_w; 
// assign lsu_defr_trap_g = lsu_tlu_defr_trp_taken_g; 

assign local_lsu_async_ttype_vld_w = lsu_tlu_async_ttype_vld_g; 
//
// modified for bug 4443 and 4561
// added for timing
dffr_s dffr_lsu_defr_trap_w2 (
   .din (lsu_defr_trap_g),
   .q   (lsu_defr_trap_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
//
// privilege action trap of the PIB registers
dffr_s dffr_pib_priv_act_trap_g (
   .din (pib_priv_act_early_trap_m),
   .q   (pib_priv_act_trap_uf_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
//
// added for bug 2133
assign pib_priv_act_trap_g = pib_priv_act_trap_uf_g & ~inst_ifu_flush_w;
//
assign	ifu_ttype_vld_g = ifu_ttype_vld_tmp_g | spu_ill_inst_g | immu_miss_g    | 
                          tick_npt_priv_act_g | ffu_ill_inst_g | pib_priv_act_trap_g | 
                          htrap_ill_inst_g;
// 
// added and modified for timing fix
assign ifu_ttype_early_vld_m = 
             (ifu_ttype_vld_m  | pib_priv_act_early_trap_m |
              spu_ill_inst_m   | tick_npt_priv_act_m | ffu_tlu_ill_inst_m |
              htrap_ill_inst_m); 

assign	early_dside_trap_g = 
            (local_sync_trap_g & ~inst_ifu_flush2_w) | 
             va_oor_inst_acc_excp_g | va_oor_data_acc_excp_g; 
//
assign	dside_sync_trap_g = 
            lsu_ttype_vld_w | early_dside_trap_g; 
//
// The sync ttype is being recoded for timing
// Merge with lsu traps.
//
mux2ds #(9) mx_local_sync_ttype (
    .in0  (9'h008),
	.in1  (9'h030),
    .sel0 (va_oor_inst_acc_excp_g),
    .sel1 (~va_oor_inst_acc_excp_g),
    .dout (local_sync_ttype_g[9-1:0])
);

// Need 9b comparator.
// assign dside_higher_priority = (dside_sync_ttype_g[8:0] > exu_ttype_g[8:0]);
assign local_higher_ttype_flg = 
           (local_sync_ttype_g[9-1:0] > 
            exu_ttype_g[9-1:0]);

// added for bug 3977
dffr_s dffr_exu_ue_trap_g (
   .din (exu_tlu_ue_trap_m),
   .q   (exu_ue_trap_g),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
assign exu_higher_pri_g = 
           exu_ue_trap_g & exu_ttype_vld_g & ~immu_miss_g;  

// Is the prioritization needed or is this handled among the units themselves ?
// modified for bug 3977
assign	priority_trap_sel0 = 
            ifu_ttype_vld_g & ~((|tlz_trap_g[4-1:0]) | 
            lsu_defr_trap_g | exu_higher_pri_g);
//
// modified for support to lsu deferred traps
// modified for bug 3977
assign	priority_trap_sel1 = 
            ~((|tlz_trap_g[4-1:0]) | lsu_defr_trap_g) & 
            ~(ifu_ttype_vld_g & ~exu_higher_pri_g) &
             ((exu_ttype_vld_g & ~early_dside_trap_g) | 
			 ((exu_ttype_vld_g &  early_dside_trap_g) & ~local_higher_ttype_flg));
// 
// modified for bug 3634
assign	priority_trap_sel2 = ~(priority_trap_sel0 | priority_trap_sel1);
//
// recoded for timing
// Prioritized ttype for thread available.
/*
mux4ds #(9) finaltt_sel (
    .in0    ({2'b00,`TLZ_TRAP}),
    .in1    (ifu_ttype_g[8:0]), 	
	.in2    (exu_ttype_g[8:0]),
	.in3    (dside_sync_ttype_g[8:0]),
    .sel0   (|tlz_trap_g[`TLU_THRD_NUM-1:0]),
    .sel1   (priority_trap_sel0),  	
	.sel2   (priority_trap_sel1),
	.sel3   (priority_trap_sel2),
    .dout   (sync_ttype_g[8:0])
); 
*/
//
// modified for bug 3634
// modified for bug 3977
mux3ds #(9) mx_early_sync_ttype (
//     .in0    ({2'b00,`TLZ_TRAP}),
    .in0    (ifu_ttype_g[8:0]), 	
	.in1    (exu_ttype_g[8:0]),
	.in2    (local_sync_ttype_g[8:0]),
    .sel0   (priority_trap_sel0),  	
	.sel1   (priority_trap_sel1),
	.sel2   (priority_trap_sel2),
    .dout   (early_sync_ttype_g[9-1:0])
); 
//
// added for timing 
dff_s #(9) dff_early_sync_ttype_w2 (
    .din (early_sync_ttype_g[9-1:0]), 
    .q   (early_sync_ttype_w2[9-1:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
//
// Now pend Div and Spill/Fill traps if necessary. These traps are always pended
// even if there is no concurrent synchronous trap. They are pended by thread.
// Include fp traps
// modified for bug 4857
assign	sync_trap_taken_g = 
	((ifu_ttype_vld_g | exu_ttype_vld_g | lsu_tlu_ttype_vld_m2 | early_dside_trap_g | 
     (|tlz_trap_g[4-1:0]) | pib_wrap_trap_g) & inst_vld_g) | 
      intrpt_taken | swint_taken | lsu_defr_trap_g;
     // (|tlz_trap_g[`TLU_THRD_NUM-1:0])) & inst_vld_g) | intrpt_taken | swint_taken |
     //  lsu_defr_trap_g | pib_wrap_trap_g; 
// 
// added for timing
dff_s dff_sync_trap_taken_w2 (
    .din (sync_trap_taken_g), 
	.q   (sync_trap_taken_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// added for timing fix 
// modified for bug 3653, bug 4758 and bug 5169
assign	sync_trap_taken_m = 
	 (exu_tlu_va_oor_jl_ret_m | exu_tlu_ttype_vld_m | 
      ifu_ttype_early_vld_m | (|tlz_trap_m[4-1:0]) | true_hscpd_dacc_excpt_m | 
      true_qtail_dacc_excpt_m | dmmu_va_oor_m | exu_tlu_va_oor_jl_ret_m |
      pib_wrap_trap_m | ifu_swint_m | ifu_hwint_m | ifu_rstint_m) & inst_vld_m; 
/*
assign	sync_trap_taken_m = 
	((exu_tlu_va_oor_jl_ret_m | exu_tlu_ttype_vld_m | 
      ifu_ttype_early_vld_m | (|tlz_trap_m[`TLU_THRD_NUM-1:0]) | true_hscpd_dacc_excpt_m | 
      true_qtail_dacc_excpt_m | dmmu_va_oor_m | exu_tlu_va_oor_jl_ret_m) & 
      inst_vld_m) | pib_wrap_trap_m | ifu_swint_m | ifu_hwint_m | ifu_rstint_m; 
*/

assign fp_trap_thrd0 = ~ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
assign fp_trap_thrd1 = ~ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];
assign fp_trap_thrd2 =  ffu_ifu_tid_w2[1] & ~ffu_ifu_tid_w2[0];
assign fp_trap_thrd3 =  ffu_ifu_tid_w2[1] &  ffu_ifu_tid_w2[0];

// assign div_zero_thrd0 = ~exu_tlu_div_tid[1] & ~exu_tlu_div_tid[0];
// assign div_zero_thrd1 = ~exu_tlu_div_tid[1] &  exu_tlu_div_tid[0];
// assign div_zero_thrd2 =  exu_tlu_div_tid[1] & ~exu_tlu_div_tid[0];
// assign div_zero_thrd3 =  exu_tlu_div_tid[1] &  exu_tlu_div_tid[0];

assign spill_thrd0 = ~exu_tlu_spill_tid[1] & ~exu_tlu_spill_tid[0];
assign spill_thrd1 = ~exu_tlu_spill_tid[1] &  exu_tlu_spill_tid[0];
assign spill_thrd2 =  exu_tlu_spill_tid[1] & ~exu_tlu_spill_tid[0];
assign spill_thrd3 =  exu_tlu_spill_tid[1] &  exu_tlu_spill_tid[0];
// 
// added for bug 3499
dff_s #(4) dff_cwp_en_thrd_reset (
    .din ({pend_to_thrd3_reset, pend_to_thrd2_reset,
           pend_to_thrd1_reset, pend_to_thrd0_reset}),
    .q   (cwp_en_thrd_reset[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_trap_cwp0_enb (
    .din (spill_thrd0),
    .q   (trap_cwp_enb[0]),
    .rst (cwp_en_thrd_reset[0]), 
    .en  (exu_tlu_spill & spill_thrd0),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_trap_cwp1_enb (
    .din (spill_thrd1),
    .q   (trap_cwp_enb[1]),
    .rst (cwp_en_thrd_reset[1]), 
    .en  (exu_tlu_spill & spill_thrd1),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_trap_cwp2_enb (
    .din (spill_thrd2),
    .q   (trap_cwp_enb[2]),
    .rst (cwp_en_thrd_reset[2]), 
    .en  (exu_tlu_spill & spill_thrd2),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_trap_cwp3_enb (
    .din (spill_thrd3),
    .q   (trap_cwp_enb[3]),
    .rst (cwp_en_thrd_reset[3]), 
    .en  (exu_tlu_spill & spill_thrd3),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_trap_cwp_en[4-1:0] = ~(trap_cwp_enb[4-1:0]);

//
// added for asynchronize dmmu traps (correctable parity error)
assign dmmu_async_thrd0 = ~lsu_tlu_async_tid_g[1] & ~lsu_tlu_async_tid_g[0];
assign dmmu_async_thrd1 = ~lsu_tlu_async_tid_g[1] &  lsu_tlu_async_tid_g[0];
assign dmmu_async_thrd2 =  lsu_tlu_async_tid_g[1] & ~lsu_tlu_async_tid_g[0];
assign dmmu_async_thrd3 =  lsu_tlu_async_tid_g[1] &  lsu_tlu_async_tid_g[0];
//
// modified for bug 4074
assign lsu_async_vld_en_g[0] = 
//            local_lsu_async_ttype_vld_w & dmmu_async_thrd0 & ~lsu_tlu_defr_trp_taken_g;
            local_lsu_async_ttype_vld_w & dmmu_async_thrd0 & ~lsu_defr_trp_taken_w2[0];
assign lsu_async_vld_en_g[1] = 
//            local_lsu_async_ttype_vld_w & dmmu_async_thrd1 & ~lsu_tlu_defr_trp_taken_g;
           local_lsu_async_ttype_vld_w & dmmu_async_thrd1 & ~lsu_defr_trp_taken_w2[1];
assign lsu_async_vld_en_g[2] = 
//            local_lsu_async_ttype_vld_w & dmmu_async_thrd2 & ~lsu_tlu_defr_trp_taken_g;
           local_lsu_async_ttype_vld_w & dmmu_async_thrd2 & ~lsu_defr_trp_taken_w2[2];
assign lsu_async_vld_en_g[3] = 
//           local_lsu_async_ttype_vld_w & dmmu_async_thrd3 & ~lsu_tlu_defr_trp_taken_g;
           local_lsu_async_ttype_vld_w & dmmu_async_thrd3 & ~lsu_defr_trp_taken_w2[3];
//
dffre_s dffre_lsu_async_vld_en_w2_0 (
    .din (lsu_async_vld_en_g[0]),
    .q   (lsu_async_vld_en_w2[0]),
    .rst (pend_to_thrd0_reset),
    .en  (lsu_async_vld_en_g[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffre_s dffre_lsu_async_vld_en_w2_1 (
    .din (lsu_async_vld_en_g[1]),
    .q   (lsu_async_vld_en_w2[1]),
    .rst (pend_to_thrd1_reset),
    .en  (lsu_async_vld_en_g[1]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffre_s dffre_lsu_async_vld_en_w2_2 (
    .din (lsu_async_vld_en_g[2]),
    .q   (lsu_async_vld_en_w2[2]),
    .rst (pend_to_thrd2_reset),
    .en  (lsu_async_vld_en_g[2]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
dffre_s dffre_lsu_async_vld_en_w2_3 (
    .din (lsu_async_vld_en_g[3]),
    .q   (lsu_async_vld_en_w2[3]),
    .rst (pend_to_thrd3_reset),
    .en  (lsu_async_vld_en_g[3]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// assign trap type base on information send
assign dmmu_async_ttype[9-1:0] = 
           {2'b0, lsu_tlu_async_ttype_g[6:0]};
// 
// derived the spill ttype
assign exu_spill_ttype[9-1:0] =
           {3'b010,exu_tlu_spill_other,exu_tlu_spill_wtype[2:0], 2'b00}; 
//
// derived ffu_asynchronous ttype
// modified for bug 4084 - new ffu asynchronous trap type: 0x29
assign ffu_async_ttype[9-1:0] = 
           (ffu_tlu_trap_ue) ? 9'h029:
	       ({7'b0001000, ffu_tlu_trap_other, ffu_tlu_trap_ieee754});
//
//
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_ttype0[9-1:0] = 
		(exu_tlu_spill & spill_thrd0) ? 
         exu_spill_ttype[9-1:0] :
		(((ffu_tlu_trap_other | ffu_tlu_trap_ieee754 | ffu_tlu_trap_ue) & fp_trap_thrd0) ? 
           ffu_async_ttype[9-1:0] :
           dmmu_async_ttype[9-1:0]);

// always flop if selected for thread.
// THREAD0
// added support for dmmu_async_traps
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_to_thrd0_en =
	       (exu_tlu_spill & spill_thrd0) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd0) |
           (lsu_async_vld_en_g[0] & ~lsu_async_vld_en_w2[0]) |
			cwp_cmplt0;				// cwp completion always pended.
//
// added for bug 5436 - Niagara 2.0
assign pend_pich_cnt_adj[0] =
	      ((exu_tlu_spill & spill_thrd0) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd0) |
           (lsu_async_vld_en_g[0] & ~lsu_async_vld_en_w2[0])) & pic_cnt_en[0];

// If there is no sync trap in a cycle, then the pending trap is taken.
assign	pend_to_thrd0_reset =
	local_rst | pending_thrd0_event_taken;

// Choose pending traps in round-robin order.
tlu_rrobin_picker       ptrap_rrobin      (
                .events         ({pending_trap3,pending_trap2,pending_trap1,pending_trap0}),
                .pick_one_hot   (pending_trap_sel[3:0]),
        // 
        // this siganl was modified to abide to the Niagara reset methodology
		        .tlu_rst_l		(tlu_rst_l),
                .clk            (clk)
        );           

// modified to arbitrate between wsr instruction and asynchronous events
// due to there is only one write port to tsa
// also modified for bug 1672
// modified for bug 3827
assign pending_thrd0_event_taken = 
            pending_trap_sel[0] & ~(sync_trap_taken_g | dnrtry_inst_g | 
            tsa_wr_tid_sel_g | ifu_thrd_flush_w[0] | (tlu_gl_rw_g & wsr_inst_g)); 

dffre_s #(12) dffre_pendthrd0 (
    .din ({pend_to_thrd0_en,pend_ttype0[8:0],cwp_cmplt0,exu_tlu_cwp_retry}), 
	.q   ({pending_trap0,pending_ttype0[8:0],cwp_cmplt0_pending,cwp_retry0}),
    .rst (pend_to_thrd0_reset), 
    .en  (pend_to_thrd0_en), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
// THREAD1
// added support for dmmu_async_traps
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_to_thrd1_en = 
	       (exu_tlu_spill & spill_thrd1) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd1) |
           (lsu_async_vld_en_g[1] & ~lsu_async_vld_en_w2[1]) |
			cwp_cmplt1;				// cwp completion always pended.
//
// added for bug 5436 - Niagara 2.0
assign pend_pich_cnt_adj[1] =
	      ((exu_tlu_spill & spill_thrd1) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd1) |
           (lsu_async_vld_en_g[1] & ~lsu_async_vld_en_w2[1])) & pic_cnt_en[1];

assign	pend_to_thrd1_reset =
	local_rst | pending_thrd1_event_taken;

// modified to arbitrate between wsr instruction and asynchronous events
// due to there is only one write port to tsa
//
// modified for bug 3827
assign pending_thrd1_event_taken = 
            pending_trap_sel[1] & ~(sync_trap_taken_g | dnrtry_inst_g | 
            tsa_wr_tid_sel_g | ifu_thrd_flush_w[1] | (tlu_gl_rw_g & wsr_inst_g)); 

//
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_ttype1[9-1:0] = 
		(exu_tlu_spill & spill_thrd1) ? 
         exu_spill_ttype[9-1:0] :
		(((ffu_tlu_trap_other | ffu_tlu_trap_ieee754 | ffu_tlu_trap_ue) & fp_trap_thrd1) ? 
           ffu_async_ttype[9-1:0] :
           dmmu_async_ttype[9-1:0]);

dffre_s #(12) dffre_pendthrd1 (
    .din ({pend_to_thrd1_en,pend_ttype1[8:0],cwp_cmplt1,exu_tlu_cwp_retry}), 
	.q   ({pending_trap1,pending_ttype1[8:0],cwp_cmplt1_pending,cwp_retry1}),
    .rst (pend_to_thrd1_reset), 
    .en  (pend_to_thrd1_en), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// THREAD2
// added support for dmmu_async_traps
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_to_thrd2_en = 
	       (exu_tlu_spill & spill_thrd2) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd2) |
           (lsu_async_vld_en_g[2] & ~lsu_async_vld_en_w2[2]) |
			cwp_cmplt2;				// cwp completion always pended.
//
// added for bug 5436 - Niagara 2.0
assign pend_pich_cnt_adj[2] =
	      ((exu_tlu_spill & spill_thrd2) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd2) |
           (lsu_async_vld_en_g[2] & ~lsu_async_vld_en_w2[2])) & pic_cnt_en[2];

assign	pend_to_thrd2_reset =
	local_rst | pending_thrd2_event_taken;

// modified to arbitrate between wsr instruction and asynchronous events
// due to there is only one write port to tsa
//
// modified for bug 3827
assign pending_thrd2_event_taken = 
            pending_trap_sel[2] & ~(sync_trap_taken_g | dnrtry_inst_g | 
            tsa_wr_tid_sel_g | ifu_thrd_flush_w[2] | (tlu_gl_rw_g & wsr_inst_g)); 

//
// modified for bug 4084 - new ffu_tlu_trap_ue
assign pend_ttype2[9-1:0] = 
		(exu_tlu_spill & spill_thrd2) ? 
         exu_spill_ttype[9-1:0] :
		(((ffu_tlu_trap_other | ffu_tlu_trap_ieee754 | ffu_tlu_trap_ue) & fp_trap_thrd2) ? 
           ffu_async_ttype[9-1:0] :
           dmmu_async_ttype[9-1:0]);

dffre_s #(12) dffre_pendthrd2 (
    .din ({pend_to_thrd2_en,pend_ttype2[8:0],cwp_cmplt2,exu_tlu_cwp_retry}), 
	.q   ({pending_trap2,pending_ttype2[8:0],cwp_cmplt2_pending,cwp_retry2}),
    .rst (pend_to_thrd2_reset), 
    .en  (pend_to_thrd2_en), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// THREAD3
// added support for dmmu_async_traps
// modified for bug 4084 - new ffu_tlu_trap_ue 
assign pend_to_thrd3_en = 
		   (exu_tlu_spill & spill_thrd3) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd3) |
           (lsu_async_vld_en_g[3] & ~lsu_async_vld_en_w2[3]) |
			cwp_cmplt3;				// cwp completion always pended.
//
// added for bug 5436 - Niagara 2.0
assign pend_pich_cnt_adj[3] =
	      ((exu_tlu_spill & spill_thrd3) |
		  ((ffu_tlu_trap_ieee754 | ffu_tlu_trap_other | ffu_tlu_trap_ue) & fp_trap_thrd3) |
           (lsu_async_vld_en_g[3] & ~lsu_async_vld_en_w2[3])) & pic_cnt_en[3];

assign	pend_to_thrd3_reset =
	local_rst |	pending_thrd3_event_taken; 

// modified to arbitrate between wsr instruction and asynchronous events
// due to there is only one write port to tsa
// modified for bug 3827
assign pending_thrd3_event_taken = 
            pending_trap_sel[3] & ~(sync_trap_taken_g | dnrtry_inst_g | 
            tsa_wr_tid_sel_g | ifu_thrd_flush_w[3] | (tlu_gl_rw_g & wsr_inst_g)); 

//
assign pend_ttype3[9-1:0] = 
		(exu_tlu_spill & spill_thrd3) ? 
         exu_spill_ttype[9-1:0] :
		(((ffu_tlu_trap_other | ffu_tlu_trap_ieee754 | ffu_tlu_trap_ue) & fp_trap_thrd3) ? 
           ffu_async_ttype[9-1:0] :
           dmmu_async_ttype[9-1:0]);
//
dffre_s #(12) dffre_pendthrd3 (
    .din ({pend_to_thrd3_en,pend_ttype3[8:0],cwp_cmplt3,exu_tlu_cwp_retry}), 
	.q   ({pending_trap3,pending_ttype3[8:0],cwp_cmplt3_pending,cwp_retry3}),
    .rst (pend_to_thrd3_reset), 
    .en  (pend_to_thrd3_en), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// added for bug 5436 - Niagara 2.0
//assign pich_cnt_hld_rst[`TLU_THRD_NUM-1:0] = 
//           (thread_inst_vld_w2[`TLU_THRD_NUM-1:0] & {4{pic_cnt_en_w2}} |
//           {4{local_rst}});  

// fix for 5436 for reopend bugs(9/8/2004) related to flushed inst reseting the hold
// and b2b valid instruction; the 1st one reseting the hold, but the 2nd not incrementing
// since the hold was not reset early to allow the 2nd inst to incr_pich.

assign pich_cnt_hld_rst_g[3:0] = 
			(thread_inst_vld_g[3:0] & {4{pic_cnt_en_w}}) &
			{4{~(lsu_ttype_vld_w | tlu_flush_all_w)}};


dff_s #(4) dff_pich_cnt_hld_rst_g (
    .din (pich_cnt_hld_rst_g[3:0]),
    .q   (pich_cnt_hld_rst_w2[3:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);


assign pend_pich_cnt_hld_early[3:0] = pend_pich_cnt_hld_q[3:0] & ~pich_cnt_hld_rst_w2[3:0];

assign pend_pich_cnt_hld[3:0] = pend_pich_cnt_hld_early[3:0];

// following is used in pib_wrap_m logic as per bug5436(reopened 9/17/04).
assign pend_pich_cnt_hld_noqual[3:0] = pend_pich_cnt_hld_q[3:0];

dffre_s dffre_pend_pich_cnt_adj_0 (
    .din (pend_pich_cnt_adj[0]),
	.q   (pend_pich_cnt_hld_q[0]),
    .rst (local_rst | pich_cnt_hld_rst_w2[0]), 
    .en  (pend_pich_cnt_adj[0]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_pend_pich_cnt_adj_1 (
    .din (pend_pich_cnt_adj[1]),
	.q   (pend_pich_cnt_hld_q[1]),
    .rst (local_rst | pich_cnt_hld_rst_w2[1]), 
    .en  (pend_pich_cnt_adj[1]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_pend_pich_cnt_adj_2 (
    .din (pend_pich_cnt_adj[2]),
	.q   (pend_pich_cnt_hld_q[2]),
    .rst (local_rst | pich_cnt_hld_rst_w2[2]), 
    .en  (pend_pich_cnt_adj[2]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_pend_pich_cnt_adj_3 (
    .din (pend_pich_cnt_adj[3]),
	.q   (pend_pich_cnt_hld_q[3]),
    .rst (local_rst | pich_cnt_hld_rst_w2[3]), 
    .en  (pend_pich_cnt_adj[3]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);


assign	trap_taken_g = 	thrd0_traps | thrd1_traps | thrd2_traps | thrd3_traps;
// 
// added for timing 
dff_s dff_trap_taken_w2 (
    .din (trap_taken_g), 	
    .q   (trap_taken_w2),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// Selection of traps should be round-robin.
assign	trap_tid_g[1:0] = 
    // lsu_defr_trap_g ? thrid_w2[1:0] :
	((sync_trap_taken_g) | (dnrtry_inst_g & cwp_fastcmplt_g))  ? thrid_g[1:0] :
			(pending_trap_sel[0] ? 2'b00 : 
				(pending_trap_sel[1] ? 2'b01 : 
					(pending_trap_sel[2] ? 2'b10 : 2'b11))); 

assign pend_trap_tid_g[1:0] = 
	       pending_trap_sel[0] ? 2'b00 : 
		       (pending_trap_sel[1] ? 2'b01 : 
			       (pending_trap_sel[2] ? 2'b10 : 
                        2'b11)); 

dff_s #(2) dff_pend_trap_tid_w2 (
    .din (pend_trap_tid_g[1:0]),
    .q   (pend_trap_tid_w2[1:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);


// Assume fixed priority for now. Should change to round-robin selection !!!

// modified for bug 1806
// modified to support lsu deferred traps - modified for timing
// modified for bug 4640 and 5127
//
assign	reset_sel_g = 
            rstint_g | (sir_inst_g & ~(lsu_defr_trap_g | pib_wrap_trap_g |
            (|tlz_trap_g[4-1:0]))) | rst_tri_en;
            // rstint_g | (sir_inst_g & ~lsu_defr_trap_g) | rst_tri_en;
//
// added for timing
dffr_s dffr_reset_sel_w2 (
   .din (reset_sel_g),
   .q   (reset_sel_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);
// 
// modified for timing
// assign	reset_defr_id_g[6:0] =
assign	reset_id_g[2:0] =
local_rst ? 3'b001 :	
	rstint_g ? rstid_g[2:0] :
		sir_inst_g ? 3'b100 :  
                3'bxxx;

// recoded for timing
//
// construct the tba_ttype to determine the tba 
// the trap is hypervisor or supervisor traps
// modified for bug 3634 and timing

assign tba_ttype_sel_w2 = 
           final_ttype_sel_w2[0] | (hyper_wdr_trap_w2 & ~lsu_defr_trap_w2);  

mux2ds #(9) mx_tba_ttype_w2 (
    .sel0 (tba_ttype_sel_w2),
    .sel1 (~tba_ttype_sel_w2),
    .in0  ({2'b0,rst_hwdr_ttype_w2[9-3:0]}),
    .in1  (final_ttype_w2[9-1:0]),
    .dout (tba_ttype_w1[9-1:0])
); 
/*
assign tba_ttype_sel_g[0] = 
               (rstint_g | rst_tri_en | ((hwint_g | swint_g | hyper_wdr_trap | 
               (|tlz_trap_g[`TLU_THRD_NUM-1:0] | sir_inst_g) | pib_wrap_trap_g) & 
                inst_vld_g & ~lsu_defr_trap_g); 
assign tba_ttype_sel_g[1] = 
           (((ifu_ttype_vld_g |  exu_ttype_vld_g | va_oor_inst_acc_excp_g) |  
            (local_sync_trap_g & ~(lsu_tlu_priv_action_g | misalign_addr_ldst_atm_g))) & 
           ~(reset_sel_g | hwint_g | swint_g | hyper_wdr_trap | (|tlz_trap_g[`TLU_THRD_NUM-1:0])) & 
             inst_vld_g) & ~lsu_defr_trap_g & ~pib_wrap_trap_g;
assign tba_ttype_sel_g[2] = 
           (((lsu_tlu_ttype_vld_m2 & inst_vld_g) | va_oor_data_acc_excp_g) & 
           ~(|tba_ttype_sel_g[1:0])) | (lsu_defr_trap_g & ~(rstint_g | rst_tri_en)); 
assign tba_ttype_sel_g[3] = 
           ~(|tba_ttype_sel_g[2:0]); 

// added for timing
dffr_s #(4) dffr_tba_ttype_sel_w2 (
    .din (tba_ttype_sel_g[3:0]),
    .q   (tba_ttype_sel_w2[3:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
mux4ds #(`TSA_TTYPE_WIDTH) mx_tba_ttype_w2 (
    .sel0 (tba_ttype_sel_w2[0]),
    .sel1 (tba_ttype_sel_w2[1]),
    .sel2 (tba_ttype_sel_w2[2]),
    .sel3 (tba_ttype_sel_w2[3]),
    .in0  ({2'b0,rst_hwdr_ttype_w2[`TSA_TTYPE_WIDTH-3:0]}),
    .in1  (early_sync_ttype_w2[`TSA_TTYPE_WIDTH-1:0]),
    .in2  (adj_lsu_ttype_w2[`TSA_TTYPE_WIDTH-1:0]),
    .in3  (pending_ttype_w2[`TSA_TTYPE_WIDTH-1:0]),
    .dout (tba_ttype_w1[`TSA_TTYPE_WIDTH-1:0])
); 

dff_s #(`TSA_TTYPE_WIDTH) dff_tba_ttype_w1 (
    .din (tba_ttype_g[`TSA_TTYPE_WIDTH-1:0]), 
    .q   (tba_ttype_w1[`TSA_TTYPE_WIDTH-1:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
*/
//
// construct the final_ttype to be written into the trap stack 
// modified for bug 3634, 4640 and timing  
assign final_ttype_sel_g[0] = 
            (rstint_g | rst_tri_en) | ((hwint_g | swint_g | sir_inst_g |
            (|tlz_trap_g[4-1:0]) | pib_wrap_trap_g) & inst_vld_g &
            ~lsu_defr_trap_g);
//             reset_sel_g | ((hwint_g | swint_g |
//             (|tlz_trap_g[`TLU_THRD_NUM-1:0]) | pib_wrap_trap_g) & inst_vld_g &
//             ~lsu_defr_trap_g);

assign final_ttype_sel_g[1] = 
           (((ifu_ttype_vld_g | exu_ttype_vld_g | va_oor_inst_acc_excp_g) |  
            (local_sync_trap_g & ~(lsu_tlu_priv_action_g | misalign_addr_ldst_atm_g))) & 
           ~(rstint_g | sir_inst_g  | hwint_g | swint_g | rst_tri_en | (|tlz_trap_g[4-1:0])) & 
             inst_vld_g) & ~lsu_defr_trap_g & ~pib_wrap_trap_g; 
assign final_ttype_sel_g[2] = 
           ((lsu_tlu_ttype_vld_m2 & inst_vld_g) | va_oor_data_acc_excp_g)  & 
           ~(|final_ttype_sel_g[1:0]) | (lsu_defr_trap_g & ~(rst_tri_en | rstint_g)); 
assign final_ttype_sel_g[3] = 
           ~(|final_ttype_sel_g[2:0]);
//
// added for timing
dffr_s #(4) dffr_final_ttype_sel_w2 (
    .din (final_ttype_sel_g[3:0]),
    .q   (final_ttype_sel_w2[3:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// modified for timing
/*
mux3ds #(`TSA_TTYPE_WIDTH) mx_adj_lsu_ttype_m2 (
    .sel0 (lsu_defr_trap_g),
    .sel1 (va_oor_data_acc_excp_g & ~lsu_defr_trap_g),
    .sel2 (~(va_oor_data_acc_excp_g | lsu_defr_trap_g)),
    .in0  ({2'b0, lsu_tlu_async_ttype_g[6:0]}),
    .in1  (9'h030),
    .in2  (lsu_tlu_ttype_m2),
    .dout (adj_lsu_ttype_m2[`TSA_TTYPE_WIDTH-1:0])
); 
*/
// added for timing 
dff_s #(9) dff_lsu_tlu_ttype_w2 (
    .din (lsu_tlu_ttype_m2[9-1:0]), 
    .q   (lsu_tlu_ttype_w2[9-1:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
//
/*
dff_s #(`TSA_TTYPE_WIDTH-2) dff_lsu_tlu_async_ttype_w2 (
    .din (lsu_tlu_async_ttype_g[`TSA_TTYPE_WIDTH-3:0]), 
    .q   (lsu_tlu_async_ttype_w2[`TSA_TTYPE_WIDTH-3:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
*/ 
mux3ds #(9) mx_adj_lsu_ttype_w2 (
    .sel0 (lsu_defr_trap_w2),
    .sel1 (va_oor_data_acc_excp_w2 & ~lsu_defr_trap_w2),
    .sel2 (~(va_oor_data_acc_excp_w2 | lsu_defr_trap_w2)),
    // modified for bug 4561
    // .in0  ({2'b0, lsu_tlu_async_ttype_w2[6:0]}),
    .in0  (9'h032),
    .in1  (9'h030),
    .in2  (lsu_tlu_ttype_w2[9-1:0]),
    .dout (adj_lsu_ttype_w2[9-1:0])
); 
//
// modified for timing 
mux4ds #(9) mx_final_ttype_w2 (
    .sel0 (final_ttype_sel_w2[0]),
    .sel1 (final_ttype_sel_w2[1]),
    .sel2 (final_ttype_sel_w2[2]),
    .sel3 (final_ttype_sel_w2[3]),
    .in0  ({2'b0,rst_ttype_w2[9-3:0]}),
    .in1  (early_sync_ttype_w2[9-1:0]),
    .in2  (adj_lsu_ttype_w2[9-1:0]),
    .in3  (pending_ttype_w2[9-1:0]),
    .dout (final_ttype_w2[9-1:0])
); 
//
// modified for timing
/*
dff_s #(`TSA_TTYPE_WIDTH) dff_tlu_final_ttype_w2 (
    .din (final_ttype_g[`TSA_TTYPE_WIDTH-1:0]),
    .q   (final_ttype_w2[`TSA_TTYPE_WIDTH-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),          
    .so  ()
);
*/

assign tlu_final_ttype_w2[9-1:0] =
           final_ttype_w2[9-1:0];
//
// added for timing
// pending trap type 
assign onehot_pending_ttype_sel = ~(|pending_trap_sel[2:0]);
//
mux4ds #(9) mx_pending_ttype (
    .sel0 (pending_trap_sel[0]),
    .sel1 (pending_trap_sel[1]),
	.sel2 (pending_trap_sel[2]),
	.sel3 (onehot_pending_ttype_sel),
    .in0  (pending_ttype0[9-1:0]),
    .in1  (pending_ttype1[9-1:0]),
    .in2  (pending_ttype2[9-1:0]),
    .in3  (pending_ttype3[9-1:0]),
    .dout (pending_ttype[9-1:0])
); 
//
// added for timing 
dff_s #(9) dff_pending_ttype_w2 (
    .din (pending_ttype[9-1:0]), 
    .q   (pending_ttype_w2[9-1:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
//
// modified for timing and bug 5117
assign rst_ttype_sel[0] = reset_sel_g; 
// modified for bug 5127
assign rst_ttype_sel[1] = 
           ((|tlz_trap_g[4-1:0]) | pib_wrap_trap_g); 
           // ~(rstint_g | rst_tri_en); 
           // ((|tlz_trap_g[`TLU_THRD_NUM-1:0]) | pib_wrap_trap_g) & ~reset_sel_g; 
// assign rst_ttype_sel[2] = ~(|rst_ttype_sel[1:0]); 

// reset ttype  
// modified for bug 3634 and bug 3705
// modified for timing and bug 5117
assign rst_hwint_ttype_g[9-3:0] = 
           (rst_ttype_sel[0])? {4'b00,reset_id_g[2:0]}:
          ((rst_ttype_sel[1])? wrap_tlz_ttype[6:0]:
            7'h60);  

dff_s #(9-2) dff_rst_hwint_ttype_w2 (
    .din (rst_hwint_ttype_g[9-3:0]),
    .q   (rst_hwint_ttype_w2[9-3:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);

dffr_s dffr_rst_hwint_sel_w2 (
    .din ((|rst_ttype_sel[1:0]) | hwint_g),
    .q   (rst_hwint_sel_w2),
    .clk (clk),
    .se  (se),  
    .rst (local_rst),
    .si  (), 
    .so  ()
);

assign rst_ttype_w2[9-3:0] =
       (rst_hwint_sel_w2)? rst_hwint_ttype_w2[9-3:0]:
        final_swint_id_w2[9-3:0];  
       
/*
mux3ds #(`TSA_TTYPE_WIDTH-2) mx_rst_ttype_g (
    .sel0  (rst_ttype_sel[0]),
    .sel1  (rst_ttype_sel[1]),
	.sel2  (rst_ttype_sel[2]),
    .in0 ({4'b00,reset_id_g[2:0]}),
    .in1 (wrap_tlz_ttype[6:0]),
    .in2 (hwint_swint_ttype[6:0]),
    .dout (rst_ttype_g[`TSA_TTYPE_WIDTH-3:0])
); 
//
// added for timing 
dff_s #(`TSA_TTYPE_WIDTH-2) dff_rst_ttype_w2 (
    .din (rst_ttype_g[`TSA_TTYPE_WIDTH-3:0]),
    .q   (rst_ttype_w2[`TSA_TTYPE_WIDTH-3:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
// modified for timing

assign rst_hwdr_ttype_sel[0] = reset_sel_g; 
assign rst_hwdr_ttype_sel[1] = hyper_wdr_trap & ~reset_sel_g;
assign rst_hwdr_ttype_sel[2] = 
           ((|tlz_trap_g[`TLU_THRD_NUM-1:0]) | pib_wrap_trap_g) & 
           ~(|rst_hwdr_ttype_sel[1:0]); 
assign rst_hwdr_ttype_sel[3] = ~(|rst_hwdr_ttype_sel[2:0]);

mux2ds #(`TSA_TTYPE_WIDTH-2) mx_hwint_swint_ttype (
    .sel0 (hwint_g),
    .sel1 (~hwint_g),
    .in0  (`HWINT_INT),
    .in1  (final_swint_id[6:0]),
    .dout (hwint_swint_ttype[6:0])
); 
*/

mux2ds #(9-2) mx_wrap_tlz_ttype (
    .sel0 (|tlz_trap_g[4-1:0]),
    .sel1 (~(|tlz_trap_g[4-1:0])),
    .in0  (7'h5f),
    .in1  (7'h4f),
    .dout (wrap_tlz_ttype[6:0])
); 
//
// modified for timing
assign rst_hwdr_ttype_sel_w2 = hyper_wdr_trap_w2 & ~reset_sel_w2;

mux2ds #(9-2) mx_rst_hwdr_ttype_w2 (
    .sel0  (rst_hwdr_ttype_sel_w2),
    .sel1  (~rst_hwdr_ttype_sel_w2),
    .in0 ({7'b0000010}),
    .in1 (rst_ttype_w2[9-3:0]),
    .dout (rst_hwdr_ttype_w2[9-3:0])
); 
//
/*
mux4ds #(`TSA_TTYPE_WIDTH-2) mx_rst_hwdr_ttype (
    .sel0  (rst_hwdr_ttype_sel[0]),
    .sel1  (rst_hwdr_ttype_sel[1]),
	.sel2  (rst_hwdr_ttype_sel[2]),
	.sel3  (rst_hwdr_ttype_sel[3]),
    .in0 ({4'b00,reset_id_g[2:0]}),
    .in1 ({7'b0000010}),
    .in2 (wrap_tlz_ttype[6:0]),
    .in3 (hwint_swint_ttype[6:0]),
    .dout (rst_hwdr_ttype_g[`TSA_TTYPE_WIDTH-3:0])
); 
//
// added for timing
dff_s #(`TSA_TTYPE_WIDTH-2) dff_rst_hwdr_ttype_w2 (
    .din (rst_hwdr_ttype_g[`TSA_TTYPE_WIDTH-3:0]), 
    .q   (rst_hwdr_ttype_w2[`TSA_TTYPE_WIDTH-3:0]),
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);
*/
//
// construct the early_ttype_g for timing to determine whether
// the trap is hypervisor or supervisor traps
// modified for bug 3646, 5117 and timing
assign early_ttype_sel[0] = 
             reset_sel_g | hwint_g | (|tlz_trap_g[4-1:0]);
             // reset_sel_g | hwint_g | swint_g | (|tlz_trap_g[`TLU_THRD_NUM-1:0]);
assign early_ttype_sel[1] = 
            local_early_flush_pipe_w;
            // local_early_flush_pipe_w & ~(reset_sel_g | hwint_g | swint_g | 
            // (|tlz_trap_g[`TLU_THRD_NUM-1:0])); 
assign early_ttype_sel[2] = 
            ~inst_vld_nf_g | inst_ifu_flush_w | ~(|early_ttype_sel[1:0]);

assign early_ttype_g[9-1:0] =
           (early_ttype_sel[2])? pending_ttype[9-1:0]:
           (early_ttype_sel[0])? {2'b0,rst_hwint_ttype_g[9-3:0]}:
           // (early_ttype_sel[0])? {2'b0,rst_ttype_g[`TSA_TTYPE_WIDTH-3:0]}:
            early_sync_ttype_g[9-1:0]; 
/*
assign early_ttype_sel[0] = 
            reset_sel_g | ((hwint_g | swint_g | (|tlz_trap_g[`TLU_THRD_NUM-1:0])) & 
            inst_vld_g) ; 
assign early_ttype_sel[1] = 
            (local_early_flush_pipe_w & ~ifu_tlu_flush_fd_w) & ~rst_tri_en & 
           ~((reset_sel_g | hwint_g | swint_g | (|tlz_trap_g[`TLU_THRD_NUM-1:0])) & inst_vld_g);
assign early_ttype_sel[2] = 
            ~(|early_ttype_sel[1:0]);
//
mux3ds #(`TSA_TTYPE_WIDTH) mx_early_ttype (
    .sel0 (early_ttype_sel[0]),
    .sel1 (early_ttype_sel[1]),
    .sel2 (early_ttype_sel[2]),
    .in0  ({2'b0,rst_ttype_g[`TSA_TTYPE_WIDTH-3:0]}),
    .in1  (early_sync_ttype_g[`TSA_TTYPE_WIDTH-1:0]),
    .in2  (pending_ttype[`TSA_TTYPE_WIDTH-1:0]),
    .dout (early_ttype_g[`TSA_TTYPE_WIDTH-1:0])
); 
*/
//
// recoded for timing
assign final_offset_en_g[0] = trap_to_redmode & ~(sir_inst_g | internal_wdr);
assign final_offset_en_g[1] = internal_wdr & ~final_offset_en_g[0]; 
// modified due to one-hot mux bug
// assign final_offset_en_g[2] = ~(|final_offset_en_g[1:0]); 

dffr_s #(2) dffr_final_offset_en_w1 (
    .din (final_offset_en_g[1:0]), 
    .q   (final_offset_en_w1[1:0]),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so  ()
);

assign final_offset_sel_w1[2] = 
           ~(|final_offset_sel_w1[1:0]);
assign final_offset_sel_w1[1] = 
           final_offset_en_w1[1] & ~rst_tri_en;
assign final_offset_sel_w1[0] = 
           final_offset_en_w1[0] & ~rst_tri_en;

mux3ds #(9) mx_final_offset_w1 (
    .sel0 (final_offset_sel_w1[0]),
    .sel1 (final_offset_sel_w1[1]),
    .sel2 (final_offset_sel_w1[2]),
    .in0  (9'b000000101),
    .in1  (9'b000000010),
    .in2  (tba_ttype_w1[9-1:0]),
    .dout (final_offset_w1[9-1:0])
); 

assign tlu_final_offset_w1[9-1:0] =
           final_offset_w1[9-1:0];
// 
// generating the trap pc and trap npc
// This section has been modified due to bug 3017 
// pc and npc has been changed from 48 -> 49 bits
// added for one-hot mux problem
assign tlu_pc_mxsel_w2[0] = 
           tlu_self_boot_rst_w2 | rst_tri_en; 
// modified for bug 3710
assign tlu_pc_mxsel_w2[1] = 
           local_select_tba_w2 & ~(rst_tri_en | tlu_self_boot_rst_w2); 
assign tlu_pc_mxsel_w2[2] = 
           ~(|tlu_pc_mxsel_w2[1:0]); 
//
/* logic moved to tlu_misctl
assign	normal_trap_pc_w1 [48:0] = 
            {1'b0, tlu_partial_trap_pc_w1[33:0],final_offset_w1[`TSA_TTYPE_WIDTH-1:0],
             5'b00000};
assign	normal_trap_npc_w1[48:0] = 
            {1'b0, tlu_partial_trap_pc_w1[33:0],final_offset_w1[`TSA_TTYPE_WIDTH-1:0],
             5'b00100};
//
// code moved from tlu_tdp
mux2ds #(49) mx_trap_pc_w1 (
       .in0  (normal_trap_pc_w1[48:0]), 
       .in1  (tlu_restore_pc_w1[48:0]),
       .sel0 (~restore_pc_sel_w1),  
       .sel1 (restore_pc_sel_w1),
       .dout (trap_pc_w1[48:0])
);           
//
dff_s #(49) dff_trap_pc_w2 (
    .din (trap_pc_w1[48:0]), 	
    .q   (trap_pc_w2[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_ifu_trappc_w2[48:0] = trap_pc_w2[48:0];

mux2ds #(49) mx_trap_npc_w1 (
       .in0  (normal_trap_npc_w1[48:0]), 
       .in1  (tlu_restore_npc_w1[48:0]),
       .sel0 (~restore_pc_sel_w1),  
       .sel1 (restore_pc_sel_w1),
       .dout (trap_npc_w1[48:0])
);           
//
dff_s #(49) dff_trap_npc_w2 (
    .din (trap_npc_w1[48:0]), 	
    .q   (trap_npc_w2[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_ifu_trapnpc_w2[48:0] = trap_npc_w2[48:0];
*/

// determine whether to generate a watch-dog reset using htba as the 
// trap base address instead of the watch-dog reset vector
// added for bug 1894 and modified for bug 1964
// modified for timing 
assign hyper_wdr_early_trap_g = ((true_trap_tid_g[1:0] == 2'b00) ? 
               (tlu_hpstate_enb[0] & ~tlu_hpstate_priv[0] & trp_lvl_at_maxstl[0]):
              ((true_trap_tid_g[1:0] == 2'b01) ? 
                   (tlu_hpstate_enb[1] & ~tlu_hpstate_priv[1] & trp_lvl_at_maxstl[1]):
                  ((true_trap_tid_g[1:0] == 2'b10) ? 
                       (tlu_hpstate_enb[2] & ~tlu_hpstate_priv[2] & trp_lvl_at_maxstl[2]):
                       (tlu_hpstate_enb[3] & ~tlu_hpstate_priv[3] & trp_lvl_at_maxstl[3]))));

dffr_s dffr_hyper_wdr_early_trap_w2 (
   .din (hyper_wdr_early_trap_g),
   .q   (hyper_wdr_early_trap_w2),
   .rst (local_rst),
   .clk (clk),
   .se  (se),       
   .si  (),          
   .so  ()
);

assign hyper_wdr_trap_w2 = 
           hyper_wdr_early_trap_w2 & (tlu_priv_traps_w2 & ~lsu_defr_trap_w2);  
//
// detetermine whehter the trapping thread is in hyperlite mode or is at
// maxstl
// modified for timing and bug 4779
/*
assign tlu_trap_to_hyper_g =  
           (true_trap_tid_g[1:0] == 2'b00) ? 
               (~tlu_hpstate_enb[0] | tlu_hpstate_priv[0] | trp_lvl_gte_maxstl[0]):
              ((true_trap_tid_g[1:0] == 2'b01) ? 
                   (~tlu_hpstate_enb[1] | tlu_hpstate_priv[1] | trp_lvl_gte_maxstl[1]):
                  ((true_trap_tid_g[1:0] == 2'b10) ? 
                       (~tlu_hpstate_enb[2] | tlu_hpstate_priv[2] | trp_lvl_gte_maxstl[2]):
                       (~tlu_hpstate_enb[3] | tlu_hpstate_priv[3] | trp_lvl_gte_maxstl[3])));
*/
//
assign tlu_trap_to_hyper_g =  
           (true_trap_tid_g[1:0] == 2'b00) ? 
               (~tlu_hpstate_enb[0] | tlu_hpstate_priv[0] | 
                 trp_lvl_gte_maxstl[0] | (tlz_trap_g[0] & inst_vld_g)):
              ((true_trap_tid_g[1:0] == 2'b01) ? 
                   (~tlu_hpstate_enb[1] | tlu_hpstate_priv[1] | 
                     trp_lvl_gte_maxstl[1] | (tlz_trap_g[1] & inst_vld_g)):
                  ((true_trap_tid_g[1:0] == 2'b10) ? 
                       (~tlu_hpstate_enb[2] | tlu_hpstate_priv[2] | 
                         trp_lvl_gte_maxstl[2] | (tlz_trap_g[2] & inst_vld_g)):
                       (~tlu_hpstate_enb[3] | tlu_hpstate_priv[3] | 
                         trp_lvl_gte_maxstl[3] | (tlz_trap_g[3] & inst_vld_g))));
// added for timing
dffr_s dffr_tlu_tlu_trap_to_hyper_w2 (
    .din (tlu_trap_to_hyper_g),
    .q   (tlu_trap_to_hyper_w2),
    .clk (clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);
                          
// recoded for timing
assign select_tba_element_w2[0] =
           ~(tlu_trap_to_hyper_w2 | lsu_defr_trap_w2) & tlu_early_priv_element_w2[0];
assign select_tba_element_w2[1] =
           ~tlu_trap_to_hyper_w2 & (|tlu_early_priv_element_w2[2:1]) & ~lsu_defr_trap_w2;
assign local_select_tba_w2 = 
           ~tlu_trap_to_hyper_w2 & (tlu_priv_traps_w2 & ~lsu_defr_trap_w2); 
assign tdp_select_tba_w2 = local_select_tba_w2;
assign tlu_select_tba_w2 = 
           select_tba_element_w2[1] | (select_tba_element_w2[0] & ~lsu_ttype_vld_w2);
           
/*
dffr_s dffr_tlu_select_tba_w2 (
    .din (select_tba_g),
    .q   (tlu_select_tba_w2),
    .clk (clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
//
// added for bug 2064 and modified for bug 2165
// modified for bug3719
assign early_priv_traps_g = 
           ((early_ttype_g[8:4] == 5'b00001)    & (|early_ttype_g[3:0])) | 
           ((early_ttype_g[8:4] == 5'b00100)    & (|early_ttype_g[3:0])) | 
           ((early_ttype_g[8:4] == 5'b00010)    & ~(early_ttype_g[3] & early_ttype_g[0]))|  
           ((early_ttype_g[8:2] == 7'b0011000)  & (early_ttype_g[1] ^ early_ttype_g[0])) | 
           ((early_ttype_g[8:4] == 5'b00111)    & (early_ttype_g[3:2]== 2'b11))       | 
           (early_ttype_g[8] & ~early_ttype_g[7]) | (early_ttype_g[7] & ~early_ttype_g[8]) |
           (pib_wrap_trap_g & ~(|tlz_trap_g[4-1:0]) & inst_vld_g) | 
           (swint_g & ~(|tlz_trap_g[4-1:0]) & inst_vld_g); 

assign exu_hyper_traps_g = 
           exu_ttype_vld_g & ((early_ttype_g[8:0] == 9'h029) | (early_ttype_g[8:0] == 9'h034));

//
// modified for timing

assign tlu_early_priv_element_g[0] = 
          early_priv_traps_g & early_ttype_sel[2]; 
assign tlu_early_priv_element_g[1] = 
           early_priv_traps_g & ~early_ttype_sel[2];
// modified for bug 4431, 4443
assign tlu_early_priv_element_g[2] = 
          lsu_tlu_wtchpt_trp_g & ~(misalign_addr_jmpl_rtn_g | misalign_addr_ldst_atm_g | 
          ifu_ttype_vld_g | exu_hyper_traps_g | lsu_tlu_priv_action_g);
//          lsu_tlu_wtchpt_trp_g & ~(lsu_tlu_priv_violtn_g | misalign_addr_jmpl_rtn_g |
//
// modified for added for timing
dffr_s #(3) dffr_tlu_early_priv_element_w2 (
    .din (tlu_early_priv_element_g[2:0]),
	.q   (tlu_early_priv_element_w2[2:0]),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_priv_traps_w2 =
            tlu_early_priv_element_w2[0] & ~lsu_ttype_vld_w2 |
            tlu_early_priv_element_w2[1] |
            tlu_early_priv_element_w2[2]; 

dffr_s dffr_tlu_self_boot_rst_w2 (
    .din (tlu_self_boot_rst_g),
	.q   (tlu_self_boot_rst_w2),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);

//=========================================================================================
//	Generate TSA Control and Data
//=========================================================================================

// MODIFY : keep 2b tid
// added for tsa_wr_tid bug
// modified for hypervisor support  and logic loop 
// modified for timing
//
assign tsa_wr_tid_sel_g = 
           wsr_inst_g_unflushed & inst_vld_g & (tstate_rw_g | tpc_rw_g | 
           tnpc_rw_g  | ttype_rw_g | tlu_htstate_rw_g); 

// added for timing

assign tsa_wr_tid_sel_tim_g = 
           (((wsr_inst_g & (tstate_rw_g | tpc_rw_g | 
            tnpc_rw_g  | ttype_rw_g | tlu_htstate_rw_g)) |
           ((retry_inst_g | done_inst_g) & cwp_fastcmplt_g)) &
            inst_vld_g) | sync_trap_taken_g ; 

dffr_s dffr_tsa_wr_tid_sel_w2 (
    .din (tsa_wr_tid_sel_tim_g),
	.q   (tsa_wr_tid_sel_w2),
    .clk (clk),
    .rst (local_rst),
    .se  (se),
    .si  (),
    .so  ()
);
/*
assign tsa_wr_tid_sel_w2 = 
           (((wsr_inst_w2 & (tstate_rw_w2 | tpc_rw_w2 | 
            tnpc_rw_w2  | ttype_rw_w2 | htstate_rw_w2)) |
           ((retry_inst_w2 | done_inst_w2) & cwp_fastcmplt_w2)) &
            inst_vld_w2) | sync_trap_taken_w2 ; 
*/
//
// added for timing
assign	thrid_w2[0] = thread1_wsel_w2 | thread3_wsel_w2;
assign	thrid_w2[1] = thread2_wsel_w2 | thread3_wsel_w2;
//
// 
// modified for bug 4403
/*
mux2ds #(2) mx_tsa_wr_tid (
    .in0  (pend_trap_tid_w2[1:0]),
	.in1  (thrid_w2[1:0]),
    .sel0 (~tsa_wr_tid_sel_w2),  		
    .sel1 (tsa_wr_tid_sel_w2),
    .dout (tsa_wr_tid[1:0])
);
*/
// modified for bug 4403 dn 4443
assign tsa_wr_tid[1:0] = 
           (tsa_wr_tid_sel_w2 & lsu_defr_trap_w2) ? true_trap_tid_w2[1:0]:
           ((tsa_wr_tid_sel_w2 & ~lsu_defr_trap_w2)? thrid_w2[1:0] :
             pend_trap_tid_w2[1:0]);

// tsa should not be written by certain resets. May have to extend to wrm etc. !!!
// modified due to the swap of memory from tlu_tsa -> bw_r_rf32x144 -> 2x bw_r_rf32x80
// modified for bug 3384
assign	tsa_wr_vld[0] = 	
             trap_taken_w2 | local_rst |               // a thread traps
			((tpc_rw_w2 | tstate_rw_w2) & wsr_inst_w2); // wrpr-tsa

assign	tsa_wr_vld[1] = 	
 			 trap_taken_w2 | local_rst   | 		        // a thread traps
			((tnpc_rw_w2   | ttype_rw_w2 | 
             htstate_rw_w2) & wsr_inst_w2); // wrpr-tsa
// 
// modified due to timing all w stage signals have been moved to w2	
assign	tsa_pc_en  	    = 	tpc_rw_w2  	 | trap_taken_w2;
assign	tsa_npc_en  	= 	tnpc_rw_w2 	 | trap_taken_w2;
assign	tsa_tstate_en  	= 	tstate_rw_w2 | trap_taken_w2;
assign	tsa_ttype_en  	= 	ttype_rw_w2  | trap_taken_w2 | local_rst;
//
// added for hypervisor support
assign	tsa_htstate_en  = 	htstate_rw_w2 | trap_taken_w2;

// Should all these regs enable a read of the tsa ?
assign	tsa_rd_vld = 	ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d | // done/retry
			(tpc_rw_d | tnpc_rw_d | tstate_rw_d | ttype_rw_d |
			 // tick_rw_d | tba_rw_d | pstate_rw_d | tl_rw_d    |
             tlu_htstate_rw_d) & ifu_tlu_rsr_inst_d; // rdpr-tsa
//
// added for timing
dff_s dff_tsa_rd_vld_e ( 
    .din (tsa_rd_vld),
	.q   (tsa_rd_vld_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// added for timing
assign	tsa_rd_en = ifu_tlu_done_inst_d | ifu_tlu_retry_inst_d | // done/retry
                    (~(|sraddr2[4:2]) & ifu_tlu_rsr_inst_d); // rdpr-tsa
// 
dff_s #(4) dff_thread_wsel_w2 (
    .din ({thread3_wsel_g, thread2_wsel_g, thread1_wsel_g, thread0_wsel_g}),
    .q   ({thread3_wsel_w2, thread2_wsel_w2, thread1_wsel_w2, thread0_wsel_w2}),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign	tlu_thread_wsel_g[0] = thread0_rsel_dec_g; 
assign	tlu_thread_wsel_g[1] = thread1_rsel_dec_g; 
assign	tlu_thread_wsel_g[2] = thread2_rsel_dec_g; 
assign	tlu_thread_wsel_g[3] = thread3_rsel_dec_g; 
//
// Added for tsa_wr_tid bug
//
assign	thread0_wtrp_w2 = ~tsa_wr_tid[1] & ~tsa_wr_tid[0];
assign	thread1_wtrp_w2 = ~tsa_wr_tid[1] &  tsa_wr_tid[0];
assign	thread2_wtrp_w2 =  tsa_wr_tid[1] & ~tsa_wr_tid[0];
assign	thread3_wtrp_w2 =  tsa_wr_tid[1] &  tsa_wr_tid[0];

// write uses trp-lvl after increment.
mux4ds #(3) tsawthrd (
   .in0  (trp_lvl0_new[2:0]),
   .in1  (trp_lvl1_new[2:0]),
   .in2  (trp_lvl2_new[2:0]),
   .in3  (trp_lvl3_new[2:0]),
   .sel0 (thread0_wtrp_w2),
   .sel1 (thread1_wtrp_w2),
   .sel2 (thread2_wtrp_w2),
   .sel3 (thread3_wtrp_w2),
   .dout (tsa_wr_tpl[2:0])
); 

// rd use trp-lvl prior to decrement.
mux4ds  #(3) tsarthrd (
        .in0    (trp_lvl0[2:0]),
        .in1    (trp_lvl1[2:0]),
        .in2    (trp_lvl2[2:0]),
        .in3    (trp_lvl3[2:0]),
        .sel0   (thread0_rsel_d),
        .sel1   (thread1_rsel_d),
        .sel2   (thread2_rsel_d),
        .sel3   (thread3_rsel_d),
        .dout   (tsa_rd_tpl[2:0])
); 

assign	tsa_rd_tid[1:0]  = thrid_d[1:0];

//=========================================================================================
//      TT initial state
//=========================================================================================

// The initial state of TT should be 1 on por. Since this is required for 4 thread,
// it will be difficult to do this thru a write to the tsa while reset is occuring.
// Instead a bit will be used to mark whether the tt for a thread has been written to.
// If it hasn't then a '1' has to be inserted into the 
dff_s dff_rst_d1 (
    .din (local_rst),
    .q   (reset_d1),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign  tt_init_en =  reset_d1 & tlu_rst_l;
//
// modified for timing all g stage signals have been move to w2
assign  tt_init_rst[0] =  
            local_rst | (tsa_ttype_en & (|tsa_wr_vld[1:0]) & thread0_wtrp_w2);
assign  tt_init_rst[1] =  
            local_rst | (tsa_ttype_en & (|tsa_wr_vld[1:0]) & thread1_wtrp_w2);
assign  tt_init_rst[2] =  
            local_rst | (tsa_ttype_en & (|tsa_wr_vld[1:0]) & thread2_wtrp_w2);
assign  tt_init_rst[3] =  
            local_rst | (tsa_ttype_en & (|tsa_wr_vld[1:0]) & thread3_wtrp_w2);

assign	lsu_tlu_rsr_data_mod_e[7:0] = ttype_unwritten_sel ? 8'b0000_0001 : lsu_tlu_rsr_data_e[7:0];

dffre_s dffre_tt_init0  (
    .din (tt_init_en), 
    .q   (tt_unwritten[0]),
    .rst (tt_init_rst[0]),
    .en  (tt_init_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_tt_init1  (
    .din (tt_init_en), 
    .q   (tt_unwritten[1]),
    .rst (tt_init_rst[1]),
    .en  (tt_init_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_tt_init2  (
    .din (tt_init_en), 
    .q   (tt_unwritten[2]),
    .rst (tt_init_rst[2]),
    .en  (tt_init_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffre_tt_init3  (
    .din (tt_init_en), 
    .q   (tt_unwritten[3]),
    .rst (tt_init_rst[3]),
    .en  (tt_init_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
//	Decode SR Addr
//=========================================================================================

// **Exceptions for Write/Reads of Privileged/State Register**
// WRPR:
// - Access to reserved rd fields will cause exception. Done by IFU.
// - A write to TPC, TNPC, TT or TSTATE when the trap level is zero
// (TL=0) causes an illegal_instruction exception.
// - privileged opcode. Use privilege bit in sraddr for exception.
// WRSR :
// - privileged opcode. wrasr only - implementation dependent.
// - illegal inst - done by IFU.
// RDPR :
// - A read from TPC, TNPC, TT or TSTATE when the trap level is zero
// (TL=0) causes an illegal_instruction exception.
// - Access to reserved rs1 fields causes an illegal_inst exception.
// - privileged opcode.
// RDSR :
// - privileged opcode. rdasr only - implementation dependent.
// - Access to reserved rs1 fields causes an illegal_inst exception.
assign	sraddr[7-1:0]	=	
            ifu_tlu_sraddr_d[7-1:0];
assign	sraddr2[7-1:0] =	
            sraddr[7-1:0];
//
// added for hypervisor support
assign  asr_hyperp  =   sraddr2[6];
assign  asr_priv    =   sraddr2[5]; 

assign	stickcmp_rw_d 	=  sraddr2[4] & sraddr2[3] &  ~sraddr2[2] &  ~sraddr2[1] &  sraddr2[0] &
			~asr_priv;	// 
assign	stick_rw_d = sraddr2[4] & sraddr2[3] &  ~sraddr2[2] & ~sraddr2[1] & ~sraddr2[0]; 

assign	tpc_rw_d 	= ~sraddr[4] & ~sraddr[3] & ~sraddr[2] & ~sraddr[1] & ~sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	tnpc_rw_d 	= ~sraddr[4] & ~sraddr[3] & ~sraddr[2] & ~sraddr[1] &  sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	tstate_rw_d 	= ~sraddr[4] & ~sraddr[3] & ~sraddr[2] &  sraddr[1] & ~sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	ttype_rw_d 	= ~sraddr[4] & ~sraddr[3] & ~sraddr[2] &  sraddr[1] &  sraddr[0] &
			asr_priv;	// =1 ; privileged.

// stick and tick are refering to the same register.  
// - privileged action - rdtick only.
assign	tick_rw_d 	= ((~sraddr2[4] & ~sraddr2[3] &  sraddr2[2] & ~sraddr2[1] & ~sraddr2[0]) | 
                        stick_rw_d) & ~asr_hyperp; // =1 ; privileged.
// 
// modified for bug 1293
// qualified with the rsr read
assign	tick_npriv_r_d = (~sraddr2[4] & ~sraddr2[3] &  sraddr2[2] & ~sraddr2[1] & ~sraddr2[0] |
                          stick_rw_d) & ~asr_priv & ifu_tlu_rsr_inst_d;	// =0; non-privileged.

assign	tickcmp_rw_d 	=  sraddr2[4] & ~sraddr2[3] &  sraddr2[2] &  sraddr2[1] &  sraddr2[0] &
			~asr_priv;	// 
assign	tba_rw_d 	= ~sraddr[4] & ~sraddr[3] &  sraddr[2] & ~sraddr[1] &  sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	pstate_rw_d 	= ~sraddr[4] & ~sraddr[3] &  sraddr[2] &  sraddr[1] & ~sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	tl_rw_d 	= ~sraddr[4] & ~sraddr[3] &  sraddr[2] &  sraddr[1] &  sraddr[0] &
			asr_priv;	// =1 ; privileged.
assign	pil_rw_d 	= ~sraddr2[4] &  sraddr2[3] & ~sraddr2[2] & ~sraddr2[1] & ~sraddr2[0] &
			asr_priv;	// =1 ; privileged.
assign	set_sftint_d 	=  sraddr2[4] &  ~sraddr2[3] & sraddr2[2] & ~sraddr2[1] & ~sraddr2[0] &
                           ~(asr_priv | asr_hyperp);
assign	clr_sftint_d 	=  sraddr2[4] &  ~sraddr2[3] & sraddr2[2] & ~sraddr2[1] &  sraddr2[0] & 
                           ~(asr_priv | asr_hyperp);
assign	sftint_rg_rw_d  =  sraddr2[4] &  ~sraddr2[3] & sraddr2[2] &  sraddr2[1] & ~sraddr2[0] &
                           ~(asr_priv | asr_hyperp);
//
// pib register decodes
assign pcr_rsr_d = 
           (sraddr[7-1:0] == 7'b0010000); 
assign pic_rsr_d = 
           ((sraddr[7-1:0] == 7'b0110001) |
            (sraddr[7-1:0] == 7'b0010001));

// Bug 818 fix: The qualification to sraddr[5] is removed due to the sftint and tick_cmp registers
// are priveledged write state registers and not priveledged registers, therefore, the sraddr[5] is 
// not asserted for these
// modified due to timing
// assign	wsr_inst_d	= ifu_tlu_wsr_inst_d; 
//
// added for bug 1293
          
// Stage to E1.

dff_s dff_tpc_rw_e (
    .din (tpc_rw_d),
    .q   (tpc_rw_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tnpc_rw_e (
    .din (tnpc_rw_d),
    .q   (tnpc_rw_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tstate_rw_e (
    .din (tstate_rw_d),
    .q   (tstate_rw_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_ttype_rw_e (
    .din (ttype_rw_d),
    .q   (ttype_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tick_rw_e (
    .din (tick_rw_d),
    .q   (tick_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tick_npriv_r_e (
    .din (tick_npriv_r_d),
    .q   (tick_npriv_r_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tickcmp_rw_e (
    .din (tickcmp_rw_d),
    .q   (tickcmp_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tba_rw_e (
    .din (tba_rw_d),
    .q   (tba_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_pstate_rw_e (
    .din (pstate_rw_d),
    .q   (pstate_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tl_rw_d_e (
    .din (tl_rw_d),
    .q   (tl_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_pil_rw_d_e (
    .din (pil_rw_d),
    .q   (pil_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_set_sftint_e (
    .din (set_sftint_d),
    .q   (set_sftint_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_clr_sftint_e (
    .din (clr_sftint_d),
    .q   (clr_sftint_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_sftint_rg_rw_e (
    .din (sftint_rg_rw_d),
    .q   (sftint_rg_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pcr_rsr_e (
    .din (pcr_rsr_d),
    .q   (pcr_rsr_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_pic_rsr_e (
    .din (pic_rsr_d),
    .q   (pic_rsr_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// modified due to timing
/*
dff_s dff_wsr_inst_d_e (
    .din (wsr_inst_d),
    .q   (wsr_inst_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
assign	wsr_inst_e	= lsu_tlu_wsr_inst_e; 

dff_s dff_stickcmp_rw_e (
    .din (stickcmp_rw_d),
    .q   (stickcmp_rw_e),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
// Stage to E2.

dff_s dff_tpc_rw_m (
   .din (tpc_rw_e),
   .q   (tpc_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tnpc_rw_m (
   .din (tnpc_rw_e),
   .q   (tnpc_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tstate_rw_m (
    .din (tstate_rw_e),
    .q   (tstate_rw_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_ttype_rw_m (
   .din (ttype_rw_e),
   .q   (ttype_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tick_rw_m (
   .din (tick_rw_e),
   .q   (tick_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tick_npriv_r_m (
   .din (tick_npriv_r_e),
   .q   (tick_npriv_r_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tickcmp_rw_m (
   .din (tickcmp_rw_e),
   .q   (tickcmp_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
//
// added for timing - moved from hypervisor
dff_s dff_htickcmp_rw_m_m (
    .din (tlu_htickcmp_rw_e),
    .q   (htickcmp_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tba_rw_m (
   .din (tba_rw_e),
   .q   (tba_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_pstate_rw_m (
   .din (pstate_rw_e),
   .q   (pstate_rw_m),
   .clk (clk),
   .se  (se),
   .si  (),
   .so  ()
);
						
dff_s dff_tl_rw_m (
    .din (tl_rw_e),
    .q   (tl_rw_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_pil_rw_m (
    .din (pil_rw_e),
    .q   (pil_rw_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_set_sftint_m (
    .din (set_sftint_e),
    .q   (set_sftint_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_clr_sftint_m (
    .din (clr_sftint_e),
    .q   (clr_sftint_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_sftint_rg_rw_m (
    .din (sftint_rg_rw_e),
    .q   (sftint_rg_rw_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_wsr_inst_m (
    .din (wsr_inst_e),
    .q   (wsr_inst_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// added for hypervisor support
dff_s dff_stickcmp_rw_m (
    .din (stickcmp_rw_e),
    .q   (stickcmp_rw_m),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_tpc_rw_g (
    .din (tpc_rw_m),
    .q   (tpc_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tnpc_rw_g (
    .din (tnpc_rw_m),
    .q   (tnpc_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tstate_rw_g (
    .din (tstate_rw_m),
    .q   (tstate_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_ttype_rw_g (
    .din (ttype_rw_m),
    .q   (ttype_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tick_rw_g (
    .din (tick_rw_m),
    .q   (tick_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tick_npriv_r_g (
     .din (tick_npriv_r_m),
     .q   (tick_npriv_r_g),
     .clk (clk),
     .se  (se),
     .si  (),
     .so  ()
);
						
dff_s dff_tickcmp_rw_g (
     .din (tickcmp_rw_m),
     .q   (tickcmp_rw_g),
     .clk (clk),
     .se  (se),
     .si  (),
     .so  ()
);
//
// added for timing - moved form hyperv
dff_s dff_htickcmp_rw_m_g (
    .din (htickcmp_rw_m),
    .q   (htickcmp_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
						
dff_s dff_tba_rw_g (
     .din (tba_rw_m),
     .q   (tba_rw_g),
     .clk (clk),
     .se  (se),
     .si  (),
     .so  ()
);
						
dff_s dff_pstate_rw_g (
    .din (pstate_rw_m),
    .q   (pstate_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_pstate_rw_w2 (
    .din (pstate_rw_g),
    .q   (pstate_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_tl_rw_g (
    .din (tl_rw_m),
    .q   (tl_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_tl_rw_w2 (
    .din (tl_rw_g),
    .q   (tl_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_pil_rw_g (
    .din (pil_rw_m),
    .q   (pil_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_tpc_rw_w2 (
    .din (tpc_rw_g),
    .q   (tpc_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tnpc_rw_w2 (
    .din (tnpc_rw_g),
    .q   (tnpc_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_tstate_rw_w2 (
    .din (tstate_rw_g),
    .q   (tstate_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_ttype_rw_w2 (
    .din (ttype_rw_g),
    .q   (ttype_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_htstate_rw_w2 (
    .din (tlu_htstate_rw_g),
    .q   (htstate_rw_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_set_sftint_g (
    .din (set_sftint_m),
    .q   (set_sftint_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_clr_sftint_g (
    .din (clr_sftint_m),
    .q   (clr_sftint_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_sftint_rg_rw_g (
    .din (sftint_rg_rw_m),
    .q   (sftint_rg_rw_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
						
dff_s dff_wsr_inst_g (
    .din (wsr_inst_m),
    .q   (wsr_inst_g_unflushed),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_wsr_inst_w2 (
    .din (wsr_inst_g),
    .q   (wsr_inst_w2),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s dff_tlu_gl_rw_g (
    .din (tlu_gl_rw_m),
    .q   (tlu_gl_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// added for hypervisor support
dff_s dff_stickcmp_rw_g (
    .din (stickcmp_rw_m),
    .q   (stickcmp_rw_g),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// modified due to timing violations						
// assign	wsr_inst_g = wsr_inst_g_unflushed & ~tlu_ifu_flush_pipe_w & inst_vld_g;
assign	wsr_inst_g = wsr_inst_g_unflushed & ~local_early_flush_pipe_w & inst_vld_g;
assign tlu_wsr_inst_nq_g = 
           wsr_inst_g_unflushed & ~local_early_flush_pipe_w & inst_vld_nf_g;


//=========================================================================================
//	TICK/TICK-CMP RELATED
//=========================================================================================

wire	[1:0]	tckctr;
wire	[1:0]	tckctr_in;

// modified due to swapping in the incr64 soft macro
// assign tckctr_incr = tckctr + 1;
assign tckctr_in[1:0] = tlu_tckctr_in[1:0]; 
assign tlu_incr_tick[1:0] = tckctr[1:0]; 

dffr_s #(2) dffr_tckctr_cnt (
    .din (tckctr_in[1:0]), 
    .q (tckctr[1:0]),
    .rst (local_rst | ~tlu_tick_en_l), 
    .clk (clk),
    .se  (se),  
    .si  (), 
    .so ()
);

// 3rd cycle, increment tick reg.
// assign	tlu_incr_tick = tckctr[1] & tckctr[0];

assign	tlu_tickcmp_sel[0] = ~tckctr[1] & ~tckctr[0];
assign	tlu_tickcmp_sel[1] = ~tckctr[1] &  tckctr[0];
assign	tlu_tickcmp_sel[2] =  tckctr[1] & ~tckctr[0];
assign	tlu_tickcmp_sel[3] =  tckctr[1] &  tckctr[0];

// TICK.NPT

// reset should not be needed in this equation !!!
assign	tick_ctl_din = tlu_wsr_data_b63_w | local_rst | por_rstint_g;
assign  tlu_tick_ctl_din = tick_ctl_din;

dffe_s dffe_npt0 (
    .din (tick_ctl_din), 
    .q   (tick_npt0),
    .en  (tick_en[0]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s dffe_npt1 (
    .din (tick_ctl_din), 
    .q   (tick_npt1),
    .en  (tick_en[1]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s dffe_npt2 (
    .din (tick_ctl_din), 
    .q   (tick_npt2),
    .en  (tick_en[2]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s dffe_npt3 (
    .din (tick_ctl_din), 
    .q   (tick_npt3),
    .en  (tick_en[3]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign	tlu_tick_npt =
	(thread0_rsel_e & tick_npt0) |
		(thread1_rsel_e & tick_npt1) |
			(thread2_rsel_e & tick_npt2) |
				(thread3_rsel_e & tick_npt3);

assign	tick_npt_priv_act_g = 
	(tick_npriv_r_g & ~ifu_ttype_vld_tmp_g) &
	   ((tick_npt0 & thread0_rsel_g & tlu_none_priv[0]) |
		(tick_npt1 & thread1_rsel_g & tlu_none_priv[1]) |
		(tick_npt2 & thread2_rsel_g & tlu_none_priv[2]) |
		(tick_npt3 & thread3_rsel_g & tlu_none_priv[3])); 
//
// added for timing fix
assign	tick_npt_priv_act_m = 
	 (tick_npriv_r_m & ~ifu_ttype_vld_m) &
	((tick_npt0 & thread0_rsel_m & tlu_none_priv[0]) |
	 (tick_npt1 & thread1_rsel_m & tlu_none_priv[1]) |
	 (tick_npt2 & thread2_rsel_m & tlu_none_priv[2]) |
	 (tick_npt3 & thread3_rsel_m & tlu_none_priv[3])); 

assign	exu_tick_npt_priv_act_m = 
	  tick_npriv_r_m &
	((tick_npt0 & thread0_stg_m_buf & tlu_none_priv[0]) |
	 (tick_npt1 & thread1_stg_m_buf & tlu_none_priv[1]) |
	 (tick_npt2 & thread2_stg_m_buf & tlu_none_priv[2]) |
	 (tick_npt3 & thread3_stg_m_buf & tlu_none_priv[3])); 

//=========================================================================================
//	Soft Interrupt Control
//=========================================================================================

wire	[1:0]	sftintctr;
wire	[1:0]	sftintctr_incr;

assign sftintctr_incr[1:0] = sftintctr[1:0] + 2'b01;

dffr_s #(2) dffr_sftint_cnt  (
   .din (sftintctr_incr[1:0]), 
   .q (sftintctr[1:0]),
   .rst (local_rst), 
   .clk (clk),
   .se  (se),
   .si  (),
   .so ()
);
// 
// modified for bug 4626 and 5117 
/*
assign swint_nq_g = swint_g; 
assign swint_thrd_g[0]= swint_nq_g & thread0_rsel_g & tlu_int_pstate_ie[0];
assign swint_thrd_g[1]= swint_nq_g & thread1_rsel_g & tlu_int_pstate_ie[1];
assign swint_thrd_g[2]= swint_nq_g & thread2_rsel_g & tlu_int_pstate_ie[2];
// assign swint_thrd_g[3]= swint_nq_g & thread3_rsel_g & tlu_int_pstate_ie[3];
*/

assign sftint_user_update_g = 
       clr_sftint_g | sftint_rg_rw_g;

dffr_s dffr_sftint_user_update_w2 (
    .din (sftint_user_update_g),
	.q   (sftint_user_update_w2),
    .clk (clk),
    .rst (local_rst), 
    .se  (se),       
    .si  (),          
    .so  ()
);

assign penc_sel_user_update = sftint_user_update_w2 & ~swint_g;

assign sftint_penc_update = sftint_user_update_w2 | swint_g; 

assign sftint_penc_thrd[0]= 
       (swint_g & thread0_rsel_g) | (penc_sel_user_update & thread0_wsel_w2);
assign sftint_penc_thrd[1]= 
       (swint_g & thread1_rsel_g) | (penc_sel_user_update & thread1_wsel_w2);
assign sftint_penc_thrd[2]= 
       (swint_g & thread2_rsel_g) | (penc_sel_user_update & thread2_wsel_w2);

assign	tlu_sftint_penc_sel[0] = 
            ((~sftintctr[1] & ~sftintctr[0] & ~sftint_penc_update) | 
             sftint_penc_thrd[0]) & ~rst_tri_en;
assign	tlu_sftint_penc_sel[1] = 
            ((~sftintctr[1] &  sftintctr[0] & ~sftint_penc_update) | 
             sftint_penc_thrd[1]) & ~rst_tri_en;
assign	tlu_sftint_penc_sel[2] = 
            (( sftintctr[1] & ~sftintctr[0] & ~sftint_penc_update) | 
             sftint_penc_thrd[2]) & ~rst_tri_en;
//
// added for bug 5117

assign sftint_wait_rst[0] = 
           sftint_pend_wait[0] & tlu_sftint_penc_sel[0]; 
assign sftint_wait_rst[1] = 
           sftint_pend_wait[1] & tlu_sftint_penc_sel[1]; 
assign sftint_wait_rst[2] = 
           sftint_pend_wait[2] & tlu_sftint_penc_sel[2]; 
assign sftint_wait_rst[3] = 
           sftint_pend_wait[3] & tlu_sftint_penc_sel[3]; 

dffr_s dffr_sftint_pend_wait_0 (
    .din (sftint_user_update_g & thread0_rsel_dec_g),
	.q   (sftint_pend_wait[0]),
    .clk (clk),
    .rst (local_rst | sftint_wait_rst[0]), 
    .se  (se),       
    .si  (),          
    .so  ()
);
dffr_s dffr_sftint_pend_wait_1 (
    .din (sftint_user_update_g & thread1_rsel_dec_g),
	.q   (sftint_pend_wait[1]),
    .clk (clk),
    .rst (local_rst | sftint_wait_rst[1]), 
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_sftint_pend_wait_2 (
    .din (sftint_user_update_g & thread2_rsel_dec_g),
	.q   (sftint_pend_wait[2]),
    .clk (clk),
    .rst (local_rst | sftint_wait_rst[2]), 
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_sftint_pend_wait_3 (
    .din (sftint_user_update_g & thread3_rsel_dec_g),
	.q   (sftint_pend_wait[3]),
    .clk (clk),
    .rst (local_rst | sftint_wait_rst[3]), 
    .se  (se),       
    .si  (),          
    .so  ()
);
/*
assign	tlu_sftint_penc_sel[0] = 
            (~sftintctr[1] & ~sftintctr[0] & ~swint_nq_g) | swint_thrd_g[0];
assign	tlu_sftint_penc_sel[1] = 
            (~sftintctr[1] &  sftintctr[0] & ~swint_nq_g) | swint_thrd_g[1];
assign	tlu_sftint_penc_sel[2] = 
            ( sftintctr[1] & ~sftintctr[0] & ~swint_nq_g) | swint_thrd_g[2];
//
*/
// 
// modified for one-hot problem
assign	tlu_sftint_penc_sel[3] =
            ~(|tlu_sftint_penc_sel[2:0]);
// assign	tlu_sftint_penc_sel[3] =
//             ( sftintctr[1] &  sftintctr[0] & ~swint_nq_g) | swint_thrd_g[3];
/*
assign	tlu_sftint_penc_sel[0] = ~sftintctr[1] & ~sftintctr[0];
assign	tlu_sftint_penc_sel[1] = ~sftintctr[1] &  sftintctr[0];
assign	tlu_sftint_penc_sel[2] =  sftintctr[1] & ~sftintctr[0];
assign	tlu_sftint_penc_sel[3] =  sftintctr[1] &  sftintctr[0];
*/

//  Flop sftint values on a per thread basis.
dffe_s #(4) dffe_sftint_id0  (
    .din (tlu_sftint_id[3:0]), 
    .q   (sftint0_id[3:0]),
    .en  (tlu_sftint_penc_sel[0]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(4) dffe_sftint_id1  (
    .din (tlu_sftint_id[3:0]), 
    .q   (sftint1_id[3:0]),
    .en  (tlu_sftint_penc_sel[1]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(4) dffe_sftint_id2  (
    .din (tlu_sftint_id[3:0]), 
    .q   (sftint2_id[3:0]),
    .en  (tlu_sftint_penc_sel[2]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(4) dffe_sftint_id3  (
    .din (tlu_sftint_id[3:0]), 
    .q   (sftint3_id[3:0]),
    .en  (tlu_sftint_penc_sel[3]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// Soft Int Control
// modified to fix one-hot problem
assign	tlu_set_sftint_l_g   =  ~(set_sftint_g) | rst_tri_en; 
assign	tlu_clr_sftint_l_g   =  ~(clr_sftint_g) | rst_tri_en;
assign	tlu_wr_sftint_l_g    =  ~(sftint_rg_rw_g) | rst_tri_en;
// modified for timing
/*
assign	tlu_set_sftint_l_g   =  ~(set_sftint_g & wsr_inst_g);
assign	tlu_clr_sftint_l_g   =  ~(clr_sftint_g & wsr_inst_g);
assign	tlu_wr_sftint_l_g    =  ~(sftint_rg_rw_g & wsr_inst_g);
*/

// modified for pib support
//
assign tlu_sftint_en_l_g[0] = 
           ~((set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
              wsr_inst_g & thread0_rsel_dec_g) & tlu_rst_l;
assign tlu_sftint_en_l_g[1] = 
           ~((set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
              wsr_inst_g & thread1_rsel_dec_g) & tlu_rst_l;
assign tlu_sftint_en_l_g[2] = 
           ~((set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
              wsr_inst_g & thread2_rsel_dec_g) & tlu_rst_l;
assign tlu_sftint_en_l_g[3] = 
           ~((set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
              wsr_inst_g & thread3_rsel_dec_g) & tlu_rst_l;

// added for one-hot mux bug
// modified for timing
assign tlu_sftint_mx_sel[0] = 
           ~(|tlu_sftint_mx_sel[3:1]); 
assign tlu_sftint_mx_sel[1] = 
           (set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
            thread1_rsel_dec_g & ~rst_tri_en; 
assign tlu_sftint_mx_sel[2] = 
           (set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
            thread2_rsel_dec_g & ~rst_tri_en; 
assign tlu_sftint_mx_sel[3] = 
           (set_sftint_g | clr_sftint_g | sftint_rg_rw_g) & 
            thread3_rsel_dec_g & ~rst_tri_en; 
//
// determine whether there is a pending sftint interrupt for each thread
//
assign tlu_int_sftint_pend[0] = |(sftint0_id[3:0]) & ~sftint_pend_wait[0];
assign tlu_int_sftint_pend[1] = |(sftint1_id[3:0]) & ~sftint_pend_wait[1];
assign tlu_int_sftint_pend[2] = |(sftint2_id[3:0]) & ~sftint_pend_wait[2];
assign tlu_int_sftint_pend[3] = |(sftint3_id[3:0]) & ~sftint_pend_wait[3];

// if there is no existing sft interrupt, then sftint_id = 0, and vld would never be asserted. 
// this is why a 15b vector has been encoded as a 16b vector.
// modified for hypervisor support

// fix for bug 7027
/*
assign sftint_only_vld[0] = (tlu_int_sftint_pend[0]) ? 
                            (sftint0_id[3:0] > true_pil0[3:0]) & pil_cmp_en[0] : 1'b0;
assign sftint_only_vld[1] = (tlu_int_sftint_pend[1]) ?
                            (sftint1_id[3:0] > true_pil1[3:0]) & pil_cmp_en[1] : 1'b0;
assign sftint_only_vld[2] = (tlu_int_sftint_pend[2]) ?
                            (sftint2_id[3:0] > true_pil2[3:0]) & pil_cmp_en[2] : 1'b0;
assign sftint_only_vld[3] = (tlu_int_sftint_pend[3]) ?
                            (sftint3_id[3:0] > true_pil3[3:0]) & pil_cmp_en[3] : 1'b0;
*/

assign sftint_only_vld[0] = (tlu_int_sftint_pend[0]) ?
                            (sftint0_id[3:0] > true_pil0[3:0]) : 1'b0;
assign sftint_only_vld[1] = (tlu_int_sftint_pend[1]) ?
                            (sftint1_id[3:0] > true_pil1[3:0]) : 1'b0;
assign sftint_only_vld[2] = (tlu_int_sftint_pend[2]) ?
                            (sftint2_id[3:0] > true_pil2[3:0]) : 1'b0;
assign sftint_only_vld[3] = (tlu_int_sftint_pend[3]) ?
                            (sftint3_id[3:0] > true_pil3[3:0]) : 1'b0;


// swint 
// removed the qualification of the tlu_int_pstate_ie - otherwise, IFU might never wakeup
// after the thread has been suspended.
// 
// modified for timing
assign tlu_sftint_vld[0] = 
           (tlu_cpu_mondo_trap[0] | tlu_dev_mondo_trap[0] | sftint_only_vld[0]); 
assign tlu_sftint_vld[1] = 
           (tlu_cpu_mondo_trap[1] | tlu_dev_mondo_trap[1] | sftint_only_vld[1]);
assign tlu_sftint_vld[2] = 
           (tlu_cpu_mondo_trap[2] | tlu_dev_mondo_trap[2] | sftint_only_vld[2]);
assign tlu_sftint_vld[3] = 
           (tlu_cpu_mondo_trap[3] | tlu_dev_mondo_trap[3] | sftint_only_vld[3]);
//
// added for hypervisor support
// htick_match traps 

// fix for bug 7027
/*
assign tlu_hintp_vld[0] = 
           tlu_hintp[0] & (~tlu_hpstate_priv[0] | 
          (tlu_hpstate_priv[0] & tlu_int_pstate_ie[0]));
assign tlu_hintp_vld[1] = 
           tlu_hintp[1] & (~tlu_hpstate_priv[1] | 
          (tlu_hpstate_priv[1] & tlu_int_pstate_ie[1]));
assign tlu_hintp_vld[2] = 
           tlu_hintp[2] & (~tlu_hpstate_priv[2] | 
          (tlu_hpstate_priv[2] & tlu_int_pstate_ie[2]));
assign tlu_hintp_vld[3] = 
           tlu_hintp[3] & (~tlu_hpstate_priv[3] | 
          (tlu_hpstate_priv[3] & tlu_int_pstate_ie[3]));
*/

assign tlu_hintp_vld[0] = tlu_hintp[0];
assign tlu_hintp_vld[1] = tlu_hintp[1];
assign tlu_hintp_vld[2] = tlu_hintp[2];
assign tlu_hintp_vld[3] = tlu_hintp[3];


//
// resum_err traps
// modified for timing

// fix for bug 7027
/*
assign tlu_rerr_vld[0] = tlu_resum_err_trap[0] & tlu_int_pstate_ie[0]; 
assign tlu_rerr_vld[1] = tlu_resum_err_trap[1] & tlu_int_pstate_ie[1]; 
assign tlu_rerr_vld[2] = tlu_resum_err_trap[2] & tlu_int_pstate_ie[2]; 
assign tlu_rerr_vld[3] = tlu_resum_err_trap[3] & tlu_int_pstate_ie[3]; 
*/
assign tlu_rerr_vld[0] = tlu_resum_err_trap[0];
assign tlu_rerr_vld[1] = tlu_resum_err_trap[1];
assign tlu_rerr_vld[2] = tlu_resum_err_trap[2];
assign tlu_rerr_vld[3] = tlu_resum_err_trap[3];


assign pil_cmp_en[0] = 
           ~(tlu_hpstate_priv[0] & tlu_hpstate_enb[0]);
assign pil_cmp_en[1] = 
           ~(tlu_hpstate_priv[1] & tlu_hpstate_enb[1]);
assign pil_cmp_en[2] = 
           ~(tlu_hpstate_priv[2] & tlu_hpstate_enb[2]);
assign pil_cmp_en[3] = 
           ~(tlu_hpstate_priv[3] & tlu_hpstate_enb[3]);

// TLU.TICK_INT - The tick and stick interrupt logic has been moved to tlu_tdp
// the interrupt will be report back to tlu_tcl via the softint settings
/*
assign wsr_tick_intclr_g =  (tlu_clr_sftint_l_g | ~tlu_wsr_data_w[0]) & (tlu_wr_sftint_l_g | tlu_wsr_data_w[0]);
assign wsr_tick_intset_g = ~(tlu_set_sftint_l_g & tlu_wr_sftint_l_g) & tlu_wsr_data_w[0];
//
// added for hypervisor suppor for tlu_stck_int
assign wsr_stick_intclr_g =  (tlu_clr_sftint_l_g | ~tlu_wsr_data_b16_w) & (tlu_wr_sftint_l_g | tlu_wsr_data_b16_w);
assign wsr_stick_intset_g = ~(tlu_set_sftint_l_g & tlu_wr_sftint_l_g) & tlu_wsr_data_b16_w;
*/
// The following code has been moved to tlu_tdp
/*
assign	tick_intclr[0] = tlu_tick_int[0] & wsr_tick_intclr_g;
assign	tick_intclr[1] = tlu_tick_int[1] & wsr_tick_intclr_g;
assign	tick_intclr[2] = tlu_tick_int[2] & wsr_tick_intclr_g;
assign	tick_intclr[3] = tlu_tick_int[3] & wsr_tick_intclr_g; 
//
assign	tickcmp_int[0] = tlu_tick_match & ~tick_intdis0 & tlu_tickcmp_sel[0];  
assign	tickcmp_int[1] = tlu_tick_match & ~tick_intdis1 & tlu_tickcmp_sel[1];   
assign	tickcmp_int[2] = tlu_tick_match & ~tick_intdis2 & tlu_tickcmp_sel[2]; 
assign	tickcmp_int[3] = tlu_tick_match & ~tick_intdis3 & tlu_tickcmp_sel[3]; 

assign	tick_intrpt[0] = tickcmp_int[0] | tick_intclr[0];
assign	tick_intrpt[1] = tickcmp_int[1] | tick_intclr[1];
assign	tick_intrpt[2] = tickcmp_int[2] | tick_intclr[2];
assign	tick_intrpt[3] = tickcmp_int[3] | tick_intclr[3];

// modified for bug 1022
// qualified tlu_set_sftint with wsr_data_w[0]
//
assign	tick_int_en[0] = ~tlu_sftint_en_l_g[0] | tick_intrpt[0];
assign	tick_int_din[0] = (tick_intrpt[0] | wsr_tick_intset_g) ? 1'b1 : 1'b0;

assign	tick_int_en[1] = ~tlu_sftint_en_l_g[1] | tick_intrpt[1];
assign	tick_int_din[1] = (tick_intrpt[1] | wsr_tick_intset_g) ? 1'b1 : 1'b0;

assign	tick_int_en[2] = ~tlu_sftint_en_l_g[2] | tick_intrpt[2];
assign	tick_int_din[2] = (tick_intrpt[2] | wsr_tick_intset_g) ? 1'b1 : 1'b0;

assign	tick_int_en[3] = ~tlu_sftint_en_l_g[3] | tick_intrpt[3];
assign	tick_int_din[3] = (tick_intrpt[3] | wsr_tick_intset_g) ? 1'b1 : 1'b0;
//
// recoded tlu_tick_int for bug 818
dffre_s dffre_tick_int0 (
    .din (tick_int_din[0]), 
    .q   (tlu_tick_int[0]),
    .rst (local_rst), 
    .en  (tick_int_en[0]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// recoded tlu_tick_int for bug 818
dffre_s dffre_tick_int1 (
    .din (tick_int_din[1]), 
    .q   (tlu_tick_int[1]),
    .rst (local_rst), 
    .en  (tick_int_en[1]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// recoded tlu_tick_int for bug 818
//
dffre_s dffre_tick_int2 (
    .din (tick_int_din[2]), 
    .q   (tlu_tick_int[2]),
    .rst (local_rst), 
    .en  (tick_int_en[2]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// recoded tlu_tick_int for bug 818
dffre_s dffre_tick_int3 (
    .din (tick_int_din[3]), 
    .q   (tlu_tick_int[3]),
    .rst (local_rst), 
    .en  (tick_int_en[3]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
//
// added and/or modified for hypervisor support
// the following logic has been moved to tlu_tdp
/*
assign	stick_intclr[0] = tlu_stick_int[0] & wsr_stick_intclr_g;
assign	stick_intclr[1] = tlu_stick_int[1] & wsr_stick_intclr_g;
assign	stick_intclr[2] = tlu_stick_int[2] & wsr_stick_intclr_g;
assign	stick_intclr[3] = tlu_stick_int[3] & wsr_stick_intclr_g; 
//
assign	stickcmp_int[0] = tlu_stick_match & ~stick_intdis0 & tlu_tickcmp_sel[0];  
assign	stickcmp_int[1] = tlu_stick_match & ~stick_intdis1 & tlu_tickcmp_sel[1];   
assign	stickcmp_int[2] = tlu_stick_match & ~stick_intdis2 & tlu_tickcmp_sel[2]; 
assign	stickcmp_int[3] = tlu_stick_match & ~stick_intdis3 & tlu_tickcmp_sel[3]; 
//
assign	stick_intrpt[0] = stickcmp_int[0] | stick_intclr[0];
assign	stick_intrpt[1] = stickcmp_int[1] | stick_intclr[1];
assign	stick_intrpt[2] = stickcmp_int[2] | stick_intclr[2];
assign	stick_intrpt[3] = stickcmp_int[3] | stick_intclr[3];
//
// modified for bug 1022
// qualified tlu_set_sftint with wsr_data_w[16]
//
assign	stick_int_en[0] = ~tlu_sftint_en_l_g[0] | stick_intrpt[0];
assign	stick_int_din[0] = (stick_intrpt[0] | wsr_stick_intset_g) ? 1'b1 : 1'b0;

assign	stick_int_en[1] = ~tlu_sftint_en_l_g[1] | stick_intrpt[1];
assign	stick_int_din[1] = (stick_intrpt[1] | wsr_stick_intset_g) ? 1'b1 : 1'b0;

assign	stick_int_en[2] = ~tlu_sftint_en_l_g[2] | stick_intrpt[2];
assign	stick_int_din[2] = (stick_intrpt[2] | wsr_stick_intset_g) ? 1'b1 : 1'b0;

assign	stick_int_en[3] = ~tlu_sftint_en_l_g[3] | stick_intrpt[3];
assign	stick_int_din[3] = (stick_intrpt[3] | wsr_stick_intset_g) ? 1'b1 : 1'b0;

// recoded tlu_tick_int for bug 818
//
dffre_s dffre_stick_int0 (
    .din (stick_int_din[0]), 
    .q   (tlu_stick_int[0]),
    .rst (local_rst), 
    .en  (stick_int_en[0]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
dffre_s dffre_stick_int1 (
    .din (stick_int_din[1]), 
    .q   (tlu_stick_int[1]),
    .rst (local_rst), 
    .en  (stick_int_en[1]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
dffre_s dffre_stick_int2  (
    .din (stick_int_din[2]), 
    .q   (tlu_stick_int[2]),
    .rst (local_rst), 
    .en  (stick_int_en[2]), 
    .clk (clk),
    .se  (se),
    .si (),
    .so ()
);
//
dffre_s dffre_stick_int3 (
    .din (stick_int_din[3]), 
    .q   (tlu_stick_int[3]),
    .rst (local_rst), 
    .en  (stick_int_en[3]), 
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// modified for hypervisor support
//
assign	tlu_sftint_lvl14_all[0] = 
            tlu_sftint_lvl14[0] | tlu_tick_int[0] | tlu_stick_int[0];
assign	tlu_sftint_lvl14_all[1] = 
            tlu_sftint_lvl14[1] | tlu_tick_int[1] | tlu_stick_int[1];
assign	tlu_sftint_lvl14_all[2] = 
            tlu_sftint_lvl14[2] | tlu_tick_int[2] | tlu_stick_int[2];
assign	tlu_sftint_lvl14_all[3] = 
            tlu_sftint_lvl14[3] | tlu_tick_int[3] | tlu_stick_int[3];
//
assign	tlu_sftint_lvl14_int[0] = tickcmp_int[0] | stickcmp_int[0];
assign	tlu_sftint_lvl14_int[1] = tickcmp_int[1] | stickcmp_int[1];
assign	tlu_sftint_lvl14_int[2] = tickcmp_int[2] | stickcmp_int[2];
assign	tlu_sftint_lvl14_int[3] = tickcmp_int[3] | stickcmp_int[3];
*/

//=========================================================================================
//	PIL for Threads
//=========================================================================================

assign	pil0_en	= pil_rw_g & wsr_inst_g & thread0_wsel_g; 
assign	pil1_en	= pil_rw_g & wsr_inst_g & thread1_wsel_g; 
assign	pil2_en	= pil_rw_g & wsr_inst_g & thread2_wsel_g; 
assign	pil3_en	= pil_rw_g & wsr_inst_g & thread3_wsel_g; 

// THREAD 0
dffe_s #(4) dffe_pil0 (
    .din (tlu_wsr_data_w[3:0]),
    .q   (true_pil0[3:0]),
    .en  (pil0_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
// 
// THREAD 1
dffe_s #(4) dffe_pil1 (
    .din (tlu_wsr_data_w[3:0]),
    .q   (true_pil1[3:0]),
    .en  (pil1_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
// 
// THREAD 2
dffe_s #(4) dffe_pil2 (
    .din (tlu_wsr_data_w[3:0]),
    .q   (true_pil2[3:0]),
    .en  (pil2_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// THREAD 3
dffe_s #(4) dffe_pil3 (
    .din (tlu_wsr_data_w[3:0]),
    .q   (true_pil3[3:0]),
    .en  (pil3_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
//	TL for Threads
//=========================================================================================
//
dff_s dff_stgim_g (
    .din (ifu_tlu_immu_miss_m), 
    .q  (immu_miss_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// wrpr supplies new value else increment on trap.
// wrpr %tl when tl=0 will cause a trap.
// trap in MAXTL-1 enters RED_MODE. 
// added for hypervisor support
// capped the tl value by supervisor write at MAXSTL 
//
assign maxstl_wr_sel[0] = 
           ~tlu_hyper_lite[0] & (tlu_wsr_data_w[2:0] > 3'b010);
assign maxstl_wr_sel[1] = 
           ~tlu_hyper_lite[1] & (tlu_wsr_data_w[2:0] > 3'b010); 
assign maxstl_wr_sel[2] = 
           ~tlu_hyper_lite[2] & (tlu_wsr_data_w[2:0] > 3'b010); 
assign maxstl_wr_sel[3] = 
           ~tlu_hyper_lite[3] & (tlu_wsr_data_w[2:0] > 3'b010); 

assign maxtl_wr_sel =  (tlu_wsr_data_w[2:0] == 3'b111); 

// THREAD0
// Use to signal page fault for now.
// sync_trap_taken_g already qualified with inst_vld_g.
// long-latency sparc traps have to be killed in own pipeline
// hwint interrupts are qualified elsewhere
// modified due to timing
// modified for bug 4561
assign thrd0_traps =
            (sync_trap_taken_g & thread0_rsel_g) | 
            (pending_trap_sel[0] & ~(dnrtry_inst_g | tsa_wr_tid_sel_g |
             ifu_thrd_flush_w[0] | cwp_cmplt0_pending | sync_trap_taken_g |
            (tlu_gl_rw_g & wsr_inst_g))); 
//
// trap level will get updated next cycle.
dff_s #(1) dff_stgw2_0 (
    .din (thrd0_traps), 
    .q   (thrd0_traps_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign tlu_thrd_traps_w2[0] = thrd0_traps_w2; 

assign	trp_lvl0_at_maxtl = (trp_lvl0[2:0] == 3'b110);
assign	trp_lvl0_at_maxtlless1 = (trp_lvl0[2:0] == 3'b101);
//
// added for modified for hypervisor support
assign trp_lvl_at_maxstl[0]   = (trp_lvl0[2:0] == 3'b010);
assign trp_lvl_gte_maxstl[0]  = (trp_lvl0[2:0] > 3'b010) | trp_lvl_at_maxstl[0];
assign wsr_trp_lvl0_data_w[2:0] = 
           (maxstl_wr_sel[0])? 3'b010: 
           ((maxtl_wr_sel)? 3'b110: tlu_wsr_data_w[2:0]);
//
// added for timing
dff_s #(3) dff_wsr_trp_lvl0_data_w2 (
    .din (wsr_trp_lvl0_data_w[2:0]),
    .q   (wsr_trp_lvl0_data_w2[2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
// The following section has been recoded due to timing
//=========================================================================================
// trap level to be incremented if thread not at MAXTL and not in redmode
assign	trp_lvl0_incr_w2 = thrd0_traps_w2 & ~trp_lvl0_at_maxtl;

assign trp_lvl0_new[2:0] = 
	   (tl_rw_w2 & wsr_inst_w2 & thread0_wsel_w2) ? 
			wsr_trp_lvl0_data_w2[2:0] : 
			(local_rst | por_rstint0_w2) ? 3'b110 :
			(dnrtry_inst_w2[0]) ? 
				trp_lvl0[2:0] - 3'b001:// done/retry decrements
				trp_lvl0[2:0] + {2'b00,trp_lvl0_incr_w2};// trap increments
assign tl0_en =
           (tl_rw_w2 & wsr_inst_w2 & thread0_wsel_w2) |  
			trp_lvl0_incr_w2| local_rst | por_rstint0_w2 | 
            dnrtry_inst_w2[0]; 

// Reset required as processor will start out at tl0 after reset.
// tl has to be correctly defined for all conditions !!!
dffe_s #(3) dffe_tl0 (
    .din (trp_lvl0_new[2:0]),
    .q   (trp_lvl0[2:0]),
    .en  (tl0_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
assign	tlu_lsu_tl_zero[0] = ~trp_lvl0[2] & ~trp_lvl0[1] & ~trp_lvl0[0];         
assign	tl0_gt_0 = trp_lvl0[2] | trp_lvl0[1] | trp_lvl0[0]; 	
//
// THREAD1
// Use to signal page fault for now.
// sync_trap_taken_g already qualified with inst_vld_g.
// long-latency sparc traps have to be killed in own pipeline
// hwint interrupts are qualified elsewhere
// modified due to timing
assign thrd1_traps =
            (sync_trap_taken_g & thread1_rsel_g ) | 
            (pending_trap_sel[1] & ~(dnrtry_inst_g | tsa_wr_tid_sel_g |
             ifu_thrd_flush_w[1] | cwp_cmplt1_pending | sync_trap_taken_g |
            (tlu_gl_rw_g & wsr_inst_g))); 
//
// trap level will get updated next cycle.
dff_s #(1) dff_stgw2_1 (
    .din (thrd1_traps),
    .q  (thrd1_traps_w2),
    .clk (clk),
    .se  (se),
    .si (),
    .so ()
);

assign tlu_thrd_traps_w2[1] = thrd1_traps_w2; 

assign	trp_lvl1_at_maxtl = (trp_lvl1[2:0] == 3'b110);
assign	trp_lvl1_at_maxtlless1 = (trp_lvl1[2:0] == 3'b101);
//
// added for modified for hypervisor support
assign trp_lvl_at_maxstl[1]   = (trp_lvl1[2:0] == 3'b010);
assign trp_lvl_gte_maxstl[1]  = (trp_lvl1[2:0] > 3'b010) | trp_lvl_at_maxstl[1];
assign wsr_trp_lvl1_data_w[2:0] = 
           (maxstl_wr_sel[1])? 3'b010: 
           ((maxtl_wr_sel)? 3'b110: tlu_wsr_data_w[2:0]);
//
// added for timing
dff_s #(3) dff_wsr_trp_lvl1_data_w2 (
    .din (wsr_trp_lvl1_data_w[2:0]),
    .q   (wsr_trp_lvl1_data_w2[2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
// The following section has been recoded due to timing
//=========================================================================================
// trap level to be incremented if thread not at MAXTL and not in redmode
assign	trp_lvl1_incr_w2 = thrd1_traps_w2 & ~trp_lvl1_at_maxtl;

assign trp_lvl1_new[2:0] = 
	   (tl_rw_w2 & wsr_inst_w2 & thread1_wsel_w2) ? 
			wsr_trp_lvl1_data_w2[2:0] : 
			(local_rst | por_rstint1_w2) ? 3'b110 :
			(dnrtry_inst_w2[1]) ? 
				trp_lvl1[2:0] - 3'b001:// done/retry decrements
				trp_lvl1[2:0] + {2'b00,trp_lvl1_incr_w2};// trap increments
assign tl1_en =
           (tl_rw_w2 & wsr_inst_w2 & thread1_wsel_w2) |  
			trp_lvl1_incr_w2| local_rst | por_rstint1_w2 | 
            dnrtry_inst_w2[1]; 

// Reset required as processor will start out at tl1 after reset.
// tl has to be correctly defined for all conditions !!!
dffe_s #(3) dffe_tl1 (
    .din (trp_lvl1_new[2:0]),
    .q   (trp_lvl1[2:0]),
    .en  (tl1_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
assign	tlu_lsu_tl_zero[1] = ~trp_lvl1[2] & ~trp_lvl1[1] & ~trp_lvl1[0];         
assign	tl1_gt_0 = trp_lvl1[2] | trp_lvl1[1] | trp_lvl1[0]; 	
//
// THREAD2
// Use to signal page fault for now.
// sync_trap_taken_g already qualified with inst_vld_g.
// long-latency sparc traps have to be killed in own pipeline
// hwint interrupts are qualified elsewhere
// modified due to timing
// modified for bug 3827
assign thrd2_traps =
            (sync_trap_taken_g & thread2_rsel_g) | 
            (pending_trap_sel[2] & ~(dnrtry_inst_g | tsa_wr_tid_sel_g |
             ifu_thrd_flush_w[2] | cwp_cmplt2_pending | sync_trap_taken_g | 
             (tlu_gl_rw_g & wsr_inst_g))); 

// trap level will get updated next cycle.
dff_s #(1) dff_stgw2_2 (
    .din (thrd2_traps), 
    .q   (thrd2_traps_w2),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign tlu_thrd_traps_w2[2] = thrd2_traps_w2;

assign	trp_lvl2_at_maxtl = (trp_lvl2[2:0] == 3'b110);
assign	trp_lvl2_at_maxtlless1 = (trp_lvl2[2:0] == 3'b101);
//
// added or modified for hypervisor support
assign trp_lvl_at_maxstl[2]   = (trp_lvl2[2:0] == 3'b010);
assign trp_lvl_gte_maxstl[2]  = (trp_lvl2[2:0] > 3'b010) | trp_lvl_at_maxstl[2];
assign wsr_trp_lvl2_data_w[2:0] = 
           (maxstl_wr_sel[2])? 3'b010:
           ((maxtl_wr_sel)? 3'b110: tlu_wsr_data_w[2:0]);
//
// added for timing
dff_s #(3) dff_wsr_trp_lvl2_data_w2 (
    .din (wsr_trp_lvl2_data_w[2:0]),
    .q   (wsr_trp_lvl2_data_w2[2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
// The following section has been recoded due to timing
//=========================================================================================
// trap level to be incremented if thread not at MAXTL and not in redmode
assign	trp_lvl2_incr_w2 = thrd2_traps_w2 & ~trp_lvl2_at_maxtl;

assign trp_lvl2_new[2:0] = 
	   (tl_rw_w2 & wsr_inst_w2 & thread2_wsel_w2) ? 
			wsr_trp_lvl2_data_w2[2:0] : 
			(local_rst | por_rstint2_w2) ? 3'b110 :
			(dnrtry_inst_w2[2]) ? 
				trp_lvl2[2:0] - 3'b001:// done/retry decrements
				trp_lvl2[2:0] + {2'b00,trp_lvl2_incr_w2};// trap increments
assign tl2_en =
           (tl_rw_w2 & wsr_inst_w2 & thread2_wsel_w2) |  
			trp_lvl2_incr_w2| local_rst | por_rstint2_w2 | 
            dnrtry_inst_w2[2]; 

// Reset required as processor will start out at tl1 after reset.
// tl has to be correctly defined for all conditions !!!
dffe_s #(3) dffe_tl2 (
    .din (trp_lvl2_new[2:0]),
    .q   (trp_lvl2[2:0]),
    .en  (tl2_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
assign	tlu_lsu_tl_zero[2] = ~trp_lvl2[2] & ~trp_lvl2[1] & ~trp_lvl2[0];         
assign	tl2_gt_0 = trp_lvl2[2] | trp_lvl2[1] | trp_lvl2[0]; 	
//
// THREAD3
// Use to signal page fault for now.
// sync_trap_taken_g already qualified with inst_vld_g.
// long-latency sparc traps have to be killed in own pipeline
// hwint interrupts are qualified elsewhere
// modified due to timing
assign thrd3_traps =
            (sync_trap_taken_g & thread3_rsel_g) | 
            (pending_trap_sel[3] & ~(dnrtry_inst_g | tsa_wr_tid_sel_g |
             ifu_thrd_flush_w[3] | cwp_cmplt3_pending | sync_trap_taken_g |
            (tlu_gl_rw_g & wsr_inst_g))); 

// trap level will get updated next cycle.
dff_s #(1) dff_stgw2_3 (
    .din (thrd3_traps), 
    .q   (thrd3_traps_w2),
    .clk (clk),
    .se  (se),
    .si (),
    .so ()
);

assign tlu_thrd_traps_w2[3] = thrd3_traps_w2;

assign	trp_lvl3_at_maxtl = (trp_lvl3[2:0] == 3'b110);
assign	trp_lvl3_at_maxtlless1 = (trp_lvl3[2:0] == 3'b101);
//
// added for modified for hypervisor support
assign trp_lvl_at_maxstl[3]   = (trp_lvl3[2:0] == 3'b010);
assign trp_lvl_gte_maxstl[3]  = (trp_lvl3[2:0] > 3'b010) | trp_lvl_at_maxstl[3];
assign wsr_trp_lvl3_data_w[2:0] = 
           (maxstl_wr_sel[3])? 3'b010:
           ((maxtl_wr_sel)? 3'b110: tlu_wsr_data_w[2:0]);
//
// added for timing
dff_s #(3) dff_wsr_trp_lvl3_data_w2 (
    .din (wsr_trp_lvl3_data_w[2:0]),
    .q   (wsr_trp_lvl3_data_w2[2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

//=========================================================================================
// The following section has been recoded due to timing
//=========================================================================================
// trap level to be incremented if thread not at MAXTL and not in redmode
assign	trp_lvl3_incr_w2 = thrd3_traps_w2 & ~trp_lvl3_at_maxtl;

assign trp_lvl3_new[2:0] = 
	   (tl_rw_w2 & wsr_inst_w2 & thread3_wsel_w2) ? 
			wsr_trp_lvl3_data_w2[2:0] : 
			(local_rst | por_rstint3_w2) ? 3'b110 :
			(dnrtry_inst_w2[3]) ? 
				trp_lvl3[2:0] - 3'b001:// done/retry decrements
				trp_lvl3[2:0] + {2'b00,trp_lvl3_incr_w2};// trap increments

assign tl3_en =
           (tl_rw_w2 & wsr_inst_w2 & thread3_wsel_w2) |  
			trp_lvl3_incr_w2| local_rst | por_rstint3_w2 | 
            dnrtry_inst_w2[3]; 

// Reset required as processor will start out at tl1 after reset.
dffe_s #(3) dffe_tl3 (
    .din (trp_lvl3_new[2:0]),
    .q   (trp_lvl3[2:0]),
    .en  (tl3_en),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
assign	tlu_lsu_tl_zero[3] = ~trp_lvl3[2] & ~trp_lvl3[1] & ~trp_lvl3[0];         
assign	tl3_gt_0 = trp_lvl3[2] | trp_lvl3[1] | trp_lvl3[0]; 	
//
// added for hypervisor support - TLZ trap
// detection of transition of trap-level from <> 0 to 0
// modified for bug 3192

assign tlz_thread_set[0] = ~(tlu_lsu_tl_zero[0] | (|(trp_lvl0_new[2:0]))) & tl0_en;
assign tlz_thread_set[1] = ~(tlu_lsu_tl_zero[1] | (|(trp_lvl1_new[2:0]))) & tl1_en;
assign tlz_thread_set[2] = ~(tlu_lsu_tl_zero[2] | (|(trp_lvl2_new[2:0]))) & tl2_en;
assign tlz_thread_set[3] = ~(tlu_lsu_tl_zero[3] | (|(trp_lvl3_new[2:0]))) & tl3_en;

dff_s #(4) dff_tlz_thread_data (
    .din (tlz_thread_set[4-1:0]),
	.q   (tlz_thread_data[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// storing the state of the tlz trap to take the trap on the next valid
// instruction 
// modified for bug 3646
dffre_s dffr_tlz_thread_0  (
    .din (tlz_thread_data[0]),
    .q   (tlz_thread[0]),
    .rst (local_rst | tlz_trap_g[0] | thread_inst_vld_g[0]),
    .en  (tlz_thread_data[0] & tlu_hpstate_tlz[0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffr_tlz_thread_1  (
    .din (tlz_thread_data[1]),
    .q   (tlz_thread[1]),
    .rst (local_rst | tlz_trap_g[1] | thread_inst_vld_g[1]), 
    .en  (tlz_thread_data[1] & tlu_hpstate_tlz[1]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffr_tlz_thread_2  (
    .din (tlz_thread_data[2]),
    .q   (tlz_thread[2]),
    .rst (local_rst | tlz_trap_g[2] | thread_inst_vld_g[2]),
    .en  (tlz_thread_data[2] & tlu_hpstate_tlz[2]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffre_s dffr_tlz_thread_3  (
    .din (tlz_thread_data[3]),
    .q   (tlz_thread[3]),
    .rst (local_rst | tlz_trap_g[3] | thread_inst_vld_g[3]),
    .en  (tlz_thread_data[3] & tlu_hpstate_tlz[3]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// initiate the trap for the appropriate thread
// modified for bug 4434 & 4758
assign tlz_trap_m[0] =
          ~ifu_rstint_m & 
          // ~(ifu_rstint_m | (ifu_hwint_m  & tlu_int_pstate_ie[0])) & 
            inst_vld_m & tlu_lsu_tl_zero[0] & thread0_rsel_m & tlz_thread[0] & 
          ~tlu_hpstate_priv[0] & tlu_hpstate_tlz[0];
assign tlz_trap_m[1] =
          ~ifu_rstint_m & 
          // ~(ifu_rstint_m | (ifu_hwint_m & tlu_int_pstate_ie[1])) & 
            inst_vld_m & tlu_lsu_tl_zero[1] & thread1_rsel_m & tlz_thread[1] &
          ~tlu_hpstate_priv[1] & tlu_hpstate_tlz[1];
assign tlz_trap_m[2] =
          ~ifu_rstint_m & 
          // ~(ifu_rstint_m | (ifu_hwint_m & tlu_int_pstate_ie[2])) & 
            inst_vld_m & tlu_lsu_tl_zero[2] & thread2_rsel_m & tlz_thread[2] & 
          ~tlu_hpstate_priv[2] & tlu_hpstate_tlz[2];
assign tlz_trap_m[3] =
          ~ifu_rstint_m & 
          // ~(ifu_rstint_m | (ifu_hwint_m & tlu_int_pstate_ie[3])) & 
            inst_vld_m & tlu_lsu_tl_zero[3] & thread3_rsel_m & tlz_thread[3] &
          ~tlu_hpstate_priv[3] & tlu_hpstate_tlz[3];
//
// added for timing - modifed to removed the qualification of the interrupts from
// IFU
assign tlz_exu_trap_m[0] =
            tlu_lsu_tl_zero[0] & thread0_rsel_m & tlz_thread[0] & ~tlu_hpstate_priv[0] & 
            tlu_hpstate_tlz[0];
assign tlz_exu_trap_m[1] =
            tlu_lsu_tl_zero[1] & thread1_rsel_m & tlz_thread[1] & ~tlu_hpstate_priv[1] & 
            tlu_hpstate_tlz[1];
assign tlz_exu_trap_m[2] =
            tlu_lsu_tl_zero[2] & thread2_rsel_m & tlz_thread[2] & ~tlu_hpstate_priv[2] & 
            tlu_hpstate_tlz[2];
assign tlz_exu_trap_m[3] =
            tlu_lsu_tl_zero[3] & thread3_rsel_m & tlz_thread[3] & ~tlu_hpstate_priv[3] & 
            tlu_hpstate_tlz[3];
//
// modified for bug 4862
// indicate that a TLZ trap needs to be taken
dffr_s #(4) dffr_tlz_trap_g  (
    .din (tlz_trap_m[4-1:0]), 
    .q   (tlz_trap_nq_g[4-1:0]),
    .rst (local_rst),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign tlz_trap_g[0] = tlz_trap_nq_g[0] & ~inst_ifu_flush2_w;
assign tlz_trap_g[1] = tlz_trap_nq_g[1] & ~inst_ifu_flush2_w;
assign tlz_trap_g[2] = tlz_trap_nq_g[2] & ~inst_ifu_flush2_w;
assign tlz_trap_g[3] = tlz_trap_nq_g[3] & ~inst_ifu_flush2_w;

//=========================================================================================
//	EXCEPTION HANDLING
//=========================================================================================
// modified to test out timing - 
/*
assign	tlu_ifu_flush_pipe_w = 
 	(thrd0_traps_flush | thrd1_traps_flush | thrd2_traps_flush | thrd3_traps_flush) & 
     inst_vld_g; 
//
assign	tlu_ifu_flush_pipe_w = 
            (dside_sync_trap_g & inst_vld_g) | local_early_flush_pipe_w;  
*/
assign tlu_ifu_flush_pipe_w = 
           (early_dside_trap_g & inst_vld_g) | lsu_tlu_defr_trp_taken_g | 
            local_early_flush_pipe_w | lsu_ttype_vld_w;  
           // modified for bug 4561
           // (lsu_defr_trap_g & (thrid_g[1:0] == thrid_w2[1:0]))  |

//
// modified for timing fix
assign tlu_flush_all_w = 
           inst_ifu_flush_w | local_early_flush_pipe_w | 
           (lsu_tlu_early_flush_w & inst_vld_nf_g);


// staging the all flush signal 
dffr_s dffr_tlu_flush_all_w2 (
    .din (tlu_flush_all_w),
    .q   (tlu_flush_all_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// added for timing
assign lsu_ttype_vld_w = 
           lsu_tlu_ttype_vld_m2 & inst_vld_g;
// 
// staging the flush-pipe signal 
dffr_s dffr_lsu_ttype_vld_w2 (
    .din (lsu_ttype_vld_w),
    .q   (lsu_ttype_vld_w2),
    .rst (local_rst),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign	tlu_flush_pipe_w = tlu_ifu_flush_pipe_w;
//
// added for timing 
assign	tlu_full_flush_pipe_w2 = 
            lsu_ttype_vld_w2 | tlu_flush_all_w2;

// added for early flush pipe timing fix
// assign tlu_early_flush_pipe_m = sync_trap_taken_m;  

assign tlu_local_flush_w          = local_early_flush_pipe_w;
assign tlu_early_flush_pipe2_w    = local_early_flush_pipe2_w; 
assign tlu_exu_early_flush_pipe_w = local_early_flush_pipe3_w;
assign tlu_early_flush_pipe_w     = local_early_flush_pipe4_w; 

// added local early flush pipe timing fix

dffr_s dffr_local_early_flush_pipe_w (
    .din (sync_trap_taken_m),
    .q   (local_early_flush_pipe_w),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

dffr_s dffr_local_early_flush_pipe2_w (
    .din (sync_trap_taken_m),
    .q   (local_early_flush_pipe2_w),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

dffr_s dffr_local_early_flush_pipe3_w (
    .din (sync_trap_taken_m),
    .q   (local_early_flush_pipe3_w),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

dffr_s dffr_local_early_flush_pipe4_w (
    .din (sync_trap_taken_m),
    .q   (local_early_flush_pipe4_w),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);

//=========================================================================================
//	SFSR/SFAR HANDLING
//=========================================================================================

assign thread_tl_zero =
	thread0_rsel_e ? tlu_lsu_tl_zero[0] :
		thread1_rsel_e ? tlu_lsu_tl_zero[1] :
			thread2_rsel_e ? tlu_lsu_tl_zero[2] : tlu_lsu_tl_zero[3];

// Generate selects for ctxt to be written to tag_access
// iside trap meant to cover immu_miss and inst_access_excp
// modified for hypervisor support
// assign	iside_trap = exu_tlu_ttype_vld_m | immu_va_oor_brnchetc_m | exu_tlu_va_oor_jl_ret_m;
// removed for timing 
/*
assign	iside_trap =
            ifu_tlu_immu_miss_m | exu_tlu_ttype_vld_m | 
            immu_va_oor_brnchetc_m | exu_tlu_va_oor_jl_ret_m ;
  
assign	tlu_tag_access_ctxt_sel_m[0] = iside_trap &  thread_tl_zero_m;
assign	tlu_tag_access_ctxt_sel_m[1] = iside_trap & ~thread_tl_zero_m;
assign	tlu_tag_access_ctxt_sel_m[2] = ~iside_trap;
*/

// ISFSR

// voor reported for both ifetch and memref - need to distinguish.
// va-out-of-range for ldst,branch,call,sequential 
// modified for bug 4763
// assign	immu_va_oor_brnchetc_m
// 	= exu_tlu_va_oor_m & ~pstate_am & ~memref_m;

dffr_s dffr_immu_va_oor_brnchetc_m (
    .din (ifu_tlu_pc_oor_e),
    .q   (immu_va_oor_brnchetc_m),
    .rst (local_rst), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_memref_e (
    .din (ifu_lsu_memref_d),
    .q   (memref_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so ()
);


dff_s dff_memref_m (
    .din (memref_e),// ifu_tlu_flsh_inst_e
    .q   (memref_m),// flsh_inst_m
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign isfsr_flt_vld_m = 
	(thread0_rsel_m & tlu_isfsr_flt_vld[0]) |
	(thread1_rsel_m & tlu_isfsr_flt_vld[1]) |
	(thread2_rsel_m & tlu_isfsr_flt_vld[2]) |
	(thread3_rsel_m & tlu_isfsr_flt_vld[3]);

assign tlu_lsu_pstate_am[3:0] = tlu_pstate_am[3:0];

assign	pstate_am = 
	(thread0_rsel_m & tlu_pstate_am[0]) |
	(thread1_rsel_m & tlu_pstate_am[1]) |
	(thread2_rsel_m & tlu_pstate_am[2]) |
	(thread3_rsel_m & tlu_pstate_am[3]);

dff_s #(1) dff_am_stgg (
    .din (pstate_am),
    .q   (tlu_addr_msk_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// logic moved to lsu_expctl due to timing
/*
assign	pstate_priv = 
	(thread0_rsel_m & tlu_pstate_priv[0]) |
	(thread1_rsel_m & tlu_pstate_priv[1]) |
	(thread2_rsel_m & tlu_pstate_priv[2]) |
	(thread3_rsel_m & tlu_pstate_priv[3]);
*/


assign trp_lvl_zero = 
	(thread0_rsel_g & tlu_lsu_tl_zero[0]) |
	(thread1_rsel_g & tlu_lsu_tl_zero[1]) |
	(thread2_rsel_g & tlu_lsu_tl_zero[2]) |
	(thread3_rsel_g & tlu_lsu_tl_zero[3]);

assign	isfsr_ftype_sel[0] =  ifu_tlu_priv_violtn_m;
// The 2 out of range exceptions are mutex as they are based on inst type.
assign	isfsr_ftype_sel[1] = ~isfsr_ftype_sel[0] & immu_va_oor_brnchetc_m;
// modified for bug 4452
assign isfsr_ftype_sel[2] = 
           ~isfsr_ftype_sel[0] & exu_tlu_va_oor_jl_ret_m & 
           ~(exu_tlu_ttype_vld_m | ifu_tlu_ttype_vld_m) & ~pstate_am;

assign	isfsr_trp_wr_m = |isfsr_ftype_sel[2:0];

dff_s #(1) dff_isfsrw_stgg (
        .din (isfsr_trp_wr_m),
        .q   (isfsr_trp_wr_g),
        .clk (clk),
        .se  (se),
        .si  (),
        .so  ()
);

dff_s #(1) dff_itag_acc_sel_g (
        .din (isfsr_trp_wr_m | ifu_tlu_immu_miss_m),
        .q   (itag_acc_sel_g),
        .clk (clk),
        .se  (se),
        .si  (),
        .so ()
);

assign tlu_itag_acc_sel_g = itag_acc_sel_g;

// terms below can be made common. (grape)
// recoded for timing - flush qualification moved to mmu_ctl
assign	immu_sfsr_trp_wr[0] = 
            isfsr_trp_wr_g & inst_vld_nf_g & thread0_rsel_g;
assign	immu_sfsr_trp_wr[1] = 
            isfsr_trp_wr_g & inst_vld_nf_g & thread1_rsel_g;
assign	immu_sfsr_trp_wr[2] = 
            isfsr_trp_wr_g & inst_vld_nf_g & thread2_rsel_g;
assign	immu_sfsr_trp_wr[3] = 
            isfsr_trp_wr_g & inst_vld_nf_g & thread3_rsel_g;

assign	isfsr_ftype_m[6] = isfsr_ftype_sel[2];
assign	isfsr_ftype_m[5] = isfsr_ftype_sel[1];
assign	isfsr_ftype_m[4:1] = 4'b0000;
assign	isfsr_ftype_m[0] = isfsr_ftype_sel[0];
//
// modified due to timing
dff_s #(8) dff_isfsr_stgg (
    .din ({isfsr_ftype_m[6:0],isfsr_flt_vld_m}), // pstate_priv, 
	.q   ({isfsr_ftype_g[6:0],isfsr_flt_vld_g}), // pstate_priv_g,
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

// Can we remove the excessive bits in isfsr ?
// Do jmpl/rtrn define the asi in i or dsfsr ? seems only jmpl_rtrn mem_addr_not_aligned
// traps set the asi and that too in the dsfsr
// Need to add ctxt !!!

assign isfsr_ctxt_g[1:0] =
	       trp_lvl_zero ? 2'b00 : 2'b10;

dff_s #(1) dff_thread_tl_zero_m (
    .din (thread_tl_zero),
    .q   (thread_tl_zero_m),
    .clk (clk),
    .se  (se),
    .si (),
    .so ()
);

dff_s #(1) dff_thread_tl_zero_g (
    .din (thread_tl_zero_m),
    .q   (thread_tl_zero_g),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign isfsr_asi_g[7:0] = 
           thread_tl_zero_g ? 8'h80 : 8'h04; 
//
// modified for bug 3323
assign	tlu_isfsr_din_g[23:0] =
	{isfsr_asi_g[7:0],2'b0,isfsr_ftype_g[6:0],1'b0,isfsr_ctxt_g[1:0],2'b0,isfsr_flt_vld_g,1'b1};

assign	dmmu_va_oor_m = exu_tlu_va_oor_m & ~pstate_am & memref_m & ~lsu_tlu_squash_va_oor_m;

dff_s #(3) dff_dsfsr_stgg (
    .din ({dmmu_va_oor_m,// memref_m,
           exu_tlu_misalign_addr_jmpl_rtn_m,
	       lsu_tlu_misalign_addr_ldst_atm_m}),
    .q   ({dmmu_va_oor_g,
	       misalign_addr_jmpl_rtn_g,
           misalign_addr_ldst_atm_g}),
    .clk (clk),
    .se  (se),
    .si (),
    .so ()
);

//=========================================================================================
//	GLOBAL REGISTER SWITCHING
//=========================================================================================
// modified for bug 3827
//
assign agp_tid_sel = 
           (dnrtry_inst_g) | (tlu_gl_rw_g & wsr_inst_g); 
assign	agp_tid_g[1:0] = 
            agp_tid_sel ? thrid_g[1:0] : trap_tid_g[1:0]; 

dff_s #(2) dff_tlu_agp_tid_w2 (
    .din (agp_tid_g[1:0]),
    .q   (agp_tid_w2[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// added for timing
dff_s #(2) dff_agp_tid_w3 (
    .din (agp_tid_w2[1:0]),
    .q   (agp_tid_w3[1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_agp_tid_w2[1:0]  = agp_tid_w2[1:0];
assign tlu_exu_agp_tid[1:0] = agp_tid_w3[1:0];

//=========================================================================================
//	CWP/CCR restoration
//=========================================================================================
// code moved to tlu_misctl
/*
dff_s #(8) dff_ccr_stgm (
    .din (tsa_rdata_ccr[7:0]),
    .q   (tlu_exu_ccr_m[7:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(3) dff_cwp_stgm (
    .din (tsa_rdata_cwp[2:0]),
    .q   (tlu_exu_cwp_m[2:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(8) dff_lsu_asi_m (
    .din (tsa_rdata_asi[7:0]),
    .q   (tlu_lsu_asi_m[7:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
    );
*/
//

assign	tlu_exu_tid_m[1:0] = thrid_m[1:0];

assign	tlu_int_tid_m[1:0] = tlu_exu_tid_m[1:0];
assign	tlu_lsu_tid_m[1:0] = tlu_exu_tid_m[1:0];

// modified due to timing violations
assign	tlu_lsu_asi_update_m = tlu_exu_cwpccr_update_m;

// Assumption is that this will be transmitted in the equivalent
// of the w-stage from the exu.
assign	cwp_cmplt0 = ~exu_tlu_cwp_cmplt_tid[1] & ~exu_tlu_cwp_cmplt_tid[0] 
			& exu_tlu_cwp_cmplt;
assign	cwp_cmplt1 = ~exu_tlu_cwp_cmplt_tid[1] &  exu_tlu_cwp_cmplt_tid[0] 
			& exu_tlu_cwp_cmplt;
assign	cwp_cmplt2 =  exu_tlu_cwp_cmplt_tid[1] & ~exu_tlu_cwp_cmplt_tid[0] 
			& exu_tlu_cwp_cmplt;
assign	cwp_cmplt3 =  exu_tlu_cwp_cmplt_tid[1] &  exu_tlu_cwp_cmplt_tid[0] 
			& exu_tlu_cwp_cmplt;


assign	pending_dntry0_taken = cwp_cmplt0_pending & pending_thrd0_event_taken;
assign	pending_dntry1_taken = cwp_cmplt1_pending & pending_thrd1_event_taken;
assign	pending_dntry2_taken = cwp_cmplt2_pending & pending_thrd2_event_taken;
assign	pending_dntry3_taken = cwp_cmplt3_pending & pending_thrd3_event_taken; 

// Any pending cwp change completes.
// ** This equation can be optimized in terms of gate count **
assign	cwp_cmplt_g = 
		pending_dntry0_taken | pending_dntry1_taken |
		pending_dntry2_taken | pending_dntry3_taken;

// A cwp change related to retry completes.
assign	cwp_cmplt_rtry_g = 
		(cwp_cmplt0_pending & pending_thrd0_event_taken & cwp_retry0) | 
		(cwp_cmplt1_pending & pending_thrd1_event_taken & cwp_retry1) | 
		(cwp_cmplt2_pending & pending_thrd2_event_taken & cwp_retry2) | 
		(cwp_cmplt3_pending & pending_thrd3_event_taken & cwp_retry3); 
// 

dff_s #(2) dff_ccmplt_stgw2 (
    .din ({cwp_cmplt_g,cwp_cmplt_rtry_g}),
    .q   ({cwp_cmplt_w2,cwp_cmplt_rtry_w2}),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//=========================================================================================
//	Generate SSCAN data 
//=========================================================================================
// 
assign sscan_tid_sel[4-1:0] = ctu_sscan_tid[4-1:0]; 
/* 
// logic moved to tlu_misctl
// generating write indicators of ttype to the tsa
assign sscan_tt_wr_sel[0] = 
           tsa_ttype_en & tsa_wr_vld[1] & thread0_wtrp_w2; 
assign sscan_tt_wr_sel[1] = 
           tsa_ttype_en & tsa_wr_vld[1] & thread1_wtrp_w2; 
assign sscan_tt_wr_sel[2] = 
           tsa_ttype_en & tsa_wr_vld[1] & thread2_wtrp_w2; 
assign sscan_tt_wr_sel[3] = 
           tsa_ttype_en & tsa_wr_vld[1] & thread3_wtrp_w2;
//
// generating read indicators of ttype from the tsa
assign sscan_tt_rd_sel[0] = 
           tsa_rd_vld_m & thread0_rsel_m; 
assign sscan_tt_rd_sel[1] = 
           tsa_rd_vld_m & thread1_rsel_m; 
assign sscan_tt_rd_sel[2] = 
           tsa_rd_vld_m & thread2_rsel_m; 
assign sscan_tt_rd_sel[3] = 
           tsa_rd_vld_m & thread3_rsel_m; 

assign sscan_ttype_en[0] = 
           sscan_tt_rd_sel[0] | sscan_tt_wr_sel[0]; 
assign sscan_ttype_en[1] = 
           sscan_tt_rd_sel[1] | sscan_tt_wr_sel[1]; 
assign sscan_ttype_en[2] = 
           sscan_tt_rd_sel[2] | sscan_tt_wr_sel[2]; 
assign sscan_ttype_en[3] = 
           sscan_tt_rd_sel[3] | sscan_tt_wr_sel[3]; 
//
assign sscan_tt0_din[`TSA_TTYPE_WIDTH-1:0] = 
           (sscan_tt_wr_sel[0]) ? 
            final_ttype_w2[`TSA_TTYPE_WIDTH-1:0] : tsa_rdata_ttype_m[`TSA_TTYPE_WIDTH-1:0];  
assign sscan_tt1_din[`TSA_TTYPE_WIDTH-1:0] = 
           (sscan_tt_wr_sel[1]) ? 
            final_ttype_w2[`TSA_TTYPE_WIDTH-1:0] : tsa_rdata_ttype_m[`TSA_TTYPE_WIDTH-1:0];  
assign sscan_tt2_din[`TSA_TTYPE_WIDTH-1:0] = 
           (sscan_tt_wr_sel[2]) ? 
            final_ttype_w2[`TSA_TTYPE_WIDTH-1:0] : tsa_rdata_ttype_m[`TSA_TTYPE_WIDTH-1:0];  
assign sscan_tt3_din[`TSA_TTYPE_WIDTH-1:0] = 
           (sscan_tt_wr_sel[3]) ? 
            final_ttype_w2[`TSA_TTYPE_WIDTH-1:0] : tsa_rdata_ttype_m[`TSA_TTYPE_WIDTH-1:0];  
//
dffe_s #(`TSA_TTYPE_WIDTH) dffe_sscan_tt0_data (
    .din (sscan_tt0_din[`TSA_TTYPE_WIDTH-1:0]), 
    .q   (sscan_tt0_data[`TSA_TTYPE_WIDTH-1:0]),
    .en  (sscan_ttype_en[0]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(`TSA_TTYPE_WIDTH) dffe_sscan_tt1_data (
    .din (sscan_tt1_din[`TSA_TTYPE_WIDTH-1:0]), 
    .q   (sscan_tt1_data[`TSA_TTYPE_WIDTH-1:0]),
    .en  (sscan_ttype_en[1]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(`TSA_TTYPE_WIDTH) dffe_sscan_tt2_data (
    .din (sscan_tt2_din[`TSA_TTYPE_WIDTH-1:0]), 
    .q   (sscan_tt2_data[`TSA_TTYPE_WIDTH-1:0]),
    .en  (sscan_ttype_en[2]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dffe_s #(`TSA_TTYPE_WIDTH) dffe_sscan_tt3_data (
    .din (sscan_tt3_din[`TSA_TTYPE_WIDTH-1:0]), 
    .q   (sscan_tt3_data[`TSA_TTYPE_WIDTH-1:0]),
    .en  (sscan_ttype_en[3]), 
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s #(`TSA_TTYPE_WIDTH) dff_tsa_rdata_ttype_m (
    .din (tsa_rdata_ttype[`TSA_TTYPE_WIDTH-1:0]), 
	.q   (tsa_rdata_ttype_m[`TSA_TTYPE_WIDTH-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_tsa_rd_vld_e ( 
    .din (tsa_rd_vld),
	.q   (tsa_rd_vld_e),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

dff_s dff_tsa_rd_vld_m (
    .din (tsa_rd_vld_e),
	.q   (tsa_rd_vld_m),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified - due to sscan_tt[0-3]_data moved to tlu_misctl
mux4ds #(`TCL_SSCAN_WIDTH) mx_sscan_test_data (
       .in0  ({trp_lvl0[2:0],sscan_tt0_data[`TSA_TTYPE_WIDTH-1:0]}),
       .in1  ({trp_lvl1[2:0],sscan_tt1_data[`TSA_TTYPE_WIDTH-1:0]}),
       .in2  ({trp_lvl2[2:0],sscan_tt2_data[`TSA_TTYPE_WIDTH-1:0]}),
       .in3  ({trp_lvl3[2:0],sscan_tt3_data[`TSA_TTYPE_WIDTH-1:0]}),
       .sel0 (sscan_tid_sel[0]),
       .sel1 (sscan_tid_sel[1]),
       .sel2 (sscan_tid_sel[2]),
       .sel3 (sscan_tid_sel[3]),
       .dout (tcl_sscan_test_data[`TCL_SSCAN_WIDTH-1:0])
); 
*/

mux4ds #(3) mx_sscan_test_data (
       .in0  (trp_lvl0[2:0]),
       .in1  (trp_lvl1[2:0]),
       .in2  (trp_lvl2[2:0]),
       .in3  (trp_lvl3[2:0]),
       .sel0 (sscan_tid_sel[0]),
       .sel1 (sscan_tid_sel[1]),
       .sel2 (sscan_tid_sel[2]),
       .sel3 (sscan_tid_sel[3]),
       .dout (tcl_sscan_test_data[3-1:0])
); 

assign tlu_sscan_tcl_data[3-1:0] = 
           tcl_sscan_test_data[3-1:0]; 

//=========================================================================================
//	Instrumentation signals created for sas 
//=========================================================================================
// 
// synopsys translate_off
wire [9-1:0] sas_final_ttype_g;
wire [9-1:0] sas_adj_lsu_ttype_m2;
wire [6:0] sas_hwint_swint_ttype;
wire [9-3:0] sas_rst_ttype_g;

mux4ds #(9) mx_sas_final_ttype_g (
    .sel0 (final_ttype_sel_g[0]),
    .sel1 (final_ttype_sel_g[1]),
    .sel2 (final_ttype_sel_g[2]),
    .sel3 (final_ttype_sel_g[3]),
    .in0  ({2'b0,sas_rst_ttype_g[9-3:0]}),
    .in1  (early_sync_ttype_g[9-1:0]),
    .in2  (sas_adj_lsu_ttype_m2[9-1:0]),
    .in3  (pending_ttype[9-1:0]),
    .dout (sas_final_ttype_g[9-1:0])
); 

mux3ds #(9) mx_sas_adj_lsu_ttype_m2 (
    .sel0 (lsu_defr_trap_g),
    .sel1 (va_oor_data_acc_excp_g & ~lsu_defr_trap_g),
    .sel2 (~(va_oor_data_acc_excp_g | lsu_defr_trap_g)),
    .in0  (9'h032),
    .in1  (9'h030),
    .in2  (lsu_tlu_ttype_m2),
    .dout (sas_adj_lsu_ttype_m2[9-1:0])
); 

assign sas_hwint_swint_ttype[6:0] =
       (hwint_g)? 7'h60:
       (cpu_mondo_trap_g)? 7'h7c:
       (dev_mondo_trap_g)? 7'h7d:
        {3'b100, tlu_sftint_id[3:0]};

assign sas_rst_ttype_g[9-3:0] =
       (rst_ttype_sel[0])? {4'b00,reset_id_g[2:0]}:
       (rst_ttype_sel[1])? wrap_tlz_ttype[6:0]: 
        sas_hwint_swint_ttype[6:0];

// synopsys translate_on
endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: tlu_tdp.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
///////////////////////////////////////////////////////////////////////
/*
//	Description:	Trap Datapath 
*/
////////////////////////////////////////////////////////////////////////
// Global header file includes
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: sys.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// -*- verilog -*-
////////////////////////////////////////////////////////////////////////
/*
//
// Description:		Global header file that contain definitions that 
//                      are common/shared at the systme level
*/
////////////////////////////////////////////////////////////////////////
//
// Setting the time scale
// If the timescale changes, JP_TIMESCALE may also have to change.
`timescale	1ps/1ps
`default_nettype wire

//
// Number of threads in a core
// ===========================
//

//`define CONFIG_NUM_THREADS // This must be defined for any of below to work
//`define THREADS_1
//`define THREADS_2
//`define THREADS_3


//
// JBUS clock
// =========
//
// `define SYSCLK_PERIOD   5000


// Afara Link Defines
// ==================

// Reliable Link




// Afara Link Objects


// Afara Link Object Format - Reliable Link










// Afara Link Object Format - Congestion



  







// Afara Link Object Format - Acknowledge











// Afara Link Object Format - Request

















// Afara Link Object Format - Message



// Acknowledge Types




// Request Types





// Afara Link Frame



//
// UCB Packet Type
// ===============
//

















//
// UCB Data Packet Format
// ======================
//






























// Size encoding for the UCB_SIZE_HI/LO field
// 000 - byte
// 001 - half-word
// 010 - word
// 011 - double-word
// 111 - quad-word







//
// UCB Interrupt Packet Format
// ===========================
//










//`define UCB_THR_HI             9      // (6) cpu/thread ID shared with
//`define UCB_THR_LO             4             data packet format
//`define UCB_PKT_HI             3      // (4) packet type shared with
//`define UCB_PKT_LO             0      //     data packet format







//
// FCRAM Bus Widths
// ================
//






//
// ENET clock periods
// ==================
//
// `define AXGRMII_CLK_PERIOD          6400 // 312.5MHz/2
// `define ENET_GMAC_CLK_PERIOD        8000 // 125MHz


//
// JBus Bridge defines
// =================
//
// `define      SYS_UPA_CLK        `SYS.upa_clk
// `define      SYS_J_CLK          `SYS.j_clk
// `define      SYS_P_CLK          `SYS.p_clk
// `define      SYS_G_CLK          `SYS.g_clk
// `define      JP_TIMESCALE       `timescale 1 ps / 1 ps
// `define      PCI_CLK_PERIOD     15152                  //  66 MHz
// `define      UPA_RD_CLK_PERIOD  6666                   // 150 MHz
// `define      UPA_REF_CLK_PERIOD 7576                   // 132 MHz
// `define      ICHIP_CLK_PERIOD   30304                  //  33 MHz


//
// PCI Device Address Configuration
// ================================
//























// system level definition file which contains the 
			     // time scale definition

////////////////////////////////////////////////////////////////////////
// Local header file includes / local defines
////////////////////////////////////////////////////////////////////////
// Modified by Princeton University on June 9th, 2015
/*
* ========== Copyright Header Begin ==========================================
* 
* OpenSPARC T1 Processor File: tlu.h
* Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
* 
* The above named program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License version 2 as published by the Free Software Foundation.
* 
* The above named program is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public
* License along with this work; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
* 
* ========== Copyright Header End ============================================
*/
// ifu trap types





















//
// modified for hypervisor support
//
























//


// modified due to bug 2588
// `define	TSA_PSTATE_VRANGE2_LO 16 


//











//
// added due to Niagara SRAMs methodology
// The following defines have been replaced due
// the memory macro replacement from:
// bw_r_rf32x144 -> 2x bw_r_rf32x80
/*
`define	TSA_MEM_WIDTH     144 
`define	TSA_HTSTATE_HI    142 //  3 bits 
`define	TSA_HTSTATE_LO    140 
`define	TSA_TPC_HI        138 // 47 bits 
`define	TSA_TPC_LO         92
`define	TSA_TNPC_HI        90 // 47 bits
`define	TSA_TNPC_LO        44 
`define	TSA_TSTATE_HI      40 // 29 bits 
`define	TSA_TSTATE_LO      12 
`define	TSA_TTYPE_HI        8 //  9 bits
`define	TSA_TTYPE_LO        0
`define	TSA_MEM_CWP_LO	   12
`define	TSA_MEM_CWP_HI	   14
`define	TSA_MEM_PSTATE_LO  15
`define	TSA_MEM_PSTATE_HI  22
`define	TSA_MEM_ASI_LO	   23
`define	TSA_MEM_ASI_HI	   30
`define	TSA_MEM_CCR_LO	   31
`define	TSA_MEM_CCR_HI	   38
`define	TSA_MEM_GL_LO	   39 
`define	TSA_MEM_GL_HI	   40 
*/











//











// HPSTATE position definitions within wsr






// TSTATE postition definitions within wsr







// modified due to bug 2588


// added for bug 2584 




//







//
// tick_cmp and stick_cmp definitions





//
// PIB WRAP



// HPSTATE postition definitions






// HTBA definitions




// TBA definitions




















//
// added for the hypervisor support


// modified due to bug 2588
















//
// compressed PSTATE WSR definitions














//
// ASI_QUEUE for hypervisor
// Queues are: CPU_MONODO
//             DEV_MONODO
//             RESUMABLE_ERROR
//             NON_RESUMABLE_ERROR
//







// for address range checking
















//
// Niagara scratch-pads
// VA address of 0x20 and 0x28 are exclusive to hypervisor
// 







//
// range checking 







// PIB related definitions
// Bit definition for events









// 
// PIB related definitions
// PCR and PIC address definitions



// 
// PCR bit definitions







//









// PIC definitions








// PIC  mask bit position definitions










// added define from sparc_tlu_int.v 










//
// shadow scan related definitions 

// modified due to logic redistribution
// `define TCL_SSCAN_WIDTH 12 





// `define TCL_SSCAN_LO 51 




// 
// position definitions - TDP






// 
// position definitions - TCL




// 
// To speedup POR for verification purposes


//PITON_PROTO enables all FPGA related modifications





module tlu_tdp (/*AUTOARG*/
   // Outputs
   tlu_pib_rsr_data_e, tlu_restore_pc_w1, tlu_restore_npc_w1, tlu_partial_trap_pc_w1,
   tsa_wdata, tlu_int_pstate_ie, local_pstate_ie, tlu_ifu_pstate_pef, 
   tlu_lsu_pstate_cle, tlu_lsu_pstate_priv, tlu_int_redmode, tlu_lsu_redmode, 
   tlu_sscan_test_data, 
   // modified for bug 1767
   tlu_pstate_am, tlu_sftint_id, 
   // added for timing
   // modfied for hypervisor support
   tlu_dnrtry_global_g, tlu_tick_incr_din, tlu_exu_rsr_data_m, 
   tlu_hpstate_priv, local_hpstate_priv, local_hpstate_enb, local_pstate_priv, 
   tlu_hpstate_enb, tlu_hintp, tlu_por_rstint_g, tcl_hpstate_priv, tcl_hpstate_enb, 
   tlu_trap_hpstate_enb, tlu_hpstate_tlz, tlu_asi_state_e, tlu_hpstate_ibe, 
   so, 
   // Inputs
   tsa_rdata, tlu_wsr_data_w, lsu_tlu_rsr_data_e, tlu_ibrkpt_trap_w2, 
   // reset was modified to abide to the Niagara reset methodology
   rclk, tlu_rst, tlu_thrd_wsel_w2, ifu_lsu_imm_asi_d, // tm_l, 
   tlu_final_ttype_w2, tlu_pstate_din_sel0, tlu_pstate_din_sel1, 
   tlu_pstate_din_sel2, tlu_pstate_din_sel3, ifu_lsu_imm_asi_vld_d,  
   lsu_asi_reg0, lsu_asi_reg1, lsu_asi_reg2, lsu_asi_reg3, 
   exu_tlu_ccr0_w, exu_tlu_ccr1_w, exu_tlu_ccr2_w, exu_tlu_ccr3_w, 
   exu_tlu_cwp0, exu_tlu_cwp1, exu_tlu_cwp2, exu_tlu_cwp3, tlu_trap_cwp_en, 
   tlu_pc_new_w, tlu_npc_new_w, tlu_sftint_en_l_g, tlu_sftint_mx_sel, 
   tlu_set_sftint_l_g, tlu_wr_tsa_inst_w2,  tlu_clr_sftint_l_g, 
   tlu_wr_sftint_l_g, tlu_sftint_penc_sel, tlu_tba_en_l, tlu_tick_en_l, 
   tlu_tickcmp_sel, tlu_tickcmp_en_l, // tlu_retry_inst_m, tlu_done_inst_m, 
   tlu_update_pc_l_w, tlu_tl_gt_0_w2, pib_pich_wrap, // tlu_dnrtry_inst_m_l, 
   tlu_select_tba_w2, tlu_select_redmode, tlu_update_pstate_l_w2, tlu_pil, 
   tlu_trp_lvl, tlu_tick_npt, tlu_thrd_rsel_e, tlu_tick_incr_dout, 
   tlu_rdpr_mx1_sel, tlu_rdpr_mx2_sel, tlu_rdpr_mx3_sel, tlu_rdpr_mx4_sel, 
   tlu_hpstate_din_sel0, tlu_hpstate_din_sel1, tlu_pc_mxsel_w2,  
   tlu_hpstate_din_sel2, tlu_hpstate_din_sel3, tlu_update_hpstate_l_w2, 
   tlu_htba_en_l, tlu_rdpr_mx5_sel, tlu_rdpr_mx6_sel, pib_picl_wrap, 
   tlu_rdpr_mx7_sel, tlu_htickcmp_intdis, tlu_stickcmp_en_l, tlu_htickcmp_en_l, 
   tlu_gl_lvl0, tlu_gl_lvl1, tlu_gl_lvl2, tlu_gl_lvl3, tlu_wr_hintp_g, 
   tlu_set_hintp_sel_g, ctu_sscan_tid, si, se,


   // rtap_tlu_rstvbase_wr_en,
   // rtap_ifu_pc_data
   // trin
   // core_rtap_data,
   rtap_core_val,
   rtap_core_threadid,
   rtap_core_id,
   rtap_core_data
   );	

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
// End of automatics
input	[134-1:0] tsa_rdata;		   // rd data for tsa.
input   [4-1:0] tlu_por_rstint_g;
//
// modified for timing
input   [64-1:0] tlu_wsr_data_w; // pr/st data from irf.

input	[7:0]	lsu_tlu_rsr_data_e;	// lsu sr/pr read data

input		rclk;			// clock
//
// reset was removed to abide to the Niagara reset methodology 
input tlu_rst;			           // unit-reset
input [4-1:0] tlu_thrd_wsel_w2;// thread requiring tsa write.
input [9-1:0]	tlu_final_ttype_w2;	   // selected ttype - g
input tlu_ibrkpt_trap_w2;	// instruction brkpt trap 
input tlu_trap_hpstate_enb;	// mode indicator for the trapped thrd 
input tlu_wr_tsa_inst_w2;	// write state inst
input [1:0]  tlu_pstate_din_sel0; // sel source of tsa wdata
input [1:0]  tlu_pstate_din_sel1; // sel source of tsa wdata
input [1:0]  tlu_pstate_din_sel2; // sel source of tsa wdata
input [1:0]  tlu_pstate_din_sel3; // sel source of tsa wdata
input [8-1:0] lsu_asi_reg0; // asi state - thread0
input [8-1:0] lsu_asi_reg1; // asi state - thread1
input [8-1:0] lsu_asi_reg2; // asi state - thread2
input [8-1:0] lsu_asi_reg3; // asi state - thread3
input [8-1:0] ifu_lsu_imm_asi_d; // asi state value from imm 
input ifu_lsu_imm_asi_vld_d; // valid asi state value from imm

input [3:0]	 tlu_tickcmp_sel;  // select src for tickcmp
input [3:0]	 tlu_tickcmp_en_l; // tick cmp reg write enable
input        tlu_tick_en_l;	   // tick reg write enable

// overflow for the pic registers - lvl15 int 
// input  [`TLU_THRD_NUM-1:0] pib_pic_wrap; 
input  [4-1:0] pib_pich_wrap; 
input  [4-1:0] pib_picl_wrap; 

input [7:0]  exu_tlu_ccr0_w;  // ccr - thread0
input [7:0]  exu_tlu_ccr1_w;  // ccr - thread1
input [7:0]  exu_tlu_ccr2_w;  // ccr - thread2
input [7:0]  exu_tlu_ccr3_w;  // ccr - thread3
// input [2:0]  exu_tlu_cwp0_w;  // cwp - thread0
// input [2:0]  exu_tlu_cwp1_w;  // cwp - thread1
// input [2:0]  exu_tlu_cwp2_w;  // cwp - thread2
// input [2:0]  exu_tlu_cwp3_w;  // cwp - thread3
input [2:0]  exu_tlu_cwp0;  // cwp - thread0
input [2:0]  exu_tlu_cwp1;  // cwp - thread1
input [2:0]  exu_tlu_cwp2;  // cwp - thread2
input [2:0]  exu_tlu_cwp3;  // cwp - thread3
// added for bug3499
input [4-1:0] tlu_trap_cwp_en;
// modified due to bug 3017
// input [47:0] ifu_tlu_pc_m;	  // pc
// input [47:0] ifu_tlu_npc_m;   // npc
// modified due to redistribution of logic
// input [48:0] ifu_tlu_pc_m;	  // pc
// input [48:0] ifu_tlu_npc_m;   // npc
input [48:0] tlu_pc_new_w;	  // pc
input [48:0] tlu_npc_new_w;   // npc

input [3:0]	 tlu_sftint_en_l_g; // wr enable for sftint regs.
input [3:0]	 tlu_sftint_mx_sel; // mux select for sftint regs 
input        tlu_set_sftint_l_g;       // set sftint
input        tlu_clr_sftint_l_g;       // clr sftint
input        tlu_wr_sftint_l_g;        // wr to sftin (asr 16)
//
// removed due to sftint recode
// input [3:0]	 tlu_sftint_lvl14_int;  // sftint lvl 14 plus tick int
input [3:0]	 tlu_sftint_penc_sel;
input [3:0]	 tlu_tba_en_l;		   // tba reg write enable
// logic moved to tlu_misctl
// input		 tlu_retry_inst_m;	   // valid retry inst
// input		 tlu_done_inst_m;	   // valid done inst
// input		 tlu_dnrtry_inst_m;	   // valid done/retry inst - g
// input		 tlu_dnrtry_inst_m_l;	   // valid done/retry inst - g
// input [3:0]	 tlu_update_pc_l_m;	   // update pc or npc for a thread
input [3:0]	 tlu_update_pc_l_w;	   // update pc or npc for a thread
// modified due to timing
// input  		 tlu_self_boot_rst_g;
// input		 tlu_tl_gt_0_g;		   // trp lvl gt then 0
// input  		 tlu_select_tba_g;
// input tlu_select_htba_g;   // choosing htba for forming trappc/trapnpc 
// input tlu_self_boot_rst_w2;
// added for one-hot mux problem
input [2:0] tlu_pc_mxsel_w2; 
input tlu_tl_gt_0_w2;	  // trp lvl gt then 0
input tlu_select_tba_w2;
input [4-1:0] tlu_update_pstate_l_w2; // pstate write enable
input [4-1:0] tlu_thrd_rsel_e; // read select for threaded regs
input [3:0] tlu_pil;     // mx'ed pil
input [2:0] tlu_trp_lvl; // mx'ed trp lvl

input tlu_select_redmode;
input tlu_tick_npt;       // npt bit of tick

input [64-4:0] tlu_tick_incr_dout;
//
// added and/or modified for hypervisor support
input [1:0] tlu_hpstate_din_sel0; // sel source of tsa wdata
input [1:0] tlu_hpstate_din_sel1; // sel source of tsa wdata
input [1:0] tlu_hpstate_din_sel2; // sel source of tsa wdata
input [1:0] tlu_hpstate_din_sel3; // sel source of tsa wdata
input [4-1:0] tlu_stickcmp_en_l; // stick cmp reg write enable
input [4-1:0] tlu_htickcmp_en_l; // htick cmp reg write enable
input [4-1:0] tlu_wr_hintp_g;    // wr control for hintp regs.
input [4-1:0] tlu_set_hintp_sel_g; // set control for hintp regs.
input [4-1:0] tlu_htba_en_l;     // htba reg write enable
input [4-1:0] tlu_update_hpstate_l_w2; // hpstate write enable
input tlu_htickcmp_intdis; // int. disable bit of htick-cmp
input [2-1:0] tlu_gl_lvl0; // global register value t0 
input [2-1:0] tlu_gl_lvl1; // global register value t1 
input [2-1:0] tlu_gl_lvl2; // global register value t2 
input [2-1:0] tlu_gl_lvl3; // global register value t3 
// mux select to read the new ASR registers
input [3:1] tlu_rdpr_mx1_sel;
input [3:1] tlu_rdpr_mx2_sel;
input [2:1] tlu_rdpr_mx3_sel;
input [2:1] tlu_rdpr_mx4_sel;
input [3:1] tlu_rdpr_mx5_sel;
input [2:0] tlu_rdpr_mx6_sel;
input [3:0] tlu_rdpr_mx7_sel;
//
input [4-1:0] ctu_sscan_tid;
input [64-1:0] tlu_pib_rsr_data_e; // rsr data from pib 

input si; // scan-in
input se; // scan-en

// jtag
   // output wire [`CORE_JTAG_BUS_WIDTH-1:0] core_rtap_data;
   input wire rtap_core_val;
   input wire [1:0] rtap_core_threadid;
   input wire [4-1:0]  rtap_core_id;
   input wire [94-1:0] rtap_core_data;

/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
// End of automatics
//
// modified due to bug 3017
output [48:0] tlu_restore_pc_w1;  // trap pc or pc on retry.
output [48:0] tlu_restore_npc_w1; // trap pc or pc on retry.
output [33:0] tlu_partial_trap_pc_w1;
// the tlu_exu_rsr_data_e will become obsolete, to be removed
// added for timing
// output [`TLU_ASR_DATA_WIDTH-1:0] tlu_exu_rsr_data_e; // rsr data to exu 
output [64-1:0] tlu_exu_rsr_data_m; // rsr data to exu 
// modified due to timing violations
// output [`TLU_ASR_DATA_WIDTH-1:0] tlu_pib_rsr_data_e; // trap pc or pc on retry.
//
// modified for hypervisor support
output [136-1:0] tsa_wdata; // wr data for tsa.
//
output [4-1:0] tlu_int_pstate_ie;   // interrupt enable
output [4-1:0] local_pstate_ie;   // interrupt enable
output [4-1:0] tlu_ifu_pstate_pef;  // fp enable
output [4-1:0] tlu_lsu_pstate_cle;  // current little endian
output [4-1:0] tlu_lsu_pstate_priv; // privilege mode
output [4-1:0] tlu_int_redmode;	  // redmode
output [4-1:0] tlu_lsu_redmode;	  // redmode
// modified for bug 1767
// output   [1:0] tlu_pstate0_mmodel; // mem. model - thread0
// output   [1:0] tlu_pstate1_mmodel; // mem. model - thread1
// output   [1:0] tlu_pstate2_mmodel; // mem. model - thread2
// output   [1:0] tlu_pstate3_mmodel; // mem. model - thread3
// output   [3:0] tlu_pstate_tle;	  // trap little endian
// output [`TLU_THRD_NUM-1:0] tlu_pstate_cle;  // current little endian
// output [`TLU_THRD_NUM-1:0] tlu_pstate_priv; // privilege mode
output [4-1:0] tlu_pstate_am;   // address mask
//
// removed for bug 2187
// output [`TLU_THRD_NUM-1:0] tlu_sftint_lvl14;
output [4-1:0] tlu_hpstate_priv; // hypervisor privilege	
output [4-1:0] tlu_hpstate_enb;  // hypervisor lite enb	
output [4-1:0] tlu_hpstate_tlz;  // hypervisor tlz 
output [4-1:0] tlu_hpstate_ibe;  // hypervisor instruction brkpt	
output [4-1:0] local_hpstate_priv; // hypervisor privilege	
output [4-1:0] tcl_hpstate_priv; // hypervisor privilege	
output [4-1:0] local_pstate_priv;  // pstate privilege	
output [4-1:0] local_hpstate_enb;  // hypervisor lite enb	
output [4-1:0] tcl_hpstate_enb;  // hypervisor lite enb	
output [3:0] tlu_sftint_id;	
// output       tlu_tick_match;	// tick to tick cmp match
// output       tlu_stick_match;	// stick to tick cmp match
// output       tlu_htick_match;	// htick to tick cmp match
// output [`TLU_ASR_DATA_WIDTH-1:0] tlu_tick_incr_din;
output [64-3:0] tlu_tick_incr_din;
//
// modified for hypervisor support
// output	[2:0]	tlu_restore_globals; // restored global regs
//
output [2-1:0] tlu_dnrtry_global_g; // restored globals 
output [4-1:0]     tlu_hintp;
// 
// current asi state 
output [8-1:0] tlu_asi_state_e;
//
// modified due to race key word limitation
// output [62:0] tlu_sscan_test_data;
output [51-1:0] tlu_sscan_test_data;
output		  so; // scan-out;

/*AUTOWIRE*/
// Beginning of automatic wires (for undeclared instantiated-module outputs)
// End of automatics
//
// local reset was added to abide to the Niagara reset methodology 
wire        local_rst; // local reset
wire        se_l; // testmode_l replacement 
//
// rdpr muxe outputs
wire [64-1:0] tlu_rdpr_mx1_out;
wire [3:0]  tlu_rdpr_mx2_out;
wire [17-1:0]  tlu_rdpr_mx3_out;
wire [48-1:0]  tlu_rdpr_mx4_out;
// 
// constructing one-hot selects
wire rdpr_mx1_onehot_sel, rdpr_mx2_onehot_sel; 
wire rdpr_mx3_onehot_sel, rdpr_mx4_onehot_sel; 
wire rdpr_mx5_onehot_sel, rdpr_mx6_onehot_sel; 
//
wire  [32:0] true_tba0,true_tba1,true_tba2,true_tba3;
wire  [60:0] true_tick;
// modified due to bug 3017
wire  [48:0] true_pc0,true_pc1,true_pc2,true_pc3;
// wire  [47:0] sscan_pc; 
wire  [51-1:0] sscan_data_test0;
wire  [51-1:0] sscan_data_test1;
// wire  [`TDP_SSCAN_WIDTH-1:0] sscan_data_test2;
// wire  [`TDP_SSCAN_WIDTH-1:0] sscan_data_test3;
wire  [51-1:0] tdp_sscan_test_data;
wire  [4-1:0] sscan_tid_sel; 
wire  [48:0] true_npc0,true_npc1,true_npc2,true_npc3;
// wire  [47:0] true_npc0,true_npc1,true_npc2,true_npc3;
// wire  [47:0] true_pc0,true_pc1,true_pc2,true_pc3;
// wire  [47:0] sscan_pc; 
// wire  [47:0] normal_trap_pc, normal_trap_npc;
//
// modified for hypervisor support
wire [136-1:0] trap_tsa_wdata;
wire [136-1:0] trap0_tsa_wdata,trap1_tsa_wdata;
wire [136-1:0] trap2_tsa_wdata,trap3_tsa_wdata;
wire [136-1:0] wrpr_tsa_wdata;
wire [136-1:0] tsa_wdata;
wire [48-1:0]  tstate_rdata;
wire [1:0]  tstate_dummy_zero;
wire [29-1:0]   compose_tstate;
wire [4-1:0]  compose_htstate;
wire [2-1:0]   global_rdata;	
// wire [`TLU_ASR_DATA_WIDTH-1:0] wsr_data_w;	
wire [17-1:0] wsr_data_w;	
// reduced width to 48 due to lint violations
wire [47:0] wsr_data_w2;	
//
// modified for bug 3017
// wire  [47:2] trap_pc0,trap_pc1,trap_pc2,trap_pc3;
// wire  [47:2] trap_npc0,trap_npc1,trap_npc2,trap_npc3;
wire  [48:2] trap_pc0,trap_pc1,trap_pc2,trap_pc3;
wire  [48:2] trap_npc0,trap_npc1,trap_npc2,trap_npc3;
wire   [7:0] trap_ccr0,trap_ccr1,trap_ccr2,trap_ccr3;
wire   [7:0] trap_asi0,trap_asi1,trap_asi2,trap_asi3;
wire   [2:0] trap_cwp0,trap_cwp1,trap_cwp2,trap_cwp3;
wire   [2:0] tlu_cwp0,tlu_cwp1,tlu_cwp2,tlu_cwp3;
wire   [8-1:0] imm_asi_e; 
wire   [8-1:0] asi_state_reg_e; 
wire   [8-1:0] asi_state_final_e; 
wire   imm_asi_vld_e;
//
// modified due to tickcmp, stickcmp and sftint cleanup
// wire  [15:0] sftint0, sftint1, sftint2, sftint3;
// wire  [15:1] sftint_set_din, sftint_clr_din, sftint_wr_din;
wire  [17-1:0] sftint0, sftint1, sftint2, sftint3;
wire  [17-1:0] sftint_set_din, sftint_clr_din, sftint_wr_din;
wire [17-1:0] sftint_din;
wire [17-1:0] sftint;
wire [4-1:0] sftint_b0_din; 
wire [4-1:0] sftint_b0_en;
wire [4-1:0] sftint_b15_din; 
wire [4-1:0] sftint_b15_en;
wire [4-1:0] sftint_b16_din; 
wire [4-1:0] sftint_b16_en; 
wire [4-1:0] sftint_lvl14;
wire [3:0] sftin_din_mxsel;
// recoded for one-hot problem during reset
// wire sftint_sel_onehot_g;
//
// added for PIB support
wire	     tcmp0_clk, tcmp1_clk; 
wire	     tcmp2_clk, tcmp3_clk;
wire [14:0]  sftint_penc_din;
wire	     sftint0_clk,sftint1_clk;
wire	     sftint2_clk,sftint3_clk;
// 
wire [32:0] tba_data;
wire [32:0] tba_rdata;
// wire [33:0] tlu_rstvaddr_base;
reg [33:0] tlu_rstvaddr_base;
wire [34-1:0] htba_data;
wire        tba0_clk,tba1_clk,tba2_clk,tba3_clk;
// modified for bug 3017
// wire [46:0] tsa_pc_m,tsa_npc_m;
// wire [48:0] dnrtry_pc,dnrtry_npc;
wire [48:0] restore_pc_w2;
wire [48:0] restore_npc_w2;
// wire [48:0]	pc_new, npc_new;
// wire [48:0]	pc_new_w, npc_new_w;
wire [33:0] partial_trap_pc_w2;
wire        pc0_clk,pc1_clk,pc2_clk,pc3_clk;
// wire [`TLU_TSA_WIDTH-1:0] tsa_data_m;
wire [64-1:0] true_tickcmp0, true_tickcmp1;
wire [64-1:0] true_tickcmp2, true_tickcmp3;
wire [64-1:0] tickcmp_rdata;
wire [4-1:0] tickcmp_intdis_din;
wire [4-1:0] tickcmp_intdis_en;
wire [4-1:0] tickcmp_int;
wire [4-1:0] tlu_set_hintp_g;
wire [4-1:0] tlu_hintp_en_l_g;
wire tlu_htick_match;	// htick to tick cmp match
wire tick_match;
wire [64-4:0] tickcmp_data;
wire [64-2:2] tick_din;
// reg	 [`TLU_ASR_DATA_WIDTH-1:0] tlu_rsr_data_e;
wire [12-1:0] true_pstate0,true_pstate1;
wire [12-1:0] true_pstate2,true_pstate3;
// wire [`TLU_THRD_NUM-1:0] tlu_pstate_priv; // privilege mode
// added for hypervisor support 
wire [8-1:0] trap_pstate0,trap_pstate1;
wire [8-1:0] trap_pstate2,trap_pstate3;
//
// wire [`PSTATE_TRUE_WIDTH-1:0] dnrtry_pstate;
// wire [`PSTATE_TRUE_WIDTH-1:0] dnrtry_pstate_m;	
// wire [`PSTATE_TRUE_WIDTH-1:0] wsr_data_pstate_g;	
wire [6-1:0] dnrtry_pstate_m;	
wire [6-1:0] dnrtry_pstate_g;	
wire [6-1:0] dnrtry_pstate_w2;
// removed for timing
// wire [`WSR_PSTATE_VR_WIDTH-1:0] wsr_data_pstate_g;
wire [6-1:0] wsr_data_pstate_w2;	
//
// modified for bug 1767
//wire [`PSTATE_TRUE_WIDTH-1:0] ntrap_pstate;
// wire [`PSTATE_TRUE_WIDTH-1:0] ntrap_pstate0;
// wire [`PSTATE_TRUE_WIDTH-1:0] ntrap_pstate1;
// wire [`PSTATE_TRUE_WIDTH-1:0] ntrap_pstate2;
// wire [`PSTATE_TRUE_WIDTH-1:0] ntrap_pstate3;
wire [6-1:0] ntrap_pstate0;
wire [6-1:0] ntrap_pstate1;
wire [6-1:0] ntrap_pstate2;
wire [6-1:0] ntrap_pstate3;
// modified for bug 2161 and 2584
wire pstate_priv_set, hpstate_priv_set; 
wire [4-1:0] pstate_priv_thrd_set;
// wire [`TLU_THRD_NUM-1:0] pstate_priv_update_g;
wire [4-1:0] pstate_priv_update_w2;
// wire [`TLU_THRD_NUM-1:0] hpstate_dnrtry_priv_g;
wire [4-1:0] hpstate_dnrtry_priv_w2;
wire [4-1:0] hpstate_enb_set;
wire [4-1:0] hpstate_ibe_set;
wire [4-1:0] hpstate_tlz_set;
// wire [`TLU_THRD_NUM-1:0] hpstate_priv_update_g;
wire [4-1:0] hpstate_priv_update_w2;
//
// removed for bug 2588
// wire [1:0] tlu_select_mmodel0;
// wire [1:0] tlu_select_mmodel1;
// wire [1:0] tlu_select_mmodel2;
// wire [1:0] tlu_select_mmodel3;
wire [4-1:0] tlu_select_tle;
wire [4-1:0] tlu_select_cle;
// wire [1:0] tlu_pstate0_mmodel;	// mem. model - thread0
// wire [1:0] tlu_pstate1_mmodel;	// mem. model - thread1
// wire [1:0] tlu_pstate2_mmodel;	// mem. model - thread2
// wire [1:0] tlu_pstate3_mmodel;	// mem. model - thread3
wire [4-1:0] tlu_pstate_tle; // trap little endian
//
// modified for bug 1575
// wire	[`PSTATE_TRUE_WIDTH-1:0]	restore_pstate;
// wire [`PSTATE_TRUE_WIDTH-1:0]	restore_pstate0;
// wire [`PSTATE_TRUE_WIDTH-1:0]	restore_pstate1;
// wire [`PSTATE_TRUE_WIDTH-1:0]	restore_pstate2; 
// wire [`PSTATE_TRUE_WIDTH-1:0]	restore_pstate3;
wire [6-1:0]	restore_pstate0;
wire [6-1:0]	restore_pstate1;
wire [6-1:0]	restore_pstate2; 
wire [6-1:0]	restore_pstate3;
wire [6-1:0]	restore_pstate0_w3;
wire [6-1:0]	restore_pstate1_w3;
wire [6-1:0]	restore_pstate2_w3; 
wire [6-1:0]	restore_pstate3_w3;
wire tlu_pstate_nt_sel0, tlu_pstate_nt_sel1;
wire tlu_pstate_nt_sel2, tlu_pstate_nt_sel3;
wire tlu_pstate_wsr_sel0, tlu_pstate_wsr_sel1;
wire tlu_pstate_wsr_sel2, tlu_pstate_wsr_sel3;
wire hpstate_redmode;
wire pstate0_clk,pstate1_clk,pstate2_clk,pstate3_clk;

//
// added or modified for hypervisor support
// wire	[2:0]   global_sel;	
wire stcmp0_clk, stcmp1_clk, stcmp2_clk, stcmp3_clk;
wire htcmp0_clk, htcmp1_clk, htcmp2_clk, htcmp3_clk;
wire tlu_hpstate_hnt_sel0, tlu_hpstate_hnt_sel1;
wire tlu_hpstate_hnt_sel2, tlu_hpstate_hnt_sel3;
wire tlu_hpstate_wsr_sel0, tlu_hpstate_wsr_sel1;
wire tlu_hpstate_wsr_sel2, tlu_hpstate_wsr_sel3;
wire pc_bit15_sel;
wire htba0_clk,htba1_clk,htba2_clk,htba3_clk;
wire hpstate0_clk,hpstate1_clk,hpstate2_clk,hpstate3_clk;
wire hintp0_clk,hintp1_clk,hintp2_clk,hintp3_clk;
wire hintp_rdata;
wire [4-1:0]       hintp_din;
// added or modified due to stickcmp clean-up
// wire [`TLU_ASR_DATA_WIDTH-2:0] stickcmp_rdata;
// wire [`TLU_ASR_DATA_WIDTH-2:0] true_stickcmp0, true_stickcmp1;
// wire [`TLU_ASR_DATA_WIDTH-2:0] true_stickcmp2, true_stickcmp3;
wire [64-1:0] stickcmp_rdata;
wire [64-1:0] true_stickcmp0, true_stickcmp1;
wire [64-1:0] true_stickcmp2, true_stickcmp3;
wire [4-1:0] stickcmp_intdis_din;
wire [4-1:0] stickcmp_intdis_en; 
wire [4-1:0] stickcmp_int; 
wire stick_match;
wire [64-4:0] stickcmp_data;
//
wire [64-2:0] htickcmp_rdata;
wire [64-4:0] htickcmp_data;
wire [64-2:0] true_htickcmp0, true_htickcmp1;
wire [64-2:0] true_htickcmp2, true_htickcmp3;
wire [5-1:0]  true_hpstate0,true_hpstate1;
wire [5-1:0]  true_hpstate2,true_hpstate3;
wire [5-1:0]  true_hpstate;
wire [4-1:0]  tsa_dnrtry_hpstate_m; 
wire [4-1:0]  tsa_dnrtry_hpstate_g; 
wire [4-1:0]  tsa_dnrtry_hpstate_w2; 
// wire [`TLU_HPSTATE_WIDTH-1:0]  dnrtry_hpstate0_g, dnrtry_hpstate1_g; 
wire [5-1:0]  dnrtry_hpstate0_w2, dnrtry_hpstate1_w2; 
// wire [`TLU_HPSTATE_WIDTH-1:0]  dnrtry_hpstate2_g, dnrtry_hpstate3_g; 
wire [5-1:0]  dnrtry_hpstate2_w2, dnrtry_hpstate3_w2; 
// wire [`TLU_HPSTATE_WIDTH-1:0]  hntrap_hpstate0_g, hntrap_hpstate1_g; 
wire [5-1:0]  hntrap_hpstate0_w2, hntrap_hpstate1_w2; 
// wire [`TLU_HPSTATE_WIDTH-1:0]  hntrap_hpstate2_g, hntrap_hpstate3_g; 
wire [5-1:0]  hntrap_hpstate2_w2, hntrap_hpstate3_w2; 
wire [5-1:0]  wsr_data_hpstate_w2; 
wire [5-1:0]  restore_hpstate0, restore_hpstate1; 
wire [5-1:0]  restore_hpstate2, restore_hpstate3; 
wire [34-1:0]	   true_htba0, true_htba1;
wire [34-1:0]	   true_htba2, true_htba3;
wire [2-1:0]   dnrtry_global_m;	
wire [64-1:0] tlu_rdpr_mx5_out;
wire [17-1:0]       tlu_rdpr_mx6_out;
wire [64-1:0] tlu_rdpr_mx7_out;
wire [64-1:0] tlu_exu_rsr_data_e;
wire clk; 
//
//=========================================================================================
// create local reset

assign local_rst = tlu_rst;
assign se_l = ~se;

// clock rename
assign clk = rclk;

//=========================================================================================
// Design Notes :
// HTSTATE-	       4 (ENB from HPSTATE is not saved)	
// TPC-		      47 (48-2)VA+(1)VA_HOLE
// TNPC-		  47 (48-2)VA+(1)VA_HOLE
// TSTATE.GL-	   2 (Only two significant bits are saved)
// TSTATE.CCR-     8
// TSTATE.ASI-	   8
// TSTATE.PSTATE-  8 (RED, IG, MG and AG bits are not used)
// TSTATE.CWP-	   3
// TRAPTYPE-	   9
//========================================================
// Total         136

//=========================================================================================
//	Timing Diagram	
//=========================================================================================


// WRITE TO TSA and other trap related registers.
//	|	|	|		|		|
//	|E	|M	|	W	|  	W2	| Integer
//	|	|	| exceptions	| push tsa	|
//	|	|	| reported	| xmit pc	|
//	|	|	|		|		|
//	|E	|M	|	G 	|	W2	| Long-Latency
//	|	|	| exceptions	|		|
//	|	|	| reported	| push tsa	|
//	|	|	|		| xmit pc	|

//=========================================================================================
//	Generate TSA Control and Data
//=========================================================================================

// modified for bug 3017
assign  trap_pc0[48:2] =  true_pc0[48:2];
assign  trap_pc1[48:2] =  true_pc1[48:2];
assign  trap_pc2[48:2] =  true_pc2[48:2];
assign  trap_pc3[48:2] =  true_pc3[48:2];

assign  trap_npc0[48:2] = true_npc0[48:2]; 
assign  trap_npc1[48:2] = true_npc1[48:2];
assign  trap_npc2[48:2] = true_npc2[48:2];
assign  trap_npc3[48:2] = true_npc3[48:2];

assign	trap_ccr0[7:0] = exu_tlu_ccr0_w[7:0];
assign	trap_ccr1[7:0] = exu_tlu_ccr1_w[7:0];
assign	trap_ccr2[7:0] = exu_tlu_ccr2_w[7:0];
assign	trap_ccr3[7:0] = exu_tlu_ccr3_w[7:0];

// assign	trap_cwp0[2:0] = exu_tlu_cwp0_w[2:0];
// assign	trap_cwp1[2:0] = exu_tlu_cwp1_w[2:0];
// assign	trap_cwp2[2:0] = exu_tlu_cwp2_w[2:0];
// assign	trap_cwp3[2:0] = exu_tlu_cwp3_w[2:0];
//
// added for bug 3695
dff_s #(3) dff_tlu_cwp0 (
    .din (exu_tlu_cwp0[2:0]),
    .q   (tlu_cwp0[2:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(3) dff_tlu_cwp1 (
    .din (exu_tlu_cwp1[2:0]),
    .q   (tlu_cwp1[2:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(3) dff_tlu_cwp2 (
    .din (exu_tlu_cwp2[2:0]),
    .q   (tlu_cwp2[2:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(3) dff_tlu_cwp3 (
    .din (exu_tlu_cwp3[2:0]),
    .q   (tlu_cwp3[2:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// modified for bug 3499 and 3695
dffe_s #(3) dffe_trap_cwp0 (
    // .din (exu_tlu_cwp0[2:0]),
    .din (tlu_cwp0[2:0]),
    .q   (trap_cwp0[2:0]),
    .en  (tlu_trap_cwp_en[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(3) dffe_trap_cwp1 (
    // .din (exu_tlu_cwp1[2:0]),
    .din (tlu_cwp1[2:0]),
    .q   (trap_cwp1[2:0]),
    .en  (tlu_trap_cwp_en[1]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(3) dffe_trap_cwp2 (
    // .din (exu_tlu_cwp2[2:0]),
    .din (tlu_cwp2[2:0]),
    .q   (trap_cwp2[2:0]),
    .en  (tlu_trap_cwp_en[2]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffe_s #(3) dffe_trap_cwp3 (
    // .din (exu_tlu_cwp3[2:0]),
    .din (tlu_cwp3[2:0]),
    .q   (trap_cwp3[2:0]),
    .en  (tlu_trap_cwp_en[3]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign	trap_asi0[7:0] = lsu_asi_reg0[7:0];
assign	trap_asi1[7:0] = lsu_asi_reg1[7:0];
assign	trap_asi2[7:0] = lsu_asi_reg2[7:0];
assign	trap_asi3[7:0] = lsu_asi_reg3[7:0];
// 
// staging the immediate asi

dff_s #(8) dff_imm_asi_e (
    .din (ifu_lsu_imm_asi_d[8-1:0]),
    .q   (imm_asi_e[8-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffr_s dffr_imm_asi_vld_e (
     .din (ifu_lsu_imm_asi_vld_d),
     .q   (imm_asi_vld_e),
     .clk (clk),
	 .rst (local_rst),
     .se  (se),
     .si  (),
     .so  ()
);
//
// generating the current asi state
mux4ds  #(8) mx_tlu_asi_state_e (
        .in0    (lsu_asi_reg0[8-1:0]),
        .in1    (lsu_asi_reg1[8-1:0]),
        .in2    (lsu_asi_reg2[8-1:0]),
        .in3    (lsu_asi_reg3[8-1:0]),
        .sel0   (tlu_thrd_rsel_e[0]),
        .sel1   (tlu_thrd_rsel_e[1]),
        .sel2   (tlu_thrd_rsel_e[2]),
        .sel3   (tlu_thrd_rsel_e[3]),
        // modified due to bug 2442
        // .dout   (tlu_asi_state_e[`TLU_ASI_STATE_WIDTH-1:0])
        .dout   (asi_state_reg_e[8-1:0])
); 
//
// added for bug 2442
// generating the current asi state
mux2ds #(8) mx_asi_state_final_e (
       .in0  (imm_asi_e[8-1:0]),
	   .in1  (asi_state_reg_e[8-1:0]),
       .sel0 (imm_asi_vld_e),  	
	   .sel1 (~imm_asi_vld_e),
       .dout (asi_state_final_e[8-1:0])
); 

assign tlu_asi_state_e[8-1:0] =
           asi_state_final_e[8-1:0];
//
// thread 0
assign trap_pstate0 = {
       true_pstate0[9:8], 
       2'b0, true_pstate0[4:1]};
//
// modified due to hpstate.ibe addition
assign trap0_tsa_wdata[135:132] = 
       {true_hpstate0[5-1],
        true_hpstate0[4-2:0]};
//
// modified for bug 3017
//
assign trap0_tsa_wdata[131:85] = 
           trap_pc0[48:2];
//
assign trap0_tsa_wdata[84:38] = 
           trap_npc0[48:2];
//
assign trap0_tsa_wdata[37:36] = 
       tlu_gl_lvl0[2-1:0]; 
//
assign trap0_tsa_wdata[35:28] = 
       trap_ccr0[8-1:0]; 
//
assign trap0_tsa_wdata[27:20] = 
       trap_asi0[8-1:0]; 
//
assign trap0_tsa_wdata[19:12] = 
       trap_pstate0[8-1:0]; 
//
assign trap0_tsa_wdata[11:9] = 
       trap_cwp0[3-1:0]; 
//
assign trap0_tsa_wdata[8:0] = 
       tlu_final_ttype_w2[9-1:0]; 
//
// thread 1
assign trap_pstate1 = {
       true_pstate1[9:8], 
       2'b0, true_pstate1[4:1]};
//
// modified due to hpstate.ibe addition
assign trap1_tsa_wdata[135:132] = 
       {true_hpstate1[5-1],
        true_hpstate1[4-2:0]};
//
assign trap1_tsa_wdata[131:85] = 
           trap_pc1[48:2];
//
assign trap1_tsa_wdata[84:38] = 
           trap_npc1[48:2];
//
assign trap1_tsa_wdata[37:36] = 
       tlu_gl_lvl1[2-1:0]; 
//
assign trap1_tsa_wdata[35:28] = 
       trap_ccr1[8-1:0]; 
//
assign trap1_tsa_wdata[27:20] = 
       trap_asi1[8-1:0]; 
//
assign trap1_tsa_wdata[19:12] = 
       trap_pstate1[8-1:0]; 
//
assign trap1_tsa_wdata[11:9] = 
       trap_cwp1[3-1:0]; 
//
assign trap1_tsa_wdata[8:0] = 
       tlu_final_ttype_w2[9-1:0]; 
//
// thread 2
assign trap_pstate2 = {
       true_pstate2[9:8], 
       2'b0, true_pstate2[4:1]};
//
// modified due to hpstate.ibe addition
assign trap2_tsa_wdata[135:132] = 
       {true_hpstate2[5-1],
        true_hpstate2[4-2:0]};
//
assign trap2_tsa_wdata[131:85] = 
           trap_pc2[48:2];
//
assign trap2_tsa_wdata[84:38] = 
           trap_npc2[48:2];
//
assign trap2_tsa_wdata[37:36] = 
       tlu_gl_lvl2[2-1:0]; 
//
assign trap2_tsa_wdata[35:28] = 
       trap_ccr2[8-1:0]; 
//
assign trap2_tsa_wdata[27:20] = 
       trap_asi2[8-1:0]; 
//
assign trap2_tsa_wdata[19:12] = 
       trap_pstate2[8-1:0]; 
//
assign trap2_tsa_wdata[11:9] = 
       trap_cwp2[3-1:0]; 
//
assign trap2_tsa_wdata[8:0] = 
       tlu_final_ttype_w2[9-1:0]; 
//
// thread 3
assign trap_pstate3 = {
       true_pstate3[9:8], 
       2'b0, true_pstate3[4:1]};
//
// modified due to hpstate.ibe addition
assign trap3_tsa_wdata[135:132] = 
       {true_hpstate3[5-1],
        true_hpstate3[4-2:0]};
//
assign trap3_tsa_wdata[131:85] = 
           trap_pc3[48:2];
//
assign trap3_tsa_wdata[84:38] = 
           trap_npc3[48:2];
//
assign trap3_tsa_wdata[37:36] = 
       tlu_gl_lvl3[2-1:0]; 
//
assign trap3_tsa_wdata[35:28] = 
       trap_ccr3[8-1:0]; 
//
assign trap3_tsa_wdata[27:20] = 
       trap_asi3[8-1:0]; 
//
assign trap3_tsa_wdata[19:12] = 
       trap_pstate3[8-1:0]; 
//
assign trap3_tsa_wdata[11:9] = 
       trap_cwp3[3-1:0]; 
//
assign trap3_tsa_wdata[8:0] = 
       tlu_final_ttype_w2[9-1:0]; 
//
// modified for timing: tlu_thrd_wsel_g -> tlu_thrd_wsel_w2

 // Use two threads unless this is defined

mux2ds  #(136) tsawdsel (
        .in0    (trap0_tsa_wdata[136-1:0]),
        .in1    (trap1_tsa_wdata[136-1:0]),
        .sel0   (tlu_thrd_wsel_w2[0]),
        .sel1   (tlu_thrd_wsel_w2[1]),
        .dout   (trap_tsa_wdata[136-1:0])
);















































 // `ifndef CONFIG_NUM_THREADS
 
//
// modified for timing and lint violations
// assign wsr_data_w[`TLU_ASR_DATA_WIDTH-1:0] = 
//            tlu_wsr_data_w[`TLU_ASR_DATA_WIDTH-1:0];
assign wsr_data_w[17-1:0] = 
           tlu_wsr_data_w[17-1:0];
// 
// added for timing
// reduced width to 48 due to lint violations
dff_s #(48) dff_wsr_data_w2 (
    .din (tlu_wsr_data_w[47:0]),
    .q   (wsr_data_w2[47:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// extracting the relevant data for tstate from the WSR to be written
// modified due to timing changes
assign compose_tstate[29-1:0] = 
	  {wsr_data_w2[41:40],
       wsr_data_w2[39:32],
       wsr_data_w2[31:24],
       wsr_data_w2[17:16],
       2'b0,
       wsr_data_w2[12:9],
       wsr_data_w2[2:0]};
//
// extracting the relevant data from hstate from the WSR to be written
assign compose_htstate[4-1:0] = 
	  {wsr_data_w2[10],
       wsr_data_w2[5],
	   wsr_data_w2[2],
	   wsr_data_w2[0]};

// htstate
assign	wrpr_tsa_wdata[135:132]=
        compose_htstate[4-1:0];
// 
// modified for bug 3017 
// pc
assign wrpr_tsa_wdata[131:85]=
       {1'b0, wsr_data_w2[47:2]};
// npc
assign wrpr_tsa_wdata[84:38]=
       {1'b0, wsr_data_w2[47:2]};
// tstate data
assign wrpr_tsa_wdata[37:9]=
       compose_tstate[29-1:0];
// ttype data
assign wrpr_tsa_wdata[8:0]=
       wsr_data_w2[9-1:0];

mux2ds #(136) tsawdata_sel (
       .in0    ({trap_tsa_wdata[136-1:0]}),
	   .in1    ({wrpr_tsa_wdata[136-1:0]}),
       .sel0   (~tlu_wr_tsa_inst_w2),
       .sel1    (tlu_wr_tsa_inst_w2),
       .dout   ({tsa_wdata[136-1:0]})
); 

//=========================================================================================
//	SOFT INTERRUPT for Threads
//=========================================================================================

// Assumption is that softint state is unknown after reset.
// TICK_INT will be maintained separately. What is the relative order of
// setting and clearing this bit ? What takes precedence ?
//
// modified for bug 2204
// recoded due to one-hot problem during reset

 // Use two threads unless this is defined

mux2ds #(17) mx_sftint (
        .in0  (sftint0[17-1:0]),
        .in1  (sftint1[17-1:0]),
        .sel0 (tlu_sftint_mx_sel[0]),
        .sel1 (tlu_sftint_mx_sel[1]),
        .dout (sftint[17-1:0])
);















































 // `ifndef CONFIG_NUM_THREADS
 
/*
assign sftint_sel_onehot_g = 
           ~tlu_sftint_en_l_g[0] | (&tlu_sftint_en_l_g[3:1]); 

mux4ds #(`SFTINT_WIDTH) mx_sftint (
        .in0  (sftint0[`SFTINT_WIDTH-1:0]),
        .in1  (sftint1[`SFTINT_WIDTH-1:0]),
        .in2  (sftint2[`SFTINT_WIDTH-1:0]),
        .in3  (sftint3[`SFTINT_WIDTH-1:0]),
        .sel0 (sftint_sel_onehot_g),
        .sel1 (~tlu_sftint_en_l_g[1]),
        .sel2 (~tlu_sftint_en_l_g[2]),
        .sel3 (~tlu_sftint_en_l_g[3]),
        .dout (sftint[`SFTINT_WIDTH-1:0])
); 
*/

assign	sftint_set_din[17-1:0] = 
            (wsr_data_w[17-1:0] | sftint[17-1:0]);
assign	sftint_clr_din[17-1:0] = 
            (~wsr_data_w[17-1:0] & sftint[17-1:0]);
assign	sftint_wr_din[17-1:0]  =  
            wsr_data_w[17-1:0];

// consturcting the mux select for the sftin_din mux

assign sftin_din_mxsel[0] = ~tlu_set_sftint_l_g;
assign sftin_din_mxsel[1] = ~tlu_clr_sftint_l_g;
assign sftin_din_mxsel[2] = ~tlu_wr_sftint_l_g;
assign sftin_din_mxsel[3] =  
           tlu_set_sftint_l_g & tlu_clr_sftint_l_g & tlu_wr_sftint_l_g; 

mux4ds #(17) mx_sftint_din (
        .in0  (sftint_set_din[17-1:0]),
        .in1  (sftint_clr_din[17-1:0]),
        .in2  (sftint_wr_din[17-1:0]),
        .in3  (sftint[17-1:0]),
        .sel0 (sftin_din_mxsel[0]),
        .sel1 (sftin_din_mxsel[1]),
        .sel2 (sftin_din_mxsel[2]),
        .sel3 (sftin_din_mxsel[3]),
        .dout (sftint_din[17-1:0])
); 



clken_buf clkbf_st0 (
		.rclk	(clk),
		.enb_l	(tlu_sftint_en_l_g[0]),
		.tmb_l	(se_l),
		.clk	(sftint0_clk)
		);	




clken_buf clkbf_st1 (
		.rclk	(clk),
		.enb_l	(tlu_sftint_en_l_g[1]),
		.tmb_l	(se_l),
		.clk	(sftint1_clk)
		);	




clken_buf clkbf_st2 (
		.rclk	(clk),
		.enb_l	(tlu_sftint_en_l_g[2]),
		.tmb_l	(se_l),
		.clk	(sftint2_clk)
		);	




clken_buf clkbf_st3 (
		.rclk	(clk),
		.enb_l	(tlu_sftint_en_l_g[3]),
		.tmb_l	(se_l),
		.clk	(sftint3_clk)
		);	

//		
// added for PIB support - modified to make inst count precise
assign sftint_b15_din[0] = 
           (pib_picl_wrap[0] | pib_pich_wrap[0] | sftint_din[15]);
assign sftint_b15_din[1] =                       
           (pib_picl_wrap[1] | pib_pich_wrap[1] | sftint_din[15]);
assign sftint_b15_din[2] =                       
           (pib_picl_wrap[2] | pib_pich_wrap[2] | sftint_din[15]);
assign sftint_b15_din[3] =                       
           (pib_picl_wrap[3] | pib_pich_wrap[3] | sftint_din[15]);

assign sftint_b15_en[0] = 
           (pib_picl_wrap[0] | pib_pich_wrap[0] | ~tlu_sftint_en_l_g[0]);
assign sftint_b15_en[1] = 
           (pib_picl_wrap[1] | pib_pich_wrap[1] | ~tlu_sftint_en_l_g[1]);
assign sftint_b15_en[2] = 
           (pib_picl_wrap[2] | pib_pich_wrap[2] | ~tlu_sftint_en_l_g[2]);
assign sftint_b15_en[3] = 
           (pib_picl_wrap[3] | pib_pich_wrap[3] | ~tlu_sftint_en_l_g[3]);
//		
// added due to sftint spec change 
// tickcmp interrupts
assign sftint_b0_din[0] = (tickcmp_int[0] | sftint_din[0]);
assign sftint_b0_din[1] = (tickcmp_int[1] | sftint_din[0]);
assign sftint_b0_din[2] = (tickcmp_int[2] | sftint_din[0]);
assign sftint_b0_din[3] = (tickcmp_int[3] | sftint_din[0]);

assign sftint_b0_en[0] = (tickcmp_int[0] | ~tlu_sftint_en_l_g[0]);
assign sftint_b0_en[1] = (tickcmp_int[1] | ~tlu_sftint_en_l_g[1]);
assign sftint_b0_en[2] = (tickcmp_int[2] | ~tlu_sftint_en_l_g[2]);
assign sftint_b0_en[3] = (tickcmp_int[3] | ~tlu_sftint_en_l_g[3]);
//
// stickcmp interrupts
assign sftint_b16_din[0] = (stickcmp_int[0] | sftint_din[16]);
assign sftint_b16_din[1] = (stickcmp_int[1] | sftint_din[16]);
assign sftint_b16_din[2] = (stickcmp_int[2] | sftint_din[16]);
assign sftint_b16_din[3] = (stickcmp_int[3] | sftint_din[16]);

assign sftint_b16_en[0] = (stickcmp_int[0] | ~tlu_sftint_en_l_g[0]);
assign sftint_b16_en[1] = (stickcmp_int[1] | ~tlu_sftint_en_l_g[1]);
assign sftint_b16_en[2] = (stickcmp_int[2] | ~tlu_sftint_en_l_g[2]);
assign sftint_b16_en[3] = (stickcmp_int[3] | ~tlu_sftint_en_l_g[3]);

// modified for sftint spec change - special treatments for bit 0, 15 and 16 
//
// thread 0











dffr_s #(14) dffr_sftint0 (
    .din (sftint_din[14:1]), 
    .q   (sftint0[14:1]),
    .clk (sftint0_clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint0_b0 (
    .din (sftint_b0_din[0]), 
    .q   (sftint0[0]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b0_en[0]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint0_b15 (
    .din (sftint_b15_din[0]), 
    .q   (sftint0[15]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b15_en[0]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint0_b16 (
    .din (sftint_b16_din[0]), 
    .q   (sftint0[16]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b16_en[0]),
    .se  (se),
    .si  (),          
    .so  ()
);
//
// thread 1











dffr_s #(14) sftint1ff (
    .din (sftint_din[14:1]), 
    .q   (sftint1[14:1]),
    .clk (sftint1_clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);


dffre_s dffre_sftint1_b0 (
    .din (sftint_b0_din[1]), 
    .q   (sftint1[0]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b0_en[1]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint1_b15 (
    .din (sftint_b15_din[1]), 
    .q   (sftint1[15]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b15_en[1]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint1_b16 (
    .din (sftint_b16_din[1]), 
    .q   (sftint1[16]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b16_en[1]),
    .se  (se),
    .si  (),          
    .so  ()
);
//
// thread 2











dffr_s #(14) sftint2ff (
    .din (sftint_din[14:1]), 
    .q   (sftint2[14:1]),
    .clk (sftint2_clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);


dffre_s dffre_sftint2_b0 (
    .din (sftint_b0_din[2]), 
    .q   (sftint2[0]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b0_en[2]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint2_b15 (
    .din (sftint_b15_din[2]), 
    .q   (sftint2[15]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b15_en[2]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint2_b16 (
    .din (sftint_b16_din[2]), 
    .q   (sftint2[16]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b16_en[2]),
    .se  (se),
    .si  (),          
    .so  ()
);
//
// thread 3











dffr_s #(14) sftint3ff (
    .din (sftint_din[14:1]), 
    .q   (sftint3[14:1]),
    .clk (sftint3_clk),
    .rst (local_rst),
    .se  (se),       
    .si  (),          
    .so  ()
);


dffre_s dffre_sftint3_b0 (
    .din (sftint_b0_din[3]), 
    .q   (sftint3[0]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b0_en[3]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint3_b15 (
    .din (sftint_b15_din[3]), 
    .q   (sftint3[15]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b15_en[3]),
    .se  (se),
    .si  (),          
    .so  ()
);

dffre_s dffre_sftint3_b16 (
    .din (sftint_b16_din[3]), 
    .q   (sftint3[16]),
    .clk (clk),
    .rst (local_rst),
    .en  (sftint_b16_en[3]),
    .se  (se),
    .si  (),          
    .so  ()
);
// 
// Datapath priority encoder.
assign sftint_lvl14[0] = 
           sftint0[0] | sftint0[16] | 
           sftint0[14];
assign sftint_lvl14[1] = 
           sftint1[0] | sftint1[16] | 
           sftint1[14];
assign sftint_lvl14[2] = 
           sftint2[0] | sftint2[16] | 
           sftint2[14];
assign sftint_lvl14[3] = 
           sftint3[0] | sftint3[16] | 
           sftint3[14];
//
// modified to ensure one-hot mux check

 // Use two threads unless this is defined

mux2ds #(17-2) mx_sftint_penc_din (
    .in0  ({sftint0[15],sftint_lvl14[0],sftint0[13:1]}),
    .in1  ({sftint1[15],sftint_lvl14[1],sftint1[13:1]}),
    .sel0 (tlu_sftint_penc_sel[0]),
    .sel1 (tlu_sftint_penc_sel[1]),
    .dout (sftint_penc_din[14:0])
);















































 // `ifndef CONFIG_NUM_THREADS
   
tlu_prencoder16	prencoder16 (
			.din	(sftint_penc_din[14:0]),
			.dout	(tlu_sftint_id[3:0])
		);

//wire	[15:0]	sftint_rdata;
//
// modified for hypervisor support
// adding the SM bit
wire [17-1:0]	sftint_rdata;
// modified due to spec change
/*
mux4ds #(`SFTINT_WIDTH) sftint_mx_rsel (
    .in0  ({tlu_stick_int[0],sftint0[15:1],tlu_tick_int[0]}),
    .in1  ({tlu_stick_int[1],sftint1[15:1],tlu_tick_int[1]}),
    .in2  ({tlu_stick_int[2],sftint2[15:1],tlu_tick_int[2]}),
    .in3  ({tlu_stick_int[3],sftint3[15:1],tlu_tick_int[3]}),
    .sel0 (tlu_thrd_rsel_e[0]),
    .sel1 (tlu_thrd_rsel_e[1]),
    .sel2 (tlu_thrd_rsel_e[2]),
    .sel3 (tlu_thrd_rsel_e[3]),
    .dout (sftint_rdata[16:0])
);
*/

 // Use two threads unless this is defined

mux2ds #(17) sftint_mx_rsel (
    .in0  (sftint0[17-1:0]),
    .in1  (sftint1[17-1:0]),
    .sel0 (tlu_thrd_rsel_e[0]),
    .sel1 (tlu_thrd_rsel_e[1]),
    .dout (sftint_rdata[16:0])
);















































 // `ifndef CONFIG_NUM_THREADS
   
//=========================================================================================
//	TBA for Threads
//=========================================================================================

// Lower 15 bits are read as zero and ignored when written.



clken_buf clkbf_tba0 (
		.rclk	(clk),
		.enb_l	(tlu_tba_en_l[0]),
		.tmb_l	(se_l),
		.clk	(tba0_clk)
		);	




clken_buf clkbf_tba1 (
		.rclk	(clk),
		.enb_l	(tlu_tba_en_l[1]),
		.tmb_l	(se_l),
		.clk	(tba1_clk)
		);	




clken_buf clkbf_tba2 (
		.rclk	(clk),
		.enb_l	(tlu_tba_en_l[2]),
		.tmb_l	(se_l),
		.clk	(tba2_clk)
		);	




clken_buf clkbf_tba3 (
		.rclk	(clk),
		.enb_l	(tlu_tba_en_l[3]),
		.tmb_l	(se_l),
		.clk	(tba3_clk)
		);	


// THREAD0











dff_s #(33) tba0 (
    .din (tlu_wsr_data_w[47:15]), 
    .q   (true_tba0[32:0]),
    .clk (tba0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// THREAD1











dff_s #(33) tba1 (
    .din (tlu_wsr_data_w[47:15]), 
    .q  (true_tba1[32:0]),
    .clk (tba1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// THREAD2











dff_s #(33) tba2 (
    .din (tlu_wsr_data_w[47:15]), 
    .q   (true_tba2[32:0]),
    .clk (tba2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// THREAD3











dff_s #(33) tba3 (
    .din (tlu_wsr_data_w[47:15]), 
    .q  (true_tba3[32:0]),
    .clk (tba3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// tba_data is for traps specifically
// modified for timing 

 // Use two threads unless this is defined

mux2ds #(33) mux_tba_data (
       .in0  (true_tba0[32:0]),
       .in1  (true_tba1[32:0]),
       .sel0 (tlu_thrd_wsel_w2[0]),
       .sel1 (tlu_thrd_wsel_w2[1]),
       .dout (tba_data[32:0])
);

// tba_rdata is for read of tba regs specifically.
mux2ds #(33) tba_mx_rsel (
       .in0  (true_tba0[32:0]),
       .in1  (true_tba1[32:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (tba_rdata[32:0])
);































































































 // `ifndef CONFIG_NUM_THREADS

// added for hypervisor support
//
// HTBA write - constructing clocks  


clken_buf clkbf_htba0 (
    .rclk  (clk),
	.enb_l (tlu_htba_en_l[0]),
	.tmb_l (se_l),
	.clk   (htba0_clk)
);	




clken_buf clkbf_htba1 (
    .rclk  (clk),
	.enb_l (tlu_htba_en_l[1]),
	.tmb_l (se_l),
	.clk   (htba1_clk)
);	




clken_buf clkbf_htba2 (
    .rclk  (clk),
	.enb_l (tlu_htba_en_l[2]),
	.tmb_l (se_l),
	.clk   (htba2_clk)
);	




clken_buf clkbf_htba3 (
    .rclk  (clk),
	.enb_l (tlu_htba_en_l[3]),
	.tmb_l (se_l),
	.clk   (htba3_clk)
);	

//
// HTBA write - writing the registers
// lower 14 bits of HTBA are reserved, therefore, not stored
//
// Thread 0










dff_s #(34) dff_true_htba0 (
    .din (tlu_wsr_data_w[47:14]), 
    .q   (true_htba0[34-1:0]),
    .clk (htba0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// Thread 1










dff_s #(34) dff_true_htba1 (
    .din (tlu_wsr_data_w[47:14]), 
    .q   (true_htba1[34-1:0]),
    .clk (htba1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// Thread 2










dff_s #(34) dff_true_htba2 (
    .din (tlu_wsr_data_w[47:14]), 
    .q   (true_htba2[34-1:0]),
    .clk (htba2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// Thread 3










dff_s #(34) dff_true_htba3 (
    .din (tlu_wsr_data_w[47:14]), 
    .q   (true_htba3[34-1:0]),
    .clk (htba3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// constructing the rdata for HTBA
wire [34-1:0] htba_rdata;

 // Use two threads unless this is defined

mux2ds #(34) mux_htba_rdata (
       .in0  (true_htba0[34-1:0]),
       .in1  (true_htba1[34-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (htba_rdata[34-1:0])
);
//
// selecting the htba base address to use
// modified for timing
mux2ds #(34) mux_htba_data (
       .in0  (true_htba0[34-1:0]),
       .in1  (true_htba1[34-1:0]),
       .sel0 (tlu_thrd_wsel_w2[0]),
       .sel1 (tlu_thrd_wsel_w2[1]),
       .dout (htba_data[34-1:0])
);





















































































 // `ifndef CONFIG_NUM_THREADS
   
/*
mux4ds #(`TLU_HTBA_WIDTH) mux_htba_data (
       .in0  (true_htba0[`TLU_HTBA_WIDTH-1:0]),
       .in1  (true_htba1[`TLU_HTBA_WIDTH-1:0]),
       .in2  (true_htba2[`TLU_HTBA_WIDTH-1:0]),
       .in3  (true_htba3[`TLU_HTBA_WIDTH-1:0]),
       .sel0 (tlu_thrd_rsel_g[0]),
       .sel1 (tlu_thrd_rsel_g[1]),
       .sel2 (tlu_thrd_rsel_g[2]),
       .sel3 (tlu_thrd_rsel_g[3]),
       .dout (htba_data[`TLU_HTBA_WIDTH-1:0])
);
*/
//=========================================================================================
//	TICKS for Threads
//=========================================================================================

// npt needs to be muxed into read !!!


// THREAD0,1,2,3

mux2ds #(61) tick_sel (
       .in0  (tlu_wsr_data_w[62:2]), 	
	   .in1  (tlu_tick_incr_dout[60:0]),
       .sel0 (~tlu_tick_en_l),  	
	   .sel1 ( tlu_tick_en_l),
       .dout (tick_din[62:2])
); 
// 
// modified due to the switch to the soft macro
// assign	tlu_tick_incr_din[`TLU_ASR_DATA_WIDTH-1:0] = 
//         {3'b000,true_tick[60:0]};
assign	tlu_tick_incr_din[64-3:0] = 
         {1'b0,true_tick[60:0]};

// Does not need enable as either in increment or update state
dff_s #(61) tick0123 (
    .din (tick_din[62:2]), 
    .q  (true_tick[60:0]),
    .clk (clk),
    .se  (se),       
    .si (),          
    .so ()
);

//=========================================================================================
//	TICK COMPARE  for Threads
//=========================================================================================



clken_buf clkbf_tcmp0 (
    .rclk  (clk),
	.enb_l (tlu_tickcmp_en_l[0]),
	.tmb_l (se_l),
	.clk   (tcmp0_clk)
);	




clken_buf clkbf_tcmp1 (
    .rclk  (clk),
	.enb_l (tlu_tickcmp_en_l[1]),
	.tmb_l (se_l),
	.clk   (tcmp1_clk)
);	




clken_buf clkbf_tcmp2 (
    .rclk  (clk),
	.enb_l (tlu_tickcmp_en_l[2]),
	.tmb_l (se_l),
	.clk   (tcmp2_clk)
);	




clken_buf clkbf_tcmp3 (
    .rclk  (clk),
	.enb_l (tlu_tickcmp_en_l[3]),
	.tmb_l (se_l),
	.clk   (tcmp3_clk)
);	


// thread 0
// added or modified due to tickcmp clean-up
assign tickcmp_intdis_din[0] = 
           tlu_wsr_data_w[63] | local_rst | 
           tlu_por_rstint_g[0];
// added and modified for bug 4763
assign tickcmp_intdis_en[0] = 
           ~tlu_tickcmp_en_l[0] | local_rst | tlu_por_rstint_g[0];  

dffe_s dffe_tickcmp_intdis0 (
    .din (tickcmp_intdis_din[0]),
	.q   (true_tickcmp0[63]),
    .en  (tickcmp_intdis_en[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) tickcmp0 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_tickcmp0[64-2:0]),
    .clk (tcmp0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 1
// added or modified due to tickcmp clean-up
assign tickcmp_intdis_din[1] = 
           tlu_wsr_data_w[63] | local_rst | 
           tlu_por_rstint_g[1];
// added and modified for bug 4763
assign tickcmp_intdis_en[1] = 
           ~tlu_tickcmp_en_l[1] | local_rst | tlu_por_rstint_g[1];  

dffe_s dffe_tickcmp_intdis1 (
    .din (tickcmp_intdis_din[1]),
	.q   (true_tickcmp1[63]),
    .en  (tickcmp_intdis_en[1]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) tickcmp1 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_tickcmp1[64-2:0]),
    .clk (tcmp1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 2
// added or modified due to tickcmp clean-up
assign tickcmp_intdis_din[2] = 
           tlu_wsr_data_w[63] | local_rst | 
           tlu_por_rstint_g[2];
// added and modified for bug 4763
assign tickcmp_intdis_en[2] = 
           ~tlu_tickcmp_en_l[2] | local_rst | tlu_por_rstint_g[2];  

dffe_s dffe_tickcmp_intdis2 (
    .din (tickcmp_intdis_din[2]),
	.q   (true_tickcmp2[63]),
    .en  (tickcmp_intdis_en[2]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) tickcmp2 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_tickcmp2[64-2:0]),
    .clk (tcmp2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 3
// added or modified due to tickcmp clean-up
assign tickcmp_intdis_din[3] = 
           tlu_wsr_data_w[63] | local_rst | 
           tlu_por_rstint_g[3];
// added and modified for bug 4763
assign tickcmp_intdis_en[3] = 
           ~tlu_tickcmp_en_l[3] | local_rst | tlu_por_rstint_g[3];  

dffe_s dffe_tickcmp_intdis3 (
    .din (tickcmp_intdis_din[3]),
	.q   (true_tickcmp3[63]),
    .en  (tickcmp_intdis_en[3]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) tickcmp3 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_tickcmp3[64-2:0]),
    .clk (tcmp3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// Select 1/4 sources. Assume compare is independent of read
// and thus needs separate mux
 // Use two threads unless this is defined

mux2ds #(64-3) tcmp_mx_sel (
       .in0  (true_tickcmp0[64-2:2]),
       .in1  (true_tickcmp1[64-2:2]),
       .sel0 (tlu_tickcmp_sel[0]),
       .sel1 (tlu_tickcmp_sel[1]),
       .dout (tickcmp_data[64-4:0])
);

// mux for read
mux2ds #(64) tcmp_mx_rsel (
       .in0  (true_tickcmp0[64-1:0]),
       .in1  (true_tickcmp1[64-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (tickcmp_rdata[64-1:0])
);


















































































 // `ifndef CONFIG_NUM_THREADS
   
//
// evaluate for tickcmp match
assign tick_match = 
           (tickcmp_data[60:0] == 
            true_tick[60:0]);
//
// moved from tlu_tcl
assign	tickcmp_int[0] = 
            tick_match & ~true_tickcmp0[63] & tlu_tickcmp_sel[0];  
assign	tickcmp_int[1] = 
            tick_match & ~true_tickcmp1[63] & tlu_tickcmp_sel[1];
assign	tickcmp_int[2] = 
            tick_match & ~true_tickcmp2[63] & tlu_tickcmp_sel[2];
assign	tickcmp_int[3] = 
            tick_match & ~true_tickcmp3[63] & tlu_tickcmp_sel[3];

//=========================================================================================
//	STICK COMPARE  for Threads
//=========================================================================================
// added for hypervisor support



clken_buf clkbf_stcmp0 (
    .rclk  (clk),
	.enb_l (tlu_stickcmp_en_l[0]),
	.tmb_l (se_l),
	.clk   (stcmp0_clk)
);




clken_buf clkbf_stcmp1 (
    .rclk  (clk),
	.enb_l (tlu_stickcmp_en_l[1]),
	.tmb_l (se_l),
	.clk   (stcmp1_clk)
);




clken_buf clkbf_stcmp2 (
    .rclk  (clk),
	.enb_l (tlu_stickcmp_en_l[2]),
	.tmb_l (se_l),
	.clk   (stcmp2_clk)
);




clken_buf clkbf_stcmp3 (
    .rclk  (clk),
	.enb_l (tlu_stickcmp_en_l[3]),
	.tmb_l (se_l),
	.clk   (stcmp3_clk)
);


// thread 0
// added or modified due to stickcmp clean-up
assign stickcmp_intdis_din[0] = tickcmp_intdis_din[0]; 
// added and modified for bug 4763
assign stickcmp_intdis_en[0] = 
           ~tlu_stickcmp_en_l[0] | local_rst | tlu_por_rstint_g[0];  

dffe_s dffe_stickcmp_intdis0 (
    .din (stickcmp_intdis_din[0]),
	.q   (true_stickcmp0[63]),
    .en  (stickcmp_intdis_en[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) stickcmp0 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_stickcmp0[64-2:0]),
    .clk (stcmp0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 1
// added or modified due to stickcmp clean-up
assign stickcmp_intdis_din[1] = tickcmp_intdis_din[1]; 
// added and modified for bug 4763
assign stickcmp_intdis_en[1] = 
           ~tlu_stickcmp_en_l[1] | local_rst | tlu_por_rstint_g[1];  

dffe_s dffe_stickcmp_intdis1 (
    .din (stickcmp_intdis_din[1]),
	.q   (true_stickcmp1[63]),
    .en  (stickcmp_intdis_en[1]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) stickcmp1 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_stickcmp1[64-2:0]),
    .clk (stcmp1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 2
// added or modified due to stickcmp clean-up
assign stickcmp_intdis_din[2] = tickcmp_intdis_din[2]; 
// added for bug 4763
assign stickcmp_intdis_en[2] = 
           ~tlu_stickcmp_en_l[2] | local_rst | tlu_por_rstint_g[2];  

dffe_s dffe_stickcmp_intdis2 (
    .din (stickcmp_intdis_din[2]),
	.q   (true_stickcmp2[63]),
    .en  (stickcmp_intdis_en[2]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) stickcmp2 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_stickcmp2[64-2:0]),
    .clk (stcmp2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// thread 3
// added or modified due to stickcmp clean-up
assign stickcmp_intdis_din[3] = tickcmp_intdis_din[3]; 
// added and modified for bug 4763
assign stickcmp_intdis_en[3] = 
           ~tlu_stickcmp_en_l[3] | local_rst | tlu_por_rstint_g[3];  

dffe_s dffe_stickcmp_intdis3 (
    .din (stickcmp_intdis_din[3]),
	.q   (true_stickcmp3[63]),
    .en  (stickcmp_intdis_en[3]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);











dff_s #(64-1) stickcmp3 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_stickcmp3[64-2:0]),
    .clk (stcmp3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
 // !`ifdef FPGA_SYN_CLK_DFF
   
// Select 1/4 sources. Assume compare is independent of read
// and thus needs separate mux

 // Use two threads unless this is define

mux2ds #(64-3) mux_stickcmp_data (
       .in0  (true_stickcmp0[64-2:2]),
       .in1  (true_stickcmp1[64-2:2]),
       .sel0 (tlu_tickcmp_sel[0]),
       .sel1 (tlu_tickcmp_sel[1]),
       .dout (stickcmp_data[64-4:0])
);
//
// mux for read
mux2ds #(64) mux_stickcmp_rdata (
       .in0  (true_stickcmp0[64-1:0]),
       .in1  (true_stickcmp1[64-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (stickcmp_rdata[64-1:0])
);


















































































 // `ifndef CONFIG_NUM_THREADS
   
//
// evaluate for stickcmp match
assign stick_match = 
           (stickcmp_data[60:0] == 
            true_tick[60:0]);
//
// moved from tlu_tcl
assign	stickcmp_int[0] = 
            stick_match & ~true_stickcmp0[63] & tlu_tickcmp_sel[0];  
assign	stickcmp_int[1] = 
            stick_match & ~true_stickcmp1[63] & tlu_tickcmp_sel[1];
assign	stickcmp_int[2] = 
            stick_match & ~true_stickcmp2[63] & tlu_tickcmp_sel[2];
assign	stickcmp_int[3] = 
            stick_match & ~true_stickcmp3[63] & tlu_tickcmp_sel[3];

//=========================================================================================
//	HTICK COMPARE  for Threads
//=========================================================================================
// added for hypervisor support



clken_buf clkbf_htcmp0 (
    .rclk  (clk),
	.enb_l (tlu_htickcmp_en_l[0]),
	.tmb_l (se_l),
	.clk   (htcmp0_clk)
);	




clken_buf clkbf_htcmp1 (
    .rclk  (clk),
	.enb_l (tlu_htickcmp_en_l[1]),
	.tmb_l (se_l),
	.clk   (htcmp1_clk)
);	




clken_buf clkbf_htcmp2 (
    .rclk  (clk),
	.enb_l (tlu_htickcmp_en_l[2]),
	.tmb_l (se_l),
	.clk   (htcmp2_clk)
);	




clken_buf clkbf_htcmp3 (
    .rclk  (clk),
	.enb_l (tlu_htickcmp_en_l[3]),
	.tmb_l (se_l),
	.clk   (htcmp3_clk)
);	

   
// THREAD0










dff_s #(64-1) htickcmp0 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_htickcmp0[64-2:0]),
    .clk (htcmp0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// THREAD1










dff_s #(64-1) htickcmp1 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_htickcmp1[64-2:0]),
    .clk (htcmp1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// THREAD2










dff_s #(64-1) htickcmp2 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_htickcmp2[64-2:0]),
    .clk (htcmp2_clk),
    .se  (se),
    .si  (),
    .so  ()
);


// THREAD3










dff_s #(64-1) htickcmp3 (
    .din (tlu_wsr_data_w[64-2:0]),
	.q   (true_htickcmp3[64-2:0]),
    .clk (htcmp3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);



// Select 1/4 sources. Assume compare is independent of read
// and thus needs separate mux
 // Use two threads unless this is defined

mux2ds #(64-3) mux_htickcmp_data (
       .in0  (true_htickcmp0[64-2:2]),
       .in1  (true_htickcmp1[64-2:2]),
       .sel0 (tlu_tickcmp_sel[0]),
       .sel1 (tlu_tickcmp_sel[1]),
       .dout (htickcmp_data[64-4:0])
);
//
// mux for read
mux2ds #(64-1) mux_htickcmp_rdata (
       .in0  (true_htickcmp0[64-2:0]),
       .in1  (true_htickcmp1[64-2:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (htickcmp_rdata[64-2:0])
);


















































































 // `ifndef CONFIG_NUM_THREADS
 
//
// evaluate for htickcmp match
assign tlu_htick_match = 
           (htickcmp_data[60:0] == 
            true_tick[60:0]);
//
//=========================================================================================
// HINTP REG for Threads
//=========================================================================================
// added for hypervisor support
// modified for timing
// creating clocks for accessing the hintp regs
assign tlu_hintp_en_l_g[0] = 
           ~(tlu_set_hintp_g[0] | tlu_wr_hintp_g[0]); 
assign tlu_hintp_en_l_g[1] = 
           ~(tlu_set_hintp_g[1] | tlu_wr_hintp_g[1]); 
assign tlu_hintp_en_l_g[2] = 
           ~(tlu_set_hintp_g[2] | tlu_wr_hintp_g[2]); 
assign tlu_hintp_en_l_g[3] = 
           ~(tlu_set_hintp_g[3] | tlu_wr_hintp_g[3]); 



clken_buf clkbf_hintp0 (
		.rclk	(clk),
		.enb_l	(tlu_hintp_en_l_g[0]),
		.tmb_l	(se_l),
		.clk	(hintp0_clk)
);




clken_buf clkbf_hintp1 (
		.rclk	(clk),
		.enb_l	(tlu_hintp_en_l_g[1]),
		.tmb_l	(se_l),
		.clk	(hintp1_clk)
);




clken_buf clkbf_hintp2 (
		.rclk	(clk),
		.enb_l	(tlu_hintp_en_l_g[2]),
		.tmb_l	(se_l),
		.clk	(hintp2_clk)
);




clken_buf clkbf_hintp3 (
		.rclk	(clk),
		.enb_l	(tlu_hintp_en_l_g[3]),
		.tmb_l	(se_l),
		.clk	(hintp3_clk)
);

// 
// setting the value of hintp registers
//
// Thread 0
// added for timing
assign tlu_set_hintp_g[0] = 
           tlu_set_hintp_sel_g[0] & tlu_htick_match;

// modified to reflect the physical implementation
// assign hintp_din[0] = 
//            (tlu_set_hintp_g[0])? tlu_set_hintp_g[0]: wsr_data_w[0]; 

mux2ds mx_hintp_din_0 (
       .in0  (tlu_set_hintp_g[0]),
	   .in1  (wsr_data_w[0]),
       .sel0 (tlu_set_hintp_g[0]),  	
	   .sel1 (~tlu_set_hintp_g[0]),
       .dout (hintp_din[0])
); 












dffr_s dffr_hintp0 (
     .din (hintp_din[0]), 
     .q   (tlu_hintp[0]),
     .clk (hintp0_clk),
	 .rst (local_rst),
     .se  (se),
     .si  (),
     .so  ()
);


// Thread 1
// added for timing
assign tlu_set_hintp_g[1] = 
           tlu_set_hintp_sel_g[1] & tlu_htick_match;

// modified to reflect the physical implementation
// assign hintp_din[1] = 
//            (tlu_set_hintp_g[1])? tlu_set_hintp_g[1]: wsr_data_w[0]; 

mux2ds mx_hintp_din_1 (
       .in0  (tlu_set_hintp_g[1]),
	   .in1  (wsr_data_w[0]),
       .sel0 (tlu_set_hintp_g[1]),  	
	   .sel1 (~tlu_set_hintp_g[1]),
       .dout (hintp_din[1])
); 












dffr_s dffr_hintp1 (
     .din (hintp_din[1]), 
     .q   (tlu_hintp[1]),
     .clk (hintp1_clk),
	 .rst (local_rst),
     .se  (se),
     .si  (),
     .so  ()
);


// Thread 2
// added for timing
assign tlu_set_hintp_g[2] = 
           tlu_set_hintp_sel_g[2] & tlu_htick_match;

// modified to reflect the physical implementation
// assign hintp_din[2] = 
//            (tlu_set_hintp_g[2])? tlu_set_hintp_g[2]: wsr_data_w[0]; 

mux2ds mx_hintp_din_2 (
       .in0  (tlu_set_hintp_g[2]),
	   .in1  (wsr_data_w[0]),
       .sel0 (tlu_set_hintp_g[2]),  	
	   .sel1 (~tlu_set_hintp_g[2]),
       .dout (hintp_din[2])
); 












dffr_s dffr_hintp2 (
     .din (hintp_din[2]), 
     .q   (tlu_hintp[2]),
     .clk (hintp2_clk),
	 .rst (local_rst),
     .se  (se),
     .si  (),
     .so  ()
);


// Thread 3
// added for timing
assign tlu_set_hintp_g[3] = 
           tlu_set_hintp_sel_g[3] & tlu_htick_match;

// modified to reflect the physical implementation
// assign hintp_din[3] = 
//            (tlu_set_hintp_g[3])? tlu_set_hintp_g[3]: wsr_data_w[0]; 

mux2ds mx_hintp_din_3 (
       .in0  (tlu_set_hintp_g[3]),
	   .in1  (wsr_data_w[0]),
       .sel0 (tlu_set_hintp_g[3]),  	
	   .sel1 (~tlu_set_hintp_g[3]),
       .dout (hintp_din[3])
); 












dffr_s dffr_hintp3 (
     .din (hintp_din[3]), 
     .q   (tlu_hintp[3]),
     .clk (hintp3_clk),
	 .rst (local_rst),
     .se  (se),
     .si  (),
     .so  ()
);


//=========================================================================================
//	DONE/RETRY 
//=========================================================================================

// PC/nPC will be updated by pc/npc from IFU,
// OR, Done/Retry which reads TSA in E stage. Execution of Done/Retry will
// put pc/npc temporarily in bypass flop which will then update actual pc/npc
// in g. Update of pc/npc by inst_in_w or done/retry thus becomes aligned.
// recoded due to lint violations - individualized the components
/*
dff_s #(`TLU_TSA_WIDTH) poptsa_m (
    .din (tsa_rdata[`TLU_TSA_WIDTH-1:0]), 
	.q   (tsa_data_m[`TLU_TSA_WIDTH-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// added, modified for hypervisor and timing 
assign dnrtry_pstate_m = 
       {2'b0,  // old IG, MG - replaced by global register
        tsa_data_m[`TSA_PSTATE_VRANGE2_HI:`TSA_PSTATE_VRANGE2_LO],
        2'b0,  // memory model has been change to TSO only - bug 2588
        1'b0,  // old RED - replaced by hpstate.red
        tsa_data_m[`TSA_PSTATE_VRANGE1_HI:`TSA_PSTATE_VRANGE1_LO],
        1'b0}; // old AG - replaced by global register 
        
dff_s #(12) dff_pstate_g (
    .din (dnrtry_pstate_m[`PSTATE_TRUE_WIDTH-1:0]),
	.q   (dnrtry_pstate[`PSTATE_TRUE_WIDTH-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
    );
*/
// recoded due to lint violation

dff_s #(6) dff_dnrtry_pstate_m (
    .din ({tsa_rdata[19:18],
           tsa_rdata[15:12]}),
	.q   (dnrtry_pstate_m[6-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
        
dff_s #(6) dff_pstate_g (
    .din (dnrtry_pstate_m[6-1:0]),
	.q   (dnrtry_pstate_g[6-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(6) dff_pstate_w2 (
    .din (dnrtry_pstate_g[6-1:0]),
	.q   (dnrtry_pstate_w2[6-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// assign dnrtry_pstate_m[`WSR_PSTATE_VR_WIDTH-1:0] = 
//        {tsa_data_m[`TSA_PSTATE_VRANGE2_HI:`TSA_PSTATE_VRANGE2_LO],
//         tsa_data_m[`TSA_PSTATE_VRANGE1_HI:`TSA_PSTATE_VRANGE1_LO]}; 
// 
// reading hpstate from tsa for recovery
// recoded due to lint violations

dff_s #(4) dff_tsa_dnrtry_hpstate_m (
    // .din (tsa_rdata[`TLU_HTSTATE_HI:`TLU_HTSTATE_LO]), 
    .din (tsa_rdata[133:130]), 
	.q   (tsa_dnrtry_hpstate_m[4-1:0]),
    .clk (clk),
    .se  (se),
    .si  (),          
    .so  ()
);

dff_s #(4) dff_tsa_dnrtry_hpstate_g (
//     .din (tsa_data_m[`TLU_HTSTATE_HI:`TLU_HTSTATE_LO]),
    .din (tsa_dnrtry_hpstate_m[4-1:0]),
	.q   (tsa_dnrtry_hpstate_g[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// 
// added for timing
dff_s #(4) dff_tsa_dnrtry_hpstate_w2 (
    .din (tsa_dnrtry_hpstate_g[4-1:0]),
	.q   (tsa_dnrtry_hpstate_w2[4-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// reading value of original global registers from tsa for recovery
// recoded due to lint cleanup
// assign dnrtry_global_m = tsa_data_m[`TLU_GL_HI:`TLU_GL_LO];

dff_s #(2) dff_dnrtry_global_m (
    .din (tsa_rdata[37:36]),
	.q   (dnrtry_global_m[2-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(2) dff_global_g (
    .din (dnrtry_global_m[2-1:0]),
	.q   (tlu_dnrtry_global_g[2-1:0]),
    .clk (clk),
    .se  (se), 
    .si  (),    
    .so  ()
);
//
/* logic moved to tlu_misctl
// added due to lint violations
dff_s #(47) dff_tsa_pc_m (
    .din (tsa_rdata[`TLU_PC_HI:`TLU_PC_LO]),
	.q   (tsa_pc_m[46:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(47) dff_tsa_npc_m (
    .din (tsa_rdata[`TLU_NPC_HI:`TLU_NPC_LO]),
	.q   (tsa_npc_m[46:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

// pstate may have to be staged by an additional cycle.
assign dnrtry_pc[48:0]  = {tsa_pc_m[46:0],2'b00};
assign dnrtry_npc[48:0] = {tsa_npc_m[46:0],2'b00};
*/

//=========================================================================================
//	PC/nPC
//=========================================================================================

// TRUE PC/NPC. AN INSTRUCTION'S PC/NPC IS VISIBLE IN W2.
// F:S:D:E:M:G:W2
// Modified by Done/Retry and inst

/* logic moved to tlu_misctl
// On done, npc will become pc. 
// modified due to bug 3017 
// pc width increase from 48 -> 49 bits
mux3ds #(49) finalpc_sel_m (
       .in0  (dnrtry_pc[48:0]), 	
	   .in1  (dnrtry_npc[48:0]),
	   .in2  (ifu_tlu_pc_m[48:0]),
       .sel0 (tlu_retry_inst_m),  	
	   .sel1 (tlu_done_inst_m),
	   .sel2 (tlu_dnrtry_inst_m_l),
       .dout (pc_new[48:0])
); 
// On done, npc will stay npc. The valid to the IFU will
// not be signaled along with npc for a done. 
// modified due to bug 3017 
// pc width increase from 48 -> 49 bits
mux2ds #(49) finalnpc_sel_m (
       .in0  (dnrtry_npc[48:0]), 	
       .in1  (ifu_tlu_npc_m[48:0]),
       .sel0 (~tlu_dnrtry_inst_m_l),  	
       .sel1 (tlu_dnrtry_inst_m_l),
       .dout (npc_new[48:0])
); 

dff_s #(49) dff_pc_new_w (
    .din (pc_new[48:0]), 	
    .q   (pc_new_w[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

dff_s #(49) dff_npc_new_w (
    .din (npc_new[48:0]), 	
    .q   (npc_new_w[48:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
*/
//


clken_buf clkbf_pc0 (
    .rclk  (clk),
    .enb_l (tlu_update_pc_l_w[0]),
	.tmb_l (se_l),
	.clk   (pc0_clk)
);	




clken_buf clkbf_pc1 (
    .rclk  (clk),
    .enb_l (tlu_update_pc_l_w[1]),
	.tmb_l (se_l),
	.clk   (pc1_clk)
);	




clken_buf clkbf_pc2 (
    .rclk  (clk),
    .enb_l (tlu_update_pc_l_w[2]),
	.tmb_l (se_l),
	.clk   (pc2_clk)
);	




clken_buf clkbf_pc3 (
    .rclk  (clk),
    .enb_l (tlu_update_pc_l_w[3]),
	.tmb_l (se_l),
	.clk   (pc3_clk)
);	
	
//
// modified for bug 3017 
// all pc width has been increased from 48 -> 49 bits
// Thread 0
//










dff_s #(49) pc0_true (
    .din (tlu_pc_new_w[48:0]), 
    .q   (true_pc0[48:0]),
    .clk (pc0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// update_pc will be used for both pc and npc - in this case
// npc will contain gibberish but it's okay. 
// modified to avert area growth 










dff_s #(49) npc0_true (
    .din (tlu_npc_new_w[48:0]), 	
    .q  (true_npc0[48:0]),
    .clk (pc0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// THREAD1
//










dff_s #(49) pc1_true (
    .din (tlu_pc_new_w[48:0]), 
    .q   (true_pc1[48:0]),
    .clk (pc1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// update_pc will be used for both pc and npc - in this case
// npc will contain gibberish but it's okay. 










dff_s #(49) npc1_true (
    .din (tlu_npc_new_w[48:0]), 	
    .q   (true_npc1[48:0]),
    .clk (pc1_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// THREAD2
//










dff_s #(49) pc2_true (
    .din (tlu_pc_new_w[48:0]), 
    .q   (true_pc2[48:0]),
    .clk (pc2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// update_pc will be used for both pc and npc - in this case
// npc will contain gibberish but it's okay. 










dff_s #(49) npc2_true (
    .din (tlu_npc_new_w[48:0]), 	
    .q   (true_npc2[48:0]),
    .clk (pc2_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
// THREAD3
//










dff_s #(49) pc3_true (
    .din (tlu_pc_new_w[48:0]), 
    .q   (true_pc3[48:0]),
    .clk (pc3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


// update_pc will be used for both pc and npc - in this case
// npc will contain gibberish but it's okay. 










dff_s #(49) npc3_true (
    .din (tlu_npc_new_w[48:0]), 	
    .q   (true_npc3[48:0]),
    .clk (pc3_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);


//=========================================================================================
//	Generating Trap Vector
//=========================================================================================
// 
// Normal Trap Processing.
mux2ds mux_pc_bit15_sel (
    .in0  (tlu_tl_gt_0_w2),
    .in1  (htba_data[0]),
    .sel0  (~tlu_trap_hpstate_enb),
    .sel1  (tlu_trap_hpstate_enb),
    .dout (pc_bit15_sel)
);

// trin: so jtag could overwrite the reset vector base
// //
// // modified to help speed up simulation time
// //
// assign tlu_rstvaddr_base[33:0] = `RSTVADDR_BASE;

reg                rtap_tlu_rstvbase_wr_en;
reg [33:0]         rtap_ifu_pc_data;

always @ *
begin
   rtap_tlu_rstvbase_wr_en = 0;
   if (rtap_core_val && rtap_core_id == 4'd4)
   begin
      rtap_tlu_rstvbase_wr_en = 1'b1;
   end
   rtap_ifu_pc_data = rtap_core_data[33:0];
end

always @ (posedge clk)
begin
   if (local_rst)
      tlu_rstvaddr_base <= 34'h3_ffff_c000;
   else
   begin
      if (rtap_tlu_rstvbase_wr_en)
      begin
         tlu_rstvaddr_base <= rtap_ifu_pc_data;
      end
   end
end

mux3ds #(34) nrmlpc_sel_w2 (
       .in0  (tlu_rstvaddr_base[33:0]),
	   .in1  ({tba_data[32:0], tlu_tl_gt_0_w2}),
	   .in2  ({htba_data[33:1], pc_bit15_sel}),
       .sel0 (tlu_pc_mxsel_w2[0]),
	   .sel1 (tlu_pc_mxsel_w2[1]),
	   .sel2 (tlu_pc_mxsel_w2[2]),
       .dout (partial_trap_pc_w2[33:0])
);

assign tlu_partial_trap_pc_w1[33:0] = partial_trap_pc_w2[33:0]; 

// restore pc/npc select
// true pc muxed into restore pc; previously restore_pcx was muxed in.
// modified due to bug 3017
 // Use two threads unless this is defined

mux2ds  #(98) trprsel (
        .in0    ({true_pc0[48:0],true_npc0[48:0]}),
        .in1    ({true_pc1[48:0],true_npc1[48:0]}),
        .sel0   (tlu_thrd_wsel_w2[0]),
        .sel1   (tlu_thrd_wsel_w2[1]),
        .dout   ({restore_pc_w2[48:0],restore_npc_w2[48:0]})
);

















































 // `ifndef CONFIG_NUM_THREADS
   
//
// the matching of the w1 and w2 is intentional
assign tlu_restore_pc_w1[48:0]  = restore_pc_w2[48:0];
assign tlu_restore_npc_w1[48:0] = restore_npc_w2[48:0];

//=========================================================================================
//	TAP PC OBSERVABILITY
//=========================================================================================
//
// modified due to spec change
// shadow scan 
// thread 0 data
assign sscan_data_test0[51-1:0] = 
           {true_hpstate0[2:0], 
            true_pstate0[2],
            true_pstate0[1],
            true_pc0[47:2]};
//
// thread 1 data
assign sscan_data_test1[51-1:0] = 
           {true_hpstate1[2:0], 
            true_pstate1[2],
            true_pstate1[1],
            true_pc1[47:2]};
// //
// // thread 2 data
// assign sscan_data_test2[`TDP_SSCAN_WIDTH-1:0] = 
//            {true_hpstate2[2:0], 
//             true_pstate2[`PSTATE_PRIV],
//             true_pstate2[`PSTATE_IE],
//             true_pc2[47:2]};
// //
// // thread 3 data
// assign sscan_data_test3[`TDP_SSCAN_WIDTH-1:0] = 
//            {true_hpstate3[2:0], 
//             true_pstate3[`PSTATE_PRIV],
//             true_pstate3[`PSTATE_IE],
//             true_pc3[47:2]};
//
// `ifndef CONFIG_NUM_THREADS // Use two threads unless this is defined

// mux2ds #(`TDP_SSCAN_WIDTH) mx_sscan_test_data (
//        .in0  (sscan_data_test0[`TDP_SSCAN_WIDTH-1:0]),
//        .in1  (sscan_data_test1[`TDP_SSCAN_WIDTH-1:0]),
//        .sel0 (sscan_tid_sel[0]),
//        .sel1 (sscan_tid_sel[1]),
//        .dout (tdp_sscan_test_data[`TDP_SSCAN_WIDTH-1:0])
// );

// `else // `ifndef CONFIG_NUM_THREADS

// `ifdef FPGA_SYN_1THREAD
//    assign tdp_sscan_test_data[`TDP_SSCAN_WIDTH-1:0] = sscan_data_test0[`TDP_SSCAN_WIDTH-1:0];

// `elsif THREADS_1

//    assign tdp_sscan_test_data[`TDP_SSCAN_WIDTH-1:0] = sscan_data_test0[`TDP_SSCAN_WIDTH-1:0];

// `elsif THREADS_2

mux2ds #(51) mx_sscan_test_data (
       .in0  (sscan_data_test0[51-1:0]),
       .in1  (sscan_data_test1[51-1:0]),
       .sel0 (sscan_tid_sel[0]),
       .sel1 (sscan_tid_sel[1]),
       .dout (tdp_sscan_test_data[51-1:0])
);

// `elsif THREADS_3

// mux3ds #(`TDP_SSCAN_WIDTH) mx_sscan_test_data (
//        .in0  (sscan_data_test0[`TDP_SSCAN_WIDTH-1:0]),
//        .in1  (sscan_data_test1[`TDP_SSCAN_WIDTH-1:0]),
//        .in2  (sscan_data_test2[`TDP_SSCAN_WIDTH-1:0]),
//        .sel0 (sscan_tid_sel[0]),
//        .sel1 (sscan_tid_sel[1]),
//        .sel2 (sscan_tid_sel[2]),
//        .dout (tdp_sscan_test_data[`TDP_SSCAN_WIDTH-1:0])
// );

// `else
   
// mux4ds #(`TDP_SSCAN_WIDTH) mx_sscan_test_data (
//        .in0  (sscan_data_test0[`TDP_SSCAN_WIDTH-1:0]),
//        .in1  (sscan_data_test1[`TDP_SSCAN_WIDTH-1:0]),
//        .in2  (sscan_data_test2[`TDP_SSCAN_WIDTH-1:0]),
//        .in3  (sscan_data_test3[`TDP_SSCAN_WIDTH-1:0]),
//        .sel0 (sscan_tid_sel[0]),
//        .sel1 (sscan_tid_sel[1]),
//        .sel2 (sscan_tid_sel[2]),
//        .sel3 (sscan_tid_sel[3]),
//        .dout (tdp_sscan_test_data[`TDP_SSCAN_WIDTH-1:0])
// ); 
// `endif // !`ifdef FPGA_SYN_1THREAD
  
// `endif // `ifndef CONFIG_NUM_THREADS
 
assign sscan_tid_sel[4-1:0] = ctu_sscan_tid[4-1:0]; 

assign tlu_sscan_test_data[51-1:0] =
          tdp_sscan_test_data[51-1:0]; 

//=========================================================================================
//	PSTATE for Threads
//=========================================================================================

// pstate needs to be updated on a trap. Assume for now that only non-RED state instruction
// related traps are handled.

// Normal traps, non-red mode.
assign pstate_priv_set = tlu_select_tba_w2 | local_rst | tlu_select_redmode;
//
assign pstate_priv_thrd_set[0] = pstate_priv_set | ~true_hpstate0[3];
assign pstate_priv_thrd_set[1] = pstate_priv_set | ~true_hpstate1[3];
assign pstate_priv_thrd_set[2] = pstate_priv_set | ~true_hpstate2[3];
assign pstate_priv_thrd_set[3] = pstate_priv_set | ~true_hpstate3[3];
//
// modified for bug 3349
assign pstate_priv_update_w2[0] = 
       ~(tlu_update_pstate_l_w2[0] & 
        (true_hpstate0[3] | tlu_update_hpstate_l_w2[0])) |
        (~wsr_data_w2[11] & tlu_hpstate_din_sel0[1]);
assign pstate_priv_update_w2[1] = 
       ~(tlu_update_pstate_l_w2[1] & 
        (true_hpstate1[3] | tlu_update_hpstate_l_w2[1])) |
        (~wsr_data_w2[11] & tlu_hpstate_din_sel1[1]);
assign pstate_priv_update_w2[2] = 
       ~(tlu_update_pstate_l_w2[2] & 
        (true_hpstate2[3] | tlu_update_hpstate_l_w2[2])) |
        (~wsr_data_w2[11] & tlu_hpstate_din_sel2[1]);
assign pstate_priv_update_w2[3] = 
       ~(tlu_update_pstate_l_w2[3] & 
        (true_hpstate3[3] | tlu_update_hpstate_l_w2[3])) |
        (~wsr_data_w2[11] & tlu_hpstate_din_sel3[1]);
//
assign hpstate_priv_update_w2[0] = 
       ~(tlu_update_hpstate_l_w2[0] & 
        (true_hpstate0[3] | tlu_update_pstate_l_w2[0]));
assign hpstate_priv_update_w2[1] = 
       ~(tlu_update_hpstate_l_w2[1] & 
        (true_hpstate1[3] | tlu_update_pstate_l_w2[1]));
assign hpstate_priv_update_w2[2] = 
       ~(tlu_update_hpstate_l_w2[2] & 
        (true_hpstate2[3] | tlu_update_pstate_l_w2[2]));
assign hpstate_priv_update_w2[3] = 
       ~(tlu_update_hpstate_l_w2[3] & 
        (true_hpstate3[3] | tlu_update_pstate_l_w2[3]));
//
// added for bug 2161 and modified for bug 2161
assign hpstate_enb_set[0] = true_hpstate0[3] & ~(local_rst | tlu_select_redmode); 
assign hpstate_enb_set[1] = true_hpstate1[3] & ~(local_rst | tlu_select_redmode); 
assign hpstate_enb_set[2] = true_hpstate2[3] & ~(local_rst | tlu_select_redmode);
assign hpstate_enb_set[3] = true_hpstate3[3] & ~(local_rst | tlu_select_redmode);

// added for hpstate.ibe ECO 
// modified due to timing - tlu_ibrkpt_trap_g has been delayed one stage to tlu_ibrkpt_trap_w2
assign hpstate_ibe_set[0] = 
           true_hpstate0[4] & ~(local_rst | tlu_select_redmode | tlu_ibrkpt_trap_w2);
assign hpstate_ibe_set[1] = 
           true_hpstate1[4] & ~(local_rst | tlu_select_redmode | tlu_ibrkpt_trap_w2);
assign hpstate_ibe_set[2] = 
           true_hpstate2[4] & ~(local_rst | tlu_select_redmode | tlu_ibrkpt_trap_w2);
assign hpstate_ibe_set[3] = 
           true_hpstate3[4] & ~(local_rst | tlu_select_redmode | tlu_ibrkpt_trap_w2);
//
// added due to TLZ spec change 
// modified for bug 3505
assign hpstate_tlz_set[0] = true_hpstate0[0] & ~(local_rst | tlu_select_redmode);
assign hpstate_tlz_set[1] = true_hpstate1[0] & ~(local_rst | tlu_select_redmode);
assign hpstate_tlz_set[2] = true_hpstate2[0] & ~(local_rst | tlu_select_redmode);
assign hpstate_tlz_set[3] = true_hpstate3[0] & ~(local_rst | tlu_select_redmode);
//
// thread 0
assign tlu_select_tle[0] =
           tlu_pstate_tle[0] & ~(tlu_select_redmode);
// modified for timing and bug 3417 
assign tlu_select_cle[0] =
           tlu_select_tle[0] & 
          (tlu_select_tba_w2 | ~true_hpstate0[3]); 
//         tlu_select_tle[0] & tlu_select_tba_w2; 
//
// modified for timing and width cleanup
/*
assign	ntrap_pstate0[`PSTATE_TRUE_WIDTH-1:0] = 
    {2'b0,  // tlu_select_int_global - replaced by gl register	
	        // tlu_select_mmu_global - replaced by gl register
	 tlu_select_cle[0], // cle<-tle, or 0	
	 tlu_select_tle[0], // keep old tle, or 0
     2'b0,
     1'b0,  // tlu_select_redmode - replaced by hpstate.red
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[0], // enter priv mode for priv traps
	 1'b0,  // interrupts disabled
	 1'b0}; // tlu_select_alt_global - replaced by gl register 
*/
assign	ntrap_pstate0[6-1:0] = 
    {tlu_select_cle[0], // cle<-tle, or 0	
	 tlu_select_tle[0], // keep old tle, or 0
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[0], // enter priv mode for priv traps
	 1'b0}; // interrupts disabled
//
// thread 1
assign tlu_select_tle[1] =
           tlu_pstate_tle[1] & ~(tlu_select_redmode);
// modified for timing and bug 3417 
assign tlu_select_cle[1] =
           tlu_select_tle[1] & 
          (tlu_select_tba_w2 | ~true_hpstate1[3]); 
//           tlu_select_tle[1] & tlu_select_tba_w2;
//
// modified due to timing
/*
assign	ntrap_pstate1[`PSTATE_TRUE_WIDTH-1:0] = 
    {2'b0,  // tlu_select_int_global - replaced by gl register	
	        // tlu_select_mmu_global - replaced by gl register
	 tlu_select_cle[1], // cle<-tle, or 0	
	 tlu_select_tle[1], // keep old tle, or 0
     2'b0,
     1'b0,  // tlu_select_redmode - replaced by hpstate.red
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[1], // enter priv mode for priv traps
	 1'b0,  // interrupts disabled
	 1'b0}; // tlu_select_alt_global - replaced by gl register 
*/
assign	ntrap_pstate1[6-1:0] = 
    {tlu_select_cle[1], // cle<-tle, or 0	
	 tlu_select_tle[1], // keep old tle, or 0
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[1], // enter priv mode for priv traps
	 1'b0}; // interrupts disabled// 
//
// thread 2
assign tlu_select_tle[2] =
           tlu_pstate_tle[2] & ~(tlu_select_redmode);
// modified for timing and bug 3417 
assign tlu_select_cle[2] =
           tlu_select_tle[2] & 
          (tlu_select_tba_w2 | ~true_hpstate2[3]); 
//           tlu_select_tle[2] & tlu_select_tba_w2; 
//
// modified for timing and width cleanup
/*
assign	ntrap_pstate2[`PSTATE_TRUE_WIDTH-1:0] = 
    {2'b0,  // tlu_select_int_global - replaced by gl register	
	        // tlu_select_mmu_global - replaced by gl register
	 tlu_select_cle[2], // cle<-tle, or 0	
	 tlu_select_tle[2], // keep old tle, or 0
     2'b0,
     1'b0,  // tlu_select_redmode - replaced by hpstate.red
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[2], // enter priv mode for priv traps
	 1'b0,  // interrupts disabled
	 1'b0}; // tlu_select_alt_global - replaced by gl register 
*/
assign	ntrap_pstate2[6-1:0] = 
    {tlu_select_cle[2], // cle<-tle, or 0	
	 tlu_select_tle[2], // keep old tle, or 0
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[2], // enter priv mode for priv traps
	 1'b0}; // interrupts disabled// 
//
// thread 3
assign tlu_select_tle[3] =
           tlu_pstate_tle[3] & ~(tlu_select_redmode);
// modified for timing and bug 3417 
assign tlu_select_cle[3] =
           tlu_select_tle[3] & 
          (tlu_select_tba_w2 | ~true_hpstate3[3]); 
//           tlu_select_tle[3] & tlu_select_tba_w2;
//
// modified for timing
/*
assign	ntrap_pstate3[`PSTATE_TRUE_WIDTH-1:0] = 
    {2'b0,  // tlu_select_int_global - replaced by gl register	
	        // tlu_select_mmu_global - replaced by gl register
	 tlu_select_cle[3], // cle<-tle, or 0	
	 tlu_select_tle[3], // keep old tle, or 0
     2'b0,
     1'b0,  // tlu_select_redmode - replaced by hpstate.red
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[3], // enter priv mode for priv traps
	 1'b0,  // interrupts disabled
	 1'b0}; // tlu_select_alt_global - replaced by gl register 
*/
assign	ntrap_pstate3[6-1:0] = 
    {tlu_select_cle[3], // cle<-tle, or 0	
	 tlu_select_tle[3], // keep old tle, or 0
	 1'b1,  // fp turned on
	 1'b0,  // address masking turned off
	 pstate_priv_thrd_set[3], // enter priv mode for priv traps
	 1'b0}; // interrupts disabled// 

// Clock Enable Buffers
//


clken_buf clkbf_ps0 (
    .rclk  (clk),
	.enb_l (tlu_update_pstate_l_w2[0]),
	.tmb_l (se_l),
	.clk   (pstate0_clk)
);




clken_buf clkbf_ps1 (
    .rclk  (clk),
	.enb_l (tlu_update_pstate_l_w2[1]),
	.tmb_l (se_l),
	.clk   (pstate1_clk)
);




clken_buf clkbf_ps2 (
    .rclk  (clk),
	.enb_l (tlu_update_pstate_l_w2[2]),
	.tmb_l (se_l),
	.clk   (pstate2_clk)
);




clken_buf clkbf_ps3 (
    .rclk  (clk),
	.enb_l (tlu_update_pstate_l_w2[3]),
	.tmb_l (se_l),
	.clk   (pstate3_clk)
);

//
// added for hypervisor support 
// clock enable buffers for updating the hpstate registers
//


clken_buf clkbf_hps0 (
    .rclk  (clk),
	.enb_l (tlu_update_hpstate_l_w2[0]),
	.tmb_l (se_l),
	.clk   (hpstate0_clk)
);




clken_buf clkbf_hps1 (
    .rclk  (clk),
	.enb_l (tlu_update_hpstate_l_w2[1]),
	.tmb_l (se_l),
	.clk   (hpstate1_clk)
);




clken_buf clkbf_hps2 (
    .rclk  (clk),
	.enb_l (tlu_update_hpstate_l_w2[2]),
	.tmb_l (se_l),
	.clk   (hpstate2_clk)
);




clken_buf clkbf_hps3 (
    .rclk  (clk),
	.enb_l (tlu_update_hpstate_l_w2[3]),
	.tmb_l (se_l),
	.clk   (hpstate3_clk)
);

// assign the initial value of hpstate.red mode
//
// modified for bug 1893
// assign hpstate_redmode = 
//            (local_rst)? 1'b1: tlu_select_redmode;
assign hpstate_redmode = 
           local_rst | (~local_rst & tlu_select_redmode); 
// 
// extracting hpstate from wsr_data
//
// modified for timing tlu_wsr_data_w -> wsr_data_w2
assign wsr_data_hpstate_w2[5-1:0] = 
     {wsr_data_w2[10],
      wsr_data_w2[11],
      wsr_data_w2[5],
      wsr_data_w2[2],
      wsr_data_w2[0]
     };
//
// added or modified for hypervisor support
// modified due to timing
/*
assign wsr_data_pstate_g[`PSTATE_TRUE_WIDTH-1:0] = 
    {2'b0,  // old IG, MG - replaced by global register
     tlu_wsr_data_w[`PSTATE_VRANGE2_HI:`PSTATE_VRANGE2_LO], 
     2'b0,  // memory model has been change to TSO only - bug 2588
     1'b0,  // old red, - replaced by hpstate.red 
     tlu_wsr_data_w[`PSTATE_VRANGE1_HI:`PSTATE_VRANGE1_LO], 
     1'b0};  // old AG - replaced by global register 

assign wsr_data_pstate_g[`WSR_PSTATE_VR_WIDTH-1:0] = 
       {tlu_wsr_data_w[`PSTATE_VRANGE2_HI:`PSTATE_VRANGE2_LO],
        tlu_wsr_data_w[`PSTATE_VRANGE1_HI:`PSTATE_VRANGE1_LO]};
*/
assign wsr_data_pstate_w2[6-1:0] = 
       {wsr_data_w2[9:8],
        wsr_data_w2[4:1]};
//
// THREAD0
// added for bug 1575
// modified for bug 2584
// assign tlu_pstate_nt_sel0 = ~|(tlu_pstate_din_sel0[1:0]);
assign tlu_pstate_nt_sel0 = 
          ~(tlu_pstate_din_sel0[0] | tlu_pstate_wsr_sel0);
// 
// modified for bug 3349
assign tlu_pstate_wsr_sel0 = 
           tlu_pstate_din_sel0[1] | 
           (~(true_hpstate0[3] & wsr_data_w2[11]) &
              tlu_hpstate_din_sel0[1]);
//            (~true_hpstate0[`HPSTATE_ENB] & tlu_hpstate_din_sel0[1]);

mux3ds #(6) mux_restore_pstate0(
       .in0  (dnrtry_pstate_w2[6-1:0]), 	
	   .in1  (wsr_data_pstate_w2[6-1:0]),
	   .in2  (ntrap_pstate0[6-1:0]),
       .sel0 (tlu_pstate_din_sel0[0]),  		
	   .sel1 (tlu_pstate_wsr_sel0),
	   .sel2 (tlu_pstate_nt_sel0),
       .dout (restore_pstate0[6-1:0])
);













dff_s #(6-1) dff_restore_pstate0_w3 (
    .din ({restore_pstate0[5:3-1], 
           restore_pstate0[0]}), 
    .q   ({restore_pstate0_w3[5:3-1],
           restore_pstate0_w3[0]}),
    .clk (pstate0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
dffe_s dffe_pstate0_priv (
    .din (restore_pstate0[1]),
    .q   (restore_pstate0_w3[1]),
    .en  (pstate_priv_update_w2[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
// true_pstate0 assignments
assign true_pstate0[12-1:0] = 
           {2'b0, // tlu_select_int_global - replaced by gl register
                  // tlu_select_mmu_global - replaced by gl register 
            restore_pstate0_w3[5:4],
            2'b0, // fixed mmodel - TSO
            1'b0, // redmode - replaced by hpstate.red
            restore_pstate0_w3[3:0],
            1'b0}; // tlu_select_alt_global - replaced by gl register 
//
// modified for timing
/*
mux3ds #(9) mux_restore_pstate0(
       .in0  (dnrtry_pstate[`PSTATE_TRUE_WIDTH-3:1]), 	
	   .in1  (wsr_data_pstate_g[`PSTATE_TRUE_WIDTH-3:1]),
	   .in2  (ntrap_pstate0[`PSTATE_TRUE_WIDTH-3:1]),
       .sel0 (tlu_pstate_din_sel0[0]),  		
       // modified for bug 2584
	   // .sel1 (tlu_pstate_din_sel0[1]),
	   .sel1 (tlu_pstate_wsr_sel0),
	   .sel2 (tlu_pstate_nt_sel0),
       .dout (restore_pstate0[`PSTATE_TRUE_WIDTH-3:1])
);

dff_s #(`PSTATE_TRUE_WIDTH) pstate0_1 (
    .din (restore_pstate0[`PSTATE_TRUE_WIDTH-1:0]), 
	.q   (true_pstate0[`PSTATE_TRUE_WIDTH-1:0]),
    .clk (pstate0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
 );
//
dff_s #(`PSTATE_TRUE_WIDTH-1) dff_true_pstate0 (
    .din ({restore_pstate0[`PSTATE_TRUE_WIDTH-1:3], 
           restore_pstate0[1:0]}), 
    .q   ({true_pstate0[`PSTATE_TRUE_WIDTH-1:3], 
           true_pstate0[1:0]}), 
    .clk (pstate0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
//
dffe_s dffe_pstate0_priv (
    .din (restore_pstate0[`PSTATE_PRIV]),
    .q   (true_pstate0[`PSTATE_PRIV]),
    .en  (pstate_priv_update_g[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);
// modified for hypervisor support
assign restore_pstate0[11:10] = 2'b0;
assign restore_pstate0[0]     = 1'b0;
//
// modified to reflect the physical implementation
// assign hpstate_dnrtry_priv_w2[0] = 
           (true_hpstate0[`HPSTATE_ENB])? 
            tsa_dnrtry_hpstate_w2[`HPSTATE_PRIV] :
            dnrtry_pstate_w2[`WSR_PSTATE_VR_PRIV];
*/
mux2ds mx_hpstate_dnrtry_priv_w2_0 (
       .in0  (tsa_dnrtry_hpstate_w2[1]),
	   .in1  (dnrtry_pstate_w2[1]),
       .sel0 (true_hpstate0[3]),  	
	   .sel1 (~true_hpstate0[3]),
       .dout (hpstate_dnrtry_priv_w2[0])
); 
//
assign dnrtry_hpstate0_w2[5-1:0] = 
       {tsa_dnrtry_hpstate_w2[4-1],
        true_hpstate0[3],  
        tsa_dnrtry_hpstate_w2[2],
        hpstate_dnrtry_priv_w2[0],
        tsa_dnrtry_hpstate_w2[0]};

// added for bug 3747
assign hpstate_priv_set = ~(tlu_select_tba_w2) | tlu_select_redmode; 
//
// constructing the hpstate for hyper-privileged traps 
//
assign hntrap_hpstate0_w2[5-1:0] = 
       {hpstate_ibe_set[0],  
        hpstate_enb_set[0],  
        hpstate_redmode, // Redmode bit
        // modified for bug 3747
        hpstate_priv_set, // hyper-privileged bit
        hpstate_tlz_set[0]}; // TLZ interrupt bit 

assign tlu_hpstate_hnt_sel0 = 
       ~(tlu_hpstate_din_sel0[0] | tlu_hpstate_wsr_sel0);
//
assign tlu_hpstate_wsr_sel0 = 
           tlu_hpstate_din_sel0[1] | 
           (~true_hpstate0[3] & tlu_pstate_din_sel0[1]);

mux3ds #(5) mux_restore_hpstate0(
       .in0  (dnrtry_hpstate0_w2[5-1:0]), 	
	   .in1  (wsr_data_hpstate_w2[5-1:0]),
	   .in2  (hntrap_hpstate0_w2[5-1:0]),
       .sel0 (tlu_hpstate_din_sel0[0]),  		
       .sel1 (tlu_hpstate_wsr_sel0),
	   .sel2 (tlu_hpstate_hnt_sel0),
       .dout (restore_hpstate0[5-1:0])
);
//
// need to initialize hpstate.enb = 0
// need to initialize hpstate.ibe = 0
// modified due to the addition of hpstate.ibe











dffr_s #(2) dffr_true_hpst0_enb_ibe (
    .din (restore_hpstate0[5-1:5-2]),
	.q   (true_hpstate0[5-1:5-2]),
    .rst (local_rst),
    .clk (hpstate0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
 );

//












dff_s #(2) dff_true_hpstate0 (
    .din ({restore_hpstate0[2], 
           restore_hpstate0[0]}),
    .q   ({true_hpstate0[2], 
           true_hpstate0[0]}),
    .clk (hpstate0_clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

//
dffe_s dffe_hpstate0_priv (
    .din (restore_hpstate0[1]), 
    .q   (true_hpstate0[1]), 
    .en  (hpstate_priv_update_w2[0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

assign tlu_ifu_pstate_pef[0]   = true_pstate0[4];
assign tlu_lsu_pstate_cle[0]   = true_pstate0[9];
assign tlu_lsu_pstate_priv[0]  = true_pstate0[2];
assign tlu_int_pstate_ie[0]    = true_pstate0[1];
assign local_pstate_ie[0]      = true_pstate0[1];
// assign tlu_pstate_cle[0] 	   = true_pstate0[`PSTATE_CLE];
assign tlu_pstate_tle[0] 	   = true_pstate0[8];
// assign tlu_pstate_priv[0] 	   = true_pstate0[`PSTATE_PRIV];
assign local_pstate_priv[0]    = true_pstate0[2];
assign tlu_pstate_am[0] 	   = true_pstate0[3];
assign tlu_int_redmode[0] = true_hpstate0[2];
assign tlu_lsu_redmode[0] = true_hpstate0[2];
// 
// hypervisor privilege indicator
assign tlu_hpstate_priv[0]   = true_hpstate0[1];
assign local_hpstate_priv[0] = true_hpstate0[1];
assign tcl_hpstate_priv[0]   = true_hpstate0[1];
//
// hypervisor lite mode selector
assign tlu_hpstate_enb[0]   = true_hpstate0[3];
assign local_hpstate_enb[0] = true_hpstate0[3];
assign tcl_hpstate_enb[0]   = true_hpstate0[3];

// hypervisor tlz indicator
assign tlu_hpstate_tlz[0] = true_hpstate0[0];

// hypervisor instruction breakpt enable 
assign tlu_hpstate_ibe[0] = true_hpstate0[4];

 // Use two threads unless this is defined

// THREAD 1
assign tlu_pstate_nt_sel1 =
          ~(tlu_pstate_din_sel1[0] | tlu_pstate_wsr_sel1);
//
// modified for bug 3349
assign tlu_pstate_wsr_sel1 =
              tlu_pstate_din_sel1[1] |
           (~(true_hpstate1[3] & wsr_data_w2[11]) &
              tlu_hpstate_din_sel1[1]);
//            (~true_hpstate1[`HPSTATE_ENB] & tlu_hpstate_din_sel1[1]);

mux3ds #(6) mux_restore_pstate1(
       .in0  (dnrtry_pstate_w2[6-1:0]),
       .in1  (wsr_data_pstate_w2[6-1:0]),
       .in2  (ntrap_pstate1[6-1:0]),
       .sel0 (tlu_pstate_din_sel1[0]),
       .sel1 (tlu_pstate_wsr_sel1),
       .sel2 (tlu_pstate_nt_sel1),
       .dout (restore_pstate1[6-1:0])
);













dff_s #(6-1) dff_restore_pstate1_w3 (
    .din ({restore_pstate1[5:3-1],
           restore_pstate1[0]}),
    .q   ({restore_pstate1_w3[5:3-1],
           restore_pstate1_w3[0]}),
    .clk (pstate1_clk),
    .se  (se),
    .si  (),
    .so  ()
);

//
dffe_s dffe_pstate1_priv (
    .din (restore_pstate1[1]),
    .q   (restore_pstate1_w3[1]),
    .en  (pstate_priv_update_w2[1]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified to reflect the physical implementation
/*
assign hpstate_dnrtry_priv_w2[1] =
           (true_hpstate1[`HPSTATE_ENB])?
            tsa_dnrtry_hpstate_w2[`HPSTATE_PRIV] :
            dnrtry_pstate_w2[`WSR_PSTATE_VR_PRIV];
*/
mux2ds mx_hpstate_dnrtry_priv_w2_1 (
       .in0  (tsa_dnrtry_hpstate_w2[1]),
       .in1  (dnrtry_pstate_w2[1]),
       .sel0 (true_hpstate1[3]),
       .sel1 (~true_hpstate1[3]),
       .dout (hpstate_dnrtry_priv_w2[1])
);
//
assign dnrtry_hpstate1_w2[5-1:0] =
       {tsa_dnrtry_hpstate_w2[4-1],
        true_hpstate1[3],
        tsa_dnrtry_hpstate_w2[2],
        hpstate_dnrtry_priv_w2[1],
        tsa_dnrtry_hpstate_w2[0]};
//
// true_pstate1 assignments
assign true_pstate1[12-1:0] =
           {2'b0, // tlu_select_int_global - replaced by gl register
                  // tlu_select_mmu_global - replaced by gl register
            restore_pstate1_w3[5:4],
            2'b0, // fixed mmodel - TSO
            1'b0, // redmode - replaced by hpstate.red
            restore_pstate1_w3[3:0],
            1'b0}; // tlu_select_alt_global - replaced by gl register
//
// modified for timing
/*
mux3ds #(9) mux_restore_pstate1(
       .in0  (dnrtry_pstate[`PSTATE_TRUE_WIDTH-3:1]),
       .in1  (wsr_data_pstate_g[`PSTATE_TRUE_WIDTH-3:1]),
       .in2  (ntrap_pstate1[`PSTATE_TRUE_WIDTH-3:1]),
       .sel0 (tlu_pstate_din_sel1[0]),
       // modified for bug 2584
       // .sel1 (tlu_pstate_din_sel1[1]),
       .sel1 (tlu_pstate_wsr_sel1),
       .sel2 (tlu_pstate_nt_sel1),
       .dout (restore_pstate1[`PSTATE_TRUE_WIDTH-3:1])
);

`ifdef FPGA_SYN_CLK_DFF
dffe_s #(`PSTATE_TRUE_WIDTH) pstate1_1 (
    .din (restore_pstate1[`PSTATE_TRUE_WIDTH-1:0]),
    .q   (true_pstate1[`PSTATE_TRUE_WIDTH-1:0]),
    .en (~(tlu_update_pstate_l_w2[1])), .clk(clk),
    .se  (se),
    .si  (),
    .so  ()
    );
`else
dff_s #(`PSTATE_TRUE_WIDTH) pstate1_1 (
    .din (restore_pstate1[`PSTATE_TRUE_WIDTH-1:0]),
    .q   (true_pstate1[`PSTATE_TRUE_WIDTH-1:0]),
    .clk (pstate1_clk),
    .se  (se),
    .si  (),
    .so  ()
    );
`endif
//
`ifdef FPGA_SYN_CLK_DFF
dffe_s #(`PSTATE_TRUE_WIDTH-1) dff_true_pstate1 (
    .din ({restore_pstate1[`PSTATE_TRUE_WIDTH-1:3],
           restore_pstate1[1:0]}),
    .q   ({true_pstate1[`PSTATE_TRUE_WIDTH-1:3],
           true_pstate1[1:0]}),
    .en (~(tlu_update_pstate_l_w2[1])), .clk(clk),
    .se  (se),
    .si  (),
    .so  ()
);
`else
dff_s #(`PSTATE_TRUE_WIDTH-1) dff_true_pstate1 (
    .din ({restore_pstate1[`PSTATE_TRUE_WIDTH-1:3],
           restore_pstate1[1:0]}),
    .q   ({true_pstate1[`PSTATE_TRUE_WIDTH-1:3],
           true_pstate1[1:0]}),
    .clk (pstate1_clk),
    .se  (se),
    .si  (),
    .so  ()
);
`endif
//
dffe_s dffe_pstate1_priv (
    .din (restore_pstate1[`PSTATE_PRIV]),
    .q   (true_pstate1[`PSTATE_PRIV]),
    .en  (pstate_priv_update_g[1]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);
//
// modified for hypervisor support
assign restore_pstate1[11:10] = 2'b0;
assign restore_pstate1[0]     = 1'b0;
*/
//
// constructing the hpstate for hyper-privileged traps
//
assign hntrap_hpstate1_w2[5-1:0] =
       {hpstate_ibe_set[1],
        hpstate_enb_set[1],
        hpstate_redmode,  // Redmode bit
        hpstate_priv_set, // hyper-privileged bit
        hpstate_tlz_set[1]}; // TLZ interrupt bit
//
assign tlu_hpstate_hnt_sel1 =
       ~(tlu_hpstate_din_sel1[0] | tlu_hpstate_wsr_sel1);
//
assign tlu_hpstate_wsr_sel1 =
           tlu_hpstate_din_sel1[1] |
           (~true_hpstate1[3] & tlu_pstate_din_sel1[1]);

mux3ds #(5) mux_restore_hpstate1 (
       .in0  (dnrtry_hpstate1_w2[5-1:0]),
       .in1  (wsr_data_hpstate_w2[5-1:0]),
       .in2  (hntrap_hpstate1_w2[5-1:0]),
       .sel0 (tlu_hpstate_din_sel1[0]),
       .sel1 (tlu_hpstate_wsr_sel1),
       .sel2 (tlu_hpstate_hnt_sel1),
       .dout (restore_hpstate1[5-1:0])
);

// need to initialize hpstate.enb = 0
// need to initialize hpstate.ibe = 0
// modified due to the addition of hpstate.ibe











dffr_s #(2) dffr_true_hpst1_enb_ibe (
    .din (restore_hpstate1[5-1:5-2]),
    .q   (true_hpstate1[5-1:5-2]),
    .rst (local_rst),
    .clk (hpstate1_clk),
    .se  (se),
    .si  (),
    .so  ()
);

//












dff_s #(2) dff_true_hpstate1 (
    .din ({restore_hpstate1[2],
           restore_hpstate1[0]}),
    .q   ({true_hpstate1[2],
           true_hpstate1[0]}),
    .clk (hpstate1_clk),
    .se  (se),
    .si  (),
    .so  ()
);

//
dffe_s dffe_hpstate1_priv (
    .din (restore_hpstate1[1]),
    .q   (true_hpstate1[1]),
    .en  (hpstate_priv_update_w2[1]),
    .clk (clk),
    .se  (se),
    .si  (),
    .so  ()
);

assign tlu_ifu_pstate_pef[1]   = true_pstate1[4];
assign tlu_lsu_pstate_cle[1]   = true_pstate1[9];
assign tlu_lsu_pstate_priv[1]  = true_pstate1[2];
assign tlu_int_pstate_ie[1]    = true_pstate1[1];
assign local_pstate_ie[1]      = true_pstate1[1];
// assign tlu_pstate_cle[1]        = true_pstate1[`PSTATE_CLE];
assign tlu_pstate_tle[1]       = true_pstate1[8];
// assign tlu_pstate_priv[1]       = true_pstate1[`PSTATE_PRIV];
assign local_pstate_priv[1]    = true_pstate1[2];
assign tlu_pstate_am[1]        = true_pstate1[3];
// assign tlu_pstate1_mmodel[1:0] = true_pstate1[`PSTATE_MM_HI:`PSTATE_MM_LO];
//
assign tlu_int_redmode[1] = true_hpstate1[2];
assign tlu_lsu_redmode[1] = true_hpstate1[2];
//
// hypervisor privilege indicator
assign tlu_hpstate_priv[1]   = true_hpstate1[1];
assign local_hpstate_priv[1] = true_hpstate1[1];
assign tcl_hpstate_priv[1]   = true_hpstate1[1];
//
// hypervisor lite mode selector
assign tlu_hpstate_enb[1]   = true_hpstate1[3];
assign local_hpstate_enb[1] = true_hpstate1[3];
assign tcl_hpstate_enb[1]   = true_hpstate1[3];

// hypervisor tlz indicator
assign tlu_hpstate_tlz[1] = true_hpstate1[0];

// hypervisor instruction breakpt enable
assign tlu_hpstate_ibe[1] = true_hpstate1[4];

assign tlu_ifu_pstate_pef[3:2] = 2'b00;
assign tlu_lsu_pstate_cle[3:2] = 2'b00;
assign tlu_lsu_pstate_priv[3:2] = 2'b00;
assign tlu_int_pstate_ie[3:2] = 2'b00;
assign local_pstate_ie[3:2] = 2'b00;
assign tlu_pstate_tle[3:2] = 2'b00;
assign local_pstate_priv[3:2] = 2'b00;
assign tlu_pstate_am[3:2] = 2'b00;
assign tlu_int_redmode[3:2] = 2'b00;
assign tlu_lsu_redmode[3:2] = 2'b00;
assign tlu_hpstate_priv[3:2] = 2'b00;
assign local_hpstate_priv[3:2] = 2'b00;
assign tcl_hpstate_priv[3:2] = 2'b00;
assign tlu_hpstate_enb[3:2] = 2'b00;
assign local_hpstate_enb[3:2] = 2'b00;
assign tcl_hpstate_enb[3:2] = 2'b00;
assign tlu_hpstate_tlz[3:2] = 2'b00;
assign tlu_hpstate_ibe[3:2] = 2'b00;































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 // `ifndef CONFIG_NUM_THREADS
   
// Mux to choose the pstate register to read base on thread
wire [12-1:0] pstate_rdata;
wire [12-1:0] hpstate_rdata;

 // Use two threads unless this is defined

mux2ds #(12) pstate_mx_sel (
       .in0  (true_pstate0[12-1:0]),
       .in1  (true_pstate1[12-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (pstate_rdata[12-1:0])
);
//
// added for hypervisor support
// mux to choose the pstate register to read base on thread

mux2ds #(5) hpstate_mx_sel (
       .in0  (true_hpstate0[5-1:0]),
       .in1  (true_hpstate1[5-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (true_hpstate[5-1:0])
);

























































































 // `ifndef CONFIG_NUM_THREADS 
// 
// assigned the stored hpstate bits to the ASR positions
//
assign hpstate_rdata[11]  = true_hpstate[3]; 
assign hpstate_rdata[10]  = true_hpstate[4]; 
assign hpstate_rdata[5]  = true_hpstate[2]; 
assign hpstate_rdata[2] = true_hpstate[1]; 
assign hpstate_rdata[0]  = true_hpstate[0]; 
//
// grounding the reserved bits
// modified due to the addition of hpstate.ibe 
// assign hpstate_rdata[`WSR_HPSTATE_ENB-1 :`WSR_HPSTATE_RED+1]  = 5'h00; 
assign hpstate_rdata[10-1 :5+1]  = 4'h0; 
assign hpstate_rdata[5-1 :2+1] = 2'b00; 
assign hpstate_rdata[2-1:0+1]  = 1'b0; 
//
// constructing data for htstate
//
wire [12-1:0] htstate_rdata;

// assign htstate_rdata[`WSR_HPSTATE_RED]  = tsa_rdata[`TLU_HTSTATE_HI]; 
// assign htstate_rdata[`WSR_HPSTATE_PRIV] = tsa_rdata[`TLU_HTSTATE_HI-1]; 
/* modified due to logic redistribution
assign htstate_rdata[`WSR_HPSTATE_IBE]  = tsa_rdata[`TLU_HTSTATE_HI]; 
assign htstate_rdata[`WSR_HPSTATE_RED]  = tsa_rdata[`TLU_HTSTATE_HI-1]; 
assign htstate_rdata[`WSR_HPSTATE_PRIV] = tsa_rdata[`TLU_HTSTATE_HI-2]; 
assign htstate_rdata[`WSR_HPSTATE_TLZ]  = tsa_rdata[`TLU_HTSTATE_LO]; 
*/
assign htstate_rdata[10]  = tsa_rdata[133]; 
assign htstate_rdata[5]  = tsa_rdata[133-1]; 
assign htstate_rdata[2] = tsa_rdata[133-2]; 
assign htstate_rdata[0]  = tsa_rdata[130]; 
//
// grounding the reserved bits
// modified due to addition of hpstate.ibe
// assign htstate_rdata[`RDSR_HPSTATE_WIDTH-1 :`WSR_HPSTATE_RED+1] = 6'h00; 
assign htstate_rdata[12-1] = 1'b0; 
assign htstate_rdata[10-1 :5+1]  = 4'h0; 
assign htstate_rdata[5-1 :2+1] = 2'b00; 
assign htstate_rdata[2-1:0+1]  = 1'b0; 

//=========================================================================================
//	RDPR - This section has been recoded due to timing
//=========================================================================================

 // Use two threads unless this is defined

mux2ds #(2) mux_global_rdata (
       .in0  (tlu_gl_lvl0[2-1:0]),
       .in1  (tlu_gl_lvl1[2-1:0]),
       .sel0 (tlu_thrd_rsel_e[0]),
       .sel1 (tlu_thrd_rsel_e[1]),
       .dout (global_rdata[2-1:0])
);
//
// htickcmp interrupt enable
//
mux2ds #(1) mux_hintp_rdata (
        .in0    (tlu_hintp[0]),
        .in1    (tlu_hintp[1]),
        .sel0   (tlu_thrd_rsel_e[0]),
        .sel1   (tlu_thrd_rsel_e[1]),
        .dout   (hintp_rdata)
);






















































































 // `ifndef CONFIG_NUM_THREADS 
  
// 
// tstate.gl - 2b
assign tstate_rdata[41:40] = 
       tsa_rdata[37:36];
//
// tstate.ccr - 8b
assign tstate_rdata[39:32] = 
       tsa_rdata[35:28];
//
// tstate.asi - 8b
assign tstate_rdata[31:24] = 
       tsa_rdata[27:20];
//
// tstate.pstate(valid range 2) - 2b
assign tstate_rdata[17:16] = 
       tsa_rdata[19:18];
// 
// added for to please lint 
assign tstate_dummy_zero[1:0] = 
       tsa_rdata[18-1:15+1] & 2'b0; 
//
// tstate.pstate(valid range 1) - 4b
assign tstate_rdata[12:9] = 
       tsa_rdata[15:12];
//
// tstate.cwp - 3b
assign tstate_rdata[2:0] = 
       tsa_rdata[11:9];
//
// reserved bits with ASR - assign to  1'b0
assign tstate_rdata[48-1:41+1] = 
       6'h00; 
assign tstate_rdata[24-1:17+1] = 
       6'h00; 
assign tstate_rdata[16-1:12+1] = 
       {1'b0, tstate_dummy_zero[1:0]}; 
assign tstate_rdata[9-1:2+1] = 
       6'h00; 
//
//============================================================================
// new rdpr mux coding due to timing changes 
//============================================================================
//
// added for bug 2332
assign rdpr_mx1_onehot_sel = 
           ~(|tlu_rdpr_mx1_sel[3:1]);
// mux1- 64b
mux4ds #(64) rdpr_mx1(
	.in0({tlu_tick_npt,true_tick[60:0], 2'b0}),
	.in1(tickcmp_rdata[64-1:0]),
	.in2(stickcmp_rdata[64-1:0]),
	.in3({tlu_htickcmp_intdis,htickcmp_rdata[64-2:0]}),
	.sel0(rdpr_mx1_onehot_sel),
	.sel1(tlu_rdpr_mx1_sel[1]),
	.sel2(tlu_rdpr_mx1_sel[2]),
	.sel3(tlu_rdpr_mx1_sel[3]),
	.dout(tlu_rdpr_mx1_out[64-1:0])
);
// 
//
// added for bug 2332
assign rdpr_mx2_onehot_sel = 
           ~(|tlu_rdpr_mx2_sel[3:1]); 
//
// mux2 - 4b 
mux4ds #(4) rdpr_mx2(
	.in0({2'b0,global_rdata[2-1:0]}),
	.in1({3'b0,hintp_rdata}),
	.in2({1'b0,tlu_trp_lvl[2:0]}),
	.in3(tlu_pil[3:0]),
	.sel0(rdpr_mx2_onehot_sel),
	.sel1(tlu_rdpr_mx2_sel[1]),
	.sel2(tlu_rdpr_mx2_sel[2]),
	.sel3(tlu_rdpr_mx2_sel[3]),
	.dout(tlu_rdpr_mx2_out[3:0])
);
//
// added for bug 2332
assign rdpr_mx3_onehot_sel = 
           ~(|tlu_rdpr_mx3_sel[2:1]);
//
// mux3 - 17b
mux3ds #(17) rdpr_mx3(
	.in0(sftint_rdata[17-1:0]),
	.in1({5'b0,pstate_rdata[12-1:0]}),
	.in2({5'b0,hpstate_rdata[12-1:0]}),
	.sel0(rdpr_mx3_onehot_sel),
	.sel1(tlu_rdpr_mx3_sel[1]),
	.sel2(tlu_rdpr_mx3_sel[2]),
	.dout(tlu_rdpr_mx3_out[17-1:0])
);
//
// added for bug 2332
assign rdpr_mx4_onehot_sel = 
           ~(|tlu_rdpr_mx4_sel[2:1]);
//
// mux4 - 48b 
mux3ds #(48) rdpr_mx4(
	.in0({tsa_rdata[129:84],2'b00}),
	.in1({tsa_rdata[83:38],2'b00}),
	// .in0({tsa_rdata[`TLU_PC_HI-1:`TLU_PC_LO],2'b00}),
	// .in1({tsa_rdata[`TLU_NPC_HI-1:`TLU_NPC_LO],2'b00}),
    .in2(tstate_rdata[48-1:0]),
	.sel0(rdpr_mx4_onehot_sel),
	.sel1(tlu_rdpr_mx4_sel[1]), 
	.sel2(tlu_rdpr_mx4_sel[2]), 
	.dout(tlu_rdpr_mx4_out[48-1:0])
);
//
// added for bug 2332
assign rdpr_mx5_onehot_sel = 
           ~(|tlu_rdpr_mx5_sel[3:1]);
//
// mux5 - 64b 
mux4ds #(64) rdpr_mx5(
	.in0({{16{tba_rdata[33-1]}},
           tba_rdata[33-1:0],15'h0000}),
	.in1({{16{htba_rdata[34-1]}},
           htba_rdata[34-1:0],14'h0000}),
	.in2(tlu_rdpr_mx1_out[64-1:0]),
	.in3(tlu_pib_rsr_data_e[64-1:0]),
	.sel0(rdpr_mx5_onehot_sel),
	.sel1(tlu_rdpr_mx5_sel[1]),
	.sel2(tlu_rdpr_mx5_sel[2]),
	.sel3(tlu_rdpr_mx5_sel[3]),
	.dout(tlu_rdpr_mx5_out[64-1:0])
);
//
// added for bug 2332
assign rdpr_mx6_onehot_sel = 
           ~(|tlu_rdpr_mx6_sel[2:0]);
//
// mux6 - 12b 
mux4ds #(17) rdpr_mx6(
	.in0({8'b0,tsa_rdata[8:0]}),  // ttype
	.in1({5'b0,htstate_rdata[12-1:0]}),
	.in2({13'b0,tlu_rdpr_mx2_out[3:0]}),
	.in3({tlu_rdpr_mx3_out[17-1:0]}),
	.sel0(rdpr_mx6_onehot_sel),
	.sel1(tlu_rdpr_mx6_sel[0]),
	.sel2(tlu_rdpr_mx6_sel[1]),
	.sel3(tlu_rdpr_mx6_sel[2]),
	.dout(tlu_rdpr_mx6_out[17-1:0])
);
//
// mux7- 64b
mux4ds #(64) rdpr_mx7(
	.in0({{16{tlu_rdpr_mx4_out[48-1]}}, 
           tlu_rdpr_mx4_out[48-1:0]}),
	.in1(tlu_rdpr_mx5_out[64-1:0]),
	.in2({47'b0,tlu_rdpr_mx6_out[17-1:0]}),
	.in3({56'b0,lsu_tlu_rsr_data_e[7:0]}),
	.sel0(tlu_rdpr_mx7_sel[0]),
	.sel1(tlu_rdpr_mx7_sel[1]),
	.sel2(tlu_rdpr_mx7_sel[2]),
	.sel3(tlu_rdpr_mx7_sel[3]),
	.dout(tlu_rdpr_mx7_out[64-1:0])
);
/*
mux4ds #(`TLU_ASR_DATA_WIDTH) rdpr_mx7(
	.in0({{16{tlu_rdpr_mx4_out[`RDSR_TSTATE_WIDTH-1]}}, 
           tlu_rdpr_mx4_out[`RDSR_TSTATE_WIDTH-1:0]}),
	.in1(tlu_rdpr_mx5_out[`TLU_ASR_DATA_WIDTH-1:0]),
	.in2({47'b0,tlu_rdpr_mx6_out[`SFTINT_WIDTH-1:0]}),
	.in3({56'b0,lsu_tlu_rsr_data_e[7:0]}),
	.sel0(tlu_rdpr_mx7_sel[0]),
	.sel1(tlu_rdpr_mx7_sel[1]),
	.sel2(tlu_rdpr_mx7_sel[2]),
	.sel3(tlu_rdpr_mx7_sel[3]),
	.dout(tlu_rdpr_mx7_out[`TLU_ASR_DATA_WIDTH-1:0])
);
*/
//
// drive rsr data to exu
assign tlu_exu_rsr_data_e[64-1:0] = 
           tlu_rdpr_mx7_out[64-1:0];
//
// added for timing
dff_s #(64) dff_tlu_exu_rsr_data_m (
    .din (tlu_exu_rsr_data_e[64-1:0]),
    .q   (tlu_exu_rsr_data_m[64-1:0]),
    .clk (clk),
    .se  (se),       
    .si  (),          
    .so  ()
);

endmodule
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_tlu_dec64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_tlu_dec64
//  Description:    
//    6 -> 64 decoder
*/

module sparc_tlu_dec64(/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [5:0] in;

   output [63:0] out;


   wire [5:0] 	 in;
   reg [63:0] 	 out;

/*   integer 	 i;
   
   always @ (in)
     begin
	for (i=0;i<64;i=i+1)
	  begin
	     if (i[5:0] == in[5:0])
	       out[i] = 1'b1;
	     else
	       out[i] = 1'b0;
	  end
     end
*/

always @ (in)
begin
    case (in)
       6'h00: out = 64'h0000000000000001;
       6'h01: out = 64'h0000000000000002;
       6'h02: out = 64'h0000000000000004;
       6'h03: out = 64'h0000000000000008;
       6'h04: out = 64'h0000000000000010;
       6'h05: out = 64'h0000000000000020;
       6'h06: out = 64'h0000000000000040;
       6'h07: out = 64'h0000000000000080;
       6'h08: out = 64'h0000000000000100;
       6'h09: out = 64'h0000000000000200;
       6'h0a: out = 64'h0000000000000400;
       6'h0b: out = 64'h0000000000000800;
       6'h0c: out = 64'h0000000000001000;
       6'h0d: out = 64'h0000000000002000;
       6'h0e: out = 64'h0000000000004000;
       6'h0f: out = 64'h0000000000008000;
       6'h10: out = 64'h0000000000010000;
       6'h11: out = 64'h0000000000020000;
       6'h12: out = 64'h0000000000040000;
       6'h13: out = 64'h0000000000080000;
       6'h14: out = 64'h0000000000100000;
       6'h15: out = 64'h0000000000200000;
       6'h16: out = 64'h0000000000400000;
       6'h17: out = 64'h0000000000800000;
       6'h18: out = 64'h0000000001000000;
       6'h19: out = 64'h0000000002000000;
       6'h1a: out = 64'h0000000004000000;
       6'h1b: out = 64'h0000000008000000;
       6'h1c: out = 64'h0000000010000000;
       6'h1d: out = 64'h0000000020000000;
       6'h1e: out = 64'h0000000040000000;
       6'h1f: out = 64'h0000000080000000;
       6'h20: out = 64'h0000000100000000;
       6'h21: out = 64'h0000000200000000;
       6'h22: out = 64'h0000000400000000;
       6'h23: out = 64'h0000000800000000;
       6'h24: out = 64'h0000001000000000;
       6'h25: out = 64'h0000002000000000;
       6'h26: out = 64'h0000004000000000;
       6'h27: out = 64'h0000008000000000;
       6'h28: out = 64'h0000010000000000;
       6'h29: out = 64'h0000020000000000;
       6'h2a: out = 64'h0000040000000000;
       6'h2b: out = 64'h0000080000000000;
       6'h2c: out = 64'h0000100000000000;
       6'h2d: out = 64'h0000200000000000;
       6'h2e: out = 64'h0000400000000000;
       6'h2f: out = 64'h0000800000000000;
       6'h30: out = 64'h0001000000000000;
       6'h31: out = 64'h0002000000000000;
       6'h32: out = 64'h0004000000000000;
       6'h33: out = 64'h0008000000000000;
       6'h34: out = 64'h0010000000000000;
       6'h35: out = 64'h0020000000000000;
       6'h36: out = 64'h0040000000000000;
       6'h37: out = 64'h0080000000000000;
       6'h38: out = 64'h0100000000000000;
       6'h39: out = 64'h0200000000000000;
       6'h3a: out = 64'h0400000000000000;
       6'h3b: out = 64'h0800000000000000;
       6'h3c: out = 64'h1000000000000000;
       6'h3d: out = 64'h2000000000000000;
       6'h3e: out = 64'h4000000000000000;
       6'h3f: out = 64'h8000000000000000;

    endcase
end

endmodule // sparc_tlu_dec64

	
// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
// 
// OpenSPARC T1 Processor File: sparc_tlu_penc64.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
// 
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
// 
// The above named program is distributed in the hope that it will be 
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// ========== Copyright Header End ============================================
////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_tlu_penc64
//  Description:    
//    64 -> 6 priority encoder
//    Bit 63 has the highest priority
//
*/

module sparc_tlu_penc64 (/*AUTOARG*/
   // Outputs
   out, 
   // Inputs
   in
   );

   input [63:0] in;

   output [5:0] out;


   reg [5:0] 	out;
//   integer 	i;
   
always @ (in)
begin
//
// code modified for verplex to avoid inferred latches
//	     if (in == 64'b0) // don't want a latch
	out = 6'b0;
//	else 
//	for (i=0;i<64;i=i+1)
//	    begin

	       if (in[0])
		   out[5:0] = 6'd0;
    

	       if (in[1])
		   out[5:0] = 6'd1;
    

	       if (in[2])
		   out[5:0] = 6'd2;
    

	       if (in[3])
		   out[5:0] = 6'd3;
    

	       if (in[4])
		   out[5:0] = 6'd4;
    

	       if (in[5])
		   out[5:0] = 6'd5;
    

	       if (in[6])
		   out[5:0] = 6'd6;
    

	       if (in[7])
		   out[5:0] = 6'd7;
    

	       if (in[8])
		   out[5:0] = 6'd8;
    

	       if (in[9])
		   out[5:0] = 6'd9;
    

	       if (in[10])
		   out[5:0] = 6'd10;
    

	       if (in[11])
		   out[5:0] = 6'd11;
    

	       if (in[12])
		   out[5:0] = 6'd12;
    

	       if (in[13])
		   out[5:0] = 6'd13;
    

	       if (in[14])
		   out[5:0] = 6'd14;
    

	       if (in[15])
		   out[5:0] = 6'd15;
    

	       if (in[16])
		   out[5:0] = 6'd16;
    

	       if (in[17])
		   out[5:0] = 6'd17;
    

	       if (in[18])
		   out[5:0] = 6'd18;
    

	       if (in[19])
		   out[5:0] = 6'd19;
    

	       if (in[20])
		   out[5:0] = 6'd20;
    

	       if (in[21])
		   out[5:0] = 6'd21;
    

	       if (in[22])
		   out[5:0] = 6'd22;
    

	       if (in[23])
		   out[5:0] = 6'd23;
    

	       if (in[24])
		   out[5:0] = 6'd24;
    

	       if (in[25])
		   out[5:0] = 6'd25;
    

	       if (in[26])
		   out[5:0] = 6'd26;
    

	       if (in[27])
		   out[5:0] = 6'd27;
    

	       if (in[28])
		   out[5:0] = 6'd28;
    

	       if (in[29])
		   out[5:0] = 6'd29;
    

	       if (in[30])
		   out[5:0] = 6'd30;
    

	       if (in[31])
		   out[5:0] = 6'd31;
    

	       if (in[32])
		   out[5:0] = 6'd32;
    

	       if (in[33])
		   out[5:0] = 6'd33;
    

	       if (in[34])
		   out[5:0] = 6'd34;
    

	       if (in[35])
		   out[5:0] = 6'd35;
    

	       if (in[36])
		   out[5:0] = 6'd36;
    

	       if (in[37])
		   out[5:0] = 6'd37;
    

	       if (in[38])
		   out[5:0] = 6'd38;
    

	       if (in[39])
		   out[5:0] = 6'd39;
    

	       if (in[40])
		   out[5:0] = 6'd40;
    

	       if (in[41])
		   out[5:0] = 6'd41;
    

	       if (in[42])
		   out[5:0] = 6'd42;
    

	       if (in[43])
		   out[5:0] = 6'd43;
    

	       if (in[44])
		   out[5:0] = 6'd44;
    

	       if (in[45])
		   out[5:0] = 6'd45;
    

	       if (in[46])
		   out[5:0] = 6'd46;
    

	       if (in[47])
		   out[5:0] = 6'd47;
    

	       if (in[48])
		   out[5:0] = 6'd48;
    

	       if (in[49])
		   out[5:0] = 6'd49;
    

	       if (in[50])
		   out[5:0] = 6'd50;
    

	       if (in[51])
		   out[5:0] = 6'd51;
    

	       if (in[52])
		   out[5:0] = 6'd52;
    

	       if (in[53])
		   out[5:0] = 6'd53;
    

	       if (in[54])
		   out[5:0] = 6'd54;
    

	       if (in[55])
		   out[5:0] = 6'd55;
    

	       if (in[56])
		   out[5:0] = 6'd56;
    

	       if (in[57])
		   out[5:0] = 6'd57;
    

	       if (in[58])
		   out[5:0] = 6'd58;
    

	       if (in[59])
		   out[5:0] = 6'd59;
    

	       if (in[60])
		   out[5:0] = 6'd60;
    

	       if (in[61])
		   out[5:0] = 6'd61;
    

	       if (in[62])
		   out[5:0] = 6'd62;
    

	       if (in[63])
		   out[5:0] = 6'd63;
    

//	    end
end
   
endmodule // sparc_tlu_penc64

